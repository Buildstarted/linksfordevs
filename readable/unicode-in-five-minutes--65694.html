<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Unicode In Five Minutes &#x231A; - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Unicode In Five Minutes &#x231A; - linksfor.dev(s)"/>
    <meta property="article:author" content="By Richard Harris"/>
    <meta property="og:description" content="One encoding covering most of the world&#x2019;s writing systems. Standard&#xA;encoding of the web, most operating systems, Java and .NET."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://richardjharris.github.io/unicode-in-five-minutes.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Unicode In Five Minutes &#x231A;</title>
<div class="readable">
        <h1>Unicode In Five Minutes &#x231A;</h1>
            <div>by By Richard Harris</div>
            <div>Reading time: 12-16 minutes</div>
        <div>Posted here: 15 Aug 2020</div>
        <p><a href="https://richardjharris.github.io/unicode-in-five-minutes.html">https://richardjharris.github.io/unicode-in-five-minutes.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
      <!-- /.post-info -->      <h2>Why</h2>
<p>One encoding covering <em>most</em> of the world‚Äôs writing systems. Standard
encoding of the web, most operating systems, Java and .NET.</p>
<p>Before Unicode, each script (or script family) had its own encoding, or
worse, lots of different incompatible encodings. Unicode is a superset
of almost all of them, so can be used for interchange.</p>
<p>It‚Äôs been around for <a href="http://www.unicode.org/history/unicode88.pdf">over 30 years</a>.</p>
<p><em>Note: code examples are Perl-centric so far, because it has really good Unicode
support and I know it; if you have examples for other languages, please do post
a comment!</em></p>
<h2>What</h2>
<p><img alt="Unicode character examples" src="https://richardjharris.github.io/static/images/unichar-examples.png"></p>
<p>Unicode defines a <em>code point</em> (number) for every character, such as <span><span data-code="0061" data-name="LATIN SMALL LETTER A" title="LATIN SMALL LETTER A (U+0061)">a</span></span>, <span><span data-code="00E3" data-name="LATIN SMALL LETTER A WITH TILDE" title="LATIN SMALL LETTER A WITH TILDE (U+00E3)">√£</span></span>,
<span><span data-code="06D0" data-name="ARABIC LETTER E" title="ARABIC LETTER E (U+06D0)">€ê</span></span>, <span><span data-code="4E0D" data-name="CJK UNIFIED IDEOGRAPH-4E0D" title="CJK UNIFIED IDEOGRAPH-4E0D (U+4E0D)">‰∏ç</span></span> and <span><span data-code="2603" data-name="SNOWMAN" title="SNOWMAN (U+2603)">‚òÉ</span></span>. As of <a href="http://www.unicode.org/versions/Unicode6.2.0/">Unicode 6.2</a> there are <strong>109,976</strong> code points!
<em>(You can mouseover any highlighted character for more information.)</em></p>
<p>It also includes <em>combining characters</em> such as <span><span data-code="0300" data-name="COMBINING GRAVE ACCENT" title="COMBINING GRAVE ACCENT (U+0300)">‚óåÃÄ</span></span> which can be added to
other characters; this way, Unicode does not need a code point for every possible
combination of letter and accent. On the other hand, Unicode <em>generally</em> doesn‚Äôt care
about fonts or stylistic differences: it gives <img alt="a (double-story)" src="https://richardjharris.github.io/static/images/a1.png">
and <img alt="a (single-story)" src="https://richardjharris.github.io/static/images/a2.png"> the same codepoint.</p>
<p>It‚Äôs <em>more than just a character set</em>: it also covers standard encodings such
as UTF-8; <nobr>lower/upper/title</nobr> case mapping; collation (sorting); line breaks;
rendering; right-to-left script handling, and more.</p>
<h2>Normalization</h2>
<p>For compatibility with other encodings Unicode sometimes includes <em>precomposed</em>
versions of characters, for example, these three:</p>
<ul>
<li><span><span data-code="00C5" data-name="LATIN CAPITAL LETTER A WITH RING ABOVE" title="LATIN CAPITAL LETTER A WITH RING ABOVE (U+00C5)">√Ö</span><span> LATIN CAPITAL LETTER A WITH RING ABOVE (U+00C5)</span></span></li>
<li><span><span data-code="212B" data-name="ANGSTROM SIGN" title="ANGSTROM SIGN (U+212B)">‚Ñ´</span><span> ANGSTROM SIGN (U+212B)</span></span></li>
<li><span><span data-code="0041" data-name="LATIN CAPITAL LETTER A" title="LATIN CAPITAL LETTER A (U+0041)">A</span><span> LATIN CAPITAL LETTER A (U+0041)</span></span> + <span><span data-code="030A" data-name="COMBINING RING ABOVE" title="COMBINING RING ABOVE (U+030A)">‚óåÃä</span><span> COMBINING RING ABOVE (U+030A)</span></span></li>
</ul>
<p>For these to be treated as the same string in equality tests etc. you should
run all input through <a href="http://unicode.org/reports/tr15/">Unicode normalisation</a>. The most common form is
<abbr title="Normalisation Form C (canonical decomposition + canonical composition)">NFC</abbr>, which uses pre<strong>C</strong>omposed characters where possible, and defines a strict ordering
of diacritics if more than one exists. <abbr title="Normalization Form D (canonical decomposition)">NFD</abbr> <strong>D</strong>ecomposes characters where possible.<sup id="fnref:gory"><a href="#fn:gory" rel="footnote">1</a></sup></p>
<p>It doesn‚Äôt matter what form you use as long as you are consistent; NFD is
faster in general (fewer codepoints) and <a href="http://stackoverflow.com/a/6163129/74496">tchrist</a> suggests running input
through NFD and output through NFC.</p>
<p><strong>Compatibility decomposition</strong> also maps characters such as <span><span data-code="FB03" data-name="LATIN SMALL LIGATURE FFI" title="LATIN SMALL LIGATURE FFI (U+FB03)">Ô¨É</span></span>, <span><span data-code="2168" data-name="ROMAN NUMERAL NINE" title="ROMAN NUMERAL NINE (U+2168)">‚Ö®</span></span>
and even <span><span data-code="2075" data-name="SUPERSCRIPT FIVE" title="SUPERSCRIPT FIVE (U+2075)">‚Åµ</span></span> to ‚Äòffi‚Äô, ‚ÄòIX‚Äô and ‚Äò5‚Äô respectively. This <abbr title="Normalization Form KC (compatibility decomposition + canonical composition)">NFKC</abbr> normalisation
helps when searching for text.</p>
<div><pre><span>#!/usr/bin/perl</span>
<span>use</span> <span>Unicode::</span><span>Normalize</span><span>;</span>
<span>my</span> <span>$norm</span> <span>=</span> <span>NFD</span><span>(</span><span>$str</span><span>);</span>
</pre></div>


<hr>
<div><pre><span>#!/usr/bin/python</span>
<span>import</span> <span>unicodedata</span>
<span>norm</span> <span>=</span> <span>unicodedata</span><span>.</span><span>normalize</span><span>(</span><span>'NFC'</span><span>,</span> <span>string</span><span>)</span>
</pre></div>


<hr>
<div><pre><span>#!/usr/bin/ruby</span>
<span># gem install unicode_utils</span>
<span>require</span> <span>"unicode_utils/nfc"</span>
<span>norm</span> <span>=</span> <span>UnicodeUtils</span><span>.</span><span>nfc</span><span>(</span><span>string</span><span>)</span>
</pre></div>


<h2>Casefolding</h2>
<p>Casing is not so simple in the Unicode world:</p>
<ul>
<li>
<p>Some strings actually change length when they change case: <span><span data-code="00DF" data-name="LATIN SMALL LETTER SHARP S" title="LATIN SMALL LETTER SHARP S (U+00DF)">√ü</span></span> uppercases
  to ‚ÄòSS‚Äô.</p>
</li>
<li>
<p><span><span data-code="017F" data-name="LATIN SMALL LETTER LONG S" title="LATIN SMALL LETTER LONG S (U+017F)">≈ø</span><span> LATIN SMALL LETTER LONG S</span></span> should be seen as equal to ‚Äòs‚Äô and ‚ÄòS‚Äô in case-insensitive comparisons.</p>
</li>
<li>
<p><span><span data-code="03A3" data-name="GREEK CAPITAL LETTER SIGMA" title="GREEK CAPITAL LETTER SIGMA (U+03A3)">Œ£</span><span> GREEK CAPITAL LETTER SIGMA</span></span> has <em>two</em> lowercase forms: <span><span data-code="03C3" data-name="GREEK SMALL LETTER SIGMA" title="GREEK SMALL LETTER SIGMA (U+03C3)">œÉ</span></span> at the beginning or middle of the
  word, and <span><span data-code="03C2" data-name="GREEK SMALL LETTER FINAL SIGMA" title="GREEK SMALL LETTER FINAL SIGMA (U+03C2)">œÇ</span></span> at the end of a word.</p>
</li>
<li>
<p>Casing is <em>mostly</em> consistent across locales, but Turkish is an exception: it
  has both a <a href="https://en.wikipedia.org/wiki/Dotted_and_dotless_I">Dotted and dotless I</a>, in both lower and upper cases.</p>
</li>
</ul>
<p>To ensure your code handles these cases, and any new ones, Unicode provides a
<em>one-way</em> ‚Äòcasefold‚Äô operation that allows case-insensitive comparison:</p>
<div><pre><span>#!/usr/bin/perl</span>
<span>use</span> <span>Unicode::</span><span>CaseFold</span><span>;</span>   <span># or: use v5.16;</span>
<span>sort</span> <span>{</span> <span>fc</span><span>(</span><span>$a</span><span>)</span> <span>cmp</span> <span>fc</span><span>(</span><span>$b</span><span>)</span> <span>}</span> <span>@stuff</span><span>;</span>
</pre></div>


<p>Casefolding does <em>not</em> include normalization, so do that too.</p>
<h2>Sorting</h2>
<p>Sorting (or <em>collation</em>) is <strong>locale specific</strong> and just as riddled with
pecularities as casing:</p>
<ul>
<li>
<p>German and Swedish both have √§ and √∂ but sort them differently - German
    treats them as variants of the same letters without umlauts (i.e. ‚Äòa<strong>√§</strong>bcdefghijklmno<strong>√∂</strong>pqrstuvwxyz‚Äô)
    whereas Swedish considers them new letters, and puts them at the end (‚Äòabcdefghijklmnopqrstuvwxyz<strong>√§√∂</strong>‚Äò)</p>
<p>It‚Äôs important that things are sorted in the order the user expects.</p>
</li>
<li>
<p>Sorting varies by application too; phonebooks are often sorted differently to book
    indices, for example.</p>
</li>
<li>
<p>For Chinese characters and other ideographs, there are many possible orders, e.g.
    pinyin (phonetic), by stroke count, etc.</p>
</li>
<li>
<p>Collations can be <em>tailored</em> based on user preferences, e.g. lower or upper-case first?</p>
</li>
</ul>
<p>It‚Äôs not enough to just sort by binary comparison. And codepoints aren‚Äôt generally in any
sensible order either. Fortunately Unicode specifies a <a href="http://www.unicode.org/reports/tr10/">Collation Algorithm</a>
that is immensely customisable, covers all the edge-cases, and does clever things to make
it reasonably fast. Here‚Äôs an example:<sup id="fnref:locale"><a href="#fn:locale" rel="footnote">2</a></sup></p>
<div><pre><span>#!/usr/bin/perl</span>
<span>use</span> <span>Unicode::Collate::</span><span>Locale</span><span>;</span>
<span>my</span> <span>$collator</span> <span>=</span> <span>Unicode::Collate::</span><span>Locale</span><span>-&gt;</span><span>new</span><span>(</span><span>locale</span> <span>=&gt;</span> <span>'DE'</span><span>);</span>
<span>my</span> <span>@sorted</span> <span>=</span> <span>$collator</span><span>-&gt;</span><span>sort</span><span>(</span><span>@array</span><span>);</span>
<span>$collator</span><span>-&gt;</span><span>cmp</span><span>(</span><span>$word</span><span>,</span> <span>$another_word</span><span>);</span>  <span># -&gt; -1, 0 or 1</span>
</pre></div>


<p>The <abbr title="Unicode Collation Algorithm">UCA</abbr> can do other clever things, such as sort ‚Äò10‚Äô after ‚Äò2‚Äô numerically, or sort
the character ‚Äò?‚Äô as if it was the string ‚Äòquestion mark‚Äô.</p>
<h2>Encodings</h2>
<p>The big ones are <code>UTF-8</code>, <code>UTF-16</code> and <code>UTF-32</code>. Each one guarantees a reversible
mapping of almost every codepoint<sup id="fnref:every"><a href="#fn:every" rel="footnote">3</a></sup> to a byte sequence.</p>
<ul>
<li>
<p><strong>UTF-32</strong> is dead simple: each codepoint gets four bytes. Takes up tons of space,
  not recommended for interchange.</p>
</li>
<li>
<p><strong>UTF-8</strong> is very common the web. It‚Äôs byte-oriented (no endianness issues),
  handles corruption well, is ASCII-compatible and takes up minimal space for text
  that is mostly ASCII (e.g. HTML).</p>
<ul>
<li>
<p>Code points between U+0800 and U+FFFF, which includes commonly used <abbr title="Chinese, Japanese, Korean and Vietnamese">CJKV</abbr>
  characters, will take up 3 bytes instead of 2. So UTF-16 may be more space
  efficient.</p>
</li>
<li>
<p>ASCII-compatibility is helpful to allow UTF-8 to stealth its way through
  scripts and processes that are not Unicode-aware. But if such a system tries to
  do anything with the data (casing, sub-strings, regex), that data may be
  corrupted.</p>
</li>
</ul>
</li>
<li>
<p><strong>UTF-16</strong> is used by Java, .NET and Windows. It uses 2 bytes (16-bit) to
  represent the most common 63K codepoints, and 4 bytes for the less common 1M
  codepoints (using two ‚Äòsurrogate‚Äô codepoints).</p>
<ul>
<li>
<p>Contrary to popular belief, UTF-16 is not a fixed-width encoding. But as
  long as it contains no surrogates, it can be treated as one, which can speed
  up string operations.</p>
</li>
<li>
<p>UTF-16 streams typically begin with <span><span data-code="FEFF" data-name="ZERO WIDTH NO-BREAK SPACE" title="ZERO WIDTH NO-BREAK SPACE (U+FEFF)">U+FEFF</span></span><sup id="fnref:bomnote"><a href="#fn:bomnote" rel="footnote">4</a></sup> to detect the endianness
  (byte order) of the stream. Otherwise, you can explicitly encode or decode
  via ‚ÄòUTF-16BE‚Äô or ‚ÄòUTF-16LE‚Äô to specify the endianness.</p>
</li>
</ul>
</li>
</ul>
<h2>Unicode and internationalised domain names</h2>
<p>International characters create a <a href="http://en.wikipedia.org/wiki/IDN_homograph_attack">big problem</a>
for domain names. Just as <span><span data-code="0049" data-name="LATIN CAPITAL LETTER I" title="LATIN CAPITAL LETTER I (U+0049)">I</span></span> and <span><span data-code="006C" data-name="LATIN SMALL LETTER L" title="LATIN SMALL LETTER L (U+006C)">l</span></span> look similar, Unicode multiplies that problem
by 1,000, in addition to adding numerous invisible control characters, spacing characters
and right-to-left text.</p>
<p>Browsers and registrars have implemented several measures against this:</p>
<ul>
<li>Many TLDs restrict which characters can be used in domain names.</li>
<li>Browsers may display the domain in Punycode (see below) if the domain includes characters
  from multiple scripts and/or characters not belonging to one of the user‚Äôs preferred languages.</li>
<li>Internationalised country codes such as .—Ä—Ñ (Russia) only accept Cyrillic names.</li>
</ul>
<h3>nameprep/stringprep</h3>
<p><a href="http://tools.ietf.org/html/rfc3491">RFC 3491</a> defines <em>nameprep</em>, a mechanism
to case-fold, normalize and sanitize strings before they can be used in domain names. This
removes many invisible characters and throws an error if prohibited code points are in use.</p>
<p>It is implemented in terms of a wider framework called <em>stringprep</em>. In Perl, one can use
<a href="https://metacpan.org/module/Net::IDN::Encode">Net::IDN::Encode</a> which will also perform Punycode conversion.</p>
<h3>Punycode</h3>
<p>For legacy reasons DNS does not allow extended characters outside of ASCII, so Punycode
is an ASCII-compatible encoding scheme. For example, <code>caf√©.com</code> becomes <code>xn--caf-dma.com</code>.
All Punycode-encoded domain components are instantly recognisable by their <code>xn--</code> prefix.</p>
<p>This goes for TLDs too: .‰∏≠ÂõΩ is really known as <em>xn‚Äîfiqs8s</em>.</p>
<h2>The problem of ‚Äòuser characters‚Äô</h2>
<p>In Perl at least, everything (<code>substr</code>, <code>length</code>, <code>index</code>, <code>reverse</code>‚Ä¶) works on the level
of codepoints. This is often not what you want, because what a user considers to be a
character such as —û is actually two codepoints (<span><span data-code="0079" data-name="LATIN SMALL LETTER Y" title="LATIN SMALL LETTER Y (U+0079)">y</span></span> + <span><span data-code="0306" data-name="COMBINING BREVE" title="COMBINING BREVE (U+0306)">‚óåÃÜ</span></span>). Here‚Äôs a <a href="http://www.nntp.perl.org/group/perl.perl5.porters/2011/10/msg178687.html">really good
usenet post</a> on the subject.</p>
<p>Even seemingly innocuous things like <code>printf "%-10s", $str</code> breaks completely for combining characters,
double-width characters (e.g. Chinese/Japanese) or zero-width characters.</p>
<p>Fortunately Perl provides the <code>\X</code> regular expression metachar which matches exactly one
‚Äòextended grapheme cluster‚Äô, i.e. what a user would consider a character to be. A more robust
solution is to install <a href="https://metacpan.org/module/Unicode::GCString">Unicode::GCString</a>:</p>
<div><pre><span>#!/usr/bin/perl</span>
<span>use</span> <span>Unicode::</span><span>GCString</span><span>;</span>
<span>use</span> <span>Unicode::</span><span>Normalize</span><span>;</span>
<span>use</span> <span>utf8</span><span>;</span>
<span>use</span> <span>open</span> <span>qw(:std :encoding(UTF-8))</span><span>;</span>

<span>my</span> <span>$s</span> <span>=</span> <span>NFD</span><span>(</span><span>"cr√®me br√ªl√©e"</span><span>);</span>  <span># ensure combining marks get their own codepoint</span>
<span>my</span> <span>$g</span> <span>=</span> <span>Unicode::</span><span>GCString</span><span>-&gt;</span><span>new</span><span>(</span><span>$s</span><span>);</span>

<span>print</span> <span>$g</span><span>-&gt;</span><span>length</span><span>,</span> <span>"\n"</span><span>;</span>       <span># 12, not 15</span>
<span>print</span> <span>reverse</span><span>(</span><span>@$g</span><span>),</span> <span>"\n"</span><span>;</span>     <span># 'eeÃÅluÃÇrb emeÃÄrc', not 'eÃÅelÃÇurb emÃÄerc'</span>
<span>print</span> <span>$g</span><span>-&gt;</span><span>substr</span><span>(</span><span>0</span><span>,</span><span>5</span><span>),</span> <span>"\n"</span><span>;</span>  <span># 'creÃÄme', not 'creÃÄm'</span>
<span>print</span> <span>$g</span><span>-&gt;</span><span>substr</span><span>(</span><span>0</span><span>,</span><span>3</span><span>),</span> <span>"\n"</span><span>;</span>  <span># 'creÃÄ', not 'cre'</span>

<span>print</span> <span>"1234512345123451234512345|\n"</span><span>;</span>
<span>printf</span> <span>"%s%*s|\n"</span><span>,</span> <span>$g</span><span>,</span> <span>(</span><span>25</span> <span>-</span> <span>$g</span><span>-&gt;</span><span>columns</span><span>),</span> <span>''</span><span>;</span>  <span># 25 columns long (·µî·¥•·µî)</span>

<span>printf</span> <span>"%-25s|\n"</span><span>,</span> <span>$s</span><span>;</span>                          <span># 22 columns long (‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª</span>
</pre></div>


<h3>Line breaks</h3>
<p>Line breaking (or word wrapping) is another thing that becomes <a href="http://www.unicode.org/reports/tr14/">insanely complicated</a>
once Unicode is involved. You have to account for various non-breaking and breaking control
and spacing characters, punctuation in every language (e.g. <span><span data-code="00AB" data-name="LEFT-POINTING DOUBLE ANGLE QUOTATION MARK" title="LEFT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00AB)">¬´</span></span> and <span><span data-code="00BB" data-name="RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK" title="RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (U+00BB)">¬ª</span></span> quotes, or the
full stop or comma being used in numerics such as <code>2,140</code>) and the width of each character.</p>
<p>In Perl, this has all been handled for you - just use <a href="https://metacpan.org/module/Unicode::LineBreak">Unicode::LineBreak</a>.</p>
<h2>Regular expressions</h2>
<p>Some useful Perl regular expression syntax:</p>
<dl>
<dt><code>\R</code></dt>
<dd>Match any Unicode linebreak sequence (including <code>\n</code>, <code>\r\n</code> and six others)</dd>
<dt><code>\p</code>, <code>\P</code></dt>
<dd>Match any codepoint possessing (or not possessing) a Unicode property.</dd>
<dd>Common ones are <code>\pL</code> (Letter), <code>\pU</code> (Uppercase), <code>\pS</code> (Symbol), or even <code>\p{script=Latin}</code>,
<code>\p{East_Asian_Width=Wide}</code>, <code>\p{Numeric_Value=4}</code>.</dd>
<dd>See <a href="http://perldoc.perl.org/perluniprops.html">perluniprops</a> for a big list.</dd>
<dd>Built-in character classes such as <code>\w</code>, <code>\b</code>, <code>\s</code> and <code>\d</code> are Unicode-aware since Perl
5.6 (though you need to make sure your string or pattern has the <code>UTF8</code> flag on!) Disable this
with the <code>/a</code> flag (see <a href="http://perldoc.perl.org/perlre.html#Character-set-modifiers">perlre</a>).</dd>
<dt><code>\X</code></dt>
<dd>Match an extended grapheme cluster, which is basically a user-visible ‚Äòcharacter‚Äô.</dd>
<dd>Use it instead of <b><code>.</code></b> unless you want codepoints.</dd>
<dd>
<p>E.g. to match a vowel with optional diacritics or marks (<a href="http://www.perl.com/pub/2012/05/perlunicook-match-unicode-grapheme-cluster-in-regex.html">source</a>):</p>
<div><pre><span>my</span> <span>$nfd</span> <span>=</span> <span>NFD</span><span>(</span><span>$string</span><span>);</span>
<span>$nfd</span> <span>=~</span><span> / (?=[aeiou]) \X /xi</span><span>;</span>
</pre></div>


</dd>
</dl>
<hr>
<h2>Trivia</h2>
<h3>Filesystems</h3>
<p>When you use Unicode strings as file or directory names, all bets are off. What encoding do you
use? What <em>API</em> do you use? (Windows has two, one speaks Unicode, the other tries to use locale-dependent
encodings). Some filesystems perform normalization such as NFD on file names, such as Mac OS X; this
may be an issue if your platform doesn‚Äôt understand decomposed Unicode.</p>
<p>In summary, consult docs and test your assumptions.</p>
<h3>Han Unification</h3>
<p>Han characters are a common feature of Chinese, Japanese (kanji) and historical
Korean and Vietnamese.
Many have a distinct visual appearance depending on the script, but Unicode unifies
them as a single codepoint for simplicity and performance reasons (<a href="http://en.wikipedia.org/wiki/Han_unification#Examples_of_language_dependent_characters">examples</a>).</p>
<p>This caused controversy because the visual form of a character can be <em>meaningful</em>;
users may not be shown their national variant but rather some other country‚Äôs version.
In some cases they can look very different (e.g. <span><span data-code="76F4" data-name="CJK UNIFIED IDEOGRAPH-76F4" title="CJK UNIFIED IDEOGRAPH-76F4 (U+76F4)">Áõ¥</span></span>). Just as Western names vary
(e.g. ‚ÄòJohn‚Äô or ‚ÄòJon‚Äô) Japanese names may use specific glyph variants that Unicode
does not provide, so people cannot actually write their own name the way they‚Äôd prefer!</p>
<p>In practice, users select a typeface that renders glyphs in the style they want, be
that Japanese or Chinese. Variation Selectors (see below) are another solution to the
problem.</p>
<p>For political and legacy reasons (compatibility with older character sets), Unicode
does not attempt to unify simplified and traditional Chinese.</p>
<h3>Emoji</h3>
<p>Version 6.0 of Unicode adds 722 ‚Äòemoji‚Äô characters, which are emoticons used
mostly on Japanese phones, but recently in Mac OS X (Lion), Gmail, iPhone and Windows
Phone 7. Some fonts may choose to render them as full-colour emoticons; some may not
support them at all.</p>
<p>Emoji is the reason why Unicode includes <span><span data-code="1F3E9" data-name="LOVE HOTEL" title="LOVE HOTEL (U+1F3E9)">üè©</span><span> LOVE HOTEL</span></span> and <span><span data-code="1F4A9" data-name="PILE OF POO" title="PILE OF POO (U+1F4A9)">üí©</span><span> PILE OF POO</span></span>. (If you can‚Äôt see
them, install <a href="http://users.teilar.gr/~g1951d/">Symbola</a>, or click the fileformat.info link for a picture).</p>
<h4>Regional Indicator symbols</h4>
<p><img alt="Regional indicator example (FR)" src="https://richardjharris.github.io/static/images/regional-indicators.png"></p>
<p>Unicode 6.0‚Äôs emoji introduced symbols for many country flags,
but not all of them. As an alternative, the range <span><span data-code="1F1E6" data-name="REGIONAL INDICATOR SYMBOL LETTER A" title="REGIONAL INDICATOR SYMBOL LETTER A (U+1F1E6)">U+1F1E6</span></span>..<span><span data-code="1F1FF" data-name="REGIONAL INDICATOR SYMBOL LETTER Z" title="REGIONAL INDICATOR SYMBOL LETTER Z (U+1F1FF)">U+1F1FF</span></span>
defines symbols from A to Z. If two symbols from this range form an ISO-3166-1
country code (e.g. ‚ÄòFR‚Äô for France), the renderer may choose to display it
as a flag instead!</p>
<h3>Variation Selectors</h3>
<p>Variation Selectors are codepoints that change the way the character before
them is rendered. There are 256 and they occupy the ranges <span><span data-code="FE00" data-name="VARIATION SELECTOR-1" title="VARIATION SELECTOR-1 (U+FE00)">U+FE00</span></span>..<span><span data-code="FE0F" data-name="VARIATION SELECTOR-16" title="VARIATION SELECTOR-16 (U+FE0F)">U+FE0F</span></span>
and <span><span data-code="E0100" data-name="VARIATION SELECTOR-17" title="VARIATION SELECTOR-17 (U+E0100)">U+E0100</span></span>..<span><span data-code="E01EF" data-name="VARIATION SELECTOR-256" title="VARIATION SELECTOR-256 (U+E01EF)">U+E01EF</span></span> plus <span><span data-code="180B" data-name="MONGOLIAN FREE VARIATION SELECTOR ONE" title="MONGOLIAN FREE VARIATION SELECTOR ONE (U+180B)">U+180B</span></span>, <span><span data-code="180C" data-name="MONGOLIAN FREE VARIATION SELECTOR TWO" title="MONGOLIAN FREE VARIATION SELECTOR TWO (U+180C)">U+180C</span></span> and <span><span data-code="180D" data-name="MONGOLIAN FREE VARIATION SELECTOR THREE" title="MONGOLIAN FREE VARIATION SELECTOR THREE (U+180D)">U+180D</span></span>.</p>
<p>They are essential for the Mongolian script, which has different glyph forms
depending on its position in the word, the gender of the word, what letters
are nearby, whether or not the word is foreign, and modern vs. traditional
orthography (<a href="http://babelstone.blogspot.co.uk/2007/06/secret-life-of-variation-selectors.html">details</a>).</p>
<p>It is anticipated that these will be used to offer variations of glyphs
unified by Han Unification.</p>
<p>They are also used for somewhat more esoteric things, such as <a href="http://www.unicode.org/Public/6.0.0/ucd/StandardizedVariants.html">serif versions
of mathematical operators</a>.</p>

    </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>