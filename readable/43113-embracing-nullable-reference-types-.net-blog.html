<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Embracing nullable reference types | .NET Blog -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Embracing nullable reference types | .NET Blog</h1>
    <div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/02/DSC07122-3-150x150.jpg" width="58" alt="Mads Torgersen" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 alignnone photo"><p>Mads</p></div></div></div><p>Probably the most impactful feature of C# 8.0 is Nullable Reference Types (NRTs). It lets you make the flow of nulls explicit in your code, and warns you when you don&#x2019;t act according to intent.</p><p>The NRT feature holds you to a higher standard on how you deal with nulls, and as such it issues new warnings on existing code. So that those warnings (however useful) don&#x2019;t break you, the feature must be explicitly <em>enabled</em> in your code before it starts complaining. Once you do that on existing code, you have work to do to make that code null-safe and satisfy the compiler that you did.</p><p>How should you think about <em>when</em> to do this work? That&#x2019;s the main subject of this post, and we propose below that there&#x2019;s a <em>&#x201C;nullable rollout phase&#x201D;</em> until .NET 5 ships (November 2020), wherein popular libraries should strive to embrace NRTs.</p><p>But first a quick primer.</p><h2>Remind me &#x2013; what is this feature again?</h2><p>Up until now, in C# we allow references to be null, but we also allow them to be dereferenced without checks. This leads to what is by far the most common exception &#x2013; the <code>NullReferenceException</code> &#x2013; when nulls are accidentally dereferenced. An undesired null coming from one place in the code may lead to an exception being thrown later, from somewhere else that dereferences it. This makes null bugs hard to discover and annoying to fix. Can you spot the bug?:</p><pre><code class="language-c#">static void M(string s) 
{ 
    Console.WriteLine(s.Length);
}
static void Main(string[] args)
{
    string s = (args.Length &gt; 0) ? args[0] : null;
    M(s);
}
</code></pre><p>In C# 8.0 we want to help get rid of this problem by being stricter about nulls. This means we&#x2019;re going to start complaining when values of ordinary reference types (<code>string</code>, <code>object</code>, <code>IDisposable</code> etc) are null. However, new warnings on existing code aren&#x2019;t something we can <em>just do</em>, no matter how good it is for you! So NRT is an <em>optional</em> feature &#x2013; you have to turn it on to get new warnings. You can do that either at the project level, or directly in the source code with a new directive:</p><pre><code class="language-c#">#nullable enable
</code></pre><p>If you put this on the example above (e.g. at the top of the file) you&#x2019;ll get a warning on this line:</p><pre><code class="language-c#">    string s = (args.Length &gt; 0) ? args[0] : null; // WARNING!
</code></pre><p>saying you shouldn&#x2019;t assign the right-hand-side value to the <code>string</code> variable <code>s</code> because it might be null! Ordinary reference types have become non-nullable! You can fix the warning by giving a non-null value:</p><pre><code class="language-c#">    string s = (args.Length &gt; 0) ? args[0] : &quot;&quot;;
</code></pre><p>If you <em>want</em> <code>s</code> to be able to be null, however, that&#x2019;s fine too, but you have to <em>say</em> so, by using a <em>nullable reference type</em> &#x2013; i.e. tagging a <code>?</code> on the end of <code>string</code>:</p><pre><code class="language-c#">    string? s = (args.Length &gt; 0) ? args[0] : null;
</code></pre><p>Now the warning on that line goes away, but of course it shows up on the <em>next</em> line where you&#x2019;re now passing something that you <em>said</em> may be null (a <code>string?</code>) to something that doesn&#x2019;t <em>want</em> a null (a <code>string</code>):</p><pre><code class="language-c#">    M(s); // WARNING!
</code></pre><p>Now again you can choose whether to change the signature of <code>M</code> (if you own it) to accept nulls or whether to make sure you don&#x2019;t pass it a null to begin with.</p><p>C# is pretty smart about this. Let&#x2019;s only call <code>M</code> if <code>s</code> is not null:</p><pre><code class="language-c#">    if (s != null) M(s);
</code></pre><p>Now the warning disappears. This is because C# tracks the null state of variables across execution flow. In this case, even though <code>s</code> is declared to be a <code>string?</code>, C# knows that it won&#x2019;t be null <em>inside the true-branch of the if</em>, because we just tested that.</p><p>In summary the nullable feature splits reference types into non-nullable reference types (such as <code>string</code>) and nullable reference types (such as <code>string?</code>), and enforces their null behavior with warnings.</p><p>This is enough of a primer for the purposes of this post. If you want to go deeper, please visit the docs on <a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references">Nullable Reference Types</a>, or check some of the earlier posts on the topic (<a href="https://devblogs.microsoft.com/dotnet/take-c-8-0-for-a-spin/">Take C# 8.0 for a spin</a>, <a href="https://devblogs.microsoft.com/dotnet/nullable-reference-types-in-csharp/">Introducing Nullable Reference Types in C#</a>).</p><p>There are many more nuances to how you can tune your nullable annotations, and we use a good many of them in our &#x201C;nullification&#x201D; of the .NET Core Libraries. The post <a href="https://devblogs.microsoft.com/dotnet/try-out-nullable-reference-types/">Try out Nullable Reference Types</a> explores those in great detail.</p><h2>How and when to become &#x201C;null-aware&#x201D;?</h2><p>Now to the meat of this post. <em>When</em> should you adopt nullable reference types? How to think about that? Here are some observations about the interaction between libraries and clients. Afterwards we propose a shared <em>timeline</em> for the whole ecosystem &#x2013; the <em>&#x201C;nullable rollout phase&#x201D;</em> &#x2013; to guide the adoption based on what you are building.</p><h2>What happens when you enable nullable reference types in your code?</h2><p>You will have to go over your signatures to decide in each place where you have a reference type whether to leave it non-nullable (e.g. <code>string</code>) or make it nullable (e.g. <code>string?</code>). Does your method handle null arguments gracefully (or even meaningfully), or does it immediately check and throw? If it throws on null you want to keep it non-nullable to signal that to your callers. Does your method sometimes return null? If so you want to make the return type nullable to &#x201C;warn&#x201D; your callers about it.</p><p>You&#x2019;ll also start getting warnings when you use those members wrong. If you dereference the result of a method that returns <code>string?</code> and you don&#x2019;t check it for null first, then you&#x2019;ll have to fix that.</p><h2>What happens when you call libraries that have the feature enabled?</h2><p>If you yourself have the feature enabled and a library you depend on has already been compiled with the feature on, then it too will have nullable and nonnullable types in its signatures, and you will get warnings if you use those in the wrong way.</p><p>This is one of the core values of NRTs: That libraries can accurately describe the null behavior of the APIs, in a way that is checkable in client code at the call site. This raises expressiveness on API boundaries so that everyone can get a handle on the safe propagation and dereferencing of nulls. Nobody likes null reference exceptions or argument-null exceptions! This helps you write the code right the first time, and avoid the sources of those exceptions before you even compile and run the code.</p><h2>What happens when you call libraries that have not enabled the feature?</h2><p>Nothing! If a library was not compiled with the feature on, your compiler cannot assume one way or the other about whether types in the signatures were supposed to be nullable or not. So it doesn&#x2019;t give you <em>any</em> warnings when you use the library. In nullable parlance, the library is &#x201C;null-oblivious&#x201D;. So even though <em>you</em> have opted in to getting the null checking, it only goes as far as the boundary to a null-oblivious library.</p><p>When that library later comes out in a new version that <em>does</em> enable the feature, and you upgrade to that version, you may get new warnings! All of a sudden, your compiler knows what is &#x201C;right&#x201D; and &#x201C;wrong&#x201D; in the consumption of those APIs, and will start telling you about the &#x201C;wrong&#x201D;!</p><p>This is good of course. But if you adopt NRTs before the libraries you depend on, it does mean that you&#x2019;ll get some churn as they &#x201C;come online&#x201D; with their null annotations.</p><h2>The nullable rollout phase</h2><p>Here comes the big ask of you. In order to minimize the impact and churn, I want to recommend that we all think about the next year&#x2019;s time until .NET 5 (November 2020) as the <strong><em>&#x201C;nullable rollout phase&#x201D;</em></strong>, where certain behaviors are encouraged. After that, we should be in a &#x201C;new normal&#x201D; where NRTs are everywhere, and everyone can use this feature to track and be explicit about nullability.</p><h2>What should library authors do?</h2><p>We strongly encourage authors of libraries (and similar infrastructure, such as code generators) to <strong>adopt NRTs <em>during</em> the nullable rollout phase</strong>. Pick a time that&#x2019;s natural according to your shipping schedule, and that lets you get the work done, but do it within the next year. If your clients pester you to do it quicker, you can tell them <em>&#x201C;No! Go away! It&#x2019;s still the nullable rollout phase!&#x201D;</em></p><p>If you do go beyond the nullable rollout phase, however, your clients start having a point that you are holding back <em>their</em> adoption, and causing them to risk churn further down the line.</p><p>As a library writer you always face a dilemma between <em>reach</em> of your library and the <em>feature set</em> you can depend on in the runtime. In some cases you may feel compelled to split your library in two so that one version can target e.g. the classic .NET Framework, while a &#x201C;modern&#x201D; version makes use of e.g. new types and features in .NET Core 3.1.</p><p>However, with Nullable Reference Types specifically, you should be able to work around this. If you multitarget your library (e.g. in Visual Studio) to .NET Standard 2.0 and .NET Core 3.1, you will get the reach of .NET Standard 2.0 while benefitting from the nullable <em>annotations</em> of the .NET Core 3.1 libraries.</p><p>You also have to set the language version to C# 8.0, of course, and <em>that is not a supported scenario</em> when one of the target versions is below .NET Core 3.0. However, you can still do it manually in your project settings, and unlike many C# 8.0 features, the NRT feature <em>specifically</em> happens to not depend on specific elements of .NET Core 3.1. But if you try to use other language features of C# 8.0 while targeting .NET Standard 2.0, all bets are off!</p><h2>What should library users do?</h2><p>You should be aware that there&#x2019;s a nullable rollout phase where things will be in flux. If you don&#x2019;t mind the flux, by all means turn the feature on right away! It may be easier to fix bugs gradually, as libraries come online, rather than in bulk.</p><p>If you <em>do</em> want to save up the work for one fell swoop, however, you should wait for the nullable rollout phase to be over, or at least for all the libraries you depend on to have enabled the feature.</p><p>It&#x2019;s not fair to nag your library providers about nullability annotations until the nullable rollout phase is over. <em>Engaging</em> them to help get it done, through OSS or as early adopters or whatever, is of course highly encouraged, as always.</p><h2>What will Microsoft do?</h2><p>We will also aim to be done with null-annotating our core libraries when .NET 5 comes around &#x2013; and we are currently on track to do so. (Tracking issue: <a href="https://github.com/dotnet/corefx/issues/40623">Annotate remainder of .NET Core assemblies for nullable reference types</a>).</p><p>We will also keep a keen eye on the usage and feedback during this time, and we will feel free to make adjustments anywhere in the stack, whether library, compilers or tooling, in order to improve the experience based on what we hear. <em>Adjustments</em>, not <em>sweeping changes</em>. For instance, <a href="https://github.com/dotnet/corefx/issues/41346">this</a> and <a href="https://github.com/dotnet/corefx/issues/41404">this</a> issue were already addressed by <a href="https://github.com/dotnet/corefx/pull/41367">this</a> and <a href="https://github.com/dotnet/corefx/pull/41415">this</a> fix.</p><p>When .NET 5 rolls around, if we feel the nullable rollout phase has been a success, I could see us turning the feature on by default for new projects in Visual Studio. If the ecosystem is ready for it, there is no reason why <em>any</em> new code should ignore the improved safety and reliability you get from nullability annotations!</p><p>At that point, the mechanisms for opt-in and opt-out become effectively obsolete &#x2013; a mechanism to deal with legacy code.</p><h2>Call to action</h2><p>Make a plan! How are <em>you</em> going to act on nullable reference types? Try it out! Turn it on in your code and see what happens. Scary many warnings? That may happen until you get your signatures annotated right. After that, the remaining warnings are about the quality of your consuming code, and those are the reward: an opportunity to fix the places where your code is probably not null safe!</p><p>And as always: Have fun exploring!</p><p>Happy hacking,</p><p>Mads Torgersen, C# lead designer</p></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>