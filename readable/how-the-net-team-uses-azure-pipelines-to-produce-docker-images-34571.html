<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How the .NET Team uses Azure Pipelines to produce Docker Images | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="How the .NET Team uses Azure Pipelines to produce Docker Images | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Matt ThalmanFollow Matt"/>
    <meta property="og:description" content="Producing&#xA0;Docker images for .NET&#xA0;might not seem&#xA0;like that big of a deal.&#xA0; Once you&#x2019;ve got a&#xA0;Dockerfile&#xA0;defined, just run&#xA0;&#x201C;docker build&#x201C;&#xA0;and&#xA0;&#x201C;docker&#xA0;push&#x201C;&#xA0;and you&#x2019;re done, right?&#xA0;&#xA0;Then&#xA0;just rinse and repeat&#xA0;when&#xA0;new versions of .NET&#xA0;are released&#xA0;and that should be all that&#x2019;s needed."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/how-the-net-team-uses-azure-pipelines-to-produce-docker-images/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - How the .NET Team uses Azure Pipelines to produce Docker Images | .NET Blog</title>
<div class="readable">
        <h1>How the .NET Team uses Azure Pipelines to produce Docker Images | .NET Blog</h1>
            <div>by Matt ThalmanFollow Matt</div>
            <div>Reading time: 10-13 minutes</div>
        <div>Posted here: 28 Aug 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/how-the-net-team-uses-azure-pipelines-to-produce-docker-images/">https://devblogs.microsoft.com/dotnet/how-the-net-team-uses-azure-pipelines-to-produce-docker-images/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/2c75388dc7947fa9034c15352e6c6c69?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Matt</p></div></div></div><p>August 28th, 2019</p><p><span data-contrast="none">Produc</span><span data-contrast="none">ing&nbsp;</span><a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/"><span data-contrast="none">Docker images for .NET</span></a><span data-contrast="none">&nbsp;might not seem&nbsp;</span><span data-contrast="none">like that big of a deal.&nbsp; O</span><span data-contrast="none">nce you’ve got a&nbsp;</span><span data-contrast="none">Dockerfile</span><span data-contrast="none">&nbsp;defined, just run&nbsp;</span><span data-contrast="none">“</span><span data-contrast="none">docker build</span><span data-contrast="none">“</span><span data-contrast="none">&nbsp;and&nbsp;</span><span data-contrast="none">“</span><span data-contrast="none">docker&nbsp;</span><span data-contrast="none">push</span><span data-contrast="none">“</span><span data-contrast="none">&nbsp;and you’re done, right?</span><span data-contrast="none">&nbsp;&nbsp;</span><span data-contrast="none">Then</span><span data-contrast="none">&nbsp;just rinse and repeat&nbsp;</span><span data-contrast="none">when&nbsp;</span><span data-contrast="none">new versions of .NET&nbsp;</span><span data-contrast="none">are released&nbsp;</span><span data-contrast="none">and that should be all that’s needed.&nbsp; Well, it’s not quite that simple.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">When you factor in&nbsp;</span><span data-contrast="none">the&nbsp;</span><span data-contrast="none">number&nbsp;</span><span data-contrast="none">of Linux distro</span><span data-contrast="none">s</span><span data-contrast="none">&nbsp;and Windows versions, different processor architectures,&nbsp;</span><span data-contrast="none">and&nbsp;</span><span data-contrast="none">different .NET versions, you end up&nbsp;</span><span data-contrast="none">with a substantial matrix of images that need to be</span><span data-contrast="none">&nbsp;built and</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">published</span><span data-contrast="none">.&nbsp;&nbsp;</span><span data-contrast="none">Then consider that some images have dependencies on others</span><span data-contrast="none">&nbsp;which implies a specific order in which to build the images</span><span data-contrast="none">.&nbsp; And&nbsp;</span><span data-contrast="none">on top</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">of all that,&nbsp;</span><span data-contrast="none">we need to</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">ensure the&nbsp;</span><span data-contrast="none">images&nbsp;</span><span data-contrast="none">ar</span><span data-contrast="none">e p</span><span data-contrast="none">ublished&nbsp;</span><span data-contrast="none">as quickly as possible&nbsp;</span><span data-contrast="none">so that customers can get their hands on&nbsp;</span><span data-contrast="none">newly released product versions and security fixes.</span><span data-contrast="none">&nbsp;&nbsp;</span><span data-contrast="none">Oh, and by the way, in addition to the&nbsp;</span><a href="https://github.com/dotnet/dotnet-docker" target="_blank"><span data-contrast="none">.NET Core</span></a><span data-contrast="none">&nbsp;</span><span data-contrast="none">images&nbsp;</span><span data-contrast="none">we also produce .NET Core&nbsp;</span><a href="https://github.com/dotnet/dotnet-docker/tree/nightly" target="_blank"><span data-contrast="none">nightly</span></a><span data-contrast="none">&nbsp;images for preview releases,&nbsp;</span><a href="https://github.com/dotnet/dotnet-buildtools-prereqs-docker" target="_blank"><span data-contrast="none">images</span></a><span data-contrast="none">&nbsp;for developers of .NET Core, as well as images for&nbsp;</span><a href="https://github.com/Microsoft/dotnet-framework-docker" target="_blank"><span data-contrast="none">.NET Framework</span></a><span data-contrast="none">.</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">This is starting to look a little daunting.</span><span data-contrast="none">&nbsp; Let’s dive into what goes into producing the .NET Docker images.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">To keep things “simple”, let’s just consider the Docker images for&nbsp;</span><span data-contrast="none">.NET Core</span><span data-contrast="none">.&nbsp;&nbsp;</span><span data-contrast="none">The same infrastructure is used amongst all the types of images we produce</span><span data-contrast="none">&nbsp;but keep in mind that the scope of the work is greater than described here.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">T</span><span data-contrast="none">he full set of .NET Core images</span><span data-contrast="none">&nbsp;are derived from the following matrix</span><span data-contrast="none">:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><ul><li data-leveltext="" data-font="Symbol" data-listid="2" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="none">Linux: 3 distros / 7 versions</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></li><li data-leveltext="" data-font="Symbol" data-listid="2" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><span data-contrast="none">Windows: 4 versions</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></li><li data-leveltext="" data-font="Symbol" data-listid="2" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="none">Architectures: AMD64, ARM32, ARM64</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></li><li data-leveltext="" data-font="Symbol" data-listid="2" aria-setsize="-1" data-aria-posinset="4" data-aria-level="1"><span data-contrast="none">.NET Core: 3 versions</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></li></ul><p><span data-contrast="none">In total,&nbsp;</span><span data-contrast="none">119 distinct images with&nbsp;</span><span data-contrast="none">309&nbsp;</span><span data-contrast="none">tags</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">(281 simple and 28 shared)&nbsp;</span><span data-contrast="none">are&nbsp;</span><span data-contrast="none">being&nbsp;</span><span data-contrast="none">produced</span><span data-contrast="none">&nbsp;today</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">This matrix is constantly evolving as new OS and .NET versions are released.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><h2 aria-level="2"><span data-contrast="none">Anatomy of our Pipeline</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}">&nbsp;</span></h2><p><span data-contrast="none">Our</span><span data-contrast="none">&nbsp;CI/CD</span><span data-contrast="none">&nbsp;pipeline is implemented using&nbsp;</span><a href="https://azure.microsoft.com/services/devops/pipelines" target="_blank"><span data-contrast="none">Azure Pipelines</span></a><span data-contrast="none">&nbsp;with the core YAML</span><span data-contrast="none">-based&nbsp;</span><span data-contrast="none">source located&nbsp;</span><a href="https://github.com/dotnet/docker-tools/tree/master/eng/common/templates" target="_blank"><span data-contrast="none">here</span></a><span data-contrast="none">. It’s divided into three stages: build, test, and publish. Build and test each run multiple jobs in parallel. This parallelism&nbsp;</span><span data-contrast="none">dramatically reduces&nbsp;</span><span data-contrast="none">the&nbsp;</span><span data-contrast="none">pipeline’s</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">execution time from start to finish&nbsp;</span><span data-contrast="none">by an order of magnitude</span><span data-contrast="none">&nbsp;versus running the jobs sequentially</span><span data-contrast="none">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><h3 aria-level="3"><span><span>Build Agents</span>&nbsp;</span></h3><p><span data-contrast="none">Since we’ve got jobs running in parallel, we also need&nbsp;a number of&nbsp;build agents that can fulfill the execution of those jobs.&nbsp;</span><span data-contrast="none">T</span><span data-contrast="none">here is a&nbsp;</span><span data-contrast="none">self-hosted&nbsp;</span><span data-contrast="none">agent pool</span><span data-contrast="none">&nbsp;that we use&nbsp;</span><span data-contrast="none">for</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">producing&nbsp;</span><span data-contrast="none">.NET&nbsp;</span><span data-contrast="none">images&nbsp;</span><span data-contrast="none">which&nbsp;</span><span data-contrast="none">consists of a variety of&nbsp;</span><span data-contrast="none">virtual machines&nbsp;</span><span data-contrast="none">and physical hardware to meet our</span><span data-contrast="none">&nbsp;platform and</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">perf demands</span><span data-contrast="none">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">For Linux AMD64 builds,&nbsp;</span><span data-contrast="none">we use the Hosted Ubuntu 1604 pool provided by Azure DevOp</span><span data-contrast="none">s. That pool meets our performance needs and makes things simple from an operations standpoint.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">For Windows AMD64 builds, we have&nbsp;</span><span data-contrast="none">custom Azure VMs configured as Azure Pipeline</span><span data-contrast="none">&nbsp;self-hosted</span><span data-contrast="none">&nbsp;agents that are</span><span data-contrast="none">&nbsp;running four different Windows versions (five agents for each version).</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">For&nbsp;</span><span data-contrast="none">ARM builds</span><span data-contrast="none">, things get a bit&nbsp;</span><span data-contrast="none">trickier</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">We need to build and test the Docker images on ARM-</span><span data-contrast="none">based&nbsp;</span><span data-contrast="none">hardware.&nbsp;&nbsp;</span><span data-contrast="none">Since the&nbsp;</span><span data-contrast="none">Azure Pipeline agent software</span><span data-contrast="none">’s support for ARM is limited to Linux/ARM32, we</span><span data-contrast="none">&nbsp;use AMD-based Linux machines as the agents&nbsp;</span><span data-contrast="none">that send commands to&nbsp;</span><span data-contrast="none">remote&nbsp;</span><span data-contrast="none">Linux</span><span data-contrast="none">&nbsp;and Windows ARM devices.</span><span data-contrast="none">&nbsp;&nbsp;</span><span data-contrast="none">Each of those devices runs a Docker daemon</span><span data-contrast="none">.&nbsp; The agent machines act as proxies to send Docker commands to the&nbsp;</span><span data-contrast="none">remote&nbsp;</span><span data-contrast="none">daemon</span><span data-contrast="none">s</span><span data-contrast="none">&nbsp;running on the&nbsp;</span><span data-contrast="none">ARM&nbsp;</span><span data-contrast="none">device</span><span data-contrast="none">s</span><span data-contrast="none">.</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">For Linux, we use&nbsp;</span><a href="https://www.nvidia.com/en-us/autonomous-machines/embedded-systems" target="_blank"><span data-contrast="none">NVIDA Jetson</span></a><span data-contrast="none">&nbsp;</span><span data-contrast="none">devices that run on the AArch64 architecture which&nbsp;</span><span data-contrast="none">are</span><span data-contrast="none">&nbsp;capable of building images that target&nbsp;</span><span data-contrast="none">either ARM32 or ARM64</span><span data-contrast="none">.</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">For Windows,&nbsp;</span><span data-contrast="none">we have</span><span data-contrast="none">&nbsp;</span><a href="https://www.solid-run.com/nxp-family/hummingboard/" target="_blank"><span data-contrast="none">SolidRun</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">HummingBoard</span></a><span data-contrast="none">&nbsp;</span><span data-contrast="none">ARM device</span><span data-contrast="none">s.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><h3 aria-level="3"><span>Image&nbsp;Matrix Generation&nbsp;</span></h3><p><span data-contrast="none">One of the key features of&nbsp;</span><a href="https://azure.microsoft.com/services/devops/pipelines" target="_blank"><span data-contrast="none">Azure Pipelines</span></a><span data-contrast="none">&nbsp;</span><span data-contrast="none">that we&nbsp;</span><span data-contrast="none">rely on&nbsp;</span><span data-contrast="none">is&nbsp;</span><span data-contrast="none">the&nbsp;</span><a href="https://docs.microsoft.com/azure/devops/pipelines/yaml-schema?view=azure-devops&amp;tabs=schema#matrix" target="_blank"><span data-contrast="none">matrix</span></a><span data-contrast="none">&nbsp;strategy for build jobs.&nbsp;</span><span data-contrast="none">It&nbsp;</span><span data-contrast="none">allows a variable number of build jobs to be generated based on a</span><span data-contrast="none">n image&nbsp;</span><span data-contrast="none">matrix that is defined by our pipeline.&nbsp; An&nbsp;</span><span data-contrast="none">illustration</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">of&nbsp;</span><span data-contrast="none">a very simplified&nbsp;</span><span data-contrast="none">matrix is the following</span><span data-contrast="none">&nbsp;YAML</span><span data-contrast="none">:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="auto">3.0-runtime-deps-disco-graph:</span><br> <span data-contrast="auto">&nbsp;&nbsp;imageBuilderPaths: 3.0/runtime-deps/disco</span><span data-contrast="auto">&nbsp;</span><span data-contrast="auto">3.0/runtime/disco</span><span data-contrast="auto">&nbsp;</span><span data-contrast="auto">3.0/aspnet/disco</span><br> <span data-contrast="auto">&nbsp;&nbsp;osType:&nbsp;linux</span><br> <span data-contrast="auto">&nbsp; architecture: amd64</span><br> <span data-contrast="auto">3.0-sdk-disco:</span><br> <span data-contrast="auto">&nbsp;&nbsp;imageBuilderPaths: –path 3.0/sdk/disco</span><br> <span data-contrast="auto">&nbsp;&nbsp;osType:&nbsp;linux</span><br> <span data-contrast="auto">&nbsp; architecture: amd64</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">This matrix</span><span data-contrast="none">&nbsp;would cause two&nbsp;</span><span data-contrast="none">build jobs to execute in parallel, each running the same set of steps but with different inputs.&nbsp;&nbsp;</span><span data-contrast="none">The inputs consist of variables defined by the matrix.&nbsp;&nbsp;</span><span data-contrast="none">The first job</span><span data-contrast="none">,</span><span data-contrast="none">&nbsp;as identified by&nbsp;</span><span data-contrast="auto">3.0-runtime-deps-disco-graph</span><span data-contrast="none">,&nbsp;</span><span data-contrast="none">has a variable named&nbsp;</span><span data-contrast="auto">imageBuilderPaths</span><span data-contrast="none">&nbsp;that indicates to the build steps that</span><span data-contrast="none">&nbsp;the</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">.</span><span data-contrast="none">NET Core 3.0&nbsp;</span><span data-contrast="none">Docker images f</span><span data-contrast="none">or&nbsp;</span><span data-contrast="auto">runtime-deps</span><span data-contrast="none">,&nbsp;</span><span data-contrast="auto">runtime</span><span data-contrast="none">, and&nbsp;</span><span data-contrast="auto">aspnet</span><span data-contrast="none">&nbsp;on Ubuntu Disco</span><span data-contrast="none">&nbsp;are to be built</span><span data-contrast="none">.</span><span data-contrast="none">&nbsp; The reason those&nbsp;</span><span data-contrast="none">images are built in a single job is because the</span><span data-contrast="none">r</span><span data-contrast="none">e</span><span data-contrast="none">&nbsp;are</span><span data-contrast="none">&nbsp;dependencies amongst them.&nbsp;&nbsp;</span><span data-contrast="none">The&nbsp;</span><span data-contrast="auto">runtime</span><span data-contrast="none">&nbsp;image depends on&nbsp;</span><span data-contrast="auto">runtime-deps</span><span data-contrast="none">&nbsp;and the&nbsp;</span><span data-contrast="auto">aspnet</span><span data-contrast="none">&nbsp;image depends on the&nbsp;</span><span data-contrast="auto">runtime</span><span data-contrast="none">&nbsp;image; there’s no parallelism that can be done within this graph.&nbsp; The&nbsp;</span><span data-contrast="auto">sdk</span><span data-contrast="none">&nbsp;image, however, can be built in parallel with the others because it doesn’t depend on them; it depends on&nbsp;</span><a href="https://github.com/docker-library/buildpack-deps/blob/master/disco/scm/Dockerfile" target="_blank"><span data-contrast="none">buildpa</span><span data-contrast="none">ck-deps:disco-scm</span></a><span data-contrast="none">, an&nbsp;</span><span data-contrast="none">official Docker&nbsp;image</span><span data-contrast="none">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">The goal is to produce a matrix that&nbsp;</span><span data-contrast="none">splits things apart s</span><span data-contrast="none">uch that operations are executed in&nbsp;</span><span data-contrast="none">parallel whenever possible.&nbsp; You</span><span data-contrast="none">&nbsp;might</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">be&nbsp;</span><span data-contrast="none">thinking th</span><span data-contrast="none">at such a matrix has got to be a real headache to maintain.</span><span data-contrast="none">&nbsp; And you’d be right.&nbsp; That’s why we don’t maintain a statically defined matrix.&nbsp; It’s generated for us&nbsp;</span><span data-contrast="none">dynamically at build time&nbsp;</span><span data-contrast="none">by a multi-purpo</span><span data-contrast="none">se&nbsp;</span><span data-contrast="none">tool</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">we’ve created&nbsp;</span><span data-contrast="none">called&nbsp;</span><a href="https://github.com/dotnet/docker-tools" target="_blank"><span data-contrast="none">Image Builder</span></a><span data-contrast="none">.</span><span data-contrast="none">&nbsp;With this&nbsp;</span><span data-contrast="none">tool</span><span data-contrast="none">,&nbsp;</span><span data-contrast="none">we can execute a command that will consume a&nbsp;</span><span data-contrast="none">custom&nbsp;</span><span data-contrast="none">manifest file and outputs a matrix&nbsp;</span><span data-contrast="none">that is consumed by&nbsp;</span><a href="https://azure.microsoft.com/services/devops/pipelines" target="_blank"><span data-contrast="none">Azure Pipelines</span></a><span data-contrast="none">.&nbsp; The&nbsp;</span><a href="https://github.com/dotnet/dotnet-docker/blob/master/manifest.json" target="_blank"><span data-contrast="none">manifest file</span></a><span data-contrast="none">&nbsp;</span><span data-contrast="none">contains&nbsp;</span><span data-contrast="none">a bunch of metadata about all the images we need to produce&nbsp;</span><span data-contrast="none">and includes information like the file paths to the&nbsp;</span><span data-contrast="none">Dockerfiles</span><span data-contrast="none">&nbsp;and the tags to be assigned to the images.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">We don’t just generate one matrix either.&nbsp; Separate matrices are generated based on the&nbsp;</span><span data-contrast="none">platform and architecture.&nbsp; For example, there are separate matrices for Linux</span><span data-contrast="none">/</span><span data-contrast="none">AMD64, Linux</span><span data-contrast="none">/</span><span data-contrast="none">ARM32,&nbsp;</span><span data-contrast="none">Windows Nano Server 1809</span><span data-contrast="none">/</span><span data-contrast="none">ARM32, etc.&nbsp; The output from Image Builder labels each matrix with its corresponding platform</span><span data-contrast="none">/architecture identifier.&nbsp; This identifier determines which build agents will run that&nbsp;</span><span data-contrast="none">particular matrix</span><span data-contrast="none">.</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">As an example, t</span><span data-contrast="none">he pipeline is configured to run&nbsp;</span><span data-contrast="none">the Linux/AMD</span><span data-contrast="none">64 matrix on the Hosted Ubuntu 1604 agent pool.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><h3 aria-level="3"><span data-contrast="none">Build Stage</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}">&nbsp;</span></h3><p><span data-contrast="none">The&nbsp;</span><span data-contrast="none">build stage</span><span data-contrast="none">&nbsp;of the pipeline</span><span data-contrast="none">&nbsp;is responsible for&nbsp;</span><span data-contrast="none">build</span><span data-contrast="none">ing</span><span data-contrast="none">&nbsp;the</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">Docker images</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">T</span><span data-contrast="none">here are 64 jobs that are executed which account for the different platform and product version combinations a</span><span data-contrast="none">s well as</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">image&nbsp;</span><span data-contrast="none">dependencies</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">Examples of job names include “Build-2.2-aspnet-Windows-NanoServer1809-AMD64”, “</span><span data-contrast="none">Build</span><span data-contrast="none">-2.</span><span data-contrast="none">1-runtime-deps-graph</span><span data-contrast="none">-Linux-</span><span data-contrast="none">bionic</span><span data-contrast="none">-A</span><span data-contrast="none">RM32v7</span><span data-contrast="none">”, and “</span><span data-contrast="none">Build</span><span data-contrast="none">-3.0</span><span data-contrast="none">-sdk</span><span data-contrast="none">-Linux-bionic-A</span><span data-contrast="none">MD64</span><span data-contrast="none">”.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">The first step of this process is to call&nbsp;</span><a href="https://github.com/dotnet/docker-tools" target="_blank"><span data-contrast="none">Image Builder</span></a><span data-contrast="none">&nbsp;to generate the build matri</span><span data-contrast="none">ces</span><span data-contrast="none">.&nbsp;&nbsp;</span><span data-contrast="none">Each matrix produces a set of jobs that build the set of Docker images as described by their portion of the matrix.&nbsp;&nbsp;</span><span data-contrast="none">Remember the&nbsp;</span><span data-contrast="auto">imageBuilderPaths</span><span data-contrast="none">&nbsp;variable contained in the matrix example mentioned earlier? This value is fed into Image Builder</span><span data-contrast="none">&nbsp;so that it knows which Docker images it should b</span><span data-contrast="none">uild</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">It also uses the metadata in the&nbsp;</span><a href="https://github.com/dotnet/dotnet-docker/blob/master/manifest.json" target="_blank"><span data-contrast="none">manifest file</span></a><span data-contrast="none">&nbsp;</span><span data-contrast="none">to know which tags should be defined for these images.</span><span data-contrast="none">&nbsp;This includes the&nbsp;</span><span data-contrast="none">definition&nbsp;</span><span data-contrast="none">of simple tags</span><span data-contrast="none">&nbsp;(</span><span data-contrast="none">platform-specific and</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">map to a single image</span><span data-contrast="none">)</span><span data-contrast="none">&nbsp;and shared tags</span><span data-contrast="none">&nbsp;(</span><span data-contrast="none">not platform-specific and&nbsp;</span><span data-contrast="none">can map to multiple images</span><span data-contrast="none">)</span><span data-contrast="none">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">Because a build agent begins a job in a clean state</span><span data-contrast="none">&nbsp;and has no state from its previous run</span><span data-contrast="none">, there needs to be an external storage mechanism for the Docker images that are produced</span><span data-contrast="none">.&nbsp; For that reason,&nbsp;</span><span data-contrast="none">each job pushe</span><span data-contrast="none">s the images it has built</span><span data-contrast="none">&nbsp;to&nbsp;</span><span data-contrast="none">a</span><span data-contrast="none">&nbsp;staging location in an</span><span data-contrast="none">&nbsp;</span><a href="https://azure.microsoft.com/services/container-registry/" target="_blank"><span data-contrast="none">Azure Container Registry (ACR)</span></a><span data-contrast="none">&nbsp;</span><span data-contrast="none">so</span><span data-contrast="none">&nbsp;they can&nbsp;</span><span data-contrast="none">later be pulled&nbsp;</span><span data-contrast="none">by the agents running&nbsp;</span><span data-contrast="none">in&nbsp;</span><span data-contrast="none">the test stage</span><span data-contrast="none">&nbsp;and eventually published</span><span data-contrast="none">.</span><span data-contrast="none">&nbsp;&nbsp;</span><span data-contrast="none">In some cases, a given image may be used by&nbsp;</span><span data-contrast="none">multiple test jobs so having it available&nbsp;</span><span data-contrast="none">to be pulled from an external source is necessary.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><h3 aria-level="3"><span data-contrast="none">Test Stage</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}">&nbsp;</span></h3><p><span data-contrast="none">Now that&nbsp;</span><span data-contrast="none">all</span><span data-contrast="none">&nbsp;the images have been built it’s time to test them. This is done with a set of smoke tests that verify the basics, such as being able to create and build a project with the SDK image and run it&nbsp;</span><span data-contrast="none">with</span><span data-contrast="none">&nbsp;the runtime image.&nbsp;</span><span data-contrast="none">Even though these tests are very basic, they have sometimes caught product issues and enabled us to halt publishing a .NET Core update</span><span data-contrast="none">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">Like</span><span data-contrast="none">&nbsp;the build stage, the test stage is split into a set of&nbsp;</span><span data-contrast="none">34 jobs that run in parallel</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">Each test job is responsible for testing a&nbsp;</span><span data-contrast="none">specific</span><span data-contrast="none">&nbsp;.NET Core version&nbsp;</span><span data-contrast="none">on a specific operating system version on a specific architecture.&nbsp; Examples of job names include&nbsp;</span><span data-contrast="none">“</span><span data-contrast="none">Test-</span><span data-contrast="none">2.1-Windows-NanoServer1809-AMD64”,&nbsp;</span><span data-contrast="none">“</span><span data-contrast="none">Test-</span><span data-contrast="none">2.2-</span><span data-contrast="none">Linux-</span><span data-contrast="none">alpine3.9-AMD64</span><span data-contrast="none">”</span><span data-contrast="none">,&nbsp;</span><span data-contrast="none">and&nbsp;</span><span data-contrast="none">“</span><span data-contrast="none">Test-</span><span data-contrast="none">3.0-</span><span data-contrast="none">Linux-</span><span data-contrast="none">bionic</span><span data-contrast="none">-ARM64v8</span><span data-contrast="none">”</span><span data-contrast="none">.</span><span data-contrast="none">&nbsp;&nbsp;</span><span data-contrast="none">Notice that</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">the&nbsp;</span><span data-contrast="none">breakdown&nbsp;</span><span data-contrast="none">of jobs&nbsp;</span><span data-contrast="none">is different</span><span data-contrast="none">&nbsp;compared to the build stage&nbsp;</span><span data-contrast="none">as the tests have dependencies on images that are different than the build jobs. For example, even though an SDK image might be able to be built independently of the runtime image, both images are needed together in order to test them</span><span data-contrast="none">&nbsp;because of how our test scenarios are authored</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">T</span><span data-contrast="none">here are not separate jobs that test just the runtime image and just the SDK image; rather, there is one job that tests them both for a given platform/architecture/.NET version. That means each test job selectively pulls down only the images it requires from&nbsp;</span><span data-contrast="none">the staging location in&nbsp;</span><span data-contrast="none">ACR.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><h3 aria-level="3"><span data-contrast="none">Publish Stage</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}">&nbsp;</span></h3><p><span data-contrast="none">Once it’s known that&nbsp;</span><span data-contrast="none">all&nbsp;</span><span data-contrast="none">the images are in a good state from the test stage, we can move on to publishing them to</span><span data-contrast="none">&nbsp;</span><a href="https://devblogs.microsoft.com/dotnet/net-core-container-images-now-published-to-microsoft-container-registry/"><span data-contrast="none">Microsoft Container Registry (MCR)</span></a><span data-contrast="none">. Publishing runs relatively quickly (</span><span data-contrast="none">the entire</span><span data-contrast="none">&nbsp;stage only takes about 3 minutes) because the images are&nbsp;</span><span data-contrast="none">efficiently&nbsp;</span><span data-contrast="none">transferred</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">from&nbsp;</span><span data-contrast="none">ACR&nbsp;</span><span data-contrast="none">to MCR within shared Azure infrastructure</span><span data-contrast="none">. MCR detects th</span><span data-contrast="none">is transfer</span><span data-contrast="none">&nbsp;and makes&nbsp;</span><span data-contrast="none">the</span><span data-contrast="none">&nbsp;images</span><span data-contrast="none">&nbsp;available</span><span data-contrast="none">&nbsp;for public consumption</span><span data-contrast="none">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">Included with publishing the images are a&nbsp;</span><span data-contrast="none">few other supplemental&nbsp;</span><span data-contrast="none">steps</span><span data-contrast="none">.&nbsp; The first is</span><span data-contrast="none">&nbsp;to publish the&nbsp;</span><a href="https://blog.docker.com/2017/11/multi-arch-all-the-things/" target="_blank"><span data-contrast="none">image manifests</span></a><span data-contrast="none">&nbsp;to support multi-arch</span><span data-contrast="none">&nbsp;</span><span data-contrast="none">using the Docker&nbsp;</span><a href="https://github.com/estesp/manifest-tool" target="_blank"><span data-contrast="none">manifest tool</span></a><span data-contrast="none">.&nbsp;&nbsp;</span><span data-contrast="none">Next, the</span><span data-contrast="none">&nbsp;README files on&nbsp;</span><a href="https://hub.docker.com/" target="_blank"><span data-contrast="none">Docker Hub</span></a><span data-contrast="none">&nbsp;are update</span><span data-contrast="none">d to reflect the latest content from the repo’s README files.&nbsp; Lastly, a</span><span data-contrast="none">&nbsp;JSON</span><span data-contrast="none">&nbsp;file&nbsp;</span><span data-contrast="none">is updated that keeps track of&nbsp;</span><span data-contrast="none">metadata about the latest images that have been published.&nbsp; This file serves several purposes</span><span data-contrast="none">,&nbsp;</span><span data-contrast="none">one of&nbsp;</span><span data-contrast="none">which&nbsp;</span><span data-contrast="none">is&nbsp;</span><span data-contrast="none">to provide a way to determine when we need to&nbsp;</span><span data-contrast="none">re-build an image due&nbsp;</span><span data-contrast="none">to&nbsp;</span><span data-contrast="none">it</span><span data-contrast="none">s base image being updated.&nbsp; More on th</span><span data-contrast="none">at</span><span data-contrast="none">&nbsp;in a future blog post.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><h2 aria-level="2"><span data-contrast="none">Conclusion</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}">&nbsp;</span></h2><p><span data-contrast="none">It is a testament to the power and flexibility of Azure Pipelines&nbsp;</span><span data-contrast="none">to&nbsp;</span><span data-contrast="none">enable us&nbsp;</span><span data-contrast="none">to produce Docker images at&nbsp;</span><span data-contrast="none">the scale and breadth of platforms that&nbsp;</span><span data-contrast="none">we require</span><span data-contrast="none">.&nbsp;</span><span data-contrast="none">If you’re interested</span><span data-contrast="none">&nbsp;in the nitty-gritty details</span><span data-contrast="none">, check out&nbsp;</span><span data-contrast="none">our</span><span data-contrast="none">&nbsp;</span><a href="https://github.com/dotnet/docker-tools/tree/master/eng/common/templates" target="_blank"><span data-contrast="none">pipeline infrastructure</span></a><span data-contrast="none">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">What are the systems that you have in place for producing your organization’s Docker image</span><span data-contrast="none">s</span><span data-contrast="none">?&nbsp; Did this post spark any ideas on changes you could make to your&nbsp;</span><span data-contrast="none">process?&nbsp; Let us know in the comments.</span><span data-contrast="none">&nbsp;And if you’re a consumer of our Docker images, let us know how we’re doing either&nbsp;</span><span data-contrast="none">in the comments&nbsp;</span><span data-contrast="none">or at&nbsp;</span><span data-contrast="none">our</span><span data-contrast="none">&nbsp;</span><a href="https://github.com/dotnet/dotnet-docker" target="_blank"><span data-contrast="none">GitHub repo</span></a><span data-contrast="none">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p><p><span data-contrast="none">Happy containerizing!</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">&nbsp;</span></p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>