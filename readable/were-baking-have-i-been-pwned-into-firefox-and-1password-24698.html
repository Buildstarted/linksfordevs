<!DOCTYPE html>
<html lang="en">
<head>
    <title>
We&#x27;re Baking Have I Been Pwned into Firefox and 1Password - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="We&#x27;re Baking Have I Been Pwned into Firefox and 1Password - linksfor.dev(s)"/>
    <meta property="article:author" content="Troy Hunt"/>
    <meta property="og:description" content="Pretty much every day, I get a reminder from someone about how little people know about their exposure in data breaches. Often, it&#x27;s after someone has searched Have I Been Pwned (HIBP) and found themselves pwned somewhere or other. Frequently, it&#x27;s some long-forgotten site they haven&#x27;t even thought about in"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.troyhunt.com/were-baking-have-i-been-pwned-into-firefox-and-1password/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - We&#x27;re Baking Have I Been Pwned into Firefox and 1Password</title>
<div class="readable">
        <h1>We&#x27;re Baking Have I Been Pwned into Firefox and 1Password</h1>
            <div>by Troy Hunt</div>
            <div>Reading time: 16-20 minutes</div>
        <div>Posted here: 22 May 2019</div>
        <p><a href="https://www.troyhunt.com/were-baking-have-i-been-pwned-into-firefox-and-1password/">https://www.troyhunt.com/were-baking-have-i-been-pwned-into-firefox-and-1password/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section>
            <!--kg-card-begin: markdown--><p>Pretty much every day, I get a reminder from someone about how little people know about their exposure in data breaches. Often, it's after someone has searched <a href="https://haveibeenpwned.com/">Have I Been Pwned</a> (HIBP) and found themselves pwned somewhere or other. Frequently, it's some long-forgotten site they haven't even thought about in years and also frequently, the first people know of these incidents is via HIBP:</p>
<twitter-widget id="twitter-widget-0" data-tweet-id="1003628398772711424"></twitter-widget>

<twitter-widget id="twitter-widget-1" data-tweet-id="1003337886463397888"></twitter-widget>

<twitter-widget id="twitter-widget-2" data-tweet-id="1003278452848394240"></twitter-widget>

<p>In cases like Ticketfly, loading the data into HIBP meant notifying 105k of my subscribers. That's out of a subscriber base that just recently ticked over the 2M million mark:</p>
<twitter-widget id="twitter-widget-3" data-tweet-id="1009352425197719552"></twitter-widget>

<p>2 million is more than I ever expected, if I'm honest, but it's also only a tiny, tiny drop in the ocean. Of the 5.1 billion <em>records</em> that are in HIBP today, there's 3.1B unique email addresses. I'm reaching 0.06% of them via the notification service and not a whole lot more in terms of people coming to the site and doing an ad hoc search (usually 100k - 200k people a day). Don't get me wrong - I'm enormously happy and personally fulfilled by having been able to do even this - but clearly, I'm barely scratching the surface. However, that scope is about to expand dramatically via 2 new partnerships which I'm announcing today, starting with Firefox:</p>
<h2 id="mozillaandfirefoxmonitor">Mozilla and Firefox Monitor</h2>
<p>Last November, there was much press about <a href="https://www.infosecurity-magazine.com/news/mozilla-pwned-function-firefox/">Mozilla integrating HIBP into Firefox</a>. I was a bit surprised at the time as it was nothing more than their <a href="https://www.techrepublic.com/article/firefox-breach-alerts-will-warn-users-if-they-visit-a-hacked-site/">Breach Alerts feature</a> which simply highlighted if the site being visited had previously been in a data breach (it draws this from <a href="https://haveibeenpwned.com/API/v2#AllBreaches">the freely accessible breach API on HIBP</a>). But the press picked up on some signals which indicated that in the long term, we had bigger plans than that and the whole thing got a heap of <em>very</em> positive attention. I ended up fielding a heap of media calls just on that one little feature - people <em>loved</em> the idea of HIBP in Firefox, even in a very simple form. As it turns out, we had <em>much</em> bigger plans and that's what I'm sharing here today.</p>
<p><strong>Over the coming weeks, Mozilla will begin trialling integration between HIBP and Firefox to make breach data searchable via a new tool called "Firefox Monitor".</strong></p>
<p>Here's what it looks like:</p>
<p><img src="https://www.troyhunt.com/content/images/2018/06/Firefox-Monitor-Website---General-Homepage-1.png" alt="Firefox Monitor Website"></p>
<p>This is major because Firefox has an install base of hundreds of millions of people which <em>significantly</em> expands the audience that can be reached once this feature rolls out to the mainstream. You can read <a href="https://blog.mozilla.org/futurereleases/2018/06/25/testing-firefox-monitor-a-new-security-tool/">Mozilla's announcement of the new feature</a> and how they plan to conduct the testing and rollout.</p>
<p>I'm really happy to see Firefox integrating with HIBP in this fashion, not just to get it in front of as many people as possible, but because I  have a great deal of respect for their contributions to the technology community. In particular, <a href="https://en.wikipedia.org/wiki/Let%27s_Encrypt#History">Mozilla was instrumental in the birth of Let's Encrypt</a>, the free and open certificate authority that's massively increased the adoption of HTTPS on the web. Arguably, the work done by Mozilla's Josh Aas and Eric Rescorla (still the Mozilla CTO today) has been one of the greatest contributions to online privacy and security we've seen and <a href="https://letsencrypt.org/sponsors/">Mozilla remains a platinum sponsor to this day</a>. They've also been instrumental in helping define the model which HIBP uses to feed them data <em>without Mozilla disclosing the email addresses being searched for</em>. I'm going to talk more about the mechanics of that model in a moment but first, let me talk about 1Password:</p>
<h2 id="1password">1Password</h2>
<p>My relationship with 1Password stretches all the way back to 2011 when I came to the realisation that <a href="https://www.troyhunt.com/only-secure-password-is-one-you-cant/">the only secure password is the one you can't remember</a>. Over the last 7 years, I've continued to buy their product and use it every single day across all my devices <em>and</em> my entire family's devices. In February, only the day after I launched <a href="https://www.troyhunt.com/ive-just-launched-pwned-passwords-version-2/">Pwned Passwords V2</a>, 1Password turned around and built it into their product so that users of the password manager could see if their password had been previously exposed in a breach. That effort was a large factor in my <a href="https://www.troyhunt.com/have-i-been-pwned-is-now-partnering-with-1password/">choosing 1Password to partner with HIBP back in March</a> and since that time, they've built Pwned Passwords into the desktop apps for Mac and Windows and provided the ability to check all your passwords <em>in one single go</em>. But today, we're announcing something much bigger:</p>
<p><strong>As of now, you can search HIBP from directly within 1Password via the Watchtower feature in the web version of the product.</strong></p>
<p>This helps Watchtower become "mission control" for accounts and introduces the "Breach Report" feature:</p>
<p><img src="https://www.troyhunt.com/content/images/2018/06/1Password-Breach-Report.jpg" alt="1Password Breach Report"></p>
<p><img src="https://www.troyhunt.com/content/images/2018/06/1Password-Breach-Info.jpg" alt="1Password Breach Info"></p>
<p><img src="https://www.troyhunt.com/content/images/2018/06/1Password-Disqus-Breach.jpg" alt="1Password Disqus Breach"></p>
<p>As with Pwned Passwords, by pushing this out in the web-based version of the product they can get it to customers quickly then over time, bake it right into the desktop versions as well. There's also a bunch of other ways 1Password can use the data to streamline how users protect their accounts and that's something we're actively discussing. I expect we'll see the existing functionality enhanced in the not too distant future.</p>
<p>If you're a 1Password user you can use this feature right now, just head on over to <a href="https://start.1password.com/signin">the 1Password login page</a>. And if you're not already putting all your passwords in 1Password, go and <a href="https://1password.com/sign-up/">grab a free trial</a> and give it a go. You can also find a more detailed write-up on 1Password's implementation in the very aptly titled blog post: <a href="https://blog.agilebits.com/2018/06/25/watchtower-we-shall-fight-on-the-breaches/">we shall fight on the breaches</a> (why didn't I ever think of that?!)</p>
<h2 id="enablinganonymoussearcheswithkanonymity">Enabling Anonymous Searches with k-Anonymity</h2>
<p>I want to talk about protecting the identities of Firefox and 1Password users because more than ever - and regardless of where you are in the world - we're becoming increasingly conscious of our online privacy. We're also becoming increasingly connected and sharing unprecedented volumes of data which, let's face it, isn't exactly analogous with privacy and anonymity! But we <em>can</em> have both and I want to illustrate that by talking about <a href="https://haveibeenpwned.com/Passwords">the Pwned Passwords model</a> for a moment.</p>
<p>When this feature launched, Cloudflare (hat-tip again to <a href="https://twitter.com/icyapril">Junade Ali</a> there) did some great work on a "k-anonymity" model which works like this: when searching HIBP for a password, the client SHA-1 hashes it then takes the first 5 characters and sends this to the API. In response, a collection of hashes is returned that match that prefix (477 on average). By looking at the hash prefix sent to the service, I have no idea what the password is. It <em>could</em> be any one of those 477 or it could be something totally different, I don't know. Of course, I could always speculate based on the prevalence of each password but it would never be anything more than that - speculation. (Just to add to that, I've never got any idea of the username attached to the password either so even if I take an educated guess at it, there's nothing I can actually do with it.)</p>
<p>The email address being searched for by Firefox and 1Password works in the same fashion, albeit it with slightly different numbers due to the significantly larger data set at play. When I processed the source HIBP data in preparation for this feature, out of the 5B records in the system at the time there were 3.1B unique email addresses. (In other words, each address has been in an average of 1.6 data breaches.) I took each one of those 3.1B addresses, hashed it and stored it in a new data construct I'll talk about later. That gave me a repository to search against, now let's cover the mechanics of that search:</p>
<p>For the purposes of anonymity, I needed to decide on how many characters of the SHA-1 hash to allow searching by such that a sufficiently large number was returned to have no reasonable way of knowing which address was searched for, but also for the system to respond quickly. For Pwned Passwords, that number was 5 characters resulting in 16^5 possible search ranges which, across a data set of 500M records, meant the aforementioned 477 results per range. However, if I'd used 5 chars with the 3.1B email addresses, each range would contain an average of almost 3K results which is starting to get pretty sizeable.</p>
<p>Ultimately, I settled on 6 characters which means 16^6 possible ranges with an average of 185 results per range. Now, on the one hand you might say "that's less than Pwned Passwords therefore provides less protection", but it's a bit more nuanced than that. Firstly, because this number will grow <em>significantly</em> over time; more data breaches means more new email addresses means larger results in the range search. More importantly though, email addresses are <em>far</em> less predictable than passwords; as I mentioned earlier, if I was to spy on searches for Pwned Passwords (and I don't, but this is the threat k-anonymity is protecting us from), the prevalence of passwords in the system beginning with that hash can indicate the <em>likelihood</em> of what was searched by. But when we're talking about email addresses, there's no such indicator, certainly the number of breaches each has been exposed in divulges nothing in terms of which one is likely being searched for.</p>
<p>Here's what a search for an email address ultimately looks like:</p>
<pre><code>Address: test@example.com
SHA-1 hash: 567159D622FFBB50B11B0EFD307BE358624A26EE
6 char prefix: 567159
API endpoint: https://[host]/[path]/567159</code></pre>
<p>Which results in a response containing the following:</p>
<p><img src="https://www.troyhunt.com/content/images/2018/06/Pwned-Email-Range-Search-Result.png" alt="Pwned Email Range Search Result"></p>
<p>In this case, the searched address is the last one because the hash suffix matches with the SHA-1 hash of <a href="mailto:test@example.com">test@example.com</a>. The associated websites next to that hash are the ones that the email address appeared in and can be matched back to the full breach details via <a href="https://haveibeenpwned.com/API/v2#AllBreaches">the public breach list API</a>.</p>
<p>Unlike the way 1Password implements Pwned Passwords by calling the API directly from the client, this model is only consumable by an authenticated request from Firefox's or 1Password's infrastructure. What this means is that consumers only ever call their API then they call HIBP's API. Both these organisations implement all the same controls that HIBP does on the existing public email search API, namely the rate limit, not returning sensitive breaches to non-verified addresses and employing a range of other abuse-protection mechanisms. Why not call the API directly from each client? Let's talk about that next:</p>
<h2 id="theviabilityofusingthisapipublicly">The Viability of Using This API Publicly</h2>
<p>There's one fundamentally important (and perhaps quite obvious) reason why I don't expect to make this service available publicly: it could <em>massively</em> accelerate enumeration activities. Back in 2016, <a href="https://www.troyhunt.com/the-have-i-been-pwned-api-rate-limiting-and-commercial-use/">I implemented a rate limit on the public API</a> to greatly reduce the potential to abuse the service. This meant the ability to check records was limited to 1 request every 1,500ms. If I was to offer the k-anonymity service publicly, that jumps massively to 185 every 1,500ms (and it will grow as the data does) because that's how many results are returned. In fairness, you'd only get back hashed suffixes of email addresses but if someone had a <em>massive</em> list of them they wanted to work through (and that's one of the key patterns the rate limit is designed to curtail), they could hash the lot then grab those first 6 chars of each and get back a bunch of results in one go. Granted, they almost certainly wouldn't have the source email addresses of all 185 returned suffixes, but it still provides a vector to greatly accelerate search rates.</p>
<p>A (somewhat) middle ground, however, would be to allow searching the repository of hashed addresses by complete hash. Rather than the current model which needs a full email address, now that I have a mirrored data set containing only hashes I could always roll the search over to query that repository instead. I could also adapt the web front end to hash an entered email address client-side then only send that to the server. <a href="https://haveibeenpwned.uservoice.com/forums/275398-general/suggestions/8234421-allow-users-to-search-for-an-email-address-by-hash">I actually closed a User Voice idea along these lines</a> (and you can read about why in that idea), but now that I have that collection of hashes already in storage, it'd be trivial to stand up an endpoint to query it even if there's not always a lot of privacy upside. The main reason I can't do that immediately is that the email addresses for <a href="https://www.troyhunt.com/introducing-paste-searches-and/">the paste service</a> <em>are not hashed</em> and the existing search model on the website needs to search both sources.</p>
<p>And just on that, let me refer quickly back to my post on <a href="https://www.troyhunt.com/the-ethics-of-running-a-data-breach-search-service/">The Ethics of Running a Data Breach Search Service</a>. This explains in detail <em>why</em> the service allows addresses to be searched in the way it presently does and provides both technical and logical reasons. Do read that if you're curious, it was very carefully thought-out and explains the detailed thinking behind it.</p>
<h2 id="scalingsearcheswithazureandcloudflare">Scaling Searches with Azure and Cloudflare</h2>
<p>As with the k-anonymity model itself, I've leaned heavily on the Pwned Passwords experience in designing how this model works. <a href="https://www.troyhunt.com/azure-functions-in-practice/">Azure Functions</a> provide the API layer (they're serverless and scale beautifully) and Cloudflare does the reverse-proxying and caching. Unfortunately, I can't cache anywhere <em>near</em> as aggressively as with Pwned Passwords because instead of 16^5 different ranges (and therefore unique request patterns), it's 16^6. Also, I have a one-month cache expiration on Pwned Passwords because they rarely change but at present, only a 15-minute cache expiration on the email address search. I didn't want someone searching for a breach I'd just loaded, finding it in HIBP then <em>not</em> finding it in Firefox or 1Password.</p>
<p>One major difference between Pwned Passwords and this feature here is the underlying storage construct. For the passwords, <a href="https://www.troyhunt.com/i-wanna-go-fast-why-searching-through-500m-pwned-passwords-is-so-quick/">I ended up putting them all in blob storage</a> so there's one file per hash range. That was faster than the original Table Storage construct I used and because the files rarely ever change (I'll probably only update the passwords a couple of times a year), they could remain relatively static files. For emails in breaches, however, I don't have that luxury; breaches are continually loaded into the system and I needed a queryable construct that allowed for fast inserts and reads which means that like the existing HIBP email address storage, the hash ranges for this service are also in Azure Table Storage. It's an entirely separate table to the one that's been there from day one and just holds email addresses so obviously that's also impacted the data load process which now needs to do twice as much record handling.</p>
<p>What this means is that the entire record for <a href="mailto:test@example.com">test@example.com</a> looks like this:</p>
<pre><code>Partition key: 567159
Row key: D622FFBB50B11B0EFD307BE358624A26EE
Websites: [delimited array of pwned site names]</code></pre>
<p>Partitioning in this fashion means that when a search is done, it's easy to return every single suffix for the hash prefix which is used as the partition key. Some quick performance testing last week resulted in the following:</p>
<p><img src="https://www.troyhunt.com/content/images/2018/06/Distribution-of-Requests.png" alt="Distribution of Requests"></p>
<p>That's fine as a starting point and median load time of 280ms means that even with network latency and processing on Firefox's and 1Password's end should mean results are turned around in well under a second. Functions also seem to accelerate in execution time as infrastructure warms up so I expect we'll only see improvements in this area. I'll share some perf info once the volumes really ramp up.</p>
<p>Finally, like the existing search services and regardless of the fact requests only ever contain 6 characters of a hash, no searches are ever explicitly logged. They'll pass through very short-term transient logs and that's it - all I'll have is very broad-brush stats on things like the number of calls and the duration of executions. So, in summary, everything will be fast, efficient and above all, anonymous.</p>
<h2 id="thenotificationservice">The Notification Service</h2>
<p>Let me talk briefly about one last thing that's on the horizon - notifications. The service above is a point-in-time representation of breach state which is great, but clearly, it's a state that will continue to evolve over time. There needs to be a construct to notify Firefox and 1Password of <em>deltas</em> to the data set as new breaches are loaded so that in the future, they have the ability to offer subscriptions in the same way as <a href="https://haveibeenpwned.com/NotifyMe">the HIBP notification service</a>. Re-querying all the data every time a breach is loaded would be <em>massively</em> inefficient so that's not going to happen, we need to be smarter than that.</p>
<p>A few years back <a href="https://www.troyhunt.com/have-i-been-pwned-goes-little-bit/#mylifeandcallbacks">I wrote about a callback model</a> and an equivalent paradigm will be used here. What this boils down to is the ability to subscribe a hash prefix for notifications so in that <a href="mailto:test@example.com">test@example.com</a> scenario, "567159" would be subscribed then a callback sent to Firefox or 1Password when an address that hashes down to that prefix is loaded. The callback will contain the name of the breach that's just been loaded and all the hash suffixes for that prefix that were found in it.</p>
<p>I'm building that feature out next and in time I expect we'll see that flow through to Firefox and 1Password. It's a neat way of ensuring that anonymity is still protected <em>and</em> that subscribers of those services stay abreast of security incidents that impact them.</p>
<h2 id="summary">Summary</h2>
<p>As HIBP grows, I keep coming back to this question:</p>
<p><strong>How can HIBP do good things for people in the wake of bad events?</strong></p>
<p>I'm really happy this initiative furthers that objective and does it in a way that puts privacy first. The leverage these two organisations have to drive positive outcomes in the wake of data breaches is massive and I'm <em>enormously</em> excited to see the impact they both make in partnership with HIBP.</p>
<!--kg-card-end: markdown-->

            <section>
                <a href="https://www.troyhunt.com/tag/have-i-been-pwned-3f/">Have I Been Pwned</a>
                <a href="https://www.troyhunt.com/tag/1password/">1Password</a>
            </section>
        </section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>