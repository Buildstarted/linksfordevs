<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Hands-on Scala Programming - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Hands-on Scala Programming - linksfor.dev(s)"/>
    <meta property="og:description" content="Hands-on Scala teaches you how to use the Scala programming language in a&#xA;practical, project-based fashion. This book is designed to quickly teach an&#xA;experienced software engineer everything they need to build all sorts of&#xA;production applications using Scala."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.handsonscala.com/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Hands-on Scala Programming</title>
<div class="readable">
        <h1>Hands-on Scala Programming</h1>
            <div>Reading time: 21-27 minutes</div>
        <div>Posted here: 19 Apr 2020</div>
        <p><a href="https://www.handsonscala.com/">https://www.handsonscala.com/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div id="nav-tabContent"><div id="list-chapter-1" role="tabpanel" aria-labelledby="list-chapter-1-list"><div id="table-of-contents-1-preview"><hr><table><tbody><tr><td>1.1 Expected Audience</td><td><a>16</a></td></tr><tr><td>1.2 Why Scala?</td><td><a>17</a></td></tr><tr><td>1.3 Why This Book?</td><td><a>17</a></td></tr><tr><td>1.4 How This Book Is Organized</td><td><a>19</a></td></tr><tr><td>1.5 Code Snippet Conventions</td><td><a>19</a></td></tr></tbody></table><hr><pre><code><b><span>package</span> app
<span>object</span> MinimalApplication <span>extends</span> cask<span>.</span>MainRoutes<span>{</span>
  <span>@cask</span><span>.</span>get<span>(</span><span>"/"</span><span>)</span>
  <span>def</span> hello<span>(</span><span>)</span> <span>=</span> <span>{</span>
    <span>"Hello World!"</span>
  <span>}</span>

  initialize<span>(</span><span>)</span>
<span>}</span>
</b></code></pre><p><em>Hands-on Scala</em> teaches you how to use the Scala programming language in a
practical, project-based fashion. This book is designed to quickly teach an
experienced software engineer everything they need to build all sorts of
production applications using Scala.</p><p>In working through this book, you will not only become familiar with the Scala
language itself, but also learn the concrete skills necessary to anyone
using the language professionally: handling files &amp; processes, JSON and
structured data, third-party APIs, web servers, databases, concurrency,
and so on. <em>Hands-on Scala</em> will guide you through completing several non-trivial
projects which reflect the applications you may end up building as part of a
software engineering job, so you can quickly hit the ground running using Scala
professionally.</p><p><em>(Code snippet: a tiny example Scala web application, one of many Scala programs
we will encounter in this book)</em></p></div></div><div id="list-chapter-2" role="tabpanel" aria-labelledby="list-chapter-2-list"><div id="table-of-contents-2-preview"><hr><table><tbody><tr><td>2.1 Windows Setup (Optional)</td><td><a>26</a></td></tr><tr><td>2.2 Installing Java</td><td><a>27</a></td></tr><tr><td>2.3 Installing Ammonite</td><td><a>28</a></td></tr><tr><td>2.4 Installing Mill</td><td><a>32</a></td></tr><tr><td>2.5 IDE Support</td><td><a>36</a></td></tr></tbody></table><hr><pre><code><b>$ amm</b>
<i>Loading...
Welcome to the Ammonite Repl 2.0.4 (Scala 2.13.1 Java 11.0.2)
</i><b>@ <span>1</span> <span>+</span> <span>1</span></b>
<i>res0<span>:</span> <span>Int</span> <span>=</span> <span>2</span>

</i><b>@ println<span>(</span><span>"hello world"</span> <span>+</span> <span>"!"</span> <span>*</span> <span>10</span><span>)</span></b>
<i>hello world<span>!</span><span>!</span><span>!</span><span>!</span><span>!</span><span>!</span><span>!</span><span>!</span><span>!</span><span>!</span>
</i></code></pre><p>In this chapter, we will set up a simple Scala programming environment, giving
you the ability to write, run, and test your Scala code. It will be a simple
setup, but enough so you can immediately get into the meat of the Scala language
and start being productive.</p><p><em>(Code snippet: getting started with the Ammonite Scala REPL)</em></p></div></div><div id="list-chapter-3" role="tabpanel" aria-labelledby="list-chapter-3-list"><div id="table-of-contents-3-preview"><hr><table><tbody><tr><td>3.1 Values</td><td><a>44</a></td></tr><tr><td>3.2 Loops, Conditionals, Comprehensions</td><td><a>51</a></td></tr><tr><td>3.3 Methods and Functions</td><td><a>55</a></td></tr><tr><td>3.4 Classes and Traits</td><td><a>58</a></td></tr></tbody></table><hr><pre><code><b><span>for</span><span>(</span>i <span>&lt;-</span> Range<span>.</span>inclusive<span>(</span><span>1</span><span>,</span> <span>100</span><span>)</span><span>)</span><span>{</span>
  println<span>(</span>
    <span>if</span> <span>(</span>i <span>%</span> <span>3</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> i <span>%</span> <span>5</span> <span>==</span> <span>0</span><span>)</span> <span>"FizzBuzz"</span>
    <span>else</span> <span>if</span> <span>(</span>i <span>%</span> <span>3</span> <span>==</span> <span>0</span><span>)</span> <span>"Fizz"</span>
    <span>else</span> <span>if</span> <span>(</span>i <span>%</span> <span>5</span> <span>==</span> <span>0</span><span>)</span> <span>"Buzz"</span>
    <span>else</span> i
  <span>)</span>
<span>}</span>
</b></code></pre><p>This chapter is a quick tour of the Scala language. For now we will focus on the
basics of Scala that are similar to what you might find in any mainstream
programming language.</p><p>The goal of this chapter is to get familiar enough that you can take code
written in some other mainstream language and port it to Scala without
difficulty. This chapter will not covering any Scala-specific programming styles
or language features: those will be left for <b><i>Chapter 5: Notable Scala Features</i></b>.</p><p><em>(Code snippet: the popular "FizzBuzz" programming challenge, implemented in
Scala)</em></p></div></div><div id="list-chapter-4" role="tabpanel" aria-labelledby="list-chapter-4-list"><div id="table-of-contents-4-preview"><hr><table><tbody><tr><td>4.1 Operations</td><td><a>62</a></td></tr><tr><td>4.2 Immutable Collections</td><td><a>68</a></td></tr><tr><td>4.3 Mutable Collections</td><td><a>75</a></td></tr><tr><td>4.4 Common Interfaces</td><td><a>79</a></td></tr></tbody></table><hr><pre><code><b>@ <span>def</span> stdDev<span>(</span>a<span>:</span> Array<span>[</span><span>Double</span><span>]</span><span>)</span><span>:</span> <span>Double</span> <span>=</span> <span>{</span>
    <span>val</span> mean <span>=</span> a<span>.</span>sum <span>/</span> a<span>.</span>length
    <span>val</span> squareErrors <span>=</span> a<span>.</span>map<span>(</span>x <span>=&gt;</span> x <span>-</span> mean<span>)</span><span>.</span>map<span>(</span>x <span>=&gt;</span> x <span>*</span> x<span>)</span>
    math<span>.</span>sqrt<span>(</span>squareErrors<span>.</span>sum <span>/</span> a<span>.</span>length<span>)</span>
  <span>}</span>
</b></code></pre><p>The core of the Scala standard library is its <em>collections</em>: a common set of
containers and data structures that are shared by all Scala programs. Scala's
collections make it easy for you to manipulate arrays, linked lists, sets, maps
and other data structures in convenient ways, providing built-in many of the
data structures needed for implementing your application.</p><p>This chapter will walk through the common operations that apply to all
collection types, before discussing the individual data structures that are
available and when you might use each of them in practice.</p><p><em>(Code snippet: calculating the standard deviation of an array using Scala
Collection operations)</em></p></div></div><div id="list-chapter-5" role="tabpanel" aria-labelledby="list-chapter-5-list"><div id="table-of-contents-5-preview"><hr><table><tbody><tr><td>5.1 Case Classes and Sealed Traits</td><td><a>82</a></td></tr><tr><td>5.2 Pattern Matching</td><td><a>84</a></td></tr><tr><td>5.3 By-Name Parameters</td><td><a>90</a></td></tr><tr><td>5.4 Implicit Parameters</td><td><a>92</a></td></tr><tr><td>5.5 Typeclass Inference</td><td><a>94</a></td></tr></tbody></table><hr><pre><code><b>@ <span>def</span> getDayMonthYear<span>(</span>s<span>:</span> <span>String</span><span>)</span> <span>=</span> s <span>match</span><span>{</span>
    <span>case</span> s<span>"</span><span>$</span>day<span>-</span><span>$</span>month<span>-</span><span>$</span>year<span>"</span> <span>=&gt;</span> println<span>(</span>s<span>"found day: </span><span>$</span>day<span>, month: </span><span>$</span>month<span>, year: </span><span>$</span>year<span>"</span><span>)</span>
    <span>case</span> _ <span>=&gt;</span> println<span>(</span><span>"not a date"</span><span>)</span>
  <span>}</span>

</b><b>@ getDayMonthYear<span>(</span><span>"9-8-1965"</span><span>)</span></b>
<i>found day<span>:</span> <span>9</span><span>,</span> month<span>:</span> <span>8</span><span>,</span> year<span>:</span> <span>1965</span>

</i><b>@ getDayMonthYear<span>(</span><span>"9-8"</span><span>)</span></b>
<i>not a date
</i></code></pre><p>This chapter will cover some of the more interesting and unusual features of
Scala that are not found in mainstream programming languages. For each such
feature, we will cover both what the feature does as well as some common use
cases to give you an intuition for what the it is useful for.</p><p>Not every feature covered will be something you use day-to-day: while <em>Case
Classes</em> and <em>Pattern Matching</em> you will use regularly, <em>By-Name Parameters</em> you
will only encounter infrequently, and <em>Implicit Parameters</em> only when used in
libraries and frameworks. Nevertheless, even these less-commonly-used features
are used often enough that it is valuable to have a high-level understanding for
when you eventually encounter them in the wild.</p><p><em>(Code snippet: using Scala's pattern matching feature to parse simple string
patterns)</em></p></div></div><div id="list-chapter-6" role="tabpanel" aria-labelledby="list-chapter-6-list"><div id="table-of-contents-6-preview"><hr><table><tbody><tr><td>6.1 Merge Sort</td><td><a>106</a></td></tr><tr><td>6.2 Prefix Tries</td><td><a>110</a></td></tr><tr><td>6.3 Breadth First Search</td><td><a>117</a></td></tr><tr><td>6.4 Shortest Paths</td><td><a>120</a></td></tr></tbody></table><hr><pre><code><b><span>def</span> breadthFirstSearch<span>[</span>T<span>]</span><span>(</span>start<span>:</span> T<span>,</span> graph<span>:</span> Map<span>[</span>T<span>,</span> Seq<span>[</span>T<span>]</span><span>]</span><span>)</span><span>:</span> Set<span>[</span>T<span>]</span> <span>=</span> <span>{</span>
  <span>val</span> seen <span>=</span> collection<span>.</span>mutable<span>.</span>Set<span>(</span>start<span>)</span>
  <span>val</span> queue <span>=</span> collection<span>.</span>mutable<span>.</span>ArrayDeque<span>(</span>start<span>)</span>
  <span>while</span><span>(</span>queue<span>.</span>nonEmpty<span>)</span><span>{</span>
    <span>val</span> current <span>=</span> queue<span>.</span>removeHead<span>(</span><span>)</span>
    <span>for</span><span>(</span>next <span>&lt;-</span> graph<span>(</span>current<span>)</span> <span>if</span> <span>!</span>seen<span>(</span>next<span>)</span><span>)</span><span>{</span>
      seen<span>.</span>add<span>(</span>next<span>)</span>
      queue<span>.</span>append<span>(</span>next<span>)</span>
    <span>}</span>
  <span>}</span>
  seen<span>.</span>toSet
<span>}</span>
</b></code></pre><p>In this chapter, we will walk you through the implementation of a number of
common algorithms using the Scala programming language. These algorithms are
commonly taught in schools and tested at professional job interviews, and you
likely will have been exposed to them before.</p><p>By implementing them in Scala, we aim to get you more familiar with using the
Scala programming language to solve small problems in isolation. We will also
see how some of the unique languages features we saw in <b><i>Chapter 5: Notable Scala Features</i></b> can be applied to simplify the implementation of these
well-known algorithms. This will prepare us for subsequent chapters which will
expand in scope to include many different kinds of systems, APIs, tools and
techniques.</p><p><em>(Code snippet: a simple breadth-first-search algorithm we will implement using
Scala in this chapter)</em></p></div></div><div id="list-chapter-7" role="tabpanel" aria-labelledby="list-chapter-7-list"><div id="table-of-contents-7-preview"><hr><table><tbody><tr><td>7.1 Paths</td><td><a>124</a></td></tr><tr><td>7.2 Filesystem Operations</td><td><a>127</a></td></tr><tr><td>7.3 Folder Syncing</td><td><a>132</a></td></tr><tr><td>7.4 Simple Subprocess Invocations</td><td><a>136</a></td></tr><tr><td>7.5 Interactive and Streaming Subprocesses</td><td><a>139</a></td></tr></tbody></table><hr><pre><code><b>@ os<span>.</span>walk<span>(</span>os<span>.</span>pwd<span>)</span><span>.</span>filter<span>(</span>os<span>.</span>isFile<span>)</span><span>.</span>map<span>(</span>p <span>=&gt;</span> <span>(</span>os<span>.</span>size<span>(</span>p<span>)</span><span>,</span> p<span>)</span><span>)</span><span>.</span>sortBy<span>(</span><span>-</span>_<span>.</span>_1<span>)</span><span>.</span>take<span>(</span><span>5</span><span>)</span></b>
<i>res60<span>:</span> IndexedSeq<span>[</span><span>(</span><span>Long</span><span>,</span> os<span>.</span>Path<span>)</span><span>]</span> <span>=</span> ArrayBuffer<span>(</span>
  <span>(</span><span>6340270L</span><span>,</span> <span>/</span>Users<span>/</span>lihaoyi<span>/</span>test<span>/</span>post<span>/</span>Reimagining<span>/</span>GithubHistory<span>.</span>gif<span>)</span><span>,</span>
  <span>(</span><span>6008395L</span><span>,</span> <span>/</span>Users<span>/</span>lihaoyi<span>/</span>test<span>/</span>post<span>/</span>SmartNation<span>/</span>routes<span>.</span>json<span>)</span><span>,</span>
  <span>(</span><span>5499949L</span><span>,</span> <span>/</span>Users<span>/</span>lihaoyi<span>/</span>test<span>/</span>post<span>/</span>slides<span>/</span>Why<span>-</span>You<span>-</span>Might<span>-</span>Like<span>-</span>Scala<span>.</span>js<span>.</span>pdf<span>)</span><span>,</span>
  <span>(</span><span>5461595L</span><span>,</span> <span>/</span>Users<span>/</span>lihaoyi<span>/</span>test<span>/</span>post<span>/</span>slides<span>/</span>Cross<span>-</span>Platform<span>-</span>Development<span>-</span>in<span>-</span>Scala<span>.</span>js<span>.</span>pdf<span>)</span><span>,</span>
  <span>(</span><span>4576936L</span><span>,</span> <span>/</span>Users<span>/</span>lihaoyi<span>/</span>test<span>/</span>post<span>/</span>Reimagining<span>/</span>FluentSearch<span>.</span>gif<span>)</span>
<span>)</span>
</i></code></pre><p>Working with files and subprocesses is one of the most common things you do when
programming: from the Bash shell, to Python or Ruby scripts, to large
applications written in a compiled language. This chapter will walk you through
how to perform basic file and subprocess operations in Scala.</p><p>This chapter finishes with two small projects: building a simple file
synchronizer, and building a streaming subprocess pipeline, which will form the
basis of <b><i>Chapter 17: Multi-Process Applications</i></b> and <b><i>Chapter 18: Building a Real-time File Synchronizer</i></b></p><p><em>(Code snippet: a short Scala code snippet to find the five largest files in a
directory tree)</em></p></div></div><div id="list-chapter-8" role="tabpanel" aria-labelledby="list-chapter-8-list"><div id="table-of-contents-8-preview"><hr><table><tbody><tr><td>8.1 Reading and Generating JSON</td><td><a>146</a></td></tr><tr><td>8.2 Modifying and Traversing JSON</td><td><a>149</a></td></tr><tr><td>8.3 JSON Serialization of Scala Data Types</td><td><a>150</a></td></tr><tr><td>8.4 Writing your own Generic Serialization Methods</td><td><a>156</a></td></tr><tr><td>8.5 Binary Serialization</td><td><a>158</a></td></tr></tbody></table><hr><pre><code><b>@ <span>val</span> output <span>=</span> ujson<span>.</span>Arr<span>(</span>
    ujson<span>.</span>Obj<span>(</span><span>"hello"</span> <span>-&gt;</span> <span>"world"</span><span>,</span> <span>"answer"</span> <span>-&gt;</span> <span>42</span><span>)</span><span>,</span>
    <span>true</span>
  <span>)</span>

</b><b>@ println<span>(</span>output<span>)</span></b>
<i><span>[</span><span>{</span><span>"hello"</span><span>:</span><span>"world"</span><span>,</span><span>"answer"</span><span>:</span><span>42</span><span>}</span><span>,</span><span>true</span><span>]</span>

</i><b>@ output<span>(</span><span>0</span><span>)</span><span>(</span><span>"hello"</span><span>)</span> <span>=</span> <span>"goodbye"</span>

</b><b>@ output<span>(</span><span>0</span><span>)</span><span>(</span><span>"tags"</span><span>)</span> <span>=</span> ujson<span>.</span>Arr<span>(</span><span>"awesome"</span><span>,</span> <span>"yay"</span><span>,</span> <span>"wonderful"</span><span>)</span>

</b><b>@ println<span>(</span>output<span>)</span></b>
<i><span>[</span><span>{</span><span>"hello"</span><span>:</span><span>"goodbye"</span><span>,</span><span>"answer"</span><span>:</span><span>42</span><span>,</span><span>"tags"</span><span>:</span><span>[</span><span>"awesome"</span><span>,</span><span>"yay"</span><span>,</span><span>"wonderful"</span><span>]</span><span>}</span><span>,</span><span>true</span><span>]</span>
</i></code></pre><p>Data serialization is an important tool in any programmer's toolbox. While your
variables and classes suffice to store data within a program, most data tends to
outlive a single program process: whether saved to disk, exchanged between
processes, or sent over the network. This chapter will cover how to serialize
your Scala data structures to two common data formats - textual JSON and binary
MessagePack - and how you can interact with</p><p>The JSON workflows we learn in this chapter will be used later in <b><i>Chapter 12: Working with HTTP APIs</i></b> and <b><i>Chapter 14: Simple Web and API Servers</i></b>, while the
binary serialization techniques we learn here will be used later in <b><i>Chapter 17: Multi-Process Applications</i></b>.</p><p><em>(Code snippet: manipulating a JSON tree structure in the Scala REPL)</em></p></div></div><div id="list-chapter-9" role="tabpanel" aria-labelledby="list-chapter-9-list"><div id="table-of-contents-9-preview"><hr><table><tbody><tr><td>9.1 Reading Files Off Disk</td><td><a>164</a></td></tr><tr><td>9.2 Using a Scala HTML Library</td><td><a>165</a></td></tr><tr><td>9.3 Using a Java Markdown Library</td><td><a>167</a></td></tr><tr><td>9.4 Links and Bootstrap</td><td><a>172</a></td></tr></tbody></table><hr><pre><code><b>os<span>.</span>write<span>(</span>
  os<span>.</span>pwd <span>/</span> <span>"out"</span> <span>/</span> <span>"index.html"</span><span>,</span>
  doctype<span>(</span><span>"html"</span><span>)</span><span>(</span>
    html<span>(</span>
      body<span>(</span>
        h1<span>(</span><span>"Blog"</span><span>)</span><span>,</span>
        <span>for</span><span>(</span><span>(</span>_<span>,</span> suffix<span>,</span> _<span>)</span> <span>&lt;-</span> postInfo<span>)</span>
        <span>yield</span> h2<span>(</span>a<span>(</span>href <span>:</span><span>=</span> <span>(</span><span>"post/"</span> <span>+</span> mdNameToHtml<span>(</span>suffix<span>)</span><span>)</span><span>)</span><span>(</span>suffix<span>)</span><span>)</span>
      <span>)</span>
    <span>)</span>
  <span>)</span>
<span>)</span>
</b></code></pre><p>Scala Scripts are a great way to write small programs. Each script is
self-contained and can download its own dependencies when necessary, letting you
write and distribute scripts without spending time fiddling with build
configuration or library installation.</p><p>In this chapter, we make use of Scala's ability to write self-contained scripts
for a small project: writing a static site generator using Scala. We will write
with a script that uses third-party libraries to processes Markdown input files
and generate a set of HTML output files that are ready for deployment on any
static file hosting service. This will form the foundation for <b><i>Chapter 10: Static Build Pipelines</i></b>, where we will turn the static site generator into an
incremental build pipeline by using the Mill build tool.</p><p><em>(Code snippet: rendering a HTML page using the third-party Scalatags HTML
library)</em></p></div></div><div id="list-chapter-10" role="tabpanel" aria-labelledby="list-chapter-10-list"><div id="table-of-contents-10-preview"><hr><table><tbody><tr><td>10.1 Mill Build Pipelines</td><td><a>180</a></td></tr><tr><td>10.2 Mill Modules</td><td><a>184</a></td></tr><tr><td>10.3 Revisiting Our Static Site Script</td><td><a>188</a></td></tr><tr><td>10.4 Conversion to a Mill Build Pipeline</td><td><a>188</a></td></tr><tr><td>10.5 Extending Your Static Site Pipeline</td><td><a>191</a></td></tr></tbody></table><hr><pre><code><b><span>def</span> sources <span>=</span> T<span>.</span>source<span>(</span>os<span>.</span>pwd <span>/</span> <span>"src"</span><span>)</span>

<span>def</span> concat <span>=</span> T<span>{</span>
  os<span>.</span>write<span>(</span>T<span>.</span>dest <span>/</span> <span>"concat.txt"</span><span>,</span>  os<span>.</span>list<span>(</span>srcs<span>(</span><span>)</span><span>.</span>path<span>)</span><span>.</span>map<span>(</span>os<span>.</span>read<span>(</span>_<span>)</span><span>)</span><span>)</span>
  PathRef<span>(</span>T<span>.</span>dest <span>/</span> <span>"concat.txt"</span><span>)</span>
<span>}</span>
</b></code></pre><p>Build pipelines are a common pattern, where you have files and assets you want
to process but want to do so efficiently and incrementally. This usually means
only re-processing files when they change, and otherwise re-using the already
processed assets as much as possible.</p><p>This chapter will walk through how to use the
<a>Mill build tool</a> to set up these build pipelines,
and demonstrate the advantages a build pipeline gives you over a naive build
script. We will take the the simple static site generator we wrote in <b><i>Chapter 9: Self-Contained Scala Scripts</i></b> and convert it into an efficient build pipeline
that can incrementally update the static site as you make changes to the
sources. We will be using the Mill build tool in several of the projects later
in the book, starting with <b><i>Chapter 14: Simple Web and API Servers</i></b>.</p><p><em>(Code snippet: the definition of a simple Mill build pipeline)</em></p></div></div><div id="list-chapter-11" role="tabpanel" aria-labelledby="list-chapter-11-list"><div id="table-of-contents-11-preview"><hr><table><tbody><tr><td>11.1 Scraping Wikipedia</td><td><a>202</a></td></tr><tr><td>11.2 MDN Web Documentation</td><td><a>206</a></td></tr><tr><td>11.3 Scraping MDN</td><td><a>208</a></td></tr><tr><td>11.4 Putting it Together</td><td><a>213</a></td></tr></tbody></table><hr><pre><code><b>@ <span>import</span> $ivy<span>.</span>`org<span>.</span>jsoup<span>:</span>jsoup<span>:</span><span>1.12</span><span>.1</span>`<span>,</span> org<span>.</span>jsoup<span>.</span>_

</b><b>@ <span>val</span> doc <span>=</span> Jsoup<span>.</span>connect<span>(</span><span>"http://en.wikipedia.org/"</span><span>)</span><span>.</span>get<span>(</span><span>)</span>

</b><b>@ doc<span>.</span>title<span>(</span><span>)</span></b>
<i>res4<span>:</span> <span>String</span> <span>=</span> <span>"Wikipedia, the free encyclopedia"</span>

</i><b>@ <span>val</span> headlines <span>=</span> doc<span>.</span>select<span>(</span><span>"#mp-itn b a"</span><span>)</span></b>
<i>headlines<span>:</span> select<span>.</span>Elements <span>=</span>
<span>&lt;</span>a href<span>=</span><span>"/wiki/Bek_Air_Flight_2100"</span> title<span>=</span><span>"Bek Air Flight 2100"</span><span>&gt;</span>Bek Air Flight <span>2100</span><span>&lt;</span><span>/</span>a<span>&gt;</span>
<span>&lt;</span>a href<span>=</span><span>"/wiki/Assassination_of_..."</span> title<span>=</span><span>"Assassination of ..."</span><span>&gt;</span><span>2018</span> killing<span>&lt;</span><span>/</span>a<span>&gt;</span>
<span>&lt;</span>a href<span>=</span><span>"/wiki/State_of_the_..."</span> title<span>=</span><span>"State of the..."</span><span>&gt;</span>upholds a ruling<span>&lt;</span><span>/</span>a<span>&gt;</span>
<span>.</span><span>.</span><span>.</span>
</i></code></pre><p>The user-facing interface of most networked systems is a website. In fact, often
that is the <em>only</em> interface: not every system exposes their data through a JSON
API, and in many cases the HTML page shown to users is all you get. This chapter
will walk you through using Scala to scrape useful information from
human-readable HTML pages, unlocking the ability to extract data from online
websites or services that were never designed for programmatic access via an
API.</p><p><em>(Code snippet: scraping Wikipedia's front-page links using the Jsoup
third-party library in the Scala REPL)</em></p></div></div><div id="list-chapter-12" role="tabpanel" aria-labelledby="list-chapter-12-list"><div id="table-of-contents-12-preview"><hr><table><tbody><tr><td>12.1 The Task: Github Issue Migrator</td><td><a>219</a></td></tr><tr><td>12.2 Creating Issues and Comments</td><td><a>221</a></td></tr><tr><td>12.3 Fetching Issues and Comments</td><td><a>223</a></td></tr><tr><td>12.4 Migrating Issues and Comments</td><td><a>228</a></td></tr></tbody></table><hr><pre><code><b>@ requests<span>.</span>post<span>(</span>
    <span>"https://api.github.com/repos/lihaoyi/test/issues"</span><span>,</span>
    data <span>=</span> ujson<span>.</span>Obj<span>(</span><span>"title"</span> <span>-&gt;</span> <span>"hello"</span><span>)</span><span>,</span>
    headers <span>=</span> Map<span>(</span><span>"Authorization"</span> <span>-&gt;</span> s<span>"token </span><span>$</span>token<span>"</span><span>)</span>
  <span>)</span></b>
<i>res56<span>:</span> requests<span>.</span>Response <span>=</span> Response<span>(</span>
  <span>"https://api.github.com/repos/lihaoyi/test/issues"</span><span>,</span>
  <span>201</span><span>,</span>
  <span>"Created"</span><span>,</span>
<span>.</span><span>.</span><span>.</span>
</i></code></pre><p>HTTP APIs have become the standard for any organization that is intentionally
exposing parts of their system publicly for external developers to work with.
This chapter will walk you through how to access HTTP APIs in Scala, building up
to a simple use case: migrating Github issues from one repository to another
using Github's public API.</p><p>We will build upon techniques learned in this chapter in <b><i>Chapter 13: Fork-Join Parallelism with Futures</i></b>, where we will be writing a parallel web crawler using
the Wikipedia JSON API to walk the graph of articles and the links between them.</p><p><em>(Code snippet: interacting with Github's HTTP API from the Scala REPL)</em></p></div></div><div id="list-chapter-13" role="tabpanel" aria-labelledby="list-chapter-13-list"><div id="table-of-contents-13-preview"><hr><table><tbody><tr><td>13.1 Parallel Computation using Futures</td><td><a>236</a></td></tr><tr><td>13.2 N-Ways Parallelism</td><td><a>240</a></td></tr><tr><td>13.3 A Parallel Web Crawler</td><td><a>243</a></td></tr><tr><td>13.4 Asynchronous Futures</td><td><a>250</a></td></tr><tr><td>13.5 Asynchronous Web Crawling</td><td><a>253</a></td></tr></tbody></table><hr><pre><code><b><span>def</span> fetchAllLinksParallel<span>(</span>startTitle<span>:</span> <span>String</span><span>,</span> depth<span>:</span> <span>Int</span><span>)</span><span>:</span> Set<span>[</span><span>String</span><span>]</span> <span>=</span> <span>{</span>
  <span>var</span> seen <span>=</span> Set<span>(</span>startTitle<span>)</span>
  <span>var</span> current <span>=</span> Set<span>(</span>startTitle<span>)</span>
  <span>for</span><span>(</span>i <span>&lt;-</span> Range<span>(</span><span>0</span><span>,</span> depth<span>)</span><span>)</span><span>{</span>
    <span>val</span> futures <span>=</span> <span>for</span><span>(</span>title <span>&lt;-</span> current<span>)</span> <span>yield</span> Future<span>{</span> fetchLinks<span>(</span>title<span>)</span> <span>}</span>
    <span>val</span> nextTitleLists <span>=</span> futures<span>.</span>map<span>(</span>Await<span>.</span>result<span>(</span>_<span>,</span> Inf<span>)</span><span>)</span>
    current <span>=</span> nextTitleLists<span>.</span>flatten<span>.</span>filter<span>(</span><span>!</span>seen<span>.</span>contains<span>(</span>_<span>)</span><span>)</span>
    seen <span>=</span> seen <span>++</span> nextTitleLists<span>.</span>flatten
  <span>}</span>
  seen
<span>}</span>
</b></code></pre><p>The Scala programming language comes with a Futures API. Futures make parallel
programming much easier to handle than working with traditional techniques of
threads, locks, and callbacks.</p><p>This chapter dives into Scala's Futures: how to use them, how they work, and how
you can use them to parallelize data processing workflows. It culminates in
using Futures together with the techniques we learned in <b><i>Chapter 12: Working with HTTP APIs</i></b> to write a high-performance parallel web crawler in a way that
is straightforward and intuitive.</p><p><em>(Code snippet: a simple parallel web-crawling implemented using Scala Futures)</em></p></div></div><div id="list-chapter-14" role="tabpanel" aria-labelledby="list-chapter-14-list"><div id="table-of-contents-14-preview"><hr><table><tbody><tr><td>14.1 A Minimal Webserver</td><td><a>260</a></td></tr><tr><td>14.2 Serving HTML</td><td><a>264</a></td></tr><tr><td>14.3 Forms and Data</td><td><a>266</a></td></tr><tr><td>14.4 Dynamic Updates via JSON API Requests</td><td><a>272</a></td></tr><tr><td>14.5 Real-time Updates with Websockets</td><td><a>276</a></td></tr></tbody></table><hr><pre><code><b><span>object</span> MinimalApplication <span>extends</span> cask<span>.</span>MainRoutes<span>{</span>
  <span>@cask</span><span>.</span>get<span>(</span><span>"/"</span><span>)</span>
  <span>def</span> hello<span>(</span><span>)</span> <span>=</span> <span>{</span>
    <span>"Hello World!"</span>
  <span>}</span>

  <span>@cask</span><span>.</span>post<span>(</span><span>"/do-thing"</span><span>)</span>
  <span>def</span> doThing<span>(</span>request<span>:</span> cask<span>.</span>Request<span>)</span> <span>=</span> <span>{</span>
    request<span>.</span>text<span>(</span><span>)</span><span>.</span>reverse
  <span>}</span>

  initialize<span>(</span><span>)</span>
<span>}</span>
</b></code></pre><p>Web and API servers are the backbone of internet systems. While in <b><i>Chapter 12: Working with HTTP APIs</i></b> and <b><i>Chapter 11: Scraping Websites</i></b> we learned to to
access these APIs and Websites from a <em>client's</em> perspective, this chapter will
teach you how to provide such APIs and Websites from the <em>server's</em> perspective.</p><p>We will walk through a complete example of building a simple real-time chat
website serving both HTML web pages and JSON API endpoints. We will re-visit
this website in <b><i>Chapter 15: Querying SQL Databases</i></b>, where will convert its
simple in-memory datastore into a proper SQL database.</p><p><em>(Code snippet: a minimal Scala web application, using the Cask web framework)</em></p></div></div><div id="list-chapter-15" role="tabpanel" aria-labelledby="list-chapter-15-list"><div id="table-of-contents-15-preview"><hr><table><tbody><tr><td>15.1 Setting up Quill and PostgreSQL</td><td><a>282</a></td></tr><tr><td>15.2 Mapping Tables to Case Classes</td><td><a>284</a></td></tr><tr><td>15.3 Querying and Updating Data</td><td><a>287</a></td></tr><tr><td>15.4 Transactions</td><td><a>292</a></td></tr><tr><td>15.5 A Database-Backed Chat Website</td><td><a>293</a></td></tr></tbody></table><hr><pre><code><b>@ ctx<span>.</span>run<span>(</span>query<span>[</span>City<span>]</span><span>.</span>filter<span>(</span>_<span>.</span>population <span>&gt;</span> <span>5000000</span><span>)</span><span>.</span>filter<span>(</span>_<span>.</span>countryCode <span>==</span> <span>"CHN"</span><span>)</span><span>)</span></b>
<i>res16<span>:</span> List<span>[</span>City<span>]</span> <span>=</span> List<span>(</span>
  City<span>(</span><span>1890</span><span>,</span> <span>"Shanghai"</span><span>,</span> <span>"CHN"</span><span>,</span> <span>"Shanghai"</span><span>,</span> <span>9696300</span><span>)</span><span>,</span>
  City<span>(</span><span>1891</span><span>,</span> <span>"Peking"</span><span>,</span> <span>"CHN"</span><span>,</span> <span>"Peking"</span><span>,</span> <span>7472000</span><span>)</span><span>,</span>
  City<span>(</span><span>1892</span><span>,</span> <span>"Chongqing"</span><span>,</span> <span>"CHN"</span><span>,</span> <span>"Chongqing"</span><span>,</span> <span>6351600</span><span>)</span><span>,</span>
  City<span>(</span><span>1893</span><span>,</span> <span>"Tianjin"</span><span>,</span> <span>"CHN"</span><span>,</span> <span>"Tianjin"</span><span>,</span> <span>5286800</span><span>)</span>
<span>)</span>
</i></code></pre><p>Most modern systems are backed by relational databases. This chapter will walk
you through the basics of using a relational database from Scala, using the
Quill query library. We will work through small self-contained examples of how
to store and query data within a Postgres database, and finish with converting
the interactive chat website we implemented in <b><i>Chapter 14: Simple Web and API Servers</i></b> to use a Postgres database for data storage.</p><p><em>(Code snippet: querying a database using the Quill database query library, from
the Scala REPL)</em></p></div></div><div id="list-chapter-16" role="tabpanel" aria-labelledby="list-chapter-16-list"><div id="table-of-contents-16-preview"><hr><table><tbody><tr><td>16.1 Castor Actors</td><td><a>302</a></td></tr><tr><td>16.2 Actor-based Background Uploads</td><td><a>303</a></td></tr><tr><td>16.3 Concurrent Logging Pipelines</td><td><a>309</a></td></tr><tr><td>16.4 Debugging Actors</td><td><a>315</a></td></tr></tbody></table><hr><pre><code><b><span>class</span> SimpleUploadActor<span>(</span><span>)</span><span>(</span><span>implicit</span> cc<span>:</span> castor<span>.</span>Context<span>)</span> <span>extends</span> castor<span>.</span>SimpleActor<span>[</span><span>String</span><span>]</span><span>{</span>
  <span>def</span> run<span>(</span>msg<span>:</span> <span>String</span><span>)</span> <span>=</span> <span>{</span>
    <span>val</span> res <span>=</span> requests<span>.</span>post<span>(</span><span>"https://httpbin.org/post"</span><span>,</span> data <span>=</span> msg<span>)</span>
    println<span>(</span><span>"response "</span> <span>+</span> res<span>.</span>statusCode<span>)</span>
  <span>}</span>
<span>}</span>
</b></code></pre><p>Message-based parallelism is a technique that involves splitting your
application logic into multiple "Actors", each of which can run concurrently,
and only interacts with other Actors by exchanging asynchronous messages.</p><p>This chapter will introduce the fundamental concepts of message-based
parallelism with actors, and how to use them to achieve parallelism in scenarios
where the techniques we covered in <b><i>Chapter 13: Fork-Join Parallelism with Futures</i></b> cannot be applied. We will first discuss the basic Actor APIs, see how
they can be used in a standalone use case, and then see how they can be used in
a more involved multi-actor pipelines. The techniques in this chapter will come
in useful later in <b><i>Chapter 18: Building a Real-time File Synchronizer</i></b>.</p><p><em>(Code snippet: a simple Actor implemented in Scala using the Castor library)</em></p></div></div><div id="list-chapter-17" role="tabpanel" aria-labelledby="list-chapter-17-list"><div id="table-of-contents-17-preview"><hr><table><tbody><tr><td>17.1 Two-Process Build Setup</td><td><a>320</a></td></tr><tr><td>17.2 Shared Procedure Calls</td><td><a>323</a></td></tr><tr><td>17.3 The Agent Process</td><td><a>325</a></td></tr><tr><td>17.4 The Sync Process</td><td><a>326</a></td></tr><tr><td>17.5 Pipelined Syncing</td><td><a>330</a></td></tr></tbody></table><hr><pre><code><b><span>def</span> send<span>[</span>T<span>:</span> Writer<span>]</span><span>(</span>out<span>:</span> DataOutputStream<span>,</span> msg<span>:</span> T<span>)</span><span>:</span> <span>Unit</span> <span>=</span> <span>{</span>
  <span>val</span> bytes <span>=</span> upickle<span>.</span>default<span>.</span>writeBinary<span>(</span>msg<span>)</span>
  out<span>.</span>writeInt<span>(</span>bytes<span>.</span>length<span>)</span>
  out<span>.</span>write<span>(</span>bytes<span>)</span>
  out<span>.</span>flush<span>(</span><span>)</span>
<span>}</span>

<span>def</span> receive<span>[</span>T<span>:</span> Reader<span>]</span><span>(</span>in<span>:</span> DataInputStream<span>)</span> <span>=</span> <span>{</span>
  <span>val</span> buf <span>=</span> <span>new</span> Array<span>[</span><span>Byte</span><span>]</span><span>(</span>in<span>.</span>readInt<span>(</span><span>)</span><span>)</span>
  in<span>.</span>readFully<span>(</span>buf<span>)</span>
  upickle<span>.</span>default<span>.</span>readBinary<span>[</span>T<span>]</span><span>(</span>buf<span>)</span>
<span>}</span>
</b></code></pre><p>While all our programs so far have run within a single process, in real world
scenarios you will be working as part of a larger system, and the application
itself may need to be split into multiple processes. This chapter will walk you
through how to do so: configuring your build tool to support multiple Scala
processes, sharing code between the two processes, and exchange serialized
messages between two processes.</p><p>As a worked example, we will be building a simple multi-process file
synchronizer that can work over a network. This chapter builds upon the simple
single-process file synchronizer in <b><i>Chapter 7: Files and Subprocesses</i></b>, and
will in turn form the basis for <b><i>Chapter 18: Building a Real-time File Synchronizer</i></b>.</p><p><em>(Code snippet: RPC send and receive methods for sending serialized Scala data
types over an operating system pipe or network)</em></p></div></div><div id="list-chapter-18" role="tabpanel" aria-labelledby="list-chapter-18-list"><div id="table-of-contents-18-preview"><hr><table><tbody><tr><td>18.1 Watching for Changes</td><td><a>338</a></td></tr><tr><td>18.2 Real-time Syncing with Actors</td><td><a>339</a></td></tr><tr><td>18.3 Testing the Syncer</td><td><a>347</a></td></tr><tr><td>18.4 Pipelined Real-time Syncing</td><td><a>348</a></td></tr></tbody></table><hr><pre><code><b><span>object</span> SyncActor <span>extends</span> castor<span>.</span>SimpleActor<span>[</span>Msg<span>]</span><span>{</span>
  <span>def</span> run<span>(</span>msg<span>:</span> Msg<span>)</span><span>:</span> <span>Unit</span> <span>=</span> msg <span>match</span><span>{</span>
    <span>case</span> ChangedPath<span>(</span>value<span>)</span> <span>=&gt;</span> Shared<span>.</span>send<span>(</span>agent<span>.</span>stdin<span>.</span>data<span>,</span> Rpc<span>.</span>StatPath<span>(</span>value<span>)</span><span>)</span>
    <span>case</span> AgentResponse<span>(</span>Rpc<span>.</span>StatInfo<span>(</span>p<span>,</span> remoteHash<span>)</span><span>)</span> <span>=&gt;</span>
      <span>val</span> localHash <span>=</span> Shared<span>.</span>hashPath<span>(</span>src <span>/</span> p<span>)</span>
      <span>if</span> <span>(</span>localHash <span>!=</span> remoteHash <span>&amp;&amp;</span> localHash<span>.</span>isDefined<span>)</span><span>{</span>
        Shared<span>.</span>send<span>(</span>agent<span>.</span>stdin<span>.</span>data<span>,</span> Rpc<span>.</span>WriteOver<span>(</span>os<span>.</span>read<span>.</span>bytes<span>(</span>src <span>/</span> p<span>)</span><span>,</span> p<span>)</span><span>)</span>
      <span>}</span>
  <span>}</span>
<span>}</span>
</b></code></pre><p>In <b><i>Chapter 7: Files and Subprocesses</i></b> we had seen how to use Scala's <code>os<span>.</span>*</code>
functions to synchronize files between two local folders, and then in <b><i>Chapter 17: Multi-Process Applications</i></b> we saw how to turn that into a multi-process
application that can function over the network. We will now round off that
project using the Actor-based techniques we learned in <b><i>Chapter 16: Message-based Parallelism with Actors</i></b>, to turn our previously one-off file
synchronizer into a continuously running program that keeps the destination
folder always up to date even as the files in the source folder change over
time.</p><p><em>(Code snippet: an actor used as part of our real-time file synchronizer)</em></p></div></div><div id="list-chapter-19" role="tabpanel" aria-labelledby="list-chapter-19-list"><div id="table-of-contents-19-preview"><hr><table><tbody><tr><td>19.1 Simple Parsers</td><td><a>356</a></td></tr><tr><td>19.2 Parsing Structured Values</td><td><a>361</a></td></tr><tr><td>19.3 Implementing a Calculator</td><td><a>366</a></td></tr><tr><td>19.4 Parsing Arithmetic Expression Trees</td><td><a>369</a></td></tr><tr><td>19.5 Parser Debugging and Error Reporting</td><td><a>371</a></td></tr></tbody></table><hr><pre><code><b>@ <span>def</span> parser<span>[</span>_<span>:</span> P<span>]</span> <span>=</span>
    P<span>(</span> <span>(</span><span>"hello"</span> <span>|</span> <span>"goodbye"</span><span>)</span><span>.</span>! <span>~</span> <span>" "</span><span>.</span>rep<span>(</span><span>1</span><span>)</span> <span>~</span> <span>(</span><span>"world"</span> <span>|</span> <span>"seattle"</span><span>)</span><span>.</span>! <span>~</span> End <span>)</span>

</b><b>@ fastparse<span>.</span>parse<span>(</span><span>"hello seattle"</span><span>,</span> parser<span>(</span>_<span>)</span><span>)</span></b>
<i>res41<span>:</span> Parsed<span>[</span><span>(</span><span>String</span><span>,</span> <span>String</span><span>)</span><span>]</span> <span>=</span> Success<span>(</span><span>(</span><span>"hello"</span><span>,</span> <span>"seattle"</span><span>)</span><span>,</span> <span>13</span><span>)</span>

</i><b>@ fastparse<span>.</span>parse<span>(</span><span>"hello     world"</span><span>,</span> parser<span>(</span>_<span>)</span><span>)</span></b>
<i>res42<span>:</span> Parsed<span>[</span><span>(</span><span>String</span><span>,</span> <span>String</span><span>)</span><span>]</span> <span>=</span> Success<span>(</span><span>(</span><span>"hello"</span><span>,</span> <span>"world"</span><span>)</span><span>,</span> <span>15</span><span>)</span>
</i></code></pre><p>One common programming task is parsing structured text. This chapter will
introduce the basic features of the FastParse library, before diving into a
worked example where we write a simple arithmetic parser in Scala. This will
allow you to work competently with unusual data formats, query languages, or
source code for which you do not have an existing parser already at hand.</p><p>We will build upon the parsing techniques learned in this chapter as part of
<b><i>Chapter 20: Implementing a Programming Language</i></b>.</p><p><em>(Code snippet: parsing simple text formats using the FastParse library)</em></p></div></div><div id="list-chapter-20" role="tabpanel" aria-labelledby="list-chapter-20-list"><div id="table-of-contents-20-preview"><hr><table><tbody><tr><td>20.1 Interpreting Jsonnet</td><td><a>378</a></td></tr><tr><td>20.2 Jsonnet Language Features</td><td><a>379</a></td></tr><tr><td>20.3 Parsing Jsonnet</td><td><a>380</a></td></tr><tr><td>20.4 Evaluating the Syntax Tree</td><td><a>389</a></td></tr><tr><td>20.5 Serializing to JSON</td><td><a>396</a></td></tr></tbody></table><hr><pre><code><b><span>def</span> evaluate<span>(</span>expr<span>:</span> Expr<span>,</span> scope<span>:</span> Map<span>[</span><span>String</span><span>,</span> Value<span>]</span><span>)</span><span>:</span> Value <span>=</span> expr <span>match</span><span>{</span>
  <span>case</span> Expr<span>.</span>Str<span>(</span>s<span>)</span> <span>=&gt;</span> Value<span>.</span>Str<span>(</span>s<span>)</span>
  <span>case</span> Expr<span>.</span>Dict<span>(</span>kvs<span>)</span> <span>=&gt;</span> Value<span>.</span>Dict<span>(</span>kvs<span>.</span>map<span>{</span><span>case</span> <span>(</span>k<span>,</span> v<span>)</span> <span>=&gt;</span> <span>(</span>k<span>,</span> evaluate<span>(</span>v<span>,</span> scope<span>)</span><span>)</span><span>}</span><span>)</span>
  <span>case</span> Expr<span>.</span>Plus<span>(</span>left<span>,</span> right<span>)</span> <span>=&gt;</span>
    <span>val</span> Value<span>.</span>Str<span>(</span>leftStr<span>)</span> <span>=</span> evaluate<span>(</span>left<span>,</span> scope<span>)</span>
    <span>val</span> Value<span>.</span>Str<span>(</span>rightStr<span>)</span> <span>=</span> evaluate<span>(</span>right<span>,</span> scope<span>)</span>
    Value<span>.</span>Str<span>(</span>leftStr <span>+</span> rightStr<span>)</span>
  <span>case</span> Expr<span>.</span>Local<span>(</span>name<span>,</span> assigned<span>,</span> body<span>)</span> <span>=&gt;</span>
    <span>val</span> assignedValue <span>=</span> evaluate<span>(</span>assigned<span>,</span> scope<span>)</span>
    evaluate<span>(</span>body<span>,</span> scope <span>+</span> <span>(</span>name <span>-&gt;</span> assignedValue<span>)</span><span>)</span>
  <span>case</span> Expr<span>.</span>Ident<span>(</span>name<span>)</span> <span>=&gt;</span> scope<span>(</span>name<span>)</span>
<span>}</span>
</b></code></pre><p>One strength of Scala is working with programming languages. Even if your goal
is not to implement an entirely new programming language, these techniques are
still useful: for writing linters, program analyzers, query engines, and other
such tools.</p><p>This chapter builds upon the simple parsers we learned in <b><i>Chapter 19: Parsing Structured Text</i></b>, and walks you through the process of implementing a simple
programming language in Scala. We finish with a working interpreter for a simple
programming language.</p><p><em>(Code snippet: evaluating a parsed syntax tree into structured JSON output
values using Scala's pattern matching feature)</em></p></div></div></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>