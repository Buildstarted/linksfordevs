<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Depending on the right PowerShell NuGet package in your .NET project | PowerShell - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Depending on the right PowerShell NuGet package in your .NET project | PowerShell - linksfor.dev(s)"/>
    <meta property="article:author" content="Robert HoltFollow"/>
    <meta property="og:description" content="Alongside the pwsh executable packages published with each PowerShell release, the PowerShell team also maintain several NuGet packages that are available on NuGet to allow targeting PowerShell as an API platform in .NET.&#xA;As a .NET application that both provides APIs and expects to load .NET libraries implementing its own (binary modules),"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/powershell/depending-on-the-right-powershell-nuget-package-in-your-net-project/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Depending on the right PowerShell NuGet package in your .NET project | PowerShell</title>
<div class="readable">
        <h1>Depending on the right PowerShell NuGet package in your .NET project | PowerShell</h1>
            <div>by Robert HoltFollow</div>
            <div>Reading time: 17-21 minutes</div>
        <div>Posted here: 09 Apr 2020</div>
        <p><a href="https://devblogs.microsoft.com/powershell/depending-on-the-right-powershell-nuget-package-in-your-net-project/">https://devblogs.microsoft.com/powershell/depending-on-the-right-powershell-nuget-package-in-your-net-project/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>Alongside the <code>pwsh</code> executable packages published with each PowerShell release, the PowerShell team also maintain several NuGet packages that are available on <a href="https://www.nuget.org/" rel="nofollow" target="_blank">NuGet</a> to allow targeting PowerShell as an API platform in .NET.</p><p>As a .NET application that both provides APIs and expects to load .NET libraries implementing its own (binary modules), it’s essential that PowerShell be available in the form of a NuGet package.</p><p>Currrently there are several NuGet packages that provide some representation of the PowerShell API surface area, and which to use with a particular project hasn’t always been made clear. This blog post will shed some light on a few common scenarios for PowerShell-targeting .NET projects and how to choose the right NuGet package to target for your PowerShell-oriented .NET project.</p><h2>Hosting vs referencing</h2><p>Some .NET projects seek to write code to be loaded into a pre-existing PowerShell runtime (such as <code>pwsh</code>, <code>powershell.exe</code>, the PowerShell Integrated Console or the ISE), while others want to run PowerShell in their own applications.</p><ul><li><strong>Referencing</strong> is for when a project, usually a module, is intended to be loaded into PowerShell. It must be compiled against the APIs that PowerShell provides in order to interact with it, but the PowerShell implementation is supplied by the PowerShell process loading it in. For referencing, a project can use <a href="https://github.com/dotnet/standard/blob/master/docs/history/evolution-of-design-time-assemblies.md#definitions" target="_blank">reference assemblies</a> or the actual runtime assemblies as a compilation target, but must ensure that it does not publish any of these with its build.</li><li><strong>Hosting</strong> is when a project needs its own implemenation of PowerShell, usually because it is a standalone application that needs to run PowerShell. In this case, pure reference assemblies cannot be used, and instead a concrete PowerShell implementation must be depended upon. Because a concrete PowerShell implementation must be used, a specific version of PowerShell must be chosen for hosting; a single host application cannot multi-target PowerShell versions.</li></ul><h3>Publishing projects that target PowerShell as a reference</h3><blockquote><p><strong>NOTE</strong>: We use the term <strong>publish</strong> in this blog post to refer to running <code>dotnet publish</code>, which places a .NET library into a directory with all of its dependencies, ready for deployment to a particular runtime.</p></blockquote><p>In order to prevent publishing project dependencies that are just being used as compilation reference targets, it is recommended to set the <a href="https://docs.microsoft.com/dotnet/core/tools/csproj#packagereference" rel="nofollow" target="_blank">PrivateAssets attribute</a>:<code></code></p><div><div id="crayon-5e8ce917c40a3744688917" data-settings=" minimize scroll-mouseover wrap"><div><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>&lt;</span><span>PackageReference </span><span>Include</span>=<span>"PowerShellStandard.Library"</span><span> </span><span>Version</span>=<span>"5.1.0.0"</span><span> </span><span>PrivateAssets</span>=<span>"all"</span><span> </span>/<span>&gt;</span></p></div></td></tr></tbody></table></div></div></div></div><p>If you forget to do this and use a reference assembly as your target, you may see issues related to using the reference assembly’s default implementation instead of the actual implementation. This may take the form of <code>NullReferenceException</code>s, since reference assemblies often mock the implementation API by simply returning <code>null</code>.</p><h2>Key kinds of PowerShell-targeting .NET projects</h2><p>While any .NET library or application can embed PowerShell, there are some common scenarios that use PowerShell APIs:</p><ul><li><strong>Implementing a PowerShell binary module</strong> PowerShell binary modules are .NET libraries loaded by PowerShell that must implement PowerShell APIs like the <a href="https://docs.microsoft.com/dotnet/api/system.management.automation.pscmdlet" rel="nofollow" target="_blank">PSCmdlet</a> or <a href="https://docs.microsoft.com/dotnet/api/system.management.automation.provider.cmdletprovider" rel="nofollow" target="_blank">CmdletProvider</a> types in order to expose cmdlets or providers respectively. Because they are loaded in, modules seek to compile against references to PowerShell without publishing it in their build. It’s also common for modules to want to support multiple PowerShell versions and platforms, ideally with a minimum of overhead of disk space, complexity or repeated implementation. (See <a href="https://docs.microsoft.com/powershell/module/microsoft.powershell.core/about/about_modules" rel="nofollow" target="_blank">about_Modules</a> for more information about modules.)</li><li><strong>Implementing a PowerShell Host</strong> A PowerShell Host provides an interaction layer for the PowerShell runtime. It is a specific form of <em>hosting</em>, where a <a href="https://docs.microsoft.com/dotnet/api/system.management.automation.host.pshost" rel="nofollow" target="_blank">PSHost</a> is implemented as a new user interface to PowerShell. For example, the PowerShell ConsoleHost provides a terminal user interface for PowerShell executables, while the PowerShell Editor Services Host and the ISE Host both provide an editor-integrated partially graphical user interface around PowerShell. While it’s possible to load a host onto an existing PowerShell process, it’s much more common for a host implementation to act as a standalone PowerShell implementation that redistributes the PowerShell engine.</li><li><strong>Calling into PowerShell from another .NET application</strong> As with any application, PowerShell can be called as a subprocess to run workloads. However, as a .NET application, it’s also possible to invoke PowerShell in-process to get back full .NET objects for use within the calling application. This is a more general form of <em>hosting</em>, where the application holds its own PowerShell implementation for internal use. Examples of this might be a service or daemon running PowerShell to manage machine state or a web application that runs PowerShell on request to do something like manage cloud deployments.</li><li><strong>Unit testing PowerShell modules from .NET</strong> While modules and other libraries designed to expose functionality to PowerShell should be primarily tested from PowerShell (we recommend <a href="https://github.com/Pester/Pester" target="_blank">Pester</a>), sometimes it’s necessary to unit test APIs written for a PowerShell module from .NET. This situation involves the module code trying to target a number of PowerShell versions, while testing should run it on specific, concrete implementations.</li></ul><h2>PowerShell NuGet packages at a glance</h2><p>In this blog post, we’ll cover the following NuGet packages that expose PowerShell APIs:</p><ul><li><a href="https://www.nuget.org/packages/System.Management.Automation/" rel="nofollow" target="_blank"><strong>PowerShellStandard.Library</strong></a>, a reference assembly that enables building a single assembly that can be loaded by multiple PowerShell runtimes.</li><li><a href="https://www.nuget.org/packages/Microsoft.PowerShell.SDK/" rel="nofollow" target="_blank"><strong>Microsoft.PowerShell.SDK</strong></a>, the way to target and rehost the whole PowerShell SDK</li><li>The <a href="https://www.nuget.org/packages/System.Management.Automation/" rel="nofollow" target="_blank"><strong>System.Management.Automation</strong></a> package, the core PowerShell runtime and engine implementation, that can be useful in minimal hosted implementations and for version-specific targeting scenarios.</li><li>The <strong>Windows PowerShell reference assemblies</strong>, the way to target and effectively rehost Windows PowerShell (PowerShell versions 5.1 and below).</li></ul><blockquote><p><strong>NOTE</strong>: The <a href="https://www.nuget.org/packages/PowerShell/" rel="nofollow" target="_blank"><strong>PowerShell</strong></a> NuGet package is not a .NET library package at all, but instead provides the PowerShell dotnet global tool implementation. This should not be used by any projects, since it only provides an executable.</p></blockquote><h2>PowerShellStandard.Library</h2><p>The <a href="https://www.nuget.org/packages/PowerShellStandard.Library/" rel="nofollow" target="_blank">PowerShell Standard library</a> is a reference assembly that captures the intersection of the APIs of PowerShell versions 7, 6 and 5.1. This provides a compile-time-checked API surface to compile .NET code against, allowing .NET projects to target PowerShell versions 7, 6 and 5.1 without risking calling an API that won’t be there.</p><p>PowerShell Standard is intended for writing PowerShell modules, or other code only intended to be run after loading it into a PowerShell process. Because it is a reference assembly, PowerShell Standard contains no implementation itself, so provides no functionality for standalone applications.</p><h3>Using PowerShell Standard with different .NET runtimes</h3><p>PowerShell Standard targets the <a href="https://docs.microsoft.com/dotnet/standard/net-standard" rel="nofollow" target="_blank">.NET Standard 2.0</a> target runtime, which is a fa???ade runtime designed to provide a common surface area shared by .NET Framework and .NET Core. This allows targeting a single runtime to produce a single assembly that will work with multiple PowerShell versions, but has the following consequences:</p><ul><li>The PowerShell loading the module or library must be running a minimum of .NET 4.6.1; .NET 4.6 and .NET 4.5.2 do not support .NET Standard. Note that a newer Windows PowerShell version does not mean a newer .NET Framework version; Windows PowerShell 5.1 may run on .NET 4.5.2.</li><li>In order to work with a PowerShell running .NET Framework 4.7.1 or below, the .NET 4.6.1 <a href="https://www.nuget.org/packages/NETStandard.Library/" rel="nofollow" target="_blank">NETStandard.Library</a> implemenation is required to provide the netstandard.dll and other shim assemblies in older .NET Framework versions.</li></ul><p>PowerShell 6+ provides its own shim assemblies for type forwarding from .NET Framework 4.6.1 (and above) to .NET Core. This means that as long as a module uses only APIs that exist in .NET Core, PowerShell 6+ can load and run it when it has been built for .NET Framework 4.6.1 (the <code>net461</code> runtime target).</p><p>This means that binary modules using PowerShell Standard to target multiple PowerShell versions with a single published DLL have two options:</p><ol><li>Publishing an assembly built for the <code>net461</code> target runtime. This involves:<ul><li>Publishing the project for the <code>net461</code> runtime</li><li>Also compiling against the <code>netstandard2.0</code> runtime (without using its build output) to ensure that all APIs used are also present in .NET Core.</li></ul></li><li>Publishing an assembly build for the <code>netstandard2.0</code> target runtime. This requires:<ul><li>Publishing the project for the <code>netstandard2.0</code> runtime</li><li>Taking the <code>net461</code> dependencies of NETStandard.Library and copying them into the project assembly’s publish location so that the assembly is type-forwarded corrected in .NET Framework.</li></ul></li></ol><p>Note that to build PowerShell modules or libraries targeting older .NET Framework versions, it may be preferable to target multiple .NET runtimes. This will publish an assembly for each target runtime, and the correct assembly will need to be loaded at module load time (for example with a small psm1 as the root module).</p><h3>Testing PowerShell Standard projects in .NET</h3><p>When it comes to testing your module in .NET test runners like xUnit, remember that compile-time checks can only go so far, so you must test your module against the relevant PowerShell platforms.</p><p>To test APIs built against PowerShell Standard in .NET, you should add Microsoft.PowerShell.SDK as a testing dependency with .NET Core (with the version set to match the desired PowerShell version), and the appropriate Windows PowerShell reference assemblies with .NET Framework.</p><p>For more information on PowerShell Standard and using it to write a binary module that works in multiple PowerShell versions, see <a href="https://devblogs.microsoft.com/powershell/powershell-standard-library-build-single-module-that-works-across-windows-powershell-and-powershell-core/" rel="nofollow">this blog post</a>. Also see the <a href="https://github.com/PowerShell/PowerShellStandard" target="_blank">PowerShell Standard GitHub repository</a>.</p><h2>Microsoft.PowerShell.SDK</h2><p>Microsoft.PowerShell.SDK is a meta-package that pulls together all of the components of the PowerShell SDK into a single NuGet package. A self-contained .NET application can use Microsoft.PowerShell.SDK to run arbitrary PowerShell functionality without depending on any external PowerShell installations or libraries.</p><blockquote><p><strong>NOTE</strong>: The PowerShell SDK just refers to all the component packages that make up PowerShell, and which can be used for .NET development with PowerShell.</p></blockquote><p>A given Microsoft.PowerShell.SDK version contains the concrete implementation of the same version of the PowerShell application; version 7.0 contains the implementation of PowerShell 7.0 and running commands or scripts with it will largely behave like running them in PowerShell 7.0.</p><p>Running PowerShell commands from the SDK is mostly, but not totally, the same as running them from <code>pwsh</code>; for example, <a href="https://docs.microsoft.com/powershell/module/microsoft.powershell.core/start-job" rel="nofollow" target="_blank">Start-Job</a> currently depends on the <code>pwsh</code> executable being available, and so will not work with Microsoft.PowerShell.SDK by default.</p><p>Targeting Microsoft.Powershell.SDK from a .NET application allows you to integrate with all of PowerShell’s implementation assemblies, such as <code>System.Management.Automation</code>, <code>Microsoft.PowerShell.Management</code> and other module assemblies.</p><p>Publishing an application targeting Microsoft.PowerShell.SDK will include all these assemblies, along with any dependencies PowerShell requires, as well as other assets that PowerShell requires in its build such as the module manifests for <code>Microsoft.PowerShell.*</code> modules and the <code>ref</code> directory required by <a href="https://docs.microsoft.com/powershell/module/microsoft.powershell.utility/add-type" rel="nofollow" target="_blank">Add-Type</a>.</p><p>Given the completeness of Microsoft.PowerShell.SDK, it’s best suited for:</p><ul><li>Implementation of PowerShell hosts.</li><li>xUnit testing of libraries targeting PowerShell reference assemblies.</li><li>Invoking PowerShell in-process from a .NET application.</li></ul><p>Microsoft.PowerShell.SDK may also be used as a reference target when a .NET project is intended to be used as a module or otherwise loaded by PowerShell, but depends on APIs only present in a particular version of PowerShell. Note that an assembly published against a specific version of Microsoft.PowerShell.SDK will only be safe to load and use in that version of PowerShell; to target multiple PowerShell versions with specific APIs, multiple builds are required, each targeting their own version of Microsoft.PowerShell.SDK.</p><blockquote><p><strong>NOTE</strong>: The PowerShell SDK is only available for PowerShell versions 6 and up. To provide equivalent functionality with Windows PowerShell, use the Windows PowerShell reference assemblies described below.</p></blockquote><h2>System.Management.Automation</h2><p>The System.Management.Automation package is the heart of the PowerShell SDK and exists on NuGet chiefly as an asset for Microsoft.PowerShell.SDK to pull in. However, it can also be used directly as a package for smaller hosting scenarios and version-targeting modules.</p><p>Specifically, the System.Management.Automation package may be a preferable provider of PowerShell functionality when:</p><ul><li>You’re only looking to use PowerShell language functionality (in the <code>System.Management.Automation.Language</code> namespace) like the PowerShell parser, AST and AST visitor APIs (for example for static analysis of PowerShell).</li><li>You only wish to execute specific commands from the <code>Microsoft.PowerShell.Core</code> module and can execute them in a session state created with the <a href="https://docs.microsoft.com/dotnet/api/system.management.automation.runspaces.initialsessionstate.createdefault2" rel="nofollow" target="_blank"><code>CreateDefault2</code></a> factory method.</li></ul><p>Additionally, System.Management.Automation is a useful reference assembly when:</p><ul><li>You wish to target APIs that are only present within a specific PowerShell version</li><li>You won’t be depending on types occurring outside the <code>System.Management.Automation</code> assembly (for example, types exported by cmdlets in <code>Microsoft.PowerShell.*</code> modules).</li></ul><h2>Windows PowerShell reference assemblies</h2><p>For PowerShell versions 5.1 and older (Windows PowerShell), there is no SDK to provide an implementation of PowerShell, since Windows PowerShell’s implementation is a part of Windows.</p><p>Instead, the Windows PowerShell reference assemblies provide both reference targets and a way to rehost Windows PowerShell, acting the same as the PowerShell SDK does for versions 6 and up.</p><p>Rather than being differentiated by version, Windows PowerShell reference assemblies have a different package for each version of Windows PowerShell:</p><ul><li><a href="https://www.nuget.org/packages/Microsoft.PowerShell.5.ReferenceAssemblies/" rel="nofollow" target="_blank">PowerShell 5.1</a></li><li><a href="https://www.nuget.org/packages/Microsoft.PowerShell.4.ReferenceAssemblies/" rel="nofollow" target="_blank">PowerShell 4</a></li><li><a href="https://www.nuget.org/packages/Microsoft.PowerShell.3.ReferenceAssemblies/" rel="nofollow" target="_blank">PowerShell 3</a></li></ul><p>Information on how to use the Windows PowerShell reference assemblies can be found <a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/windows-powershell" rel="nofollow" target="_blank">here</a>.</p><h2>Real-world examples using these NuGet packages</h2><p>Different PowerShell tooling projects target different PowerShell NuGet packages depending on their needs. Listed here are some notable examples.</p><h3>PSReadLine</h3><p><a href="https://github.com/PowerShell/PSReadLine" target="_blank">PSReadLine</a>, the PowerShell module that provides much of PowerShell’s rich console experience, targets PowerShell Standard as a dependency rather than a specific PowerShell version, and targets the <code>net461</code> .NET runtime <a href="https://github.com/PowerShell/PSReadLine/blob/master/PSReadLine/PSReadLine.csproj" target="_blank">in its csproj</a>.</p><p>PowerShell 6+ supplies its own shim assemblies that allow a DLL targeting the <code>net461</code> runtime to “just work” when loaded in (by redirecting binding to .NET Framework’s mscorlib.dll to the relevant .NET Core assembly).</p><p>This simplifies PSReadLine’s module layout and delivery significantly, since PowerShell Standard ensures the only APIs used will be present in both PowerShell 5.1 and PowerShell 6+, while also allowing the module to ship with only a single assembly.</p><p>The .NET 4.6.1 target does mean that Windows PowerShell running on .NET 4.5.2 and .NET 4.6 is not supported though.</p><h3>PowerShell Editor Services</h3><p><a href="https://github.com/PowerShell/PowerShellEditorServices/" target="_blank">PowerShell Editor Services</a> (PSES) is the backend for the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell" rel="nofollow" target="_blank">PowerShell extension</a> for <a href="https://code.visualstudio.com/" rel="nofollow" target="_blank">Visual Studio Code</a>, and is actually a form of PowerShell module that gets loaded by a PowerShell executable and then takes over that process to rehost PowerShell within itself while also providing Language Service Protocol and Debug Adapter features.</p><p>PSES provides concrete implementation targets for <code>netcoreapp2.1</code> to target PowerShell 6+ (since PowerShell 7’s <code>netcoreapp3.1</code> runtime is backwards compatible) and <code>net461</code> to target Windows PowerShell 5.1, but contains most of its logic in a second assembly that targets <code>netstandard2.0</code> and PowerShell Standard. This allows it to pull in dependencies required for .NET Core and .NET Framework platforms, while still simplifying most of the codebase behind a uniform abstraction.</p><p>Because it is build against PowerShell Standard, PSES requires a runtime implementation of PowerShell in order to be tested correctly. To do this, <a href="https://github.com/PowerShell/PowerShellEditorServices/blob/8c500ee1752201d3c1cc2e5d90f1a2af3b1eb15d/test/PowerShellEditorServices.Test/PowerShellEditorServices.Test.csproj#L15-L20" target="_blank">PSES’s xUnit tests pull in Microsoft.PowerShell.SDK and Microsoft.PowerShell.5.ReferenceAssemblies</a> in order to provide a PowerShell implementation in the test environment.</p><p>As with PSReadLine, PSES cannot support .NET 4.6 and below, but it <a href="https://github.com/PowerShell/PowerShellEditorServices/blob/8c500ee1752201d3c1cc2e5d90f1a2af3b1eb15d/src/PowerShellEditorServices.Hosting/EditorServicesLoader.cs#L231-L251" target="_blank">performs a check at runtime</a> before calling any of the APIs that could cause a crash on the lower .NET Framework runtimes.</p><h3>PSScriptAnalyzer</h3><p><a href="https://github.com/powershell/psscriptanalyzer" target="_blank">PSScriptAnalyzer</a>, the linter for PowerShell, must target syntactic elements only introduced in certain versions of PowerShell. Because recognition of these syntactic elements is accomplished by implementing an <a href="https://docs.microsoft.com/dotnet/api/system.management.automation.language.astvisitor2" rel="nofollow" target="_blank">AstVisitor2</a>, it’s not possible to use PowerShellStandard and also implement AST visitor methods for newer PowerShell syntaxes.</p><p>Instead, PSScriptAnalyzer <a href="https://github.com/PowerShell/PSScriptAnalyzer/blob/master/Engine/Engine.csproj" target="_blank">targets each PowerShell version</a> as a build configuration, and produces a separate DLL for each of them. This increases build size and complexity, but allows:</p><ul><li>Version-specific API targeting</li><li>Version specific functionality to be implemented with essentially no runtime cost</li><li>Total support for Windows PowerShell all the way down to .NET Framework 4.5.2</li></ul><h2>Summary</h2><p>In this post, we’ve listed and discussed the NuGet packages available to target when implementing a .NET project that uses PowerShell, and the reasons you might have for using one over another.</p><p>If you’ve skipped to the summary, some broad recommendations are:</p><ul><li>PowerShell <strong>modules</strong> should compile against PowerShell Standard if they only require APIs common to different PowerShell versions.</li><li>PowerShell <strong>hosts and applications</strong> that need to run PowerShell internally should target the PowerShell SDK for PowerShell 6+ or the relevant Windows PowerShell reference assemblies for Windows PowerShell.</li><li>PowerShell modules that need <strong>version-specific APIs</strong> should target the PowerShell SDK or Windows PowerShell reference assemblies for the required PowerShell versions, using them as reference assemblies (i.e. not publishing the PowerShell dependencies).</li></ul><p>If you’re unsure about your scenario, feel free to get in touch by commenting, <a href="https://github.com/PowerShell/PowerShell/issues/new/choose" target="_blank">opening an issue</a> or reaching out to us on social media.</p><p>Cheers!</p><p>Rob Holt</p><p>Software Engineer</p><p>PowerShell Team</p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>