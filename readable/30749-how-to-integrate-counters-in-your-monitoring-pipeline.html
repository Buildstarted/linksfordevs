<!DOCTYPE html>
<html lang="en">
<head>
    <title>
how to integrate counters in your monitoring pipeline -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>how to integrate counters in your monitoring pipeline</h1><div><div class="ac ae af ag ah ea aj ak"><p id="b743" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This post of the series digs into the implementation details of the new .NET Core counters.</p><p id="ba2e" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 1: <a href="http://labs.criteo.com/2018/06/replace-net-performance-counters-by-clr-event-tracing" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Replace .NET performance counters by CLR event tracing</a>.</p><p id="2eaf" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 2: <a href="http://labs.criteo.com/2018/07/grab-etw-session-providers-and-events/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Grab ETW Session, Providers and Events</a>.</p><p id="a70a" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 3: <a href="http://labs.criteo.com/2018/09/monitor-finalizers-contention-and-threads-in-your-application/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">CLR Threading events with TraceEvent</a>.</p><p id="afdd" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 4: <a class="da by hc hd he hf" target="_blank" rel="noopener" href="/criteo-labs/spying-on-net-garbage-collector-with-traceevent-f49dc3117de">Spying on .NET Garbage Collector with TraceEvent</a>.</p><p id="5fe1" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 5: <a class="da by hc hd he hf" target="_blank" rel="noopener" href="/criteo-labs/c-building-your-own-java-like-gc-logs-in-net-992205fd8d4f">Building your own Java GC logs in .NET</a></p><p id="3a6f" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part6: <a class="da by hc hd he hf" target="_blank" rel="noopener" href="/criteo-labs/spying-on-net-garbage-collector-with-net-core-eventpipes-9f2a986d5705">Spying on .NET Core Garbage Collector with .NET Core EventPipes</a></p><h1 id="296a" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Introduction</h1><p id="354f" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">As explained in <a class="da by hc hd he hf" target="_blank" rel="noopener" href="/criteo-labs/c-in-process-clr-event-listeners-with-net-core-2-2-ef4075c14e87">a previous post</a>, <a class="da by hc hd he hf" target="_blank" rel="noopener" href="/criteo-labs/c-in-process-clr-event-listeners-with-net-core-2-2-ef4075c14e87">.NET Core 2.2 introduced</a> the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventlistener?view=netcore-2.2" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">EventListener class</a> to receive in-proc CLR events both on Windows and Linux. Starting with .NET Core 3.0 Preview 6, the <strong class="gq hx">EventPipe</strong>-based infrastructure makes it now possible to get these events from another process. The <a href="https://github.com/dotnet/diagnostics" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">diagnostics repository</a> contains the cross-platform tools leveraging this infrastructure:</p><ul class=""><li id="2a3b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb hy hz ia"><a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-dump-instructions.md" class="da by hc hd he hf" target="_blank" rel="noopener nofollow"><strong class="gq hx">dotnet-dump</strong></a>: take memory snapshot and allow analysis based on most SOS commands</li><li id="b432" class="go gp ed at gq b gr ib gt ic gv id gx ie gz if hb hy hz ia"><a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-trace-instructions.md" class="da by hc hd he hf" target="_blank" rel="noopener nofollow"><strong class="gq hx">dotnet-trace</strong></a>: collect events emitted by the Core CLR and generate trace file to be analyzed with Perfview</li><li id="3249" class="go gp ed at gq b gr ib gt ic gv id gx ie gz if hb hy hz ia"><a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md" class="da by hc hd he hf" target="_blank" rel="noopener nofollow"><strong class="gq hx">dotnet-counters</strong></a>: collect the metrics corresponding to some performance counters that used to be exposed by the .NET Framework</li></ul><p id="ba4f" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">At Criteo, our metrics are exposed in Grafana dashboards and it is interesting to figure out how the new counters are implemented and see how to fetch them via the <strong class="gq hx">EventPipe</strong> infrastructure. With this knowledge in hand, I’ve implemented helpers to let you get counters in less than 10 lines of code:</p><figure class="ig ih ii ij ik il"><p id="e913" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">At the end of this post you will be able to very easily integrate any counter to your own monitoring pipeline!</p><h1 id="b4ae" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">.NET Core replacement for .NET Framework Performance Counters</h1><p id="f064" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">With .NET Core being cross-platform, performance counters were gone and, as explained in the previous posts of the series, CLR events were the only way to get metrics about how your .NET Core applications were behaving. However, with .NET Core 3.0, it is now possible to view a few metrics thanks to the <strong class="gq hx">dotnet-counters</strong> tool.</p><p id="dbec" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">You can download and install the tools automatically if you have installed .NET Core SDK 2.1+. Microsoft is currently working to provide other ways to directly download the tools binaries without having to install the SDK or recompile the diagnostics repository.</p><p id="33de" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Use the following command line to install dotnet-counters:<br><code class="iq ir is it iu b">dotnet tool install --global dotnet-counters --version 3.0.0-preview7.19365.2</code></p><p id="dd28" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Note that you need to have the same version both for the Core CLR runtime and for the tools because, as you will soon see, the monitoring and the monitored applications are communicating via a dedicated protocol (that have changed between previews) on top of a transport layer different between Windows and Linux.</p><p id="4958" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">After the installation, use the following command line <code class="iq ir is it iu b">dotnet counters monitor -p &lt;your application process id&gt;</code> and you get a 1 second auto-refreshed view of counters.</p><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="b84b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">These counters are exposed by the <em class="jf">System.Runtime</em> provider and are detailed with the <code class="iq ir is it iu b">list</code> argument:</p><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="5888" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This list is currently hard-coded in the <code class="iq ir is it iu b"><a href="https://github.com/dotnet/diagnostics/blob/master/src/Tools/dotnet-counters/KnownData.cs#L19" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">CreateKnownProviders</a></code> method. However, you are free to create your own provider and expose your application metrics as shown in <a href="https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.Tracing/documentation/EventCounterTutorial.md" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">this tutorial</a> (and in the next forthcoming post). In addition, if you are using ASP.NET Core, starting from Preview 7, then you could get a few counters from the “Microsoft.AspNetCore.Hosting” provider defined in <code class="iq ir is it iu b"><a href="https://github.com/aspnet/AspNetCore/blob/master/src/Hosting/Hosting/src/Internal/HostingEventSource.cs#L25" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">HostingEventSource.cs</a></code>.</p><h1 id="847a" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">What are these “counters”</h1><p id="94a2" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">Even though it is nice to have a console-based cross-platform tool to see the values of counters change, what would be the cost to get them into your own monitoring pipeline? For example, at Criteo, we are pushing our metrics to Graphite in order to get nice Grafana dashboards. These graphical representations allow us to have a visual representation of the evolution of metrics over time. In addition, it is also possible to define alerts based on threshold for some metrics values (when CPU &gt; 85% for more than 5 seconds for example).</p><p id="a576" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In a nutshell, dotnet-counters tool is listening to another application via <strong class="gq hx">EventPipe</strong>. Unlike .NET Framework performance counters that are polled by the monitoring application, the counters are pushed by the monitored .NET Core process.</p><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="ee8d" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In term of implementation, these counters are values that you could get via .NET internal or public APIs if you were running in-proc as shown <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Diagnostics/Eventing/RuntimeEventSource.cs#L47" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">in RuntimeEventSource.cs</a>:</p><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="a4f5" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Unlike most of the events that previous posts of this series presented, counters are metrics that are computed by the CLR in the monitored application. They are supposed to provide a set of values changing over time in the monitored application without impacting the performance nor flooding the listener client. I highly recommend to take a look at <a href="https://github.com/dotnet/diagnostics/issues/346" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">this issue</a> for a deeper discussion about <strong class="gq hx">EventCounters</strong> compared to regular events.</p><p id="5acf" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">As of Preview 7, two types of counters are used:</p><ul class=""><li id="1c95" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb hy hz ia"><em class="jf">Mean</em>: supposed to contain a mean of all values during the polling interval with its min and max values. However, based on <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Diagnostics/Tracing/PollingCounter.cs#L70" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">the current implementation</a>, all contain only the current value.</li><li id="51c1" class="go gp ed at gq b gr ib gt ic gv id gx ie gz if hb hy hz ia"><em class="jf">Sum</em>: contains an increment between the previous value and the current one</li></ul><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="8d51" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The question is now to figure out how to get the values of the counters.</p><h1 id="02b9" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">How to receive the counters?</h1><p id="4b61" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">Like the Perfview tool that relies on <strong class="gq hx">TraceEvent</strong> library, dotnet-counters uses an API exposed by <strong class="gq hx">Microsoft.Diagnostics.Tools.RuntimeClient</strong> assembly. Note that it is currently <a href="https://github.com/dotnet/diagnostics/issues/343" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">not (yet) available from nuget</a> so you need to recompile it with the <a href="https://github.com/dotnet/diagnostics/issues/343" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">diagnostics git repo</a>.</p><p id="f7f2" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">To receive counters, you need to create an <strong class="gq hx">EventPipe</strong> session that communicates via IPC (named pipes on Windows and domain sockets on Linux) with the CLR of the monitored process. Here is an excerpt of the <code class="iq ir is it iu b">CounterMonitor.StartMonitoring</code><a href="https://github.com/dotnet/diagnostics/blob/master/src/Tools/dotnet-counters/CounterMonitor.cs#L177" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">implementation</a> that connects and listens to counter events:</p><figure class="ig ih ii ij ik il"><p id="1b40" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The important method call is call is <code class="iq ir is it iu b">EventPipeClient.CollectTracing()</code> that returns a <code class="iq ir is it iu b">Stream</code> from which an <code class="iq ir is it iu b">EventPipeEventSource</code> instance gets created. This class has been added to <strong class="gq hx">TraceEvent</strong> so you can now leverage the event parsing infrastructure on top of <strong class="gq hx">EventPipe</strong>! As shown in <a href="http://labs.criteo.com/2018/07/grab-etw-session-providers-and-events/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">a previous post</a>, it is easy to attach a listener to the source <code class="iq ir is it iu b">All</code> .NET event and get notified each time an event is received after the <code class="iq ir is it iu b">Process</code> method is called.</p><p id="b780" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">A few parameters are given to <code class="iq ir is it iu b">CollectTracing</code> via the <code class="iq ir is it iu b">SessionConfiguration</code> object: the size of the circular buffer used by the CLR and no file path because we want a live session. The last one is supposed to filter which providers and counters you would like to listen to: it expects a list of <code class="iq ir is it iu b">Provider</code> instances. This struct <a href="https://github.com/dotnet/diagnostics/blob/master/src/Microsoft.Diagnostics.Tools.RuntimeClient/Eventing/Provider.cs#L10" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">is created with a few parameters</a>:</p><figure class="ig ih ii ij ik il"><p id="6f65" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">As we have already mentioned, the name of the provider is “<em class="jf">System.Runtime</em>” for the Core CLR counters. The keywords and event level are expected to have these max values. The filter data string starts with “<em class="jf">EventCounterIntervalSec=</em>” followed by the refresh interval in seconds. Internally, the CLR in the monitored application <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Diagnostics/Tracing/CounterGroup.cs#L135" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">is creating a timer</a> with that frequency to push the counters via <strong class="gq hx">EventPipe</strong> (more on this later).</p><p id="cb86" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Here is a helper class to easily create your providers:</p><figure class="ig ih ii ij ik il"><p id="6ab2" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Note that <code class="iq ir is it iu b">dotnet-counters</code> allows you to pass a subset of the counters with the <em class="jf">System.Runtime[counter1,counter2,counter2]</em> syntax: events for all System.Runtime counters will be received but only these three will be displayed in the console.</p><h1 id="2b7d" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Show time for counter events!</h1><p id="56b1" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">Next, the important part of the job takes place in the <code class="iq ir is it iu b">EventSourc.All</code> event listener. Each new counter value is received in the payload of an event named “<em class="jf">EventCounters</em>”.</p><figure class="ig ih ii ij ik il"><p id="8841" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The <code class="iq ir is it iu b">Name</code> and <code class="iq ir is it iu b">DisplayName</code> values are self-explanatory. The <em class="jf">Sum</em>/<em class="jf">Mean</em> type is retrieved from <code class="iq ir is it iu b">CounterType</code>.</p><p id="7f2b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The value for each counter type is retrieved from the payload with “Increment” (<em class="jf">Sum</em> type) or “Mean” (<em class="jf">Mean </em>type) keys.</p><figure class="ig ih ii ij ik il"><p id="fb48" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The <code class="iq ir is it iu b">CounterMonitor</code> class has been added on my <a href="https://github.com/chrisnas/ClrEvents" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Github</a> to expose a <code class="iq ir is it iu b">CounterUpdate</code> C# event when a counter event is received:</p><figure class="ig ih ii ij ik il"><p id="cb01" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The event argument contains the expected properties but other could be added if needed such as the timestamp for example:</p><figure class="ig ih ii ij ik il"><h1 id="1567" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Let’s show some graphs!</h1><p id="e15a" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">With these helpers in hand, it is easy to integrate any counter to your monitoring pipeline. As an example, let’s see how to generate a .csv file used to create visual representations in Excel.</p><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="b87a" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">With a refresh rate of 1 second, one line containing the value of the CLR counters should be added to the .csv file every second. Since we get one event per counter, we need to know which is the “last” counter event sent by the CLR for a given 1 second counters push.</p><p id="4ef0" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">As mentioned earlier the <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Diagnostics/Eventing/RuntimeEventSource.cs#L47" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">RuntimeEventSource</a> class defines the CLR counters. Each one is an instance of a type derived from the <code class="iq ir is it iu b">DiagnoticCounter</code> class that <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Diagnostics/Tracing/DiagnosticCounter.cs#L45" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">associates its instances</a> to a <code class="iq ir is it iu b">CounterGroup</code> also bound to the <code class="iq ir is it iu b">RuntimeEventSource</code>. The <code class="iq ir is it iu b">CounterGroup</code> class will setup a repeating timer responsible for creating the payload for its <code class="iq ir is it iu b">DiagnosticCounter</code>-derived instances and ask the event source to send each to the monitoring application via <strong class="gq hx">EventPipe</strong>.</p><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="586d" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">So we can rely on the order defined by the counters creation code in <code class="iq ir is it iu b">RuntimeEventSource</code>: for a given push of counters, the name of the last one will be “<em class="jf">assembly-count</em>”. Beware that in a case of new counters (such as for ASP.NET Core), you would need to check what would be the last one of the counters series. Another way to work around would be to rely on the timestamps of each event but this could become flaky over time. It would have been great if a “<em class="jf">CounterSeries</em>”event containing the list of counter names would have been sent before any “<em class="jf">EventCounters</em>” of a series push (good idea for a pull request :^)</p><p id="09e2" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The <code class="iq ir is it iu b">CsvCounterListener</code> class wraps the few lines of code needed to handle the events and add a line into the .csv file each time a series of counters is received:</p><figure class="ig ih ii ij ik il"><h1 id="e744" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">What’s next?</h1><p id="0252" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">You have seen how easy it is to be notified of CLR counters update. The integration to your own monitoring system should not be more complicated. However, you need to pay attention to the meaning of counter types between <em class="jf">Mean </em>and <em class="jf">Sum</em>. For example, the value you get for <strong class="gq hx">gen-0-count</strong> (<em class="jf">Sum</em>) counters is a difference between now and the previous computation. It means that you can’t have the “current” number of gen 0 collection at a given time.</p><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="38eb" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This is not a problem in the Excel example because you can “rebuild” a column that will contain the “current” count based on the previous value + the diff returned by the counter.</p><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="c983" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Here is the resulting graph:</p><figure class="ig ih ii ij ik il dm dn paragraph-image"><p id="54c3" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In other cases, you might need to feed your monitoring system with real count values and benefit from advanced charting such as non derivative computation to show a rate based on a series of values. At the end of the day, it is just a question of initial value from which rebuild a count. And if you think about it, you are often more interested in unexpected variations (i.e. differences returned by counters) when monitoring your application.</p><p id="7bd5" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In addition to your business metrics, .NET Core Counters are usually enough to monitor the health of your applications. However, in order to investigate situations where counters value are showing weird results, you often need more details. For example spikes in garbage collections count might not be a problem if the pause time is not too long. Listening to specific CLR events as shown in previous posts of this series is a great way to unveil important metrics such as GC pause time, contentions duration or exception names without performance hit.</p><p id="76fa" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The code available on <a href="https://github.com/chrisnas/ClrEvents" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Github</a> has been updated to provide the <code class="iq ir is it iu b">CounterMonitor</code> and <code class="iq ir is it iu b">CsvCounterListener</code> classes that demonstrates how to get .NET Core counters and generate .csv file usable in Excel.</p></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>