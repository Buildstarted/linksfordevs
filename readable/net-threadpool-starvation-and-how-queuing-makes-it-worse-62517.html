<!DOCTYPE html>
<html lang="en">
<head>
    <title>
.NET ThreadPool starvation, and how queuing makes it worse - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content=".NET ThreadPool starvation, and how queuing makes it worse - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@kevingosse"/>
    <meta property="og:description" content="There has been a lot of discussion around ThreadPool starvation. But why? And what it is about? Read on!"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/criteo-labs/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - .NET ThreadPool starvation, and how queuing makes it worse</title>
<div class="readable">
        <h1>.NET ThreadPool starvation, and how queuing makes it worse</h1>
            <div>by https://medium.com/@kevingosse</div>
            <div>Reading time: 9-12 minutes</div>
        <div>Posted here: 08 Jun 2020</div>
        <p><a href="https://medium.com/criteo-labs/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527">https://medium.com/criteo-labs/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><p id="72f0" data-selectable-paragraph="">To illustrate that, consider a web server that would execute this code:</p><figure><div></div></figure><p id="f41c" data-selectable-paragraph="">You start an asynchronous operation (<code>DoSomethingAsync</code>) then block the current thread. At some point, the asynchronous operation will need a thread to finish executing, so it’ll ask the ThreadPool for a new one. You end up using two threads for an operation that could be done with just one: one waiting actively on the Wait() method call and another one performing the continuation. In most cases this is fine. But it can become a problem if you deal with a burst of requests:</p><ul><li id="3e7c" data-selectable-paragraph="">Request 1 arrives at the server. <code>ProcessRequest</code> is called from a ThreadPool thread. It starts the asynchronous operation then waits on it</li><li id="f5d6" data-selectable-paragraph="">Requests 2, 3, 4, and 5 arrive at the server</li><li id="bda5" data-selectable-paragraph="">The asynchronous operation completes and its continuation is enqueued to the ThreadPool</li><li id="02b1" data-selectable-paragraph="">In the meantime, since 4 requests have arrived, 4 calls to <code>ProcessRequest</code> have been enqueued before your continuation</li><li id="d61d" data-selectable-paragraph="">Each of those requests will, in turn, start an asynchronous operation and block their ThreadPool thread</li></ul><p id="2464" data-selectable-paragraph="">Combined with the fact that the ThreadPool grows very slowly (one thread per second or so), it’s easy to understand how a burst of requests can push a system into a situation of thread starvation. But there’s something missing in the picture: while the burst could temporarily lock the system unless the workload is continuously increasing, the ThreadPool should be capable of growing enough to eventually recover.</p><p id="3196" data-selectable-paragraph="">Yet, it does not fit what we observed on our own servers. We usually restart our instances as soon as starvation happens, but in one case we didn’t. The ThreadPool grew until its hardcoded limit (32767 threads), and the system never recovered:</p><figure><div><div><div><p><img src="https://miro.medium.com/max/60/0*9Lcd_ALXI3phkuP8.jpg?q=20" width="634" height="226" role="presentation"></p><p><img width="634" height="226" srcset="https://miro.medium.com/max/552/0*9Lcd_ALXI3phkuP8.jpg 276w, https://miro.medium.com/max/1104/0*9Lcd_ALXI3phkuP8.jpg 552w, https://miro.medium.com/max/1268/0*9Lcd_ALXI3phkuP8.jpg 634w" sizes="634px" role="presentation"></p></div></div></div></figure><p id="a6c2" data-selectable-paragraph="">If you do the math, 32767 threads should be more than enough to handle the 1000–2000 QPS that our servers process, even if every request required 10 threads!</p><p id="5c87" data-selectable-paragraph="">It seems there’s something else going on.</p><p id="2991" data-selectable-paragraph="">Let’s consider the following code. Take a minute to guess what will happen:</p><figure><div></div></figure><p id="4147" data-selectable-paragraph="">Producer enqueues 5 calls to Process every second. In Process, we yield to avoid blocking the caller, then we start a task that will wait 1 second and wait for it. In total, we start 5 tasks per second and each of those tasks will need an additional task. So we need 10 threads to absorb the constant workload. The ThreadPool is manually configured to start with 8 threads, so we are 2 threads short. My expectations are that the program will struggle for 2 seconds until the ThreadPool grows to absorb the workload. Then it needs to grow a bit further to process the additional work-items that we enqueued during the 2 seconds. After a few seconds, the situation will stabilize.</p><p id="90c3" data-selectable-paragraph="">But if you run the program, you’ll see that it managed to display “Ended” a few times in the console, then nothing happens anymore:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/0*fCYXWrvqOrUwLzp3.png?q=20" width="902" height="310" role="presentation"></p><p><img width="902" height="310" srcset="https://miro.medium.com/max/552/0*fCYXWrvqOrUwLzp3.png 276w, https://miro.medium.com/max/1104/0*fCYXWrvqOrUwLzp3.png 552w, https://miro.medium.com/max/1280/0*fCYXWrvqOrUwLzp3.png 640w, https://miro.medium.com/max/1400/0*fCYXWrvqOrUwLzp3.png 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><p id="33ea" data-selectable-paragraph=""><em>Note that this code assumes that </em><code><em>Environment.ProcessorCount</em></code><em> is lower or equal to 8 on your machine. If it’s bigger, then the ThreadPool will start with more thread available, and you need to lower the delay of the </em><code><em>Thread.Sleep</em></code><em> in </em><code><em>Producer()</em></code><em> to set the same conditions.</em></p><p id="92ac" data-selectable-paragraph="">Looking at the task manager, we can see that CPU usage is 0 and the number of threads is growing at about one per second:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/0*BT4GUCFcHoe8sUdK.png?q=20" width="725" height="52" role="presentation"></p><p><img width="725" height="52" srcset="https://miro.medium.com/max/552/0*BT4GUCFcHoe8sUdK.png 276w, https://miro.medium.com/max/1104/0*BT4GUCFcHoe8sUdK.png 552w, https://miro.medium.com/max/1280/0*BT4GUCFcHoe8sUdK.png 640w, https://miro.medium.com/max/1400/0*BT4GUCFcHoe8sUdK.png 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><p id="29bc" data-selectable-paragraph="">Here I’ve let it run for a while and got to a whopping 989 threads, yet still nothing is happening! Even though 10 threads should be enough to handle the workload. So what’s going on?</p><p id="3236" data-selectable-paragraph="">Every bit is important in that code. For instance, if we remove <code>Task.Yield</code> and manually start new tasks instead in <code>Producer</code> (the comments indicate the changes):</p><figure><div></div></figure><p id="9437" data-selectable-paragraph="">Then we get the predicted behavior! The application struggles a bit at first, until the ThreadPool grows enough. Then we have a steady stream of messages, and the number of threads is stable (29 in my case).</p><p id="2f07" data-selectable-paragraph="">What if we take that working code but start <code>Producer</code><strong> </strong>in its own thread?</p><figure><div></div></figure><p id="91fc" data-selectable-paragraph="">This frees one thread from the ThreadPool, so we should expect it to work slightly better. Yet, we end up with the first case: the application displays a few messages before locking up, and the number of threads grows indefinitely.</p><p id="f7e2" data-selectable-paragraph="">Let’s put <code>Producer</code> back to a ThreadPool thread, but use the <code>PreferFairness</code> flag when starting the <code>Process</code> tasks:</p><figure><div></div></figure><p id="9705" data-selectable-paragraph="">Then once again we end up with the first situation: the application locks up, and the number of threads increases indefinitely.</p><p id="22e0" data-selectable-paragraph="">So, what is really going on?</p><p id="d93f" data-selectable-paragraph="">To understand what’s happening, we need to dig into the internals of the ThreadPool. More specifically, in the way, the work-items are queued.</p><p id="4f7d" data-selectable-paragraph="">There are a few articles out there explaining how the ThreadPool queuing works (<a href="http://www.danielmoth.com/Blog/New-And-Improved-CLR-4-Thread-Pool-Engine.aspx" target="_blank" rel="noopener nofollow">http://www.danielmoth.com/Blog/New-And-Improved-CLR-4-Thread-Pool-Engine.aspx</a>). In a nutshell, the important part is that the ThreadPool has multiple queues. For N threads in the ThreadPool, there are N+1 queues: one local queue for each thread, and one global queue. The rules for picking in which queue your item will go are simple:</p><p id="723e" data-selectable-paragraph="">The item will be enqueued to the global queue:</p><ul><li id="1778" data-selectable-paragraph="">If the thread that enqueues the item is not a ThreadPool thread</li><li id="60eb" data-selectable-paragraph="">If it uses <code>ThreadPool.QueueUserWorkItem</code><strong> </strong>or <code>ThreadPool.UnsafeQueueUserWorkItem</code></li><li id="5e21" data-selectable-paragraph="">If it uses <code>Task.Factory.StartNew</code> with the<strong> </strong><code>TaskCreationOptions.PreferFairness</code> flag</li><li id="8ae1" data-selectable-paragraph="">If it uses <code>Task.Yield</code> on the default task scheduler</li></ul><p id="ce0f" data-selectable-paragraph="">In pretty much all other cases, the item will be enqueued to the thread’s local queue.</p><p id="6c8a" data-selectable-paragraph="">How are the items dequeued? Whenever a ThreadPool thread is free, it will start looking into its local queue, and dequeue items in LIFO order. If the local queue is empty, then the thread will look into the global queue and dequeue in the FIFO order. If the global queue is also empty, then the thread will look into the local queues of other threads and dequeue in FIFO order (to reduce the contention with the owner of the queue, which dequeues in LIFO order).</p><h2 id="eebf" data-selectable-paragraph="">How does that impact us? Let’s go back to our faulty code.</h2><p id="ed2a" data-selectable-paragraph="">In all the variations of the code, the <code>Thread.Sleep(1000)</code> is enqueued in a local queue, because <code>Process</code> is always executed in a ThreadPool thread. But in some cases we enqueue <code>Process</code> in the global queue and in others in the local queues:</p><ul><li id="58eb" data-selectable-paragraph="">In the first version of the code, we use <code>Task.Yield</code>, which queues to the global queue</li><li id="3f8d" data-selectable-paragraph="">In the second version, we use <code>Task.Factory.StartNew</code>, which queues to the local queue</li><li id="8ccb" data-selectable-paragraph="">In the third version, we change the <code>Producer</code> thread to not use the ThreadPool, so<strong> </strong><code>Task.Factory.StartNew</code> enqueues to the global queue</li><li id="4aa7" data-selectable-paragraph="">In the fourth version, <code>Producer</code> is a ThreadPool thread again but we use <code>TaskCreationOptions.PreferFairness</code> when enqueuing <code>Process</code>, thus using the global queue again</li></ul><p id="f7ee" data-selectable-paragraph="">We can see that the only version that worked was the one not using the global queue. From there, it’s just a matter of connecting the dots:</p><ul><li id="1f72" data-selectable-paragraph="">Initial condition: we put our system in a state where the ThreadPool is starved (i.e. all the threads are busy)</li><li id="d944" data-selectable-paragraph="">We enqueue 5 items per second into the global queue</li><li id="8312" data-selectable-paragraph="">Each of those items, when executing, enqueues another item into the local queue and waits for it</li><li id="5ef9" data-selectable-paragraph="">When a new thread is spawned by the ThreadPool, that thread will first look into its own local queue which is empty (since it’s newborn). Then it’ll pick an item from the global queue</li><li id="ff96" data-selectable-paragraph="">Since we enqueue into the global queue faster than the ThreadPool grows (5 items per second versus 1 thread per second), it’s completely impossible for the system to recover. Because of the priority induced by the usage of the global queue, <strong>the more threads we add, the more pressure we put on the system</strong></li></ul><p id="f7e1" data-selectable-paragraph="">When using the local queue instead (second version of the code), the newborn threads will pick items from the other threads’ local queues since the global queue is empty. Therefore, <strong>new threads help alleviate the pressure on the system.</strong></p><h2 id="e2ff" data-selectable-paragraph="">How does it translate to a real-world scenario?</h2><p id="7546" data-selectable-paragraph="">Take the case of an HTTP-based service. The HTTP stack, whether it uses Windows’ http.sys or another API, is most likely native. When it forwards new requests to the .NET user code, it’ll queue them in the ThreadPool. Those items will necessarily end up in the global queue since the native HTTP stack can’t possibly use .NET ThreadPool threads. Then the user code relies on async/await, and very likely uses the local queues all the way. It means that in a situation of starvation, new threads spawned by the ThreadPool will process the new requests (enqueued in the global queue by the native code) rather than completing the ones already in the pipe (enqueued in the local queues). Therefore, <strong>we end up in the situation previously described where every new thread adds even more pressure to the system.</strong></p><p id="82e6" data-selectable-paragraph="">Another situation where things can turn ugly is if the blocking code is running as part of the callback of a timer. Timer callbacks are enqueued into the global queue. I believe such a case can be found here (pay close attention to the <code>TimerQueueTimer.Fire</code> call at the beginning of the callstack for the 1202 threads shown): <a href="https://blogs.msdn.microsoft.com/vsoservice/?p=17665" target="_blank" rel="noopener nofollow">https://blogs.msdn.microsoft.com/vsoservice/?p=17665</a>.</p><p id="26da" data-selectable-paragraph="">From a user-code perspective, unfortunately not much. Of course, in an ideal world, we would use non-blocking code and never end up in a ThreadPool starvation situation. Using a dedicated pool of threads around the blocking calls can help a lot, as you stop competing with the global queue for new threads. Having a back-pressure system is a good idea too. At Criteo we’re experimenting with a back-pressure system that measures how long it takes for the ThreadPool to dequeue an item from a local queue. If it takes longer than a few configured threshold, then we stop processing incoming requests until the system recovers. So far it shows promising results.</p><p id="c1eb" data-selectable-paragraph="">From a BCL perspective, I believe we should treat the global queue as just another local queue. I can’t really see a reason why it should be treated in priority compared to all other local queues. If we’re afraid that the global queue would grow quicker than the other queues, we could put a weight on the random selection of the queue. It would probably require some adjustments, but this is worth exploring.</p></div></div></section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>