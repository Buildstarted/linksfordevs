<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Fixing Random, bonus episode 2: pigeons and the noisy-or&#xA0;distribution -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Fixing Random, bonus episode 2: pigeons and the noisy-or&#xA0;distribution</h1>
    <div class="entry-content"> <p>Source code for this episode is <a href="https://github.com/ericlippert/probability/tree/bonus02">here</a>.</p> <p>Welcome to this special bonus episode of <em><a href="https://ericlippert.com/tag/fixing_random/">Fixing Random</a>,</em> the immensely long blog series where I discuss ways to add probabilistic programming features into C#. I ran into an interesting problem at work that pertains to the techniques that we discussed in this series, so I thought I might discuss it a bit today.</p>
<p>Let&#x2019;s suppose we have three forts, Fort Alpha, Fort Bravo and Fort Charlie at the base of a mountain. They are constantly passing messages back and forth by carrier pigeon. Alpha and Charlie are too far apart to fly a pigeon directly, so messages from Alpha to Charlie first go from Alpha to Bravo, and then on from Bravo to Charlie. (Similarly. messages from Charlie to Alpha go via Bravo, but we&#x2019;ll not worry about that direction for the purposes of this discussion.)</p>
<p>Carrier pigeons are of course an unreliable mechanism for passing messages, so let&#x2019;s model this as a Bernoulli process; every time we send a message from Alpha to Bravo, or Bravo to Charlie, we flip an unfair coin. Heads, the bird gets through, tails it gets lost along the way.</p>
<p>From this we can predict the reliability of passing a message from Alpha to Charlie via Bravo; the probability of failure is the probability that A-B fails or B-C fails (or both). Equivalently, the probability of success is the probability of A-B succeeding and B-C succeeding. This is just straightforward, basic probability; if the probability of success from A-B is, say, 95% and B-C is 96%, then the probability of success from A to C is their product, around 91%.</p> <p><strong>Aside:</strong> Note that I am assuming in this article that pigeons are passing from Bravo to Charlie even if a pigeon failed to arrive from Alpha; I&#x2019;m <em>not</em> trying to model in this system constraints like &#x201C;pigeons only fly from Bravo to Charlie when one arrived from Alpha&#x201D;.</p> <p>Now let&#x2019;s add an extra bit of business.</p>
<p>We have an observer on the mountaintop at Fort Delta overlooking Alpha, Bravo and Charlie. Delta has some high-power binoculars and is recording carrier pigeon traffic from Alpha to Bravo and Bravo to Charlie. But here&#x2019;s the thing: Delta is an unreliable observer, because observing carrier pigeons from a mountaintop is inherently error-prone; <i>sometimes Delta will fail to see a pigeon. </i>Let&#x2019;s say that 98% of the time, Delta observes a pigeon that is there, and Delta never observes a pigeon that is not there.</p>
<p>Every so often, Delta issues a report: either &#x201C;<em>the channel from Alpha to Charlie is healthy</em>&#x201D; if Delta has observed a pigeon making it from Alpha to Bravo <em>and</em> also a pigeon making it from Bravo to Charlie. But if Delta has just failed to observe either a pigeon going from Alpha to Bravo, <em>or</em> a pigeon going from Bravo to Charlie, then Delta issues a report saying &#x201C;<em>the channel from Alpha to Charlie is unhealthy</em>&#x201C;.</p>
<p>The question now is: suppose Delta issues a report that the Alpha-Charlie channel is unhealthy. <i>What is the probability that a pigeon failed to get from Alpha to Bravo, and what is the probability that a pigeon failed to get from Bravo to Charlie?</i> Each is surely much higher than the 5-ish percent chance that is our prior.</p>
<p>We can use the gear we developed in the early part of my Fixing Random series to answer this question definitively, but before we do, <strong>make a prediction. </strong>If you recall <a href="https://ericlippert.com/2019/03/25/fixing-random-part-16/">episode 16</a>, you&#x2019;ll remember that you can have a 99% accurate test but the posterior probability of having the disease that the test diagnoses is only 50% when you test positive;<em> this is a variation on that scenario.</em></p>
<p>Rather than defining multiple enumerated types as I did in earlier episodes, or even using bools, let&#x2019;s just come up with a straightforward numeric encoding. We&#x2019;ll say that <strong>1</strong> represents &#x201C;a pigeon failed to make the journey&#x201D;, and <strong>0</strong> means &#x201C;a pigeon successfully made the journey&#x201D; &#x2014; if that seems backwards to you, I agree but it will make sense in a minute.</p>
<p>Similarly, we&#x2019;ll say that <strong>1</strong> represents &#x201C;Delta&#x2019;s attempt to observe a pigeon has failed&#x201D;, and <strong>0</strong> as success, and finally, that <strong>1</strong> represents Delta making the report &#x201C;the channel is unhealthy&#x201D; and <strong>0</strong> represents &#x201C;the channel is healthy&#x201D;.</p>
<p>The reason I&#x2019;m using <strong>1</strong> in all these cases to mean &#x201C;something failed&#x201D; is because I want to use <strong>OR</strong> to get the final result. Let&#x2019;s build our model:</p>
<pre>var ab = Bernoulli.Distribution(95, 5);
var bc = Bernoulli.Distribution(96, 4);
var d = Bernoulli.Distribution(98, 2);</pre>
<ul>
<li>5% of the time <code>ab</code> reports <strong>1</strong>: the pigeon failed to get through.</li>
<li>4% of the time, <code>bc</code>reports <strong>1</strong>: the pigeon failed to get through.</li>
<li>2% of the time, <code>d</code> reports <strong>1</strong>: it fails to see a pigeon that is there.</li>
</ul>
<p>Now we can ask and answer our question about the posterior: what do we know about the posterior distribution of pigeons making it from Alpha to Bravo and Bravo to Charlie? We&#x2019;ll sample from <code>ab</code> and <code>bc</code> once to find out if a pigeon failed to get through, and then ask whether Delta failed to observe the pigeons.</p>
<p>What is the condition that causes Delta to report that the channel is unhealthy?</p>
<ul>
<li>the pigeon from Alpha to Bravo failed, OR</li>
<li>the pigeon from Bravo to Charlie failed, OR</li>
<li>Delta failed to observe Alpha&#x2019;s pigeon, OR</li>
<li>Delta failed to observe Bravo&#x2019;s pigeon.</li>
</ul>
<p>We observe that Delta reports that the channel is unhealthy, so we&#x2019;ll add a <strong>where</strong> clause to condition the result, and then print out the resulting posterior joint probability:</p>
<pre>var result = from pab in ab
 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;from pbc in bc
 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; from oab in d
 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;from obc in d
 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; let report = pab | pbc | oab | obc
 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;where report == 1
 &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;select (pab, pbc);
Console.WriteLine(result.ShowWeights());</pre>
<p>This is one of several possible variations on the &#x201C;<strong>noisy OR distribution</strong>&#x201D; &#x2014; that is, the distribution that we get when we <strong>OR</strong> together a bunch of random Boolean quantities, but where the <strong>OR</strong> operation itself has some probabilistic &#x201C;noise&#x201D; attached to it.</p> <p><strong>Aside:</strong> That&#x2019;s why I wanted to express this in terms of OR-ing together quantities; of course we can always turn this into a &#x201C;noisy AND&#x201D; by doing the appropriate arithmetic, but typically this distribution is called &#x201C;noisy OR&#x201D;.</p> <p>We get these results:</p>
<pre>(0, 0):11286&#xA0;   -- about 29%
(0, 1):11875&#xA0;   -- about 30%
(1, 0):15000    -- about 39%
(1, 1):625&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; -- less than 2%</pre>
<p>Remember that <strong>(0, 0)</strong> means that pigeons <em>did</em> make it from Alpha to Bravo and from Bravo to Charlie; in every other case we had at least one failure.</p>
<p>It should not be too surprising that <strong>(1, 1)</strong> &#x2014; both the Alpha and Bravo pigeons failed simultaneously &#x2014; is the rarest case because after all, that happens less than 9% of the cases overall, so it certainly should happen in some smaller percentage of the &#x201C;unhealthy report&#x201D; cases.</p>
<p>But the possibly surprising result is: when Delta reports a failure, there is a 29% chance that this is a false positive report of failure, and in fact it is almost as likely to be a false positive as it is to be a dropped packet, I mean <em>lost&#xA0;pigeon</em>, between Bravo and Charlie!</p>
<p>Put another way, if you get an &#x201C;unhealthy&#x201D; report, 3 times out of 10, the report is wrong and you&#x2019;ll be chasing a wild goose. Just as we saw with false positives for tests for diseases, <em>if the test failure rate is close to the disease rate of the population, then false positives make up a huge percentage of all positives.</em></p>
<p>My slip-up there of course illuminates what you figured out long ago; all of this whimsy about forts and pigeons and mountains is just a silly analogy. Of course what we really have is not three forts connected by two carrier pigeon routes, but ten thousand machines and hundreds of routers in a data center connected by network cabling in a known topology. Instead of pigeons we have trillions of packets. Instead of an observer in a fort on a mountaintop, we have special supervising software or hardware that is trying to detect failures in the network so that they can be diagnosed and fixed. Since the failure detection system is itself part of the network, it <i>also</i> is unreliable, which introduces &#x201C;noise&#x201D; into the system.</p>
<p>The real question at hand is: given prior probabilities on the reliability of each part of the system including the reporting system itself, <i>what are the most likely posterior probabilities that explain a report that some part of the network is unhealthy</i>?</p>
<p>This is a highly practical and interesting question to answer because it means that network engineers can quickly narrow down the list of possible faulty components given a failure report to the most likely culprits.&#xA0; <b>The power of probabilistic extensions in programming languages is that we now have the tools that we need to concisely express both those models and the observations that we need explanations for, and then generate the answers automatically.</b></p>
<p>Of course I have just given some of the flavor of this problem space and I&#x2019;m sure you can imagine a dozen ways to make the problem more interesting:</p>
<ul>
<li>what if instead of a coin flip that represent &#x201C;dropped&#x201D; or &#x201C;delivered&#x201D; on a packet, we had a more complex distribution on every edge of the network topology graph &#x2014; say, representing average throughput?</li>
<li>How does moving to a system with continuous probabilities change our analysis and the cost of producing that analysis?</li>
<li>And so on.</li>
</ul>
<p>We can use the more complex tools I developed in my series, like the Metropolis method, to solve these harder problems; however, I think I&#x2019;ll leave it at that for now.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>