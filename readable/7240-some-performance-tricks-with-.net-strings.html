<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Some performance tricks with .NET strings -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><div><div class="q" itemprop="articleBody"><p>I've created a <a href="https://github.com/aspnet/AspNetCore/pull/6784">pull request<i class="fa-external-link e f"></i></a> on the ASP.NET Core repository. At the beginning, the changes were just about changing the unsafe code (<code>char*</code>) for <code>stackalloc</code> to a safe version with <code>Span&lt;T&gt;</code>. So, it was a very small change. During the review, <a href="https://github.com/lkts">Oleksandr Kolomiiets<i class="fa-external-link e f"></i></a>, <a href="https://github.com/gfoidl">GÃ¼nther Foidl<i class="fa-external-link e f"></i></a>, and <a href="https://github.com/davidfowl">David Fowler<i class="fa-external-link e f"></i></a> have suggested a few additional changes to improve the performance. Thank you very much for taking the time to review the PR! The comments were very interesting, so I've decided to explain them in a post.</p><p class="m"><a href="https://twitter.com/davidfowl/status/1086884513278357504"><img src="/assets/tweet.png?v=edc34c41&amp;utm_medium=social&amp;utm_source=web" width="459" height="253"><i class="fa-external-link e f"></i></a></p><p>Here's the explanation of each change, and you'll see that the final code is twice more performant than the initial code!</p><h2 id="original-code"><a class="j" href="#original-code">#</a>Original code</h2><p>The code allows encoding a <code>long</code> number into a base 32 string. The code has already been optimized as explained in the comment, but we'll see how can optimize even more!</p><pre><code class="language-csharp"><span class="b">private</span><span class="b">static</span><span class="b">readonly</span><span class="b">string</span> s_encode32Chars <span class="c">=</span><span class="k">"0123456789ABCDEFGHIJKLMNOPQRSTUV"</span><span class="a">;</span><span class="b">public</span><span class="b">static</span><span class="b">unsafe</span><span class="b">string</span><span class="h">GenerateId</span><span class="a">(</span><span class="b">long</span> id<span class="a">)</span><span class="a">{</span><span class="g">// The following routine is ~310% faster than calling long.ToString() on x64</span><span class="g">// and ~600% faster than calling long.ToString() on x86 in tight loops of 1 million+ iterations</span><span class="g">// See: https://github.com/aspnet/Hosting/pull/385</span><span class="g">// stackalloc to allocate array on stack rather than heap</span><span class="b">char</span><span class="c">*</span> buffer <span class="c">=</span><span class="b">stackalloc</span><span class="b">char</span><span class="a">[</span><span class="d">13</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">0</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">60</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">1</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">55</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">2</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">50</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">3</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">45</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">4</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">40</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">5</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">35</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">6</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">30</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">7</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">25</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">8</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">20</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">9</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">15</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">10</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">10</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">11</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">5</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">12</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span>id <span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="b">return</span><span class="b">new</span><span class="b">string</span><span class="a">(</span>buffer<span class="a">)</span><span class="a">;</span><span class="a">}</span></code></pre><h2 id="using-span-t"><a class="j" href="#using-span-t">#</a>Using Span&lt;T&gt;</h2><p>My first commit replaces the unsafe code with <code>Span&lt;char&gt;</code>. It is nothing more that a small rewrite that doesn't impact the performance. This change is now possible as ASP.NET Core 3 will only support .NET Core 3. ASP.NET Core 2.2 targets .NET Standard 2.0 which doesn't contain <code>Span&lt;T&gt;</code>. If you are not familiar with <code>Span</code>s, you should read the <a href="https://twitter.com/SitnikAdam">Adam Sitnik<i class="fa-external-link e f"></i></a>'s post: <a href="https://adamsitnik.com/Span/">https://adamsitnik.com/Span/<i class="fa-external-link e f"></i></a>.</p><p>Here're the changes:</p><pre><code class="language-csharp"><span class="b">private</span><span class="b">static</span><span class="b">readonly</span><span class="b">string</span> s_encode32Chars <span class="c">=</span><span class="k">"0123456789ABCDEFGHIJKLMNOPQRSTUV"</span><span class="a">;</span><span class="g">// Remove unsafe keyword</span><span class="b">public</span><span class="b">static</span><span class="b">string</span><span class="h">GenerateId</span><span class="a">(</span><span class="b">long</span> id<span class="a">)</span><span class="a">{</span><span class="g">// Replace char* with Span&lt;T&gt;</span>
    Span<span class="c">&lt;</span><span class="b">char</span><span class="c">&gt;</span> buffer <span class="c">=</span><span class="b">stackalloc</span><span class="b">char</span><span class="a">[</span><span class="d">13</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">0</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">60</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">1</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">55</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="a">.</span><span class="a">.</span><span class="a">.</span>
    buffer<span class="a">[</span><span class="d">11</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span>id <span class="c">&gt;&gt;</span><span class="d">5</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
    buffer<span class="a">[</span><span class="d">12</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span>id <span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="b">return</span><span class="b">new</span><span class="b">string</span><span class="a">(</span>buffer<span class="a">,</span><span class="d">0</span><span class="a">,</span><span class="d">13</span><span class="a">)</span><span class="a">;</span><span class="a">}</span></code></pre><h2 id="using-string-create"><a class="j" href="#using-string-create">#</a>Using string.Create</h2><p>A first optimization is to use <code>string.Create</code>. In the previous code, a buffer is created on the stack, then the string is created on the heap from the buffer. This means the buffer is copied to the new string instance. Using <code>string.Create</code> we avoid the copy of the buffer. The method allocates the string directly on the heap and you can set the content using the delegate (<a href="https://github.com/dotnet/corefx/blob/88ec3d985b4879bd77b7821f154663099e7bae29/src/Common/src/CoreLib/System/String.cs#L343">code on GitHub<i class="fa-external-link e f"></i></a>).</p><pre><code class="language-csharp"><span class="b">private</span><span class="b">static</span><span class="b">readonly</span><span class="b">string</span> s_encode32Chars <span class="c">=</span><span class="k">"0123456789ABCDEFGHIJKLMNOPQRSTUV"</span><span class="a">;</span><span class="b">public</span><span class="b">static</span><span class="b">string</span><span class="h">GenerateId</span><span class="a">(</span><span class="b">long</span> id<span class="a">)</span><span class="a">{</span><span class="b">return</span><span class="b">string</span><span class="a">.</span><span class="h">Create</span><span class="a">(</span><span class="d">13</span><span class="a">,</span> id<span class="a">,</span><span class="a">(</span>buffer<span class="a">,</span><span class="b">value</span><span class="a">)</span><span class="c">=&gt;</span><span class="a">{</span><span class="g">// Do not use "id" here as it would create a closure and allocate</span><span class="g">// instead use "value" (read hereafter for more details)</span>
        buffer<span class="a">[</span><span class="d">0</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">60</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
        buffer<span class="a">[</span><span class="d">1</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">55</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="a">.</span><span class="a">.</span><span class="a">.</span>
        buffer<span class="a">[</span><span class="d">11</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">5</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
        buffer<span class="a">[</span><span class="d">12</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="b">value</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="a">}</span><span class="a">}</span></code></pre><p>You may have notice that I do not use <code>id</code> inside the lambda expression. Indeed, it would introduce a closure. A closure is bad here as the delegate cannot be cached, and a new delegate will be instantiated each time the method is called. In the end, this would decrease the performance (about 30% in this case) and add some pressure to the GC. This is the reason why the second parameter of <code>String.Create</code> exists. This parameter prevents the use of a closure. You can read more about closure on <a href="https://blog.jetbrains.com/dotnet/2014/07/24/unusual-ways-of-boosting-up-app-performance-lambdas-and-linqs/">the Jetbrains'blog<i class="fa-external-link e f"></i></a>.</p><p>The benchmark indicates using <code>string.Create</code> is about 35% faster!</p><p><a href="https://twitter.com/stevejgordon">Steve Gordon<i class="fa-external-link e f"></i></a> has written a post about string.Create: <a href="https://www.stevejgordon.co.uk/creating-strings-with-no-allocation-overhead-using-string-create-csharp">Creating Strings with No Allocation Overhead Using String.Create<i class="fa-external-link e f"></i></a></p><h2 id="reversing-assignatio"><a class="j" href="#reversing-assignatio">#</a>Reversing assignation order</h2><p>David Fowler has suggested to reverse the assignation order (e.g. assign <code>buffer[12]</code> then <code>buffer[11]</code> and so on). This allows the JIT to not add <a href="https://en.wikipedia.org/wiki/Bounds_checking">bounds checks<i class="fa-external-link e f"></i></a>. Indeed, if you can access the index 12, there is no reason for lower indices to be out of range.</p><pre><code class="language-csharp"><span class="b">private</span><span class="b">static</span><span class="b">readonly</span><span class="b">string</span> s_encode32Chars <span class="c">=</span><span class="k">"0123456789ABCDEFGHIJKLMNOPQRSTUV"</span><span class="a">;</span><span class="b">public</span><span class="b">static</span><span class="b">string</span><span class="h">GenerateId</span><span class="a">(</span><span class="b">long</span> id<span class="a">)</span><span class="a">{</span><span class="b">return</span><span class="b">string</span><span class="a">.</span><span class="h">Create</span><span class="a">(</span><span class="d">13</span><span class="a">,</span> id<span class="a">,</span><span class="a">(</span>buffer<span class="a">,</span><span class="b">value</span><span class="a">)</span><span class="c">=&gt;</span><span class="a">{</span><span class="g">// Assign buffer from 12 to 0 to avoid a bound check</span>
        buffer<span class="a">[</span><span class="d">12</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="b">value</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
        buffer<span class="a">[</span><span class="d">11</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">5</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="a">.</span><span class="a">.</span><span class="a">.</span>
        buffer<span class="a">[</span><span class="d">1</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">55</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
        buffer<span class="a">[</span><span class="d">0</span><span class="a">]</span><span class="c">=</span> s_encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">60</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="a">}</span><span class="a">}</span></code></pre><p>While the JIT emits an optimized code, the optimized version does have the same performance on my computer. As suggested by GÃ¼nther Foidl, it may be because the <a href="https://en.wikipedia.org/wiki/Branch_predictor">branch predictor of the CPU<i class="fa-external-link e f"></i></a> is doing a good job in this case. It doesn't mean this optimization is not useful. Other CPU may not have a good branch prediction in this case. Also, the size of the emitted code is smaller, which is always a good thing.</p><aside class="kb"><p><i class="fa-lightbulb e n"></i><strong>Tip:</strong> Using BenchmarkDotNet you can easily get the assembly code by using the attribute <code>[DisassemblyDiagnoser(printAsm: true, printSource: true)]</code>.</p></aside><p></p><p>Here's the assembly code generated by the JIT with the optimization.</p><p class="m"><img src="/assets/boundscheck.png?v=e4f9ceba&amp;utm_medium=social&amp;utm_source=web" width="800" height="668" srcset="/assets/boundscheck-th-w500-h0.png?v=effb9c24&amp;utm_medium=social&amp;utm_source=web 500w,/assets/boundscheck.png?v=e4f9ceba&amp;utm_medium=social&amp;utm_source=web 800w" sizes="100vw"></p><p>The full assembly code is available on <a href="https://gist.github.com/meziantou/7ab15c70f7e9fc0b55dec4b074fb3209#file-bounds-check-assembly-txt">the following Gist<i class="fa-external-link e f"></i></a>:</p><ul><li><a href="https://gist.github.com/meziantou/7ab15c70f7e9fc0b55dec4b074fb3209#file-bounds-check-assembly-txt-L273">Unoptimized version<i class="fa-external-link e f"></i></a>: You can see the bounds check at every access (line 273, 286, 297, and so on)</li><li><a href="https://gist.github.com/meziantou/7ab15c70f7e9fc0b55dec4b074fb3209#file-bounds-check-assembly-txt-L76">Optimized version<i class="fa-external-link e f"></i></a>: You can see there is a bounds check only for the first access (line 76), but not for the next accesses (line 88)</li></ul><h2 id="copying-the-field-in"><a class="j" href="#copying-the-field-in">#</a>Copying the field into a local variable</h2><p>The JIT must emit code to load <code>s_encode32Chars</code> for each access, as it is a mutable array (the reference is <code>readonly</code>, but the elements are not immutable) and from JIT's point of view the elements could change, so the <em>fresh</em> data must be loaded.</p><p>This can be avoided by loading it once into a local, where the JIT can track that nothing changes, and read-only access is done.</p><pre><code class="language-csharp"><span class="b">private</span><span class="b">static</span><span class="b">readonly</span><span class="b">string</span> s_encode32Chars <span class="c">=</span><span class="k">"0123456789ABCDEFGHIJKLMNOPQRSTUV"</span><span class="a">;</span><span class="b">public</span><span class="b">static</span><span class="b">string</span><span class="h">GenerateId</span><span class="a">(</span><span class="b">long</span> id<span class="a">)</span><span class="a">{</span><span class="b">return</span><span class="b">string</span><span class="a">.</span><span class="h">Create</span><span class="a">(</span><span class="d">13</span><span class="a">,</span> id<span class="a">,</span><span class="a">(</span>buffer<span class="a">,</span><span class="b">value</span><span class="a">)</span><span class="c">=&gt;</span><span class="a">{</span><span class="g">// Copy the reference</span><span class="b">var</span> encode32Chars <span class="c">=</span> s_encode32Chars<span class="a">;</span>

        buffer<span class="a">[</span><span class="d">12</span><span class="a">]</span><span class="c">=</span> encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="b">value</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
        buffer<span class="a">[</span><span class="d">11</span><span class="a">]</span><span class="c">=</span> encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">5</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="a">.</span><span class="a">.</span><span class="a">.</span>
        buffer<span class="a">[</span><span class="d">1</span><span class="a">]</span><span class="c">=</span> encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">55</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
        buffer<span class="a">[</span><span class="d">0</span><span class="a">]</span><span class="c">=</span> encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">int</span><span class="a">)</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">60</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="a">}</span><span class="a">}</span></code></pre><p>The benchmark indicates the code is about 4% faster than the previous version!</p><p class="m"><a href="/assets/loadstring.png?v=d5fe94a6&amp;utm_medium=social&amp;utm_source=web"><img src="/assets/loadstring.png?v=d5fe94a6&amp;utm_medium=social&amp;utm_source=web" width="800" height="482" srcset="/assets/loadstring-th-w500-h0.png?v=8b2b76fc&amp;utm_medium=social&amp;utm_source=web 500w,/assets/loadstring-th-w800-h0.png?v=79ad7cf1&amp;utm_medium=social&amp;utm_source=web 800w,/assets/loadstring.png?v=d5fe94a6&amp;utm_medium=social&amp;utm_source=web 1139w" sizes="100vw"></a></p><h2 id="removing-the-explici"><a class="j" href="#removing-the-explici">#</a>Removing the explicit cast</h2><p>The last optimization is to remove the explicit cast to <code>int</code>. The indexer of a string only accept an <code>int</code>, hence the cast. But, we can easily change the string to <code>char[]</code>, so we can use a <code>long</code> as the indexer. Without the casts the JIT produces better code for 64bit systems. For 32bit systems additional code may be generated, resulting in worse performance. But most of the application are now on 64bits (especially web servers), so this change should be acceptable.</p><pre><code class="language-csharp"><span class="g">// Change from string to char[], so we can use the long</span><span class="b">private</span><span class="b">static</span><span class="b">readonly</span><span class="b">char</span><span class="a">[</span><span class="a">]</span> s_encode32Chars <span class="c">=</span><span class="k">"0123456789ABCDEFGHIJKLMNOPQRSTUV"</span><span class="a">.</span><span class="h">ToCharArray</span><span class="a">(</span><span class="a">)</span><span class="a">;</span><span class="b">public</span><span class="b">static</span><span class="b">string</span><span class="h">GenerateId</span><span class="a">(</span><span class="b">long</span> id<span class="a">)</span><span class="a">{</span><span class="b">return</span><span class="b">string</span><span class="a">.</span><span class="h">Create</span><span class="a">(</span><span class="d">13</span><span class="a">,</span> id<span class="a">,</span><span class="a">(</span>buffer<span class="a">,</span><span class="b">value</span><span class="a">)</span><span class="c">=&gt;</span><span class="a">{</span><span class="b">var</span> encode32Chars <span class="c">=</span> s_encode32Chars<span class="a">;</span><span class="g">// Remove explicit cast in the indexer</span>
        buffer<span class="a">[</span><span class="d">12</span><span class="a">]</span><span class="c">=</span> encode32Chars<span class="a">[</span><span class="b">value</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
        buffer<span class="a">[</span><span class="d">11</span><span class="a">]</span><span class="c">=</span> encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">5</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="a">.</span><span class="a">.</span><span class="a">.</span>
        buffer<span class="a">[</span><span class="d">1</span><span class="a">]</span><span class="c">=</span> encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">55</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span>
        buffer<span class="a">[</span><span class="d">0</span><span class="a">]</span><span class="c">=</span> encode32Chars<span class="a">[</span><span class="a">(</span><span class="b">value</span><span class="c">&gt;&gt;</span><span class="d">60</span><span class="a">)</span><span class="c">&amp;</span><span class="d">31</span><span class="a">]</span><span class="a">;</span><span class="a">}</span><span class="a">}</span></code></pre><p>The benchmark indicates the code is about 5% faster than the previous version!</p><h2 id="benchmark"><a class="j" href="#benchmark">#</a>Benchmark</h2><p>I've created a benchmark using <a href="/comparing-implementations-with-benchmarkdotnet.htm?utm_medium=social&amp;utm_source=web" title="Comparing implementations with BenchmarkDotnet">BenchmarkDotNet</a> to measure how performant each change of the pull request is. You can find <a href="https://gist.github.com/meziantou/7ab15c70f7e9fc0b55dec4b074fb3209#file-code-cs">the code on Gist<i class="fa-external-link e f"></i></a>.</p><p class="m"><img src="/assets/benchmarkdotnet-3.png?v=da53775a&amp;utm_medium=social&amp;utm_source=web" width="800" height="142" srcset="/assets/benchmarkdotnet-3-th-w500-h0.png?v=6081801e&amp;utm_medium=social&amp;utm_source=web 500w,/assets/benchmarkdotnet-3.png?v=da53775a&amp;utm_medium=social&amp;utm_source=web 800w" sizes="100vw"></p><pre><code class="language-text">BenchmarkDotNet=v0.11.3, OS=Windows 10.0.17763.253 (1809/October2018Update/Redstone5)
Intel Core i5-6600 CPU 3.30GHz (Skylake), 1 CPU, 4 logical and 4 physical cores
.NET Core SDK=3.0.100-preview-009812
  [Host] : .NET Core 3.0.0-preview-27122-01 (CoreCLR 4.6.27121.03, CoreFX 4.7.18.57103), 64bit RyuJIT
  Core   : .NET Core 3.0.0-preview-27122-01 (CoreCLR 4.6.27121.03, CoreFX 4.7.18.57103), 64bit RyuJIT

Job=Core  Runtime=Core</code></pre><table><thead><tr><th>Method</th><th>Mean</th><th>Median</th><th>Allocated Memory/Op</th></tr></thead><tbody><tr><td>Original</td><td>34.21 ns</td><td>34.24 ns</td><td>48 B</td></tr><tr><td>Span</td><td>33.86 ns</td><td>33.77 ns</td><td>48 B</td></tr><tr><td>String.Create</td><td>21.87 ns</td><td>22.15 ns</td><td>48 B</td></tr><tr><td>String.Create with closure</td><td>46.30 ns</td><td>46.30 ns</td><td>136 B</td></tr><tr><td>Reverse assignation</td><td>21.69 ns</td><td>21.59 ns</td><td>48 B</td></tr><tr><td>Use local</td><td>18.95 ns</td><td>18.98 ns</td><td>48 B</td></tr><tr><td>Remove explicit cast</td><td>17.85 ns</td><td>17.16 ns</td><td>48 B</td></tr></tbody></table><aside class="lb"><p><i class="fa-info-circle e f"></i><strong>Note:</strong> the full data table is <a href="https://gist.github.com/meziantou/7ab15c70f7e9fc0b55dec4b074fb3209#file-results-md">available on Gist<i class="fa-external-link e f"></i></a></p></aside><p>The final code is twice faster than the original version and there is no more unsafe code. Thanks to all the reviewers of the <a href="https://github.com/aspnet/AspNetCore/pull/6784">pull request<i class="fa-external-link e f"></i></a> to help me discovering new C# features!</p><p>Here's another great post about these changes by <a href="https://twitter.com/NimaAra">Nima Ara<i class="fa-external-link e f"></i></a>: <a href="https://www.nimaara.com/generating-ids-in-csharp/">Generating IDs in C#, 'safely' and efficiently<i class="fa-external-link e f"></i></a></p><p>Do you have a question or a suggestion about this post? <a href="/contact.htm?utm_medium=social&amp;utm_source=web">Contact me!</a></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>