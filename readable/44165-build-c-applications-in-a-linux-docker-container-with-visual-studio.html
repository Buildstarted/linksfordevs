<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Build C&#x2B;&#x2B; Applications in a Linux Docker Container with Visual Studio -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Build C++ Applications in a Linux Docker Container with Visual Studio</h1><div><div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/04/IMG_1597-1-150x150.jpg" width="58" height="58" alt="Erika Sweet" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 alignnone photo"><p>Erika</p></div></div></div><p>December 13th, 2019</p><p>Docker containers provide a consistent development environment for building, testing, and deployment. The virtualized OS, file system, environment settings, libraries, and other dependencies are all encapsulated and shipped as one image that can be shared between developers and machines. This is especially useful for C++ cross-platform developers because you can target a container that runs a different operating system than the one on your development machine.</p><p>In this blog post we’re going to use Visual Studio’s native CMake support to build a simple Linux application in a Linux docker container over SSH. This post focuses on creating your first docker container and building from Visual Studio. If you’re interested in learning more about Docker as a tool to configure reproducible build environments, check out our post on <a href="https://devblogs.microsoft.com/cppblog/using-multi-stage-containers-for-c-development/">using multi-stage containers for C++ development.</a></p><p>This workflow leverages Visual Studio’s native support for CMake, but the same instructions can be used to build a <a href="https://docs.microsoft.com/en-us/cpp/linux/configure-a-linux-project?view=vs-2019">MSBuild-based Linux project in Visual Studio</a>.</p><h4>Set-up your first Linux docker container</h4><p>First, we’ll set-up a Linux docker container on Windows. You will need to download the <a href="https://www.docker.com/products/docker-desktop">Docker Desktop Client for Windows</a> and create a docker account if you haven’t already. See <a href="https://docs.docker.com/docker-for-windows/">Install Docker Desktop on Windows</a> for download information, system requirements, and installation instructions.</p><p>We’ll get started by pulling down an image of the <a href="https://hub.docker.com/_/ubuntu">Ubuntu OS</a> &nbsp;and running a few commands. From the Windows command prompt run:</p><p>This will download the latest image of Ubuntu from Docker. You can see a list of your docker images by running:</p><p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_images.png"><img class="aligncenter size-full wp-image-25288" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_images.png" alt="" width="958" height="52" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_images.png 958w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_images-300x16.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_images-768x42.png 768w" sizes="(max-width: 958px) 100vw, 958px"></a></p><p>Next, we’ll use a Dockerfile to create a custom image based on our local image of Ubuntu. Dockerfiles contain the commands used to assemble an image and allow you to automatically reproduce the same build environment from any machine. See <a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a> for more information on authoring your own Dockerfiles. The following Dockerfile can be used to install Visual Studio’s <a href="https://docs.microsoft.com/en-us/cpp/linux/download-install-and-setup-the-linux-development-workload?view=vs-2019#options-for-creating-a-linux-environment">required build tools&nbsp;</a>and configure SSH. CMake is also a required dependency but I will deploy <a href="https://github.com/microsoft/CMake/releases/tag/v3.15.3150938">statically linked binaries</a> directly from Visual Studio in a later step. Use your favorite text editor to create a file called ‘Dockerfile’ with the following content.</p><div id="crayon-5e398966c2809410203510" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" touchscreen minimize scroll-mouseover wrap"><p class="crayon-plain-wrap"><textarea class="crayon-plain print-no" data-settings="dblclick"># our local base image
FROM ubuntu 

LABEL description="Container for use with Visual Studio" 

# install build dependencies 
RUN apt-get update &amp;&amp; apt-get install -y g++ rsync zip openssh-server make 

# configure SSH for communication with Visual Studio 
RUN mkdir -p /var/run/sshd

RUN echo 'PasswordAuthentication yes' &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \ 
   ssh-keygen -A 

# expose port 22 
EXPOSE 22</textarea></p><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " data-settings="hide"></td><td class="crayon-code"><div class="crayon-pre"><p class="crayon-line" id="crayon-5e398966c2809410203510-1"># our local base image</p><p class="crayon-line" id="crayon-5e398966c2809410203510-2">FROM ubuntu</p><p class="crayon-line" id="crayon-5e398966c2809410203510-4">LABEL description="Container for use with Visual Studio"</p><p class="crayon-line" id="crayon-5e398966c2809410203510-6"># install build dependencies</p><p class="crayon-line" id="crayon-5e398966c2809410203510-7">RUN apt-get update &amp;&amp; apt-get install -y g++ rsync zip openssh-server make</p><p class="crayon-line" id="crayon-5e398966c2809410203510-9"># configure SSH for communication with Visual Studio</p><p class="crayon-line" id="crayon-5e398966c2809410203510-10">RUN mkdir -p /var/run/sshd</p><p class="crayon-line" id="crayon-5e398966c2809410203510-12">RUN echo 'PasswordAuthentication yes' &gt;&gt; /etc/ssh/sshd_config &amp;&amp; \</p><p class="crayon-line" id="crayon-5e398966c2809410203510-13">&nbsp;&nbsp; ssh-keygen -A</p><p class="crayon-line" id="crayon-5e398966c2809410203510-15"># expose port 22</p><p class="crayon-line" id="crayon-5e398966c2809410203510-16">EXPOSE 22</p></div></td></tr></tbody></table></div></div><p>We can then <a href="https://docs.docker.com/engine/reference/commandline/build/">build an image</a> based on our Dockerfile by running the following command from the directory where your Dockerfile is saved:</p><div id="crayon-5e398966c2817603390140" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" touchscreen minimize scroll-mouseover wrap"><p class="crayon-plain-wrap"><textarea class="crayon-plain print-no" data-settings="dblclick">&gt; docker build -t ubuntu-vs .</textarea></p><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " data-settings="hide"><p class="crayon-num" data-line="crayon-5e398966c2817603390140-1">1</p></td><td class="crayon-code"><p class="crayon-line" id="crayon-5e398966c2817603390140-1"><span class="crayon-h">&gt;</span><span class="crayon-h"></span><span class="crayon-e">docker </span><span class="crayon-i">build</span><span class="crayon-h"></span>-<span class="crayon-i">t</span><span class="crayon-h"></span><span class="crayon-i">ubuntu</span>-<span class="crayon-i">vs</span><span class="crayon-h"></span><span class="crayon-sy">.</span></p></td></tr></tbody></table></div></div><p>Next, we can <a href="https://docs.docker.com/engine/reference/commandline/run/">run a container</a> derived from our image:</p><div id="crayon-5e398966c2825558765693" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" touchscreen minimize scroll-mouseover wrap"><p class="crayon-plain-wrap"><textarea class="crayon-plain print-no" data-settings="dblclick">&gt; docker run -p 5000:22 -i -t ubuntu-vs /bin/bash</textarea></p><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " data-settings="hide"><p class="crayon-num" data-line="crayon-5e398966c2825558765693-1">1</p></td><td class="crayon-code"><p class="crayon-line" id="crayon-5e398966c2825558765693-1"><span class="crayon-h">&gt;</span><span class="crayon-h"></span><span class="crayon-e">docker </span><span class="crayon-i">run</span><span class="crayon-h"></span>-<span class="crayon-i">p</span><span class="crayon-h"></span><span class="crayon-cn">5000</span><span class="crayon-sy">:</span><span class="crayon-cn">22</span><span class="crayon-h"></span>-<span class="crayon-i">i</span><span class="crayon-h"></span>-<span class="crayon-i">t</span><span class="crayon-h"></span><span class="crayon-i">ubuntu</span>-<span class="crayon-i">vs</span><span class="crayon-h"></span>/<span class="crayon-i">bin</span>/<span class="crayon-i">bash</span></p></td></tr></tbody></table></div></div><p>The -p flag is used to expose the container’s internal port to the host. If this step was successful, then you should automatically attach to the running container. You can stop your docker container at any time and return to the command prompt using the <strong>exit </strong>command. To reattach, run <strong>docker ps -a</strong>, <strong>docker start &lt;container-ID&gt;</strong>, and <strong>docker attach &lt;container-ID&gt;</strong> from the command prompt.</p><p>Lastly, we will interact with our docker container directly to start SSH and create a user account to use with our SSH connection. Note that you can also enable root login and start SSH from your Dockerfile if you want to avoid any manual and container-specific configuration. Replace &lt;user-name&gt; with the username you would like to use and run:</p><div id="crayon-5e398966c2833523282082" class="crayon-syntax crayon-theme-classic crayon-font-monaco crayon-os-pc print-yes notranslate" data-settings=" touchscreen minimize scroll-mouseover wrap"><p class="crayon-plain-wrap"><textarea class="crayon-plain print-no" data-settings="dblclick">&gt; service ssh start
&gt; useradd -m -d /home/&lt;user-name&gt; -s /bin/bash -G sudo &lt;user-name&gt;
&gt; passwd &lt;user-name&gt;</textarea></p><div class="crayon-main"><table class="crayon-table"><tbody><tr class="crayon-row"><td class="crayon-nums " data-settings="hide"></td><td class="crayon-code"><div class="crayon-pre"><p class="crayon-line" id="crayon-5e398966c2833523282082-1"><span class="crayon-h">&gt;</span><span class="crayon-h"></span><span class="crayon-e">service </span><span class="crayon-e">ssh </span><span class="crayon-i">start</span></p><p class="crayon-line" id="crayon-5e398966c2833523282082-2"><span class="crayon-h">&gt;</span><span class="crayon-h"></span><span class="crayon-i">useradd</span><span class="crayon-h"></span>-<span class="crayon-i">m</span><span class="crayon-h"></span>-<span class="crayon-i">d</span><span class="crayon-h"></span>/<span class="crayon-i">home</span>/<span class="crayon-h">&lt;</span><span class="crayon-i">user</span>-<span class="crayon-i">name</span><span class="crayon-h">&gt;</span><span class="crayon-h"></span>-<span class="crayon-i">s</span><span class="crayon-h"></span>/<span class="crayon-i">bin</span>/<span class="crayon-i">bash</span><span class="crayon-h"></span>-<span class="crayon-i">G</span><span class="crayon-h"></span><span class="crayon-i">sudo</span><span class="crayon-h"></span><span class="crayon-h">&lt;</span><span class="crayon-i">user</span>-<span class="crayon-i">name</span><span class="crayon-h">&gt;</span></p><p class="crayon-line" id="crayon-5e398966c2833523282082-3"><span class="crayon-h">&gt;</span><span class="crayon-h"></span><span class="crayon-i">passwd</span><span class="crayon-h"></span><span class="crayon-h">&lt;</span><span class="crayon-i">user</span>-<span class="crayon-i">name</span><span class="crayon-h">&gt;</span></p></div></td></tr></tbody></table></div></div><p>The -m and -d flags create a user with the specified home directory, and the -s flag sets the user’s default shell.</p><p>You are now ready to connect to your container from Visual Studio.</p><h4>Connect to your docker container from Visual Studio</h4><p>Make sure you have <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2019</a> and the <a href="https://docs.microsoft.com/en-us/cpp/linux/download-install-and-setup-the-linux-development-workload?view=vs-2019#visual-studio-setup">Linux development with C++ workload</a> installed.</p><p>Open Visual Studio 2019 a create a new CMake Project. CMake is cross-platform and allows you to configure an application to run on both Windows and Linux.</p><p>Once the IDE has loaded, you can add a SSH connection to your Linux docker container the same way you would add any other <a href="https://docs.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=vs-2019">remote connection</a>. Navigate to the Connection Manager (Tools &gt; Options &gt; Cross Platform &gt; Connection Manager) and select “Add” to add a new remote connection.</p><p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_newConnection.png"><img class="aligncenter wp-image-25289" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_newConnection.png" alt="Add a new remote connection in Visual Studio, with input fields for host name, port, user name, authentication type, and password." width="500" height="489" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_newConnection.png 659w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_newConnection-300x294.png 300w" sizes="(max-width: 500px) 100vw, 500px"></a></p><p>Your host name should be “localhost”, the port should be whatever you are using for your SSH connection (in this example we’re using 5000), and your username and password should match the user account that you just created for your container.</p><h4>Configure build in Visual Studio</h4><p>At this point the project behaves like any other CMake project in Visual Studio. To configure and build the console application in our Linux container navigate to “Manage Configurations…” in the configuration drop-down.<a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_configurationDropDown.png"><img class="aligncenter wp-image-25290" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_configurationDropDown.png" alt="" width="500" height="147" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_configurationDropDown.png 654w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_configurationDropDown-300x88.png 300w" sizes="(max-width: 500px) 100vw, 500px"></a></p><p>You can then select the green plus sign in the CMake Settings Editor to add a new “Linux-Debug” configuration. Make sure that the remote machine name of your Linux configuration matches the remote connection we created for our Linux docker container.</p><p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_remoteMachineName.png"><img class="aligncenter wp-image-25291" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_remoteMachineName.png" alt="Remote machine name property in the CMake Settings Editor showing the local docker container I am connected to" width="750" height="103" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_remoteMachineName.png 1053w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_remoteMachineName-300x41.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_remoteMachineName-1024x140.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/12/docker_remoteMachineName-768x105.png 768w" sizes="(max-width: 750px) 100vw, 750px"></a></p><p>Save the CMake Settings Editor (ctrl + s) and select your new Linux configuration from the configuration drop-down to kick off a CMake configuration. If you don’t already have CMake installed on your docker container, then Visual Studio will prompt you to deploy <a href="https://github.com/microsoft/CMake/releases/tag/v3.15.3150938">statically linked binaries</a> directly to your remote connection as a part of the configure step.</p><p>At this point you can build your application in your Linux docker container directly from Visual Studio. Additional build settings (including custom toolchain files, CMake variables, and environment variables) can be configured in the <a href="https://docs.microsoft.com/en-us/cpp/build/customize-cmake-settings?view=vs-2019">CMake Settings Editor</a>. The underlying <a href="https://docs.microsoft.com/en-us/cpp/build/cmakesettings-reference?view=vs-2019">CMakeSettings.json file</a> can store multiple build configurations and can be checked into source control and shared between team members.</p><h4>Coming next</h4><p>This post showed you how to build a C++ application in a Linux docker container with Visual Studio. Stay tuned for our next post, where will we show you how to copy the build artifacts back to your local Windows machine and debug using gdbserver on a second remote system.</p><h4>Give us your feedback</h4><p>Do you have feedback on our Linux tooling or CMake support in Visual Studio? We’d love to hear from you to help us prioritize and build the right features for you. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">Developer Community</a>, email (<a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>), and Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p><div class="authorinfoarea"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>