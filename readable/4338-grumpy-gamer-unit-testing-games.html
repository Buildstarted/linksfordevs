<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Grumpy Gamer - Unit Testing Games -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Grumpy Gamer - Unit Testing Games</h1><div><div class="media-body"><p class="readability-styled" style="display: inline;">
    [Forgive me in advance for some SERIOUS 'thinking out loud.'&nbsp;&nbsp;It gets a little unstructured at times. Also, be warned: TWP spoilers.]</p><p>Let me first mention that I've never been a programmer for a paycheck; I've done quite a bit over the past few decades, but I doubt I'll be approaching things like a proper programmer. I'm mostly a "math guy in progress" at this point, although my interests are sort of "broad to the point that it's easy to accuse me of being unfocused."&nbsp;&nbsp;c'est la vie. </p><p>Anyhow, I had actually first started wondering about using graphs to describe game state and the like, back when I took discrete math several years ago.&nbsp;&nbsp;I didn't follow up on that at the time, as by that point anything having to do with game-making was perpetually on the backburner for me. But when the notion showed up in TWP, it rekindled my interest.</p><p>After I'd played through TWP a handful of times, I read through the blog post about puzzle dependency charts and decided to try making one for TWP.&nbsp;&nbsp;This was around the time you had one of those testing-related conversations on twitter, and it got me thinking about the question, What ~could~ I test, and how would I go about doing it?</p><p>The puzzle dependency chart (which I think I'll start abbreviating PDC) that I drew up essentially just reflected the game's narrative; the "states" that I could define, knowing only what a PDC has to say, seems like would entail two things: game progress variables (bAgentsHaveBeenIndoctrinatedAboutArrestTron and the like) and inventory. We'd probably need to include constraints on when pick up-able objects appear and disappear from the game, as well as when rooms become accessible (and inaccessable). At one point, I think I considered including this in the PDC....but quickly realized that, if I started doing that, I'd be getting close to re-stating the complete design of the game (except on paper).</p><p>That brought me to a conclusion:<br>Incorporating the PDC into the design program would let someone design a game by attaching things like item visibility and room acessibility to the PDC itself. It the designer can (combinatorially) generate all possible states (such as {part = 2; bArrestTronIndoctrination = true; bWC67PartNumberKnown = false; ...etc. (for every other game progress variable); inventory = (bottle, etc.)} then we can test the game logic by applying all possible "actions" to the set of states.</p><p>(I'm using the word "actions" as in "group actions," but I really don't know if there's a group here. I may have to answer that question, at some point.)</p><p>What are the "actions," then? (I'm gonna stop putting quotes around that word now, btw.) Given that we're only talking about game progress stuff (and not the rendering state) then the actions are the 9 verbs, with one caveat; for every object in the game that can be used with another objected, we'd need to make a curried(?) action for that object; that is, "Use(obj_to_use, target_obj)" wouldn't just be one action, but rather you'd have one for every possible value of obj_to_use, which I suppose would mean there's one for every item in the game that can be added to inventory.&nbsp;&nbsp;(Or, more likely, one for every item in the game that the constraints say can be accessed at the time that the state can possibly exist.&nbsp;&nbsp;So, for example, in part 9, we have a short list of items that can possibly be in the inventory, so it wouldn't be productive to ask if we can "use record with corpse" during act 9.</p><p>It also seems to me now that we'd want to break up the sets of states into "states that can exist under the same set of constraints," then I think we'd have to pay some particular kind of attention to actions that move you from one set to another (meaning the actions that trigger a change in item/room availability). (If I mention those points again, I'll probably call them 'boundaries.' You know what the condensed matter physicists say: If you want to know how two materials work together, you study the boundaries.)</p><p>While we're having the design program generate these possible states and these lists of actions appropriate for the various sets of states, what are we looking to test?&nbsp;&nbsp;I think the answer is this:<br>Given any one state and any one action, we want to resulting state to be another valid state within the same set of states.&nbsp;&nbsp;If the state changes item/room availability, we want to resulting state to be in the set of states that reflects that new constraint.)</p><p>At this point, I want to step back and try to assess what I've just rambled on about.&nbsp;&nbsp;By suggesting that the PDC be integrated into the designer, and then requiring that pieces of game logic be attached (in some sense) to the PDC, it seems like we could make an automated way to ensure that all game logic that exists in the game will continue to allow the game to get from beginning to end.&nbsp;&nbsp;</p><p>When I watched the video of the TesterTron, it actually seemed like this was essentially what you were having it do, albeit it what looks like a randomized way.&nbsp;&nbsp;(I'm guessing that the TesterTron is just picking a random interactable object in the current room and doing an action on it.)</p><p>So....that means that what I'm describing it basically a less ad-hoc approach to testing than you're already doing, that would probably require a huge time commitment to implement.&nbsp;&nbsp;I guess that's when we file an idea under "eh...maybe, if I rebuild the engine from scratch, some day."</p><p>I ~do~ envision it as having the advantage that, as soon as you add a piece of game logic in the designer, it seems like it would be possible to have it detect when you have "unresolved state changes" that would need to be addressed to another piece of game logic.&nbsp;&nbsp;So, if this works like I'm imagining it, you might be able to cut out time spent testing game logic.....especially since the TesterTron tests that aspect pretty slowly, since it's rendering as it goes.</p><p>Of course, that also means that what I've been describing does nothing to check for visual artifacts.&nbsp;&nbsp;How to test that is much less apparent to me, short of something ML-driven like you have already thought of (with an image analyzer trained to identify unusual sections of sprites, I suppose), or perhaps putting more strict constraints on masks for render-behinds and stuff like that.&nbsp;&nbsp;(This might go without saying, I'm pretty far out of my realm of knowledge, at this point.)</p><p>Having said all this, the one thing I feel like I have any confidence in saying is that there seems to be potential value in separating testing for visual artifacts from testing for game logic errors.</p><p>Anyhoo....there's my thoughts on the matter, if they're worth anything.<br></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>