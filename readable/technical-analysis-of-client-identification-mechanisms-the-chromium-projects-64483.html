<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Technical analysis of client identification mechanisms - The Chromium Projects - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Technical analysis of client identification mechanisms - The Chromium Projects - linksfor.dev(s)"/>
    <meta property="og:description" content="Home of the Chromium Open Source Project"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.chromium.org/Home/chromium-security/client-identification-mechanisms"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Technical analysis of client identification mechanisms - The Chromium Projects</title>
<div class="readable">
        <h1>Technical analysis of client identification mechanisms - The Chromium Projects</h1>
            <div>Reading time: 35-45 minutes</div>
        <div>Posted here: 19 Jul 2020</div>
        <p><a href="https://www.chromium.org/Home/chromium-security/client-identification-mechanisms">https://www.chromium.org/Home/chromium-security/client-identification-mechanisms</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="sites-canvas-main">
<div id="sites-canvas-main-content">
<div><div dir="ltr"><p><i><span color="#0b5394" face="georgia, serif" size="2">Written by Artur Janc &lt;<a href="mailto:aaj@google.com">aaj@google.com</a>&gt; and Michal Zalewski &lt;<a href="mailto:lcamtuf@google.com">lcamtuf@google.com</a>&gt;</span></i></p><p><span><p dir="ltr"><span>In common use, the term “web tracking” refers to the process of calculating or assigning unique and reasonably stable identifiers to each browser that visits a website. In most cases, this is done for the purpose of correlating future visits from the same person or machine with historical data.</span></p><p dir="ltr"><span>Some uses of such tracking techniques are well established and commonplace. For example, they are frequently employed to tell real users from malicious bots, to make it harder for attackers to gain access to compromised accounts, or to store user preferences on a website. In the same vein, the online advertising industry has used cookies as the primary client identification technology since the mid-1990s. Other practices may be less known, may not necessarily map to existing browser controls, and may be impossible or difficult to detect. Many of them - in particular, various methods of client fingerprinting - have garnered concerns from software vendors, standards bodies, and the media.</span></p><p dir="ltr"><span>To guide us in improving the range of existing browser controls and to highlight the potential pitfalls when designing new web APIs, we decided to prepare a technical overview of known tracking and fingerprinting vectors available in the browser. Note that we describe these vectors, but do not wish this document to be interpreted as a broad invitation to their use. Website owners should keep in mind that any single tracking technique may be conceivably seen as inappropriate, depending on user expectations and other complex factors beyond the scope of this doc.</span></p><p dir="ltr"><span>We divided the methods discussed on this page into several categories: </span><span>explicitly assigned client-side identifiers</span><span>, such as HTTP cookies;</span><span> inherent client device characteristics</span><span> that identify a particular machine; and </span><span>measurable user behaviors and preferences </span><span>that may reveal the identity of the person behind the keyboard (or touchscreen). After reviewing the known tracking and fingerprinting techniques, we also discuss potential directions for future work and summarize some of the challenges that browser and other software vendors would face trying to detect or prevent such behaviors on the Web.</span></p></span></p><h2><a name="TOC-Explicitly-assigned-client-side-identifiers"></a><span><span face="georgia, serif" size="5">Explicitly assigned client-side identifiers</span></span></h2><p><span face="georgia, serif">The canonical approach to identifying clients across HTTP requests is to store a unique, long-lived token on the client and to programmatically retrieve it on subsequent visits. Modern browsers offer a multitude of ways to achieve this goal, including but not limited to:</span></p><p><span><span size="2"><p dir="ltr"><span>We believe that the availability of any one of these mechanisms is sufficient to reliably tag clients and identify them later on; in addition to this, many such identifiers can be deployed in a manner that conceals the uniqueness of the ID assigned to a particular client. On the flip side, </span><span>browsers provide users with some degree of control over the behavior of at least some of these APIs, and with several exceptions discussed later on, the identifiers assigned in this fashion do not propagate to other browser profiles or to private browsing sessions.</span></p><span>The remainder of this section provides a more in-depth overview of several notable examples of client tagging schemes that are within the reach of web apps.</span></span></span></p><p><span><h3><a name="TOC-HTTP-cookies"></a><span><i>HTTP cookies</i></span></h3><p dir="ltr"><span><a href="http://tools.ietf.org/html/rfc6265"><span>HTTP cookies</span></a><span size="2"> are the most familiar and best-understood method for persisting data on the client. In essence, any web server may issue unique identifiers to first-time visitors as a part of a HTTP response, and have the browser play back the stored values on all future requests to a particular site.</span></span></p><p dir="ltr"><span><span size="2">All major browsers have for years been equipped with UIs for managing cookies; a large number of third-party cookie management and blocking software is available, too. In practice, however, external research has implied that only a minority of users regularly review or purge browser cookies. The reasons for this are probably complex, but one of them may be that the removal of cookies tends to be disruptive: contemporary browsers do not provide any heuristics to distinguish between the session cookies that are needed to access the sites the user is logged in, and the rest.</span></span></p><p dir="ltr"><span><span size="2">Some browsers offer user-configurable restrictions on the ability for websites to set “third-party” cookies (that is, cookies coming from a domain other than the one currently displayed in the address bar - a behavior most commonly employed to serve online ads or other embedded content). It should be noted that the existing implementations of this setting will assign the “first-party” label to any cookies set by documents intentionally navigated to by the user, as well as to ones issued by content loaded by the browser as a part of full-page interstitials, HTTP redirects, or click-triggered pop-ups. </span></span></p><p dir="ltr"><span><span size="2">Compared to most other mechanisms discussed below, overt use of HTTP cookies is fairly transparent to the user. That said, the mechanism may be used to tag clients without the use of cookie values that obviously resemble unique IDs. For example, client identifiers could be encoded as a combination of several seemingly innocuous and reasonable cookie names, or could be stored in metadata such as paths, domains, or cookie expiration times. Because of this, we are not aware of any means for a browser to reliably flag HTTP cookies employed to identify a specific client in this manner.</span></span></p><p dir="ltr"><span><span size="2">Just as interestingly, the abundance of cookies means that an actor could even conceivably rely on the values set by others, rather than on any newly-issued identifiers that could be tracked directly to the party in question. We have seen this employed for some rich content ads, which are usually hosted in a single origin shared by all advertisers - or, less safely, are executed directly in the context of the page that embeds the ad.</span></span></p><p><span><span><h3><a name="TOC-Flash-LSOs"></a><span><i>Flash LSOs</i></span></h3><p dir="ltr"><span size="2"><a href="http://www.adobe.com/security/flashplayer/articles/lso/"><span>Local Shared Objects</span></a><span> are the canonical way to store client-side data within Adobe Flash. The mechanism is designed to be a direct counterpart to HTTP cookies, offering a convenient way to maintain session identifiers and other application state on a per-origin basis. In contrast to cookies, LSOs can be also used for structured storage of data other than short snippets of text, making such objects more difficult to inspect and analyze in a streamlined way.</span></span></p><p dir="ltr"><span size="2"><span>In the past, the behavior of LSOs within the Flash plugin had to be configured separately from any browser privacy settings, by visiting a lesser-known </span><a href="http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager03.html"><span>Flash Settings Manager</span></a><span> UI hosted on </span><span>macromedia.com </span><span>(</span><span>standalone installs of Flash 10.3 and above supplanted this with a </span><span>Control Panel / System Preferences dialog available locally on the machine)</span><span>. Today, most browsers offer a degree of integration: for example, clearing cookies and other site data will generally also remove LSOs. On the flip side, more nuanced controls may not be synchronized: say, the specific setting for third-party cookies in the browser is not always reflected by the behavior of LSOs.</span></span></p><span size="2"><span>From a purely technical standpoint, the use of Local Shared Objects in a manner similar to HTTP cookies is within the apparent design parameters for this API -</span><span><span> </span><span>but the reliance on LSOs to recreate deleted cookies or bypass browser cookie preferences has been subject to public scrutiny</span><span>.</span></span></span></span></span></p><p><span><span><h3><a name="TOC-Silverlight-Isolated-Storage---Update:-Silverlight-and-other-plugins-were-removed-years-ago."></a><span><i>Silverlight Isolated Storage - <span color="#990000">Update: Silverlight and other plugins were removed years ago.</span></i></span></h3><p dir="ltr"><span size="2"><span>Microsoft Silverlight is a widely-deployed applet framework bearing many similarities to Adobe Flash. The Silverlight equivalent of Flash LSOs is known as </span><a href="http://msdn.microsoft.com/en-us/library/bdts8hk0(v=vs.95).aspx"><span>Isolated Storage</span></a><span>.</span></span></p><p dir="ltr"><span><span size="2">The privacy settings in Silverlight are typically not coupled to the underlying browser. In our testing, values stored in Isolated Storage survive clearing cache and site data in Chrome, Internet Explorer and Firefox. Perhaps m</span></span><span>ore surprisingly, Isolated Storage also appears to be shared between all non-incognito browser windows and browser profiles installed on the same machine; this may have consequences for users who rely on separate browser instances to maintain distinct online identities.</span></p><span><span size="2">As with LSOs, reliance on Isolated Storage to store session identifiers and similar state information does not present issues from a purely technical standpoint. That said, given that the mechanism is not currently managed via browser controls, its use of for client identification is not commonplace and thus may be viewed as less transparent than standard cookies.</span></span></span></span></p><p><span><h3><a name="TOC-HTML5-client-side-storage-mechanisms"></a><span><i>HTML5 client-side storage mechanisms</i></span></h3><p dir="ltr"><span size="2"><span>HTML5 introduces a range of structured data storage mechanisms on the client; this includes </span><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage"><span>localStorage</span></a><span>,</span><span> </span><span>the </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/File"><span><i>File </i>API</span></a><span>, and </span><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API"><span><i>IndexedDB</i></span></a><span>. Although semantically different from each other, all of them are designed to allow persistent storage of arbitrary blobs of binary data tied to a particular web origin. In contrast to cookies and LSOs, there are no significant size restrictions on the data stored with these APIs.</span></span></p><p dir="ltr"><span size="2"><span>In modern browsers, HTML5 storage is usually purged alongside other site data, but the mapping to browser settings isn’t necessarily obvious. For example, Firefox will retain</span><span> localStorage </span><span>data unless the user selects “offline website data” or “site preferences” in the deletion dialog and specifies the time range as “everything” (this is not the default). Another idiosyncrasy is the behavior of Internet Explorer,</span><span> </span><span>where the data is retained for the lifetime of a tab for any sites that are open at the time the operation takes place.</span></span></p><p dir="ltr"><span size="2"><span>Beyond that, the mechanisms do not always appear to follow the restrictions on persistence that apply to HTTP cookies. For example, in our testing, in Firefox, </span><span>localStorage</span><span> can be written and read in cross-domain frames even if third-party cookies are disabled.</span></span></p><p dir="ltr"><span><span size="2">Due to the similarity of the design goals of these APIs, the authors expect that the perception and the caveats of using HTML5 storage for storing session identifiers would be similar to the situation with Flash and Silverlight.</span></span></p><h3><a name="TOC-Cached-objects"></a><span><i>Cached objects</i></span></h3><p dir="ltr"><span size="2"><span>For performance reasons, all mainstream web browsers maintain a global cache of previously retrieved HTTP resources. Although this mechanism is not explicitly designed as a random-access storage mechanism, it can be easily leveraged as such. To accomplish this, a cooperating server may return, say, a JavaScript document with a unique identifier embedded in its body, and set </span><span>Expires</span><span> / </span><span>max-age=</span><span> headers to a date set in the distant future.</span></span></p><p dir="ltr"><span size="2"><span>Once this unique identifier is stored within a script subresource in the browser cache, the ID can be read back on any page on the Internet simply by loading the script from a known URL and monitoring the agreed-upon local variable or setting up a predefined callback function in JavaScript. The browser will periodically check for newer copies of the script by issuing a conditional request to the originating server with a suitable </span><span>If-Modified-Since</span><span> header; but if the server consistently responds to such check with HTTP code 304 (</span><span>“Not modified”</span><span>), the old copy will continue to be reused indefinitely.</span></span></p><p dir="ltr"><span size="2"><span>There is no concept of blocking “third-party” cache objects in any browser known to the authors of this document, and no simple way to prevent cache objects from being stored without dramatically degrading performance of everyday browsing. </span><span>Automated detection of such behaviors is extremely difficult owing to the sheer volume and complexity of cached JavaScript documents encountered on the modern Web</span><span>.</span></span></p><p dir="ltr"><span><span size="2">All browsers expose the option to manually clear the document cache. That said, because clearing the cache requires specific action on the part of the user, it is unlikely to be done regularly, if at all.</span></span></p><p dir="ltr"><span><span size="2">Leveraging the browser cache to store session identifiers is very distinct from using HTTP cookies; the authors are unsure if and how the cookie settings - the convenient abstraction layer used for most of the other mechanisms discussed to date - could map to the semantics of browser caches.</span></span></p><h3><a name="TOC-Cache-metadata:-ETag-and-Last-Modified"></a><i><span>Cache metadata: </span><span>ETag</span><span> and </span><span>Last-Modified</span></i></h3><p dir="ltr"><span size="2"><span>To make implicit browser-level document caching work properly, servers must have a way to notify browsers that a newer version of a particular document is available for retrieval. The HTTP/1.1 standard specifies two methods of document versioning: one based on the date of the most recent modification, and another based on an abstract, opaque identifier known as </span><span>ETag.</span></span></p><p dir="ltr"><span size="2"><span>In the </span><span>ETag </span><span>scheme, the server initially returns an opaque “version tag” string in a response header alongside with the actual document. On subsequent conditional requests to the same URL, the client echoes back the value associated with the copy it already has, through an </span><span>If-None-Match</span><span> </span><span>header; if the version specified in this header is still current, the server will respond with HTTP code 304 (</span><span>“Not Modified”</span><span>) and the client is free to reuse the cached document. Otherwise, a new document with a new </span><span>ETag</span><span> will follow.</span></span></p><p dir="ltr"><span size="2"><span>Interestingly, the behavior of the </span><span>ETag</span><span> header closely mimics that of HTTP cookies: the server can store an arbitrary, persistent value on the client, only to read it back later on. This observation, and its potential applications for browser tracking </span><a href="http://seclists.org/bugtraq/2000/Mar/331"><span>date back at least to 2000</span></a><span>.&nbsp;</span></span></p><p dir="ltr"><span>The other versioning scheme, </span><span>Last-Modified</span><span>, suffers from the same issue: servers can store at least 32 bits of data within a well-formed date string, which will then be echoed back by the client through a request header known as </span><span>If-Modified-Since. </span><span>(In practice, most browsers don't even require the string to be a well-formed date to begin with.)</span></p><p dir="ltr"><span><span size="2">Similarly to tagging users through cache objects, both of these “metadata” mechanisms are unaffected by the deletion of cookies and related site data; the tags can be destroyed only by purging the browser cache.</span></span></p><span size="2"><span>As with Flash LSOs, use of </span><span>ETag </span><span>to allegedly skirt browser cookie settings has been subject to scrutiny.</span></span></span></p><p><span><h3><a name="TOC-HTML5-AppCache"></a><span><i>HTML5 AppCache</i></span></h3><p dir="ltr"><span size="2"><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#appcache"><span>Application Caches</span></a><span> allow website authors to specify that portions of their websites should be stored on the disk and made available even if the user is offline. The mechanism is controlled by </span><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#manifests"><span>cache manifests</span></a><span> that outline the rules for storing and retrieving cache items within the app.</span></span></p><p dir="ltr"><span><span size="2">Similarly to implicit browser caching, AppCaches make it possible to store unique, user-dependent data - be it inside the cache manifest itself, or inside the resources it requests. The resources are retained indefinitely and not subject to the browser’s usual cache eviction policies.</span></span></p><p dir="ltr"><span><span size="2">AppCache appears to occupy a netherworld between HTML5 storage mechanisms and the implicit browser cache. In some browsers, it is purged along with cookies and stored website data; in others, it is discarded only if the user opts to delete the browsing history and all cached documents.</span></span></p><p dir="ltr"><span size="2"><span>Note: AppCache is likely to be succeeded with </span><a href="https://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html"><span>Service Workers</span></a><span>; the privacy properties of both mechanisms are likely to be comparable.</span></span></p><h3><a name="TOC-Flash-resource-cache"></a><span><i>Flash resource cache</i></span></h3><p dir="ltr"><span size="2"><span>Flash maintains its own internal store of resource files, which can be probed using a variety of techniques. In particular, the internal repository includes an </span><span>asset cache</span><span>, relied upon to store </span><a href="http://help.adobe.com/en_US/Flex/4.0/UsingSDK/WS2db454920e96a9e51e63e3d11c0bf69084-7add.html"><span>Runtime Shared Libraries</span></a><span> signed by Adobe to improve applet load times. There is also </span><a href="http://www.adobe.com/support/documentation/en/flashaccess/"><span>Adobe Flash Access</span></a><span>, a mechanism to store automatically acquired licenses for DRM-protected content.</span></span></p><p dir="ltr"><span size="2"><span>As of this writing, these document caches do not appear to be coupled to any browser privacy settings and can only be deleted by making several independent configuration changes in the </span><a href="http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager03.html"><span>Flash Settings Manager</span></a><span> UI on </span><span>macromedia.com</span><span>. We believe there is no global option to delete all cached resources or prevent them from being stored in the future.</span></span></p><p dir="ltr"><span><span size="2">Browsers other than Chrome appear to share Flash asset data across all installations and in private browsing modes, which may have consequences for users who rely on separate browser instances to maintain distinct online identities. </span></span></p><h3><a name="TOC-SDCH-dictionaries---Removed-from-Chrome-59-"></a><span><i>SDCH dictionaries - <span color="#990000">Removed from Chrome 59+</span></i></span></h3><p dir="ltr"><span size="2"><a href="http://lists.w3.org/Archives/Public/ietf-http-wg/2008JulSep/att-0441/Shared_Dictionary_Compression_over_HTTP.pdf"><span>SDCH</span></a><span> is a Google-developed compression algorithm that relies on the use of server-supplied, cacheable dictionaries to achieve compression rates considerably higher than what’s possible with methods such as </span><span>gzip</span><span> or </span><span>deflate</span><span> for several common classes of documents. </span></span></p><p dir="ltr"><span size="2"><span>The site-specific dictionary caching behavior at the core of SDCH inevitably offers an opportunity for storing unique identifiers on the client: both the dictionary IDs (echoed back by the client using the </span><span>Avail-Dictionary</span><span> header), and the contents of the dictionaries themselves, can be used for this purpose, in a manner very similar to the regular browser cache.</span></span></p><p dir="ltr"><span size="2"><span>In Chrome, the data does not persist across browser restarts; it was, however, shared between profiles and incognito modes and was not deleted with other site data when such an operation is requested by the user. Google addressed this in bug </span><a href="https://code.google.com/p/chromium/issues/detail?id=327783"><span>327783</span></a><span>.</span></span></p><h3><a name="TOC-Other-script-accessible-storage-mechanisms"></a><span><i>Other script-accessible storage mechanisms</i></span></h3><p dir="ltr"><span><span size="2">Several other more limited techniques make it possible for JavaScript or other active content running in the browser to maintain and query client state, sometimes in a fashion that can survive attempts to delete all browsing and site data. </span></span></p><p dir="ltr"><span size="2"><span>For example, it is possible to use </span><span>window.name</span><span> or </span><span>sessionStorage </span><span>to store persistent identifiers for a given window: if a user deletes all client state but does not close a tab that at some point in the past displayed a site determined to track the browser, re-navigation to any participating domain will allow the window-bound token to be retrieved and the new session to be associated with the previously collected data.</span></span></p><p dir="ltr"><span size="2"><span>More obviously, the same is true for active JavaScript: any currently open JavaScript context is allowed to retain state even if the user attempts to delete local site data; this can be done not only by the top-level sites open in the currently-viewed tabs, but also by “hidden” contexts such as HTML frames, web workers, and pop-unders. This can happen by accident: for example, a running ad loaded in an </span><span>&lt;iframe&gt;</span><span> may remain completely oblivious to the fact that the user attempted to clear all browsing history, and keep using a session ID stored in a local variable in JavaScript. (In fact, in addition to JavaScript, Internet Explorer will also retain session cookies for the currently-displayed origins.)</span></span></p><p><span size="2"><span>Another interesting and often-overlooked persistence mechanism is the caching of <a href="http://tools.ietf.org/html/rfc2617">RFC 2617</a> HTTP authentication credentials: once explicitly passed in an URL, the cached values may be sent on subsequent requests even after all the site data is deleted in the browser UI.</span></span></p><p dir="ltr"><span size="2"><span>In addition to the cross-browser approaches discussed earlier in this document, there are also several proprietary APIs that can be leveraged to store unique identifiers on the client system. An interesting example of this are the proprietary </span><a href="http://msdn.microsoft.com/en-us/library/ms533007(v=vs.85).aspx"><span>persistence behaviors</span></a><span> in some versions of Internet Explorer, including the </span><a href="http://msdn.microsoft.com/en-us/library/ms531424(VS.85).aspx"><span><i>userData </i>API</span></a><span>.&nbsp;</span></span></p><p dir="ltr"><span>Last but not least, a variety of other, less common plugins and plugin-mediated interfaces likely expose analogous methods for storing data on the client, but have not been studied in detail as a part of this write-up; an example of this may be the </span><i><a href="http://docs.oracle.com/javase/7/docs/jre/api/javaws/jnlp/javax/jnlp/PersistenceService.html">PersistenceService</a> API </i><span>in Java, or the DRM license management mechanisms within Silverlight.</span></p><h3><a name="TOC-Lower-level-protocol-identifiers"></a><span><i>Lower-level protocol identifiers </i></span></h3><p dir="ltr"><span><span size="2">On top of the fingerprinting mechanisms associated with HTTP caching and with the purpose-built APIs available to JavaScript programs and plugin-executed code, modern browsers provide several network-level features that offer an opportunity to store or retrieve unique identifiers:</span></span></p><ul><li><p><span size="2"><span><a href="http://www.browserauth.net/origin-bound-certificates">Origin Bound Certificates</a></span><span> (aka <i>ChannelID</i>) <b>were</b> persistent self-signed certificates identifying the client to an HTTPS server, envisioned as the future of session management on the web. A separate certificate is generated for every newly encountered domain and reused for all connections initiated later on.</span><span><br></span><span><br></span><span>By design, OBCs function as unique and stable client fingerprints, essentially replicating the operation of authentication cookies; they are treated as “site and plug-in data” in Chrome, and can be removed along with cookies.</span><span><br></span><span><br></span><span>Uncharacteristically, sites can leverage OBC for user tracking without performing any actions that would be visible to the client: the ID can be derived simply by taking note of the cryptographic hash of the certificate automatically supplied by the client as a part of a legitimate SSL handshake. </span><span><br></span><span><br></span><span>ChannelID is currently suppressed in Chrome in “third-party” scenarios (e.g., for different-domain frames). <span color="#990000"><b>NOTE</b>: </span></span></span><b><span color="#990000">this feature and its successor, TLS Token Binding, were removed years ago.</span></b></p></li><li><p><span size="2"><span>The set of supported ciphersuites can be used to fingerprint <a href="http://whatever-will-be-que-sera-sera.tumblr.com/">a TLS/SSL handshake</a>. Note that clients have been actively deprecating various ciphersuites in recent years, making this attack even more powerful.</span></span></p></li><li><p><span size="2"><span>In a similar fashion, two separate mechanisms within TLS - <a href="http://tools.ietf.org/html/rfc5246">session identifiers</a> and <a href="http://tools.ietf.org/html/rfc5077">session tickets</a> - allow clients to resume previously terminated HTTPS connections without completing a full handshake; this is accomplished by reusing previously cached data. These session resumption protocols provide a way for servers to identify subsequent requests originating from the same client for a short period of time.</span></span></p></li></ul><ul><li dir="ltr"><p dir="ltr"><span size="2"><a href="http://tools.ietf.org/html/rfc6797"><span>HTTP Strict Transport Security</span></a><span> is a security mechanism that allows servers to demand that all future connections to a particular host name need to happen exclusively over HTTPS, even if the original URL nominally begins with “http://”.</span><span><br></span><span><br></span><span>It follows that a fingerprinting server could set long-lived HSTS headers for a distinctive set of attacker-controlled host names for each newly encountered browser; this information could be then retrieved by loading faux (but possibly legitimately-looking) subresources from all the designated host names and seeing which of the connections are automatically switched to HTTPS. </span><span><br></span><span><br></span><span>In an attempt to balance security and privacy, any HSTS pins set during normal browsing [were*] carried over to the incognito mode in Chrome; there is no propagation in the opposite direction, however. *<b>Update: </b>Behavior was <a href="https://crbug.com/774643">changed in Chrome 64</a>, such that Chrome w</span><span face="Georgia"><span>on't use on-disk HSTS information for incognito requests.&nbsp;
</span></span></span><span>
It is worth noting that leveraging HSTS for tracking purposes requires establishing </span><span>log(n)</span><span> connections to uniquely identify </span><span>n</span><span> users, which makes it relatively unattractive, except for targeted uses; that said, creating a smaller number of buckets may be a valuable tool for refining other imprecise fingerprinting signals across a very large user base.</span></p></li></ul><ul><li dir="ltr"><p dir="ltr"><span size="2"><span>Last but not least, virtually all modern browsers maintain internal DNS caches to speed up name resolution (and, in some implementations, to mitigate the risk of </span><a href="http://crypto.stanford.edu/dns/dns-rebinding.pdf"><span>DNS rebinding attacks</span></a><span>).</span><span><br></span><span><br></span><span>Such caches can be easily leveraged to store small amounts of information for a configurable amount of time; for example, with 16 available IP addresses to choose from, around 8-9 cached host names would be sufficient to uniquely identify every computer on the Internet. On the flip side, the value of this approach is limited by the modest size of browser DNS caches and the potential conflicts with resolver caching on ISP level.</span></span></p></li></ul><p><span><h2><a name="TOC-Machine-specific-characteristics"></a><span><span size="5">Machine-specific characteristics</span></span></h2><p dir="ltr"><span><span size="2">With the notable exception of Origin-Bound Certificates, the techniques described in section 1 of the document rely on a third-party website explicitly placing a new unique identifier on the client system.</span></span></p><p dir="ltr"><span size="2"><span>Another, less obvious approach to web tracking relies on querying or indirectly measuring the inherent characteristics of the client system. Individually, each such signal will reveal just several bits of information - but when combined together, it seems probable that they may uniquely identify almost any computer on the Internet. In addition to being harder to detect or stop, such techniques could be used to</span><span> </span><span><b>cross-correlate user activity across various browser profiles or private browsing sessions</b></span><span><b>.</b> Furthermore, because the techniques are conceptually very distant from HTTP cookies, the authors find it difficult to decide how, if at all, the existing cookie-centric privacy controls in the browser should be used to govern such practices.</span></span></p><p dir="ltr"><span size="2"><span>EFF </span><a href="https://panopticlick.eff.org/browser-uniqueness.pdf"><span>Panopticlick</span></a><span> is one of the most prominent experiments demonstrating the principle of combining low-value signals into a high-accuracy fingerprint; there is also some evidence of </span><span><a href="http://www.ieee-security.org/TC/SP2013/papers/4977a541.pdf">sophisticated passive fingerpri</a></span></span><a href="http://www.ieee-security.org/TC/SP2013/papers/4977a541.pdf"><span>nts being used</span></a><span> by commercial tracking services.</span></p><h3><a name="TOC-Browser-level-fingerprints"></a><span><i>Browser-level fingerprints</i></span></h3><p dir="ltr"><span><span size="2">The most straightforward approach to fingerprinting is to construct identifiers by actively and explicitly combining a range of individually non-identifying signals available within the browser environment:</span></span></p><ul><li dir="ltr"><p dir="ltr"><span size="2"><span>User-Agent</span><span> string, identifying the browser version, OS version, and some of the installed browser add-ons.</span><span><br></span><span><br></span><span>(In cases where </span><span>User-Agent</span><span> information is not available or imprecise, browser versions can be usually inferred very accurately by examining the structure of other headers and by testing for the availability and semantics of the features introduced or modified between releases of a particular browser.)</span></span></p></li><li dir="ltr"><p dir="ltr"><span><span size="2">Clock skew and drift: unless synchronized with an external time source, most systems exhibit clock drift that, over time, produces a fairly unique time offset for every machine. Such offsets can be measured with microsecond precision using JavaScript. In fact, even in the case of NTP-synchronized clocks, ppm-level skews may be possible to <a href="http://www.caida.org/publications/papers/2005/fingerprinting/KohnoBroidoClaffy05-devicefingerprinting.pdf">measure remotely</a>.</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>Fairly fine-grained information about the underlying CPU and GPU, either as exposed directly (</span><span>GL_RENDERER</span><span>) or as measured by executing </span><a href="http://w2spconf.com/2011/papers/jspriv.pdf"><span>Javascript benchmarks</span></a><span> and testing for driver- or GPU-specific </span><span><a href="http://cseweb.ucsd.edu/~hovav/dist/canvas.pdf">differences in WebGL rendering</a></span><span> or the application of  ICC color profiles to <i>&lt;canvas&gt;</i> data.</span></span></p></li><li dir="ltr"><p dir="ltr"><span><span size="2">Screen and browser window resolutions, including parameters of secondary displays for multi-monitor users.</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>The window-manager- and addon-specific “thickness” of the browser UI in various settings (e.g., </span><span>window.outerHeight - window.innerHeight</span><span>).</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>The list and ordering of installed system fonts - enumerated directly or inferred with the help of an API such as </span><span>getComputedStyle</span><span>.</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>The list of all installed plugins, ActiveX controls, and Browser Helper Objects, including their versions - queried or brute-forced through </span><span>navigator.plugins[]</span><span>. (Some add-ons also announce their existence in HTTP headers.)</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>Information about installed browser extensions and other software. While the set cannot be directly enumerated, many extensions include </span><a href="https://developer.chrome.com/extensions/manifest/web_accessible_resources"><span>web-accessible resources</span></a><span> that aid in fingerprinting. In addition to this, add-ons such as popular ad blockers make detectable modifications to viewed pages, revealing information about the extension or its configuration. Using browser “sync” features may result in these characteristics being identical for a given user across multiple devices.

A similar but less portable approach specific to Internet Explorer allows websites to <a href="http://www.alienvault.com/open-threat-exchange/blog/attackers-abusing-internet-explorer-to-enumerate-software-and-detect-securi">enumerate locally installed</a> software by attempting to load DLL resources via the <i>res:// </i>pseudo-protocol.</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>Random seeds reconstructed from the output of non-cryptosafe PRNGs (e.g. </span><span>Math.random()</span><span>, multipart form boundaries, etc). In some browsers, the PRNG is initialized only at startup, or reinitialized using values that are system-specific (e.g., based on system time or PID).</span></span></p></li></ul><p dir="ltr"><span size="2"><span>According to the EFF, their Panopticlick experiment - which combines only a relatively small subset of the actively-probed signals discussed above - is able to uniquely identify </span><a href="http://hostmaster.freehaven.net/anonbib/cache/pets2010:eckersley2010unique.pdf"><span>95% of desktop users</span></a><span> based on system-level metrics alone. Current commercial fingerprinters are reported to be </span><a href="http://www.ieee-security.org/TC/SP2013/papers/4977a541.pdf"><span>considerably more sophisticated</span></a><span> </span><span>and their developers might be able to claim significantly higher success rates.</span></span></p><p dir="ltr"><span><span size="2">Of course, the value of some of the signals discussed here will be diminished on mobile devices, where both the hardware and the software configuration tends to be more homogenous; for example, measuring window dimensions or the list of installed plugins offers very little data on most Android devices. Nevertheless, we feel that the remaining signals - such as clock skew and drift and the network-level and user-specific signals described later on - are together likely more than sufficient to uniquely identify virtually all users.</span></span></p><span size="2"><span>When discussing potential mitigations, it is worth noting that restrictions such as disallowing the enumeration of </span><span>navigator.plugins[]</span><span> generally do not prevent fingerprinting; the set of all notable plugins and fonts ever created and distributed to users is relatively small and a malicious script can conceivably test for every possible value in very little time.</span></span></span></p><p><span><h3><a name="TOC-Network-configuration-fingerprints"></a><span><i>Network configuration fingerprints</i></span></h3><p dir="ltr"><span><span size="2">An interesting set of additional device characteristics is associated with the architecture of the local network and the configuration of lower-level network protocols; such signals are disclosed independently of the design of the web browser itself. These traits covered here are generally shared between all browsers on a given client and cannot be easily altered by common privacy-enhancing tools or practices; they include:</span></span></p><ul><li dir="ltr"><p dir="ltr"><span><span size="2">The external client IP address. For IPv6 addresses, this vector is even more interesting: in some settings, the last octets may be derived from the device's MAC address and preserved across networks.</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>A broad range of TCP/IP and TLS stack fingerprints, obtained with passive tools such as </span><a href="http://lcamtuf.coredump.cx/p0f3/"><span><i>p0f</i></span></a><span>. The information disclosed on this level is often surprisingly specific: for example, TCP/IP traffic will often reveal high-resolution system uptime data through TCP timestamps. </span></span></p></li><li dir="ltr"><p dir="ltr"><span><span size="2">Ephemeral source port numbers for outgoing TCP/IP connections, generally selected sequentially by most operating systems.</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>The local network IP address for users behind network address translation or HTTP proxies (</span><a href="http://www.thousandparsec.net/~tim/webrtc-myip.html"><span>via WebRTC</span></a><span>). Combined with the external client IP, internal NAT IP uniquely identifies most users, and is generally stable for desktop browsers (due to the tendency for DHCP clients and servers to cache leases).</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>Information about proxies used by the client, as detected from the presence of extra HTTP headers (</span><span>Via</span><span>, </span><span>X-Forwarded-For</span><span>). This can be combined with the client’s actual IP address revealed when making proxy-bypassing connections using one of several available methods.</span></span></p></li><li dir="ltr"><p dir="ltr"><span>With active probing, the </span><a href="http://www.slideshare.net/amiable_indian/javascript-malware-spi-dynamics"><span>list of open ports on the local host</span></a><span> indicating other installed software and firewall settings on the system. Unruly actors may also be tempted to </span><a href="http://www.andlabs.org/tools/jsrecon/jsrecon.html"><span>probe the systems and services in the visitor’s local network</span></a><span>; doing so directly within the browser will circumvent any firewalls that normally filter out unwanted incoming traffic.</span></p></li></ul></span></p><p><span><h2><a name="TOC-User-dependent-behaviors-and-preferences"></a><span><span size="5">User-dependent behaviors and preferences</span></span></h2><p dir="ltr"><span size="2"><span>In addition to trying to uniquely identify the device used to browse the web, some parties may opt to examine characteristics that aren’t necessarily tied to the machine, but that are closely associated with specific users, their local preferences, and the online behaviors they exhibit. Similarly to the methods described in section 2, such patterns would </span><span>persist across different browser sessions, profiles, and across the boundaries of private browsing modes</span><span>.</span></span></p><p dir="ltr"><span><span size="2">The following data is typically open to examination:</span></span></p><ul><li dir="ltr"><p dir="ltr"><span><span size="2">Preferred language, default character encoding, and local time zone (sent in HTTP headers and visible to JavaScript).</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>Data in the client cache and history. It is possible to detect items in the client’s cache by performing simple timing attacks; for any long-lived cache items associated with popular destinations on the Internet, a fingerprinter could detect their presence simply by measuring how quickly they load (and by aborting the navigation if the latency is greater than expected for local cache).</span><span><br></span><span><br></span><span>(It is also possible to directly extract URLs stored in the browsing history, although such an attack requires </span><a href="http://lcamtuf.coredump.cx/yahh/"><span>some user interaction</span></a><span> in modern browsers.)</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>Mouse gesture, keystroke timing and velocity patterns, and </span><a href="http://www.theregister.co.uk/2013/01/31/smartphone_accelerometer_data_leak/"><span>accelerometer readings</span></a><span> (</span><span>ondeviceorientation</span><span>) that are unique to a particular user or to particular surroundings. There is a </span><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.310.4320&amp;rep=rep1&amp;type=pdf"><span>considerable</span></a><span> </span><a href="http://www.csis.pace.edu/~ctappert/it691-13spring/projects/mouse-pusara.pdf"><span>body</span></a><span> </span><a href="http://www.cs.wm.edu/~hnw/paper/ccs11.pdf"><span>of</span></a><span> </span><a href="http://www.computer.org/csdl/mags/it/2013/04/mit2013040012-abs.html"><span>scientific</span></a><span> </span><a href="http://www.octaviogutierrez.net/docs/Gutierrez-ConferencePaper-SAM.pdf"><span>research</span></a><span> suggesting that even relatively trivial interactions are deeply user-specific and highly identifying.</span></span></p></li><li dir="ltr"><p dir="ltr"><span><span size="2">Any changes to default website fonts and font sizes, website zoom level, and the use of any accessibility features such as text color, size, or CSS overrides (all indirectly measurable with JavaScript).</span></span></p></li><li dir="ltr"><p dir="ltr"><span><span size="2">The state of client features that can be customized or disabled by the user, with special emphasis on mechanisms such as DNT, third-party cookie blocking, changes to DNS prefetching, pop-up blocking, Flash security and content storage, and so on. (In fact, users who extensively tweak their settings from the defaults may be actually making their browsers considerably easier to uniquely fingerprint.)</span></span></p></li></ul><p dir="ltr"><span><span size="2">On top of this, user fingerprinting can be accomplished by interacting with third-party services through the user’s browser, using the ambient credentials (HTTP cookies) maintained by the browser:</span></span></p><ul><li dir="ltr"><p dir="ltr"><span><span size="2">Users logged into websites that offer collaboration features can be de-anonymized by covertly instructing their browser to navigate to a set of distinctively ACLed resources and then examining which of these navigation attempts result in a new collaborator showing up in the UI.</span></span></p></li><li dir="ltr"><p dir="ltr"><span size="2"><span>Request timing, </span><span>onerror </span><span>and </span><span>onload </span><span>handlers, and similar measurement techniques can be used to detect which third-party resources return HTTP 403 error codes in the user’s browser, thus constructing an accurate picture of which sites the user is logged in; in some cases, finer-grained insights into user settings or preferences on the site can be obtained, too. </span><span><br></span><span><br></span><span>(A similar but possibly more versatile login-state attack can be also mounted with the help of Content Security Policy, a new security mechanism introduced in modern browsers.)</span></span></p></li><li dir="ltr"><p dir="ltr"><span><span size="2">Any of the explicit web application APIs that allow identity attestation may be leveraged to confirm the identity of the current user (typically based on a starting set of probable guesses).</span></span></p></li></ul><h2><a name="TOC-Fingerprinting-prevention-and-detection-challenges"></a><span><span size="5">Fingerprinting prevention and detection challenges</span></span></h2><p dir="ltr"><span><span size="2">In a world with no possibility of fingerprinting, web browsers would be indistinguishable from each other, with the exception of a small number of robustly compartmentalized and easily managed identifiers used to maintain login state and implement other essential features in response to user’s intent.</span></span></p><p dir="ltr"><span><span size="2">In practice, the Web is very different: browser tracking and fingerprinting are attainable in a large number of ways. A number of the unintentional tracking vectors are a product of implementation mistakes or oversights that could be conceivably corrected today; many others are virtually impossible to fully rectify without completely changing the way that browsers, web applications, and computer networks are designed and operated. In fact, some of these design decisions might have played an unlikely role in the success of the Web.</span></span></p><p dir="ltr"><span><span size="2">In lieu of eliminating the possibility of web tracking, some have raised hope of detecting use of fingerprinting in the online ecosystem and bringing it to public attention via technical means through browser- or server-side instrumentation. Nevertheless, even this simple concept runs into a number of obstacles:</span></span></p><ul><li dir="ltr"><p dir="ltr"><span><span size="2"><span>Some fingerprinting techniques simply leave no remotely measurable footprint, thus precluding any attempts to detect them in an automated fashion.</span></span></span></p></li><li dir="ltr"><p dir="ltr"><span><span size="2">Most other fingerprinting and tagging vectors are used in fairly evident ways, but could be easily redesigned so that they are practically indistinguishable from unrelated types of behavior. This would frustrate any programmatic detection strategies in the long haul, particularly if they are attempted on the client (where the party seeking to avoid detection can reverse-engineer the checks and iterate until the behavior is no longer flagged as suspicious).</span></span></p></li><li dir="ltr"><span><span size="2">The distinction between behaviors that may be acceptable to the user and ones that might not is hidden from view: for example, a cookie set for abuse detection looks the same as a cookie set to track online browsing habits. Without a way to distinguish between the two and properly classify the observed behaviors, tracking detection mechanisms may provide little real value to the user.</span></span></li></ul></span></p><p><span><h2><a name="TOC-Potential-directions-for-future-work"></a><span><span size="5">Potential directions for future work</span></span></h2><p dir="ltr"><span><span size="2">There may be no simple, universal, technical solutions to the problem of tracking on the Web by parties who are intent on doing so with no regard for user controls. That said, the authors of this page see some theoretical room for improvement when it comes to building simpler and more intuitive privacy controls to provide a better framework for the bulk of interactions with responsible sites and parties on the Internet:</span></span></p><ul><li dir="ltr"><p dir="ltr"><span size="2"><span>The current browser privacy controls evolved almost exclusively around the notion of HTTP cookies and several other very specific concepts that do not necessarily map cleanly to many of the tracking and fingerprinting methods discussed in this document. </span></span><span><span face="Georgia" size="2">In light of this, to better meet user expectations, it may be beneficial for in-browser privacy settings to focus on clearly explaining practical privacy outcomes, rather than continuing to build on top of narrowly-defined concepts such as "third-party cookies".</span></span></p></li><li dir="ltr"><p dir="ltr"><span><span size="2"><span face="Georgia"><span>We worry that in some cases, interacting with browser privacy controls can degrade one’s browsing experience, discouraging the user from ever touching them. A canonical example of this is trying to delete cookies: reviewing them manually is generally impractical, while deleting all cookies will kick the user out of any sites he or she is logged into and frequents every day. Although fraught with some implementation challenges, it may be desirable to</span><span> build better heuristics that distinguish and preserve site data</span><span> specifically for the destinations that users frequently log into or meaningfully interact with.</span></span></span></span></p></li><li dir="ltr"><p dir="ltr"><span><span size="2">Even for extremely privacy-conscious users who are willing to put up with the inconvenience of deleting one’s cookies and purging other session data, resetting online fingerprints can be difficult and fail in unexpected ways. An example of this is discussed in section 1: if there are ads loaded on any of the currently open tabs, clearing all local data may not actually result in a clean slate. Investing in developing technologies that provide more robust and intuitive ways to maintain, manage, or compartmentalize one's online footprints may be a noble goal.</span></span></p></li><li dir="ltr"><p dir="ltr"><span face="Georgia" size="2"><span>Today, some privacy-conscious users may resort to tweaking multiple settings and installing a broad range of extensions that together have the paradoxical effect of facilitating fingerprinting - simply by making their browsers considerably more distinctive, no matter where they go. There is a compelling case for improving the clarity and effect of a handful of well-defined privacy settings as to limit the probability of such outcomes.</span></span></p></li></ul><span face="Georgia" size="2"><span>We present these ideas for discussion within the community; at the same time, we recognize that although they may sound simple when expressed in a single paragraph, their technical underpinnings are elusive and may prove difficult or impossible to fully flesh out and implement in any browser.</span></span></span></p></span></p></span></p></div></div>
</div> 
</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>