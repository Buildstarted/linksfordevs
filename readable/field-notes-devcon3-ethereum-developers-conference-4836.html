<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Field Notes: Devcon3 - Ethereum Developer&#x27;s Conference - Andreessen Horowitz - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Field Notes: Devcon3 - Ethereum Developer&#x27;s Conference - Andreessen Horowitz - linksfor.dev(s)"/>
    <meta property="og:description" content="Editor&#x27;s Note: These notes, based on talks at the Ethereum Foundation&#x27;s third&#xA0;annual developer&#x27;s conference&#xA0;earlier this month, were shared internally over email, as part of our ongoing sharing of &#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://a16z.com/2017/11/24/devcon3-notes/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Field Notes: Devcon3 - Ethereum Developer&#x27;s Conference - Andreessen Horowitz</title>
<div class="readable">
        <h1>Field Notes: Devcon3 - Ethereum Developer&#x27;s Conference - Andreessen Horowitz</h1>
            <div>Reading time: 57-73 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://a16z.com/2017/11/24/devcon3-notes/">https://a16z.com/2017/11/24/devcon3-notes/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
				<p><em>Editor’s Note: These notes, based on talks at the Ethereum Foundation’s <a href="https://ethereumfoundation.org/devcon3/agenda/" target="_blank" rel="noopener noreferrer">third&nbsp;annual developer’s conference</a>&nbsp;earlier this month, were shared internally over email, as part of our ongoing sharing of ideas and learning inside a16z. They’ve now been reposted here, unedited, as a resource for those interested in ethereum technology, research, development, and more. For more about the Ethereum Foundation and resources, <a href="https://ethereum.org/" target="_blank" rel="noopener noreferrer">visit their site</a>. For our own podcasts and writings, go <a href="https://a16z.com/category/blockchain-cryptocurrencies-bitcoin-ethereum/" target="_blank" rel="noopener noreferrer">here</a>.&nbsp;</em></p>
<h5><strong>Ethereum in 25 Minutes (Vitalik Buterin)</strong></h5>
<p>Why ethereum?</p>
<ul>
<li>Seeming public consensus since 2013 that blockchains are useful for… stuff. Not just money! Asset issuance, etc</li>
<li>Problem: most existing blockchain protocols were designed like a calculator — can do one thing well.
<ul>
<li>People were starting to create protocols that worked like a Swiss army knife. Come up with 25 different blockchain applications, protocols. But breaks down when 26th application comes around</li>
<li>Why not make a protocol that works like a smartphone? Instead of supporting small suite of applications, support a programming language which gives you the ability to create applications. Anyone can write code, package it, and you have an app. Anyone can download the app, use it and run it</li>
</ul>
</li>
</ul>
<p>The concept — Ethereum is a blockchain with a few additions. There are two types of accounts:</p>
<ul>
<li>User accounts (controlled by private keys). If transaction included in a block, it gets executed</li>
<li>Contracts (controlled by code): If thing A happens, send coins to person X. If you send coins into the account, the code is the only thing that can move coins around. Digital assets controlled by computer program. Can be used to represent arbitrarily complex business logic on the blockchain (e.g. on blockchain voting scheme, ENS (name service), issuer backed assets, etc)</li>
<li>Anyone can create an application with any rules by defining it as a contract</li>
</ul>
<p>State vs history. State == “current” information. Accounts to balances (how much Ether), nonce (counter for replay protection), contract code and contract storage (mini database that any contract on blockchain can use). History == things that happened. Transactions, receipts. Currently, all “full” nodes store state, some store history, and some do not store history</p>
<p>Code execution: Every transaction has a TO address it sends to (unless it’s creating a contract)&nbsp;. The TO address’s code runs. Code can: send ETH to other contracts, read/write storage, call other contracts</p>
<p>Gas — Halting problem: cannot tell whether or not a program will run infinitely. Solution: charge fee per computational step (“gas”). Special gas fees applied to operations that take up storage. Not a currency (can’t transfer or hold), but a unit of measurement</p>
<ul>
<li>Gas limit — Counterpart to the block size limit in bitcoin, set by miners voting on it. Currently at 6.7m</li>
<li>Transactions contain:
<ul>
<li>nonce (anti-replay attack) — Send 10 ETH to Bob, prevents Bob from including it in the blockchain 100 times</li>
<li>gasprice (amount of ether per unit gas)</li>
<li>startgas (max gas consumable)</li>
<li>to (Destination address)</li>
<li>value (amount of ETH to send)</li>
<li>data (readable by contract code)</li>
<li>v, r, s (ECDSA signature values)</li>
</ul>
</li>
</ul>
<p>Logs: Append-only, not readable by contracts. Bloom filter protocol to allow easier searching by topic. Put in Merkle tree so efficient light client access to event records (domain name changed, etc)</p>
<p>EVM: Stack, Memory (temporary array of data VM can access), Storage (contract’s database), Environment variables (block number, timestamp), Logs, Sub-calling</p>
<p>High level languages (most of the time won’t be writing in EVM code): Viper, Solidity, LLL, Bamboo</p>
<p>The ABI</p>
<ul>
<li>Function calls are compiled into transaction data</li>
<li>First 4 bytes: function ID</li>
<li>Next 64 bytes: first argument (32 byte), second argument</li>
<li>Create transaction, broadcast to network.</li>
</ul>
<p>Merkle trees are singlehandedly responsible for making light clients possible. Allows for efficiently verifiable proofs that a transaction was included in a block (or verify that a piece of data included in a larger piece of data). Branch of hashes that allow you to check membership. State tree — Merkle tree of entire Ethereum state — contract code, storage, transactions, etc. Root hash goes into the block header — called the state root</p>
<p>New in Byzantium (hard fork live Oct 16) — Privacy features: Ring signatures, zk-snarks, big number exponentiation (think: RSA)</p>
<p>Future directions</p>
<ul>
<li>Casper</li>
<li>Sharding</li>
<li>EVM and other protocol upgrades</li>
</ul>
<h5><strong>Introduction to Casper Implementation (Chang-Wu Chen)</strong></h5>
<p>Ethereum’s next generation Proof of Stake, Deposit-based proof of stake consensus protocol. Put ETH into contract to become validator.</p>
<p>Byzantine fault tolerant (BFT) style Proof of Stake. If more than 2/3 validators follow protocol, then no conflicting blocks will be finalized.</p>
<p>Two versions of Casper in internal research team:</p>
<ul>
<li>Casper the Friendly Finality Gadget (Casper-FFG), designed by Vitalik</li>
<li>Casper the Friendly Ghost: Correct by Construction (Casper-CBC), designed by Vlad</li>
</ul>
<p>How does Casper work?</p>
<ul>
<li>Advantages: Energy efficiency (don’t need hardware for mining). Reduces the risk of centralization. Can only get 1 dollar’s worth of benefit per dollar vs PoW — cheaper cost when you have high computational power. Economic finality (security)</li>
<li>BFT-based (Byzantine Fault Tolerance). If more than 2/3 validators follow protocol, then no conflicting blocks will be finalized. It also means if the majority is less than 2/3, the system will get stuck if no additional action is taken</li>
<li>Challenges: Goal: an ever-growing canonical chain. In PoW, a single miner can make progress over time. In PoS, system can get stuck if validators misbehave. Keep in mind that validators could malfunction or misbehave: Accountable safety, Plausible liveness</li>
<li>Any ETH holder can become a validator (a fixed amount of ETH) by simply depositing ETH into the Casper smart contract. Validator’s job to reach a consensus via vote. Validator’s vote weight is proportional to the total deposit size</li>
<li>Reward: if the checkpoint is getting finalized, then the validator gets the reward</li>
<li>Hybrid Casper
<ul>
<li>Layering PoS on top of PoW — check points are coming from PoW</li>
<li>Every 100 blocks (epoch) will have a checkpoint that validators will vote for</li>
<li>Incentivize miners to migrate to PoS</li>
</ul>
</li>
<li>Vote message — A vote has four parameters: epoch number, checkpoint hash, epoch source, checkpoint hash source</li>
<li>Supermajority link — An ordered pair of checkpoints with target and source (a, b), such that at least 2/3 of validators (by deposit) have published votes with source a and target b</li>
<li>Justified checkpoint — The genesis is always justified and finalized. If a chain has accepted votes from 2/3rds of validators for some checkpoint C that all use as a source the same ancestor C’, and C’ is justified, then C is justified</li>
<li>Finalized checkpoint — A checkpoint C is finalized if it is justified and has a direct child C’ that is justified</li>
<li>Accountable safety — At least 1/3 of total deposits will be slashed if two conflicting checkpoints are finalized</li>
<li>Avoid double vote — Don’t contradict yourself within the same epoch. Avoid surround vote — make sure targets in the DAGs are consistent with your previous vote</li>
<li>Plausible liveness — Supermajority links can always be added to produce new finalized checkpoints, provided there exist children extending the finalized chain</li>
<li>Status
<ul>
<li>Casper contract: Manage dynamic validator sets, vote records in each epoch, slash conditions, rewards and penalties</li>
<li>Proof of concept: Casper-FFG contract, testing language, run on testate to evaluate the correctness, no particular release date</li>
</ul>
</li>
</ul>
<h5><strong>Presenting Parity: A Light Client for a Heavy Chain (Robert Habermeier)</strong></h5>
<p>Classifications of Ethereum clients</p>
<ul>
<li>Full nodes verify all blocks and transactions</li>
<li>Light clients verify block headers, but don’t verify transactions</li>
<li>Thin client — isn’t checking consensus process, but has someone else do checking and then fetch data about the chain</li>
</ul>
<p>Security guarantees of a light client</p>
<ul>
<li>Checks validity of headers, but not validity of state transitions (transaction execution, block reward, etc)</li>
<li>What kinds of attacks does this leave us open to? Targeted attacks toward individuals (not able to do this on the whole network), by sending them fake headers</li>
<li>When doing large transactions would want security of a full node</li>
</ul>
<p>1. Backreferencing — We want not only homogeneous requests to be responded to in a specific packet (e.g. account balance at block A, data at block A, etc), minimizes round trips</p>
<p>2. State proofs</p>
<ul>
<li>Transaction execution (for gas estimation or etc_call) requires an unpredictable subset of the state trie</li>
<li>Naive requesting from network leads tumor round trips and duplicate info</li>
<li>Request an entire transaction proof from a peer</li>
</ul>
<p>3. Request credits</p>
<ul>
<li>Serving nodes give peers “credits” that can be used to make requests</li>
<li>Credits recharge slowly over time</li>
<li>Different requests have different costs: determined by server</li>
<li>Servers gather data on request serving times and adapt costs</li>
</ul>
<p>4. Pub/sub</p>
<ul>
<li>Querying for data like events or contract states changing can be wasteful</li>
<li>Full node peers know better than we do when something has changed</li>
<li>Subscribing to changes let us keep track better</li>
<li>Caveat: catching out peers who don’t publish when they’re supposed to</li>
</ul>
<p>Canonical Hash Tries — This is how we avoid storing most headers on the light client</p>
<p>Block Pruning on Full Nodes</p>
<ul>
<li>We already use DHT-style routing in the network protocols</li>
<li>K-buckets are sybil resistant</li>
<li>Make Node IDs assign responsibilities for batches of N historical blocks</li>
</ul>
<h5><strong>Challenges Ahead for Smart Contracts (Emin Gun Sirer)</strong><strong>&nbsp;</strong></h5>
<p>Ethereum today — “blockchain” is a word that needs no article, definite or indefinite</p>
<ul>
<li>Cryptocurrencies are a new asset class, worth $100b</li>
<li>Ethereum has emerged as a platform for new projects — $1.4b traditional VC money invested in startups as of Jan 2017. More than $2b projected in ICOs this year</li>
<li>Strong foundation: EVM, Solidity, Dapps. No downtime since launch</li>
<li>Multiple implementations of EVM: Parity, Gets</li>
<li>Supportive, constructive, science-driven community (worth its weight in any currency, actual value proposition)</li>
</ul>
<p>Significance</p>
<ul>
<li>We are witnessing the emergence of a new class of systems: A new take on eliminating trust, Trustworthiness comes through audibility and transparency</li>
<li>As well as the emergence of a new class of financial instruments, instruments that are executable</li>
<li>And a new form of social organization: Crypto-backed corporations, trusts, partnerships</li>
</ul>
<p>Challenges ahead for Ethereum</p>
<ul>
<li>Scale — How do we pack more transactions/s without impacting decentralization?</li>
<li>Correctness — how do we make sure that contracts do what we think they do?</li>
<li>Privacy — how do we couple confidential, private data with smart contracts?</li>
</ul>
<p>Scale</p>
<ul>
<li>Blockchain operation — create interlinked blocks, append to ledger</li>
<li>Makes it infeasible to modify the past, as long as attacker does not control majority hash power</li>
<li>The Block Size dilemma
<ul>
<li>The Bitcoin community is having a civil war over the maximum size of a block</li>
<li>Ethereum: Blocks cannot exceed 1MB, are issued every 14s. Throughput: 7-25tx/s (Bay bridge probably processes ~7 tx/s in traffic). Latency: 14s</li>
<li>Simply increasing the block size is not a long term option. Very large blocks can lead to centralization</li>
<li>Science of consensus protocols (vs. “Design by gut”) — New metrics for probabilistic consensus protocols: Mining power utilization. Fairness (even to small miners). Consensus delay (want it to be low). Time to win and Time to prune (latency of consensus process from the point of view of a miner).</li>
<li>Apparatus for measurement and evaluation — Miniature world, a 1:1 replica (of crypto world in basement of Cornell CS department). Falcon network, relay backbone (Collect data from inside Bitcoin network).</li>
</ul>
</li>
</ul>
<ul>
<li>Ethereum findings
<ul>
<li>Ethereum PoW system incurs many uncle blocks (would be nice to reduce)</li>
<li>Ethereum network would benefit from a relay network</li>
<li>Ethereum mining ecosystem is more centralized than Bitcoin</li>
<li>State of the art in an- and off-chain scaling?</li>
</ul>
</li>
<li>Bitcoin-NG — (best) protocol for on-chain scaling. Reassigning roles to blocks
<ul>
<li>Assigning a leader to the key block that verifies transactions as they come in</li>
<li>Key blocks are small and rare, micro blocks are small and frequent</li>
<li>Critical part is in getting th incentives structure just right so the subsequent miner will extend the longest chain</li>
<li>Set of constraints guide us to precise parameters</li>
<li>Bitcoin-NG has better fairness than Bitcoin as block size increases</li>
<li>Can yield ~300tx/s. Not quite VISA/Google scale</li>
<li>ByzCoin generalizes the NG idea to a coalition of leaders</li>
</ul>
</li>
</ul>
<p>Scaling, Off-chain</p>
<ul>
<li>Lightning and Raiden
<ul>
<li>Take load off blockchain to two parties that communicate in private and resolve back to the blockchain</li>
<li>Fundamental problem: the participants have access to old settlement transactions. They can push an old state, rewinding the channel</li>
<li>Ecosystem: requires constant monitoring of the chain (so parties don’t try settle early). Starts to look more like a bank</li>
<li>Security: vulnerable to transaction malleability</li>
<li>Performance: require multiple round trips</li>
<li>Teechan and Teechain. Inside every recent Intel chip is a TEE (trusted execution environment), something far better than a Trezor/Ledger. Also inside ARM and AMD. All memory is encrypted, if program is hacked, access to decryption keys is lost</li>
<li>Remote attestation — prove to a remote host what code you are running</li>
</ul>
</li>
<li>Teechan
<ul>
<li>Secure, hardware based protocol</li>
<li>Freeze the on-chain state of two contracts: Exchange keys (safe because executing in TEE, cannot get keys out). Use peer-to-peer state changes, off chain. Settle and update on chain state of two contracts.</li>
</ul>
</li>
<li>Teechain
<ul>
<li>Generalized Teechan to multi hop, atomic transactions. Implemented on Bitcoin, signed with SGX keys</li>
<li>&gt;100ktx/s/channel</li>
<li>&lt;30ms latency UK to US</li>
<li>Work underway for Ethereum</li>
</ul>
</li>
</ul>
<p>Correctness</p>
<ul>
<li>Verify smart contracts do what you think they should</li>
<li>Typically done with the aid of a specification</li>
<li>A rich field, many decades old</li>
<li>Software verification as we know it falls short (so far focusses on safety and liveness); also needs game theoretic verification</li>
<li>Safety: proving that a predicate is always true on all parts of execution: “sum totals of tokens &lt;N”, “token balances are conserved”</li>
<li>Liveness: proving that eventually something good happens on every path “smart contract does not get stuck”</li>
<li>Game theoretic properties:
<ul>
<li>“this contract is fair to all participants”</li>
<li>“this contract is truthful or incentive-compatible”</li>
<li>“late voters in a DAO are not disadvantaged”</li>
<li>“DAO++ is designed to be regret-free”</li>
<li>“contract maximizes social utility/outcomes”</li>
<li>typically need to be coupled with models of utility. almost always need to be evaluated with respect to other execution paths</li>
</ul>
</li>
<li>We still need basic program verification
<ul>
<li>We still need oracles (virtual notary, town crier, Oraclize, Augur, …)</li>
<li>We will need escape hatches — crowd-sourced possible for use in decentralized settings</li>
<li>But we need to start tackling problems on the horizon — btw, the DAO suffered from multiple such problems that required human examination to find</li>
</ul>
</li>
</ul>
<p>Privacy</p>
<ul>
<li>Private data and public blockchains do not mix — all contract state is public. Contracts cannot hold or exercise secret keys (e.g. API keys, interact with AWS, exchanges)</li>
<li>There is private data we’d love to store</li>
<li>CreDB — new database, implemented on secure hardware
<ul>
<li>Not on-chain, but on network. NoSQL-like</li>
<li>Eidetic — remembers everything that ever happened</li>
<li>Blockchain-driven — gets its instructions from the blockchain in encrypted form. Can store data, can query, can store methods</li>
</ul>
</li>
</ul>
<p>Conclusions</p>
<ul>
<li>Planetary scale decentralized computer that executes in tandem with integrity</li>
<li>There are exciting challenges ahead, we know at least the next few steps</li>
<li>With a science driven constructive community we are poised to tackle them and more</li>
</ul>
<h5><strong>Intro to Cryptoeconomics (Karl Floersch)</strong></h5>
<p>When you have programmable incentives, you can program human behaviour</p>
<p>Cryptoeconomics</p>
<ul>
<li>The application of economics and cryptography to achieve information security goals</li>
<li>Designing Incentives. “You cannot reasonably about security of blockchain protocols without reasoning about economics” — Vitalik</li>
<li>Cryptography — hash functions, digital signatures, Merkle DAGs, zkSNARKS</li>
<li>Economics — tokens, voting rights, bribing attacker, auctions</li>
</ul>
<p>Good outcomes — trusted execution, open access, fast finality, decentralized control, inexpensive</p>
<p>Bad outcomes — safety failure, censorship, etc</p>
<p>Casper is just one of many crypto economic mechanisms, e.g. Automated market maker contract. Design a mechanism, analyze incentives, make a website &amp; logo, publish analysis &amp; website, observe behavior, record findings. Smart contract trading ETH to UNI.</p>
<p>Participation incentive</p>
<ul>
<li>Exchange creator:
<ul>
<li>+Passive fee income (race to the bottom? can model out, play around with it. what tokens is it useful for? [don’t want to create market maker for a token that will plummet]).</li>
<li>-Capital lockup.</li>
<li>? Maintain 50/50 hedge</li>
</ul>
</li>
<li>Token buyers
<ul>
<li>+Minimal transactions</li>
<li>+Trustless exchange</li>
<li>– exchange fee</li>
</ul>
</li>
<li>Token arbitrageurs
<ul>
<li>+ Low risk profit (how close will the price track other exchanges?)</li>
<li>+ trustless exchange</li>
<li>– exchange fee</li>
</ul>
</li>
<li>If assumptions hold true, the exchange will produce the following outcomes within these bounds… good outcomes? Good — easier exchange, trestles trades, liquidity for small trades. Bad — no KYC, bots get richer, miner front running</li>
</ul>
<p>Going live — code, open source, publish. Anyone can deploy a contract which can be trusted with millions of dollars. Can recreate financial systems and anyone can do it</p>
<p>Learning from mistakes — miner front running</p>
<ul>
<li>Assumptions were incorrect, forgot about miner front runners
<ul>
<li>Slip in my transaction before it closes, sell for quick profit</li>
<li>+super low risk profit</li>
<li>– dev costs</li>
</ul>
</li>
<li>Disincentivize — flat rate per block? trusted tx ordering oracle? just accept it as a <strong>minor</strong> tax?</li>
<li>Token arbitrageurs initially human, but are eventually replaced with bots</li>
</ul>
<p>Programming incentives</p>
<ul>
<li>Superpowers for makers</li>
<li>Incentives drive behavior</li>
<li>Program incentives which promote cooperation, equitability, not incentives which promote domination</li>
</ul>
<p>Solving big problems — Energy, financial tools (decentralized exchanges), reward content creators with more interesting incentives</p>
<h5><strong>Casper the Friendly Ghost: A correct-by-construction blockchain (Vlad Zamfir)</strong></h5>
<p>Process for Casper the friendly finality gadget — taking existing consensus protocols and simplifying them, for consensus safety</p>
<p>Casper the friendly ghost — derived to satisfy</p>
<p>“Proof of work” blockchain consensus does not decide on one block at a time, more overhead</p>
<p>Casper: Each block finalized with async BFT consensus safety. And it only requires O(1) per node</p>
<p>Abstract consensus safety proof:</p>
<ul>
<li>We need:
<ul>
<li>“Protocol states”, “protocols tate transitions”; an “estimator” to define “estimate safety”</li>
<li>Protocol states are elements in a set, and protocol state transitions are directed paths through protocol states</li>
<li>An estimator maps protocol states to estimates. In binary consensus it maps to 0 or 1</li>
</ul>
</li>
<li>An estimate is said to be safe if it is consistent to future protocol states</li>
<li>If two estimates are safe at two states, and they have a future in common, then they are also safe at that future</li>
<li>Key intuition — we remove the states that have too many Byzantine faults, states have a common future because there are not more than N Byzantine faults</li>
</ul>
<p>Binary Consensus</p>
<ul>
<li>Protocol messages that are bits</li>
<li>Score of an estimate is sum of estimators that have that estimate, Look at all recent validators</li>
<li>Detecting Byzantine faults — attest to what they see from other nodes. Equivocation — find Byzantine faults by equivocations</li>
<li>Arrive at an binary Estimate safety</li>
</ul>
<p>Casper the friendly ghost</p>
<ul>
<li>Blocks have another block in the estimate spot.</li>
<li>Score of a block is weight of validators whose latest messages have the block in their blockchains</li>
<li>Greedy heaviest observed sub-tree</li>
<li>Protocol states and state transitions are defined in the same way as before</li>
<li>Estimate safety — For all future protocol states, this block is in the blockchain we will choose in all future states</li>
</ul>
<p>Nodes running either of these protocols will need to detect estimate safety in order to make decisions on safe estimates</p>
<p>Clique Oracle: Nodes in a clique can’t change each other’s estimates</p>
<p>Validator rotation</p>
<ul>
<li>Define a block structure with weights mappings in the justification</li>
<li>We will score blocks according to the weights map in their parent/prev block</li>
<li>But none of the other definitions need to change, so done with addicting validator rotation to consensus safety</li>
</ul>
<p>Experimental observations: blockchain</p>
<ul>
<li>Blocks can contribute to the finality of many blocks; blocks will agree and disagree will other blocks; will determine how future safety turns out</li>
</ul>
<h5><strong>Panel: Casper and Consensus (Vitalik Buterin, Vlad Zamfir, Peter Czaban, Emin Gun Sirer, Elaine Shi)</strong></h5>
<p>Casper principles: decentralization, Byzantine fault tolerance, economic security</p>
<p>Goal of Casper-FFG, as simple as possible, as simple to graft onto PoW chains as possible while being safe under asynchroncity, BFT</p>
<p>Proof of stake increases security because you get finality that’s safe in asynchrony (vs PoW). Attacking nodes attack at a higher cost than PoW</p>
<p>Vitalik: Thought experiment: attacker spends $1b to buy ASICs, 51% attack. Can spawn camp. Developers will change the PoW algorithm so ASICs become useless. Attacker has lost $1b. All of good miners lost useful hardware as well</p>
<ul>
<li>Get another $1b, corner market on GPUs. Launch another 51% attack, general purpose so developers have no countermove.</li>
<li>Has to make cost of attack very high — survival through domination of hash power</li>
<li>Proof of stake attack.
<ul>
<li>Buy $100m of Ether</li>
<li>Breaks finality, censors transaction for a while — Worst case: community can coordinate hard fork. Legitimate because PoW people agree to changing algorithm, which is also a hard fork. Attacker loses money, community not affected. Eventually run out of money, price of Ether increases after multiple attacks.</li>
</ul>
</li>
</ul>
<p>PoW — at the mercy of hardware trends. — as people come with better ASIC tricks, heat/cooling, no knob to turn to adjust. PoS have ability to put independent individual knobs on individual participants in system</p>
<h5><strong>Introducing the TrueBit Virtual Machine (Jason Teutsch)</strong></h5>
<p>Take C/C++ code, run verification code</p>
<p>Ethereum sacrificed computation speed for immutability + communication component</p>
<p>Scalability idea #1 — obliterate Ethereum’s gasLimit</p>
<ul>
<li>gasLimit helps incentivize transaction verification</li>
<li>A world without gasLimit — a heavy transaction with a massive transaction fee</li>
<li>Verifier’s Dilemma — in the case of a heavy transaction, what should a rational miner do?
<ul>
<li>Skipping verification affords an advantage in the mining race — therefore skip verification</li>
<li>Mining on the “wrong” chain means the other miners will ignore a found block. Therefore do the verification</li>
<li>Prevents smart contracts from running for more than a fraction of a second</li>
</ul>
</li>
</ul>
<p>TrueBit gives Ethereum a computational boost — do heavy work off chain</p>
<p>Protocol goals:</p>
<ul>
<li>Anyone can offer a reward for performing a computational task</li>
<li>Anyone can solve a task in exchange for a reward</li>
<li>The protocol guarantees correctness of solutions</li>
</ul>
<p>Consists of an Ethereum smart contract and a off chain computation framework</p>
<p>Unanimous consensus algorithm (unlike Ethereum which is majority)</p>
<ul>
<li>Anyone can challenge a computation by taking it to court — verification game</li>
<li>Judges enforce a binary search to pinpoint the step where the disagreement occurs</li>
</ul>
<p>Scalability ideas #2 &amp; #3</p>
<ul>
<li>How can we ensure that verification actually occurs?</li>
<li>Idea 2: offer rewards for checking coputations. Incentivizes participation, but doesn’t incentivize correctness</li>
<li>Idea 3: Offer rewards for finding bugs. Incentivizes correctness, but doesn’t incentivize participation (where there are no bugs)</li>
<li>Verifiers will stop paying attention if they don’t expect rewards</li>
</ul>
<p>Scalability idea #4: forced errors</p>
<ul>
<li>Offer a bug bounty and provide expectation that bugs will exist</li>
<li>TrueBit protocol occasionally pays “Solvers” for submitting incorrect solutions</li>
<li>Dispute resolution subroutine ensures correctness whenever “forced errors” are not in effect</li>
<li>Ideally, this subroutine is never used</li>
</ul>
<p>Three properties of TVM:</p>
<ul>
<li>Tasks must compile and execute identically on all machines</li>
<li>A single computation step on the TVM runs comfortably within Ethereum’s gas limit</li>
<li>Space required to describe a TVM state change fits inside a single Ethereum transactions</li>
<li>A Turing machine would be ideal but there’s no such compiler. Next best thing: go to WebAssembly steps, broken down into 16 sub steps</li>
</ul>
<h5><strong>Plasma (Joseph Poon)</strong></h5>
<p>At its core, Building a blockchain on top of a blockchain</p>
<p>Write a contract on Ethereum, taking a library and modifying it to suit your needs (e.g. social network, private blockchain that binds to public network — Ethereum becomes base chain for private chains, micropayments, decentralized exchange)</p>
<p>Initialize Plasma blockchain</p>
<p>Localized computation — only periodic commitments</p>
<p>Unique rules per Plasma blockchain</p>
<p>Decentralized applications at scale</p>
<p>Periodic commitments to the root chain. Not really trusting them — periodically commit small (hundreds of bytes) hashes. Not proof of existence, actually enforceable</p>
<p>Fraud proof enforcement. Submit proof on Ethereum — Merkleized attestation and proof. Can represent information very compactly</p>
<p>Core novelty in Plasma is around exits</p>
<ul>
<li>Exiting Byzantine behavior — predesign contracts so all Plasma blockchains allow for orderly exits</li>
<li>Data unavailability. Can’t prove when someone is withholding data. Exit in the event blocks are withheld</li>
<li>When you discover blocks are being withheld (could be bad data, bad state transitions, can’t prove because no data), you exit to another Plasmas blockchain or the root blockchain as soon as possible</li>
</ul>
<p>Allows computation with map reduce</p>
<ul>
<li>Map — blockchains doing computation</li>
<li>Reduce computations back down — return values</li>
<li>Reach computation scale</li>
</ul>
<p>Design goals</p>
<ul>
<li>One blockchain can encompass all worldwide blockchains</li>
<li>Trust minimization</li>
<li>Payment and ledger scalability</li>
</ul>
<p>Transaction Data Availability Problem</p>
<ul>
<li>Transactions in a Plasma block — let’s say you wanted to create a simple payment in a Plasma block. Try to create a transaction similar to a standard payment on root chain Ethereum.
<ul>
<li>Potential Problem: Cannot attest to this payment in the event of block withholding</li>
<li>Potential Problem: If blocks are withheld it is unclear whether an unconfirmed transaction has spent funds or not. Difficult to prove double spends in a Plasma block and enforce it on Ethereum</li>
</ul>
</li>
<li>Adding funds to Plasma block — same problem but when sending funds to a Plasma contract</li>
</ul>
<p>Two-Phase Commit Mechanism — create transaction, sign and broadcast it</p>
<ul>
<li>Plasma block with payment gets signed by validators — Plasma block confirmed and ultimately committed on Ethereum. At this point the transaction is not usable, Alice can still recover her funds from the old state
<ul>
<li>Alice commits to seeing the funds in a block — Alice signs a message confirming that she sees the block. Alice shares it with Bob or Plasma chain</li>
<li>Bob receives the funds and is treated as confirmed — Alice cannot take back</li>
</ul>
</li>
<li>Why do we do this? Alice needs to be sure she is certain her transaction occurred on the Plasma chain in order to do a withdrawal in the event of a chain halt or other byzantine behavior. If money was sent to Bob, Bob needs the data available. This ensures either Alice or Bob own the funds. 3 parties: Alice, Bob, and Plasma chain itself.</li>
<li>Let’s say Alice tries to maliciously withdraw. The Plasma chain has not confirmed the commitment yet. Alice sends a transaction on Ethereum to withdraw her 1ETH from the Plasma Chain contract. She must put up a bond and wait some time. During that time Bob notices that Alice is trying to taking his money. Bob broadcasts a fraud proof. He can now take her bond and his money back</li>
</ul>
<p>Attestation on information availability. Emerging theme when dealing with states when not everyone has information</p>
<p>Scaling the world computer. Root blockchain as the supreme court</p>
<h5><strong>ZoKrates – A Toolbox for zkSNARKs on Ethereum (Jacob Eberhardt)</strong></h5>
<p>Motivation: Off-chain transaction processing, result is written back to chain and verified to be correct on chain</p>
<p>Benefits of processing off chain</p>
<ul>
<li>Scalability: If verification is cheaper than execution, throughput can be increased. Block complexity gas limit does not apply (halting problem does not apply)</li>
<li>Confidentiality: Private information can be used on external node without revealing to public blockchain</li>
<li>Approaches: TrueBit, Non-interactive Zero-Knowledge Proofs (zkSNARKS)</li>
</ul>
<p>zero-knowledge Succint Non-interactive Arguments of Knowledge</p>
<ul>
<li>Short and non interactive proofs</li>
<li>Zero knowledge</li>
<li>Verification cost independent of computational complexity</li>
</ul>
<p>Ethereum Byzantium zkSNARK precompiles — EC Add, Scalar multiplication, Pairing check</p>
<p>ZoKrates Vision</p>
<ul>
<li>Provide usable abstraction and tooling for zkSNARKS</li>
<li>Support complete process: from program code to on-chain verification</li>
<li>Seamlessly integrate with Ethereum</li>
</ul>
<p>ZoKrates — a toolbox for zkSNARKS</p>
<ul>
<li>A high-level language</li>
<li>A compiler, which transforms programs to provable constraint systems</li>
<li>Tools — Setup phase, witness computation, proof generation, Verification Smart Contract generation</li>
</ul>
<h5><strong>A Modest Proposal for Ethereum 2.0 (Vitalik Buterin)</strong></h5>
<p>Let’s look at Ethereum so far…</p>
<p>Successes — it works! many applications, high adoption (&gt;500k/day == ~7 tx/s) — includes ERC20 dapps smart contracts, Byzantium (a whole bunch of privacy features). More than 20k nodes worldwide</p>
<p>What are the challenges? Scalability — trilemma claims blockchain systems can at most have two of the three properties:</p>
<ul>
<li>Decentralization (defined as the system being able to run in a scenario where each participant only has access to O(c) resources, i.e. a regular laptop or small VPS</li>
<li>Scalability (defined as being able to process O(n) &gt; O(c) transactions)</li>
<li>Security (defined as being secure against attackers with up to O(n) resources)</li>
</ul>
<p>Scalability</p>
<ul>
<li>Every node processes every transaction</li>
<li>This means that the capacity of a blockchain is limited to the capacity of one node</li>
<li>Limited by disk reads</li>
</ul>
<p>Likely solution: sharding</p>
<ul>
<li>Spit blockchain state into N universes (“shards”)</li>
<li>Only allow asynchronous communication between shards</li>
<li>Each client only processes a small portion of transactions</li>
</ul>
<p>Governance / protocol evolution</p>
<ul>
<li>High demand for protocol stability, hard forks making deep changes are hard. Long time to code, long time to test, high risk of consensus bugs</li>
</ul>
<p>But to get to Ethereum 2.0, deep changes are exactly what we need, so what do we do?</p>
<ul>
<li>Intuition: “One blockchain, two systems”</li>
<li>Add validator manager contract. Runs proof of stake system that maintains consensus for 2 layer sharding system
<ul>
<li>Would not maintain copy of all consensus rules.</li>
<li>Enforce data in shards are available and data availability in the shard</li>
<li>First a low risk thing to participate in. Get fairly significant portion of Ether stake participating, creating blocks in each shards periodically. Blocks in shards called “collations”</li>
</ul>
</li>
<li>2 layer structure
<ul>
<li>Top layer is blockchain</li>
<li>Each shard is its own universe. Have validator manager contractor bridging them. Process moving Ether from main chain to shard and one shard to another</li>
</ul>
</li>
<li>Scalability Main shard O(C) — one node | new shards O(C^2)</li>
<li>Consensus main shard PoW –&gt; Hybrid PoS –&gt; PoS | new shards PoS through on-chain contract</li>
<li>Security Main shard Full | new shards 50% honest majority of on-chain PoS now, full security later</li>
<li>Governance main shard emphasize conservatism and strong immutability more than today | on-chain ETH voting governance through PoS, emphasize fast evolution now, conservatism later</li>
</ul>
<p>Implementation roadmap/ Sharding roadmap</p>
<ul>
<li>Implement as proof of stake sidechain
<ul>
<li>Collation headers get verified and processed by on main chain validator manager contract</li>
<li>Block creation rights assigned by simple proof of stake</li>
<li>Clients randomly assigned</li>
<li>One way ETH convertability</li>
</ul>
</li>
<li>Add two way convertibility</li>
<li>Move collation headers from contract position to uncle position</li>
<li>Tight coupling — reject blocks with invalid headers. Ideally would happen when things on sharding side are stabilized</li>
<li>Shards are creating new address space, not affect existing address space. Incomptatible</li>
</ul>
<p>Changes to make:</p>
<ul>
<li>Changing Merkle trees from hexary -&gt; binary. 4x shorter Merkle proofs</li>
<li>Account/state tree redesigns</li>
<li>EVM upgrades: EVM 1.5, E-WASM</li>
<li>Parallelizability</li>
<li>Stateless clients
<ul>
<li>Consensus nodes do not hold entire state, only state root</li>
<li>Transaction senders attach Merkle branches (“witnesses”) proving state that they access</li>
<li>Blocks get passed around with the witnesses</li>
<li>Substitute disk read with ~1kb bandwidth (assuming 10^9 accounts, optimized Merkle branch)</li>
<li>Make it much easier to reshuffle validators when sharding</li>
<li>Allow us to care less about state size</li>
<li>Massively increase parallelizability. Allows us unlimited leeway along the traditional “big block” scaling route if we want it</li>
</ul>
</li>
</ul>
<p>Split ongoing development into two layers: Layer 1: safe and conservative (getting Casper rolled out),</p>
<p>Layer 2: rapid development and experimentation. Get benefits of both at the same time in the short-medium term.</p>
<h5><strong>Using Ethereum for Secure Decentralized Optimization (Eric Munsing)</strong></h5>
<p>Solve hard math problems off chain — machine learning, market clearing, operation scheduling</p>
<p>Smart contracts coordinate consensus on global optimum</p>
<p>Guarantee security, feasibility, and optimality</p>
<p>Optimization problems — convex optimization, decentralized optimization, fully-decentralized optimization</p>
<p>Using smart contracts for security</p>
<p>Convex optimization: minimize/maximize subject to constraints</p>
<p>Break big tasks into small pieces: solve local problems on distributed hardware, bring local solutions into consensus</p>
<p>Create analytically solvable sub-problems, break into a set of smaller problems, respect privacy of local information</p>
<p>Weaknesses of aggregator-based consensus</p>
<ul>
<li>Trust issues in market clearing, monopoly price distortion, single point of failure/attack</li>
<li>Alternative: fully decentralized optimization. Consensus with neighbors who share variables</li>
</ul>
<h5><strong>Swarm team development update (Viktor Tron, Daniel Nagy, Aron Fischer, Louis Holbrook)</strong></h5>
<p>Network of computers that share data with each other, p2p decentralized storage</p>
<p>Same p2p connections as the Ethereum network, tightly integrated into Ethereum</p>
<p>Decentralized store of app data</p>
<p>Type address into URL bar bzz://some-dapp-site.eth</p>
<ul>
<li>Use Ethereum ENS to turn name.eth into a hash</li>
<li>Use hash to query peers for data</li>
<li>Render Dapp/website</li>
<li>Integrity protected, resilient, censorship free, server less, p2p web</li>
</ul>
<p>Swarm under the hood</p>
<ul>
<li>Split file into 4k chunks, send to different places for storage.</li>
<li>Content addressed: each chunk gets a hash as its “id”</li>
<li>Chunks stored at node with “closest” address</li>
<li>Data stored uniformly across the data</li>
</ul>
<p>Swarm payment infrastructure is modular, flexible, and extensible</p>
<ul>
<li>Can provide incentive structure for content delivery and content storage, but also many other services</li>
</ul>
<p>Status</p>
<ul>
<li>If you’ve tried swarm, you’ve been using Swarm PoC Client 0.2. Proof of concept. Shows basic idea works. Performance slow</li>
<li>Learned a lot, rewriting parts of the system</li>
<li>Scope of the project has grown beyond just storage — direct node to node communication, live streaming</li>
</ul>
<p>Swarm is a devp2p network. Can use routed network to send messages between any two nodes connected by intermediary nodes</p>
<ul>
<li>Ethereuem Whisper is to serve the need of anonymity at cost of performance</li>
<li>PSS (Postal Service over Swarm) is routed, so it knows the fastest way with minimum of network load, different purpose</li>
<li>Uses whisper (v5) for Topics, expiry, cryptography</li>
</ul>
<p>FUSE integration and SWARM — Synchronize files and directories between own devices</p>
<h5><strong>Scalable Responsive Dapps with Swarm and ENS (Daniel Nagy)</strong></h5>
<p>The challenges of scaling / bottlenecks</p>
<ul>
<li>The blockchain
<ul>
<li>Information stored on every node</li>
<li>Requires immediate full ordering of events</li>
<li>Requires fast broadcast of transactions and blocks</li>
</ul>
</li>
<li>Network links, network-wide broadcasts</li>
<li>Overcoming storage bottlenecks — keep data in swarm, store root hash in ENS</li>
<li>Overcoming transaction bottlenecks — Raiden style updates to ENS resolvers</li>
<li>Overcoming broadcast bottlenecks — clever use of PSS with pub/sub</li>
</ul>
<p>Eventual consistency on blockchain</p>
<ul>
<li>15 minute block time x 12 confirmations ~= 3 minutes</li>
<li>Updates reach concerned nodes faster</li>
</ul>
<p>Update structure requires clever design</p>
<ul>
<li>Just sending a root hash is insufficient: concurrency and delay issues</li>
<li>Endpoint aggregation is often preferred to complicated updates</li>
</ul>
<p>Rely on generic infrastructure, if possible</p>
<ul>
<li>Enough redundancy even for unpopular/niche apps.</li>
<li>Make sure data eventually reaches the blockchain: ETH &gt; LES &gt; BZZ &gt; PSS</li>
</ul>
<p>Make sure that important state is eventually committed. Think about incentives!</p>
<ul>
<li>Use deposits or other commitment to reduce provider churn</li>
<li>On-chain dispute resolution</li>
</ul>
<h5><strong>Designing Future-proof Smart Contract Systems (Jorge Izquierdo)</strong></h5>
<p>Aragon: decentralized organizations platform built on Ethereum</p>
<ul>
<li>Usable by nontechnical users</li>
<li>Allow extendability of the system with third party on-chain modules</li>
</ul>
<p>The case against upgradeability</p>
<ul>
<li>Changing the rules on a live contract</li>
<li>Trust required on the entity that can upgrade</li>
<li>Front-running attack with an upgrade</li>
</ul>
<p>Upgradeable libraries</p>
<ul>
<li>Pros: transparent for developer, allows to ‘modify’ the linked library</li>
<li>Cons: main contract ABI cannot be modified, data structures are fixed</li>
</ul>
<p>AragonOS: Tiny kernel, upgradeable business logic on edges –&gt; apps</p>
<h5><strong>Exploring the Ethereum Blockchain (Matthew Tan)</strong></h5>
<p>Etherscan — Ethereum block explorer. 1m MAUs, 9b API calls/mo, launched 8/2015</p>
<p>Ethereum blockchain. Genesis block – July 30th 2015</p>
<ul>
<li>&gt;4.4m blocks, &gt;71m txns, &gt;37.5m “internal transactions” — message call that resulted in a value transfer, &gt;10k ERC20 token</li>
<li>Devcon #1 11/2015 — 8.5k txns/day.</li>
<li>Devcon#2 9/2016 46k txns/day</li>
<li>Devcon #3 11/2017 500k tx/day</li>
</ul>
<p>Challenges in building an infrastructure level service</p>
<ul>
<li>Scalability, security, support, “just keeping up”, nodes management</li>
</ul>
<p>Ethereum nodes management</p>
<ul>
<li>Multiple client implementations (Geth and Parity). Different feature sets + network robustness</li>
<li>Node deployment strategies for public nodes:
<ul>
<li>Use SSD drives</li>
<li>Cache settings</li>
<li>Monitor node response</li>
<li>Load balancers with smaller multiple nodes</li>
</ul>
</li>
</ul>
<p>Deriving the “Ethereum user persona” with Google Analytics</p>
<ul>
<li>US remains dominant user base.</li>
<li>China #2 in 2017</li>
</ul>
<h5><strong>The Raiden Network (Augusto Hack, Jannik Luhn, Loredana Cirstea)</strong></h5>
<p>Scalability solution for Ethereum, up to 1m tx/s</p>
<p>Currently only on Linux (MacOS coming)</p>
<p>Not an Ethereum node, separate process communicating with Ethereum node, also need Ethereum node running on machine</p>
<p>API (for building applications on top of Raiden)</p>
<ul>
<li>PUT /api/1/connections/&lt;token&gt;
<ul>
<li>Automatic channel management</li>
<li>Tell Raiden how much funds to use on channel</li>
</ul>
</li>
<li>PUT /api/1/channels
<ul>
<li>Manually opens a new channel. Manage it on your own</li>
</ul>
</li>
<li>PATCH /api/1/channels/&lt;address&gt;
<ul>
<li>Change the channel state. deposit/close</li>
</ul>
</li>
<li>POST /api/1/transfers/&lt;token&gt;/&lt;target&gt; (once connected to network)
<ul>
<li>Make transfers, use identifiers</li>
</ul>
</li>
<li>GET /api/1/events/tokens/&lt;address&gt;
<ul>
<li>Polling for EventTransferReceivedSuccess, EventTransferSentSuccess, EventTransferSentFailed</li>
</ul>
</li>
</ul>
<p>Microraiden</p>
<ul>
<li>Robust off chain payment channel framework</li>
<li>Easy to use off the shelf, unidirectional, many to one, so don’t need to think about routing issues or fees for people who have routing channels open</li>
<li>Fast and free off chain</li>
<li>Available now on Kovan testate, available on main net by end of month</li>
</ul>
<p>Microraiden applications</p>
<ul>
<li>Paywalled content — pay per use, pay per view for static resources or streamed videos</li>
<li>M2M services: utilities, data storage, data usage, API usage. Scheduled API queries, token field robots</li>
</ul>
<p>How does it work? off chain payments</p>
<ul>
<li>Sender and receiver keep copies of channel data, block number, current balance. Receiver has last balance proof received from sender. Message signed by the sender container balance, address, block number and receiver’s address</li>
<li>ERC223 option of using less gas</li>
</ul>
<h5><strong>Towards a Permanent ENS Registrar (Nick Johnson)</strong></h5>
<p>Ethereum name service</p>
<p>Launched on May 4</p>
<ul>
<li>To date: 180,822 names auctioned, 168k ETH deposited</li>
</ul>
<p>Dispute resolution not initially built in. Decided to build in as a separate layer, so can implement blacklists</p>
<p>Permanent registrar design — differing costs of capital</p>
<ul>
<li>User — 1 ETH (total cost for indefinite use), Investor 5%/year, Speculator 0</li>
<li>Conclusion: transition to rent based model — 1 ETH / year, equalizes cost for everyone</li>
</ul>
<p>Rolling auctions — no more ‘open auction’, any name can be bid on at any time. Makes guessing the name a user is bidding on impossible. 48 hour bid period, 48 hour reveal</p>
<p>DNSSEC Oracle — user proves to oracle; for any records it doesn’t know about it contains the record and a signature. Claim with text records to registrar, registrar queries oracle, oracle responds with answer. Registrar sends setSubnodeOwner to ENS</p>
<p>Starting with .xyz domains, 3/4 of domains compatible with algorithm</p>
<h5><strong>Intro to Solidity (Hudson Jameson)</strong></h5>
<p>High-level language for Ethereum contracts</p>
<p>It looks like Javascript (with types)</p>
<p>Contracts look like classes</p>
<p>Code is compiled to the EVM, once deployed to the EVM, code is completely isolated and cannot reach outside of the EVM. It’s deployed and run on every node in the Ethereum network.</p>
<ul>
<li>Cannot have outside sources of information (like sports scores) unless you explicitly include it</li>
<li>Trusted data feeds / oracles</li>
</ul>
<p>Easy to write contracts, hard to make sure they are secure</p>
<ul>
<li>Contracts standards are beginning to emerge</li>
<li>ERC20 — interface for tokens to interoperate with others on Ethereum blockchain</li>
<li>Consensys has smart contract best practices writeup</li>
</ul>
<p>Tools:</p>
<ul>
<li>Metamask (online plugin for browser. Acts as a bridge between browser and Ethereum network)</li>
<li>Remix (online Solidity IDE — debugging, static analysis, call functions, etc)</li>
<li>Etherscan (block explorer)</li>
</ul>
<p>More tools:</p>
<ul>
<li>Solgraph (contracts talking to other contracts is hard to. tells you inputs and outputs of contract), solidity repl, Solium (linter for Solidity), evmdis (EVM disassembler), Truffle, Populus (Dapp framework), Embark, Ethereum package management</li>
</ul>
<p>Questions:</p>
<ul>
<li>What do you think is the biggest problem of Solidity?
<ul>
<li>It is a young language, and like all young languages, it’s missing a lot of features / advanced tools that programmers are used to</li>
</ul>
</li>
<li>Questions about safety of Solidity, money that’s been lost. It’s an experiment and evolving</li>
<li>What upcoming feature are you most excited about?
<ul>
<li>New features to get cryptographic primitives into EVM — zkSNARKS</li>
</ul>
</li>
</ul>
<h5><strong>Enigma: Building an Ethereum-assisted Decentralized Data Marketplace (Guy Zyskind)</strong></h5>
<p>Launched from MIT in 2015</p>
<p>Decentralized computation platform with better privacy</p>
<p>Data is everywhere — the challenge is building a marketplace where data providers create supply and data consumers create demand.</p>
<p>Catalyst — the first App on the Enigma protocol</p>
<p>Data marketplace protocol</p>
<ul>
<li>Ethereum smart contracts handle dataset registration, and remuneration</li>
<li>Routing, data storage and processing is done completely off chain</li>
<li>Only occasional payments and disputes need to touch the chain</li>
</ul>
<p>Registration (off chain)</p>
<ul>
<li>When a data provider wants to register a data set, they send a request to the off chain network with metadata where the dataset lives</li>
<li>Data provider deposits ENG to serve as collateral</li>
</ul>
<p>Incentives and data discovery</p>
<ul>
<li>Value of data — data sets are denominated with ENG tokens</li>
<li>Work — storage and computational work is rewarded through fees paid from the earning data curator to the workers</li>
<li>Discovery and ranking — the system associates rank of a dataset with the stake put on it (rank &lt;&lt;- subscribers x price + C x deposit</li>
</ul>
<p>Heavy lifting happens off chain. Global consensus is expensive</p>
<ul>
<li>Shard data into logical segments</li>
<li>For each segment, select a random node (or a quorum) to store the data and run subsequent computations over it
<ul>
<li>Using pseudo-random verifiable secret sharing</li>
<li>Using threshold signatures (e.g. DFINITY)</li>
<li>Public random becaons</li>
</ul>
</li>
</ul>
<p>Outsourcing private computation</p>
<ul>
<li>Methods: blockchain, partial encryption, FHE, zkSNARKS, sMPC, Secure Hardware</li>
</ul>
<p>Multi-party computation</p>
<ul>
<li>In the real world, we can’t rely on one trusted machine</li>
<li>MPC shows that for at most t&lt;n bad actors, data can remain confidential even in use, and the result is correct</li>
<li>g. Multiplication needs computation between the nodes</li>
<li>With addition and multiplication, we can securely store/compute any circuit –&gt; we can construct a secure VM</li>
</ul>
<h5><strong>[zk] — Introduction to zkSNARKs (Christian Reitwiessner)</strong></h5>
<p>Why zkSNARKs and why they are important: blockchains scale better if they only verify, not compute.</p>
<ul>
<li>zkSNARKs: verification magnitudes faster than computation of zkSNARKs</li>
<li>In blockchains everything is public –&gt; zkSNARKs are “zero knowledge”</li>
</ul>
<p>2 parties: prover (tx sender), verifier (blockchain)</p>
<ul>
<li>Prover wants to convince verifier that some statement is true without revealing why it is true (zero knowledge)
<ul>
<li>Given message is valid transaction</li>
<li>There is some w such that f(x,w) = y for fixed f</li>
<li>g. Mini Sudoku (4×4) board is solvable — Size of puzzle is not relevant. Need: table, paper, opaque tape, dice</li>
</ul>
</li>
<li>Prover has secret solution to Mini Sudoku puzzle
<ul>
<li>Step 1: Prover shuffles numbers, replace each number with a different one (with dice). Shuffled solution is still a solution, but initially given numbers are different</li>
<li>Step 2: Prover writes shuffled puzzle on a piece of paper and covers each number with piece of tape. Prover puts paper on table for verifier to see</li>
<li>Step 3: Verifier chooses one of: Reveal certain row, column, sub square, or reveal initially filled cells and shuffling</li>
<li>Step 4: Prover removes tape on cells</li>
<li>Step 5: Verifier checks numbers and shuffling against initially filled cells</li>
<li>Prover did not reveal any private information apart from the shuffling chosen</li>
<li>Repeat steps 1-5 until Verifier is convinced</li>
</ul>
</li>
<li>Round 2, covered shuffled solution
<ul>
<li>Still, prover is not able to cheat (up to certain probability — because verifier does not look at complete solution), because of commitment to solution (paper and tape). Probability of cheating decreases exponentially with number of rounds</li>
</ul>
</li>
<li>Still some problems with Mini Sudoku algorithm:
<ul>
<li>Does not work for generic computations. But can take an arbitrary problem in computation and transform it into the Sudoku problem (reduction). Solved problem. But lots of engineering work to make it efficient</li>
<li>Many rounds of interactions — Especially problematic for blockchain. Reason: single error can be hidden in any cell (why you need many rounds). Motivation: find a game where a single error can be found in one round. Can be done with polynomials</li>
</ul>
</li>
<li>Use polynomials to make error visible almost everywhere
<ul>
<li>Changing a coefficient makes a polynomial function at every point</li>
<li>Theorem: two different polynomials of degree up to n can coincide in at most n points. n is tiny compared to the number of possible evaluation point</li>
</ul>
</li>
</ul>
<p>How do SNARKs work?</p>
<ul>
<li>Map computation to polynomial equations. Prover knows a (secret only known to prover) w such that for all x: a(x) * w(x) = b(x) * c(x)</li>
<li>Verifier chooses secret evaluation point</li>
<li>Prover evaluates polynomials…using homomorphic encryption</li>
<li>Verifier checks equality</li>
</ul>
<p>Homomorphic encryption is computation on encrypted data (known function / program, perform computation on inputs, result in encrypted output)</p>
<ul>
<li>Arbitrary computation not yet practical, but “pairings” can do arbitrary sums and a single multiplication at the end. a(x) * w(x) = b(x) * c(x) works if done separately for each power of x. Allows prover to evaluate polynomial at encrypted point and check if outputs are equal</li>
</ul>
<p>Trusted Setup</p>
<ul>
<li>Reduced to 2-round protocol, but would like no interaction</li>
<li>Randomly generate x, encrypt to [x], send [x] to prover, evaluate polynomial, check equality</li>
<li>Equality can be checked on encrypted form</li>
<li>Not required to know x, only [x] , and can be reused</li>
<li>Trusted setup: generate [x] in a distributed process a la [x] = [a] + [b] + [c] + [d] (= [a + b + c + d]). Distributed to improve security — need all secretes to be published to break encryption. x = a + b + c + d can only be created if a, b, c, d are known</li>
</ul>
<p>Zero knowledge is achieved by adding the same random number to both sides</p>
<ul>
<li>Interesting thing in SNARKs is they allow speed up in verification</li>
<li>Zero knowledge is a triviality to add to protocol, comes for free</li>
<li>Most of the work in the protocol is in the speedup</li>
</ul>
<p>Tiny proof: 8 group elements</p>
<ul>
<li>Because random number is unencrypted, prover cannot cheat, so you achieve zero knowledge</li>
<li>Verification: 5 pairing checks plus some elliptic curve arithmetic</li>
</ul>
<h5><strong> [zk] — Democratizing zk-SNARKs: Improved setup, performance and security (Sean Bowe)</strong></h5>
<p>zkSNARKs in production software. zcash brought zkSNARKs to production last year. Very expensive — only people to production so far.</p>
<p>Engineering intensive, auditing is complex</p>
<p>zkSNARK challenges: curve security, performance, trust</p>
<p>BN128</p>
<ul>
<li>Originally targeted 128-bit security, now closer to 110 bits</li>
<li>Implemented in zcash and Ethereum</li>
<li>Not a very rigid construction; not particularly optimized for pairing performance</li>
</ul>
<p>Designing a new curve BLS12-381</p>
<ul>
<li>Moving to next version of zcash</li>
<li>Targets closer to 128-bit security with minimal performance overhead</li>
<li>Implemented in Rust library called ‘pairing’</li>
<li>Very rigid and optimized construction with extensive review; appears in a new paper (BGM17)</li>
</ul>
<p>Performance improvements — newer ones use less than 8 group elements</p>
<ul>
<li>Proving system performance</li>
<li>Streamed proving: Public parameters of zkSNARKs are loaded from disk as computation is performed when constructing a proof. Led to 100x memory usage during proving</li>
<li>Jubjub curve</li>
</ul>
<p>Proving systems</p>
<ul>
<li>State of the art proving systems are based on Jens Groth’s 2016 pairing-based SNARK — 3 group elements</li>
<li>Improved papers followed — subversion resistant SNARKs, snarky signatures</li>
<li>Groth’s original construction performs the best. Clear path toward non-malleability and reduced assumptions, without added proving costs</li>
</ul>
<p>Jubjub curve</p>
<ul>
<li>Special “embedded” elliptic curve optimized for use in zkSNARKs built on top of BLS12-381</li>
<li>Construct efficient cryptographic primitives: Collision-resistant hash functions, Commitment schemes, Authentication</li>
<li>Use SHA256 for everything in zcash, but not necessarily efficient. New crypto primitives are algebraic primitives so more efficient (5-10x)</li>
</ul>
<p>Trusted setup</p>
<ul>
<li>Biggest complaint about zkSNARKs</li>
<li>STARKs are trustless (and quantum resistant) but still on academic horizon. Still large proofs. So probably deal with SNARKs for next few years</li>
<li>Zcash and other projects need to perform these setups and making them trustworthy is difficult</li>
<li>We have a new paper that addresses this problem for zkSNARKs today</li>
</ul>
<p>Multiparty computation</p>
<ul>
<li>zkSNARK parameters can be setup via multiparty computation</li>
<li>6 people get together, only one participant needs to be honest (all have to be compromised to compromise the final result — construct false proofs)</li>
<li>The more participants the less likely all are compromised or secretly colluding</li>
</ul>
<p>Zcash’s original MPC</p>
<ul>
<li>Commitment round round robin across MPC group</li>
<li>Expensive FFT</li>
<li>Then 2 more random coefficient rounds</li>
<li>Disadvantages:
<ul>
<li>Couldn’t scale to large number of participants</li>
<li>Less flexibility for each participant (software, hardware, OS)</li>
<li>Coordination was difficult because participants had to be selected in advance, could not drop out</li>
</ul>
</li>
</ul>
<p>New MPC just published</p>
<ul>
<li>Eliminates pre-commitment round, scales to an unbounded number of participants, much cheaper per circuit</li>
<li>Phase 1 (Powers of Tau)
<ul>
<li>Communical ceremony for all zkSNARK circuits</li>
<li>Expensive but scales to hundreds/thousands of participants</li>
</ul>
</li>
<li>Phase 2
<ul>
<li>Statement-specific zkSNARK MPC</li>
<li>Much cheaper</li>
</ul>
</li>
</ul>
<h5><strong>[zk] — Scalable, Transparent and Post-quantum Secure Computational Integrity, with Applications to Cryptocurrencies (Eli Ben-Sasson)</strong></h5>
<p>Interactive Oracle Proofs (IOP) — Mathematically clean model but unrealistic</p>
<p>Scalable Transparent IOP of Knowledge (STIK) — IOP with near optimal complexity, Probably sound, no crypto but still unrealistic</p>
<p>Scalable Transparent Argument of Knowledge (STARK)</p>
<ul>
<li>Realization of STIK</li>
<li>ZK optional (doubles prover time)</li>
<li>requires crypto primitives/assumptions</li>
</ul>
<p>Bob (Prover) wishes to prove to Alice (Verifier) in ZK:</p>
<ul>
<li>I know private input w, such that running computation C on w and public input x reaches output y in T steps</li>
<li>g. zcash JoinSplit, proof of solvency, smart contract</li>
<li>IOP — Informal
<ul>
<li>Multi-round interactive protocol between P and V</li>
<li>P sends USB, V sends randomness, etc</li>
</ul>
</li>
<li>Unrealistic model but mathematically clean — Every language in model (NEXP) has a fully scalable, transparent, IOP of knowledge with perfect ZK
<ul>
<li>Double scalable — prover time is quasi-linear Tlog^O(1)(T)
<ul>
<li>Verifier time is exponentially fast log^O(1)(T)</li>
</ul>
</li>
<li>Transparent: V only uses public randomness</li>
<li>IOP of knowledge — w can be extracted from USB sticks</li>
<li>Perfect ZK: strongest form of ZK — Assumes V limits # of queries</li>
<li>Last two points contradictory, can compromise ZK</li>
</ul>
</li>
</ul>
<p>STARK (Scalable transparent argument of knowledge)</p>
<ul>
<li>Crypto based realizations of STIKS are called STARKs: two options
<ul>
<li>Interactive (iSTARK): P sends root of Merkle hash instead of USB, V responds with public randomness (Kilian92)</li>
<li>Noninteractive (nSTARK): P uses root of Merkle hash as V’s randomness (Mic00,BCS16)</li>
<li>Open Research Question: are nSTARKs invariably SNARKs?</li>
</ul>
</li>
<li>First STARK without ZK: called SCI presented at Eurocrypt 2016</li>
<li>First zkSTARK [BBHR17]
<ul>
<li>PoC code ready, paper not yet</li>
</ul>
</li>
</ul>
<p>Practice: zkSTARK benchmark — forensic DNA profile search</p>
<ul>
<li>FBI has DNA profile DB D</li>
<li>Knows hash(D) — Davies-Meyer- AES160</li>
<li>FBI reports Andy’s DNA profile match result, along with zkSTARK proof</li>
</ul>
<p>Arithmetization: use of low-degree polynomials to argue about computation</p>
<ul>
<li>Goes back to Godel’s Incompleteness theorem (1930s)</li>
<li>Used by Razborov to prove circuit flower bounds (1980s)</li>
<li>Modified by Baibai and Fortnow to interactive proof systems</li>
</ul>
<p>Polynomials P(X) = Sigma(i&lt;=d)a_i*X^i, degree (d) is maximal non-zero term</p>
<ul>
<li>Function f : S –&gt; F is called “degree d” if it is evaluation of degree d polynomial: for all x_0 in S, f(x) = P(X)</li>
<li>Fact: two distinct polynomials of degree d intersect at &lt;=d points (e.g. two distinct lines intersect at &lt;= 1 point)</li>
<li>So: two distinct functions of degree d evaluated at 100 * d points are 99%-far in relative hamming distance</li>
<li>Corollary: space of low degree functions forms a linear error correcting code, called the Reed-Soloman (RS) code</li>
</ul>
<p>Succinct computational integrity and privacy</p>
<ul>
<li>Given (i) program C, (ii) input x_in, (iii) time bound T. Bob claims C(x_in, x_aux) = x_out after T steps, (a_aux is auxiliary private input).</li>
<li>Three goals:
<ul>
<li>Integrity: Can we trust Bob’s output? Can he prove it’s correct?</li>
<li>Privacy: Will the proof leak Bob’s x_aux (medical / financial info)?</li>
<li>Succinctness: Can the proof be verified in time O(T)?</li>
</ul>
</li>
<li>Bob claim 1: “have list with 10^6 integers, all are in {1,…,10}
<ul>
<li>Problem: Can alice check this with 2 queries to file and 99% certainty? No, has to check all million points.</li>
</ul>
</li>
<li>Bob claim 2: “I have encoded the list as a degree-10^6 function f (low-degree extension), evaluated on 10^9 points?
<ul>
<li>Problem: Can Alice check now with 2 queries to f and 99% certainty? No, not enough information because still need to read 10^6 points</li>
</ul>
</li>
<li>Bob: “What more do you need to be convinced claim 2 is true?”
<ul>
<li>Alice: “evaluate one more polynomial g of degree 10^7-10^6, then query 1 random point in each of f and g, based on answers will verify claim 2 is true with 99% certainty</li>
<li>Let C(X) = (X-1)(X-2)…(X-10) be the constrained polynomial of degree 10 that vanishes exactly on 1,…10</li>
<li>Let D(X) be the domain polynomial of degree 10^6 that vanishes on the domain of interest {1…10^6}</li>
</ul>
</li>
<li>Alice’s test:
<ul>
<li>Pick random x_0 in {1…10^9}</li>
<li>Query f(x_0) and g(x_0), let alpha and beta be answers</li>
<li>Acceptable Claim 2 as true iff</li>
<li>C(alpha) = beta * D(x_0)</li>
</ul>
</li>
<li>Completeness — suppose Bob honest
<ul>
<li>Let P(X) be the interpolant of f</li>
<li>Then C(P(X)) (new polynomial) vanishes on x_0 in {1…10^6}</li>
<li>Fact: Q(X) vanishes on x_0 iff some other polynomial Q’(X) (one degree less) such that Q(X) = (X – x_0)(Q’(X)</li>
<li>Corollary: Q(X) = C(P(X)) vanishes on domain {1…10^6} only if there exists Q’(X) such that degree of Q’ = degree(Q) – deg(D) &lt;= 10^7 – 10^6</li>
</ul>
</li>
<li>Soundness — suppose Bob cheats, say f(1) = 11
<ul>
<li>Let P(X) be the interpolant of f</li>
<li>Then C(P(X)) does not vanish on all of x_o in {1…10^6}</li>
<li>For any polynomial Q’(X) the product Q’(X)D(X) does vanish on all x_0 in {1…10^6} because D(x_0) = 0</li>
<li>So for any Q’(X) of degree 10^7-10^6 the polynomial Q’(X)D(X) differs from C(P(x)) of degree 10^7</li>
<li>The evaluations of C({(X)) and Q’(X)D(X) disagree on 10^9-10^7 points out of 10^9 points</li>
<li>So for random x_0, test fails with probability 99%</li>
</ul>
</li>
</ul>
<h5><strong>EtherDelta: Off-chain Order Book with On-chain Settlement (Zack Coburn)</strong></h5>
<p>Send funds into a smart contract</p>
<p>Off-chain orderbook</p>
<p>Order parameters tightly packed, hashed, signed</p>
<p>Order has an expiry block number</p>
<p>To trade, submit order and signature</p>
<p>Cost — placing an order is free (no gas, no trading fee); because not actually making a transaction</p>
<ul>
<li>Other operations involves a gas fee</li>
<li>Taking liquidity involves a trading fee (Etherdelta’s business model)</li>
</ul>
<p>90k addresses that have traded with smart contracts</p>
<p>30k DAUs, 3.4m transactions</p>
<h5><strong>0x: An Open protocol for Trustless, Low Friction Exchange of ERC20 Tokens (Will Warren)</strong></h5>
<p>Background and timeline — started work over a year ago, released white paper in Feb</p>
<p>Motivation: the world’s value is becoming tokenized (currency, traditional assets, digital goods)</p>
<ul>
<li>Value will be tokenized and moved into a financial market like the Ethereum blockchain</li>
</ul>
<p>Exchange ecosystem – fractured</p>
<ul>
<li>Each app must bootstrap liquidity</li>
<li>Each app uses custom smart contracts –&gt; no interoperability</li>
</ul>
<p>…Should be structured as modular building blocks, and open standards win in the long run</p>
<p>Existing work:</p>
<ul>
<li>On chain order books are expensive, bloat the blockchain, high latency</li>
<li>Automated Market Makers — low throughput, front running, gameable</li>
<li>State channels — 3+ txs, security deposit, challenge period
<ul>
<li>Off blockchain, aggregate series of state changes and resolve on blockchain</li>
<li>Great for day trading, but has friction for one time use — have to move on a channel, put down security deposit (makes sure everyone is behaving honestly), and a challenge period when moving off. 2When you move onto a state channel you isolate yourself from interesting smart contracts</li>
</ul>
</li>
<li>Off-chain order relay, on-chain settlement
<ul>
<li>Standard order schema + smart contract system for settlement</li>
<li>Arbitrary transport layer and message passing semantics</li>
<li>Anyone can relay orders and charge trading fees — keep 100% of fees the charge</li>
<li>Relayer strategies — Can use an open order book strategy (like EtherDelta), can have a centralized matching strategy, someone acts as a reserve manager and bid/asks for trading pair</li>
</ul>
</li>
</ul>
<p>Why create an open standard?</p>
<ul>
<li>Can create really great developer tools — lower barrier to entry for developers and others who want to create decentralized exchanges — highly competitive one fees and UX, diversity that have different niches</li>
<li>If every decentralized exchange talks to each other, there’s network effects — they talk to each other and benefit each other</li>
<li>dapps can be customers of relayers like Kin Alpha (9/25)
<ul>
<li>Created by single developer in spare time over few weeks</li>
<li>Radar Relay (10/10/2017)</li>
<li>Paradex (launch Q4 2017) — centralized matching strategy</li>
</ul>
</li>
</ul>
<p>Exchange module for the EVM</p>
<ul>
<li>0x allows smart contracts to natively execute trades in a single line of Solidity: exchange.fill(…order, value)</li>
</ul>
<p>Governance</p>
<ul>
<li>0x is an open system with a variety of stakeholders, all of which benefit from network effects</li>
<li>Open system must remain future proof — Token voting for future upgrades to protocol</li>
</ul>
<p>Decentralized application stack</p>
<ul>
<li>Unbundling -&gt; specialized networks with distinct incentives and tokens</li>
<li>External Data — oracle, inject real-world data into blockchain | Augur</li>
<li>Computation — scalable computation. Not feasible in EVM | TrueBit</li>
<li>File Storage — scalable data storage. Too expensive in EVM | Filecoin, Swarm</li>
<li>Dispatcher — Snow</li>
</ul>
<p>Example App stack — 1. retrieve data, 2. computation. 3 injection result C(D). 4. process result P(C(D))</p>
<ul>
<li>Token abstraction: As end user of decentralized application, instead of holding a variety of tokens, can hold onto tokenized fiat. Hold and pass into 0x orders –&gt; dApp will exchange with 0x</li>
<li>v2
<ul>
<li>Order generation by smart contracts</li>
<li>Atomic order matching</li>
<li>Fee splitting between relayers</li>
<li>Protocol optimizations</li>
</ul>
</li>
</ul>



<p><em><span>The views expressed here are those of the individual AH Capital Management, L.L.C. (“a16z”) personnel quoted and are not the views of a16z or its affiliates. Certain information contained in here has been obtained from third-party sources, including from portfolio companies of funds managed by a16z. While taken from sources believed to be reliable, a16z has not independently verified such information and makes no representations about the enduring accuracy of the information or its appropriateness for a given situation.</span></em></p>
<p><em><span>This content is provided for informational purposes only, and should not be relied upon as legal, business, investment, or tax advice. You should consult your own advisers as to those matters. References to any securities or digital assets are for illustrative purposes only, and do not constitute an investment recommendation or offer to provide investment advisory services. Furthermore, this content is not directed at nor intended for use by any investors or prospective investors, and may not under any circumstances be relied upon when making a decision to invest in any fund managed by a16z. (An offering to invest in an a16z fund will be made only by the private placement memorandum, subscription agreement, and other relevant documentation of any such fund and should be read in their entirety.) Any investments or portfolio companies mentioned, referred to, or described are not representative of all investments in vehicles managed by a16z, and there can be no assurance that the investments will be profitable or that other investments made in the future will have similar characteristics or results. A list of investments made by funds managed by Andreessen Horowitz (excluding investments and certain publicly traded cryptocurrencies/ digital assets for which the issuer has not provided permission for a16z to disclose publicly) is available at <a href="https://a16z.com/investments/" rel="nofollow">https://a16z.com/investments/</a>.</span></em></p>
<p><em><span>Charts and graphs provided within are for informational purposes solely and should not be relied upon when making any investment decision. Past performance is not indicative of future results. The content speaks only as of the date indicated. Any projections, estimates, forecasts, targets, prospects, and/or opinions expressed in these materials are subject to change without notice and may differ or be contrary to opinions expressed by others. Please see <a href="https://a16z.com/disclosures" rel="nofollow">https://a16z.com/disclosures</a> for additional important information.</span></em></p>
			</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>