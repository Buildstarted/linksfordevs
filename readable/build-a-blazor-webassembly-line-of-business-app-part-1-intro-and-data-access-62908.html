<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Build a Blazor WebAssembly Line of Business App Part 1: Intro and Data Access - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Build a Blazor WebAssembly Line of Business App Part 1: Intro and Data Access - linksfor.dev(s)"/>
    <meta property="article:author" content="Empowering developers to be their best.&#x1F4C5; Jun 13, 2020&#xA;&#x1F558; 17 min read&#xA;&#x1F4AC; 3598 words"/>
    <meta property="og:description" content="Describes a fully functional real-world project built in Blazor WebAssembly with EF Core that demonstrates authentication, logging, shadow properties, auditing, optimistic concurrency, entity validation, paging/sorting/filtering and more."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.jeremylikness.com/blog/build-a-blazor-webassembly-line-of-business-app/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Build a Blazor WebAssembly Line of Business App Part 1: Intro and Data Access</title>
<div class="readable">
        <h1>Build a Blazor WebAssembly Line of Business App Part 1: Intro and Data Access</h1>
            <div>by Empowering developers to be their best.&#x1F4C5; Jun 13, 2020&#xA;&#x1F558; 17 min read&#xA;&#x1F4AC; 3598 words</div>
            <div>Reading time: 26-32 minutes</div>
        <div>Posted here: 15 Jun 2020</div>
        <p><a href="https://blog.jeremylikness.com/blog/build-a-blazor-webassembly-line-of-business-app/">https://blog.jeremylikness.com/blog/build-a-blazor-webassembly-line-of-business-app/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>You are viewing a limited version of this blog. To enable experiences like comments, opt-in to our privacy and cookie policy.
</p><div><p><a href="https://jlik.me/hz0">Blazor WebAssembly</a> is here and ready for production. It enables new scenarios for .NET developers to run existing code and libraries in the browser without a plugin. Blazor WebAssembly enables the creation of desktop, tablet, and mobile friendly apps with offline support as a <a href="https://hz1/">Progressive Web Application (PWA)</a>. The built-in templates enable security for enterprise authentication and authorization scenarios. Although Blazor WebAssembly supports most .NET Standard class libraries out of the box, there are some constraints that exist due to the browser security model. For example, the raw TCP ports needed to connect directly to a SQL Server database aren’t available in the browser. That means the client must connect to data over an API.</p><p>I built the <a href="https://github.com/JeremyLikness/BlazorWasmEFCoreExample">Blazor WebAssembly EF Core Example</a> application as a learning tool and starting point for line of business applications. I wanted to go beyond a simple “<a href="https://blog.jeremylikness.com/blog/2016-02-28_30-years-of-hello-world/">Hello, World</a>” demo and create an application that implements many features often found in line of business apps, like filtering and sorting, auditing and concurrency resolution. To get started with the application, visit the repo then follow the instructions. The rest of this blog post will explain the functionality and how it was implemented.</p><p><i></i>&nbsp;<a href="https://github.com/JeremyLikness/BlazorWasmEFCoreExample" target="_blank">
JeremyLikness/BlazorWasmEFCoreExample</a></p><p>To start with, I created an application with authentication.</p><h2 id="get-started-authentication">Get Started: Authentication</h2><p>There are several scenarios that Blazor WebAssembly supports for security. First, there is <em>standalone</em> Blazor WebAssembly. This handles the project as a typical standalone Single Page Application (SPA) that is deployed as a set of static assets that can be published through any web server. The second option is <em>hosted</em> that creates an ASP. NET Core application that can optionally host authentication as well as Web API endpoints to support the client application. These are the available options based on your hosting model:</p><table><thead><tr><th><strong>Authentication Provider</strong></th><th>Standalone Option</th><th>Hosted Option</th></tr></thead><tbody><tr><td><em><a href="https://jlik.me/hz5">Authentication Library</a></em></td><td><a href="https://jlik.me/hz6">Documentation</a></td><td>Not Available</td></tr><tr><td><em><a href="https://jlik.me/hz7">Microsoft Accounts</a></em></td><td><a href="https://jlik.me/hz8">Documentation</a></td><td>Not Available</td></tr><tr><td><em><a href="https://jlik.me/hz9">Azure Active Directory</a></em></td><td><a href="https://jlik.me/h0a">Documentation</a></td><td><a href="https://jlik.me/h0b">Documentation</a></td></tr><tr><td><em><a href="https://jlik.me/h0c">Azure AD B2C</a></em></td><td><a href="https://jlik.me/h0d">Documentation</a></td><td><a href="https://jlik.me/h0e">Documentation</a></td></tr><tr><td><em><a href="https://jlik.me/h0f">Identity Server</a></em></td><td>Not Available</td><td><a href="https://jlik.me/h0g">Documentation</a></td></tr></tbody></table><p>I chose to go with the Identity Server option so the example will work regardless of whether you have access to Azure AD. The app requires a backend, so the hosted ASP.NET Core option is perfect. I followed the directions in the linked document to create the application, verified it ran, then went to work customizing the app.</p><h2 id="extend-identity-to-audit-user-account-management">Extend Identity to Audit User Account Management</h2><p>The Identity Server uses EF Core for data access. The template creates an <code>ApplicationDbContext</code> for access to the identity database. The built-in templates provide the ability to login, register, and “confirm” email via a web interface. In production apps, this can be customized to send an actual email confirmation. Many businesses require an audit trail of user activity. Fortunately, this is relatively straightforward to do in EF Core.</p><p>First, I created a new context named <code>ApplicationAuditDbContext</code> that inherits from <code>ApplicationDbContext.</code> I changed all of the registrations in <code>Startup.cs</code> to use this new context. This is why the app required you to create a new migration to get started instead of using the built-in migration that was generated by the template.</p><p>The <code>UserAudit</code> class represents an audit entry.</p><div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>UserAudit</span>
{
    <span>public</span> UserAudit()
    {
        EventTime = DateTimeOffset.UtcNow;
    }

    <span>public</span> UserAudit(<span>string</span> action, ApplicationUser user) : <span>this</span>()
    {
        UserId = user.Id;
        Username = user.UserName;
        Action = action;
    }
    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }

    <span>public</span> <span>string</span> UserId { <span>get</span>; <span>set</span>; }
    <span>public</span> DateTimeOffset EventTime { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Action { <span>get</span>; <span>set</span>; }
    <span>public</span> <span>string</span> Username { <span>get</span>; <span>set</span>; }
}
</code></pre></div><p>The <code>AuditAdapter</code> class exposes a <code>Snap</code> method to take a snapshot of a context. It takes an instance of <code>ApplicationAuditDbContext</code> as a parameter. EF Core has a built-in API for <a href="https://jlik.me/h00">managing changes to objects</a>. This is how it issues the correct database commands to handle any changes. For the audit, I’m interested in changes to the <code>ApplicationUser</code> class (either add, delete, or modified). This code looks specifically at <code>ApplicationUser</code> changes and filters on added, deleted, and modified statuses.</p><div><pre><code data-lang="csharp"><span>var</span> tracker = context.ChangeTracker;
<span>foreach</span> (<span>var</span> item <span>in</span> tracker.Entries&lt;ApplicationUser&gt;())
{
    <span>if</span> (item.State == EntityState.Added ||
        item.State == EntityState.Deleted ||
        item.State == EntityState.Modified)
    {
        <span>//do the right thing
</span><span></span>    }
}
</code></pre></div><p>Each change tracker entry has a state and a snapshot of the entity. If the state is modified, I add an extra check to see if the <code>EmailConfirmed</code> field changes to specifically track that as a separate audit event.</p><div><pre><code data-lang="csharp"><span>var</span> audit = <span>new</span> UserAudit(item.State.ToString(), item.Entity);
<span>if</span> (item.State == EntityState.Modified)
{
    <span>var</span> wasConfirmed =
        (<span>bool</span>)item.OriginalValues[nameof(ApplicationUser.EmailConfirmed)];
    <span>if</span> (wasConfirmed == <span>false</span> &amp;&amp; item.Entity.EmailConfirmed == <span>true</span>)
    {
        audit.Action = <span>"Email Confirmed"</span>;
    }
}
</code></pre></div><p>Finally, the audit entries are simply added to the context. This flags them as new, so when the context saves changes, it will update the user and insert the audit statements as part of the same save cycle.</p><div><pre><code data-lang="csharp">context.Audits.AddRange(auditList);
</code></pre></div><p>The new context I created exposes the audit collection, then overrides <code>SaveChangesAsync</code> to intercept the operation, snapshot the changes, then save them.</p><div><pre><code data-lang="csharp"><span>public</span> DbSet&lt;UserAudit&gt; Audits { <span>get</span>; <span>set</span>; }

<span>public</span> <span>override</span> Task&lt;<span>int</span>&gt; SaveChangesAsync(
    CancellationToken token = <span>default</span>)
{
    _adapter.Snap(<span>this</span>);
    <span>return</span> <span>base</span>.SaveChangesAsync(token);
}
</code></pre></div><p>A quick peek at the database confirms this is working (the double entries for the hypothetical <code>test@test.com</code> account are from an earlier bug that was fixed):</p><p><img src="https://blog.jeremylikness.com/blog/build-a-blazor-webassembly-line-of-business-app/images/auditentries.jpg" alt="Audit entries"></p><p>Now that the basics of authentication and authorization are taken care of, it’s time to build the contacts domain.</p><p>I’m not a fan of creating too many projects for an application. There are some guidelines I use to maximize reusability and maintainability. I go with a “maximize surface area” approach and organize code into projects that can be shared as broadly as possible. The <code>ContactsApp.Model</code> project is a .NET Standard library, so it can be used in a variety of applications from web apps to desktop apps to mobile applications and edge devices. It doesn’t take on any dependencies other than the core data annotations project, so it can be used regardless of data access strategy.</p><p>The project structure ended up looking like this:</p><p><img src="https://blog.jeremylikness.com/blog/build-a-blazor-webassembly-line-of-business-app/images/dependencies.jpg" alt="Project dependency graph"></p><p>Notice that, as far as the client is concerned, it’s only dealing with a library of controls, a set of data access interfaces, and a model.</p><p>The main entity used in the application is a <code>Contact</code>. The definition of the class includes data annotations to describe some rules (business logic) for the various properties.</p><div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>Contact</span>
{
    <span>public</span> <span>int</span> Id { <span>get</span>; <span>set</span>; }
<span>
</span><span>    [Required]</span>
<span>    [StringLength(100, ErrorMessage = "First name cannot exceed 100 characters.")]</span>
    <span>public</span> <span>string</span> FirstName { <span>get</span>; <span>set</span>; }
<span>
</span><span>    [StringLength(100, ErrorMessage = "Last name cannot exceed 100 characters.")]</span>
    <span>public</span> <span>string</span> LastName { <span>get</span>; <span>set</span>; }
<span>
</span><span>    [StringLength(15, ErrorMessage = "Phone number cannot exceed 15 digits.")]</span>
    <span>public</span> <span>string</span> Phone { <span>get</span>; <span>set</span>; }
<span>
</span><span>    [Required]</span>
<span>    [StringLength(100, ErrorMessage = "Street cannot exceed 100 characters.")]</span>
    <span>public</span> <span>string</span> Street { <span>get</span>; <span>set</span>; }
<span>
</span><span>    [Required]</span>
<span>    [StringLength(50, ErrorMessage = "City cannot exceed 50 characters.")]</span>
    <span>public</span> <span>string</span> City { <span>get</span>; <span>set</span>; }
<span>
</span><span>    [Required]</span>
<span>    [StringLength(3, ErrorMessage = "State abbreviation cannot exceed 3 characters.")]</span>
    <span>public</span> <span>string</span> State { <span>get</span>; <span>set</span>; }
<span>
</span><span>    [Required]</span>
<span>    [RegularExpression(@"^\d{5}(?:[-\s]</span><span>\</span>d{<span>4</span>})?<span>$", ErrorMessage = "</span>Enter a valid zipcode <span>in</span> <span>55555</span> or <span>55555</span>-<span>5555</span> format<span>")]
</span><span></span>    <span>public</span> <span>string</span> ZipCode { <span>get</span>; <span>set</span>; }
}
</code></pre></div><p>A production application may have more complex rules and perform actions like address validation. I did not want to make the example too complicated but <em>did</em> want to include some rules to show how it works on the client and the server.</p><p>The project also contains definitions for the properties to filter or sort on (<code>ContactFilterColumns</code> enumeration), the filter (<code>IContactFilters</code>) and a “page helper” interface (<code>IPageHelper</code>) that holds paging state and performs the math necessary to skip and take the correct entries for a “page.” All of these classes are documented so they should be straightforward to understand.</p><h2 id="data-access-with-entity-framework-core">Data Access with Entity Framework Core</h2><p>The next project, <code>ContactApps.DataAccess</code>, has a reference to EF Core. It does <em>not</em> reference a specific provider and doesn’t use any database-specific references so it can potentially be reused for MySQL, PostgreSQL, SQLite, or Oracle (Cosmos DB requires some manual management of keys, so that would take some tweaks). Here is a <a href="https://jlik.me/h01">full list of supported EF Core providers</a>. The project is also a .NET Standard class library that can run on multiple platforms from Blazor and ASP.NET Core to Xamarin for mobile. This is an opinionated library as it couples to EF Core for the data access strategy.</p><blockquote><p>⭐ <strong>Note:</strong> although placing the context in a separate assembly promotes reusability, it does come with caveats if you choose to do migrations. That will be addressed later in this post.</p></blockquote><p>Here is the basic structure of the <code>DbContext</code> defined (think of this as a unit of work for interacting with the database).</p><div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>ContactContext</span> : DbContext, ISupportUser
{
    <span>public</span> <span>static</span> <span>readonly</span> <span>string</span> BlazorContactsDb =
        nameof(BlazorContactsDb).ToLower();

    <span>public</span> ContactContext(DbContextOptions&lt;ContactContext&gt; options)
        : <span>base</span>(options)
    {
    }

    <span>public</span> DbSet&lt;Contact&gt; Contacts { <span>get</span>; <span>set</span>; }
}
</code></pre></div><p>The project has some extra code to set an <code>_id</code> property and intercepts <code>Dispose</code> as a debugging tool. It provides information about when a context is created and disposed.</p><p>The database name is exposed so any references are consistent and to provide a simple way to refactor the name if you wish to change it. The constructor takes in an options instance so that it can be configured at runtime. This is how the provider is specified at runtime and settings like connection strings are passed in.</p><p>Although it’s not necessary for this project, the repository pattern I’ll describe later uses the data context in a way that will also work for Blazor Server. Our guidance is to use one context per operation whenever possible. The context is lightweight and instantiates quickly. There are some cases that require a longer-lived context, such as when you want to use the context for change tracking and/or concurrency resolution. To make it easier to generate new contexts with configuration, I created a factory class that handles creation of a new context along with any dependencies that may have been configured.</p><div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>DbContextFactory</span>&lt;TContext&gt; <span>where</span> TContext : DbContext
{
    <span>private</span> <span>readonly</span> IServiceProvider _provider;

    <span>public</span> DbContextFactory(IServiceProvider provider)
    {
        _provider = provider;
    }

    <span>public</span> TContext CreateDbContext()
    {
        <span>if</span> (_provider == <span>null</span>)
        {
            <span>throw</span> <span>new</span> InvalidOperationException(<span>$"You must configure an instance of IServiceProvider"</span>);
        }

        <span>return</span> ActivatorUtilities.CreateInstance&lt;TContext&gt;(_provider);
    }
}
</code></pre></div><p>This works for the reference project but for broader use should implement an interface so that users can create their own versions for testing and performance. For example, it may be fine to simply use <code>new</code> to create a new instance and pass in options. That will be significantly faster than resolving service dependencies. If you want to see the “production-ready” implementation of the factory, take a look at <a href="https://github.com/dotnet/efcore/pull/21246/">this pull request</a>.</p><p>The context-per operation pattern then looks like this:</p><div><pre><code data-lang="csharp"><span>using</span> (<span>var</span> context = _factory.CreateDbContext())
{
   context.Entities.Add(newEntity);
   <span>await</span> context.SaveChangesAsync();
}
</code></pre></div><p>To register the factory, I created an extension method in <code>FactoryExtensions</code>.</p><div><pre><code data-lang="csharp"><span>public</span> <span>static</span> <span>class</span> <span>FactoryExtensions</span>
{
    <span>public</span> <span>static</span> IServiceCollection AddDbContextFactory&lt;TContext&gt;(
        <span>this</span> IServiceCollection collection,
        Action&lt;DbContextOptionsBuilder&gt; optionsAction = <span>null</span>,
        ServiceLifetime contextAndOptionsLifetime = ServiceLifetime.Singleton)
        <span>where</span> TContext : DbContext
    {
        collection.Add(<span>new</span> ServiceDescriptor(
            <span>typeof</span>(DbContextFactory&lt;TContext&gt;),
            sp =&gt; <span>new</span> DbContextFactory&lt;TContext&gt;(sp),
            contextAndOptionsLifetime));

        collection.Add(<span>new</span> ServiceDescriptor(
            <span>typeof</span>(DbContextOptions&lt;TContext&gt;),
            sp =&gt; GetOptions&lt;TContext&gt;(optionsAction, sp),
            contextAndOptionsLifetime));

        <span>return</span> collection;
    }

    <span>private</span> <span>static</span> DbContextOptions&lt;TContext&gt; GetOptions&lt;TContext&gt;(
        Action&lt;DbContextOptionsBuilder&gt; action,
            IServiceProvider sp = <span>null</span>) <span>where</span> TContext : DbContext
    {
        <span>var</span> optionsBuilder = <span>new</span> DbContextOptionsBuilder&lt;TContext&gt;();
        <span>if</span> (sp != <span>null</span>)
        {
            optionsBuilder.UseApplicationServiceProvider(sp);
        }
        action?.Invoke(optionsBuilder);
        <span>return</span> optionsBuilder.Options;
    }
}
</code></pre></div><p>The solution registers the factory and the options with a default <em>singleton</em> scope (one copy application-wide). If your application requires a different configuration per user (for example, administrative users use a different connection string compared to other users), you can register the factory in the <em>scoped</em> scope. This will re-evaluate the options configuration each time the factory is requested by the controller for a different user, in case there may be different connection string settings. The server project registers the factory and options like this in <code>Startup.cs</code>:</p><div><pre><code data-lang="csharp">services.AddDbContextFactory&lt;ContactContext&gt;(opt =&gt;
opt.UseSqlServer(
    Configuration.GetConnectionString(ContactContext.BlazorContactsDb))
.EnableSensitiveDataLogging());
</code></pre></div><p>This uses SQL Server for the provider, passes the connection string that is named the same as the database, and enables sensitive data logging.</p><blockquote><p>⭐ <strong>Tip</strong>: as per the previous note, the <code>ContactContext</code> exists in a class library that cannot be executed directly. If you want to use <a href="https://jlik.me/h0u">migrations</a>, you must pass an executable project that references the context. I created the <code>ContactContextFactory</code> class in <code>ContactApps.Server</code> to provide design-time hints for building migrations. This is an example command that specifies the startup and context:</p></blockquote><blockquote><p><code>dotnet ef migrations add --startup-project ContactsApp/Server --context ContactContext InitialContact</code></p></blockquote><blockquote><p>The result will be a migration named <code>InitialContact</code> in the <code>Migrations</code> folder of the <code>ContactApps.Server</code> project.</p></blockquote><h2 id="logging">Logging</h2><p>By default, the project configures the contact context to use sensitive data logging. This enables the logs to pick up generated SQL. The <code>appsettings.Development.json</code> configuration file contains this logging block:</p><div><pre><code data-lang="json"><span>"Logging"</span><span>:</span> {
    <span>"LogLevel"</span>: {
        <span>"Default"</span>: <span>"Information"</span>,
        <span>"Microsoft"</span>: <span>"Warning"</span>,
        <span>"Microsoft.Hosting.Lifetime"</span>: <span>"Information"</span>,
        <span>"Microsoft.EntityFrameworkCore.Database.Command"</span>: <span>"Information"</span>
    }
}
</code></pre></div><p>The caveat is, of course, that generated SQL may contain sensitive data that you don’t want in your logs. It is enabled here for demo purposes.</p><p>The combination of the sensitive data logging and setting the EF Core entry to <em>information</em> results in the generated SQL being output to the logs. For local development, it can help with troubleshooting and understanding the queries. For example, it removes any doubt that filters and paging are happening in-memory. This is the SQL generated for a new page request with a filter:</p><div><pre><code data-lang="sql"><span>--Executed DbCommand (7ms) [Parameters=[@___controls_FilterText_0='quartz' (Size = 100)], 
</span><span>--CommandType='Text', CommandTimeout='30']
</span><span></span>
<span>SELECT</span> <span>COUNT</span>(<span>*</span>)
<span>FROM</span> [Contacts] <span>AS</span> [<span>c</span>]
<span>WHERE</span> ((<span>@</span>___controls_FilterText_0 <span>=</span> N<span>''</span>) <span>OR</span>
         (CHARINDEX(<span>@</span>___controls_FilterText_0, [<span>c</span>].[FirstName]) <span>&gt;</span> <span>0</span>))
    <span>OR</span>
      ((<span>@</span>___controls_FilterText_0 <span>=</span> N<span>''</span>) <span>OR</span>
         (CHARINDEX(<span>@</span>___controls_FilterText_0, [<span>c</span>].[LastName]) <span>&gt;</span> <span>0</span>))

<span>--Executed DbCommand (6ms) [Parameters=[@___controls_FilterText_0='quartz' (Size = 100),
</span><span></span>
<span>--@__p_1='0', @__p_2='20'], CommandType='Text', CommandTimeout='30']
</span><span></span>
<span>SELECT</span> [<span>c</span>].[Id], [<span>c</span>].[City], [<span>c</span>].[CreatedBy], [<span>c</span>].[CreatedOn], [<span>c</span>].[FirstName],
    [<span>c</span>].[LastName], [<span>c</span>].[ModifiedBy], [<span>c</span>].[ModifiedOn], [<span>c</span>].[Phone], [<span>c</span>].[RowVersion],
    [<span>c</span>].[<span>State</span>], [<span>c</span>].[Street], [<span>c</span>].[ZipCode]
<span>FROM</span> [Contacts] <span>AS</span> [<span>c</span>]
<span>WHERE</span> ((<span>@</span>___controls_FilterText_0 <span>=</span> N<span>''</span>) <span>OR</span> 
         (CHARINDEX(<span>@</span>___controls_FilterText_0, [<span>c</span>].[FirstName]) <span>&gt;</span> <span>0</span>)) 
    <span>OR</span> 
      ((<span>@</span>___controls_FilterText_0 <span>=</span> N<span>''</span>) <span>OR</span> 
         (CHARINDEX(<span>@</span>___controls_FilterText_0, [<span>c</span>].[LastName]) <span>&gt;</span> <span>0</span>))
<span>ORDER</span> <span>BY</span> [<span>c</span>].[LastName]
<span>OFFSET</span> <span>@</span>__p_1 <span>ROWS</span> <span>FETCH</span> <span>NEXT</span> <span>@</span>__p_2 <span>ROWS</span> <span>ONLY</span>
</code></pre></div><p>A count and a set of rows are returned based on the current page, the page size, and the name filter that is passed in.</p><h2 id="repository-pattern-and-server-implementation">Repository Pattern and Server Implementation</h2><p>It is not always necessary to create a data service to wrap EF Core. The data context itself is testable. You can read more at: <a href="https://jlik.me/h0h">testing code that uses EF Core</a>. I decided to use a repository pattern because it provides a consistent interface for data access on both the client and the server. It also allows Razor components to reference the interface without relying on the implementation, so the components work equally well in Blazor WebAssembly and Blazor Server apps. In fact, all of the components in this solution will work “as is” in a Blazor Server app.</p><p>There are many implementations of the repository pattern. I chose to go with a simple approach: a repository that supports multiple operations, and a unit of work concept that extends the repository. All operations use their own short-lived context unless a unit of work is created that “captures” a context for the duration of the work. The unit of work implements <code>IDisposable</code> because it is long-lived and may hold onto resources. The basic unit of work interface lives in the <code>ContactsApp.BaseRepository</code> project and looks like this (I added a special interface to pass in the authenticated user, more on that in a bit):</p><div><pre><code data-lang="csharp"><span>public</span> <span>interface</span> IUnitOfWork&lt;TEntity&gt; : IDisposable
{
    IBasicRepository&lt;TEntity&gt; Repo { <span>get</span>; }
    <span>void</span> SetUser(ClaimsPrincipal user);
    Task CommitAsync();
}
</code></pre></div><p>Some implementations also provide a <code>RollbackAsync()</code> method. The unit of work references the basic repository interface:</p><div><pre><code data-lang="csharp"><span>public</span> <span>interface</span> IBasicRepository&lt;TEntity&gt;
{
    Task QueryAsync(Func&lt;IQueryable&lt;TEntity&gt;, Task&gt; query);
    Task&lt;ICollection&lt;TEntity&gt;&gt; GetListAsync();
    Task&lt;TEntity&gt; LoadAsync(<span>int</span> id, ClaimsPrincipal user, <span>bool</span> forUpdate = <span>false</span>);
    Task&lt;<span>bool</span>&gt; DeleteAsync(<span>int</span> id, ClaimsPrincipal user);
    <span>void</span> Attach(TEntity item);
    Task&lt;TEntity&gt; AddAsync(TEntity item, ClaimsPrincipal user);
    Task&lt;TEntity&gt; UpdateAsync(TEntity item, ClaimsPrincipal user);
    Task&lt;TPropertyType&gt; GetPropertyValueAsync&lt;TPropertyType&gt;(
            TEntity item, <span>string</span> propertyName);
    Task SetOriginalValueForConcurrencyAsync&lt;TPropertyType&gt;(
        TEntity item, <span>string</span> propertyName, TPropertyType <span>value</span>);
}
</code></pre></div><p>The first method may look confusing at first, but it’s designed to provide an extensible way to query with LINQ that doesn’t rely on Entity Framework Core. The context exposes a <code>DbSet&lt;TEntity&gt;</code> that must be cast to queryable. The <code>QueryAsync</code> method is implemented by the repository and expects a function it can call back to with an <code>IQueryable&lt;TEntity&gt;</code> instance that is awaitable. This allows the repo to pass the queryable back, without exposing the mechanism, so you could just as easily cast a list to the query as a database table.</p><p>An example call would look like this:</p><div><pre><code data-lang="csharp"><span>await</span> _repo.QueryAsync(
    <span>async</span> query =&gt; contacts = <span>await</span> query
        .Where(c =&gt; c.FirstName == <span>"Jeremy"</span>)
        .OrderBy(c =&gt; c.City).ToListAsync());
</code></pre></div><p>The call gets passed back a queryable, which then is filtered and sorted, cast to a list, then assigned to a collection. We’ll break that down a little more in a minute.</p><p>The rest of the methods should make sense. They address adding, deleting, etc. <code>Attach</code> is a special way of saying “start watching this entity” for things like change detection or concurrency resolution. The <code>GetPropertyValueAsync</code> and <code>SetOriginalValueForConcurrencyAsync</code> are used to access shadow properties and manage concurrency. I’ll cover more on those in a later section.</p><p>Don’t worry, I haven’t overlooked the <code>RepoConcurrencyException</code>. It will make a lot more sense later on.</p><h2 id="implement-the-repository">Implement the Repository</h2><p>The implementation of the repository pattern must be able to handle a context-per-request as well as a long-lived context for longer running transactions. Therefore, a more specialized version of the <code>IBaseRepository</code> interface is defined in the <code>ContactsApp.Repository</code> project. <code>IRepository</code> is solely used by the <code>UnitOfWork</code> to manage the longer-lived context.</p><p>Here is the interface:</p><div><pre><code data-lang="csharp"><span>public</span> <span>interface</span> IRepository&lt;TEntity, TContext&gt;:
        IDisposable,
        IBasicRepository&lt;TEntity&gt; <span>where</span> TContext: DbContext, ISupportUser
{
    TContext PersistedContext { <span>get</span>; <span>set</span>;  }
}
</code></pre></div><p><code>ISupportUser</code> defines a <code>ClaimsPrincipal</code> property and indicates the implementation supports setting a user property for audit purposes. The <code>UnitOfWork</code> implementation looks like this:</p><div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>UnitOfWork</span>&lt;TContext, TEntity&gt; :
        IUnitOfWork&lt;TEntity&gt;
        <span>where</span> TContext: DbContext, ISupportUser
{
    <span>private</span> IRepository&lt;TEntity, TContext&gt; _repo;
    <span>public</span> IBasicRepository&lt;TEntity&gt; Repo
    {
        <span>get</span> =&gt; _repo;
    }
    <span>public</span> UnitOfWork(
        IRepository&lt;TEntity, TContext&gt; repo, DbContextFactory&lt;TContext&gt; factory)
    {
        repo.PersistedContext = factory.CreateDbContext();
        _repo = repo;
    }
    <span>public</span> <span>async</span> Task CommitAsync()
    {
       <span>// stay tuned ...
</span><span></span>    }
    <span>public</span> <span>void</span> Dispose()
    {
        <span>if</span> (_repo != <span>null</span>)
        {
            _repo.Dispose();
            _repo = <span>null</span>;
        }
    }

    <span>public</span> <span>void</span> SetUser(ClaimsPrincipal user)
    {
        <span>if</span> (_repo.PersistedContext != <span>null</span>)
        {
            _repo.PersistedContext.User = user;
        }
    }
}
</code></pre></div><p>Notice that the public interface exposes the repository as <code>IBasicRepository&lt;TEntity&gt;</code> but internally it is defined as <code>IRepository&lt;TEntity, TContext&gt;</code>.</p><p>The unit of work relies on a repository that it tracks the context for. Here is the server implementation of <code>ContactRepository</code> (which, by implementing <code>IRepository</code> automatically implements <code>IBasicRepository</code>):</p><div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>ContactRepository</span> : IRepository&lt;Contact, ContactContext&gt;
{
    <span>private</span> <span>readonly</span> DbContextFactory&lt;ContactContext&gt; _factory;
    <span>private</span> <span>bool</span> disposedValue;

    <span>public</span> ContactContext PersistedContext { <span>get</span>; <span>set</span>; }

    <span>public</span> ContactRepository(DbContextFactory&lt;ContactContext&gt; factory)
    {
        _factory = factory;
    }

    <span>private</span> <span>async</span> Task WorkInContextAsync(
        Func&lt;ContactContext, Task&gt; work,
        ClaimsPrincipal user,
        <span>bool</span> saveChanges = <span>false</span>)
    {
        <span>if</span> (PersistedContext != <span>null</span>)
        {
            <span>if</span> (user != <span>null</span>)
            {
                PersistedContext.User = user;
            }
           <span>await</span> work(PersistedContext);
        }
        <span>else</span>
        {
            <span>using</span> (<span>var</span> context = _factory.CreateDbContext())
            {
                context.User = user;
                <span>await</span> work(context);
                <span>if</span> (saveChanges)
                {
                    <span>await</span> context.SaveChangesAsync();
                }
            }
        }
    }

    <span>public</span> <span>void</span> Attach(Contact item)
    {
        <span>if</span> (PersistedContext == <span>null</span>)
        {
            <span>throw</span> <span>new</span> InvalidOperationException(<span>"Only valid in a unit of work."</span>);
        }
        PersistedContext.Attach(item);
    }

    <span>public</span> <span>async</span> Task&lt;Contact&gt; AddAsync(Contact item, ClaimsPrincipal user)
    {
        <span>await</span> WorkInContextAsync(context =&gt;
        {
            context.Contacts.Add(item);
            <span>return</span> Task.CompletedTask;
        }, user, <span>true</span>);
        <span>return</span> item;
    }

    <span>public</span> <span>async</span> Task&lt;<span>bool</span>&gt; DeleteAsync(<span>int</span> id, ClaimsPrincipal user)
    {
        <span>bool?</span> result = <span>null</span>;
        <span>await</span> WorkInContextAsync(<span>async</span> context =&gt;
        {
            <span>var</span> item = <span>await</span> context.Contacts.SingleOrDefaultAsync(c =&gt; c.Id == id);
            <span>if</span> (item == <span>null</span>)
            {
                result = <span>false</span>;
            }
            <span>else</span>
            {
                context.Contacts.Remove(item);
            }
        }, user, <span>true</span>);
        <span>if</span> (!result.HasValue)
        {
            result = <span>true</span>;
        }
        <span>return</span> result.Value;
    }

    <span>public</span> Task&lt;ICollection&lt;Contact&gt;&gt; GetListAsync()
    {
        <span>throw</span> <span>new</span> NotImplementedException();
    }

    <span>public</span> <span>async</span> Task&lt;Contact&gt; LoadAsync(
        <span>int</span> id, 
        ClaimsPrincipal user,
        <span>bool</span> forUpdate = <span>false</span>)
    {
        Contact contact = <span>null</span>;
        <span>await</span> WorkInContextAsync(<span>async</span> context =&gt;
        {
            <span>var</span> contactRef = context.Contacts;
            <span>if</span> (forUpdate)
            {
                contactRef.AsNoTracking();
            }
            contact = <span>await</span> contactRef
                .SingleOrDefaultAsync(c =&gt; c.Id == id);
        }, user);
        <span>return</span> contact;
    }

    <span>public</span> <span>async</span> Task QueryAsync(Func&lt;IQueryable&lt;Contact&gt;, Task&gt; query)
    {
        <span>await</span> WorkInContextAsync(<span>async</span> context =&gt;
        {
            <span>await</span> query(context.Contacts.AsNoTracking().AsQueryable());
        }, <span>null</span>);
    }

    <span>public</span> <span>async</span> Task&lt;Contact&gt; UpdateAsync(Contact item, ClaimsPrincipal user)
    {
        <span>await</span> WorkInContextAsync(context =&gt;
        {
            context.Contacts.Attach(item);
            <span>return</span> Task.CompletedTask;
        }, user, <span>true</span>);
        <span>return</span> item;
    }

    <span>protected</span> <span>virtual</span> <span>void</span> Dispose(<span>bool</span> disposing)
    {
        <span>if</span> (!disposedValue)
        {
            <span>if</span> (disposing)
            {
                <span>if</span> (PersistedContext != <span>null</span>)
                {
                    PersistedContext.Dispose();
                }
            }
            disposedValue = <span>true</span>;
        }
    }

    <span>public</span> <span>void</span> Dispose()
    {
        Dispose(disposing: <span>true</span>);
        GC.SuppressFinalize(<span>this</span>);
    }
}
</code></pre></div><p>The main method to unpack is the <code>WorkInContextAsync</code>. If a long-lived context exists, this will run the operation against that context. Otherwise, it will create a short-lived context for the operation using the factory. It’s a way of managing similar workloads in different contexts. The persisted context will only exist if the repo is injected into a unit of work, and when the unit of work is disposed, the repository is disposed, which in turn disposes the context. Most operations (read, query, etc.) are fine using the pattern of a new context per operation, but what about an update with potential concurrency conflicts?</p><p>In a desktop application, or a solution like Blazor Server, EF Core will automatically track the entities as long as the context exists. This means you can load an entity, modify it, then save changes and if there is a concurrency conflict, an exception is thrown. With Blazor WebAssembly, however, the server must operate in a disconnected state: the load happens separately from the update. To handle this, I use shadow properties. Before jumping into concurrency, let’s look at our controller and explore some more features.</p><p>Continue to the next section:</p><div><p><img src="https://blog.jeremylikness.com/blog/build-a-blazor-webassembly-line-of-business-app-part-2/images/validation_hu0e4bb389a5f1c0c27a4c1686455d2241_49794_200x100_fit_q75_box.jpg" alt="Build a Blazor WebAssembly Line of Business App Part 2: Client and Server"></p><p><small>Part 2 of the series that describes a fully functional real-world project built in Blazor WebAssembly with EF Core. Part 2 focuses on the Web API, shadow properties, automation of audit, and the repository implementation.</small></p></div><p>Regards,</p><p><img src="https://blog.jeremylikness.com/images/jeremylikness.gif" alt="Jeremy Likness"></p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>