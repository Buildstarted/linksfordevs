<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Joe Bergeron | Java Obfuscation: A Pattern Language - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Joe Bergeron | Java Obfuscation: A Pattern Language - linksfor.dev(s)"/>
    <meta property="og:description" content="I recently took it upon myself to decompile and attempt to deobfuscate the relatively substantial Java codebase of a much-loved childhood MMO, a game which still manages to&#xA;attract a sizeable playerbase, despite its age. (Take a guess at what game I&#x27;m talking about!) By no means am I the first to attempt this; many third-party clients exist for&#xA;this game, some even open-source. My goal with this project wasn&#x27;t to do anything new, or even to improve on the deobfuscations and client rewrites that already exist. Mostly,&#xA;I just wanted to see how it&#x27;s done, if I could do it, and how, in theory, one might go about programtically integrating with the game&#x27;s API. The point of this post is not about&#xA;the specifics of this game&#x27;s implementation. Rather, it&#x27;s about some tricky (read: evil) obfuscation techniques that I&#x27;ve discovered while working through the decompiled Java bytecode."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.joe-bergeron.com/posts/Java%20Obfuscation:%20A%20Pattern%20Language/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Joe Bergeron | Java Obfuscation: A Pattern Language</title>
<div class="readable">
        <h1>Joe Bergeron | Java Obfuscation: A Pattern Language</h1>
            <div>Reading time: 26-33 minutes</div>
        <div>Posted here: 25 Jul 2020</div>
        <p><a href="https://www.joe-bergeron.com/posts/Java%20Obfuscation:%20A%20Pattern%20Language/">https://www.joe-bergeron.com/posts/Java%20Obfuscation:%20A%20Pattern%20Language/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><h5>July 22, 2020</h5><br><h2>Background</h2><p>I recently took it upon myself to decompile and attempt to deobfuscate the relatively substantial Java codebase of a much-loved childhood MMO, a game which still manages to
attract a sizeable playerbase, despite its age. (Take a guess at what game I'm talking about!) By no means am I the first to attempt this; many third-party clients exist for
this game, some even open-source. My goal with this project wasn't to do anything new, or even to improve on the deobfuscations and client rewrites that already exist. Mostly,
I just wanted to see how it's done, if I could do it, and how, in theory, one might go about programtically integrating with the game's API. The point of this post is not about
the specifics of this game's implementation. Rather, it's about some tricky (read: evil) obfuscation techniques that I've discovered while working through the decompiled Java bytecode.</p><p>The game I chose to decompile and deobfuscate has historically been the target of botters. This game supports a large and ubiquitous in-game economy; this economy is crucial to
the game's enjoyment, and its health is required for the game's sustainability. Over the game's lifespan, numerous waves of widespread and coordinated botting have hugely impacted
and degraded the health of the game. As a result, botters and the developers play a never-ending game of cat and mouse, with botters typically a couple of steps ahead.</p><p>I have no interest in botting. I do however, have an interest in how it's done in theory, from first principles. Plenty of software is available to assist in writing and executing
bot scripts already. I wanted to see how one might go from "big binary client blob" to teasing out the structure of the client and hooking into it, what techniques are involved, and
how difficult such a task might be.</p><h2>Setup</h2><p>I am, by no means whatsoever, a Java programmer. In fact, it is a language I love to disparage, conjuring up images of certain <a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition" target="_blank">eldritch horrors</a>.
Despite this, I decided to dive in head first. The game client is distributed as a Java <code>.jar</code>. Great cross-platform support! The first step, then, is to attempt to decompile it. My
first attempt at decompilation was with <a href="https://github.com/fesh0r/fernflower" target="_blank"><em>fernflower</em></a>. This was easy to do, but resulted in a more or less unusable product. fernflower was
entirely incapable of decompiling certain functions, which left me with something I had no hope of getting to re-compile successfully.</p><p>My second attempt at decompilation was with <a href="https://github.com/Storyyeller/Krakatau" target="_blank"><em>Krakatau</em></a>. This was much more successful, with all classes and methods seemingly decompiling to
<strong>something</strong>, at the very least. Despite this, the source did not easily recompile. The client <code>.jar</code> is seemingly customized per-platform, which means it depended on a number
of external (MacOS) libraries I didn't have access to. After stripping the decompiled source of all such problematic references, to my complete surprise, it actually managed to compile
and run; I was able to log in to the client and run the game as normal!</p><p>The only reason I mention the decompilation step is because I'm not entirely sure if certain aspects/properties/patterns in the decompiled source are a consequence of direct, intentional
obfuscation by the client developers, or simply artifacts of the decompiler's implementation. That is to say, I'm not entirely sure if the patterns below would be encountered when using
other decompilers than Krakatau. Anyways, now that I had a compile-able source, it was time to start cleaning things up and figuring out how everything worked. The purpose of this post
is to just try to document some common code patterns/strategies I encountered while deobfuscating the source. But first...</p><h3>A note on editors...</h3><p>Like with all my projects, I began by opening up <a href="https://www.gnu.org/software/emacs/" target="_blank">emacs</a> in a <a href="https://kb.iu.edu/d/acuy" target="_blank">screen</a> session in my shell. I very quickly
realized that, for the first time I've ever experienced, emacs may have met its match. I'm sure with enough Java-specific packages I could have made it work. Out of the box, though,
emacs just was not suited for the task of deobfuscating decompiled code. Tasks like refactoring function signatures, renaming symbols, and automatic removal of redundant code blocks
are critical, and editor support for these is a must-have. Tools like listing all symbol usage, and being able to distinguish between reads and writes on a symbol prove hugely
useful. emacs was just not suited to the task. I installed <a href="https://www.jetbrains.com/idea/" target="_blank">IntelliJ IDEA</a>, and have so far been very pleased with it. It's certainly a whole lot
better than when I had to use <a href="https://www.eclipse.org/ide/" target="_blank">Eclipse</a> for the single undergraduate course I took in Java, and it features some very powerful static analysis tools.</p><h2>Obfuscation Patterns</h2><p>What follows is a list of some tricky code patterns I've noticed while attempting to deobfuscate, and some techniques I've used to overcome them.</p><h3>Function Overloading</h3><p>This one's great, and I'm pretty sure it's a consequence of direct obfuscation. All methods for classes (that don't inherit and override methods from a standard Java library, or implement some interface) have the same
exact method name, overloaded with different singatures for each. Typically, this results in all classes being filled with methods named <code>a</code>. If two class methods have the same signature, one of them gets the next letter of the alphabet as their name, and so on. I'm also pretty sure the obfuscator takes Java's type inference into account -- I noticed some methods
named <code>b</code> without identical function signatures named <code>a</code>. If our class is named <code>a</code> (yes, really), this all might look a little something like this.</p><pre><pre><code><span>final</span> <span><span>class</span> <span>a</span> </span>{
    <span><span>final</span> <span>static</span> <span>void</span> <span>a</span><span>(String s, String s0, String s1)</span> </span>{
        <span>// Do stuff</span>
    }
    <span><span>final</span> <span>static</span> String <span>a</span><span>(bool b, bool b0)</span> </span>{
        <span>// Do stuff</span>
    }
    <span><span>final</span> <span>static</span> <span>void</span> <span>a</span><span>(<span>int</span> i)</span> </span>{
        <span>// Do stuff</span>
    }
    <span><span>final</span> <span>static</span> <span>int</span> <span>a</span><span>(String s, <span>int</span> i)</span> </span>{
        <span>// Do stuff</span>
    }
    <span><span>final</span> <span>static</span> <span>void</span> <span>b</span><span>(<span>int</span> i)</span> </span>{
        <span>// Do stuff</span>
    }
    a() {
        <span>// Do stuff</span>
    }
    a(String s) {
        <span>// Do stuff</span>
    }
}
</code></pre></pre><p>Great. Honestly, this is more of an inconvenient nuisance than anything else. Good IDEs will be able to symbolically distinguish which implementation of the overloaded method is being
called in a particular location, show all usages of that implementation, and rename the implementation and all its uses. Without a good IDE, however, this would be kind of a nightmare.
There's no way a good decompiler would <em>choose</em> to name methods this way. We can actually look at the debug information in the <code>.class</code> files included in the original <code>.jar</code> to see that
the source was intentionally obfuscated this way:</p><pre><pre><code>$ javap someclass.class

&gt; Compiled from <span>"someclass.java"</span>
&gt; public final class someclass {
&gt;   static final void a(java.lang.String, java.lang.String, int, java.lang.String);
&gt;   static final void a(java.lang.String, int);
&gt;   public static final void a(int, java.lang.String);
&gt; }
</code></pre></pre><p>As soon as you start digging into a function like this, I recommend you change its name right away, to something human readable. Very often, you'll want to change the function signature of the method, since many methods have completely useless arguments. By removing an argument, the function signature might collide with another function that has the same name, forcing you
to change the function name anyways.</p><h3>Useless Arguments</h3><h4>(Obvious) Dummy Arguments</h4><p>Of course, the obfuscator inserts function signatures with transparently useless arguments. Occasionally, this is pretty easy to deal with, and in fact, the decompiler even helped to identify these
situations. For example:</p><pre><pre><code><span>final</span> <span><span>class</span> <span>b</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>c</span><span>(String s, String s0, <span>int</span> i)</span> </span>{
        <span>// Do some legitimate stuff</span>

        <span>float</span> dummy = ((<span>float</span>) <span>150</span> * i)/(<span>25.0</span>) + i;

        <span>// Never read/write dummy again</span>
    }
}
</code></pre></pre><p>I ran into a number of cases where a method contained an argument that was read only once, to calculate some number which was then assigned to variable that is never actually used. In these
cases, Krakatau was kind enough to name these variables <code>dummy</code>. Most IDEs will be able to recognize that a variable is unused, and can prompt you to remove them. After removing <code>dummy</code>, you're
safe to remove the integer argument <code>i</code> from the function signature. IDEA, at the very least, allows you to refactor a function signature across a project. If you're removing an argument,
IDEA is smart enough to know whether or not it's safe to remove. Since <code>i</code> is no longer used in the function body, we're good to go; all callers of this method will have the useless argument
removed from their invocation.</p><p>In general, the callers of these methods that contain useless arguments either pass an arbitrary hardcoded value for the useless argument (very common for integer dummy arguments), or some
variable derived from either local variables within the caller, or from an argument passed to the caller itself. Eliminating a useless argument from a deeply nested function has a sort of
butterfly effect elsewhere in the codebase, which can end up revealing information/deobfuscating functions much further up in the stack.</p><p>Unfortunately, there are other sorts of usless arguments, which tend to be much more nefarious.</p><h3>More Complicated Useless Arguments</h3><p>Many arguments appear to affect the control flow of a method in some significant way, but in reality are useless, and actually have no effect on
execution. For an argument like this to <em>actually</em> have no effect, it needs to be the case that either:</p><ul><li>the direction the control flow takes is irrelevant to the final outcome, or</li><li>the same path is taken on every call.</li></ul><p>Typically, if the variable affects the control flow of the function, it does so in a meaningful way. In other words, the direction
that the control flow takes <em>matters</em>. Real differences in program logic are found between the paths. For the argument to be actually useless then,
it needs to take on a value that always results in the same code path executing. This happens <em>a lot</em>. Here's a very silly example:</p><pre><pre><code><span>final</span> <span><span>class</span> <span>a</span> </span>{
    <span><span>final</span> <span>static</span> <span>void</span> <span>a</span><span>()</span> </span>{
        b.a(-<span>124</span>);
    }

    <span><span>final</span> <span>static</span> <span>void</span> <span>b</span><span>()</span> </span>{
        b.a(-<span>204</span>);
    }

    <span><span>final</span> <span>static</span> <span>void</span> <span>c</span><span>()</span> </span>{
        b.a(-<span>110</span>);
    }

    <span><span>final</span> <span>static</span> <span>void</span> <span>d</span><span>()</span> </span>{
        b.a(-<span>891</span>);
    }

    <span><span>final</span> <span>static</span> <span>void</span> <span>e</span><span>()</span> </span>{
        b.a(-<span>220</span>);
    }
}
</code></pre></pre><pre><pre><code><span>final</span> <span><span>class</span> <span>b</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>a</span><span>(<span>int</span> i)</span> </span>{
        <span>if</span> (i &gt; -<span>110</span>) {
            <span>// Crash the program, do whatever...</span>
            <span>return</span> <span>0</span>;
        }
        <span>// Do something reasonable...</span>
        <span>return</span> <span>100</span>;
    }
}
</code></pre></pre><p>Arguments can appear like they actually do something until you look at what the callers are actually calling the function with. Oftentimes, the actual value that passed arguments
take on will guarantee that a particular codepath is executed on every call. In this case, if these are our only two classes, it's obvious that the integer argument to <code>b.a</code> is
useless; the <code>if</code> statement never fires in any of our calls, so we're safe to just completely delete the <code>if</code> block from <code>b.a</code>. Some actual cases are as simple as the example
given above, but most are more complicated.</p><p>In reality, the value passed by callers to <code>b.a</code> will be a hardcoded value in about, say, 50% of cases. The other half of the values will be derived variables. It takes a fair
bit of sleuthing to figure out that <em>all</em> of these derived values throughout the entire codebase will always guarantee some particular codepath firing in <code>b.a</code>. A lot of times,
these derived variables can be reduced to constants by searching the source for <em>all calls</em> to the <em>callers of, e.g. <code>b.a</code></em>, recursing up the stack. For example:</p><pre><pre><code><span>final</span> <span><span>class</span> <span>a</span> </span>{
    <span><span>final</span> <span>static</span> <span>void</span> <span>a</span><span>()</span> </span>{
        <span>boolean</span> b0 = <span>false</span>;
        b0 = !b0;
        b.a(b0);
    }

    <span><span>final</span> <span>static</span> <span>void</span> <span>b</span><span>()</span> </span>{
        b.a(<span>true</span>);
    }
}
</code></pre></pre><pre><pre><code><span>final</span> <span><span>class</span> <span>b</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>a</span><span>(<span>boolean</span> b0)</span> </span>{
        <span>int</span> i = -<span>100</span>;
        <span>if</span> (!b0) {
            <span>return</span> c.a(i + <span>150</span>);
        }
        <span>return</span> c.a(-i*<span>3</span>);
    }
}
</code></pre></pre><pre><pre><code><span>final</span> <span><span>class</span> <span>c</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>a</span><span>(<span>int</span> i)</span> </span>{
        <span>if</span> (i &gt; <span>100</span>) {
            <span>// Crash the program, do whatever...</span>
            <span>return</span> <span>0</span>;
        }
        <span>// Do something reasonable...</span>
        <span>return</span> <span>100</span>;
    }
}
</code></pre></pre><p>This is a bit more convoluted, no? Even if <code>b.a</code> is the only method that calls <code>c.a</code>, we can't yet remove the argument from <code>c.a</code>'s signature, since <code>b.a</code>'s boolean argument controls
what gets passed to <code>c.a</code>. If <code>b0</code> is <code>true</code>, we call <code>c.a(300)</code>, else we call <code>c.a(50)</code>. If <code>b0</code> is actually useless within <code>b.a</code>, however, we can then remove <code>i</code> from<code>c.a</code>'s signature.
Looking at <code>a.a</code> and <code>a.b</code>, we see that <code>b.a</code> is always passed <code>true</code>, which means that the <code>if block</code> in <code>b.a</code> <em>always</em> fires, which means we can remove its argument, and get:</p><pre><pre><code><span>final</span> <span><span>class</span> <span>a</span> </span>{
    <span><span>final</span> <span>static</span> <span>void</span> <span>a</span><span>()</span> </span>{
        b.a();
    }

    <span><span>final</span> <span>static</span> <span>void</span> <span>b</span><span>()</span> </span>{
        b.a();
    }
}
</code></pre></pre><pre><pre><code><span>final</span> <span><span>class</span> <span>b</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>a</span><span>()</span> </span>{
        <span>return</span> c.a(<span>50</span>);
    }
}
</code></pre></pre><pre><pre><code><span>final</span> <span><span>class</span> <span>c</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>a</span><span>(<span>int</span> i)</span> </span>{
        <span>if</span> (i &gt; <span>100</span>) {
            <span>// Crash the program, do whatever...</span>
            <span>return</span> <span>0</span>;
        }

        <span>// Do something reasonable...</span>
        <span>return</span> <span>100</span>;
    }
}
</code></pre></pre><p>Now, it's obvious that <code>c.a</code>'s argument is useless. Additionally, <code>a.a</code> and <code>a.b</code> now have identical functionality. We can combine them and modify all potential callers of either of them to
call this new method. We can also rename everything else:</p><pre><pre><code><span>final</span> <span><span>class</span> <span>Class1</span> </span>{
    <span><span>final</span> <span>static</span> <span>void</span> <span>combinedFunction</span><span>()</span> </span>{
        Class2.get100Wrapper();
    }
}
</code></pre></pre><pre><pre><code><span>final</span> <span><span>class</span> <span>Class2</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>get100Wrapper</span><span>()</span> </span>{
        <span>return</span> Class3.get100();
    }
}
</code></pre></pre><pre><pre><code><span>final</span> <span><span>class</span> <span>Class3</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>get100</span><span>()</span> </span>{
        <span>return</span> <span>100</span>;
    }
}
</code></pre></pre><p>Different names, different function signatures, but same exact behavior. In practice, identifying and eliminating unnecessary arguments to functions is a pretty painful process, though I've
it to be pretty important in eliminating the noise and getting to the core of what's actually going on.</p><h3>Useless Static Variables</h3><p>This is probably even more annoying to me than unnecessary arguments to methods. The obfuscation process seems to insert useless static variables into classes, that are used throughout the entire
application in seemingly consequential ways. These variables are both read from and written to in various places throughout the codebase, but these reads and writes never actually do anything
meaningful.</p><p>In one particularly frustrating example from my experience, there was a static class variable, call it <code>bar</code>, in the class <code>Foo</code>, which gets initialized to 0. <em>Every single method</em>, in <em>every
single class</em>, in the <em>entire application</em> was filled with checks every couple of lines, to make sure that <code>Foo.bar</code> was 0. If it wasn't, the application would take some totally bonkers code
path that took everything off course, and, as I discovered by manually forcing <code>Foo.bar = 1</code>, sent the program into infinite loops and stack overflows. This obviously smelled like a completely
useless piece of data, meant to confuse humans trying to reverse engineer the source, but I couldn't be 100% sure.</p><p>Turns out, <code>Foo.bar</code>, is written to in one place besides initialization, where it gets incremented -- <code>Foo.bar = Foo.bar + 1</code>. Huh, maybe it could possibly be nonzero somehow. Further
digging showed that this increment was wrapped in an <code>if</code> block, that checked to make sure <em>another</em> static class variable, call it <code>Baz.bar</code>, was nonzero. So, if <code>Baz.bar</code> was ever nonzero,
we'd set <code>Foo.bar</code> nonzero and crash. Well, <code>Baz.bar</code> is initialized to zero, and only written to in one place, like <code>Foo.bar</code>, where we increment it -- <code>Baz.bar = Baz.bar + 1</code>. Okay...
Well, turns out that increment is wrapped in an <code>if</code> of its own... we only increment <code>Baz.bar</code> if <code>Foo.bar</code> is nonzero! We essentially have a deadlock situation, where neither variable can
turn nonzero unless the other one already is. What this ultimately means, is that both <code>Foo.bar</code> and <code>Baz.bar</code> are essentially constant values, and all their occurences can be replaced with
a simple 0.</p><p>This wasn't the only example in the application where classes had completely useless static variables. Some static variables were actually used as a replacement for method arguments. For example:</p><pre><pre><code><span>final</span> <span><span>class</span> <span>a</span> </span>{
    <span>static</span> <span>int</span> x;

    <span><span>final</span> <span>static</span> <span>int</span> <span>a</span><span>(<span>int</span> i)</span> </span>{
        x = i;
        <span>return</span> a.b()*<span>2</span>;
    }

    <span><span>final</span> <span>static</span> <span>int</span> <span>b</span><span>()</span> </span>{
        <span>return</span> x*<span>3</span>;
    }
}
</code></pre></pre><p>This is a silly example, but clearly, <code>x</code> should be an argument to <code>a.b</code> rather than a static variable. After cleaning up, things should look a bit like this:</p><pre><pre><code><span>final</span> <span><span>class</span> <span>Multiply</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>timesSix</span><span>(<span>int</span> number)</span> </span>{
        <span>return</span> Multiply.timesThree(number)*<span>2</span>;
    }

    <span><span>final</span> <span>static</span> <span>int</span> <span>timesThree</span><span>(<span>int</span> number)</span> </span>{
        <span>return</span> number*<span>3</span>;
    }
}
</code></pre></pre><p>In general, when a static class variable is used in a very limited number of functions, all in a small, congruent slice of the call stack, it should probably be an argument
rather than a class variable.</p><h3>Labels</h3><p>By far the single most evil and mind-bogglingly frustrating pattern I encountered throughout my deobfuscation efforts was the use of <em>labels</em> in the decompiled code.
I'm not sure if this comes from some explicit obfuscation process, or is a quirk of the decompilation itself (although both decompilers I tried resulted in the same
sort of label usage), but it's probably the most frustrating thing I had to deal with.</p><p><em>Labels</em> in Java, if you haven't used them before (I hope you haven't!) work probably as you'd expect.</p><pre><pre><code><span>boolean</span> b0 = <span>true</span>;
<span>boolean</span> b1 = <span>false</span>;
<span>int</span> i0 = <span>0</span>;

label0:
    label1: {
        <span>if</span> (b0) {
            <span>break</span> label1;
        }
        i0 += <span>1</span>;
    }
    <span>if</span> (b1) {
        <span>break</span> label0;
    }
    i0 += <span>1</span>;
}
</code></pre></pre><p>Labels can be added to (any?) lexical scope, not just arbitrary scope created using brackets. That means we can add labels to <code>for</code>, <code>while</code>, <code>try</code>/<code>catch</code>/<code>finally</code>,  etc.
The <code>break &lt;label&gt;</code> statement just jumps execution to the next statement directly after the end of the referenced label. A more, er, <em>conventional</em> way to write the above
snippet might look something like this.</p><pre><pre><code><span>boolean</span> b0 = <span>true</span>;
<span>boolean</span> b1 = <span>false</span>;
<span>int</span> i1 = <span>0</span>;

<span>if</span> (b0) {
    i0 += <span>1</span>;
}

<span>if</span> (b1) {
    i0 += <span>1</span>;
}
</code></pre></pre><p>That's a bit better. In the decompiled source I was analyzing, certain (<em>extremely long</em>) functions contained over to <em>thirty</em> (<strong>30!</strong>) nested labels. Fortunately, a common
pattern in these situations emerged, making them somewhat simple, if not <em>extremely annoying</em> to deal with.</p><h4>Labeling &amp; Exceptions</h4><p>Get this: you have a long function and you don't want to refactor it. Lots of little pieces of your function can throw an exception of type, say, <code>SomeException</code>, and your
function is designated to throw this exception type as well, with a <code>throws SomeException</code>. How do you structure your function? Ignore the exceptions and let them bubble up?
Lots of minimally-scoped <code>try</code>/<code>catch</code> blocks to try to deal with the errors? Boo. How about somwthing like this?</p><pre><pre><code><span><span>final</span> <span>static</span> <span>void</span> <span>myFunction</span><span>()</span> <span>throws</span> SomeException </span>{
    SomeException a0 = <span>null</span>;
    label0: {
        SomeException a1 = <span>null</span>;
        label1: {
            SomeException a2 = <span>null</span>;
            label2: {
                SomeException a3 = <span>null</span>;
                label3: {
                    SomeException a4 = <span>null</span>;
                    label4: {
                        <span>try</span> {
                            FunctionOne();
                        } <span>catch</span> (SomeException a5) {
                            a0 = a5;
                            <span>break</span> label0;
                        }
                        <span>try</span> {
                            FunctionTwo();
                        } <span>catch</span> (SomeException a6) {
                            a1 = a6;
                            <span>break</span> label1;
                        }
                        <span>try</span> {
                            FunctionThree();
                        } <span>catch</span> (SomeException a7) {
                            a2 = a7;
                            <span>break</span> label2;
                        }
                        <span>try</span> {
                            FunctionFour();
                        } <span>catch</span> (SomeException a8) {
                            a3 = a8;
                            <span>break</span> label3;
                        }
                        <span>try</span> {
                            FunctionFive();
                        } <span>catch</span> (SomeException a9) {
                            a4 = a9;
                            <span>break</span> label4;
                        }
                        <span>return</span>;
                    }
                    <span>throw</span> a4;
                }
                <span>throw</span> a3;
            }
            <span>throw</span> a2;
        }
        <span>throw</span> a1;
    }
    <span>throw</span> a0;
}
</code></pre></pre><p>Take a good long look. Now imagine <code>label4</code> actually reads <code>label37</code>. Do you know what this is doing? I'll save you the trouble. The function above is exactly equivalent to this one:</p><pre><pre><code><span><span>final</span> <span>static</span> <span>void</span> <span>myFunction</span><span>()</span> <span>throws</span> SomeException </span>{
    FunctionOne();
    FunctionTwo();
    FunctionThree();
    FunctionFour();
}
</code></pre></pre><p>Pretty cool, huh? At first, this pattern looked pretty scary, and I dreaded tackling the 600+ line functions that abused it. After I figured out the trick though, I realized that
this pattern posed a mere annoyance, instead of demanding real mental gymnastics. This isn't the only fun with labels to be found though. There's one other primary label pattern I
ran into.</p><h4>Labeling &amp; Conditionals</h4><p>Take a walk with me.<sup id="fnref-1"><a href="#fn-1">1</a></sup> You've just finished re-reading "Clean Code", a staple of your morning routine. As you wrap up reciting your <a href="http://www.ccs.neu.edu/home/lieber/courses/csg110/sp08/Pragmatic%20Quick%20Reference.htm" target="_blank">daily affirmations</a>
and give your hands a moment to rest after a vigourous session of finger-stretches, you make your way to your standing desk and let the hydraulics work their magic. You take a sip of your freshly brewed, locally-sourced coffee.
(Inverted aeopress; bulletproof.) You open up your 2019 Macbook Pro -- AirPods in, daily Spotify EDM playlist on. You click on the familiar icon in your dock -- your IDE of choice. As Eclipse jumps to life on your 13.3" Retina display,
your gaze rests comfortably on a fresh, blank Java project. "Time to implement some <em>business logic</em>," you think to yourself. Your fingers float effortlessly over your split ortholinear keyboard in a flash of brilliance, the ear-piercing <em>"CLACK!"</em>
of your Cherry MX Blues barely audible over the epic beat of the latest Diplo track. Time passes. Was it minutes? Hours? Sweating, dizzy, you lower your desk and collapse into your Steelcase Leap office chair. Wiping beads of sweat
from your brow, you squint at the screen, beholding the fruits of your labor.</p><pre><pre><code><span>final</span> <span>static</span> <span><span>class</span> <span>a</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>a</span><span>(<span>boolean</span> b, <span>int</span> i)</span> </span>{
        <span>int</span> i0 = <span>0</span>;
        <span>int</span> i1 = <span>0</span>;
        label0: {
            label1: {
                <span>if</span> (!b) {
                   <span>break</span> label1;
                }
                <span>if</span> (i ^ -<span>1</span> &lt;= -<span>100</span>) {
                    i0 = <span>20</span>;
                    i = i*i0;
                    <span>break</span> label0;
                }
                i1 = -<span>50</span>;
                i0 = (i1 ^ -<span>1</span>) - i;
                <span>break</span> label0;
            }
            i1 = -<span>200</span>;
            i0 = i1 + -<span>200</span>;
        }
        i1 = <span>7</span>;
        i0 = (i0 ^ -<span>1</span>) + i1;
        <span>return</span> i0;
    }
}
</code></pre></pre><p>Good thing you read Clean Code, or else that might have looked a lot worse. Fun and games aside, one of the primary strengths of obfuscation is making trivial logic look terribly complicated. A common
pattern I noticed was that otherwise simple <code>if</code>/<code>else if</code>/<code>else</code> statements were replaced with awful label/break combinations. In the simplest case, this pattern looks as follows:</p><pre><pre><code>
label0: {
    label1: {
        <span>if</span> (condition1) {
            <span>break</span> label1;
        }
        <span>if</span> (condition2) {
            <span>// Only executed if condition2</span>
            <span>break</span> label0;
        }
        <span>// Only executed if !condition1 and !condition2</span>
        <span>break</span> label0;
    }
    <span>// Only executed if condition1</span>
}
<span>// Always executed</span>

</code></pre></pre><p>Laid out like this, the logic becomes a bit clearer, if you stare at it for long enough. If we simplify our original example, we get something that looks like this:</p><pre><pre><code><span>final</span> <span>static</span> <span><span>class</span> <span>a</span> </span>{
    <span><span>final</span> <span>static</span> <span>int</span> <span>a</span><span>(<span>boolean</span> b, <span>int</span> i)</span> </span>{
        <span>int</span> i0 = <span>0</span>;
        <span>int</span> i1 = <span>0</span>;

        <span>if</span> (!b) {
            i1 = -<span>200</span>;
            i0 = i1 + -<span>200</span>;
        } <span>else</span> <span>if</span> (i ^ -<span>1</span> &lt;= -<span>100</span>) {
            i0 = <span>20</span>;
            i = i*i0;
        } <span>else</span> {
            i1 = -<span>50</span>;
            i0 = (i1 ^ -<span>1</span>) - i;
        }

        i1 = <span>7</span>;
        i0 = (i1 ^ -<span>1</span>) + i;
        <span>return</span> i0;
    }
}
</code></pre></pre><p>This pattern is particularly annoying, since it introduces a significant lexical seperation between the program logic and the code that fires between each path. With larger versions of this
pattern, containing multiple <code>else if</code> blocks, things can get pretty hairy. Even in this example, the first <code>if</code> statement is physically quite far away from the code that relates to it; it's
not immediately obvious what's supposed to happen here.</p><p>Looking at the above example, you might notice something else that seems a bit off. What the hell is <code>i ^ -1</code>??</p><h3>Drop-In Replacements</h3><p>I suppose this one is a free win for the obfuscators. If you can make a single statement an order of magnitude more complicated in isolation, why not? Often times, simple standalone
statements would be replaced with more complicated versions that ultimately evaluate to the same thing. I haven't taken a look at the JVM bytecode (and frankly, I'm not too keen on it)
so I'm not sure whether or not this is a consequence of the decompiler or intentional obfuscation. Either way, there were two types of replacements that stuck out to me.</p><h4>XOR-Minus-One</h4><p>This one took me embarassingly long to decode. Literally every conditional operator in the decompiled code that compared integers, did it a little bit like this:</p><pre><pre><code><span>if</span> ((i0 ^ -<span>1</span>) &lt;= (-<span>110</span> ^ -<span>1</span>)) ...
</code></pre></pre><p>Long story short, for an integer <code>i</code>, <code>i ^ -1</code> ends up evaluating to <code>-i - 1</code>. <code>i0 ^ -1</code> turns to <code>-i0 -1</code>, and <code>-110 ^ -1</code> turns to <code>110 - 1</code> turns to <code>109</code>. Working it out, our original
conditional turns into...</p><pre><pre><code><span>if</span> (i0 &gt;= -<span>110</span>) ...
</code></pre></pre><p>A bit simpler. This pattern does a great job at obscuring what's actually being compared. That <em>is</em> kind of the point, I suppose.</p><h4>Char =&gt; Int</h4><p>I actually suspect this one is a product of the standard compilation/decompilation process itself, but I'm not entirely sure. Regardless, every place a character literal would typically
be used, it was replaced with its integer representation. For example, one particular function iterated over an array over bytes, looking for locations where a particular string
occured. It did this by peeking ahead of the current index and comparing the contents of subsequent indices to integer literals. In one case, it was checking if subsequent indices
equaled <code>78</code>, <code>97</code>, <code>109</code>, <code>101</code>, <code>58</code>, in that order. While annoying, all it takes is a quick scan of an <a href="http://www.asciitable.com/" target="_blank">ASCII table</a> to decipher what we're looking for:
a substring containing "Name:"<sup id="fnref-2"><a href="#fn-2">2</a></sup>.</p><h3>Function Inlining</h3><p>This one is just a suspicion, but I wouldn't be surprised if it was indeed the case. A number of decompiled functions, particularly ones that control important outer loops of the primary program logic,
are obscenely long. Even when deobfuscated and simplified, their logic seems to cover much more than any sensibly structured code should cover. Once deobfuscated, the actual logic of these
exceptionally long functions tends to organize itself nicely into neat functional blocks, which gives me the suspicion that these neat functional blocks were initially class methods. Since the logic in
these functional blocks only (to the best of my knowledge) appears a single time throughout the codebase, it would make sense that these blocks of code were originally standalone methods that the
obfuscator decided could be safely inlined into the body of the caller, without increasing binary size. Not only is this annoying, since we end up having super long functions in the decompiled
source, but it seems to give the obfuscator more opportunities to mangle together program logic, since there's just more <em>stuff</em> to work with in these longer functions.</p><h2>In Conclusion...</h2><p>I think that's about all I've got for now. If you know any other <em>fun</em> and <em>exciting</em> obfuscation techniques that I've missed, please let me know! Similarly, if you're particularly well-versed
in actual (de)obfuscation/reverse engineering, please let me know if I've gotten anything wrong in this post. In particular, I'd be curious to know which sorts of patterns are typically found
in obfuscators, versus those that are merely unavoidable aspects of regular compilation/decompilation. In either case, if you're trying to obfuscate your code, hopefully you have some neat new
tools to work with, and if you're trying to reverse engineer something, hopefully you're a bit better equipped.</p></div></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>