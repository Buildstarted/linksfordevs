<!DOCTYPE html>
<html lang="en">
<head>
    <title>
fractals, computer graphics, mathematics, shaders, demoscene and more -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>fractals, computer graphics, mathematics, shaders, demoscene and more</h1><div><div id="" class="">. It runs full framerate in my GeForce 1070 based latpop, using a single fragment shader to do all rendering (again, Shadertoy style). The mesh and BVH data is stored in a Shader Storage Buffer, so I couldn't share it as an actual Shadertoy example.<center><div class="partsC"><div class="part"><img class="myPicture" src="gfx02.jpg"><p class="readability-styled" style="display: inline;">Soft shadows produced by an exact SDF</p></div><div class="part"><img class="myPicture" src="gfx03.jpg"><p class="readability-styled" style="display: inline;">Displacement</p></div><div class="part"><img class="myPicture" src="gfx04.jpg"><p class="readability-styled" style="display: inline;">Smooth minimum</p></div></div></center>
Besides the nice shading and lighting tricks, one advantage of an SDF representation for a mesh is that one can do easy edge antialiasing and more importantly, it opens the doors for research in geometric filtering for analytic LOD, since the SDF of a mesh provides a volumetric representation.<p>The code wasn't particularly optimized, I wrote the whole demo in a night, but in run well enough as a simple fragment shader as I said (no compute):</p><p class="code">float sdMesh( in vec3 pos, in float minDist )
{
    stack_reset();
    int currentNode = 0;
    for( ;; )
    {
        Node n = data.node[ currentNode ];
        
        
        if( sdBox( pos, n.bbox ) &lt; minDist )
        {
            
            if( n.numTriangles&gt;0 )
            {
                minDist = sdTriangles( pos, n.trianglesOffset, n.numTriangles, minDist );
            }
			
            
            int closest = (pos[n.splitAxis] &lt; center(n.bbox)[n.splitAxis]) ? 0 : 1;
            stack_push( Data(n.childOffset+1-closest) );
            stack_push( Data(n.childOffset+  closest) );
        }

        
        if( stack_is_empty() ) break;
        currentNode = stack_pop();
    }

    return minDist;
}</p><br>Please note this code is just given as a basic reference to give you an idea of the kind of algorithm used, and it's by no means optimized. For example, in practice one can traverse big parts of the hierarchy without ever pushing and popping nodes into the stack by rearranging the traversal in a nested loop. Also, all the node data such as numTriangles and splitAxis are just bits in a shared integer field, and trianglesOffset and childOffset are of course a shared integer as well. And of course the bounding boxes can be quantized. Lastly, you can perform the whole mesh SDF evaluation with a single square root, since both the sdBox() and sdTriangle() functions allow for taking it as a common factor. Note however how in this implementation the tree is binary and the children are allocated in pairs in order to save on pointer/offsets.<p>In practice, much of the performance is determined by the tree construction algorithm and considerations such as the SAH (Surface Area Heuristic) that determines how to split a node into children, amount of children overlap that is allowed on encouraged, the maximum number of triangles allowed in a node, etc.</p><h3>Spatial Subdivision</h3><hr><br>One problem with BVH is that each node needs to store its bounding volume, which can be very memory consuming even when quantized heavily. One way to improve that situation is to use Spatial Subdivision schemas instead, which don't partition the data-set but space. So, technically they don't belong in an article called "Bounding Volumes", but since they are relevant and I used a second night to experiment with them, I'll talk quickly about it now, if only as an introduction.<p>Grids, Octrees and KD-Trees are the best known Spatial Subdivision structures. From these, only Octrees and KD-Trees are hierarchical, which we need. KD-Tres are binary trees, so their traversal logic is simpler than that for Octrees. While in an Octree traversal one needs to decide the order priority of the 8 children, in a KD-tree there's only two and usually a simple comparison or sign bit extraction suffices to determine the best children to proceed with.</p><p>The advantage of Spatial Subdivision structures over Bounding Volume Hierarchies is that they offer a smaller memory footprint and bandwidth. The cons, however, are that they are more expensive to build, AND require a thicker stack in the shader code during runtime traversal. A thicker stack consumes more registers and can kill parallelism in the thread group, if implemented in the GPU. Techniques can be used to amortize the cost of traversal among tiles of pixels by using compute shaders, but at that point we are asking for problems when rays are shot randomly instead of in right packets (unless, again, an even more sophisticated layer of point evaluation sorting is added on top, again outside the scope of this article).</p><p>The following is a simplified comparison between the trade-offs in the Node and Stack structures for both methods:</p><table cellpadding="12"><tbody><tr><td></td><td>Node Data</td><td>Stack Data</td></tr><tr><td>BVH</td><td>BBox, PointerOffset, Flags</td><td>PointerOffset, Flags</td></tr><tr><td>KD-Tree</td><td>NodeID</td><td>BBox, NodeID</td></tr></tbody></table><br>Of course there are hybrid acceleration structures such as BIH, but that night I came up with an interesting way for using KD-Trees without having to pay the cost of the BBox (or split plane location) storage in the stack. The idea was to sacrifice tree quality and use a simple procedural space splitting criteria instead of sophisticated SAH during tree construction. This should allow, from the Node ID/address alone to reconstruct its bounding box completely in the shader. Meaning all that I'd need to push to the stack would be an integer, not a whole bbox. The cons and pros of this method are:<p>Cons:<br></p><ul><li>Lower quality tree</li><li>More compute during traversal (need to build the bounding boxes procedurally)</li></ul>
Pros:<br><ul><li>Think stack like BVH, less register pressure</li><li>Faster build times (no SAH!)</li></ul>
In my experiment I was able to build the bounding boxes from the address of each node  by interpreting it a binary string where each bit indicates a left or right branch taken down the tree. I implemented this by using GLSL's findMSB() call and some branchless bit manipulations (as many as levels of depth were allowed in my tree).<p>I coded the procedural KD-tree in a second night of work and this time I implemented a more proper KD-tree traversal loop, which I had experience with from (now 15 years old!) past <a class="regular" href="../raytracing/raytracing.htm">real-time SIMD packet ratracing</a> work. Of course traversing and looking for intersections is different than traversing looking for closest distance, but the code is similar enough so these were not unkown waters this time.</p><p>For a single night of work, the technique was not a failure, but it wasn't also super successful, I think I'd need to spend more time in this problem space in order to get a good traversal implementation, and maybe do it as a compute shader rather than a fragment shader. But, it did work to some degree, at least I was able to raymarch primary rays and soft shadows for some models like the Sponza atrium (downloaded from Morgan McGuire's Computer Graphics Archive <a class="regular" href="https://casual-effects.com/data">https://casual-effects.com/data</a>)
</p><div class="iframeCenter"><p class="readability-styled" style="display: inline;">KD-Tree driven raymarched SDF, with soft shadows, object blending, occlusion and distance driven moss</p></div><p>The performance was pretty bad though, on the single digit framerate in my laptop computer + GeForce 1070. Still, you can see nice soft shadows, some contact shadowing/occlusion and a sphere that I added to the scene to show this was an SDF, so for a quick experiment I think this was a good outcome.</p><center><img class="myPicture" src="gfx06.jpg"><br>Hit map (triange+box sdf evaluations per mesh SDF evaluation)</center><p>Overall, I think there's lots of potential for SDF evaluation using the same acceleration structures used for regular raycasting, and the benefit is that one can evaluate proximity to geometry easily, which has multiple purposes beyond shadowing tricks - for example, you can use it to drive vegetation growth and wetness or snow, just to name a few shading ideas, as shown in the image above where the proximity to other geometry drives the green surface coloring. I was told that the acceleration structures for HW raytracing in current GPUs wouldn't be efficient for SDF evaluation, but I think they don't need to be - you can get a lot of global proximity information with one or two queries per pixel and do lots of cool things with them that would require dozens of regular rays. So I feel we have a 10x performance hit we can take for SDF evaluation and still be competitive with raycast based methods?</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>