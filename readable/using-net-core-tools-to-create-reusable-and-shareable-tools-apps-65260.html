<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using .NET Core Tools to Create Reusable and Shareable Tools &amp; Apps - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Using .NET Core Tools to Create Reusable and Shareable Tools &amp; Apps - linksfor.dev(s)"/>
    <meta property="article:author" content="https://facebook.com/rickstrahl"/>
    <meta property="og:description" content="Dotnet Tools offer a simple way to create, publish and consume what are essentially .NET Core applications that can be published and shared using the existing NuGet infrastructure for packaging and distribution. It&#x27;s y quick and easy to build tools that you can share either publicly or privately.  In this article I make a case for why you might use or build a Dotnet Tool and show how create, build, publish and consume Dotnet tools as well as showing some examples of useful tools I&#x27;ve build and published."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://weblog.west-wind.com/posts/2020/Aug/05/Using-NET-Core-Tools-to-Create-Reusable-and-Shareable-Tools-Apps"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Using .NET Core Tools to Create Reusable and Shareable Tools &amp; Apps</title>
<div class="readable">
        <h1>Using .NET Core Tools to Create Reusable and Shareable Tools &amp; Apps</h1>
            <div>by https://facebook.com/rickstrahl</div>
            <div>Reading time: 29-37 minutes</div>
        <div>Posted here: 05 Aug 2020</div>
        <p><a href="https://weblog.west-wind.com/posts/2020/Aug/05/Using-NET-Core-Tools-to-Create-Reusable-and-Shareable-Tools-Apps">https://weblog.west-wind.com/posts/2020/Aug/05/Using-NET-Core-Tools-to-Create-Reusable-and-Shareable-Tools-Apps</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="ArticleBody" itemprop="articleBody">
        
        


        <p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/banner.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/banner.png" alt=""></a></p>
<p>Starting with .NET Core 2.1 Microsoft introduced the <strong>Dotnet Tools</strong> platform as part of the .NET Core SDK and since then these tools have become a vital although underutilized part of the .NET Eco system.</p>
<p>Dotnet Tools are a simple way to create, publish and consume what are essentially .NET Core applications that can be published and shared using the existing NuGet infrastructure for packaging and distribution. This means it's really quick and easy to build tools that you can share either publicly or privately.</p>

<p>When you break down a Dotnet Tool it boils down to its simplest terms you end up with this simple statement:</p>
<blockquote>
<p><strong>“A Dotnet Tool is a glorified.NET Core Application that can be quickly and easily shared and installed via NuGet.”</strong></p>
<p><small><em>me, 2020</em></small></p>
</blockquote>
<p>The idea behind a Dotnet Tool is to make it easy to build, publish and consume executable tools in the same way you've been able create NuGet packages for .NET and .NET Core components.</p>
<p>And while the original idea was to build tools to aid as part of the build and development process, this platform really offers a much wider scope because <strong>you can publish and share any .NET Core executable application</strong>. This includes servers that run full ASP.NET Core applications or services, and even .NET Core desktop applications.</p>
<h3 id="why-use-dotnet-tools"><a name="why-use-dotnet-tools" href="#why-use-dotnet-tools"></a>Why use Dotnet Tools?</h3>
<p>While the idea behind Dotnet Tools isn't anything new, this tooling does provide a number of benefits to developers and the entire .NET Core eco system. The big selling points are:</p>
<p><strong>Easy to build</strong></p>
<ul>
<li>Uses standard .NET Core Projects</li>
<li>Uses existing NuGet Infrastructure</li>
<li>Nothing new to learn - works with existing tech</li>
<li>Configured via standard <code>.csproj</code> settings</li>
</ul>
<p><strong>Sharing</strong></p>
<ul>
<li>Can be easily shared</li>
<li>Can reach a large number of users</li>
<li>Quickly published and available</li>
<li>No explicit package validation</li>
</ul>
<p><strong>Community</strong></p>
<ul>
<li>Ease of use and shareability promotes creation of tools</li>
<li>Shared content helps build community</li>
</ul>
<p>On the flip side there is a big prerequisite to using a Dotnet Tool:</p>
<ul>
<li>The <strong>.NET Core SDK is required</strong> to install a Dotnet Tool</li>
</ul>
<p>The SDK dependence is both a blessing and a curse: Because it's guaranteed that the .NET Core Runtime is installed, binaries of your Dotnet Tool can be very small and only consist of application specific files. But the .NET SDK has to exist on the target machine and the SDK install is neither small, nor something that a typical, non development user will already have installed.</p>
<h3 id="careful-security-of-dotnet-tools"><a name="careful-security-of-dotnet-tools" href="#careful-security-of-dotnet-tools"></a>Careful: Security of Dotnet Tools</h3>
<p>Since Dotnet Tools are executables that are installed from a remote source and there is no validation process for published tools, it's important to understand that <strong>there is a potentially substantial security risk</strong> to your machine. The code that comes down can execute locally on your system and  has access to your local resources when you run a tool.</p>
<p>Be sure you trust the publisher of the tool, and/or verify that the source code is available somewhere to review and check for issues in the project.</p>
<p><strong>Be careful and know the risks!</strong></p>
<p>To be fair, the same cautions apply to NuGet packages since those too can execute any code contained in the package and there's not much concern around that.</p>
<h3 id="theres-nothing-new-under-the-sun"><a name="theres-nothing-new-under-the-sun" href="#theres-nothing-new-under-the-sun"></a>There's nothing new under the Sun!</h3>
<blockquote>
<p><em><strong>“Did you just describe NPM?”</strong></em><br>
Yup: Dotnet Tool is very much like NPM  for .NET Core.</p>
</blockquote>
<p>If all this looks familiar from NodeJs and NPM - you're right. The idea of shared tools is not new by any means and follows various other development platforms and their package managers. But for .NET to easily publish and share binary executable tools in a cross-platform manner is relatively new and exciting and opens up the reach of small and useful tools that otherwise would never be shared.</p>
<h3 id="what-can-you-use-dotnet-tools-for"><a name="what-can-you-use-dotnet-tools-for" href="#what-can-you-use-dotnet-tools-for"></a>What can you use Dotnet Tools For?</h3>
<p>Although .NET Tools were initially designed to provide development time tools, compilation helpers, build tools etc., it turns out that Dotnet Tools are just plain .NET Core executables that can do anything that a .NET Core executable can do. This means you can use it for all sorts of things that might not be directly developer related.</p>
<p>Here are a few general use cases addressed by Dotnet Tools:</p>
<ul>
<li><p><strong>Build and Dev Time Tools</strong><br>
There are many tools that follow the original design goal for creating project helpers that make development tasks easier or facilitate external but related development operations. For example, tools like EF migration commands in <code>dotnet ef</code>, <code>dotnet watch run</code>, and the user secrets manager, dotnet watch are all Dotnet Tools that fit this bill. There are many tools available in this category.</p>
</li>
<li><p><strong>Generic Command Line Tools</strong><br>
If you need to build some complex command line helpers that work on scenarios that are more complex than what you reasonably want to do in PowerShell or Bash, a tool can fit that niche nicely. Because these tools can be shared and installed easily and are generally very small they make a good fit for <em>'beyond scripting'</em> scenarios.</p>
</li>
<li><p><strong>Local Servers</strong><br>
.NET Core makes it easy to build server applications and it's easy to create self-contained Web Server or Services applications. Whether it's running a Web application locally for testing, or whether you have some internal application that maybe is a hybrid that uses both a Web interface and a desktop application in mixed mode, a Dotnet Tool makes it easy to provide this. It's very powerful to be able to create <strong>small</strong> and easily shareable, self-contained Web and server applications. I'll show a couple of examples of this later.</p>
</li>
<li><p><strong>Desktop Applications</strong><br>
Although Microsoft's official documentation claims that <code>Dotnet Tool</code> is meant for Console Applications, it turns out that you <strong>can</strong> also create desktop applications and share them as a tool. You can create .NET Core WinForms and WPF applications and package them as tools too. Keep in mind though that WinForms and WPF applications are platform dependent and have to run on Windows, unlike pure Console applications which can run on any supported .NET Core platform assuming they are not using platform specific features.</p>
</li>
</ul>
<h3 id="locating-dotnet-tools-available"><a name="locating-dotnet-tools-available" href="#locating-dotnet-tools-available"></a>Locating Dotnet Tools Available</h3>
<p>Unfortunately, finding all .NET Tools that are available is not so obvious. Puzzlingly the <a href="https://nuget.org/">NuGet Web site</a> doesn't allow any filters for searches that filter for just Dotnet Tools.</p>
<p>There are a couple of other places you can check though:</p>
<ul>
<li><p>Nate McMaster has a GitHub repo with a <a href="https://github.com/natemcmaster/dotnet-tools">list of many Dotnet Tools</a></p>
</li>
<li><p>The <a href="https://www.toolget.net/tools?q=LiveReloadServer">ToolGet Site</a> searches NuGet with a Dotnet Tool filter!</p>
</li>
</ul>
<h3 id="dotnet-tool-or-platform-specific-binary"><a name="dotnet-tool-or-platform-specific-binary" href="#dotnet-tool-or-platform-specific-binary"></a>Dotnet Tool or Platform Specific Binary?</h3>
<p>.NET Core supports creating executable binaries for every platform that it supports. But each platform requires a custom executable launcher and runtime dependencies to run, which means each platform distribution is different.</p>
<p>It's possible to create standalone executables for each platform using either a pre-installed .NET Core runtime installation, or a fully self-contained executable that can contain all the required runtime files in addition to the files that your application needs to run. Self-contained applications are great for self-reliance and predictable behavior, but they are terribly large as the runtimes make up a minimum of 70mb of distribution size.</p>
<p>A full self-contained application is useful and sometimes required, especially for non-developer related tools. If you're building an end user tool or application, then a self-contained application is usually a better call. But if you're building developer tools the <code>Dotnet Tool</code> experience is often preferable. Dotnet Tools are definitely targeted at developers and not end users.</p>
<p>The advantage of building a .NET Tool is that  a Dotnet Tool is <strong>not platform specific</strong>. Like a NuGet component package, the executable is actually just the compiled .NET assemblies packaged into a NuGet zip file. This file contains the .NET executable code, that is not tied to any platform - ie. there's no platform specific binary loader as you would have with an EXE file on Windows for example. Since Dotnet Tools rely on an SDK installation to run, the runtime is guaranteed to be there. If <code>dotnet tool</code> can run, your tool can run.</p>
<p>This means you can build a single, relatively small NuGet package as a Dotnet Tool and it will work on all supported .NET Core platforms - assuming your code is written to otherwise use platform agnostic features. That's cool: It provides you cross platform functionality without having to build and maintain any platform specific loaders and it keeps the deployment size very small.</p>
<p>As an aside, you can also achieve the same cross-platform behavior with a .NET Core Runtime installation and using <code>dotnet run</code> but that's considerably less user friendly as you have to deal with paths and installation folders. A Dotnet Tool abstracts all that away so you just have your executable to run.</p>

<p>Let's jump in and see how you can:</p>
<ul>
<li>Build a Dotnet Tool package for distribution</li>
<li>Publish a Dotnet Tool package</li>
<li>Consume a Dotnet Tool package</li>
</ul>
<h3 id="create-a-dotnet-tool-step-by-step"><a name="create-a-dotnet-tool-step-by-step" href="#create-a-dotnet-tool-step-by-step"></a>Create a Dotnet Tool Step by Step</h3>
<p>Let's create a very simple project <code>MagicWindBall</code> that 'predicts' Wind conditions for the day. It's a play on words of Magic Eightball which is a fake fortune telling device and I'm highjacking the idea to tell me my wind fortunes.</p>
<p>Start by creating a .NET Core Console project. I'll use the <code>dotnet</code> Command line tooling, but you can also use Visual Studio (or <a href="https://www.jetbrains.com/rider/">Rider</a> etc.) to create a new <strong>.NET Core Console project</strong>.</p>
<p>From the command line, start by creating a new folder with the Project name, and then create a project in that folder:</p>
<pre><code>mkdir MagicWindBall
cd MagicWindBall
dotnet new console
code .
</code></pre>
<p>This creates a new project <code>MagicWindBall.csproj</code> which you can open in Visual Studio or Visual Studio Code. I'll use VS Code here as shown in <strong>Figure 1</strong>, which makes it easy to open the projects from a folder via <code>code .</code>.</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/DotnetToolProjectVisualStudioCode.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/DotnetToolProjectVisualStudioCode.png" alt=""></a><br>
<small><strong>Figure 1</strong> - Opening and running the Console project in Visual Studio Code</small></p>
<p>This project is silly simple, with an imaginary wind forecast generator that randomly displays a string from a list of pre-defined wind condition strings.</p>
<p>The code is along these lines: <small>(full code on GitHub at <a href="https://github.com/RickStrahl/CodeMagazine-DotnetTools/blob/master/Source/MagicWindBall/Program.cs">https://github.com/RickStrahl/CodeMagazine-DotnetTools/blob/master/Source/MagicWindBall/Program.cs</a>)</small></p>
<pre><code><span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
{
    WriteWrappedHeader(<span>"Magic WindBall"</span>);

    Console.WriteLine();

    Write(<span>"thinking."</span>, ConsoleColor.Cyan);
    Wait(<span>500</span>);
   
    Write(<span>" consulting the stars."</span>, ConsoleColor.Yellow);
    Wait(<span>1000</span>);
    Write(<span>"."</span>, ConsoleColor.Yellow);
   
    Write(<span>" guessing some more."</span>, ConsoleColor.Cyan);
    Wait(<span>1000</span>);
    Write(<span>"."</span>, ConsoleColor.Cyan);
    
    Console.WriteLine(<span>'\n'</span>);

    <span>var</span> rnd = <span>new</span> Random(DateTime.UtcNow.Millisecond);
    <span>var</span> val = rnd.Next(<span>6</span>);
    
    Console.WriteLine(<span>"Wind today be:"</span>);

    <span>switch</span> (val)
    {

        <span>case</span> <span>0</span>:
            WriteLine(<span>"No Wind - Skunked again."</span>, ConsoleColor.DarkYellow);
            <span>break</span>;
        <span>case</span> <span>1</span>:
            WriteLine(<span>"Light Wind - Take a nap, pray for wind."</span>, ConsoleColor.DarkCyan);
            <span>break</span>;
        <span>case</span> <span>2</span>:
            WriteLine(<span>"Light Breeze - Sucker wind."</span>, ConsoleColor.DarkGreen);
            <span>break</span>;
        <span>case</span> <span>3</span>:
            WriteLine(<span>"Breezy- Wake up and get ready."</span>, ConsoleColor.Green);
            <span>break</span>;
        <span>case</span> <span>4</span>:
            WriteLine(<span>"Windy- What the hell are you doing at the keyboard?"</span>, ConsoleColor.Yellow);
            <span>break</span>;
        <span>case</span> <span>5</span>:
            WriteLine(<span>"Super Nuker- Get out and rig your Hankie."</span>, ConsoleColor.Red);
            <span>break</span>;
        <span>default</span>:
            WriteLine(<span>"Roll the Dice - It's coming in waves."</span>);
            <span>break</span>;
    }

    Console.WriteLine();
}
</code></pre>
<p>First, let's make sure the code works as a regular Console application. Open a Terminal in the project folder and do:</p>
<pre><code>dotnet run
</code></pre>
<p>In <strong>Figure 1</strong> I use the built-in Terminal in VS Code Terminal to test the 'application'.</p>
<h4 id="make-it-a-dotnet-tool"><a name="make-it-a-dotnet-tool" href="#make-it-a-dotnet-tool"></a>Make it a Dotnet Tool</h4>
<p>You now have a plain .NET Core Console application. To turn this into a <strong>Dotnet Tool</strong> add a few specific settings to the project file. At minimum add:</p>
<pre><code><span>&lt;<span>Project</span> <span>Sdk</span>=<span>"Microsoft.NET.Sdk"</span>&gt;</span>

  <span>&lt;<span>PropertyGroup</span>&gt;</span>    
    <span>&lt;<span>OutputType</span>&gt;</span>Exe<span>&lt;/<span>OutputType</span>&gt;</span>
    <span>&lt;<span>TargetFramework</span>&gt;</span>netcoreapp3.1<span>&lt;/<span>TargetFramework</span>&gt;</span>
  <span>&lt;/<span>PropertyGroup</span>&gt;</span>

  
  <span>&lt;<span>PropertyGroup</span>&gt;</span>
    <span>&lt;<span>PackAsTool</span>&gt;</span>true<span>&lt;/<span>PackAsTool</span>&gt;</span>
    <span>&lt;<span>PackageId</span>&gt;</span>dotnet-magicwindball<span>&lt;/<span>PackageId</span>&gt;</span>
    <span>&lt;<span>ToolCommandName</span>&gt;</span>magicwindball<span>&lt;/<span>ToolCommandName</span>&gt;</span>
    
    <span>&lt;<span>PackageOutputPath</span>&gt;</span>./nupkg<span>&lt;/<span>PackageOutputPath</span>&gt;</span>
    <span>&lt;<span>GeneratePackageOnBuild</span>&gt;</span>true<span>&lt;/<span>GeneratePackageOnBuild</span>&gt;</span>
  <span>&lt;/<span>PropertyGroup</span>&gt;</span>

<span>&lt;/<span>Project</span>&gt;</span>
</code></pre>
<p>The dotnet tool specific settings set the project as a .NET tool via <code>&lt;PackAsTool&gt;</code>, provide a name and set up the project to build as a NuGet package. With these flags in place you can now build the project and generate the Dotnet Tool NuGet Package into the <code>./nupkg</code> folder:</p>
<pre><code>dotnet build -c Release
</code></pre>
<p>If you use Visual Studio just build in Release mode.</p>
<p>This builds the project <strong>and creates a NuGet Package</strong> in the <code>./nupkg</code> folder. You can use the <a href="https://github.com/NuGetPackageExplorer/NuGetPackageExplorer">NuGet Package Explorer</a> to spy into the package to see what is in the package as shown in <strong>Figure 2</strong>.</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/NugetPackageExplorer.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/NugetPackageExplorer.png" alt=""></a><br>
<small><strong>Figure 2</strong> - The Dotnet Tool NuGet Package in the NuGet Package Explorer
</small></p>
<h4 id="testing-the-dotnet-tool-locally"><a name="testing-the-dotnet-tool-locally" href="#testing-the-dotnet-tool-locally"></a>Testing the Dotnet Tool Locally</h4>
<p>Once you've created the NuGet Package you'll probably want to test it locally first before publishing it to NuGet (if at all). You can do that by installing the dotnet tool locally from a folder. To install a Dotnet Tool you use <code>dotnet tool install</code> or <code>dotnet tool update</code>.</p>
<p>For public tools that come from the default, cloud based NuGet package store you use:</p>
<pre><code>Dotnet Tool install -g dotnet-magicwindball
</code></pre>
<p>But... this doesn't work yet, because I haven't published the package yet. You can however test the package locally by installing the NuGet component from a folder by specifying the <code>--add-source ./nupkg</code> command line option:</p>
<pre><code>dotnet tool install -g dotnet-magicwindball --add-source ./nupkg
</code></pre>
<p>Et voila! You've just installed the Dotnet Tool locally and you can now run the tool simply by typing <code>magicwindball</code> into the Terminal. <strong>Figure 3</strong> shows building, installing and running the tool in a Terminal window.</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/BuildAndRunLocal.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/BuildAndRunLocal.png" alt=""></a><br>
<small><strong>Figure 3</strong> - Build and run your Dotnet Tool locally</small></p>
<h4 id="publishing-to-nuget"><a name="publishing-to-nuget" href="#publishing-to-nuget"></a>Publishing to NuGet</h4>
<p>Dotnet Tools are published as NuGet packages and use the same exact mechanism you might use to publish a NuGet package for a regular .NET Component using <code>Nuget publish</code> or you can also use the NuGet Package Explorer shown in <strong>Figure 2</strong> earlier.</p>
<p>Here's a full build, sign and publish PowerShell script <small>(<a href="https://github.com/RickStrahl/CodeMagazine-DotnetTools/blob/master/Source/MagicWindBall/publish-nuget.ps1">full script on Github</a>)</small>:</p>
<pre><code>dotnet build -c Release

<span>$filename</span> = gci <span>"./nupkg/*.nupkg"</span> | `
                sort LastWriteTime | `
                select -last <span>1</span> | `
                select -ExpandProperty <span>"Name"</span>
<span>$len</span> = <span>$filename</span>.length

<span>if</span> (<span>$len</span> <span>-gt</span> <span>0</span>) {
    nuget sign  <span>".\nupkg\<span>$filename</span>"</span>   `
          -CertificateSubject <span>"West Wind Technologies"</span> `
          -timestamper <span>" http://timestamp.comodoca.com"</span>

    nuget push  <span>".\nupkg\<span>$filename</span>"</span> -source nuget.org
}
</code></pre>
<p>Note that NuGet Package signing is optional, but since I already have a publisher certificate I'm using it to sign my package. For the <code>nuget push</code> to work you'll need to set the active NuGet publishing Id before you publish the package.</p>
<pre><code>nuget setApiKey &lt;your_API_key&gt;   
</code></pre>
<p>Once published the package is  listed on NuGet after a few minutes. <strong>Figure 4</strong> shows what the package looks like on the NuGet Package Store site.</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/DotnetToolOnNuGet.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/DotnetToolOnNuGet.png" alt=""></a><br>
<small><strong>Figure 4</strong> - The published Dotnet Tool in the NuGet Package Store</small></p>
<p>Once published, the package becomes accessible within a few minutes. Feed listings can take a bit longer, so you may have to explicitly specify a version on the command line using the <code>--version</code> flag.</p>
<p>You can now install and run the component from the NuGet Package Store. <strong>Figure 5</strong> shows the install and run sequence.</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/InstallAndRunFromNuget.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/InstallAndRunFromNuget.png" alt=""></a>
<small><strong>Figure 5</strong> - Install and Run a Dotnet Tool</small></p>
<p>If you need to update the Dotnet Tool, make your code changes and increment the version number of the project then simply, re-publish to NuGet. A new package with the new version number is created and pushed and that becomes available on Nuget. Then use <code>dotnet tool update -g dotnet-magicwindball</code> to update the local tool installation.</p>
<h3 id="how-a-tool-gets-executed"><a name="how-a-tool-gets-executed" href="#how-a-tool-gets-executed"></a>How a Tool gets Executed</h3>
<p>Dotnet Tools are deployed as .NET NuGet packages that <strong>don't include an OS specific executable file</strong>. Rather, when a tool is installed, a proxy launcher executable is created that acts as a proxy loader for the .NET Core runtime, which then bootstraps the dotnet tool application. The proxy is created in a system mapped <code>.dotnet</code> folder and is then globally available by the command name. <strong>Figure 6</strong> shows the proxy and the actual install folder that holds only the .NET assemblies that can execute on any platform.</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/DotnetToolsProxyFolder.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/DotnetToolsProxyFolder.png" alt=""></a><br>
<small><strong>Figure 6</strong> - An installed Dotnet Tool uses a proxy loader to launch the Dotnet Tool.</small></p>
<p>The <code>.dotnet/.store</code> path holds the actual unpacked NuGet package content for each tool installed. When you run the proxy stub (<code>magicwindball.exe</code> in this case), the launcher starts, loads the .NET Core runtime and then calls the <code>static void Main()</code> entry point in the entry assembly of the package. The <code>.exe</code> you see on the left in <strong>Figure 6</strong> is only a loader. If hook up an IL decompiler to the EXE you'll find that the exe is a native binary, not a .NET assembly.</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/NotADotnetAssembly.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/NotADotnetAssembly.png" alt=""></a><br>
<small><strong>Figure 7</strong> - The Dotnet Tool proxy executable is a native launcher</small></p>
<h3 id="running-on-another-platform-linux-with-wsl"><a name="running-on-another-platform-linux-with-wsl" href="#running-on-another-platform-linux-with-wsl"></a>Running on another Platform: Linux with WSL</h3>
<p>Dotnet Tools are platform agnostic and assuming your application doesn't use any platform specific features, they can run as is on Windows, Mac or Linux.</p>
<p>So let's run this Dotnet Tool on Linux using WSL using the same steps as before. Use <code>dotnet tool install</code> and then execute the command. <strong>Figure 8</strong> shows what that looks like inside of the Windows Subsystem for Linux (WSL). If you have WSL installed on Windows or if you have another Linux or Mac OS available to test on, bring up a terminal there and follow the same procedure we used on Windows to install as shown in <strong>Figure 8</strong>.</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/RunningUnderWsl.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/RunningUnderWsl.png" alt=""></a><br>
<strong>Figure 8</strong> - Dotnet Tools are cross platform, here running under WSL</p>
<p>It works, and although this component is exceedingly simple, as long as your application doesn't do anything that is platform specific it'll work on the other supported platforms too.</p>
<h3 id="listing-and-managing-installed-tools"><a name="listing-and-managing-installed-tools" href="#listing-and-managing-installed-tools"></a>Listing and Managing Installed Tools</h3>
<p>You can check what tools you have installed by using the <code>Dotnet Tool list -g</code> command as shown in Figure 9.</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/DotnetToolList.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/DotnetToolList.png" alt=""></a><br>
<strong>Figure 9</strong> - Listing installed Dotnet Tool components</p>
<p>This lists both the <strong>Package Id</strong> which is the Install name used with NuGet and the <strong>Command</strong> name which is used to invoke the package. These can be different as they are for <code>dotnet-magicwindball</code> and the <code>magicwindball</code> command, but they don't have to be. The <code>dotnet-</code> is an original convention used by various .NET internal tools to make it obvious they are .NET tools, but I find in many cases it's more consistent to use a single value for the package and command.</p>
<blockquote>
<p>Keep in mind that command names are <strong>case sensitive</strong> on case sensitive operating systems.</p>
</blockquote>
<p>You can keep tools up to date using the <code>update</code> command:</p>
<pre><code>Dotnet Tool update -g dotnet-magicwindball
</code></pre>
<p>and you can easily uninstall tools with <code>uninstall</code>:</p>
<pre><code>Dotnet Tool uninstall -g dotnet-magicwindball
</code></pre>
<h2 id="example-components"><a name="example-components" href="#example-components"></a>Example Components</h2>
<p>In this section I'd like to describe a few of the Dotnet Tools I've created and discuss the how's and more pertinently the why's. I've been huge fan of these tools because it is so frictionless to get a tool published and reuse. If it wasn't for the easy of sharing via NuGet I probably wouldn't have bothered sharing these tools at all.</p>
<p>Some of these tools I built mainly for myself, but since I've made them public they ended up getting used by quite a few other people. Maybe you'll find some of these useful as well. But more importantly I hope it inspires you to share your own tools no matter how silly or simple - somebody might find them useful too!</p>
<h3 id="simple-tools"><a name="simple-tools" href="#simple-tools"></a>Simple Tools</h3>
<p>The first couple of examples are your typical utility tools that under normal circumstances I would have distributed as a downloadable installer or just a standalone binary. If a tool is popular enough I still go that route <strong>in addition to the Dotnet Tool</strong>, but for me personally I tend to use the .NET tool rather than a standalone installed application.</p>
<h4 id="visual-studio-snippet-converter"><a name="visual-studio-snippet-converter" href="#visual-studio-snippet-converter"></a><a href="https://github.com/RickStrahl/VisualStudioSnippetConverter">Visual Studio Snippet Converter</a></h4>
<p>This tool is a narrow use case utility tool that converts Visual Studio Code Snippets (code expansions) into:</p>
<ul>
<li>Visual Studio Code Snippets</li>
<li>JetBrains Rider Snippets</li>
</ul>
<p>This is obviously specifically targeted at developers who are already using Visual Studio and so are <strong>very likely</strong> to have the .NET SDK installed just by virtue of using Visual Studio. So as a tool this is perfect and it fits perfect into the <strong>Dotnet Project Tooling</strong> use case that was the original design goal by Microsoft.</p>
<p>The background behind this tool is that I have a ton of Visual Studio code snippets that help me quickly format blocks of code - from inserting properties, creating entire blocks of classes that have complex signatures or inserting complex HTML markup completions for various Web frameworks.  Snippets are an incredibly useful and very underutilized feature in Visual Studio (and other tools).</p>
<p>These days I use a number of different development tools - in addition to Visual Studio I use Rider for .NET development especially on other platforms and also Visual Studio Code especially for front end development.</p>
<p>So this tool lets me export my Visual Studio snippets into these other platforms and take advantage of them there as well. It also provides me a with a 'master' snippet repository which I keep in Visual Studio and then export after updating which makes it easy to keep snippets in sync.</p>
<p>To use this tool:</p>
<pre><code>Dotnet Tool install -g snippetconverter
</code></pre>
<p>For options just run it:</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/SnippetConverterSyntax.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/SnippetConverterSyntax.png" alt=""></a><br>
<small><strong>Figure 10</strong> - A Snippet Converter tool to convert Visual Studio Snippets to VS Code and Rider</small></p>
<p>Then to run the converter you can specify a source snippet or folder and an output path:</p>
<pre><code>snippetconverter <span>"~\Visual C#\My Code Snippets"</span> -o <span>"~\ww-csharp.code-snippets"</span> -r -d
</code></pre>
<p>To make the snippet location easier to use the tool lets you use <code>~</code> for the default snippet folders. For Visual Studio you can specify</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/SnippetConverterExportedSnippets.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/SnippetConverterExportedSnippets.png" alt=""></a><br>
<small><strong>Figure 11</strong> - Migrated snippets in VS Code</small></p>
<h4 id="htmlpackager"><a name="htmlpackager" href="#htmlpackager"></a><a href="https://github.com/RickStrahl/Westwind.HtmlPackager">HtmlPackager</a></h4>
<p>HtmlPackager is another very specific tool that I built some time ago to package up HTML content from a URL and package it into either a fully self-contained 'package' bringing all the content offline.  The 'package' output can be either a single very large HTML file that internalizes all dependencies inline in the single HTML file, or an HTML document with a folder full of dependencies, or a Zip file of the latter HTML plus dependencies.</p>
<p>I needed this functionality at the time for my <a href="https://markdownmonster.west-wind.com/">Markdown Monster</a> editor, and was looking for a command line tool, but came up with nothing that worked that had a small footprint and no dependencies. As a result I ended up building my own .NET library that I used in Markdown Monster initially, but I also decided to provide it as a Dotnet Tool so it can be used from the command line to capture URL content into self-contained packages.</p>
<p>This tool is not directly related to Dotnet projects or the development process, but rather it's a general purpose tool and <code>dotnet tool</code> functionality just provides a very easy way to share this tool.</p>
<p>The <code>dotnet-htmlpackager</code> tool can be installed with:</p>
<pre><code>Dotnet Tool install -g dotnet-htmlpackager
</code></pre>
<p>Once installed you can run using the <code>help</code> command to see command line options:</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/HtmlPackagerHelp.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/HtmlPackagerHelp.png" alt=""></a>
<small><strong>Figure 12</strong> - HTML Packager packaging options</small></p>
<p>Then to run it you can do something like this:</p>
<pre><code>htmlpackager  https://markdownmonster.west-wind.com -o /temp/captured/MarkdownMonster.html -v 
</code></pre>
<p>which creates a single, very large but fully self-contained HTML file:</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/HtmlPackagerRun.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/HtmlPackagerRun.png" alt=""></a><br>
<small><strong>Figure 13</strong> - Running HTML Packager against a URL produces a single self-contained HTML file</small></p>
<p>There are other options for creating:</p>
<ul>
<li>A folder of loose HTML and resource files</li>
<li>A zip file of the folder of loose HTML and resources</li>
</ul>
<p>It's a very special use tool but I've found this to be very useful in a few scenarios where I needed to automate the process of capturing an HTML page.</p>
<p>Because this tool is very general purpose, it's also published via Chocolatey as a standalone tool:</p>
<pre><code>choco install htmlpackager
</code></pre>
<h3 id="servers"><a name="servers" href="#servers"></a>Servers</h3>
<p>Because a .NET tool is just a .NET Core application you can take advantage of just about any .NET Core feature - including the ability to create self-contained Web server applications and services that can run locally.</p>
<h4 id="liverelodserver---a-generic-static-file-web-server"><a name="liverelodserver---a-generic-static-file-web-server" href="#liverelodserver---a-generic-static-file-web-server"></a><a href="https://github.com/RickStrahl/LiveReloadServer">LiveRelodServer</a> - A Generic Static File Web Server</h4>
<p>I frequently run local static Web sites on my dev machine where I need to access some client side development site or if I need to do some quick fixes to some HTML or client side content and just push it back up to a server.</p>
<p>In order to do this efficiently I can spin up a full development environment or I can just quickly run a local development server and run the application. The <code>LiveReloadServer</code> tool I created is just that - a quick and dirty .NET Core based static Web Server that can serve local static file content out of an arbitrary folder you specify. It can:</p>
<ul>
<li>Serve Local Static Web Content</li>
<li>Loose Razor Pages (optionally)</li>
<li>Markdown Pages</li>
</ul>
<p>In addition it also provides what for me is the most useful feature:</p>
<ul>
<li>Live Reload Functionality (optionally)</li>
</ul>
<p>The live reload functionality is built-in and enabled by default and automatically refreshes any active HTML pages loaded through the server when an HTML page or any other related resources like CSS, JS etc. plus any extensions you've added are changed. This makes it a great tool to use on older non-build process Web sites or tools you might need to run locally to add functionality and make changes.</p>
<p>The Dotnet Tool makes it easy to install the server and it's very quick to run and start up.</p>
<p>This is not a new idea obviously. There have been static NodeJs based servers like <a href="https://github.com/http-party/http-server#readme">http-server</a> or <a href="https://www.browsersync.io/">browser-sync</a> forever, but these tools require NodeJs and - for browser-sync at least - it doesn't work as quickly or nicely as I would like. LiveReloadServer is an alternative and it's .NET Core based.</p>
<p>To use Live Reload Server:</p>
<pre><code>Dotnet Tool install -g LiveReloadServer
</code></pre>
<p>To run it you simply point it at a <code>--WebRoot</code> folder on your local machine and that site then becomes a Web Site</p>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/LiveReloadServerRunning.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/LiveReloadServerRunning.png" alt=""></a><br>
<small><strong>Figure 14</strong> - LiveReloadServer generically serving Web content out of a local folder</small></p>
<p>Live Reload is enabled by default so you can edit static text files and if you have Razor Pages and/or Markdown Page processing enabled you can also edit Razor and Markdown pages and see those pages refreshed.</p>
<p>This is very useful Dotnet Tool and I use it almost daily. It's also useful to have easy access to when you need to quickly launch a local Web server to check out a folder of files. It also works cross platform, so although originally I built this mainly for my local Windows setup it turns out it also works great on a Mac and Linux (with some minor adjustments for file path syntax 😁).</p>
<p>The server can run both in local publishing mode but can also be accessed externally.</p>
<h4 id="a-legacy-web-and-application-server"><a name="a-legacy-web-and-application-server" href="#a-legacy-web-and-application-server"></a>A Legacy Web and Application Server</h4>
<p>The final example is for a legacy application server. It's an ancient tool that has recently been updated to .NET Core as an option. I've been involved with - wait for it - a FoxPro legacy product called <a href="http://www.west-wind.com/webconnection/" target="WebConnection">West Wind Web Connection</a> that I maintain and still have a hundreds of users on - for nearly 25 years now. This is ultra legacy, and you may laugh at technology this old.</p>
<p>But because the tools I created so many years ago extended FoxPro functionality to build Web applications, there are still a fair number of existing applications that use large FoxPro code bases that haven't been touched in forever and just keep going. These tools have been kept current and continue to allow these ancient applications to continue ticking along without major disruption or requiring complete re-writes on other platforms for which there often is no budget or technical incentive.</p>
<p><a href="http://www.west-wind.com/webconnection/" target="WebConnection">West Wind Web Connection</a> has for many years used .NET technologies to provide the interface between a Web Server (IIS in the past) and FoxPro and the tech using .NET (and now .NET Core) and COM (ugh) is surprisingly stable and reliable with a number of updated applications running on the platform that are nearly 25 years old.</p>
<p>So, when .NET Core came out a few years ago, it offered a number of new opportunities to extend the Web Server interface tooling <a href="http://www.west-wind.com/webconnection/" target="WebConnection">West Wind Web Connection</a> implements by:</p>
<ul>
<li>Providing a fully self-contained development server</li>
<li>Providing a nearly zero configuration environment</li>
<li>Ability to run the server component on non-Windows machines</li>
<li>Ability to run a local machine or network server without requiring IIS</li>
<li>Ability to run truly local Web application like Desktop applications</li>
</ul>
<p>Long story short - a Dotnet Tool turned out to be great delivery mechanism for someone who needs to run an old application that was built with <a href="http://www.west-wind.com/webconnection/" target="WebConnection">West Wind Web Connection</a>, but doesn't have access or can't install IIS on a machine and most of all doesn't want to set up and configure IIS.</p>
<p>This sounds weird, but this is actually a very common scenario for me: A user calls and says they have a <a href="http://www.west-wind.com/webconnection/" target="WebConnection">West Wind Web Connection</a> application that was developed 15 years ago, the developer left and they need to run the application and perhaps make a few changes. Setting up an environment in the past was not the easiest thing in the world. With this new component I can whittle that down to:</p>
<ul>
<li>Install the .NET Core SDK</li>
<li>Install  <code>Dotnet Tool install -g WebConnection</code></li>
<li>Point at a <a href="http://www.west-wind.com/webconnection/" target="WebConnection">West Wind Web Connection</a> folder and go</li>
</ul>
<p><a href="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/WebConnectionServer.png"><img src="https://weblog.west-wind.com/images/2020/CodeMagazine-DotnetTools/WebConnectionServer.png" alt=""></a><br>
<small><strong>Figure 15</strong> - WebConnectionWebServer running a FoxPro server application through .NET Core</small></p>
<p>A Dotnet Tool here offers a smooth solution to distribute a server that can then be used to serve an ancient legacy application without complex configuration or special installations required. On the local machine it's literally - point at a <a href="http://www.west-wind.com/webconnection/" target="WebConnection">West Wind Web Connection</a> application folder and go - no further configuration required. The same server implementation can also be deployed in a live environment with IIS.</p>
<p>The internal server implementation is very similar to the Live Reload server, but extended to handle the <a href="http://www.west-wind.com/webconnection/" target="WebConnection">West Wind Web Connection</a> server protocols so it can handle <a href="http://www.west-wind.com/webconnection/" target="WebConnection">West Wind Web Connection</a> specific script handling and request routing that lets FoxPro server code execute in response to Web requests. The .NET Core implementation was moved from a .NET HTTP Handler to .NET Core Middleware, and it was surprisingly easy with 95% code reuse from the existing handler. The most complex changes for .NET Core had to deal with introducing the Async cascade required to handle all the HTTP inputs and outputs using <code>async</code> code.</p>
<p>Legacy technology is always an eye roller, and I doubt any of you will use this technology (or even know what it is) 😄, but it makes for an interesting use case of the Dotnet Tool functionality in a very unconventional scenario.</p>
<h2 id="summary"><a name="summary" href="#summary"></a>Summary</h2>
<p>Dotnet Tools provide a great way to share executable code from .NET Core in an easy and  platform independent way. If you've built a NuGet package and published it before you already know how to build and share a Dotnet Tool.</p>
<p>They are easy to consume which gives access to a variety existing tools and because they are so easy to share promote a community of tools to be created.</p>
<p>Hopefully this post has given you some ideas of tools that you might want to use, or better yet - create and share your own with the communicate or even just within your organization.</p>
<p>Rock on!</p>
<h2 id="resources"><a name="resources" href="#resources"></a>Resources</h2>
<ul>
<li><a href="https://github.com/natemcmaster/dotnet-tools">Nate McMaster's Tool List</a></li>
<li><a href="https://www.toolget.net/">ToolGet Tool Package Search</a></li>
<li><a href="https://github.com/NuGetPackageExplorer/NuGetPackageExplorer">NuGet Package Explorer</a></li>
</ul>

<ul>
<li><a href="https://github.com/RickStrahl/LiveReloadServer">LiveReloadServer</a></li>
<li><a href="https://github.com/RickStrahl/Westwind.HtmlPackager">HtmlPackager</a></li>
<li><a href="https://github.com/RickStrahl/VisualStudioSnippetConverter">Visual Studio Snippet Converter</a></li>
</ul>





        
        
        
    </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>