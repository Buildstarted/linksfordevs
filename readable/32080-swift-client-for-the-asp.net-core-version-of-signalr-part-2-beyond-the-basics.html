<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Swift Client for the Asp.NET Core version of SignalR &#x2013; Part 2: Beyond the Basics -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Swift Client for the Asp.NET Core version of SignalR – Part 2: Beyond the Basics</h1><div><div class="entry-content"><p>In the <a href="https://blog.3d-logic.com/2019/07/28/swift-client-for-the-asp-net-core-version-of-signalr-part-1-getting-started/">previous post</a> we looked at some basic usage of the <a href="https://github.com/moozzyk/SignalR-Client-Swift">Swift SignalR Client</a>. This was enough to get started but far from enough for any real-world application. In this post we will look at features offered by the client that allow handling more advanced scenarios.</p><h3>Lifecycle hooks</h3><p>One very important detail we glossed over in the previous post was related to starting the connection. While starting the connection seems to be as simple as invoking:<br></p><p class="readability-styled" style="display: inline;">
it is not really the case. If you run the playground sample in one go you will see a lot of errors similar to:</p><br><code><br>2019-07-29T16:05:00.987Z error: Attempting to send data before connection has been started.<br></code><p class="readability-styled" style="display: inline;">
What’s going on here? The </p><code>start()</code><p class="readability-styled" style="display: inline;"> method is a not blocking call and establishing a connection to the server requires sending some HTTP requests, so takes much more time than just running code locally. As a result, the playground code continues to run and try to invoke hub methods while the client is still working in the background on setting up the connection. Another problem is that there is actually no guarantee that the connection will be ever successfully started (e.g. the provided URL can be incorrect, the network can be down, the server might be not responding etc.) but the </p><code>start()</code><p class="readability-styled" style="display: inline;"> method never returns whether the operation completed succcessfully. The solution to these problems is the </p><a href="https://github.com/moozzyk/SignalR-Client-Swift/blob/3db9f3a90a999786aaf7187eceb918b94076c92c/Sources/SignalRClient/HubConnectionDelegate.swift#L11-L15"><code>HubConnectionDelegate</code></a><p class="readability-styled" style="display: inline;"> protocol. It contains a few callbacks that allow the code that consumes the client be notified about the connection lifecycle events. The </p><code>HubConnectionDelegate</code><p class="readability-styled" style="display: inline;"> protocol looks like this:</p><br><p class="readability-styled" style="display: inline;">
The names of the callbacks should make their purpose quite clear but let’s go over them briefly:</p><ul><li><code>connectionDidOpen(hubConnection: HubConnection)</code> –<br>raised when the connection was started successfully. Once this event happens it is safe to invoke hub methods. The hubConnection passed to the callback is the newly started connection</li><li><code>connectionDidFailToOpen(error: Error)</code> – raised when the connection could not be started successfully. The error contains the reason of the failure</li><li><code>connectionDidClose(error: Error?)</code> – raised when the connection was closed. If the connection was closed due to an error the error argument will contain the reason of the failure. If the connection was closed gracefully (due to calling the <code>stop()</code> method) the error will be <code>nil</code>. Once the connection is closed trying invoking a hub method will result in an error</li></ul><p>To set up your code to be notified about hub connection lifecycle events you need to create a class that conforms to the <code>HubConnectionDelegate</code> protocol and use the <code>HubConnectionBuilder.withHubConnectionDelegate()</code> method to register it. One important detail is that the client uses a weak reference to the delegate to prevent retain cycles. This puts the burden of maintaining the reference to the delegate on the user. If the reference is not maintained correctly the delegate might be released prematurely resulting in missing event notifications.<br>The <a href="https://github.com/moozzyk/SignalR-Client-Swift/tree/a1301f0ba2f942e16816a72212126b79d8d11cae/Examples/HubSamplePhone">example chat application</a> shows the usage of the lifecycle events. It <a href="https://github.com/moozzyk/SignalR-Client-Swift/blob/a1301f0ba2f942e16816a72212126b79d8d11cae/Examples/HubSamplePhone/ViewController.swift#L102-L105">blocks/unblocks the UI</a> based on the events raised by hub connection to prevent the user from sending messages when there is no connection to the server. The <code>HubConnectionDelegate</code> derived instance is <a href="https://github.com/moozzyk/SignalR-Client-Swift/blob/a1301f0ba2f942e16816a72212126b79d8d11cae/Examples/HubSamplePhone/ViewController.swift#L18">stored in a class variable</a> to ensure that the delegate will not be released before the connection is stopped.</p><h3>HubConnectionBuilder</h3><p>The <code>HubConnectionBuilder</code> is a helper class that contains a number of methods for configuring the connection:</p><ul><li><code>withLogging</code> – allows configuring logging. By default no logging will be configured and no logs will be written. There are three overloads of the <code>withLogging</code> method. The simplest overload takes just the minimum log level which can be one of:
<ul><li><code>.debug</code> (= 4)</li><li><code>.info</code> (= 3)</li><li><code>.warning</code> (= 2)</li><li><code>.error</code> (= 1)</li></ul><p>When the client is configured with this overload all log entries at the configured or higher log level will be written using the <code>print</code> function. The user can create more advanced loggers (e.g. a file logger) by creating a class conforming to the <a href="https://github.com/moozzyk/SignalR-Client-Swift/blob/99df85c6398374880f728e61f53c5ba9fff10013/Sources/SignalRClient/Logger.swift#L18-L20"><code>Logger</code></a> protocol and registering it with one of the other <code>withLogging</code> overloads</p></li><li><code>withHubConnectionDelegate</code> – configures a delegate that allows receiving connection lifecycle events (described above)</li><li><code>withHttpConnectionOptions</code> – allows setting lower level configuration options (described below)</li><li><code>withHubProtocol</code> – used to set the hub protocol that the client will use to communicate with the server. Not very useful at the moment given that currently the only supported hub protocol is the Json hub protocol which is also used by default (i.e. no additional configuration is required to use this protocol)</li></ul><h3>HttpConnectionOptions</h3><p>The <a href="https://github.com/moozzyk/SignalR-Client-Swift/blob/a1301f0ba2f942e16816a72212126b79d8d11cae/Sources/SignalRClient/HttpConnectionOptions.swift"><code>HttpConnectionOptions</code></a> class contains lower level configuration options set using the <code>HubConnectionBuilder.withHubConnectionOptions</code> method. It allows configuring the following options:</p><ul><li><code>accessTokenProvider</code> – used to set a token provider factory. Each time the client makes an HTTP request (currently – because the client supports only the webSocket transport – this happens when sending the negotiate request and when opening a webSocket) the client will invoke the provided token factory and set the <code>Authorization</code> HTTP header to:<br><code>Bearer {token-returned-by-factory}</code></li><li><code><code>skipNegotiation</code> – by default the first step the client takes to establish a connection with a SignalR server is sending a negotiate request to get the capabilities of the server (e.g. supported transports), the connection id which identifies the connection on the server side and a redirection URL in case of Azure SignalR Service. However, the webSocket transport does not need a connection id (the connection is persistent) and if the user knows that the server supports the webSocket transport the negotiate request can be skipped saving one HTTP request and thus making starting the connection faster. The default value is <code>false</code>. <strong>Note</strong>: when connecting to Azure SignalR service this setting must be set to <code>false</code> regardless of the transport used by the client</code></li><li><code><code>headers</code> – a dictionary containing HTTP headers that should be included in each HTTP request sent by the client</code></li><li><code><code>httpClientFactory</code> – a factory that allow providing an alternative implementation of the <code>HttpClient</code> protocol. Currently used only by tests</code></li></ul><h3><code>Azure SignalR Service</code></h3><p><code>When working with Azure SignalR Service the only requirement is that the <code>HttpConnectionOptions.skipNegotiation</code> is set to false. This is the default setting so typically no special configuration is required to make this scenario work.</code></p><h3><code>Miscellaneous</code></h3><h4><code>Limits on the number of arguments</code></h4><p><code>The <code>invoke</code>/<code>send</code> methods have strongly typed overloads that take up to 8 arguments. This should be plenty but in rare cases when this is not enough it is possible to drop to lower level primitives and use functions that operate on arrays of items that conform to the <code>Encodable</code> protocols. These functions work for any number of arguments and can be used as follows:<br></code></p><h4><code>Variable number of arguments</code></h4><p><code>The SignalR server does not enforce that the same client method is always invoked with the same number of arguments. On the client side this rare scenario cannot be handled with the strongly typed .on methods. In addition -similarly to the scenarios described above – there is a limit of 8 parameters that the strongly typed <code>.on</code> callbacks support. Both scenarios can be handled by dropping to the lower level primitive which uses an <code>ArgumentExtractor</code> class instead of separate arguments. Here is an example:<br></code></p><p><code>These are pretty much all the knobs and buttons that the <a href="https://github.com/moozzyk/SignalR-Client-Swift">Swift SignalR Client</a> currently offers. Knowing them allows using the client in the most effective way.</code></p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><h3 class="jp-relatedposts-headline"><code><em>Related</em></code></h3></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>