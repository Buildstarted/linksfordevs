<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Docker and kvm containers (from scratch) - redo: a recursive build system - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Docker and kvm containers (from scratch) - redo: a recursive build system - linksfor.dev(s)"/>
    <meta property="og:description" content="&quot;Containers&quot; became popular a few years ago with the emergence of&#xA;Docker, but they are actually the result of a&#xA;long line of evolution starting with&#xA;chroot, a concept which dates all&#xA;the way back to 1979.  The idea of a container, or a chroot, is to run a&#xA;process or set of processes in a (more or less) isolated environment that&#x27;s&#xA;separate from your main operating system."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://redo.readthedocs.io/en/latest/cookbook/container/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Docker and kvm containers (from scratch) - redo: a recursive build system</title>
<div class="readable">
        <h1>Docker and kvm containers (from scratch) - redo: a recursive build system</h1>
            <div>Reading time: 42-54 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://redo.readthedocs.io/en/latest/cookbook/container/">https://redo.readthedocs.io/en/latest/cookbook/container/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div role="main">
            <div>
              
                <h3 id="containers">Containers</h3>
<p>"Containers" became popular a few years ago with the emergence of
<a href="https://www.docker.com/">Docker</a>, but they are actually the result of a
long line of evolution starting with
<a href="https://en.wikipedia.org/wiki/Chroot">chroot</a>, a concept which dates all
the way back to 1979.  The idea of a container, or a chroot, is to run a
process or set of processes in a (more or less) isolated environment that's
separate from your main operating system.</p>
<p>The first iteration, chroot, only isolated the filesystem: chroot would
"change" the "root" directory (hence the name) to a subdirectory of the main
filesystem, then run a program that would see only files in that
subdirectory.  Among other things, this was used as a way to prevent rogue
programs from accidentally damaging other files on the system.  But it
wasn't particularly safe, especially because any program running with
administrator privileges could play tricks and eventually switch its root
back to the "real" root directory.  Separately from security, though, it's
sometimes interesting to install a different operating system variant in a
subdirectory, then chroot into it and run programs that require that
operating system version.  For example, if you're running the latest version
of Debian Linux, but you want to build an application that only builds
correctly on the Debian version from 5 years ago, you can install the
5-years-ago Debian files in a directory, chroot into that, and build your
application.  The main limitation is that your "host" system and your chroot
environment share the same kernel version, and rogue programs usually can
find a way to escape the chroot, so it's not useful if your inner system is
running dangerous code.</p>
<p>Partly in response to the limitations of chroot, "virtualization" started to
gain popularity around 2001, made famous by VMware.  (IBM mainframes had
been doing something similar for a few decades, but not many people knew how
IBM mainframes worked.) Anyway, virtualization simulates a computer's actual
hardware and lets you run a different kernel on the virtual hardware, and a
filesystem inside that hardware.  This has several advantages, including
much stricter security separation and the ability to run a different kernel
or even a different "guest" operating system than the one on the host.
Virtualization used to be pretty slow, but it's gotten faster and faster
over the years, especially with the introduction of "paravirtualization,"
where we emulate special virtual-only "hardware" that needs special drivers
in the guest, in exchange for better performance.  On Linux, the easiest
type of paravirtualization nowadays is
<a href="https://www.linux-kvm.org/page/Main_Page">kvm</a> (kernel virtual machine), a
variant of <a href="https://www.qemu.org/">QEMU</a>.</p>
<p>Virtual machines provide excellent security isolation, but at the expense of
performance, since every VM instance needs to have its own kernel, drivers,
init system, terminal emulators, memory management, swap space, and so on.
In response to this, various designers decided to go back to the old
<code>chroot</code> system and start fixing the isolation limits, one by one.  The
history from here gets a bit complicated, since there are many, overlapping,
new APIs that vary between operating systems and versions.  Eventually, this
collection of features congealed into what today we call "containers," in
products like <a href="https://en.wikipedia.org/wiki/OpenVZ">OpenVZ</a>,
<a href="https://en.wikipedia.org/wiki/LXC">LXC</a>, and (most famously) Docker.</p>
<p>Why are we talking about all this?  Because in this tutorial, we'll use
<code>redo</code> to build and run three kinds of containers (chroot, kvm, and docker),
sharing the same app build process between all three.  redo's dependency and
parallelism management makes it easy to build multiple container types in
parallel, share code between different builds, and use different container
types (each with different tradeoffs) for different sorts of testing.</p>
<p>You can follow along by <a href="https://redo.readthedocs.io/en/latest/GettingStarted/">checking out the redo source</a>
and looking in the
<a href="https://github.com/apenwarr/redo/tree/master/docs/cookbook/container">docs/cookbook/container/</a>
directory.</p>
<h3 id="a-hello-world-container">A Hello World container</h3>
<p>Most Docker tutorials start at the highest level of abstraction: download
someone else's container, copy your program into it, and run your program in
a container.  In the spirit of redo's low-level design, we're going to do
the opposite, starting at the very lowest level and building our way up.
The lowest level is, of course, Hello World, which we compiled (with redo of
course) in <a href="https://redo.readthedocs.io/en/latest/cookbook/hello/">an earlier tutorial</a>:
</p><pre><b>../hello/hello.c</b><code lang="c" src="../hello/hello.c"><span>#<span>include</span> <span>&lt;stdio.h&gt;</span></span>

<span><span>int</span> <span>main</span><span>()</span> </span>{
    <span>printf</span>(<span>"Hello, world!\n"</span>);
    <span>return</span> <span>0</span>;
}</code></pre>
<p>In fact, our earlier version of Hello World is a great example of redo's
safe recursion.  Instead of producing an app as part of this tutorial, we'll
just <code>redo-ifchange ../hello/hello</code> from in our new project, confident that
redo will figure out any locking, dependency, consistency, and parallelism
issues.  (This sort of thing usually doesn't work very well in <code>make</code>,
because you might get two parallel sub-instances of <code>make</code> recursing into
the <code>../hello</code> directory simultaneously, stomping on each other.)</p>
<p>For our first "container," we're just going to build a usable chroot
environment containing our program (<code>/bin/hello</code>) and the bare minimum
requirements of an "operating system": a shell (<code>/bin/sh</code>), an init script
(<code>/init</code>, which will just be a symlink to <code>/bin/hello</code>), and, for debugging
purposes, the all-purpose <a href="https://busybox.net/about.html">busybox</a> program.</p>
<p>Here's a .do script that will build our simple container filesystem:
</p><pre><b>simple.fs.do</b><code lang="sh" src="simple.fs.do">



FILES=<span>"
	/bin/sh
	../hello/hello
"</span>
<span>if</span> [ -x /bin/busybox ]; <span>then</span>
	
	FILES=<span>"<span>$FILES</span> /bin/busybox"</span>
<span>else</span>
	redo-ifcreate /bin/busybox
<span>fi</span>
redo-ifchange <span>$FILES</span>

fs=<span>${1%.fs}</span>
rm -rf <span>"<span>$fs</span>"</span>
mkdir -p <span>"<span>$fs</span>/bin"</span>
cp <span>$FILES</span> <span>"<span>$fs</span>/bin/"</span>
ln -s bin/hello <span>"<span>$fs</span>/init"</span>

redo-ifchange <span>"<span>$fs</span>/bin/sh"</span>
</code></pre>
<p>There's a little surprise here.  Did you see it above?
In current versions of redo,
the semantics of a .do script producing a directory as its output are
undefined.  That's because the redo authors haven't yet figured out quite
what ought to happen when a .do file creates a directory.  Or rather,
what should happen <em>after</em> you create a directory?</p>
<p>Can people <code>redo-ifchange</code> on
a file inside that newly created directory?  If so, what if the new directory
contains .do files?  What if you <code>redo-ifchange</code> one of the sub-files before
you <code>redo-ifchange</code> the directory that contains it, so that the sub-file's
.do doesn't exist yet?  And so on.  We don't know.  So for now, to stop you
from depending on this behaviour, we intentionally made it not work.</p>
<p>Instead of that, you can have a .do script that produces a <em>different</em>
directory as a side effect.  So above, <code>simple.fs.do</code> produces a directory
called <code>simple</code> when you run <code>redo simple.fs</code>.  <code>simple.fs</code> is the
(incidentally empty) target file, which is remembered by redo as a node in
the dependency tree, so that other
scripts can depend upon it using <code>redo-ifchange simple.fs</code>.  The <code>simple</code>
directory happens to materialize too, and redo doesn't know anything about
it, which means it doesn't try to do anything about it, and you don't have
to care what redo's semantics for it might someday be.  In other words,
maybe someday we'll find a more elegant way to handle .do files that create
directories, but we won't break your old code when we do.</p>
<p>Okay?</p>
<p>All right, one more catch.  Operating systems are complicated, and there's
one more missing piece.  Our Hello World program is <em>dynamically linked</em>,
which means it depends on shared libraries elsewhere in the system.  You can
see exactly which ones by using the <code>ldd</code> command:</p>
<pre><code><span>$</span><span> ldd ../hello/hello</span>
    linux-vdso.so.1 (0x00007ffd1ffca000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9ddf8fd000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f9ddfe9e000)
</code></pre>

<p>If we <code>chroot</code> into our simplistic "container" and try to run <code>hello</code>, it
won't work, because those libraries aren't available to programs inside the
chroot.  That's the whole point of chroot, after all!</p>
<p>How do we fix it?  We get a list of the libraries with <code>ldd</code>, and then
we copy the libraries into place.</p>
<p>Actually, for reasons we'll address below, let's make a copy of the new
filesystem and copy the new libraries into <em>that</em>:
</p><pre><b>libs.fs.do</b><code lang="sh" src="libs.fs.do">fs=<span>${1%.fs}</span>
redo-ifchange simple.fs

rm -rf <span>"<span>$fs</span>"</span>
cp -a simple/. <span>"<span>$fs</span>"</span>

<span>for</span> full <span>in</span> <span>"<span>$fs</span>"</span>/bin/*; <span>do</span>
	<span>if</span> [ -x <span>"<span>$full</span>"</span> ]; <span>then</span>
		ldd <span>"<span>$full</span>"</span> | <span>while</span> <span>read</span> a b c junk; <span>do</span>
			[ <span>"<span>$b</span>"</span> = <span>"=&gt;"</span> ] &amp;&amp; a=<span>$c</span>
			<span>if</span> [ -e <span>"<span>$a</span>"</span> ]; <span>then</span>
				mkdir -p <span>"<span>$fs</span>/lib"</span> <span>"<span>$fs</span>/<span>$(dirname "$a")</span>"</span>
				cp -f <span>"<span>$a</span>"</span> <span>"<span>$fs</span>/<span>$a</span>"</span>
			<span>fi</span>
		<span>done</span>
	<span>fi</span>
<span>done</span>

redo-ifchange <span>"<span>$fs</span>/bin/sh"</span>
</code></pre>
<p>So now there's a directory called <code>simple</code>, which contains our program and
some helper programs, and one called <code>libs</code>, which contains all that stuff,
plus the supporting libraries.  That latter one is suitable for use with
chroot.</p>
<h3 id="running-a-container-with-unshare-and-chroot">Running a container with <code>unshare</code> and <code>chroot</code></h3>
<p>So let's run it!  We can teach redo how to start a program inside any chroot
by using a <code>default.do</code> script.  In this case, we'll use
<code>default.runlocal.do</code>.  With that file in place, when we run <code>redo
whatever.runlocal</code> (for any value of <code>whatever</code>), redo will first construct
the <code>whatever</code> directory (using <code>redo-ifchange whatever.fs</code>), and then
chroot into it and run <code>/init</code> inside.  We'll collect stdout into the redo
output (ie.  the file outside the chroot named <code>whatever.runlocal</code>).  Also,
the stderr will go to redo's build log, readable with <a href="https://redo.readthedocs.io/redo-log/">redo-log</a>
or on the console at build time, and if the <code>/init</code> script returns a nonzero
exit code, so will our script.  As a result, the whole container execution
will act like a single node in our build process.  It can depend on other
things, and other things can depend on it.</p>
<p>Just one more thing: once upon a time, <code>chroot</code> was only available to
sysadmins, not normal users.  And it's never a good idea to run your build
scripts as root.  Luckily, Linux recently got a feature called "user
namespaces" (userns), which, among many other things, lets non-administrator
users use <code>chroot</code>.  This is a really great addition.</p>
<p>(Unfortunately, some people worry that user namespaces might create security
holes.  From an abundance of caution, many OSes disable user namespaces for
non-administrators by default.  So most of this script is just detecting
those situations so it can give you a useful warning.  The useful part of
the script is basically just: <code>unshare -r chroot "$2" /init &gt;$3</code>.  Alas,
the subsequent error handling makes our script look long and complicated.)</p>
<pre><b>default.runlocal.do</b><code lang="sh" src="default.runlocal.do">redo-ifchange <span>"<span>$2</span>.fs"</span>

./need.sh unshare

<span>set</span> +e
unshare -r chroot <span>"<span>$2</span>"</span> /init &gt;<span>$3</span>
rv=$?
<span>if</span> [ <span>"<span>$rv</span>"</span> != 0 ]; <span>then</span>
	f=/proc/sys/kernel/unprivileged_userns_clone
	<span>if</span> [ -e <span>"<span>$f</span>"</span> ]; <span>then</span>
		<span>read</span> v &lt;<span>$f</span>
		<span>if</span> [ <span>"<span>$v</span>"</span> -eq 0 ]; <span>then</span>
			<span>echo</span> <span>"Try: echo 1 &gt;<span>$f</span>"</span> &gt;&amp;2
		<span>fi</span>
	<span>fi</span>

	f=/proc/sys/kernel/userns_restrict
	<span>if</span> [ -e <span>"<span>$f</span>"</span> ]; <span>then</span>
		<span>read</span> v &lt;<span>$f</span>
		<span>if</span> [ <span>"<span>$v</span>"</span> -ne 0 ]; <span>then</span>
			<span>echo</span> <span>"Try: echo 0 &gt;<span>$f</span>"</span> &gt;&amp;2
		<span>fi</span>
	<span>fi</span>
<span>fi</span>
<span>exit</span> <span>"<span>$rv</span>"</span>
</code></pre>

<p>Speaking of error handling, the script above calls a script called
<code>./need.sh</code>, which is just a helper that prints a helpful error message and
aborts right away if the listed programs are not available to run, rather
than failing in a more complicated way.  We'll use that script more
extensively below.
</p><pre><b>need.sh</b><code lang="sh" src="need.sh"><span>#!/bin/sh</span>
fail=0
<span>for</span> d <span>in</span> <span>"<span>$@</span>"</span>; <span>do</span>
	<span>if</span> ! <span>type</span> <span>"<span>$d</span>"</span> &gt;/dev/null 2&gt;/dev/null; <span>then</span>
		<span>echo</span> <span>" -- missing tool: <span>$d</span>"</span> &gt;&amp;2
		fail=1
	<span>fi</span>
<span>done</span>
<span>exit</span> <span>"<span>$fail</span>"</span>
</code></pre>
<p>And that's it!  A super simple container!</p>
<pre><code><span>$</span><span> redo libs.runlocal</span>
redo  libs.runlocal
redo    libs.fs
redo      simple.fs
<span>
$</span><span> time redo libs.runlocal</span>
redo  libs.runlocal

real    0m0.112s
user    0m0.060s
sys 0m0.024s
<span>
$</span><span> du libs</span>
792 libs/bin
156 libs/lib64
1656    libs/lib/x86_64-linux-gnu
1660    libs/lib
3752    libs
<span>
$</span><span> cat libs.runlocal</span>
Hello, world!
</code></pre>

<p>By the way, if this were a docker tutorial, it would still print "Hello,
world!" but your container would be &gt;100 megabytes instead of 3.7 megabytes,
and it would have taken at least a couple of seconds to start instead of
0.11 seconds.  But we'll get to that later.  First, now that we have a
container, let's do more stuff with it!</p>
<h3 id="running-a-container-with-kvm-and-initrd">Running a container with <code>kvm</code> and <code>initrd</code></h3>
<p>Now you've seen chroot in action, but we can run almost the same container
in <code>kvm</code> (kernel virtual machine) instead, with even greater isolation.
<code>kvm</code> only runs on Linux, so for this step you'll need a Linux machine. And
for our example, we'll just have it run exactly the same kernel you're
already using, although kvm has the ability to use whatever kernel you want.
(You could even build a kernel as part of your redo project, redo-ifchange
it, and then run it with kvm.  But we're not going to do that.)</p>
<p>Besides a kernel, kvm needs an "initial ramdisk", which is where it'll get
its filesystem.  (kvm can't exactly access your normal filesystem,
because it's emulating hardware, and there's no such thing as "filesystem
hardware." There are tools like the <a href="https://www.kernel.org/doc/Documentation/filesystems/9p.txt">9p
filesystem</a>
that make this easier, but it's not available in all kernel builds, so we'll
avoid it for now.)</p>
<p>"Initial ramdisk" (initrd) sounds fancy, but it's actually just a tarball
(technically, a <a href="https://en.wikipedia.org/wiki/Cpio">cpio</a> archive) that the
kernel extracts into a ramdisk at boot time.  Since we already have the
files, making the tarball is easy:
</p><pre><b>default.initrd.do</b><code lang="sh" src="default.initrd.do">redo-ifchange <span>"<span>$2</span>.fs"</span> rdinit
d=<span>$PWD</span>
fs=<span>$2</span>
(
	(<span>cd</span> <span>"<span>$fs</span>"</span> &amp;&amp; find . -print0 |
	 <span>"<span>$d</span>/try_fakeroot.sh"</span> <span>"<span>$d</span>/<span>$2</span>.fakeroot"</span> \
	 	cpio -Hnewc -0 -o)
	<span>printf</span> <span>'rdinit\0'</span> | cpio -Hnewc -0 -o
) &gt;<span>$3</span>
</code></pre>
<p>(Ignore that <code>try_fakeroot.sh</code> thing for now.  We'll get to it a bit further
down.  In our <code>simple.fs</code> example, it's a no-op anyway.)</p>
<p>The main thing you need to know is that, unlike tar, cpio takes a list of
files on stdin instead of on the command line, and it doesn't recurse
automatically (so if you give it a directory name, it'll store an entry for
that directory, but not its contents, unless you also provide a list of its
contents).  This gives us a lot of power, which we'll use later.  For now
we're just doing basically <code>find | cpio -o</code>, which takes all the files and
directories and puts them in a cpio archive file.</p>
<pre><code><span>$</span><span> redo libs.initrd</span>
redo  libs.initrd
5163 blocks
1 block
<span>
$</span><span> cpio -t &lt;libs.initrd</span>
.
bin
bin/hello
bin/busybox
bin/sh
lib64
lib64/ld-linux-x86-64.so.2
lib
lib/x86_64-linux-gnu
lib/x86_64-linux-gnu/libc.so.6
init
7444 blocks
</code></pre>

<p><code>default.initrd.do</code> also appends another file, <code>rdinit</code> (the "ram disk init"
script), which is the first thing the kvm Linux kernel will execute after
booting.  We use this script to set up a useful environment for our
container's <code>/init</code> script to run in - notably, it has to write its stdout
to some virtual hardware device, so redo can capture it, and it has to save
its exit code somewhere, so redo knows whether it suceeded or not.  Here's a
simple <code>rdinit</code> script that should work with any container we want to run
using this technique:
</p><pre><b>rdinit</b><code lang="sh" src="rdinit"><span>#!/bin/sh</span>
busybox mount -t devtmpfs none /dev
/init &gt;/dev/ttyS1
<span>echo</span> $? &gt;/dev/ttyS2
busybox poweroff -f
</code></pre>
<p>Configuring a virtual machine can get a little complicated, and there are a
million things we might want to do.  One of the most important is setting
the size of the ramdisk needed for the initrd.  Current Linux versions limit
the initrd to half the available RAM in the (virtual) machine, so to be
safe, we'll make sure to configure kvm to provide at least 3x as much RAM as
the size of the initrd.  Here's a simple script to calculate that:
</p><pre><b>memcalc.py</b><code lang="sh" src="memcalc.py">
import os, sys
st = os.stat(sys.argv[1])
megabytes = st.st_size // 1024 // 1024


need = megabytes * 3 + 64
<span>print</span>(<span>"%dM"</span> % need)
</code></pre>
<p>With all those pieces in place, actually executing the kvm is pretty
painless.  Notice in particular the three serial ports we create: one for
the console (stderr), one for the output (stdout), and one for the exit
code:
</p><pre><b>default.runkvm.do</b><code lang="sh" src="default.runkvm.do">./need.sh python kvm busybox

redo-ifchange <span>"<span>$2</span>.initrd"</span> memcalc.py
rm -f <span>"<span>$1</span>.out"</span> <span>"<span>$1</span>.code"</span>



mem=$(./memcalc.py <span>"<span>$2</span>.initrd"</span>)
<span>echo</span> <span>"<span>$2</span>: kvm memory required: <span>$mem</span>"</span> &gt;&amp;2

kvm \
	-m <span>"<span>$mem</span>"</span> \
	-kernel /boot/vmlinuz-$(uname -r) \
	-initrd <span>"<span>$2</span>.initrd"</span> \
	-append <span>'rdinit=/rdinit panic=1 console=ttyS0 loglevel=4'</span> \
	-no-reboot \
	-display none \
	-chardev stdio,mux=on,id=char0 \
	-chardev file,id=char1,path=<span>"<span>$1</span>.out"</span> \
	-chardev file,id=char2,path=<span>"<span>$1</span>.code"</span> \
	-serial chardev:char0 \
	-serial chardev:char1 \
	-serial chardev:char2 &gt;&amp;2
<span><span>fix_cr</span></span>() {
	
	
	sed -e <span>'s/\r//g'</span>
}
rv=$(fix_cr &lt;<span>"<span>$1</span>.code"</span>)
[ -n <span>"<span>$rv</span>"</span> ] || <span>exit</span> 99
<span>if</span> [ <span>"<span>$rv</span>"</span> -eq 0 ]; <span>then</span>
	fix_cr &lt;<span>"<span>$1</span>.out"</span> &gt;<span>$3</span>
	<span>echo</span> <span>"ok."</span> &gt;&amp;2
<span>else</span>
	<span>echo</span> <span>"kvm program returned error: <span>$rv</span>"</span> &gt;&amp;2
<span>fi</span>
<span>exit</span> <span>"<span>$rv</span>"</span>
</code></pre>
<p>And it works!</p>
<pre><code><span>$</span><span> redo libs.runkvm</span>
redo  libs.runkvm
redo    libs.initrd
5163 blocks
1 block
libs: kvm memory required: 70M
[    0.306682] reboot: Power down
ok.
<span>
$</span><span> time redo libs.runkvm</span>
redo  libs.runkvm
libs: kvm memory required: 70M
[    0.295139] reboot: Power down
ok.

real    0m0.887s
user    0m0.748s
sys 0m0.112s
<span>
$</span><span> cat libs.runkvm</span>
Hello, world!
</code></pre>

<p>Virtual machines have come a long way since 1999: we managed to build an
initrd, boot kvm, run our program, and shut down in only 0.9 seconds.  It
could probably go even faster if we used a custom-built kernel with no
unnecessary drivers.</p>
<h3 id="a-real-docker-container">A real Docker container</h3>
<p>Okay, that was fun, but nobody in real life cares about all these fast,
small, efficient isolation systems that are possible for mortals to
understand, right?  We were promised a <strong>Container System</strong>, and a container
system has daemons, and authorization, and quotas, and random delays, and
some kind of Hub where I can download (and partially deduplicate) someone
else's multi-gigabyte Hello World images that are built in a highly
sophisticated enterprise-ready collaborative construction process.  Come on,
tell me, can redo do <strong>that</strong>?</p>
<p>Of course!  But we're going to get there the long way.</p>
<p>First, let's use the big heavy Container System with daemons and delays to
run our existing tiny understandable container.  After that, we'll show how
to build a huge incomprehensible container that does the same thing, so your
co-workers will think you're normal.</p>
<h4 id="docker-and-layers">Docker and layers</h4>
<p>Normal people build their Docker containers using a
<a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a>.  A
Dockerfile is sort of like a non-recursive redo, or maybe a Makefile, except
that it runs linearly, without the concept of dependencies or
parallelization.  In that sense, I guess it's more like an IBM mainframe job
control script from 1970.  It even has KEYWORDS in ALL CAPS, just like 1970.</p>
<p>Dockerfiles do provide one really cool innovation over IBM job control
scripts, which is that they cache intermediate results so you don't have to
regenerate it every time.  Basically, every step in a Dockerfile copies a
container, modifies it slightly, and saves the result for use in the next
step.  If you modify step 17 and re-run the Dockerfile, it can just start
with the container produced by step 16, rather than going all the way back
to step 1.  This works pretty well, although it's a bit expensive to start
and stop a container at each build step, and it's unclear when and how
interim containers are expunged from the cache later.  And some of your
build steps are "install the operating system" and "install the compiler",
so each step produces a larger and larger container.  A very common mistake
among Docker users is to leave a bunch of intermediate files (source code,
compilers, packages, etc) installed in the output container, bloating it up
far beyond what's actually needed to run the final application.</p>
<p>Spoiler: we're not going to do it that way.</p>
<p>Instead, let's use redo to try to get the same Dockerfile advantages
(multi-stage cache; cheap incremental rebuilds) without the disadvantages
(launching and unlaunching containers; mixing our build environment with our
final output).</p>
<p>To understand how we'll do this, we need to talk about
<a href="https://medium.com/@jessgreb01/digging-into-docker-layers-c22f948ed612">Layers</a>.
Unlike our kvm initrd from earlier, a Docker image is not just a single
tarball; it's a sequence of tarballs, each containing the set of files
changed at each step of the build process.  This layering system is how
Docker's caching and incremental update system works: if I incrementally
build an image starting from step 17, based on the pre-existing output from
step 16, then the final image can just re-use layers 1..16 and provide new
layers 17..n.  Usually, the first few layers (install the operating system,
install the compilers, etc) are the biggest ones, so this means a new
version of an image takes very little space to store or transfer to a system
that already has the old one.</p>
<p>The inside of a docker image looks like this:</p>
<pre><code><span> $</span><span> tar -tf test.image</span>
ae5419fd49e39e4dc0baab438925c1c6e4417c296a8b629fef5ea93aa6ea481c/
ae5419fd49e39e4dc0baab438925c1c6e4417c296a8b629fef5ea93aa6ea481c/VERSION
ae5419fd49e39e4dc0baab438925c1c6e4417c296a8b629fef5ea93aa6ea481c/json
ae5419fd49e39e4dc0baab438925c1c6e4417c296a8b629fef5ea93aa6ea481c/layer.tar
b65ae6e742f8946fdc3fbdccb326378162641f540e606d56e1e638c7988a5b95/
b65ae6e742f8946fdc3fbdccb326378162641f540e606d56e1e638c7988a5b95/VERSION
b65ae6e742f8946fdc3fbdccb326378162641f540e606d56e1e638c7988a5b95/json
b65ae6e742f8946fdc3fbdccb326378162641f540e606d56e1e638c7988a5b95/layer.tar
</code></pre>

<p>We could use redo to build a Docker image by simply making a single
<code>layer.tar</code> of the filesystem (like we did with initrd), adding a VERSION
and json file, and putting those three things into an outer tarball.  But if
we want a system that works as well as a Dockerfile, we'll have to make use
of multiple layers.</p>
<p>Our <code>simple</code> container is already pretty tiny by container standards - 2.6MB
- but it's still a bit wasteful.  Most of that space turns out to be from
the dynamic libraries we imported from the host OS.  These libraries don't
change when we change Hello World!  They belong in their own layer.</p>
<p>Up above, in preparation for this moment, we created <code>libs.fs.do</code> to build a
separate filesystem, rather than adding the libraries inside
<code>simple.fs.do</code>, which would have been easier.  Now we can make each of those
filesystems its own layer.</p>
<p>There's one more complication: we did things a bit backwards.  In a
Dockerfile, you install the libraries first, and then you install your
application.  When you replace your application, you replace only the
topmost layer.  We did it the other way around: we installed our
application and some debugging tools, then detected which libraries they
need and added a layer on top.  The most recent versions of Docker, 1.10 and
above, are more efficient about handling layers changing in the middle of
the stack, but not everyone is using newer Docker versions yet, so let's try
to make things efficient for older Docker versions too.</p>
<p>Luckily, since we're starting from first principles, in redo we can do
anything we want.  We have to generate a tarball for each layer anyway, so
we can decide what goes into each layer and then we can put those layers in
whatever sequence we want.</p>
<p>Let's start simple.  A layer is just a tarball made of a set of files
(again, ignore the <code>try_fakeroot</code> stuff for now):
</p><pre><b>default.layer.do</b><code lang="sh" src="default.layer.do">d=<span>$PWD</span>
redo-ifchange <span>"<span>$2</span>.fs"</span> <span>"<span>$2</span>.list"</span>

sed -e <span>'s/ [^ ]*$//'</span> &lt;<span>$2</span>.list |
(
	<span>cd</span> <span>"<span>$2</span>"</span>
	<span>"<span>$d</span>/try_fakeroot.sh"</span> <span>"<span>$d</span>/<span>$2</span>.fakeroot"</span> \
		cpio -Hustar -o
) &gt;<span>$3</span>
</code></pre>
<p>The magic, of course, is in deciding which files go into which layers.  In
the script above, that's provided in the .list file corresponding to each
layer.  The .list file is produced by <code>default.list.do</code>:
</p><pre><b>default.list.do</b><code lang="sh" src="default.list.do">d=<span>$PWD</span>
redo-ifchange <span>"<span>$2</span>.fs"</span>

<span>if</span> [ -e <span>"<span>$2</span>.diffbase"</span> ]; <span>then</span>
	redo-ifchange <span>"<span>$2</span>.diffbase"</span>
	<span>read</span> diffbase &lt;<span>$2</span>.diffbase
	diffbase=<span>$diffbase</span>.list
	redo-ifchange <span>"<span>$diffbase</span>"</span>
<span>else</span>
	diffbase=/dev/null
	redo-ifcreate <span>"<span>$2</span>.diffbase"</span>
<span>fi</span>

(
	<span>cd</span> <span>"<span>$2</span>"</span> &amp;&amp;
	find . -<span>print</span> | sort | <span>"<span>$d</span>/try_fakeroot.sh"</span> <span>"<span>$d</span>/<span>$2</span>.fakeroot"</span> <span>"<span>$d</span>/fileids.py"</span>
) &gt;<span>$1</span>.tmp

comm -1 -3 <span>"<span>$diffbase</span>"</span> <span>"<span>$1</span>.tmp"</span> &gt;<span>$3</span>
rm -f <span>"<span>$1</span>.tmp"</span>


nbytes=$(wc -c &lt;<span>"<span>$3</span>"</span>)
<span>test</span> <span>$nbytes</span> -gt 0
</code></pre>
<p>This requires a bit of explanation.  First of all, you probably haven't seen
the very old, but little-known <code>comm</code> program before.  It's often described
as "compare two sorted files" or "show common lines between two files."  But
it actually does more than just showing common lines: it can show the lines
that are only in file #1, or only in file #2, or in both files.  <code>comm -1
-3</code> <em>suppresses</em> the output of lines that are only in #1 or that are in
both, so that it will print the lines that are only in the second file.</p>
<p>If we want to make a <code>libs.layer</code> that contains only the files that are
<em>not</em> in <code>simple</code>, then we can use <code>comm -1 -3</code> to compare <code>simple</code> with
<code>libs</code>.</p>
<p>Now, this script is supposed to be able to construct the file list for any
layer.  To do that, it has to know what parent to compare each layer
against.  We call that the "diffbase", and for layers that are based on
other layers, we put the name of the parent layer in its diffbase file:
</p><pre><b>libs.diffbase</b><code lang="sh" src="libs.diffbase">simple
</code></pre>
<p>(If there's no diffbase, then we use /dev/null as the diffbase.  Because if
file #1 is empty, then <em>all</em> the lines are only in file #2, which is exactly
what we want.)</p>
<p>There's just one more wrinkle: if we just compare lists of files, then we'll
detect newly-added files, but we won't detect <em>modified</em> files.  To fix
this, we augment the file list with file checksums before the comparison
(using <code>fileids.py</code>), then strip the checksums back out in
<code>default.layer.do</code> before sending the resulting list to <code>cpio</code>.</p>
<p>The augmented file list looks like this:</p>
<pre><code><span>$</span><span> cat simple.list</span>
. 0040755-0-0-0
./bin 0040755-0-0-0
./bin/busybox 0100755-0-0-ba34fb34865ba36fb9655e724266364f36155c93326b6b73f4e3d516f51f6fb2
./bin/hello 0100755-0-0-22e4d2865e654f830f6bfc146e170846dde15185be675db4e9cd987cb02afa78
./bin/sh 0100755-0-0-e803088e7938b328b0511957dcd0dd7b5600ec1940010c64dbd3814e3d75495f
./init 0120777-0-0-14bdc0fb069623c05620fc62589fe1f52ee6fb67a34deb447bf6f1f7e881f32a
</code></pre>

<p>(Side note: the augmentation needs to be added at the end of the line, not
the beginning so that the file list is still sorted afterwards.  <code>comm</code> only
works correctly if both input files are sorted.)</p>
<p>The script for augmenting the file list is fairly simple.  It just reads a
list of filenames on stdin, checksums those files, and writes the augmented
list on stdout:
</p><pre><b>fileids.py</b><code lang="sh" src="fileids.py">
import hashlib, os, <span>stat</span>, sys

<span>for</span> name <span>in</span> sys.stdin:
    name = name[:-1]  
    st = os.lstat(name)
    <span>if</span> stat.S_ISREG(st.st_mode):
        h = hashlib.sha256()
        f = open(name, <span>'rb'</span>)
        <span>while</span> 1:
            b = f.read(65536)
            <span>if</span> not b: <span>break</span>
            h.update(b)
        digest = h.hexdigest()
    <span>elif</span> stat.S_ISLNK(st.st_mode):
        digest = hashlib.sha256(os.readlink(name).encode(<span>'utf8'</span>)).hexdigest()
    <span>else</span>:
        digest = <span>'0'</span>
    <span>print</span>(<span>'%s %07o-%s-%s-%s'</span> % (
        name,
        st.st_mode, st.st_uid, st.st_gid, digest))
</code></pre>
<p>Just one more thing!  Docker (before 1.10) deduplicates images by detecting
that they contain identical layers.  When using a Dockerfile, the layers are
named automatically using random 256-bit numbers (UUIDs).  Since Dockerfiles
usually don't regenerate earlier layers, the UUIDs of those earlier layers
won't change, so future images will contain layers with known UUIDs, so
Docker doesn't need to deduplicate them.</p>
<p>We don't want to rely on never rebuilding layers.  Instead, we'll adopt a
technique from newer Docker versions (post 1.10): we'll name layers after a
checksum of their contents.  Now, we don't want to actually checksum the
<code>whatever.layer</code> file, because it turns out that tarballs contain a bunch of
irrelevant details, like inode numbers and
<a href="https://apenwarr.ca/log/20181113">mtimes</a>, so they'll have a different
checksum every time they're built.  Instead, we'll make a digest of the
<code>whatever.list</code> file, which conveniently already has a checksum of each
file's contents, plus the interesting subset of the file's attributes.</p>
<p>Docker expects 256-bit layer names, so we might normally generate a sha256
digest using the <code>sha256sum</code> program, but that's not available on all
platforms.  Let's write a python script to do the job instead.  To make it
interesting, let's write it as a .do file, so we can generate the sha256 of
<code>anything</code> by asking for <code>redo-ifchange anything.sha256</code>.  This is a good
example of how in redo, .do files can be written in any scripting language,
not just sh.
</p><pre><b>default.sha256.do</b><code lang="sh" src="default.sha256.do">
<span>""</span><span>"Calculate the sha256 digest of a given file."</span><span>""</span>
import hashlib, os, subprocess, sys

subprocess.check_call([
    <span>'redo-ifchange'</span>,
    sys.argv[2],
], close_fds=False)

h = hashlib.sha256()
f = open(sys.argv[2], <span>'rb'</span>)
<span>while</span> 1:
    b = f.read(65536)
    <span>if</span> not b: <span>break</span>
    h.update(b)
open(sys.argv[3], <span>'w'</span>).write(h.hexdigest() + <span>'\n'</span>)
</code></pre>
<p>Let's test it out:</p>
<pre><code><span>$</span><span> redo simple.list.sha256</span>
redo  simple.list.sha256
redo    simple.list
<span>
$</span><span> cat simple.list.sha256</span>
4d1fda9f598191a4bc281e5f6ac9c27493dbc8dd318e93a28b8a392a7105c145
<span>
$</span><span> rm -rf simple</span>
<span>
$</span><span> redo simple.list.sha256</span>
redo  simple.list.sha256
redo    simple.list
redo      simple.fs
<span>
$</span><span> cat simple.list.sha256</span>
4d1fda9f598191a4bc281e5f6ac9c27493dbc8dd318e93a28b8a392a7105c145
</code></pre>

<p>Consistent layer id across rebuilds!  Perfect.</p>
<h4 id="combining-layers-building-a-docker-image">Combining layers: building a Docker image</h4>
<p>We're almost there.  Now that we can produce a tarball for each layer, we
have to produce the final tarball that contains all the layers in the right
order.  For backward compatibility with older Docker versions, we also need
to produce a json "manifest" for each layer.  In those old versions, each
layer was also its own container, so it needed to have all the same
attributes as a container, including a default program to run, list of open
ports, and so on.  We're never going to use those values except for the
topmost layer, but they have to be there, so let's just auto-generate them.
Here's the script for customizing each layer's json file from a template:
</p><pre><b>dockjson.py</b><code lang="sh" src="dockjson.py">
<span>""</span><span>"Generate a docker 1.0-style manifest for a docker image."</span><span>""</span>
import json, os, sys, time

j = json.load(open(<span>'template.json'</span>))
layerid = open(sys.argv[1] + <span>'.list.sha256'</span>).<span>read</span>().strip()
j[<span>'id'</span>] = layerid

<span>if</span> len(sys.argv) &gt; 2 and sys.argv[2]:
    parentid = open(sys.argv[2] + <span>'.list.sha256'</span>).<span>read</span>().strip()
    j[<span>'parent'</span>] = parentid

t = time.time()
gt = time.gmtime(t)
nsec = int(t * 1e9) % 1000000000
j[<span>'created'</span>] = time.strftime(<span>'%Y-%m-%dT%H:%M:%S'</span>, gt) + (<span>'.%09dZ'</span> % nsec)

nbytes = os.stat(sys.argv[1] + <span>'.layer'</span>).st_size
j[<span>'Size'</span>] = nbytes

json.dump(j, sys.stdout, indent=2)
</code></pre>
<p>And here's the empty template:
</p><pre><b>template.json</b><code lang="sh" src="template.json">{
    <span>"architecture"</span>: <span>"amd64"</span>,
    <span>"comment"</span>: <span>"Imported from -"</span>,
    <span>"config"</span>: {
        <span>"AttachStderr"</span>: <span>false</span>,
        <span>"AttachStdin"</span>: <span>false</span>,
        <span>"AttachStdout"</span>: <span>false</span>,
        <span>"Cmd"</span>: [
            <span>"/init"</span>
        ],
        <span>"CpuShares"</span>: 0,
        <span>"Cpuset"</span>: <span>""</span>,
        <span>"Domainname"</span>: <span>""</span>,
        <span>"Entrypoint"</span>: null,
        <span>"Env"</span>: null,
        <span>"ExposedPorts"</span>: null,
        <span>"Hostname"</span>: <span>""</span>,
        <span>"Image"</span>: <span>""</span>,
        <span>"Labels"</span>: null,
        <span>"MacAddress"</span>: <span>""</span>,
        <span>"Memory"</span>: 0,
        <span>"MemorySwap"</span>: 0,
        <span>"NetworkDisabled"</span>: <span>false</span>,
        <span>"OnBuild"</span>: null,
        <span>"OpenStdin"</span>: <span>false</span>,
        <span>"PortSpecs"</span>: null,
        <span>"StdinOnce"</span>: <span>false</span>,
        <span>"Tty"</span>: <span>false</span>,
        <span>"User"</span>: <span>""</span>,
        <span>"Volumes"</span>: null,
        <span>"WorkingDir"</span>: <span>""</span>
    },
    <span>"container_config"</span>: {
        <span>"AttachStderr"</span>: <span>false</span>,
        <span>"AttachStdin"</span>: <span>false</span>,
        <span>"AttachStdout"</span>: <span>false</span>,
        <span>"Cmd"</span>: null,
        <span>"CpuShares"</span>: 0,
        <span>"Cpuset"</span>: <span>""</span>,
        <span>"Domainname"</span>: <span>""</span>,
        <span>"Entrypoint"</span>: null,
        <span>"Env"</span>: null,
        <span>"ExposedPorts"</span>: null,
        <span>"Hostname"</span>: <span>""</span>,
        <span>"Image"</span>: <span>""</span>,
        <span>"Labels"</span>: null,
        <span>"MacAddress"</span>: <span>""</span>,
        <span>"Memory"</span>: 0,
        <span>"MemorySwap"</span>: 0,
        <span>"NetworkDisabled"</span>: <span>false</span>,
        <span>"OnBuild"</span>: null,
        <span>"OpenStdin"</span>: <span>false</span>,
        <span>"PortSpecs"</span>: null,
        <span>"StdinOnce"</span>: <span>false</span>,
        <span>"Tty"</span>: <span>false</span>,
        <span>"User"</span>: <span>""</span>,
        <span>"Volumes"</span>: null,
        <span>"WorkingDir"</span>: <span>""</span>
    },
    <span>"docker_version"</span>: <span>"1.6.2"</span>,
    <span>"os"</span>: <span>"linux"</span>
}
</code></pre>
<p>Now we just need to generate all the layers in a subdirectory, and tar them
together:
</p><pre><b>default.image.do</b><code lang="sh" src="default.image.do">redo-ifchange template.json <span>"<span>$1</span>.layers"</span>
layers=$(cat <span>"<span>$1</span>.layers"</span>)

dir=<span>$3</span>.tmp
rm -rf <span>"<span>$dir</span>"</span>
mkdir -p <span>"<span>$dir</span>"</span>


<span>for</span> layer <span>in</span> <span>$layers</span>; <span>do</span>
	<span>echo</span> <span>"<span>$layer</span>.list.sha256"</span>
	<span>echo</span> <span>"<span>$layer</span>.layer"</span>
<span>done</span> | xargs redo-ifchange

ids=
parent=
<span>for</span> layer <span>in</span> <span>$layers</span>; <span>do</span>
	<span>read</span> cid &lt;<span>$layer</span>.list.sha256
	<span>echo</span> <span>"layer: <span>$cid</span> <span>$layer</span>"</span> &gt;&amp;2
	
	
	
	
	
	ids=<span>"<span>$cid</span> <span>$ids</span>"</span>  

	mkdir <span>"<span>$dir</span>/<span>$cid</span>"</span>
	<span>echo</span> <span>"1.0"</span> &gt;<span>$dir</span>/<span>$cid</span>/VERSION
	./dockjson.py <span>"<span>$layer</span>"</span> <span>"<span>$parent</span>"</span> &gt;<span>$dir</span>/<span>$cid</span>/json
	ln <span>"<span>$layer</span>.layer"</span> <span>"<span>$dir</span>/<span>$cid</span>/layer.tar"</span>
	parent=<span>$layer</span>
<span>done</span> &lt;<span>$1</span>.layers
last_cid=<span>$cid</span>



cat &gt;<span>"<span>$dir</span>/repositories"</span> &lt;&lt;-EOF
	{
	    <span>"<span>$2</span>"</span>:{
	        <span>"latest"</span>:<span>"<span>$last_cid</span>"</span>
	    }
	}
EOF

tar -C <span>"<span>$dir</span>"</span> -cf - <span>$ids</span> repositories &gt;<span>$3</span>
rm -rf <span>"<span>$dir</span>"</span>
</code></pre>
<p>This requires a list of layers for each image we might want to create.
Here's the list of two layers for our <code>simple</code> container:
</p><pre><b>simple.image.layers</b><code lang="sh" src="simple.image.layers">libs
simple
</code></pre>
<p>Finally, some people like to compress their Docker images for transport or
uploading to a repository.  Here's a nice .do script that can produce the
.gz compressed version of any file:
</p><pre><b>default.gz.do</b><code lang="sh" src="default.gz.do">redo-ifchange <span>"<span>$2</span>"</span>



gzt=$(gzip --rsyncable -c &lt;/dev/null 2&gt;/dev/null | wc -c)
<span>if</span> [ <span>"<span>$gzt</span>"</span> -gt 0 ]; <span>then</span>
	
	
	
	gzip --rsyncable -c &lt;<span>$2</span> &gt;<span>$3</span>
<span>else</span>
	gzip -c &lt;<span>$2</span> &gt;<span>$3</span>
<span>fi</span>
</code></pre>
<p>Notice the use of <code>--rsyncable</code>.  Very few people seem to know about this
gzip option, but it's immensely handy.  Normally, if a few bytes change
early in a file, it completely changes gzip's output for all future bytes,
which means that incremental copying of new versions of a file (eg. using
<code>rsync</code>) is very inefficient.  With <code>--rsyncable</code>, gzip does a bit of extra
work to make sure that small changes in one part of a file don't affect the
gzipped bytes later in the file, so an updated container will be able to
transfer a minimal number of bytes, even if you compress it.</p>
<p>Let's try it out!</p>
<pre><code><span>$</span><span> redo simple.image.gz</span>
redo  simple.image.gz
redo    simple.image
redo      libs.list.sha256
redo        libs.list
redo          simple.list
redo      libs.layer
3607 blocks
redo      simple.list.sha256
redo      simple.layer
1569 blocks
layer: b65ae6e742f8946fdc3fbdccb326378162641f540e606d56e1e638c7988a5b95 libs
layer: 4d1fda9f598191a4bc281e5f6ac9c27493dbc8dd318e93a28b8a392a7105c145 simple

flow:~/src/redo/docs/cookbook/container $ tar -tf simple.image.gz
4d1fda9f598191a4bc281e5f6ac9c27493dbc8dd318e93a28b8a392a7105c145/
4d1fda9f598191a4bc281e5f6ac9c27493dbc8dd318e93a28b8a392a7105c145/VERSION
4d1fda9f598191a4bc281e5f6ac9c27493dbc8dd318e93a28b8a392a7105c145/json
4d1fda9f598191a4bc281e5f6ac9c27493dbc8dd318e93a28b8a392a7105c145/layer.tar
b65ae6e742f8946fdc3fbdccb326378162641f540e606d56e1e638c7988a5b95/
b65ae6e742f8946fdc3fbdccb326378162641f540e606d56e1e638c7988a5b95/VERSION
b65ae6e742f8946fdc3fbdccb326378162641f540e606d56e1e638c7988a5b95/json
b65ae6e742f8946fdc3fbdccb326378162641f540e606d56e1e638c7988a5b95/layer.tar
</code></pre>

<p>In the above, notice how we build libs.layer first and simple.layer second,
because that's the order of the layers in <code>simple.image.layers</code>.  But to
produce <code>libs.list</code> we need to compare the file list against <code>simple.list</code>,
so it declares a dependency on <code>simple.list</code>.</p>
<p>The final <code>simple.image</code> tarball then includes the layers in <em>reverse</em> order
(topmost to bottommost), because that's how Docker does it.  The id of the
resulting docker image is the id of the topmost layer, in this case
4d1fda9f.</p>
<h4 id="loading-and-running-a-docker-image">Loading and running a Docker image</h4>
<p>Phew!  Okay, we finally have a completed Docker image in the format Docker
expects, and we didn't have to execute even one Dockerfile.  Incidentally,
that means all of the above steps could run without having Docker installed,
and without having any permissions to talk to the local Docker daemon.
That's a pretty big improvement (in security and manageability) over running
a Dockerfile.</p>
<p>The next step is to load the image into Docker, which is easy:
</p><pre><b>default.load.do</b><code lang="sh" src="default.load.do">redo-ifchange <span>"<span>$2</span>.image"</span>
./need.sh docker
docker load &lt;<span>$2</span>.image
</code></pre>
<p>And finally, we can ask Docker to run our image, and capture its output like
we did, so long ago, in <code>default.runlocal.do</code> and <code>default.runkvm.do</code>:
</p><pre><b>default.rundocker.do</b><code lang="sh" src="default.rundocker.do">redo-ifchange <span>"<span>$2</span>.load"</span> <span>"<span>$2</span>.list.sha256"</span>
./need.sh docker
<span>read</span> container_id &lt;<span>$2</span>.list.sha256
docker run <span>"<span>$container_id</span>"</span>
</code></pre>
<p>The result is almost disappointing in its apparent simplicity:</p>
<pre><code><span>$</span><span> time redo simple.rundocker</span>
redo  simple.rundocker
redo    simple.load

real    0m2.688s
user    0m0.068s
sys 0m0.036s
<span>
$</span><span> cat simple.rundocker</span>
Hello, world!
</code></pre>

<p>Notice that, for some reason, Docker takes 2.7s to load, launch and run our
tiny container.  That's about 3x as long as it takes to boot and run a kvm
virtual machine up above with exactly the same files.  This is kind of
weird, since containers are supposed to be much more lightweight than
virtual machines.  I'm sure there's a very interesting explanation for this
phenomenon somewhere.  For now, notice that you might save a lot of time by
initially testing your containers using <code>default.runlocal</code> (0.11 seconds)
instead of Docker (2.7 seconds), even if you intend to eventally deploy them
in Docker.</p>
<h3 id="a-debian-based-container">A Debian-based container</h3>
<p>We're not done yet!  We've built and run a Docker container the hard way,
but we haven't built and run an <strong>unnecessarily wastefully huge</strong> Docker
container the hard way.  Let's do that next, by installing Debian in a
chroot, then packaging it up into a container.</p>
<p>As we do that, we'll recycle almost all the redo infrastructure we built
earlier while creating our <code>simple</code> container.</p>
<h4 id="interlude-fakeroot">Interlude: Fakeroot</h4>
<p>It's finally time to talk about that mysterious <code>try_fakeroot.sh</code> script
that showed up a few times earlier.  It looks like this:
</p><pre><b>try_fakeroot.sh</b><code lang="sh" src="try_fakeroot.sh"><span>#!/bin/sh</span>
frfile=<span>$1</span>
<span>shift</span>
broken=
fakeroot <span>true</span> 2&gt;/dev/null || broken=1
<span>if</span> [ -z <span>"<span>$broken</span>"</span> ] &amp;&amp; [ -e <span>"<span>$frfile</span>"</span> ]; <span>then</span>
	redo-ifchange <span>"<span>$frfile</span>"</span>
	<span>exec</span> fakeroot -i <span>"<span>$frfile</span>"</span> <span>"<span>$@</span>"</span>
<span>elif</span> [ -z <span>"<span>$broken</span>"</span> ]; <span>then</span>
	<span>exec</span> fakeroot <span>"<span>$@</span>"</span>
<span>else</span>
	<span>exec</span> <span>"<span>$@</span>"</span>
<span>fi</span>
</code></pre>
<p><a href="https://wiki.debian.org/FakeRoot">fakeroot</a> is a tool, originally developed
for the Debian project, that convinces your programs that they are running
as root, without actually running them as root.  This is mainly so that they
can pretend to chown() files, without actually introducing security holes on
the host operating system.  Debian uses this when building packages: they
compile the source, start fakeroot, install to a fakeroot directory,
make a tarball of that directory, then exit fakeroot.  The tarball then
contains the permissions they want.</p>
<p>Normally, fakeroot forgets all its simulated file ownership and permissions
whenever it exits.  However, it has <code>-s</code> (save) and <code>-i</code> (input) options for
saving the permissions to a file and reloading the permissions from that
file, respectively.</p>
<p>As we build our container layers, we need redo to continually enter
fakeroot, do some stuff, and exit it again.  The <code>try_fakeroot.sh</code> script is
a helper to make that easier.</p>
<h4 id="debootstrap">Debootstrap</h4>
<p>The next Debian tool we should look at is
<a href="https://wiki.debian.org/Debootstrap">debootstrap</a>.  This handy program
downloads and extracts the (supposedly) minimal packages necessary to build
an operational Debian system in a chroot-ready subdirectory.  Nice!</p>
<p>In order for debootstrap to work without being an administrator - and you
should not run your build system as root - we'll use fakeroot to let it
install all those packages.</p>
<p>Unfortunately, debootstrap is rather slow, for two reasons:</p>
<ol>
<li>It has to download a bunch of things.</li>
<li>It has to install all those things.</li>
</ol>
<p>And after debootstrap has run, all we have is a Debian system, which by
itself isn't a very interesting container.  (You usually want your container
to have an app so it does something specific.)</p>
<p>Does this sound familiar?  It sounds like a perfect candidate for Docker
layers.  Let's make three layers:</p>
<ol>
<li>Download the packages.</li>
<li>Install the packages.</li>
<li>Install an app.</li>
</ol>
<p>Here's step one:
</p><pre><b>debdownload.fs.do</b><code lang="sh" src="debdownload.fs.do">fs=<span>${1%.fs}</span>




mkdir -p <span>"<span>$fs</span>"</span>
redo-ifchange debootstrap.options
debootstrap \
	--download-only \
	--keep-debootstrap-dir \
	$(cat debootstrap.options) \
	<span>"<span>$fs</span>"</span> &gt;&amp;2
redo-ifchange <span>"<span>$fs</span>/debootstrap/debootstrap.log"</span>
</code></pre>
<p>On top of that layer, we run the install process:
</p><pre><b>debootstrap.fs.do</b><code lang="sh" src="debootstrap.fs.do">fs=<span>${1%.fs}</span>
rm -rf <span>"<span>$fs</span>"</span> <span>"<span>$fs</span>.fakeroot"</span>

redo-ifchange debdownload.fs debootstrap.options
cp -a debdownload/. <span>"<span>$fs</span>"</span>
eatmydata \
	fakechroot \
	fakeroot -s <span>"<span>$fs</span>.fakeroot"</span> \
	debootstrap $(cat debootstrap.options) <span>"<span>$fs</span>"</span> &gt;&amp;2


rm -f <span>"<span>$fs</span>"</span>/var/cache/apt/archives/*.deb \
	<span>"<span>$fs</span>"</span>/var/cache/apt/*.bin \
	<span>"<span>$fs</span>"</span>/var/lib/apt/lists/*Packages \
	<span>"<span>$fs</span>"</span>/var/lib/apt/lists/*Sources \
	<span>"<span>$fs</span>"</span>/var/lib/apt/lists/debootstrap*

redo-ifchange <span>"<span>$fs</span>/bin/sh"</span>
</code></pre>
<p>Since both steps run debootstrap and we might want to customize the set of
packages to download+install, we'll put the debootstrap options in their own
shared file:
</p><pre><b>debootstrap.options</b><code lang="sh" src="debootstrap.options">--variant=minbase
--include=busybox
stretch
</code></pre>
<p>And finally, we'll produce our "application" layer, which in this case is
just a shell script that counts then number of installed Debian packages:
</p><pre><b>debian.fs.do</b><code lang="sh" src="debian.fs.do">fs=<span>${1%.fs}</span>
rm -rf <span>"<span>$fs</span>"</span> <span>"<span>$fs</span>.fakeroot"</span>

redo-ifchange debootstrap.fs
fakeroot -i debootstrap.fakeroot -s <span>"<span>$fs</span>.fakeroot"</span> \
	cp -a debootstrap/. <span>"<span>$fs</span>"</span> &gt;&amp;2





pwdir=$(dirname <span>"<span>$PWD</span>/bootstrap/"</span>)
mkdir -p <span>"<span>$fs</span>/<span>$pwdir</span>/debootstrap"</span>
dots=$(<span>echo</span> <span>"<span>$pwdir</span>/"</span> | sed -e <span>'s,[^/]*/,../,g'</span>)
ln -s <span>"<span>${dots}</span>lib"</span> <span>"<span>$fs</span>/<span>$pwdir</span>/debootstrap/lib"</span>


cat &gt;<span>"<span>$fs</span>/init"</span> &lt;&lt;-EOF
	
	dpkg -l | wc -l
EOF
chmod a+x <span>"<span>$fs</span>/init"</span>

redo-ifchange <span>"<span>$fs</span>/bin/sh"</span>
</code></pre>
<h4 id="building-the-debian-container">Building the Debian container</h4>
<p>Now that we have the three filesystems, let's actually generate the Docker
layers.  But with a catch: we won't actually include the layer for step 1,
since all those package files will never be needed again.  (Similarly, if we
were installing a compiler - and perhaps redo! - in the container so we
could build our application in a controlled environment, we might want to
omit the "install compiler" layers from the final product.)</p>
<p>So we list just two layers:
</p><pre><b>debian.image.layers</b><code lang="sh" src="debian.image.layers">debootstrap
debian
</code></pre>
<p>And the 'debian' layer's diffbase is <code>debootstrap</code>, so we don't include the
same files twice:
</p><pre><b>debian.diffbase</b><code lang="sh" src="debian.diffbase">debootstrap
</code></pre>
<h4 id="running-the-debian-container">Running the Debian container</h4>
<p>This part is easy.  All the parts are already in place.  We'll just run
the existing <code>default.rundocker.do</code>:</p>
<pre><code><span>$</span><span> time redo debian.rundocker</span>
redo  debian.rundocker
redo    debian.load
redo      debian.image
redo        debian.list.sha256
redo          debian.list
redo        debian.layer
12 blocks
layer: a542b5976e1329b7664d79041d982ec3d9f7949daddd73357fde17465891d51d debootstrap
layer: d5ded4835f8636fcf01f6ccad32125aaa1fe9e1827f48f64215b14066a50b9a7 debian

real    0m7.313s
user    0m0.632s
sys 0m0.300s
<span>
$</span><span> cat debian.rundocker</span>
82
</code></pre>

<p>It works!  Apparently there are 82 Debian packages installed.  It took 7.3
seconds to load and run the docker image though, probably because it had to
transfer the full contents of those 82 packages over a socket to the docker
server, probably for security reasons, rather than just reading the files
straight from disk.  Luckily, our chroot and kvm scripts also still work:</p>
<pre><code><span>$</span><span> time redo debian.runlocal</span>
redo  debian.runlocal

real    0m0.084s
user    0m0.052s
sys 0m0.004s
<span>
$</span><span> cat debian.runlocal</span>
82
<span>
$</span><span> time redo debian.runkvm</span>
redo  debian.runkvm
redo    debian.initrd
193690 blocks
1 block
debian: kvm memory required: 346M
[    0.375365] reboot: Power down
ok.

real    0m3.445s
user    0m1.008s
sys 0m0.644s
<span>
$</span><span> cat debian.runkvm</span>
82
</code></pre>

<h4 id="testing-and-housekeeping">Testing and housekeeping</h4>
<p>Let's finish up by providing the usual boilerplate.  First, an <code>all.do</code> that
builds, runs, and tests all the images on all the container platforms. 
This isn't a production build system, it's a subdirectory of the redo
package, so we'll skip softly, with a warning, if any of the components are
missing or nonfunctional.  If you were doing this in a "real" system, you
could just let it abort when something is missing.
</p><pre><b>all.do</b><code lang="sh" src="all.do"><span>exec</span> &gt;&amp;2   
no_simple=
no_debian=
no_runlocal=
no_runkvm=
no_docker=

<span>if</span> ! ./need.sh ldd; <span>then</span>
	<span>echo</span> <span>"skipping simple image."</span>
	no_simple=1
<span>fi</span>
<span>if</span> ! ./need.sh debootstrap eatmydata; <span>then</span>
	<span>echo</span> <span>"skipping debian image."</span>
	no_debian=1
<span>fi</span>
<span>if</span> ! ./need.sh cpio; <span>then</span>
	<span>echo</span> <span>"skipping tarball generation."</span>
	no_image=1
<span>fi</span>
<span>if</span> ! ./need.sh fakeroot fakechroot ||
   ! ./try_fakeroot.sh <span>"x"</span> <span>true</span> 2&gt;/dev/null; <span>then</span>
	<span>echo</span> <span>"skipping chroot test."</span>
	no_runlocal=1
	<span>echo</span> <span>"skipping debian image."</span>
	no_debian=1
<span>fi</span>
<span>if</span> ! ./need.sh unshare ||
   ! unshare -r <span>true</span> 2&gt;/dev/null; <span>then</span>
	<span>echo</span> <span>" -- 'unshare -r' command doesn't work."</span>
	<span>echo</span> <span>"skipping chroot test."</span>
	no_runlocal=1
<span>fi</span>
<span>if</span> ! ./need.sh busybox kvm cpio; <span>then</span>
	<span>echo</span> <span>"skipping kvm test."</span>
	no_runkvm=1
<span>fi</span>
kernel=<span>"/boot/vmlinuz-<span>$(uname -r)</span>"</span>
<span>if</span> ! [ -e <span>"<span>$kernel</span>"</span> ]; <span>then</span>
	<span>echo</span> <span>" -- missing kernel: <span>$kernel</span>"</span>
	<span>echo</span> <span>"skipping kvm test."</span>
	no_runkvm=1
<span>fi</span>
<span>if</span> ! ./need.sh docker cpio ||
   ! docker images &gt;/dev/null; <span>then</span>
	<span>echo</span> <span>"skipping docker test."</span>
	no_docker=1
<span>fi</span>
<span>if</span> [ -n <span>"<span>$NO_SLOW_TESTS</span>"</span> ]; <span>then</span>
	<span>echo</span> <span>" -- NO_SLOW_TESTS is set."</span>
	<span>echo</span> <span>"skipping debian image."</span>
	no_debian=1
	
	
	
	
	<span>echo</span> <span>"skipping docker test."</span>
	no_docker=1
<span>fi</span>

<span><span>add</span></span>() { targets=<span>"<span>$targets</span> $*"</span>; }

[ -z <span>"<span>$no_simple</span><span>$no_image</span>"</span> ] &amp;&amp; add simple.image.gz
[ -z <span>"<span>$no_simple</span><span>$no_runlocal</span>"</span> ] &amp;&amp; add libs.runlocal
[ -z <span>"<span>$no_simple</span><span>$no_runkvm</span>"</span> ] &amp;&amp; add libs.runkvm
[ -z <span>"<span>$no_simple</span><span>$no_docker</span>"</span> ] &amp;&amp; add simple.rundocker

[ -z <span>"<span>$no_debian</span><span>$no_image</span>"</span> ] &amp;&amp; add debian.image
[ -z <span>"<span>$no_debian</span><span>$no_runlocal</span>"</span> ] &amp;&amp; add debian.runlocal
[ -z <span>"<span>$no_debian</span><span>$no_runkvm</span>"</span> ] &amp;&amp; add debian.runkvm
[ -z <span>"<span>$no_debian</span><span>$no_docker</span>"</span> ] &amp;&amp; add debian.rundocker

redo-ifchange <span>$targets</span>

<span><span>check</span></span>() {
	label=<span>$1</span>
	<span>shift</span>
	<span>printf</span> <span>"checking %-18s %-35s "</span> <span>"<span>$label</span>:"</span> <span>"$*"</span> &gt;&amp;2
	<span>if</span> <span>test</span> <span>"<span>$@</span>"</span>; <span>then</span>
		<span>printf</span> <span>"ok\n"</span> &gt;&amp;2
	<span>else</span>
		<span>printf</span> <span>"failed\n"</span> &gt;&amp;2
	<span>fi</span>
}

<span><span>hellocheck</span></span>() {
	check <span>"<span>$1</span>"</span> <span>"<span>$(cat "$1")</span>"</span> = <span>"Hello, world!"</span>
}

<span><span>debcheck</span></span>() {
	check <span>"<span>$1</span>"</span> <span>"<span>$(cat "$1")</span>"</span> -ge <span>"70"</span>
	check <span>"<span>$1</span>"</span> <span>"<span>$(cat "$1")</span>"</span> -le <span>"100"</span>
}

<span>if</span> [ -z <span>"<span>$no_simple</span>"</span> ]; <span>then</span>
	[ -n <span>"<span>$no_runlocal</span>"</span> ] || hellocheck libs.runlocal
	[ -n <span>"<span>$no_runkvm</span>"</span> ] || hellocheck libs.runkvm
	[ -n <span>"<span>$no_docker</span>"</span> ] || hellocheck simple.rundocker
<span>fi</span>

<span>if</span> [ -z <span>"<span>$no_debian</span>"</span> ]; <span>then</span>
	[ -n <span>"<span>$no_runlocal</span>"</span> ] || debcheck debian.runlocal
	[ -n <span>"<span>$no_runkvm</span>"</span> ] || debcheck debian.runkvm
	[ -n <span>"<span>$no_docker</span>"</span> ] || debcheck debian.rundocker
<span>fi</span>
</code></pre>
<p>And here's a <code>redo clean</code> script that gets rid of (most of) the files
produced by the build.  We say "most of" the files, because actually we
intentionally don't delete the debdownload and debootstrap directories. 
Those take a really long time to build, and redo knows to rebuild them if
their dependencies (or .do files) change anyway.  So instead of throwing
away their content on 'redo clean', we'll keep it around.
</p><pre><b>clean.do</b><code lang="sh" src="clean.do">rm -rf *~ .*~ simple libs debian \
	*.fs debian.fakeroot *.gz \
	*.code *.dockjson *.image *.image.gz *.initrd \
	*.out *.layer *.list \
	*.runkvm *.runlocal *.rundocker \
	*.sha256
</code></pre>
<p>Still, we want a script that properly cleans up everything, so let's have
<code>redo xclean</code> (short for "extra clean") wipe out the last remaining
files:
</p><pre><b>xclean.do</b><code lang="sh" src="xclean.do">redo clean
rm -rf debootstrap debdownload *.fakeroot

</code></pre>
              
            </div>
          </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>