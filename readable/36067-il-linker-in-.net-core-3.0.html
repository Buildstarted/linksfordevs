<!DOCTYPE html>
<html lang="en">
<head>
    <title>
IL-Linker in .NET Core 3.0 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div class="post"> <p class="intro"> <span class="dropcap">T</span>rim your .NET Core 3.0 app with the IL-Linker.
</p> <h3 id="net-conf-2019-countdown-series">.NET Conf 2019 Countdown series</h3> <p>I&#x2019;m excited to be part of the .NET Conf with this <em>every day</em> mini-post series until the 23th September.</p> <ul> <li>IL-Linker in .NET Core 3.0</li> <li>2019-09-17</li> <li>2019-09-18</li> <li>2019-09-19</li> <li>2019-09-20</li> <li>2019-09-23</li>
</ul> <p>It&#x2019;s definitely worth attending a <a href="https://www.dotnetconf.net/local-events">.NET Conf 2019 local event</a> to get together with other .NET friends.
Join me on the 30th september at <a href="https://www.meetup.com/de-DE/Basel-NET-User-Group/events/264124718/">Community .NET Conf 2019 Event</a>.</p> <h2 id="prerequisites--setup">Prerequisites &amp; Setup</h2> <p>You will need <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019</a> and <a href="https://dotnet.microsoft.com/download/dotnet-core/3.0">.NET Core 3.0 SDK</a> to try out this feature.</p> <p>The .NET Core 3.0 SDK ships with an additional linker (originally from mono) that can be opt-in.
The IL-Linker scans statically the IL instructions of your application to detect which code is actually required, and trims unused framework libraries. This can reduce the deployment size of your application, depending on the subset of framework assemblies you use.
It is primarily a deployment feature rather than useful for development scenarios.</p> <p>To test this, you could use the console application template:</p> <figure class="highlight"><pre><code class="language-cmd">    dotnet new console</code></pre></figure> <p>Then, enable this <em>trimming</em> behavior with the following changes in the <em>csproj</em> file:</p> <figure class="highlight"><pre><code class="language-xml"><span class="nt">&lt;Project</span> <span class="na">Sdk=</span><span class="s">&quot;Microsoft.NET.Sdk&quot;</span><span class="nt">&gt;</span> <span class="nt">&lt;PropertyGroup&gt;</span> <span class="nt">&lt;OutputType&gt;</span>Exe<span class="nt">&lt;/OutputType&gt;</span> <span class="nt">&lt;TargetFramework&gt;</span>netcoreapp3.0<span class="nt">&lt;/TargetFramework&gt;</span> <span class="nt">&lt;RuntimeIdentifier&gt;</span>win10-x64<span class="nt">&lt;/RuntimeIdentifier&gt;</span> <span class="nt">&lt;PublishTrimmed&gt;</span>true<span class="nt">&lt;/PublishTrimmed&gt;</span> <span class="nt">&lt;/PropertyGroup&gt;</span>
<span class="nt">&lt;/Project&gt;</span></code></pre></figure> <p>You will need the <code class="highlighter-rouge">&lt;RuntimeIdentifier&gt;</code> element or specify the specific RID while publishing because this is only supported for self-contained applications (SCD):</p> <figure class="highlight"><pre><code class="language-cmd">    dotnet publish -r win10-x64 -c Release</code></pre></figure> <p>Let&#x2019;s compare the size of the application publish directory:</p> <p><strong>Trimmed: 25,3 MB (26.548.001 bytes)</strong></p> <p><strong>Note trimmed: 65,8 MB (69.091.753 bytes)</strong></p> <p>Around 30 MB smaller - not that much but still enough to be worth doing it.</p> <h3 id="framework-dependent-deployment-fdd">Framework-Dependent Deployment (FDD)</h3> <p>As the name <em>Framework-Dependent</em> already implies, this deployment model relies on the existence of a (shared) framework installed on the target environment.
The publish directory of your application contains the application itself and everything needed (non-framework dependencies).</p> <h3 id="self-contained-deployment-scd">Self-Contained Deployment (SCD)</h3> <p>This deployment model is a lot larger in output size as the FDD is, but for a good reason.
The publish directory contains everything needed to run on the target environment - the framework and your application.
Therefor it&#x2019;s also isolated from any installed framework on the target environment.
The SCD possibility is in my humble opinion one of the strongest feature of .NET Core and something that the &#x201C;old&#x201D; .NET Framework had it&#x2019;s issues (it is not supported).</p> <p><img src="/assets/img/netconf-netcore3-IL-Linker/framework-deploy-models.png" alt="framework-deployment-models"></p> <h2 id="caveats">Caveats</h2> <p>The IL-Linker is a static analyzer and does not consider <em>Reflection</em> API&#x2019;s.
That means for instance: when you invoke a method via reflection or searching types and load them dynamically - <strong>that wouldn&#x2019;t work and your app will fail at runtime!</strong></p> <p>How could you address this issue? There are two options:</p> <p><strong>Option 1</strong></p> <p>Referencing a type from that assembly somewhere:</p> <figure class="highlight"><pre><code class="language-c#"> <span class="kt">var</span> <span class="n">t</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="nf">GetType</span><span class="p">(</span><span class="s">&quot;MyAssembly.MyClass, MyAssembly&quot;</span><span class="p">);</span> <span class="c1">// or direct reference</span> <span class="k">typeof</span><span class="p">(</span><span class="n">MyAssembly</span><span class="p">.</span><span class="n">MyClass</span><span class="p">);</span></code></pre></figure> <p><strong>Option 2</strong></p> <p>Add a &#x201C;reference&#x201D; in the .csproj (this is not a real assembly reference):</p> <figure class="highlight"><pre><code class="language-xml"><span class="nt">&lt;ItemGroup&gt;</span> <span class="nt">&lt;TrimmerRootAssembly</span> <span class="na">Include=</span><span class="s">&quot;MyAssembly.MyClass&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/ItemGroup&gt;</span></code></pre></figure> <h2 id="conclusion">Conclusion</h2> <p>I like this feature, even if it has some caveats as mentioned above.
It&#x2019;s cool that this tech comes originally from mono and is reused.
Let me know what you think about it.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>