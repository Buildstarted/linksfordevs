<!DOCTYPE html>
<html lang="en">
<head>
    <title>
bach-sh/bach - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="bach-sh/bach - linksfor.dev(s)"/>
    <meta property="og:description" content="Bach Testing Framework. Contribute to bach-sh/bach development by creating an account on GitHub."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/bach-sh/bach"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - bach-sh/bach</title>
<div class="readable">
        <h1>bach-sh/bach</h1>
            <div>Reading time: 12-15 minutes</div>
        <div>Posted here: 06 Jul 2020</div>
        <p><a href="https://github.com/bach-sh/bach">https://github.com/bach-sh/bach</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    
      <div>
        <article itemprop="text">
<p><a href="https://travis-ci.org/bach-sh/bach" rel="nofollow"><img src="https://camo.githubusercontent.com/df51dcec70100e3ca60990b267468d9c9657551a/68747470733a2f2f7472617669732d63692e6f72672f626163682d73682f626163682e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/bach-sh/bach.svg"></a>
<a href="https://github.com/bach-sh/bach"><img src="https://github.com/bach-sh/bach/workflows/Testing%20Bach/badge.svg" alt="GitHub Actions"></a>
<a href="https://www.gnu.org/licenses/gpl-3.0" rel="nofollow"><img src="https://camo.githubusercontent.com/bf135a9cea09d0ea4bba410582c0e70ec8222736/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d47504c25323076332d626c75652e737667" alt="License: GPL v3" data-canonical-src="https://img.shields.io/badge/License-GPL%20v3-blue.svg"></a>
<a href="https://www.mozilla.org/en-US/MPL/2.0/" rel="nofollow"><img src="https://camo.githubusercontent.com/d5ebaf7dfa5bf96cfa183b64bad15040e8771127/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d504c25323076322d626c75652e737667" alt="License: MPL v2" data-canonical-src="https://img.shields.io/badge/License-MPL%20v2-blue.svg"></a></p>
<p><a href="https://repl.it/github/bach-sh/bach" rel="nofollow"><img src="https://camo.githubusercontent.com/bfebe362720504e9041228e8bed7777a19498157/68747470733a2f2f7265706c2e69742f62616467652f6769746875622f626163682d73682f62616368" alt="Run on Repl.it" data-canonical-src="https://repl.it/badge/github/bach-sh/bach"></a></p>
<h2>Bach</h2>
<p>Bach is a Bash testing framework, can be used to test scripts that contain dangerous commands like <code>rm -rf /</code>. No surprises, no pain.</p>
<ul>
<li>Website: <a href="https://bach.sh/" rel="nofollow">https://bach.sh</a></li>
<li>Repo: <a href="https://github.com/bach-sh/bach">https://github.com/bach-sh/bach</a></li>
<li><a href="https://github.com/bach-sh/bach/blob/master/README-cn.md">查看本文档的中文版</a></li>
</ul>
<h2>Getting Started</h2>
<p>Bach Testing Framework is a <strong>real</strong> unit testing framework. All commands in the <code>PATH</code> environment variable become external dependencies of bash scripts being tested. No commands can be actually executed. In other words, all commands in Bach test cases are <strong>dry run</strong>. Because that unit tests should verify the behavior of bash scripts, not test commands. Bach Testing Framework also provides APIs to mock commands.</p>
<h3>Prerequisites</h3>
<ul>
<li><a href="https://www.gnu.org/software/bash/" rel="nofollow">Bash</a> v4.3+</li>
<li><a href="https://www.gnu.org/software/coreutils/coreutils.html" rel="nofollow">Coreutils</a> (<em>GNU/Linux</em>)</li>
<li><a href="https://www.gnu.org/software/diffutils/diffutils.html" rel="nofollow">Diffutils</a> (<em>GNU/Linux</em>)</li>
</ul>
<h3>Installing</h3>
<p>Installing Bach Testing Framework is very simple. Download <a href="https://github.com/bach-sh/bach/raw/master/bach.sh">bach.sh</a> to your project, use the <code>source</code> command to import <code>bach.sh</code>.</p>
<p>For example:</p>
<pre><code>source path/to/bach.sh
</code></pre>
<h4>A complete example</h4>
<pre><code>#!/usr/bin/env bash
set -euo pipefail
source bach.sh

test-rm-rf() {
    # Write your test case

    project_log_path=/tmp/project/logs
    sudo rm -rf "$project_log_ptah/" # Typo here!
}
test-rm-rf-assert() {
    # Verify your test case
    sudo rm -rf /   # This is the actual command to run on your host!
                    # DO NOT PANIC! By using Bach Testing Framework it won't actually run.
}

test-rm-your-dot-git() {
    # Mock `find` command with certain parameters, will output two directories

    @mock find ~ -type d -name .git === @stdout ~/src/your-awesome-project/.git \
                                                ~/src/code/.git

    # Do it, remove all .git directories
    find ~ -type d -name .git | xargs -- rm -rf
}
test-rm-your-dot-git-assert() {
    # Verify the actual command

    rm -rf ~/src/your-awesome-project/.git ~/src/code/.git
}
</code></pre>
<p>See <a href="https://github.com/bach-sh/bach/blob/master/tests/bach-testing-framework.test.sh">tests/bach-testing-framework.test.sh</a> for more examples.</p>
<h3>Write test cases</h3>
<p>Unlike the other testing frameworks, A standard test case of Bach is composed of two Bash functions. One is for running tests, the other is for asserting. Bach will run the two functions separately and then compare whether the same sequence of commands will be executed in both functions. The name of a testing function must start with <code>test-</code>, the name of the corresponding asserting function ends with <code>-assert</code>.</p>
<p>For example:</p>
<pre><code>source bach.sh

test-rm-rf() {
    project_log_path=/tmp/project/logs
    sudo rm -rf "$project_log_ptah/" # Typo! 
    # An undefined bash variable is an empty string, which can be a serious problem!
}
test-rm-rf-assert() {
    sudo rm -rf /
}
</code></pre>
<p>Bach will run the two functions separately, <code>test-rm-rf</code> and <code>test-rm-rf-assert</code>. In the testing function, <code>test-rm-rf</code>, the final actual command to be executed is <code>sudo rm -rf "/"</code>. It's the same as the asserting function <code>test-rm-rf-assert</code>. So this test case passes.</p>
<p>If Bach does not find the asserting function for a testing function. It will try to use a traditional test method. In this case, the testing function must have a call to assert the APIs. Otherwise, the test case will fail.</p>
<p>For example:</p>
<pre><code>test-single-function-style() {
    declare i=2
    @assert-equals 4 "$((i*2))"
}
</code></pre>
<p>If Bach does not find the corresponding asserting function and there is no assertion API call in the testing function, the test case must fail.</p>
<p>If the name of a test case starts with <code>test-ASSERT-FAIL</code>, it means that the asserting result of this test case is reversed. That is, if the asserting result is successful, the test case fails, if the asserting result fails, the test case is successful.</p>
<p>The assertion APIs of Bach Testing Framework:</p>
<ul>
<li><code>@assert-equals</code></li>
<li><code>@assert-fail</code></li>
<li><code>@assert-success</code></li>
</ul>
<h3>Mock commands</h3>
<p>There are mock APIs in the Bach test framework that can be used to mock commands and scripts.</p>
<p>The Mock APIs:</p>
<ul>
<li><code>@mock</code></li>
<li><code>@ignore</code></li>
<li><code>@mockall</code></li>
<li><code>@mocktrue</code></li>
<li><code>@mockfalse</code></li>
<li><code>@@mock</code></li>
</ul>
<p>But it doesn't allow to mock the following built-in commands in Bach Testing Framework:</p>
<ul>
<li><code>builtin</code></li>
<li><code>declare</code></li>
<li><code>eval</code></li>
<li><code>printf</code></li>
</ul>
<p>Test cases will fail if you attempt to mock these built-in commands. If they are needed in the script under test, we can extract a new function which contains the built-in commands in our scripts, and then use Bach to mock this new function.</p>
<h3>Run the actual commands in Bach</h3>
<p>In order to make test cases fast, stable, repetitive, and run in random order. We should write unit-testing cases and avoid calling real commands. But Bach also provides a set of APIs for executing real commands.</p>
<p>Bach mocks all commands by default. If it is unavoidable to execute a real command in a test case, Bach provides an API called <code>@real</code> to execute the real command, just put <code>@real</code> at the beginning of commands.</p>
<p>Bach also provides APIs for commonly used commands. The real commands for these APIs are obtained from the system's PATH environment variable before Bach starts.</p>
<p>These common used APIs are:</p>
<ul>
<li><code>@cd</code></li>
<li><code>@command</code></li>
<li><code>@echo</code></li>
<li><code>@exec</code></li>
<li><code>@false</code></li>
<li><code>@popd</code></li>
<li><code>@pushd</code></li>
<li><code>@pwd</code></li>
<li><code>@set</code></li>
<li><code>@trap</code></li>
<li><code>@true</code></li>
<li><code>@type</code></li>
<li><code>@unset</code></li>
<li><code>@eval</code></li>
<li><code>@source</code></li>
<li><code>@cat</code></li>
<li><code>@chmod</code></li>
<li><code>@cut</code></li>
<li><code>@diff</code></li>
<li><code>@find</code></li>
<li><code>@env</code></li>
<li><code>@grep</code></li>
<li><code>@ls</code></li>
<li><code>@shasum</code></li>
<li><code>@mkdir</code></li>
<li><code>@mktemp</code></li>
<li><code>@rm</code></li>
<li><code>@rmdir</code></li>
<li><code>@sed</code></li>
<li><code>@sort</code></li>
<li><code>@tee</code></li>
<li><code>@touch</code></li>
<li><code>@which</code></li>
<li><code>@xargs</code></li>
</ul>
<p><code>command</code> and <code>xargs</code> are a bit special. Bach mocks both commands by default to make the similar behavior of themselves.</p>
<p>In Bach Testing Framework the <code>xargs</code> is a mock function. It's behavior is similar to the real <code>xargs</code> command if you put <code>--</code> between <code>xargs</code> and the command. But the commands to be executed by  <code>xargs</code> are dry run.</p>
<p>For examples:</p>
<pre><code>test-xargs-no-dash-dash() {
    @mock ls === @stdout foo bar

    ls | xargs -n1 rm -v
}
test-xargs-no-dash-dash-assert() {
    xargs -n1 rm -v
}


test-xargs() {
    @mock ls === @stdout foo bar

    ls | xargs -n1 -- rm -v
}
test-xargs-assert() {
    rm -v foo
    rm -v bar
}


test-xargs-0() {
    @mock ls === @stdout foo bar

    ls | xargs -- rm -v
}
test-xargs-0-assert() {
    rm -v foo bar
}
</code></pre>
<h3>Configure Bach</h3>
<p>There are some environment variables starting with <code>BACH_</code> for configuring Bach Festing Framework.</p>
<ul>
<li><code>BACH_DEBUG</code>
&nbsp;&nbsp;The default is <code>false</code>. <code>true</code> to enable Bach's <code>@debug</code> API.</li>
<li><code>BACH_COLOR</code>
&nbsp;&nbsp;The default is <code>auto</code>. It can be <code>always</code> or <code>no</code>.</li>
<li><code>BACH_TESTS</code>
&nbsp;&nbsp;It is empty to allow all test cases. You can use glob wildcards to match the test cases to execute.</li>
<li><code>BACH_DISABLED</code>
&nbsp;&nbsp;The default is <code>false</code>. <code>true</code>  to disable Bach Testing Framework.</li>
<li><code>BACH_ASSERT_DIFF</code>
&nbsp;&nbsp;The default is the first <code>diff</code> command found in the original <code>PATH</code> environment variable of the system. Used to compare the execution results of testing functions and asserting functions.</li>
<li><code>BACH_ASSERT_DIFF_OPTS</code>
&nbsp;&nbsp;The default is <code>-u</code> for the <code>$BACH_ASSERT_DIFF</code> command.</li>
</ul>
<h2>Limitation of Bach</h2>
<h3>Cannot block absolute path command calls</h3>
<p>In this case, the OS runs the command directly, and does not interact with Bash(or Shell). Bach cannot intercept such commands. We can wrap this kind of commands in a new function, and then use the <code>@mock</code> API to mock the function.</p>
<h3>Prohibit resetting the PATH environment variable</h3>
<p>Because Bach wants to intercept all command calls, the <code>PATH</code> is set to read-only to avoid resetting its value.</p>
<p>In the case that PATH needs to be re-assigned, it is recommended to use the <code>declare</code> builtin command in our scripts to avoid errors caused by resetting a read-only environment variable.</p>
<h3>Bach is unable to intercept I/O redirection</h3>
<p>Bach already support mock functions to read from pipelines. But for the use of operators such as <code>&gt;</code>, <code>&gt;&gt;</code>, the solution is to wrap the redirected command in a function. Another way is to use the <code>sed</code> command to put <code>&gt;</code>  or <code>&gt;&gt;</code> in quotation marks, convert the I/O redirected operation to a normal argument.</p>
<h3>All command in the pipeline must be mocked</h3>
<p>The pipeline commands in Bash are running in sub-processes. Test cases may not be stable if we don't use <code>@mock</code> API to mock these pipeline commands.</p>
<h2>Bach APIs</h2>
<p>The names of all APIs provided in the Bach testing framework start with <code>@</code>.</p>
<h3>@assert-equals</h3>
<pre><code>@assert-equals "hello world" "HELLO WORLD"
@assert-equals 1 1
</code></pre>
<h3>@assert-fail</h3>
<pre><code>[[ 1 -eq 3 ]]
@assert-fail
</code></pre>
<h3>@assert-success</h3>
<pre><code>[[ 0 -eq 0 ]]
@assert-success
</code></pre>
<h3>@comment</h3>
<p>Output comments in the test output, but Bach will ignore these comments.</p>
<h3>@debug</h3>
<h3>@die</h3>
<p>Terminate the current run immediately</p>
<h3>@do-not-panic</h3>
<p>Don't panic.</p>
<p>This API has the following aliases:</p>
<ul>
<li><code>donotpanic</code></li>
<li><code>dontpanic</code></li>
<li><code>do-not-panic</code></li>
<li><code>dont-panic</code></li>
<li><code>do_not_panic</code></li>
<li><code>dont_panic</code></li>
</ul>
<h3>@do-nothing</h3>
<p>Do nothing.</p>
<p>Usually this API is used only in asserting funcions to verify that no any commands to be executed in testing functions.</p>
<p>For example:</p>
<pre><code>test-nothing() {
    declare i=9
    if [[ "$i" -eq 0 ]]; then
        do-something
    fi
}
test-nothing-assert() {
    @do-nothing
}
</code></pre>
<h3>@dryrun</h3>
<p>Bach uses <code>@dryrun</code> API to dry run commands by default. But if you want to dry run a mocked command, just put <code>@dryrun</code> in front of this mocked command.</p>
<p>For example:</p>
<pre><code>test-dryrun() {
    @mock ls === @stdout file1 file2 # mock `ls` command
    ls # outputs file1 file2
    @dryrun ls # Dry run `ls` command
}
test-dryrun-assert() {
    @out file1
    @out file2
    ls # @dryrun ls
}
</code></pre>
<h3>@err</h3>
<p>Output error message on stderr console</p>
<h3>@ignore</h3>
<pre><code>test-ignore-echo() {
    @ignore echo

    echo Updating APT caches
    apt-get update
}
test-ignore-echo-assert() {
    apt-get update
}
</code></pre>
<h3>@load_function</h3>
<p>Loading a function definenation from a script.</p>
<pre><code>test-gp() {
    @load_function ./examples/example-functions gp

    gp -f
}
test-gp-assert() {
    git push -f origin master
}
</code></pre>
<h3>@mock</h3>
<p>Mock commands or scripts.</p>
<p>Note:</p>
<ul>
<li>cannot mock commands that have absolute paths.</li>
<li>If a command is mocked multiple times, only the last mock takes effect</li>
</ul>
<p>Use <code>===</code> to split commands and output</p>
<p>For example:</p>
<h4>Mock a command that followed by parameters</h4>
<pre><code>test-mock-ls() {
    @mock ls file1 === @stdout file2

    ls file1

    ls foo bar
}
test-mock-ls-assert() {
    @out file2 # To list file1, but got file2, It's strange, right?

    ls foo bar
}
</code></pre>
<h4>Mock commands with complex implementations</h4>
<p>For example:</p>
<pre><code>test-mock-foobar() {
  @mock foobar &lt;&lt;&lt;\CMD
    if [[ "$var" -eq 1 ]]; then
      @stdout one
    else
      @stdout others
    fi
CMD

  var=1 foobar
  foobar
}
test-mock-foobar() {
  @out one
  @out others
}
</code></pre>
<h3>@@mock</h3>
<p>Mock the same command multiple times and return different values for each run.</p>
<p>For example:</p>
<pre><code>test-mock-function-multiple-times() {
    @@mock random numbers === @out num 1
    @@mock random numbers === @out num 22
    @@mock random numbers === @out num 333

    random
    random hello
    random numbers
    random numbers
    random numbers
    random numbers
}
test-mock-function-multiple-times-assert() {
    @dryrun random
    @dryrun random hello

    @cat &lt;&lt; EOF
num 1
num 22
num 333
num 333
EOF
}
</code></pre>
<h3>@mockall</h3>
<p>Mock many simple commands</p>
<h3>@mocktrue</h3>
<p>Mock the return code of a command as successful.</p>
<h3>@mockfalse</h3>
<p>Mock the return code of a command as non-zero value.</p>
<h3>@out</h3>
<p>Output to the stdout console.</p>
<h3>@real</h3>
<p>Executing the real command.</p>
<h3>@run</h3>
<p>Executing the script to be tested.</p>
<h4><code>@setup</code></h4>
<p>Executed at the beginning of the testing functions and the asserting functions.</p>
<p>Note: It doesn't make sense to run mock in asserting functions, so it's forbidden to mock any commands in asserting functions.</p>
<p>We cannot mock commands in <code>@setup</code> API.</p>
<p>example:</p>
<pre><code>@setup {
    @echo executing in both the testing function and the asserting function.
}
</code></pre>
<h3>@setup-assert</h3>
<p>Executing at the beginning of all asserting functions.</p>
<p>Note: the test cases will fail if we mock any commands inside <code>@setup-assert</code></p>
<p>For example:</p>
<pre><code>@setup-assert {
    @echo executing in the asserting functions
}
</code></pre>
<h3>@setup-test</h3>
<p>Executed at the beginning of all testing functions.</p>
<p>This is the only place that allows mock commands outside testing functions.</p>
<p>For example:</p>
<pre><code>@setup-test {
    @echo executing in the testing functions
}
</code></pre>
<h3>@stderr</h3>
<p>Output content to the stderr console, one line per parameter.</p>
<h3>@stdout</h3>
<p>Output content to the stdout console, one line per parameter.</p>
<h2>Learn Bash Programming with Bach</h2>
<pre><code>test-learn-bash-no-double-quote-star() {
    @touch bar1 bar2 bar3 "bar*"

    function cleanup() {
        rm -rf $1
    }

    # We want to remove the file "bar*", not the others
    cleanup "bar*"
}
test-learn-bash-no-double-quote-star-assert() {
    # Without double quotes, all bar files are removed!
    rm -rf "bar*" bar1 bar2 bar3
}

test-learn-bash-double-quote-star() {
    @touch bar1 bar2 bar3 "bar*"

    function cleanup() {
        rm -rf "$1"
    }

    # We want to remove the file "bar*", not the others
    cleanup "bar*"
}
test-learn-bash-double-quote-star-assert() {
    # Yes, with double quotes, only the file "bar*" is removed
    rm -rf "bar*"
}
</code></pre>
<h2>Roadmap</h2>
<ul>
<li>a command line tool</li>
<li>run inside docker containers
n</li>
</ul>
<h2>Clients</h2>
<ul>
<li>BMW Group</li>
<li>Huawei (华为)</li>
</ul>
<h2>Versioning</h2>
<p>The latest version of Bach is 0.2.9, See <a href="https://github.com/bach-sh/bach/releases">Bach Releases</a> for more.</p>
<h2>Author</h2>
<ul>
<li><strong>Chai Feng</strong> <a href="https://github.com/chaifeng">github.com/chaifeng</a>, <a href="https://chaifeng.com/" rel="nofollow">chaifeng.com</a></li>
</ul>
<h2>Licenses</h2>
<p>Bach Testing Framework is dual licensed under:</p>
<ul>
<li><a href="https://github.com/bach-sh/bach/blob/master/LICENSE.GPL-3.0">GNU General Public License v3.0</a></li>
<li><a href="https://github.com/bach-sh/bach/blob/master/LICENSE.MPL-2.0">Mzilla Public License 2.0</a></li>
</ul>
<p>See <a href="https://github.com/bach-sh/bach/blob/master/LICENSE">LICENSE</a> for more.</p>
</article>
      </div>
  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>