<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Different kinds of testing - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Different kinds of testing - linksfor.dev(s)"/>
    <meta property="article:author" content="Nicolas Fr&#xE4;nkel"/>
    <meta property="og:description" content="The subject of testing is vast. It may seem simple from outside, but it&#x2019;s not. For example, one may define testing as checking that the software is fit for its purpose. But it encompasses a lot more: for example, mutation testing verifies that assertions do actually assert. In this post, I&#x2019;d like to touch some testing flavors, what&#x2019;s their purpose and how they compare to each other. The need for testing In an ideal world, we wouldn&#x2019;t need testing. We would just write b"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.frankel.ch/different-kinds-testing/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Different kinds of testing</title>
<div class="readable">
        <h1>Different kinds of testing</h1>
            <div>by Nicolas Fr&#xE4;nkel</div>
            <div>Reading time: 12-15 minutes</div>
        <div>Posted here: 03 Aug 2020</div>
        <p><a href="https://blog.frankel.ch/different-kinds-testing/">https://blog.frankel.ch/different-kinds-testing/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="site-main" role="main"> <div> <article itemscope="" itemtype="http://schema.org/BlogPosting"> <meta itemprop="mainEntityOfPage" content="//different-kinds-testing/"> <meta itemprop="description" content="">  <figure itemscope="" itemprop="image" itemtype="http://schema.org/ImageObject"> <meta itemprop="url" content="https://blog.frankel.ch/assets/resources/different-kinds-testing/test-214185_1280.jpg"> <meta itemprop="height" content="847"> <meta itemprop="width" content="1280"> </figure> <section> <div itemprop="articleBody"> <p>The subject of testing is vast. It may seem simple from outside, but it’s not. For example, one may define testing as checking that the software is fit for its purpose. But it encompasses a lot more: for example, mutation testing verifies that assertions do actually assert. In this post, I’d like to touch some testing flavors, what’s their purpose and how they compare to each other.</p> <div> <h2 id="the-need-for-testing">The need for testing</h2> <div> <p>In an ideal world, we wouldn’t need testing. We would just write bug-free performant code that would be the perfect direct implementation of the requirements.</p> <p>Yet, the process of transforming requirements into code needs to be checked. Software development involves requirements gathering, writing documents, communicating with people, coping with organizational issues, etc. For the sake of simplification, in the rest of this post, we will consider that this process is perfect - even though it’s not, and focus on code.</p> <p>Let’s mention the elephant in the room: some platforms <em>e.g.</em> <a href="https://coq.inria.fr/" target="_blank" rel="noopener">Coq</a> do allow <strong>formal proof</strong>. This means it can be mathematically proven that the code is bug-free. However, most of those platforms stay within the bounds of academia. As far as I know, there aren’t that many attempts at using <a href="https://en.wikipedia.org/wiki/Formal_verification" target="_blank" rel="noopener">formal verification</a> in the industry.</p> <p>By removing formal proof from the equation (pun intended), the only option left is testing. But <strong>testing doesn’t prove the absence of bugs</strong>. In fact, testing is not only about bugs: it covers a lot of different areas. Let’s look at some of them.</p> </div> </div> <div> <h2 id="unit-testing">Unit Testing</h2> <div> <p><em>Unit Testing</em> is a fairly well-documented discipline: regardless of the language, a ton of books have been published on the subject. They generally repeat the same things.</p> <div> <blockquote> <p>[…​] Unit testing is a software testing method by which individual units of source code […​] are tested to determine whether they are fit for use.</p> </blockquote>  </div> <p>The only strongly-debated point is what constitutes a <em>unit</em>: in <abbr title="Object-Oriented Programming">OOP</abbr>, some argue it’s the <em>class</em>; others argue that it’s a <em>module</em> <em>i.e.</em> a set of collaborating classes.</p> </div> </div> <div> <h2 id="integration-testing">Integration Testing</h2> <div> <p>While <em>Unit Testing</em> is fairly well defined and understood, <em>Integration Testing</em> seems like virgin territory in comparison. I actually wrote the book <a href="https://blog.frankel.ch/books/integration-testing-trenches/" target="_blank" rel="noopener">Integration Testing from the Trenches</a> because I found no other books on the subject at that time.</p> <div> <blockquote> <p>Integration testing […​] is the phase in software testing in which individual software modules are combined and tested as a group.</p> </blockquote>  </div> <p>One of the core concepts behind <em>Integration Testing</em> is the <em>System Under Test</em>. In <em>Unit Testing</em>, the <em><abbr title="System Under Test">SUT</abbr></em> is the unit (<em>i.e.</em> the class or the module, as described above). In <em>Integration Testing</em>, the SUT needs to be defined per test: it can be as small as two units collaborating, and as big as the whole system.</p> <p>There’s a raging debate about <em>unit testing</em> vs. <em>integration testing</em>. Some consider only the former, while other only the latter. If you want to know my personal stance on this, please read <a href="https://blog.frankel.ch/unit-test-vs-integration-test/">this previous post</a>.</p> </div> </div> <div> <h2 id="end-to-end-testing">End-To-End Testing</h2> <div> <p>At a time when most applications were Human-To-Machine, <em>End-To-End Testing</em> meant testing the flow from the <em>User Interface</em> to the database, and back again. Because web applications have become nearly ubiquitous, this involves the browser. For this reason, <em><abbr title="End-to-End">E2E</abbr> Testing</em> is very different from the previous approach. Automating user interactions with the browser is not trivial, even if the tools available improved with time.</p> <p>The biggest issue in <em>E2E Testing</em> comes from the brittleness of the <abbr title="User Interface">UI</abbr> layer. Modern architectures cleanly separate into a JavaScript-based front-end and a <abbr title="REpresentational State Transfer">REST</abbr> back-end. To cope with the mentioned brittleness, it helps to first test the REST layer via <em>Integration Testing</em>.</p> <p>With <em>E2E Testing</em>, there’s a whole continuum from <em>Unit Testing</em> through <em>Integration Testing</em>. This is pretty well summarized in the famous <em>Testing Pyramid</em>.</p> <div> <p>The Test Pyramid</p> <p><span><a href="https://martinfowler.com/articles/practical-test-pyramid.html"><img src="https://martinfowler.com/articles/practical-test-pyramid/testPyramid.png" alt="The Test Pyramid"></a></span></p> </div> <p>One can consider <em>E2E Testing</em> as the most complete form of <em>Integration Testing</em>: in that case, the <em>SUT</em> is the whole application.</p> </div> </div> <div> <h2 id="system-testing">System Testing</h2> <div> <p>With time passing, more and more applications are targeted at Machine-To-Machine interactions instead of <abbr title="Human-To-Machine">H2M</abbr> ones. <em>End-To-End Testing</em> is to H2M what <em>System Testing</em> is to <abbr title="Human-To-Machine">M2M</abbr>.</p> <p>The benefit is that there’s no browser involved. Hence, the same automation techniques from <em>Unit Testing</em> and <em>Integration Testing</em> can be reused.</p> </div> </div> <div> <h2 id="performance-testing">Performance Testing</h2> <div> <p>Most of the previous approachs focus on testing <em>Functional Requirements</em>. It’s easy to forget that the fitness of a software component encompasses both <em>Functional Requirements</em> and <em>Non-Functional Requirements</em>. Performance counts as part of the <abbr title="Non-Functional Requirements">NFR</abbr>, along with reliability, etc.</p> <p>Note that the <em>SUT</em> in performance tests can be the whole system, or just a sub-component deemed critical. Yet, in that case, asserting the performance of each individual components might not be enough to guarantee the performance of the whole system.</p> <div> <blockquote> <p>[…​] performance testing is in general a testing practice performed to determine how a system performs in terms of responsiveness and stability under a particular workload.</p> </blockquote>  </div> <p>From my experience, the term <em>Performance Testing</em> is overused, and much too general. It has many facets: here are the most commons ones.</p> <div> <h3 id="load-testing">Load Testing</h3> <p><em>Load Testing</em> is in general what is implicitly meant when people talk about <em>Performance Testing</em>. In this context, one sets different parameters for the tests. Those parameters model a representative load from the production environment. In reality, most organizations are unable to provide a quality sample of the production load, and the load is inferred.</p> <p>For example, in an e-commerce context, testing parameters would include:</p> <ul><li><span>The different types of requests: browsing the catalog, viewing distinct products, adding them to the cart, checking out, paying, etc.</span></li><li><span>The repartition between them <em>e.g.</em> 70% browsing, 20% viewing, 6% cart manipulation, 3% checkout, and 1% payment</span></li><li><span>The number of concurrent requests</span></li><li><span>The number of concurrent user sessions, and how are they spread between requests</span></li><li><span>etc.</span></li></ul> </div> <div> <h3 id="endurance-testing">Endurance Testing</h3> <p>In regular <em>Load Testing</em>, tests run until they are finished executing. The goal is to check that the system behaves according to one’s expectations under a specific load.</p> <p>In <em>Endurance Testing</em> also known as <em>Soak Testing</em>, the goal is to check how the system’s behavior evolves along with time. In comparison, the duration of those tests are more in the order of days, or even weeks.</p> <div> <blockquote> <p>Soak testing involves testing a system with a typical production load, over a continuous availability period, to validate system behavior under production use.</p> </blockquote>  </div> </div> <div> <h3 id="stress-testing">Stress Testing</h3> <p><em>Stress Testing</em> is the testing of the system until it breaks. The load is increased gradually. The goal of <em>Stress Testing</em> is to understand the performance limits of the system.</p> <div> <blockquote> <p>Stress testing (sometimes called torture testing) is a form of deliberately intense or thorough testing used to determine the stability of a given system, critical infrastructure or entity. It involves testing beyond normal operational capacity, often to a breaking point, in order to observe the results.</p> </blockquote>  </div> <p>Conclusions of such experiments are along the lines of: within a load of <code>x</code> requests/second, a <code>y</code> fraction of requests return a <code>5xx</code> error code.</p> </div> </div> </div> <div> <h2 id="chaos-testing">Chaos Testing</h2> <div> <p><em>Chaos Testing</em>, also known as Chaos Engineering, is the practice of randomly removing components of a system to understand how it breaks, and check its overall resiliency under duress.</p> <div> <blockquote> <p>Chaos engineering is the discipline of experimenting on a software system in production in order to build confidence in the system’s capability to withstand turbulent and unexpected conditions.</p> </blockquote>  </div> <p>The defining property of <em>Chaos Testing</em> is that it’s generally <strong>performed in the production environment</strong>. That doesn’t mean that experiments made in other environments cannot bring actionable feedback, far from the contrary. However, everybody has experienced issues in production that never happened in previous environments. The root cause might be slightly different architectures, different data data, higher load, etc: in the end, the only environment that needs to be battle-tested and bulletproof is production.</p> <p>While counter-intuitive at first, the idea is now firmly entrenched in mature organizations that are serious about the resilience of their systems.</p> </div> </div> <div> <h2 id="security-testing">Security Testing</h2> <div> <p>Just like <em>Performance Testing</em> is too broad a term, <em>Security Testing</em> covers many different areas. The most well-known form of <em>Security Testing</em> is <em>Penetration Testing</em>.</p> <div> <blockquote> <p>A penetration test […​] is an authorized simulated cyberattack on a computer system, performed to evaluate the security of the system.</p> <p>The test is performed to identify both weaknesses […​], including the potential for unauthorized parties to gain access to the system’s features and data, as well as strengths, enabling a full risk assessment to be completed.</p> </blockquote>  </div> </div> </div> <div> <h2 id="mutation-testing">Mutation Testing</h2> <div> <p>Most forms of testing focus on the fitness of pieces of software, or the system as a whole. <em>Mutation Testing</em> is unique in that its goal is to give a hindsight on unit tests, and more specifically on the misleading <em>Code Coverage</em> metrics.</p> <div> <blockquote> <p>Mutation testing […​] is used to design new software tests and evaluate the quality of existing software tests.</p> </blockquote>  </div> <p>I’ve already <a href="https://blog.frankel.ch/introduction-to-mutation-testing/" target="_blank" rel="noopener">written</a> on the subject before. Please read it if you want to know more.</p> </div> </div> <div> <h2 id="exploratory-testing">Exploratory Testing</h2> <div> <p>A lot of testing approaches focus on <em>regression bugs</em>, bugs that appear in previously working software. For that, tests are automated: they are ran for every build. If a previously running test fails, the build fails as well.</p> <p>The goal of <em>Exploratory Testing</em> is to catch bugs that are out of the testing harness’s reach. To achieve that, one interacts with the system in new and unexpected ways.</p> <div> <blockquote> <p>Exploratory testing is an approach to software testing that is concisely described as simultaneous learning, test design and test execution.</p> </blockquote>  </div> <p>Because of its exploratory nature, this process is manual. My experience has shown me that <em>Exploratory Testing</em> is undervalued. That’s a pity, because I’ve witnessed testers who uncovered issues in the system that previous automated steps didn’t find.</p> <p>Despite its manual nature, <em>Exploratory Testing</em> is not about clicking everywhere. It’s an engineering practice, that require discipline and a rigorous approach to documenting the steps that led to the issue. The best testers are also able:</p> <ul><li><span>To isolate the issue</span></li><li><span>To reproduce the steps that led to it</span></li><li><span>To create the issue in a way that will ease the job of developpers who will need to fix the bug</span></li></ul> </div> </div> <div> <h2 id="user-acceptance-testing">User Acceptance Testing</h2> <div> <p>Most forms of testing are performed by technical people: developers, automation testers, etc. On the opposite, <em>Acceptance Testing</em> is performed by non-technical people, <em>e.g.</em> business analysts or end users. As the name implies, the goal is to assess whether they accept the software as fit for their usage.</p> <div> <blockquote> <p>User acceptance testing consists of a process of verifying that a solution works for the user.</p> </blockquote>  </div> </div> </div> <div> <h2 id="summary">Summary</h2> <div> <table> <colgroup> <col> <col> <col> <col> </colgroup> <thead> <tr> <th>Kind</th> <th>Goal</th> <th>Actor</th> <th>Automated</th> </tr> </thead> <tbody> <tr> <th><p><a href="#unit-testing">Unit</a></p></th> <td><p>Assess the fitness of a code unit</p></td> <td><p>Developer</p></td> <td></td> </tr> <tr> <th><p><a href="#integration-testing" target="_blank" rel="noopener">Integration</a></p></th> <td><p>Check the collaboration of units</p></td> <td><p>Developer</p></td> <td></td> </tr> <tr> <th><p><a href="#system-testing">System</a></p></th> <td><p>Verify the behavior of the system as a whole</p></td> <td><div><p>Mix of different skillsets:</p> <ul><li><span>Backend developers</span></li><li><span>System administrators</span></li><li><span><abbr title="DataBase Administrator">DBA</abbr>s</span></li><li><span>etc.</span></li></ul></div></td> <td></td> </tr> <tr> <th><p><a href="#end-to-end-testing">End-to-End</a></p></th> <td><p>Validate the flow from the <abbr title="Graphical User Interface">GUI</abbr> to the datastore and back</p></td> <td><div><ul><li><span>Front-end developer</span></li><li><span>Specialized automation tester</span></li></ul></div></td> <td></td> </tr> <tr> <th><p><a href="#performance-testing">Performance</a></p></th> <td><p>Check different performance-related metrics</p></td> <td><p>System administrator with specialized testing skills</p></td> <td><p><span><i></i></span> | <span><i></i></span></p></td> </tr> <tr> <th><p><a href="#chaos-testing">Chaos</a></p></th> <td><p>Verify the resiliency of a system</p></td> <td><div><p>Mix of different skillsets:</p> <ul><li><span>System administrators</span></li><li><span>Network experts</span></li><li><span>etc.</span></li></ul></div></td> <td></td> </tr> <tr> <th><p><a href="#security-testing">Penetration</a></p></th> <td><p>Assess the vulnerability of a system</p></td> <td><p>"Hacker"</p></td> <td></td> </tr> <tr> <th><p><a href="#mutation-testing">Mutation</a></p></th> <td><p>Check the quality of tests</p></td> <td><p>Developer</p></td> <td></td> </tr> <tr> <th><p><a href="#exploratory-testing">Exploratory</a></p></th> <td><p>Find hidden bugs</p></td> <td><p>Manual tester</p></td> <td></td> </tr> <tr> <th><p><a href="#user-acceptance-testing">UAT</a></p></th> <td><p>Validate the system conforms to specifications</p></td> <td><p>Business people</p></td> <td></td> </tr> </tbody> </table> </div> </div> <div> <h2 id="conclusion">Conclusion</h2> <div> <p>The post is already too long, and I only brushed the surface of available testing kinds. In conclusion, one need to remember a couple of things:</p> <ol><li><span>It’s easier to find a bug in the system than to point to its root cause. The bigger the SUT, the harder it is.</span></li><li><span>The right balance between manual testing and automated testing efforts needs to be found: this balance is context-dependent.</span></li><li><span>Testing is all about <abbr title="Return Over Investement">ROI</abbr>. This is plain risk management: the goal is to evaluate risks, their nature, their probability, their impact, the respective mitigation actions, etc. in regard to the associated costs.</span></li><li><span>Finally, testing is a strategic move: one should carefully plan one’s testing efforts and the reasons behind them before writing a single one (and yes, it’s against <abbr title="Test-Driven Development">TDD</abbr>).</span></li></ol> <p>Happy testing!</p> </div> </div>    </div> </section>   </article> </div> </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>