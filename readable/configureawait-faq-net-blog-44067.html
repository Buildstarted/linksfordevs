<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ConfigureAwait FAQ | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="ConfigureAwait FAQ | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Stephen ToubFollow"/>
    <meta property="og:description" content=".NET added async/await to the languages and libraries over seven years ago. In that time, it&#x2019;s caught on like wildfire, not only across the .NET ecosystem, but also being replicated in a myriad of other languages and frameworks. It&#x2019;s also seen a ton of improvements in .NET,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/configureawait-faq/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - ConfigureAwait FAQ | .NET Blog</title>
<div class="readable">
        <h1>ConfigureAwait FAQ | .NET Blog</h1>
            <div>by Stephen ToubFollow</div>
            <div>Reading time: 31-39 minutes</div>
        <div>Posted here: 13 Dec 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/">https://devblogs.microsoft.com/dotnet/configureawait-faq/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/49e67eaea0533a547f3489aa03707bbb?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p></div></div></div><p>December 11th, 2019</p><p>.NET added <code>async</code>/<code>await</code> to the languages and libraries over seven years ago. In that time, it’s caught on like wildfire, not only across the .NET ecosystem, but also being replicated in a myriad of other languages and frameworks. It’s also seen a ton of improvements in .NET, in terms of additional language constructs that utilize asynchrony, APIs offering async support, and fundamental improvements in the infrastructure that makes <code>async</code>/<code>await</code> tick (in particular performance and diagnostic-enabling improvements in .NET Core).</p><p>However, one aspect of <code>async</code>/<code>await</code> that continues to draw questions is <code>ConfigureAwait</code>. In this post, I hope to answer many of them. I intend for this post to be both readable from start to finish as well as being a list of Frequently Asked Questions (FAQ) that can be used as future reference.</p><p>To really understand <code>ConfigureAwait</code>, we need to start a bit earlier…</p><h3>What is a SynchronizationContext?</h3><p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext" rel="noopener noreferrer" target="_blank"><code>System.Threading.SynchronizationContext</code> docs</a> state that it “Provides the basic functionality for propagating a synchronization context in various synchronization models.” Not an entirely obvious description.</p><p>For the 99.9% use case, <code>SynchronizationContext</code> is just a type that provides a virtual <code>Post</code> method, which takes a delegate to be executed asynchronously (there are a variety of other virtual members on <code>SynchronizationContext</code>, but they’re much less used and are irrelevant for this discussion). The base type’s <code>Post</code> literally <a href="https://github.com/dotnet/runtime/blob/5e67c2480d8b9361923566243c1395a3d1a5d617/src/libraries/System.Private.CoreLib/src/System/Threading/SynchronizationContext.cs#L25" rel="noopener noreferrer" target="_blank">just calls</a> <code>ThreadPool.QueueUserWorkItem</code> to asynchronously invoke the supplied delegate. However, derived types override <code>Post</code> to enable that delegate to be executed in the most appropriate place and at the most appropriate time.</p><p>For example, Windows Forms has a <a href="https://github.com/dotnet/winforms/blob/94ce4a2e52bf5d0d07d3d067297d60c8a17dc6b4/src/System.Windows.Forms/src/System/Windows/Forms/WindowsFormsSynchronizationContext.cs" rel="noopener noreferrer" target="_blank"><code>SynchronizationContext</code>-derived type</a> that overrides <code>Post</code> to do the equivalent of <code>Control.BeginInvoke</code>; that means any calls to its <code>Post</code> method will cause the delegate to be invoked at some later point on the thread associated with that relevant Control, aka “the UI thread”. Windows Forms relies on Win32 message handling and has a “message loop” running on the UI thread, which simply sits waiting for new messages to arrive to process. Those messages could be for mouse movements and clicks, for keyboard typing, for system events, for delegates being available to invoke, etc. So, given a <code>SynchronizationContext</code> instance for the UI thread of a Windows Forms application, to get a delegate to execute on that UI thread, one simply needs to pass it to <code>Post</code>.</p><p>The same goes for Windows Presentation Foundation (WPF). It has its own <a href="https://github.com/dotnet/wpf/blob/ac9d1b7a6b0ee7c44fd2875a1174b820b3940619/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherSynchronizationContext.cs" rel="noopener noreferrer" target="_blank"><code>SynchronizationContext</code>-derived type</a> with a <code>Post</code> override that similarly “marshals” a delegate to the UI thread (via <code>Dispatcher.BeginInvoke</code>), in this case managed by a WPF Dispatcher rather than a Windows Forms Control.</p><p>And for Windows RunTime (WinRT). It has its own <a href="https://github.com/dotnet/runtime/blob/60d1224ddd68d8ac0320f439bb60ac1f0e9cdb27/src/libraries/System.Runtime.WindowsRuntime/src/System/Threading/WindowsRuntimeSynchronizationContext.cs" rel="noopener noreferrer" target="_blank"><code>SynchronizationContext</code>-derived type</a> with a <code>Post</code> override that also queues the delegate to the UI thread via its <code>CoreDispatcher</code>.</p><p>This goes beyond just “run this delegate on the UI thread”. Anyone can implement a <code>SynchronizationContext</code> with a <code>Post</code> that does anything. For example, I may not care what thread a delegate runs on, but I want to make sure that any delegates <code>Post</code>‘d to my <code>SynchronizationContext</code> are executed with some limited degree of concurrency. I can achieve that with a custom <code>SynchronizationContext</code> like this:</p><pre><code><span>internal</span><span> </span><span>sealed</span><span> </span><span>class</span><span> </span><span>MaxConcurrencySynchronizationContext</span><span> </span><span>:</span><span> </span><span>SynchronizationContext</span><span>
</span><span>{</span><span>
    </span><span>private</span><span> </span><span>readonly</span><span> </span><span>SemaphoreSlim</span><span> _semaphore</span><span>;</span><span>

    </span><span>public</span><span> </span><span>MaxConcurrencySynchronizationContext</span><span>(</span><span>int</span><span> maxConcurrencyLevel</span><span>)</span><span> </span><span>=&gt;</span><span>
        _semaphore </span><span>=</span><span> </span><span>new</span><span> </span><span>SemaphoreSlim</span><span>(</span><span>maxConcurrencyLevel</span><span>);</span><span>

    </span><span>public</span><span> </span><span>override</span><span> </span><span>void</span><span> </span><span>Post</span><span>(</span><span>SendOrPostCallback</span><span> d</span><span>,</span><span> </span><span>object</span><span> state</span><span>)</span><span> </span><span>=&gt;</span><span>
        _semaphore</span><span>.</span><span>WaitAsync</span><span>().</span><span>ContinueWith</span><span>(</span><span>delegate</span><span>
        </span><span>{</span><span>
            </span><span>try</span><span> </span><span>{</span><span> d</span><span>(</span><span>state</span><span>);</span><span> </span><span>}</span><span> </span><span>finally</span><span> </span><span>{</span><span> _semaphore</span><span>.</span><span>Release</span><span>();</span><span> </span><span>}</span><span>
        </span><span>},</span><span> </span><span>default</span><span>,</span><span> </span><span>TaskContinuationOptions</span><span>.</span><span>None</span><span>,</span><span> </span><span>TaskScheduler</span><span>.</span><span>Default</span><span>);</span><span>

    </span><span>public</span><span> </span><span>override</span><span> </span><span>void</span><span> </span><span>Send</span><span>(</span><span>SendOrPostCallback</span><span> d</span><span>,</span><span> </span><span>object</span><span> state</span><span>)</span><span>
    </span><span>{</span><span>
        _semaphore</span><span>.</span><span>Wait</span><span>();</span><span>
        </span><span>try</span><span> </span><span>{</span><span> d</span><span>(</span><span>state</span><span>);</span><span> </span><span>}</span><span> </span><span>finally</span><span> </span><span>{</span><span> _semaphore</span><span>.</span><span>Release</span><span>();</span><span> </span><span>}</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>In fact, the unit testing framework xunit <a href="https://github.com/xunit/xunit/blob/d81613bf752bb4b8774e9d4e77b2b62133b0d333/src/xunit.execution/Sdk/MaxConcurrencySyncContext.cs" rel="noopener noreferrer" target="_blank">provides a <code>SynchronizationContext</code></a> very similar to this, which it uses to limit the amount of code associated with tests that can be run concurrently.</p><p>The benefit of all of this is the same as with any abstraction: it provides a single API that can be used to queue a delegate for handling however the creator of the implementation desires, without needing to know the details of that implementation. So, if I’m writing a library, and I want to go off and do some work, and then queue a delegate back to the original location’s “context”, I just need to grab their <code>SynchronizationContext</code>, hold on to it, and then when I’m done with my work, call <code>Post</code> on that context to hand off the delegate I want invoked. I don’t need to know that for Windows Forms I should grab a <code>Control</code> and use its <code>BeginInvoke</code>, or for WPF I should grab a <code>Dispatcher</code> and uses its <code>BeginInvoke</code>, or for xunit I should somehow acquire its context and queue to it; I simply need to grab the current <code>SynchronizationContext</code> and use that later on. To achieve that, <code>SynchronizationContext</code> provides a <code>Current</code> property, such that to achieve the aforementioned objective I might write code like this:</p><pre><code><span>public</span><span> </span><span>void</span><span> </span><span>DoWork</span><span>(</span><span>Action</span><span> worker</span><span>,</span><span> </span><span>Action</span><span> completion</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>SynchronizationContext</span><span> sc </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
    </span><span>ThreadPool</span><span>.</span><span>QueueUserWorkItem</span><span>(</span><span>_ </span><span>=&gt;</span><span>
    </span><span>{</span><span>
        </span><span>try</span><span> </span><span>{</span><span> worker</span><span>();</span><span> </span><span>}</span><span>
        </span><span>finally</span><span> </span><span>{</span><span> sc</span><span>.</span><span>Post</span><span>(</span><span>_ </span><span>=&gt;</span><span> completion</span><span>(),</span><span> </span><span>null</span><span>);</span><span> </span><span>}</span><span>
    </span><span>});</span><span>
</span><span>}</span></code></pre><p>A framework that wants to expose a custom context from <code>Current</code> uses the <code>SynchronizationContext.SetSynchronizationContext</code> method.</p><h3>What is a TaskScheduler?</h3><p><code>SynchronizationContext</code> is a general abstraction for a “scheduler”. Individual frameworks sometimes have their own abstractions for a scheduler, and <code>System.Threading.Tasks</code> is no exception. When <code>Task</code>s are backed by a delegate such that they can be queued and executed, they’re associated with a <code>System.Threading.Tasks.TaskScheduler</code>. Just as <code>SynchronizationContext</code> provides a virtual <code>Post</code> method to queue a delegate’s invocation (with the implementation later invoking the delegate via typical delegate invocation mechanisms), <code>TaskScheduler</code> provides an abstract <code>QueueTask</code> method (with the implementation later invoking that <code>Task</code> via the <code>ExecuteTask</code> method).</p><p>The default scheduler as returned by <code>TaskScheduler.Default</code> is the thread pool, but it’s possible to derive from <code>TaskScheduler</code> and override the relevant methods to achieve arbitrary behaviors for when and where a <code>Task</code> is invoked. For example, the core libraries include the <code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code> type. An instance of this class exposes two <code>TaskScheduler</code> properties, one called <code>ExclusiveScheduler</code> and one called <code>ConcurrentScheduler</code>. Tasks scheduled to the <code>ConcurrentScheduler</code> may run concurrently, but subject to a limit supplied to <code>ConcurrentExclusiveSchedulerPair</code> when it was constructed (similar to the <code>MaxConcurrencySynchronizationContext</code> shown earlier), and no <code>ConcurrentScheduler</code> <code>Task</code>s will run when a <code>Task</code> scheduled to <code>ExclusiveScheduler</code> is running, with only one exclusive <code>Task</code> allowed to run at a time… in this way, it behaves very much like a reader/writer-lock.</p><p>Like <code>SynchronizationContext</code>, <code>TaskScheduler</code> also has a <code>Current</code> property, which returns the “current” <code>TaskScheduler</code>. Unlike <code>SynchronizationContext</code>, however, there’s no method for setting the current scheduler. Instead, the current scheduler is the one associated with the currently running <code>Task</code>, and a scheduler is provided to the system as part of starting a <code>Task</code>. So, for example, this program will output “True”, as the lambda used with <code>StartNew</code> is executed on the <code>ConcurrentExclusiveSchedulerPair</code>‘s <code>ExclusiveScheduler</code> and will see <code>TaskScheduler.Current</code> set to that scheduler:</p><pre><code><span>using</span><span> </span><span>System</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Threading</span><span>.</span><span>Tasks</span><span>;</span><span>

</span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>()</span><span>
    </span><span>{</span><span>
        </span><span>var</span><span> cesp </span><span>=</span><span> </span><span>new</span><span> </span><span>ConcurrentExclusiveSchedulerPair</span><span>();</span><span>
        </span><span>Task</span><span>.</span><span>Factory</span><span>.</span><span>StartNew</span><span>(()</span><span> </span><span>=&gt;</span><span>
        </span><span>{</span><span>
            </span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>TaskScheduler</span><span>.</span><span>Current</span><span> </span><span>==</span><span> cesp</span><span>.</span><span>ExclusiveScheduler</span><span>);</span><span>
        </span><span>},</span><span> </span><span>default</span><span>,</span><span> </span><span>TaskCreationOptions</span><span>.</span><span>None</span><span>,</span><span> cesp</span><span>.</span><span>ExclusiveScheduler</span><span>).</span><span>Wait</span><span>();</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>Interestingly, <code>TaskScheduler</code> provides a static <code>FromCurrentSynchronizationContext</code> method, which creates a new <code>TaskScheduler</code> that queues <code>Task</code>s to run on whatever <code>SynchronizationContext.Current</code> returned, using its <code>Post</code> method for queueing tasks.</p><h3>How do SynchronizationContext and TaskScheduler relate to await?</h3><p>Consider writing a UI app with a <code>Button</code>. Upon clicking the <code>Button</code>, we want to download some text from a web site and set it as the <code>Button</code>‘s <code>Content</code>. The <code>Button</code> should only be accessed from the UI thread that owns it, so when we’ve successfully downloaded the new date and time text and want to store it back into the <code>Button</code>‘s <code>Content</code>, we need to do so from the thread that owns the control. If we don’t, we get an exception like:</p><pre><code><span>System</span><span>.</span><span>InvalidOperationException</span><span>:</span><span> </span><span>'The calling thread cannot access this object because a different thread owns it.'</span></code></pre><p>If we were writing this out manually, we could use <code>SynchronizationContext</code> as shown earlier to marshal the setting of the <code>Content</code> back to the original context, such as via a <code>TaskScheduler</code>:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>).</span><span>ContinueWith</span><span>(</span><span>downloadTask </span><span>=&gt;</span><span>
    </span><span>{</span><span>
        downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> downloadTask</span><span>.</span><span>Result</span><span>;</span><span>
    </span><span>},</span><span> </span><span>TaskScheduler</span><span>.</span><span>FromCurrentSynchronizationContext</span><span>());</span><span>
</span><span>}</span></code></pre><p>or using <code>SynchronizationContext</code> directly:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>SynchronizationContext</span><span> sc </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
    s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>).</span><span>ContinueWith</span><span>(</span><span>downloadTask </span><span>=&gt;</span><span>
    </span><span>{</span><span>
        sc</span><span>.</span><span>Post</span><span>(</span><span>delegate</span><span>
        </span><span>{</span><span>
            downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> downloadTask</span><span>.</span><span>Result</span><span>;</span><span>
        </span><span>},</span><span> </span><span>null</span><span>);</span><span>
    </span><span>});</span><span>
</span><span>}</span></code></pre><p>Both of these approaches, though, explicitly uses callbacks. We would instead like to write the code naturally with <code>async</code>/<code>await</code>:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> async </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>string</span><span> text </span><span>=</span><span> await s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>);</span><span>
    downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> text</span><span>;</span><span>
</span><span>}</span></code></pre><p>This “just works”, successfully setting <code>Content</code> on the UI thread, because just as with the manually implemented version above, <code>await</code>ing a <code>Task</code> pays attention by default to <code>SynchronizationContext.Current</code>, as well as to <code>TaskScheduler.Current</code>. When you <code>await</code> anything in C#, the compiler transforms the code to ask (via calling <code>GetAwaiter</code>) the “awaitable” (in this case, the <code>Task</code>) for an “awaiter” (in this case, a <code>TaskAwaiter&lt;string&gt;</code>). That awaiter is responsible for hooking up the callback (often referred to as the “continuation”) that will call back into the state machine when the awaited object completes, and it does so using whatever context/scheduler it captured at the time the callback was registered. While not exactly the code used (there are additional optimizations and tweaks employed), it’s something like this:</p><pre><code><span>object</span><span> scheduler </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
</span><span>if</span><span> </span><span>(</span><span>scheduler </span><span>is</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> </span><span>TaskScheduler</span><span>.</span><span>Current</span><span> </span><span>!=</span><span> </span><span>TaskScheduler</span><span>.</span><span>Default</span><span>)</span><span>
</span><span>{</span><span>
    scheduler </span><span>=</span><span> </span><span>TaskScheduler</span><span>.</span><span>Current</span><span>;</span><span>
</span><span>}</span></code></pre><p>In other words, it first checks whether there’s a <code>SynchronizationContext</code> set, and if there isn’t, whether there’s a non-default <code>TaskScheduler</code> in play. If it finds one, when the callback is ready to be invoked, it’ll use the captured scheduler; otherwise, it’ll generally just execute the callback on as part of the operation completing the awaited task.</p><h3>What does ConfigureAwait(false) do?</h3><p>The <code>ConfigureAwait</code> method isn’t special: it’s not recognized in any special way by the compiler or by the runtime. It is simply a method that returns a struct (a <code>ConfiguredTaskAwaitable</code>) that wraps the original task it was called on as well as the specified Boolean value. Remember that <code>await</code> can be used with any type that exposes the right pattern. By returning a different type, it means that when the compiler accesses the instances <code>GetAwaiter</code> method (part of the pattern), it’s doing so off of the type returned from <code>ConfigureAwait</code> rather than off of the task directly, and that provides a hook to change the behavior of how the <code>await</code> behaves via this custom awaiter.</p><p>Specifically, awaiting the type returned from <code>ConfigureAwait(continueOnCapturedContext: false)</code> instead of awaiting the <code>Task</code> directly ends up impacting the logic shown earlier for how the target context/scheduler is captured. It effectively makes the previously shown logic more like this:</p><pre><code><span>object</span><span> scheduler </span><span>=</span><span> </span><span>null</span><span>;</span><span>
</span><span>if</span><span> </span><span>(</span><span>continueOnCapturedContext</span><span>)</span><span>
</span><span>{</span><span>
    scheduler </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
    </span><span>if</span><span> </span><span>(</span><span>scheduler </span><span>is</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> </span><span>TaskScheduler</span><span>.</span><span>Current</span><span> </span><span>!=</span><span> </span><span>TaskScheduler</span><span>.</span><span>Default</span><span>)</span><span>
    </span><span>{</span><span>
        scheduler </span><span>=</span><span> </span><span>TaskScheduler</span><span>.</span><span>Current</span><span>;</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>In other words, by specifying <code>false</code>, even if there is a current context or scheduler to call back to, it pretends as if there isn’t.</p><h3>Why would I want to use ConfigureAwait(false)?</h3><p><code>ConfigureAwait(continueOnCapturedContext: false)</code> is used to avoid forcing the callback to be invoked on the original context or scheduler. This has a few benefits:</p><p><strong>Improving performance.</strong> There is a cost to queueing the callback rather than just invoking it, both because there’s extra work (and typically extra allocation) involved, but also because it means certain optimizations we’d otherwise like to employ in the runtime can’t be used (we can do more optimization when we know exactly how the callback will be invoked, but if it’s handed off to an arbitrary implementation of an abstraction, we can sometimes be limited). For very hot paths, even the extra costs of checking for the current <code>SynchronizationContext</code> and the current <code>TaskScheduler</code> (both of which involve accessing thread statics) can add measurable overhead. If the code after an <code>await</code> doesn’t actually require running in the original context, using <code>ConfigureAwait(false)</code> can avoid all these costs: it won’t need to queue unnecessarily, it can utilize all the optimizations it can muster, and it can avoid the unnecessary thread static accesses.</p><p><strong>Avoiding deadlocks.</strong> Consider a library method that uses <code>await</code> on the result of some network download. You invoke this method and synchronously block waiting for it to complete, such as by using <code>.Wait()</code> or <code>.Result</code> or <code>.GetAwaiter().GetResult()</code> off of the returned <code>Task</code> object. Now consider what happens if your invocation of it happens when the current <code>SynchronizationContext</code> is one that limits the number of operations that can be running on it to 1, whether explicitly via something like the <code>MaxConcurrencySynchronizationContext</code> shown earlier, or implicitly by this being a context that only has one thread that can be used, e.g. a UI thread. So you invoke the method on that one thread and then block it waiting for the operation to complete. The operation kicks off the network download and awaits it. Since by default awaiting a <code>Task</code> will capture the current <code>SynchronizationContext</code>, it does so, and when the network download completes, it queues back to the <code>SynchronizationContext</code> the callback that will invoke the remainder of the operation. But the only thread that can process the queued callback is currently blocked by your code blocking waiting on the operation to complete. And that operation won’t complete until the callback is processed. Deadlock! This can apply even when the context doesn’t limit the concurrency to just 1, but when the resources are limited in any fashion. Imagine the same situation, except using the <code>MaxConcurrencySynchronizationContext</code> with a limit of 4. And instead of making just one call to the operation, we queue to that context 4 invocations, each of which makes the call and blocks waiting for it to complete. We’ve now still blocked all of the resources while waiting for the async methods to complete, and the only thing that will allow those async methods to complete is if their callbacks can be processed by this context that’s already entirely consumed. Again, deadlock! If instead the library method had used <code>ConfigureAwait(false)</code>, it would not queue the callback back to the original context, avoiding the deadlock scenarios.</p><h3>Why would I want to use ConfigureAwait(true)?</h3><p>You wouldn’t, unless you were using it purely as an indication that you were purposefully not using <code>ConfigureAwait(false)</code> (e.g. to silence static analysis warnings or the like). <code>ConfigureAwait(true)</code> does nothing meaningful. When comparing <code>await task</code> with <code>await task.ConfigureAwait(true)</code>, they’re functionally identical. If you see <code>ConfigureAwait(true)</code> in production code, you can delete it without ill effect.</p><p>The <code>ConfigureAwait</code> method accepts a Boolean because there are some niche situations in which you want to pass in a variable to control the configuration. But the 99% use case is with a hardcoded false argument value, <code>ConfigureAwait(false)</code>.</p><h3>When should I use ConfigureAwait(false)?</h3><p>It depends: are you implementing application-level code or general-purpose library code?</p><p>When writing applications, you generally want the default behavior (which is why it is the default behavior). If an app model / environment (e.g. Windows Forms, WPF, ASP.NET Core, etc.) publishes a custom <code>SynchronizationContext</code>, there’s almost certainly a really good reason it does: it’s providing a way for code that cares about synchronization context to interact with the app model / environment appropriately. So if you’re writing an event handler in a Windows Forms app, writing a unit test in xunit, writing code in an ASP.NET MVC controller, whether or not the app model did in fact publish a <code>SynchronizationContext</code>, you want to use that <code>SynchronizationContext</code> if it exists. And that means the default / <code>ConfigureAwait(true)</code>. You make simple use of <code>await</code>, and the right things happen with regards to callbacks/continuations being posted back to the original context if one existed. This leads to the general guidance of: <strong>if you’re writing app-level code, <em>do not</em> use <code>ConfigureAwait(false)</code></strong>. If you think back to the Click event handler code example earlier in this post:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> async </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>string</span><span> text </span><span>=</span><span> await s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>);</span><span>
    downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> text</span><span>;</span><span>
</span><span>}</span></code></pre><p>the setting of <code>downloadBtn.Content = text</code> needs to be done back in the original context. If the code had violated this guideline and instead used <code>ConfigureAwait(false)</code> when it shouldn’t have:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> async </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>string</span><span> text </span><span>=</span><span> await s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>).</span><span>ConfigureAwait</span><span>(</span><span>false</span><span>);</span><span> </span><span>// bug</span><span>
    downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> text</span><span>;</span><span>
</span><span>}</span></code></pre><p>bad behavior will result. The same would go for code in a classic ASP.NET app reliant on <code>HttpContext.Current</code>; using <code>ConfigureAwait(false)</code> and then trying to use <code>HttpContext.Current</code> is likely going to result in problems.</p><p>In contrast, general-purpose libraries are “general purpose” in part because they don’t care about the environment in which they’re used. You can use them from a web app or from a client app or from a test, it doesn’t matter, as the library code is agnostic to the app model it might be used in. Being agnostic then also means that it’s not going to be doing anything that needs to interact with the app model in a particular way, e.g. it won’t be accessing UI controls, because a general-purpose library knows nothing about UI controls. Since we then don’t need to be running the code in any particular environment, we can avoid forcing continuations/callbacks back to the original context, and we do that by using <code>ConfigureAwait(false)</code> and gaining both the performance and reliability benefits it brings. This leads to the general guidance of: <strong>if you’re writing general-purpose library code, use <code>ConfigureAwait(false)</code></strong>. This is why, for example, you’ll see every (or almost every) <code>await</code> in the .NET Core runtime libraries using <code>ConfigureAwait(false)</code> on every <code>await</code>; with a few exceptions, in cases where it doesn’t it’s very likely a bug to be fixed. For example, <a href="https://github.com/dotnet/corefx/pull/38610" rel="noopener noreferrer" target="_blank">this PR</a> fixed a missing <code>ConfigureAwait(false)</code> call in <code>HttpClient</code>.</p><p>As with all guidance, of course, there can be exceptions, places where it doesn’t make sense. For example, one of the larger exemptions (or at least categories that requires thought) in general-purpose libraries is when those libraries have APIs that take delegates to be invoked. In such cases, the caller of the library is passing potentially app-level code to be invoked by the library, which then effectively renders those “general purpose” assumptions of the library moot. Consider, for example, an asynchronous version of LINQ’s Where method, e.g. <code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)</code>. Does <code>predicate</code> here need to be invoked back on the original <code>SynchronizationContext</code> of the caller? That’s up to the implementation of <code>WhereAsync</code> to decide, and it’s a reason it may choose not to use <code>ConfigureAwait(false)</code>.</p><p>Even with these special cases, the general guidance stands and is a very good starting point: use <code>ConfigureAwait(false)</code> if you’re writing general-purpose library / app-model-agnostic code, and otherwise don’t.</p><h3>Does ConfigureAwait(false) guarantee the callback won’t be run in the original context?</h3><p>No. It guarantees it won’t be queued back to the original context… but that doesn’t mean the code after an <code>await task.ConfigureAwait(false)</code> won’t still run in the original context. That’s because awaits on already-completed awaitables just keep running past the <code>await</code> synchronously rather than forcing anything to be queued back. So, if you <code>await</code> a task that’s already completed by the time it’s awaited, regardless of whether you used <code>ConfigureAwait(false)</code>, the code immediately after this will continue to execute on the current thread in whatever context is still current.</p><h3>Is it ok to use ConfigureAwait(false) only on the first await in my method and not on the rest?</h3><p>In general, no. See the previous FAQ. If the <code>await task.ConfigureAwait(false)</code> involves a task that’s already completed by the time it’s awaited (which is actually incredibly common), then the <code>ConfigureAwait(false)</code> will be meaningless, as the thread continues to execute code in the method after this and still in the same context that was there previously.</p><p>One notable exception to this is if you know that the first <code>await</code> will always complete asynchronously and the thing being awaited will invoke its callback in an environment free of a custom SynchronizationContext or a TaskScheduler. For example, <code>CryptoStream</code> in the .NET runtime libraries wants to ensure that its potentially computationally-intensive code doesn’t run as part of the caller’s synchronous invocation, so it <a href="https://github.com/dotnet/runtime/blob/4f9ae42d861fcb4be2fcd5d3d55d5f227d30e723/src/libraries/System.Security.Cryptography.Primitives/src/System/Security/Cryptography/CryptoStream.cs#L205" rel="noopener noreferrer" target="_blank">uses a custom awaiter</a> to ensure that everything after the first <code>await</code> runs on a thread pool thread. However, even in that case you’ll notice that the next <code>await</code> still uses <code>ConfigureAwait(false)</code>; technically that’s not necessary, but it makes code review a lot easier, as otherwise every time this code is looked at it doesn’t require an analysis to understand why <code>ConfigureAwait(false)</code> was left off.</p><h3>Can I use Task.Run to avoid using ConfigureAwait(false)?</h3><p>Yes. If you write:</p><pre><code><span>Task</span><span>.</span><span>Run</span><span>(</span><span>async </span><span>delegate</span><span>
</span><span>{</span><span>
    await </span><span>SomethingAsync</span><span>();</span><span> </span><span>// won't see the original context</span><span>
</span><span>});</span></code></pre><p>then a <code>ConfigureAwait(false)</code> on that <code>SomethingAsync()</code> call will be a nop, because the delegate passed to <code>Task.Run</code> is going to be executed on a thread pool thread, with no user code higher on the stack, such that <code>SynchronizationContext.Current</code> will return <code>null</code>. Further, <code>Task.Run</code> implicitly uses <code>TaskScheduler.Default</code>, which means querying <code>TaskScheduler.Current</code> inside of the delegate will also return <code>Default</code>. That means the <code>await</code> will exhibit the same behavior regardless of whether <code>ConfigureAwait(false)</code> was used. It also doesn’t make any guarantees about what code inside of this lambda might do. If you have the code:</p><pre><code><span>Task</span><span>.</span><span>Run</span><span>(</span><span>async </span><span>delegate</span><span>
</span><span>{</span><span>
    </span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>new</span><span> </span><span>SomeCoolSyncCtx</span><span>());</span><span>
    await </span><span>SomethingAsync</span><span>();</span><span> </span><span>// will target SomeCoolSyncCtx</span><span>
</span><span>});</span></code></pre><p>then the code inside <code>SomethingAsync</code> will in fact see <code>SynchronizationContext.Current</code> as that <code>SomeCoolSyncCtx</code> instance, and both this <code>await</code> and any non-configured awaits inside <code>SomethingAsync</code> will post back to it. So to use this approach, you need to understand what all of the code you’re queueing may or may not do and whether its actions could thwart yours.</p><p>This approach also comes at the expense of needing to create/queue an additional task object. That may or may not matter to your app or library depending on your performance sensitivity.</p><p>Also keep in mind that such tricks may cause more problems than they’re worth and have other unintended consequences. For example, static analysis tools (e.g. Roslyn analyzers) have been written to flag awaits that don’t use <code>ConfigureAwait(false)</code>, such as <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007?view=vs-2019" rel="noopener noreferrer" target="_blank">CA2007</a>. If you enable such an analyzer but then employ a trick like this just to avoid using <code>ConfigureAwait</code>, there’s a good chance the analyzer will flag it, and actually cause more work for you. So maybe you then disable the analyzer because of its noisiness, and now you end up missing other places in the codebase where you actually should have been using <code>ConfigureAwait(false)</code>.</p><h3>Can I use SynchronizationContext.SetSynchronizationContext to avoid using ConfigureAwait(false)?</h3><p>No. Well, maybe. It depends on the involved code.</p><p>Some developers write code like this:</p><pre><code><span>Task</span><span> t</span><span>;</span><span>
</span><span>SynchronizationContext</span><span> old </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
</span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>null</span><span>);</span><span>
</span><span>try</span><span>
</span><span>{</span><span>
    t </span><span>=</span><span> </span><span>CallCodeThatUsesAwaitAsync</span><span>();</span><span> </span><span>// awaits in here won't see the original context</span><span>
</span><span>}</span><span>
</span><span>finally</span><span> </span><span>{</span><span> </span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>old</span><span>);</span><span> </span><span>}</span><span>
await t</span><span>;</span><span> </span><span>// will still target the original context</span></code></pre><p>in hopes that it’ll make the code inside <code>CallCodeThatUsesAwaitAsync</code> see the current context as <code>null</code>. And it will. However, the above will do nothing to affect what the <code>await</code> sees for <code>TaskScheduler.Current</code>, so if this code is running on some custom <code>TaskScheduler</code>, <code>await</code>s inside <code>CallCodeThatUsesAwaitAsync</code> (and that don’t use <code>ConfigureAwait(false)</code>) will still see and queue back to that custom <code>TaskScheduler</code>.</p><p>All of the same caveats also apply as in the previous <code>Task.Run</code>-related FAQ: there are perf implications of such a workaround, and the code inside the try could also thwart these attempts by setting a different context (or invoking code with a non-default <code>TaskScheduler</code>).</p><p>With such a pattern, you also need to be careful about a slight variation:</p><pre><code><span>SynchronizationContext</span><span> old </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
</span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>null</span><span>);</span><span>
</span><span>try</span><span>
</span><span>{</span><span>
    await t</span><span>;</span><span>
</span><span>}</span><span>
</span><span>finally</span><span> </span><span>{</span><span> </span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>old</span><span>);</span><span> </span><span>}</span></code></pre><p>See the problem? It’s a bit hard to see but also potentially very impactful. There’s no guarantee that the <code>await</code> will end up invoking the callback/continuation on the original thread, which means the resetting of the <code>SynchronizationContext</code> back to the original may not actually happen on the original thread, which could lead subsequent work items on that thread to see the wrong context (to counteract this, well-written app models that set a custom context generally add code to manually reset it before invoking any further user code). And even if it does happen to run on the same thread, it may be a while before it does, such that the context won’t be appropriately restored for a while. And if it runs on a different thread, it could end up setting the wrong context onto that thread. And so on. Very far from ideal.</p><h3>I’m using GetAwaiter().GetResult(). Do I need to use ConfigureAwait(false)?</h3><p>No. <code>ConfigureAwait</code> only affects the callbacks. Specifically, the awaiter pattern requires awaiters to expose an <code>IsCompleted</code> property, a <code>GetResult</code> method, and an <code>OnCompleted</code> method (optionally with an <code>UnsafeOnCompleted</code> method). <code>ConfigureAwait</code> only affects the behavior of <code>{Unsafe}OnCompleted</code>, so if you’re just directly calling to the awaiter’s <code>GetResult()</code> method, whether you’re doing it on the <code>TaskAwaiter</code> or the <code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code> makes zero behavior difference. So, if you see <code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code> in code, you can replace it with <code>task.GetAwaiter().GetResult()</code> (and also consider whether you really want to be blocking like that).</p><h3>I know I’m running in an environment that will never have a custom SynchronizationContext or custom TaskScheduler. Can I skip using ConfigureAwait(false)?</h3><p>Maybe. It depends on how sure you are of the “never” part. As mentioned in previous FAQs, just because the app model you’re working in doesn’t set a custom <code>SynchronizationContext</code> and doesn’t invoke your code on a custom <code>TaskScheduler</code> doesn’t mean that some other user or library code doesn’t. So you need to be sure that’s not the case, or at least recognize the risk if it may be.</p><h3>I’ve heard ConfigureAwait(false) is no longer necessary in .NET Core. True?</h3><p>False. It’s needed when running on .NET Core for exactly the same reasons it’s needed when running on .NET Framework. Nothing’s changed in that regard.</p><p>What has changed, however, is whether certain environments publish their own <code>SynchronizationContext</code>. In particular, whereas the classic ASP.NET on .NET Framework has <a href="https://github.com/microsoft/referencesource/blob/3b1eaf5203992df69de44c783a3eda37d3d4cd10/System.Web/AspNetSynchronizationContextBase.cs" rel="noopener noreferrer" target="_blank">its own <code>SynchronizationContext</code></a>, in contrast ASP.NET Core does not. That means that code running in an ASP.NET Core app by default won’t see a custom <code>SynchronizationContext</code>, which lessens the need for <code>ConfigureAwait(false)</code> running in such an environment.</p><p>It doesn’t mean, however, that there will never be a custom <code>SynchronizationContext</code> or <code>TaskScheduler</code> present. If some user code (or other library code your app is using) sets a custom context and calls your code, or invokes your code in a <code>Task</code> scheduled to a custom <code>TaskScheduler</code>, then even in ASP.NET Core your awaits may see a non-default context or scheduler that would lead you to want to use <code>ConfigureAwait(false)</code>. Of course, in such situations, if you avoid synchronously blocking (which you should avoid doing in web apps regardless) and if you don’t mind the small performance overheads in such limited occurrences, you can probably get away without using <code>ConfigureAwait(false)</code>.</p><h3>Can I use ConfigureAwait when ‘await foreach’ing an IAsyncEnumerable<t>?</t></h3><p>Yes. See this <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="noopener noreferrer" target="_blank">MSDN Magazine article</a> for an example.</p><p><code>await foreach</code> binds to a pattern, and so while it can be used to enumerate an <code>IAsyncEnumerable&lt;T&gt;</code>, it can also be used to enumerate something that exposes the right API surface area. The .NET runtime libraries include a <code>ConfigureAwait</code> <a href="https://github.com/dotnet/runtime/blob/91a717450bf5faa44d9295c01f4204dc5010e95c/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/TaskAsyncEnumerableExtensions.cs#L25-L26" rel="noopener noreferrer" target="_blank">extension method</a> on <code>IAsyncEnumerable&lt;T&gt;</code> that returns a custom type that wraps the <code>IAsyncEnumerable&lt;T&gt;</code> and a <code>Boolean</code> and exposes the right pattern. When the compiler generates calls to the enumerator’s <code>MoveNextAsync</code> and <code>DisposeAsync</code> methods, those calls are to the returned configured enumerator struct type, and it in turns performs the awaits in the desired configured way.</p><h3>Can I use ConfigureAwait when ‘await using’ an IAsyncDisposable?</h3><p>Yes, though with a minor complication.</p><p>As with <code>IAsyncEnumerable&lt;T&gt;</code> described in the previous FAQ, the .NET runtime libraries expose a <code>ConfigureAwait</code> extension method on <code>IAsyncDisposable</code>, and <code>await using</code> will happily work with this as it implements the appropriate pattern (namely exposing an appropriate <code>DisposeAsync</code> method):</p><pre><code><span>await </span><span>using</span><span> </span><span>(</span><span>var</span><span> c </span><span>=</span><span> </span><span>new</span><span> </span><span>MyAsyncDisposableClass</span><span>().</span><span>ConfigureAwait</span><span>(</span><span>false</span><span>))</span><span>
</span><span>{</span><span>
    </span><span>...</span><span>
</span><span>}</span></code></pre><p>The problem here is that the type of <code>c</code> is now not <code>MyAsyncDisposableClass</code> but rather a <code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code>, which is the type returned from that <code>ConfigureAwait</code> extension method on <code>IAsyncDisposable</code>.</p><p>To get around that, you need to write one extra line:</p><pre><code><span>var</span><span> c </span><span>=</span><span> </span><span>new</span><span> </span><span>MyAsyncDisposableClass</span><span>();</span><span>
await </span><span>using</span><span> </span><span>(</span><span>c</span><span>.</span><span>ConfigureAwait</span><span>(</span><span>false</span><span>))</span><span>
</span><span>{</span><span>
    </span><span>...</span><span>
</span><span>}</span></code></pre><p>Now the type of <code>c</code> is again the desired <code>MyAsyncDisposableClass</code>. This also has the effect of increasing the scope of <code>c</code>; if that’s impactful, you can wrap the whole thing in braces.</p><h3>I used ConfigureAwait(false), but my AsyncLocal<t> still flowed to code after the await. Is that a bug?</t></h3><p>No, that is expected. <code>AsyncLocal&lt;T&gt;</code> data flows as part of <code>ExecutionContext</code>, which is separate from <code>SynchronizationContext</code>. Unless you’ve explicitly disabled <code>ExecutionContext</code> flow with <code>ExecutionContext.SuppressFlow()</code>, <code>ExecutionContext</code> (and thus <code>AsyncLocal&lt;T&gt;</code> data) will always flow across <code>await</code>s, regardless of whether <code>ConfigureAwait</code> is used to avoid capturing the original <code>SynchronizationContext</code>. For more information, see this <a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" rel="noopener noreferrer" target="_blank">blog post</a>.</p><h3>Could the language help me avoid needing to use ConfigureAwait(false) explicitly in my library?</h3><p>Library developers sometimes express their frustration with needing to use <code>ConfigureAwait(false)</code> and ask for less invasive alternatives.</p><p>Currently there aren’t any, at least not built into the language / compiler / runtime. There are however numerous proposals for what such a solution might look like, e.g. https://github.com/dotnet/csharplang/issues/645, https://github.com/dotnet/csharplang/issues/2542, https://github.com/dotnet/csharplang/issues/2649, and https://github.com/dotnet/csharplang/issues/2746.</p><p>If this is important to you, or if you feel like you have new and interesting ideas here, I encourage you to contribute your thoughts to those or new discussions.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>