<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ConfigureAwait FAQ | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="ConfigureAwait FAQ | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Stephen ToubFollow"/>
    <meta property="og:description" content=".NET added async/await to the languages and libraries over seven years ago. In that time, it&#x2019;s caught on like wildfire, not only across the .NET ecosystem, but also being replicated in a myriad of other languages and frameworks. It&#x2019;s also seen a ton of improvements in .NET,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/configureawait-faq/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - ConfigureAwait FAQ | .NET Blog</title>
<div class="readable">
        <h1>ConfigureAwait FAQ | .NET Blog</h1>
            <div>by Stephen ToubFollow</div>
            <div>Reading time: 31-39 minutes</div>
        <div>Posted here: 13 Dec 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/">https://devblogs.microsoft.com/dotnet/configureawait-faq/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/49e67eaea0533a547f3489aa03707bbb?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p></div></div></div><p>December 11th, 2019</p><p>.NET added <code>async</code>/<code>await</code> to the languages and libraries over seven years ago. In that time, it‚Äôs caught on like wildfire, not only across the .NET ecosystem, but also being replicated in a myriad of other languages and frameworks. It‚Äôs also seen a ton of improvements in .NET, in terms of additional language constructs that utilize asynchrony, APIs offering async support, and fundamental improvements in the infrastructure that makes <code>async</code>/<code>await</code> tick (in particular performance and diagnostic-enabling improvements in .NET Core).</p><p>However, one aspect of <code>async</code>/<code>await</code> that continues to draw questions is <code>ConfigureAwait</code>. In this post, I hope to answer many of them. I intend for this post to be both readable from start to finish as well as being a list of Frequently Asked Questions (FAQ) that can be used as future reference.</p><p>To really understand <code>ConfigureAwait</code>, we need to start a bit earlier‚Ä¶</p><h3>What is a SynchronizationContext?</h3><p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext" rel="noopener noreferrer" target="_blank"><code>System.Threading.SynchronizationContext</code> docs</a> state that it ‚ÄúProvides the basic functionality for propagating a synchronization context in various synchronization models.‚Äù Not an entirely obvious description.</p><p>For the 99.9% use case, <code>SynchronizationContext</code> is just a type that provides a virtual <code>Post</code> method, which takes a delegate to be executed asynchronously (there are a variety of other virtual members on <code>SynchronizationContext</code>, but they‚Äôre much less used and are irrelevant for this discussion). The base type‚Äôs <code>Post</code> literally <a href="https://github.com/dotnet/runtime/blob/5e67c2480d8b9361923566243c1395a3d1a5d617/src/libraries/System.Private.CoreLib/src/System/Threading/SynchronizationContext.cs#L25" rel="noopener noreferrer" target="_blank">just calls</a> <code>ThreadPool.QueueUserWorkItem</code> to asynchronously invoke the supplied delegate. However, derived types override <code>Post</code> to enable that delegate to be executed in the most appropriate place and at the most appropriate time.</p><p>For example, Windows Forms has a <a href="https://github.com/dotnet/winforms/blob/94ce4a2e52bf5d0d07d3d067297d60c8a17dc6b4/src/System.Windows.Forms/src/System/Windows/Forms/WindowsFormsSynchronizationContext.cs" rel="noopener noreferrer" target="_blank"><code>SynchronizationContext</code>-derived type</a> that overrides <code>Post</code> to do the equivalent of <code>Control.BeginInvoke</code>; that means any calls to its <code>Post</code> method will cause the delegate to be invoked at some later point on the thread associated with that relevant Control, aka ‚Äúthe UI thread‚Äù. Windows Forms relies on Win32 message handling and has a ‚Äúmessage loop‚Äù running on the UI thread, which simply sits waiting for new messages to arrive to process. Those messages could be for mouse movements and clicks, for keyboard typing, for system events, for delegates being available to invoke, etc. So, given a <code>SynchronizationContext</code> instance for the UI thread of a Windows Forms application, to get a delegate to execute on that UI thread, one simply needs to pass it to <code>Post</code>.</p><p>The same goes for Windows Presentation Foundation (WPF). It has its own <a href="https://github.com/dotnet/wpf/blob/ac9d1b7a6b0ee7c44fd2875a1174b820b3940619/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherSynchronizationContext.cs" rel="noopener noreferrer" target="_blank"><code>SynchronizationContext</code>-derived type</a> with a <code>Post</code> override that similarly ‚Äúmarshals‚Äù a delegate to the UI thread (via <code>Dispatcher.BeginInvoke</code>), in this case managed by a WPF Dispatcher rather than a Windows Forms Control.</p><p>And for Windows RunTime (WinRT). It has its own <a href="https://github.com/dotnet/runtime/blob/60d1224ddd68d8ac0320f439bb60ac1f0e9cdb27/src/libraries/System.Runtime.WindowsRuntime/src/System/Threading/WindowsRuntimeSynchronizationContext.cs" rel="noopener noreferrer" target="_blank"><code>SynchronizationContext</code>-derived type</a> with a <code>Post</code> override that also queues the delegate to the UI thread via its <code>CoreDispatcher</code>.</p><p>This goes beyond just ‚Äúrun this delegate on the UI thread‚Äù. Anyone can implement a <code>SynchronizationContext</code> with a <code>Post</code> that does anything. For example, I may not care what thread a delegate runs on, but I want to make sure that any delegates <code>Post</code>‚Äòd to my <code>SynchronizationContext</code> are executed with some limited degree of concurrency. I can achieve that with a custom <code>SynchronizationContext</code> like this:</p><pre><code><span>internal</span><span> </span><span>sealed</span><span> </span><span>class</span><span> </span><span>MaxConcurrencySynchronizationContext</span><span> </span><span>:</span><span> </span><span>SynchronizationContext</span><span>
</span><span>{</span><span>
    </span><span>private</span><span> </span><span>readonly</span><span> </span><span>SemaphoreSlim</span><span> _semaphore</span><span>;</span><span>

    </span><span>public</span><span> </span><span>MaxConcurrencySynchronizationContext</span><span>(</span><span>int</span><span> maxConcurrencyLevel</span><span>)</span><span> </span><span>=&gt;</span><span>
        _semaphore </span><span>=</span><span> </span><span>new</span><span> </span><span>SemaphoreSlim</span><span>(</span><span>maxConcurrencyLevel</span><span>);</span><span>

    </span><span>public</span><span> </span><span>override</span><span> </span><span>void</span><span> </span><span>Post</span><span>(</span><span>SendOrPostCallback</span><span> d</span><span>,</span><span> </span><span>object</span><span> state</span><span>)</span><span> </span><span>=&gt;</span><span>
        _semaphore</span><span>.</span><span>WaitAsync</span><span>().</span><span>ContinueWith</span><span>(</span><span>delegate</span><span>
        </span><span>{</span><span>
            </span><span>try</span><span> </span><span>{</span><span> d</span><span>(</span><span>state</span><span>);</span><span> </span><span>}</span><span> </span><span>finally</span><span> </span><span>{</span><span> _semaphore</span><span>.</span><span>Release</span><span>();</span><span> </span><span>}</span><span>
        </span><span>},</span><span> </span><span>default</span><span>,</span><span> </span><span>TaskContinuationOptions</span><span>.</span><span>None</span><span>,</span><span> </span><span>TaskScheduler</span><span>.</span><span>Default</span><span>);</span><span>

    </span><span>public</span><span> </span><span>override</span><span> </span><span>void</span><span> </span><span>Send</span><span>(</span><span>SendOrPostCallback</span><span> d</span><span>,</span><span> </span><span>object</span><span> state</span><span>)</span><span>
    </span><span>{</span><span>
        _semaphore</span><span>.</span><span>Wait</span><span>();</span><span>
        </span><span>try</span><span> </span><span>{</span><span> d</span><span>(</span><span>state</span><span>);</span><span> </span><span>}</span><span> </span><span>finally</span><span> </span><span>{</span><span> _semaphore</span><span>.</span><span>Release</span><span>();</span><span> </span><span>}</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>In fact, the unit testing framework xunit <a href="https://github.com/xunit/xunit/blob/d81613bf752bb4b8774e9d4e77b2b62133b0d333/src/xunit.execution/Sdk/MaxConcurrencySyncContext.cs" rel="noopener noreferrer" target="_blank">provides a <code>SynchronizationContext</code></a> very similar to this, which it uses to limit the amount of code associated with tests that can be run concurrently.</p><p>The benefit of all of this is the same as with any abstraction: it provides a single API that can be used to queue a delegate for handling however the creator of the implementation desires, without needing to know the details of that implementation. So, if I‚Äôm writing a library, and I want to go off and do some work, and then queue a delegate back to the original location‚Äôs ‚Äúcontext‚Äù, I just need to grab their <code>SynchronizationContext</code>, hold on to it, and then when I‚Äôm done with my work, call <code>Post</code> on that context to hand off the delegate I want invoked. I don‚Äôt need to know that for Windows Forms I should grab a <code>Control</code> and use its <code>BeginInvoke</code>, or for WPF I should grab a <code>Dispatcher</code> and uses its <code>BeginInvoke</code>, or for xunit I should somehow acquire its context and queue to it; I simply need to grab the current <code>SynchronizationContext</code> and use that later on. To achieve that, <code>SynchronizationContext</code> provides a <code>Current</code> property, such that to achieve the aforementioned objective I might write code like this:</p><pre><code><span>public</span><span> </span><span>void</span><span> </span><span>DoWork</span><span>(</span><span>Action</span><span> worker</span><span>,</span><span> </span><span>Action</span><span> completion</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>SynchronizationContext</span><span> sc </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
    </span><span>ThreadPool</span><span>.</span><span>QueueUserWorkItem</span><span>(</span><span>_ </span><span>=&gt;</span><span>
    </span><span>{</span><span>
        </span><span>try</span><span> </span><span>{</span><span> worker</span><span>();</span><span> </span><span>}</span><span>
        </span><span>finally</span><span> </span><span>{</span><span> sc</span><span>.</span><span>Post</span><span>(</span><span>_ </span><span>=&gt;</span><span> completion</span><span>(),</span><span> </span><span>null</span><span>);</span><span> </span><span>}</span><span>
    </span><span>});</span><span>
</span><span>}</span></code></pre><p>A framework that wants to expose a custom context from <code>Current</code> uses the <code>SynchronizationContext.SetSynchronizationContext</code> method.</p><h3>What is a TaskScheduler?</h3><p><code>SynchronizationContext</code> is a general abstraction for a ‚Äúscheduler‚Äù. Individual frameworks sometimes have their own abstractions for a scheduler, and <code>System.Threading.Tasks</code> is no exception. When <code>Task</code>s are backed by a delegate such that they can be queued and executed, they‚Äôre associated with a <code>System.Threading.Tasks.TaskScheduler</code>. Just as <code>SynchronizationContext</code> provides a virtual <code>Post</code> method to queue a delegate‚Äôs invocation (with the implementation later invoking the delegate via typical delegate invocation mechanisms), <code>TaskScheduler</code> provides an abstract <code>QueueTask</code> method (with the implementation later invoking that <code>Task</code> via the <code>ExecuteTask</code> method).</p><p>The default scheduler as returned by <code>TaskScheduler.Default</code> is the thread pool, but it‚Äôs possible to derive from <code>TaskScheduler</code> and override the relevant methods to achieve arbitrary behaviors for when and where a <code>Task</code> is invoked. For example, the core libraries include the <code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code> type. An instance of this class exposes two <code>TaskScheduler</code> properties, one called <code>ExclusiveScheduler</code> and one called <code>ConcurrentScheduler</code>. Tasks scheduled to the <code>ConcurrentScheduler</code> may run concurrently, but subject to a limit supplied to <code>ConcurrentExclusiveSchedulerPair</code> when it was constructed (similar to the <code>MaxConcurrencySynchronizationContext</code> shown earlier), and no <code>ConcurrentScheduler</code> <code>Task</code>s will run when a <code>Task</code> scheduled to <code>ExclusiveScheduler</code> is running, with only one exclusive <code>Task</code> allowed to run at a time‚Ä¶ in this way, it behaves very much like a reader/writer-lock.</p><p>Like <code>SynchronizationContext</code>, <code>TaskScheduler</code> also has a <code>Current</code> property, which returns the ‚Äúcurrent‚Äù <code>TaskScheduler</code>. Unlike <code>SynchronizationContext</code>, however, there‚Äôs no method for setting the current scheduler. Instead, the current scheduler is the one associated with the currently running <code>Task</code>, and a scheduler is provided to the system as part of starting a <code>Task</code>. So, for example, this program will output ‚ÄúTrue‚Äù, as the lambda used with <code>StartNew</code> is executed on the <code>ConcurrentExclusiveSchedulerPair</code>‚Äòs <code>ExclusiveScheduler</code> and will see <code>TaskScheduler.Current</code> set to that scheduler:</p><pre><code><span>using</span><span> </span><span>System</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Threading</span><span>.</span><span>Tasks</span><span>;</span><span>

</span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>()</span><span>
    </span><span>{</span><span>
        </span><span>var</span><span> cesp </span><span>=</span><span> </span><span>new</span><span> </span><span>ConcurrentExclusiveSchedulerPair</span><span>();</span><span>
        </span><span>Task</span><span>.</span><span>Factory</span><span>.</span><span>StartNew</span><span>(()</span><span> </span><span>=&gt;</span><span>
        </span><span>{</span><span>
            </span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>TaskScheduler</span><span>.</span><span>Current</span><span> </span><span>==</span><span> cesp</span><span>.</span><span>ExclusiveScheduler</span><span>);</span><span>
        </span><span>},</span><span> </span><span>default</span><span>,</span><span> </span><span>TaskCreationOptions</span><span>.</span><span>None</span><span>,</span><span> cesp</span><span>.</span><span>ExclusiveScheduler</span><span>).</span><span>Wait</span><span>();</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>Interestingly, <code>TaskScheduler</code> provides a static <code>FromCurrentSynchronizationContext</code> method, which creates a new <code>TaskScheduler</code> that queues <code>Task</code>s to run on whatever <code>SynchronizationContext.Current</code> returned, using its <code>Post</code> method for queueing tasks.</p><h3>How do SynchronizationContext and TaskScheduler relate to await?</h3><p>Consider writing a UI app with a <code>Button</code>. Upon clicking the <code>Button</code>, we want to download some text from a web site and set it as the <code>Button</code>‚Äòs <code>Content</code>. The <code>Button</code> should only be accessed from the UI thread that owns it, so when we‚Äôve successfully downloaded the new date and time text and want to store it back into the <code>Button</code>‚Äòs <code>Content</code>, we need to do so from the thread that owns the control. If we don‚Äôt, we get an exception like:</p><pre><code><span>System</span><span>.</span><span>InvalidOperationException</span><span>:</span><span> </span><span>'The calling thread cannot access this object because a different thread owns it.'</span></code></pre><p>If we were writing this out manually, we could use <code>SynchronizationContext</code> as shown earlier to marshal the setting of the <code>Content</code> back to the original context, such as via a <code>TaskScheduler</code>:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>).</span><span>ContinueWith</span><span>(</span><span>downloadTask </span><span>=&gt;</span><span>
    </span><span>{</span><span>
        downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> downloadTask</span><span>.</span><span>Result</span><span>;</span><span>
    </span><span>},</span><span> </span><span>TaskScheduler</span><span>.</span><span>FromCurrentSynchronizationContext</span><span>());</span><span>
</span><span>}</span></code></pre><p>or using <code>SynchronizationContext</code> directly:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>SynchronizationContext</span><span> sc </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
    s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>).</span><span>ContinueWith</span><span>(</span><span>downloadTask </span><span>=&gt;</span><span>
    </span><span>{</span><span>
        sc</span><span>.</span><span>Post</span><span>(</span><span>delegate</span><span>
        </span><span>{</span><span>
            downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> downloadTask</span><span>.</span><span>Result</span><span>;</span><span>
        </span><span>},</span><span> </span><span>null</span><span>);</span><span>
    </span><span>});</span><span>
</span><span>}</span></code></pre><p>Both of these approaches, though, explicitly uses callbacks. We would instead like to write the code naturally with <code>async</code>/<code>await</code>:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> async </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>string</span><span> text </span><span>=</span><span> await s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>);</span><span>
    downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> text</span><span>;</span><span>
</span><span>}</span></code></pre><p>This ‚Äújust works‚Äù, successfully setting <code>Content</code> on the UI thread, because just as with the manually implemented version above, <code>await</code>ing a <code>Task</code> pays attention by default to <code>SynchronizationContext.Current</code>, as well as to <code>TaskScheduler.Current</code>. When you <code>await</code> anything in C#, the compiler transforms the code to ask (via calling <code>GetAwaiter</code>) the ‚Äúawaitable‚Äù (in this case, the <code>Task</code>) for an ‚Äúawaiter‚Äù (in this case, a <code>TaskAwaiter&lt;string&gt;</code>). That awaiter is responsible for hooking up the callback (often referred to as the ‚Äúcontinuation‚Äù) that will call back into the state machine when the awaited object completes, and it does so using whatever context/scheduler it captured at the time the callback was registered. While not exactly the code used (there are additional optimizations and tweaks employed), it‚Äôs something like this:</p><pre><code><span>object</span><span> scheduler </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
</span><span>if</span><span> </span><span>(</span><span>scheduler </span><span>is</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> </span><span>TaskScheduler</span><span>.</span><span>Current</span><span> </span><span>!=</span><span> </span><span>TaskScheduler</span><span>.</span><span>Default</span><span>)</span><span>
</span><span>{</span><span>
    scheduler </span><span>=</span><span> </span><span>TaskScheduler</span><span>.</span><span>Current</span><span>;</span><span>
</span><span>}</span></code></pre><p>In other words, it first checks whether there‚Äôs a <code>SynchronizationContext</code> set, and if there isn‚Äôt, whether there‚Äôs a non-default <code>TaskScheduler</code> in play. If it finds one, when the callback is ready to be invoked, it‚Äôll use the captured scheduler; otherwise, it‚Äôll generally just execute the callback on as part of the operation completing the awaited task.</p><h3>What does ConfigureAwait(false) do?</h3><p>The <code>ConfigureAwait</code> method isn‚Äôt special: it‚Äôs not recognized in any special way by the compiler or by the runtime. It is simply a method that returns a struct (a <code>ConfiguredTaskAwaitable</code>) that wraps the original task it was called on as well as the specified Boolean value. Remember that <code>await</code> can be used with any type that exposes the right pattern. By returning a different type, it means that when the compiler accesses the instances <code>GetAwaiter</code> method (part of the pattern), it‚Äôs doing so off of the type returned from <code>ConfigureAwait</code> rather than off of the task directly, and that provides a hook to change the behavior of how the <code>await</code> behaves via this custom awaiter.</p><p>Specifically, awaiting the type returned from <code>ConfigureAwait(continueOnCapturedContext: false)</code> instead of awaiting the <code>Task</code> directly ends up impacting the logic shown earlier for how the target context/scheduler is captured. It effectively makes the previously shown logic more like this:</p><pre><code><span>object</span><span> scheduler </span><span>=</span><span> </span><span>null</span><span>;</span><span>
</span><span>if</span><span> </span><span>(</span><span>continueOnCapturedContext</span><span>)</span><span>
</span><span>{</span><span>
    scheduler </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
    </span><span>if</span><span> </span><span>(</span><span>scheduler </span><span>is</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> </span><span>TaskScheduler</span><span>.</span><span>Current</span><span> </span><span>!=</span><span> </span><span>TaskScheduler</span><span>.</span><span>Default</span><span>)</span><span>
    </span><span>{</span><span>
        scheduler </span><span>=</span><span> </span><span>TaskScheduler</span><span>.</span><span>Current</span><span>;</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>In other words, by specifying <code>false</code>, even if there is a current context or scheduler to call back to, it pretends as if there isn‚Äôt.</p><h3>Why would I want to use ConfigureAwait(false)?</h3><p><code>ConfigureAwait(continueOnCapturedContext: false)</code> is used to avoid forcing the callback to be invoked on the original context or scheduler. This has a few benefits:</p><p><strong>Improving performance.</strong> There is a cost to queueing the callback rather than just invoking it, both because there‚Äôs extra work (and typically extra allocation) involved, but also because it means certain optimizations we‚Äôd otherwise like to employ in the runtime can‚Äôt be used (we can do more optimization when we know exactly how the callback will be invoked, but if it‚Äôs handed off to an arbitrary implementation of an abstraction, we can sometimes be limited). For very hot paths, even the extra costs of checking for the current <code>SynchronizationContext</code> and the current <code>TaskScheduler</code> (both of which involve accessing thread statics) can add measurable overhead. If the code after an <code>await</code> doesn‚Äôt actually require running in the original context, using <code>ConfigureAwait(false)</code> can avoid all these costs: it won‚Äôt need to queue unnecessarily, it can utilize all the optimizations it can muster, and it can avoid the unnecessary thread static accesses.</p><p><strong>Avoiding deadlocks.</strong> Consider a library method that uses <code>await</code> on the result of some network download. You invoke this method and synchronously block waiting for it to complete, such as by using <code>.Wait()</code> or <code>.Result</code> or <code>.GetAwaiter().GetResult()</code> off of the returned <code>Task</code> object. Now consider what happens if your invocation of it happens when the current <code>SynchronizationContext</code> is one that limits the number of operations that can be running on it to 1, whether explicitly via something like the <code>MaxConcurrencySynchronizationContext</code> shown earlier, or implicitly by this being a context that only has one thread that can be used, e.g. a UI thread. So you invoke the method on that one thread and then block it waiting for the operation to complete. The operation kicks off the network download and awaits it. Since by default awaiting a <code>Task</code> will capture the current <code>SynchronizationContext</code>, it does so, and when the network download completes, it queues back to the <code>SynchronizationContext</code> the callback that will invoke the remainder of the operation. But the only thread that can process the queued callback is currently blocked by your code blocking waiting on the operation to complete. And that operation won‚Äôt complete until the callback is processed. Deadlock! This can apply even when the context doesn‚Äôt limit the concurrency to just 1, but when the resources are limited in any fashion. Imagine the same situation, except using the <code>MaxConcurrencySynchronizationContext</code> with a limit of 4. And instead of making just one call to the operation, we queue to that context 4 invocations, each of which makes the call and blocks waiting for it to complete. We‚Äôve now still blocked all of the resources while waiting for the async methods to complete, and the only thing that will allow those async methods to complete is if their callbacks can be processed by this context that‚Äôs already entirely consumed. Again, deadlock! If instead the library method had used <code>ConfigureAwait(false)</code>, it would not queue the callback back to the original context, avoiding the deadlock scenarios.</p><h3>Why would I want to use ConfigureAwait(true)?</h3><p>You wouldn‚Äôt, unless you were using it purely as an indication that you were purposefully not using <code>ConfigureAwait(false)</code> (e.g. to silence static analysis warnings or the like). <code>ConfigureAwait(true)</code> does nothing meaningful. When comparing <code>await task</code> with <code>await task.ConfigureAwait(true)</code>, they‚Äôre functionally identical. If you see <code>ConfigureAwait(true)</code> in production code, you can delete it without ill effect.</p><p>The <code>ConfigureAwait</code> method accepts a Boolean because there are some niche situations in which you want to pass in a variable to control the configuration. But the 99% use case is with a hardcoded false argument value, <code>ConfigureAwait(false)</code>.</p><h3>When should I use ConfigureAwait(false)?</h3><p>It depends: are you implementing application-level code or general-purpose library code?</p><p>When writing applications, you generally want the default behavior (which is why it is the default behavior). If an app model / environment (e.g. Windows Forms, WPF, ASP.NET Core, etc.) publishes a custom <code>SynchronizationContext</code>, there‚Äôs almost certainly a really good reason it does: it‚Äôs providing a way for code that cares about synchronization context to interact with the app model / environment appropriately. So if you‚Äôre writing an event handler in a Windows Forms app, writing a unit test in xunit, writing code in an ASP.NET MVC controller, whether or not the app model did in fact publish a <code>SynchronizationContext</code>, you want to use that <code>SynchronizationContext</code> if it exists. And that means the default / <code>ConfigureAwait(true)</code>. You make simple use of <code>await</code>, and the right things happen with regards to callbacks/continuations being posted back to the original context if one existed. This leads to the general guidance of: <strong>if you‚Äôre writing app-level code, <em>do not</em> use <code>ConfigureAwait(false)</code></strong>. If you think back to the Click event handler code example earlier in this post:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> async </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>string</span><span> text </span><span>=</span><span> await s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>);</span><span>
    downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> text</span><span>;</span><span>
</span><span>}</span></code></pre><p>the setting of <code>downloadBtn.Content = text</code> needs to be done back in the original context. If the code had violated this guideline and instead used <code>ConfigureAwait(false)</code> when it shouldn‚Äôt have:</p><pre><code><span>private</span><span> </span><span>static</span><span> </span><span>readonly</span><span> </span><span>HttpClient</span><span> s_httpClient </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>();</span><span>

</span><span>private</span><span> async </span><span>void</span><span> downloadBtn_Click</span><span>(</span><span>object</span><span> sender</span><span>,</span><span> </span><span>RoutedEventArgs</span><span> e</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>string</span><span> text </span><span>=</span><span> await s_httpClient</span><span>.</span><span>GetStringAsync</span><span>(</span><span>"http://example.com/currenttime"</span><span>).</span><span>ConfigureAwait</span><span>(</span><span>false</span><span>);</span><span> </span><span>// bug</span><span>
    downloadBtn</span><span>.</span><span>Content</span><span> </span><span>=</span><span> text</span><span>;</span><span>
</span><span>}</span></code></pre><p>bad behavior will result. The same would go for code in a classic ASP.NET app reliant on <code>HttpContext.Current</code>; using <code>ConfigureAwait(false)</code> and then trying to use <code>HttpContext.Current</code> is likely going to result in problems.</p><p>In contrast, general-purpose libraries are ‚Äúgeneral purpose‚Äù in part because they don‚Äôt care about the environment in which they‚Äôre used. You can use them from a web app or from a client app or from a test, it doesn‚Äôt matter, as the library code is agnostic to the app model it might be used in. Being agnostic then also means that it‚Äôs not going to be doing anything that needs to interact with the app model in a particular way, e.g. it won‚Äôt be accessing UI controls, because a general-purpose library knows nothing about UI controls. Since we then don‚Äôt need to be running the code in any particular environment, we can avoid forcing continuations/callbacks back to the original context, and we do that by using <code>ConfigureAwait(false)</code> and gaining both the performance and reliability benefits it brings. This leads to the general guidance of: <strong>if you‚Äôre writing general-purpose library code, use <code>ConfigureAwait(false)</code></strong>. This is why, for example, you‚Äôll see every (or almost every) <code>await</code> in the .NET Core runtime libraries using <code>ConfigureAwait(false)</code> on every <code>await</code>; with a few exceptions, in cases where it doesn‚Äôt it‚Äôs very likely a bug to be fixed. For example, <a href="https://github.com/dotnet/corefx/pull/38610" rel="noopener noreferrer" target="_blank">this PR</a> fixed a missing <code>ConfigureAwait(false)</code> call in <code>HttpClient</code>.</p><p>As with all guidance, of course, there can be exceptions, places where it doesn‚Äôt make sense. For example, one of the larger exemptions (or at least categories that requires thought) in general-purpose libraries is when those libraries have APIs that take delegates to be invoked. In such cases, the caller of the library is passing potentially app-level code to be invoked by the library, which then effectively renders those ‚Äúgeneral purpose‚Äù assumptions of the library moot. Consider, for example, an asynchronous version of LINQ‚Äôs Where method, e.g. <code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)</code>. Does <code>predicate</code> here need to be invoked back on the original <code>SynchronizationContext</code> of the caller? That‚Äôs up to the implementation of <code>WhereAsync</code> to decide, and it‚Äôs a reason it may choose not to use <code>ConfigureAwait(false)</code>.</p><p>Even with these special cases, the general guidance stands and is a very good starting point: use <code>ConfigureAwait(false)</code> if you‚Äôre writing general-purpose library / app-model-agnostic code, and otherwise don‚Äôt.</p><h3>Does ConfigureAwait(false) guarantee the callback won‚Äôt be run in the original context?</h3><p>No. It guarantees it won‚Äôt be queued back to the original context‚Ä¶ but that doesn‚Äôt mean the code after an <code>await task.ConfigureAwait(false)</code> won‚Äôt still run in the original context. That‚Äôs because awaits on already-completed awaitables just keep running past the <code>await</code> synchronously rather than forcing anything to be queued back. So, if you <code>await</code> a task that‚Äôs already completed by the time it‚Äôs awaited, regardless of whether you used <code>ConfigureAwait(false)</code>, the code immediately after this will continue to execute on the current thread in whatever context is still current.</p><h3>Is it ok to use ConfigureAwait(false) only on the first await in my method and not on the rest?</h3><p>In general, no. See the previous FAQ. If the <code>await task.ConfigureAwait(false)</code> involves a task that‚Äôs already completed by the time it‚Äôs awaited (which is actually incredibly common), then the <code>ConfigureAwait(false)</code> will be meaningless, as the thread continues to execute code in the method after this and still in the same context that was there previously.</p><p>One notable exception to this is if you know that the first <code>await</code> will always complete asynchronously and the thing being awaited will invoke its callback in an environment free of a custom SynchronizationContext or a TaskScheduler. For example, <code>CryptoStream</code> in the .NET runtime libraries wants to ensure that its potentially computationally-intensive code doesn‚Äôt run as part of the caller‚Äôs synchronous invocation, so it <a href="https://github.com/dotnet/runtime/blob/4f9ae42d861fcb4be2fcd5d3d55d5f227d30e723/src/libraries/System.Security.Cryptography.Primitives/src/System/Security/Cryptography/CryptoStream.cs#L205" rel="noopener noreferrer" target="_blank">uses a custom awaiter</a> to ensure that everything after the first <code>await</code> runs on a thread pool thread. However, even in that case you‚Äôll notice that the next <code>await</code> still uses <code>ConfigureAwait(false)</code>; technically that‚Äôs not necessary, but it makes code review a lot easier, as otherwise every time this code is looked at it doesn‚Äôt require an analysis to understand why <code>ConfigureAwait(false)</code> was left off.</p><h3>Can I use Task.Run to avoid using ConfigureAwait(false)?</h3><p>Yes. If you write:</p><pre><code><span>Task</span><span>.</span><span>Run</span><span>(</span><span>async </span><span>delegate</span><span>
</span><span>{</span><span>
    await </span><span>SomethingAsync</span><span>();</span><span> </span><span>// won't see the original context</span><span>
</span><span>});</span></code></pre><p>then a <code>ConfigureAwait(false)</code> on that <code>SomethingAsync()</code> call will be a nop, because the delegate passed to <code>Task.Run</code> is going to be executed on a thread pool thread, with no user code higher on the stack, such that <code>SynchronizationContext.Current</code> will return <code>null</code>. Further, <code>Task.Run</code> implicitly uses <code>TaskScheduler.Default</code>, which means querying <code>TaskScheduler.Current</code> inside of the delegate will also return <code>Default</code>. That means the <code>await</code> will exhibit the same behavior regardless of whether <code>ConfigureAwait(false)</code> was used. It also doesn‚Äôt make any guarantees about what code inside of this lambda might do. If you have the code:</p><pre><code><span>Task</span><span>.</span><span>Run</span><span>(</span><span>async </span><span>delegate</span><span>
</span><span>{</span><span>
    </span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>new</span><span> </span><span>SomeCoolSyncCtx</span><span>());</span><span>
    await </span><span>SomethingAsync</span><span>();</span><span> </span><span>// will target SomeCoolSyncCtx</span><span>
</span><span>});</span></code></pre><p>then the code inside <code>SomethingAsync</code> will in fact see <code>SynchronizationContext.Current</code> as that <code>SomeCoolSyncCtx</code> instance, and both this <code>await</code> and any non-configured awaits inside <code>SomethingAsync</code> will post back to it. So to use this approach, you need to understand what all of the code you‚Äôre queueing may or may not do and whether its actions could thwart yours.</p><p>This approach also comes at the expense of needing to create/queue an additional task object. That may or may not matter to your app or library depending on your performance sensitivity.</p><p>Also keep in mind that such tricks may cause more problems than they‚Äôre worth and have other unintended consequences. For example, static analysis tools (e.g. Roslyn analyzers) have been written to flag awaits that don‚Äôt use <code>ConfigureAwait(false)</code>, such as <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007?view=vs-2019" rel="noopener noreferrer" target="_blank">CA2007</a>. If you enable such an analyzer but then employ a trick like this just to avoid using <code>ConfigureAwait</code>, there‚Äôs a good chance the analyzer will flag it, and actually cause more work for you. So maybe you then disable the analyzer because of its noisiness, and now you end up missing other places in the codebase where you actually should have been using <code>ConfigureAwait(false)</code>.</p><h3>Can I use SynchronizationContext.SetSynchronizationContext to avoid using ConfigureAwait(false)?</h3><p>No. Well, maybe. It depends on the involved code.</p><p>Some developers write code like this:</p><pre><code><span>Task</span><span> t</span><span>;</span><span>
</span><span>SynchronizationContext</span><span> old </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
</span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>null</span><span>);</span><span>
</span><span>try</span><span>
</span><span>{</span><span>
    t </span><span>=</span><span> </span><span>CallCodeThatUsesAwaitAsync</span><span>();</span><span> </span><span>// awaits in here won't see the original context</span><span>
</span><span>}</span><span>
</span><span>finally</span><span> </span><span>{</span><span> </span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>old</span><span>);</span><span> </span><span>}</span><span>
await t</span><span>;</span><span> </span><span>// will still target the original context</span></code></pre><p>in hopes that it‚Äôll make the code inside <code>CallCodeThatUsesAwaitAsync</code> see the current context as <code>null</code>. And it will. However, the above will do nothing to affect what the <code>await</code> sees for <code>TaskScheduler.Current</code>, so if this code is running on some custom <code>TaskScheduler</code>, <code>await</code>s inside <code>CallCodeThatUsesAwaitAsync</code> (and that don‚Äôt use <code>ConfigureAwait(false)</code>) will still see and queue back to that custom <code>TaskScheduler</code>.</p><p>All of the same caveats also apply as in the previous <code>Task.Run</code>-related FAQ: there are perf implications of such a workaround, and the code inside the try could also thwart these attempts by setting a different context (or invoking code with a non-default <code>TaskScheduler</code>).</p><p>With such a pattern, you also need to be careful about a slight variation:</p><pre><code><span>SynchronizationContext</span><span> old </span><span>=</span><span> </span><span>SynchronizationContext</span><span>.</span><span>Current</span><span>;</span><span>
</span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>null</span><span>);</span><span>
</span><span>try</span><span>
</span><span>{</span><span>
    await t</span><span>;</span><span>
</span><span>}</span><span>
</span><span>finally</span><span> </span><span>{</span><span> </span><span>SynchronizationContext</span><span>.</span><span>SetSynchronizationContext</span><span>(</span><span>old</span><span>);</span><span> </span><span>}</span></code></pre><p>See the problem? It‚Äôs a bit hard to see but also potentially very impactful. There‚Äôs no guarantee that the <code>await</code> will end up invoking the callback/continuation on the original thread, which means the resetting of the <code>SynchronizationContext</code> back to the original may not actually happen on the original thread, which could lead subsequent work items on that thread to see the wrong context (to counteract this, well-written app models that set a custom context generally add code to manually reset it before invoking any further user code). And even if it does happen to run on the same thread, it may be a while before it does, such that the context won‚Äôt be appropriately restored for a while. And if it runs on a different thread, it could end up setting the wrong context onto that thread. And so on. Very far from ideal.</p><h3>I‚Äôm using GetAwaiter().GetResult(). Do I need to use ConfigureAwait(false)?</h3><p>No. <code>ConfigureAwait</code> only affects the callbacks. Specifically, the awaiter pattern requires awaiters to expose an <code>IsCompleted</code> property, a <code>GetResult</code> method, and an <code>OnCompleted</code> method (optionally with an <code>UnsafeOnCompleted</code> method). <code>ConfigureAwait</code> only affects the behavior of <code>{Unsafe}OnCompleted</code>, so if you‚Äôre just directly calling to the awaiter‚Äôs <code>GetResult()</code> method, whether you‚Äôre doing it on the <code>TaskAwaiter</code> or the <code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code> makes zero behavior difference. So, if you see <code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code> in code, you can replace it with <code>task.GetAwaiter().GetResult()</code> (and also consider whether you really want to be blocking like that).</p><h3>I know I‚Äôm running in an environment that will never have a custom SynchronizationContext or custom TaskScheduler. Can I skip using ConfigureAwait(false)?</h3><p>Maybe. It depends on how sure you are of the ‚Äúnever‚Äù part. As mentioned in previous FAQs, just because the app model you‚Äôre working in doesn‚Äôt set a custom <code>SynchronizationContext</code> and doesn‚Äôt invoke your code on a custom <code>TaskScheduler</code> doesn‚Äôt mean that some other user or library code doesn‚Äôt. So you need to be sure that‚Äôs not the case, or at least recognize the risk if it may be.</p><h3>I‚Äôve heard ConfigureAwait(false) is no longer necessary in .NET Core. True?</h3><p>False. It‚Äôs needed when running on .NET Core for exactly the same reasons it‚Äôs needed when running on .NET Framework. Nothing‚Äôs changed in that regard.</p><p>What has changed, however, is whether certain environments publish their own <code>SynchronizationContext</code>. In particular, whereas the classic ASP.NET on .NET Framework has <a href="https://github.com/microsoft/referencesource/blob/3b1eaf5203992df69de44c783a3eda37d3d4cd10/System.Web/AspNetSynchronizationContextBase.cs" rel="noopener noreferrer" target="_blank">its own <code>SynchronizationContext</code></a>, in contrast ASP.NET Core does not. That means that code running in an ASP.NET Core app by default won‚Äôt see a custom <code>SynchronizationContext</code>, which lessens the need for <code>ConfigureAwait(false)</code> running in such an environment.</p><p>It doesn‚Äôt mean, however, that there will never be a custom <code>SynchronizationContext</code> or <code>TaskScheduler</code> present. If some user code (or other library code your app is using) sets a custom context and calls your code, or invokes your code in a <code>Task</code> scheduled to a custom <code>TaskScheduler</code>, then even in ASP.NET Core your awaits may see a non-default context or scheduler that would lead you to want to use <code>ConfigureAwait(false)</code>. Of course, in such situations, if you avoid synchronously blocking (which you should avoid doing in web apps regardless) and if you don‚Äôt mind the small performance overheads in such limited occurrences, you can probably get away without using <code>ConfigureAwait(false)</code>.</p><h3>Can I use ConfigureAwait when ‚Äòawait foreach‚Äôing an IAsyncEnumerable<t>?</t></h3><p>Yes. See this <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="noopener noreferrer" target="_blank">MSDN Magazine article</a> for an example.</p><p><code>await foreach</code> binds to a pattern, and so while it can be used to enumerate an <code>IAsyncEnumerable&lt;T&gt;</code>, it can also be used to enumerate something that exposes the right API surface area. The .NET runtime libraries include a <code>ConfigureAwait</code> <a href="https://github.com/dotnet/runtime/blob/91a717450bf5faa44d9295c01f4204dc5010e95c/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/TaskAsyncEnumerableExtensions.cs#L25-L26" rel="noopener noreferrer" target="_blank">extension method</a> on <code>IAsyncEnumerable&lt;T&gt;</code> that returns a custom type that wraps the <code>IAsyncEnumerable&lt;T&gt;</code> and a <code>Boolean</code> and exposes the right pattern. When the compiler generates calls to the enumerator‚Äôs <code>MoveNextAsync</code> and <code>DisposeAsync</code> methods, those calls are to the returned configured enumerator struct type, and it in turns performs the awaits in the desired configured way.</p><h3>Can I use ConfigureAwait when ‚Äòawait using‚Äô an IAsyncDisposable?</h3><p>Yes, though with a minor complication.</p><p>As with <code>IAsyncEnumerable&lt;T&gt;</code> described in the previous FAQ, the .NET runtime libraries expose a <code>ConfigureAwait</code> extension method on <code>IAsyncDisposable</code>, and <code>await using</code> will happily work with this as it implements the appropriate pattern (namely exposing an appropriate <code>DisposeAsync</code> method):</p><pre><code><span>await </span><span>using</span><span> </span><span>(</span><span>var</span><span> c </span><span>=</span><span> </span><span>new</span><span> </span><span>MyAsyncDisposableClass</span><span>().</span><span>ConfigureAwait</span><span>(</span><span>false</span><span>))</span><span>
</span><span>{</span><span>
    </span><span>...</span><span>
</span><span>}</span></code></pre><p>The problem here is that the type of <code>c</code> is now not <code>MyAsyncDisposableClass</code> but rather a <code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code>, which is the type returned from that <code>ConfigureAwait</code> extension method on <code>IAsyncDisposable</code>.</p><p>To get around that, you need to write one extra line:</p><pre><code><span>var</span><span> c </span><span>=</span><span> </span><span>new</span><span> </span><span>MyAsyncDisposableClass</span><span>();</span><span>
await </span><span>using</span><span> </span><span>(</span><span>c</span><span>.</span><span>ConfigureAwait</span><span>(</span><span>false</span><span>))</span><span>
</span><span>{</span><span>
    </span><span>...</span><span>
</span><span>}</span></code></pre><p>Now the type of <code>c</code> is again the desired <code>MyAsyncDisposableClass</code>. This also has the effect of increasing the scope of <code>c</code>; if that‚Äôs impactful, you can wrap the whole thing in braces.</p><h3>I used ConfigureAwait(false), but my AsyncLocal<t> still flowed to code after the await. Is that a bug?</t></h3><p>No, that is expected. <code>AsyncLocal&lt;T&gt;</code> data flows as part of <code>ExecutionContext</code>, which is separate from <code>SynchronizationContext</code>. Unless you‚Äôve explicitly disabled <code>ExecutionContext</code> flow with <code>ExecutionContext.SuppressFlow()</code>, <code>ExecutionContext</code> (and thus <code>AsyncLocal&lt;T&gt;</code> data) will always flow across <code>await</code>s, regardless of whether <code>ConfigureAwait</code> is used to avoid capturing the original <code>SynchronizationContext</code>. For more information, see this <a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" rel="noopener noreferrer" target="_blank">blog post</a>.</p><h3>Could the language help me avoid needing to use ConfigureAwait(false) explicitly in my library?</h3><p>Library developers sometimes express their frustration with needing to use <code>ConfigureAwait(false)</code> and ask for less invasive alternatives.</p><p>Currently there aren‚Äôt any, at least not built into the language / compiler / runtime. There are however numerous proposals for what such a solution might look like, e.g. https://github.com/dotnet/csharplang/issues/645, https://github.com/dotnet/csharplang/issues/2542, https://github.com/dotnet/csharplang/issues/2649, and https://github.com/dotnet/csharplang/issues/2746.</p><p>If this is important to you, or if you feel like you have new and interesting ideas here, I encourage you to contribute your thoughts to those or new discussions.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>