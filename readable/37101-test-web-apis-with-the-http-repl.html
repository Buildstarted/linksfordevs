<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Test web APIs with the HTTP REPL -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Test web APIs with the HTTP REPL</h1><div><div id="main" class="content "><p>By <a href="https://twitter.com/Scott_Addie" data-linktype="external">Scott Addie</a></p><p>The HTTP Read-Eval-Print Loop (REPL) is:</p><ul><li>A lightweight, cross-platform command-line tool that's supported everywhere .NET Core is supported.</li><li>Used for making HTTP requests to test ASP.NET Core web APIs (and non-ASP.NET Core web APIs) and view their results.</li><li>Capable of testing web APIs hosted in any environment, including localhost and Azure App Service.</li></ul><p>The following <a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#74-supported-methods" data-linktype="external">HTTP verbs</a> are supported:</p><p>To follow along, <a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/web-api/http-repl/samples" data-linktype="external">view or download the sample ASP.NET Core web API</a> (<a href="../?view=aspnetcore-3.1#how-to-download-a-sample" data-linktype="relative-path">how to download</a>).</p><h2 id="prerequisites">Prerequisites</h2><h2 id="installation">Installation</h2><p>To install the HTTP REPL, run the following command:</p><pre><code class="lang-dotnetcli">dotnet tool install -g Microsoft.dotnet-httprepl
</code></pre><p>A <a href="/en-us/dotnet/core/tools/global-tools#install-a-global-tool" data-linktype="absolute-path">.NET Core Global Tool</a> is installed from the <a href="https://www.nuget.org/packages/Microsoft.dotnet-httprepl" data-linktype="external">Microsoft.dotnet-httprepl</a> NuGet package.</p><h2 id="usage">Usage</h2><p>After successful installation of the tool, run the following command to start the HTTP REPL:</p><pre><code class="lang-console">httprepl
</code></pre><p>To view the available HTTP REPL commands, run one of the following commands:</p><pre><code class="lang-console">httprepl -h
</code></pre><pre><code class="lang-console">httprepl --help
</code></pre><p>The following output is displayed:</p><pre><code class="lang-console">Usage:
  httprepl [&lt;BASE_ADDRESS&gt;] [options]

Arguments:
  &lt;BASE_ADDRESS&gt; - The initial base address for the REPL.

Options:
  -h|--help - Show help information.

Once the REPL starts, these commands are valid:

Setup Commands:
Use these commands to configure the tool for your API server

connect        Configures the directory structure and base address of the api server
set header     Sets or clears a header for all requests. e.g. `set header content-type application/json`

HTTP Commands:
Use these commands to execute requests against your application.

GET            get - Issues a GET request
POST           post - Issues a POST request
PUT            put - Issues a PUT request
DELETE         delete - Issues a DELETE request
PATCH          patch - Issues a PATCH request
HEAD           head - Issues a HEAD request
OPTIONS        options - Issues a OPTIONS request

Navigation Commands:
The REPL allows you to navigate your URL space and focus on specific APIs that you are working on.

set base       Set the base URI. e.g. `set base http://locahost:5000`
ls             Show all endpoints for the current path
cd             Append the given directory to the currently selected path, or move up a path when using `cd ..`

Shell Commands:
Use these commands to interact with the REPL shell.

clear          Removes all text from the shell
echo [on/off]  Turns request echoing on or off, show the request that was made when using request commands
exit           Exit the shell

REPL Customization Commands:
Use these commands to customize the REPL behavior.

pref [get/set] Allows viewing or changing preferences, e.g. 'pref set editor.command.default 'C:\\Program Files\\Microsoft VS Code\\Code.exe'`
run            Runs the script at the given path. A script is a set of commands that can be typed with one command per line
ui             Displays the Swagger UI page, if available, in the default browser

Use `help &lt;COMMAND&gt;` for more detail on an individual command. e.g. `help get`.
For detailed tool info, see https://aka.ms/http-repl-doc.
</code></pre><p>The HTTP REPL offers command completion. Pressing the <kbd>Tab</kbd> key iterates through the list of commands that complete the characters or API endpoint that you typed. The following sections outline the available CLI commands.</p><h2 id="connect-to-the-web-api">Connect to the web API</h2><p>Connect to a web API by running the following command:</p><pre><code class="lang-console">httprepl &lt;ROOT URI&gt;
</code></pre><p><code>&lt;ROOT URI&gt;</code> is the base URI for the web API. For example:</p><pre><code class="lang-console">httprepl https://localhost:5001
</code></pre><p>Alternatively, run the following command at any time while the HTTP REPL is running:</p><pre><code class="lang-console">connect &lt;ROOT URI&gt;
</code></pre><p>For example:</p><pre><code class="lang-console">(Disconnected)~ connect https://localhost:5001
</code></pre><h2 id="manually-point-to-the-swagger-document-for-the-web-api">Manually point to the Swagger document for the web API</h2><p>The connect command above will attempt to find the Swagger document automatically. If for some reason it is unable to do so, you can specify the URI of the Swagger document for the web API by using the <code>--swagger</code> option:</p><pre><code class="lang-console">connect &lt;ROOT URI&gt; --swagger &lt;SWAGGER URI&gt;
</code></pre><p>For example:</p><pre><code class="lang-console">(Disconnected)~ connect https://localhost:5001 --swagger /swagger/v1/swagger.json
</code></pre><h2 id="navigate-the-web-api">Navigate the web API</h2><h3 id="view-available-endpoints">View available endpoints</h3><p>To list the different endpoints (controllers) at the current path of the web API address, run the <code>ls</code> or <code>dir</code> command:</p><pre><code class="lang-console">https://localhot:5001/~ ls
</code></pre><p>The following output format is displayed:</p><pre><code class="lang-console">.        []
Fruits   [get|post]
People   [get|post]

https://localhost:5001/~
</code></pre><p>The preceding output indicates that there are two controllers available: <code>Fruits</code> and <code>People</code>. Both controllers support parameterless HTTP GET and POST operations.</p><p>Navigating into a specific controller reveals more detail. For example, the following command's output shows the <code>Fruits</code> controller also supports HTTP GET, PUT, and DELETE operations. Each of these operations expects an <code>id</code> parameter in the route:</p><pre><code class="lang-console">https://localhost:5001/fruits~ ls
.      [get|post]
..     []
{id}   [get|put|delete]

https://localhost:5001/fruits~
</code></pre><p>Alternatively, run the <code>ui</code> command to open the web API's Swagger UI page in a browser. For example:</p><pre><code class="lang-console">https://localhost:5001/~ ui
</code></pre><h3 id="navigate-to-an-endpoint">Navigate to an endpoint</h3><p>To navigate to a different endpoint on the web API, run the <code>cd</code> command:</p><pre><code class="lang-console">https://localhost:5001/~ cd people
</code></pre><p>The path following the <code>cd</code> command is case insensitive. The following output format is displayed:</p><pre><code class="lang-console">/people    [get|post]

https://localhost:5001/people~
</code></pre><h2 id="customize-the-http-repl">Customize the HTTP REPL</h2><p>The HTTP REPL's default <a href="#set-color-preferences" data-linktype="self-bookmark">colors</a> can be customized. Additionally, a <a href="#set-the-default-text-editor" data-linktype="self-bookmark">default text editor</a> can be defined. The HTTP REPL preferences are persisted across the current session and are honored in future sessions. Once modified, the preferences are stored in the following file:</p><div class="tabGroup" id="tabgroup_CeZOj-G++Q"><section id="tabpanel_CeZOj-G++Q_linux" role="tabpanel" data-tab="linux"><p><em>%HOME%/.httpreplprefs</em></p></section><section id="tabpanel_CeZOj-G++Q_macos" role="tabpanel" data-tab="macos" aria-hidden="true" hidden="hidden"><p><em>%HOME%/.httpreplprefs</em></p></section><section id="tabpanel_CeZOj-G++Q_windows" role="tabpanel" data-tab="windows" aria-hidden="true" hidden="hidden"><p><em>%USERPROFILE%\.httpreplprefs</em></p></section></div><p>The <em>.httpreplprefs</em> file is loaded on startup and not monitored for changes at runtime. Manual modifications to the file take effect only after restarting the tool.</p><h3 id="view-the-settings">View the settings</h3><p>To view the available settings, run the <code>pref get</code> command. For example:</p><pre><code class="lang-console">https://localhost:5001/~ pref get
</code></pre><p>The preceding command displays the available key-value pairs:</p><pre><code class="lang-console">colors.json=Green
colors.json.arrayBrace=BoldCyan
colors.json.comma=BoldYellow
colors.json.name=BoldMagenta
colors.json.nameSeparator=BoldWhite
colors.json.objectBrace=Cyan
colors.protocol=BoldGreen
colors.status=BoldYellow
</code></pre><h3 id="set-color-preferences">Set color preferences</h3><p>Response colorization is currently supported for JSON only. To customize the default HTTP REPL tool coloring, locate the key corresponding to the color to be changed. For instructions on how to find the keys, see the <a href="#view-the-settings" data-linktype="self-bookmark">View the settings</a> section. For example, change the <code>colors.json</code> key value from <code>Green</code> to <code>White</code> as follows:</p><pre><code class="lang-console">https://localhost:5001/people~ pref set colors.json White
</code></pre><p>Only the <a href="https://github.com/dotnet/HttpRepl/blob/01d5c3c3373e98fe566ff5ef8a17c571de880293/src/Microsoft.Repl/ConsoleHandling/AllowedColors.cs" data-linktype="external">allowed colors</a> may be used. Subsequent HTTP requests display output with the new coloring.</p><p>When specific color keys aren't set, more generic keys are considered. To demonstrate this fallback behavior, consider the following example:</p><ul><li>If <code>colors.json.name</code> doesn't have a value, <code>colors.json.string</code> is used.</li><li>If <code>colors.json.string</code> doesn't have a value, <code>colors.json.literal</code> is used.</li><li>If <code>colors.json.literal</code> doesn't have a value, <code>colors.json</code> is used.</li><li>If <code>colors.json</code> doesn't have a value, the command shell's default text color (<code>AllowedColors.None</code>) is used.</li></ul><h3 id="set-indentation-size">Set indentation size</h3><p>Response indentation size customization is currently supported for JSON only. The default size is two spaces. For example:</p><pre><code class="lang-json">[
  {
    "id": 1,
    "name": "Apple"
  },
  {
    "id": 2,
    "name": "Orange"
  },
  {
    "id": 3,
    "name": "Strawberry"
  }
]
</code></pre><p>To change the default size, set the <code>formatting.json.indentSize</code> key. For example, to always use four spaces:</p><pre><code class="lang-console">pref set formatting.json.indentSize 4
</code></pre><p>Subsequent responses honor the setting of four spaces:</p><pre><code class="lang-json">[
    {
        "id": 1,
        "name": "Apple"
    },
    {
        "id": 2,
        "name": "Orange"
    },
    {
        "id": 3,
        "name": "Strawberry"
    }
]
</code></pre><h3 id="set-the-default-text-editor">Set the default text editor</h3><p>By default, the HTTP REPL has no text editor configured for use. To test web API methods requiring an HTTP request body, a default text editor must be set. The HTTP REPL tool launches the configured text editor for the sole purpose of composing the request body. Run the following command to set your preferred text editor as the default:</p><pre><code class="lang-console">pref set editor.command.default "&lt;EXECUTABLE&gt;"
</code></pre><p>In the preceding command, <code>&lt;EXECUTABLE&gt;</code> is the full path to the text editor's executable file. For example, run the following command to set Visual Studio Code as the default text editor:</p><div class="tabGroup" id="tabgroup_CeZOj-G++Q-1"><section id="tabpanel_CeZOj-G++Q-1_linux" role="tabpanel" data-tab="linux"><pre><code class="lang-console">pref set editor.command.default "/usr/bin/code"
</code></pre></section><section id="tabpanel_CeZOj-G++Q-1_macos" role="tabpanel" data-tab="macos" aria-hidden="true" hidden="hidden"><pre><code class="lang-console">pref set editor.command.default "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code"
</code></pre></section><section id="tabpanel_CeZOj-G++Q-1_windows" role="tabpanel" data-tab="windows" aria-hidden="true" hidden="hidden"><pre><code class="lang-console">pref set editor.command.default "C:\Program Files\Microsoft VS Code\Code.exe"
</code></pre></section></div><p>To launch the default text editor with specific CLI arguments, set the <code>editor.command.default.arguments</code> key. For example, assume Visual Studio Code is the default text editor and that you always want the HTTP REPL to open Visual Studio Code in a new session with extensions disabled. Run the following command:</p><pre><code class="lang-console">pref set editor.command.default.arguments "--disable-extensions --new-window"
</code></pre><h3 id="set-the-swagger-search-paths">Set the Swagger search paths</h3><p>By default, the HTTP REPL has a set of relative paths that it uses to find the Swagger document when executing the <code>connect</code> command without the <code>--swagger</code> option. These relative paths are combined with the root and base paths specified in the <code>connect</code> command. The default relative paths are:</p><ul><li><em>swagger.json</em></li><li><em>swagger/v1/swagger.json</em></li><li><em>/swagger.json</em></li><li><em>/swagger/v1/swagger.json</em></li></ul><p>To use a different set of search paths in your environment, set the <code>swagger.searchPaths</code> preference. The value must be a pipe-delimited list of relative paths. For example:</p><pre><code class="lang-console">pref set swagger.searchPaths "swagger/v2/swagger.json|swagger/v3/swagger.json"
</code></pre><h2 id="test-http-get-requests">Test HTTP GET requests</h2><h3 id="synopsis">Synopsis</h3><pre><code class="lang-console">get &lt;PARAMETER&gt; [-F|--no-formatting] [-h|--header] [--response] [--response:body] [--response:headers] [-s|--streaming]
</code></pre><h3 id="arguments">Arguments</h3><p><code>PARAMETER</code></p><p>The route parameter, if any, expected by the associated controller action method.</p><h3 id="options">Options</h3><p>The following options are available for the <code>get</code> command:</p><ul><li><p><code>-F|--no-formatting</code></p><p>A flag whose presence suppresses HTTP response formatting.</p></li><li><p><code>-h|--header</code></p><p>Sets an HTTP request header. The following two value formats are supported:</p><ul><li><code>{header}={value}</code></li><li><code>{header}:{value}</code></li></ul></li><li><p><code>--response</code></p><p>Specifies a file to which the entire HTTP response (including headers and body) should be written. For example, <code>--response "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:body</code></p><p>Specifies a file to which the HTTP response body should be written. For example, <code>--response:body "C:\response.json"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:headers</code></p><p>Specifies a file to which the HTTP response headers should be written. For example, <code>--response:headers "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>-s|--streaming</code></p><p>A flag whose presence enables streaming of the HTTP response.</p></li></ul><h3 id="example">Example</h3><p>To issue an HTTP GET request:</p><ol><li><p>Run the <code>get</code> command on an endpoint that supports it:</p><pre><code class="lang-console">https://localhost:5001/people~ get
</code></pre><p>The preceding command displays the following output format:</p><pre><code class="lang-console">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Fri, 21 Jun 2019 03:38:45 GMT
Server: Kestrel
Transfer-Encoding: chunked

[
  {
    "id": 1,
    "name": "Scott Hunter"
  },
  {
    "id": 2,
    "name": "Scott Hanselman"
  },
  {
    "id": 3,
    "name": "Scott Guthrie"
  }
]


https://localhost:5001/people~
</code></pre></li><li><p>Retrieve a specific record by passing a parameter to the <code>get</code> command:</p><pre><code class="lang-console">https://localhost:5001/people~ get 2
</code></pre><p>The preceding command displays the following output format:</p><pre><code class="lang-console">HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Fri, 21 Jun 2019 06:17:57 GMT
Server: Kestrel
Transfer-Encoding: chunked

[
  {
    "id": 2,
    "name": "Scott Hanselman"
  }
]


https://localhost:5001/people~
</code></pre></li></ol><h2 id="test-http-post-requests">Test HTTP POST requests</h2><h3 id="synopsis-1">Synopsis</h3><pre><code class="lang-console">post &lt;PARAMETER&gt; [-c|--content] [-f|--file] [-h|--header] [--no-body] [-F|--no-formatting] [--response] [--response:body] [--response:headers] [-s|--streaming]
</code></pre><h3 id="arguments-1">Arguments</h3><p><code>PARAMETER</code></p><p>The route parameter, if any, expected by the associated controller action method.</p><h3 id="options-1">Options</h3><ul><li><p><code>-F|--no-formatting</code></p><p>A flag whose presence suppresses HTTP response formatting.</p></li><li><p><code>-h|--header</code></p><p>Sets an HTTP request header. The following two value formats are supported:</p><ul><li><code>{header}={value}</code></li><li><code>{header}:{value}</code></li></ul></li><li><p><code>--response</code></p><p>Specifies a file to which the entire HTTP response (including headers and body) should be written. For example, <code>--response "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:body</code></p><p>Specifies a file to which the HTTP response body should be written. For example, <code>--response:body "C:\response.json"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:headers</code></p><p>Specifies a file to which the HTTP response headers should be written. For example, <code>--response:headers "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>-s|--streaming</code></p><p>A flag whose presence enables streaming of the HTTP response.</p></li></ul><ul><li><p><code>-c|--content</code></p><p>Provides an inline HTTP request body. For example, <code>-c "{"id":2,"name":"Cherry"}"</code>.</p></li><li><p><code>-f|--file</code></p><p>Provides a path to a file containing the HTTP request body. For example, <code>-f "C:\request.json"</code>.</p></li><li><p><code>--no-body</code></p><p>Indicates that no HTTP request body is needed.</p></li></ul><h3 id="example-1">Example</h3><p>To issue an HTTP POST request:</p><ol><li><p>Run the <code>post</code> command on an endpoint that supports it:</p><pre><code class="lang-console">https://localhost:5001/people~ post -h Content-Type=application/json
</code></pre><p>In the preceding command, the <code>Content-Type</code> HTTP request header is set to indicate a request body media type of JSON. The default text editor opens a <em>.tmp</em> file with a JSON template representing the HTTP request body. For example:</p><pre><code class="lang-json">{
  "id": 0,
  "name": ""
}
</code></pre></li><li><p>Modify the JSON template to satisfy model validation requirements:</p><pre><code class="lang-json">{
  "id": 0,
  "name": "Scott Addie"
}
</code></pre></li><li><p>Save the <em>.tmp</em> file, and close the text editor. The following output appears in the command shell:</p><pre><code class="lang-console">HTTP/1.1 201 Created
Content-Type: application/json; charset=utf-8
Date: Thu, 27 Jun 2019 21:24:18 GMT
Location: https://localhost:5001/people/4
Server: Kestrel
Transfer-Encoding: chunked

{
  "id": 4,
  "name": "Scott Addie"
}


https://localhost:5001/people~
</code></pre></li></ol><h2 id="test-http-put-requests">Test HTTP PUT requests</h2><h3 id="synopsis-2">Synopsis</h3><pre><code class="lang-console">put &lt;PARAMETER&gt; [-c|--content] [-f|--file] [-h|--header] [--no-body] [-F|--no-formatting] [--response] [--response:body] [--response:headers] [-s|--streaming]
</code></pre><h3 id="arguments-2">Arguments</h3><p><code>PARAMETER</code></p><p>The route parameter, if any, expected by the associated controller action method.</p><h3 id="options-2">Options</h3><ul><li><p><code>-F|--no-formatting</code></p><p>A flag whose presence suppresses HTTP response formatting.</p></li><li><p><code>-h|--header</code></p><p>Sets an HTTP request header. The following two value formats are supported:</p><ul><li><code>{header}={value}</code></li><li><code>{header}:{value}</code></li></ul></li><li><p><code>--response</code></p><p>Specifies a file to which the entire HTTP response (including headers and body) should be written. For example, <code>--response "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:body</code></p><p>Specifies a file to which the HTTP response body should be written. For example, <code>--response:body "C:\response.json"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:headers</code></p><p>Specifies a file to which the HTTP response headers should be written. For example, <code>--response:headers "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>-s|--streaming</code></p><p>A flag whose presence enables streaming of the HTTP response.</p></li></ul><ul><li><p><code>-c|--content</code></p><p>Provides an inline HTTP request body. For example, <code>-c "{"id":2,"name":"Cherry"}"</code>.</p></li><li><p><code>-f|--file</code></p><p>Provides a path to a file containing the HTTP request body. For example, <code>-f "C:\request.json"</code>.</p></li><li><p><code>--no-body</code></p><p>Indicates that no HTTP request body is needed.</p></li></ul><h3 id="example-2">Example</h3><p>To issue an HTTP PUT request:</p><ol><li><p><em>Optional</em>: Run the <code>get</code> command to view the data before modifying it:</p><pre><code class="lang-console">https://localhost:5001/fruits~ get
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Sat, 22 Jun 2019 00:07:32 GMT
Server: Kestrel
Transfer-Encoding: chunked

[
  {
    "id": 1,
    "data": "Apple"
  },
  {
    "id": 2,
    "data": "Orange"
  },
  {
    "id": 3,
    "data": "Strawberry"
  }
]
</code></pre></li><li><p>Run the <code>put</code> command on an endpoint that supports it:</p><pre><code class="lang-console">https://localhost:5001/fruits~ put 2 -h Content-Type=application/json
</code></pre><p>In the preceding command, the <code>Content-Type</code> HTTP request header is set to indicate a request body media type of JSON. The default text editor opens a <em>.tmp</em> file with a JSON template representing the HTTP request body. For example:</p><pre><code class="lang-json">{
  "id": 0,
  "name": ""
}
</code></pre></li><li><p>Modify the JSON template to satisfy model validation requirements:</p><pre><code class="lang-json">{
  "id": 2,
  "name": "Cherry"
}
</code></pre></li><li><p>Save the <em>.tmp</em> file, and close the text editor. The following output appears in the command shell:</p><pre><code class="lang-console">[main 2019-06-28T17:27:01.805Z] update#setState idle
HTTP/1.1 204 No Content
Date: Fri, 28 Jun 2019 17:28:21 GMT
Server: Kestrel
</code></pre></li><li><p><em>Optional</em>: Issue a <code>get</code> command to see the modifications. For example, if you typed "Cherry" in the text editor, a <code>get</code> returns the following:</p><pre><code class="lang-console">https://localhost:5001/fruits~ get
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Sat, 22 Jun 2019 00:08:20 GMT
Server: Kestrel
Transfer-Encoding: chunked

[
  {
    "id": 1,
    "data": "Apple"
  },
  {
    "id": 2,
    "data": "Cherry"
  },
  {
    "id": 3,
    "data": "Strawberry"
  }
]


https://localhost:5001/fruits~
</code></pre></li></ol><h2 id="test-http-delete-requests">Test HTTP DELETE requests</h2><h3 id="synopsis-3">Synopsis</h3><pre><code class="lang-console">delete &lt;PARAMETER&gt; [-F|--no-formatting] [-h|--header] [--response] [--response:body] [--response:headers] [-s|--streaming]
</code></pre><h3 id="arguments-3">Arguments</h3><p><code>PARAMETER</code></p><p>The route parameter, if any, expected by the associated controller action method.</p><h3 id="options-3">Options</h3><ul><li><p><code>-F|--no-formatting</code></p><p>A flag whose presence suppresses HTTP response formatting.</p></li><li><p><code>-h|--header</code></p><p>Sets an HTTP request header. The following two value formats are supported:</p><ul><li><code>{header}={value}</code></li><li><code>{header}:{value}</code></li></ul></li><li><p><code>--response</code></p><p>Specifies a file to which the entire HTTP response (including headers and body) should be written. For example, <code>--response "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:body</code></p><p>Specifies a file to which the HTTP response body should be written. For example, <code>--response:body "C:\response.json"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:headers</code></p><p>Specifies a file to which the HTTP response headers should be written. For example, <code>--response:headers "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>-s|--streaming</code></p><p>A flag whose presence enables streaming of the HTTP response.</p></li></ul><h3 id="example-3">Example</h3><p>To issue an HTTP DELETE request:</p><ol><li><p><em>Optional</em>: Run the <code>get</code> command to view the data before modifying it:</p><pre><code class="lang-console">https://localhost:5001/fruits~ get
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Sat, 22 Jun 2019 00:07:32 GMT
Server: Kestrel
Transfer-Encoding: chunked

[
  {
    "id": 1,
    "data": "Apple"
  },
  {
    "id": 2,
    "data": "Orange"
  },
  {
    "id": 3,
    "data": "Strawberry"
  }
]
</code></pre></li><li><p>Run the <code>delete</code> command on an endpoint that supports it:</p><pre><code class="lang-console">https://localhost:5001/fruits~ delete 2
</code></pre><p>The preceding command displays the following output format:</p><pre><code class="lang-console">HTTP/1.1 204 No Content
Date: Fri, 28 Jun 2019 17:36:42 GMT
Server: Kestrel
</code></pre></li><li><p><em>Optional</em>: Issue a <code>get</code> command to see the modifications. In this example, a <code>get</code> returns the following:</p><pre><code class="lang-console">https://localhost:5001/fruits~ get
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Sat, 22 Jun 2019 00:16:30 GMT
Server: Kestrel
Transfer-Encoding: chunked

[
  {
    "id": 1,
    "data": "Apple"
  },
  {
    "id": 3,
    "data": "Strawberry"
  }
]


https://localhost:5001/fruits~
</code></pre></li></ol><h2 id="test-http-patch-requests">Test HTTP PATCH requests</h2><h3 id="synopsis-4">Synopsis</h3><pre><code class="lang-console">patch &lt;PARAMETER&gt; [-c|--content] [-f|--file] [-h|--header] [--no-body] [-F|--no-formatting] [--response] [--response:body] [--response:headers] [-s|--streaming]
</code></pre><h3 id="arguments-4">Arguments</h3><p><code>PARAMETER</code></p><p>The route parameter, if any, expected by the associated controller action method.</p><h3 id="options-4">Options</h3><ul><li><p><code>-F|--no-formatting</code></p><p>A flag whose presence suppresses HTTP response formatting.</p></li><li><p><code>-h|--header</code></p><p>Sets an HTTP request header. The following two value formats are supported:</p><ul><li><code>{header}={value}</code></li><li><code>{header}:{value}</code></li></ul></li><li><p><code>--response</code></p><p>Specifies a file to which the entire HTTP response (including headers and body) should be written. For example, <code>--response "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:body</code></p><p>Specifies a file to which the HTTP response body should be written. For example, <code>--response:body "C:\response.json"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:headers</code></p><p>Specifies a file to which the HTTP response headers should be written. For example, <code>--response:headers "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>-s|--streaming</code></p><p>A flag whose presence enables streaming of the HTTP response.</p></li></ul><ul><li><p><code>-c|--content</code></p><p>Provides an inline HTTP request body. For example, <code>-c "{"id":2,"name":"Cherry"}"</code>.</p></li><li><p><code>-f|--file</code></p><p>Provides a path to a file containing the HTTP request body. For example, <code>-f "C:\request.json"</code>.</p></li><li><p><code>--no-body</code></p><p>Indicates that no HTTP request body is needed.</p></li></ul><h2 id="test-http-head-requests">Test HTTP HEAD requests</h2><h3 id="synopsis-5">Synopsis</h3><pre><code class="lang-console">head &lt;PARAMETER&gt; [-F|--no-formatting] [-h|--header] [--response] [--response:body] [--response:headers] [-s|--streaming]
</code></pre><h3 id="arguments-5">Arguments</h3><p><code>PARAMETER</code></p><p>The route parameter, if any, expected by the associated controller action method.</p><h3 id="options-5">Options</h3><ul><li><p><code>-F|--no-formatting</code></p><p>A flag whose presence suppresses HTTP response formatting.</p></li><li><p><code>-h|--header</code></p><p>Sets an HTTP request header. The following two value formats are supported:</p><ul><li><code>{header}={value}</code></li><li><code>{header}:{value}</code></li></ul></li><li><p><code>--response</code></p><p>Specifies a file to which the entire HTTP response (including headers and body) should be written. For example, <code>--response "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:body</code></p><p>Specifies a file to which the HTTP response body should be written. For example, <code>--response:body "C:\response.json"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:headers</code></p><p>Specifies a file to which the HTTP response headers should be written. For example, <code>--response:headers "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>-s|--streaming</code></p><p>A flag whose presence enables streaming of the HTTP response.</p></li></ul><h2 id="test-http-options-requests">Test HTTP OPTIONS requests</h2><h3 id="synopsis-6">Synopsis</h3><pre><code class="lang-console">options &lt;PARAMETER&gt; [-F|--no-formatting] [-h|--header] [--response] [--response:body] [--response:headers] [-s|--streaming]
</code></pre><h3 id="arguments-6">Arguments</h3><p><code>PARAMETER</code></p><p>The route parameter, if any, expected by the associated controller action method.</p><h3 id="options-6">Options</h3><ul><li><p><code>-F|--no-formatting</code></p><p>A flag whose presence suppresses HTTP response formatting.</p></li><li><p><code>-h|--header</code></p><p>Sets an HTTP request header. The following two value formats are supported:</p><ul><li><code>{header}={value}</code></li><li><code>{header}:{value}</code></li></ul></li><li><p><code>--response</code></p><p>Specifies a file to which the entire HTTP response (including headers and body) should be written. For example, <code>--response "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:body</code></p><p>Specifies a file to which the HTTP response body should be written. For example, <code>--response:body "C:\response.json"</code>. The file is created if it doesn't exist.</p></li><li><p><code>--response:headers</code></p><p>Specifies a file to which the HTTP response headers should be written. For example, <code>--response:headers "C:\response.txt"</code>. The file is created if it doesn't exist.</p></li><li><p><code>-s|--streaming</code></p><p>A flag whose presence enables streaming of the HTTP response.</p></li></ul><p>To set an HTTP request header, use one of the following approaches:</p><ul><li><p>Set inline with the HTTP request. For example:</p><pre><code class="lang-console">https://localhost:5001/people~ post -h Content-Type=application/json
</code></pre><p>With the preceding approach, each distinct HTTP request header requires its own <code>-h</code> option.</p></li><li><p>Set before sending the HTTP request. For example:</p><pre><code class="lang-console">https://localhost:5001/people~ set header Content-Type application/json
</code></pre><p>When setting the header before sending a request, the header remains set for the duration of the command shell session. To clear the header, provide an empty value. For example:</p><pre><code class="lang-console">https://localhost:5001/people~ set header Content-Type
</code></pre></li></ul><h2 id="test-secured-endpoints">Test secured endpoints</h2><p>The HTTP REPL supports the testing of secured endpoints through the use of HTTP request headers. Examples of supported authentication and authorization schemes include basic authentication, JWT bearer tokens, and digest authentication. For example, you can send a bearer token to an endpoint with the following command:</p><pre><code class="lang-console">set header Authorization "bearer &lt;TOKEN VALUE&gt;"
</code></pre><p>To access an Azure-hosted endpoint or to use the <a href="/en-us/rest/api/azure/" data-linktype="absolute-path">Azure REST API</a>, you need a bearer token. Use the following steps to obtain a bearer token for your Azure subscription via the <a href="/en-us/cli/azure/" data-linktype="absolute-path">Azure CLI</a>. The HTTP REPL sets the bearer token in an HTTP request header and retrieves a list of Azure App Service Web Apps.</p><ol><li><p>Log in to Azure:</p><pre><code class="lang-azcli">az login
</code></pre></li><li><p>Get your subscription ID with the following command:</p><pre><code class="lang-azcli">az account show --query id
</code></pre></li><li><p>Copy your subscription ID and run the following command:</p><pre><code class="lang-azcli">az account set --subscription "&lt;SUBSCRIPTION ID&gt;"
</code></pre></li><li><p>Get your bearer token with the following command:</p><pre><code class="lang-azcli">az account get-access-token --query accessToken
</code></pre></li><li><p>Connect to the Azure REST API via the HTTP REPL:</p><pre><code class="lang-console">httprepl https://management.azure.com
</code></pre></li><li><p>Set the <code>Authorization</code> HTTP request header:</p><pre><code class="lang-console">https://management.azure.com/&gt; set header Authorization "bearer &lt;ACCESS TOKEN&gt;"
</code></pre></li><li><p>Navigate to the subscription:</p><pre><code class="lang-console">https://management.azure.com/&gt; cd subscriptions/&lt;SUBSCRIPTION ID&gt;
</code></pre></li><li><p>Get a list of your subscription's Azure App Service Web Apps:</p><pre><code class="lang-console">https://management.azure.com/subscriptions/{SUBSCRIPTION ID}&gt; get providers/Microsoft.Web/sites?api-version=2016-08-01
</code></pre><p>The following response is displayed:</p><pre><code class="lang-console">HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Length: 35948
Content-Type: application/json; charset=utf-8
Date: Thu, 19 Sep 2019 23:04:03 GMT
Expires: -1
Pragma: no-cache
Strict-Transport-Security: max-age=31536000; includeSubDomains
X-Content-Type-Options: nosniff
x-ms-correlation-request-id: &lt;em&gt;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&lt;/em&gt;
x-ms-original-request-ids: &lt;em&gt;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&lt;/em&gt;
x-ms-ratelimit-remaining-subscription-reads: 11999
x-ms-request-id: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
x-ms-routing-request-id: WESTUS:xxxxxxxxxxxxxxxx:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx
{
  "value": [
    &lt;AZURE RESOURCES LIST&gt;
  ]
}
</code></pre></li></ol><h2 id="toggle-http-request-display">Toggle HTTP request display</h2><p>By default, display of the HTTP request being sent is suppressed. It's possible to change the corresponding setting for the duration of the command shell session.</p><h3 id="enable-request-display">Enable request display</h3><p>View the HTTP request being sent by running the <code>echo on</code> command. For example:</p><pre><code class="lang-console">https://localhost:5001/people~ echo on
Request echoing is on
</code></pre><p>Subsequent HTTP requests in the current session display the request headers. For example:</p><pre><code class="lang-console">https://localhost:5001/people~ post

[main 2019-06-28T18:50:11.930Z] update#setState idle
Request to https://localhost:5001...

POST /people HTTP/1.1
Content-Length: 41
Content-Type: application/json
User-Agent: HTTP-REPL

{
  "id": 0,
  "name": "Scott Addie"
}

Response from https://localhost:5001...

HTTP/1.1 201 Created
Content-Type: application/json; charset=utf-8
Date: Fri, 28 Jun 2019 18:50:21 GMT
Location: https://localhost:5001/people/4
Server: Kestrel
Transfer-Encoding: chunked

{
  "id": 4,
  "name": "Scott Addie"
}


https://localhost:5001/people~
</code></pre><h3 id="disable-request-display">Disable request display</h3><p>Suppress display of the HTTP request being sent by running the <code>echo off</code> command. For example:</p><pre><code class="lang-console">https://localhost:5001/people~ echo off
Request echoing is off
</code></pre><h2 id="run-a-script">Run a script</h2><p>If you frequently execute the same set of HTTP REPL commands, consider storing them in a text file. Commands in the file take the same form as those executed manually on the command line. The commands can be executed in a batched fashion using the <code>run</code> command. For example:</p><ol><li><p>Create a text file containing a set of newline-delimited commands. To illustrate, consider a <em>people-script.txt</em> file containing the following commands:</p><pre><code class="lang-text">set base https://localhost:5001
ls
cd People
ls
get 1
</code></pre></li><li><p>Execute the <code>run</code> command, passing in the text file's path. For example:</p><pre><code class="lang-console">https://localhost:5001/~ run C:\http-repl-scripts\people-script.txt
</code></pre><p>The following output appears:</p><pre><code class="lang-console">https://localhost:5001/~ set base https://localhost:5001
Using swagger metadata from https://localhost:5001/swagger/v1/swagger.json

https://localhost:5001/~ ls
.        []
Fruits   [get|post]
People   [get|post]

https://localhost:5001/~ cd People
/People    [get|post]

https://localhost:5001/People~ ls
.      [get|post]
..     []
{id}   [get|put|delete]

https://localhost:5001/People~ get 1
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Fri, 12 Jul 2019 19:20:10 GMT
Server: Kestrel
Transfer-Encoding: chunked

{
  "id": 1,
  "name": "Scott Hunter"
}


https://localhost:5001/People~
</code></pre></li></ol><h2 id="clear-the-output">Clear the output</h2><p>To remove all output written to the command shell by the HTTP REPL tool, run the <code>clear</code> or <code>cls</code> command. To illustrate, imagine the command shell contains the following output:</p><pre><code class="lang-console">httprepl https://localhost:5001
(Disconnected)~ set base "https://localhost:5001"
Using swagger metadata from https://localhost:5001/swagger/v1/swagger.json

https://localhost:5001/~ ls
.        []
Fruits   [get|post]
People   [get|post]

https://localhost:5001/~
</code></pre><p>Run the following command to clear the output:</p><pre><code class="lang-console">https://localhost:5001/~ clear
</code></pre><p>After running the preceding command, the command shell contains only the following output:</p><pre><code class="lang-console">https://localhost:5001/~
</code></pre><h2 id="additional-resources">Additional resources</h2></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>