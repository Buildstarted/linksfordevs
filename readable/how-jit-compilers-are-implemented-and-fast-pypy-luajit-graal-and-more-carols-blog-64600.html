<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How JIT Compilers are Implemented and Fast: Pypy, LuaJIT, Graal and More | Carol&#x27;s Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="How JIT Compilers are Implemented and Fast: Pypy, LuaJIT, Graal and More | Carol&#x27;s Blog - linksfor.dev(s)"/>
    <meta property="og:description" content="Carol Chen&#x27;s blog about stuff she does or reads about or observes"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://carolchen.me/blog/jits-impls/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - How JIT Compilers are Implemented and Fast: Pypy, LuaJIT, Graal and More | Carol&#x27;s Blog</title>
<div class="readable">
        <h1>How JIT Compilers are Implemented and Fast: Pypy, LuaJIT, Graal and More | Carol&#x27;s Blog</h1>
            <div>Reading time: 27-34 minutes</div>
        <div>Posted here: 21 Jul 2020</div>
        <p><a href="https://carolchen.me/blog/jits-impls/">https://carolchen.me/blog/jits-impls/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section id="js-article">
    
<p>This post goes into details of 5+ JITs and various optimization strategies and discuss how they work with different JITs. Information in this blog post is more <em>depth-first</em>, thus there are many important concepts that may be skipped. That also means that this blogpost is <em>not enough information</em> to draw meaningful conclusions on any comparisons of implementations/languages. </p>
<p>For background on JIT compilers see <a href="https://carolchen.me/blog/jits-intro">A Deep Introduction to JIT Compilers: JITs are not very Just-in-time</a>. If the title does not make sense to you then it may be worth a skim. </p>
<blockquote>
<p><em>Mild Disclaimers, can be skipped</em>.</p>
</blockquote>
<blockquote>
<p>I will often describe an optimization behaviour and claim that it probably exists in some other compiler. Though I don't always check if an optimization exists in another JIT (it's sometimes ambiguous), I'll always state explicitly if I know it’s there. 
I will also provide code examples to show where an optimization might occur, however the optimization may not necessarily occur for that code because another optimization will take precedence. There may also be some general oversimplifications, but not more than I think exists in most posts like these. </p>
</blockquote>
<h2 id="table-of-contents-highlights">Table of Contents / Highlights<a href="#table-of-contents-highlights" aria-label="Anchor link for: table-of-contents-highlights"> </a>
</h2>
<ul>
<li><a href="https://carolchen.me/blog/jits-impls/#wait-but-you-said-meta-tracing">Meta-tracing in Pypy works</a></li>
<li><a href="https://carolchen.me/blog/jits-impls/#interpreting-c">How GraalVM languages support C extensions</a></li>
<li><a href="https://carolchen.me/blog/jits-impls/#go-back-to-the-interpreted-code-it-ll-be-faster">Deoptimisation</a></li>
<li><a href="https://carolchen.me/blog/jits-impls/#wet-code-is-fast-code-inlining-and-osr">Inlining and OSR</a></li>
<li><a href="https://carolchen.me/blog/jits-impls/#what-if-instead-of-instruction-based-ir-like-everyone-else-we-had-a-big-graph-and-also-it-modifies-itself">Seas of Nodes</a></li>
<li><a href="https://carolchen.me/blog/jits-impls/#yay-jit-compiled-code-let-s-compile-it-again-and-again">Tiering JITs</a></li>
</ul>

<p>LuaJIT employs a method called tracing. Pypy does meta-tracing, which involves using a system to generate tracing interpreters and JITs. Pypy and LuaJIT are not the reference implementations of Python or Lua, but projects on their own. I would describe LuaJIT as shockingly fast, and it describes itself as one of the fastest dynamic language implementations -- which I buy fully.</p>
<p>To determine when to start tracing, the interpreting loop will look for "hot" loops to trace (the concept of "hot" code is universal to JITS!). Then, the compiler will "trace" the loop, recording executed operations to compile well optimized machine code. In LuaJIT, the compilation is performed on the traces with an instruction-like IR that is unique to LuaJIT. </p>
<h3 id="how-pypy-implements-tracing"><strong>How Pypy Implements Tracing</strong><a href="#how-pypy-implements-tracing" aria-label="Anchor link for: how-pypy-implements-tracing"> </a>
</h3>
<p>Pypy will start tracing a function after 1619 executions, and will compile it after another 1039 executions, meaning a function has to execute around 3000 times for it to start gaining speed. These constants were carefully tuned by the Pypy team (lots of constants are tuned for compilers in general!).</p>
<p>Dynamic languages make it hard to optimize things away. The following code could be statically eliminated by a stricter language, as <code>False</code> will always be falsy. However, in Python 2, that could not have been guaranteed before runtime.</p>
<pre><code><span>if </span><span>False</span><span>:
  </span><span>print</span><span>(</span><span>"FALSE"</span><span>)
</span></code></pre>
<p>For any sane program, the conditional will always be false. Unfortunately, the value of <code>False</code> could be reassigned and thus if the statement were in a loop, it could be redefined somewhere else. For this case, Pypy would build a "guard". When a guard fails, the JIT will fall back to the interpreting loop. Pypy then uses another constant (200), called <em>trace eagerness</em> to decide whether to compile the rest of the new path till the end of the loop. That sub-path is called a <em>bridge</em>.</p>
<p>Pypy also exposes all those constants as arguments that can be tweaked at execution, along with configuration for unrolling (expanding loops) and inlining! It also exposes some hooks so we can see when things are compiled. </p>
<pre><code><span>def </span><span>print_compiler_info</span><span>(</span><span>i</span><span>):
  </span><span>print</span><span>(i</span><span>.</span><span>type)
pypyjit</span><span>.</span><span>set_compile_hook</span><span>(print_compiler_info)

</span><span>for </span><span>i </span><span>in </span><span>range</span><span>(</span><span>10000</span><span>):
  </span><span>if </span><span>False</span><span>:
    </span><span>pass

</span><span>print</span><span>(pypyjit</span><span>.</span><span>get_stats_snapshot</span><span>()</span><span>.</span><span>counters)
</span></code></pre>
<p>Above, I set up a plain python program with a compile hook to print the type of compilation made. It also prints some data at the end, where I can see the number of guards. For the above I get one compilation of a loop and 66 guards. When I replaced the if statement with just a pass under the for-loop, I was left with 59 guards.</p>
<pre><code><span>for </span><span>i </span><span>in </span><span>range</span><span>(</span><span>10000</span><span>):
  </span><span>pass </span><span># removing the `if False` saved 7 guards!
</span></code></pre>
<p>With these two lines added to the for loop, I will get two compilations, with the new one being of type 'bridge'!</p>
<pre><code><span>if </span><span>random</span><span>.</span><span>randint</span><span>(</span><span>1</span><span>, </span><span>100</span><span>) </span><span>&lt; </span><span>20</span><span>:
  </span><span>False </span><span>= </span><span>True
</span></code></pre><h3 id="wait-but-you-said-meta-tracing">Wait, but you said Meta-tracing!<a href="#wait-but-you-said-meta-tracing" aria-label="Anchor link for: wait-but-you-said-meta-tracing"> </a>
</h3>
<p>The concept behind meta-tracing is “write an interpreter, get a compiler for free!” or more magically, “turn your interpreter into a JIT-compiler!”. This is just obviously a great thing, since writing compilers is hard so if we can get a great compiler for free that’s just a good deal. Pypy "has" an interpreter and a compiler, but there’s no explicit implementation of a traditional compiler.</p>
<p>Pypy has a toolchain called RPython (which was built for Pypy). It is a framework program for implementing interpreters. It is a language in that it specifies a subset of the Python language, namely to force things like static typing. It is a language to write an interpreter in. It is not a language to code in typed-Python, since it doesn’t care or have things like standard libraries or packages. Any RPython program is a valid Python program. RPython programs are transpiled to C and then compiled. Thus, the RPython meta-compiler exists as a compiled C program.</p>
<p>The “meta” in meta-tracing comes from the fact that the trace is on the execution of the interpreter rather than the execution of the program. The interpreter more or less behaves as any interpreter, with the added capability of tracing its own operations, and being engineered to optimize those traces by updating the path of the interpreter (itself). With further tracing, the path that the interpreter takes becomes more optimized. With a very optimized interpreter taking a specific, optimized path, the compiled machine code being used in that path from the compiled RPython can be used as the compilation. </p>
<p>In short, the “compiler” in Pypy is compiling your interpreter, which is why Pypy is sometimes referred to as a meta-compiler. The compiler is less for the program you're trying to execute, but rather for compiling the trace of the optimizing interpreter!</p>
<p>Metatracing might be confusing, so I wrote a very bad metatracing program that can only understand <code>a = 0</code> and <code>a++</code>to illustrate.</p>
<pre><code><span># interpreter written with RPython
</span><span>for </span><span>line </span><span>in </span><span>code:
  </span><span>if </span><span>line </span><span>== </span><span>"a = 0"</span><span>:
    </span><span>alloc</span><span>(a, </span><span>0</span><span>)
  </span><span>elif </span><span>line </span><span>== </span><span>"a++"</span><span>:
    </span><span>guard</span><span>(a, </span><span>"is_int"</span><span>) </span><span># notice how in Python, the type is unknown, but after being interpreted by RPython, the type is known
    </span><span>guard</span><span>(a, </span><span>"&gt; 0"</span><span>)
    </span><span>int_add</span><span>(a, </span><span>1</span><span>)
</span></code></pre>
<p>If I ran the following in a hot loop;</p>
<pre><code><span>a </span><span>= </span><span>0
</span><span>a</span><span>++
</span><span>a</span><span>++
</span></code></pre>
<p>Then the traces may look something like:</p>
<pre><code><span># Trace from numerous logs of the hot loop
</span><span>a </span><span>= </span><span>alloc</span><span>(</span><span>0</span><span>) </span><span># guards can go away
</span><span>a </span><span>= </span><span>int_add</span><span>(a, </span><span>1</span><span>)
a </span><span>= </span><span>int_add</span><span>(a, </span><span>2</span><span>)

</span><span># optimize trace to be compiled
</span><span>a </span><span>= </span><span>alloc</span><span>(</span><span>2</span><span>) </span><span># the section of code that executes this trace _is_ the compiled code
</span></code></pre>
<p>But the compiler isn't some special standalone unit, it's built into the interpreter! So the interpreter loop would actually look something like this</p>
<pre><code><span>for </span><span>line </span><span>in </span><span>code:
  </span><span>if </span><span>traces</span><span>.</span><span>is_compiled</span><span>(line):
    </span><span>run_compiled</span><span>(traces</span><span>.</span><span>compiled</span><span>(line))
    </span><span>continue
  elif </span><span>traces</span><span>.</span><span>is_optimized</span><span>(line):
    </span><span>compile</span><span>(traces</span><span>.</span><span>optimized</span><span>(line))
    </span><span>continue
  elif </span><span>line </span><span>== </span><span>"a = 0"
  </span><span># ....
</span></code></pre><h2 id="an-introduction-to-jvms">An Introduction to JVMs<a href="#an-introduction-to-jvms" aria-label="Anchor link for: an-introduction-to-jvms"> </a>
</h2>
<p>Disclaimer: I worked on/with a Graal-based language, <a href="https://github.com/oracle/truffleruby">TruffleRuby</a> for four months and loved it.</p>
<p>Hotspot (named after looking for <em>hot</em> spots) is the VM that ships with standard installations of Java, and there are actually multiple compilers in it for a tiered strategy. Hotspot is open source, with 250,000 lines of code which contains the compilers, and three garbage collectors. It does an <em>awesome</em> job at being a good JIT, there are some benchmarks that have Hotspot on par with C++ impls (oh my gosh so many asterisks on this, you can Google to find all the debate). Though Hotspot is not a tracing JIT, it employs a similar approach of having an interpreter, profiling and then compiling. There is not a specific name for what Hotspot does, though the closest categorization would probably be a method-based JIT (they optimized by method) or a Tiering JIT. </p>
<p>Strategies used in Hotspot inspired many of the subsequent JITs, the structure of language VMs and especially the development of Javascript engines. It also created a wave of JVM languages such as Scala, Kotlin, JRuby or Jython. JRuby and Jython are fun implementations of Ruby and Python that compile the source code down to the JVM bytecode and then have Hotspot execute it. These projects have been relatively successful at speeding up languages like Python and Ruby (Ruby more so than Python) without having to implement an entire toolchain like Pypy did. Hotspot is also unique in that it's a JIT for a less dynamic language (though it's technically it's a JIT for JVM bytecode and not Java). </p>
<p><img src="https://carolchen.me/blog/img/jits/vms.png" alt=""></p>
<p>GraalVM is a JavaVM and then some, written in Java. It can run any JVM language (Java, Scala, Kotlin, etc). It also supports a Native Image, to allow AOT compiled code through something called Substrate VM. Twitter runs a significant portion of their Scala services with Graal, so it must be pretty good, and better than the JVM in some ways despite being written in Java. </p>
<p>But wait, there's more! GraalVM also provides Truffle, a framework for implementing languages through building Abstract Syntax Tree (AST) interpreters. With Truffle, there’s no explicit step where JVM bytecode is created as with a conventional JVM language, rather Truffle will just use the interpreter and communicate with Graal to create machine code directly with profiling and a technique called partial evaluation. Partial evaluation is out of scope for this blog post, tl;dr it follows metatracing’s “write an interpreter, get a compiler for free” philosophy but is approached differently.</p>
<blockquote>
<p>TruffleJS, the Truffle implementation of Javascript outperforms the JavaScript V8 engine on select benchmarks which is really impressive since V8 has had numerous more years of development, Google money+resources poured in and some crazy skilled people working on it. TruffleJS is still by no means “better” than V8 (or other JS engines) on most measures but it is a sign of promise for Graal. </p>
</blockquote>

<h3 id="interpreting-c">Interpreting C<a href="#interpreting-c" aria-label="Anchor link for: interpreting-c"> </a>
</h3>
<p>A common problem with JIT implementations is support for C Extensions. Standard interpreters such as Lua, Python, Ruby, and PHP have a C API, which allows users to build packages in C, thus making the execution significantly faster. Common packages such as <code>numpy</code> or standard library functions such as <code>rand</code> are written in C. These C extensions are vital to having these interpreted languages run quickly in practice.</p>
<p>C extension support is hard to support for a variety of reasons, the most obvious being that the API is modelled on internal implementation details. Furthermore, it's easier to support C extensions when the interpreter is written in C as JRuby couldn't support C extensions but has a Java extension API. Pypy recently came out with beta support for C extensions, though I'm not sure how usable it is yet largely due to <a href="https://www.hyrumslaw.com/">Hyrum's Law</a>. LuaJIT does support C extensions, along with additional features in their C extensions (LuaJIT is pretty darn great!)</p>
<p>Graal solves the problem with Sulong, an engine that runs LLVM Bitcode on GraalVM by making LLVM Bitcode a Truffle language. LLVM is a toolchain, though all we need to know about it is that C can be compiled into LLVM Bitcode (Julia also has an LLVM backend!). It's a bit weird, but basically the solution is to take a perfectly good 40+ year old compiled language and interpret it! Of course, it's not nearly as fast as properly compiling C, but there are a few wins tucked away in here.</p>
<p><img src="https://carolchen.me/blog/img/jits/cextensions.png" alt=""></p>
<p>LLVM Bitcode is already fairly low-level, which means that jitting that IR is not as inefficient as jitting C. Some of that cost is earned back in that the Bitcode can be optimized along with the rest of the Ruby program, whereas a compiled C program could not be. All that allocation removal, inlining, dead code elimination, etc can be run on the C and Ruby code together instead of Ruby code just calling a C binary. Select benchmarks even have TruffleRuby C extensions running faster than CRuby C extensions.</p>
<p>For this system to work, it should be known that the Truffle ASTs are completely language-agnostic and the overhead to switching between C, Java or whatever language in Graal is minimal.</p>
<p>The ability for Graal to work with Sulong is a part of their polyglot features, which provides high interoperability between languages. Not only is it great for the compiler, but it is also a proof of concept for multiple languages easily used in one "application".</p>
<h3 id="go-back-to-the-interpreted-code-it-ll-be-faster">Go back to the interpreted code, it'll be faster<a href="#go-back-to-the-interpreted-code-it-ll-be-faster" aria-label="Anchor link for: go-back-to-the-interpreted-code-it-ll-be-faster"> </a>
</h3>
<p>We know that JITs come with an interpreter and a compiler, and that they move from the interpreter to the compiler to get faster. Pypy set bridges to take the inverse path, though for Graal and Hotspot, they <em>deoptimize</em>. The terms do not refer to strictly different concepts, but deoptimization refers more to transferring back to the interpreter as a deliberate optimization rather than as a solution to the inevitabilities of dynamic languages. Hotspot and Graal both leverage deoptimization aggressively -- Graal especially as engineers have heavy control over the compilation and need more control over the compilation for optimizations (compared to, say, Pypy). Deoptimization is also used in JS Engines such as V8 which I'll discuss a lot as it powers Javascript in Chrome as well as Node.js.</p>
<p>An important component to making deoptimization fast, is to make sure that switch from the compiler to interpreter is as fast as possible. The most naive implementation would result in the interpreter having to “catch up” with the compiler in order to be able to make the deopt. Additional complexity exists in dealing with deoptimizing asynchronous threads. To deoptimize, Graal will recreate the stack frames and use a mapping from generated code to return to the interpreter. For threads, safepoints in Java threads are used which are in place for threads to constantly pause and go “hi garbage collector, do I stop now?” so not much overhead is added to handle threads. It’s a bit rocky, but fast enough to make deoptimization a good strategy.</p>
<p><img src="https://carolchen.me/blog/img/jits/deopts.png" alt=""></p>
<p>Similarly to the Pypy bridging example, monkey patching of functions can be deoptimized. The deoptimization there is actually more elegant, as it's not a deoptimization that occurs when a guard fails, rather the deoptimizing-code is added where monkey patching occurs.</p>
<p>A great example of a JIT deoptimization is conversion overflow, which is not a super official term, but generally refers to when a particular type (say <code>int32</code>) is represented/allocated internally but needs to become a <code>int64</code>. This is something that TruffleRuby does through deoptimizations, as well as V8.</p>
<p>Say when you set <code>var = 0</code> in Ruby, you get an <code>int32</code> (Ruby actually calls it Fixnum and Bignum, but I’ll continue saying <code>int32</code> and <code>int64</code>). Whenever you perform an operation on <code>var</code>, you would then have to check if the resulting value overflows. The check is one thing, however, compiling the code that handles the overflow is expensive, especially given how common numeric operations are.</p>
<p>Even without looking at compiled instructions, we can see how this deoptimization eases the amount of code it takes to handle.</p>
<pre><code><span>int</span><span> a, b;
</span><span>int</span><span> sum </span><span>=</span><span> a </span><span>+</span><span> b;
</span><span>if </span><span>(overflowed) </span><span>{
  </span><span>long</span><span> bigSum </span><span>=</span><span> a </span><span>+</span><span> b;
  </span><span>return</span><span> bigSum;
</span><span>} </span><span>else </span><span>{
  </span><span>return</span><span> sum;
</span><span>}

</span><span>int</span><span> a, b;
</span><span>int</span><span> sum </span><span>=</span><span> a </span><span>+</span><span> b;
</span><span>if </span><span>(overflowed) </span><span>{</span><span>
  Deoptimize</span><span>!
</span><span>}
</span></code></pre>
<p>For TruffleRuby, it’s engineered to only deoptimize the first time a specific operation is run, so that the cost of the deopt isn’t spent every time should an operation consistently overflow.</p>
<h3 id="wet-code-is-fast-code-inlining-and-osr">Wet code is fast code - Inlining and OSR<a href="#wet-code-is-fast-code-inlining-and-osr" aria-label="Anchor link for: wet-code-is-fast-code-inlining-and-osr"> </a>
</h3>
<pre><code><span>function </span><span>foo</span><span>(</span><span>a</span><span>, </span><span>b</span><span>) </span><span>{
 </span><span>return </span><span>a </span><span>+ </span><span>b</span><span>;
</span><span>}
</span><span>for </span><span>(</span><span>var </span><span>i </span><span>= </span><span>0</span><span>; </span><span>i </span><span>&lt; </span><span>1000000</span><span>; </span><span>i</span><span>++</span><span>) </span><span>{
 </span><span>foo</span><span>(</span><span>i</span><span>, </span><span>i </span><span>+ </span><span>1</span><span>);
</span><span>}
</span><span>foo</span><span>(</span><span>1</span><span>, </span><span>2</span><span>);
</span></code></pre>
<p>In V8, even something as trivial as that triggers a deopt! With options like<code>--trace-deopt</code> and <code>--trace-opt</code> one can gather a lot of data about the JIT as well as modify behaivour (there are also highly comprehensive tools for Graal, though I’ll be using V8 since people likely have <code>node</code> it installed).</p>
<p>It is the final line (<code>foo(1, 2)</code>) that triggers the deopt, which is puzzling because that exact call is made in the loop! The message is “Insufficient type feedback for call” (you can find a full list of deopt reasons <a href="https://chromium.googlesource.com/v8/v8/+/roll/src/deoptimize-reason.h">here</a>, which funnily includes a “no reason” reason). The output gives us an input frame which shows us the literals <code>1</code> and <code>2</code>.</p>
<p>So why the deoptimization? V8 should be smart enough to type inference that the type of <code>i</code> is an integer and that the literals passed in are also integers.</p>
<p>I can investigate this by replacing the final line with <code>foo(i, i +1)</code>, but I actually still get a deoptimization, though this time the message is “Insufficient type feedback for binary operation”. WHY I ASK WHY IT IS LITERALLY THE SAME OPERATION I RAN IN THE LOOP WITH THE SAME VARIABLES.</p>
<p>The answer my friend, is <del>blowing in the wind</del> on-stack replacement (OSR). Inlining is a powerful compiler optimization (not just JITs) in which functions stop being functions and instead the contents are expanded at the call site. JITs can inline by changing the code at runtime to make it faster(compiled languages just inline statically).</p>
<pre><code><span>// partial output from printing inlining details

[compiling method 0x04a0439f3751 &lt;JSFunction (sfi = 0x4a06ab56121)&gt; using TurboFan OSR]
0x04a06ab561e9 &lt;SharedFunctionInfo foo&gt;: IsInlineable? true
Inlining small function(s) at call site #49:JSCall
</span></code></pre>
<p>So V8 will compile <code>foo</code> and determine it is inline-able and inlines it with  with OSR. However, it only performs this inlining for the code within the loop because it's the hot path and the last line doesn't really exist to the interpreter when this inlining is performed. Thus, V8 still does not have enough type feedback on the function <code>foo</code> because it isn’t actually used in the loop -- the inlined version is. If I <code>--no-use-osr</code>, then the deoptimization doesn’t happen - whether or not I pass a literal or <code>i</code>. Yet without the inlining even a measly million iterations are noticeably slower. JITs really embody "there are no solutions, only tradeoffs". Deoptimizations are expensive but not nearly as much as the cost of method lookup and inlining is much preferred in this case.</p>
<p>Inlining is crazy effective! I ran the code above with a couple extra zeroes, and it was 4 times slower with inlining disabled.</p>
<p><img src="https://carolchen.me/blog/img/jits/inliningbench.png" alt=""></p>
<p>Though this is a blog post about JITs, inlining is also really effective for compiled languages. All LLVM languages will inline aggressively (because LLVM will inline), though Julia actually inlines without LLVM because of its jitty nature. JITs can inline with heuristics that come from runtime information, and can switch from not-inlining to inlining with OSR.</p>
<blockquote>
<h3 id="a-note-about-jits-and-the-llvm">A note about JITs and the LLVM<a href="#a-note-about-jits-and-the-llvm" aria-label="Anchor link for: a-note-about-jits-and-the-llvm"> </a>
</h3>
<p>A toolchain to consider is LLVM, which provides a ton of tools related to compiler infrastructure. Julia works with LLVM (note that it’s a large toolchain and each language will utilize it differently), as well as Rust, Swift and Crystal. Suffice it to say that it’s a significant and amazing project that of course also supports JITs, yet there hasn’t really been any significant dynamic JITs built with the LLVM. JavaScriptCore’s fourth compiler tier briefly used an LLVM backend but was replaced in less than two years. The LLVM hasn’t been well suited to dynamic JITs generally because it wasn’t made to work with the unique challenges of being dynamic. Pypy has tried about 5 or 6 times, but JSC actually went with it! With the LLVM, allocation sinking and code motion were limited. Powerful JIT features like range-inferencing (like type inference, but also knowing the range of a value) were not possible. Most importantly, LLVM comes with very expensive compile times.</p>
</blockquote>
<h3 id="what-if-instead-of-instruction-based-ir-like-everyone-else-we-had-a-big-graph-and-also-it-modifies-itself">What if instead of instruction based IR like everyone else we had a big graph, and also it modifies itself<a href="#what-if-instead-of-instruction-based-ir-like-everyone-else-we-had-a-big-graph-and-also-it-modifies-itself" aria-label="Anchor link for: what-if-instead-of-instruction-based-ir-like-everyone-else-we-had-a-big-graph-and-also-it-modifies-itself"> </a>
</h3>
<p>We've taken a look at LLVM bitcode and Python/Ruby/Java-esque bytecode as IR - and they share the same format of some kind of language that looks like instructions. Hotspot, Graal and V8 have an IR called "Sea of Nodes" (pioneered by Hotspot) which is essentially a lower level AST. One can imagine how Seas of Nodes are effective IR, as much of profiling work is based on a notion of a certain path not being taken often (or being traversed in a particular pattern). Note that these compiler ASTs are distinct from the parser AST.</p>
<p>I'm usually all for "try this at home!" but getting graphs to browse is actually a bit difficult, albeit lots of fun and often very helpful for understanding compiler flows. I for one, cannot read all the graphs not only by limits of knowledge but by the computation power of my brain (which can be mediated with compiler options to get rid of behaviours I don't care about)</p>
<p><img src="https://carolchen.me/blog/img/jits/igvyikes.png" alt=""></p>
<p>For V8, you'll need to build V8 and then use the D8 tool with the flag <code>--print-ast</code>. For Graal, <code>--vm.Dgraal.Dump=Truffle:2</code>. These give you text outputs (formatted such that you can get a graph out of them). I'm not sure how V8 developers generate visual graphs but Oracle provides "Ideal Graph Visualizer", which is used above. I did not have the energy to reinstall IGV so instead I have graphs from Chris Seaton generated with Seafoam which is not currently open sourced.</p>
<p>Anyway, let us look at a JavaScript AST!</p>
<pre><code><span>function </span><span>accumulate</span><span>(</span><span>n</span><span>, </span><span>a</span><span>) </span><span>{
  </span><span>var </span><span>x </span><span>= </span><span>0</span><span>;
  </span><span>for </span><span>(</span><span>var </span><span>i </span><span>= </span><span>0</span><span>; </span><span>i </span><span>&lt; </span><span>n</span><span>; </span><span>i</span><span>++</span><span>) </span><span>{
    x </span><span>+= </span><span>a</span><span>;
  </span><span>}
  </span><span>return </span><span>x</span><span>;
</span><span>}

</span><span>accumulate</span><span>(</span><span>1</span><span>, </span><span>1</span><span>)
</span></code></pre>
<p>Above is the code that I’ve run through <code>d8 --print-ast test.js</code>, though we only care about the function <code>accumulate</code>. You’ll notice that I only call it once, which means that I don’t have to wait for any compilation to occur in order to get an AST. </p>
<p>Below is the AST (with some non-essential lines removed) </p>
<pre><code><span>FUNC</span><span> at </span><span>19
</span><span>. </span><span>NAME </span><span>"accumulate"
</span><span>. </span><span>PARAMS
</span><span>. . </span><span>VAR </span><span>(</span><span>0x7ff5358156f0</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>false</span><span>) </span><span>"n"
</span><span>. . </span><span>VAR </span><span>(</span><span>0x7ff535815798</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>false</span><span>) </span><span>"a"
</span><span>. </span><span>DECLS
</span><span>. . </span><span>VARIABLE </span><span>(</span><span>0x7ff5358156f0</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>false</span><span>) </span><span>"n"
</span><span>. . </span><span>VARIABLE </span><span>(</span><span>0x7ff535815798</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>false</span><span>) </span><span>"a"
</span><span>. . </span><span>VARIABLE </span><span>(</span><span>0x7ff535815840</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"x"
</span><span>. . </span><span>VARIABLE </span><span>(</span><span>0x7ff535815930</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"i"
</span><span>. </span><span>BLOCK NOCOMPLETIONS</span><span> at </span><span>-</span><span>1
</span><span>. . </span><span>EXPRESSION STATEMENT</span><span> at </span><span>38
</span><span>. . . </span><span>INIT</span><span> at </span><span>38
</span><span>. . . . </span><span>VAR PROXY</span><span> local[</span><span>0</span><span>] (</span><span>0x7ff535815840</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"x"
</span><span>. . . . </span><span>LITERAL 0
</span><span>. </span><span>FOR</span><span> at </span><span>43
</span><span>. . </span><span>INIT</span><span> at </span><span>-</span><span>1
</span><span>. . . </span><span>BLOCK NOCOMPLETIONS</span><span> at </span><span>-</span><span>1
</span><span>. . . . </span><span>EXPRESSION STATEMENT</span><span> at </span><span>56
</span><span>. . . . . </span><span>INIT</span><span> at </span><span>56
</span><span>. . . . . . </span><span>VAR PROXY</span><span> local[</span><span>1</span><span>] (</span><span>0x7ff535815930</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"i"
</span><span>. . . . . . </span><span>LITERAL 0
</span><span>. . </span><span>COND</span><span> at </span><span>61
</span><span>. . . </span><span>LT</span><span> at </span><span>61
</span><span>. . . . </span><span>VAR PROXY</span><span> local[</span><span>1</span><span>] (</span><span>0x7ff535815930</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"i"
</span><span>. . . . </span><span>VAR PROXY</span><span> parameter[</span><span>0</span><span>] (</span><span>0x7ff5358156f0</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>false</span><span>) </span><span>"n"
</span><span>. . </span><span>BODY</span><span> at </span><span>-</span><span>1
</span><span>. . . </span><span>BLOCK</span><span> at </span><span>-</span><span>1
</span><span>. . . . </span><span>EXPRESSION STATEMENT</span><span> at </span><span>77
</span><span>. . . . . </span><span>ASSIGN_ADD</span><span> at </span><span>79
</span><span>. . . . . . </span><span>VAR PROXY</span><span> local[</span><span>0</span><span>] (</span><span>0x7ff535815840</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"x"
</span><span>. . . . . . </span><span>VAR PROXY</span><span> parameter[</span><span>1</span><span>] (</span><span>0x7ff535815798</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>false</span><span>) </span><span>"a"
</span><span>. . </span><span>NEXT</span><span> at </span><span>67
</span><span>. . . </span><span>EXPRESSION STATEMENT</span><span> at </span><span>67
</span><span>. . . . </span><span>POST INC</span><span> at </span><span>67
</span><span>. . . . . </span><span>VAR PROXY</span><span> local[</span><span>1</span><span>] (</span><span>0x7ff535815930</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"i"
</span><span>. </span><span>RETURN</span><span> at </span><span>91
</span><span>. . </span><span>VAR PROXY</span><span> local[</span><span>0</span><span>] (</span><span>0x7ff535815840</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"x"
</span></code></pre>
<p>This is pretty hard to parse, but it actually maps somewhat closely to a parser-level AST (though this won’t be the case for all programs) which will help. The AST below was generated with Acorn.js</p>
<p>A distinct difference is the variable declarations. In the parser-AST, no actual declaration is explicit for the parameters, and the declaration for the loop is tucked away under the <code>ForStatement</code> node. In the compiler-level AST, all declarations are grouped, along with addresses and metadata. </p>
<p>The compiler-level AST also uses this wacky <code>VAR PROXY</code> thing. The parser-level AST cannot actually identify which names correspond to which variables (by addresses) due to hoisting and <code>eval</code> and whatnot. So the compiler AST uses PROXY variables that are later connected to the actual variable. </p>
<pre><code><span>// This chunk is the declarations and the assignment of `x = 0` 
</span><span>. </span><span>DECLS
</span><span>. . </span><span>VARIABLE </span><span>(</span><span>0x7ff5358156f0</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>false</span><span>) </span><span>"n"
</span><span>. . </span><span>VARIABLE </span><span>(</span><span>0x7ff535815798</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>false</span><span>) </span><span>"a"
</span><span>. . </span><span>VARIABLE </span><span>(</span><span>0x7ff535815840</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"x"
</span><span>. . </span><span>VARIABLE </span><span>(</span><span>0x7ff535815930</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"i"
</span><span>. </span><span>BLOCK NOCOMPLETIONS</span><span> at </span><span>-</span><span>1
</span><span>. . </span><span>EXPRESSION STATEMENT</span><span> at </span><span>38
</span><span>. . . </span><span>INIT</span><span> at </span><span>38
</span><span>. . . . </span><span>VAR PROXY</span><span> local[</span><span>0</span><span>] (</span><span>0x7ff535815840</span><span>) (mode </span><span>= </span><span>VAR</span><span>, assigned </span><span>= </span><span>true</span><span>) </span><span>"x"
</span><span>. . . . </span><span>LITERAL 0
</span></code></pre>
<p>Now, the same program’s AST with Graal!</p>
<p><img src="https://carolchen.me/blog/img/jits/seafoam.jpg" alt=""></p>
<p>This of course, looks much simpler. Red is control flow, blue is <del>water</del> data flow, and arrows are directions. Note that the fact that this graph appears simpler than the AST from V8, does not indicate that Graal has better simplified the program. Rather, this graph is generated from Java which is much less dynamic. The same Graal graph generated from Ruby would closer resemble that first photo of the graph. </p>
<p>The fun part about Graal graphs is that these ASTs will actually change depending on execution. This graph was generated by calling the function many times, with random parameters so that the function doesn’t get optimized away and with OSR and inlining disabled. The dump actually gives you a whole folder of graphs! Graal uses a self-specializing AST to optimize their programs (V8 will make similar optimizations, but not at the AST level). When you dump the Graal graphs you get well over a dozen graphs at different levels of optimization. In node rewriting, nodes replace themselves (specialize) with a different node. </p>
<p>The above graph is a great example of a specialization on a dynamically typed language (image from “One VM to Rule Them All”, 2013). The reason for this process to exist ties in closely with how partial evaluation works - it’s all about the specialization.</p>
<h3 id="yay-jit-compiled-code-let-s-compile-it-again-and-again">Yay, JIT compiled code! Let's compile it again! And again!<a href="#yay-jit-compiled-code-let-s-compile-it-again-and-again" aria-label="Anchor link for: yay-jit-compiled-code-let-s-compile-it-again-and-again"> </a>
</h3>
<p>I've been teasing "Tiering" since Part 1, so let's finally get a look into it! It is the simple concept that if we're not ready to create the most optimized code yet, but interpreting is still expensive, we can compile early once and then compile again when we're ready to generate more optimized code.</p>
<p>Hotspot is a tiering JIT, with two compilers; C1 and C2. The C1 compiler will kick in first and do a quick compile and run then run full profiling to get C2 compiled code. This can help clear up a lot of our concerns with warmup. Unoptimized compiled code is still faster than interpreting and aquiring that unoptimized compiled code is faster. Another fancy thing is that not all code will be compiled by C1 and C2. If a function is deemed trivial enough, it's very likely that optimized C2 output will not be helpful and no attempt will be made (and profiling time is saved!). If perhaps C1 is busy compiling, then the profiling can continue and skip C1 to be compiled by C2 directly.</p>
<p><img src="https://carolchen.me/blog/img/jits/hotspottiers.png" alt=""></p>
<p>JavaScript Core tiers even harder! In fact, it has <em>three JITs</em>. JSC's interpreter also does light profiling, then moves onto the Baseline JIT, then to the DFG (Data Flow Graph) JIT, and finally to the FTL (Faster than Light) JIT. With these tiers, the meaning of deoptimization is no longer limited to a compiler-to-interpreter path, but deoptimization can happen from the DFG to the Baseline JIT (this doesn't seem to be the case for Hotspot C2-&gt;C1). These deoptimizations and passes into the next tier are done through on-stack-replacement.</p>
<p>The Baseline JIT kicks in by 100 executions and the DFG JIT kicks in at about 1000 executions (with exceptions) which means that the JIT gets compiled code much more quickly than say Pypy (which took about 3000 executions). The tiering strategy enables the JIT to try to match the amount of time spent executing the code with the amount of time spent optimizing the code. There are a whole bunch more handy tricks as to which kind of optimizations (inlining, type inferencing, etc) are done at which tier and why that's optimal!</p>

<p>In vague order of how they're related to the blog post.</p>
<ul>
<li>
<p><a href="https://www.freelists.org/post/luajit/How-does-LuaJITs-trace-compiler-work,1">How LuaJIT's Trace Compiler Works from Mike Pall</a></p>
</li>
<li>
<p><a href="https://tratt.net/laurie/research/pubs/html/bolz_tratt__the_impact_of_metatracing_on_vm_design_and_implementation/">Impact of Meta-tracing on VMs by Laurie Tratt</a></p>
</li>
<li>
<p><a href="https://morepypy.blogspot.com/2010/09/escape-analysis-in-pypys-jit.html">Pypy Escape Analysis</a></p>
</li>
<li>
<p><a href="https://tratt.net/laurie/blog/entries/why_arent_more_users_more_happy_with_our_vms_part_1.html">Why Users aren't More Happy with VMs by Laurie Tratt</a></p>
</li>
<li>
<p>Things About JS Engines</p>
<ul>
<li><a href="https://flaviocopes.com/node-runtime-v8-options/">List of V8 Compiler Options</a></li>
<li><a href="https://webkit.org/blog/3362/introducing-the-webkit-ftl-jit/">JSCore Replacing their LLVM Backend for a "Faster Than Light" JIT</a></li>
</ul>
</li>
<li>
<p>Things about Deoptimizations</p>
<ul>
<li><a href="https://engineering.shopify.com/blogs/engineering/optimizing-ruby-lazy-initialization-in-truffleruby-with-deoptimization">Deoptimizing TruffleRuby Lazy Initialization by me</a></li>
<li><a href="https://chrisseaton.com/truffleruby/deoptimizing/">Deoptimizing Ruby by Chris Seaton</a></li>
<li><a href="https://v8.dev/blog/lazy-unlinking">V8 Lazy Deopts</a></li>
</ul>
</li>
<li>
<p>Things About Graal</p>
<ul>
<li><a href="http://lafo.ssw.uni-linz.ac.at/papers/2013_Onward_OneVMToRuleThemAll.pdf">One VM to Rule Them All (a paper)</a></li>
<li><a href="https://chrisseaton.com/truffleruby/cext/">High Performance C Extensions by Chris Seaton</a></li>
<li><a href="https://chrisseaton.com/truffleruby/basic-graal-graphs/">Understanding Graal Graphs by Chris Seaton</a></li>
<li><a href="https://chrisseaton.com/truffleruby/tenthings/">Top 10 Things to do with GraalVM by Chris Seaton</a></li>
</ul>
</li>
<li>
<p>Things about Partial Evaluation</p>
<ul>
<li><a href="https://stefan-marr.de/papers/oopsla-marr-ducasse-meta-tracing-vs-partial-evaluation/">Partial Evaluation vs Meta-tracing</a></li>
<li><a href="https://chrisseaton.com/rubytruffle/pldi17-truffle/pldi17-truffle.pdf">Paper that introduces partial evaluation for Graal</a></li>
</ul>
</li>
<li>
<p>Misc</p>
<ul>
<li><a href="https://jvns.ca/blog/2016/07/23/rigorous-benchmarking-in-reasonable-time/">Benchmarking correctly is hard by Julia Evans</a></li>
</ul>
</li>
</ul>
<h2 id="upcoming-blog-post-allocation-optimizations-for-jits">Upcoming Blog Post: Allocation Optimizations for JITs<a href="#upcoming-blog-post-allocation-optimizations-for-jits" aria-label="Anchor link for: upcoming-blog-post-allocation-optimizations-for-jits"> </a>
</h2>
<p>When I started writing this post it wasn't for public consumption but to help me model my information. Thus, there are still a few thousand more words I have! I expect this post to be released in mid-July 2020. </p>
<p>The next post will illustrate the basics of garbage collection, dynamics of allocations in compilers and describe some implementations of how JITs improve the cost of allocations (or remove them completely). The topic is hugely important to JITs, as a compiled program can rarely make assumptions about where, if and how some allocated data will be used. Writing to registers is orders of magnitude faster than malloc-ing and eliminating allocations can save the garbage collector time. </p>


  </section></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>