<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A Template for Clean Domain-Driven Design Architecture - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A Template for Clean Domain-Driven Design Architecture - linksfor.dev(s)"/>
    <meta property="og:description" content="A software architectural template for applying Clean Domain-Driven Design and CQRS to your own solutions"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.jacobsdata.com/2020/03/02/a-clean-domain-driven-design-architectural-template"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A Template for Clean Domain-Driven Design Architecture</title>
<div class="readable">
        <h1>A Template for Clean Domain-Driven Design Architecture</h1>
            <div>Reading time: 36-46 minutes</div>
        <div>Posted here: 09 Mar 2020</div>
        <p><a href="https://blog.jacobsdata.com/2020/03/02/a-clean-domain-driven-design-architectural-template">https://blog.jacobsdata.com/2020/03/02/a-clean-domain-driven-design-architectural-template</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div itemprop="articleBody"><p><img alt="Architectural Template" src="https://blob.jacobsdata.com/software-alchemy/entry8/architectural-template.jpg"></p>

<h2>Overview</h2>

<p>The purpose of this blog entry is to introduce an architectural template for building web applications which is based upon my interpretation of the Clean DDD and CQRS concepts that I introduced in the previous entry. The information I provide here is guidance only, and I don't claim this to be the definitive approach to building modern applications. It reflects my own personal software development biases and may or may not be suitable to your needs. Once again, I'm operating under the assumption that you fall into a certain category, namely a developer or team of developers working in a startupy-type environment, or a small team within a larger organization. You embrace Agile and lean startup practices, are flexible in your thinking, and focused on continuous improvement and development. Whatever the case, you should always do your homework as well.</p>

<p>To demonstrate this template, I've created a demo application which attempts to solve a (highly contrived) fictional problem for a fake organization. As indicated in the past few entries, you can find the source code to the demo solution <a href="https://github.com/JacobsDataSolutions/OrgManager/" target="org-manager">here</a>. Feel free to refer to the source code alongside the architectural guidelines I've outlined below.</p>

<p>In developing this template, I studied solutions and tutorials from a handful of experts. As always, I've linked to those resources at the bottom. The experts/resources that this architecture is based on are&nbsp;Jason Taylor,&nbsp;Julie Lerman, Steve Smith,&nbsp;Jimmy Bogard,&nbsp;Matthew Renze,&nbsp;Vladimir Khorikov,&nbsp;Greg Young,&nbsp;Dino Esposito, and finally the Microsoft e-book,&nbsp;.NET Microservices: Architecture for Containerized .NET Applications.</p>

<p>Out of all of these, I'm most in agreement with the Taylor solution, which in turn seems to be heavily influenced by the Microsoft guide. At first, I wanted to give this template some cool name like "Wolverine Architecture," but I didn't want to come off as <em>too</em> presumptuous, so I will just refer to it as "my architectural template" or "my architecture."</p>

<p>Before I dive in, I'd like to list a few more caveats:</p>

<ul>
	<li>The demo application is NOT complete, as it is in an initial state which is sufficient to demonstrate the concepts I've discussed in this and previous blog entries. It will change and evolve over time as I elaborate on more software development topics. As a matter of fact, at this point the actual "app" isn't even an ASP.NET&nbsp;Core web application—I've started it out using a simple console application standing in for the Presentation layer. Hopefully this will help you to get a good idea of how the various layers and their corresponding components communicate through the stack without being distracted by too many boilerplate details that would have been there had I used an actual web app for the main project. I'll try to tag the source code accordingly, so that each revision can be easily indexed to the blog entries that it pertains to.</li>
	<li>A few key features are currently missing, such as Identity and Security. I'll add those in future posts.</li>
	<li>This architecture represents the stack up to the Persistence layer. I'm not going to touch on the UI yet.</li>
	<li>I don't agree with the above references on all points. It's okay to disagree with the experts (although, if you are going to adopt a heretical stance, be well-prepared to defend your choice). I'll try to clarify my reasoning in areas in which I deviate from their approaches.</li>
</ul>

<h2>First, the Use Case</h2>

<p>A company would like to have a comprehensive, business-centric application to manage various functions in the organization.</p>

<ul>
	<li>They would like to automate processes which belong to the various business units of the organization—Human Resources, Accounting, etc. For example, they need to track payroll at a basic level, and they need a seamless way to onboard or offboard employees through the Manager of HR.</li>
	<li>They need different adjunct functionalities, like tracking paid time off (PTO) time available, which will be handled through the HR side as well.</li>
	<li>The business will almost certainly request additional features in the future as the application grows and they have time to interact with it, elucidating more business requirements.</li>
</ul>

<p>I've been instructed to build an enterprise solution on the .NET Core stack and deploy it to the Azure cloud. Starting out, the system will simply handle basic HR and Accounting, but it MUST be able to grow to accommodate more complex business functions, such as those managed by Operations, or even the executive team themselves. At the outset, I'm only allowed to use a single relational database as the data store, which will also be in the cloud. Additionally, I've been told by the CIO that the Accounting logic will be coded and maintained by a separate team (maybe even a single individual). She tells me this is for <s>political</s> technical reasons. OK, those are my orders. Time to get to work.</p>

<h2>A Template for Business-Focused Web Applications in the Microsoft Cloud</h2>
<br>
<h3>Code-Level Conventions</h3>

<p>As stated in blog entry 4, I generally follow the conventions from Framework Design Guidelines.&nbsp;Once again, I highly, highly recommend that you use a tool like CodeMaid or something similar to automatically clean up and organize your files for you. You can customize it to organize them the way you want. Here are some specifics:</p>

<ul>
	<li>Pascal case is used for classes names, method names, properties and so on.</li>
	<li>Parameter names, private fields, etc. are camel case.</li>
	<li>Underscores are never used, except in method names for unit tests. I never prefix private fields with underscores.</li>
	<li>SCREAMING_CASE is never used.</li>
	<li>While Hungarian notation is not allowed, certain conventions which might resemble it are okay, such as MyCoolController, MyAwesomeVm, UpdateSomethingCommand, etc. In other words, using suffixes. Those are generally okay.</li>
	<li>I mentioned this in a previous post but here it is again. In recent years there has been a small yet fervent movement to stop prefixing interfaces with "I" because technically it is a vestige of Hungarian notation. DON'T DO THIS. Interfaces should be prefixed with "I" because the distinction between them and other types is so important that their names themselves should express this. If you have any doubts, just look at the source code for the various official Microsoft .NET Core packages. What do they do? (When in doubt, emulate the pros).</li>
	<li>I arrange my code files this way, top to bottom:
	<ul>
		<li>Fields/constants</li>
		<li>Properties/indexers</li>
		<li>Constructors</li>
		<li>Methods</li>
		<li>Nested classes</li>
	</ul>
	</li>
	<li>Within each of the above categories I arrange members based upon access modifier in the following order:
	<ul>
		<li>Public</li>
		<li>Internal</li>
		<li>Protected</li>
		<li>Private</li>
	</ul>
	</li>
</ul>

<h3>Basic Solution Organization</h3>

<p>These are guidelines for organizing the solution into files and projects:</p>

<ul>
	<li>There should be one class/enum/interface per source code file. This one drives me nuts. I've encountered solutions in which there are five or six different classes in a single file along with a bunch of enums and other nonsense. However, there is an exception to this rule, which you can see in the demo application: I've nested the handler classes for commands/queries inside the command/query classes themselves. The reason for this is simple, which is that user code doesn't need to call them directly. Remember, we are relying on MediatR to perform the dispatch to handler methods.</li>
	<li>Project names, folder names, and namespace names should all align. It drives me crazy when I encounter a solution in which there is a folder called "Foo" and the corresponding namespace for classes in that folder is "Bar." Don't do this. Names of everything should align, so that if decide you need to take a folder full of classes and put it into its own project, <u>the namespaces don't break</u>. This idea, which I'll tentatively call the "Project/Folder/Namespace Fungibility principle" is important, because as the solution grows it gives us the flexibility to refactor it easily and move different sections of the architecture into separate microservices. To put it simply, <em>Project Name = Folder Name = Namespace</em>. Do this, and your solutions will be much easier to refactor.</li>
	<li>Related to the above point is the naming of projects themselves. A good guideline is &lt;Company&gt;.&lt;Solution&gt;.&lt;Layer&gt;.&lt;Bounded context or other detail&gt;. Alternatively, you can use &lt;Solution&gt;.&lt;Layer&gt;.&lt;BC/detail&gt; or whatever. Just be consistent.</li>
	<li>I recommend keeping your project structure flat (for the most part). This means not hiding projects in some nested folder somewhere, which makes them difficult to find.</li>
</ul>

<h3>External Dependencies</h3>

<p>This is a list of third-party toolkits, libraries, and NuGet packages that the solution depends upon. This is not comprehensive, and more will be added as the solution grows over time.</p>

<ul>
	<li>MediatR, by Jimmy Bogard - Used in both Domain layer and Application layer. This is a really powerful package and is the special sauce that brings everything together. As stated in the previous entry, MediatR facilitates a simple, elegant CQRS implementation.</li>
	<li>Entity Framework Core - Microsoft's ORM. Used almost exclusively inside CQRS commands to update the database and sometimes to perform simple queries against it.</li>
	<li>Dapper - A powerful and efficient micro-ORM which allows us to write flexible queries which translate well into DTO/view models. Used on the query side of the stack to return query results by projecting complex SQL queries into 1NF view models.</li>
	<li>FluentValidation - Plugs nicely into MediatR and allows for validation of commands that are sent down the stack before they hit the Domain layer.</li>
	<li>Mapster - A fast and intuitive object mapping library which assists in mapping view models and persistence models to/from domain models. Alternatively, you could use AutoMapper, also by Jimmy Bogard, but at this time I prefer Mapster because it's faster and the usage is slightly more intuitive.</li>
	<li>Serlilog - A powerful logging library which sits on top of the base .NET Core logging infrastructure.</li>
</ul>

<h3>Logical Organization of the Solution</h3>

<p>When working with this or any other architecture, I strive to produce solutions that are neatly organized and easy to navigate. A great principle to follow in this regard is&nbsp;<a href="https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html" target="bob-screaming-architecture">Screaming Architecture</a>&nbsp;(<em>The architecture should scream the intent of the system!</em>), which is another Uncle Bob-ism. Starting from this, let's discuss for a minute <u>component organization</u>&nbsp;and&nbsp;<u>functional organization</u>, which are two distinct methodologies for organizing classes, interfaces, components, and other objects together inside a software solution.</p>

<h3>Component Organization</h3>

<p>Under component organization, classes, interfaces and other objects are grouped together in folders or projects based upon their <em>category</em>, or what they represent—e.g. Controllers, Views, so on. The underlying concept here is&nbsp;<u>categorical cohesion</u>, which simply means that entities of the same classification or category should go together. Imagine grouping baseball players from a baseball league. In this way, all third basemen from all teams would go together into one group, pitchers in another, and so on.</p>

<p>This is the default for most solutions in .NET, especially MVC solutions.&nbsp;At first, this seems easier to grasp but has its drawbacks. As the solution grows, you may find yourself "jumping around" more to find dependencies for different components. I've certainly found this to be the case with most legacy systems I've worked on in corporate environments, in which F12, Ctrl-F12, and Ctrl-Q become my best friends.</p>

<p><img alt="Component Organization" src="https://blob.jacobsdata.com/software-alchemy/entry8/component-organization.jpg"></p>

<p><sup>These are all the same thing?</sup></p>

<h3>Functional Organization</h3>

<p>On the other hand, functional organization is based upon the idea of spatial locality: it is more efficient to keep items that are often used together near each other. The underlying concept is functional cohesion, which means that entities which work toward the same goal or purpose should go together. Going back to the baseball analogy, this would simply imply that players from each team should go together, regardless of their positions, because they play together and operate as a functional unit on that team.</p>

<p>As applied to a .NET software solution, classes and other objects are grouped together in folders or projects based upon their <em>use case</em>, or what purpose they serve—e.g. <span>RegisterOrUpdateEmployee</span>, <span>GetPaidTimeOffPolicyList</span>, etc.&nbsp;The benefit to this approach is that it's easier to navigate the solution, especially as it grows, and it helps you to maintain a high level of cohesion around different use cases of the system.&nbsp;Some of the downsides to this are that you might break from framework conventions, lose automatic scaffolding from certain tools, and so on. Personally, I think it's worth the cost.&nbsp;As an aside, it's worth noting that Angular uses functional organization by default, so this isn't a totally radical methodology.</p>

<p><img alt="Functional Organization" src="https://blob.jacobsdata.com/software-alchemy/entry8/functional-organization.jpg"></p>

<p><sup>These all work well together.</sup></p>

<p>In my architecture I use functional organization to the greatest extent possible, <em>where it makes sense</em>. Once again, the 80/20 rule (Pareto principle) applies. In situations where it doesn't make sense, I fall back to component organization. In Renze's demo solution he mixes unit test classes into the same folders as the classes under test within the application projects. DON'T EVER DO THIS. Unit tests are a different animal, and they belong in their own projects. Once again, principles and practices are guidance, general rules to follow, and as the character Morpheus states in the <a href="https://en.wikipedia.org/wiki/The_Matrix" target="matrix-wiki">Matrix</a>, "some of them can be bent, others can be broken."</p>

<p>When applied to the architectural layers of a Clean DDD solution, functional organization looks like this. Layer/grouping:</p>

<ul>
	<li>Domain - Each domain entity</li>
	<li>Application - Aggregate root corresponding to each use case</li>
	<li>Persistence - Each database table</li>
	<li>Infrastructure - Each functional area of the operating system (file operations, etc.) and/or external resources</li>
	<li>Presentation - Aggregate root corresponding to each screen or web page</li>
	<li>Cross-cutting (Common) - Each cross-cutting concern (Logging, Security, etc.)</li>
</ul>

<h3>The Template</h3>

<p>Just as a refresher, here is what the architecture looks like at a high level.</p>

<p><img alt="Clean Domain Driven-Design, Jacobs Interpretation" src="https://blob.jacobsdata.com/software-alchemy/entry8/clean-domain-driven-design-jacobs-510.png"></p>

<h3>Core Layers</h3>

<p>As stated in the previous entry, the core is comprised of the Domain layer and the Application layer.&nbsp;Think of this as the "zone of abstractions and logic".</p>

<h4>Domain Layer Organization</h4>

<p><img alt="Domain Layer Organization" src="https://blob.jacobsdata.com/software-alchemy/entry8/domain-layer-organization.png"></p>

<p>Once again, the Domain Layer should have no knowledge of outside layers, even by proxy (i.e. by exposing interfaces which are implemented by outside layers). It is strictly for business entities and logic.</p>

<p>Key points:</p>

<ul>
	<li>I start with a single Domain project, in which I create root-level folders that hold base classes corresponding to different key DDD concepts—Models, Events, so on. Additional projects can be added, for instance to separate out bounded contexts, but this is the main one.</li>
	<li>I also have a separate root level folder to house interfaces and other abstractions. I've named this Abstractions, and it's pretty similar to the way that the official .NET Core packages are structured. In fact, at some point in the future we could even separate this into its own project. This is a recurring pattern throughout the layers.</li>
	<li>There is a Common folder at the root level as well, which holds various Domain entities and value objects that don't belong to any particular bounded context. This is essentially a "shared kernel" in DDD-speak. Note that this pattern doesn't just apply to the Domain layer. Anything which <em>cuts across Bounded Contexts</em> goes into a "Common" folder for each layer.</li>
	<li>Additional root level folders exist for each bounded context. In the future, as the solution scales, each one can be broken off into its own project with little refactoring involved, if we continue to abide by the Fungibility principle I stated above. You can see this in the demo app, where I have created a separate Domain project for the Accounting bounded context.</li>
	<li>I studied a few different ValueObject base class implementations and I settled on the one that Taylor's solution and the Microsoft e-book use. <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/implement-value-objects" target="value-object-impl">In this implementation</a>, child classes must explicitly state which data properties are used for comparison. While this might seem like more effort, I prefer this over reflection-based approaches because the design of each value object should not be taken lightly, and furthermore you don't want to take a performance hit from using reflection in these. See below.</li>
	<li>In general, the Domain layer should have zero reliance on external packages and third-party dependencies. However, if you examine the demo application, you'll see that I put in a hard dependency on MediatR as a means of dispatching domain events. Some may regard this as worthy of a slap on the wrist, but I consider it to be a situation where breaking the rules is acceptable, because trying to abstract away MediatR is simply is not worth the effort, and it wouldn't be hard to remove if the need arose to use a different in-process messaging implementation.</li>
</ul>

<p>Finally, here are some thoughts on putting persistence abstractions (interfaces) in the domain layer. At least two of the solutions I examined do this. For example, in Khorikov's solution he puts CQRS commands into the Domain layer, and the Microsoft e-book does basically the same thing with repository interfaces.&nbsp;</p>

<p>I don't agree with them. In my architectural template, CQRS commands and queries, and repository interfaces (if you choose to use them) NEVER go into the Domain layer, because they have nothing to do with pure business logic.&nbsp;Persistence logic, even through interfaces, does not belong in there. In this respect, my architecture is more conservative than other Clean DDD solutions—the Domain layer should ONLY be concerned with business logic and interaction among domain entities.&nbsp;The Application layer is the appropriate place to put persistence interfaces because <em>that</em> is the layer of orchestration and coordination.</p>

<h4>Application Layer Organization</h4>

<p><img alt="Application Layer Organization 1" src="https://blob.jacobsdata.com/software-alchemy/entry8/application-layer-organization1.png">&nbsp;&nbsp;<img alt="Application Layer Organization 2" src="https://blob.jacobsdata.com/software-alchemy/entry8/application-layer-organization2.png"></p>

<p>In my opinion, this is the most important layer in the entire architecture, so I'll go into some detail on this.&nbsp;</p>

<p>Key points:</p>

<ul>
	<li>Just like in the Domain layer, there is an Abstractions root level folder, inside which are subfolders which are broken apart using functional organization. In this case, each subfolder corresponds to different general concerns of the Application layer. This is important because this contains interfaces that higher-level layers, such as Persistence and Infrastructure will implement. This is basically the means by which this layer connects to the higher-level layers: Application layer components receive references to these various interfaces via constructor injection, and the higher-level layers provide the actual concrete implementations. This decoupling is extremely important, as we have now made it easy to mock the Application layer orchestration logic inside unit tests without requiring a connection to an actual database, operating system, etc. This is the Dependency Inversion principle in action. In the demo application there are two interfaces that I want to draw your attention to:
	<ul>
		<li><span>IOrgManagerDbContext</span> - This is a facade which abstracts away an Entity Framework Core database context for our application data. This will be used almost exclusively on the command side of the stack.</li>
		<li><span>IOrgManagerDbQueryFacade</span> - This is a facade which abstracts away calls to a micro-ORM called Dapper. This will be used mostly on the query side of the stack, although there's no restriction against using this inside commands, should the need arise.</li>
	</ul>
	</li>
	<li>There is a Common folder in here as well. Think of it as a higher-level shared kernel. In here are subfolders, each of which corresponds to a separate Entity Framework Core entity, which in turn will map to a database table, since we're using EF code-first. You might be wondering why this is not broken apart by bounded context as well. The reason is simple: we are only targeting one database. As stated earlier, the approach is to build a monolithic application comprised of several projects, which can be broken apart into separate microservices at some later date. When (if) that time comes, we can worry about splitting the data model.</li>
	<li>Also, at the root level there are folders corresponding to different bounded contexts. Just like with the Domain layer, these can be moved into separate projects, should the need arise. Each bounded context folder has subfolders corresponding to each aggregate root. Inside each of these, we've separated our commands from queries. See below on how this could scale, should the need arise to split the stack.</li>
	<li>This layer may reference "helper" libraries such as mappers, internal messaging components (MediatR).</li>
	<li>MediatR + CQRS
	<ul>
		<li>As stated in the previous blog entry, the use of the Mediator pattern along with CQRS is almost a no-brainer. Encapsulating commands/queries as MediatR requests is how we accomplish this.</li>
		<li>We get additional benefits, such as being able to inject cross-cutting concerns into the request pipeline, which is exactly what I've done. The RequestCachingBehavior that I've implemented is a great example of this.</li>
	</ul>
	</li>
</ul>

<h4>Application Model Classes</h4>

<p>Remember from the last entry what I said about view models? To recap, they are models that map to some piece of the UI and are used to communicate back and forth between the UI and the Presentation layer (web API). In this architecture I treat both CQRS commands and the DTOs that are returned from queries as view models. This might strike you as wrong or otherwise violating the Single Responsibility principle, but in this instance it's okay. This is because the task-based orientation of CQRS functionally aligns with the UI, so there's typically a 1:1 correspondence between the models that present information to the user and those that are required/produced by CQRS commands and queries. Furthermore, if there comes a time when the two must be decoupled, there's nothing from stopping us from doing that and putting that mapping logic into the Presentation layer.</p>

<p>The persistence models are a different story...&nbsp;Several the solutions I studied were reusing the EF Core model classes as Domain entities.&nbsp;NO,&nbsp;NO,&nbsp;NO, NO! Even Taylor's solution does this, and his architecture is the closest to mine out of all them. I disagree with virtually all the experts on this. Here's why:</p>

<p>Persistence model classes never quite map perfectly to database tables and queries because of what Greg Young calls an <u>object-relational impedance mismatch</u>.&nbsp;This sounds complicated but it's not. All it means is that databases and programming languages differ in the way they represent data and relationships between entities, so of necessity there always must be some degree of translation going on. More specifically, databases are (traditionally) relational, which means that they are based upon <u>Set Theory</u>. Modern programming frameworks are (often) object-oriented, which means that they are based on <u>Graph Theory</u>. Furthermore, databases have their own data types which are almost always different from the data types used in your programming language of choice, so conversion or even data loss is involved when communicating between the two. If you are using an ORM like Entity Framework, then it will handle this for you. If you are writing straight ADO.NET&nbsp;code, then you have to deal with the pain of mapping between them yourself.</p>

<p>Taking this a step further, domain entities and persistence entities have radically different intents: one is used to model the business and the other is used to store data. The accepted answer from <a href="https://softwareengineering.stackexchange.com/questions/384846/pitfalls-of-domain-driven-design-with-entity-framework#384929" target="stack-exchange">this stack exchange question</a>, by&nbsp;Robert Bräutigam, explains it quite well:</p>

<blockquote>
<p>DDD and EF have little to nothing to do with each other.</p>

<p>DDD is a modeling concept. It means to think about the Domain, the Business Requirements, and model those. Especially in the context of object-orientation it means to create a design which mirrors business functions and capabilities.</p>

<p>EF is a persistence technology. It is mainly concerned with data and database records.</p>

<p>These two are sharply divorced. A DDD design may use EF in some form under the hood, but the two should not interact in any other way.</p>

<p>Some interpretations of Domain-Driven Design do advocate data-modeling, and I think this is what your question is about. In this interpretation "Entities" and "Value Objects" are essentially function-less data holders only, and the design concerns itself with what properties these hold and what relation they have between each other. In this context DDD vs. EF may come up.</p>

<p>This interpretation however is flawed, and I would strongly recommend ignoring it altogether.</p>

<p>In conclusion: DDD and EF are not mutually exclusive, they are actually irrelevant to each other, as long as you are doing proper object-modeling and not data-modeling. DDD objects should not in any shape or form be EF artifacts. DDD Entities should not be EF "entities" for example. Inside some business-relevant function, a DDD design might use EF with some related data-objects, but those should be always hidden under a business-relevant behavior-oriented interface.</p>
</blockquote>

<p>One solution to avoid getting tangled in this mess is to use mapping.&nbsp;You'll notice that the folders corresponding to different commands/queries have mapper classes which allow you to map from view models to domain models, and back again. Additionally, the folders corresponding to different database tables have mapper classes that allow you to map from persistence entities to domain models, and back again as well. This is the price that we must pay for using a Clean DDD approach because it's important to maintain the decoupling between Domain layer entities and view models/persistence entities. This is the biggest pain point in this architecture, but fortunately that pain can be minimized by using tools such as AutoMapper or Mapster. I've abstracted the mappers for each entity pair behind interfaces, because this makes our solution much more testable and flexible. Dependency injection is used to provide the actual implementations to the command/query classes that need them.</p>

<h4>Persistence Entities and Facades</h4>

<p>You might be questioning why view models and persistence models are declared in the Application layer instead of Presentation/Persistence. The answer, quite simply, is because the Application layer is doing all the heavy lifting in the system and depends upon them to manipulate the data model inside command handlers, and relay query results back up the stack from inside of query handlers.</p>

<p>Remember from the last entry, in which I talked about the asymmetry of the solution? You can clearly see this in the Application and Persistence layers, in which I'm using two different persistence technologies: Entity Framework Core and Dapper.</p>

<ul>
	<li>EF Core is Microsoft's ORM for .NET Core. I'm using this on the command/write side of the stack because it makes inserting and updating data to the database much easier. It can also be used for simple queries against the database inside CQRS commands. I've abstracted the EF Core DbContext behind an interface which gets injected into CQRS command handlers.</li>
	<li>Dapper is a lightweight micro-ORM. I'm using this on the query/read side of the stack because it facilitates writing complex database queries without incurring the performance penalties typically associated with ORMs, including EF Core. I've abstracted a few key Dapper methods behind a query facade interface which gets injected into the CQRS query handlers.</li>
</ul>

<p>You'll notice that the <span>IOrgManagerDbContext</span> and&nbsp;<span>IOrgManagerDbQueryFacade</span> interfaces still allow CQRS command/query handlers to use LINQ and/or straight SQL queries. Aren't these leaky abstractions—i.e. allowing database details into the Application layer? In a sense, yes. Technically I've broken another rule and I'm sure Uncle Bob would yell at me for this. However,&nbsp;I'm of the camp that trying to create a "pure" abstraction that removes ALL knowledge of the underlying data store is not worth the effort, because the paradigms underlying various data stores can be so radically different that it's difficult to keep underlying details from leaking across the interface boundary anyway. What if the underlying data store is a NoSQL database? Or the file system?&nbsp;The Repository pattern attempts to do mitigate this problem, but I'm not a fan of using it in CQRS solutions. Read on.</p>

<h4>To Repo, or Not to Repo?</h4>

<p>I disagree with a few the experts on the use of the Repository pattern. In my opinion,&nbsp;repositories are an unnecessary abstraction in CQRS solutions—they are trying to solve a problem which doesn't exist, which is the encapsulation of task-based operations into a <u>Unit of Work</u>; the commands themselves already do this.&nbsp;Furthermore, I believe that repositories can tend to sway you toward CRUD-type semantics, whereas CQRS commands (ideally) are unambiguously centered around business tasks. I'm not 100% against repositories, but I think they are more appropriate for CRUD applications.</p>

<p>While it's true that forgoing the use of repositories and writing LINQ/SQL queries directly in the CQRS handlers isn't truly persistence agnostic, it is still flexible enough that we can swap out one database provider for another (in theory). Regarding testability, we still maintain the ability to write unit tests against our CQRS handlers by mocking out the persistence facade interfaces.</p>

<h3>Periphery Layers</h3>

<p>The periphery is comprised of the Persistence, Infrastructure, and Presentation layers. Think of this as the "zone of implementations and concretes." Honestly, I'm not going to go into great detail with these because they are self-explanatory.</p>

<h4>Persistence Layer Organization</h4>

<p><img alt="Persistence Layer Organization" src="https://blob.jacobsdata.com/software-alchemy/entry8/persistence-layer-organization.png"></p>

<p>It's important to mention that another benefit to using Entity Framework Core is that it allows us to scaffold our database from the persistence model classes, which can be a huge time saver and result in a clean, robust database schema. That's exactly what I've done, so the EF configuration classes are in here, functionally organized into subfolders, along with the EF code migrations.</p>

<p>The Persistence layer additionally houses the implementations for the EF Core DbContext interface and the Dapper QueryFacade interface.</p>

<h4>Infrastructure Layer Organization</h4>

<p><img alt="Infrastructure Layer Organization" src="https://blob.jacobsdata.com/software-alchemy/entry8/infrastructure-layer-organization.png"></p>

<p>This is very similar to the Persistence layer. The Infrastructure layer contains concrete implementations for abstractions that are defined in the Application layer relating to things like Identity, accessing the file system, external messaging, and so on. Likewise, implementations for abstractions defined in the Common layer should also go in here, a good example being the IDateTime interface, discussed below.</p>

<p>You might be wondering why Identity is in here instead of in the Persistence layer. The reason is that Identity is an entirely separate architectural area from persistence, and there's no reason to assume that user identity will be backed by a DB, as opposed to some third-party identity store accessed through an API (there are dozens out there).</p>

<h4>Presentation Layer Organization</h4>

<p><img alt="Presentation Layer Organization" src="https://blob.jacobsdata.com/software-alchemy/entry8/presentation-layer-organization.png"></p>

<p>For all intents and purposes the Presentation layer is the top of the stack as far as back end code is concerned. The UI is treated separately. In the finished solution, this will be an ASP.NET&nbsp;Core web API with thin logic inside of it. The only code inside here will be:</p>

<ul>
	<li>ASP.NET&nbsp;Core boilerplate, to get the web API up and running.</li>
	<li>Controllers, which act as the REST interface that the UI will communicate with.</li>
	<li>High-level components, namely from the Application layer, which get injected into the controllers and called as a consequence of various controller actions. All these components are wired together using an IOC container and dependency injection.</li>
</ul>

<p>While keeping the Presentation layer decoupled from the Application layer is a must, decoupling from the UI isn't as big of a deal.&nbsp;At some point in the future, should we feel the need, there is nothing to stop us from peeling off the Presentation layer and replace it with a desktop UI, implemented using WPF. In this case, the Presentation layer <em>is</em> the UI.&nbsp;Alternatively, we can unplug the stack starting from the Application layer on down and put it inside a different web API, one that is specifically targeted toward mobile clients. Anything is possible.</p>

<p>In some of the other demo solutions I studied, the web API project was treated as the Application layer. I don't agree with this.&nbsp;My stance is to treat the Web API project as belonging to the Presentation Layer (as distinct from the UI). This coincides with the Taylor solution and provides for much better decoupling at an architectural level.</p>

<h4>Common Layer Organization</h4>

<p><img alt="Common Layer Organization" src="https://blob.jacobsdata.com/software-alchemy/entry8/common-layer-organization.png"></p>

<p>There isn't much going on here, just your usual cross-cutting concerns like text manipulation and the like. As always, be careful what you put into this layer and make sure that it's a cross-cutting concern.</p>

<p>Here's a short explanation of the&nbsp;<span>IDateTime</span> interface. This is in here because it's used by virtually every layer, including the Domain layer.&nbsp;The actual implementation for it is in the Infrastructure layer.&nbsp;This is something you might take for granted, but it is an incredibly powerful pattern. Some of the benefits are:</p>

<ul>
	<li>All components and logic which are dependent upon the system date/time instantly become unit testable.</li>
	<li>What's more, if you have a system which is highly sensitive to the current date/time, you can put a special implementation behind this, and all subsystems will stay in sync.</li>
	<li>I'd take this further and put in the provision that all date/times must be in UTC across the whole stack, except when being presented to the user. The reasons for this are numerous, but suffice it to say, I've acquired this point of view after working on dozens of legacy systems which DON'T do this.</li>
</ul>

<h3>Unit Test Projects</h3>

<p><img alt="Unit Tests Organization" src="https://blob.jacobsdata.com/software-alchemy/entry8/unit-tests-organization.png"></p>

<p>When adding unit tests to a solution,&nbsp;I largely follow the conventions espoused by Roy Osherove in his book <a href="https://www.manning.com/books/the-art-of-unit-testing-third-edition" target="osherove-unit-testing">The Art of Unit Testing</a>.&nbsp;For instance, the folder structure of unit test projects should mirror the folder structure of the projects under test, and each test should be cohesive and test only one thing. In terms of code coverage,&nbsp;100% is rarely feasible or necessary. Aim to test the most critical pieces first. Test-driven development (TDD) is easier when using CQRS, and I may touch on that in a future post. If you've designed them well and are using dependency injection properly, then command/query handlers should be easily unit testable.</p>

<h3>Points for Style: F# Projects</h3>

<p><img alt="F# Project" src="https://blob.jacobsdata.com/software-alchemy/entry8/f-sharp-project.png"></p>

<div id="gist101088244">
    <div>
      <div>
        <div>
  <div id="file-organizationverifier-fs">
    

  <div itemprop="text">
      
<table data-tab-size="8">
      <tbody><tr>
        <td id="file-organizationverifier-fs-L1" data-line-number="1"></td>
        <td id="file-organizationverifier-fs-LC1"><span><span>namespace</span> <span>JDS.OrgManager.Domain.HumanResources.Advanced</span></span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L2" data-line-number="2"></td>
        <td id="file-organizationverifier-fs-LC2"><span>open</span> <span>JDS.<span>OrgManager</span>.<span>Domain</span>.<span>HumanResources</span>.<span>Employees</span></span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L3" data-line-number="3"></td>
        <td id="file-organizationverifier-fs-LC3"><span>open</span> <span>System.<span>Linq</span></span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L4" data-line-number="4"></td>
        <td id="file-organizationverifier-fs-LC4"><span>open</span> <span>System.<span>Collections</span>.<span>Generic</span></span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L5" data-line-number="5"></td>
        <td id="file-organizationverifier-fs-LC5">
</td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L6" data-line-number="6"></td>
        <td id="file-organizationverifier-fs-LC6"><span>type</span> <span>OrganizationVerifier</span><span>()</span> <span>=</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L7" data-line-number="7"></td>
        <td id="file-organizationverifier-fs-LC7">    <span>let</span> <span>rules</span> <span>=</span> <span>[</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L8" data-line-number="8"></td>
        <td id="file-organizationverifier-fs-LC8">        (<span>fun</span> (emp <span>:</span> Employee) <span>-&gt;</span> emp.AssertAggregates<span>()</span>)<span>;</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L9" data-line-number="9"></td>
        <td id="file-organizationverifier-fs-LC9">        (<span>fun</span> <span>emp</span> -<span>&gt;</span> emp.VerifyEmployeeManagerAndSubordinates<span>()</span>)<span>;</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L10" data-line-number="10"></td>
        <td id="file-organizationverifier-fs-LC10">        (<span>fun</span> <span>emp</span> -<span>&gt;</span> emp.VerifyPtoHoursAreValid<span>()</span>)<span>;</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L11" data-line-number="11"></td>
        <td id="file-organizationverifier-fs-LC11">        (<span>fun</span> <span>emp</span> -<span>&gt;</span> <span>if</span> emp.FirstName <span>=</span> <span><span>"</span>John<span>"</span></span> <span>&amp;&amp;</span> emp.LastName <span>=</span> <span><span>"</span>Doe<span>"</span></span> <span>then</span> raise <span>&lt;|</span> <span>new</span> EmployeeException(<span><span>"</span>Invalid employee name!<span>"</span></span>))</td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L12" data-line-number="12"></td>
        <td id="file-organizationverifier-fs-LC12">    <span>]</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L13" data-line-number="13"></td>
        <td id="file-organizationverifier-fs-LC13">    <span>let</span><span> rec</span> <span>verifyOrgRecursive</span> (<span>emp</span> : <span>Employee</span>) <span>=</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L14" data-line-number="14"></td>
        <td id="file-organizationverifier-fs-LC14">        rules</td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L15" data-line-number="15"></td>
        <td id="file-organizationverifier-fs-LC15">        <span>|&gt;</span> Seq.iter (<span>fun</span> <span>rule</span> -<span>&gt;</span> rule(emp))</td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L16" data-line-number="16"></td>
        <td id="file-organizationverifier-fs-LC16">
</td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L17" data-line-number="17"></td>
        <td id="file-organizationverifier-fs-LC17">        <span>if</span> not <span>&lt;|</span> emp.Subordinates.Any<span>()</span> <span>then</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L18" data-line-number="18"></td>
        <td id="file-organizationverifier-fs-LC18">            (<span>1</span>, emp.EmployeeLevel)</td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L19" data-line-number="19"></td>
        <td id="file-organizationverifier-fs-LC19">        <span>else</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L20" data-line-number="20"></td>
        <td id="file-organizationverifier-fs-LC20">            <span>let</span> <span>sCount, sComp</span> <span>=</span> emp.Subordinates <span>|&gt;</span> Seq.map verifyOrgRecursive <span>|&gt;</span> List.ofSeq <span>|&gt;</span> List.unzip <span>|&gt;</span> (<span>fun</span> (c, x) <span>-&gt;</span> (Seq.reduce (<span>+</span>) c, Seq.reduce (<span>+</span>) x))</td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L21" data-line-number="21"></td>
        <td id="file-organizationverifier-fs-LC21">            (sCount <span>+</span> <span>1</span>, sComp <span>+</span> emp.EmployeeLevel)</td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L22" data-line-number="22"></td>
        <td id="file-organizationverifier-fs-LC22">
</td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L23" data-line-number="23"></td>
        <td id="file-organizationverifier-fs-LC23">    <span>interface</span> IOrganizationVerifier <span>with</span></td>
      </tr>
      <tr>
        <td id="file-organizationverifier-fs-L24" data-line-number="24"></td>
        <td id="file-organizationverifier-fs-LC24">        <span>override</span> <span>this.VerifyOrg</span>(<span>employees</span> : <span>Employee</span> <span>seq</span>) <span>=</span> <span>new</span> List<span>&lt;</span>int <span>*</span> int<span>&gt;</span>(employees <span>|&gt;</span> Seq.map verifyOrgRecursive) <span>:&gt;</span> IReadOnlyList<span>&lt;</span>int <span>*</span> int<span>&gt;</span></td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>


<p><sup>Example code for a domain class built using F#.</sup></p>

<p>In the demo application&nbsp;I've added an F# project to the solution, representing specialized logic in the Domain layer for a bounded context.&nbsp;This is just to demonstrate how easy it is to create multi-paradigm solutions, and the way that I dovetail F# code into a .NET solution which is mainly built using C#.&nbsp;As stated in the blog entry on DDD, functional programming techniques are extremely powerful when used to implement domain logic. In this kind of a scenario, anemic domain models are okay, because the business rules are encapsulated inside functions.&nbsp;I'm not going to do a lot in the future using F# in the demo application, however a complete multi-paradigm solution would probably be comprised of 80% C# code, and 20% F# code. This gives you an idea of what's possible.</p>

<h3>Layer Interaction</h3>

<p>Simplistically, this demonstrates how the layers interact with each other.</p>

<p><img alt="Layer Interaction" src="https://blob.jacobsdata.com/software-alchemy/entry8/clean-domain-driven-design-jacobs-layer-interactions-510.png"></p>

<h2>Conclusion</h2>

<p>In this entry I went into detail about how to implement Clean DDD and CQRS in a .NET Core solution. I mentioned some of the experts whose solutions I studied and spoke a little bit about some of their solutions. I presented the use case for a fictional company to create an organization management tool, and I introduced the demo application. I laid out some of the code-level conventions and project-level guidelines for organizing the solution, and I talked about functional organization vs. component organization. Finally, I went into detail about each layer of the architecture, building off the concepts presented in the previous blog entry. Finally, I introduced unit tests at a surface level, and I wrapped up by pointing the way toward building multi-paradigm solutions, which combine both functional F# code with OOP C# code.</p>

<h2>Experts/Authorities/Resources</h2>
<br>
<h3>Robert C. Martin (Uncle Bob)</h3>

<ul>
	<li><a href="http://cleancoder.com/" target="bob1">cleancoder.com</a></li>
	<li><a href="https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html" target="bob2">https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html</a></li>
</ul>

<h3>Roy Osherove</h3>

<ul>
	<li><a href="https://osherove.com/" target="osherove1">https://osherove.com/</a></li>
	<li><a href="https://www.manning.com/books/the-art-of-unit-testing-third-edition" target="osherove2">The Art of Unit Testing</a></li>
</ul>

<h3>Jason Taylor</h3>

<ul>
	<li><a href="https://www.youtube.com/watch?v=_lwCVE_XgqI&amp;feature=youtu.be" target="taylor1">Clean Architecture with ASP.NET Core 2.1</a></li>
	<li><a href="https://github.com/JasonGT/NorthwindTraders" target="taylor2">https://github.com/JasonGT/NorthwindTraders</a></li>
</ul>

<h3>Julie Lerman/Steve Smith</h3>

<ul>
	<li><a href="https://app.pluralsight.com/library/courses/domain-driven-design-fundamentals" target="ls1">Domain-Driven Design Fundamentals</a></li>
	<li><a href="https://github.com/iamijaz/domain-driven-design-fundamentals" target="ls2">https://github.com/iamijaz/domain-driven-design-fundamentals</a></li>
</ul>

<h3>Steve Smith</h3>

<ul>
	<li><a href="https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/" target="smith1">Architect Modern Web Applications with ASP.NET Core and Azure</a></li>
	<li><a href="https://github.com/ardalis/cleanarchitecture" target="smith2">https://github.com/ardalis/cleanarchitecture</a></li>
</ul>

<h3>Jimmy Bogard</h3>

<ul>
	<li><a href="https://jimmybogard.com/" target="bogard1">https://jimmybogard.com/</a></li>
	<li><a href="https://lostechies.com/jimmybogard/" target="bogard2">https://lostechies.com/jimmybogard/</a></li>
	<li><a href="https://github.com/jbogard/MediatR" target="bogard3">https://github.com/jbogard/MediatR</a></li>
</ul>

<h3>Matthew Renze</h3>

<ul>
	<li><a href="https://app.pluralsight.com/library/courses/clean-architecture-patterns-practices-principles" target="renze1">Clean Architecture: Patterns, Practices, and Principles</a></li>
	<li><a href="https://github.com/matthewrenze/clean-architecture-demo" target="renze2">https://github.com/matthewrenze/clean-architecture-demo</a></li>
</ul>

<h3>Vladimir Khorikov</h3>

<ul>
	<li><a href="https://app.pluralsight.com/library/courses/domain-driven-design-in-practice" target="k1">Domain-Driven Design in Practice</a></li>
	<li><a href="https://github.com/vkhorikov/CqrsInPractice.git" target="k2">https://github.com/vkhorikov/CqrsInPractice.git</a></li>
</ul>

<h3>Greg Young</h3>

<ul>
	<li><a href="https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf" target="young1">https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf</a></li>
</ul>

<h3>Dino Esposito</h3>

<ul>
	<li><a href="https://app.pluralsight.com/library/courses/modern-software-architecture-domain-models-cqrs-event-sourcing" target="dino1">Modern Software Architecture: Domain Models, CQRS, and Event Sourcing</a></li>
</ul>

<h3>Microsoft - Microservice/DDD Guide</h3>

<ul>
	<li><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/" target="ms1">.NET Microservices: Architecture for Containerized .NET Applications</a></li>
	<li><a href="https://github.com/dotnet-architecture/eShopOnContainers" target="ms2">https://github.com/dotnet-architecture/eShopOnContainers</a></li>
</ul>

<h3>Code Maid</h3>

<ul>
	<li><a href="http://www.codemaid.net/" target="cm1">http://www.codemaid.net/</a></li>
	<li><a href="https://www.youtube.com/watch?v=M8iwCaw61Mo" target="cm2">https://www.youtube.com/watch?v=M8iwCaw61Mo</a></li>
</ul>

<h3>Dapper</h3>

<ul>
	<li><a href="https://github.com/StackExchange/Dapper" target="dapper1">https://github.com/StackExchange/Dapper</a></li>
</ul>
<hr>
<p>This is entry #8 in the <a href="https://blog.jacobsdata.com/category/foundational%20concepts">Foundational Concepts Series</a></p></div><p>If you want to view or submit comments you must accept the cookie consent.</p></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>