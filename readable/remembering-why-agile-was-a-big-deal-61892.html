<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Remembering Why Agile was a Big Deal - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Remembering Why Agile was a Big Deal - linksfor.dev(s)"/>
    <meta property="article:author" content="by jeremydmiller"/>
    <meta property="og:description" content="Earlier this year I recorded a podcast for Software Engineering Radio with Jeff Doolittle on Agile versus Waterfall Software Development where we discussed the vital differences between Agile devel&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://jeremydmiller.com/2020/05/19/remembering-why-agile-was-a-big-deal/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Remembering Why Agile was a Big Deal</title>
<div class="readable">
        <h1>Remembering Why Agile was a Big Deal</h1>
            <div>by by jeremydmiller</div>
            <div>Reading time: 14-17 minutes</div>
        <div>Posted here: 20 May 2020</div>
        <p><a href="https://jeremydmiller.com/2020/05/19/remembering-why-agile-was-a-big-deal/">https://jeremydmiller.com/2020/05/19/remembering-why-agile-was-a-big-deal/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
			<p data-adtags-visited="true"><em>Earlier this year I recorded a podcast for <a href="https://www.se-radio.net/">Software Engineering Radio</a> with <a href="https://twitter.com/jeffdoolittle">Jeff Doolittle</a> on <a href="https://www.se-radio.net/2020/03/episode-401-jeremy-miller-on-waterfall-versus-agile/">Agile versus Waterfall Software Development</a> where we discussed the vital differences between Agile development and traditional waterfall, and why those differences still matter. This post is the long-awaited companion piece I couldn’t manage to finish before the podcast posted. I might write a follow up post on some software engineering practices like continuous design later so that I can strictly focus here on softer process related ideas.</em></p>
<p data-adtags-visited="true">I started my software development career writing <a href="https://www.webopedia.com/TERM/S/shadow-it.html">Shadow IT</a> applications and automation for my engineering group. No process, no real practices either, and lots of code. As you’d probably guess, I later chafed very badly at the formal waterfall processes and organizational model of my first “real” software development job for plenty of reasons I’ll detail later in this post.</p>
<p data-adtags-visited="true">During that first real IT job, I started to read and learn about alternative iterative development processes like the <a href="https://en.wikipedia.org/wiki/Rational_Unified_Process">Rational Unified Process</a> (RUP), but I was mostly inspired by the brand new, shiny <a href="http://www.extremeprogramming.org/">Extreme Programming</a> (XP) method. After tilting the windmill a bit at my waterfall shop to try to move us away from the waterfall to RUP (Agile would have been a bridge too far), I jumped to a consulting company that was an influential, early adopter of XP. I’ve worked almost exclusively with Agile processes and inside more or less Agile organizational models ever since — until recently. In the past couple years I’ve been involved with a long running project in a classic waterfall shop which has absolutely reinforced my belief in the philosophical approaches to software development that came out of Agile Software (or Lean Programming). I also think some of those ideas are somewhat lost in contemporary Scrum’s monomaniacal focus on project management, so here’s a long blog post talking about what I think really was vital in the shift from waterfall to agile development.</p>
<h3>First, what I believe in</h3>
<p data-adtags-visited="true">A consistent theme in all of these topics is trying to minimize the amount of <a href="https://jeremydmiller.com/2019/06/04/context-is-important/">context switching throughout a project</a>and anybody’s average day. I think that Agile processes made a huge improvement in that regard over the older waterfall models, and that by itself is enough to justify staking waterfall through the heart permanently in my book.</p>
<h4>Self-contained, multi-disciplinary teams</h4>
<p data-adtags-visited="true">My strong preference and a constant recommendation to our clients is to favor self-contained, multi-disciplinary teams centered around specific projects or products. What I mean here is that the project is done by a team who is completely dedicated to working on just that project. That team should ideally have every possible skillset it needs to execute the project so that there’s reduced need to coordinate with external teams, so it’s whatever mix you need of developers, testers, analysts all working together on a common goal.</p>
<p data-adtags-visited="true">In the later sections on what I think is wrong with the waterfall model, I bring up the <a href="http://torqsoftware.com/blogs/apolon/2007/04/fallacy-of-local-optimization.html">fallacy of local optimization</a>. In terms of a software project, we need to focus on optimizing the entire process of delivering working software, not just on what it takes to code a feature, or write tests, or quickly checking off a process quality gate. A self-contained team is hopefully all focused on delivering just one project or sprint, so there should be more opportunity to optimize the delivery. This generally means things like developers purposely thinking about how to support the testers on their team or using practices like <a href="https://cucumber.io/blog/hiptest/what-are-executable-specifications/">Executable Specifications</a> for requirements that shortens the development and testing time overall, even if it’s more work for the original analysts upfront.</p>
<p data-adtags-visited="true">A lot of the overhead of software projects is communication between project team members. To be effective, you need to improve the quality of that communication so that team members have a shared understanding of the project. I also think you’re a lot less brittle as a project if you have fewer people to communication with. In a classic waterfall shop, you may need to be involving a lot of folks from external projects who are simultaneously working on several other initiatives and have a different schedule than your project’s schedule. That tends to force communication into either occasional meetings (which impact productivity on its own) or through asynchronous communication via emails or intermediate documentation like design specifications.</p>
<p data-adtags-visited="true">Let’s step back and think about the various types of communication you use with your colleagues, and what actually works. Take a look at this diagram from Scott Ambler’s <a href="http://agilemodeling.com/essays/communication.htm">Communication on Agile Software Teams</a> essay (originally adapted from some influential writings by Alistair Cockburn that I couldn’t quite find this morning):</p>

<p data-adtags-visited="true"><img data-attachment-id="8702" data-permalink="https://jeremydmiller.com/2020/05/19/remembering-why-agile-was-a-big-deal/communicationmodes/" data-orig-file="https://jeremydmiller.files.wordpress.com/2020/05/communicationmodes.gif" data-orig-size="612,528" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="communicationModes" data-image-description="" data-medium-file="https://jeremydmiller.files.wordpress.com/2020/05/communicationmodes.gif?w=300" data-large-file="https://jeremydmiller.files.wordpress.com/2020/05/communicationmodes.gif?w=612" src="https://jeremydmiller.files.wordpress.com/2020/05/communicationmodes.gif?w=625" alt="communicationModes"></p>
<p data-adtags-visited="true">In a self-contained, multi-disciplinary team, you’re much more likely to be using the more effective forms of communication in the upper, right hand of the graph. In a waterfall model where different disciplines (testers, developers, analysts) may be working in different teams and on different projects at any one time, the communication is mostly happening at the less effective, lower left of this diagram.</p>
<p data-adtags-visited="true">I think that a self-contained team suffers much less from context switching, but I’ll cover that in the section on delivering serially.</p>
<p data-adtags-visited="true">Another huge advantage to self-contained teams is the flexibility in scheduling and the ability to adapt to changing project circumstances and whatever you’re learning as you go. This is the idea of <a href="http://codebetter.com/jeremymiller/2008/02/11/first-causes-reversibility/">Reversibility</a> from Extreme Programming:</p>
<blockquote><p>“If you can easily change your decisions, this means it’s less important to get them right – which makes your life much simpler. ” — <a href="https://www.martinfowler.com/articles/designDead.html#id21604">Martin Fowler</a></p></blockquote>
<p data-adtags-visited="true">In a self-contained team, your reversibility is naturally higher, and you’re more likely able to adapt and incorporate learning throughout the project. If you’re dependent upon external teams or can’t easily change approved specification documents, you have much lower reversibility.</p>
<p data-adtags-visited="true"><em>If you’re interested in Reversibility, I gave a <a href="https://www.youtube.com/watch?v=R0QbL2g_rBI">technically focused talk on that at Agile Vancouver several years ago</a>.&nbsp;</em></p>
<p data-adtags-visited="true">I think everything in this section still applies to teams that are focused on a product or family of products.</p>
<p data-adtags-visited="true">Looking over my history, I’ve written about this topic quite a bit over the years:</p>
<ol>
<li><a href="http://codebetter.com/jeremymiller/2007/08/06/on-software-teams/">On Software Teams</a></li>
<li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2007/08/03/call-me-a-utopian-but-i-want-my-teams-flat-and-my-team-members-broad.aspx">Call me a Utopian, but I want my teams flat and my team members broad</a></li>
<li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2007/04/16/Self-Organizing-Teams-are-Superior-to-Command-n_2700_-Control-Teams.aspx">Self Organizing Teams are Superior to Command n’ Control Teams</a></li>
<li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2007/01/29/Once-Upon-a-Team.aspx">Once Upon a Team</a></li>
<li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2007/01/21/The-Anti-Team.aspx">The Anti Team</a></li>
<li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2007/04/08/On-Process-and-Practices.aspx">On Process and Practices</a></li>
<li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2006/05/06/144188.aspx">Want productivity? Try some team continuity (and a side of empowerment too)</a>&nbsp;– I miss this team.</li>
<li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2006/09/21/The-Will-to-be-Good.aspx">The Will to be Good</a></li>
<li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2005/06/03/129560.aspx">Learning Lessons — Can You Make Mistakes at Work?</a></li>
<li><a href="http://codebetter.com/blogs/jeremy.miller/archive/2006/12/13/Indelible-proof-of-a-healthy-team.aspx">Indelible Proof of a Healthy Team</a></li>
</ol>
<h4>Deliver serially over working in parallel</h4>
<p data-adtags-visited="true">A huge shift in thinking behind Agile Software Development is simply the idea that the only thing that matters is delivering working software. Not design specifications, not intermediate documents, not process checkpoints passed, but actual working software deployed to production.</p>
<p data-adtags-visited="true">In practice, this means that Agile teams seek to deliver completely working features or “<a href="https://agileforall.com/vertical-slices-and-scale/">vertical slices</a>” of functionality at one time. In this model a team strives for the <a href="https://continuousdelivery.com/">continuous delivery</a> model of constantly making little releases of working software.</p>
<p data-adtags-visited="true">Contrast this idea to the old “software as construction” metaphor from my waterfall youth where we generally developed by:</p>
<ol>
<li>Get the business requirements</li>
<li>Do a high level architecture document</li>
<li>Maybe do a lower level design specification (or do a prototype first and pretend you wrote the spec first)</li>
<li>Design the database model for the new system</li>
<li>Code the data layer</li>
<li>Code the business layer</li>
<li>Code any user interface</li>
<li>Rework 4-6 because you inevitably missed something or realized something new as you went</li>
<li>Declare the system “code complete”</li>
<li>Start formal testing of then entire system</li>
<li>Fix lots of bugs on 4-6</li>
<li>User acceptance testing (hopefully)</li>
<li>Release to production</li>
</ol>
<p data-adtags-visited="true">The obvious problems in this cycle is that you deliver no actual value until the very, very end of the project. You’re also struggling quite a bit in the later parts of the project because you’re needing to re-visit work that was done much earlier and you often struggle with the context switching that entails.</p>
<p data-adtags-visited="true">In contrast, delivering in vertical slices allows you to:</p>
<ul>
<li>Minimize context switching because you’re finishing work much closer to when it’s started. With a multi-disciplinary team, every body is focused on a small subset of features at any one time which tends to improve the communication between disciplines.</li>
<li>Actually deliver something much earlier to production and start accruing some business payoff. Moreover, you should be working in the order of business priority, so the most important things are worked on and completed first. Which also serves to fail softer compared to a waterfall project cycle.</li>
<li>Fail softer by delivering part of a project on time if even if you’re not able to complete all the planned features by the theoretical end date — as apposed to failing completely to deliver anything on time in a waterfall model.</li>
</ul>
<p data-adtags-visited="true">In the Extreme Programming days we talked a lot about <a href="http://codebetter.com/jeremymiller/2006/04/14/code-complete-is-a-lie-done-done-done-is-the-truth/">the concept of done, done, done as opposed to being theoretically “code complete.”</a></p>

<h4>Rev’ing up feedback loops</h4>
<p data-adtags-visited="true">After coming back to waterfall development the past couple years, the most frustrating thing to me is how slow the feedback cycles are between doing or deciding something and knowing whether or not anything you did was really correct. It also turns out that having a roomful of people staring at a design specification document in a formal review doesn’t do a great job at spotting a lot of problems that present themselves later in the project when actual code is being written.</p>
<p data-adtags-visited="true">Any iterative process helps tighten feedback cycles and enables you to fix issues earlier. What Agile brought to the table was an emphasis on better, faster, more fine-grained feedback cycles through project automation and practices like continuous integration and test driven development.</p>
<p data-adtags-visited="true">More on the engineering practices in later posts. Maybe. It literally took me 5 years to go from an initial draft to publishing this post so don’t hold your breathe.</p>

<h3><strong>What I think is wrong with classic waterfall development</strong></h3>
<p data-adtags-visited="true">Potentially a lot. Your mileage may vary from mine (my experiences with formal waterfall processes has been very negative) and I’m sure some of you are succeeding just fine with waterfall processes of one sort or another.</p>
<p data-adtags-visited="true">At its most extreme, I’ve observed these traits in shops with formal waterfall methods, all of which I think work against successful delivery and why I think these traits are problematic.</p>
<h4><strong>Over-specialization of personnel</strong></h4>
<p data-adtags-visited="true">I’m not even just talking about developers vs testers. I mean having some developers or groups who govern the central batch scheduling infrastructure, others that own integrations, a front end team maybe, and obviously the centralized database team. Having folks specialized in their roles like this means that it takes more people involved in a project in order to have all the necessary skillset, and that means having a lot more effort to communicate and collaborate between people who aren’t in the same teams or even in the same organizations. That’s a lot of potential project overhead, and it makes your project less flexible as you’re bound by the constraints of your external dependencies.</p>
<p data-adtags-visited="true">The other problem with over-specialization is the <a href="http://codebetter.com/jeremymiller/2007/01/30/once-upon-a-team/">fallacy of local optimization problem</a>, because many folks only have purview over part of a project and don’t necessarily see or understand the whole project.</p>
<h4>Formal, intermediate documents</h4>
<p data-adtags-visited="true">I’m not here to start yet another argument over how much technical documentation is enough. What I will argue about is a misplaced focus on formal, intermediate documents as a quality or process gate. Especially if those intermediate documents are really meant to serve as the primary communication between architects, analysts, and developers. One, because that’s a deeply inefficient way to communicate. Two, because those documents are always wrong because they’re written too early. Three because it’s just a lot of overhead to go through authoring those documents to get through a formal process gate that could be better spent on getting real feedback about the intended system or project.</p>
<h4>Slow feedback cycles</h4>
<p data-adtags-visited="true">Easily the thing I hate the most about “true” waterfall projects is the length of time between getting adequate feedback between the early design and requirements documents and an actually working system getting tested or going through some user acceptance testing from real users. This is an especially pernicious issue if you hew to the idea that formal testing can only start after all designed features are complete.</p>
<p data-adtags-visited="true">The killer problem in larger waterfall projects over my career is that you’re always trying to remember how some piece of code you wrote 3-6 months ago works when problems finally surface from real testing or usage.</p>

<h3>Summary</h3>
<p data-adtags-visited="true">I’d absolutely choose some sort of disciplined Agile process with solid engineering practices over any kind of formal waterfall process any day of the week. I think waterfall processes do a wretched job managing project risks by the slow, ineffective feedback cycles and waste a lot of energy on unevenly useful intermediate documentation.</p>
<p data-adtags-visited="true">Agile hasn’t always been pretty for me though, see <a href="https://jeremydmiller.com/2015/08/31/the-surprisingly-valuable-and-lasting-lessons-i-learned-from-a-horrible-project/">The Surprisingly Valuable and Lasting Lessons I Learned from a Horrible Project</a> about an absolutely miserable XP project.</p>
<p data-adtags-visited="true">Ironically, the most successful project I’ve ever worked on from a business perspective was technically a waterfall project (a certain 20-something first time technical lead basically ignored the official process), but process wasn’t really an issue because:</p>
<ul>
<li>We had a very good relationship with the business partners including near constant feedback about what we were building. That project is still the best collaboration I’ve ever experienced with the actual business experts</li>
<li>There was a very obvious problem to solve for the business that was likely to pay off quickly</li>
<li>Our senior management did a tremendous job being a “shit umbrella” to keep the rest of the organization from interfering with us</li>
<li>It was a short project</li>
</ul>
<p data-adtags-visited="true">And projects like that just don’t come around very often, so I wouldn’t read much into the process being the deciding factor in its success.</p>







			
			
								</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>