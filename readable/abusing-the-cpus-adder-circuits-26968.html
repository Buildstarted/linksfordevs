<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>Abusing the CPU&#x2019;s adder circuits</h1>
        <p>
by Gianni Tedesco <br/>Reading time: 6-7 minutes        </p>
        <p><a href="https://giannitedesco.github.io/2019/06/15/abusing-add.html">https://giannitedesco.github.io/2019/06/15/abusing-add.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section id="main_content">
        <small>15 June 2019</small>


<p>by Gianni Tedesco</p>

<h2 id="where-we-explain-why-kernighans-trick-works">Where we explain why Kernighan‚Äôs trick works</h2>
<p>Have you ever been asked the interview question ‚Äúhow do you count the number of
bits set in an integer?‚Äù</p>

<p>A smart-ass like myself might answer something like:</p>

<div><div><pre><code><span>unsigned</span> <span>int</span> <span>count_set_bits</span><span>(</span><span>unsigned</span> <span>int</span> <span>x</span><span>)</span>
<span>{</span>
	<span>return</span> <span>__builtin_popcount</span><span>(</span><span>x</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Which, on <code>x86_64</code>, produces:</p>
<div><div><pre><code>	<span>xor</span>	<span>eax</span><span>,</span> <span>eax</span>
	<span>popcnt</span>	<span>eax</span><span>,</span> <span>edi</span>
	<span>ret</span>
</code></pre></div></div>

<p>The interviewer, of course, doesn‚Äôt like that. He wants to see you come up with
an algorithm. So you come up with something like this:</p>

<div><div><pre><code><span>unsigned</span> <span>int</span> <span>count_set_bits</span><span>(</span><span>uint32_t</span> <span>x</span><span>)</span>
<span>{</span>
	<span>unsigned</span> <span>int</span> <span>i</span><span>,</span> <span>ret</span><span>;</span>
	<span>for</span><span>(</span><span>ret</span> <span>=</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>32</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
		<span>ret</span> <span>+=</span> <span>!!</span><span>(</span><span>x</span> <span>&amp;</span> <span>(</span><span>1U</span> <span>&lt;&lt;</span> <span>i</span><span>));</span>
	<span>}</span>
	<span>return</span> <span>ret</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Which gives you something like:</p>
<div><div><pre><code>	<span>xor</span>	<span>r8d</span><span>,</span> <span>r8d</span>
	<span>xor</span>	<span>eax</span><span>,</span> <span>eax</span>
	<span>mov</span>	<span>ecx</span><span>,</span> <span>1</span>
	<span>.</span><span>p2align</span> <span>4</span><span>,,</span><span>10</span>
	<span>.</span><span>p2align</span> <span>3</span>
<span>.</span><span>L4</span><span>:</span>
	<span>shlx</span>	<span>edx</span><span>,</span> <span>ecx</span><span>,</span> <span>eax</span>
	<span>test</span>	<span>edx</span><span>,</span> <span>edi</span>
	<span>setne</span>	<span>dl</span>
	<span>movzx</span>	<span>edx</span><span>,</span> <span>dl</span>
	<span>inc</span>	<span>eax</span>
	<span>add</span>	<span>r8d</span><span>,</span> <span>edx</span>
	<span>cmp</span>	<span>eax</span><span>,</span> <span>32</span>
	<span>jne</span>	<span>.</span><span>L4</span>
	<span>mov</span>	<span>eax</span><span>,</span> <span>r8d</span>
	<span>ret</span>
</code></pre></div></div>

<p>Which is, of course, dreadful. But the reason the interviewer likes this is
because it sets up the next question: ‚Äúhow can we optimize this?‚Äù Or if you
want to be more circumspect: ‚Äúwhat if we only expect one or two bits to be
set?‚Äù or ‚Äúwhat if our data is very sparse?‚Äù</p>

<p>Realistically though, you either know about ‚ÄúKernighan‚Äôs trick‚Äù, or, you don‚Äôt.
It goes something like this:</p>
<div><div><pre><code><span>unsigned</span> <span>int</span> <span>count_set_bits</span><span>(</span><span>unsigned</span> <span>int</span> <span>x</span><span>)</span>
<span>{</span>
	<span>unsigned</span> <span>int</span> <span>ret</span><span>;</span>
	<span>for</span><span>(</span><span>ret</span> <span>=</span> <span>0</span><span>;</span> <span>x</span><span>;</span> <span>x</span> <span>&amp;=</span> <span>(</span><span>x</span> <span>-</span> <span>1</span><span>))</span>
		<span>ret</span><span>++</span><span>;</span>
	<span>return</span> <span>ret</span><span>;</span>
<span>}</span>

</code></pre></div></div>

<p>Which, at least for an Intel weenie such as myself, was a pointless exercise
because gcc compiles that to:</p>
<div><div><pre><code>	<span>xor</span>	<span>eax</span><span>,</span> <span>eax</span>
	<span>popcnt</span>	<span>eax</span><span>,</span> <span>edi</span>
	<span>mov</span>	<span>edx</span><span>,</span> <span>0</span>
	<span>test</span>	<span>edi</span><span>,</span> <span>edi</span>
	<span>cmove</span>	<span>eax</span><span>,</span> <span>edx</span>
	<span>ret</span>
</code></pre></div></div>

<p>Which looks like a terrible code-generation bug in gcc. But hey, at least clang
does the right thing here:</p>


<p>Anyway, I digress. Did you notice the <code>x &amp;= (x - 1)</code> part? That is bitwise
woo-woo magic to unset the rightmost bit in <code>x</code>. It‚Äôs a neat trick, and if you
know it you‚Äôll ace this part of the job interview.</p>

<p>But later, when you‚Äôre at home, alone, contemplating the empty meaninglessness
of the universe, you might ask yourself ‚Äúbut why does it work?‚Äù</p>

<h2 id="twos-complement">Two‚Äôs complement</h2>
<p>Let‚Äôs forget the <code>&amp;</code> part and just focus on what <code>x - 1</code> is doing for now.</p>

<p>One thing you‚Äôre going to need to know about is
<a href="https://en.wikipedia.org/wiki/Two%27s_complement">two‚Äôs complement</a>
arithmetic.</p>

<p>I won‚Äôt bore you by recapitulating the details but we should do well to
remember the following equations:</p>

<span><span id="MJXp-Span-1"><span id="MJXp-Span-2"><span><span id="MJXp-Span-3"><span id="MJXp-Span-4"><span id="MJXp-Span-5">x</span><span id="MJXp-Span-6">‚àí</span><span id="MJXp-Span-7">y</span></span><span id="MJXp-Span-8"><span id="MJXp-Span-9"></span><span id="MJXp-Span-10">=</span><span id="MJXp-Span-11">x</span><span id="MJXp-Span-12">+</span><span id="MJXp-Span-13">‚àí</span><span id="MJXp-Span-14">y</span></span></span><span id="MJXp-Span-15"><span id="MJXp-Span-16"><span id="MJXp-Span-17">‚àí</span><span id="MJXp-Span-18">x</span></span><span id="MJXp-Span-19"><span id="MJXp-Span-20"></span><span id="MJXp-Span-21">=</span><span id="MJXp-Span-22"><span id="MJXp-Span-23"><span><span><span><span id="MJXp-Span-25">Àú</span></span><span><span id="MJXp-Span-24">x</span></span></span></span></span></span><span id="MJXp-Span-26">+</span><span id="MJXp-Span-27">1</span></span></span></span></span></span></span>

<p>Therefore:</p>

<span><span id="MJXp-Span-28"><span id="MJXp-Span-29"><span><span id="MJXp-Span-30"><span id="MJXp-Span-31"><span id="MJXp-Span-32">x</span><span id="MJXp-Span-33">‚àí</span><span id="MJXp-Span-34">1</span></span><span id="MJXp-Span-35"><span id="MJXp-Span-36"></span><span id="MJXp-Span-37">=</span><span id="MJXp-Span-38">x</span><span id="MJXp-Span-39">+</span><span id="MJXp-Span-40">‚àí</span><span id="MJXp-Span-41">1</span></span></span><span id="MJXp-Span-42"><span id="MJXp-Span-43"></span><span id="MJXp-Span-44"><span id="MJXp-Span-45"></span><span id="MJXp-Span-46">=</span><span id="MJXp-Span-47">x</span><span id="MJXp-Span-48">+</span><span id="MJXp-Span-49">1111...</span></span></span></span></span></span></span>

<p>So the magic rune is just adding all one‚Äôs to our original value.</p>

<h2 id="half-adder">Half adder</h2>
<p>So here‚Äôs the part where we get in to how addition really works. You probably
have a good handle on this already from your school days, but let‚Äôs refresh.</p>

<p>The simplest case is if we‚Äôre just adding together a couple of 1-bit numbers.</p>

<p>Let‚Äôs write out the truth table for that:</p>

<table>
  <thead>
    <tr>
      <th>x</th>
      <th>y</th>
      <th>result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0‚Ä¶ oh yeah, we need to carry‚Ä¶</td>
    </tr>
  </tbody>
</table>

<p>Let‚Äôs try again:</p>

<table>
  <thead>
    <tr>
      <th>x</th>
      <th>y</th>
      <th>result</th>
      <th>carry</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>Right, if we‚Äôre going to expand this to add numbers with more than one bit,
we‚Äôre going to need to do something about this carry output.</p>

<h2 id="full-adder">Full adder</h2>
<p>Let‚Äôs call the last adder with 2 inputs, and 2 outputs, the ‚Äúhalf-adder.‚Äù</p>

<p>The full adder is going to have 3 inputs: the 2 operands, and then a carry-in
which is going to be connected to the next least significant bit‚Äôs carry-out.</p>

<table>
  <thead>
    <tr>
      <th>x</th>
      <th>y</th>
      <th>carry-in</th>
      <th>result</th>
      <th>carry-out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>So you can see in this example of a 4-bit adder that there‚Äôs this chain of
carry inputs going from right to left:</p>

<p><img src="https://giannitedesco.github.io/assets/images/4-bit_ripple_carry_adder.png" alt="there" title="4-bit ripple carry adder"></p>

<p>Thanks to <a href="https://en.wikipedia.org/wiki/User:Cburnett">Colin M.L. Burnett</a>
for the excellent diagram.</p>

<h2 id="putting-it-all-together">Putting it all together</h2>
<p>The basic outline of the algorithm is that we start with an input, <code>x</code>. And as
long as it isn‚Äôt zero, we unset the least significant bit, and increment the
result.</p>

<p>So if the input is <code>1000_1100</code>, the loop will iterate 3 times.</p>

<p><code>x &amp;= (x - 1)</code> is an operation which clears the least-significant set bit in
the input, <code>x</code>.</p>

<p>Since we‚Äôre going to do <code>x &amp;= mask</code>, that must mean that <code>mask</code> has a zero in
the position we want to zero out. And it can‚Äôt have any zeroes where the input
has a one.</p>

<p>So we abuse the carry-chain to create such a mask. By adding <code>1111_1111</code> to the
input, we‚Äôre essentially ensuring that the carry signal is not asserted until
we hit the first one bit, but after that it will be asserted for all the rest
of the bits (travelling from right to left).</p>

<p>If we extract the relevant parts of the adder truth table we can see how the
addition operation will produce the mask that we need:</p>

<table>
  <thead>
    <tr>
      <th>x</th>
      <th>y</th>
      <th>cin</th>
      <th>result</th>
      <th>cout</th>
      <th>explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>Before the first bit, produce ones</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>For the first bit, produce a zero and set the carry going</td>
    </tr>
    <tr>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>now the result is zero if x was 0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
      <td>or 1 if x was one</td>
    </tr>
  </tbody>
</table>

<p>What that gives us is a number which is (from right to left):</p>
<ol>
  <li>all ones (but that‚Äôs okay because corresponding input bits are zeroes)</li>
  <li>zero for the first one bit (which ensures that it will be cleared)</li>
  <li>and then equal to the input after that (leaving all higher bits unchanged)</li>
</ol>



  <small>tags: <em>binary</em> - <em>logic</em> - <em>bitwise-hacks</em></small>








      </section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>

</body>
</html>