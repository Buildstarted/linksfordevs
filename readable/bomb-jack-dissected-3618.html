<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Bomb Jack Dissected - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Bomb Jack Dissected - linksfor.dev(s)"/>
    <meta property="og:description" content="TL;DR: what I learned about the Bomb Jack arcade machine while writingan emulator for it."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://floooh.github.io/2018/10/06/bombjack.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Bomb Jack Dissected</title>
<div class="readable">
        <h1>Bomb Jack Dissected</h1>
            <div>Reading time: 30-38 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://floooh.github.io/2018/10/06/bombjack.html">https://floooh.github.io/2018/10/06/bombjack.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
      <div>
        <article itemscope="" itemtype="https://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><strong>TL;DR</strong>: what I learned about the Bomb Jack arcade machine while writing
an emulator for it.</p>

<p><img src="https://floooh.github.io/images/bombjack_logo.png" alt="Bomb Jack Logo"></p>

<p>I wrote a little Bomb Jack arcade emulator last week, mainly to learn
how those early 8-bit arcade machines differed in design from 8-bit home
computers.</p>

<p>Playing arcade games like Bomb Jack as a kid at the summer fair in my home
town was one of those ‘life-changing moments’ that I only recognized much
later as such. On a typical summer day, after I had spent all my coin budget
on arcade games (usually didn’t take very long) I walked home with the head
full of colors and sound effects, trying to figure out how those games
worked. And then for the rest of the year spend all my after-school time
trying to build rather poor impressions of those arcade games on my home
computer, not unlike a cargo-cult worshipper on a post-WWII pacific island trying to
build a US military radio station from wooden sticks.</p>

<p>At first I’ve been playing with the idea of writing a <em>Pengo</em> emulator, since
this burned itself even more into my teenager-brain than Bomb Jack (this is my
<a href="https://floooh.github.io/tiny8bit/kc85.html?type=kc85_3&amp;file=kc85/pengo.kcc">cargo-cult version of
Pengo</a> btw).
But the Pengo arcade hardware would require new chip emulators for sound and
video, while Bomb Jack only needs parts I already had working (Z80 as CPU
and the AY-3-8910 for sound), so I went for Bomb Jack first.</p>

<p>Bomb Jack was also a good opportunity to finally add NMI (non-maskable interrupt)
support to my Z80 emulator. None of the Z80 machines I emulated before
used NMIs, and it didn’t make much sense to implement a feature when I have
no way to test whether it even works.</p>

<p>If you don’t know what Bomb Jack is, it looks like this (not sure if I got the
screen aspect ratio right):</p>

<p><img src="https://floooh.github.io/images/bombjack_1.png" alt="Bomb Jack Screenshot"></p>

<p>…you can check out the WebAssembly version of the emulator here:</p>

<p><a href="https://floooh.github.io/tiny8bit/bombjack.html">https://floooh.github.io/tiny8bit/bombjack.html</a></p>

<p>After the boot sequence has finished and the hiscore screen appears,
press <strong>1</strong> to insert coins, and than <strong>Enter</strong> (or any other key
except arrows and space) to start a game.</p>

<p>In the game, use <strong>arrows keys</strong> for direction, and <strong>space</strong> to jump. While
in the air tap <strong>space</strong> to reduce falling speed.</p>

<p>The source code is here:</p>

<p><a href="https://github.com/floooh/chips-test/blob/master/examples/sokol/bombjack.c">https://github.com/floooh/chips-test/blob/master/examples/sokol/bombjack.c</a></p>

<p>This uses the <a href="https://github.com/floooh/chips">chips headers</a> to provide
the Z80 and AY-3-8910 emulations, and the <a href="https://github.com/floooh/sokol">sokol headers</a> as cross-platform wrapper (application
entry, rendering, input and audio).</p>

<h2 id="step-1-research">Step 1: Research</h2>

<p>“Research” is a grand word for typing “Bombjack arcade hardware specs” into
Google ;)</p>

<p>Compared to popular 80’s home computers (or even obscure Eastern European
computers, which often still have active communities), there’s very little
information for Bomb Jack on the web.</p>

<p>The two useful pieces of information I found are the original <a href="https://github.com/floooh/emu-info/blob/master/misc/bombjack-schematics.pdf">hardware
schematics</a>,
and of course the <a href="https://github.com/mamedev/mame/blob/master/src/mame/drivers/bombjack.cpp">MAME emulator source
code</a>.</p>

<p>There’s also a project which implements <a href="http://papilio.cc/index.php?n=Playground.BombJack">Bomb Jack in an FGPA</a> 
where the VHDL source yielded some details where the schematics miss information.</p>

<p>The MAME sources may be a bit hard to grok, because the arcade emulations
are usually just a bunch of macros describing how the different hardware
parts interact, but there’s little actual <em>source code</em> to read.</p>

<p>But the macro-hardware-descriptions, and especially the comments are still
very helpful to understand how the hardware works, and in those places where
it all becomes a bit too obscure (for instance the <a href="https://github.com/mamedev/mame/blob/master/src/mame/video/bombjack.cpp">video decoding
part</a>)
a bit of trial and error, and running the finger through the hardware
schematics is enough to clear up the confusion.</p>

<h2 id="hardware-overview">Hardware Overview</h2>

<p>The most interesting feature of the Bomb Jack hardware is that it’s actually
<strong>two computers</strong> duck-taped together, there’s a <strong>mainboard</strong> with a Z80 CPU
and the video decoding hardware, and a separate <strong>soundboard</strong> with its own
Z80 CPU and 3 (yes, three!!) AY-3-8910 sound chips.</p>

<p>The video decoding hardware on the mainboard isn’t implemented in an
integrated circuit, instead it’s lots and lots of little general-purpose
chips (taking up 6 of the 10 schematics pages). For the emulator I took a
shortcut here: instead of emulating the video decoding hardware piece by
piece, I only emulated its behaviour by creating the right visual output
from the inputs, without caring too much how the hardware inbetween actually
works.</p>

<p>This shortcut-approach is totally fine for a dedicated arcade machine which
only ever needs to run one program. If the game looks and feels right, the
emulation is “good enough”.</p>

<p>This ‘shortcut approach’ is also an important difference to most home
computer emulators: some games demand a more precise emulation than others,
for instance machines like the C64 or Amstrad CPC need a very precise emulation down
to the clock cycle for the video systems for some games and graphics demos to
work.</p>

<p>It also means that my existing CPU and sound-chip emulators are a
bit overkill for Bomb Jack, for instance the Z80 CPU is running with
machine-cycle granularity when a simpler and faster instruction granularity
emulation would definitely be good enough.</p>

<h2 id="the-main-board">The Main Board</h2>

<p>Usually the first thing I try to find out when writing a new emulator is the
memory map (where are the ROM and RAM areas, the video memory, and
special IO addresses or ports).</p>

<p>The Bomb Jack mainboard only has one ‘interesting’ chip, the Z80 CPU running
at 4 MHz. The entire remaining space on the mainboard is dedicated to the
video decoding hardware (besides a couple of RAM and ROM chips).</p>

<p>The 16-bit address space looks like this:</p>

<ul>
  <li><strong>0000..7FFF</strong>: 32 KByte ROM</li>
  <li><strong>8000..8FFF</strong>: 4 KByte general purpose RAM</li>
  <li><strong>9000..93FF</strong>: 1 KByte video RAM</li>
  <li><strong>9400..97FF</strong>: 1 KByte color RAM</li>
  <li><strong>9820..987F</strong>: 96 bytes sprite RAM</li>
  <li><strong>9C00..9CFF</strong>: 256 bytes color palette RAM</li>
  <li><strong>9E00, B000..B005, B800</strong>: IO ports</li>
  <li><strong>C000..DFFF</strong>: 8 KByte ROM</li>
</ul>

<p>The IO port area looks like this, some of the ports are write-only,
some are read-only, and some have different functions when read or written:</p>

<ul>
  <li><strong>9E00</strong>:     write: the current background-image number, read: —</li>
  <li><strong>B000</strong>:     read: player 1 joystick state, write: NMI enable/disable mask</li>
  <li><strong>B001</strong>:     read: player 2 joystick state, write: —</li>
  <li><strong>B002</strong>:     read: coins and start buttons, write: —</li>
  <li><strong>B003</strong>:     read: CPU watchdog, write: ???</li>
  <li><strong>B004</strong>:     read: dip-switches 1, write: flip screen</li>
  <li><strong>B005</strong>:     read: dip-switches 2, write: —</li>
  <li><strong>B800</strong>:     write: command to soundboard, read: —</li>
</ul>

<p>There’s a few noteworthy things:</p>

<ul>
  <li>There’s a LOT of ROM (40 KBytes), and not a lot of RAM (about 7 KBytes, with
only 4 KByte ‘general purpose RAM’)</li>
  <li>There’s only 2 KBytes for ‘display RAM’, divided into 2 chunks of 1 KByte,
this looks very small for driving a colorful 256x256 display which appears to have
per-pixel colors</li>
  <li>It’s a memory-mapped-IO system!</li>
</ul>

<p>Memory-mapped-IO is a bit unusual for a Z80 machine, since one of the
defining features of the Z80 is the separate 16-bit address space for device-IO,
so that no precious memory address space needs to be wasted. Memory mapped IO
is typically a feature found on computers with a 6502 CPU.</p>

<p>A quick look into the schematics confirms this: There’s no IORQ pin anywhere
to be found on the mainboard CPU, only the MREQ pin is connected (which
is used to initiate a memory read or write):</p>

<p><img src="https://floooh.github.io/images/bombjack_iorq.png" alt="Bomb Jack IORQ"></p>

<p>This means I don’t need to care about IO requests in the emulator’s mainboard CPU
tick function at all, only about memory requests.</p>

<p>While snooping around the schematics, there’s another interesting mainboard CPU detail:</p>

<p>Only the NMI pin is connected, while the INT pin is always kept high/inactive (meaning
no ‘regular’ maskable interrupts will happen, only non-maskable interrupts):</p>

<p><img src="https://floooh.github.io/images/bombjack_nmi.png" alt="Bomb Jack IORQ"></p>

<p>This is also quite unusual for a Z80 machine. All Z80-based home computers
I’ve seen so far had it the other way around, they only used maskable
interrupts, and never non-maskable interrupts. The maskable interrupt
handling on the Z80 is very flexible and a big improvement over the rather
primitive interrupt system of its ‘illegitimate father’, the Intel 8080, or
its rival, the MOS 6502. But this improved flexibility is also more complex
to implement in hardware (unless other Z80-family chips are used as interrupt
source, those have the complex interrupt ‘daisy-chain’ protocol already baked
in).</p>

<p>Ok, enough with the hardware details for now, onward to the emulator!</p>

<h2 id="the-boot-sequence">The Boot Sequence</h2>

<p>The next step after figuring out the memory configuration is to hook up an
emulated CPU to the emulated memory map, write some adhoc visualization of
the video memory content, and start ticking the CPU.</p>

<p>And surprisingly, this crude approach is often enough to run through the
boot sequence and get <em>something</em> on screen. For the Bomb Jack emulator I
simply took the content of the 1 KByte video memory at the range 0x9000 to
0x93FF as a 32x32 byte matrix, and when the byte is 0, render a black 8x8
pixel block, otherwise a white pixel block.</p>

<p>Then simply start the emulated CPU and hope for the best. And behold! Something
recognizable appears:</p>

<p><img src="https://floooh.github.io/images/bombjack_boot_1.png" alt="Bomb Jack Boot 1">
<img src="https://floooh.github.io/images/bombjack_boot_2.png" alt="Bomb Jack Boot 2"></p>

<p>The left image looks a lot like the hardware testing screen during boot, and
the right image like the hiscore screen that appears when the boot
sequence is over:</p>

<p><img src="https://floooh.github.io/images/bombjack_boot_3.png" alt="Bomb Jack Boot 3">
<img src="https://floooh.github.io/images/bombjack_boot_4.png" alt="Bomb Jack Boot 4"></p>

<p>…but 90 degrees rotated (which figures because arcade cabinets often had
the screen in vertical ‘portrait mode’ orientation).</p>

<p>Ok very promising start!</p>

<p>The next step would be figuring out how to turn
those white blocks into colored pixels… (huuuge jump now, the details
are described below in the section on video decoding).</p>

<p>At first everything went quite smoothly, the test screen during boot had
pixels and colors (later I noticed that the color decoding was all wrong, but
anyway):</p>

<p><img src="https://floooh.github.io/images/bombjack_boot_6.png" alt="Bomb Jack Boot 5"></p>

<p>But where the hiscore screen should appear I ended up with a black screen.
Hacking the background color to ‘not black’ revealed that the pixels are rendered,
but the color palette was set to all black. Hmm…</p>

<p><img src="https://floooh.github.io/images/bombjack_boot_5.png" alt="Bomb Jack Boot 5"></p>

<p>After staring at this screen for a few minutes, I remembered that some colors
on the hiscore screen were animated, and when there’s animation there needs
to be some timer, and the obvious time source in this hardware config would be the
display’s VSYNC signal, and the VSYNC is hooked up to the CPU’s NMI pin (or
rather the VBLANK, which is the short duration between the VSYNC signal and the
cathode ray tube beam travelling back to the top-left corner).</p>

<p>And I didn’t have implemented any of this yet…</p>

<p>On the next evening, after I had added a first version of the NMI handling
to the Z80 emulation and hooked this up to an adhoc vsync/vblank counter
in the mainboard’s CPU tick function, a lot of things suddenly started to
happen!</p>

<p>First, the hiscore screen had colors, and some of them were animated:</p>

<p><img src="https://floooh.github.io/images/bombjack_nmi_1.png" alt="Bomb Jack NMI 1"></p>

<p>And after a few seconds, more exciting things happened! The hiscore screen
disappeared, and a weird rendition of the first map showed up. This was
clearly the arcade cabinet’s attract mode, I could see the first level, and
some color-animated bombs which disappeared as an imaginary Bomb Jack jumped
around the map collecting those bombs:</p>

<p><img src="https://floooh.github.io/images/bombjack_nmi_2.png" alt="Bomb Jack NMI 2"></p>

<p>Colors were still totally wrong, but nevertheless: PROGRESS!</p>

<p>This was the right time to take care of the rest of the video decoding:</p>

<h2 id="the-video-hardware">The Video Hardware</h2>

<p>At first glance the Bomb Jack video hardware looks very powerful for 
an 8-bit machine from 1984: even though it only has a 256x256 pixel
resolution, it can display 128 (out of 4096) colors at the same time,
and render up to 24 hardware sprites (16x16 or 32x32 pixels big), all
with per-pixel colors.</p>

<p>8-bit home computers of the time had about the same display resolution,
but with many restrictions when it comes to colors, those restrictions can
be seen nicely when comparing the Bomb Jack versions for the ZX Spectrum and
Amstrad CPC with the Arcade version:</p>

<p>The <a href="https://floooh.github.io/tiny8bit/zx.html?file=zx/bombjack_zx.z80&amp;joystick=kempston&amp;type=zx48k">ZX Spectrum version</a> 
has a pretty good pixel resolution 256x192), but very
few colors, and it suffers from the Spectrum’s typical ‘color clash’ effect
(although the developers did a pretty good job to not make this too
obvious):</p>

<p><img src="https://floooh.github.io/images/bombjack_zx.png" alt="Bomb Jack ZX"></p>

<p>The <a href="https://floooh.github.io/tiny8bit/cpc.html?file=cpc/bomb_jack.sna&amp;joystick=true">Amstrad CPC version</a> 
is more colorful, but in order to get more colors
they had to switch to a low-resolution display mode (160x200), with the result
that Jack and the monster are a lowres pixel mess:</p>

<p><img src="https://floooh.github.io/images/bombjack_cpc.png" alt="Bomb Jack CPC"></p>

<p>Compare that with the Arcade version which has about the same pixel
resolution as the ZX Spectrum, but with many more colors <em>and</em> 
a per-pixel color resolution:</p>

<p><img src="https://floooh.github.io/images/bombjack_arcade.png" alt="Bomb Jack Arcade"></p>

<p>Now the interesting part is that the arcade version doesn’t have better
graphics because it runs on more powerful hardware (it has more ROM to store
more image data, but the ‘computing power’ is roughly the same), instead the
hardware designers could focus on building a specialized machine for one
specific type of game, they didn’t have to create a flexible and general
purpose home computer.</p>

<p>Here’s how the display hardware works (at least my high-level interpretation
of it):</p>

<h2 id="the-3-display-layers">The 3 Display Layers</h2>

<p>The final Bomb Jack video output is composed from 3 layers: background layer,
foreground layer and sprite layer.</p>

<p>This layer system has 2 main advantages:</p>

<ul>
  <li>it implements a fairly clever hardware image compression to generate
a colorful “high-resolution” image from very little data</li>
  <li>it drastically reduces the amount of CPU work necessary to update
dynamic elements on the screen (even at 4 MHz, an 8-bit CPU by far doesn’t
have enough performance to move that much stuff around on a 256x256 
display at 60 Hz)</li>
</ul>

<p>The video hardware is fairly different from what I’ve seen on 8-bit home
computers, but since MAME has implemented generic helper classes for this
sort of hardware I assume it was fairly common on arcade machines.</p>

<h3 id="the-background-layer">The Background Layer</h3>

<p>The background layer can render 1 of 5 predefined background images hardwired
into ROM. A background image is selected by writing a value
between 1 and 5 to the address 0x9E00 (value 0 seems to be special and renders
an all-black background).</p>

<p>The hardware actually seems to be capable of rendering 7 different
images, but the game only uses 5. I was secretly hoping to find previously
undiscovered image data in the ROMs. But alas, there aren’t any (and I probably
wasn’t the first one to look either)</p>

<p>This is what the background layer for the first map looks like without the other two layers:</p>

<p><img src="https://floooh.github.io/images/bombjack_bg.png" alt="Bomb Jack Background"></p>

<p>The background layer is built from <strong>16x16</strong> pixel tiles.</p>

<p>The advantage of building the background images from tiles is that identical
tiles can be reused, so that less image data needs to be stored in ROMs. Note
how the blue sky, parts of the pyramid and the sand below the pyramid use 
identical tiles:</p>

<p><img src="https://floooh.github.io/images/bombjack_bg_tiles.png" alt="Bomb Jack Background Tiles"></p>

<p>The background layer hardware implements another trick to save some memory,
tiles can be flipped horizontally. I almost didn’t implement this because 
I assumed that the software doesn’t use this hardware feature, until I 
noticed a subtile bug in the 3rd map background:</p>

<p><img src="https://floooh.github.io/images/bombjack_bg_3.png" alt="Bomb Jack Background 3"></p>

<p>The same trick is used on the 5th map, it’s a bit harder to notice there 
though if you don’t know what to look for:</p>

<p><img src="https://floooh.github.io/images/bombjack_bg_5.png" alt="Bomb Jack Background 5"></p>

<h3 id="the-foreground-layer">The Foreground Layer:</h3>

<p>On top of the background layer is a ‘foreground layer’, which renders any
non-movable parts of the screen that must still be updated by the CPU
(mainly text, platforms and bombs). The layout is read from RAM (the 1 KB
video RAM and 1 KB color RAM chunks).</p>

<p>This is what the isolated foreground layer looks like for the first map:</p>

<p><img src="https://floooh.github.io/images/bombjack_fg.png" alt="Bomb Jack Foreground"></p>

<p>The foreground layer is also tiled (just like the background layer), but uses
smaller 8x8 tiles:</p>

<p><img src="https://floooh.github.io/images/bombjack_fg_tiles.png" alt="Bomb Jack Background Tiles"></p>

<p>The main advantage of keeping background and foreground in separate layers is
that the CPU doesn’t need to care about storing and restoring background
pixels when foreground elements are created or removed.</p>

<h3 id="the-sprite-layer">The Sprite Layer</h3>

<p>Finally on top of the foreground layer, the hardware sprites are rendered.
Everything that’s moving around on screen is done with sprites.
The Bomb Jack hardware can render up to 24 sprites, where each sprite
can be either 16x16 or 32x32 pixels, and sprites can be positioned 
with pixel resolution:</p>

<p><img src="https://floooh.github.io/images/bombjack_sprites.png" alt="Bomb Jack Sprites"></p>

<h2 id="the-8x8-tile-decoder">The 8x8 Tile Decoder</h2>

<p>At the heart of the video decoding hardware is a color palette with 
128 entries and an 8x8-pixel tile decoder. The job of the tile decoder
is to generate a 7-bit color palette index for each of the 64 pixels
in a tile.</p>

<p>Those 8x8 tiles are the building blocks for everything on screen, the 16x16
background tiles, 8x8 foreground tiles, and the 16x16 or 32x32 hardware
sprites.</p>

<p>Here’s a functional diagram of this 8x8 tile decoder for the foreground
layer rendering (as far as I understood it):</p>

<p><img src="https://floooh.github.io/images/bombjack_8x8.jpg" alt="Bomb Jack Tile Decoding"></p>

<p>A top-to-bottom explanation of the diagram:</p>

<ul>
  <li>The decoding process starts at the top by reading a ‘tile code’ byte from
the video RAM (organized as a 32x32 matrix of tile codes), and a separate
byte from the color RAM (also a 32x32 matrix). Fetching the tile- and
color-codes from video RAM only happens for the foreground layer, but I added
this because it makes the ‘overall picture’ a bit clearer. The 8x8 tile
decoder itself only needs a tile- and color-code as input.</li>
  <li>The tile code is used as index to lookup 3 separate pixel bitplanes, those
pixel bitplanes are always stored in ROM (you can think of the pixel
bitplanes as font data or sprite sheets). Each of the 3 display layers has
its own tile ROMs, and those ROMs are only visible to the decoding hardware,
not to the CPU (so they don’t take up valuable CPU address space).</li>
  <li>A single pixel bitplane consists of 8 bytes per tile, with each byte
holding 8 pixels (one bit per pixel). Since the pixel data for each tile is
built from 3 bitplanes this means an 8x8 tile requires 24 bytes of ROM data
to describe its appearance (3 bits per pixel).</li>
  <li>For each of the 64 pixels in a tile, a 7-bit value is constructed. The
lower 3 bits are provided by the tile bitplanes read from the tile ROMs, and
the higher 4 bits are provided by the color value byte. This basically means
that each tile can select one of 16 ‘slots’ from the color palette, with each
slot having 8 colors. Each tile pixel can select one of the 8 colors in the
tile’s palette slot.</li>
  <li>This 7-bit index built from bitplanes and tile-color-value is used to
lookup a 12-bit RGB color value from the color palette (4 bits per color
channel). The color palette is located in RAM and can be manipulated by the
CPU (as far as I have seen the video-, color- and palette-RAMs are
write-only, at least the CPU never does read-accesses on those areas).</li>
</ul>

<p>This is the basic tile decoding that’s used by each of the 3 display layers,
but each layer decoding differs in small details:</p>

<ul>
  <li>The foreground layer can actually render 512 different 8x8 tiles. This
requires 9-bit tile codes, but the video RAM only provides 8 bits per tile.
The 9th bit is ‘borrowed’ from the 5th bit of the color value (since only 4
bits of the color value are used to build the color palette index, there
are 4 bits free for other purposes). If the 3 bits from the 8x8 tile
bitplanes are all zero, the foreground pixel is transparent, and the
background pixel ‘peeks through’.</li>
  <li>The background layer uses 16x16 tiles, so it only needs 16x16=256 tile code
values and 256 color values to describe one background image in the
background image ROM (512 bytes per image). The twist is though that the
16x16 pixel bitplanes are layed out as four 8x8 tiles, so that the same 8x8
tile decoder hardware can be used. As mentioned above, background tiles can
be horizontally flipped, this is controlled with one of the ‘spare’ color
value bits: if bit 7 of the color value is set, the tile will be flipped.</li>
  <li>Each hardware sprite can either be 16x16 pixels or 32x32 pixels, and the
tile bitplanes are also layed out as 4 or 16 consecutive 8x8 tiles in the
sprite tile ROMs. This means a 16x16 sprite needs 96 bytes, and a 32x32 sprite
a whopping 384 bytes in the tile ROMs. As with foreground tiles, if all 3
pixel bitplane bits are zero, the sprite pixel is transparent.</li>
</ul>

<p>To get a better idea what the tile bitplanes look like, I wrote a little
<a href="https://gist.github.com/floooh/5f44cce30912142e726bb4ff783e24b8">C program</a> to convert the tile ROMs into PNG files (with the 3 bits per 
pixel converted into 8 levels of grey).</p>

<p>This is the foreground layer tile ROM. You can see the numbers and text
font data, the platform tiles, bombs (split in half), parts of the 
Bomb Jack splash screen logo, and the score multiplier numbers that 
appear at the top of the screen (btw, everything is 90 degree rotated
because the whole screen is rotated too):</p>

<p><img src="https://floooh.github.io/images/bombjack_tilerom_fg.png" alt="Bomb Jack Foreground Tile ROM"></p>

<p>Next the background tile ROM, this doesn’t look very recognizeable because
what you see is the 8x8 tile decoding of 16x16 tiles. Each 16x16 tile
is created from four neighbouring 8x8 tiles. But it’s possible to recognize
the fairly regular pieces for the greek temple on map 2, the castle
on map 3 and the sky scrapers on map 4.</p>

<p><img src="https://floooh.github.io/images/bombjack_tilerom_bg.png" alt="Bomb Jack Background Tile ROM"></p>

<p>And finally the sprite tile ROM. The 16x16 sprites take up the upper half,
and the 32x32 sprites the lower half.</p>

<p><img src="https://floooh.github.io/images/bombjack_tilerom_sprites.png" alt="Bomb Jack Sprite Tile ROM"></p>

<p>An interesting hack in the Bomb Jack splash screen is that the logo is
constructed from foreground tiles and sprites, I guess the developers were
running out of foreground tile ROM, but had some space to spare in the 
sprite ROM:</p>

<p><img src="https://floooh.github.io/images/bombjack_splash_1.png" alt="Bomb Jack Splash 1">
<img src="https://floooh.github.io/images/bombjack_splash_2.png" alt="Bomb Jack Splash 2">
<img src="https://floooh.github.io/images/bombjack_splash_3.png" alt="Bomb Jack Splash 3"></p>

<h2 id="the-sprite-hardware">The Sprite Hardware</h2>

<p>The Bomb Jack sprite hardware is very powerful compared to what home computers
provided at the time:</p>

<ul>
  <li>up to 24 hardware sprites can be rendered, seemingly without restrictions
how many sprites can be shown on a scanline</li>
  <li>sprites can be 16x16 or 32x32 pixels</li>
  <li>each sprite can choose one of 16 ‘8-color-slots’ in the shared color palette</li>
  <li>sprites have a per-pixel color resolution</li>
  <li>each sprite can be vertically and horizontally flipped</li>
  <li>each sprite can select one of 128 hardwired sprite images in ROM</li>
</ul>

<p>The pixel- and color-decoding of the sprite system uses the same basic 8x8
tile decoding that’s also used in the background- and foreground-layer.</p>

<p>The sprite attributes are mapped into the address range 0x9820 to 0x987F,
96 bytes, 4 bytes per sprite. As far as I’ve seen, this is a write-only area,
at least there are no CPU read accesses happening on this memory range.</p>

<p>Each sprite is described by 4 bytes:</p>

<ul>
  <li><strong>Byte 0</strong>:
    <ul>
      <li><strong>Bit 7</strong>: if set, this is a 32x32 sprite, otherwise 16x16</li>
      <li><strong>Bits 6..0</strong>: 7 bits to define the tile code for the sprite, used
to look up the sprite’s image bitplanes in the tile ROMs</li>
    </ul>
  </li>
  <li><strong>Byte 1</strong>:
    <ul>
      <li><strong>Bit 7</strong>: if set, the sprite is horizontally flipped</li>
      <li><strong>Bit 6</strong>: if set, the sprite is vertically flipped</li>
      <li><strong>Bits 3..0</strong>: 4 bits to provide the color value for the tile decoder</li>
    </ul>
  </li>
  <li><strong>Byte 2</strong>: the sprite’s X position on screen</li>
  <li><strong>Byte 3</strong>: the sprite’s Y position on screen</li>
</ul>

<p>It’s unclear what the bits 4 and 5 of byte 1 do, a comment in MAME
has this to say:</p>

<div><div><pre><code> e        ? (set when big sprites are selected)
 f        ? (set only when the bonus (B) materializes?)
</code></pre></div></div>

<h2 id="the-memory-mapped-io-ports">The Memory Mapped IO Ports</h2>

<p>A few notes about the IO ports of the mainboard, as mentioned above,
the IO ports look like this:</p>

<ul>
  <li><strong>9E00</strong>:     write: the current background-image number, read: —</li>
  <li><strong>B000</strong>:     read: player 1 joystick state, write: NMI enable/disable mask</li>
  <li><strong>B001</strong>:     read: player 2 joystick state, write: —</li>
  <li><strong>B002</strong>:     read: coins and start buttons, write: —</li>
  <li><strong>B003</strong>:     read: CPU watchdog, write: ???</li>
  <li><strong>B004</strong>:     read: dip-switches 1, write: flip screen</li>
  <li><strong>B005</strong>:     read: dip-switches 2, write: —</li>
  <li><strong>B800</strong>:     write: command to soundboard, read: —</li>
</ul>

<p>The location 0x9E00 (background image selection) has already been handled above,
and the location 0xB800 (sound command) will be handled in the next section,
this leaves the locations 0xB000 to 0xB005:</p>

<p>Reading from location 0xB000 and 0xB001 returns the current state of the
2 joysticks. A set bit indicates that a joystick trigger is closed:</p>

<ul>
  <li><strong>bit 0</strong>: right direction</li>
  <li><strong>bit 1</strong>: left direction</li>
  <li><strong>bit 2</strong>: up direction</li>
  <li><strong>bit 3</strong>: down direction</li>
  <li><strong>bit 4</strong>: jump button pressed</li>
</ul>

<p>The remaining 3 bits are ignored.</p>

<p>Reading from 0xB002 returns the state of the coin-detector and start buttons:</p>

<ul>
  <li><strong>bit 0</strong>: player 1 coin inserted</li>
  <li><strong>bit 1</strong>: player 2 coin inserted</li>
  <li><strong>bit 2</strong>: player 1 start button</li>
  <li><strong>bit 3</strong>: player 2 start button</li>
</ul>

<p>Reading from addresses 0xB004 and 0xB005 provides the state of dip-switches
which are used to customize the arcade machine’s behaviour:</p>

<ul>
  <li><strong>B004</strong>:
    <ul>
      <li><strong>bits 0,1</strong>: how many ‘plays’ are given per coin (1, 2, 3 or 5)</li>
      <li><strong>bits 2,3</strong>: the same for player 2</li>
      <li><strong>bits 4,5</strong>: how many lifes per play (3, 4, 5 or 2)</li>
      <li><strong>bit 6</strong>: whether the arcade machine is a ‘cocktail table’, or ‘upright’</li>
      <li><strong>bit 7</strong>: whether to play sound while idle</li>
    </ul>
  </li>
  <li><strong>B005</strong>:
    <ul>
      <li><strong>bits 3,4</strong>: difficulty 1 (bird speed)</li>
      <li><strong>bits 5,6</strong>: difficulty 2 (enemy number and speed)</li>
      <li><strong>bit 7</strong>: ratio of special coin appearance</li>
    </ul>
  </li>
</ul>

<p>Finally, reading from address <strong>B003</strong> implements a software watchdog. The
CPU needs to read from this location frequently, otherwise the arcade
machine will perform a hardware reset. If for some reason the game
crashes, the hardware will automatically reboot.</p>

<p>Some IO port locations are writable:</p>

<ul>
  <li><strong>B000</strong>: whether to generate an NMI during vblank or not, this only seems to be disabled during the boot sequence</li>
  <li><strong>B004</strong>: flip the entire screen, I haven’t seen this used, but I have a theory (see below)</li>
</ul>

<p>The flip-screen functionality is a bit baffling, since when playing the game 
I haven’t seen this used. I have an idea what it does though, but need to do
a bit more coding to confirm this. When the arcade machine is a ‘cocktail table’,
the two players are sitting opposite each other. So my guess is that when the game
switches from player 1 to player 2, it will ‘flip the screen’. I haven’t implemented
2-player mode in the emulator yet though.</p>

<h2 id="the-sound-board">The Sound Board</h2>

<p>The soundboard is its own fully working computer with a Z80 CPU (running at 3
MHz), 3 sound chips (AY-38910, running at 1.5 MHz) and some RAM and ROM. The
memory map of the soundboard looks quite simple:</p>

<ul>
  <li><strong>0000..2000</strong>: 8 KBytes ROM</li>
  <li><strong>4000..4400</strong>: 1 KByte RAM</li>
  <li><strong>6000</strong>: sound command from the mainboard</li>
</ul>

<p>Since there’s nothing of interest in the memory map above 0x8000, the
CPU’s topmost address pin isn’t even connected:</p>

<p><img src="https://floooh.github.io/images/bombjack_sound_a15.png" alt="Bomb Jack Sound A15"></p>

<p>The special location 0x6000 is a memory mapped IO port (8-bit latch) not
backed by actual RAM. This is the same port that’s mapped to address
0xB800 on the mainboard, and this is the communication link between
the mainboard and the soundboard.</p>

<p>The 3 sound chips are controlled through actual Z80 output instructions, 
not through memory-mapped ports. The AY-3-8910 only exposes two 
IO ports, the first one is used to store a register number, and the
the second port is used to write or read the content of the register
identified by the first port.</p>

<p>The IO map looks like this:</p>

<ul>
  <li><strong>0x00</strong>: 1st sound-chip: select register</li>
  <li><strong>0x01</strong>: 1st sound-chip: access selected register</li>
  <li><strong>0x10</strong>: 2nd sound-chip: select register</li>
  <li><strong>0x11</strong>: 2nd sound-chip: access selected register</li>
  <li><strong>0x80</strong>: 3rd sound-chip: select register</li>
  <li><strong>0x81</strong>: 3rd sound-chip: access selected register</li>
</ul>

<p>A few notes about the sound chip AY-3-8910:</p>

<p>This is a fairly standard part which also has been very popular in home 
computer designs of the time (for instance the Amstrad CPC, ZX Spectrum 128,
MSX computers and more). The AY-3-8910 spawned many variations and clones, 
(for instance the Yamaha YM2149, which itself was the base for a whole family
of more powerful sound chips).</p>

<p>The AY-3-8910 has 3 square-wave voices, a single noise generator which could
be mixed into the 3 voices, and a single envelope generator. Since there was
only one envelope generator for all three voices it wasn’t actually that
useful, and most games used the CPU to modulate pitch and volume.</p>

<p>This means the AY-3-8910 needs more CPU intervention to produce good sound
(unlike the much more autonomous SID chip in the C64 for instance).</p>

<p>It’s really surprising what one can do with 3 rather simple sound chips and
a dedicated CPU to drive them though. Bomb Jack’s music and sound effects are
much ‘richer’ than what I’ve heard from most home computer games.</p>

<p>The only really interesting thing about the soundboard is how it receives its
command from the mainboard though.</p>

<h2 id="the-sound-command-latch">The Sound Command Latch</h2>

<p>The ‘sound latch’ is a single byte storage (an 8-bit latch) shared between the mainboard and soundboard. The latch is mapped to address 0xB800 on the main
board, and to address 0x6000 on the soundboard.</p>

<p>The soundboard runs a very simple interrupt service routine when an NMI is
triggered by the VSYNC which reads the hardware latch, and writes it
to a normal memory location, along with setting a ‘signal bit’ which tells
the ‘main loop’ that a new sound command has been received:</p>

<pre><code>        ex af,af'               ;0066
        exx                     ;0067
        ld hl,04390h            ;0068
        set 0,(hl)              ;006b
        ld a,(06000h)           ;006d
        ld (04391h),a           ;0070
        exx                     ;0073
        ex af,af'               ;0074
        retn                    ;0075
</code></pre>

<p>The way the NMI pin is activated differs slightly from the
mainboard:</p>

<p>On the mainboard, the NMI pin goes active for the duration of the VBLANK.</p>

<p>On the soundboard however, the NMI is activated when a VSYNC triggers, and
stays active not for the duration of the VBLANK, but instead until 
the interrupt service routine reads from the latch at 0x6000.</p>

<p>When the hardware detects a read from location 0x6000 it performs two
hardwired operations:</p>

<ul>
  <li>the content of the sound latch is cleared to 0</li>
  <li>the NMI pin goes inactive</li>
</ul>

<p>This is basically a simple debouncing which prevents that the same sound
command is executed twice.</p>

<p>The only remaining question now was: how often does the main board write a
new command (because this dictates how I would implement the emulation of
the 2 boards).</p>

<p>With some printf-debugging I found out that the main board writes at most
one new sound command per 60Hz frame, this simplified the design of the
emulators ‘main loop’ a lot.</p>

<p>The problem of running 2 separate emulated computers side by side that need
to communicate with each other is that emulation of one computer is only efficient
if it can run a lot of cycles uninterrupted.</p>

<p>For instance the worst case would be:</p>

<ul>
  <li>run computer 1 for one instruction</li>
  <li>run computer 2 for one instruction</li>
  <li>repeat…</li>
</ul>

<p>My Z80 emulator is not optimized for entering and exiting the emulation for
each instruction, because in this case it needs to flush and load the CPU
state to and from memory at the start and end of each instruction. If the CPU
can crunch through many instructions uninterrupted, it can keep (most of) the
CPU state in registers and only flush state to memory at the last
instruction.</p>

<p>So the ideal situation is to run an emulated system for an entire host system 
frame without interruption (for a 4 MHz CPU and 60Hz frames this means
about 67k ticks per frame, or somewhere between 3k and 16k Z80
instructions).</p>

<p>For Bomb Jack I had to make sure that the mainboard doesn’t write a new command
before the sound board is able to read the last command. Before I found out that
the mainboard only writes at most one command per frame, I was considering building
a complicated command queue, which catches writes to the mainboard sound latch,
and stores a tick count and the command byte in a queue.</p>

<p>Then when the sound board executes its frame, it would pull a new command from
the command queue when it has reached the command’s tick count.</p>

<p>This would work and would be ‘correct’, but also add quite a bit of code complexity.</p>

<p>In the end I decided for a much simpler solution without any queueing. Since
the mainboard only writes one command per frame, I interleave the execution
of the two computers so that each computer runs 2 ‘time slices’ per frame:</p>

<ul>
  <li>run mainboard for first half of frame</li>
  <li>run soundboard for first half of frame</li>
  <li>run mainboard for second half of frame</li>
  <li>run soundboard for second half of frame</li>
</ul>

<p>This guarantees that the soundboard properly sees every single command written
by the mainboard while still running each emulation for thousands of ticks.</p>

<p>The big assumption about this is of course that the host system runs roughly at
a 60Hz framerate :)</p>

<h2 id="one-last-thing">One Last Thing…</h2>

<p>One last interesting trivia about the WebAssembly version of the emulator:</p>

<p>The compressed download size of all files when running the WebAssembly
emulator is about 113 KBytes:</p>

<ul>
  <li>about 2.5 KBytes for the HTML, CSS and ‘manually written’ JS</li>
  <li>26.8 KBytes for the emscripten runtime JS file</li>
  <li>83.7 KBytes for the .wasm file</li>
</ul>

<p>The WASM file contains the embedded arcade machine ROMs.</p>

<p>Those ROMs have an uncompressed size of 112 KBytes.</p>

<p>So the <strong>entire</strong> compressed emulator with embedded ROMs is about the same
size as the uncompressed ROMs :)</p>

<p>The 112 KByte ROMs compress to about 57 KBytes, this means the actual 
compressed code size in the WASM blob without the ROM data 
is under 30 KBytes (84 - 57).</p>

<p>Not too bad for an entire 8-bit system emulator I think ;)</p>

  </div>

</article>

      </div>
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>