<!DOCTYPE html>
<html lang="en">
<head>
    <title>
To Null, or not to Null?!? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="To Null, or not to Null?!? - linksfor.dev(s)"/>
    <meta property="article:author" content="Dave Cook"/>
    <meta property="og:description" content="I&#x2019;ll start this post with a question:"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@dcook_net/to-null-or-not-to-null-304571effc80"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - To Null, or not to Null?!?</title>
<div class="readable">
        <h1>To Null, or not to Null?!?</h1>
            <div>by Dave Cook</div>
            <div>Reading time: 17-21 minutes</div>
        <div>Posted here: 05 Dec 2019</div>
        <p><a href="https://medium.com/@dcook_net/to-null-or-not-to-null-304571effc80">https://medium.com/@dcook_net/to-null-or-not-to-null-304571effc80</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><figure><div><div><p><img src="https://miro.medium.com/max/60/1*BobPMwM4Ugm53zeDPXbnvQ.png?q=20" width="2084" height="1012" role="presentation"></p><p><img width="2084" height="1012" role="presentation" src="https://miro.medium.com/max/2084/1*BobPMwM4Ugm53zeDPXbnvQ.png"></p></div></div><figcaption data-selectable-paragraph="">Ugly code!</figcaption></figure></div><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@dcook_net?source=post_page-----304571effc80----------------------"><img alt="Dave Cook" src="https://miro.medium.com/fit/c/96/96/1*kR3nf5pBv_Ivd6Y5QpzF8w.jpeg" width="48" height="48"></a></p></div></div></div></div><p id="790c" data-selectable-paragraph="">I‚Äôll start this post with a question:</p><p id="6a17" data-selectable-paragraph=""><strong>Who is responsible for a NullReferenceException being thrown?</strong></p><p id="4242" data-selectable-paragraph="">Is it the dev who forgot to check for null, or is it the dev that created the null in the first place?</p><p id="e250" data-selectable-paragraph="">In this post, I‚Äôd like to challenge the use of <code>null</code> to model the absence of data and our general acceptance of this behaviour, while also presenting some alternative approaches that should help reduce both the need to check for null, and the possibility of null reference exceptions.</p><p id="61cb" data-selectable-paragraph="">This post forms part of the <a href="https://crosscuttingconcerns.com/The-Third-Annual-csharp-Advent" target="_blank" rel="noopener nofollow">2019 C# Advent</a>, so check it out for another 49 articles of C# goodness.</p></div></div></section><section><div><div><p id="8616" data-selectable-paragraph="">It‚Äôs been over a decade since <a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener nofollow">Sir Tony Hoare</a> described his invention of the null reference in 1965 as his <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/" target="_blank" rel="noopener nofollow">billion-dollar mistake</a>:</p><blockquote><p id="f1cc" data-selectable-paragraph="">‚ÄúThis has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.‚Äù</p></blockquote><p id="a973" data-selectable-paragraph="">Given that the inventor of null thinks it was a bad idea, you would expect that the rest of us might have figured out an alternative to code like this:</p><figure><div></div></figure><p id="46a1" data-selectable-paragraph="">This is not real code, but is based on real code that I‚Äôve seen many times, and I expect you have too!</p><p id="f4f5" data-selectable-paragraph="">So, what‚Äôs the issue? Well, let‚Äôs ignore the fact that it has more than one <a href="https://deviq.com/single-responsibility-principle/" target="_blank" rel="noopener nofollow">responsibility</a> and there are <a target="_blank" rel="noopener" href="https://medium.com/@dcook_net/how-to-check-for-null-in-c-926a115dfc1b">better ways to check for null</a> ‚Ä¶ my main bugbear is that there are paths through this code that result in a null being returned to the caller.</p><p id="74cd" data-selectable-paragraph="">This is something that has been grating on me for some time now, as every null is another exception waiting to happen. Over recent months I have come to the conclusion that this is lies somewhere between a poor design decision and just a little bit lazy!</p><p id="4ae3" data-selectable-paragraph="">Why?</p><p id="c955" data-selectable-paragraph="">Because it casually pushes work and responsibility on to each and every one of our consumers, opening the door to the dreaded <a href="https://docs.microsoft.com/en-us/dotnet/api/system.nullreferenceexception?view=netcore-3.0" target="_blank" rel="noopener nofollow">NullReferenceException</a>, and in order to avoid said exception each of our callers needs to test the result for null.</p><p id="e3ee" data-selectable-paragraph="">No hardship right; it‚Äôs just a one-liner to check for null, or a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators" target="_blank" rel="noopener nofollow">?</a> here and there!</p><p id="0b92" data-selectable-paragraph="">Sure, but it assumes that everyone calling our code actually knows to check for null; what about the juniors on the team? And we need to remember to write that code to check for null; what about the seniors on the team ;-)</p><p id="48a2" data-selectable-paragraph="">In some scenarios we might get a warning indicating a possible null reference, and maybe even a helpful suggestion on how to fix it, but nothing is physically stopping us from building our app. Nothing is stopping us from deploying it to Production and then finding the issue at run time.</p><p id="84d3" data-selectable-paragraph="">You might be reading this and thinking ‚Äòit‚Äôs ok, our test suite would pick that up!‚Äù ‚Äî great! But tests don‚Äôt solve all of our problems!</p><ul><li id="d65f" data-selectable-paragraph=""><strong>Problem 1: Returning null forces work on to our consumer(s)</strong></li></ul><p id="2af7" data-selectable-paragraph="">Not only that, but it does so covertly!</p><p id="4c98" data-selectable-paragraph="">Let‚Äôs look at some code through the eyes of a potential consumer of a theoretical Accounts class:</p><pre><span id="fbce" data-selectable-paragraph="">//method signature:<br>public User LookupUserByEmail(string email)  </span><span id="154c" data-selectable-paragraph="">//calling code:<br>User result = accounts.LookupUserByEmail(‚Äútest.user@data.com‚Äù);</span></pre><p id="53a0" data-selectable-paragraph="">What can we infer from this?</p><p id="13d6" data-selectable-paragraph="">Its reasonable to assume that given we supply an email address then we will get a User object back, but we can‚Äôt actually learn anything else without further investigation. In order to figure out what happens when a user isn‚Äôt found, or when something fails, we need to actually look at the implementation and read the code.</p><ul><li id="cef2" data-selectable-paragraph=""><strong>Problem 2: Reading code takes time and delays us from our goal!</strong></li></ul><p id="c78d" data-selectable-paragraph="">Then upon reading the code, we uncover a lie. A dirty, dirty lie!</p><p id="79b3" data-selectable-paragraph="">When a user with a matching email address can‚Äôt be found, it doesn‚Äôt return the promised User object at all. It returns a null. A dirty, dirty null!</p><ul><li id="04b5" data-selectable-paragraph=""><strong>Problem 3: The method signature is dishonest</strong></li></ul><p id="32dc" data-selectable-paragraph="">Our method signature gives no indication that there is a possibility of us not getting a User object back, nothing explicit to flag the potential error scenario that we need to deal with, and no warnings about nulls.</p><p id="c0cb" data-selectable-paragraph="">This is less than ideal, and unfortunately because it requires little thought or effort, it‚Äôs easy to fall into this trap and adopt this default behaviour, reusing this pattern time and time again: littering our code bases with land mines, waiting to blow up in our faces.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*vDbUrXtH_60fn2mALfO6Sw.png?q=20" width="1242" height="560" role="presentation"></p><p><img width="1242" height="560" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Spotted on Twitter!</figcaption></figure><p id="9ea2" data-selectable-paragraph="">But what alternatives do we have? What can we do to solve these issues?</p><h2 id="635b" data-selectable-paragraph="">Don‚Äôt Return Null!</h2><p id="68dd" data-selectable-paragraph="">There are actually a number of techniques we can use as safe alternatives to null, which remove the possibility of null reference exceptions while still modelling the absence of data, and also keeping our <a href="http://functionalprogrammingcsharp.com/honest-functions" target="_blank" rel="noopener nofollow">functions honest</a>.</p><p id="26d7" data-selectable-paragraph="">For starters, we could return a safe default value such as an empty collection. For example:</p><figure><div></div></figure><p id="7737" data-selectable-paragraph="">Here we handle 3 different scenarios, or routes, through our code:</p><ul><li id="90c1" data-selectable-paragraph="">The happy path: Everything works. We find 1 or more matching accounts and return them to the caller.</li><li id="a811" data-selectable-paragraph="">The Less happy, but not exceptional or unanticipated path: No accounts match our criteria, so we return an empty list.</li><li id="2e1b" data-selectable-paragraph="">Error Path: Something hits the fan. We log the detail to aid diagnostics, then return an empty list.</li></ul><p id="4239" data-selectable-paragraph="">In each of these scenarios, we return an object that meets the promises stated in the method signature. We keep our function honest, as it always returns a list of account objects, even in the event of failure.</p><p id="9bb4" data-selectable-paragraph="">We remove the need to check that the response is not null, so we are not forcing work on to our consumer, and our code is less prone to error: if our caller fails to check for null, we don‚Äôt give rise to unwanted NullReferecnceExceptions.</p><p id="f63a" data-selectable-paragraph="">Here‚Äôs the calling code that executes the example above:</p><figure><div></div><figcaption>Nothing blows up when we access the accounts object!</figcaption></figure><p id="a98b" data-selectable-paragraph="">An alternative to returning an empty list, which is quite specific, is to use the <a href="https://deviq.com/null-object-pattern/" target="_blank" rel="noopener nofollow">Null Object Pattern</a>, returning an object derived from the return type expressed in the signature that carries zero side effects when it‚Äôs members are accessed.</p><p id="5e40" data-selectable-paragraph="">Consider the following example where we upgrade an existing insurance policy to a newer version:</p><figure><div></div><figcaption>No checks for null here!</figcaption></figure><p id="6b3d" data-selectable-paragraph="">Here we lookup the implementation required to upgrade the Policy from version x to y, and then we use the result of that lookup to actually upgrade the Policy object, returning the updated Policy to the caller.</p><p id="e463" data-selectable-paragraph="">Notice that there is no guard clause around the <code>policyUpgrader</code> object to ensure that we found a matching implementation to perform the upgrade. So how do we sleep at night?</p><p id="ea3d" data-selectable-paragraph="">Here is the implementation of FindPolicyUpgrader:</p><figure><div></div><figcaption>If no matches found, return a NullObject rather than a null.</figcaption></figure><p id="b8d7" data-selectable-paragraph="">In the event that we find a match for our query, then we obviously return that matching implementation. However, when no match is found, instead of returning a null we return an instance of an object that conforms to the contract in our method signature; in this case it implements the interface we are expecting to return: IPolicyUpgrader.</p><p id="ac91" data-selectable-paragraph="">The key thing about this special case implementation of our interface is that it doesn‚Äôt actually do anything when we execute it‚Äôs UpgradePolicy method‚Ä¶there are no consequences or side effects to executing this code, it simply returns the policy object that it is supplied, without doing anything to it.</p><p id="7f68" data-selectable-paragraph="">Again, we have kept our method honest and returned what we said we would in our method signature, and we‚Äôve not forced any extra work on to our clients with the potential of creating errors if they forget to perform that work.</p><p id="75e2" data-selectable-paragraph="">While these two approaches do work for some scenarios, we obviously can‚Äôt get away with this behaviour all the time. We need to think about how our response is going to be used and what possible implications Null Objects might have once released into our program. For example, if downstream code makes a decision based on the count of items in a collection, and some of the instances in that collection are Null Objects, then we are potentially introducing defects into the codebase that could be really difficult to diagnose.</p><p id="27b8" data-selectable-paragraph="">In a similar way, if we returned an empty string instead of a null, then we avoid a potential null reference exception, but we might cause strange behaviour further downstream.</p><p id="1023" data-selectable-paragraph="">Indeed ‚Äî in the example above, we‚Äôve performed the Upgrade task, but the Policy has not actually been upgraded‚Ä¶will that cause other errors elsewhere?</p><p id="6ab4" data-selectable-paragraph="">These techniques also fail to address the fact that we still need to look at the implementation of the function in order to figure out what happens when we deviate from the happy path, as their method signatures are not expressive enough to communicate that level of detail.</p><p id="0203" data-selectable-paragraph="">If you are lucky enough to be using C# 8, then you can benefit from a new language feature called <a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references" target="_blank" rel="noopener nofollow">non-nullable reference types</a>, which allows us to tell the compiler and anyone reading our code: this object is not supposed to be null!</p><p id="f00a" data-selectable-paragraph="">Its something we need to <a href="https://devblogs.microsoft.com/dotnet/try-out-nullable-reference-types/" target="_blank" rel="noopener nofollow">opt into at a project level</a>, and once enabled it magically makes all the existing reference types in that project non-nullable by default (unless suffixed with a ?, in the same way you define a nullable value type). This means that instances of these objects must be initialised to a non-null value, and the variable can never be assigned the value <code>null</code>.</p><p id="2880" data-selectable-paragraph="">Here‚Äôs an excerpt from the docs:</p><blockquote><p id="c298" data-selectable-paragraph="">The compiler uses static analysis to determine if a nullable reference is known to be non-null. The compiler warns you if you dereference a nullable reference when it may be null</p></blockquote><p id="69f9" data-selectable-paragraph="">Sounds good, right? That should prevent some null reference exceptions! For example, while this code was perfectly fine before, now we get a compiler warning against each of these assignments:</p><pre><span id="fab0" data-selectable-paragraph="">Policy policy = null;<br>List&lt;IPolicyUpgrader&gt; policyUpgraders = null;<br>string name = null;  </span><span id="c751" data-selectable-paragraph="">// [CS8600] Converting null literal or possible null value to non-nullable type.</span></pre><p id="5335" data-selectable-paragraph="">Pretty cool‚Ä¶ but we can ignore these warnings and ship to production anyway! What if we <a href="https://dailydotnettips.com/avoid-code-warnings-being-missed-or-ignored-treating-warnings-as-errors-in-visual-studio/" target="_blank" rel="noopener nofollow">crank up the compiler settings</a> all the way to 11 and <a href="https://blog.submain.com/treat-warnings-errors/" target="_blank" rel="noopener nofollow"><em>treat all warnings as errors</em></a>?</p><p id="f5d8" data-selectable-paragraph="">Now the game has changed again, as these assignments now fail the build. This is obviously much better than a warning, as it is physically stopping us from initialising our objects with a null.</p><p id="df1c" data-selectable-paragraph="">It‚Äôs not a quick fix though; opting for these settings on even a small project may suddenly create quite a bit of work in order to get it compiling again. So what do we get for our efforts? How do non-nullable reference types address the 3 problems discussed above?</p><ul><li id="d9ca" data-selectable-paragraph=""><strong>Returning null forces work on to our consumer: </strong>The compiler is now preventing us from returning null at design time, so that solves that issue.</li><li id="c201" data-selectable-paragraph=""><strong>The method signature is dishonest: </strong>We are now forced to return something that matches the signature of our method, so that‚Äôs not a problem anymore.</li><li id="8023" data-selectable-paragraph=""><strong>Reading code takes time and delays us from our goal: </strong>Let‚Äôs look at our original example again‚Ä¶</li></ul><pre><span id="51e9" data-selectable-paragraph="">public User LookupUserByEmail(string email)</span></pre><p id="3774" data-selectable-paragraph="">This looks like exactly the same code that we saw before, but now that our reference types are all non-nullable we know a little bit more information: Given an email address that should not be null, it returns a User object, which also should not be null. That‚Äôs a little more expressive than it was.</p><p id="7847" data-selectable-paragraph="">But we still can‚Äôt infer what happens when a match for our requested user can‚Äôt be found, so we still need to look at the implementation and read the code to figure this out.</p><p id="4d28" data-selectable-paragraph="">There is also the slightly disappointing use of the word <strong><em>should</em></strong>. While non-nullable reference types prevent us from initialising our objects and returning null from our functions at design time, it does not actually prevent them from containing null at run time.</p><p id="3f21" data-selectable-paragraph="">For example, the following test will fail even though <code>Policy</code> is non-nullable, because the value of <code>p</code> is <code>null</code>:</p><figure><div></div></figure><p id="7650" data-selectable-paragraph="">So while this means we can‚Äôt delete all of our null checking code just yet, it‚Äôs still well worth turning on this feature in order to reduce the chances of a null reference exception, and express our intent a teeny wee bit more.</p><p id="6649" data-selectable-paragraph="">We could use the TryGet pattern: whereby our function returns a tuple of <code>(bool, T)</code> with the boolean flag indicating if the function was successful or not, and <code>T</code> will either contain a result or a null. Let‚Äôs have a look at how this might look if we refactor our earlier example:</p><figure><div></div><figcaption>This pattern is often implemented using out params‚Ä¶</figcaption></figure><p id="477b" data-selectable-paragraph="">What does this give us? Our method name has changed very subtly to indicate that this may or may not succeed with the inclusion of the word Try. This is slightly more expressive to us humans, as it provides a small hint of the possibility of failure, but it means nothing to the compiler, and therefore does nothing to force a change in the consumer‚Äôs behaviour.</p><p id="4665" data-selectable-paragraph="">The return type does go a little bit further though: as we are now returning a tuple (a value type: aka a struct) we now know that we can never receive a null response, and we have made our code less prone to error in that regard.</p><p id="bd7d" data-selectable-paragraph="">Our consumers can now check the boolean success flag to determine if it is safe or not to access the result. This is, however, a check that the consumer needs to opt into: they can choose to skip the safety check and access the result anyway, which may or may not be null:</p><pre><span id="74eb" data-selectable-paragraph="">var (_, policyUpgrader) = TryFindUpdater(1, 2);</span><span id="9e2b" data-selectable-paragraph="">policyUpgrader.UpgradePolicy(policy);</span></pre><p id="3021" data-selectable-paragraph="">The TryGet pattern is a step in the right direction, but we can go a little further.</p><p id="62a1" data-selectable-paragraph="">I‚Äôve been avoiding the elephant in the room. We could obviously avoid returning null by throwing an Exception instead. But this is a post about reducing null reference exceptions, so it seems a little odd to replace one type of exception with another. That feels a little like massaging the numbers to me!</p><p id="6b56" data-selectable-paragraph="">Throwing Exceptions also has the side affect of making our methods dishonest and forces work onto our consumers in a similar way to returning null, so this isn‚Äôt solving all the issues we set out to fix.</p><p id="0560" data-selectable-paragraph="">For the purposes of this discussion I will continue to avoid throwing exceptions.</p><p id="f307" data-selectable-paragraph="">If we look to functional programming languages for a little inspiration we can actually lean on the compiler a lot more. In languages such as F# and Haskell it‚Äôs impossible to return null from a function, because there is no null. It simply doesn‚Äôt exist!</p><p id="5a9b" data-selectable-paragraph="">Instead, F# uses a <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/options" target="_blank" rel="noopener nofollow">built-in type</a> of <code>Option&lt;T&gt;</code> (called ‚ÄòMaybe‚Äô In Haskell), to represent the fact that an instance may, or may not, contain an underlaying value of <code>T</code>:</p><ul><li id="8348" data-selectable-paragraph="">When we have a value to return, then we return that value wrapped inside a <code>Some</code>.</li><li id="8017" data-selectable-paragraph="">When we have no value to return, then we return <code>None</code>.</li><li id="2f31" data-selectable-paragraph="">Both <code>Some&lt;T&gt;</code> and <code>None</code> satisfy the compiler‚Äôs need for type safety.</li><li id="7e57" data-selectable-paragraph="">And crucially, <code>Option&lt;T&gt;</code> can never be set it to null, just as a struct can never be null.</li></ul><p id="2f6d" data-selectable-paragraph="">With the ground rules established, let‚Äôs have a look at those method signatures from earlier and see how they might look if we could use something like <code>Option&lt;T&gt;</code> in C#, while also reflecting on those initial problems with null;</p><pre><span id="7aa4" data-selectable-paragraph="">public Option&lt;IPolicyUpgrader&gt; FindPolicyUpgrader(int from, int to)</span><span id="c8da" data-selectable-paragraph="">public Option&lt;User&gt; LookupUserByEmail(string email)</span></pre><p id="cac4" data-selectable-paragraph=""><strong>Is our signature honest?</strong></p><p id="e2a5" data-selectable-paragraph="">Yes. Our signatures have changed to explicitly show that our response may or may not return an instance of T, and whether it succeeds or fails we always get something back that we were expecting, never a null.</p><p id="71c7" data-selectable-paragraph=""><strong>Do we need to inspect the method‚Äôs implementation?</strong></p><p id="d436" data-selectable-paragraph="">As the method signatures are a lot more expressive, we actually have a much better idea of what to expect the method to return, both on and off the happy path. We don‚Äôt really need to read the implementation to see what the method does in failure scenarios, as we can infer from the response type what we will get back if no match is found.</p><p id="0923" data-selectable-paragraph=""><strong>Are we forcing work on to our consumers?</strong></p><p id="4e76" data-selectable-paragraph=""><code>Option&lt;T&gt;</code> can‚Äôt be null, so we‚Äôve removed the need for a null check and the possibility of a null reference exception.</p><p id="b553" data-selectable-paragraph="">What the caller needs to do now is decide what to do with <code>Option&lt;T&gt;</code>. Does it contain a value or not, and what to do if its empty? These are decisions that they should have been making anyway, only now they are being forced by the compiler (and aided by the intellisense in the IDE) to consider both possibilities, Some and None, rather than assuming that all was well and forgetting about that pesky null!</p><p id="2e8e" data-selectable-paragraph="">Cool. We‚Äôve solved all the problems created by null, but the solution is to use a type from another programming language‚Ä¶so where does that leave us?</p><p id="0c34" data-selectable-paragraph="">Have no fear, these types DO exist in C# and are just a nuget package away: both <a href="https://www.nuget.org/packages/LaYumba.Functional/" target="_blank" rel="noopener nofollow">LaYumba</a> and <a href="https://www.nuget.org/packages/LanguageExt.Core/" target="_blank" rel="noopener nofollow">LanguageExt</a> packages contain good implementations of <code>Option&lt;T&gt;</code> that we can use to achieve the behaviour we‚Äôve just discussed, have excellent documentation explaining how to use them, and are based on structs so they can never be null.</p><p id="accc" data-selectable-paragraph="">This is actually a question I‚Äôm trying to answer for myself right now. Most of the code I write exists within web services: they process incoming json payloads, interact with a database or another web service, and respond with more json. How do we model the absence of data when talking to our collaborators at the edges of our system?</p><p id="83d6" data-selectable-paragraph=""><code>Option&lt;T&gt;</code> does not serialise to json straight out of the box, so does not work smoothly with model binding when a controller receives a request, or when a controller responds to a request with an object of <code>Option&lt;T&gt;</code>, or an object with properties of <code>Option&lt;T&gt;</code>.</p><p id="7f8b" data-selectable-paragraph="">Likewise, the out of the box behaviour does not serialise when saving a document (an Object) to a Mongo Database. If I wanted to save something to SQL Server, then I assume I would need to model the field as as nullable, using the appropriate datatype, and then write either the underlying value or a null to the record. I assume I need to do a similar thing with Mongo.</p><p id="c712" data-selectable-paragraph="">So for now I am using <code>Option&lt;T&gt;</code> inside my services, mapping back and forth into nullable types at the boundaries when talking to other systems.</p></div></div></section><section><div><div><p id="daca" data-selectable-paragraph="">The aim of this post was to try to get you to question the use of null as a way of modelling the absence of data, as well as arming you with some tools and techniques to help reduce null reference exceptions.</p><p id="8812" data-selectable-paragraph="">I‚Äôm not suggesting that any of the options presented here are the answer to all scenarios. You may wish to use a combination of these techniques in order to avoid and reduce null reference exceptions.</p><p id="fa83" data-selectable-paragraph="">Either way, I don‚Äôt think we‚Äôve seen the last of null, but hopefully we‚Äôll see it a little less going forward.</p><p id="4d47" data-selectable-paragraph="">Now back to where it all began:</p><p id="8e9e" data-selectable-paragraph=""><strong>Who‚Äôs responsible for that NullReferenceException?</strong></p></div></div></section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
</body>
</html>