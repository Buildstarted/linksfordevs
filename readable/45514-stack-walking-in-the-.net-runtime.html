<!DOCTYPE html>
<html lang="en">
<head>
    <title>
&#x201C;Stack Walking&#x201D; in the .NET Runtime -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>&#x201C;Stack Walking&#x201D; in the .NET Runtime</h1>
    <div class="post"> <span class="post-date">21 Jan 2019 - 6375 words</span> <p>What is &#x2018;stack walking&#x2019;, well as always the &#x2018;Book of the Runtime&#x2019; (BotR) helps us, from the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/stackwalking.md">relevant page</a>:</p> <blockquote> <p>The CLR makes heavy use of a technique known as stack walking (or stack crawling). This involves <strong>iterating the sequence of call frames for a particular thread</strong>, from the most recent (the thread&#x2019;s current function) back down to the base of the stack.</p> <p><strong>The runtime uses stack walks for a number of purposes</strong>:</p> <ul> <li>The runtime walks the stacks of all threads <strong>during garbage collection, looking for managed roots</strong> (local variables holding object references in the frames of managed methods that need to be reported to the GC to keep the objects alive and possibly track their movement if the GC decides to compact the heap).</li> <li>On some platforms the stack walker is used during the <strong>processing of exceptions</strong> (looking for handlers in the first pass and unwinding the stack in the second).</li> <li>The <strong>debugger uses the functionality</strong> when generating managed stack traces.</li> <li>Various miscellaneous methods, usually those close to some public managed API, perform a stack walk <strong>to pick up information about their caller</strong> (such as the method, class or assembly of that caller).</li> </ul>
</blockquote> <p><strong>The rest of this post will explore what &#x2018;Stack Walking&#x2019; is, how it works and why so many parts of the runtime need to be involved.</strong></p> <p><strong>Table of Contents</strong></p> <h2 id="where-does-the-clr-use-stack-walking">Where does the CLR use &#x2018;Stack Walking&#x2019;?</h2> <p>Before we dig into the &#x2018;internals&#x2019;, let&#x2019;s take a look at where the runtime utilises &#x2018;stack walking&#x2019;, below is the full list (as of .NET Core CLR &#x2018;Release 2.2&#x2019;). All these examples end up calling into the <code class="language-plaintext highlighter-rouge">Thread::StackWalkFrames(..)</code> method <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L978-L1042">here</a> and provide a <code class="language-plaintext highlighter-rouge">callback</code> that is triggered whenever the API encounters a new section of the stack (see <a href="#how-to-use-it">How to use it</a> below for more info).</p> <h3 id="common-scenarios">Common Scenarios</h3> <h3 id="debuggingdiagnostics">Debugging/Diagnostics</h3> <ul> <li><strong>Debugger</strong> </li> <li><strong>Managed APIs</strong> (e.g <code class="language-plaintext highlighter-rouge">System.Diagnostics.StackTrace</code>) <ul> <li>Managed code calls via an <code class="language-plaintext highlighter-rouge">InternalCall</code> (C#) <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/mscorlib/src/System/Diagnostics/Stacktrace.cs#L317-L318">here</a> into <code class="language-plaintext highlighter-rouge">DebugStackTrace::GetStackFramesInternal(..)</code> (C++) <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debugdebugger.cpp#L327-L800">here</a></li> <li>Before ending up in <code class="language-plaintext highlighter-rouge">DebugStackTrace::GetStackFramesHelper(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debugdebugger.cpp#L852-L956">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debugdebugger.cpp#L976-L1060">callback</a></li> </ul> </li> <li><strong>DAC (via by SOS)</strong> - Scan for GC &#x2018;Roots&#x2019; <ul> <li><code class="language-plaintext highlighter-rouge">DacStackReferenceWalker::WalkStack&lt;..&gt;(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/debug/daccess/dacimpl.h#L1973-L2022">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/debug/daccess/daccess.cpp#L8466-L8638">callback</a></li> </ul> </li> <li><strong>Profiling API</strong> <ul> <li><code class="language-plaintext highlighter-rouge">ProfToEEInterfaceImpl::ProfilerStackWalkFramesWrapper(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/proftoeeinterfaceimpl.cpp#L7624-L7652">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/proftoeeinterfaceimpl.cpp#L7177-L7286">callback</a></li> </ul> </li> <li><strong>Event Pipe</strong> (Diagnostics) <ul> <li><code class="language-plaintext highlighter-rouge">EventPipe::WalkManagedStackForThread(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eventpipe.cpp#L971-L994">here</a> -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eventpipe.cpp#L996-L1029">callback</a></li> </ul> </li> <li><strong>CLR prints a Stack Trace</strong> (to the console/log, DEBUG builds only) <ul> <li><code class="language-plaintext highlighter-rouge">PrintStackTrace()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debughelp.cpp#L1015-L1109">here</a> (and other functions) -&gt; <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/debughelp.cpp#L881-L1013">callback</a></li> </ul> </li>
</ul> <h3 id="obscure-scenarios">Obscure Scenarios</h3> <ul> <li><strong>Reflection</strong> <ul> <li><code class="language-plaintext highlighter-rouge">RuntimeMethodHandle::GetCurrentMethod(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/reflectioninvocation.cpp#L1487-L1511">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/reflectioninvocation.cpp#L1449-L1485">callback</a>)</li> </ul> </li> <li><strong>Application (App) Domains</strong> (See &#x2018;Stack Crawl Marks&#x2019; below) <ul> <li><code class="language-plaintext highlighter-rouge">SystemDomain::GetCallersMethod(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/appdomain.cpp#L3389-L3417">here</a> (also <code class="language-plaintext highlighter-rouge">GetCallersType(..)</code> and <code class="language-plaintext highlighter-rouge">GetCallersModule(..)</code>) (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/appdomain.cpp#L3520-L3664">callback</a>)</li> <li><code class="language-plaintext highlighter-rouge">SystemDomain::GetCallersModule(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/appdomain.cpp#L3494-L3518">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/appdomain.cpp#L3666-L3686">callback</a>)</li> </ul> </li> <li><strong>&#x2018;Code Pitching&#x2019;</strong> <ul> <li><code class="language-plaintext highlighter-rouge">CheckStacksAndPitch()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codepitchingmanager.cpp#L446-L501">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codepitchingmanager.cpp#L340-L347">wrapper</a> and <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codepitchingmanager.cpp#L304-L338">callback</a>)</li> </ul> </li> <li><strong>Extensible Class Factory</strong> (<code class="language-plaintext highlighter-rouge">System.Runtime.InteropServices.ExtensibleClassFactory</code>) <ul> <li><code class="language-plaintext highlighter-rouge">RegisterObjectCreationCallback(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/extensibleclassfactory.cpp#L72-L130">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/extensibleclassfactory.cpp#L23-L69">callback</a>)</li> </ul> </li> <li><strong>Stack Sampler</strong> (unused?) <ul> <li><code class="language-plaintext highlighter-rouge">StackSampler::ThreadProc()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stacksampler.cpp#L264-L331">here</a> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stacksampler.cpp#L217-L224">wrapper</a> and <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stacksampler.cpp#L226-L262">callback</a>)</li> </ul> </li>
</ul> <h3 id="stack-crawl-marks">Stack Crawl Marks</h3> <p>One of the above scenarios deserves a closer look, but firstly why are &#x2018;stack crawl marks&#x2019; used, from <a href="https://github.com/dotnet/coreclr/issues/21629#issuecomment-449225852">coreclr/issues/#21629 (comment)</a>:</p> <blockquote> <p>Unfortunately, there is a ton of legacy APIs that were added during netstandard2.0 push whose behavior depend on the caller. <strong>The caller is basically passed in as an implicit argument to the API</strong>. Most of these StackCrawlMarks are there to support these APIs&#x2026;</p>
</blockquote> <p>So we can see that multiple functions within the CLR itself need to have knowledge of their <strong>caller</strong>. To understand this some more, let&#x2019;s look an example, the <code class="language-plaintext highlighter-rouge">GetType(string typeName)</code> <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.gettype?view=netframework-4.7.2#System_Type_GetType_System_String_">method</a>. Here&#x2019;s the flow from the externally-visible method all the way down to where the work is done, note how a <code class="language-plaintext highlighter-rouge">StackCrawlMark</code> instance is passed through:</p> <ul> <li><code class="language-plaintext highlighter-rouge">Type::GetType(string typeName)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/System.Private.CoreLib/src/System/Type.CoreCLR.cs#L38-L43">implementation</a> (Creates <code class="language-plaintext highlighter-rouge">StackCrawlMark.LookForMyCaller</code>)</li> <li><code class="language-plaintext highlighter-rouge">RuntimeType::GetType(.., ref StackCrawlMark stackMark)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/System.Private.CoreLib/src/System/RtType.cs#L1741-L1749">implementation</a></li> <li><code class="language-plaintext highlighter-rouge">RuntimeType::GetTypeByName(.., ref StackCrawlMark stackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/System.Private.CoreLib/src/System/RuntimeHandles.cs#L431-L459">implementation</a></li> <li><code class="language-plaintext highlighter-rouge">extern void GetTypeByName(.., ref StackCrawlMark stackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/System.Private.CoreLib/src/System/RuntimeHandles.cs#L426-L429">definition</a> (call into native code, i.e. <code class="language-plaintext highlighter-rouge">[DllImport(JitHelpers.QCall, ..)]</code>)</li> <li><code class="language-plaintext highlighter-rouge">RuntimeTypeHandle::GetTypeByName(.., QCall::StackCrawlMarkHandle pStackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/runtimehandles.cpp#L1433-L1463">implementation</a></li> <li><code class="language-plaintext highlighter-rouge">TypeHandle TypeName::GetTypeManaged(.., StackCrawlMark* pStackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/typeparse.cpp#L1178-L1271">implementation</a></li> <li><code class="language-plaintext highlighter-rouge">TypeHandle TypeName::GetTypeWorker(.. , StackCrawlMark* pStackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/typeparse.cpp#L1405-L1662">implementation</a></li> <li><code class="language-plaintext highlighter-rouge">SystemDomain::GetCallersAssembly(StackCrawlMark *stackMark,..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/appdomain.cpp#L3430-L3438">implementation</a></li> <li><code class="language-plaintext highlighter-rouge">SystemDomain::GetCallersModule(StackCrawlMark* stackMark, ..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/appdomain.cpp#L3394-L3421">implementation</a></li> <li><code class="language-plaintext highlighter-rouge">SystemDomain::CallersMethodCallbackWithStackMark(..)</code> <a href="https://github.com/dotnet/coreclr/blob/606c246/src/vm/appdomain.cpp#L3467-L3610">callback implementation</a></li>
</ul> <p>In addition the JIT (via the VM) has to ensure that all relevant methods are available in the call-stack, i.e. they can&#x2019;t be removed:</p> <p>However, the <code class="language-plaintext highlighter-rouge">StackCrawlMark</code> feature is currently being <em>cleaned</em> up, so it may look different in the future:</p> <h3 id="exception-handling">Exception Handling</h3> <p>The place that most .NET Developers will run into &#x2018;stack traces&#x2019; is when dealing with exceptions. I originally intended to also describe &#x2018;exception handling&#x2019; here, but then I opened up <a href="https://github.com/dotnet/coreclr/blob/master/src/vm/exceptionhandling.cpp">/src/vm/exceptionhandling.cpp</a> and saw that it contained <strong>over 7,000</strong> lines of code!! So I decided that it can wait for a future post &#x1F601;.</p> <p>However, if you want to learn more about the &#x2018;internals&#x2019; I really recommend Chris Brumme&#x2019;s post <a href="https://blogs.msdn.microsoft.com/cbrumme/2003/10/01/the-exception-model/">The Exception Model</a> (2003) which is the definitive guide on the topic (also see his <a href="https://channel9.msdn.com/Search?term=Christopher%20Brumme&amp;lang-en=true">Channel9 Videos</a>) and as always, the &#x2018;BotR&#x2019; chapter <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/exceptions.md">&#x2018;What Every (<em>Runtime</em>) Dev needs to Know About Exceptions in the Runtime&#x2019;</a> is well worth a read.</p> <p>Also, I recommend talking a look at the slides from the <a href="https://blog.adamfurmanek.pl/wp-content/uploads/2018/06/Internals_of_exceptions.pdf">&#x2018;Internals of Exceptions&#x2019; talk&#x2019;</a> and the related post <a href="https://blog.adamfurmanek.pl/blog/2016/10/01/handling-and-rethrowing-exceptions-in-c/">.NET Inside Out Part 2 &#x2014; Handling and rethrowing exceptions in C#</a> both by <a href="https://twitter.com/furmanekadam">Adam Furmanek</a>.</p> <h2 id="the-stack-walking-api">The &#x2018;Stack Walking&#x2019; API</h2> <p>Now that we&#x2019;ve seen <em>where</em> it&#x2019;s used, let&#x2019;s look at the &#x2018;stack walking&#x2019; API itself. Firstly, <em>how</em> is it used?</p> <h3 id="how-to-use-it">How to use it</h3> <p>It&#x2019;s worth pointing out that the only way you can access it from C#/F#/VB.NET code is via the <code class="language-plaintext highlighter-rouge">StackTrace</code> <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.stacktrace?view=netframework-4.7.2">class</a>, only the runtime itself can call into <code class="language-plaintext highlighter-rouge">Thread::StackWalkFrames(..)</code> directly. The simplest usage in the runtime is <code class="language-plaintext highlighter-rouge">EventPipe::WalkManagedStackForThread(..)</code> (see <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eventpipe.cpp#L971-L994">here</a>), which is shown below. As you can see it&#x2019;s as simple as specifying the relevant flags, in this case <code class="language-plaintext highlighter-rouge">ALLOW_ASYNC_STACK_WALK | FUNCTIONSONLY | HANDLESKIPPEDFRAMES | ALLOW_INVALID_OBJECTS</code> and then providing the callback, which in the EventPipe class is the <code class="language-plaintext highlighter-rouge">StackWalkCallback</code> method (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eventpipe.cpp#L996-L102">here</a>)</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">EventPipe</span><span class="o">::</span><span class="n">WalkManagedStackForThread</span><span class="p">(</span><span class="n">Thread</span> <span class="o">*</span><span class="n">pThread</span><span class="p">,</span> <span class="n">StackContents</span> <span class="o">&amp;</span><span class="n">stackContents</span><span class="p">)</span>
<span class="p">{</span> <span class="n">CONTRACTL</span> <span class="p">{</span> <span class="n">NOTHROW</span><span class="p">;</span> <span class="n">GC_NOTRIGGER</span><span class="p">;</span> <span class="n">MODE_ANY</span><span class="p">;</span> <span class="n">PRECONDITION</span><span class="p">(</span><span class="n">pThread</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span> <span class="p">}</span> <span class="n">CONTRACTL_END</span><span class="p">;</span> <span class="c1">// Calling into StackWalkFrames in preemptive mode violates the host contract,</span> <span class="c1">// but this contract is not used on CoreCLR.</span> <span class="n">CONTRACT_VIOLATION</span><span class="p">(</span> <span class="n">HostViolation</span> <span class="p">);</span> <span class="n">stackContents</span><span class="p">.</span><span class="n">Reset</span><span class="p">();</span> <span class="n">StackWalkAction</span> <span class="n">swaRet</span> <span class="o">=</span> <span class="n">pThread</span><span class="o">-&gt;</span><span class="n">StackWalkFrames</span><span class="p">(</span> <span class="p">(</span><span class="n">PSTACKWALKFRAMESCALLBACK</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">StackWalkCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stackContents</span><span class="p">,</span> <span class="n">ALLOW_ASYNC_STACK_WALK</span> <span class="o">|</span> <span class="n">FUNCTIONSONLY</span> <span class="o">|</span> <span class="n">HANDLESKIPPEDFRAMES</span> <span class="o">|</span> <span class="n">ALLOW_INVALID_OBJECTS</span><span class="p">);</span> <span class="k">return</span> <span class="p">((</span><span class="n">swaRet</span> <span class="o">==</span> <span class="n">SWA_DONE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">swaRet</span> <span class="o">==</span> <span class="n">SWA_CONTINUE</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">StackWalkFrame(..)</code> function then does the <em>heavy-lifting</em> of actually walking the stack, before triggering the callback shown below. In this case it just records the &#x2018;Instruction Pointer&#x2019; (IP/CP) and the &#x2018;managed function&#x2019;, which is an instance of the <code class="language-plaintext highlighter-rouge">MethodDesc</code> obtained via the <code class="language-plaintext highlighter-rouge">pCf-&gt;GetFunction()</code> call:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">StackWalkAction</span> <span class="n">EventPipe</span><span class="o">::</span><span class="n">StackWalkCallback</span><span class="p">(</span><span class="n">CrawlFrame</span> <span class="o">*</span><span class="n">pCf</span><span class="p">,</span> <span class="n">StackContents</span> <span class="o">*</span><span class="n">pData</span><span class="p">)</span>
<span class="p">{</span> <span class="n">CONTRACTL</span> <span class="p">{</span> <span class="n">NOTHROW</span><span class="p">;</span> <span class="n">GC_NOTRIGGER</span><span class="p">;</span> <span class="n">MODE_ANY</span><span class="p">;</span> <span class="n">PRECONDITION</span><span class="p">(</span><span class="n">pCf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span> <span class="n">PRECONDITION</span><span class="p">(</span><span class="n">pData</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span> <span class="p">}</span> <span class="n">CONTRACTL_END</span><span class="p">;</span> <span class="c1">// Get the IP.</span> <span class="n">UINT_PTR</span> <span class="n">controlPC</span> <span class="o">=</span> <span class="p">(</span><span class="n">UINT_PTR</span><span class="p">)</span><span class="n">pCf</span><span class="o">-&gt;</span><span class="n">GetRegisterSet</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ControlPC</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">controlPC</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">pData</span><span class="o">-&gt;</span><span class="n">GetLength</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// This happens for pinvoke stubs on the top of the stack.</span> <span class="k">return</span> <span class="n">SWA_CONTINUE</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="n">_ASSERTE</span><span class="p">(</span><span class="n">controlPC</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Add the IP to the captured stack.</span> <span class="n">pData</span><span class="o">-&gt;</span><span class="n">Append</span><span class="p">(</span><span class="n">controlPC</span><span class="p">,</span> <span class="n">pCf</span><span class="o">-&gt;</span><span class="n">GetFunction</span><span class="p">());</span> <span class="c1">// Continue the stack walk.</span> <span class="k">return</span> <span class="n">SWA_CONTINUE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="how-it-works">How it works</h3> <p>Now onto the most interesting part, how to the runtime actually walks the stack. Well, first let&#x2019;s understand what the stack looks like, from the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/stackwalking.md">&#x2018;BotR&#x2019; page</a>:</p> <p><img src="/images/2019/01/Stack Description from BotR.png" alt="Stack Description from BotR"></p> <p>The main thing to note is that a .NET &#x2018;stack&#x2019; can contain 3 types of methods:</p> <ol> <li><strong>Managed</strong> - this represents code that started off as C#/F#/VB.NET, was turned into IL and then finally compiled to native code by the &#x2018;JIT Compiler&#x2019;.</li> <li><strong>Unmanaged</strong> - completely <em>native</em> code that exists outside of the runtime, i.e. a OS function the runtime calls into or a user call via <code class="language-plaintext highlighter-rouge">P/Invoke</code>. The runtime <em>only</em> cares about transitions <em>into</em> or <em>out of</em> regular unmanaged code, is doesn&#x2019;t care about the stack frame within it.</li> <li><strong>Runtime Managed</strong> - still <em>native</em> code, but this is slightly different because the runtime case more about this code. For example there are quite a few parts of the Base-Class libraries that make use of <code class="language-plaintext highlighter-rouge">InternalCall</code> methods, for more on this see the <a href="#helper-method-frames">&#x2018;Helper Method&#x2019; Frames</a> section later on.</li>
</ol> <p>So the &#x2018;stack walk&#x2019; has to deal with these different scenarios as it proceeds. Now let&#x2019;s look at the &#x2018;code flow&#x2019; starting with the entry-point method <code class="language-plaintext highlighter-rouge">StackWalkFrames(..)</code>:</p> <ul> <li><code class="language-plaintext highlighter-rouge">Thread::StackWalkFrames(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L978-L1042">here</a> <ul> <li>the entry-point function, the type of &#x2018;stack walk&#x2019; can be controlled via <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/threads.h#L3302-L3361">these flags</a></li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">Thread::StackWalkFramesEx(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L899-L976">here</a> <ul> <li>worker-function that sets up the <code class="language-plaintext highlighter-rouge">StackFrameIterator</code>, via a call to <code class="language-plaintext highlighter-rouge">StackFrameIterator::Init(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L1150-L1274">here</a></li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">StackFrameIterator::Next()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L1586-L1621">here</a>, then hands off to the primary <em>worker</em> method <code class="language-plaintext highlighter-rouge">StackFrameIterator::NextRaw()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L2291-L2761">here</a> that does 5 things: <ol> <li><code class="language-plaintext highlighter-rouge">CheckForSkippedFrames(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L3009-L3119">here</a>, deals with frames that may have been allocated inside a managed stack frame (e.g. an inlined p/invoke call).</li> <li><code class="language-plaintext highlighter-rouge">UnwindStackFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eetwain.cpp#L4162-L4214">here</a>, in-turn calls: <ul> <li><strong><code class="language-plaintext highlighter-rouge">x64</code></strong> - <code class="language-plaintext highlighter-rouge">Thread::VirtualUnwindCallFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L553-L671">here</a>, then calls <code class="language-plaintext highlighter-rouge">VirtualUnwindNonLeafCallFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L711-L757">here</a> or <code class="language-plaintext highlighter-rouge">VirtualUnwindLeafCallFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L676-L708">here</a>. All of of these functions make use of the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winnt/nf-winnt-rtllookupfunctionentry">Windows API function</a> <code class="language-plaintext highlighter-rouge">RtlLookupFunctionEntry(..)</code> to do the actual unwinding.</li> <li><strong><code class="language-plaintext highlighter-rouge">x86</code></strong> - <code class="language-plaintext highlighter-rouge">::UnwindStackFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eetwain.cpp#L4012-L4107">here</a>, in turn calls <code class="language-plaintext highlighter-rouge">UnwindEpilog(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eetwain.cpp#L3528-L3557">here</a> and <code class="language-plaintext highlighter-rouge">UnwindEspFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/eetwain.cpp#L3663-L3721">here</a>. Unlike <code class="language-plaintext highlighter-rouge">x64</code>, under <code class="language-plaintext highlighter-rouge">x86</code> all the &#x2018;stack-unwinding&#x2019; is done manually, within the CLR code.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">PostProcessingForManagedFrames(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L3193-L3229">here</a>, determines if the stack-walk is actually within a <strong>managed method</strong> rather than a <strong>native frame</strong>.</li> <li><code class="language-plaintext highlighter-rouge">ProcessIp(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L2786-L2800">here</a> has the job of looking up the current <strong>managed method</strong> (if any) based on the current <strong>instruction pointer</strong> (IP). It does this by calling into <code class="language-plaintext highlighter-rouge">EECodeInfo::Init(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/jitinterface.cpp#L13948-L13976">here</a> and then ends up in one of: <ul> <li><code class="language-plaintext highlighter-rouge">EEJitManager::JitCodeToMethodInfo(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codeman.cpp#L3631-L3676">here</a>, that uses a very cool looking data structure refereed to as a <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/inc/nibblemapmacros.h#L12-L26">&#x2018;nibble map&#x2019;</a></li> <li><code class="language-plaintext highlighter-rouge">NativeImageJitManager::JitCodeToMethodInfo(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codeman.cpp#L5428-L5616">here</a></li> <li><code class="language-plaintext highlighter-rouge">ReadyToRunJitManager::JitCodeToMethodInfo(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/codeman.cpp#L6875-L6953">here</a></li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">ProcessCurrentFrame(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L2802-L3007">here</a>, does some final house-keeping and tidy-up.</li> </ol> </li> <li><code class="language-plaintext highlighter-rouge">CrawlFrame::GotoNextFrame()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L369-L390">here</a> <ul> <li>in-turn calls <code class="language-plaintext highlighter-rouge">pFrame-&gt;Next()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L836-L840">here</a> to walk through the &#x2018;linked list&#x2019; of frames which drive the &#x2018;stack walk&#x2019; (more on these &#x2018;frames&#x2019; later)</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">StackFrameIterator::Filter()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L1623-L2289">here</a> </li>
</ul> <p>When it gets a valid frame it triggers the callback in <code class="language-plaintext highlighter-rouge">Thread::MakeStackwalkerCallback(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L859-L891">here</a> and passes in a pointer to the current <code class="language-plaintext highlighter-rouge">CrawlFrame</code> class <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.h#L68-L496">defined here</a>, this exposes methods such as <code class="language-plaintext highlighter-rouge">IsFrameless()</code>, <code class="language-plaintext highlighter-rouge">GetFunction()</code> and <code class="language-plaintext highlighter-rouge">GetThisPointer()</code>. The <code class="language-plaintext highlighter-rouge">CrawlFrame</code> actually represents 2 scenarios, based on the current IP:</p> <ul> <li><strong>Native</strong> code, represented by a <code class="language-plaintext highlighter-rouge">Frame</code> class <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L378-L284">defined here</a>, which we&#x2019;ll discuss more in a moment.</li> <li><strong>Managed</strong> code, well technically &#x2018;managed code&#x2019; that was JITted to &#x2018;native code&#x2019;, so more accurately a <strong>managed stack frame</strong>. In this situation the <code class="language-plaintext highlighter-rouge">MethodDesc</code> class <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/method.hpp#L187-L1879">defined here</a> is provided, you can read more about this key CLR data-structure in <a href="https://github.com/dotnet/coreclr/blob/release/2.2/Documentation/botr/method-descriptor.md">the corresponding BotR chapter</a>.</li>
</ul> <h3 id="see-it-in-action">See it &#x2018;in Action&#x2019;</h3> <p>Fortunately we&#x2019;re able to turn on some nice diagnostics in a debug build of the CLR (<code class="language-plaintext highlighter-rouge">COMPLUS_LogEnable</code>, <code class="language-plaintext highlighter-rouge">COMPLUS_LogToFile</code> &amp; <code class="language-plaintext highlighter-rouge">COMPLUS_LogFacility</code>). With that in place, given C# code like this:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span> <span class="p">{</span> <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span> <span class="nf">MethodA</span><span class="p">();</span> <span class="p">}</span> <span class="p">[</span><span class="nf">MethodImpl</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">NoInlining</span><span class="p">)]</span> <span class="k">private</span> <span class="k">void</span> <span class="nf">MethodA</span><span class="p">()</span> <span class="p">{</span> <span class="nf">MethodB</span><span class="p">();</span> <span class="p">}</span> <span class="p">[</span><span class="nf">MethodImpl</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">NoInlining</span><span class="p">)]</span> <span class="k">private</span> <span class="k">void</span> <span class="nf">MethodB</span><span class="p">()</span> <span class="p">{</span> <span class="nf">MethodC</span><span class="p">();</span> <span class="p">}</span> <span class="p">[</span><span class="nf">MethodImpl</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">NoInlining</span><span class="p">)]</span> <span class="k">private</span> <span class="k">void</span> <span class="nf">MethodC</span><span class="p">()</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">stackTrace</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StackTrace</span><span class="p">(</span><span class="n">fNeedFileInfo</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">stackTrace</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>We get the output shown below, in which you can see the &#x2018;stack walking&#x2019; process. It starts in <code class="language-plaintext highlighter-rouge">InitializeSourceInfo</code> and <code class="language-plaintext highlighter-rouge">CaptureStackTrace</code> which are methods internal to the <code class="language-plaintext highlighter-rouge">StackTrace</code> class (see <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/mscorlib/src/System/Diagnostics/Stacktrace.cs#L351-L407">here</a>), before moving up the stack <code class="language-plaintext highlighter-rouge">MethodC</code> -&gt; <code class="language-plaintext highlighter-rouge">MethodB</code> -&gt; <code class="language-plaintext highlighter-rouge">MethodA</code> and then finally stopping in the <code class="language-plaintext highlighter-rouge">Main</code> function. Along the way its does a &#x2018;FILTER&#x2019; and &#x2018;CONSIDER&#x2019; step before actually unwinding (&#x2018;finished unwind for &#x2026;&#x2019;):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TID 4740: STACKWALK    starting with partial context
TID 4740: STACKWALK: [000] FILTER  : EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cc48  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [001] CONSIDER: EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cc48  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [001] FILTER  : EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cc48  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [002] CONSIDER: EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cdd8  vtbl= 00007ffd`74995220 
TID 4740: STACKWALK    LazyMachState::unwindLazyState(ip:00007FFD7439C45C,sp:000000029977C338)
TID 4740: STACKWALK: [002] CALLBACK: EXPLICIT : PC= 00000000`00000000  SP= 00000000`00000000  Frame= 00000002`9977cdd8  vtbl= 00007ffd`74995220 
TID 4740: STACKWALK    HelperMethodFrame::UpdateRegDisplay cached ip:00007FFD72FE9258, sp:000000029977D300
TID 4740: STACKWALK: [003] CONSIDER: FRAMELESS: PC= 00007ffd`72fe9258  SP= 00000002`9977d300  method=InitializeSourceInfo 
TID 4740: STACKWALK: [003] CALLBACK: FRAMELESS: PC= 00007ffd`72fe9258  SP= 00000002`9977d300  method=InitializeSourceInfo 
TID 4740: STACKWALK: [004] about to unwind for &apos;InitializeSourceInfo&apos;, SP: 00000002`9977d300 , IP: 00007ffd`72fe9258 
TID 4740: STACKWALK: [004] finished unwind for &apos;InitializeSourceInfo&apos;, SP: 00000002`9977d480 , IP: 00007ffd`72eeb671 
TID 4740: STACKWALK: [004] CONSIDER: FRAMELESS: PC= 00007ffd`72eeb671  SP= 00000002`9977d480  method=CaptureStackTrace 
TID 4740: STACKWALK: [004] CALLBACK: FRAMELESS: PC= 00007ffd`72eeb671  SP= 00000002`9977d480  method=CaptureStackTrace 
TID 4740: STACKWALK: [005] about to unwind for &apos;CaptureStackTrace&apos;, SP: 00000002`9977d480 , IP: 00007ffd`72eeb671 
TID 4740: STACKWALK: [005] finished unwind for &apos;CaptureStackTrace&apos;, SP: 00000002`9977d5b0 , IP: 00007ffd`72eeadd0 
TID 4740: STACKWALK: [005] CONSIDER: FRAMELESS: PC= 00007ffd`72eeadd0  SP= 00000002`9977d5b0  method=.ctor 
TID 4740: STACKWALK: [005] CALLBACK: FRAMELESS: PC= 00007ffd`72eeadd0  SP= 00000002`9977d5b0  method=.ctor 
TID 4740: STACKWALK: [006] about to unwind for &apos;.ctor&apos;, SP: 00000002`9977d5b0 , IP: 00007ffd`72eeadd0 
TID 4740: STACKWALK: [006] finished unwind for &apos;.ctor&apos;, SP: 00000002`9977d5f0 , IP: 00007ffd`14c620d3 
TID 4740: STACKWALK: [006] CONSIDER: FRAMELESS: PC= 00007ffd`14c620d3  SP= 00000002`9977d5f0  method=MethodC 
TID 4740: STACKWALK: [006] CALLBACK: FRAMELESS: PC= 00007ffd`14c620d3  SP= 00000002`9977d5f0  method=MethodC 
TID 4740: STACKWALK: [007] about to unwind for &apos;MethodC&apos;, SP: 00000002`9977d5f0 , IP: 00007ffd`14c620d3 
TID 4740: STACKWALK: [007] finished unwind for &apos;MethodC&apos;, SP: 00000002`9977d630 , IP: 00007ffd`14c62066 
TID 4740: STACKWALK: [007] CONSIDER: FRAMELESS: PC= 00007ffd`14c62066  SP= 00000002`9977d630  method=MethodB 
TID 4740: STACKWALK: [007] CALLBACK: FRAMELESS: PC= 00007ffd`14c62066  SP= 00000002`9977d630  method=MethodB 
TID 4740: STACKWALK: [008] about to unwind for &apos;MethodB&apos;, SP: 00000002`9977d630 , IP: 00007ffd`14c62066 
TID 4740: STACKWALK: [008] finished unwind for &apos;MethodB&apos;, SP: 00000002`9977d660 , IP: 00007ffd`14c62016 
TID 4740: STACKWALK: [008] CONSIDER: FRAMELESS: PC= 00007ffd`14c62016  SP= 00000002`9977d660  method=MethodA 
TID 4740: STACKWALK: [008] CALLBACK: FRAMELESS: PC= 00007ffd`14c62016  SP= 00000002`9977d660  method=MethodA 
TID 4740: STACKWALK: [009] about to unwind for &apos;MethodA&apos;, SP: 00000002`9977d660 , IP: 00007ffd`14c62016 
TID 4740: STACKWALK: [009] finished unwind for &apos;MethodA&apos;, SP: 00000002`9977d690 , IP: 00007ffd`14c61f65 
TID 4740: STACKWALK: [009] CONSIDER: FRAMELESS: PC= 00007ffd`14c61f65  SP= 00000002`9977d690  method=Main 
TID 4740: STACKWALK: [009] CALLBACK: FRAMELESS: PC= 00007ffd`14c61f65  SP= 00000002`9977d690  method=Main 
TID 4740: STACKWALK: [00a] about to unwind for &apos;Main&apos;, SP: 00000002`9977d690 , IP: 00007ffd`14c61f65 
TID 4740: STACKWALK: [00a] finished unwind for &apos;Main&apos;, SP: 00000002`9977d6d0 , IP: 00007ffd`742f9073 
TID 4740: STACKWALK: [00a] FILTER  : NATIVE   : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0 
TID 4740: STACKWALK: [00b] CONSIDER: EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977de58  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [00b] FILTER  : EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977de58  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [00c] CONSIDER: EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977e7e0  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: [00c] FILTER  : EXPLICIT : PC= 00007ffd`742f9073  SP= 00000002`9977d6d0  Frame= 00000002`9977e7e0  vtbl= 00007ffd`74a105b0 
TID 4740: STACKWALK: SWA_DONE: reached the end of the stack
</code></pre></div></div> <p>To find out more, you can search for these diagnostic message in <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp">\vm\stackwalk.cpp</a>, e.g. in <code class="language-plaintext highlighter-rouge">Thread::DebugLogStackWalkInfo(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L802-L856">here</a></p> <h2 id="unwinding-native-code">Unwinding &#x2018;Native&#x2019; Code</h2> <p>As explained in <a href="https://science.raphael.poss.name/go-calling-convention-x86-64.html#aside-exceptions-in-c-c">this excellent article</a>:</p> <blockquote> <p>There are fundamentally two main ways to implement exception propagation in an ABI (Application Binary Interface):</p> <ul> <li> <p>&#x201C;dynamic registration&#x201D;, <strong>with frame pointers in each activation record, organized as a linked list</strong>. This makes stack unwinding fast at the expense of having to set up the frame pointer in each function that calls other functions. This is also simpler to implement.</p> </li> <li> <p>&#x201C;table-driven&#x201D;, <strong>where the compiler and assembler create data structures alongside the program code to indicate which addresses of code correspond to which sizes of activation records</strong>. This is called &#x201C;Call Frame Information&#x201D; (CFI) data in e.g. the GNU tool chain. When an exception is generated, the data in this table is loaded to determine how to unwind. This makes exception propagation slower but the general case faster.</p> </li> </ul>
</blockquote> <p>It turns out that .NET uses the &#x2018;table-driven&#x2019; approach, for the reason explained in the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/stackwalking.md#the-stack-model">&#x2018;BotR&#x2019;</a>:</p> <blockquote> <p>The exact definition of a frame varies from platform to platform and <strong>on many platforms there isn&#x2019;t a hard definition of a frame format that all functions adhere to</strong> (x86 is an example of this). Instead the compiler is often free to optimize the exact format of frames. On such systems it is not possible to guarantee that a stackwalk will return 100% correct or complete results (for debugging purposes, debug symbols such as pdbs are used to fill in the gaps so that debuggers can generate more accurate stack traces).</p> <p>This is not a problem for the CLR, however, since we do not require a fully generalized stack walk. <strong>Instead we are only interested in those frames that are managed (i.e. represent a managed method) or, to some extent, frames coming from unmanaged code used to implement part of the runtime itself</strong>. In particular there is no guarantee about fidelity of 3rd party unmanaged frames other than to note where such frames transition into or out of the runtime itself (i.e. one of the frame types we do care about).</p>
</blockquote> <h3 id="frames">Frames</h3> <p>To enable &#x2018;unwinding&#x2019; of native code or more strictly the transitions &#x2018;into&#x2019; and &#x2018;out of&#x2019; native code, the CLR uses a mechanism of <code class="language-plaintext highlighter-rouge">Frames</code>, which are defined in the source code <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L7-L143">here</a>. These frames are arranged into a hierachy and there is one type of <code class="language-plaintext highlighter-rouge">Frame</code> for each scenario, for more info on these individual <code class="language-plaintext highlighter-rouge">Frames</code> take a look at the excellent source-code comments <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L145-L195">here</a>.</p> <ul> <li><strong>Frame</strong> (abstract/base class) <ul> <li><strong>GCFrame</strong></li> <li><strong>FaultingExceptionFrame</strong></li> <li><strong>HijackFrame</strong></li> <li><strong>ResumableFrame</strong> </li> <li><strong>InlinedCallFrame</strong></li> <li><strong>HelperMethodFrame</strong> <ul> <li>HelperMethodFrame_1OBJ</li> <li>HelperMethodFrame_2OBJ</li> <li>HelperMethodFrame_3OBJ</li> <li>HelperMethodFrame_PROTECTOBJ</li> </ul> </li> <li><strong>TransitionFrame</strong> <ul> <li>StubHelperFrame</li> <li>SecureDelegateFrame </li> <li>FramedMethodFrame <ul> <li>ComPlusMethodFrame</li> <li>PInvokeCalliFrame</li> <li>PrestubMethodFrame</li> <li>StubDispatchFrame</li> <li>ExternalMethodFrame</li> <li>TPMethodFrame</li> </ul> </li> </ul> </li> <li><strong>UnmanagedToManagedFrame</strong> <ul> <li>ComMethodFrame </li> <li>UMThkCallFrame</li> </ul> </li> <li><strong>ContextTransitionFrame</strong></li> <li><strong>TailCallFrame</strong></li> <li><strong>ProtectByRefsFrame</strong></li> <li><strong>ProtectValueClassFrame</strong></li> <li><strong>DebuggerClassInitMarkFrame</strong></li> <li><strong>DebuggerSecurityCodeMarkFrame</strong></li> <li><strong>DebuggerExitFrame</strong></li> <li><strong>DebuggerU2MCatchHandlerFrame</strong></li> <li><strong>FuncEvalFrame</strong></li> <li><strong>ExceptionFilterFrame</strong></li> </ul> </li>
</ul> <h3 id="helper-method-frames">&#x2018;Helper Method&#x2019; Frames</h3> <p>But to make sense of this, let&#x2019;s look at one type of <code class="language-plaintext highlighter-rouge">Frame</code>, known as <code class="language-plaintext highlighter-rouge">HelperMethodFrame</code> (above). This is used when .NET code in the runtime calls into C++ code to do the heavy-lifting, often for performance reasons. One example is if you call <code class="language-plaintext highlighter-rouge">Environment.GetCommandLineArgs()</code> you end up <a href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Environment.cs#L151-L180">in this code</a> (C#), but note that it ends up calling an <code class="language-plaintext highlighter-rouge">extern</code> method marked with <code class="language-plaintext highlighter-rouge">InternalCall</code>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">MethodImplAttribute</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">InternalCall</span><span class="p">)]</span>
<span class="k">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="kt">string</span><span class="p">[]</span> <span class="nf">GetCommandLineArgsNative</span><span class="p">();</span>
</code></pre></div></div> <p>This means that the rest of the method is implemented in the runtime in C++, you can see how the method call is <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/ecalllist.h#L153">wired up</a>, before ending up <code class="language-plaintext highlighter-rouge">SystemNative::GetCommandLineArgs</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/classlibnative/bcltype/system.cpp#L178-L221">here</a>, which is shown below:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FCIMPL0</span><span class="p">(</span><span class="n">Object</span><span class="o">*</span><span class="p">,</span> <span class="n">SystemNative</span><span class="o">::</span><span class="n">GetCommandLineArgs</span><span class="p">)</span>
<span class="p">{</span> <span class="n">FCALL_CONTRACT</span><span class="p">;</span> <span class="n">PTRARRAYREF</span> <span class="n">strArray</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">HELPER_METHOD_FRAME_BEGIN_RET_1</span><span class="p">(</span><span class="n">strArray</span><span class="p">);</span> <span class="c1">// &lt;-- &apos;Helper method Frame&apos; started here</span> <span class="c1">// Error handling and setup code removed for clarity</span> <span class="n">strArray</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTRARRAYREF</span><span class="p">)</span> <span class="n">AllocateObjectArray</span><span class="p">(</span><span class="n">numArgs</span><span class="p">,</span> <span class="n">g_pStringClass</span><span class="p">);</span> <span class="c1">// Copy each argument into new Strings.</span> <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numArgs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">STRINGREF</span> <span class="n">str</span> <span class="o">=</span> <span class="n">StringObject</span><span class="o">::</span><span class="n">NewString</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="n">STRINGREF</span> <span class="o">*</span> <span class="n">destData</span> <span class="o">=</span> <span class="p">((</span><span class="n">STRINGREF</span><span class="o">*</span><span class="p">)(</span><span class="n">strArray</span><span class="o">-&gt;</span><span class="n">GetDataPtr</span><span class="p">()))</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span> <span class="n">SetObjectReference</span><span class="p">((</span><span class="n">OBJECTREF</span><span class="o">*</span><span class="p">)</span><span class="n">destData</span><span class="p">,</span> <span class="p">(</span><span class="n">OBJECTREF</span><span class="p">)</span><span class="n">str</span><span class="p">,</span> <span class="n">strArray</span><span class="o">-&gt;</span><span class="n">GetAppDomain</span><span class="p">());</span> <span class="p">}</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">argv</span><span class="p">;</span> <span class="n">HELPER_METHOD_FRAME_END</span><span class="p">();</span> <span class="c1">// &lt;-- &apos;Helper method Frame&apos; ended/closed here</span> <span class="k">return</span> <span class="n">OBJECTREFToObject</span><span class="p">(</span><span class="n">strArray</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">FCIMPLEND</span>
</code></pre></div></div> <p><strong>Note</strong>: this code makes heavy use of macros, see <a href="https://gist.github.com/mattwarren/36e52b3f80a411ca5a6b7211c9f1a3a9">this gist</a> for the original code and then the expanded versions (Release and Debug). In addition, if you want more information on these mysterious <code class="language-plaintext highlighter-rouge">FCalls</code> as they are known (and the related <code class="language-plaintext highlighter-rouge">QCalls</code>) see <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/mscorlib.md">Mscorlib and Calling Into the Runtime</a> in the &#x2018;BotR&#x2019;.</p> <p>But the main thing to look at in the code sample is the <code class="language-plaintext highlighter-rouge">HELPER_METHOD_FRAME_BEGIN_RET_1()</code> macro, with ultimately installs an instance of the <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/frames.h#L1435-L1492">HelperMethodFrame_1OBJ class</a>. The macro expands into code like this:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FrameWithCookie</span> <span class="o">&lt;</span> <span class="n">HelperMethodFrame_1OBJ</span> <span class="o">&gt;</span> <span class="n">__helperframe</span><span class="p">(</span><span class="n">__me</span><span class="p">,</span> <span class="n">Frame</span><span class="o">::</span><span class="n">FRAME_ATTR_NONE</span><span class="p">,</span> <span class="p">(</span><span class="n">OBJECTREF</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="n">strArray</span><span class="p">);</span> <span class="p">{</span> <span class="n">__helperframe</span><span class="p">.</span><span class="n">Push</span><span class="p">();</span> <span class="c1">// &lt;-- &apos;Helper method Frame&apos; pushed</span> <span class="n">Thread</span> <span class="o">*</span> <span class="n">CURRENT_THREAD</span> <span class="o">=</span> <span class="n">__helperframe</span><span class="p">.</span><span class="n">GetThread</span><span class="p">();</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">CURRENT_THREAD_AVAILABLE</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">CURRENT_THREAD_AVAILABLE</span><span class="p">;;</span> <span class="p">{</span> <span class="n">Exception</span> <span class="o">*</span> <span class="n">__pUnCException</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">Frame</span> <span class="o">*</span> <span class="n">__pUnCEntryFrame</span> <span class="o">=</span> <span class="p">(</span> <span class="o">&amp;</span> <span class="n">__helperframe</span><span class="p">);</span> <span class="kt">bool</span> <span class="n">__fExceptionCatched</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;;</span> <span class="k">try</span> <span class="p">{;</span> <span class="c1">// Original code from SystemNative::GetCommandLineArgs goes in here</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="o">*</span> <span class="n">__pException</span><span class="p">)</span> <span class="p">{;</span> <span class="k">do</span> <span class="p">{}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="n">__pUnCException</span> <span class="o">=</span> <span class="n">__pException</span><span class="p">;</span> <span class="n">UnwindAndContinueRethrowHelperInsideCatch</span><span class="p">(</span><span class="n">__pUnCEntryFrame</span><span class="p">,</span> <span class="n">__pUnCException</span><span class="p">);</span> <span class="n">__fExceptionCatched</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;;</span> <span class="p">}</span> <span class="k">if</span> <span class="p">(</span><span class="n">__fExceptionCatched</span><span class="p">)</span> <span class="p">{;</span> <span class="n">UnwindAndContinueRethrowHelperAfterCatch</span><span class="p">(</span><span class="n">__pUnCEntryFrame</span><span class="p">,</span> <span class="n">__pUnCException</span><span class="p">);</span> <span class="p">}</span> <span class="p">};</span> <span class="n">__helperframe</span><span class="p">.</span><span class="n">Pop</span><span class="p">();</span> <span class="c1">// &lt;-- &apos;Helper method Frame&apos; popped</span>
<span class="p">};</span>
</code></pre></div></div> <p><strong>Note</strong>: the <code class="language-plaintext highlighter-rouge">Push()</code> and <code class="language-plaintext highlighter-rouge">Pop()</code> against <code class="language-plaintext highlighter-rouge">_helperMethodFrame</code> that make it available for &#x2018;stack walking&#x2019;. You can also see the <code class="language-plaintext highlighter-rouge">try</code>/<code class="language-plaintext highlighter-rouge">catch</code> block that the CLR puts in place to ensure any exceptions from <em>native</em> code are turned into <em>managed</em> exceptions that C#/F#/VB.NET code can handle. If you&#x2019;re interested the full macro-expansion is available <a href="https://gist.github.com/mattwarren/36e52b3f80a411ca5a6b7211c9f1a3a9#expanded-code---release---81-loc">in this gist</a>.</p> <p>So in summary, these <code class="language-plaintext highlighter-rouge">Frames</code> are <em>pushed onto</em> a &#x2018;linked list&#x2019; when calling into native code and <em>popped off</em> the list when returning from native code. This means that are any moment the &#x2018;linked list&#x2019; contains all the current or active <code class="language-plaintext highlighter-rouge">Frames</code>.</p> <p>In addition to creating &#x2018;Frames&#x2019;, the CLR also ensures that the C++ compiler emits &#x2018;unwind info&#x2019; for native code. We can see this if we use the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference?view=vs-2017">DUMPBIN tool</a> and run <code class="language-plaintext highlighter-rouge">dumpbin /UNWINDINFO coreclr.dll</code>. We get the following output for <code class="language-plaintext highlighter-rouge">SystemNative::GetCommandLineArgs(..)</code> (that we looked at before):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0002F064 003789B0 00378B7E 004ED1D8  ?GetCommandLineArgs@SystemNative@@SAPEAVObject@@XZ (public: static class Object * __cdecl SystemNative::GetCommandLineArgs(void))
    Unwind version: 1
    Unwind flags: EHANDLER UHANDLER
    Size of prologue: 0x3B
    Count of codes: 13
    Unwind codes:
      29: SAVE_NONVOL, register=r12 offset=0x1C8
      25: SAVE_NONVOL, register=rdi offset=0x1C0
      21: SAVE_NONVOL, register=rsi offset=0x1B8
      1D: SAVE_NONVOL, register=rbx offset=0x1B0
      10: ALLOC_LARGE, size=0x190
      09: PUSH_NONVOL, register=r15
      07: PUSH_NONVOL, register=r14
      05: PUSH_NONVOL, register=r13
    Handler: 00148F14 __GSHandlerCheck_EH
    EH Handler Data: 00415990
    GS Unwind flags: EHandler UHandler
    Cookie Offset: 00000180

  0002F070 00378B7E 00378BB4 004ED26C
    Unwind version: 1
    Unwind flags: EHANDLER UHANDLER
    Size of prologue: 0x0A
    Count of codes: 2
    Unwind codes:
      0A: ALLOC_SMALL, size=0x20
      06: PUSH_NONVOL, register=rbp
    Handler: 0014978C __CxxFrameHandler3
    EH Handler Data: 00415990
</code></pre></div></div> <p>If you want to understand more of what&#x2019;s going on here I really recommend reading the excellent article <a href="https://blogs.msdn.microsoft.com/ntdebugging/2010/05/12/x64-manual-stack-reconstruction-and-stack-walking/">x64 Manual Stack Reconstruction and Stack Walking</a>. But in essence the &#x2018;unwind info&#x2019; describes which registers are used within a method and how big stack is for that method. These pieces of information are enough to tell the runtime how to &#x2018;unwind&#x2019; that particular method when walking the stack.</p> <h3 id="differences-between-windows-and-unix">Differences between Windows and Unix</h3> <p>However, to further complicate things, the &#x2018;native code unwinding&#x2019; uses a different mechanism for &#x2018;Windows&#x2019; v. &#x2018;Unix&#x2019;, as explained in <a href="https://github.com/dotnet/coreclr/issues/177#issuecomment-73648128">coreclr/issues/#177 (comment)</a>:</p> <blockquote> <ol> <li><strong>Stack walker for managed code</strong>. JIT will generate regular Windows style unwinding info. We will reuse Windows unwinder code that we currently have checked in for debugger components for unwinding calls in managed code on Linux/Mac. Unfortunately, this work requires changes in the runtime that currently cannot be tested in the CoreCLR repo so it is hard to do this in the public right now. But we are working on fixing that because, as I mentioned at the beginning, our goal is do most work in the public.</li> <li><strong>Stack walker for native code</strong>. Here, in addition to everything else, we need to allow GC to unwind native stack of any thread in the current process until it finds a managed frame. Currently we are considering using libunwind (http://www.nongnu.org/libunwind) for unwinding native call stacks. @janvorli did some prototyping/experiments and it seems to do what we need. If you have any experience with this library or have any comments/suggestions please let us know.</li> </ol>
</blockquote> <p>This also shows that there are 2 different &#x2018;unwind&#x2019; mechanisms for &#x2018;managed&#x2019; or &#x2018;native&#x2019; code, we will discuss how the &#x201C;<em>stack walker for managed code</em>&#x201D; works in <a href="#unwinding-jitted-code">Unwinding &#x2018;JITted&#x2019; Code</a>.</p> <p>There is also some more information in <a href="https://github.com/dotnet/coreclr/issues/177#issuecomment-73803242">coreclr/issues/#177 (comment)</a>:</p> <blockquote> <p>My current work has two parts, as @sergiy-k has already mentioned. The <strong>windows style unwinder that will be used for the jitted code</strong> and <strong>Unix unwinder for native code</strong> that uses the libunwind&#x2019;s low level <code class="language-plaintext highlighter-rouge">unw_xxxx</code> functions like <code class="language-plaintext highlighter-rouge">unw_step</code> etc.</p>
</blockquote> <p>So, for &#x2018;native code&#x2019; the runtime uses an OS specific mechanism, i.e. on Unix the <a href="https://github.com/libunwind/libunwind">Open Source &#x2018;libunwind&#x2019; library</a> is used. You can see the differences in the code below (from <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/amd64/gmsamd64.cpp#L54-L74">here</a>), under Windows <code class="language-plaintext highlighter-rouge">Thread::VirtualUnwindCallFrame(..)</code> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/stackwalk.cpp#L552-L671">implementation</a>) is called, but on Unix (i.e. <code class="language-plaintext highlighter-rouge">FEATURE_PAL</code>) <code class="language-plaintext highlighter-rouge">PAL_VirtualUnwind(..)</code> (<a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/pal/src/exception/seh-unwind.cpp#L249-L349">implementation</a>) is called instead:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef FEATURE_PAL
</span> <span class="n">pvControlPc</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">::</span><span class="n">VirtualUnwindCallFrame</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nonVolRegPtrs</span><span class="p">);</span>
<span class="cp">#else // !FEATURE_PAL
</span> <span class="p">...</span> <span class="n">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="n">PAL_VirtualUnwind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nonVolRegPtrs</span><span class="p">);</span> <span class="p">...</span> <span class="n">pvControlPc</span> <span class="o">=</span> <span class="n">GetIP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">);</span>
<span class="cp">#endif // !FEATURE_PAL
</span></code></pre></div></div> <p>Before we more on, here are some links to the work that was done to support &#x2018;stack walking&#x2019; when .NET Core CLR was <a href="https://blogs.msdn.microsoft.com/dotnet/2016/06/27/announcing-net-core-1-0/#the-net-core-journey">ported to Linux</a>:</p> <h2 id="unwinding-jitted-code">Unwinding &#x2018;JITted&#x2019; Code</h2> <p>Finally, we&#x2019;re going to look at what happens with &#x2018;managed code&#x2019;, i.e. code that started off as C#/F#/VB.NET, was turned into IL and then compiled into native code by the &#x2018;JIT Compiler&#x2019;. This is the code that you generally want to see in your &#x2018;stack trace&#x2019;, because it&#x2019;s code you wrote yourself!</p> <h3 id="help-from-the-jit-compiler">Help from the &#x2018;JIT Compiler&#x2019;</h3> <p>Simply, what happens is that when the code is &#x2018;JITted&#x2019;, the compiler also emits some extra information, stored via the <code class="language-plaintext highlighter-rouge">EECodeInfo</code> class, which is defined <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/jitinterface.cpp#L13922-L14300">here</a>. Also see the <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/compiler.h#L7316-L7440">&#x2018;Unwind Info&#x2019; section</a> in the JIT Compiler &lt;-&gt; Runtime interface, note how it features seperate sections for <code class="language-plaintext highlighter-rouge">TARGET_ARM</code>, <code class="language-plaintext highlighter-rouge">TARGET_ARM64</code>, <code class="language-plaintext highlighter-rouge">TARGET_X86</code> and <code class="language-plaintext highlighter-rouge">TARGET_UNIX</code>.</p> <p>In addition, in <code class="language-plaintext highlighter-rouge">CodeGen::genFnProlog()</code> <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/codegencommon.cpp#L8832-L9299">here</a> the JIT emits a function &#x2018;prologue&#x2019; that contains several pieces of &#x2018;unwind&#x2019; related data. This is also imlemented in <code class="language-plaintext highlighter-rouge">CEEJitInfo::allocUnwindInfo(..)</code> in <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/vm/jitinterface.cpp#L11275-L11300">this piece of code</a>, which behaves differently for each CPU architecture:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if defined(_TARGET_X86_)
</span> <span class="c1">// Do NOTHING</span>
<span class="cp">#elif defined(_TARGET_AMD64_)
</span> <span class="n">pUnwindInfo</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">UNW_FLAG_EHANDLER</span> <span class="o">|</span> <span class="n">UNW_FLAG_UHANDLER</span><span class="p">;</span> <span class="n">ULONG</span> <span class="o">*</span> <span class="n">pPersonalityRoutine</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG</span><span class="o">*</span><span class="p">)</span><span class="n">ALIGN_UP</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pUnwindInfo</span><span class="o">-&gt;</span><span class="n">UnwindCode</span><span class="p">[</span><span class="n">pUnwindInfo</span><span class="o">-&gt;</span><span class="n">CountOfUnwindCodes</span><span class="p">]),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONG</span><span class="p">));</span> <span class="o">*</span><span class="n">pPersonalityRoutine</span> <span class="o">=</span> <span class="n">ExecutionManager</span><span class="o">::</span><span class="n">GetCLRPersonalityRoutineValue</span><span class="p">();</span>
<span class="cp">#elif defined(_TARGET_ARM64_)
</span> <span class="o">*</span><span class="p">(</span><span class="n">LONG</span> <span class="o">*</span><span class="p">)</span><span class="n">pUnwindInfo</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">// X bit</span> <span class="n">ULONG</span> <span class="o">*</span> <span class="n">pPersonalityRoutine</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG</span><span class="o">*</span><span class="p">)((</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)</span><span class="n">pUnwindInfo</span> <span class="o">+</span> <span class="n">ALIGN_UP</span><span class="p">(</span><span class="n">unwindSize</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONG</span><span class="p">)));</span> <span class="o">*</span><span class="n">pPersonalityRoutine</span> <span class="o">=</span> <span class="n">ExecutionManager</span><span class="o">::</span><span class="n">GetCLRPersonalityRoutineValue</span><span class="p">();</span>
<span class="cp">#elif defined(_TARGET_ARM_)
</span> <span class="o">*</span><span class="p">(</span><span class="n">LONG</span> <span class="o">*</span><span class="p">)</span><span class="n">pUnwindInfo</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">// X bit</span> <span class="n">ULONG</span> <span class="o">*</span> <span class="n">pPersonalityRoutine</span> <span class="o">=</span> <span class="p">(</span><span class="n">ULONG</span><span class="o">*</span><span class="p">)((</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)</span><span class="n">pUnwindInfo</span> <span class="o">+</span> <span class="n">ALIGN_UP</span><span class="p">(</span><span class="n">unwindSize</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ULONG</span><span class="p">)));</span> <span class="o">*</span><span class="n">pPersonalityRoutine</span> <span class="o">=</span> <span class="p">(</span><span class="n">TADDR</span><span class="p">)</span><span class="n">ProcessCLRException</span> <span class="o">-</span> <span class="n">baseAddress</span><span class="p">;</span>
<span class="cp">#endif
</span></code></pre></div></div> <p>Also, the JIT has several <code class="language-plaintext highlighter-rouge">Compiler::unwindXXX(..)</code> methods, that are all implemented in per-CPU source files:</p> <p>Fortunately, we can <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/building/viewing-jit-dumps.md#useful-complus-variables">ask the JIT</a> to output the unwind info that it emits, however this <em>only works</em> with a Debug version of the CLR. Given a simple method like this:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">void</span> <span class="nf">MethodA</span><span class="p">()</span> <span class="p">{</span> <span class="k">try</span> <span class="p">{</span> <span class="nf">MethodB</span><span class="p">();</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="nf">ToString</span><span class="p">());</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>if we call <code class="language-plaintext highlighter-rouge">SET COMPlus_JitUnwindDump=MethodA</code>, we get the following output with 2 &#x2018;Unwind Info&#x2019; sections, one for the <code class="language-plaintext highlighter-rouge">try</code> and the other for the <code class="language-plaintext highlighter-rouge">catch</code> block:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Unwind Info:
  &gt;&gt; Start offset   : 0x000000 (not in unwind data)
  &gt;&gt;   End offset   : 0x00004e (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x07
  CountOfUnwindCodes: 4
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 11 * 8 + 8 = 96 = 0x60
    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
Unwind Info:
  &gt;&gt; Start offset   : 0x00004e (not in unwind data)
  &gt;&gt;   End offset   : 0x0000e2 (not in unwind data)
  Version           : 1
  Flags             : 0x00
  SizeOfProlog      : 0x07
  CountOfUnwindCodes: 4
  FrameRegister     : none (0)
  FrameOffset       : N/A (no FrameRegister) (Value=0)
  UnwindCodes       :
    CodeOffset: 0x07 UnwindOp: UWOP_ALLOC_SMALL (2)     OpInfo: 5 * 8 + 8 = 48 = 0x30
    CodeOffset: 0x03 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rsi (6)
    CodeOffset: 0x02 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rdi (7)
    CodeOffset: 0x01 UnwindOp: UWOP_PUSH_NONVOL (0)     OpInfo: rbp (5)
</code></pre></div></div> <p>This &#x2018;unwind info&#x2019; is then looked up during a &#x2018;stack walk&#x2019; as explained in the <a href="#how-it-works">How it works</a> section above.</p> <p><strong>So next time you encounter a &#x2018;stack trace&#x2019; remember that a lot of work went into making it possible!!</strong></p> <h2 id="further-reading">Further Reading</h2> <p>&#x2018;Stack Walking&#x2019; or &#x2018;Stack Unwinding&#x2019; is a very large topic, so if you want to know more, here are some links to get you started:</p> <h3 id="stack-unwinding-general">Stack Unwinding (general)</h3> <h3 id="stack-unwinding-other-runtimes">Stack Unwinding (other runtimes)</h3> <p>In addition, it&#x2019;s interesting to look at how other runtimes handles this process:</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>