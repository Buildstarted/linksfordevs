<!DOCTYPE html>
<html lang="en">
<head>
    <title>
&quot;Rust does not have a stable ABI&quot; - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="&quot;Rust does not have a stable ABI&quot; - linksfor.dev(s)"/>
    <meta property="og:description" content="I&#x27;ve seen GNOME people (often, people who have been working for a long&#xA;time on C libraries) express concerns along the following lines:"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://people.gnome.org/~federico/blog/rust-stable-abi.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - &quot;Rust does not have a stable ABI&quot;</title>
<div class="readable">
        <h1>&quot;Rust does not have a stable ABI&quot;</h1>
            <div>Reading time: 16-21 minutes</div>
        <div>Posted here: 14 Aug 2020</div>
        <p><a href="https://people.gnome.org/~federico/blog/rust-stable-abi.html">https://people.gnome.org/~federico/blog/rust-stable-abi.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
    <p>I've seen GNOME people (often, people who have been working for a long
time on C libraries) express concerns along the following lines:</p>
<ol>
<li>Compiled Rust code doesn't have a stable ABI (application binary interface).</li>
<li>So, we can't have shared libraries in the traditional fashion of
   Linux distributions.</li>
<li>Also Rust bundles its entire standard library with every binary it compiles, which makes Rust-built libraries huge.</li>
</ol>
<p>These are extremely valid concerns to be addressed by people like
myself who propose that chunks of infrastructural libraries
should be done in Rust.</p>
<p>So, let's begin.</p>
<p>The first part of this article is a super-quick introduction to shared
libraries and how Linux distributions use them.  If you already know
those things, feel free to skip to the "<a href="#rust_does_not_have_a_stable_abi">Rust does not have a stable
ABI</a>" section.</p>
<h2>How do distributions use shared libraries?</h2>
<p>If several programs run at the same time and use the same shared library
(say, <code>libgtk-3.so</code>), the operating system can load a single copy of
the library in memory and share the read-only parts of the code/data
through the magic of virtual memory.</p>
<p><em>In theory</em>, if a library gets a bugfix but does not change its
interface, one can just recompile the library, stick the new <code>.so</code> in
<code>/usr/lib</code> or whatever, and be done with it.  Programs that depend on
the library do not need to be recompiled.</p>
<p>If libraries limit their public interface to a plain C ABI
(application binary interface), they are relatively easy to consume
from other programming languages.  Those languages don't have to deal
with name mangling of C++ symbols, exception handlers, constructors,
and all that complexity.  Pretty much every language has some form of
C&nbsp;FFI (foreign function interface), which roughly means "call C
functions without too much trouble".</p>
<p>For the purposes of a library, what's an
<a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a>?
Wikipedia says, "An ABI defines how data structures or computational
routines are accessed in machine code [...] A common aspect of an
ABI is the calling convention", which means that to call a function in
machine code you need to frob the call and stack pointers, pass some
function arguments in registers or push some others to the stack, etc.
Really low-level stuff.  Each machine architecture or operating system
usually defines a C standard ABI.</p>
<p>For libraries, we commonly understand an ABI to mean the machine-code
implications of their programming interface.  Which functions are
available as public symbols in the <code>.so</code> file?  To which numeric
values do C enum values correspond, so that they can be passed to
those functions?  What is the exact order and type of arguments that
the functions take?  What are the struct sizes, and the order and
types and padding of the fields that those functions take?  Does one
pass arguments in CPU registers or on the stack?  Does the caller or
the callee clean up the stack after a function call?</p>
<h2>Bug fixes and security fixes</h2>
<p>Linux distributions generally try <em>really hard</em> to have a single
version of each shared library installed in the system:  a single
<code>libjpeg.so</code>, a single <code>libpng.so</code>, a single <code>libc.so</code>, etc.</p>
<p>This is helpful when there needs to be an update to fix a bug,
security-related or not: users can just download the updated package
for the library, which when installed will just stick in a new <code>.so</code>
in the right place, and the calling software won't need to be updated.</p>
<p>This is possible only if the bug <em>really only changes the internal
code</em> without changing behavior or interface.  If a bug fix requires
part of the public API or ABI to change, then you are screwed; all
calling software needs to be recompiled.  "Irresponsible" library
authors either learn really fast when distros complain loudly about
this sort of change, or they don't learn and get forever marked by
distros as "that irresponsible library" which always requires special
handling in order not to break other software.</p>
<p>Sidenote: sometimes it's more complicated.  Poppler (the PDF
rendering library) ships at least two stable APIs, one Glib-based in
C, and one Qt-based in C++.  However, some software like texlive uses
Poppler's internals library directly, which of course does not have a
stable API, and thus texlive breaks frequently as Poppler evolves.
Someone should extend the public, stable API so that texlive doesn't
have to use the library's internals!</p>
<h2>Bundled libraries</h2>
<p>Sometimes it is not irresponsible authors of libraries, but rather
that people who use the libraries find out that over time the behavior
of the library changes subtly, maybe without breaking the API or ABI,
and they are better off bundling a specific version of the library
with their software.  That version is what they test their software
against, and they try to learn its quirks.</p>
<p>Distros inevitably complain about this, and either patch the calling
software by hand to force it to use the system's shared library, or
succeed in getting patches accepted by the software so that they have
a <code>--use-system-libjpeg</code> option or similar.</p>
<p>This doesn't work very well if the bundled version of the library has
extra patches that are not in a distro's usual patches.  Or
vice-versa; it may actually work better to use the distro's version of
the library, if it has extra fixes that the bundled library doesn't.
Who knows!  It's a case-by-case situation.</p>
<h2 id="rust_does_not_have_a_stable_abi">Rust does not have a stable ABI</h2>
<p>By default indeed it doesn't, because the compiler team wants to have
the freedom to change the data layout and Rust-to-Rust calling
conventions, often for performance reasons, at any time.  For example,
it is not guaranteed that struct fields will be laid out in memory in
the same order as they are written in the code:</p>
<div><pre><span></span><code><span>struct</span> <span>Foo</span><span> </span><span>{</span><span></span>
<span>    </span><span>bar</span>: <span>bool</span><span>,</span><span></span>
<span>    </span><span>baz</span>: <span>f64</span><span>,</span><span></span>
<span>    </span><span>beep</span>: <span>bool</span><span>,</span><span></span>
<span>    </span><span>qux</span>: <span>i32</span><span>,</span><span></span>
<span>}</span><span></span>
</code></pre></div>


<p>The compiler is free to rearrange the struct fields in memory as it
sees fit.  Maybe it decides to put the two <code>bool</code> fields next to each
other to save on inter-field padding due to alignment requirements;
maybe it does static analysis or profile-guided optimizations and
picks an optmal ordering.</p>
<p>But we can override this!  Let's look at data layout first, and then
calling conventions.</p>
<h3>Data layout for C versus Rust</h3>
<p>The following is the same struct as above, but with an extra <code>#[repr(C)]</code> attribute:</p>
<div><pre><span></span><code><span>#[repr(C)]</span><span></span>
<span>struct</span> <span>Foo</span><span> </span><span>{</span><span></span>
<span>    </span><span>bar</span>: <span>bool</span><span>,</span><span></span>
<span>    </span><span>baz</span>: <span>f64</span><span>,</span><span></span>
<span>    </span><span>beep</span>: <span>bool</span><span>,</span><span></span>
<span>    </span><span>qux</span>: <span>i32</span><span>,</span><span></span>
<span>}</span><span></span>
</code></pre></div>


<p>With that attribute, the struct will be laid out just as this C struct:</p>
<div><pre><span></span><code><span>#include</span> <span>&lt;stdbool.h&gt;</span><span></span>
<span>#include</span> <span>&lt;stdint.h&gt;</span><span></span>

<span>struct</span> <span>Foo</span> <span>{</span>
    <span>bool</span> <span>bar</span><span>;</span>
    <span>double</span> <span>baz</span><span>;</span>
    <span>bool</span> <span>beep</span><span>;</span>
    <span>int32_t</span> <span>qux</span><span>;</span>
<span>}</span>
</code></pre></div>


<p>(Aside: it is unfortunate that <a href="https://people.gnome.org/~federico/news-2017-04.html#gboolean-is-not-rust-bool"><code>gboolean</code> is not <code>bool</code></a>,
but that's because <code>gboolean</code> predates C99, and clearly standards from
20 years ago are <em>too new</em> to use.  (Aside aside: since I wrote that
other post, Rust's repr(C) for bool is actually defined as C99's bool;
it's no longer undefined.))</p>
<p>Even Rust's data-carrying enums can be laid out in a manner friendly
to C and C++:</p>
<div><pre><span></span><code><span>#[repr(C, u8)]</span><span></span>
<span>enum</span> <span>MyEnum</span><span> </span><span>{</span><span></span>
<span>    </span><span>A</span><span>(</span><span>u32</span><span>),</span><span></span>
<span>    </span><span>B</span><span>(</span><span>f32</span><span>,</span><span> </span><span>bool</span><span>),</span><span></span>
<span>}</span><span></span>
</code></pre></div>


<p>This means, use C layout, and a <code>u8</code> for the enum's discriminant.  It
will be laid out like this:</p>
<div><pre><span></span><code><span>#include</span> <span>&lt;stdbool.h&gt;</span><span></span>
<span>#include</span> <span>&lt;stdint.h&gt;</span><span></span>

<span>enum</span> <span>MyEnumTag</span> <span>{</span>
        <span>A</span><span>,</span>
        <span>B</span>
<span>};</span>

<span>typedef</span> <span>uint32_t</span> <span>MyEnumPayloadA</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>{</span>
        <span>float</span> <span>x</span><span>;</span>
        <span>bool</span> <span>y</span><span>;</span>
<span>}</span> <span>MyEnumPayloadB</span><span>;</span>

<span>typedef</span> <span>union</span> <span>{</span>
        <span>MyEnumPayloadA</span> <span>a</span><span>;</span>
        <span>MyEnumPayloadB</span> <span>b</span><span>;</span>
<span>}</span> <span>MyEnumPayload</span><span>;</span>

<span>typedef</span> <span>struct</span> <span>{</span>
        <span>uint8_t</span> <span>tag</span><span>;</span>
        <span>MyEnumPayload</span> <span>payload</span><span>;</span>
<span>}</span> <span>MyEnum</span><span>;</span>
</code></pre></div>


<p>The gory details of data layout are in the <a href="https://doc.rust-lang.org/nomicon/other-reprs.html">Alternative Representations section of the
Rustonomicon</a> and
the <a href="https://rust-lang.github.io/unsafe-code-guidelines/introduction.html">Unsafe Code
Guidelines</a>.</p>
<h3>Calling conventions</h3>
<p>An ABI's calling conventions detail things like how to call functions
in machine code, and how to lay out function arguments in registers or
the stack.  <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">The wikipedia page on X86 calling
conventions</a>
has a good cheat-sheet, useful when you are looking at assembly code
and registers in a low-level debugger.</p>
<p>I've already written about how it is possible to write Rust code to
export functions callable from C; one uses the <code>extern "C"</code> in the
function definition and a <code>#[no_mangle]</code> attribute to keep the symbol
name pristine.  This is how librsvg is able to have the following:</p>
<div><pre><span></span><code><span>#[no_mangle]</span><span></span>
<span>pub</span><span> </span><span>unsafe</span><span> </span><span>extern</span><span> </span><span>"C"</span><span> </span><span>fn</span> <span>rsvg_handle_new_from_file</span><span>(</span><span></span>
<span>    </span><span>filename</span>: <span>*</span><span>const</span><span> </span><span>libc</span>::<span>c_char</span><span>,</span><span></span>
<span>    </span><span>error</span>: <span>*</span><span>mut</span><span> </span><span>*</span><span>mut</span><span> </span><span>glib_sys</span>::<span>GError</span><span>,</span><span></span>
<span>)</span><span> </span>-&gt; <span>*</span><span>const</span><span> </span><span>RsvgHandle</span><span> </span><span>{</span><span></span>
<span>    </span><span>// ...</span>
<span>}</span><span></span>
</code></pre></div>


<p>Which compiles to what a C compiler would produce for this:</p>
<div><pre><span></span><code><span>RsvgHandle</span> <span>*</span><span>rsvg_handle_new_from_file</span> <span>(</span><span>const</span> <span>gchar</span> <span>*</span><span>filename</span><span>,</span> <span>GError</span> <span>**</span><span>error</span><span>);</span>
</code></pre></div>


<p>(Aside: librsvg <a href="https://gitlab.gnome.org/GNOME/librsvg/-/issues/416">still uses an intermediate C library full of
stubs</a> that just
call the Rust-exported functions, but there is now <a href="https://gitlab.gnome.org/GNOME/librsvg/-/issues/552">tooling to produce a .so
directly from
Rust</a> which I
just haven't had time to investigate.  Help is appreciated!)</p>
<h3>Summary of ABI so far</h3>
<p>It is <em>one's decision</em> to export a stable C ABI from a Rust library.
There is some awkwardness in how types are laid out in C, because the
Rust type system is richer, but things can be made to work well with a
little thought.  Certainly no more thought than the burden of
designing and maintaining a stable API/ABI in plain C.</p>
<p>I'll fold the second concern into here — "we can't have shared
libraries in traditional distro fashion".  Yes, we can, API/ABI-wise,
but read on.</p>
<h2>Rust bundles its entire standard library with Rust-built .so's</h2>
<p>I.e. it statically links all the Rust dependencies.  This produces a
large .so:</p>
<ul>
<li>librsvg-2.so (version 2.40.21, C only) - 1408840&nbsp;bytes</li>
<li>librsvg-2.so (version 2.49.3, Rust only) - 9899120&nbsp;bytes</li>
</ul>
<p>Holy crap!  What's all that?</p>
<p>(And I'm cheating: this is both with link-time optimization turned on,
and by running <code>strip(1)</code> on the .so.  If you just <code>autogen.sh &amp;&amp; make</code>
it will be bigger.)</p>
<p>This has Rust's standard library statically linked (or at least the
bits of that librsvg actually uses), plus all the Rust dependencies
(cssparser, selectors, nalgebra, glib-rs, cairo-rs, locale_config,
rayon, xml5ever, and an assload of crates).  I could explain why each
one is needed:</p>
<ul>
<li>cssparser - librsvg needs to parse CSS.</li>
<li>selectors - librsvg needs to run the CSS selector matching
  algorithm.</li>
<li>nalgebra - the code for SVG filter effects uses vectors and
  matrices.</li>
<li>glib-rs, cairo-rs - draw to Cairo and export GObject types.</li>
<li>locale_config - so that localized SVG files can work.</li>
<li>rayon - so filters can use all your CPU cores instead of processing
  one pixel at a time.</li>
<li>Etcetera.  SVG is big and requires a lot of helper code!</li>
</ul>
<p>Is this a problem?</p>
<p>Or more exactly, why does this happen, and why do people perceive it
as a problem?</p>
<h3>Stable APIs/ABIs and distros</h3>
<p>Many Linux distributions have worked <em>really hard</em> to ensure that
there is a single copy of "system libraries" in an installation.
There is Just One Copy of <code>/usr/lib/libc.so</code>, <code>/usr/lib/libjpeg.so</code>,
etc., and packages are compiled with special options to tell them to
really use the sytem libraries instead of their bundled versions, or
patched to do so if they don't provide build-time options for that.</p>
<p>In a way, this works well for distros:</p>
<ul>
<li>
<p>A bug in a library can be fixed in a single place, and all
  applications that use it get the fix automatically.</p>
</li>
<li>
<p>A security bug can be patched in a single place, and in theory
  applications don't need to be audited further.</p>
</li>
</ul>
<p>If you maintain a library that is shipped in Linux distros, and you
break the ABI, you'll get complaints from distros very quickly.</p>
<p>This is good because it creates responsible maintainers for libraries
that can be depended on.  It's how Inkscape/GIMP can have a stable
toolkit to be written in.</p>
<p>This is bad because it encourages stagnation in the long term.  It's
how we get a horrible, unsafe, error-prone API in libjpeg that can
never ever be improved because it would requires changes in tons of
software; it's why <code>gboolean</code> is still a 32-bit <code>int</code> after
twenty-something years, even though everything else close to C has
decided that booleans are 1&nbsp;byte.  It's how Inkscape/GIMP take many
years to move from GTK2 to GTK3 (okay, that's lack of paid developers
to do the grunt work, but it is enabled by having forever-stable APIs).</p>
<p>However, a long-term stable API/ABI has a <strong>lot of value</strong>.  It is why
the Windows API is the crown jewels; it is why people can rely on glib
and glibc to not break their code for many years and take them for granted.</p>
<h3>But we only have a single stable ABI anyway</h3>
<p>And that is the C ABI.  Even C++ libraries have trouble with this, and
people sometimes write the internals of a library in C++ for
convenience, but export a stable C API/ABI from it.</p>
<p>High level languages like Python have <em>real trouble</em> calling C++ code
precisely because of ABI issues.</p>
<h3>Actually, in GNOME we have gone further than that</h3>
<p>In GNOME we have constructed a sweet little universe where <a href="https://people.gnome.org/~federico/blog/magic-of-gobject-introspection.html">GObject
Introspection</a> is
basically a C ABI with a ton of machine-generated annotations to make
it friendly to language bindings.</p>
<p>Still, we rely on a C ABI underneath.  See <a href="https://twitter.com/federicomena/status/1286447929880801280">this exploratory twitter
thread on advancing the C ABI from Rust</a> for
lots of food for thought.</p>
<h3>Single copies of libraries with a C ABI</h3>
<p>Okay, let's go back to this.  What price do we pay for single copies
of libraries that, by necessity, must export a C ABI?</p>
<ul>
<li>
<p>Code that can be conveniently called from C, maybe from C++, and
  moderately to very inconvently from ANYTHING ELSE.  With most new
  application code being written definitely not in C, maybe we should
  reconsider our priorities here.</p>
</li>
<li>
<p>No language facilities like generics or field visibility, which are
  not even "modern language" features.  Even C++ templates get
  compiled and statically linked into the calling code, because
  there's no way to pass information like the size of <code>T</code> in
  <code>Array&lt;T&gt;</code> across a C ABI.  You wanted to make some struct fields
  public and some private?  You are out of luck.</p>
</li>
<li>
<p>No knowledge of data ownership except by careful reading of the C
  function's documentation.  Does the function free its arguments?
  How - with <code>free()</code> or <code>g_free()</code> or <code>my_thing_free()</code>?  Or does the
  caller just lend it a reference?  Can the data be copied bit-by-bit
  or must a special function be called to make a copy?
  GObject-Introspection carries this information in its annotations,
  while the C ABI has no idea and just ships raw pointers around.</p>
</li>
</ul>
<p>More food for thought note: <a href="https://twitter.com/hsivonen/status/1232204147740508162">this twitter
thread</a> says
this about the C++ ABI: "Also, the ABI matters for whether the actual
level of practicality of complying with LGPL matches the level of
practicality intended years ago when some project picked LGPL as its
license. Of course, the standard does not talk about LGPL, either.
LGPL has rather different implications for Rust and Go than it does
for C and Java. It was obviously written with C in mind."</p>
<h2>Monomorphization and template bloat</h2>
<p>While C++ had the problem of "lots of template code in header files",
Rust has the problem that <a href="https://pingcap.com/blog/generics-and-compile-time-in-rust#monomorphized-generics">monomorphization of generics creates a lot
of compiled
code</a>.
There are tricks to avoid this and they are all the decision of the
library/crate author.  Both share the root cause that templated or
generic code must be recompiled for every specific use, and thus
cannot live in a shared library.</p>
<p>Also, see this wonderful <a href="https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/">article on how different languages implement
generics</a>,
and think that a plain C ABI means we have NOTHING of the sort.</p>
<p>Also, see <a href="https://gankra.github.io/blah/swift-abi/">How Swift Achieved Dynamic Linking Where Rust
Couldn't</a> for more food for
thought.  This is extremely roughly equivalent to GObject's boxed
types; callers keep values on the heap but know the type layout via
annotation magic, while the library's actual implementation
is free to have the values on the stack or wherever for its own use.</p>
<h2>Should all libraries export APIs with generics and exotic types?</h2>
<p>No!</p>
<p>You probably want something like a low-level array of values,
<code>Vec&lt;T&gt;</code>, to be inlined everywhere and with code that knows the
type of the vector's elements.  Element accesses can be inlined to a
single machine instruction in the best case.</p>
<p>But not everything requires this absolute raw performance with
everything inlined everywhere.  It is fine to pass references or
pointers to things and do dynamic dispatch from a vtable if you are
not in a super-tight loop, as we love to do in the GObject world.</p>
<h2>Library sizes</h2>
<p>I don't have a good answer to librsvg's compiled size.  If gnome-shell
merges my branch to rustify the CSS code, it will also grow its binary
size by quite a bit.</p>
<p>It is my intention to have a Rust crate that both librsvg and
gnome-shell share for their CSS styling needs, but right now I have no
idea if this would be a shared library or just a normal Rust crate.
Maybe it's possible to have a very general CSS library, and the
application registers which properties it can parse and how?  Is it
possible to do this as a shared library without essentially
reinventing libcroco?  I don't know yet.  We'll see.</p>
<h2>A metaphor which I haven't fully explored</h2>
<p>If every application or end-user package is kind of like a living
organism, with its own cycles and behaviors and organs (dependent
libraries) that make it possible...</p>
<p>Why do distros expect all the living organisms on your machine to
share The World's Single Lungs Service, and The World's Single Stomach
Service, and The World's Single Liver Service?</p>
<p>You know, instead of letting every organism have its own slightly
different version of those organs, customized for it?  We humans know
how to do vaccination campaigns and everything; maybe we need better
tools to apply bug fixes where they are needed?</p>
<p>I know this metaphor is extremely imperfect and not how things work in
software, but it makes me wonder.</p>
  </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>