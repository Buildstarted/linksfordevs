<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Securing gRPC-based Microservices in .NET Core - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Securing gRPC-based Microservices in .NET Core - linksfor.dev(s)"/>
    <meta property="article:author" content="Search Results"/>
    <meta property="og:description" content="Learn how to add authentication and authorization to gRPC for microservices in .NET Core."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://auth0.com/blog/securing-grpc-microservices-dotnet-core/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Securing gRPC-based Microservices in .NET Core</title>
<div class="readable">
        <h1>Securing gRPC-based Microservices in .NET Core</h1>
            <div>by Search Results</div>
            <div>Reading time: 24-30 minutes</div>
        <div>Posted here: 27 Feb 2020</div>
        <p><a href="https://auth0.com/blog/securing-grpc-microservices-dotnet-core/">https://auth0.com/blog/securing-grpc-microservices-dotnet-core/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
      <div>
        
          <p><img src="https://cdn.auth0.com/blog/illustrations/grpc-logo.png" alt="illustration"></p><div>
          
          
          
          
          
          

          
            <p><span>.NET</span></p>
          <p>Learn how to add authentication and authorization to gRPC for microservices in .NET Core.</p>
          
            
            
            
            
            
            
            
            <p id="post-date">February 25, 2020</p>
            <meta itemprop="datePublished" content="2020-02-25">
            <meta itemprop="dateModified" content="2020-02-25">
          

          
        </div>
      </div>
    </div><article>
      <!-- ///DESKTOP TOC/// -->
      

      <!-- ///MAIN CONTENT/// -->
      <main id="main-post-content" itemprop="articleBody">
        <div id="blog-post-content">

          
          <p><strong>TL;DR:</strong> This tutorial will show you how to integrate authentication and authorization in a .NET Core microservice scenario based on gRPC. You will go through the process of protecting the server endpoints and will learn how to authorize a gRPC client to make requests to it. The full code of the final project is available at <a href="https://github.com/auth0-blog/secure-grpc-dotnet" target="_blank">this GitHub repository</a>.</p>

<h2 id="The-gRPC-Framework">The gRPC Framework</h2>

<p>Lately, <a href="https://grpc.io/" target="_blank">gRPC</a> is becoming quite popular since it allows you to build high performance distributed systems. Initially designed by Google to optimize communication within their internal service infrastructure, it is now an open-source project available for <a href="https://packages.grpc.io/" target="_blank">most common programming languages</a>: from Java to Python, to PHP, to C#. In a nutshell, gRPC is a <a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">Remote Procedure Call</a> framework (RPC framework) based on the HTTP/2 protocol to transport binary messages and on the <a href="https://developers.google.com/protocol-buffers/" target="_blank">Protocol Buffers</a>, also known as <em>Protobuf</em>, to define service contracts. A mandatory requirement for a gRPC service is to accept only secure gRPC connections, such as <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank">TLS</a> connections.</p>

<p>Starting from .NET Core 3.0, Microsoft supports gRPC natively, so .NET Core developers can leverage this framework to build efficient microservices. The tutorial <a href="https://auth0.com/blog/implementing-microservices-grpc-dotnet-core-3" target="_blank">Implementing Microservices with gRPC and .NET Core 3.0</a> introduces you to the basics of using this framework with .NET Core. It shows you how to create a simple microservice that evaluates whether a customer is entitled to receive credit for a given amount and a client that makes requests to it.</p>

<p>In this tutorial, you will take that project and will secure the communication between the client and the server by using <a href="https://auth0.com/" target="_blank">Auth0</a>.</p>

<h3>Prerequisites</h3>

<p>As a first step, ensure you have .NET Core 3.1 SDK installed on your machine. You can check this by running the following command in a terminal window:</p>

<pre><code><span>dotnet</span> --version
</code></pre>

<p>If you get the value <code>3.1.100</code> or above, then your environment is ready to start this project. Otherwise, <a href="https://dotnet.microsoft.com/download/dotnet-core/3.1" target="_blank">download the .NET Core 3.1 SDK</a> and install it on your machine.</p>

<blockquote><p>If you have the latest version of Visual Studio, you already have the .NET Core 3.1 SDK installed.</p></blockquote>

<p>If this is the <strong>very first time</strong> you run an HTTP-based .NET Core application on your machine, <strong>you have to trust the HTTPS development server certificate</strong>. You can do this by running the following command in a terminal window:</p>

<pre><code><span>dotnet</span> dev-certs https --trust
</code></pre>

<p>Now that you trusted the TLS/SSL certificate, you can download the initial project from GitHub by typing the following command:</p>

<pre><code><span>git</span> clone -b starting-point --single-branch https://github.com/auth0-blog/secure-grpc-dotnet
</code></pre>

<p>This command will clone only the <code>starting-point</code> branch of the repository in your machine. This branch contains the complete code of the gRPC server and its client, built in the <a href="https://auth0.com/blog/implementing-microservices-grpc-dotnet-core-3" target="_blank">gRPC tutorial</a> mentioned above. After cloning the repository, you will find a <code>secure-grpc-dotnet</code> folder on your machine. In this folder, you have:</p>

<ul>
<li>the <code>CreditRatingService</code> folder: it contains the .NET Core project for the gRPC server</li>
<li>the <code>CreditRatingClient</code> folder: it contains the project for the client.</li>
</ul>


<p>You are now going to modify these projects to use Auth0 authentication and authorization features. If you want more details about the implementation of the client and the server, please check the <a href="https://auth0.com/blog/implementing-microservices-grpc-dotnet-core-3" target="_blank">gRPC tutorial</a>.</p>

<h2 id="The-Authentication-and-Authorization-Scenario">The Authentication and Authorization Scenario</h2>

<p>The gRPC server implementation you downloaded from GitHub accepts requests from any gRPC client. As said, the goal of this tutorial is to secure the gRPC server so that only authorized gRPC clients can make requests to check whether a customer can receive credit.</p>

<p><a href="https://auth0.com/" target="_blank">Auth0</a> provides you with an easy way to integrate authentication and authorization in your applications. However, it is very important to identify the correct scenario that applies to your system. Your system's scenario requires you to choose the right <a href="https://auth0.com/docs/flows" target="_blank">flow for authentication and authorization</a>.</p>

<p>The scenario depicted by the two projects that implement the gRPC client and server is a microservice scenario. In this context, the two applications run autonomously without user interaction, even if the initial request would be originated by a user.</p>

<blockquote><p>In the specific case, the gRPC client is a console application that needs to be run by a user. However, this choice has been made for simplicity. In a production environment, the client could be a running process without user interaction.</p></blockquote>

<p>So, in the system you are going to secure, the client and the server act autonomously, not on behalf of a user. They are meant to run on the server side, so both applications are not publicly accessible. This is very important since the fact that they are not publicly accessible lets you delimit the security risks they can come across. In other words, this is what is called a machine-to-machine (M2M) scenario. In this case, the flow you are going to use is the <a href="https://auth0.com/docs/flows/concepts/client-credentials" target="_blank">Client Credentials Flow</a>. With this flow, the client is authenticated and authorized per se, not on behalf of a user.</p>

<p>The following diagram summarizes the interactions between the client (M2M App), the server (Your API), and the authorization server (Auth0 Tenant) in this flow.</p>

<p><img src="https://cdn.auth0.com/blog/secure-grpc-dotnet/auth-sequence-client-credentials.png" alt="Client Credentials Flow" title="Client Credentials Flow"></p>

<p>With this scenario in mind, you are ready to arrange the two projects to support the Client Credentials Flow.</p>

<blockquote>
  <a href="https://twitter.com/intent/tweet?text=%22Learn+how+to+secure+your+gRPC+microservices+in+.NET+Core.%22%20via%20@auth0%20http://auth0.com/blog/securing-grpc-microservices-dotnet-core/" target="_blank">
    <p>"Learn how to secure your gRPC microservices in .NET Core."</p>
    <div>
            <div>
            
                <p><img src="https://cdn.auth0.com/blog/resources/twitter.svg"></p><h4>Tweet This</h4>
            </div>
        </div>
  </a>
</blockquote>


<h2 id="Securing-the-gRPC-Server">Securing the gRPC Server</h2>

<p>Start securing the microservice system by protecting the gRPC server from unauthorized accesses. You will achieve this objective by registering the server with Auth0 and applying a few changes to the <code>CreditRatingService</code> project.</p>

<h3>Register the server with Auth0</h3>

<p>So, to register the gRPC server with Auth0, access the <a href="https://manage.auth0.com/" target="_blank">Auth0 Dashboard</a>. If you don't have an Auth0 account, you can <a href="https://auth0.com/signup" data-amp-replace="CLIENT_ID" data-amp-addparams="anonId=CLIENT_ID(cid-scope-cookie-fallback-name)" target="_blank">sign up for a free Auth0 account here</a>. Then, move to the <a href="https://manage.auth0.com/#/apis" target="_blank">API section of the Dashboard</a> and follow these steps:</p>

<ol>
<li><p>Click on <em>Create API</em></p></li>
<li><p>Provide a friendly name for your API (for example, <em>Credit Rating Service</em>) and a unique identifier in the URL format (for example, <em>https://credit-rating-service</em>), as shown in the following picture:</p>

<p><img src="https://cdn.auth0.com/blog/secure-grpc-dotnet/registering-grpc-server-with-auth0.png" alt="Registering the gRPC server with Auth0" title="Registering the gRPC server with Auth0"></p></li>
<li><p>Leave the signing algorithm to RS256 and click the <em>Create</em> button</p></li>
</ol>


<p>These steps make Auth0 aware of your server and will allow you to control access.</p>

<blockquote><p>While you are in the Auth0 Dashboard, take note of your Auth0 domain, you will need it soon. This is a string in the form <code>YOUR-TENANT-NAME.auth0.com</code> where <code>YOUR-TENANT-NAME</code> is the name you provided when you created your account with Auth0. For more information, <a href="https://auth0.com/docs/getting-started/the-basics#domains" target="_blank">check the documentation</a>.</p></blockquote>

<h3>Configure the server application</h3>

<p>Now, you need to configure your gRPC server with the parameters provided by Auth0. So, move into the <code>CreditRatingService</code> folder under the <code>secure-grpc-dotnet</code> folder. Here, open the <code>appsettings.json</code> configuration file and replace its content with the following:</p>

<pre><code>{
  <span>"Logging"</span>: {
    <span>"LogLevel"</span>: {
      <span>"Default"</span>: <span>"Warning"</span>,
      <span>"Microsoft.Hosting.Lifetime"</span>: <span>"Information"</span>
    }
  },
  <span>"AllowedHosts"</span>: <span>"*"</span>,
  <span>"Kestrel"</span>: {
    <span>"EndpointDefaults"</span>: {
      <span>"Protocols"</span>: <span>"Http2"</span>
    }
  },
  <span>"Auth0"</span>: {
    <span>"Domain"</span>: <span>"YOUR_AUTH0_DOMAIN"</span>,
    <span>"Audience"</span>: <span>"YOUR_UNIQUE_IDENTIFIER"</span>
  }
}
</code></pre>

<p>Replace the <code>YOUR_AUTH0_DOMAIN</code> placeholder with your Auth0 domain, matching the format <code>YOUR-TENANT-NAME.auth0.com</code>, and the <code>YOUR_UNIQUE_IDENTIFIER</code> placeholder with the value you provided as a unique identifier of your API.</p>

<h3>Integrate the server with Auth0</h3>

<p>In order to interact with the Auth0 authorization services, your server needs to be able to handle tokens in the <a href="https://jwt.io/" target="_blank">JWT</a> (<em>JSON Web Token</em>) format.</p>









<p>You can accomplish this by installing the <code>Microsoft.AspNetCore.Authentication.JwtBearer</code> library. So, still in the <code>CreditRatingService</code> folder, type the following command in a terminal window:</p>

<pre><code><span>dotnet</span> <span>add</span> <span>package</span> <span>Microsoft</span><span>.AspNetCore</span><span>.Authentication</span><span>.JwtBearer</span>
</code></pre>

<p>After a few seconds, the package is installed, and you are ready to make changes to the server's code so that it will support authentication and authorization. For this purpose, open the <code>Startup.cs</code> file and replace the <code>using</code> section with the following:</p>

<pre><code>

<span>using</span> Microsoft.AspNetCore.Builder;
<span>using</span> Microsoft.AspNetCore.Hosting;
<span>using</span> Microsoft.AspNetCore.Http;
<span>using</span> Microsoft.Extensions.DependencyInjection;
<span>using</span> Microsoft.Extensions.Hosting;
<span>using</span> Microsoft.Extensions.Configuration;
<span>using</span> Microsoft.AspNetCore.Authentication.JwtBearer;

<span>namespace</span> <span>CreditRatingService</span>
{
  
}
</code></pre>

<p>Compared to the previous version, you added references to <code>Microsoft.Extensions.Configuration</code> and <code>Microsoft.AspNetCore.Authentication.JwtBearer</code>. The former provides functionalities to access the configuration file, and the latter enables you to use the JWT package that just installed.</p>

<p>To enable the gRPC server to read data from the configuration file, add the <code>Configuration</code> property and the <code>Startup()</code> constructor to the <code>Startup</code> class, as shown below:</p>

<pre><code>

<span>using</span> Microsoft.AspNetCore.Builder;
<span>using</span> Microsoft.AspNetCore.Hosting;
<span>using</span> Microsoft.AspNetCore.Http;
<span>using</span> Microsoft.Extensions.DependencyInjection;
<span>using</span> Microsoft.Extensions.Hosting;
<span>using</span> Microsoft.Extensions.Configuration;
<span>using</span> Microsoft.AspNetCore.Authentication.JwtBearer;

<span>namespace</span> <span>CreditRatingService</span>
{
  <span>public</span> <span>class</span> <span>Startup</span>
  {
    <span>public</span> IConfiguration Configuration { <span>get</span>; }

    <span><span>public</span> <span>Startup</span>(<span>IConfiguration configuration</span>)
    </span>{
        Configuration = configuration;
    }

    
  }
}
</code></pre>

<p>These changes allow your server to automatically load in the <code>Configuration</code> property the parameters you saved in the <code>appsettings.json</code> file.</p>

<p>Now, you have to configure authentication and authorization for the server. Still in the <code>Startup.cs</code> file, replace the <code>ConfigureServices()</code> method with the following code:</p>

<pre><code>



<span><span>public</span> <span>void</span> <span>ConfigureServices</span>(<span>IServiceCollection services</span>)
</span>{
  services.AddAuthentication(options =&gt;
  {
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
  }).AddJwtBearer(options =&gt;
  {
    options.Authority = <span>$"https://<span>{Configuration[<span>"Auth0:Domain"</span>]}</span>/"</span>;
    options.Audience = Configuration[<span>"Auth0:Audience"</span>];
  });
  services.AddAuthorization();
  services.AddGrpc();
}


</code></pre>

<p>With the code you added to the <code>ConfigureServices()</code> method, you are registering the authentication and authorization services to the dependency system. Regarding the authentication service, you are passing the configuration parameters that state you are using the JWT-based authentication and provide the Auth0 configuration data.</p>

<p>At this point, you need to add authentication and authorization middlewares to the application. Change the <code>Configure()</code> method so that it looks like the following:</p>

<pre><code>



<span><span>public</span> <span>void</span> <span>Configure</span>(<span>IApplicationBuilder app, IWebHostEnvironment env</span>)
</span>{
  <span>if</span> (env.IsDevelopment())
  {
    app.UseDeveloperExceptionPage();
  }

  app.UseRouting();

  app.UseAuthentication();  
  app.UseAuthorization();       

  app.UseEndpoints(endpoints =&gt;
  {
    endpoints.MapGrpcService&lt;CreditRatingCheckService&gt;();

    endpoints.MapGet(<span>"/"</span>, <span>async</span> context =&gt;
    {
      <span>await</span> context.Response.WriteAsync(<span>"Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909"</span>);
    });
  });
}


</code></pre>

<p>The two newly added statements must be located in that specific position, just after <code>app.UseRouting()</code> and before <code>app.UseEndpoints()</code>. Also, they must be added <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-3.1#middleware-order" target="_blank">in the order shown above</a>. A different position or order could cause unexpected behaviors.</p>

<h3>Protecting the server endpoint</h3>

<p>Now you are ready to protect the endpoint of your gRPC server. So, move into the <code>Services</code> folder and open the <code>CreditRatingService.cs</code> file. In the <code>using</code> section of this file, add a reference to the <code>Microsoft.AspNetCore.Authorization</code> namespace. The resulting <code>using</code> section should look like the following:</p>

<pre><code>

<span>using</span> System;
<span>using</span> System.Collections.Generic;
<span>using</span> System.Threading.Tasks;
<span>using</span> Grpc.Core;
<span>using</span> Microsoft.Extensions.Logging;
<span>using</span> Microsoft.AspNetCore.Authorization;

<span>namespace</span> <span>CreditRatingService</span> {
  
}
</code></pre>

<p>Finally, add the <code>Authorize</code> attribute to the <code>CheckCreditRequest()</code> method of the <code>CreditRatingCheckService</code> class, as shown below:</p>

<pre><code>



[Authorize]
<span><span>public</span> <span>override</span> Task&lt;CreditReply&gt; <span>CheckCreditRequest</span>(<span>CreditRequest request, ServerCallContext context</span>)
</span>{
  <span>return</span> Task.FromResult(<span>new</span> CreditReply
  {
    IsAccepted = IsEligibleForCredit(request.CustomerId, request.Credit)
  });
}


</code></pre>

<p>Your gRPC server is protected! You can test it by making the client interact with the server.</p>

<p>In the <code>CreditRatingService</code> folder, launch the <code>dotnet run</code> command from a terminal window to run the gRPC server. In another terminal window, move into the <code>CreditRatingClient</code> folder and launch the <code>dotnet run</code> command to run the gRPC client.</p>

<p>In the client's terminal window, you should get an error like the following:</p>

<pre><code>Unhandled exception. Grpc.Core.RpcException: Status(StatusCode=Unauthenticated, Detail=<span>"Bad gRPC response. HTTP status code: 401"</span>)
   at CreditRatingClient.Program.Main(<span>String</span>[] args) <span>in</span> /Projects/secure-grpc-dotnet/CreditRatingClient/Program.cs:line <span>25</span>
   at CreditRatingClient.Program.&lt;Main&gt;(<span>String</span>[] args)
</code></pre>

<p>This confirms that the server endpoint is protected, and the client is not authorized to make requests.</p>

<blockquote>
  <a href="https://twitter.com/intent/tweet?text=%22Integrating+authorization+in+your+gRPC-based+microservice+is+straightforward+with+Auth0.%22%20via%20@auth0%20http://auth0.com/blog/securing-grpc-microservices-dotnet-core/" target="_blank">
    <p>"Integrating authorization in your gRPC-based microservice is straightforward with Auth0."</p>
    <div>
            <div>
            
                <p><img src="https://cdn.auth0.com/blog/resources/twitter.svg"></p><h4>Tweet This</h4>
            </div>
        </div>
  </a>
</blockquote>


<h2 id="Securing-the-gRPC-Client">Securing the gRPC Client</h2>

<p>To enable the gRPC client application to make requests to the server, you need to register it with Auth0 and arrange its code so that it can be authenticated and authorized.</p>

<h3>Register the client with Auth0</h3>

<p>Similar to what you did with the server, you have to access the <a href="https://manage.auth0.com/" target="_blank">Auth0 Dashboard</a> and follow these steps to register your gRPC client:</p>

<ol>
<li><p>Move to the <a href="https://manage.auth0.com/#/applications" target="_blank">Applications</a> section and click on <em>Create Application</em></p></li>
<li><p>Provide a descriptive name for the application (for example, <em>Credit Rating Client</em>), select <em>Machine-To-Machine</em> as the application type, and click <em>Create</em></p></li>
<li><p>In the next screen, select the name of the API you registered for the gRPC server (for example, <em>Credit Rating Service</em>) as shown in the following picture:</p>

<p><img src="https://cdn.auth0.com/blog/secure-grpc-dotnet/registering-grpc-client-with-auth0.png" alt="Registering the gRPC client with Auth0" title="Registering the gRPC client with Auth0"></p></li>
<li><p>Finally, click <em>Authorize</em>.</p></li>
</ol>


<p>Your gRPC client is now registered with Auth0.</p>

<blockquote><p>While you are in the Auth0 Dashboard, move into the <em>Settings</em> tab and take note of the <em>Client ID</em> and <em>Client Secret</em> generated for your application. You will use them to authenticate your client.</p></blockquote>

<h3>Configure the client application</h3>

<p>Now you are ready to configure the client side to leverage the gRPC authentication and authorization. Move into the <code>CreditRatingClient</code> folder and add a new file named <code>appsettings.json</code> with the following content:</p>

<pre><code>{
  <span>"Auth0"</span>: {
    <span>"Domain"</span>: <span>"YOUR_AUTH0_DOMAIN"</span>,
    <span>"Audience"</span>: <span>"YOUR_UNIQUE_IDENTIFIER"</span>,
    <span>"ClientId"</span>: <span>"YOUR_CLIENT_ID"</span>,
    <span>"ClientSecret"</span>: <span>"YOUR_CLIENT_SECRET"</span>
  }
}
</code></pre>

<p>Replace the <code>YOUR_AUTH0_DOMAIN</code> placeholder with your Auth0 domain and the <code>YOUR_UNIQUE_IDENTIFIER</code> placeholder with the value you provided as a unique identifier of your API. These are the same values you used to configure the server. Also, replace the <code>YOUR_CLIENT_ID</code> and <code>YOUR_CLIENT_SECRET</code> placeholders with the <em>Client ID</em> and <em>Client Secret</em> values you got when registered the gRPC client.</p>

<blockquote><p>You are going to store the gRPC client credentials in the <code>appsettings.json</code> file. Be aware that you can do this just because the scenario of your system is a machine-to-machine scenario.</p>

<p>Remember: never store credentials in a publicly accessible client.</p></blockquote>

<p>To include the configuration file in the set of artifacts of the building process, open the <code>CreditRatingClient.csproj</code> file and add a new item group for the <code>appsettings.json</code> file, as shown in the following example:</p>

<figure><pre><code data-lang="html">
<span><span><span>&lt;</span>Project</span> <span>Sdk</span><span><span>=</span><span>"</span>Microsoft.NET.Sdk<span>"</span></span><span>&gt;</span></span>

  <span><span><span>&lt;</span>ItemGroup</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>None</span> <span>Update</span><span><span>=</span><span>"</span>appsettings.json<span>"</span></span><span>&gt;</span></span>
      <span><span><span>&lt;</span>CopyToOutputDirectory</span><span>&gt;</span></span>PreserveNewest<span><span><span>&lt;/</span>CopyToOutputDirectory</span><span>&gt;</span></span>
    <span><span><span>&lt;/</span>None</span><span>&gt;</span></span>
  <span><span><span>&lt;/</span>ItemGroup</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>Project</span><span>&gt;</span></span></code></pre></figure>

<p>At this point, you need to load these configuration parameters in the gRPC client. For this purpose, in the <code>CreditRatingClient</code> folder, run the following commands in a terminal window:</p>

<pre><code><span>dotnet</span> <span>add</span> <span>package</span> <span>Microsoft</span><span>.Extensions</span><span>.Configuration</span>
<span>dotnet</span> <span>add</span> <span>package</span> <span>Microsoft</span><span>.Extensions</span><span>.Configuration</span><span>.FileExtensions</span>
<span>dotnet</span> <span>add</span> <span>package</span> <span>Microsoft</span><span>.Extensions</span><span>.Configuration</span><span>.Json</span>
</code></pre>

<p>These commands add the configuration libraries to your project. Then, open the <code>Program.cs</code> file and add a reference to the <code>System.IO</code> and <code>Microsoft.Extensions.Configuration</code> namespaces, and the <code>GetAppSettings()</code> method, as shown in the following:</p>

<pre><code>

<span>using</span> System;
<span>using</span> System.Threading.Tasks;
<span>using</span> CreditRatingService;
<span>using</span> Grpc.Net.Client;
<span>using</span> System.Runtime.InteropServices;
<span>using</span> System.IO;
<span>using</span> Microsoft.Extensions.Configuration;

<span>namespace</span> <span>CreditRatingClient</span>
{
  <span>class</span> <span>Program</span>
  {
    <span><span>static</span> <span>async</span> Task <span>Main</span>(<span><span>string</span>[] args</span>)
    </span>{
      
    }

    <span><span>static</span> IConfiguration <span>GetAppSettings</span>(<span></span>)
    </span>{
      <span>var</span> builder = <span>new</span> ConfigurationBuilder()
       .SetBasePath(Directory.GetCurrentDirectory())
       .AddJsonFile(<span>"appsettings.json"</span>);

      <span>return</span> builder.Build();
    }
  }
}
</code></pre>

<h3>Getting an access token from Auth0</h3>

<p>The next step to enable your gRPC client to make requests to the server is to get an access token from the Auth0 authorization server. An <a href="https://auth0.com/docs/tokens/concepts/access-tokens" target="_blank">access token</a> is a string demonstrating that an application is enabled to access an API. So, having an access token and providing it to the gRPC server, your client can prove to be authorized to make requests.</p>

<p>You can request an access token from Auth0 by using the <a href="https://github.com/auth0/Auth0.net" target="_blank">Auth0 Authentication API SDK</a>. This package simplifies the interaction with the Auth0 authorization server by providing many helpful classes. To install it in the client project, make sure you're in the <code>CreditRatingClient</code> folder and run the following command in a terminal window:</p>

<pre><code><span>dotnet</span> <span>add</span> <span>package</span> <span>Auth0</span><span>.AuthenticationApi</span>
</code></pre>

<p>Then, add the <code>GetAccessToken()</code> method to the <code>Program</code> class as defined in the following:</p>

<pre><code>



<span>namespace</span> <span>CreditRatingClient</span>
{
  <span>class</span> <span>Program</span>
  {
    

    <span><span>static</span> <span>async</span> Task&lt;<span>string</span>&gt; <span>GetAccessToken</span>(<span></span>)
    </span>{
      <span>var</span> appAuth0Settings = GetAppSettings().GetSection(<span>"Auth0"</span>);
      <span>var</span> auth0Client = <span>new</span> AuthenticationApiClient(appAuth0Settings[<span>"Domain"</span>]);
      <span>var</span> tokenRequest = <span>new</span> ClientCredentialsTokenRequest()
      {
        ClientId = appAuth0Settings[<span>"ClientId"</span>],
        ClientSecret = appAuth0Settings[<span>"ClientSecret"</span>],
        Audience = appAuth0Settings[<span>"Audience"</span>]
      };
      <span>var</span> tokenResponse = <span>await</span> auth0Client.GetTokenAsync(tokenRequest);

      <span>return</span> tokenResponse.AccessToken;
    }
  }
}
</code></pre>

<p>The <code>GetAccessToken()</code> method gets the Auth0 configuration parameters from the <code>appsettings.json</code> file and uses them to instantiate a client for the Auth0 API (<code>auth0Client</code>) and a request for a token to be used with the Client Credentials flow (<code>tokenRequest</code>). Then, it sends the request to the authorization server and gets the access token from the response. This is the value returned by the method.</p>

<p>To make this method work, you need to integrate the <code>using</code> section with a few additions that end up to get the following result:</p>

<pre><code>

<span>using</span> System;
<span>using</span> System.Threading.Tasks;
<span>using</span> CreditRatingService;
<span>using</span> Grpc.Net.Client;
<span>using</span> System.Runtime.InteropServices;
<span>using</span> System.IO;
<span>using</span> Microsoft.Extensions.Configuration;
<span>using</span> Grpc.Core;
<span>using</span> Auth0.AuthenticationApi;
<span>using</span> Auth0.AuthenticationApi.Models;

<span>namespace</span> <span>CreditRatingClient</span>
{
    
}
</code></pre>

<h3>Calling the protected gRPC endpoint</h3>

<p>At this point, you have all you need to make your request to the gRPC server. You simply need to replace the <code>Main()</code> method with the following:</p>

<pre><code>



<span>namespace</span> <span>CreditRatingClient</span>
{
  <span>class</span> <span>Program</span>
  {
    

    <span><span>static</span> <span>async</span> Task <span>Main</span>(<span><span>string</span>[] args</span>)
    </span>{
      <span>var</span> serverAddress = <span>"https://localhost:5001"</span>;

      <span>if</span> (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
      {
        AppContext.SetSwitch(
            <span>"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span>, <span>true</span>);
        serverAddress = <span>"http://localhost:5000"</span>;
      }

      <span>var</span> channel = GrpcChannel.ForAddress(serverAddress);
      <span>var</span> client = <span>new</span> CreditRatingCheck.CreditRatingCheckClient(channel);
      <span>var</span> creditRequest = <span>new</span> CreditRequest { CustomerId = <span>"id0201"</span>, Credit = <span>7000</span> };

      <span>var</span> accessToken = <span>await</span> GetAccessToken();
      <span>var</span> headers = <span>new</span> Metadata();
      headers.Add(<span>"Authorization"</span>, <span>$"Bearer <span>{accessToken}</span>"</span>);

      <span>var</span> reply = <span>await</span> client.CheckCreditRequestAsync(creditRequest, headers);

      Console.WriteLine(<span>$"Credit for customer <span>{creditRequest.CustomerId}</span> <span>{(reply.IsAccepted ? <span>"approved"</span> : <span>"rejected"</span>)}</span>!"</span>);
      Console.WriteLine(<span>"Press any key to exit..."</span>);
      Console.ReadKey();
    }

    
  }
}
</code></pre>

<p>You create a gRPC channel for the address of the gRPC server (ensure that your server is listening to the same address you are putting here). Then, you create a client on that channel and prepare the request to send. You also get an access token from Auth0 and create the <code>Authorization</code> header containing the token. Finally, you send the request along with the header to the gRPC server, get the response, and show it on the console.</p>

<blockquote><p>You may notice that at the beginning of the method, there is a check on the current operating system. This check is needed to work around a <a href="https://docs.microsoft.com/en-us/aspnet/core/grpc/troubleshoot?view=aspnetcore-3.1#unable-to-start-aspnet-core-grpc-app-on-macos" target="_blank">known issue</a> with TLS support that affects macOS and older Windows versions. Keep in mind that this workaround should only be used in the development environment.</p></blockquote>

<p>To test the interaction between the gRPC client and the server, ensure that the server is up and running and then, in the <code>CreditRatingClient</code> folder, launch the <code>dotnet run</code> command in a terminal window.</p>

<p>This time, you should get the following message as a result:</p>

<pre><code>Credit <span>for</span> customer id0201 approved!
Press any key to <span>exit</span>...
</code></pre>

<p>In this simple example, the <code>GetAccessToken()</code> method requests an access token from Auth0. This leads to a network request each time your application needs the access token. Actually, once you receive an access token from Auth0, you can reuse it as long as it has not expired, and the audience remains the same.</p>

<p>This means that a production-ready application should implement a caching mechanism for the access token, avoiding unnecessary network roundtrips.</p>

<h3>Creating an authorized channel</h3>

<p>The solution you applied so far works fine. However, in a more complex application where you need to make multiple requests to a gRPC server, you have to attach the access token via the <code>Authorization</code> header to each request. This may be annoying and make the code too verbose.</p>

<p>Alternatively, you can centralize the access token addition by creating an authorized channel. Once created, the authorized channel automatically includes the access token as a header in each gRPC request.</p>

<blockquote><p>The authorized channel needs a secure connection (<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank">TLS</a>) as a mandatory requirement. Due to the <a href="https://docs.microsoft.com/en-us/aspnet/core/grpc/troubleshoot?view=aspnetcore-3.1#unable-to-start-aspnet-core-grpc-app-on-macos" target="_blank">issue</a> mentioned above, you cannot use this approach in macOS or older Windows machines.</p></blockquote>

<p>To use an authorized channel, add the <code>CreateAuthorizedChannel()</code> method to the <code>Program</code> class in the <code>Program.cs</code> file, as shown below:</p>

<pre><code>



<span>namespace</span> <span>CreditRatingClient</span>
{
  <span>class</span> <span>Program</span>
  {
    

    <span><span>private</span> <span>async</span> <span>static</span> Task&lt;GrpcChannel&gt; <span>CreateAuthorizedChannel</span>(<span><span>string</span> address</span>)
    </span>{
      <span>var</span> accessToken = <span>await</span> GetAccessToken();

      <span>var</span> credentials = CallCredentials.FromInterceptor((context, metadata) =&gt;
        {
          <span>if</span> (!<span>string</span>.IsNullOrEmpty(accessToken))
          {
            metadata.Add(<span>"Authorization"</span>, <span>$"Bearer <span>{accessToken}</span>"</span>);
          }
          <span>return</span> Task.CompletedTask;
        });

        <span>var</span> channel = GrpcChannel.ForAddress(address, <span>new</span> GrpcChannelOptions
          {
            Credentials = ChannelCredentials.Create(<span>new</span> SslCredentials(), credentials)
          });
        <span>return</span> channel;
      }
    }
}
</code></pre>

<p>This method takes the server address as a parameter, gets the access token from Auth0, and creates the call credentials from that token. Then, it creates a gRPC channel based on the server address and the created credentials. The resulting channel is returned to the caller.</p>

<p>Having the opportunity to create an authorized channel, the <code>Main()</code> method becomes as follows:</p>

<pre><code><span><span>static</span> <span>async</span> Task <span>Main</span>(<span><span>string</span>[] args</span>)
</span>{
  <span>var</span> channel = <span>await</span> CreateAuthorizedChannel(<span>"https://localhost:5001"</span>);
  <span>var</span> client = <span>new</span> CreditRatingCheck.CreditRatingCheckClient(channel);
  <span>var</span> creditRequest = <span>new</span> CreditRequest { CustomerId = <span>"id0201"</span>, Credit = <span>7000</span> };
  <span>var</span> reply = <span>await</span> client.CheckCreditRequestAsync(creditRequest);

  Console.WriteLine(<span>$"Credit for customer <span>{creditRequest.CustomerId}</span> <span>{(reply.IsAccepted ? <span>"approved"</span> : <span>"rejected"</span>)}</span>!"</span>);
  Console.WriteLine(<span>"Press any key to exit..."</span>);
  Console.ReadKey();
}
</code></pre>

<p>As you can see, the code is more compact than before. You simply create an authorized channel, build the client and the request, and send it to the server.</p>

<blockquote>
  <a href="https://twitter.com/intent/tweet?text=%22Using+an+authorized+gRPC+channel+in+.NET+Core+keeps+your+code+compact+and+clear.%22%20via%20@auth0%20http://auth0.com/blog/securing-grpc-microservices-dotnet-core/" target="_blank">
    <p>"Using an authorized gRPC channel in .NET Core keeps your code compact and clear."</p>
    <div>
            <div>
            
                <p><img src="https://cdn.auth0.com/blog/resources/twitter.svg"></p><h4>Tweet This</h4>
            </div>
        </div>
  </a>
</blockquote>


<h2 id="Summary">Summary</h2>

<p>In this tutorial, you learned that the <a href="https://auth0.com/docs/flows/concepts/client-credentials" target="_blank">Client Credentials Flow</a> is the best fit in a microservice scenario. With this knowledge, you leveraged  <a href="https://auth0.com/" target="_blank">Auth0</a> to implement this flow with .NET Core microservices that use gRPC to communicate. With a practical approach, you discovered how to protect the server endpoint and authorize the client to make requests to it.</p>

<p>You can find the full source code of developed throughout the tutorial <a href="https://github.com/auth0-blog/secure-grpc-dotnet" target="_blank">in this GitHub repository</a>.</p>


          

          



          




        </div>

      </main>
    </article></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>