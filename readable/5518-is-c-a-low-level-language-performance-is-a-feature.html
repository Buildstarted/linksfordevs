<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Is C# a low-level language? &#xB7; Performance is a Feature! -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Is C# a low-level language? ¬∑ Performance is a Feature!</h1><div><div class="post"><span class="post-date">01 Mar 2019 - 3535 words</span><p>I‚Äôm a massive fan of everything <a href="http://fabiensanglard.net/">Fabien Sanglard</a> does, I love his blog and I‚Äôve read <a href="http://fabiensanglard.net/gebbdoom/index.html">both</a> his <a href="http://fabiensanglard.net/gebbwolf3d/index.html">books</a> cover-to-cover (for more info on his books, check out the recent <a href="https://hanselminutes.com/666/episode-666-game-engine-black-book-doom-with-fabien-sanglard">Hansleminutes podcast</a>).</p><p>Recently he wrote an excellent post where he <a href="http://fabiensanglard.net/postcard_pathtracer/index.html">deciphered a postcard sized raytracer</a>, un-packing the obfuscated code and providing a fantastic explanation of the maths involved. I really recommend you take the time to read it!</p><p>But it got me thinking, <strong><em>would it be possible to port that C++ code to C#?</em></strong></p><p>Partly because in my <a href="https://raygun.com/platform/apm">day job</a> I‚Äôve been having to write a fair amount of C++ recently and I‚Äôve realised I‚Äôm a bit rusty, so I thought this might help!</p><p>But more significantly, I wanted to get a better insight into the question <strong>is C# a low-level language?</strong></p><p>A slightly different, but related question is <em>how suitable is C# for ‚Äòsystems programming‚Äô?</em> For more on that I really recommend Joe Duffy‚Äôs <a href="http://joeduffyblog.com/2013/12/27/csharp-for-systems-programming/">excellent post from 2013</a>.</p><hr><h2 id="line-by-line-port">Line-by-line port</h2><p>I started by simply porting the <a href="http://fabiensanglard.net/postcard_pathtracer/formatted_full.html">un-obfuscated C++ code</a> line-by-line <a href="https://gist.github.com/mattwarren/d17a0c356bd6fdb9f596bee6b9a5e63c">to C#</a>. Turns out that this was pretty straight forward, I guess the <a href="https://stackoverflow.com/a/1991356">story about C# being C++++</a> is true after all!!</p><p>Let‚Äôs look at an example, the main data structure in the code is a ‚Äòvector‚Äô, here‚Äôs the code side-by-side, C++ on the left and C# on the right:</p><p><a href="/images/2019/03/Diff%20-%20C++%20v.%20C%23%20-%20struct%20Vec.png"><img src="/images/2019/03/Diff%20-%20C++%20v.%20C%23%20-%20struct%20Vec.png" alt="Diff - C++ v. C# - struct Vec"></a></p><p>So there‚Äôs a few syntax differences, but because .NET lets you define <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value-types">your own ‚ÄòValue Types‚Äô</a> I was able to get the same functionality. This is significant because treating the ‚Äòvector‚Äô as a <code class="language-plaintext highlighter-rouge">struct</code> means we can get better ‚Äòdata locality‚Äô and the .NET Garbage Collector (GC) doesn‚Äôt need to be involved as the data will go onto the <em>stack</em> (probably, yes I know it‚Äôs an implementation detail).</p><p>For more info on <code class="language-plaintext highlighter-rouge">structs</code> or ‚Äòvalue types‚Äô in .NET see:</p><p>In particular that last post form Eric Lippert contains this helpful quote that makes it clear what ‚Äòvalue types‚Äô really are:</p><blockquote><p>Surely the most relevant fact about value types is <strong>not the implementation detail of <em>how they are allocated</em></strong>, but rather the <em>by-design semantic meaning</em> of ‚Äúvalue type‚Äù, <strong>namely that they are <em>always copied ‚Äúby value‚Äù</em></strong>. If the relevant thing was their allocation details then we‚Äôd have called them ‚Äúheap types‚Äù and ‚Äústack types‚Äù. But that‚Äôs not relevant most of the time. Most of the time the relevant thing is their copying and identity semantics.</p></blockquote><p>Now lets look at how some other methods look side-by-side (again C++ on the left, C# on the right), first up <code class="language-plaintext highlighter-rouge">RayTracing(..)</code>:</p><p><a href="/images/2019/03/Diff%20-%20C++%20v.%20C%23%20-%20RayMatching.png"><img src="/images/2019/03/Diff%20-%20C++%20v.%20C%23%20-%20RayMatching.png" alt="Diff - C++ v. C# - RayMatching"></a></p><p>Next <code class="language-plaintext highlighter-rouge">QueryDatabase(..)</code>:</p><p><a href="/images/2019/03/Diff%20-%20C++%20v.%20C%23%20-%20QueryDatabase%20(partial).png"><img src="/images/2019/03/Diff%20-%20C++%20v.%20C%23%20-%20QueryDatabase%20(partial).png" alt="Diff - C++ v. C# - QueryDatabase"></a></p><p>(see <a href="http://fabiensanglard.net/postcard_pathtracer/">Fabien‚Äôs post</a> for an explanation of what these 2 functions are doing)</p><p>But the point is that again, C# lets us very easily write C++ code! In this case what helps us out the most is the <code class="language-plaintext highlighter-rouge">ref</code> keyword which lets us pass a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref">value by reference</a>. We‚Äôve been able to use <code class="language-plaintext highlighter-rouge">ref</code> in method calls for quite a while, but recently there‚Äôs been a effort to allow <code class="language-plaintext highlighter-rouge">ref</code> in more places:</p><p>Now <em>sometimes</em> using <code class="language-plaintext highlighter-rouge">ref</code> can provide a performance boost because it means that the <code class="language-plaintext highlighter-rouge">struct</code> doesn‚Äôt need to be copied, see the benchmarks in <a href="https://adamsitnik.com/ref-returns-and-ref-locals/#passing-arguments-to-methods-by-reference">Adam Sitniks post</a> and <a href="https://blogs.msdn.microsoft.com/seteplia/2018/04/11/performance-traps-of-ref-locals-and-ref-returns-in-c/">Performance traps of ref locals and ref returns in C#</a> for more information.</p><p>However what‚Äôs most important for this scenario is that it allows us to have the same behaviour in our C# port as the original C++ code. Although I want to point out that ‚ÄòManaged References‚Äô as they‚Äôre known aren‚Äôt exactly the same as ‚Äòpointers‚Äô, most notably you can‚Äôt do arithmetic on them, for more on this see:</p><hr><h2 id="performance">Performance</h2><p>So, it‚Äôs all well and good being able to port the code, but ultimately the performance also matters. Especially in something like a ‚Äòray tracer‚Äô that can take minutes to run! The C++ code contains a variable called <code class="language-plaintext highlighter-rouge">sampleCount</code> that controls the final quality of the image, with <code class="language-plaintext highlighter-rouge">sampleCount = 2</code> it looks like this:</p><p><a href="/images/2019/03/output-C%23%20-%20sampleCount%20=%202.png"><img src="/images/2019/03/output-C%23%20-%20sampleCount%20=%202.png" alt="output C# - sampleCount = 2"></a></p><p>Which clearly isn‚Äôt that realistic!</p><p>However once you get to <code class="language-plaintext highlighter-rouge">sampleCount = 2048</code> things look a <em>lot</em> better:</p><p><a href="/images/2019/03/output-C%23%20-%20sampleCount%20=%202048.png"><img src="/images/2019/03/output-C%23%20-%20sampleCount%20=%202048.png" alt="output C# - sampleCount = 2048"></a></p><p>But, running with <code class="language-plaintext highlighter-rouge">sampleCount = 2048</code> means the rendering takes a <strong>long time</strong>, so all the following results were run with it set to <code class="language-plaintext highlighter-rouge">2</code>, which means the test runs completed in ~1 minute. Changing <code class="language-plaintext highlighter-rouge">sampleCount</code> only affects the number of iterations of the outermost loop of the code, see <a href="https://gist.github.com/mattwarren/1580572d9d641147c61caf65c383c3a4">this gist</a> for an explanation.</p><h3 id="results-after-a-naive-line-by-line-port">Results after a ‚Äònaive‚Äô line-by-line port</h3><p>To be able to give a meaningful side-by-side comparison of the C++ and C# versions I used the <a href="https://code.google.com/archive/p/time-windows/source/default/source">time-windows</a> tool that‚Äôs a port of the Unix <code class="language-plaintext highlighter-rouge">time</code> command. My initial results looked this this:</p><table><thead><tr><th>&nbsp;</th><th>C++ (VS 2017)</th><th>.NET Framework (4.7.2)</th><th>.NET Core (2.2)</th></tr></thead><tbody><tr><td>Elapsed time (secs)</td><td>47.40</td><td>80.14</td><td>78.02</td></tr><tr><td>Kernel time</td><td>0.14 (0.3%)</td><td>0.72 (0.9%)</td><td>0.63 (0.8%)</td></tr><tr><td>User time</td><td>43.86 (92.5%)</td><td>73.06 (91.2%)</td><td>70.66 (90.6%)</td></tr><tr><td>page fault #</td><td>1,143</td><td>4,818</td><td>5,945</td></tr><tr><td>Working set (KB)</td><td>4,232</td><td>13,624</td><td>17,052</td></tr><tr><td>Paged pool (KB)</td><td>95</td><td>172</td><td>154</td></tr><tr><td>Non-paged pool</td><td>7</td><td>14</td><td>16</td></tr><tr><td>Page file size (KB)</td><td>1,460</td><td>10,936</td><td>11,024</td></tr></tbody></table><p>So initially we see that the C# code is quite a bit slower than the C++ version, but it does get better (see below).</p><p>However lets first look at what the .NET JIT is doing for us even with this ‚Äònaive‚Äô line-by-line port. Firstly, it‚Äôs doing a nice job of in-lining the smaller ‚Äòhelper methods‚Äô, we can see this by looking at the output of the brilliant <a href="https://marketplace.visualstudio.com/items?itemName=StephanZehetner.InliningAnalyzer">Inlining Analyzer</a> tool (green overlay = inlined):</p><p><a href="/images/2019/03/Inlining Analyzer - QueryDatabase.png"><img src="/images/2019/03/Inlining Analyzer - QueryDatabase.png" alt="Inlining Analyzer - QueryDatabase"></a></p><p>However, it doesn‚Äôt inline all methods, for example <code class="language-plaintext highlighter-rouge">QueryDatabase(..)</code> is skipped because of it‚Äôs complexity:</p><p><a href="/images/2019/03/Inlining Analyzer - RayMarching - with ToolTip.png"><img src="/images/2019/03/Inlining Analyzer - RayMarching - with ToolTip.png" alt="Inlining Analyzer - RayMarching - with ToolTip"></a></p><p>Another feature that the .NET Just-In-Time (JIT) compiler provides is  converting specific methods calls into corresponding CPU instructions. We can see this in action with the <code class="language-plaintext highlighter-rouge">sqrt</code> wrapper function, here‚Äôs the original C# code (note the call to <code class="language-plaintext highlighter-rouge">Math.Sqrt</code>):</p><div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// intnv square root</span><span class="k">public</span><span class="k">static</span><span class="n">Vec</span><span class="k">operator</span><span class="p">!(</span><span class="n">Vec</span><span class="n">q</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="n">q</span><span class="p">*</span><span class="p">(</span><span class="m">1.0f</span><span class="p">/</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">%</span><span class="n">q</span><span class="p">));</span><span class="p">}</span></code></pre></div></div><p>And here‚Äôs the assembly code that the .NET JIT generates, there‚Äôs no call to <code class="language-plaintext highlighter-rouge">Math.Sqrt</code> and it makes use of the <code class="language-plaintext highlighter-rouge">vsqrtsd</code><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=vsqrtsd&amp;expand=5236">CPU instruction</a>:</p><pre><code class="language-assembly">; Assembly listing for method Program:sqrtf(float):float
; Emitting BLENDED_CODE for X64 CPU with AVX - Windows
; Tier-1 compilation
; optimized code
; rsp based frame
; partially interruptible
; Final local variable assignments
;
;  V00 arg0         [V00,T00] (  3,  3   )   float  -&gt;  mm0        
;# V01 OutArgs      [V01    ] (  1,  1   )  lclBlk ( 0) [rsp+0x00]   "OutgoingArgSpace"
;
; Lcl frame size = 0

G_M8216_IG01:
       vzeroupper 

G_M8216_IG02:
       vcvtss2sd xmm0, xmm0
       vsqrtsd  xmm0, xmm0
       vcvtsd2ss xmm0, xmm0

G_M8216_IG03:
       ret      

; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float
; ============================================================
</code></pre><p>(to get this output you need to following <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/building/viewing-jit-dumps.md#useful-complus-variables">these instructions</a>, use the <a href="https://github.com/EgorBo/Disasmo">‚ÄòDisasmo‚Äô VS2019 Add-in</a> or take a look at <a href="https://sharplab.io/#v2:EYLgHgbALANALiAhgZwLYB8ACAGABJgRgG4BYAKEwGZ8AmXAYVwG9zc39rMpcBZACgCUzVu1EA3RACdcYXAF5eiOAAsAdAGUAjpLh8C2AaTKjRhAJx8whkWwC+5W0A==">SharpLab.io</a>)</p><p>These replacements are also known as <a href="https://en.wikipedia.org/wiki/Intrinsic_function">‚Äòintrinsics‚Äô</a> and we can see the JIT generating them in the code below. This snippet just shows the mapping for <code class="language-plaintext highlighter-rouge">AMD64</code>, the JIT also targets <code class="language-plaintext highlighter-rouge">X86</code>, <code class="language-plaintext highlighter-rouge">ARM</code> and <code class="language-plaintext highlighter-rouge">ARM64</code>, the full method is <a href="https://github.com/dotnet/coreclr/blob/release/2.2/src/jit/importer.cpp#L19144-L19217">here</a></p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span><span class="n">Compiler</span><span class="o">::</span><span class="n">IsTargetIntrinsic</span><span class="p">(</span><span class="n">CorInfoIntrinsics</span><span class="n">intrinsicId</span><span class="p">)</span><span class="p">{</span><span class="cp">#if defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND))
</span><span class="k">switch</span><span class="p">(</span><span class="n">intrinsicId</span><span class="p">)</span><span class="p">{</span><span class="c1">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1</span><span class="c1">// instructions to directly compute round/ceiling/floor.</span><span class="c1">//</span><span class="c1">// TODO: Because the x86 backend only targets SSE for floating-point code,</span><span class="c1">//       it does not treat Sine, Cosine, or Round as intrinsics (JIT32</span><span class="c1">//       implemented those intrinsics as x87 instructions). If this poses</span><span class="c1">//       a CQ problem, it may be necessary to change the implementation of</span><span class="c1">//       the helper calls to decrease call overhead or switch back to the</span><span class="c1">//       x87 instructions. This is tracked by #7097.</span><span class="k">case</span><span class="n">CORINFO_INTRINSIC_Sqrt</span><span class="p">:</span><span class="k">case</span><span class="n">CORINFO_INTRINSIC_Abs</span><span class="p">:</span><span class="k">return</span><span class="nb">true</span><span class="p">;</span><span class="k">case</span><span class="n">CORINFO_INTRINSIC_Round</span><span class="p">:</span><span class="k">case</span><span class="n">CORINFO_INTRINSIC_Ceiling</span><span class="p">:</span><span class="k">case</span><span class="n">CORINFO_INTRINSIC_Floor</span><span class="p">:</span><span class="k">return</span><span class="n">compSupports</span><span class="p">(</span><span class="n">InstructionSet_SSE41</span><span class="p">);</span><span class="nl">default:</span><span class="k">return</span><span class="nb">false</span><span class="p">;</span><span class="p">}</span><span class="p">...</span><span class="p">}</span></code></pre></div></div><p>As you can see, some methods are implemented like this, e.g. <code class="language-plaintext highlighter-rouge">Sqrt</code> and <code class="language-plaintext highlighter-rouge">Abs</code>, but for others the CLR instead uses the C++ runtime functions <a href="https://en.cppreference.com/w/c/numeric/math/pow">for instance <code class="language-plaintext highlighter-rouge">powf</code></a>.</p><p>This entire process is explained very nicely in <a href="https://stackoverflow.com/a/8870593">How is Math.Pow() implemented in .NET Framework?</a>, but we can also see it in action in the CoreCLR source:</p><h3 id="results-after-simple-performance-improvements">Results after simple performance improvements</h3><p>However, I wanted to see if my ‚Äònaive‚Äô line-by-line port could be improved, after some profiling I made two main changes:</p><ul><li>Remove in-line array initialisation</li><li>Switch from <code class="language-plaintext highlighter-rouge">Math.XXX(..)</code> functions to the <code class="language-plaintext highlighter-rouge">MathF.XXX()</code> counterparts.</li></ul><p>These changes are explained in more depth below</p><h4 id="remove-in-line-array-initialisation">Remove in-line array initialisation</h4><p>For more information about why this is necessary see this excellent <a href="https://stackoverflow.com/a/39106675">Stack Overflow answer</a> from <a href="https://twitter.com/andrey_akinshin?lang=en">Andrey Akinshin</a> complete with benchmarks and assembly code! It comes to the following conclusion:</p><blockquote><p><strong>Conclusion</strong></p><ul><li><strong><em>Does .NET caches hardcoded local arrays?</em></strong> Kind of: the Roslyn compiler put it in the metadata.</li><li><strong><em>Do we have any overhead in this case?</em></strong> Unfortunately, yes: JIT will copy the array content from the metadata for each invocation; it will work longer than the case with a static array. Runtime also allocates objects and produce memory traffic.</li><li><strong><em>Should we care about it?</em></strong> It depends. If it‚Äôs a hot method and you want to achieve a good level of performance, you should use a static array. If it‚Äôs a cold method which doesn‚Äôt affect the application performance, you probably should write ‚Äúgood‚Äù source code and put the array in the method scope.</li></ul></blockquote><p>You can see the change I made <a href="https://gist.github.com/mattwarren/d17a0c356bd6fdb9f596bee6b9a5e63c/revisions#diff-ab5447b35812d457232030d7d2577458R114">in this diff</a>.</p><h4 id="using-mathf-functions-instead-of-math">Using MathF functions instead of Math</h4><p>Secondly and most significantly I got a big perf improvement by making the following changes:</p><div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#if NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0
</span><span class="c1">// intnv square root</span><span class="k">public</span><span class="k">static</span><span class="n">Vec</span><span class="k">operator</span><span class="p">!(</span><span class="n">Vec</span><span class="n">q</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="n">q</span><span class="p">*</span><span class="p">(</span><span class="m">1.0f</span><span class="p">/</span><span class="n">MathF</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">%</span><span class="n">q</span><span class="p">));</span><span class="p">}</span><span class="cp">#else
</span><span class="k">public</span><span class="k">static</span><span class="n">Vec</span><span class="k">operator</span><span class="p">!(</span><span class="n">Vec</span><span class="n">q</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="n">q</span><span class="p">*</span><span class="p">(</span><span class="m">1.0f</span><span class="p">/</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="n">q</span><span class="p">%</span><span class="n">q</span><span class="p">));</span><span class="p">}</span><span class="cp">#endif
</span></code></pre></div></div><p>As of ‚Äò.NET Standard 2.1‚Äô there are now specific <code class="language-plaintext highlighter-rouge">float</code> implementations of the common maths functions, located in the <a href="https://apisof.net/catalog/System.MathF">System.MathF class</a>. For more information on this API and it‚Äôs implementation see:</p><p>After these changes, the C# code is ~10% slower than the C++ version:</p><table><thead><tr><th>&nbsp;</th><th>C++ (VS C++ 2017)</th><th>.NET Framework (4.7.2)</th><th>.NET Core (2.2) TC OFF</th><th>.NET Core (2.2) TC ON</th></tr></thead><tbody><tr><td>Elapsed time (secs)</td><td>41.38</td><td>58.89</td><td>46.04</td><td>44.33</td></tr><tr><td>Kernel time</td><td>0.05 (0.1%)</td><td>0.06 (0.1%)</td><td>0.14 (0.3%)</td><td>0.13 (0.3%)</td></tr><tr><td>User time</td><td>41.19 (99.5%)</td><td>58.34 (99.1%)</td><td>44.72 (97.1%)</td><td>44.03 (99.3%)</td></tr><tr><td>page fault #</td><td>1,119</td><td>4,749</td><td>5,776</td><td>5,661</td></tr><tr><td>Working set (KB)</td><td>4,136</td><td>13,440</td><td>16,788</td><td>16,652</td></tr><tr><td>Paged pool (KB)</td><td>89</td><td>172</td><td>150</td><td>150</td></tr><tr><td>Non-paged pool</td><td>7</td><td>13</td><td>16</td><td>16</td></tr><tr><td>Page file size (KB)</td><td>1,428</td><td>10,904</td><td>10,960</td><td>11,044</td></tr></tbody></table><p>TC = <a href="https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/">Tiered Compilation</a> (I <em>believe</em> that it‚Äôll be on by default in .NET Core 3.0)</p><p>For completeness, here‚Äôs the results across several runs:</p><table><thead><tr><th>Run</th><th>C++ (VS C++ 2017)</th><th>.NET Framework (4.7.2)</th><th>.NET Core (2.2) TC OFF</th><th>.NET Core (2.2) TC ON</th></tr></thead><tbody><tr><td>TestRun-01</td><td>41.38</td><td>58.89</td><td>46.04</td><td>44.33</td></tr><tr><td>TestRun-02</td><td>41.19</td><td>57.65</td><td>46.23</td><td>45.96</td></tr><tr><td>TestRun-03</td><td>42.17</td><td>62.64</td><td>46.22</td><td>48.73</td></tr></tbody></table><p><strong>Note:</strong> the difference between .NET Core and .NET Framework is due to the lack of the <code class="language-plaintext highlighter-rouge">MathF</code> API in .NET Framework v4.7.2, for more info see <a href="https://github.com/dotnet/standard/issues/859">Support .Net Framework (4.8?) for netstandard 2.1</a>.</p><hr><h2 id="further-performance-improvements">Further performance improvements</h2><p>However I‚Äôm sure that others can do better!</p><p>If you‚Äôre interested in trying to close the gap the <a href="https://gist.github.com/mattwarren/d17a0c356bd6fdb9f596bee6b9a5e63c">C# code is available</a>. For comparison, you can see the assembly produced by the C++ compiler courtesy of the brilliant <a href="https://godbolt.org/z/l2QZLY">Compiler Explorer</a>.</p><p>Finally, if it helps, here‚Äôs the output from the Visual Studio Profiler showing the ‚Äòhot path‚Äô (after the perf improvement described above):</p><p><a href="/images/2019/03/Call%20Tree%20(tidied%20up)%20-%20Report20190221-2029-After-MathF-Changes-NetCore.png"><img src="/images/2019/03/Call%20Tree%20(tidied%20up)%20-%20Report20190221-2029-After-MathF-Changes-NetCore.png" alt="Call Tree (tidied up) - Report20190221-2029-After-MathF-Changes-NetCore.png"></a></p><hr><h2 id="is-c-a-low-level-language">Is C# a low-level language?</h2><p>Or more specifically:</p><blockquote><p><strong>What language features of C#/F#/VB.NET or BCL/Runtime functionality enable ‚Äòlow-level‚Äô* programming?</strong></p></blockquote><p>* yes, I know ‚Äòlow-level‚Äô is a subjective term üòä</p><p><strong>Note</strong>: Any C# developer is going to have a different idea of what ‚Äòlow-level‚Äô means, these features would be taken for granted by C++ or Rust programmers.</p><p>Here‚Äôs the list that I came up with:</p><ul><li><a href="https://adamsitnik.com/ref-returns-and-ref-locals/">ref returns and ref locals</a><ul><li>‚Äútl;dr Pass and return by reference to avoid large struct copying. It‚Äôs type and memory safe. It can be even <strong>faster</strong> than <code class="language-plaintext highlighter-rouge">unsafe!</code>‚Äù</li></ul></li><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code">Unsafe code in .NET</a><ul><li>‚ÄúThe core C# language, as defined in the preceding chapters, differs notably from C and C++ in its omission of pointers as a data type. Instead, C# provides references and the ability to create objects that are managed by a garbage collector. This design, coupled with other features, makes C# a much safer language than C or C++.‚Äù</li></ul></li><li><a href="http://tooslowexception.com/managed-pointers-in-net/">Managed pointers in .NET</a><ul><li>‚ÄúThere is, however, another pointer type in CLR ‚Äì a managed pointer. It could be defined as a more general type of reference, which may point to other locations than just the beginning of an object.‚Äù</li></ul></li><li><a href="https://blogs.msdn.microsoft.com/mazhou/2018/03/25/c-7-series-part-10-spant-and-universal-memory-management/">C# 7 Series, Part 10: Span&lt;T&gt; and universal memory management</a><ul><li>‚Äú<code class="language-plaintext highlighter-rouge">System.Span&lt;T&gt;</code> is a stack-only type (<code class="language-plaintext highlighter-rouge">ref struct</code>) that wraps all memory access patterns, it is the type for universal contiguous memory access. You can think the implementation of the Span<t> contains a dummy reference and a length, accepting all 3 memory access types."</t></li></ul></li><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interop/">Interoperability (C# Programming Guide)</a><ul><li>‚ÄúThe .NET Framework enables interoperability with unmanaged code through platform invoke services, the <code class="language-plaintext highlighter-rouge">System.Runtime.InteropServices</code> namespace, C++ interoperability, and COM interoperability (COM interop).‚Äù</li></ul></li></ul><p>However, I know my limitations and so I <a href="https://twitter.com/matthewwarren/status/1097875987398828032">asked on twitter</a> and got <em>a lot</em> more replies to add to the list:</p><ul><li><a href="https://twitter.com/ben_a_adams/status/1097876408775442432">Ben Adams</a> ‚ÄúPlatform intrinsics (CPU instruction access)‚Äù</li><li><a href="https://twitter.com/marcgravell/status/1097877192745336837">Marc Gravell</a> ‚ÄúSIMD via Vector<t> (which mixes well with Span<t>) is *fairly* low; .NET Core should (soon?) offer direct CPU intrinsics for more explicit usage targeting particular CPU ops"</t></t></li><li><a href="https://twitter.com/marcgravell/status/1097878317875761153">Marc Gravell</a> ‚Äúpowerful JIT: things like range elision on arrays/spans, and the JIT using per-struct-T rules to remove huge chunks of code that it knows can‚Äôt be reached for that T, or on your particular CPU (BitConverter.IsLittleEndian, Vector.IsHardwareAccelerated, etc)‚Äù</li><li><a href="https://twitter.com/vcsjones/status/1097877294864056320">Kevin Jones</a> ‚ÄúI would give a special shout-out to the <code class="language-plaintext highlighter-rouge">MemoryMarshal</code> and <code class="language-plaintext highlighter-rouge">Unsafe</code> classes, and probably a few other things in the <code class="language-plaintext highlighter-rouge">System.Runtime.CompilerServices</code> namespace.‚Äù</li><li><a href="https://twitter.com/Pessimizations/status/1097877381296066560">Theodoros Chatzigiannakis</a> ‚ÄúYou could also include <code class="language-plaintext highlighter-rouge">__makeref</code> and the rest.‚Äù</li><li><a href="https://twitter.com/damageboy/status/1097877247120326658">damageboy</a> ‚ÄúBeing able to dynamically generate code that fits the expected input exactly, given that the latter will only be known at runtime, and might change periodically?‚Äù</li><li><a href="https://twitter.com/RobertHaken/status/1097880613988851712">Robert Haken</a> ‚Äúdynamic IL emission‚Äù</li><li><a href="https://twitter.com/buybackoff/status/1097885830364966914">Victor Baybekov</a> ‚ÄúStackalloc was not mentioned. Also ability to write raw IL (not dynamic, so save on a delegate call), e.g. to use cached <code class="language-plaintext highlighter-rouge">ldftn</code> and call them via <code class="language-plaintext highlighter-rouge">calli</code>. VS2017 has a proj template that makes this trivial via extern methods + MethodImplOptions.ForwardRef + ilasm.exe rewrite.‚Äù</li><li><a href="https://twitter.com/buybackoff/status/1097887318806093824">Victor Baybekov</a> ‚ÄúAlso MethodImplOptions.AggressiveInlining ‚Äúdoes enable ‚Äòlow-level‚Äô programming‚Äù in a sense that it allows to write high-level code with many small methods and still control JIT behavior to get optimized result. Otherwise uncomposable 100s LOCs methods with copy-paste‚Ä¶‚Äù</li><li><a href="https://twitter.com/ben_a_adams/status/1097885533508980738">Ben Adams</a> ‚ÄúUsing the same calling conventions (ABI) as the underlying platform and p/invokes for interop might be more of a thing though?‚Äù</li><li><a href="https://twitter.com/buybackoff/status/1097893756672581632">Victor Baybekov</a> ‚ÄúAlso since you mentioned #fsharp - it does have <code class="language-plaintext highlighter-rouge">inline</code> keyword that does the job at IL level before JIT, so it was deemed important at the language level. C# lacks this (so far) for lambdas which are always virtual calls and workarounds are often weird (constrained generics).‚Äù</li><li><a href="https://twitter.com/xoofx/status/1097895771142320128">Alexandre Mutel</a> ‚Äúnew SIMD intrinsics, Unsafe Utility class/IL post processing (e.g custom, Fody‚Ä¶etc.). For C#8.0, upcoming function pointers‚Ä¶‚Äù</li><li><a href="https://twitter.com/xoofx/status/1097896059236466689">Alexandre Mutel</a> ‚Äúrelated to IL, F# has support for direct IL within the language for example‚Äù</li><li><a href="https://twitter.com/0omari0/status/1097916897952235520">OmariO</a> ‚ÄúBinaryPrimitives. Low-level but safe.‚Äù (https://docs.microsoft.com/en-us/dotnet/api/system.buffers.binary.binaryprimitives?view=netcore-3.0)</li><li><a href="https://twitter.com/kozy_kekyo/status/1097982126190878720">Kouji (Kozy) Matsui</a> ‚ÄúHow about native inline assembler? It‚Äôs difficult for how relation both toolchains and runtime, but can replace current P/Invoke solution and do inlining if we have it.‚Äù</li><li><a href="https://twitter.com/praeclarum/status/1098002275891642368">Frank A. Krueger</a> ‚ÄúLdobj, stobj, initobj, initblk, cpyblk.‚Äù</li><li><a href="https://twitter.com/konradkokosa/status/1098155819340828672">Konrad Kokosa</a> ‚ÄúMaybe Thread Local Storage? Fixed Size Buffers? unmanaged constraint and blittable types should be probably mentioned:)‚Äù</li><li><a href="https://twitter.com/sebify/status/1098161110476312582">Sebastiano Mandal√†</a> ‚ÄúJust my two cents as everything has been said: what about something as simple as struct layout and how padding and memory alignment and order of the fields may affect the cache line performance? It‚Äôs something I have to investigate myself too‚Äù</li><li><a href="https://twitter.com/NinoFloris/status/1098433286899146753">Nino Floris</a> ‚ÄúConstants embedding via readonlyspan, stackalloc, finalizers, WeakReference, open delegates, MethodImplOptions, MemoryBarriers, TypedReference, varargs, SIMD, Unsafe.AsRef can coerce struct types if layout matches exactly (used for a.o. TaskAwaiter and its <t> version)"</t></li></ul><hr><p><strong>So in summary, I would say that C# certainly lets you write code that looks a lot like C++ and in conjunction with the Runtime and Base-Class Libraries it gives you a lot of low-level functionality</strong></p><hr><p>Discuss this post on <a href="https://news.ycombinator.com/item?id=19280049">Hacker News</a>, <a href="https://old.reddit.com/r/programming/comments/aw4ig7/is_c_a_lowlevel_language/?sort=top">/r/programming</a>, <a href="https://old.reddit.com/r/dotnet/comments/aw4ilf/is_c_a_lowlevel_language/?sort=top">/r/dotnet</a> or <a href="https://old.reddit.com/r/csharp/comments/aw4ij6/is_c_a_lowlevel_language/?sort=top">/r/csharp</a></p><hr><h2 id="further-reading">Further Reading</h2><p>The Unity ‚ÄòBurst‚Äô Compiler:</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>