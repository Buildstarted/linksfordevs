<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How to build a plugin system on the web and also sleep well at night - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="How to build a plugin system on the web and also sleep well at night - linksfor.dev(s)"/>
    <meta property="article:author" content="Rudi Chen"/>
    <meta property="og:description" content="The solution we found helps us run Figma plugins in a safe way &#x2014; i.e. not eval(UNTRUSTED_CODE)."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.figma.com/blog/how-we-built-the-figma-plugin-system/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - How to build a plugin system on the web and also sleep well at night</title>
<div class="readable">
        <h1>How to build a plugin system on the web and also sleep well at night</h1>
            <div>by Rudi Chen</div>
            <div>Reading time: 28-36 minutes</div>
        <div>Posted here: 24 Aug 2019</div>
        <p><a href="https://www.figma.com/blog/how-we-built-the-figma-plugin-system/">https://www.figma.com/blog/how-we-built-the-figma-plugin-system/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><p><em>Editor's Note: Since we published this blog post, we decided to change our sandbox implementation to an alternative approach: compiling a JavaScript VM written in C to WebAssembly. As you'll see in the blog post below, it was one of several ideas we originally weighed.</em></p><p><em>We decided to implement this alternative after a security vulnerability in the Realms shim (which our original approach uses) was privately disclosed to us. The security vulnerability was promptly fixed by the Realms shim team before the vulnerability was made public and we have no evidence it was ever exploited. Read more about the vulnerability and our approach to fixing it <a href="https://www.figma.com/blog/an-update-on-plugin-security/">here</a>.</em></p><p>At Figma, we recently tackled one of our biggest engineering challenges yet: supporting plugins. Our plugins API enables third-party developers to run code directly inside our browser-based design tool, so teams can adapt Figma to their own workflows. They can enable <a href="https://www.figma.com/c/plugin/732603254453395948/Stark/">accessibility checkers</a> to measure contrast, <a href="https://www.figma.com/c/plugin/733062974250826253/Translate/">translation apps</a> to convert language, <a href="https://www.figma.com/c/plugin/738454987945972471/Unsplash/">importers</a> to populate designs with content, and anything else their heart desires.</p><p>We knew we needed to design this plugin functionality carefully. Throughout the history of software, there have been many instances where third-party extensions negatively affected a platform. In some cases, they slowed the tool to a crawl. In other cases, the plugins broke whenever new versions of the platform were released. To the extent that we could control it, we wanted users to have a better plugin experience with Figma.</p><p>Furthermore, we wanted to make sure plugins would be safe for users to run, so we knew we wouldn‚Äôt want to simply <code>eval(PLUGIN_CODE)</code>. That is the quintessential definition of insecure! Yet, eval is essentially what running a plugin boils down to.</p><p>To add to the challenge, Figma is built on a very unconventional stack with constraints that previous tools haven‚Äôt had. Our design editor is powered by <a href="https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/">WebGL</a> and <a href="https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/">WebAssembly</a>, with some of the user interface implemented in Typescript &amp; React. Multiple people can be <a href="https://www.figma.com/blog/multiplayer-editing-in-figma/">editing a file at the same time</a>. We are powered by browser technologies, but also limited by them.</p><p>This blog post will walk you through our pursuit for the perfect plugin solution. Ultimately, our efforts boiled down to one question: How do you run plugins with security, stability, and performance? Here‚Äôs a brief overview of our many non-trivial constraints:</p><figure><img srcset="//images.ctfassets.net/1khq4uysbvty/71O2PpWhzaRrK1Qt1EpHYp/053d213acd6e287cc915869e6b1d13cb/Plugins_Eng_IAA__2_.png?w=368 368w, //images.ctfassets.net/1khq4uysbvty/71O2PpWhzaRrK1Qt1EpHYp/053d213acd6e287cc915869e6b1d13cb/Plugins_Eng_IAA__2_.png?w=491 491w, //images.ctfassets.net/1khq4uysbvty/71O2PpWhzaRrK1Qt1EpHYp/053d213acd6e287cc915869e6b1d13cb/Plugins_Eng_IAA__2_.png?w=736 736w, //images.ctfassets.net/1khq4uysbvty/71O2PpWhzaRrK1Qt1EpHYp/053d213acd6e287cc915869e6b1d13cb/Plugins_Eng_IAA__2_.png?w=1104 1104w, //images.ctfassets.net/1khq4uysbvty/71O2PpWhzaRrK1Qt1EpHYp/053d213acd6e287cc915869e6b1d13cb/Plugins_Eng_IAA__2_.png?w=1472 1472w" src="https://images.ctfassets.net/1khq4uysbvty/71O2PpWhzaRrK1Qt1EpHYp/053d213acd6e287cc915869e6b1d13cb/Plugins_Eng_IAA__2_.png?w=736" alt="Security: Plugins only have access to the file when explicitly launched. Plugins are restricted to the current file. Plugins can‚Äôt make calls as figma.com. Plugins can‚Äôt access each other‚Äôs data unless given willingly. Plugins can‚Äôt tamper with the Figma UI and behavior to mislead the user (e.g. phishing).
Stability: Plugins should not be able to slow down Figma as to make it unusable. Plugins should not be able to break key invariants in our product, such as the property that everyone always sees the same thing when viewing the same file. It should not be necessary to manage plugin installation across devices/users in order to view a file. Changes to the Figma product or internal APIs should rarely, if ever, break existing plugins.
Ease of development: Plugins should be easy enough to develop to support a vibrant ecosystem. Most of our users are designers, and may only have moderate experience with JavaScript. Developers should be able to use existing debugging tools.
Performance: Plugins should run fast enough to support most common use cases, such as searching the document for a layer, generating charts, etc." sizes="(max-width: 736px) 100vw, 736px"></figure><p>We considered dozens of different approaches branching into all sorts of different paths. We had weeks of discussing, prototyping and brainstorming. This blog post will focus on just three of those attempts that formed the most central path in our exploration.</p><p>For me, it has been the most satisfying exercise in first principles thinking. I had fun leveraging all the computer science fundamentals I learned in the classroom (the ones I never thought I‚Äôd ever use in the real world). If that idea excites you too, <a href="https://www.figma.com/careers/">we‚Äôre hiring</a>!</p><h2 id="attempt-1-the-sandbox-approach"><a href="#attempt-1-the-sandbox-approach">Attempt #1: The  sandbox approach</a></h2><p>During our first few weeks of research, we found many interesting attempts at third-party code sandboxing. Some used techniques such as code-to-code transformation. However, most had not been validated in a production application and as such, carried some risk.</p><p>In the end, for our first attempt, we went for the closest thing to a standard sandboxing solution: the <code>&lt;iframe&gt;</code> tag. It‚Äôs used in applications that need to run third-party code, such as CodePen.</p><p>The <code>&lt;iframe&gt;</code> is not your everyday HTML tag.&nbsp;To understand why <code>&lt;iframe&gt;</code>s are secure, it‚Äôs necessary to think about what properties they need to guarantee. An <code>&lt;iframe&gt;</code> is typically used to embed one website into another website. For example, in the screenshot below, you can see that yelp.com is embedding google.com/maps to provide map functionality.</p><figure><img srcset="//images.ctfassets.net/1khq4uysbvty/4GKGOOVAHUZrAYZFWU7oIo/1f8bcb18924a9f555d310b9ff85e19c4/Yelp_iFrame_Plugins_Eng.gif?w=368 368w, //images.ctfassets.net/1khq4uysbvty/4GKGOOVAHUZrAYZFWU7oIo/1f8bcb18924a9f555d310b9ff85e19c4/Yelp_iFrame_Plugins_Eng.gif?w=491 491w, //images.ctfassets.net/1khq4uysbvty/4GKGOOVAHUZrAYZFWU7oIo/1f8bcb18924a9f555d310b9ff85e19c4/Yelp_iFrame_Plugins_Eng.gif?w=736 736w" src="https://images.ctfassets.net/1khq4uysbvty/4GKGOOVAHUZrAYZFWU7oIo/1f8bcb18924a9f555d310b9ff85e19c4/Yelp_iFrame_Plugins_Eng.gif?w=736" alt="Yelp iFrame Plugins Eng" sizes="(max-width: 736px) 100vw, 736px"></figure><p>Here, you wouldn‚Äôt want Yelp to be able to read what‚Äôs inside a Google website just by virtue of embedding it. There could be private user information in there. Similarly, you wouldn‚Äôt want Google to be able to read what‚Äôs inside a Yelp website just by virtue of having been embedded.</p><p>This means communication to and from the <code>&lt;iframe&gt;</code> is heavily restricted by browsers. When an <code>&lt;iframe&gt;</code> has a different origin than its container (e.g. yelp.com v.s. google.com), they are completely isolated. Then, the only way to communicate with the <code>&lt;iframe&gt;</code> is via message-passing. These messages are, for all intents and purposes, plain strings. Upon receipt, each website is free to take action on those message, or ignore them.</p><p>They‚Äôre so isolated, in fact, that the HTML spec allow browsers to implement <code>&lt;iframe&gt;</code>s as separate processes, <a href="https://www.chromium.org/developers/design-documents/oop-iframes">if they chose to</a>.</p><p>Now that we know how <code>&lt;iframe&gt;</code>s work, we can implement plugins by creating a new <code>&lt;iframe&gt;</code> every time a plugin runs, and sticking the plugin‚Äôs code inside the <code>&lt;iframe&gt;</code>. The plugin can do anything it wants inside the <code>&lt;iframe&gt;</code>. However, it won‚Äôt be able to interact with Figma documents except through explicit, whitelisted messages. The <code>&lt;iframe&gt;</code> is also a given a null origin, which means that any attempt to make a request to figma.com will be denied by the browser‚Äôs <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">cross-origin resource sharing policies</a>. </p><figure><img srcset="//images.ctfassets.net/1khq4uysbvty/6vQ4ZfKFaq9jAdgjwJv0Kg/a5418f2db1d8f0805bf4ec74fa42d74e/Plugins_Eng_run.png?w=368 368w, //images.ctfassets.net/1khq4uysbvty/6vQ4ZfKFaq9jAdgjwJv0Kg/a5418f2db1d8f0805bf4ec74fa42d74e/Plugins_Eng_run.png?w=491 491w, //images.ctfassets.net/1khq4uysbvty/6vQ4ZfKFaq9jAdgjwJv0Kg/a5418f2db1d8f0805bf4ec74fa42d74e/Plugins_Eng_run.png?w=736 736w, //images.ctfassets.net/1khq4uysbvty/6vQ4ZfKFaq9jAdgjwJv0Kg/a5418f2db1d8f0805bf4ec74fa42d74e/Plugins_Eng_run.png?w=1104 1104w, //images.ctfassets.net/1khq4uysbvty/6vQ4ZfKFaq9jAdgjwJv0Kg/a5418f2db1d8f0805bf4ec74fa42d74e/Plugins_Eng_run.png?w=1472 1472w" src="https://images.ctfassets.net/1khq4uysbvty/6vQ4ZfKFaq9jAdgjwJv0Kg/a5418f2db1d8f0805bf4ec74fa42d74e/Plugins_Eng_run.png?w=736" alt="Plugins Eng run" sizes="(max-width: 736px) 100vw, 736px"></figure><p>Effectively, the <code>&lt;iframe&gt;</code> acts as a sandbox for the plugin. Furthermore, the security properties of the sandbox are guaranteed by browser vendors, who have spent years searching for and fixing any vulnerability in the sandbox.</p><p>An actual plugin using this sandbox model would use an API that we add into the sandbox and look roughly like this:</p></div></div><div><pre><code><span>const</span> scene <span>=</span> <span>await</span> figma<span>.</span><span>loadScene</span><span>(</span><span>)</span> <span>// gets data from the main thread</span>
scene<span>.</span><span>selection</span><span>[</span><span>0</span><span>]</span><span>.</span><span>width</span> <span>*=</span> <span>2</span>
scene<span>.</span><span>createNode</span><span>(</span><span>{</span>
  <span>type</span><span>:</span> <span>'RECTANGLE'</span><span>,</span>
  x<span>:</span> <span>10</span><span>,</span> y<span>:</span> <span>20</span><span>,</span>
  <span>...</span>
<span>}</span><span>)</span>
<span>await</span> figma<span>.</span><span>updateScene</span><span>(</span><span>)</span> <span>// flush changes back, to the main thread</span></code></pre></div><div><div><p>The key thing is that plugins initialize by calling loadScene (which sends a message to Figma to get a copy of the document) and finish by calling updateScene (which sends the changes made by the plugin back to Figma). Note that:  </p><ul><li>We get a copy of the document instead of using message passing for every read and write to a property. Message-passing has overhead on the order of 0.1ms per round-trip, which would only allow for ~1000 messages per second.</li><li>We don‚Äôt make plugins use postMessage directly, since it would be cumbersome to work with.</li></ul><p>We went with this approach and built it for about a month. We even invited some alpha testers. However, it soon became clear that there were two major flaws with this approach.</p><h3 id="problem-1-asyncawait-is-not-user-friendly">Problem #1: async/await is not user friendly</h3><p>The first feedback we got is that people were having trouble with having to use async/await. In this approach, it is unavoidable. Message-passing is fundamentally an asynchronous operation, and there‚Äôs no way in JavaScript to make a synchronous, blocking call to an asynchronous operation. At the very least, you need the <code>await</code> keyword which also requires marking all calling functions <code>async</code>. All things considered, async/await is still a fairly new JavaScript feature that requires some non-trivial understanding of concurrency. This is a problem, because we expect many of our plugin developers to be designers who may be comfortable with JavaScript, but may not have formal CS education.</p><p>Now, if it were only necessary to use <code>await</code> once at the beginning of the plugin and once at the end, it wouldn‚Äôt be so bad. We would just tell developers to always use <code>await</code> with <code>loadScene</code> and <code>updateScene</code> even if they don‚Äôt quite understand what it does.</p><p>The problem is that some API calls require a lot of complex logic to run. Changing a single property on a layer sometimes cause multiple layers to update. For example, resizing a frame can recursively apply constraints to its children.</p><p>These behaviors are often complex and nuanced algorithms. It would be a bad idea to re-implement them again for plugins. That logic is also in our compiled WebAssembly binary, so it‚Äôs not easy to reuse. And if we don‚Äôt run that logic inside the plugin sandbox, plugins will be reading stale data.</p><p>So while this is manageable:</p></div></div><div><pre><code><span>await</span> figma<span>.</span><span>loadScene</span><span>(</span><span>)</span>
<span>...</span> <span>do</span> stuff <span>...</span>
<span>await</span> figma<span>.</span><span>updateScene</span><span>(</span><span>)</span></code></pre></div><p>This can get unwieldy very quickly, even for experienced engineers:</p><div><pre><code><span>await</span> figma<span>.</span><span>loadScene</span><span>(</span><span>)</span>
<span>...</span> <span>do</span> stuff <span>...</span>
<span>await</span> figma<span>.</span><span>updateScene</span><span>(</span><span>)</span>
<span>await</span> figma<span>.</span><span>loadScene</span><span>(</span><span>)</span>
<span>...</span> <span>do</span> stuff <span>...</span>
<span>await</span> figma<span>.</span><span>updateScene</span><span>(</span><span>)</span>
<span>await</span> figma<span>.</span><span>loadScene</span><span>(</span><span>)</span>
<span>...</span> <span>do</span> stuff <span>...</span>
<span>await</span> figma<span>.</span><span>updateScene</span><span>(</span><span>)</span></code></pre></div><div><div><h3 id="problem-2-copying-the-scene-is-expensive">Problem #2: copying the scene is expensive</h3><p>The second problem with the <code>&lt;iframe&gt;</code> approach is that it requires serializing large parts of the document before sending them to the plugin.</p><p>It turns out that people can create very, very large documents in Figma to the point of hitting memory limits. For example, on Microsoft‚Äôs design systems file (which we spent a month optimizing last year), it took 14 seconds just to serialize the document and send it to the plugin, <em>before the plugin could even run</em>. Given that most plugins are going to involve quick actions like ‚Äúswap two items in my selection‚Äù, this would make plugins unusable.</p><p><em>Loading the data incrementally or lazily also isn‚Äôt really an option, because: </em></p><ol start="1"><li>It would involve months of re-architecting the core product.</li><li>Any API that may need to wait on a piece of data that hasn‚Äôt arrived yet will now be asynchronous.</li></ol><p>In summary, because Figma documents can have really large amount of data with a lot of interdependencies, the <code>&lt;iframe&gt;</code> wasn‚Äôt going to work for us.</p><h2 id="back-to-the-drawing-board-and-the-main-thread"><a href="#back-to-the-drawing-board-and-the-main-thread">Back to the drawing board, and the main thread</a></h2><p>With the <code>&lt;iframe&gt;</code> approach having been ruled out, we had to backtrack in our research.</p><p>We went back to the drawing board and spent two long weeks discussing a variety of approaches. As the simple solution didn‚Äôt work out, we had to give serious consideration to more exotic ideas. There were many ‚Äî too many to fill the margins of this blog post. </p><p><em>But most approaches had one or more major disqualifying flaws:</em></p><ul><li>Have an API that would be too difficult to use (e.g. accessing the document using a REST API or GraphQL like method)</li><li>Depends on browser features that browser vendors have removed or are trying to (e.g. synchronous xhr + service worker, shared buffers)</li><li>Requires significant research work or re-architecting of our application that could take months before we can even validate that it can work (e.g. load a copy of Figma in an iframe + sync via CRDTs, hack green threads into JavaScript with generators by cross-compiling)</li></ul><p>At the end of the day, we concluded that we had to find a way to create a model where plugins can directly manipulate the document. Writing a plugin should feel like a designer automating their actions. So we knew we‚Äôd have to allow plugins to run on the main thread.</p><h3 id="implications-of-running-on-the-main-thread">Implications of running on the main thread</h3><p>Before we dive into Attempt #2, we need to take a step back and re-examine what it means to allow plugins to run on the main thread. After all, we didn‚Äôt consider it at first because we knew that it could be dangerous. Running on the main thread sounds an awful lot like <code>eval(UNSAFE_CODE)</code>.</p><p><em>The benefits of running on the main thread are that plugins can:</em></p><ol start="1"><li>Directly edit the document rather than a copy of it, eliminating loading time issues.</li><li>Run our complex component updating and constraints logic without needing to have two copies of that code.</li><li>Make synchronous API calls in situations where you‚Äôd expect a synchronous API. There would be no confusion with loading or flushing updates.</li><li>Be written in a more intuitive way: plugins are just automating actions that the user would otherwise do manually using our UI.</li></ol><p><em>However, now we have these problems:</em></p><ol start="1"><li>Plugins can hang, and there is no way to interrupt a plugin.</li><li>Plugins can make network requests as figma.com.</li><li>Plugins can access and modify global state. This includes modifying our UI, creating dependencies on internal application state outside the API, or doing downright malicious things like changing the value of <code>({}).__proto__</code>  which poisons every new and existing JavaScript object.</li></ol><p>We decided that we could drop the requirement for (1). When plugins freeze, it affects the perceived stability of Figma. However, our plugin model works such that they are only ever run on explicit user action. By changing the UI when a plugin runs, freezes would always be attributed to the plugin. It also means that it is not possible for a plugin to ‚Äúbreak‚Äù a document.</p><h3 id="what-does-it-mean-for-eval-to-be-dangerous">What does it mean for <code>eval</code> to be dangerous?</h3><p>To deal with the issue of plugins being able to make network requests and access global state, we must first understand exactly what it means that ‚Äúeval arbitrary JavaScript code is dangerous‚Äù.</p><p>If a variant of JavaScript, let‚Äôs call it SimpleScript, had only the ability to do arithmetic such  <code>7 * 24 * 60 * 60</code>, it would be quite safe to <code>eval</code>.</p><p>You can add some features to SimpleScript like variable assignment and if statements to make it more like a programming language, and it would still be very safe. At the end of the day, it still essentially boils down to doing arithmetic. Add function evaluation, and now you have lambda calculus and Turing completeness.</p><p>In other words, JavaScript doesn‚Äôt <em>have</em> to be dangerous. In its most reductionist form, it‚Äôs merely an extended way of doing arithmetics. What <em>is</em> dangerous is when it has access to input &amp; output. This includes network access, DOM access, etc. It‚Äôs <strong>Browser APIs</strong> that are dangerous.</p><p>And APIs are all global variables. So hide the global variables!</p><h3 id="hiding-the-global-variables">Hiding the global variables</h3><p>Now, hiding the global variables sounds good in theory, but it‚Äôs difficult to create secure implementations by merely ‚Äúhiding‚Äù them. You might consider, for example, removing all properties on the <code>window</code> object, or setting them to <code>null</code>, but the code could still get access to global values such as <code>({}).constructor</code>. It would be very challenging to find all the possible ways in which some global value might leak.</p><p>Rather, we need some stronger form of sandboxing where those global values never existed in the first place.</p><div><blockquote><p>In other words, JavaScript doesn‚Äôt have to be dangerous. </p></blockquote></div><p>Consider the previous example of a hypothetical SimpleScript that only supports arithmetic. It‚Äôs a straightforward CS 101 exercise to write an arithmetic evaluation program. In any reasonable implementation of this program, SimpleScript would simply be unable to do anything other than arithmetic.</p><p>Now, expand SimpleScript to support more language features until it becomes JavaScript, and this program is called an <strong>interpreter</strong>, which is how JavaScript, a dynamic interpreted language, is run.</p><h2 id="attempt-2-compile-a-javascript-interpreter-to"><a href="#attempt-2-compile-a-javascript-interpreter-to">Attempt #2: Compile a JavaScript interpreter to WebAssembly</a></h2><p>Implementing JavaScript is too much work for a small startup like ours. Instead, to validate this approach, we took <a href="https://github.com/svaarala/duktape">Duktape</a>, a lightweight JavaScript interpreter written in C++ and compiled it to WebAssembly.</p><p>To confirm that it works, we ran <a href="https://github.com/tc39/test262/tree/es5-tests">test262</a> on it, the standard JavaScript test suite. It passes all ES5 tests except for a few unimportant test failures. To run plugin code with Duktape, we would call the <code>eval</code> function of <em>the compiled interpreter</em>.</p><p><em>What are the properties of this approach?</em> </p><ul><li>This interpreter runs in the main thread, which means we can create a main-thread based API.</li><li>It‚Äôs secure in a way that‚Äôs easy to reason about. Duktape does not support any browser APIs ‚Äî and that‚Äôs a feature! Furthermore, it runs as WebAssembly which itself is a sandboxed environment that has no access to browser APIs. In other words, plugin code can communicate with the outside world only through explicit whitelisted APIs by default.</li><li>It‚Äôs slower than regular JavaScript since this interpreter is not a JIT, but that‚Äôs ok.</li><li>It requires the browser to compile a medium-size WASM binary, which has some cost.</li><li>Browser debugging tools don‚Äôt work by default, but we spent a day implementing a console for the interpreter to validate that it‚Äôd be at least possible to debug plugins.</li><li>Duktape only supports ES5, but it‚Äôs already common practice in the web community to cross-compile newer JavaScript versions using tools such as <a href="https://babeljs.io/">Babel</a>.</li></ul><p>(Aside: a few months later, Fabrice Bellard released <a href="https://bellard.org/quickjs/">QuickJS</a> which supports ES6 natively.)</p><p>Now, compiling a JavaScript interpreter! Depending on your inclinations or aesthetics as a programmer, you might either think:</p><p>THIS IS AWESOME! ü§© </p><p>or</p><p>‚Ä¶really? A JavaScript engine in a browser that <em>already has a JavaScript engine?</em> ü§®. What next, an operating system in a browser?</p><p>And some amount of suspicion is healthy! It is best to avoid re-implementing the browser unless we absolutely have to. We already spent a lot of effort <a href="https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/">implementing an entire rendering system</a>. It was necessary for performance and cross-browser support and are glad we did it, but we still try to not re-invent the wheel.</p><p><strong>This is not the approach we ended up going with.</strong> There‚Äôs an even better approach. However, it was important to cover as a step towards understanding our final sandboxing model which is more complicated.</p><h2 id="attempt-3-realms"><a href="#attempt-3-realms">Attempt #3: Realms</a></h2><p>While we had a promising approach compiling a JS interpreter, there was one more tool to look at. We found a technology called the <a href="https://github.com/tc39/proposal-realms">Realms shim</a> created by the folks at <a href="https://agoric.com/">Agoric</a>.</p><p>This technology describes creating a sandbox and supporting plugins as a potential use case. A promising description! The Realms API looks roughly like this:</p></div></div><div><pre><code><span>let</span> g <span>=</span> <span>window</span><span>;</span> <span>// outer global</span>
<span>let</span> r <span>=</span> <span>new</span> <span>Realm</span><span>(</span><span>)</span><span>;</span> <span>// realm object</span>

<span>let</span> f <span>=</span> r<span>.</span><span>evaluate</span><span>(</span><span>"(function() { return 17 })"</span><span>)</span><span>;</span>

<span>f</span><span>(</span><span>)</span> <span>===</span> <span>17</span> <span>// true</span>

<span>Reflect</span><span>.</span><span>getPrototypeOf</span><span>(</span>f<span>)</span> <span>===</span> g<span>.</span><span>Function</span><span>.</span><span>prototype</span> <span>// false</span>
<span>Reflect</span><span>.</span><span>getPrototypeOf</span><span>(</span>f<span>)</span> <span>===</span> r<span>.</span><span>global</span><span>.</span><span>Function</span><span>.</span><span>prototype</span> <span>// true</span></code></pre></div><p>This technology can actually be implemented using existing, albeit lesser known JavaScript features. One aspect of the sandbox is to hide the globals. The core of how this shim does that looks roughly like this:</p><div><pre><code><span>function</span> <span>simplifiedEval</span><span>(</span><span>scopeProxy<span>,</span> userCode</span><span>)</span> <span>{</span>
  <span>'use strict'</span>
  <span>with</span> <span>(</span>scopeProxy<span>)</span> <span>{</span>
    <span>eval</span><span>(</span>userCode<span>)</span>
  <span>}</span>
<span>}</span></code></pre></div><div><div><p>This is a simplified version for presentation purposes; there are a few more nuances in the real version. However, it showcases key pieces of the puzzle: the <code>with</code> statement and the Proxy object.</p><p>The <code>with (obj)</code> statement creates a scope where variable lookups can be resolved using the properties of <code>obj</code>. In this example, we can resolve the variables <code>PI</code>, <code>cos</code> and <code>sin</code> as properties of the <code>Math</code> object. On the other hand, <code>console</code> is not a property of <code>Math</code> and gets resolved from the global scope.</p></div></div><div><pre><code><span>with</span> <span>(</span><span>Math</span><span>)</span> <span>{</span>
  a <span>=</span> <span>PI</span> <span>*</span> r <span>*</span> r
  x <span>=</span> r <span>*</span> <span>cos</span><span>(</span><span>PI</span><span>)</span>
  y <span>=</span> r <span>*</span> <span>sin</span><span>(</span><span>PI</span><span>)</span>
  <span>console</span><span>.</span><span>log</span><span>(</span>x<span>,</span>  y<span>)</span>
<span>}</span></code></pre></div><div><div><p><strong>Proxy objects</strong> are the most dynamic form of JavaScript objects.</p><ul><li>The most basic JavaScript object returns a value on a property access <code>obj.x</code>.</li><li>The more advanced JavaScript object can have <code>getter</code> properties that returns the result of evaluating a function. The access <code>obj.x</code> calls the getter for <code>x</code>.</li><li>Proxies by running a function <code>get</code> to evaluate any property accesses.</li></ul><p>The proxy below (also simplified for presentation purposes) will return <code>undefined</code> when trying to access <strong>any</strong> property on it, other than the ones in the object <code>whitelist</code>.</p></div></div><div><pre><code><span>const</span> scopeProxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>whitelist<span>,</span> <span>{</span>
  <span>get</span><span>(</span>target<span>,</span> prop<span>)</span> <span>{</span>
    <span>// here, target === whitelist</span>
    <span>if</span> <span>(</span>prop <span>in</span> target<span>)</span> <span>{</span>
      <span>return</span> target<span>[</span>prop<span>]</span>
    <span>}</span>
    <span>return</span> undefined
  <span>}</span>
<span>}</span></code></pre></div><p>Now, when you give this proxy as the argument of the <code>with</code> object, it will capture all variable resolutions and never use the global scope to resolve a variable:</p><div><pre><code><span>with</span> <span>(</span>proxy<span>)</span> <span>{</span>
  <span>document</span> <span>// undefined!</span>
  <span>eval</span><span>(</span><span>"xhr"</span><span>)</span> <span>// undefined!</span>
<span>}</span></code></pre></div><div><div><p>Well, almost. It‚Äôs still possible to access certain globals via expressions such as <code>({}).constructor</code>. Furthermore, the sandbox does need access to some globals. For example, <code>Object</code> is a global, often used in legitimate JavaScript code (e.g. <code>Object.keys</code>).</p><p>To give plugins access to these globals without messing up the window, the Realms sandbox instantiates a new copy of all these globals by creating a <em>same-origin</em> iframe. This iframe is <strong>not</strong> used as a sandbox the way we did in our first attempt. Same-origin iframes are not subject to CORS restrictions. </p><p>Instead, when an <code>&lt;iframe&gt;</code> is created in the same origin as the parent document:</p><ol start="1"><li>It comes with a separate copy of all the globals, e.g. <code>Object.prototype</code></li><li>These globals can be accessed from the parent document.</li></ol><figure><img srcset="//images.ctfassets.net/1khq4uysbvty/kvXDf9hyuoXcjDSBFpzoP/f82499bd22ea72ca4f8d33eccca9a0e4/Plugins_Eng_grab_ref.png?w=368 368w, //images.ctfassets.net/1khq4uysbvty/kvXDf9hyuoXcjDSBFpzoP/f82499bd22ea72ca4f8d33eccca9a0e4/Plugins_Eng_grab_ref.png?w=491 491w, //images.ctfassets.net/1khq4uysbvty/kvXDf9hyuoXcjDSBFpzoP/f82499bd22ea72ca4f8d33eccca9a0e4/Plugins_Eng_grab_ref.png?w=736 736w, //images.ctfassets.net/1khq4uysbvty/kvXDf9hyuoXcjDSBFpzoP/f82499bd22ea72ca4f8d33eccca9a0e4/Plugins_Eng_grab_ref.png?w=1104 1104w, //images.ctfassets.net/1khq4uysbvty/kvXDf9hyuoXcjDSBFpzoP/f82499bd22ea72ca4f8d33eccca9a0e4/Plugins_Eng_grab_ref.png?w=1472 1472w" src="https://images.ctfassets.net/1khq4uysbvty/kvXDf9hyuoXcjDSBFpzoP/f82499bd22ea72ca4f8d33eccca9a0e4/Plugins_Eng_grab_ref.png?w=736" alt="Plugins Eng grab ref" sizes="(max-width: 736px) 100vw, 736px"></figure><p>These globals are put into the Proxy object‚Äôs <code>whitelist</code>, so that the plugin has access to them. Finally, this new <code>&lt;iframe&gt;</code> comes with a new copy of the <code>eval</code> function that differs from the existing one in an important way: even built-in values that are only accessible by syntax such as <code>({}).constructor</code> will also resolve to a copy from the iframe.</p><p>This sandboxing approach using Realms has many nice properties:  </p><ul><li>It runs on the main thread.</li><li>It is fast, because it still uses the browser‚Äôs JavaScript JIT to evaluate the code.</li><li>Browser developer tools work</li></ul><p>But one question remains. Is it secure?</p><h3 id="implementing-the-api-using-realms-securely">Implementing the API using Realms securely</h3><p>We feel good about the sandboxing capabilities of Realms. Although it involves more subtleties than the JavaScript interpreter approach, it still works as a whitelist rather than a blacklist, which keeps its implementation small and auditable. It is created by respected members of the web community.</p><p>However, using Realms isn‚Äôt the end of the story, since it‚Äôs simply a sandbox in which plugins wouldn‚Äôt be able to do anything. We still need to implement APIs that the plugin can use. Those APIs will need to be secure too, as most plugins do need to be able to show some UI and make network requests to be useful (e.g. populate a design with data from Google Sheets).</p><p>Consider, for example, that the sandbox does not contain a <code>console</code> object by default. After all, <code>console</code> is a browser API, not a JavaScript feature. It is possible to pass it as a global to the sandbox.</p></div></div><div><pre><code>realm<span>.</span><span>evaluate</span><span>(</span><span>USER_CODE</span><span>,</span> <span>{</span> log<span>:</span> <span>console</span><span>.</span><span>log</span> <span>}</span><span>)</span></code></pre></div><p>Or perhaps hide the original value inside a function so that the sandbox can‚Äôt modify it:</p><div><pre><code>realm<span>.</span><span>evaluate</span><span>(</span><span>USER_CODE</span><span>,</span> <span>{</span> <span>log</span><span>:</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>...</span>args<span>)</span> <span>}</span> <span>}</span><span>)</span></code></pre></div><div><div><p>This, unfortunately, is a security hole. Even in the second example, the anonymous function was created outside the realm, but is given directly to the realm. This means that the plugin could reach outside the sandbox by navigating through the <code>log</code> function‚Äôs prototype chain.</p><p>The correct way to implement <code>console.log</code> is to wrap it in a function created inside the realm. A simplified example is shown <a href="https://github.com/tc39/proposal-realms/issues/189">here</a> (in practice, it‚Äôs also necessary to convert any exceptions thrown between realms).</p></div></div><div><pre><code><span>// Create a factory function in the target realm. </span>
<span>// The factory return a new function holding a closure.</span>
<span>const</span> safeLogFactory <span>=</span> realm<span>.</span><span>evaluate</span><span>(</span><span><span>`
        (function safeLogFactory(unsafeLog) { 
                return function safeLog(...args) {
                        unsafeLog(...args);
                }
        })
`</span></span><span>)</span><span>;</span>

<span>// Create a safe function</span>
<span>const</span> safeLog <span>=</span> <span>safeLogFactory</span><span>(</span><span>console</span><span>.</span><span>log</span><span>)</span><span>;</span>

<span>// Test it, abort if unsafe</span>
<span>const</span> outerIntrinsics <span>=</span> safeLog <span>instanceof</span> <span>Function</span><span>;</span>
<span>const</span> innerIntrinsics <span>=</span> realm<span>.</span><span>evaluate</span><span>(</span><span><span>`log instanceof Function`</span></span><span>,</span> <span>{</span> log<span>:</span> safeLog <span>}</span><span>)</span><span>;</span>
<span>if</span> <span>(</span>outerIntrinsics <span>||</span> <span>!</span>innerIntrinsics<span>)</span> <span>throw</span> <span>new</span> <span>TypeError</span><span>(</span><span>)</span><span>;</span> 

<span>// Use it</span>
realm<span>.</span><span>evaluate</span><span>(</span><span><span>`log("Hello outside world!")`</span></span><span>,</span> <span>{</span> log<span>:</span> safeLog <span>}</span><span>)</span><span>;</span></code></pre></div><div><div><p>In general, the sandbox should never have direct access to an object created outside the sandbox as it could get access to global scope. It‚Äôs also important that the API is careful about manipulating an object from inside the sandbox, as it risks getting mixed with objects outside the sandbox.</p><p>This poses a problem. While it is possible to build a secure API, it is not tenable to have our developers worry about subtle object origin semantics every time they want to add a new function to the API. So how can we fix that?</p><h2 id="an-api-for-an-interpreter"><a href="#an-api-for-an-interpreter">An API for an interpreter</a></h2><p>The problem is that building the Figma API directly on top of Realms makes it so that each API endpoint needs to be audited, including its input and output values. The surface area created is too large.</p><figure><img srcset="//images.ctfassets.net/1khq4uysbvty/9nO6uonqBW8uDT8fSqZYV/a40887030906b48f67d8f2c98c6b0962/Plugins_Eng_audit.png?w=368 368w, //images.ctfassets.net/1khq4uysbvty/9nO6uonqBW8uDT8fSqZYV/a40887030906b48f67d8f2c98c6b0962/Plugins_Eng_audit.png?w=491 491w, //images.ctfassets.net/1khq4uysbvty/9nO6uonqBW8uDT8fSqZYV/a40887030906b48f67d8f2c98c6b0962/Plugins_Eng_audit.png?w=736 736w, //images.ctfassets.net/1khq4uysbvty/9nO6uonqBW8uDT8fSqZYV/a40887030906b48f67d8f2c98c6b0962/Plugins_Eng_audit.png?w=1104 1104w, //images.ctfassets.net/1khq4uysbvty/9nO6uonqBW8uDT8fSqZYV/a40887030906b48f67d8f2c98c6b0962/Plugins_Eng_audit.png?w=1472 1472w" src="https://images.ctfassets.net/1khq4uysbvty/9nO6uonqBW8uDT8fSqZYV/a40887030906b48f67d8f2c98c6b0962/Plugins_Eng_audit.png?w=736" alt="Plugins Eng audit" sizes="(max-width: 736px) 100vw, 736px"></figure><p>Despite the fact that code inside the Realms sandbox runs using the same JavaScript engine (and gives us convenient tooling benefits), it still helps to pretend that we live under the restrictions of the WebAssembly approach.</p><p>Consider the Duktape, the JavaScript interpreter compiled to WebAssembly from Attempt #2. It‚Äôs not possible for main thread JavaScript code to directly hold a reference to an object inside the sandbox. After all, inside the sandbox, WebAssembly manages its own heap and all JavaScript objects are just segments in this heap. In fact, Duktape might not even implement JavaScript objects using the same memory representation as the browser engine!</p><p>As a result, implementing an API for a Duktape would <em>only</em> be possible via low-level operations such as copying integers and strings in and out of the virtual machine. It would be possible to hold a reference to an object or function inside the interpreter, but only as an opaque handle. </p><p>Such an interface would look like this:</p></div></div><div><pre><code><span>// vm == virtual machine == interpreter</span>
<span>export</span> <span>interface</span> <span>LowLevelJavascriptVm</span> <span>{</span>
  <span>typeof</span><span>(</span>handle<span>:</span> <span>VmHandle</span><span>)</span><span>:</span> <span>string</span>

  <span>getNumber</span><span>(</span>handle<span>:</span> <span>VmHandle</span><span>)</span><span>:</span> <span>number</span>
  <span>getString</span><span>(</span>handle<span>:</span> <span>VmHandle</span><span>)</span><span>:</span> <span>string</span>

  <span>newNumber</span><span>(</span>value<span>:</span> <span>number</span><span>)</span><span>:</span> <span>VmHandle</span>
  <span>newString</span><span>(</span>value<span>:</span> <span>string</span><span>)</span><span>:</span> <span>VmHandle</span>
  <span>newObject</span><span>(</span>prototype<span>?</span><span>:</span> <span>VmHandle</span><span>)</span><span>:</span> <span>VmHandle</span>
  <span>newFunction</span><span>(</span>name<span>:</span> <span>string</span><span>,</span> <span>value</span><span>:</span> <span>(</span><span><span>this</span><span>:</span> <span>VmHandle</span><span>,</span> <span>...</span>args<span>:</span> <span>VmHandle</span><span>[</span><span>]</span></span><span>)</span> <span>=&gt;</span> <span>VmHandle</span><span>)</span><span>:</span> <span>VmHandle</span>

  <span>// For accessing properties of objects</span>
  <span>getProp</span><span>(</span>handle<span>:</span> <span>VmHandle</span><span>,</span> key<span>:</span> <span>string</span> <span>|</span> <span>VmHandle</span><span>)</span><span>:</span> <span>VmHandle</span>
  <span>setProp</span><span>(</span>handle<span>:</span> <span>VmHandle</span><span>,</span> key<span>:</span> <span>string</span> <span>|</span> <span>VmHandle</span><span>,</span> value<span>:</span> <span>VmHandle</span><span>)</span><span>:</span> <span>void</span>
  <span>defineProp</span><span>(</span>handle<span>:</span> <span>VmHandle</span><span>,</span> key<span>:</span> <span>string</span> <span>|</span> <span>VmHandle</span><span>,</span> descriptor<span>:</span> <span>VmPropertyDescriptor</span><span>)</span><span>:</span> <span>void</span>

  <span>callFunction</span><span>(</span>func<span>:</span> <span>VmHandle</span><span>,</span> thisVal<span>:</span> <span>VmHandle</span><span>,</span> <span>...</span>args<span>:</span> <span>VmHandle</span><span>[</span><span>]</span><span>)</span><span>:</span> <span>VmCallResult</span>
  <span>evalCode</span><span>(</span>code<span>:</span> <span>string</span><span>)</span><span>:</span> <span>VmCallResult</span>
<span>}</span>

<span>export</span> <span>interface</span> <span>VmPropertyDescriptor</span> <span>{</span>
  configurable<span>?</span><span>:</span> <span>boolean</span>
  enumerable<span>?</span><span>:</span> <span>boolean</span>
  <span>get</span><span>?</span><span>:</span> <span>(</span><span><span>this</span><span>:</span> <span>VmHandle</span></span><span>)</span> <span>=&gt;</span> <span>VmHandle</span>
  <span>set</span><span>?</span><span>:</span> <span>(</span><span><span>this</span><span>:</span> <span>VmHandle</span><span>,</span> value<span>:</span> <span>VmHandle</span></span><span>)</span> <span>=&gt;</span> <span>void</span>
<span>}</span></code></pre></div><div><div><p>Note that this is the interface the API implementation would use, but it maps more or less 1:1 to Duktape‚Äôs interpreter API. After all, Duktape (and similar virtual machines) were built precisely to be embedded and to allow the embedder to communicate with Duktape.</p><p>Using this interface, the object <code>{x: 10, y: 10}</code> could be passed to the sandbox as such:</p></div></div><div><pre><code><span>let</span> vm<span>:</span> <span>LowLevelJavascriptVm</span> <span>=</span> <span>createVm</span><span>(</span><span>)</span>
<span>let</span> jsVector <span>=</span> <span>{</span> x<span>:</span> <span>10</span><span>,</span> y<span>:</span> <span>10</span> <span>}</span>
<span>let</span> vmVector <span>=</span> vm<span>.</span><span>createObject</span><span>(</span><span>)</span>
vm<span>.</span><span>setProp</span><span>(</span>vmVector<span>,</span> <span>"x"</span><span>,</span> vm<span>.</span><span>newNumber</span><span>(</span>jsVector<span>.</span><span>x</span><span>)</span><span>)</span>
vm<span>.</span><span>setProp</span><span>(</span>vmVector<span>,</span> <span>"y"</span><span>,</span> vm<span>.</span><span>newNumber</span><span>(</span>jsVector<span>.</span><span>y</span><span>)</span><span>)</span></code></pre></div><p>An API for the ‚Äúopacity‚Äù property of a Figma node object looks like this:</p><div><pre><code>vm<span>.</span><span>defineProp</span><span>(</span>vmNodePrototype<span>,</span> <span>'opacity'</span><span>,</span> <span>{</span>
  enumerable<span>:</span> <span>true</span><span>,</span>
  <span>get</span><span>:</span> <span>function</span><span>(</span><span><span>this</span><span>:</span> <span>VmHandle</span></span><span>)</span> <span>{</span>
    <span>return</span> vm<span>.</span><span>newNumber</span><span>(</span><span>getNode</span><span>(</span>vm<span>,</span> <span>this</span><span>)</span><span>.</span><span>opacity</span><span>)</span>
  <span>}</span><span>,</span>
  <span>set</span><span>:</span> <span>function</span><span>(</span><span><span>this</span><span>:</span> <span>VmHandle</span><span>,</span> val<span>:</span> <span>VmHandle</span></span><span>)</span> <span>{</span>
    <span>getNode</span><span>(</span>vm<span>,</span> <span>this</span><span>)</span><span>.</span><span>opacity</span> <span>=</span> vm<span>.</span><span>getNumber</span><span>(</span>val<span>)</span>
    <span>return</span> vm<span>.</span><span>undefined</span>
  <span>}</span>
<span>}</span><span>)</span></code></pre></div><div><div><p>This low-level interface can be implemented equally well with the Realms sandbox. Such an implementation is a relatively small amount of code (~500 LOC in our case). This small amount of code then needs to be audited carefully. However, once that is done, future APIs can be built on top of this interface without worrying about sandbox-related security issues. In literature, this is called the membrane pattern.</p><figure><img srcset="//images.ctfassets.net/1khq4uysbvty/1jt5dvkSmLYgO68AEHIhRW/8601e9c71295ddf898a85c875fbe05bf/Plugins_Eng_safe_VM_API.png?w=368 368w, //images.ctfassets.net/1khq4uysbvty/1jt5dvkSmLYgO68AEHIhRW/8601e9c71295ddf898a85c875fbe05bf/Plugins_Eng_safe_VM_API.png?w=491 491w, //images.ctfassets.net/1khq4uysbvty/1jt5dvkSmLYgO68AEHIhRW/8601e9c71295ddf898a85c875fbe05bf/Plugins_Eng_safe_VM_API.png?w=736 736w, //images.ctfassets.net/1khq4uysbvty/1jt5dvkSmLYgO68AEHIhRW/8601e9c71295ddf898a85c875fbe05bf/Plugins_Eng_safe_VM_API.png?w=1104 1104w, //images.ctfassets.net/1khq4uysbvty/1jt5dvkSmLYgO68AEHIhRW/8601e9c71295ddf898a85c875fbe05bf/Plugins_Eng_safe_VM_API.png?w=1472 1472w" src="https://images.ctfassets.net/1khq4uysbvty/1jt5dvkSmLYgO68AEHIhRW/8601e9c71295ddf898a85c875fbe05bf/Plugins_Eng_safe_VM_API.png?w=736" alt="Plugins Eng safe VM API" sizes="(max-width: 736px) 100vw, 736px"></figure><p>Essentially, this treats both the JavaScript interpreter and the Realms sandbox as ‚Äúsome separate environment in which JavaScript runs."</p><p>There‚Äôs one more key aspect of creating a low-level abstraction over the sandbox. While we are confident about the security of Realms, it never hurts to be extra careful when it comes to security. We recognize the possibility that Realms could have an undiscovered vulnerability that will one day turn into an issue we need to deal with. But this is why we had a few paragraphs talking about compiling an interpreter that we don‚Äôt even use. Because the API is implemented with an interface whose implementation can be interchanged, using an interpreter remains a valid backup plan that we could use without reimplementing any APIs or breaking any existing plugins.</p><h2 id="rich-functionality-in-plugins"><a href="#rich-functionality-in-plugins">Rich functionality in plugins</a></h2><p>We now have a sandbox that can run arbitrary plugins safely, and an API that allows these plugins to manipulate Figma documents. This already opens up a lot of possibilities.</p><p>However, the original problem we were trying to solve was to build a plugin system for a design tool. To be useful, most of these plugins will want the ability to create a user interface, and many will want some form of network access. More generally, we would like plugins to be able to leverage as much of the browser and JavaScript ecosystem as possible.</p><p>We could expose safe, restricted versions of browser APIs one at a time, carefully, just like in the example of <code>console.log</code> above. However, browser APIs (and the DOM in particular) is a huge surface area, larger than even JavaScript itself. Such an attempt would likely either be too restrictive to be useful or it could have a security flaw.</p><p>We solve this problem by reintroducing, yet again, the null-origin <code>&lt;iframe&gt;</code>. Plugins can create an <code>&lt;iframe&gt;</code> (which we show inside the Figma editor as a modal) and put any arbitrary HTML and Javascript in it.</p><figure><img srcset="//images.ctfassets.net/1khq4uysbvty/3YNniRLI1gdJVMSksIZHIJ/29a88bafc8dddb0c7919d22f933ca41c/Plugins_Eng_sorter.png?w=368 368w, //images.ctfassets.net/1khq4uysbvty/3YNniRLI1gdJVMSksIZHIJ/29a88bafc8dddb0c7919d22f933ca41c/Plugins_Eng_sorter.png?w=491 491w, //images.ctfassets.net/1khq4uysbvty/3YNniRLI1gdJVMSksIZHIJ/29a88bafc8dddb0c7919d22f933ca41c/Plugins_Eng_sorter.png?w=736 736w, //images.ctfassets.net/1khq4uysbvty/3YNniRLI1gdJVMSksIZHIJ/29a88bafc8dddb0c7919d22f933ca41c/Plugins_Eng_sorter.png?w=1104 1104w, //images.ctfassets.net/1khq4uysbvty/3YNniRLI1gdJVMSksIZHIJ/29a88bafc8dddb0c7919d22f933ca41c/Plugins_Eng_sorter.png?w=1472 1472w" src="https://images.ctfassets.net/1khq4uysbvty/3YNniRLI1gdJVMSksIZHIJ/29a88bafc8dddb0c7919d22f933ca41c/Plugins_Eng_sorter.png?w=736" alt="Plugins Eng sorter" sizes="(max-width: 736px) 100vw, 736px"></figure><p>The difference with our original attempt at using <code>&lt;iframe&gt;</code>s is that now, the plugin is made of two components:</p><ul><li>The part that can access the Figma document and runs on the main thread, inside a Realms sandbox.</li><li>The part that can access browser APIs and runs inside an <code>&lt;iframe&gt;</code>.</li></ul><p>These two parts of can communicate with each other via message passing. This architecture makes using browser APIs a little more tedious than if we could run both parts in the same environment. However, it is the best we are able to do given current browser technologies, and it has not prevented developers from creating amazing plugins in the two months since we opened the beta.</p><h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2><p>We may have taken a winding journey to get here, but ultimately we were excited to find a viable solution for implementing plugins in Figma. The Realm shim allowed us to isolate third-party code while still letting it run in a familiar browser-like environment.</p><p>While this is the best solution for us, it may not be the right approach for every company or platform. If you need to isolate third-party code, it‚Äôs worth evaluating if you have the same performance and API ergonomic concerns as we did. If not, isolating code via iframes may be sufficient, and simple is always good. We would have liked to stay simple!</p><p>Ultimately we cared deeply about the final user experience ‚Äî both that users of plugins would find them stable and reliable, <em>and</em> that developers with basic Javascript knowledge would be able to build them. Fulfilling those accessibility and quality values made all the time we spent trying to get this right worth it.</p><p>One of the most exciting things about working on the engineering team for a browser-based design tool is that we encounter a lot of uncharted territory, and we get to create new ways of handling technical challenges like this. If these kind of engineering adventures sound like fun to you, check out the <a href="https://www.figma.com/blog/section/engineering/">rest of our blog</a> for more. Or join us, <a href="https://www.figma.com/careers/">we‚Äôre hiring</a>!</p></div></div></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>