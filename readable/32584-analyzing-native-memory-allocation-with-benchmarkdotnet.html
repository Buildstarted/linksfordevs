<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Analyzing native memory allocation with BenchmarkDotNet -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Analyzing native memory allocation with BenchmarkDotNet</h1>
    <article> <aside> </aside> <p>The <strong><code>NativeMemoryProfiler</code></strong> is a new diagnoser for <a href="https://benchmarkdotnet.org/">BenchmarkDotNet</a> that I implemented in version 0.11.6. In this post, you will learn how to analyze native memory allocations in your code. It sounds like a difficult topic, but trust me, you can do it really easily with BenchmarkDotNet.</p> <h4 id="the-story">The story</h4> <p>Not so long ago, I got a task that was difficult for me. To be honest, I did not know where to start. I like this kind of tasks because they are a challenge and a good opportunity to learn something new. I had to create an application to validate native DLLs that were created by other companies. This application should call all functions, check how long it takes to execute all functions and check if functions do not allocate native memory. The last thing was the hardest for me.</p> <p>I thought I would find a solution in some open source project. I started from BenchmarkDotNet which is my favorite .NET library for benchmarking. To my surprise, it turned out that BenchmarkDotNet did not support tracking native allocations. I even found an issue <a href="https://github.com/dotnet/BenchmarkDotNet/issues/457">dotnet/BenchmarkDotNet#457</a> that had labels: <code>help wanted</code> and <code>up-for-grabs</code>. Luckily in this issue, I found information that <a href="https://github.com/kayle">@kayle</a> added support for tracking type of native memory allocations in <a href="https://github.com/microsoft/perfview">PerfView</a>. Here is his PR <a href="https://github.com/microsoft/perfview/pull/857">microsoft/perfview#857</a>. Thanks to it, I had all the information to solve my problem but also I was able to make <code>NativeMemoryProfiler</code> for BenchmarkDotNet. So I did it.</p> <h4 id="demo">Demo</h4> <p>Bellow is a sample benchmark which uses the <code>Marshal.AllocHGlobal</code> and <code>Marshal.FreeHGlobal</code> methods to allocate and free native memory.</p>
<div class="highlight"><pre><code class="language-c#"><span>[ShortRunJob]
</span><span>[NativeMemoryProfiler]</span> <span>// &lt;-- This attribute enables the profiler for native allocation.
</span><span></span><span>[MemoryDiagnoser]</span>
<span>public</span> <span>class</span> <span>IntroNativeMemory</span>
{ <span>private</span> <span>const</span> <span>int</span> Size = <span>20</span>; <span>// Greater value could cause System.OutOfMemoryException for a test with memory leaks.
</span><span></span> <span>private</span> <span>int</span> ArraySize = Size * Marshal.SizeOf(<span>typeof</span>(<span>int</span>));<span>
</span><span>
</span><span> [Benchmark]</span> <span>public</span> <span>unsafe</span> <span>void</span> AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span&lt;<span>byte</span>&gt; unmanaged = <span>new</span> Span&lt;<span>byte</span>&gt;(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); }<span>
</span><span>
</span><span> [Benchmark]</span> <span>public</span> <span>unsafe</span> <span>void</span> AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span&lt;<span>byte</span>&gt; unmanaged = <span>new</span> Span&lt;<span>byte</span>&gt;(unmanagedHandle.ToPointer(), ArraySize);
    }
}</code></pre></div>
<p>As you can see, all you have to do to enable the profiler for native allocations is to add the <code>NativeMemoryProfiler</code> attribute to your benchmark.</p> <p>If you use <code>ManualConfig</code> you can add this profiler this way:</p>
<div class="highlight"><pre><code class="language-c#"><span>private</span> <span>class</span> <span>Config</span> : ManualConfig
{ <span>public</span> Config() { Add(<span>new</span> NativeMemoryProfiler()); <span>// &lt;-- adding profiler for native allocation
</span><span></span> <span>//Your configuration
</span><span></span>    }
}</code></pre></div>
<p>If you don&#x2019;t want to use this profiler every time, you can also enable it from the command line using <code>-p NativeMemory</code> or <code>--profiler NativeMemory</code> parameter. This allows you to enable the <code>NativeMemoryProfiler</code> on demand.</p>
<div class="highlight"><pre><code class="language-ini"><span># for .Net Framework application:</span>
<span>NativeMemorySample.exe --profiler NativeMemory</span>
<span># for .Net Core application:</span>
<span>dotnet NativeMemorySample.dll --profiler NativeMemory </span>
<span># or run benchmark from the directory where is your csproj:</span>
<span>dotnet run -c Release -f netcoreapp2.1 -- --filter *IntroNativeMemory.Alloc* --profiler NativeMemory</span></code></pre></div>
<p>After running the above example code, you will see the results:</p> <table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Error</th>
<th>StdDev</th>
<th>Gen 0</th>
<th>Gen 1</th>
<th>Gen 2</th>
<th>Allocated</th>
<th>Allocated native memory</th>
<th>Native memory leak</th>
</tr>
</thead> <tbody>
<tr>
<td>AllocHGlobal</td>
<td>78.60 ns</td>
<td>10.55 ns</td>
<td>0.578 ns</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>80 B</td>
<td>-</td>
</tr> <tr>
<td>AllocHGlobal WithLeaks</td>
<td>101.17 ns</td>
<td>150.67 ns</td>
<td>8.259 ns</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>80 B</td>
<td>80 B</td>
</tr>
</tbody>
</table> <p>As you can see, <code>NativeMemoryProfiler</code> adds extra columns: &#x201C;Allocated native memory&#x201D; and &#x201C;Native memory leak&#x201D;, to the summary table. In output, you can also find additional information from this diagnoser. This log contains useful information, e.g.: the location of the exported <code>*.etl</code> files or the number of allocated and not deallocated objects.</p>
<div class="highlight"><pre><code class="language-perl"><span>//</span> <span>*</span> Diagnostic Output <span>-</span> NativeMemoryProfiler <span>*</span>
Exported <span>2</span> trace file(s)<span>.</span> Example:
C:<span>\</span>Work<span>\</span>NativeMemorySample<span>\</span>NativeMemorySample<span>\</span>BenchmarkDotNet<span>.</span>Artifacts<span>\</span>NativeMemorySample<span>.</span>IntroNativeMemory<span>.</span>AllocHGlobal<span>-</span><span>20190806</span><span>-</span><span>115958</span><span>.</span>etl <span>--------------------</span>
IntroNativeMemory<span>.</span>AllocHGlobal: ShortRun(IterationCount<span>=</span><span>3</span>, LaunchCount<span>=</span><span>1</span>, WarmupCount<span>=</span><span>3</span>)
<span>--------------------</span>
Native memory allocated per single operation: <span>80</span> B <span>--------------------</span>
IntroNativeMemory<span>.</span>AllocHGlobalWithLeaks: ShortRun(IterationCount<span>=</span><span>3</span>, LaunchCount<span>=</span><span>1</span>, WarmupCount<span>=</span><span>3</span>)
<span>--------------------</span>
Native memory allocated per single operation: <span>80</span> B
Native memory leak per single operation: <span>80</span> B
Count of <span>not</span> deallocated object: <span>1</span> <span>//</span> <span>*</span> Diagnostic Output <span>-</span> MemoryDiagnoser <span>*</span></code></pre></div>
<h4 id="the-tracking-type-of-native-memory-allocation">The tracking type of native memory allocation</h4> <p>Currently, BenchmarkDotNet does not print information about native memory allocation types, but <code>NativeMemoryProfiler</code> saves this information in <code>*.etl</code> files. As I mentioned earlier, thanks to <a href="https://github.com/kayle">@kayle</a> and his great PR <a href="https://github.com/microsoft/perfview/pull/857">microsoft/perfview#857</a>, you can easily get type names using PerfView.</p> <p>If the benchmark uses your native DLL, you can check what types were used. Here is an example C++ code of a native DLL:</p>
<div class="highlight"><pre><code class="language-c++"><span>typedef</span> <span>struct</span> _Point { <span>int</span> X; <span>int</span> Y;
}Point; <span>__declspec</span>(dllexport) Point<span>*</span> AllocateArrayOfPoint(<span>int</span> size)
{ Point<span>*</span> a <span>=</span> <span>new</span> Point[size]; <span>// Initialize all elements.
</span><span></span> <span>for</span> (<span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> size; i<span>++</span>) { a[i].X <span>=</span> i; a[i].Y <span>=</span> i <span>+</span> <span>1</span>; } <span>return</span> a;
} <span>__declspec</span>(dllexport) <span>void</span> DeallocateArrayOfPoint(Point<span>*</span> ptr)
{ <span>delete</span>[] ptr;
}
</code></pre></div>
<p>The<code>AllocateArrayOfPoint</code> method allocates an array of <code>Point</code> and <code>DeallocateArrayOfPoint</code> deletes this array.</p> <p>In C#, you need to create a wrapper for this DLL:</p>
<div class="highlight"><pre><code class="language-c#"><span>[StructLayout(LayoutKind.Sequential)]</span>
<span>public</span> <span>struct</span> <span>Point</span>
{ <span>public</span> <span>int</span> X; <span>public</span> <span>int</span> Y;
} <span>public</span> <span>class</span> <span>NativeDll</span>
{<span>
</span><span> [DllImport(&quot;NativeDll.dll&quot;)]</span> <span>public</span> <span>static</span> <span>extern</span> IntPtr AllocateArrayOfPoint(<span>int</span> count);<span>
</span><span>
</span><span> [DllImport(&quot;NativeDll.dll&quot;)]</span> <span>public</span> <span>static</span> <span>extern</span> <span>void</span> DeallocateArrayOfPoint(IntPtr ptr);
}</code></pre></div>
<p>Your benchmark can look like this:</p>
<div class="highlight"><pre><code class="language-c#"><span>[ShortRunJob]
</span><span>[NativeMemoryProfiler]</span>
<span>public</span> <span>class</span> <span>IntroNativeMemoryFromNativeDll</span>
{<span>
</span><span> [Benchmark]</span> <span>public</span> <span>int</span> AllocAndFreeNativeStruct() { <span>var</span> ptr = NativeDll.AllocateArrayOfPoint(<span>200</span>); <span>var</span> result = <span>0</span>; <span>unsafe</span> { <span>var</span> bytes = <span>new</span> Span&lt;Point&gt;((Point*)ptr, <span>200</span>); <span>foreach</span> (<span>var</span> item <span>in</span> bytes) { result += item.X + item.Y; } } NativeDll.DeallocateArrayOfPoint(ptr); <span>return</span> result;
    }
}</code></pre></div>
<p>You can run this benchmark from the command line using the following command:</p>
<div class="highlight"><pre><code class="language-ini"><span>dotnet run -c Release -f netcoreapp2.1 -- --filter *AllocAndFreeNativeStruct*</span></code></pre></div>
<p>In output you can see the summary table:</p> <table>
<thead>
<tr>
<th>Method</th>
<th>Mean</th>
<th>Error</th>
<th>StdDev</th>
<th>Allocated native memory</th>
<th>Native memory leak</th>
</tr>
</thead> <tbody>
<tr>
<td>AllocAndFreeNativeStruct</td>
<td>323.0 ns</td>
<td>66.38 ns</td>
<td>3.64 ns</td>
<td>1600 B</td>
<td>-</td>
</tr>
</tbody>
</table> <p>This benchmark uses 1600 B of native memory because <code>Point</code> has two filed <code>int X</code> and <code>int Y</code>, <code>int</code> has 4 B and in this benchmark there was an array with 200 elements allocated. (2 * 4B * 200 = 1600 B)</p> <p>Now it&#x2019;s time to use the PerfView.</p> <p>The first step is to open the <code>etl</code> file in PerfView and navigate to the Events window.</p> <p>Because BenchmarkDotNet runs your benchmarked function many times in one workload and it runs many workloads, we would like to narrow down the search. For example, the above test on my computer generates the following result log which means that my benchmarked function was running 131072 times in one workload. And we know that there were tree workloads.</p> <p><img src="/images/NativeMemoryProfiler/WorkloadActual.gif" alt="1565168838473"></p> <p>Firstly, you need to find the start and end times of the first WarkloadActual. When you have these times, you can find all <code>HeapTrace</code> events. In summary, you can find information about how many objects were allocated:</p>
<div class="highlight"><pre><code class="language-c#">Native memory allocated per single operation: <span>1600</span> B
Count of allocated <span>object</span>: <span>1</span></code></pre></div>
<p>In my example, there was only one object which means that the first event <code>HeapTraceProvider/HeapTrace/Alloc</code> came from the first run of my benchmarked function, from the first workload. The following image shows how to find this information in PerfView:</p> <p><img src="/images/NativeMemoryProfiler/PerfView-events-windows.gif#mid" alt="PerfView-events-windows"></p> <p>Now it is time to show the information regarding types. In PerfView you should open <code>Net OS Heap Alloc Stacks</code> window from <code>Memory Group</code>. You can use the start and end times of the first Workload because only data between these times is interesting. Below you can see, how to show the information about on types of allocated objects.</p> <p><img src="/images/NativeMemoryProfiler/PerfView-heap-windows.gif#mid" alt="PerfView-events-windows"></p> <h4 id="how-it-works">How it works</h4> <p>To implement <code>NativeMemoryProfiler</code> I used <code>EtwProfiler</code> that runs User, Kernel, and Heap ETW sessions. Each session writes data to its own file and in the end these files are marge to one <code>*.etl</code> file. The <code>NativeMemoryProfiler</code> uses different events from different sessions:</p> <ul>
<li>BenchmarkDotNet Engine events, like <code>WorkloadActualStart</code> and <code>WorkloadActualStop</code> from User session,</li>
<li>HeapTrace events, like <code>HeapTraceAlloc</code>, <code>HeapTraceFree</code>, <code>HeapTraceReAlloc</code>, <code>HeapTraceDestroy</code>, from Heap session.</li>
</ul> <p>You can find the source code in my PRs: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1131">#1131</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1208">#1208</a> or directly in the BenchmarkDotNet <a href="https://github.com/dotnet/BenchmarkDotNet/blob/master/src/BenchmarkDotNet.Diagnostics.Windows/NativeMemoryProfiler.cs">code</a>.</p> <h4 id="limitations">Limitations</h4> <p>Because <code>NativeMemoryProfiler</code> uses <code>EtwProfiler</code>, it also has its limitations:</p> <ul>
<li>Windows only</li>
<li>Requires running as Admin (ETW Kernel Session)</li>
<li>No <code>InProcessToolchain</code> support</li>
</ul> <p>In advanced projects, native code and resources are used very often. Currently, during benchmarking your code, not only you can easily check its speed, but also check how much native memory it uses, thanks to <code>NativeMemoryProfiler</code>.</p> </article>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>