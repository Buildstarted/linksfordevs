<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Rewrite Buffer.BlockCopy in C# by jkotas &#xB7; Pull Request #27216 &#xB7; dotnet/coreclr &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Rewrite Buffer.BlockCopy in C# by jkotas · Pull Request #27216 · dotnet/coreclr · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><blockquote><p>I hope that hardware will add memmove instruction one day that will be superior to hand tuned implementations in every dimension.</p></blockquote><p>I'm pretty sure this is meant to be the <code>ERMSB</code> support and it does basically what you ask. Two problems are that it isn't supported everywhere yet and it has some overhead that makes it undesirable for small loops.</p><ul><li>AMD doesn't support <code>ERMSB</code> directly, but it does support block copies for the same instructions. It has a lot of notes on when it is/isn't beneficial to use.</li><li>We could expose hardware intrinsics for <code>IsGenuineIntel</code>, <code>IsAuthenticAmd</code>, and <code>ERMSB</code> to allow this to be correctly handled.</li></ul><blockquote><p>Trying to hand-tune memmove in software is a losing battle.</p></blockquote><p>I would agree that hand-tuning to have the best perf is likely a losing battle, but many of the rules around copying blocks of memory are well-defined and documented at this point (namely in the respective architecture manuals). It basically comes down to handling sizes less than 128 bytes and then everything else. The split at 128-bytes is defined because that is how much data a <code>prefetch</code> will grab.</p><p>If we exposed intrinsics for the above, we could just have some code like:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">if</span> (<span class="pl-smi">size</span><span class="pl-k">&lt;</span><span class="pl-c1">128</span>)
{
    <span class="pl-c"><span class="pl-c">//</span> small copy</span>
}
<span class="pl-en">else</span><span class="pl-en">if</span> (Cpuid.IsGenuineIntel &amp;&amp; Ermsb.IsSupported)
{
    <span class="pl-smi">Ermsb</span>.<span class="pl-en">MoveBytes</span>(<span class="pl-smi">src</span>, <span class="pl-smi">dst</span>, <span class="pl-smi">count</span>);
}
<span class="pl-en">else</span><span class="pl-en">if</span> (size &lt; threshold)
{
   <span class="pl-c"><span class="pl-c">//</span> large copy in 64-byte chunks using non-temporal loads/stores</span>
}
<span class="pl-k">else</span>
{
    <span class="pl-c"><span class="pl-c">//</span> invoke native memcpy</span>
}</pre></div><p>This should provide overall decent performance and fairly closely match what is recommended by the architecture manuals and done by other memcpy implementations.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>