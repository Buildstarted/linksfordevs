<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Create Interfaces with default implementations -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Create Interfaces with default implementations</h1><div><div class="dbc-post-content"><p>My favorite design improvement for <a href="https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8">C# 8</a> has to be the ability to add the default implementation of a method or property to an existing interface.</p><p>Just think about it, if you have defined a public interface and a bunch of down stream components consume it, any changes you make to the interface immediately need to be reflected by the class consumers, no exceptions. This feature allows you to postpone downstream change because the interface itself holds a concrete method or property it can fall back on.</p><p>Take this example interface:</p><pre class="brush: csharp;">interface IFileHandler
{
    void Delete(string filename);
}
</pre><p>Implemented here:</p><pre class="brush: csharp;">class MyFile : IFileHandler
{
    public void Delete(string filename) { System.IO.File.Delete(filename) }
}
</pre><p>I can now make changes to the interface without immediately modifying the previous class:</p><pre class="brush: csharp;">interface IFileHandler
{
    void Delete(string filename);
    void Rename(string filename, string newfilename) =&gt; System.IO.File.Move(filename, newfilename);
}
</pre><p>This new design permits consumers of your interface the opportunity to implement their own version of the method of property at will, no need for wholesale code changes. You can head over to <a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/default-interface-members-versions">Microsoft docs and go over the details by following a tutorial</a>.</p><p>Admittedly, the idea kind of rubbed me the wrong way when I first saw it, as the whole point of an <a href="https://www.poppastring.com/blog/using-explicit-interfaces">interface</a> is the framework of the contract, not the implementation details, this was quickly offset by the convenience it could give API consumers. I was also, incorrectly, assuming this might invalidate the need for base classes, but you can't inherit from interfaces. So if you want inheritable public members you still need to put them in an abstract base class.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>