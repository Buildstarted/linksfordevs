<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Getting ready to say goodbye to Silverlight and hello to Blazor -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Getting ready to say goodbye to Silverlight and hello to Blazor</h1><div><div class="ac ae af ag ah do aj ak"><p id="93f8" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">This is not everything that’s needed to build an application, this is just most of the parts that I need for modifying my system that is already in place. This is also aimed at my specific application needs but there should be enough information for anyone already using Silverlight and WCF to implement this. Here is step by step how I did everything mentioned above.</p><p id="1034" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">I created a Web API project using .Net Core 2.1 in Visual Studio 2019. The Web API are the Silverlight client are going to have different origins so I added CORS code to configuration in Startup.cs (allowing everything from everywhere for testing):</p><pre class="gl gm gn go gp hw hx hy"><span id="6090" class="hz ia ar bz ib b eu ic id r ie">services.AddCors(options =&gt;</span><span id="56ab" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">{</span><span id="9dc9" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">options.AddPolicy("EnableCORS", builder =&gt;</span><span id="67dd" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">{</span><span id="e01a" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">builder.AllowAnyOrigin().AllowAnyHeader().AllowAnyMethod()<br>.AllowCredentials().Build();</span><span id="6eea" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">});</span><span id="578f" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">});</span></pre><p id="9927" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Accompanied by adding it to the configure method:</p><pre class="gl gm gn go gp hw hx hy"><span id="29b8" class="hz ia ar bz ib b eu ic id r ie">app.UseCors("EnableCORS");</span></pre><p id="13e8" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Silverlight also refuses to access any services from a different origin so to make Silverlight happy I needed to make the server give it a <code class="gy ik il im ib b">clientaccesspolicy.xml</code> file. This file needs to be right under the wwwroot folder and will look like so when there are no restrictions in place:</p><pre class="gl gm gn go gp hw hx hy"><span id="b6b2" class="hz ia ar bz ib b eu ic id r ie">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span id="d7aa" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;access-policy&gt;</span><span id="39c6" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;cross-domain-access&gt;</span><span id="8583" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;policy&gt;</span><span id="8f83" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;allow-from http-request-headers="*"&gt;</span><span id="864d" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;domain uri="*"/&gt;</span><span id="6f30" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;domain uri="http://*"/&gt;</span><span id="45f6" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;domain uri="https://*"/&gt;</span><span id="16c4" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;/allow-from&gt;</span><span id="0794" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;grant-to&gt;</span><span id="5c4d" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;resource path="/" include-subpaths="true"/&gt;</span><span id="73cf" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;/grant-to&gt;</span><span id="0ad1" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;/policy&gt;</span><span id="e94b" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;/cross-domain-access&gt;</span><span id="a844" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">&lt;/access-policy&gt;</span></pre><p id="a55e" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">An interesting thing to note was that this actually didn’t work as originally written with just &lt;domain uri=”*”/&gt; in the file. I had to add the two additional domain entries to get it to work. By default .Net Core is not going to serve this file up. In order to have it become accessible to the client I had to add the following line of code to Configure in Startup.cs:</p><pre class="gl gm gn go gp hw hx hy"><span id="3519" class="hz ia ar bz ib b eu ic id r ie">app.UseStaticFiles();</span></pre><p id="f3b5" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">With that set up I then moved on to configuring Authentication on the server. I added the following code to the ConfigureServices method in Startup.cs and then did a few Quick Actions to resolve the dependencies:</p><pre class="gl gm gn go gp hw hx hy"><span id="dff2" class="hz ia ar bz ib b eu ic id r ie">//security key</span><span id="31ef" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">string securityKey = "Never put your secret key in your code because that would be bad";</span><span id="bd24" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">//symmetric security key</span><span id="7acb" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">var symmetricSecurityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(securityKey));</span><span id="7608" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><span id="7bf5" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">.AddJwtBearer(options =&gt;</span><span id="d5f7" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">{</span><span id="a14c" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">options.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters</span><span id="738d" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">{</span><span id="763d" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">ValidateIssuer = true,</span><span id="639e" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">ValidateAudience = true,</span><span id="bc72" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">ValidateIssuerSigningKey = true,</span><span id="f476" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">ValidIssuer = "lou.com",</span><span id="b1a4" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">ValidAudience = "readers",</span><span id="fb7c" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">IssuerSigningKey = symmetricSecurityKey</span><span id="0b6a" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">};</span><span id="1dc8" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">}</span><span id="19a2" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">);</span></pre><p id="2399" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">To make that work I then added a line in Configure as well:</p><pre class="gl gm gn go gp hw hx hy"><span id="28d8" class="hz ia ar bz ib b eu ic id r ie">app.UseAuthentication();</span></pre><p id="a8a3" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">Because I was building a test environment to see if I could actually get everything to work I worked on the default ValuesController that gets created by the Web API template. The first thing I did was add an [Authorize] attribute directly below the [ApiController] attribute on the ValuesController class. Next I created a test class with another test class that I would pass back and forth to see if my REST calls and serialization and deserialization would actually work. I called my class Foo() and gave it two public string properties and nested another class Bar() with a public string property inside of it. I then set up this method in the ValuesController for my Silverlight client to attempt to call:</p><pre class="gl gm gn go gp hw hx hy"><span id="2178" class="hz ia ar bz ib b eu ic id r ie">// POST api/values/RetrieveFooFromServer</span><span id="caef" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">[HttpPost("[action]")]</span><span id="a643" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">public ActionResult&lt;Foo&gt; RetrieveFooFromServer([FromBody] Foo value)</span><span id="5cc1" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">{</span><span id="43e6" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">try</span><span id="7b68" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">{</span><span id="b8d3" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">Foo result = new Foo();</span><span id="bfc6" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">result.Bar = value.Bar + " received";</span><span id="659b" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">result.Ear.Car = "We are nested";</span><span id="599a" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">return Ok(result);</span><span id="2dbf" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">}</span><span id="c392" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">catch</span><span id="25f6" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">{</span><span id="f5a5" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">return BadRequest();</span><span id="195a" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">}</span><span id="3ff8" class="hz ia ar bz ib b eu if ig ih ii ij id r ie">}</span></pre><p id="1619" class="fw fx ar bz fy b fz ga gb gc gd ge gf gg gh gi gj dj">A direct port of my existing business logic will result in all of my WCF service calls needing to be [HttpPost(“[action]”)] to named methods and receiving and returning C# classes so this is what I tested. At this point all of the configuration is done on the server side although it’s not testable as is because I don’t have code to generate my JWT yet.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>