<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Hacking CoreCLR on Linux with CLion -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Hacking CoreCLR on Linux with CLion</h1>
    <p class="page__inner-wrap"> <header> <p class="page__meta"><i class="far fa-clock"></i> 6 minute read
</p> </header> <section class="page__content"> <p>Being a regular Linux user, when I can, I was looking for a decent setup for myself to grok then hack on CoreCLR&#x2019;s C++ code.</p> <p>CoreCLR, namely the C++ code that implements the runtime (GC, JIT and more) is a BIG project, and trying to peel through its layers for the first time is no easy task for sure. While there are many great resources available for developers that want to read about the runtime such as the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/README.md">BotR</a>, for me, there really is no replacement for reading the code and trying to reason about what/how it gets stuff done, preferably during a debug session, with a very focused task/inquiry at hand. For this reason, I really wanted a proper IDE for the huge swaths of C++ code, and I couldn&#x2019;t think of anything else but <a href="https://www.jetbrains.com/clion/">JetBrains&#x2019; own CLion IDE</a> under Linux (and macOS, which I&#x2019;m not a user of).<br>
With my final setup, I really can do non-trivial navigation on the code base such as:</p> <video width="900"> <source src="../assets/images/clion-coreclr.webm" type="video/webm">
</video> <p>CoreCLR is a beast of a project, and getting it to parse properly under CLion, moreover, it requires some non-trivial setup, so I thought I&#x2019;d disclose my process here, for other people to see and maybe even improve upon&#x2026;</p> <p>Generally speaking, all the puzzle pieces should fit since the CoreCLR build-system is 95% made of running <code class="highlighter-rouge">cmake</code> to generate standard GNU makefiles, and then builds the whole thing using said makefiles, where the other 5% is made of some scripts wrapping the <code class="highlighter-rouge">cmake</code> build-system. At the same time, CLion builds upon <code class="highlighter-rouge">cmake</code> to bootstrap its own internal project representation, <em>provided</em> that it can invoke <code class="highlighter-rouge">cmake</code> just like the normal build would.</p> <p>Here&#x2019;s what I did to get everything working:</p> <ol> <li>First, We&#x2019;ll clone and perform a single build of CoreCLR by <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/building/linux-instructions.md#environment">following the instructions</a>, What I did on my Ubuntu machine consisted of: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>apt <span class="nb">install </span>cmake llvm-3.9 clang-3.9 lldb-3.9 liblldb-3.9-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libcurl4-openssl-dev libssl-dev libnuma-dev libkrb5-dev
<span class="nv">$ </span>./build.sh checked
</code></pre></div> </div> </li> <li>Once the build is over, you should have everything under the <code class="highlighter-rouge">bin/Product/Linux.x64.Checked</code> like so: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls </span>bin/Product/Linux.x64.Checked
bin libcoreclr.so netcoreapp2.0
coreconsole libcoreclrtraceptprovider.so PDB
corerun libdbgshim.so sosdocsunix.txt
createdump libmscordaccore.so SOS.NETCore.dll
crossgen libmscordbi.so SOS.NETCore.pdb
gcinfo libprotononjit.so superpmi
IL libsosplugin.so System.Globalization.Native.a
ilasm libsos.so System.Globalization.Native.so
ildasm libsuperpmi-shim-collector.so System.Private.CoreLib.dll
inc libsuperpmi-shim-counter.so System.Private.CoreLib.ni.<span class="o">{</span>fe21e59b-7903-49b4-b2d3-67de152c1d7d<span class="o">}</span>.map
lib           libsuperpmi-shim-simple.so     System.Private.CoreLib.xml
libclrgc.so   Loader
libclrjit.so  mcs
</code></pre></div> </div> <p>Now that an initial build is over, we can be sure that some scripts that were crucial to generate a few headers essential for the rest of the compilation process were generated and CLion will be able to find all the necessary source code once we teach it how to&#x2026;</p> </li> <li> <p>CLion needs to invoke <code class="highlighter-rouge">cmake</code> with the same arguments that the build scripts use. To sniff out the <code class="highlighter-rouge">cmake</code> command-line we&#x2019;ll use an *nix old-timer&#x2019;s trick to generate traces for <code class="highlighter-rouge">build.sh</code> run: use <code class="highlighter-rouge">bash -x</code>. Unfortunately, nothing is ever so simple in life, and CoreCLR&#x2019;s <code class="highlighter-rouge">build.sh</code> script doesn&#x2019;t directly invoke <code class="highlighter-rouge">cmake</code>, so we will need to make this <code class="highlighter-rouge">-x</code> parameter sticky or recursive. There is no better way to do this than the following somewhat convoluted procedure:<br>
First we need to generate a wrapper-script for <code class="highlighter-rouge">build.sh</code>, we&#x2019;ll call it <code class="highlighter-rouge">build-wrapper.sh</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">&quot;export SHELLOPTS</span><span class="se">\n</span><span class="s2">./build.sh </span><span class="se">\$</span><span class="s2">@&quot;</span> <span class="o">&gt;</span> build-wrapper.sh
</code></pre></div> </div> <p>After we have our wrapper in place. we run it instead of <code class="highlighter-rouge">build.sh</code> like this:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>bash <span class="nt">-x</span> ./build-wrapper.sh checked
... <span class="c"># omitted</span>
+ /usr/bin/cmake <span class="nt">-G</span> <span class="s1">&apos;Unix Makefiles&apos;</span> <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>CHECKED <span class="nt">-DCMAKE_INSTALL_PREFIX</span><span class="o">=</span>/home/dmg/projects/public/coreclr/bin/Product/Linux.x64.Checked <span class="nt">-DCMAKE_USER_MAKE_RULES_OVERRIDE</span><span class="o">=</span> <span class="nt">-DCLR_CMAKE_PGO_INSTRUMENT</span><span class="o">=</span>0 <span class="nt">-DCLR_CMAKE_OPTDATA_PATH</span><span class="o">=</span>/home/dmg/.nuget/packages/optimization.linux-x64.pgo.coreclr/99.99.99-master-20190716.1 <span class="nt">-DCLR_CMAKE_PGO_OPTIMIZE</span><span class="o">=</span>1 <span class="nt">-S</span> /home/dmg/projects/public/coreclr <span class="nt">-B</span> /home/dmg/projects/public/coreclr/bin/obj/Linux.x64.Checked
</code></pre></div> </div> <p>Boom! We&#x2019;ve hit that jackpot. For folks following this that are feeling a bit shaky, I&#x2019;ve isolated the exact part we&#x2019;re after below:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-G</span> <span class="s1">&apos;Unix Makefiles&apos;</span> <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>CHECKED <span class="nt">-DCMAKE_INSTALL_PREFIX</span><span class="o">=</span>/home/dmg/projects/public/coreclr/bin/Product/Linux.x64.Checked <span class="nt">-DCMAKE_USER_MAKE_RULES_OVERRIDE</span><span class="o">=</span> <span class="nt">-DCLR_CMAKE_PGO_INSTRUMENT</span><span class="o">=</span>0 <span class="nt">-DCLR_CMAKE_OPTDATA_PATH</span><span class="o">=</span>/home/dmg/.nuget/packages/optimization.linux-x64.pgo.coreclr/99.99.99-master-20190716.1 <span class="nt">-DCLR_CMAKE_PGO_OPTIMIZE</span><span class="o">=</span>1 <span class="nt">-S</span> /home/dmg/projects/public/coreclr <span class="nt">-B</span> /home/dmg/projects/public/coreclr/bin/obj/Linux.x64.Checked
</code></pre></div> </div> </li> <li> <p>The &#x201C;hard&#x201D; part is over. It&#x2019;s a series of boring clicks from here on. it&#x2019;s time to open up CLion and get this show on the road:
We&#x2019;ll start with defining a clang-3.9 based toolchain, since on Linux Clion defaults to using the gcc toolchain (at least on Linux), while CoreCLR needs clang-3.9 to build itself:<img src="/assets/images/clion-toolchains-coreclr.png" alt="clion-toolchains-coreclr"></p> </li> <li> <p>With a toolchain setup, we need to tell <code class="highlighter-rouge">cmake</code> about our build configuration, so we set it up like so:
<img src="/assets/images/clion-cmake-coreclr.png" alt="clion-cmake-coreclr"></p> <p>I&#x2019;ve highlighted all the text boxes you&#x2019;ll need to set. I&#x2019;ll go over the less trivial stuff:</p> <ul> <li>The command line option we just set aside in (3) goes into the <code class="highlighter-rouge">CMake options</code> field.<br>
Unfortunately CLion doesn&#x2019;t like single quotes (weird&#x2026;), so I&#x2019;ve had to change the <code class="highlighter-rouge">-G &apos;Unix Makefiles&apos;</code> into <code class="highlighter-rouge">-G &quot;Unix Makrfiles&quot;</code> (notice the use of double quotes).</li> <li>It would be a wise idea to share the same build folder as our initial command line build used, more over, we might end up going back and forth between CLion and the command line, so I override the &#x201C;Generation Path&#x201D; setting with the value <code class="highlighter-rouge">bin/obj/Linux.x64.Checked</code>. This is again extracted from the same command line we set-aside before. You&#x2019;ll find it in my case towards the end, specified right after the <code class="highlighter-rouge">-B</code> switch.</li> <li>For the build options, I&#x2019;ve specified <code class="highlighter-rouge">-j 8</code>. This option controls how many parallel builds (compilers) are launched during the build process. A good default is to set it to 2x the number of physical cores your machine has, so in my case that means using <code class="highlighter-rouge">-j 8</code>.</li> </ul> </li> <li>That&#x2019;s it, let CLion do it&#x2019;s thing while grinding your machine to a halt, and once it&#x2019;s done you can start navigating and building the CoreCLR project like a first class citizen of the civilized world :)</li>
</ol> <h2 id="debugging-coreclr-from-clion">Debugging CoreCLR from CLion</h2> <p>Once we have CLion understanding the CoreCLR project structure we can take it up a notch and try to debug CoreCLR by launching &#x201C;something&#x201D; while setting a breakpoint.</p> <p>Let&#x2019;s try to debug the JIT as an example for a useful scenario.</p> <ol> <li>First we need a console application: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nv">$ </span><span class="nb">cd</span> /tmp/ <span class="nv">$ </span>dotnet new console <span class="nt">-n</span> clion_dbg_sample The template <span class="s2">&quot;Console Application&quot;</span> was created successfully. Processing post-creation actions... Running <span class="s1">&apos;dotnet restore&apos;</span> on clion_dbg_sample/clion_dbg_sample.csproj... Restore completed <span class="k">in </span>54.39 ms <span class="k">for</span> /tmp/clion_dbg_sample/clion_dbg_sample.csproj. Restore succeeded. <span class="nv">$ </span><span class="nb">cd </span>clion_dbg_sample <span class="nv">$ </span>dotnet publish <span class="nt">-c</span> release <span class="nt">-o</span> linux-x64 <span class="nt">-r</span> linux-x64 Microsoft <span class="o">(</span>R<span class="o">)</span> Build Engine version 16.3.0+0f4c62fea <span class="k">for</span> .NET Core Copyright <span class="o">(</span>C<span class="o">)</span> Microsoft Corporation. All rights reserved. Restore completed <span class="k">in </span>66.26 ms <span class="k">for</span> /tmp/clion_dbg_sample/clion_dbg_sample.csproj.
 clion_dbg_sample -&gt; /tmp/clion_dbg_sample/bin/release/netcoreapp3.0/linux-x64/clion_dbg_sample.dll
 clion_dbg_sample -&gt; /tmp/clion_dbg_sample/linux-x64/
</code></pre></div> </div> <p>Now we have a console application published in some folder, in my case it&#x2019;s <code class="highlighter-rouge">/tmp/clion_dbg_sample/linux-x64</code></p> </li> <li> <p>Next we will setup a new configuration under CLion:<br> <img src="/assets/images/clion-edit-configurations-coreclr.png" alt></p> </li> <li> <p>Now we define a <strong>new</strong> configuration:<br> <img src="/assets/images/clion-select-executable-coreclr.png" alt> We provide some name, I&#x2019;ve decided to use the same name as my test program: <code class="highlighter-rouge">clion_dbg_sample</code>, We select &#x201C;All targets&#x201D; as the Target, and under executable we need to choose &#x201C;Select other&#x2026;&#x201D; to provide a custom path to <code class="highlighter-rouge">corerun</code>. The reason behind this is that we need to run <code class="highlighter-rouge">corerun</code> from a directory that actually contains the entire product: jit, gc and everything else.</p> </li> <li> <p>The path we provide is to the <code class="highlighter-rouge">corerun</code> executable that resides in the <code class="highlighter-rouge">bin/Product/Linux.x64.Checked</code> folder: <img src="/assets/images/clion-custom-executable-coreclr.png" alt></p> </li> <li> <p>Finally we provide our sample project from before to the <code class="highlighter-rouge">corerun</code> executable. This is how my final configuration looks like:<br> <img src="/assets/images/clion-sample-configuration-final-coreclr.png" alt></p> </li> <li> <p>It&#x2019;s time to set a break-point and launch. As a generic sample I will navigate to <code class="highlighter-rouge">compiler.cpp</code> and find the <code class="highlighter-rouge">jitNativeCode</code> method. It&#x2019;s pretty much one of the top-level functions in the JIT, and therefore a good candidate for us. If we set a breakpoint in that method and launch our newly created configuration, we should hit it in no time:
<img src="/assets/images/clion-debug-jit-coreclr.png" alt></p> </li> <li>We&#x2019;re done! If you really want to figure out what to do next, it&#x2019;s probably a good time to hit the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/README.md">BotR</a>, namely the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-overview.md">RyuJit Overview</a> and <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-tutorial.md">RyuJit Tutorial</a> pages that contain a more detailed overview of the JIT. Alternatively, if you&#x2019;re a &#x201C;get your hands dirty&#x201D; sort of person, you can also do some warm-up exercises for your fingers and start hitting that step-into keyboard shortcut. You&#x2019;re debugging the JIT as we speak!</li>
</ol> <p>I hope this end up helping someone wanting to get started digging into the JIT not on Windows. I also personally have a strong preference for CLion as I really think it&#x2019;s much more faster and powerful option than all the other stuff I&#x2019;ve tried this far. At any rate, it&#x2019;s the only viable option for Linux/macOs people.</p> <p>Have fun! Let me know on <a href="https://twitter.com/damageboy">twitter</a> if you&#x2019;re encountering any difficulties or you think I can make anything clearer&#x2026;</p> </section> <footer class="page__meta"> <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt"></i> Updated:</strong> <time>May 01, 2019</time></p> </footer> <section class="page__share"> <a href="https://twitter.com/intent/tweet?text=Hacking+CoreCLR+on+Linux+with+CLion%20https%3A%2F%2Fbits.houmus.org%2F2019-05-01%2Fhacking-coreclr-on-linux-with-clion" class="btn btn--twitter"><i class="fab fa-fw fa-twitter"></i><span> Twitter</span></a> <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fbits.houmus.org%2F2019-05-01%2Fhacking-coreclr-on-linux-with-clion" class="btn btn--facebook"><i class="fab fa-fw fa-facebook"></i><span> Facebook</span></a> <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3A%2F%2Fbits.houmus.org%2F2019-05-01%2Fhacking-coreclr-on-linux-with-clion" class="btn btn--linkedin"><i class="fab fa-fw fa-linkedin"></i><span> LinkedIn</span></a>
</section> </p>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>