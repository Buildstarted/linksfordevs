<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Old Code Gets Younger Every Year - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Old Code Gets Younger Every Year - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@bellmar"/>
    <meta property="og:description" content="The threat of decaying technology looms while we waste time talking about mainframes."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@bellmar/old-code-gets-younger-every-year-3bd24c7f2262"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Old Code Gets Younger Every Year</title>
<div class="readable">
        <h1>Old Code Gets Younger Every Year</h1>
            <div>by https://medium.com/@bellmar</div>
            <div>Reading time: 14-18 minutes</div>
        <div>Posted here: 06 Jul 2020</div>
        <p><a href="https://medium.com/@bellmar/old-code-gets-younger-every-year-3bd24c7f2262">https://medium.com/@bellmar/old-code-gets-younger-every-year-3bd24c7f2262</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@bellmar?source=post_page-----3bd24c7f2262----------------------"><img alt="Marianne Bellotti" src="https://miro.medium.com/fit/c/96/96/0*rw2MhHHnUwwnb-Op." width="48" height="48"></a></p></div></div></div></div><p id="747a" data-selectable-paragraph=""><em>The threat of decaying technology looms while we waste time talking about mainframes.</em></p></div></div><div><div><p id="c420" data-selectable-paragraph="">Without fail whenever I get an interview request, or an invitation to speak about my work doing legacy modernization everybody wants to talk about mainframes and COBOL. The assumption is that I will tell some good war stories about the drudgery of old systems for other engineers who don’t need to worry about that stuff because their careers are focused on modern technology.</p><p id="a8b0" data-selectable-paragraph="">Granted, when I started working with legacy systems I was also drawn to the <em>Ripley’s Believe It or Not</em> factor of the most ancient programs. The thrill of unearthing and dissecting older and older systems, figuring out forgotten languages that most programmers have never heard of, let alone interacted with. I have always been fascinated by low level languages and systems, the magic that turns changes in voltage to abstractions in math and design. But lately I’ve become much more interested in the coming legacy apocalypse and how to slow down the rising level of technical debt on new(-er) technologies.</p><p id="8228" data-selectable-paragraph="">The legacy apocalypse is not the death of the last Baby Boomer COBOL programmer. To be honest that crisis has come and gone. When people talk about the threat of old systems, they love to trot out a stat about how <em>old</em> COBOL programmers are. For example, in 2006 the average age of a COBOL programmer was 55. That sounds bad. Lots of critical staff are close to retirement! Who will look after their systems when they’re gone?</p><p id="34dc" data-selectable-paragraph="">Averages can be misleading. <a href="https://blog.hackerrank.com/the-inevitable-return-of-cobol/" target="_blank" rel="noopener nofollow">In the same survey 52% of programmers were 45–55 and 34% were 35–45</a>. But more to the point, eight years later when all those 55 year old programmers were supposed to have retired Micro Focus’s survey of COBOL programmers and executives put the average age of a COBOL programmer at 55 <em>again</em>. <a href="https://www.brighttalk.com/webcast/16907/376805" target="_blank" rel="noopener nofollow">Their 2019 survey had the average at 50</a>.</p><p id="6db5" data-selectable-paragraph="">In fact, the average age of COBOL programmers has been steady for <em>decades</em>. When my father worked on Y2K bugs he was in his late 40s~early 50s. His colleagues were similar ages. Every time I see people making a big deal about the age of the COBOL community I think of something American oboist Blair Tindell wrote about the classical music community:</p><blockquote><p id="bb2f" data-selectable-paragraph="">The terror about older listeners was misplaced, ignoring the fact that average audience age has hovered in the late forties for some time. It was logical for people to wait until midlife to begin attending the symphony. With children grown, tuition paid, more leisure time, concerts fit well into mature baby boomers’ rich lifestyles, tastes, and income.</p></blockquote><p id="7eaa" data-selectable-paragraph="">A similar thing could be said about COBOL. Unlike young programmers in the 60s, 70s and 80s, young programmers of today do not have university mainframes to play around with. If the university still has a mainframe it’s the work horse of the administration, too critical for student projects. Young programmers do not have the option of learning COBOL. And even if they did the hundreds — or some say thousands — of COBOL jobs are not entry level ones.</p><p id="2077" data-selectable-paragraph="">In all likelihood the reason the average age of COBOL programmers is stable is because COBOL programmers develop their depth of experience and expertise in other languages before moving over to COBOL later in their career.</p><p id="b35e" data-selectable-paragraph="">People are worried about old COBOL programmers because they assume when the last of the COBOL programmers die out then their programs will be unmaintainable. This is a reasonable concern, however most people would be surprised to learn that the threat of unmaintainable legacy code is a whole lot closer than they think and does not involve a mainframe.</p><h2 id="48e0" data-selectable-paragraph="">64% of Java Applications are stuck on Java 8</h2><p id="0806" data-selectable-paragraph="">If you are keeping score, the most current version of Java is 14. The end of life for Java 8 was supposed to be 2019.</p><p id="43c6" data-selectable-paragraph="">Java 9 introduced some structural changes to make Java more modular and therefore more feasible for embedded systems. Moving from Java 8 to Java 9 is not an upgrade, it’s a full migration. Among other things Java 9 made JDK-internal APIs inaccessible, it removed several tools and methods, and the shift to a modular structure required changes to dependencies. In other words, moving from Java 8 to Java 9 potentially meant that a lot of code would have to be rewritten.</p><p id="4ac8" data-selectable-paragraph="">So as a result <a href="https://snyk.io/wp-content/uploads/jvm_2020.pdf" target="_blank" rel="noopener nofollow">more than half of production applications surveyed by Snyk</a> in 2020 were still running on Java 8.</p><h2 id="a325" data-selectable-paragraph="">Python 2</h2><p id="40e3" data-selectable-paragraph="">Of course the ultimate in upgrades that are really major migrations is the transition from Python 2 to Python 3. As with Java 8, Python 2 has lingered because migration to Python 3 requires both a rewrite of the code you own and eliminating Python 2 from all of your dependencies. Although tools like Benjamin Peterson’s <a href="https://github.com/benjaminp/six" target="_blank" rel="noopener nofollow">six</a> have made the task much more pleasant, dependencies are more than packages and libraries. The platform the code runs on is <em>also</em> a dependency and the platforms have been slow to respond. Although Python is an extremely popular scripting tool, AWS Lambda did not support Python 3 until 3.6 in 2017, which was a year after 3.6 was released. The same year that Salt rolled out Python 3 support. Ansible supported it a year later, roughly a decade after Python 3 was originally announced.</p><p id="30a8" data-selectable-paragraph="">It’s hard to say how much Python 2 is left in the world. <a href="https://www.jetbrains.com/lp/python-developers-survey-2019/" target="_blank" rel="noopener nofollow">Jetbrains estimates that it’s only 10%</a> and with 24 thousand respondents across 150 different countries that’s probably an accurate figure. The Python 2 problem may not be that there is so much of it, but <em>where</em> it still exists. According to Jetbrains the places where Python 2 is still giving Python 3 a run for its money are DevOps/Automation, Testing, and Network Programming. Getting various flavors of Linux to commit fully to Python 3 proved to be a huge challenge. And the fight is not over yet, every Mac-loving pythonista knows that Apple computers still ship with Python 2.7 as their default Python version because of MacOS internal tools.</p><h2 id="1eeb" data-selectable-paragraph="">Everyone Hates jQuery and Yet It Is Everywhere</h2><p id="8c0f" data-selectable-paragraph="">On the flip side of dependency hell is jQuery. Migrating away from jQuery is not difficult because of dependencies, it is difficult because so many other things have come to depend on jQuery.</p><p id="b8ef" data-selectable-paragraph="">When Twitter Bootstrap finally removed jQuery as a dependency in 2019 it was only <a href="https://news.ycombinator.com/item?id=19147818" target="_blank" rel="noopener nofollow">because they copied and pasted source code from jQuery directly into Bootstrap</a>. Even then the whole project took over two years from beginning to end.</p><p id="cf55" data-selectable-paragraph="">jQuery is a victim of its own success. Its simple syntax proved so popular that other frameworks and even native JS started to adopt it. On top of that, many of the legacy technologies that jQuery provided cross compatibility with have <em>finally</em> been decommissioned (looking at you Internet Explorer). Personally I think the concern around jQuery is a little overblown, but I’m not a JavaScript person. The campaign against jQuery seems to have been kicked off by conflicts between the framework and the ascendant MVC JavaScript framework of the moment, React.</p><p id="c185" data-selectable-paragraph="">But like all holy wars in technology, good sensible arguments against choosing one option over the other become murkier the more often they are repeated. In some ways I think the jQuery story is the most similar to the COBOL story in that the headlines published about it lead with its omnipresence and imply that because other technologies can do the same things now those other (newer) technologies must be better.</p><h2 id="5d71" data-selectable-paragraph="">Depth, Not Age</h2><p id="0f99" data-selectable-paragraph="">There are many things that make legacy systems difficult to maintain. The age of the programmers doing the maintaining is not one of them. True, loss of institutional memory matters and when the programmers who knew the system best leave institutional memory goes with them. But this is not an issue exclusive to older technology. Organizations lose institutional memory to poaching staff just as often as they do to retirement (probably more often).</p><p id="5a75" data-selectable-paragraph="">The fact that the pool of available engineers savvy with COBOL is limited is a problem solved much cheaper and much easier by building pipelines to develop COBOL talent. IBM has been very active in this space with their <a href="https://www.ibm.com/it-infrastructure/z/education/master-the-mainframe" target="_blank" rel="noopener nofollow">Master the Mainframe</a> program. It’s simply not true that COBOL programmers are a finite resource that is drying up.</p><p id="7766" data-selectable-paragraph="">I have to say in my experience, whenever a COBOL system goes down it is almost <em>never</em> the COBOL that took it down. I’ve seen hardware failures, issues with non-COBOL systems that support or otherwise integrate with COBOL, I’ve seen delays in adding new features because the COBOL code is poorly documented and engineering needs to figure out how to change it…. but I haven’t seen many incidents where the fact that the system was in COBOL was a problem in and of itself. That’s not to say that there aren’t good reasons to get rid of COBOL, there definitely are. I’m just not inclined to agree that civil society can’t continue to run on millions of lines of COBOL for another 60 years. It certainly can.</p><p id="c9f1" data-selectable-paragraph="">Java 8 and Python 2 on the other hand are a far more serious threat. When systems can’t get off end of life technology they miss security updates, performance enhancements, and new features. The longer systems stay stuck in their own technical debt, the more things are built on top of them, the more entrenched the legacy becomes.</p><p id="06ab" data-selectable-paragraph="">We do programmers a disservice when we act as if the conversation about the growing threat of legacy code begins and ends with COBOL. A whole generation of software engineers are spending their careers making the problem worse by outsourcing all but the most unique aspects of their applications to armies of libraries, plugins and modules that they are powerless to monitor let alone update.</p><p id="0131" data-selectable-paragraph="">The real horseman of the legacy apocalypse is the depth of the dependency tree. Modern software development stacks abstraction on top of abstraction. If the <a href="https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/" target="_blank" rel="noopener nofollow">left-pad incident of 2016</a> proved nothing else it demonstrated that even experienced engineers will YOLO dependencies on to their applications if given the infrastructure to make installing them easy. Modern developer environments are a veritable candy store of cheap and convenient dependencies.</p><h2 id="ee5e" data-selectable-paragraph="">The Rise of Frameworks</h2><p id="e212" data-selectable-paragraph=""><a href="https://en.wikipedia.org/wiki/Timeline_of_programming_languages" target="_blank" rel="noopener nofollow">If Wikipedia can be considered an authoritative source</a>, activity around developing brand new programming languages peaked in the 90s when computers were accessible to a large number of people but were still relatively low on abstraction. The internet changed that both by making more complex distributed systems a reality but also by swelling the blast radius of security issues. Requiring better performance and better security made the MVP of a new language on modern day machines fairly complex. No longer can smart computer scientists build proof of concept pet languages and expect applying them to real world problems to power their evolution. There are a huge number of complex tasks programming languages are expected to handle for the programmer.</p><p id="ab03" data-selectable-paragraph="">So even though the number of professional programmers has grown sharply since the glory days of the 90es, these software experts have shifted away from developing new languages toward developing new <em>frameworks</em>.</p><p id="82fb" data-selectable-paragraph=""><mark>And a framework is essentially nothing more than a curated collection of dependencies given a common interface.</mark> True, frameworks make software development faster, but they also take away the developer’s ability to maintain their code. Advancements in tooling that decrease the speed of software development have inevitably deepened the dependency trees of the average software project.</p><p id="9c17" data-selectable-paragraph="">Take for example Node.js. Node is an interesting framework that made it possible to run JavaScript on the server side, but it also introduced (as a dependency) a nifty little package manager called NPM. There had been package managers before and NPM wasn’t necessarily the best one, but it provided a better user experience by learning some lessons from the package managers before it. It installed things locally instead of globally by default. The command line was designed to integrate with a package repository from the beginning, so creating and publishing new packages was arbitrarily easy.</p><p id="7b58" data-selectable-paragraph="">As a result the <a href="https://snyk.io/blog/how-much-do-we-really-know-about-how-packages-behave-on-the-npm-registry/" target="_blank" rel="noopener nofollow">average depth of the dependency tree on NPM is 4.39 packages, while the average depth on a comparable package manager (in this case PyPi) is 1.7</a>. Python developers are not inherently more responsible than JavaScript developers. JavaScript’s lack of a good core library and its history as a toy language designed and implemented in a week makes it ripe for the development of frameworks to smooth it’s rough edges. There are many many npm packages that do small stupid things that in other languages there is a built in function. NPM made it easy to share.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*0iY031HapB1Yi1Mcoj0TTg.png?q=20" width="1022" height="430" role="presentation"></p><p><img width="1022" height="430" srcset="https://miro.medium.com/max/552/1*0iY031HapB1Yi1Mcoj0TTg.png 276w, https://miro.medium.com/max/1104/1*0iY031HapB1Yi1Mcoj0TTg.png 552w, https://miro.medium.com/max/1280/1*0iY031HapB1Yi1Mcoj0TTg.png 640w, https://miro.medium.com/max/1400/1*0iY031HapB1Yi1Mcoj0TTg.png 700w" sizes="700px" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><a href="https://www.researchgate.net/publication/331587729_Security_Issues_in_Language-based_Sofware_Ecosystems" target="_blank" rel="noopener nofollow">Package dependencies NPM -vs- PyPi</a>. Truly scary numbers</figcaption></figure><p id="90c3" data-selectable-paragraph="">But what would happen if ECMA decided to fix some of JavaScript’s shortcomings the same way Java 9 and Python 3 attempted to resolve structural problems with their languages? Around 60% of packages on npm have not been updated in a year or more. Despite the lack of maintenance these packages are still downloaded <em>billions</em> of times.</p><p id="8a18" data-selectable-paragraph="">A reality that ECMA acknowledges in their <a href="https://exploringjs.com/es6/ch_one-javascript.html" target="_blank" rel="noopener nofollow">One JavaScript policy</a>:</p><blockquote><p id="0617" data-selectable-paragraph="">But how can we get rid of versioning? By always being backward-compatible. That means we must give up some of our ambitions w.r.t. cleaning up JavaScript: We can’t introduce breaking changes. Being backward-compatible means not removing features and not changing features. The slogan for this principle is: “don’t break the web”.</p></blockquote><p id="303f" data-selectable-paragraph="">We could debate the merits of forever backwards compatibility all day. The point is the colossal dependency footprint that has always been inherent in JavaScript has grown infinitely worse as frameworks for it become more popular. So the same tools that are ironing out the numerous structural problems with a language like JavaScript are also making those problems impossible to fix in newer versions of JavaScript.</p><p id="7903" data-selectable-paragraph="">When we talk about maintaining healthy and secure technical systems long term this is a far greater threat than the age of COBOL programmers. And yet when we talk about legacy, we do not talk about these issues.</p><h2 id="0a77" data-selectable-paragraph="">In Summary: Strategy Over Speed</h2><p id="67ca" data-selectable-paragraph="">Dependencies are a necessary evil, but using them doesn’t have to condemn projects to legacy hell. We need to start incorporating long term maintenance goals into our conversations about technology selection. JavaScript frameworks create deep dependency trees, yes, but even though NPM was developed to serve the needs of a backend language, <a href="https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/The-secret-history-behind-the-success-of-npm-and-Node" target="_blank" rel="noopener nofollow">80% of the activity on it is frontend related</a>. We throw frontends away and rebuild them all the damn time. The prevailing wisdom in the design community is that websites are redesigned roughly every three years. So a React frontend with a large dependency graph is less of a concern from a legacy modernization standpoint than a Node app with a dependency graph of the same size buried more deeply in the architecture.</p><p id="d5a6" data-selectable-paragraph="">In other words we need to start thinking critically about how long we expect a given piece of technology to last and ask ourselves whether the choices we make in building it will make it harder to remove later. We can no longer afford to wait and see when something better comes along. We have to assume that something better will come along <em>eventually</em>.</p><p id="aa12" data-selectable-paragraph="">Finally we need to refocus the conversation and stop demonizing technology just for being <em>old</em> and programmed by <em>old people</em>. A huge portion of the world’s COBOL is doing just fine on COBOL. The problems that do exist can also be found in webapps built in 2002. The fact that COBOL is old is besides the point and distracts away from the growing ecosystem of code that is past end of life.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>