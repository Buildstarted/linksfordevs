<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Peephole optimizations in C&#x2B;&#x2B; and C# -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Peephole optimizations in C++ and C#</h1><div><div class="post-content"><blockquote><p>‚ÄúPerformance gains due to improvements in compiler optimizations will double <br>the speed of a program every 18 years‚Äù ¬© <a href="http://proebsting.cs.arizona.edu/law.html">Proebsting‚Äôs Law</a></p></blockquote><p>When we solve equations, we try to simplify them first, e.g. <code class="highlighter-rouge">Y = -(5 - X)</code> can be simplified to just  <code class="highlighter-rouge">Y = X - 5</code>. In modern compilers it‚Äôs called ‚ÄúPeephole Optimizations‚Äù. Roughly speaking, compilers search for certain patterns and replace them with corresponding simplified expressions. In this blog post I‚Äôll list some of them which I found in LLVM, GCC and .NET Core (CoreCLR) sources.</p><p>Let‚Äôs start with simple cases:</p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="n">X</span><span class="p">*</span><span class="m">1</span><span class="p">=&gt;</span><span class="n">X</span><span class="p">-</span><span class="n">X</span><span class="p">*</span><span class="p">-</span><span class="n">Y</span><span class="p">=&gt;</span><span class="n">X</span><span class="p">*</span><span class="n">Y</span><span class="p">-(</span><span class="n">X</span><span class="p">-</span><span class="n">Y</span><span class="p">)</span><span class="p">=&gt;</span><span class="n">Y</span><span class="p">-</span><span class="n">X</span><span class="n">X</span><span class="p">*</span><span class="n">Z</span><span class="p">-</span><span class="n">Y</span><span class="p">*</span><span class="n">Z</span><span class="p">=&gt;</span><span class="n">Z</span><span class="p">*</span><span class="p">(</span><span class="n">X</span><span class="p">-</span><span class="n">Y</span><span class="p">)</span></pre></td></tr></tbody></table></code></pre></figure><p>and check the 4th one in C++ and C# compilers:</p><figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="kt">int</span><span class="nf">Test</span><span class="p">(</span><span class="kt">int</span><span class="n">x</span><span class="p">,</span><span class="kt">int</span><span class="n">y</span><span class="p">,</span><span class="kt">int</span><span class="n">z</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="n">x</span><span class="p">*</span><span class="n">z</span><span class="p">-</span><span class="n">y</span><span class="p">*</span><span class="n">z</span><span class="p">;</span><span class="c1">//  =&gt;  z * (x - y)</span><span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure><p>Now let‚Äôs take a look at what the compilers output:</p><figure class="alignleft"><figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="n">Test</span><span class="p">(</span><span class="k">int</span><span class="p">,</span><span class="k">int</span><span class="p">,</span><span class="k">int</span><span class="p">)</span><span class="o">:</span><span class="k">mov</span><span class="n">eax</span><span class="p">,</span><span class="n">edi</span><span class="k">sub</span><span class="n">eax</span><span class="p">,</span><span class="n">esi</span><span class="c">; -         </span><span class="k">imul</span><span class="n">eax</span><span class="p">,</span><span class="n">edx</span><span class="c">; *         </span><span class="k">ret</span></pre></td></tr></tbody></table></code></pre></figure><figcaption>C++ (Clang, GCC, MSVC)</figcaption></figure><figure class="alignleft"><figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="n">C</span><span class="p">.</span><span class="n">Test</span><span class="p">(</span><span class="n">Int32</span><span class="p">,</span><span class="n">Int32</span><span class="p">,</span><span class="n">Int32</span><span class="p">)</span><span class="k">mov</span><span class="n">eax</span><span class="p">,</span><span class="n">edx</span><span class="k">imul</span><span class="n">eax</span><span class="p">,</span><span class="n">r9d</span><span class="c">; *</span><span class="k">imul</span><span class="n">r8d</span><span class="p">,</span><span class="n">r9d</span><span class="c">; *</span><span class="k">sub</span><span class="n">eax</span><span class="p">,</span><span class="n">r8d</span><span class="c">; -</span><span class="k">ret</span></pre></td></tr></tbody></table></code></pre></figure><figcaption>C# (RyuJIT)</figcaption></figure><figure class="aligncenter"></figure><p>All three C++ compilers have just one <code class="highlighter-rouge">imul</code> instruction. C# (.NET Core) has two because it has a very limited set of available peephole optimizations and I‚Äôll list some of them later. Be sure to note, the entire InstCombine transformation implementation, where peephole optimizations live, in LLVM takes more than 30K lines of code (+20k LOC in DAGCombiner.cpp). By the way, <a href="https://github.com/llvm-mirror/llvm/blob/45adfa50b3fddb97d7fc512cec80e48c551f3280/lib/Transforms/InstCombine/InstCombineAddSub.cpp#L1329-L1332">here is the piece of code in LLVM</a> responsible for the pattern we are inspecting now. GCC has a special DSL which describes all peephole optimizations, and <a href="https://github.com/gcc-mirror/gcc/blob/5882c51592109e2e228d3c675792f891a09b43d6/gcc/match.pd#L2185-L2220">here is the piece of that DSL</a> for our case.</p><p>I decided, just for this blog post, to try to implement this optimization for C# in JIT (hold my beer üòõ):</p><figure class="aligncenter"><img src="/images/instcombine/jit-1.png"></figure><p><br>Let‚Äôs now test my JIT improvement (see <a href="https://github.com/EgorBo/coreclr/commit/3d0abaa2c9919a48110a66b3fe19c7abed2bf041">EgorBo/coreclr</a> commit for more details) in VS2019 with Disasmo:
</p><figure class="aligncenter"><img src="/images/instcombine/jit-2.png"><figcaption>lea + imul instead of imul + imul + add</figcaption></figure><p>Let‚Äôs go back to C++ and trace the optimization in Clang. We need to ask clang to emit LLVM IR for our C++ code via <code class="highlighter-rouge">-emit-llvm -g0</code> flags (see <a href="https://godbolt.org/z/RZQTDV">godbolt.org</a>) and then give it to the LLVM optimizer <strong>opt</strong> via <code class="highlighter-rouge">-O2 -print-before-all -print-after-all</code> flags in order to find out what transformation actually removes that extra multiplication from the <code class="highlighter-rouge">-O2</code> set. (see <a href="https://godbolt.org/z/3f0TyT">godbolt.org</a>):</p><figure class="aligncenter"><figure class="highlight"><pre><code class="language-llvm" data-lang="llvm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="c1">; *** IR Dump Before Combine redundant instructions ***</span><span class="k">define</span><span class="err">dso_lo</span><span class="k">c</span><span class="err">al</span><span class="kt">i32</span><span class="vg">@_Z5Case1iii</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="kt">i32</span><span class="p">,</span><span class="kt">i32</span><span class="p">)</span><span class="p">{</span><span class="nv">%4</span><span class="p">=</span><span class="k">mul</span><span class="k">nsw</span><span class="kt">i32</span><span class="nv">%0</span><span class="p">,</span><span class="nv">%2</span><span class="nv">%5</span><span class="p">=</span><span class="k">mul</span><span class="k">nsw</span><span class="kt">i32</span><span class="nv">%1</span><span class="p">,</span><span class="nv">%2</span><span class="nv">%6</span><span class="p">=</span><span class="k">sub</span><span class="k">nsw</span><span class="kt">i32</span><span class="nv">%4</span><span class="p">,</span><span class="nv">%5</span><span class="k">ret</span><span class="kt">i32</span><span class="nv">%6</span><span class="p">}</span><span class="c1">; *** IR Dump After Combine redundant instructions ***</span><span class="k">define</span><span class="err">dso_lo</span><span class="k">c</span><span class="err">al</span><span class="kt">i32</span><span class="vg">@_Z5Case1iii</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="kt">i32</span><span class="p">,</span><span class="kt">i32</span><span class="p">)</span><span class="p">{</span><span class="nv">%4</span><span class="p">=</span><span class="k">sub</span><span class="kt">i32</span><span class="nv">%0</span><span class="p">,</span><span class="nv">%1</span><span class="nv">%5</span><span class="p">=</span><span class="k">mul</span><span class="kt">i32</span><span class="nv">%4</span><span class="p">,</span><span class="nv">%2</span><span class="k">ret</span><span class="kt">i32</span><span class="nv">%5</span><span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure><figcaption>It's InstCombine!</figcaption></figure><p>So it‚Äôs InstCombine indeed, we can even use it as the only optimization for our code for tests via <code class="highlighter-rouge">-instcombine</code> flag passed to <code class="highlighter-rouge">opt</code>:</p><figure class="aligncenter"><img src="/images/instcombine/p2.png"></figure><p>Let‚Äôs go back to the examples. Look what a cute optimization I found in GCC sources:</p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"></code></pre></figure><p><code class="language-cpp" data-lang="cpp">And that‚Äôs true, e.g.: <code class="highlighter-rouge">4 == 8 - 4</code>. Any odd number for C (C usually means a constant/literal) will always be false for the expression:</code></p><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><img src="/images/instcombine/p3.png"><figcaption>Foo2(int x) always returns false. LLVM doesn't have this optimization.</figcaption></code></figure><h3 id="optimizations-vs-ieee754"><code class="language-cpp" data-lang="cpp">Optimizations vs IEEE754</code></h3><p><code class="language-cpp" data-lang="cpp">Lots of this type of optimizations work for different data types, e.g. <code class="highlighter-rouge">byte</code>, <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">unsigned</code>, <code class="highlighter-rouge">float</code>. The latter is a bit tricky e.g. you can‚Äôt simplify <code class="highlighter-rouge">A - B - A</code> to <code class="highlighter-rouge">-B</code> for floats/doubles, even <code class="highlighter-rouge">(A * B) * C</code> is not equal to <code class="highlighter-rouge">A * (B * C)</code> due to the <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE754 specification</a>. However, C++ compilers have a special flag to let the optimizers be less strict around IEEE754, NaN and other FP corner cases and just apply all of the optimizations - it‚Äôs usually called ‚ÄúFast Math‚Äù (<code class="highlighter-rouge">-ffast-math</code> for clang and gcc, <code class="highlighter-rouge">/fp:fast</code> for MSVC). Btw, here you can find my feature request for .NET Core to introduce the ‚ÄúFast Math‚Äù mode there: <a href="https://github.com/dotnet/coreclr/issues/24784">dotnet/coreclr#24784</a>).</code></p><p><code class="language-cpp" data-lang="cpp">As you can see, two <code class="highlighter-rouge">vsubss</code> were eliminated in the <code class="highlighter-rouge">-ffast-math</code> mode:</code></p><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><img src="/images/instcombine/p5.png"><figcaption></figcaption></code></figure><p><code class="language-cpp" data-lang="cpp">The C++ optimizers also support <code class="highlighter-rouge">math.h</code> functions, e.g.:</code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">The square root is always positive:</code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">=&gt;</span><span class="nb">false</span><span class="p">,</span><span class="k">if</span><span class="n">Y</span><span class="n">is</span><span class="n">negative</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">=&gt;</span><span class="nb">false</span></pre></td></tr></tbody></table></code></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">Why should we calculate sqrt(X) if we can just calculate C^2 in compile time instead?:</code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"></code></code></code></pre></figure><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><img src="/images/instcombine/sqrt.png"></code></code></code></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">More sqrt optimizations:</code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">==</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">==</span><span class="n">Y</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">X</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="n">logN</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">))</span><span class="o">=&gt;</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="o">*</span><span class="n">logN</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></pre></td></tr></tbody></table></code></code></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">or <code class="highlighter-rouge">exp</code>:</code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">exp</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">exp</span><span class="p">(</span><span class="n">X</span><span class="o">+</span><span class="n">Y</span><span class="p">)</span></pre></td></tr></tbody></table></code></code></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">And my favorite one:</code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"></code></code></code></code></pre></figure><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><img src="/images/instcombine/p6.png"><figcaption></figcaption></code></code></code></code></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c">There are lots of boring bit/bool patterns:</code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="p">((</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="n">a</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="n">a</span><span class="o">|</span><span class="n">b</span><span class="p">)</span><span class="p">(</span><span class="n">a</span><span class="o">&amp;</span><span class="o">~</span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">)</span><span class="o">--&gt;</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">((</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="n">a</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="n">a</span><span class="o">|</span><span class="n">b</span><span class="p">)</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span><span class="o">~</span><span class="n">Y</span><span class="p">)</span><span class="o">|^+</span><span class="p">(</span><span class="o">~</span><span class="n">X</span><span class="o">&amp;</span><span class="n">Y</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">X</span><span class="o">^</span><span class="n">Y</span><span class="n">A</span><span class="o">-</span><span class="p">(</span><span class="n">A</span><span class="o">&amp;</span><span class="n">B</span><span class="p">)</span><span class="n">into</span><span class="o">~</span><span class="n">B</span><span class="o">&amp;</span><span class="n">A</span><span class="n">X</span><span class="o">&lt;=</span><span class="n">Y</span><span class="o">-</span><span class="mi">1</span><span class="n">equals</span><span class="n">to</span><span class="n">X</span><span class="o">&lt;</span><span class="n">Y</span><span class="n">A</span><span class="o">&lt;</span><span class="n">B</span><span class="o">||</span><span class="n">A</span><span class="o">&gt;=</span><span class="n">B</span><span class="o">-&gt;</span><span class="nb">true</span><span class="p">...</span><span class="n">hundreds</span><span class="n">of</span><span class="n">them</span><span class="p">...</span></pre></td></tr></tbody></table></code></code></code></code></code></pre></figure><h3 id="machine-dependent-optimizations"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c">Machine-dependent optimizations</code></code></code></code></h3><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c">Some operations may be faster or slower on different CPUs, e.g.:</code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"></code></code></code></code></code></pre></figure><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><img src="/images/instcombine/p8.png"><figcaption></figcaption></code></code></code></code></code></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="highlighter-rouge">mulss</code>/<code class="highlighter-rouge">mulsd</code> usually have better both latency and throughput than <code class="highlighter-rouge">divss</code>/<code class="highlighter-rouge">divsd</code> for example, here is the spec for my Intel Haswell CPU:</code></code></code></code></code></p><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><img src="/images/instcombine/p7.png"><figcaption></figcaption></code></code></code></code></code></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c">We can replace <code class="highlighter-rouge">/ C</code> with <code class="highlighter-rouge">* 1/C</code> even in the non-‚ÄúFast Math‚Äù mode if <code class="highlighter-rouge">C</code> is a power of two. Btw, here is my PR for .NET Core for this optimization: <a href="https://github.com/dotnet/coreclr/pull/24584">dotnet/coreclr#24584</a>.</code></code></code></code></code></p><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c">The same rationale for:</code></code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"></code></code></code></code></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="highlighter-rouge">test</code> is better than <code class="highlighter-rouge">cmp</code> (see my PR <a href="https://github.com/dotnet/coreclr/pull/25458">dotnet/coreclr#25458</a> for more details):</code></code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="n">X</span><span class="o">&gt;=</span><span class="mi">1</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">&gt;</span><span class="mi">0</span><span class="n">X</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">&lt;=</span><span class="mi">0</span><span class="n">X</span><span class="o">&lt;=</span><span class="o">-</span><span class="mi">1</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">&gt;=</span><span class="mi">0</span><span class="n">X</span><span class="o">&gt;</span><span class="o">-</span><span class="mi">1</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">&gt;=</span><span class="mi">0</span></pre></td></tr></tbody></table></code></code></code></code></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp">And what do you think about these ones?:</code></code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="n">pow</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="n">pow</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="p">))</span><span class="n">pow</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">*</span><span class="n">X</span><span class="p">;</span><span class="mi">1</span><span class="n">mul</span><span class="n">pow</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">*</span><span class="n">X</span><span class="o">*</span><span class="n">X</span><span class="p">;</span><span class="mi">2</span><span class="n">mul</span></pre></td></tr></tbody></table></code></code></code></code></code></code></pre></figure><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><img src="/images/instcombine/p9.png"></code></code></code></code></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><br>How many <code class="highlighter-rouge">mul</code> are needed to perform <code class="highlighter-rouge">pow(X, 4)</code> or <code class="highlighter-rouge">X * X * X * X</code>?</code></code></code></code></p><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><img src="/images/instcombine/pow4.png"></code></code></code></code></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp">Just 2! Just like for <code class="highlighter-rouge">pow(X, 3)</code> and unlike <code class="highlighter-rouge">pow(X, 3)</code> we don‚Äôt even use the <code class="highlighter-rouge">xmm1</code> register.</code></code></code></code></p><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><br>Modern CPUs support a special FMA instruction to perform <code class="highlighter-rouge">mul</code> and <code class="highlighter-rouge">add</code> in just one step without an intermediate rounding operation for <code class="highlighter-rouge">mul</code>:</code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"></code></code></code></code></code></pre></figure><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><img src="/images/instcombine/p11.png"></code></code></code></code></code></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><br>Sometimes compilers are able to replace entire algorithms with just one CPU instruction, e.g.:</code></code></code></code></code></p><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><img src="/images/instcombine/p12.png"></code></code></code></code></code></figure><h3 id="traps-for-optimizations"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">Traps for optimizations</code></code></code></code></code></h3><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">We can‚Äôt just find patterns &amp; optimize them:</code></code></code></code></code></p><ul><li><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">There is a risk to break some code: there are always corner-cases, hidden side-effects. LLVM‚Äôs bugzilla contains lots of InstCombine bugs.</code></code></code></code></code></li><li><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">An expression or its parts we want to simplify might be used somewhere else.</code></code></code></code></code></li></ul><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">I borrowed a nice example for the second issue from <a href="https://arxiv.org/pdf/1809.02161.pdf">‚ÄúFuture Directions for Optimizing Compilers‚Äù</a> article.<br>Imagine we have a function:</code></code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="kt">int</span><span class="nf">Foo1</span><span class="p">(</span><span class="kt">int</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span><span class="n">b</span><span class="p">)</span><span class="p">{</span><span class="kt">int</span><span class="n">na</span><span class="o">=</span><span class="o">-</span><span class="n">a</span><span class="p">;</span><span class="kt">int</span><span class="n">nb</span><span class="o">=</span><span class="o">-</span><span class="n">b</span><span class="p">;</span><span class="k">return</span><span class="n">na</span><span class="o">+</span><span class="n">nb</span><span class="p">;</span><span class="p">}</span></pre></td></tr></tbody></table></code></code></code></code></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">We need to perform 3 operations here: <code class="highlighter-rouge">0 - a</code>, <code class="highlighter-rouge">0 - b</code>, –∏ <code class="highlighter-rouge">na + nb</code>. LLVM simplifies it to just two operations: <code class="highlighter-rouge">return -(a + b)</code> - what a smart move, here is the IR:</code></code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-llvm" data-lang="llvm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="k">define</span><span class="err">dso_lo</span><span class="k">c</span><span class="err">al</span><span class="kt">i32</span><span class="vg">@_Z4Foo1ii</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="kt">i32</span><span class="p">)</span><span class="p">{</span><span class="nv">%3</span><span class="p">=</span><span class="k">add</span><span class="kt">i32</span><span class="nv">%0</span><span class="p">,</span><span class="nv">%1</span><span class="c1">; a + b</span><span class="nv">%4</span><span class="p">=</span><span class="k">sub</span><span class="kt">i32</span><span class="m">0</span><span class="p">,</span><span class="nv">%3</span><span class="c1">; 0 - %3</span><span class="k">ret</span><span class="kt">i32</span><span class="nv">%4</span><span class="p">}</span></pre></td></tr></tbody></table></code></code></code></code></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">Now imagine that we need to store values of <code class="highlighter-rouge">na</code> and <code class="highlighter-rouge">nb</code> in some global variables, e.g. <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>:</code></code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="kt">int</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span><span class="kt">int</span><span class="nf">Foo2</span><span class="p">(</span><span class="kt">int</span><span class="n">a</span><span class="p">,</span><span class="kt">int</span><span class="n">b</span><span class="p">)</span><span class="p">{</span><span class="kt">int</span><span class="n">na</span><span class="o">=</span><span class="o">-</span><span class="n">a</span><span class="p">;</span><span class="kt">int</span><span class="n">nb</span><span class="o">=</span><span class="o">-</span><span class="n">b</span><span class="p">;</span><span class="n">x</span><span class="o">=</span><span class="n">na</span><span class="p">;</span><span class="n">y</span><span class="o">=</span><span class="n">nb</span><span class="p">;</span><span class="k">return</span><span class="n">na</span><span class="o">+</span><span class="n">nb</span><span class="p">;</span><span class="p">}</span></pre></td></tr></tbody></table></code></code></code></code></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">The optimizer still recognizes the pattern and simplifies it by removing redundant (from its point of view) <code class="highlighter-rouge">0 - a</code> and <code class="highlighter-rouge">0 - b</code> operations. But we do need them! We save them to the global variables! Thus, it leads to this:</code></code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-llvm" data-lang="llvm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">define</span><span class="err">dso_lo</span><span class="k">c</span><span class="err">al</span><span class="kt">i32</span><span class="vg">@_Z4Foo2ii</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="kt">i32</span><span class="p">)</span><span class="p">{</span><span class="nv">%3</span><span class="p">=</span><span class="k">sub</span><span class="k">nsw</span><span class="kt">i32</span><span class="m">0</span><span class="p">,</span><span class="nv">%0</span><span class="c1">; 0 - a </span><span class="nv">%4</span><span class="p">=</span><span class="k">sub</span><span class="k">nsw</span><span class="kt">i32</span><span class="m">0</span><span class="p">,</span><span class="nv">%1</span><span class="c1">; 0 - b</span><span class="k">store</span><span class="kt">i32</span><span class="nv">%3</span><span class="p">,</span><span class="kt">i32</span><span class="p">*</span><span class="vg">@x</span><span class="p">,</span><span class="k">align</span><span class="m">4</span><span class="p">,</span><span class="nv">!tbaa</span><span class="nv">!2</span><span class="k">store</span><span class="kt">i32</span><span class="nv">%4</span><span class="p">,</span><span class="kt">i32</span><span class="p">*</span><span class="vg">@y</span><span class="p">,</span><span class="k">align</span><span class="m">4</span><span class="p">,</span><span class="nv">!tbaa</span><span class="nv">!2</span><span class="nv">%5</span><span class="p">=</span><span class="k">add</span><span class="kt">i32</span><span class="nv">%0</span><span class="p">,</span><span class="nv">%1</span><span class="c1">; a + b</span><span class="nv">%6</span><span class="p">=</span><span class="k">sub</span><span class="kt">i32</span><span class="m">0</span><span class="p">,</span><span class="nv">%5</span><span class="c1">; 0 - %5</span><span class="k">ret</span><span class="kt">i32</span><span class="nv">%6</span><span class="p">}</span></pre></td></tr></tbody></table></code></code></code></code></code></code></pre></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">4 math operations instead of 3! The optimizer has just made our code a bit slower.
Now let‚Äôs see what C# RuyJIT generates for this case:</code></code></code></code></code></p><figure class="aligncenter"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><img src="/images/instcombine/p10.png"></code></code></code></code></code></figure><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">RuyJIT doesn‚Äôt have this optimization so the code contains only 3 operations :-) C# is faster than C++! :p</code></code></code></code></code></p><h3 id="do-we-really-need-these-optimizations"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">Do we really need these optimizations?</code></code></code></code></code></h3><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">Well, you never know what the final code will look like after inlining, constant folding, copy propagation, CSE, etc.<br>Also, both LLVM IR and .NET IL are not tied to a specific programming language and can‚Äôt rely on quality of the IR it generates. And you can just run your app/lib with <code class="highlighter-rouge">InstCombine</code> pass on and off to measure the performance impact.</code></code></code></code></code></p><h3 id="what-about-c"><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">What about C#?</code></code></code></code></code></h3><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">As I said earlier, peephole optimizations are very limited in C# at the moment. However, when I say ‚ÄúC#‚Äù I mean the most popular C# runtime - CoreCLR with RuyJIT. But there are more, including those, using LLVM as a backend: Mono (see my <a href="https://twitter.com/EgorBo/status/1063468884257316865">tweet</a>), Unity Burst and LILLC - these runtimes basically use exactly the same optimizations as clang does. Unity guys are even considering <a href="https://lucasmeijer.com/posts/cpp_unity/">replacing C++ with C#</a> in their internal parts. By the way, since .NET 5 will include Mono as an optional built-in runtime - you will be able to use LLVM power for such cases.</code></code></code></code></code></p><p><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">Back to CoreCLR - here are the peephole optimizations I managed to find in the <code class="highlighter-rouge">morph.cpp</code> comments (I am sure there are more):</code></code></code></code></code></p><figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">X</span><span class="p">)</span><span class="o">=&gt;</span><span class="n">X</span><span class="n">X</span><span class="o">%</span><span class="mi">1</span><span class="o">=&gt;</span><span class="mi">0</span><span class="n">X</span><span class="o">/</span><span class="mi">1</span><span class="o">=&gt;</span><span class="n">X</span><span class="n">X</span><span class="o">%</span><span class="n">Y</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">-</span><span class="p">(</span><span class="n">X</span><span class="o">/</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="n">Y</span><span class="c1">// arm
</span><span class="n">X</span><span class="o">^</span><span class="o">-</span><span class="mi">1</span><span class="o">=&gt;</span><span class="o">~</span><span class="n">x</span><span class="n">X</span><span class="o">&gt;=</span><span class="mi">1</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">&gt;</span><span class="mi">0</span><span class="n">X</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">&lt;=</span><span class="mi">0</span><span class="n">X</span><span class="o">+</span><span class="err">–°</span><span class="mi">1</span><span class="o">==</span><span class="n">C2</span><span class="o">=&gt;</span><span class="n">X</span><span class="o">==</span><span class="n">C2</span><span class="o">-</span><span class="n">C1</span><span class="p">((</span><span class="n">X</span><span class="o">+</span><span class="n">C1</span><span class="p">)</span><span class="o">+</span><span class="n">C2</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">(</span><span class="n">X</span><span class="o">+</span><span class="p">(</span><span class="n">C1</span><span class="o">+</span><span class="n">C2</span><span class="p">))</span><span class="p">((</span><span class="n">X</span><span class="o">+</span><span class="n">C1</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">Y</span><span class="o">+</span><span class="n">C2</span><span class="p">))</span><span class="o">=&gt;</span><span class="p">((</span><span class="n">X</span><span class="o">+</span><span class="n">Y</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">C1</span><span class="o">+</span><span class="n">C2</span><span class="p">))</span></pre></td></tr></tbody></table></code></code></code></code></code></code></pre></figure><p><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">There are also some in <code class="highlighter-rouge">lowering.cpp</code> (machine-dependent ones) but in general RyuJIT obviously loses to –°++ compilers here. RyuJIT just focuses more on different things and has a lot of requirements. The main one is - it should compile fast! it‚Äôs called JIT after all. And it does it very well (unlike the C++ compilers - see <a href="https://aras-p.info/blog/2018/12/28/Modern-C-Lamentations/">‚ÄúModern‚Äù C++ Lamentations</a>). It‚Äôs also more important to de-virtualize calls, optimize out boxings, heap allocations (e.g. <a href="https://github.com/dotnet/coreclr/issues/20253">Object Stack Allocation</a>). However, since RyuJIT is now supporting tiers, who knows maybe there will be a place for peephole optimizations in future in the tier1 or even a separate tier2 ;-). Maybe with some sort of DSL to declare them, just read <a href="https://medium.com/@prathamesh1615/adding-peephole-optimization-to-gcc-89c329dd27b3">this</a> article where Prathamesh Kulkarni managed to declare an optimization for GCC in just a few lines of DSL:</code></code></code></code></p><figure class="highlight"><pre><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="code"><pre><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">plus</span><span class="p">(</span><span class="n">mult</span><span class="p">(</span><span class="n">SIN</span><span class="err">@</span><span class="mi">0</span><span class="p">)</span><span class="p">(</span><span class="n">SIN</span><span class="err">@</span><span class="mi">0</span><span class="p">))</span><span class="p">(</span><span class="n">mult</span><span class="p">(</span><span class="n">COS</span><span class="err">@</span><span class="mi">0</span><span class="p">)</span><span class="p">(</span><span class="n">COS</span><span class="err">@</span><span class="mi">0</span><span class="p">)))</span><span class="p">(</span><span class="k">if</span><span class="p">(</span><span class="n">flag_unsafe_math_optimizations</span><span class="p">)</span><span class="p">{</span><span class="n">build_one_cst</span><span class="p">(</span><span class="n">TREE_TYPE</span><span class="p">(</span><span class="err">@</span><span class="mi">0</span><span class="p">));</span><span class="p">}))</span></pre></td></tr></tbody></table></code></code></code></code></code></pre></figure><p><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">for the following pattern:</code></code></code></code></p><figure class="highlight"><pre><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">cos</span><span class="o">^</span><span class="mi">2</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">+</span><span class="n">sin</span><span class="o">^</span><span class="mi">2</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="n">equals</span><span class="n">to</span><span class="mi">1</span></pre></td></tr></tbody></table></code></code></code></code></code></pre></figure><h3 id="links"><code class="language-c" data-lang="c"><code class="language-c" data-lang="c"><code class="language-cpp" data-lang="cpp"><code class="language-cpp" data-lang="cpp">Links</code></code></code></code></h3></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>