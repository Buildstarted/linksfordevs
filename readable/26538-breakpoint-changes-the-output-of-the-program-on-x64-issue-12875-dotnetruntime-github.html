<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Breakpoint changes the output of the program on x64 &#xB7; Issue #12875 &#xB7; dotnet/runtime &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Breakpoint changes the output of the program on x64 · Issue #12875 · dotnet/runtime · GitHub</h1><div><p>tl;dr - I narrowed this issue down to the fact that the debugger is not decoding the AVX instructions correctly. Below is my experiment that proves that fact.</p><div id="" class=""><li><p>Checkout my <a href="https://github.com/cshung/coreclr/tree/dev/andrewau/25132-investigation">branch</a>, build it for debug, x64</p></li><li><p>Create a .NET Core 3 console application with the repro code, publish it in self contained mode and patch the coreclr with the built binaries.</p></li><li><p>Debug the built exe using Visual Studio with breakpoint set on the indicated line and the <code>Console.WriteLine();</code> line so that we can inspect the result.</p></li><li><p>While the 1st breakpoint hit, non-invasive attach WinDBG to the debuggee process and turn on inspection by running <code>?? coreclr!g_inspect = 1</code>, and then detach WinDBG to allow further execution.</p></li><li><p>Continue the process in Visual Studio, the process should be infinitely looping on the first loop.</p></li><li><p>Non-invasive attach WinDBG to the debuggee process, Inspecting the code around the infinite loop, it should be clear that the debuggee understand this is an AVX instruction, but it deliberately setting <code>opcode0</code> to <code>0xf</code> so that the code will run into the 2 op-code branch (which is questionable ... why?). After inspecting, change RIP to get out the loop. (Some disassembly reading is required here), and then detach WinDBG to allow further execution, it should stuck on the second infinite loop.</p></li><li><p>Non-invasive attach WinDBG to the debuggee process, change note that the code is setting <code>cbImmed</code> to 1, but the instruction doesn't have an immediate value field, so this is wrong. Undo the effect of the wrong code by running <code>?? cbImmed = 0</code>, stop inspection by running <code>?? coreclr!g_inspect = 0</code>, and then detach WInDBG to allow further execution.</p></li><li><p>The process should hit the <code>Console.WriteLine();</code> breakpoint and print out the correct result because we fixed the error due to the instruction decoding bug.</p></li></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>