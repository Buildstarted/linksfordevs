<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Announcing .NET Core 3.0 Preview 6 | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Announcing .NET Core 3.0 Preview 6 | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard"/>
    <meta property="og:description" content="Today, we are announcing .NET Core 3.0 Preview 6. It includes updates for compiling assemblies for improved startup, optimizing applications for size with linker and EventPipe improvements. We&#x2019;ve also released new Docker images for Alpine on ARM64.&#xA;Download .NET Core 3.0 Preview 6 right now on Windows,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0-preview-6/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Announcing .NET Core 3.0 Preview 6 | .NET Blog</title>
<div class="readable">
        <h1>Announcing .NET Core 3.0 Preview 6 | .NET Blog</h1>
            <div>by Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard</div>
            <div>Reading time: 13-16 minutes</div>
        <div>Posted here: 13 Jun 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0-preview-6/">https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0-preview-6/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/37f91ebe219df737566a4dc7cdd53b68?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Richard</p></div></div></div><p>June 12th, 2019</p><p>Today, we are announcing <a href="https://dotnet.microsoft.com/download/dotnet-core/3.0" rel="nofollow" target="_blank">.NET Core 3.0 Preview 6</a>. It includes updates for compiling assemblies for improved startup, optimizing applications for size with linker and EventPipe improvements. We’ve also released new Docker images for Alpine on ARM64.</p><p><a href="https://dotnet.microsoft.com/download/dotnet-core/3.0" rel="nofollow" target="_blank">Download .NET Core 3.0 Preview 6</a> right now on Windows, macOS and Linux.</p><p><a href="https://github.com/dotnet/core/blob/master/release-notes/3.0/preview/3.0.0-preview6.md" target="_blank">Release notes</a> have been published at <a href="https://github.com/dotnet/core" target="_blank">dotnet/core</a>. An <a href="https://github.com/dotnet/core/blob/master/release-notes/3.0/preview/api-diff/preview6/3.0-preview6.md" target="_blank">API diff between Preview 5 and 6</a> is also available.</p><p><a href="https://devblogs.microsoft.com/aspnet/asp-net-core-and-blazor-updates-in-net-core-3-0-preview-6/">ASP.NET Core</a> and EF Core are also releasing updates today.</p><p>If you missed it, check out the improvements we released in <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0-preview-5/" rel="nofollow">.NET Core 3.0 Preview 5</a>, from last month.</p><h2>WPF and Windows Forms update</h2><p>The WPF team has now completed <a href="https://github.com/dotnet/wpf/issues/738" target="_blank">publishing most of the WPF codebase to GitHub</a>. In fact, they just <a href="https://github.com/dotnet/wpf/pull/720" target="_blank">published source for fifteen assemblies</a>. For anyone familiar with WPF, the assembly names should be very familiar.</p><p>In some cases, tests are still on the backlog to get published at or before 3.0 GA. That said, the presence of all of this code should enable the WPF community to fully participate in making changes across WPF. It is obvious from reading some of the GitHub issues that the community has its own backlog that it has been waiting to realize. Dark theme, maybe?</p><h2>Alpine Docker images</h2><p>Docker images are now available for both .NET Core and ASP.NET Core on ARM64. They were previously only available for x64.</p><p>The following images can be used in a <code>Dockerfile</code>, or with <code>docker pull</code>, as demonstrated below:</p><ul><li><code>docker pull mcr.microsoft.com/dotnet/core/runtime:3.0-alpine-arm64v8</code></li><li><code>docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0-alpine-arm64v8</code></li></ul><h2>Event Pipe improvements</h2><p>Event Pipe now supports multiple sessions. This means that you can consume events with EventListener in-proc and simultaneously have out-of-process event pipe clients.</p><p>New Perf Counters added:</p><ul><li>% Time in GC</li><li>Gen 0 Heap Size</li><li>Gen 1 Heap Size</li><li>Gen 2 Heap Size</li><li>LOH Heap Size</li><li>Allocation Rate</li><li>Number of assemblies loaded</li><li>Number of ThreadPool Threads</li><li>Monitor Lock Contention Rate</li><li>ThreadPool Work Items Queue</li><li>ThreadPool Completed Work Items Rate</li></ul><p>Profiler attach is now implemented using the same Event Pipe infrastructure.</p><p>See <a href="https://twitter.com/davidfowl/status/1135355693634949121" rel="nofollow" target="_blank">Playing with counters</a> from David Fowler to get an idea of what you can do with event pipe to perform your own performance investigations or just monitor application status.</p><p>See <a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md" target="_blank">dotnet-counters</a> to install the dotnet-counters tool.</p><h2>Optimize your .NET Core apps with ReadyToRun images</h2><p>You can improve the startup time of your .NET Core application by compiling your application assemblies as ReadyToRun (R2R) format. R2R is a form of ahead-of-time (AOT) compilation.</p><p>R2R binaries improve startup performance by reducing the amount of work the JIT needs to do as your application is loading. The binaries contain similar native code as what the JIT would produce, giving the JIT a bit of a vacation when performance matters most (at startup). R2R binaries are larger because they contain both intermediate language (IL) code, which is still needed for some scenarios, and the native version of the same code, to improve startup.</p><p>R2R is supported with .NET Core 3.0. It cannot be used with earlier versions of .NET Core.</p><h3>Sample performance numbers</h3><p>The following are performance numbers collected using a <a href="https://github.com/ridomin/msix-catalog" target="_blank">sample WPF application</a>. The application was published as self-contained and did not use the assembly linker (covered later this post).</p><p>IL-only Application:</p><ul><li>Startup time: 1.9 seconds</li><li>Memory usage: 69.1 MB</li><li>Application size: 150 MB</li></ul><p>With ReadyToRun images:</p><ul><li>Startup time: 1.3 seconds.</li><li>Memory usage: 55.7 MB</li><li>Application size: 156 MB</li></ul><h2>ReadyToRun images, explained</h2><p>You can R2R compile both libraries and application binaries. At present, libraries can only be R2R compiled as part of an application, not for delivery as a NuGet package. We’d like more feedback on whether that scenario is important.</p><p>AOT compiling assemblies has been available as a concept with .NET for a long time, going back to the <a href="https://docs.microsoft.com/dotnet/framework/tools/ngen-exe-native-image-generator" rel="nofollow" target="_blank">.NET Framework and NGEN</a>. NGEN has a key drawback, which is that compilation must be done on client machines, using the NGEN tool. It isn’t possible to generate NGEN images as part of your application build.</p><p>Enter .NET Core. It comes with <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/building/crossgen.md" target="_blank">crossgen</a>, which produces native images in a newer format called <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md" target="_blank">ReadyToRun</a>. The name describes its primary value proposition, which is that these native images can be built as part of your build and are “ready to run” without any additional work on client machines. That’s a major improvement, and also an important win for climate change.</p><p>In terms of compatibility, ReadyToRun images are similar to IL assemblies, with some key differences.</p><ul><li>IL assemblies contain just <a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language" rel="nofollow" target="_blank">IL code</a>. They can run on any runtime that supports the given target framework for that assembly. For example a <code>netstandard2.0</code> assembly can run on .NET Framework 4.6+ and .NET Core 2.0+, on any supported operating system (Windows, macOS, Linux) and architecture (Intel, ARM, 32-bit, 64-bit).</li><li>R2R assemblies contain IL and native code. They are compiled for a specific minimum .NET Core runtime version and runtime environment (RID). For example, a <code>netstandard2.0</code> assembly might be R2R compiled for .NET Core 3.0 and Linux x64. It will only be usable in that or a compatible configuration (like .NET Core 3.1 or .NET Core 5.0, on Linux x64), because it contains native code that is only usable in that runtime environment.</li></ul><h3>Instructions</h3><p>The ReadyToRun compilation is a publish-only, opt-in feature. We’ve released a preview version of it with .NET Core 3.0 Preview 5.</p><p>To enable the ReadyToRun compilation, you have to:</p><ul><li>Set the <code>PublishReadyToRun</code> property to <code>true</code>.</li><li>Publish using an explicit <code>RuntimeIdentifier</code>.</li></ul><p>Note: When the application assemblies get compiled, the native code produced is platform and architecture specific (which is why you have to specify a valid RuntimeIdentifier when publishing).</p><p>Here’s an example:</p><div><pre><span>&lt;Project</span><span> </span><span>Sdk</span><span>=</span><span>"Microsoft.NET.Sdk"</span><span>&gt;</span><span>
  </span><span>&lt;PropertyGroup&gt;</span><span>
    </span><span>&lt;OutputType&gt;</span><span>Exe</span><span>&lt;/OutputType&gt;</span><span>
    </span><span>&lt;TargetFramework&gt;</span><span>netcoreapp3.0</span><span>&lt;/TargetFramework&gt;</span><span>
    </span><span>&lt;PublishReadyToRun&gt;</span><span>true</span><span>&lt;/PublishReadyToRun&gt;</span><span>
  </span><span>&lt;/PropertyGroup&gt;</span><span>
</span><span>&lt;/Project&gt;</span></pre></div><p>And publish using the following command:</p><div><pre><span>dotnet publish </span><span>-</span><span>r win</span><span>-</span><span>x64 </span><span>-</span><span>c </span><span>Release</span></pre></div><p>Note: The <code>RuntimeIdentifier</code> can also be set in the project file.</p><p>Note: ReadyToRun is currently only supported for <a href="https://docs.microsoft.com/dotnet/core/deploying/" rel="nofollow" target="_blank">self-contained apps</a>. It will be enabled for <a href="https://docs.microsoft.com/dotnet/core/deploying/" rel="nofollow" target="_blank">framework-dependent apps</a> in a later preview.</p><p>Native symbol generation can be enabled by setting the <code>PublishReadyToRunEmitSymbols</code> property to <code>true</code> in your project. You do not need to generate native symbols for debugging purposes. These symbols are only useful for profiling purposes.</p><p>The SDK currently supports a way to exclude certain assemblies from being compiled into ReadyToRun images. This could be useful for cases when certain assemblies do not really need to be optimized for performance. This can help reduce the size of the application. It could also be a useful workaround for cases where the ReadyToRun compiler fails to compile a certain assembly. Exclusion is done using the PublishReadyToRunExclude item group. Example:</p><div><pre><span>&lt;ItemGroup&gt;</span><span>
  </span><span>&lt;PublishReadyToRunExclude</span><span> </span><span>Include</span><span>=</span><span>"FilenameOfAssemblyToExclude.dll"</span><span> </span><span>/&gt;</span><span>
</span><span>&lt;/ItemGroup&gt;</span></pre></div><h2>Cross platform/architecture compilations</h2><p>The ReadyToRun compiler doesn’t currently support cross-targeting. You need to compile on a given target. For example, if you want R2R images for Windows x64, you need to run the publish command on that environment.</p><p>Exceptions to this:</p><ul><li>Windows x64 can be used to compiles Windows ARM32, ARM64, and x86 images.</li><li>Windows x86 can be used to compile Windows ARM32 images.</li><li>Linux x64 can be used to compile Linux ARM32 and ARM64 images.</li></ul><h2>Assembly linking</h2><p>The .NET core 3.0 SDK comes with a tool that can reduce the size of apps by analyzing IL and trimming unused assemblies.</p><p>With .NET Core, it has always been possible to publish self-contained apps that include everything needed to run your code, without requiring .NET to be installed on the deployment target. In some cases, the app only requires a small subset of the framework to function and could potentially be made much smaller by including only the used libraries.</p><p>We use the <a href="https://github.com/mono/linker" target="_blank">IL linker</a> to scan the IL of your application to detect which code is actually required, and then trim unused framework libraries. This can significantly reduce the size of some apps. Typically, small tool-like console apps benefit the most as they tend to use fairly small subsets of the framework and are usually more amenable to trimming.</p><p>To use this tool, set <code>PublishTrimmed=true</code> in your project and publish a self-contained app:</p><pre><span>dotnet publish </span><span>-</span><span>r </span><span>&lt;rid&gt;</span><span> </span><span>-</span><span>c </span><span>Release</span></pre><p>The publish output will include a subset of the framework libraries, depending on what the application code calls. For a helloworld app, the linker reduces the size from ~68MB to ~28MB.</p><p>Applications or frameworks (including ASP.NET Core and WPF) that use reflection or related dynamic features will often break when trimmed, because the linker doesn’t know about this dynamic behavior and usually can’t determine which framework types will be required for reflection at run time. To trim such apps, you need to tell the linker about any types needed by reflection in your code, and in any packages or frameworks that you depend on. Be sure to test your apps after trimming.</p><p>For more information about the IL Linker, see the <a href="https://aka.ms/dotnet-illink" rel="nofollow" target="_blank">documentation</a>, or visit the <a href="https://github.com/mono/linker" target="_blank">mono/linker</a> repo.</p><p>Note: In previous versions of .NET Core, <a href="https://dotnet.myget.org/feed/dotnet-core/package/nuget/Illink.Tasks" rel="nofollow" target="_blank">ILLink.Tasks</a> was shipped as an external NuGet package and provided much of the same functionality. It is no longer supported – please update to the latest 3.0 SDK and try the new experience!</p><h2>Using the Linker and ReadyToRun Together</h2><p>The linker and ReadyToRun compiler can be used for the same application. In general, the linker makes your application smaller, and then the ready-to-run compiler will make it a bit larger again, but with a significant performance win. It is worth testing in various configurations to understand the impact of each option.</p><p>Note: <a href="https://github.com/dotnet/sdk/issues/3257" target="_blank">dotnet/sdk #3257</a> prevents the linker and ReadyToRun from being used together for WPF and Windows Forms applications. We are working on fixing that as part of the .NET Core 3.0 release.</p><h2>Native Hosting sample</h2><p>The team recently posted a <a href="https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr" target="_blank">Native Hosting sample</a>. It demonstrates a best practice approach for hosting .NET Core in a native application.</p><p>As part of .NET Core 3.0, we now expose general functionality to .NET Core native hosts that was previously only available to .NET Core managed applications through the officially provided .NET Core hosts. The functionality is primarily related to assembly loading. This functionality should make it easier to produce native hosts that can take advantage of the full feature set of .NET Core.</p><h2>HTTP/2 support in HttpClient</h2><p>HTTP/2 is a major revision of the HTTP protocol. Some of the notable features of HTTP/2 are support for header compression and fully multiplexed streams over the same connection. While HTTP/2 preserves HTTP’s semantics (HTTP headers, methods, etc) it is a change from HTTP/1.x in how data is framed and sent over the wire.</p><p><span><code>HttpClient</code></span>&nbsp;now add supports for making HTTP/2 requests. While the default remains HTTP/1.1, you can opt in to using HTTP/2 by setting the version on your HTTP request message.</p><pre><span>var</span><span> client </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>()</span><span> </span><span>{</span><span> </span><span>BaseAddress</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Uri</span><span>(</span><span>"https://localhost:5001"</span><span>)</span><span> </span><span>};</span><span>
</span><span>// HTTP/1.1 request</span><span>
</span><span>using</span><span> </span><span>(</span><span>var</span><span> response </span><span>=</span><span> await client</span><span>.</span><span>GetAsync</span><span>(</span><span>"/"</span><span>))</span><span>
</span><span>{</span><span>
    </span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>response</span><span>.</span><span>Content</span><span>);</span><span>
</span><span>}</span><span>
</span><span>// HTTP/2 request</span><span>
</span><span>using</span><span> </span><span>(</span><span>var</span><span> request </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpRequestMessage</span><span>(</span><span>HttpMethod</span><span>.</span><span>Get</span><span>,</span><span> </span><span>"/"</span><span>)</span><span> </span><span>{</span><span> </span><span>Version</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Version</span><span>(</span><span>2</span><span>,</span><span> </span><span>0</span><span>)</span><span> </span><span>})</span><span>
</span><span>using</span><span> </span><span>(</span><span>var</span><span> response </span><span>=</span><span> await client</span><span>.</span><span>SendAsync</span><span>(</span><span>request</span><span>))</span><span>
</span><span>{</span><span>
    </span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>response</span><span>.</span><span>Content</span><span>);</span><span>
</span><span>}</span></pre><p>Alternatively, you can default to sending HTTP/2 requests by setting the <span><code>DefaultRequestVersion</code></span> property on <span><code>HttpClient</code></span>.</p><pre><span>var</span><span> client </span><span>=</span><span> </span><span>new</span><span> </span><span>HttpClient</span><span>()</span><span>
</span><span>{</span><span>
    </span><span>BaseAddress</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Uri</span><span>(</span><span>"https://localhost:5001"</span><span>),</span><span>
    </span><span>DefaultRequestVersion</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Version</span><span>(</span><span>2</span><span>,</span><span> </span><span>0</span><span>)</span><span>
</span><span>};</span><span>
</span><span>// Defaults to HTTP/2</span><span>
</span><span>using</span><span> </span><span>(</span><span>var</span><span> response </span><span>=</span><span> await client</span><span>.</span><span>GetAsync</span><span>(</span><span>"/"</span><span>))</span><span>
</span><span>{</span><span>
    </span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>response</span><span>.</span><span>Content</span><span>);</span><span>
</span><span>}</span></pre><p>As a consequence of this change in framing, servers and clients need to negotiate the protocol version used. Application-Layer Protocol Negotiation (ALPN) is a TLS extension that allows the server and client negotiate the protocol version used as part of their TLS handshake. While it is possible to have prior knowledge between the server and the client on the protocol, most servers only support ALPN as the only way to establish an HTTP/2 connection. As such, HTTP/2 is negotiated by <span><code>HttpClient</code></span> only on a TLS connection.</p><p>In development scenarios when server and client have a priori knowledge that both will speak HTTP/2 unencrypted, you may establish an HTTP/2 connection over cleartext by setting an <span><code>AppContext</code></span> switch or an environment variable (<span><code>DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT=1</code></span>).</p><pre><span>AppContext</span><span>.</span><span>SetSwitch</span><span>(</span><span>"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span><span>,</span><span> </span><span>true</span><span>);</span></pre><h2>Closing</h2><p>Please try out the new features. Please file issues for the bugs or any challenging experiences you find. We want the feedback! You can file feature requests, too, but they likely will need to wait to get implemented until the next release at this point.</p><p>We are now getting very close to being feature complete for .NET Core 3.0, and are now transitioning the focus of the team to the quality of the release. We’ve got a few months of bug fixing and performance work ahead. We’ll appreciate your feedback as we work through that process, too.</p><p>On that note, we will soon be switching the <code>master</code> branches on .NET Core repos to the next major release, likely at or shortly after the Preview 7 release (July).</p><p>Thanks for trying out .NET Core 3.0 previews. We appreciate your help. At this point, we’re focused on getting a final release in your hands.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>