<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Jepsen: PostgreSQL 12.3 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Jepsen: PostgreSQL 12.3 - linksfor.dev(s)"/>
    <meta property="article:author" content="Kyle Kingsbury"/>
    <meta property="og:description" content="PostgreSQL is a widely-known relational database system. We evaluated PostgreSQL using Jepsen&#x2019;s new transactional isolation checker Elle, and found that transactions executed with serializable isolation on a single PostgreSQL instance were not, in fact, serializable. Under normal operation, transactions could occasionally exhibit G2-item: an anomaly involving a set of transactions which (roughly speaking) mutually fail to observe each other&#x2019;s writes. In addition, we found frequent instances of G2-item under PostgreSQL &#x201C;repeatable read&#x201D;, which is explicitly proscribed by commonly-cited formalizations of repeatable read. As previously reported by Martin Kleppmann, this is due to the fact that PostgreSQL &#x201C;repeatable read&#x201D; is actually snapshot isolation. This behavior is allowable due to long-discussed ambiguities in the ANSI SQL standard, but could be surprising for users familiar with the literature. A patch for the bug we found in serializability is scheduled for the next minor release, on August 13th, and the presence of G2-item under repeatable read could be readily addressed through documentation. This work was performed independently, without compensation, and conducted in accordance with the Jepsen ethics policy."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://jepsen.io/analyses/postgresql-12.3"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Jepsen: PostgreSQL 12.3</title>
<div class="readable">
        <h1>Jepsen: PostgreSQL 12.3</h1>
            <div>by Kyle Kingsbury</div>
            <div>Reading time: 20-25 minutes</div>
        <div>Posted here: 12 Jun 2020</div>
        <p><a href="http://jepsen.io/analyses/postgresql-12.3">http://jepsen.io/analyses/postgresql-12.3</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p><a href="https://www.postgresql.org/">PostgreSQL</a> is a widely-known relational database system. We evaluated PostgreSQL using Jepsen’s new transactional isolation checker <a href="https://github.com/jepsen-io/elle">Elle</a>, and found that transactions executed with serializable isolation on a single PostgreSQL instance were not, in fact, serializable. Under normal operation, transactions could occasionally exhibit G2-item: an anomaly involving a set of transactions which (roughly speaking) mutually fail to observe each other’s writes. In addition, we found frequent instances of G2-item under PostgreSQL “repeatable read”, which is explicitly proscribed by <a href="http://pmg.csail.mit.edu/papers/icde00.pdf">commonly-cited formalizations of repeatable read</a>. As previously reported by <a href="https://github.com/ept/hermitage">Martin Kleppmann</a>, this is due to the fact that PostgreSQL “repeatable read” is actually snapshot isolation. This behavior is allowable due to long-discussed ambiguities in the ANSI SQL standard, but could be surprising for users familiar with the literature. A patch for the bug we found in serializability is scheduled for the next minor release, on August 13th, and the presence of G2-item under repeatable read could be readily addressed through documentation. This work was performed independently, without compensation, and conducted in accordance with the <a href="https://jepsen.io/ethics.html">Jepsen ethics policy</a>.
  </p><article>
  <div>

<p><a href="https://www.postgresql.org/">PostgreSQL</a> is a major open-source relational database with a 23-year history and a broad range of features. While Jepsen’s work has traditionally focused on distributed systems, our tooling is readily applicable to traditional, single-node databases. In this report, we present the results of applying Jepsen’s generative concurrency testing to PostgreSQL 12.3.</p>
<p>Prior to version 9.1, <a href="https://www.postgresql.org/docs/9.0/transaction-iso.html">PostgreSQL’s documentation claimed</a> to offer up to <a href="https://jepsen.io/consistency/models/serializable">serializability</a>, “as if transactions had been executed one after another, serially, rather than concurrently…. The Serializable mode provides a rigorous guarantee that each transaction sees a wholly consistent view of the database.” However, this was not true: PostgreSQL’s “serializable” was in fact <a href="https://jepsen.io/consistency/models/snapshot-isolation">snapshot isolation</a> (SI).</p>
<p>Informally, snapshot isolated systems appear to start each transaction with a fixed, instantaneous snapshot of the database, reflecting only committed state. Writes performed in a transaction appear to apply atomically at commit time, and a transaction can only commit if no other transaction has modified the same objects as the transaction has written, since the snapshot was taken. This is (as <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">the paper which formalized snapshot isolation</a> made clear) not serializable: transactions whose write sets do not intersect can commit without observing each other’s effects, which could lead to application-level consistency violations.</p>
<p>In version 8.0, PostgreSQL’s documentation <a href="https://www.postgresql.org/docs/8.0/transaction-iso.html#XACT-SERIALIZABLE">clarified</a> that “in fact PostgreSQL’s Serializable mode does not guarantee serializable execution in this sense,” and went on to specify that PostgreSQL lacked a predicate locking system.</p>
<p><a href="https://www.postgresql.org/docs/9.1/release-9-1.html">In version 9.1</a>, PostgreSQL contributors Grittner and Ports <a href="https://drkp.net/papers/ssi-vldb12.pdf">added support for true serializability</a>, based on research by Cahill, Röhm, and Fekete into <a href="https://courses.cs.washington.edu/courses/cse444/08au/544M/READING-LIST/fekete-sigmod2008.pdf">serializable snapshot isolation</a> (SSI). In short, SSI extends SI by checking, at runtime, for a dependency relationship between transactions called a <em>dangerous structure</em>: a pair of adjacent read-write dependencies between three transactions. Preventing these dangerous structures, in addition to snapshot isolation’s normal rules, yields only serializable executions. For the last nine years, PostgreSQL’s “serializable” mode has justifiably <a href="https://www.postgresql.org/docs/12/transaction-iso.html">claimed to offer serializability</a>.</p>
<p>PostgreSQL’s “repeatable read” remains snapshot isolation, but the concurrency control documentation surprisingly <a href="https://www.postgresql.org/docs/12/transaction-iso.html#XACT-REPEATABLE-READ">does not mention the term</a>. Instead, it offers:</p>
<blockquote>
<p>The Repeatable Read isolation level only sees data committed before the transaction began; it never sees either uncommitted data or changes committed during transaction execution by concurrent transactions… This is a stronger guarantee than is required by the SQL standard for this isolation level, and prevents all of the phenomena described in Table 13.1 except for serialization anomalies. As mentioned above, this is specifically allowed by the standard, which only describes the minimum protections each isolation level must provide.</p>
</blockquote>
<p>“Serialization anomalies” is a somewhat ambiguous term: the documentation simply describes it as a result which is “inconsistent with all possible orderings of running those transactions one at a time”. To better understand what “serialization anomalies” specifically entail, we devised an experiment.</p>

<p>We designed a <a href="https://github.com/jepsen-io/jepsen/tree/master/stolon">test harness for PostgreSQL</a> using the <a href="https://github.com/jepsen-io/jepsen">Jepsen</a> testing library. Our test <a href="https://github.com/jepsen-io/jepsen/blob/3caa87c1c2537adf80878e9f356a0a841c52f8fc/stolon/src/jepsen/stolon/db.clj#L270-L292">installs PostgreSQL 12.3-1.pgdg100+1</a> (the current stable version) on a single Debian 10 node, or optionally connects to an existing PostgreSQL installation. We also evaluated versions 9.5.22, 10.13, and 11.8. Our test can kill PostgreSQL processes in random order to help measure crash safety, but our findings here do not require process crashes to reproduce. We used the default configuration provided by PostgreSQL’s official Debian packages with only minor changes (e.g.&nbsp;for binding network ports), and, during some tests, shortened autovacuum naptime and enabled more detailed logging.</p>
<p>Our test workload generates <a href="https://github.com/jepsen-io/jepsen/blob/master/stolon/src/jepsen/stolon/append.clj">randomized transactions of append and read operations</a> across an collection of list objects, chosen with exponential frequency. Each object is identified by a unique integer logical key. We store each object as a row in one of several tables, chosen by the hash of the key. Object keys are stored in two fields: a primary key <code>id</code>, and an unindexed secondary key <code>sk</code>, which we use to test access by table scans.<a href="#fn1" id="fnref1"><sup>1</sup></a> The value of each list is stored as a comma-separated <code>TEXT</code> column.</p>
<p>We append unique integer elements to a list identified by key (either via <code>id</code> or <code>sk</code>) using <code>INSERT ... ON CONFLICT DO UPDATE</code>, or, alternatively, via an update, checking to see if any rows were modified, then backing off to an insert, and if <em>that</em> failed, updating again. Reads return the current list of integers for a particular object, e.g.&nbsp;via <code>SELECT (val) FROM txn0 WHERE id = ?</code>.</p>
<p>Our test applies these transactions to PostgreSQL using the JDBC PostgreSQL driver (version 42.2.12), and analyzes the resulting history using the <a href="https://github.com/jepsen-io/elle">Elle</a> transaction isolation checker. Elle infers a transaction dependency graph over experimentally recorded histories, and searches for cycles (and non-cyclic anomalies) in that graph. This allows us to detect a broad range of anomalies from Adya, Liskov &amp; O’Neil’s <a href="http://pmg.csail.mit.edu/papers/icde00.pdf">Generalized Isolation Level Definitions</a>, including G0 (dirty write), G1a (aborted read), G1b (intermediate read), G1c (cyclic information flow), G-single (read skew), and G2-item (anti-dependency cycle). We also check for internal consistency, verifying that transactions observe values consistent with their own prior writes, duplicate effects, and garbage values (e.g. elements which were never written).</p>

<p>In most respects, PostgreSQL behaved as expected: both read uncommitted and read committed prevent write skew and aborted reads. We observed no internal consistency violations. However, we have two surprising results to report. The first is that PostgreSQL’s “repeatable read” is weaker than repeatable read, at least as defined by Berenson, Adya, Bailis, et al.&nbsp;This is not necessarily wrong: the ANSI SQL standard is ambiguous. The second result, which is <em>definitely</em> wrong, is that PostgreSQL’s “serializable” isolation level isn’t serializable: it allows G2-item during normal operation.</p>
<h2 id="repeatable-read"> Repeatable Read</h2>
<p>PostgreSQL’s “repeatable read” isolation level is actually snapshot isolation, and we observed no SI-violating anomalies when using “repeatable read”. In fact, the histories we recorded were consistent with <a href="http://www.vldb.org/conf/2006/p715-daudjee.pdf">strong snapshot isolation</a>, a stronger consistency model which prohibits stale reads and other realtime anomalies.</p>
<p>However, we observed numerous violations of repeatable read, as formally defined by Berenson, Adya, et al.&nbsp;For example, consider <a href="http://jepsen.io.s3.amazonaws.com/analyses/postgresql-12.3/20200609T133356.000-0400.zip">this history</a>, which produced roughly 140 anti-dependency cycles per minute. Here’s a short cycle from that history consisting of a trio of transactions—each of which appeared to execute before the next.</p>

<p>The top transaction begins by reading key 190, and finds the list <code>[1 2]</code>. The middle transaction appends 4 to key 190, resulting in the version <code>[1 2 4]</code>. Since that write overwrote the state that the top transaction read, we know that the middle transaction must have executed after the top transaction. We call this relationship an <em>anti-dependency</em>, and represent it as an edge labeled <code>rw</code>.</p>
<p>The middle transaction appended 5 to key 190, which was then visible to the bottom transaction’s read of <code>[1 2 4 5]</code>. This write-read dependency is represented by an edge labeled <code>wr</code>. However, the bottom transaction read key 188, and did <em>not</em> observe the top transaction’s append of 8. That anti-dependency implies the bottom transaction must have executed before the top transaction: a cycle!</p>
<p>This dependency cycle contains two anti-dependency edges, which makes it a G2 phenomenon in the language of <a href="http://pmg.csail.mit.edu/papers/icde00.pdf">Adya’s formalism</a>. Since all of these reads occurred when reading objects by their primary key<a href="#fn2" id="fnref2"><sup>2</sup></a>, it is also G2-item: a phenomenon expressly prohibited under Adya’s formalization of repeatable read. We believe this is one type of “serialization anomaly” referred to in the PostgreSQL documentation.</p>
<p>However, these anomalies <em>are</em> allowable under ANSI SQL’s definition of repeatable read, thanks to ambiguously worded plain-English definitions of prohibited phenomena. In fact, this ambiguity is part of what <em>prompted</em> Berenson, Bernstein et al.&nbsp;to write <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels</a>, and to formalize the definition of snapshot isolation in the first place. In that work, Berenson et al.&nbsp;develop two interpretations of the ANSI anomalies: one strict, and one broad. They argue that the strict interpretations fail to capture behaviors which are intuitively incorrect, and that ANSI <em>meant</em> to define the broad ones.</p>
<blockquote>
<p>Strict interpretations A1, A2, and A3 have unintended weaknesses. The correct interpretations are the Broad ones.</p>
</blockquote>
<p>Under the broad interpretations preferred by Berenson et al., snapshot isolation is <em>not comparable</em> with repeatable read: SI allows histories RR proscribes, and vice versa. Under the strict interpretation, SI is <em>stronger</em> than RR (indeed, SI is stronger than anomaly serializable!), and these G2-item anomalies are allowed under repeatable read.</p>
<p>Whether PostgreSQL’s repeatable-read behavior is correct therefore depends on one’s interpretation of the standard. It is surprising that a database based on snapshot isolation would reject the strict interpretation chosen by the seminal paper on SI, but on reflection, the behavior <em>is</em> defensible.</p>
<h2 id="serializable"> Serializable</h2>
<p>A more serious problem arose when we tested PostgreSQL’s serializable isolation level: it <em>also</em> exhibited G2-item under normal operation. In <a href="http://jepsen.io.s3.amazonaws.com/analyses/postgresql-12.3/20200609T161421.000-0400.zip">this two-minute test run</a>, Jepsen detected six cases of G2-item. For example, consider this pair of transactions, in which each failed to observe the other’s insert:</p>

<p>Alternatively, consider the following trio of transactions. The top transaction missed the middle transaction’s creation of key 1670, which <em>was</em> observed by the bottom, read-only transaction. However, that bottom transaction failed, in turn, to observe the first transaction’s creation of key 1671. Notably, the read-write transactions are serializable if taken by themselves. The read-only transaction is necessary for this cycle: it observes the effects of some, but not all, “logically prior” transactions.</p>

<p>Indeed, these dependency graphs correspond exactly to examples 1 (“Simple Write Skew”) and 2 (“Batch Processing”) from the PostgreSQL <a href="https://drkp.net/papers/ssi-vldb12.pdf">Serializable Snapshot Isolation paper</a>, shown below. Their SQL statements are different, of course—but like Example 1, our first cycle involves a pair of transactions which read one key and write another, each failing to observe the other’s effects; and our second involves a read-only transaction which precedes, via two adjacent rw anti-dependencies, a transaction which wrote state which the read-only transaction observed. These cycles are precisely what PostgreSQL’s SSI implementation is meant to prevent!</p>
<p><img src="http://jepsen.io/analyses/postgresql-12.3/ssi-examples.png" alt="Figure 3 from “Serializable Snapshot Isolation in PostgreSQL”, showing a pair of anomalous dependency graphs."><br>
</p>
<p>Every instance of G2-item we observed under serializable isolation involved at least one read-write conflict for a <em>freshly inserted row</em>. Cycles could involve rw anti-dependencies on updates to existing rows, but at least one insert appeared to be necessary.</p>
<p>Following a <a href="https://www.postgresql.org/message-id/flat/db7b729d-0226-d162-a126-8a8ab2dc4443%40jepsen.io">discussion with PostgreSQL contributors</a>, Peter Geoghegan identified <a href="https://www.postgresql.org/message-id/CAH2-Wzk%3D-gRrZP4mvsFeFN8VQDw2WNdS8AnJG8eX020Q7XSmMQ%40mail.gmail.com">the likely cause of this issue</a>: the conflict detection mechanism could, given three concurrent transactions, incorrectly identify an updating transaction’s transaction ID (XID) as responsible for <em>both</em> the original and updated versions of a tuple, rather than using the transaction ID which originally created the tuple. By flagging the wrong transaction as a potential conflict, it allowed a transaction to commit while failing to observe a prior transaction’s writes. Geoghegan, working with other members of the PostgreSQL community, has <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=5940ffb221316ab73e6fdc780dfe9a07d4221ebb">written a patch to flag the correct transaction ID</a>, and added a <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=blob;f=src/test/isolation/specs/update-conflict-out.spec;h=25c27d4ca6572ab5bdd99c099c86184b50817b26;hb=5940ffb221316ab73e6fdc780dfe9a07d4221ebb">regression test</a>. In their testing, this appears to resolve the issue.</p>
<p>This code <a href="https://www.postgresql.org/message-id/CAH2-Wzkk5CS2emjrftQXemjDVNkYSrUEXtHd-hoxBGsjSA01Ew%40mail.gmail.com">has gone essentially untouched</a> since the introduction of serializable snapshot isolation in 2011. Together, we confirmed that this bug was present in PostgreSQL 9.5.22, 10.13, 11.8, 12.3, and 13; we assume it is present in every extant version.</p>

<p>In our testing of PostgreSQL 12.3, transactions executed at read committed appeared correct: we never observed G0 (dirty write), G1a (aborted read), or G1b (intermediate read). PostgreSQL “repeatable read” appears consistent with strong snapshot isolation, but allows G2-item, which is prohibited in formalizations of repeatable read. However, this behavior could be interpreted as consistent with ANSI SQL repeatable read. Finally, PostgreSQL “serializable” allows G2-item under normal operation, due to a bug in the conflict detection mechanism. A <a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=5940ffb221316ab73e6fdc780dfe9a07d4221ebb">patch has been committed</a>, and this class of serializability violations should be resolved in the next minor release—presently scheduled for August 13th.</p>
<p>PostgreSQL has an <a href="https://github.com/postgres/postgres/tree/master/src/test/isolation">extensive suite of hand-picked examples</a>, called <code>isolationtester</code>, to verify concurrency safety. Moreover, independent testing, like Martin Kleppmann’s <a href="https://github.com/ept/hermitage/blob/master/postgres.md">Hermitage</a> has also confirmed that PostgreSQL’s serializable level prevents (at least some!) G2 anomalies. Why, then, did we immediately find G2-item with Jepsen? How has this bug persisted for so long?</p>
<p>PostgreSQL’s isolation tests, Hermitage, and most transactional Jepsen tests (prior to Elle) relied on executing a handful of cleverly constructed transactions with hand-proven invariants. For instance, <a href="https://github.com/postgres/postgres/blob/master/src/test/isolation/specs/serializable-parallel.spec">this isolationtester specification</a> verifies serializability by performing a sequence of transactions proposed by Fekete, O’Neil, &amp; O’Neil in <a href="https://www.cs.umb.edu/~poneil/ROAnom.pdf">A Read-Only Transaction Anomaly Under Snapshot Isolation</a>. Jepsen’s <a href="https://github.com/jepsen-io/jepsen/blob/master/jepsen/src/jepsen/tests/bank.clj">bank test</a> is based on a narrowly-defined class of transactions which preserves a total-balance invariant under snapshot isolation. Hermitage checks for G2-item by performing a pair of <a href="https://github.com/ept/hermitage/blob/master/postgres.md#write-skew-g2-item">symmetric read and update transactions</a>—which <em>does</em> successfully demonstrate G2-item under PostgreSQL “repeatable read”, but not under serializable.</p>
<p><a href="https://github.com/jepsen-io/elle">Elle</a>, however, is different: it allows us to generate a broad class of transactions, while still inferring strict properties over the resulting histories. This property-based approach allows us to catch unexpected behaviors that no one thought to explicitly test. In this case, it identified the possibility that concurrent updates and inserts could confuse the conflict-detection mechanism into misidentifying which transaction was responsible for a conflict.</p>
<p>That said, the list-append test we devised here verifies only a handful of SQL operations over a simple schema. Mature SQL databases like PostgreSQL are complex organisms with a myriad of interacting components and optimizations. Jepsen assumes that our tests exercise only a fraction of PostgreSQL’s possible behaviors.</p>
<p>As always, we note that Jepsen takes an experimental approach to safety verification: we can prove the presence of bugs, but not their absence. While we try hard to find problems, we cannot prove the correctness of any distributed system.</p>
<h2 id="recommendations"> Recommendations</h2>
<p>Users should be aware that PostgreSQL’s “repeatable read” is in fact snapshot isolation—a fact long-understood in the PostgreSQL community and previously reported by <a href="https://github.com/ept/hermitage">Kleppmann</a>. Since G2-item is prohibited under common formalizations of repeatable read, users may have designed applications assuming this held true for PostgreSQL. In this case, users may wish to run selected transactions under serializable isolation instead, add explicit locking, or redesign those transactions such that they are no longer sensitive to G2-item.</p>
<p>We recommend that the PostgreSQL team update their concurrency control documentation to resolve the ambiguity around “repeatable read”. The <a href="https://www.postgresql.org/docs/12/transaction-iso.html">current documentation</a> does not mention the term “snapshot isolation”—stating that PostgreSQL’s “repeatable read” actually means snapshot isolation would immediately clarify matters. The documentation could also provide clearer guidance to users by replacing the ambiguous “serialization anomaly” with G-single, G2-item, and G2; SI prohibits G-single but allows G2-item and G2.</p>
<p>As for whether snapshot isolation is stronger than repeatable read, one possible solution would be to adopt Berenson et al.’s definitions, and state that snapshot isolation is incomparable with repeatable read: SI allows some anomalies which are prohibited under RR (e.g.&nbsp;write skew), but RR allows other anomalies (e.g.&nbsp;phantoms) which are prohibited under SI. Doing so would bring PostgreSQL in line with a twenty-five year thread of scholarship on transactional isolation by <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">Berenson</a>, <a href="http://pmg.csail.mit.edu/papers/icde00.pdf">Adya</a>, <a href="https://www.vldb.org/pvldb/vol7/p181-bailis.pdf">Bailis</a>, et al.</p>
<p>However, as Ports &amp; Grittner note in their <a href="https://drkp.net/papers/ssi-vldb12.pdf">paper on PostgreSQL’s serializable snapshot isolation</a>, the ANSI specification <em>is</em> ambiguous, and the G2-item anomalies we observed do not necessarily violate the strict interpretation of the phenomena prohibited by repeatable read. In this case, we suggest that PostgreSQL explicitly state their choice of the strict, rather than broad, interpretation.</p>
<p>It appears that no version of PostgreSQL has ever guaranteed serializability. Users should be aware that concurrent update and insert transactions may exhibit G2-item. High-contention workloads are especially susceptible. The PostgreSQL team has written tests to reproduce the problem and is evaluating a patch; we recommend upgrading once the next minor release becomes available.</p>
<p>One final note: our testing suggests that PostgreSQL provides (or, in the case of serializability, will provide once the G2-item bug is resolved) <em>more</em> than snapshot isolation and serializability. Our histories appeared consistent with <em>strong</em> snapshot isolation and <em>strict</em> serializability, both of which ensure compatibility with a real-time order, in addition to preventing the usual dependency-graph anomalies. We are unsure if this is intentional, or whether it holds in all cases, but if so, PostgreSQL should feel free to claim these stronger consistency models!</p>
<h2 id="future-work"> Future Work</h2>
<p>PostgreSQL’s contributors are evaluating a patch to resolve the serializability violation we discovered, and writing clarifying documentation for snapshot isolation versus repeatable read.</p>
<p>Elle’s list-append workload is limited to reads and appends over datatypes which are isomorphic to lists. We have no way to test deletions, replacements, or other list operations: there could be latent issues in those codepaths. We have other workloads available for registers and sets, albeit supporting weaker inferences. Both could be implemented on PostgreSQL, which could help cover additional ground.</p>
<p>It seems unlikely that we can efficiently check, or even model, <em>all</em> functionality provided by modern SQL databases. Aggregations, subqueries, and stored procedures are in common use, and none are verifiable by our current approach. In particular, predicates are a key part of the SQL standard and have been encoded in Adya’s formalism—the representation of transactions which underpins Elle. We have thus far punted on how to represent, generate, and verify the correctness of transactions involving predicates. This means that Elle can only identify G2-item, not G2 in generality. We therefore cannot distinguish between repeatable read and serializable. This seems the most promising avenue for future research.</p>
<p><em>This work was performed independently, without compensation, and conducted in accordance with the <a href="https://jepsen.io/ethics.html">Jepsen ethics policy</a>. This work would not have been possible without the kind assistance of PostgreSQL contributors Andres Freund, Peter Geoghegan, Félix Gerzaguet, Thomas Munro, and Daniel Verite. Jepsen also wishes to thank C. Scott Andreas, André Arko, Silvia Botros, Lita Cho, Peter Geoghegan, Félix Gerzaguet, Alex Rasmussen, and James Turnbull for their feedback on early drafts. Kevin Cox and Frank McSherry offered suggestions on the published report.</em></p>
<section>
<hr>
<ol>
<li id="fn1"><p>Neither process crashes, multiple tables, nor secondary-key access is required to reproduce our findings in this report. The technical justification for including them in this workload is “for funsies”.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Our tests support updates and reads both by primary key and by secondary key: a predicate read. This type of anomaly occurs in both contexts.<a href="#fnref2">↩</a></p></li>
</ol>
</section>
  </div>
</article></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>