<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Performance traps of ref locals and ref returns in C# | Premier Developer - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Performance traps of ref locals and ref returns in C# | Premier Developer - linksfor.dev(s)"/>
    <meta property="article:author" content="Sergey TepliakovSenior Software Engineer,&#xA0;Tools for Software EngineersFollow Sergey"/>
    <meta property="og:description" content="The C# language from the very first version supported passing arguments by value or by reference. But before C# 7 the C# compiler supported only one way of returning a value from a method (or a property) &#x2013; returning by value."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/premier-developer/performance-traps-of-ref-locals-and-ref-returns-in-c/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Performance traps of ref locals and ref returns in C# | Premier Developer</title>
<div class="readable">
        <h1>Performance traps of ref locals and ref returns in C# | Premier Developer</h1>
            <div>by Sergey TepliakovSenior Software Engineer,&#xA0;Tools for Software EngineersFollow Sergey</div>
            <div>Reading time: 12-15 minutes</div>
        <div>Posted here: 14 Feb 2020</div>
        <p><a href="https://devblogs.microsoft.com/premier-developer/performance-traps-of-ref-locals-and-ref-returns-in-c/">https://devblogs.microsoft.com/premier-developer/performance-traps-of-ref-locals-and-ref-returns-in-c/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://devblogs.microsoft.com/premier-developer/wp-content/uploads/sites/31/2019/06/Sergey-Tepliakov-150x150.jpg" width="58" height="58" alt="Sergey Tepliakov"></p><p>Sergey</p></div></div></div><p>April 11th, 2018</p><p>The C# language from the very first version supported passing arguments by value or by reference. But before C# 7 the C# compiler supported only one way of returning a value from a method (or a property) – returning by value. This has been changed in C# 7 with two new features: ref returns and ref locals.</p><p>But unlike other features that were recently added to the C# language I’ve found these two a bit more controversial than the others.</p><h4>The motivation</h4><p>There are many differences between the arrays and other collections from the CLR perspectives. The arrays were added to the CLR from the very beginning and you can think of them as of built-in generics. The CLR and the JIT-compiler are aware of the arrays but besides that, they’re special in one more aspect: <strong>the indexer of the array returns the element by reference, not by value</strong>.</p><p>To demonstrate this behavior we have to go to the dark side — use a mutable value type:</p><div id="crayon-5e3d7b82f3a85872731900" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"><div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p></div></td><td><div><p><span>public</span><span> </span><span>struct</span><span> </span><span>Mutable</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>int</span><span> </span><span>_x</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>Mutable</span><span>(</span><span>int</span><span> </span><span>x</span><span>)</span><span> </span>=<span>&gt;</span><span> </span><span>_x</span><span> </span>=<span> </span><span>x</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>X</span><span> </span>=<span>&gt;</span><span> </span><span>_x</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>void</span><span> </span><span>IncrementX</span><span>(</span><span>)</span><span> </span><span>{</span><span> </span><span>_x</span>++<span>;</span><span> </span><span>}</span></p><p><span>}</span></p><p><span>[</span><span>Test</span><span>]</span></p><p><span>public</span><span> </span><span>void</span><span> </span><span>CheckMutability</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>var</span><span> </span><span>ma</span><span> </span>=<span> </span><span>new</span><span>[</span><span>]</span><span> </span><span>{</span><span>new</span><span> </span><span>Mutable</span><span>(</span><span>1</span><span>)</span><span>}</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>ma</span><span>[</span><span>0</span><span>]</span><span>.</span><span>IncrementX</span><span>(</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// X has been changed!</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Assert</span><span>.</span><span>That</span><span>(</span><span>ma</span><span>[</span><span>0</span><span>]</span><span>.</span><span>X</span><span>,</span><span> </span><span>Is</span><span>.</span><span>EqualTo</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>var</span><span> </span><span>ml</span><span> </span>=<span> </span><span>new</span><span> </span><span>List</span><span>&lt;</span><span>Mutable</span><span>&gt;</span><span> </span><span>{</span><span>new</span><span> </span><span>Mutable</span><span>(</span><span>1</span><span>)</span><span>}</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>ml</span><span>[</span><span>0</span><span>]</span><span>.</span><span>IncrementX</span><span>(</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// X hasn't been changed!</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Assert</span><span>.</span><span>That</span><span>(</span><span>ml</span><span>[</span><span>0</span><span>]</span><span>.</span><span>X</span><span>,</span><span> </span><span>Is</span><span>.</span><span>EqualTo</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div><p>The test will pass because the indexer of the array is quite different from the indexer of the <code>List&lt;T&gt;</code>.</p><p>The C# compiler emits a special instruction for the arrays indexer – <a href="https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes.ldelema(v=vs.110).aspx" target="_blank"><code>ldelema</code></a> that returns a managed reference to a given array’s element. Basically, array indexer returns an element by reference. But <code>List&lt;T&gt;</code> can’t have the same behavior because it wasn’t possible (*) to return an alias to the internal state in C#. That’s why the <code>List&lt;T&gt;</code> indexer returns the element by value, i.e. returning the copy of the given element.</p><p>(*) As we’ll see in a moment, it is still impossible for the <code>List&lt;T&gt;</code>‘s indexer to return an element by reference.</p><p>This means that <code>ma[0].IncrementX()</code> calls a mutation method on the first element inside of the array, but <code>ml[0].IncrementX()</code> calls a mutation method on a copy, keeping the original list unchanged.</p><h4>Ref locals and ref returns 101</h4><p>The basic idea behind these features is very simple: <code>ref return</code>allows to return an alias to an existing variable and ref local can store the alias in a local variable.</p><ol><li>Simple example</li></ol><div id="crayon-5e3d7b82f3a9b946850626" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>[</span><span>Test</span><span>]</span></p><p><span>public</span><span> </span><span>void</span><span> </span><span>RefLocalsAndRefReturnsBasics</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>int</span><span>[</span><span>]</span><span> </span><span>array</span><span> </span>=<span> </span><span>{</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span> </span><span>}</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Capture an alias to the first element into a local</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>ref </span><span>int</span><span> </span><span>first</span><span> </span>=<span> </span><span>ref </span><span>array</span><span>[</span><span>0</span><span>]</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>first</span><span> </span>=<span> </span><span>42</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Assert</span><span>.</span><span>That</span><span>(</span><span>array</span><span>[</span><span>0</span><span>]</span><span>,</span><span> </span><span>Is</span><span>.</span><span>EqualTo</span><span>(</span><span>42</span><span>)</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Local function that returns the first element by ref</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>ref </span><span>int</span><span> </span><span>GetByRef</span><span>(</span><span>int</span><span>[</span><span>]</span><span> </span><span>a</span><span>)</span><span> </span>=<span>&gt;</span><span> </span><span>ref</span><span> </span><span>a</span><span>[</span><span>0</span><span>]</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Weird syntax: the result of a function call is assignable</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>GetByRef</span><span>(</span><span>array</span><span>)</span><span> </span>=<span> </span>-<span>1</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Assert</span><span>.</span><span>That</span><span>(</span><span>array</span><span>[</span><span>0</span><span>]</span><span>,</span><span> </span><span>Is</span><span>.</span><span>EqualTo</span><span>(</span>-<span>1</span><span>)</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div><ol start="2"><li>Ref returns and readonly ref returns</li></ol><p>Ref returns can return an alias to instance fields and starting from C# 7.2 you can return a readonly alias using <code>ref readonly</code>:</p><div id="crayon-5e3d7b82f3aa9207225483" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"><div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p></div></td><td><div><p><span>class</span><span> </span><span>EncapsulationWentWrong</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>readonly </span><span>Guid </span><span>_guid</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>int</span><span> </span><span>_x</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>EncapsulationWentWrong</span><span>(</span><span>int</span><span> </span><span>x</span><span>)</span><span> </span>=<span>&gt;</span><span> </span><span>_x</span><span> </span>=<span> </span><span>x</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Return an alias to the private field. No encapsulation any more.</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>ref </span><span>int</span><span> </span><span>X</span><span> </span>=<span>&gt;</span><span> </span><span>ref </span><span>_x</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Return a readonly alias to the private field.</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>ref </span><span>readonly </span><span>Guid </span><span>Guid</span><span> </span>=<span>&gt;</span><span> </span><span>ref </span><span>_guid</span><span>;</span></p><p><span>}</span></p><p><span>[</span><span>Test</span><span>]</span></p><p><span>public</span><span> </span><span>void</span><span> </span><span>NoEncapsulation</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>var</span><span> </span><span>instance</span><span> </span>=<span> </span><span>new</span><span> </span><span>EncapsulationWentWrong</span><span>(</span><span>42</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>instance</span><span>.</span><span>X</span>++<span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Assert</span><span>.</span><span>That</span><span>(</span><span>instance</span><span>.</span><span>X</span><span>,</span><span> </span><span>Is</span><span>.</span><span>EqualTo</span><span>(</span><span>43</span><span>)</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Cannot assign to property 'EncapsulationWentWrong.Guid' because it is a readonly variable</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// instance.Guid = Guid.Empty;</span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div><ul><li>Methods and properties could return an “alias” to an internal state. <strong>The property, in this case, could not have a setter.</strong></li><li>Return by reference breaks the encapsulation because the client obtains the full control over the object’s internal state.</li><li>Returning by readonly reference avoids a redundant copy for value types but prevents the client from mutating the internal state.</li><li>You may use ref readonly for reference types even though it makes no sense for non-generic cases.</li></ul><ol start="3"><li>Existing restrictions Returning an alias could be dangerous: using an alias to a stack-allocated variable after a method is finished will crash the app. To make the feature safe, the C# compiler enforces various restrictions:</li></ol><ul><li>You can not return a reference to a local variable.</li><li>You can not return a reference to <code>this</code> in structs.</li><li>You can return a reference to heap-allocated variable (like class members).</li><li>You can return a reference to ref/out parameters.</li></ul><p>For more information see an amazing post <a href="http://mustoverride.com/safe-to-return/" target="_blank">Safe to return rules for ref returns</a> by Vladimir Sadov, the author of this feature in the C# compiler.</p><p>Now, once we know what these features are, let’s see when they can be useful.</p><h4>Using ref returns for indexers</h4><p>To test the performance impact of these features we’re going to create a custom immutable collection called <code>NaiveImmutableList&lt;T&gt;</code> and will compare it with the <code>T[]</code> and the <code>List&lt;T&gt;</code> for structs of different sizes (4, 16, 32 and 48).</p><div id="crayon-5e3d7b82f3ab6097918992" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"><div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p></div></td><td><div><p><span>public</span><span> </span><span>class</span><span> </span><span>NaiveImmutableList</span><span>&lt;</span><span>T</span><span>&gt;</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>readonly </span><span>int</span><span> </span><span>_length</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>readonly</span><span> </span><span>T</span><span>[</span><span>]</span><span> </span><span>_data</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>NaiveImmutableList</span><span>(</span><span>params</span><span> </span><span>T</span><span>[</span><span>]</span><span> </span><span>data</span><span>)</span><span> </span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>=<span>&gt;</span><span> </span><span>(</span><span>_data</span><span>,</span><span> </span><span>_length</span><span>)</span><span> </span>=<span> </span><span>(</span><span>data</span><span>,</span><span> </span><span>data</span><span>.</span><span>Length</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>ref </span><span>readonly</span><span> </span><span>T</span><span> </span><span>this</span><span>[</span><span>int</span><span> </span><span>idx</span><span>]</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// R# 2017.3.2 is completely confused with this syntax!</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// =&gt; ref (idx &gt;= _length ? ref Throw() : ref _data[idx]);</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>get</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Extracting 'throw' statement into a different</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// method helps the jitter to inline a property access.</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>if</span><span> </span><span>(</span><span>(</span><span>uint</span><span>)</span><span>idx</span><span> </span><span>&gt;</span>=<span> </span><span>(</span><span>uint</span><span>)</span><span>_length</span><span>)</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>ThrowIndexOutOfRangeException</span><span>(</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>ref </span><span>_data</span><span>[</span><span>idx</span><span>]</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>static</span><span> </span><span>void</span><span> </span><span>ThrowIndexOutOfRangeException</span><span>(</span><span>)</span><span> </span>=<span>&gt;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>throw</span><span> </span><span>new</span><span> </span><span>IndexOutOfRangeException</span><span>(</span><span>)</span><span>;</span></p><p><span>}</span></p><p><span>struct</span><span> </span><span>LargeStruct_48</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>N</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>}</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>private</span><span> </span><span>readonly </span><span>long</span><span> </span><span>l1</span><span>,</span><span> </span><span>l2</span><span>,</span><span> </span><span>l3</span><span>,</span><span> </span><span>l4</span><span>,</span><span> </span><span>l5</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>LargeStruct_48</span><span>(</span><span>int</span><span> </span><span>n</span><span>)</span><span> </span><span>:</span><span> </span><span>this</span><span>(</span><span>)</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>=<span>&gt;</span><span> </span><span>N</span><span> </span>=<span> </span><span>n</span><span>;</span></p><p><span>}</span></p><p><span>// Other structs like LargeStruct_16, LargeStruct_32 etc</span></p></div></td></tr></tbody></table></div></div><p>The benchmarks iterate over the collections and sum all the <code>N</code>property values for each elements:</p><div id="crayon-5e3d7b82f3ac3056455497" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"><div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p></div></td><td><div><p><span>private</span><span> </span><span>const</span><span> </span><span>int</span><span> </span><span>elementsCount</span><span> </span>=<span> </span><span>100_000</span><span>;</span></p><p><span>private</span><span> </span><span>static</span><span> </span><span>LargeStruct_48</span><span>[</span><span>]</span><span> </span><span>CreateArray_48</span><span>(</span><span>)</span><span> </span>=<span>&gt;</span><span> </span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Enumerable</span><span>.</span><span>Range</span><span>(</span><span>1</span><span>,</span><span> </span><span>elementsCount</span><span>)</span><span>.</span><span>Select</span><span>(</span><span>v</span><span> </span>=<span>&gt;</span><span> </span><span>new</span><span> </span><span>LargeStruct_48</span><span>(</span><span>v</span><span>)</span><span>)</span><span>.</span><span>ToArray</span><span>(</span><span>)</span><span>;</span></p><p><span>private</span><span> </span><span>readonly </span><span>LargeStruct_48</span><span>[</span><span>]</span><span> </span><span>_array48</span><span> </span>=<span> </span><span>CreateArray_48</span><span>(</span><span>)</span><span>;</span></p><p><span>[</span><span>BenchmarkCategory</span><span>(</span><span>"BigStruct_48"</span><span>)</span><span>]</span></p><p><span>[</span><span>Benchmark</span><span>(</span><span>Baseline</span><span> </span>=<span> </span><span>true</span><span>)</span><span>]</span></p><p><span>public</span><span> </span><span>int</span><span> </span><span>TestArray_48</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>int</span><span> </span><span>result</span><span> </span>=<span> </span><span>0</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Using elementsCound but not array.Length to force the bounds check</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// on each iteration.</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span>=<span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>elementsCount</span><span>;</span><span> </span><span>i</span>++<span>)</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>result</span><span> </span>=<span> </span><span>_array48</span><span>[</span><span>i</span><span>]</span><span>.</span><span>N</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>}</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>result</span><span>;</span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div><p>And here the results:</p><div id="crayon-5e3d7b82f3ad0413256890" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>Method</span><span> </span><span>|</span><span> </span><span>Mean</span><span> </span><span>|</span><span> </span><span>Scaled</span><span> </span><span>|</span><span> </span>--------------------------<span> </span><span>|</span>---------<span>:</span><span>|</span>-------<span>:</span><span>|</span><span> </span></p><p><span>TestArray_48</span><span> </span><span>|</span><span> </span><span>258.3</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.00</span><span> </span><span>|</span><span> </span></p><p><span>TestListOfT_48</span><span> </span><span>|</span><span> </span><span>488.9</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.89</span><span> </span><span>|</span><span> </span></p><p><span>TestNaiveImmutableList_48</span><span> </span><span>|</span><span> </span><span>444.8</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.72</span><span> </span><span>|</span><span> </span></p><p><span>|</span><span> </span><span>|</span><span> </span><span>|</span><span> </span></p><p><span>TestArray_32</span><span> </span><span>|</span><span> </span><span>174.4</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.00</span><span> </span><span>|</span><span> </span></p><p><span>TestListOfT_32</span><span> </span><span>|</span><span> </span><span>233.8</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.34</span><span> </span><span>|</span><span> </span></p><p><span>TestNaiveImmutableList_32</span><span> </span><span>|</span><span> </span><span>219.2</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.26</span><span> </span><span>|</span><span> </span></p><p><span>|</span><span> </span><span>|</span><span> </span><span>|</span><span> </span></p><p><span>TestArray_16</span><span> </span><span>|</span><span> </span><span>143.7</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.00</span><span> </span><span>|</span><span> </span></p><p><span>TestListOfT16</span><span> </span><span>|</span><span> </span><span>192.5</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.34</span><span> </span><span>|</span><span> </span></p><p><span>TestNaiveImmutableList16</span><span> </span><span>|</span><span> </span><span>167.8</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.17</span><span> </span><span>|</span><span> </span></p><p><span>|</span><span> </span><span>|</span><span> </span><span>|</span><span> </span></p><p><span>TestArray_4</span><span> </span><span>|</span><span> </span><span>121.7</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.00</span><span> </span><span>|</span><span> </span></p><p><span>TestListOfT_4</span><span> </span><span>|</span><span> </span><span>174.7</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.44</span><span> </span><span>|</span><span> </span></p><p><span>TestNaiveImmutableList_4</span><span> </span><span>|</span><span> </span><span>133.1</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.09</span><span> </span><span>|</span></p></div></td></tr></tbody></table></div></div><p>Apparently, something is wrong! Our <code>NaiveImmutableList&lt;T&gt;</code>has effectively the same performance characteristics as <code>List&lt;T&gt;</code>. What happened?</p><h4>Readonly ref returns under the hood</h4><p>As you may noticed, the indexer of <code>NaiveImmutableList&lt;T&gt;</code>returns a readonly reference via <code>ref readonly</code>. This makes perfect sense because we want to restrict our clients from mutating the underlying state of the immutable collection. But the structs we’ve been using in our benchmarks are regular non-readonly structs.</p><p>The following test will help us understand the underlying behavior:</p><div id="crayon-5e3d7b82f3ae4940652656" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>[</span><span>Test</span><span>]</span></p><p><span>public</span><span> </span><span>void</span><span> </span><span>CheckMutabilityForNaiveImmutableList</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>var</span><span> </span><span>ml</span><span> </span>=<span> </span><span>new</span><span> </span><span>NaiveImmutableList</span><span>&lt;</span><span>Mutable</span><span>&gt;</span><span>(</span><span>new</span><span> </span><span>Mutable</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>ml</span><span>[</span><span>0</span><span>]</span><span>.</span><span>IncrementX</span><span>(</span><span>)</span><span>;</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// X has been changed, right?</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Assert</span><span>.</span><span>That</span><span>(</span><span>ml</span><span>[</span><span>0</span><span>]</span><span>.</span><span>X</span><span>,</span><span> </span><span>Is</span><span>.</span><span>EqualTo</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div><p>The test fails! Why? Because “readonly references” are similar to <code>in</code>-modifiers and <code>readonly</code> fields in respect to structs: the compiler emits a defensive copy every time a struct member is used. It means that <code>ml[0].</code> still creates a copy of the first element but not by the indexer: the copy is created in the call site.</p><p>In fact, the behavior is very reasonable. The C# compiler supports passing arguments by value, by reference, and by “readonly reference” using <code>in</code>-modifier (for more details see my post <a href="https://blogs.msdn.microsoft.com/seteplia/2018/03/07/the-in-modifier-and-the-readonly-structs-in-c/" target="_blank">The <code>in</code>-modifier and the readonly structs in C#</a>). And now the compiler supports 3 different ways of returning a value from a method: by value, by reference and by readonly reference.</p><p>“Readonly references” are so similar, that the compiler reuses the same <code>InAttribute</code> to distinguish readonly and non-readonly return values:</p><div id="crayon-5e3d7b82f3af5802893443" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>private</span><span> </span><span>int</span><span> </span><span>_n</span><span>;</span></p><p><span>public</span><span> </span><span>ref </span><span>readonly </span><span>int</span><span> </span><span>ByReadonlyRef</span><span>(</span><span>)</span><span> </span>=<span>&gt;</span><span> </span><span>ref </span><span>_n</span><span>;</span></p></div></td></tr></tbody></table></div></div><p>In this case the method <code>ByReadonlyRef</code> is effectively compiled to:</p><div id="crayon-5e3d7b82f3b01865290765" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>[</span><span>InAttribute</span><span>]</span></p><p><span>[</span><span>return</span><span>:</span><span> </span><span>IsReadOnly</span><span>]</span></p><p><span>public</span><span> </span><span>int</span>*<span> </span><span>ByReadonlyRef</span><span>(</span><span>)</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>return</span><span> </span><span>ref </span><span>this</span><span>.</span><span>_n</span><span>;</span></p><p><span>}</span></p></div></td></tr></tbody></table></div></div><p>The similarity between <code>in</code>-modifier and readonly references means that these features are not friendly to regular structs and could cause performance issues. Here is an example:</p><div id="crayon-5e3d7b82f3b0e980916776" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"></td><td><div><p><span>public</span><span> </span><span>struct</span><span> </span><span>BigStruct</span></p><p><span>{</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>// Other fields</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>X</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>}</span></p><p><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>public</span><span> </span><span>int</span><span> </span><span>Y</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>}</span></p><p><span>}</span></p><p><span>private</span><span> </span><span>BigStruct </span><span>_bigStruct</span><span>;</span></p><p><span>public</span><span> </span><span>ref </span><span>readonly </span><span>BigStruct </span><span>GetBigStructByRef</span><span>(</span><span>)</span><span> </span>=<span>&gt;</span><span> </span><span>ref </span><span>_bigStruct</span><span>;</span></p><p><span>ref </span><span>readonly </span><span>var</span><span> </span><span>bigStruct</span><span> </span>=<span> </span><span>ref </span><span>GetBigStructByRef</span><span>(</span><span>)</span><span>;</span></p><p><span>int</span><span> </span><span>result</span><span> </span>=<span> </span><span>bigStruct</span><span>.</span><span>X</span><span> </span>+<span> </span><span>bigStruct</span><span>.</span><span>Y</span><span>;</span></p></div></td></tr></tbody></table></div></div><p>Besides a weird syntax of variable declaration for <code>bigStruct</code> the code looks good. The intent is clear: <code>BigStruct</code> is returned by reference for performance reasons. Unfortunately, because <code>BigStruct</code> is a non-readonly struct, each time a member is accessed, the defensive copy is created.</p><h4>Using ref returns for indexers. Attempt #2</h4><p>Let’s try the same set of benchmarks with <strong>readonly structs</strong> of different sizes:</p><div id="crayon-5e3d7b82f3b1a222182678" data-settings=" touchscreen minimize scroll-mouseover wrap"><div><table><tbody><tr><td data-settings="hide"><div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p></div></td><td><div><p><span>Method</span><span> </span><span>|</span><span> </span><span>Mean</span><span> </span><span>|</span><span> </span><span>Scaled</span><span> </span><span>|</span><span> </span></p><p>--------------------------<span> </span><span>|</span>---------<span>:</span><span>|</span>-------<span>:</span><span>|</span><span> </span></p><p><span>TestArray_48</span><span> </span><span>|</span><span> </span><span>265.1</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.00</span><span> </span><span>|</span><span> </span></p><p><span>TestListOfT_48</span><span> </span><span>|</span><span> </span><span>490.6</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.85</span><span> </span><span>|</span><span> </span></p><p><span>TestNaiveImmutableList_48</span><span> </span><span>|</span><span> </span><span>300.6</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.13</span><span> </span><span>|</span><span> </span></p><p><span>|</span><span> </span><span>|</span><span> </span><span>|</span><span> </span></p><p><span>TestArray_32</span><span> </span><span>|</span><span> </span><span>177.8</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.00</span><span> </span><span>|</span><span> </span></p><p><span>TestListOfT_32</span><span> </span><span>|</span><span> </span><span>233.4</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.31</span><span> </span><span>|</span><span> </span></p><p><span>TestNaiveImmutableList_32</span><span> </span><span>|</span><span> </span><span>218.0</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.23</span><span> </span><span>|</span><span> </span></p><p><span>|</span><span> </span><span>|</span><span> </span><span>|</span><span> </span></p><p><span>TestArray_16</span><span> </span><span>|</span><span> </span><span>144.7</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.00</span><span> </span><span>|</span><span> </span></p><p><span>TestListOfT16</span><span> </span><span>|</span><span> </span><span>191.8</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.33</span><span> </span><span>|</span><span> </span></p><p><span>TestNaiveImmutableList16</span><span> </span><span>|</span><span> </span><span>168.8</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.17</span><span> </span><span>|</span><span> </span></p><p><span>|</span><span> </span><span>|</span><span> </span><span>|</span><span> </span></p><p><span>TestArray_4</span><span> </span><span>|</span><span> </span><span>121.3</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.00</span><span> </span><span>|</span><span> </span></p><p><span>TestListOfT_4</span><span> </span><span>|</span><span> </span><span>178.9</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.48</span><span> </span><span>|</span><span> </span></p><p><span>TestNaiveImmutableList_4</span><span> </span><span>|</span><span> </span><span>145.3</span><span> </span><span>us</span><span> </span><span>|</span><span> </span><span>1.20</span><span> </span><span>|</span></p></div></td></tr></tbody></table></div></div><p>Now the results make much more sense. The time still grows for bigger structs, but that is expected because iterating over 100K structs of bigger size take a longer amount of time. But now the timings for <code>NaiveimmutableList&lt;T&gt;</code> is very close to <code>T[]</code> and reasonably faster than <code>List&lt;T&gt;</code>.</p><h4>Conclusion</h4><ul><li>Be cautious with ref returns because they can break encapsulation.</li><li>Be cautious with readonly ref returns because they’re more performant only for readonly structs and could cause performance issues for regular structs.</li><li>Be cautious with readonly ref locals because they also could cause performance issues for non-readonly structs causing defensive copy each time the variable is used.</li></ul><p>Ref locals and ref returns are useful features for library authors and developers working on infrastructure code. But in the case of library code, these features are quite dangerous: in order to use a collection that returns elements by readonly reference efficiently every library user should know the implications: readonly reference for a non-readonly struct causes a defensive copy “at the call site”. This can negate all performance gains at best, or can cause severe perf degradation when a readonly ref local variable is accessed multiple times.</p><p>P.S. Readonly references are coming to the BCL. The following PR for corefx repo (<a href="https://github.com/dotnet/corefx/pull/25738/files#diff-fa508ecac55e620b269a8853de2cfd66" target="_blank">Implementing ItemRef API Proposal</a>) introduced readonly ref methods to access the elements of immutable collections. So it is quite important for everyone to understand the implication of these features and to understand how to to use it and when to use it.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>