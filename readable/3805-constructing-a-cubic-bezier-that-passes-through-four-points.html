<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Constructing a cubic Bezier that passes through four points -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Constructing a cubic Bezier that passes through four points</h1><div><div id="" class=""><title>Constructing a cubic Bezier that passes through four points</title><p class="subtitle">1-Feb-2019</p><section><p><label for="mn-1" class="margin-toggle">⊕</label><input type="checkbox" id="mn-1" class="margin-toggle"><span class="marginnote">Drag any point \(\{P_0, P_1, P_2, P_3\}\) to refit the spline, or drag either tangent \(\{T_0, T_1\}\) to manually change the spline.</span></p><figure><p></p><p><input type="range" min="0" max="1" value="0.5" step="0.01" class="slider" id="slider" oninput="slider_on_input()">
    \(\alpha =\)
    <span id="lbl_alpha"></span></p></figure></section><section><p>Bezier curves are extremely useful constructs that allow users to intuitively create smooth curves by adjusting end points and tangents. Mathematically, they are polynomials. In this article, we'll focus on the most popular variant—the cubic Bezier curve.</p><p>Most applications have composite Bezier curves, i.e. curves constructed by chaining together multiple polynomials. The diagram above consists of three curves. For most of this article, we'll focus on the middle curve one going from \(P_1\) to \(P_2\). This curve is defined by the four points \(\{P_1, T_1, T_2, P_2\}\), given by the parametric equation:

    \[bezier(t) = \color{blue}{P_1} \cdot (1-t)^3 + \color{blue}{T_1} \cdot 3 \cdot (1-t)^2 \cdot t + \color{blue}{T_2} \cdot 3 \cdot (1-t) \cdot t^2 + \color{blue}{P_2} \cdot t^3\]</p><p>
        The other two curves are defined by their respective end points, and their tangents which are omitted from the diagram. I won't go into too much Bezier math theory.<input type="checkbox" id="sn-1" class="margin-toggle"></p><p>It is very useful to edit the curve using its tangent points, and most spline tools support this. However, it is also very useful to just drag/create points and make the curve automatically fit them. Very few applications support this use case.</p><p>Bezier curves' formulation doesn't describe the curve in terms of four points it needs to pass through. They describe the curve in terms of two end points and two tangent points, as we saw above.</p><p>
        However there does exist a class of curves that does support this four-point formulation—Catmull-Rom curves.
        <input type="checkbox" id="sn-2" class="margin-toggle">

        There is a sub-class of these called Centripetal Catmull-Rom curves, that guarantees the absence of cusps (<em>i.e.</em> loops), which is exactly what we want.

    </p><p>
        Both—Bezier curves and Catmull-Rom curves—are cubic polynomials, and hence interconvertible.<input type="checkbox" id="sn-3" class="margin-toggle"></p><p><b>Therefore, by keeping things in Bezier form while also supporting Catmull-Rom-like behavior, we get the best of both worlds—fine-grained tangent control, and intuitive point-fitting.</b></p></section><section><h2>The math</h2><p>Given four points, \(\{P_0, P_1, P_2, P_3\}\), we want to find the tangent points \(\{T_1, T_2\}\). They are given by:</p><p>
        \[
        \begin{align}
        T_1 &amp; = \frac{d_1^2 P_2 - d_2^2 P_0 + (2d_1^2 + 3 d_1 d_2 + d_2^2)P_1} {3d_1(d_1 + d_2)} \\
        T_2 &amp; = \frac{d_3^2 P_1 - d_2^2 P_3 + (2d_3^2 + 3 d_3 d_2 + d_2^2)P_2} {3d_3(d_3 + d_2)} \\
        \end{align}
        \]
    </p><p>where \(d_i = |P_i - P_{i - 1}|^\alpha\).</p><p>\(\alpha\) is a constant, which dictates the "tightness" of the curve. When \(\alpha = 0\), the parameterization is said to be uniform. When \(\alpha = 1\), it is said to be chordal. When \(\alpha = 0.5\), it is said to be centripetal, which is the one we're interested in the most, since it guarantees lack of cusps.</p></section><section><h2>Composite curves</h2><p>You may have noticed that the above formulation requires four points \(\{P_0, P_1, P_2, P_3\}\), but only generates the curve between the middle two \(\{P_1, P_2\}\). So how did we generate the other (greyed out) curves in the figure?</p><p>We generate phantom points. <em>E.g.</em> the curve between \(\{P_0, P1\}\) is given by the phantom point \(P_0 + \varepsilon (P_0 - P_1)\) and the points \(\{P_0, P_1, P_2\}\). \(\varepsilon\) is any arbitrarily small number. In this example I'm using 0.0001; the main constraint is that the phantom point should be colinear to its adjacent real points, for best-looking results.</p></section><section><h2>The code</h2><p> Here's the pertinent Javascript code that powers the interactive figure up top. While the example supports 2D curves, the technique works with any number of dimensions.</p><pre><code class="javascript">function vec2_dist(a, b) {
    return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

function refit_bezier(
    passthru_0, passthru_1, passthru_2, passthru_3,
    out_tangent_1, out_tangent_2
) {
    let d1 = Math.pow(vec2_dist(passthru_1, passthru_0), alpha);
    let d2 = Math.pow(vec2_dist(passthru_2, passthru_1), alpha);
    let d3 = Math.pow(vec2_dist(passthru_3, passthru_2), alpha);
    // Modify tangent 1
    {
        let a = d1 * d1;
        let b = d2 * d2;
        let c = (2 * d1 * d1) + (3 * d1 * d2) + (d2 * d2);
        let d = 3 * d1 * (d1 + d2);
        out_tangent_1.x = (a * passthru_2.x - b * passthru_0.x + c * passthru_1.x) / d;
        out_tangent_1.y = (a * passthru_2.y - b * passthru_0.y + c * passthru_1.y) / d;
    }
    // Modify tangent 2
    {
        let a = d3 * d3;
        let b = d2 * d2;
        let c = (2 * d3 * d3) + (3 * d3 * d2) + (d2 * d2);
        let d = 3 * d3 * (d3 + d2);
        out_tangent_2.x = (a * passthru_1.x - b * passthru_3.x + c * passthru_2.x) / d;
        out_tangent_2.y = (a * passthru_1.y - b * passthru_3.y + c * passthru_2.y) / d;
    }

}</code></pre></section></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>