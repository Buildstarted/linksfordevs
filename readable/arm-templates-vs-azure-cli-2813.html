<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ARM Templates vs Azure CLI - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="ARM Templates vs Azure CLI - linksfor.dev(s)"/>
    <meta property="article:author" content="Copyright &#xA9; 2020 Mark Heath"/>
    <meta property="og:description" content="Mark Heath&#x27;s Development Blog"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://markheath.net/post/arm-vs-azure-cli"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - ARM Templates vs Azure CLI</title>
<div class="readable">
        <h1>ARM Templates vs Azure CLI</h1>
            <div>by Copyright &#xA9; 2020 Mark Heath</div>
            <div>Reading time: 14-18 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://markheath.net/post/arm-vs-azure-cli">https://markheath.net/post/arm-vs-azure-cli</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div itemprop="articleBody"><p>Recently, I've been posting tutorials about how to <a href="https://markheath.net/post/deploying-azure-functions-with-azure-cli">deploy Azure Function Apps with the Azure CLI</a> and <a href="https://markheath.net/post/managed-identity-key-vault-azure-functions">create a managed identity to enable your Function App to access Key Vault</a>. I love how easy the Azure CLI makes it to quickly deploy and configure infrastructure in Azure.</p> <p>But is the Azure CLI is the right tool for the job? After all, aren't we supposed to be using ARM templates? If you've not used them before, <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates">ARM templates</a> are simply JSON files describing your infrastructure which can be deployed with a single command.</p> <p>My general recommendation is that while the Azure CLI is great for experimenting and prototyping, once you're ready to push to production, it would be a good idea to create ARM templates and use them instead.</p> <p>However, in November, an interesting tweet caught my eye. Pascal Naber <a href="https://pascalnaber.wordpress.com/2018/11/11/stop-using-arm-templates-use-the-azure-cli-instead/">wrote a blog post</a> making the case that ARM is unnecessarily complex compared to just using the Azure CLI. And I have to admit, I have some sympathy with this point of view. In the article he shows a 200+ line ARM template and contrasts it with about 10 lines of Azure CLI to achieve the same result.</p> <twitter-widget id="twitter-widget-1" data-tweet-id="1061843688677085184"></twitter-widget><p>So in this article I want to give my thoughts on the merits of the two different approaches: <strong>ARM templates</strong> which are a very <em>declarative</em> way of expressing your infrastructure (i.e. <em>what</em> should be deployed), versus <strong>Azure CLI</strong> scripts which represent a more <em>imperative</em> approach (i.e. <em>how</em> it should be deployed).</p> <h3>Infrastructure as Code</h3> <p>The term "<a href="https://docs.microsoft.com/en-us/azure/devops/learn/what-is-infrastructure-as-code">infrastructure as code</a>" is used to express the idea that your infrastructure deployment should be <strong>automated</strong> and <strong>repeatable</strong>, amd the "code" that defines your infrastructure should be <strong>stored in version control</strong>. This makes a lot of sense: you don't want error-prone manual processes to be involved in the deployment of your application, and you want to be sure that if all your infrastructure was torn down, you could easily recreate <em>exactly</em> the same environment.</p> <p>But "infrastructure as code" doesn't dictate what file format or DSL our infrastructure should be defined in. The most common approaches are JSON (used by ARM templates) and YAML (used by Kubernetes). Interestingly, <a href="https://docs.microsoft.com/en-us/azure/service-fabric-mesh/service-fabric-mesh-overview">Service Fabric Mesh</a> has introduced a YAML format that gets converted behind the scenes into an ARM template, presumably because the YAML allows a simpler way of expressing the makeup of the application (we'll come back to this idea later).</p> <p>However, there's no obvious reason why a PowerShell or Bash script couldn't also count as "infrastructure as code", or even an application written in JavaScript or C#. And thanks to the <a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest">Azure CLI</a>, <a href="https://docs.microsoft.com/en-us/powershell/azure/overview?view=azps-1.0.0">Azure PowerShell</a>, <a href="https://docs.microsoft.com/en-us/dotnet/azure/">Azure SDK for .NET</a> and <a href="https://docs.microsoft.com/en-us/javascript/api/overview/azure/?view=azure-node-latest">Azure Node SDK</a>, you can easily use any of those options to automate deployments.</p> <p>The key difference is not whether both approaches count as "infrastructure as code", but the idea that <em>declarative</em> ways of defining the infrastructure are better than <em>imperative</em>. A JSON document contains no logic - it simply expresses all the "resources" that form the infrastructure and their configuration. Whereas if we choose to write a script using the Azure CLI, then it is inherently <em>imperative</em> - it describes the steps required to provision the infrastructure.</p> <p>So which is best?</p> <h3>Declarative</h3> <p>Well the received wisdom is definitely that declarative is best. Azure strongly encourages the you to use JSON based ARM templates, Service Fabric Mesh and Docker use YAML, and other popular Infrastructure as code services like <a href="https://www.terraform.io/">Terraform</a> have <a href="https://github.com/terraform-providers/terraform-provider-aws/blob/master/examples/two-tier/main.tf">their own file-format</a> designed to be more a <a href="https://www.terraform.io/docs/configuration/index.html">more-readable alternative to JSON</a>.</p> <p>In most cases, you are simply defining the "resources" that form your infrastructure - e.g. I want a SQL Server, a Storage Account, an App Service Plan and a Function App. You also get to specify all the properties: what location should the resources be, what pricing tier/sizing do I want, what special configuration settings do I need to enable? Most of these formats also allow you to include the application code itself as a configuration property: you can specify what version of a Docker image your Web App should run, or what GitHub repository the source code for your Function App can be found in, allowing a fully-working application to be deployed with a single command.</p> <p>There are several key benefits to the declarative approach. First of all, it uses a <strong>desired state</strong> approach, which allows for <strong>incremental</strong> and <strong>idempotent</strong> deployments. In other words, your template defines what resources you want to be present, and so the act of deploying that template will only take effect if those resources are not already present, or are not in the state you requested. This means that deploying an ARM template is idempotent - there is no danger in deploying it twice - you won't end up with double of everything, or errors on the second run-through.</p> <p>There are some other nice benefits to declarative template files. They can be <strong>validated</strong> in advance of running, greatly reducing the chance that you could end up with a half-complete deployment. The underlying deployment engine can intelligently optimize by identifying which resources are needed first and what steps can be performed <strong>in parallel</strong>. Any logic to retry actions in the case of transient failures is also built into the template deployment engine. And templates can be <strong>parameterized</strong>, allowing you to use the same template to deploy to staging as well as production. Parameters also enable you to avoid storing secrets in templates.</p> <p>But it's not all great. Declarative template formats like ARM tend to suffer from a number of weaknesses. The templates themselves are often very <strong>verbose</strong>, especially if you get a tool to auto-generate them, and if you prefer to hand-roll them, the documentation is often sparse, and its a cumbersome and error prone process. When I build ARM templates I usually start by copying one of the <a href="https://github.com/Azure/azure-quickstart-templates">Azure Quickstart templates</a> and adapting it to my needs. But often that requires me to also visit <a href="https://resources.azure.com/">resources.azure.com</a> to attempt to deduce what template setting is needed to enable a feature I only know how to turn on via the portal. It can be a painfully slow and error-prone process.</p> <p>Another issue is that although YAML and JSON files are touted as being "human readable", the fact is that they quickly lose their readability once they go beyond a screen-full of text, as Pascal's example clearly demonstrated.</p> <p>And there are some practical annoyances. For example, a while ago I deployed a resource group that used some secrets. I parameterized them in the template (as is the best practice), and so when I initially deployed the ARM template, I provided those secret values. But the trouble was, now <em>every</em> time I wanted to redeploy the template because of some other unrelated change, I needed to source those secret values again even though they weren't modified. There didn't seem to be an obvious way of asking it to simply leave those secrets with the values they had on a previous deployment.</p> <p>And this brings me onto the final issue that you inevitably run into with these templates. They end up requiring their own pseudo-programming language. In ARM templates, there are often dependencies between items. I need the Storage Account to be created before the Function App, because the Function App has an App Setting pointing at the connection string for the Storage Account. In the case of a web app that talks to a database it might be even more complex, with the database needing the web app's IP address in order to set up firewall rules, while the web app needing the database's connection string, resulting in a circular dependency.</p> <p>The ARM template syntax has the concept of 'variables' which can be calculated from parameters, and can be manipulated using various helper functions such as 'concat' and 'listkeys' as you can see in the following example:</p> <pre><code>{
    <span>"name"</span>: <span>"AzureWebJobsStorage"</span>,
    <span>"value"</span>: <span>"[concat('DefaultEndpointsProtocol=https;AccountName=', variables('storageAccountName'), ';AccountKey=', listKeys(variables('storageAccountId'),'2015-05-01-preview').key1)]"</span>
},
</code></pre> <p>And this seems to be an inevitable pattern in any declarative template format that attempts to define something moderately complex - you end up wanting regular programming constructs, such as conditional expressions, string manipulations, and loops. Here's a snippet from an API Management policy defined in XML I saw recently that you can see has also introduced a level of scripting.</p> <pre><code><span>&lt;<span>set-header</span> <span>name</span>=<span>"X-User-Groups"</span> <span>exists-action</span>=<span>"override"</span>&gt;</span>
    <span>&lt;<span>value</span>&gt;</span>
        @(string.Join(";", (from item in context.User.Groups select item.Name)))
    <span>&lt;/<span>value</span>&gt;</span>
<span>&lt;/<span>set-header</span>&gt;</span>
</code></pre> <p>The frustration I have with these DSLs within templates is that they are very limiting, lack support for intellisense and syntax highlighting, and tend to make our templates more indecipherable and fragile. Escaping values correctly can become a real headache as you can find yourself encoding JSON strings within JSON strings.</p> <h3>Imperative</h3> <p>So why not just write our deployment scripts in a regular scripting or programming language? There are some obvious benefits. The language already has familiar syntax, supporting conditional steps, storing and manipulating variables for later use, generating unique names according to a custom naming conventions, and much more. Our editors can help us with intellisense, syntax highlighting and refactoring shortcuts.</p> <p>Also, we can follow the principles of "clean code" and extract blocks of logic into reusable methods. So I might make a methods that knows how to create an Azure Function App configured just the way I like it, with specific features enabled, and specific resource tags that I always apply. This allows the top-level deployment script/code to read very naturally whilst hiding the less intersting or repetitive details at a lower level.</p> <p>For example, the <a href="https://docs.microsoft.com/en-gb/dotnet/api/overview/azure/appservice?view=azure-dotnet">fluent Azure C# SDK syntax</a> gives an idea of what this could look like. Here's creating a web app:</p> <pre><code><span>var</span> app1 = azure.WebApps
    .Define(<span>"MyUniqueWebAddress"</span>)
    .WithRegion(Region.USWest)
    .WithNewResourceGroup(<span>"MyResourceGroup"</span>)
    .WithNewWindowsPlan(PricingTier.StandardS1)
    .Create();
</code></pre> <p>And you could easily build upon this approach by defining your own custom extension methods.</p> <p>Just like ARM templates, imperative deployment scripts can easily be parameterized, ensuring you keep secrets out of source control, and can reuse the same script for deploying to different environments.</p> <p>But imperative deployment scripts like this do potentially have some serious drawbacks. The first is: what about <strong>idempotency</strong>? If I run my script twice, will it fail the second time because things are already there? Can it work out what's missing and only create that? Well, we don't want to bloat our script to have to put lots of conditional logic in, checking if a resource exists and only creating it if it is missing, but it turns out that it's not all that hard to achieve. In fact, Pascal Naber recently posted a gist showing an <a href="https://gist.github.com/pascalnaber/75412a97a0d0b059314d193c3ab37c4c">idempotent bash script using the Azure CLI</a> to deploy a Function App configured to access Key Vault. You can safely run it multiple times.</p> <p>For example if I run the following Azure CLI commands multiple times, I won't get any errors:</p> <pre><code>az group create -n <span>"IdempotentTest"</span> -l <span>"west europe"</span>
az appservice plan create -n <span>"IdempotentTest"</span> -g <span>"IdempotentTest"</span> --sku B1
</code></pre> <p>But what about the <strong>desired state</strong> capabilities of a declarative framework like ARM templates? What if we wanted a Standard rather than Basic tier app service plan? Let's try:</p> <pre><code>az appservice plan create -n <span>"IdempotentTest"</span> -g <span>"IdempotentTest"</span> --sku S1
</code></pre> <p>And this works - our app service plan gets upgraded to the standard tier! Let's make it harder. What if we decide it should be a Linux app service plan:</p> <pre><code>az appservice plan create -n <span>"IdempotentTest"</span> -g <span>"IdempotentTest"</span> `
                --sku S1 --is-linux
</code></pre> <p>And now we get an error - <em>"You cannot change the OS hosting your app at this time. Please recreate your app with the desired OS."</em> Although, to be fair, I'm not sure an ARM template deployment would fare any better attempting to make this change. Not all modifications to desired state can be straightforwardly implemented.</p> <p>To be honest, I was a little surprised by this. I hadn't realised the Azure CLI had this capability, and it makes it a much more competitive alternative to ARM templates. I haven't tried the same thing with the Azure for .NET SDK - that would be in interesting experiment for the future.</p> <p>This leaves me thinking that ARM templates actually offer very few tangible benefits over using a scripting approach with Azure CLI. Perhaps one weakness of the scripting approach is that idempotency certainly is not automatic. You'd have to think very carefully about what the conditional steps and other logic in your scripts were doing. For example, if you generate a random suffix for a resource name like I do in many of my PowerShell scripts, then straight off you've not got idempotency - you'd need custom code to check if the resource already exists and find out what random suffix you used last time.</p> <p>But it's interesting that we are starting to see this approach to infrastructure as code gaining momentum elsewhere. I've not had a chance to play with <a href="https://www.pulumi.com/why-pulumi/delivering-cloud-native-infrastructure-as-code/">Pulumi</a> yet, but it seems to be taking a very similar philosophy - define your infrastructure in JavaScript, taking advantage of the expressiveness, familiarity, reusability and abstractions that a regular programming language can offer.</p> <h3>The Verdict</h3> <p>There are good reasons why ARM templates are still the recommended way to deploy resources to Azure. They help you avoid a lot of pitfalls, and still have a few benefits that are hard to replicate with a scripting or regular programming language. But they come at a cost of complexity and are generally unfriendly for developers to understand and tweak. It feels to me like we're not too far away from code-based approaches being able to offer the same benefits but with a much simpler and more developer-friendly syntax. The Azure CLI already seems very close so long as you take a sensible approach to what additional actions your script performs.</p> <p>Maybe what's needed is simply a much easier way to generate the templates in the first place - if I can write a very simple script that produces an ARM template, then I don't need to worry about how verbose the resulting template is. It seems to me that's what the Service Fabric Mesh team decided by choosing to create a YAML resource definition that gets compiled into ARM. (Although I'm sure that before long that YAML will start adding DSL like constructs for things like string manipulation).</p> <p>Anyway, thanks for sticking with this rather long and rambling post. I'm sure there's a lot more that could said on the strengths and weaknesses of both approaches, so I welcome your feedback in the comments!</p> </div><p> Want to learn more about the Azure CLI? Be sure to check out my Pluralsight course <a href="https://pluralsight.pxf.io/c/1192349/424552/7490?u=www%2Epluralsight%2Ecom%2Fcourses%2Fazure-cli-getting-started">Azure CLI: Getting Started</a>. </p></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>