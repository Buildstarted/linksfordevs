<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Meet WebWindow, a cross-platform webview library for .NET Core -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Meet WebWindow, a cross-platform webview library for .NET Core</h1>
    <div class="body"> <p>My <a href="/2019/11/01/exploring-lighter-alternatives-to-electron-for-hosting-a-blazor-desktop-app/">last post</a> investigated ways to build a .NET Core desktop/console app with a web-rendered UI <em>without</em> bringing in the full weight of Electron. This seems to have interested a lot of people, so I decided to upgrade it to newer technologies and add cross-platform support.</p> <p>The result is a little NuGet package called <a href="https://www.nuget.org/packages/WebWindow">WebWindow</a> that you can add to any .NET Core console app. It can open a native OS window (Windows/Mac/Linux) containing web-based UI, without your app having to bundle either Node or Chromium.</p> <p>I&#x2019;ve also decoupled it from Blazor. You can now host any kind of web UI inside the window. The repo contains a sample that uses Vue.js, and another that uses Blazor.</p> <blockquote> <p><strong>Caution:</strong> This library is super-pre-alpha quality. If you&#x2019;re thinking of building something real with this, see the notes at the end of this post. So far, this is just another prototype.</p>
</blockquote> <h2 id="hello-world-example">&#x201C;Hello World&#x201D; example</h2> <p>Create a new .NET Core 3 C# console application, and then add a reference to the <code class="language-plaintext highlighter-rouge">WebWindow</code> NuGet package:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ItemGroup&gt;</span> <span class="nt">&lt;PackageReference</span> <span class="na">Include=</span><span class="s">&quot;WebWindow&quot;</span> <span class="na">Version=</span><span class="s">&quot;0.1.0-20191118.2&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/ItemGroup&gt;</span>
</code></pre></div></div> <p>Next, add code to the <code class="language-plaintext highlighter-rouge">Main</code> method in your <code class="language-plaintext highlighter-rouge">Program</code> class.</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span> <span class="kt">var</span> <span class="n">window</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WebWindow</span><span class="p">(</span><span class="s">&quot;My super app&quot;</span><span class="p">);</span> <span class="n">window</span><span class="p">.</span><span class="nf">NavigateToString</span><span class="p">(</span><span class="s">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt; This window is from a .NET Core app.&quot;</span><span class="p">);</span> <span class="n">window</span><span class="p">.</span><span class="nf">WaitForExit</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>That&#x2019;s it! Now depending on which OS you&#x2019;re running, your app will display a window like one of the following:</p> <p><img src="/wp-content/uploads/2019/11/18/hello-windows.png" alt="WebWindow Hello World example on Windows"></p> <p><img src="/wp-content/uploads/2019/11/18/hello-macos.png" alt="WebWindow Hello World example on macOS"></p> <p><img src="/wp-content/uploads/2019/11/18/hello-ubuntu.png" alt="WebWindow Hello World example on Ubuntu Linux"></p> <p>The example here uses <code class="language-plaintext highlighter-rouge">NavigateToString(html)</code> to render some HTML from a hardcoded .NET <code class="language-plaintext highlighter-rouge">string</code>. You can also use:</p> <ul> <li><code class="language-plaintext highlighter-rouge">NavigateToUrl(url)</code> to display content from an HTTP server (local or remote)</li> <li><code class="language-plaintext highlighter-rouge">NavigateToLocalFile(path)</code> to display an HTML file from the local disk, where <code class="language-plaintext highlighter-rouge">path</code> is absolute or relative to the current working directory. The HTML file can reference other resources such as images, JS, CSS, etc., relative to its own location on disk. <a href="https://github.com/SteveSandersonMS/WebWindow/blob/a01537a9328b085075866a965191d6323ad2cf7d/samples/HelloWorldApp/Program.cs#L11">Example here</a>.</li>
</ul> <p>As a slightly more advanced option, you can configure the <code class="language-plaintext highlighter-rouge">WebWindow</code> to handle a custom scheme such as <code class="language-plaintext highlighter-rouge">myapp://</code> and specify a delegate (callback) that returns arbitrary content for each URL within that scheme. <a href="https://github.com/SteveSandersonMS/WebWindow/blob/a01537a9328b085075866a965191d6323ad2cf7d/testassets/HelloWorldApp/Program.cs#L14">Example here</a> and <a href="https://github.com/SteveSandersonMS/WebWindow/blob/a01537a9328b085075866a965191d6323ad2cf7d/testassets/HelloWorldApp/wwwroot/index.html#L11">here</a>.</p> <p>Once your web content is running, the low-level way to communicate between JavaScript and .NET is using the APIs <code class="language-plaintext highlighter-rouge">window.external.sendMessage</code>/<code class="language-plaintext highlighter-rouge">receiveMessage</code> in JS (<a href="https://github.com/SteveSandersonMS/WebWindow/blob/a01537a9328b085075866a965191d6323ad2cf7d/testassets/HelloWorldApp/wwwroot/index.html#L14-L20">example</a>) and <code class="language-plaintext highlighter-rouge">webWindowInstance.SendMessage</code> and <code class="language-plaintext highlighter-rouge">webWindowInstance.OnWebMessageReceived</code> in .NET - (<a href="https://github.com/SteveSandersonMS/WebWindow/blob/a01537a9328b085075866a965191d6323ad2cf7d/testassets/HelloWorldApp/Program.cs#L21-L24">example</a>). However if you&#x2019;re building a Blazor app, you don&#x2019;t need to use these low-level APIs and can use Blazor&#x2019;s regular JS interop feature instead.</p> <h2 id="hosting-a-blazor-app">Hosting a Blazor app</h2> <p>WebWindow isn&#x2019;t coupled to Blazor. Here&#x2019;s an <a href="https://github.com/SteveSandersonMS/WebWindow/tree/master/samples/VueFileExplorer">example of using Vue.js to render a simple directory-explorer app inside a WebWindow</a>.</p> <p>But if you do want to use Blazor, that&#x2019;s extremely clean and easy. I&#x2019;ve also made a small add-on package, <a href="https://www.nuget.org/packages/WebWindow.Blazor">WebWindow.Blazor</a>, that lets you host a Blazor app with one line in your <code class="language-plaintext highlighter-rouge">Program.Main</code>:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span> <span class="n">ComponentsDesktop</span><span class="p">.</span><span class="n">Run</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;(</span><span class="s">&quot;My Blazor App&quot;</span><span class="p">,</span> <span class="s">&quot;wwwroot/index.html&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>To recap, this does <em>not</em> involve WebAssembly, Node.js, or a privately-bundled copy of Chromium. It&#x2019;s just .NET Core running natively, communicating directly with the OS&#x2019;s own web rendering technology. The result, this time in macOS:</p> <p><img src="/wp-content/uploads/2019/11/18/blazor-macos.jpg" alt="Blazor example on macOS"></p> <p>The complete <a href="https://github.com/SteveSandersonMS/WebWindow/tree/master/samples/BlazorDesktopApp">WebWindow+Blazor sample is here</a>.</p> <h2 id="how-it-works">How it works</h2> <ul> <li>On <strong>Windows</strong>, WebWindow uses the new <a href="https://docs.microsoft.com/en-us/microsoft-edge/hosting/webview2">Chromium-based Edge via webview2</a>, assuming you have that browser installed (it could fall back on older Edge if you don&#x2019;t, but I haven&#x2019;t implemented that)</li> <li>On <strong>Mac</strong>, it uses the OS&#x2019;s built-in <a href="https://developer.apple.com/documentation/webkit/wkwebview">WKWebView</a>, which is the same technology behind Safari</li> <li>On <strong>Linux</strong>, it uses <a href="https://webkitgtk.org/">WebKitGTK+2</a>, which is yet again a WebKit-based technology</li>
</ul> <p>The whole point of this, compared with using Electron, is to produce apps that are smaller to download and use less memory. But does it actually? Here are the stats for download size:</p> <p><img src="/wp-content/uploads/2019/11/18/download-size-chart.png" alt="Download size chart"></p> <p>As you can see, whether you choose &#x201C;standalone&#x201D; (bundles a copy of the .NET Core runtime) or &#x201C;framework-dependent&#x201D; (rely on .NET Core being installed in the target OS) makes a vast difference to the resulting app size. Framework-dependent WebWindow apps can be truly tiny, since they only contain your own app&#x2019;s binaries and aren&#x2019;t bundling either a runtime or a browser.</p> <p>And now, stats for memory use:</p> <p><img src="/wp-content/uploads/2019/11/18/memory-use-chart.png" alt="Memory use chart"></p> <p>On Windows, WebWindow and Electron are using the same browser technology (Chromium), which eats up most of the memory. That explains why the difference between them isn&#x2019;t huge. On Linux and Mac, the difference between using a self-bundled browser and the OS&#x2019;s built in technology is more substantial.</p> <h2 id="will-this-be-supported-and-maintained">Will this be supported and maintained?</h2> <p>Currently I&#x2019;m not making any promises! It&#x2019;s best to think of it as yet another experiment for now. It&#x2019;s possible that if enough other people want to get involved, it would be possible to create a proper open-source community project.</p> <p>What&#x2019;s most urgently needed is someone with C++ experience to come and rewrite my prototype-quality C++ and Objective-C code the way it actually should be done. The chance that I&#x2019;ve got all the memory management right here is close to zero. Maybe it should use CMake or another sane build config system too. (Note: it does have a <a href="https://dev.azure.com/SteveSandersonMS/WebWindow/_build?definitionId=2">cross-platform CI build on Azure DevOps</a> though.)</p> <p>There&#x2019;s also a large number of features you&#x2019;d really want to add if you intended to use this in production. For example, the ability to set an app icon, to add a native menu bar, and so on. If you&#x2019;re interested in contributing such functionality and will make it work cross-platform, please <a href="https://github.com/SteveSandersonMS/WebWindow">head over to the repo</a>!</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>