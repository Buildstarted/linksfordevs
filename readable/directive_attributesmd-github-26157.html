<!DOCTYPE html>
<html lang="en">
<head>
    <title>
directive_attributes.md - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="directive_attributes.md - linksfor.dev(s)"/>
    <meta property="og:description" content="GitHub Gist: instantly share code, notes, and snippets."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://gist.github.com/rynowak/f2e6a4bfc3b685d7dce15d96942aa4b8"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - directive_attributes.md</title>
<div class="readable">
        <h1>directive_attributes.md</h1>
            <div>Reading time: 18-23 minutes</div>
        <div>Posted here: 09 Jun 2019</div>
        <p><a href="https://gist.github.com/rynowak/f2e6a4bfc3b685d7dce15d96942aa4b8">https://gist.github.com/rynowak/f2e6a4bfc3b685d7dce15d96942aa4b8</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
  <div id="file-directive_attributes-md">
      
    
  <div id="file-directive_attributes-md-readme">
    <article itemprop="text">
<p>Razor Components (<code>.razor</code>) have two primary kinds of metaprogramming</p>
<ol>
<li>Components (replaces an element with a C# class)</li>
<li>Directive attributes (<code>ref</code>, <code>onclick</code>, <code>bind-...</code>)</li>
</ol>
<p>Components are the main building block of the components programming model (duh). Components are always <em>invoked</em> as an element - primarily serve to create the hierarchical structure of the UI. Components can impact either other by providing cascading values, and choosing whether to render their child content or not. Components can be authored by anyone, and we expect everyone to write their own components as well as use components from libraries.</p>
<p>Directive attributes can decorate both components and DOM elements, and can <em>attach</em> arbitrary behavior. This can include intrinsic features of the render tree builder like <code>ref</code>, and event handlers (<code>onclick</code>) - or they can synthesize additional attributes like two-way binding (<code>bind-...</code>). Directive attributes can currently only be authored as part of the compiler.</p>
<p>Since directive attributes allow you customize the behavior of components and DOM elements, making them extensible adds a "word of power" to Razor as a language. While my immediate concern is how we design the <em>syntax</em> for invoking the built-in directives, we should also consider how these ideas would succeed or fail if users are able to author directives. These are features that we expect to appear everywhere in <code>.razor</code> files, and it will be extremely painful for users to change how they work post-release.</p>
<h2>Requirements, Goals and Scoping</h2>
<p><strong>requirement:</strong> Specify the syntax of the built-in directives as part of ASP.NET Core 3.0.</p>
<p><strong>requirement:</strong> Support all of the existing scenarios that built-in directives currently have and more.</p>
<p><strong>scope:</strong> Built-in directives include <code>ref</code>, event handlers, binding, and soon <em>splatting</em>.</p>
<p><strong>scope:</strong> Making directives extensible is not a requirement for this release.</p>
<p><strong>goal:</strong> Syntax design includes high-quality tooling experiences.</p>
<p><strong>goal:</strong> Syntax design is aesthetically pleasing.</p>
<p><strong>goal:</strong> Seeing directives next to DOM attributes and component parameters should not feel too jarring or inconsistent.</p>
<p><strong>goal:</strong> Make directives visually or syntactically distinct from normal DOM attributes.</p>
<p><strong>goal:</strong> Provide suffient <em>design-space</em> for future directive designs without changes to syntax.</p>
<p><strong>goal:</strong> Don't diverge from the metaphor of using attributes to attach behavior.</p>
<h2>Case Studies</h2>
<p>I'm comparing a few different approaches here so see what kinds of insights we can get from the <em>syntactic choices</em>. There are two main strategies to compare - giving the developer power through an <em>expressive attribute key</em>, and giving the developer power through an <em>expressive attribute value</em>. There's a third way, which is to make the actual attributes simple use more of them.</p>
<h2>Case-Study: Vue</h2>
<p>Vue provides a generic, extensible directive system that enables users to metaprogram DOM elements. Built-in directives are used for features like <code>ref</code>, event handlers, and binding (and more). It's important to note that while a Vue directive appears to set a single attribute, directives have the ability to metaprogram the element/component dom. Directives may set multiple DOM attributes, set a single one after transforming the value, or set no attribute at all.</p>
<p>Vue directives give a few design points to the implementor beyond a simple <code>key=value</code>.</p>
<p>An example:</p>
<div><pre><span>&lt;</span><span>button</span> <span>v-on:submit.prevent</span>="<span>onSubmit</span>"<span>&gt;</span><span>&lt;/</span><span>button</span><span>&gt;</span></pre></div>
<p>In the example above <code>v-on:submit.prevent="onSubmit"</code> can be decomposed as <code>v-(name):(argument):(modifier)=(value)</code>. The directive has a name, an optional single argument, an optional list of modifiers (boolean flags) and an optional value.</p>
<p>In this example, the <code>onSubmit</code> javascript function is bound to the button's <code>submit</code> event, and the callback will call <code>preventDefault()</code> to stop event propagation. Read more about the kinds of things that <code>v-on</code> supports <a href="https://vuejs.org/v2/guide/events.html" rel="nofollow">here</a></p>
<p>How does this align or compare with our goals:</p>
<ul>
<li><code>v-</code> syntax makes this visually and (practically) syntactically distinct from a normal HTML attribute.</li>
<li>Supporting an argument and modifiers allows for lots of flexible designs for directives.</li>
<li>The set of modifiers and completion of known values for attributes could be tooled.</li>
</ul>
<p>My personal opinion on the aesthetics of Vue's attributes - I think that Vue's examples are readable and simple. More complex examples are going to feel cramped (multiple modifiers). However, since directives in Vue only allow a single argument, it's hard to imagine a case with much more visual noise than something like <code>&lt;span v-format.bold.highlight.underline&gt;guide&lt;/span&gt;</code></p>
<p>As an interesting note, Vue sticks to directives as valid HTML attributes names. For instance a directive may have a dynamic value for its argument (<code>v-on:[eventName]="..."</code>). <code>eventName</code> in this case is a javascript expression, but <em>the expression</em> may not contain spaces, nor an invalid attribute name characters like quotes. Vue also uses <code>@</code> as a shorthand for <code>v-on</code> (<code>@</code> is legal in an attribute name).</p>
<h2>Case Study: WPF &amp; Markup Extensions</h2>
<p><em>I don't know much about the other Xaml flavours aside from WPF, I'm going to stick to what I know because there's some useful information there.</em></p>
<p>WPF/Xaml provide a concept called markup extensions, which allow metaprogramming of the value for a single attribute. The property/attribute system in WPF is complex, and I won't go into it in detail here. I'm going to analyze the syntax of WPF/Xaml's markup extensions and assume that it would be possible to build something as powerful as our built-in directives instead of being limited to setting a single property.</p>
<p>Since this is Xaml, the central metaphor is <em>creating objects</em>.</p>
<p>Example:</p>
<pre><code>&lt;Setter Property="Background" Value="{DynamicResource {x:Static SystemColors.ControlBrushKey}}" /&gt;  
</code></pre>
<p>A markup expression <code>{ ... }</code> uses a markup extension (identified by <code>DynamicResource</code> or <code>x:Static</code>) to resolve a value. An instance of the mark up extension is created using ordinal and key-value parameters, and then the markup extension is invoked to produce the value. As seen here, markup extensions can be nested.</p>
<p>I've picked an example that deals with WPF's styling system, so I'm going to imagine something that's closer to our scenarios, and then look at this through the lens of HTML+Razor. One could imagine putting different <em>syntax</em> inside the attribute value - I'm showing this to consider <em>the idea of using the attribute value</em>.</p>
<p>Example:</p>
<pre><code>&lt;button onsubmit="@{EventHandler OnSubmit, PreventDefault = true}"&gt;&lt;/button&gt;
</code></pre>
<p>Another:</p>
<pre><code>&lt;input type="text" value="@{Binder myValue, Event = Events.OnInput}"&gt;&lt;/button&gt;
</code></pre>
<p>How does this align or compare with our goals:</p>
<ul>
<li><code>@{ }</code> syntax makes this visually and (practically) syntactically distinct from a normal HTML <em>attribute value</em>.</li>
<li>It does a good job when the attribute you want to set has a static and dynamic usage (<code>bind-...</code> or <code>onclick</code>)</li>
<li>It doesn't really offer a solution for something like <code>ref</code> that doesn't exist in HTML</li>
<li>It also implies that this kind of syntax might be allowed for any attribute or component property, I'm not sure if this is good or bad.</li>
<li>Supporting ordinal arguments and key-value-pairs allows for lots of flexible designs for directives.</li>
<li>The set of arguments, keys and completion of known values for attributes could be tooled.</li>
</ul>
<p>I think the biggest criticism of something like this is that it's <em>just not C#</em>. Xaml tries to hide the syntax of a particular language because Xaml spans many. So Xaml needs features like markup extensions because you can't put literal code inside of an attribute value.</p>
<p>Well we can. What we rewrote this using regular C#?</p>
<pre><code>&lt;input type="text" value="@(EventCallback.Factory.CreateBinder(this, ...))"&gt;&lt;/button&gt;
</code></pre>
<p>The problem is that users wouldn't want to write the real code that replaces <code>...</code>. It also includes implementation details like the fact that <code>EventCallbackFactory</code> needs to be involved instead of just being simple. For cases like <code>bind-...</code> the code required to make it work is already something we only trust the compiler to write.</p>
<h3>Case Study: Angular Attribute Directives</h3>
<p><em>Angular uses the term directive for a few different things, I'm specifically talking about what they call attribute directives here. However in terms of syntax used to invoke a directive, it looks like most of the different concepts angular provides behave similarly.</em></p>
<p>Angular's directives are more limited in expressiveness compared to Vue, Angular does more things with built-in syntax compared to Vue's directives.</p>
<p>Attribute directives in Angular specify a css-selector to <em>attach</em> themselves, and then they can optionally read other attributes from the same element. It's recommended (but not required to use a distinct attribute prefix).</p>
<p>Examples:</p>
<pre><code>&lt;p [appHighlight]="color" defaultColor="violet"&gt;&lt;/p&gt;
</code></pre>
<p>Notice in this case that <code>defaultColor</code> is not prefixed.</p>
<pre><code>&lt;input #newHero (keyup.enter)="addHero(newHero.value)"&gt;
</code></pre>
<p>Notice in this case that the <code>(keyup.enter)</code> incantation is really similar to Vue <code>v-on:keyup.enter</code>. Angular's directives end up with simple keys and simple values for user-created directives. Built-in features that are part of the binding system (event bindings, style bindings) have a more Vue-like set of features in their keys.</p>
<p>How does this align or compare with our goals:</p>
<ul>
<li>Angular's directives and the other attributes they read are not syntactically distinct.</li>
<li>Directives support reading arbitrary other attributes, but they have nothing like Vue's argument or modifiers.</li>
<li>Angular uses a built-in syntax for binding and events, and this is more powerful.</li>
<li>The set of known attributes can be tooled easily</li>
</ul>
<h2>Putting it together:</h2>
<p>Based on the case study and the criteria above, some concrete things I'm going to propose.</p>
<hr>
<p><strong>Prefix our directive attributes with <code>@</code> - <code>@</code> is a legal character in an attribute name.</strong></p>
<p>This feels very-Razorey, and as long as it isn't colored bright yellow it will fade into the background. This solves the problem where it's very easy to put something wrong in <code>onclick</code> and other events. This starts to feel important when directives overlap with and provide an alternate experience to the HTML built-ins.</p>
<p>Examples of our current built-ins:</p>
<pre><code>&lt;input @bind="foo" /&gt;
&lt;MyTextInput @bind-Value="foo" /&gt;
&lt;input @onclick="OnClick" /&gt;
&lt;input @ref="bar" /&gt;
</code></pre>
<p>Note, we no longer need <code>@</code> inside the attribute value for <code>onclick</code> because we don't need to distinguish between C# and markup based on the syntax of the value.</p>
<p>Another cool example:</p>
<pre><code>&lt;div @style="..."&gt;&lt;/div&gt;
</code></pre>
<p>You could imagine scaling this to include more directives based around HTML primitives once it's possible to use the names everyone already knows. <code>style</code> is for normal css styling. <code>@style</code> is for when it gets real.</p>
<hr>
<p><strong>Stick to attribute names for passing additional arguments and flags to directives</strong></p>
<p>I don't think there's much to say about trying to put more power at the users fingertips by introducing more syntax in the attribute value. Putting some kind of a syntactic format here would require us to write new parser logic for this, and it could stray from the ability for users to write equivalent code to what the compiler generates.</p>
<p>We already have arguments in our built-ins (<code>bind-value-onclick</code> + <code>format-value</code>) takes three arguments counting the format. We're introducing modifiers <a href="https://github.com/aspnet/AspNetCore/issues/5545">as well</a>. We feel like the value these features provide is <em>worth it</em> and they shouldn't be removed. On the contrary, we should try to specify these in ways that lead to a good tooling experience. It's not clear if we need to support multiple arguments to a directive.</p>
<p>We don't have any concept yet of a <em>dynamic argument</em>. For instance Vue allows a syntax like <code>v-on:[eventName]</code> where the value of <code>eventName</code> is evaluated to decide how binding occurs. I don't really see us needing this for <code>bind</code> but it's worth considering what design approach we would take to build it.</p>
<p>The main concerns for a syntax like this:</p>
<ul>
<li>We can't allows spaces in the attribute name (breaks our experience in most HTML parsers)</li>
<li>Do we allow mutliple arguments in a single attribute or require separate attributes</li>
<li>How do we delimit arguments (ordinal) from modifiers (unordered flags)</li>
</ul>
<p>We could opt to <em>surround</em> things with a paired delimiter (<code>()</code>, <code>[]</code>, <code>{}</code>), we could opt to use inline delimiters (<code>.</code>, <code>,</code>, <code>:</code>, <code>-</code>). The reason for extra delimiters is that they are a tremendous help to completion systems. The experience is much much better if the things we use as delimiters are also treated as <em>commit characters</em> by tooling. This means that you can type <code>bin</code>, select <code>bind</code> in the menu, type <code>-</code> and you now have <code>bind-</code> and are being shown completions for the next token.</p>
<p>One of our primary motivating cases (<code>bind</code> + <code>format</code>) also has the characteristic that we want to pass a <em>string literal identifier</em> value as an additional argument to the directive. This isn't something I could really find a precedent for other than in Xaml - Vue allows runtime evaluation of arguments, but the syntaxtic form must not contain special characters like <code>"</code>. I'm going to assume that we want to retain <code>format-...</code> as a separate attribute for the purposes of this discussion.</p>
<p>From experimentation and discussion within the team - things we like (good fit for Blazor):</p>
<ul>
<li>A directive should be able to have flags (modifiers)</li>
<li>A directive should logically be able to have key-value arguments where the value is in C#</li>
</ul>
<p>Things we don't like:</p>
<ul>
<li>Expressing <em>values</em> inside an attribute name just feels bad</li>
<li>method-call syntax as an attribute name</li>
</ul>
<h2>Proposal</h2>
<p>Here's a proposal that's opimized for readability and simplicity. These cases are meant to be unambiguous and scale to a variety of usages.</p>
<p>Directive attributes are an attribute prefixed with <code>@</code> and can have an optional argument where the argument is an <em>string literal identifier</em>. For now we're limiting this to one argument, but we could allow multiple if there was ever a need. Directive attributes can also have key-value arguments which are an <em>additional</em> attribute with a key suffix.</p>
<p>Syntax for a directive attribute: <code>@(name)-(argument)=(value)</code>
Syntax for a directive key-value attribute: <code>@(name)-(argument):(key)=(value)</code></p>
<p>The reason for a secondary separator is for completion to use as a commit character, and also for clarity in how directives are grouped. It's important that we can tell the difference between a directive with an argument and a directive with a key-value argument. Since arguments are arbitrary identifiers it has to rely on syntax or else its ambiguous. Examples of this below.</p>
<p>I suggest for now that the presence of the directive attribute is required in order for the usage of the directive key-value attributes. This leads to preferring the use of the <em>argument</em> when designing directives. The implication is that for some directives the argument is optional, and for some it is required. When authoring directives we should strive to always make key-value attributes optional.</p>
<p>Attribute values follow the same rules as component parameters. They can either be specified as string-like, bool-like, or <em>other</em>. String-likes put you in the markup context by default. Bool-likes allow minimized form. Anything else puts you in the C# context by default.</p>
<p><strong>Open question: If we like this idea, do we like keys as lowercase or camelcase?</strong></p>
<h3>Abstract examples</h3>
<p>Some examples that attempt to describe the syntax and possible forms that are legal. Real examples from Blazor come later.</p>
<hr>
<p>Directive attribute without a value:</p>

<hr>
<p>Directive attribute with a value:</p>
<div><pre><span>&lt;</span><span>div</span> <span>@widget</span>="<span>kevin</span>"<span>&gt;</span>...<span>&lt;/</span><span>div</span><span>&gt;</span></pre></div>
<hr>
<p>Directive attribute with an argument without a value:</p>

<hr>
<p>Directive attribute with an argument with a value:</p>
<div><pre><span>&lt;</span><span>div</span> <span>@widget-x</span>="<span>kevin</span>"<span>&gt;</span>...<span>&lt;/</span><span>div</span><span>&gt;</span></pre></div>
<hr>
<p>Directive attribute with a minimized key-value argument (modifier/flag):</p>
<div><pre><span>&lt;</span><span>div</span> <span>@widget</span>="<span>kevin</span>" <span>@widget:awesome</span><span>&gt;</span>...<span>&lt;/</span><span>div</span><span>&gt;</span></pre></div>
<hr>
<p>Directive attribute with a minimized key-value argument:</p>
<div><pre><span>&lt;</span><span>div</span> <span>@widget</span>="<span>kevin</span>" <span>@widget:color</span>="<span>blue</span>"<span>&gt;</span>...<span>&lt;/</span><span>div</span><span>&gt;</span></pre></div>
<hr>
<p>Directive attribute with multiple arguments:</p>
<div><pre><span>&lt;</span><span>div</span> <span>@widget</span>="<span>kevin</span>" <span>@widget:color</span>="<span>blue</span>" <span>@widget:size</span>="<span>size</span>"<span>&gt;</span>...<span>&lt;/</span><span>div</span><span>&gt;</span></pre></div>
<hr>
<p>Directive key-value argument without directive attribute (not allowed):</p>
<p><strong>ERROR</strong></p>
<div><pre><span>&lt;</span><span>div</span> <span>@widget:size</span>="<span>size</span>"<span>&gt;</span>...<span>&lt;/</span><span>div</span><span>&gt;</span></pre></div>
<p>We could allow this if we wanted to, but I'm not sure we have a use case for it. If we wanted to allow it, it would be the same thing as:</p>
<div><pre><span>&lt;</span><span>div</span> <span>@widget</span> <span>@widget:size</span>="<span>size</span>"<span>&gt;</span>...<span>&lt;/</span><span>div</span><span>&gt;</span></pre></div>
<p>It has to be defined this way because anything would case an imbiguity or inconsistent. As written we have to consider <code>size</code> to be the value provided for <code>@widget:size</code>. The only design space left is whether the <code>@widget</code> is provided or not. Since this is limited to booleans and non-obvious I propose we don't allow it. I'm not sure that making directives where the <em>main function</em> is a boolean is a good practice for directives.</p>
<hr>
<p>Grouping of key-value arguments:</p>
<div><pre><span>&lt;</span><span>div</span> 
    <span>@widget</span>="<span>kevin</span>"
    <span>@widget:awesome</span>
    <span>@widget-x</span>="<span>jimmy</span>"
    <span>@widget-x:size</span>="<span>huge</span>"
    <span>@widget-x:awesome</span>="<span>@isJimmyAwesome</span>"<span>&gt;</span>...<span>&lt;/</span><span>div</span><span>&gt;</span></pre></div>
<p>In this example, the directive <code>@widget="kevin"</code> is grouped with key-value arguments <code>@widget:awesome</code>. Directive <code>@widget-x</code> is grouped with <code>@widget-x:size="huge"</code> and <code>@widget-x:awesome="@isJimmyAwesome"</code>. I don't expect that we'll see this kind of case that often, but I want to make the semantics clear. The value of giving different separators for arguments (<code>-</code>) and key-value arguments (<code>:</code>) is that these cases are consistent.</p>
<h3>Blazor examples</h3>
<p>Some motivating examples in the current state:</p>
<p><strong>Event Handlers</strong></p>
<p>Comparison with a component event handler is shown for comparison.</p>
<div><pre><span>&lt;</span><span>button</span> <span>@onclick</span>="<span>OnClick</span>"<span>&gt;</span><span>&lt;/</span><span>button</span><span>&gt;</span>
<span>&lt;</span><span>MyComponent</span> <span>OnClick</span>="<span>OnClick</span>" /&gt;
<span>&lt;</span><span>button</span> <span>@onclick</span>="<span>@(() =&gt; text = </span>"<span>clicked</span>")"<span>&gt;</span><span>&lt;/</span><span>button</span><span>&gt;</span>
<span>&lt;</span><span>MyComponent</span> <span>OnClick</span>="<span>@(() =&gt; text = </span>"<span>clicked</span>")" /&gt;

<span>&lt;!--</span>
<span>    Examples from our previous discussion. </span>
<span>--&gt;</span>
<span>&lt;</span><span>button</span> <span>@onclick</span>="<span>OnClick</span>" <span>@onclick:stoppropagation</span><span>&gt;</span><span>&lt;/</span><span>button</span><span>&gt;</span>
<span>&lt;</span><span>input</span> <span>type</span>="<span>text</span>" <span>@onkeydown</span>="<span>KeyPressed</span>" <span>@onkeydown:preventdefault</span> <span>@onkeydown:repeatdelay</span>="<span>500</span>" /&gt;

<span>&lt;!--</span>
<span>    Examples from our previous discussion with camelcase</span>
<span>--&gt;</span>
<span>&lt;</span><span>button</span> <span>@onclick</span>="<span>OnClick</span>" <span>@onclick:stopPropagation</span><span>&gt;</span><span>&lt;/</span><span>button</span><span>&gt;</span>
<span>&lt;</span><span>input</span> <span>type</span>="<span>text</span>" <span>@onkeydown</span>="<span>KeyPressed</span>" <span>@onkeydown:preventDefault</span> <span>@onkeydown:repeatDelay</span>="<span>500</span>" /&gt;</pre></div>
<p><strong>Ref</strong></p>
<div><pre><span>&lt;</span><span>button</span> <span>@ref</span>="<span>button</span>"<span>&gt;</span><span>&lt;/</span><span>button</span><span>&gt;</span>
<span>&lt;</span><span>MyComponent</span> <span>@ref</span>="<span>OnClick</span>" /&gt;

<span>&lt;!--</span>
<span>    Possible design for ref that doesn't define a field.</span>
<span>--&gt;</span>
<span>&lt;</span><span>button</span> <span>@ref</span>="<span>button</span>" <span>@ref:assign</span><span>&gt;</span><span>&lt;/</span><span>button</span><span>&gt;</span>
<span>&lt;</span><span>MyComponent</span> <span>@ref</span>="<span>OnClick</span>" <span>@ref:assign</span> /&gt;</pre></div>
<p><strong>Bind</strong></p>
<p>I propose that we simplify bind by requiring the use a key-value argument for specifying the event name. This makes these cases less terse but more obvious. We also get for free the ability
to specify the event name using code.</p>
<div><pre><span>&lt;</span><span>input</span> <span>type</span>="<span>text</span>" <span>@bind</span>="<span>message</span>" /&gt;

<span>&lt;!--</span>
<span>    Note that this wasn't possible to write before without including the attribute name, you had to go from bind to bind-value-oninput.</span>
<span>--&gt;</span>
<span>&lt;</span><span>input</span> <span>type</span>="<span>text</span>" <span>@bind</span>="<span>message</span>" <span>@bind:event</span>="<span>oninput</span>" /&gt;

<span>&lt;!--</span>
<span>    I think this is much more clear that these things are related to each out. </span>
<span>--&gt;</span>
<span>&lt;</span><span>input</span> <span>type</span>="<span>text</span>" <span>@bind</span>="<span>message</span>" <span>@bind:format</span>="<span>...</span>" /&gt;

<span>&lt;!--</span>
<span>    Today this would be written as `bind-custom-oninput`. </span>
<span>--&gt;</span>
<span>&lt;</span><span>input</span> <span>type</span>="<span>text</span>" <span>@bind-custom</span>="<span>message</span>" <span>@bind-custom:event</span>="<span>oninput</span>" /&gt;

<span>&lt;!--</span>
<span>    Comparison with a component</span>
<span>--&gt;</span>
<span>&lt;</span><span>input</span> <span>type</span>="<span>text</span>" <span>@bind</span>="<span>message</span>" /&gt;
<span>&lt;</span><span>MyComponent</span> <span>@bind-Value</span>="<span>message</span>" /&gt;

<span>&lt;!--</span>
<span>    Hypothetical future thing</span>
<span>--&gt;</span>
<span>&lt;</span><span>input</span> <span>type</span>="<span>text</span>" <span>@bind</span>="<span>latlong</span>" <span>@bind:converter</span>="<span>LatLong.Converter</span>"/&gt;
</pre></div>
<h3>References</h3>
<p><a href="https://012.vuejs.org/guide/directives.html" rel="nofollow">Vue.js directives</a></p>
<p><a href="https://vuejs.org/v2/guide/custom-directive.html" rel="nofollow">Vue.js custom directives</a></p>
<p><a href="https://angular.io/guide/attribute-directives" rel="nofollow">AngularJS attribute directives</a></p>
<p><a href="https://www.w3.org/TR/html52/syntax.html#elements-attributes" rel="nofollow">HTML attribute syntax</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/markup-extensions-and-wpf-xaml" rel="nofollow">WPF Markup Extensions</a></p>
<p><a href="https://gist.github.com/rynowak/d109c8ad75d3aac5597cb5962e034b96">Previous examples</a></p>
</article>
  </div>

  </div>
</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
</body>
</html>