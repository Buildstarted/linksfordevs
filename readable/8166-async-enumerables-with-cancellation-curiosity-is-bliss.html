<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Async Enumerables with Cancellation &#xB7; Curiosity is bliss -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Async Enumerables with Cancellation · Curiosity is bliss</h1><div><div id="" class="post"><time datetime="2019-03-08T00:00:00-08:00" class="post-date">08 Mar 2019</time>&nbsp; 
  <p>In this post, I’ll explain how to produce and consume async enumerables with support for cancellation. Since originally publishing this post, we’ve added support in the language for a new attribute which solve this problem more elegantly. I’ve added a section detailing the new method.</p><h3 id="some-context">Some context</h3><p>Visual Studio 2019 (currently in preview) includes a preview of C# 8.0 and the async-streams feature.</p><p>Three parts compose this feature:</p><ol><li>async-iterator methods: you can write methods with the <code class="language-plaintext highlighter-rouge">async</code> modifier, returning either <code class="language-plaintext highlighter-rouge">IAsyncEnumerable</code> or <code class="language-plaintext highlighter-rouge">IAsyncEnumerator</code>, and  using both <code class="language-plaintext highlighter-rouge">yield</code> and <code class="language-plaintext highlighter-rouge">await</code> syntax.</li><li><code class="language-plaintext highlighter-rouge">await foreach</code>: you can asynchronously enumerate collections that implement <code class="language-plaintext highlighter-rouge">IAsyncEnumerable</code> (or implement equivalent APIs).</li><li><code class="language-plaintext highlighter-rouge">await using</code>: you can asynchronously dispose resources that implement <code class="language-plaintext highlighter-rouge">IAsyncDisposable</code>.</li></ol><p><code class="language-plaintext highlighter-rouge">await foreach</code> follows a similar execution pattern as its synchronous sibling <code class="language-plaintext highlighter-rouge">foreach</code>: it first gets an enumerator from the enumerable (by calling <code class="language-plaintext highlighter-rouge">GetAsyncEnumerator()</code>, then repeatedly does <code class="language-plaintext highlighter-rouge">await MoveNextAsync()</code> on the enumerator and gets the item with <code class="language-plaintext highlighter-rouge">Current</code> until the enumerator is exhausted.</p><p>Here’s the code generated for an <code class="language-plaintext highlighter-rouge">await foreach</code>:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">E</span><span class="n">e</span><span class="p">=</span><span class="p">((</span><span class="n">C</span><span class="p">)(</span><span class="n">x</span><span class="p">)).</span><span class="nf">GetAsyncEnumerator</span><span class="p">();</span><span class="k">try</span><span class="p">{</span><span class="k">while</span><span class="p">(</span><span class="k">await</span><span class="n">e</span><span class="p">.</span><span class="nf">MoveNextAsync</span><span class="p">())</span><span class="p">{</span><span class="n">V</span><span class="n">v</span><span class="p">=</span><span class="p">(</span><span class="n">V</span><span class="p">)(</span><span class="n">T</span><span class="p">)</span><span class="n">e</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span><span class="c1">// body</span><span class="p">}</span><span class="p">}</span><span class="k">finally</span><span class="p">{</span><span class="k">await</span><span class="n">e</span><span class="p">.</span><span class="nf">DisposeAsync</span><span class="p">();</span><span class="p">}</span></code></pre></div></div><p>You may notice in the relevant APIs (copied below) that <code class="language-plaintext highlighter-rouge">GetAsyncEnumerator</code> accepts a <code class="language-plaintext highlighter-rouge">CancellationToken</code> parameter. But <code class="language-plaintext highlighter-rouge">await foreach</code> doesn’t make use of this parameter (it passes a <code class="language-plaintext highlighter-rouge">default</code> value).</p><p>This raises two questions: 1) how do you write an async enumerable with support for cancellation? and 2) how do you consume one?</p><h3 id="writing-an-async-enumerable-supporting-cancellation-original-method">Writing an async enumerable supporting cancellation (original method)</h3><p>Let’s say that you intend to write <code class="language-plaintext highlighter-rouge">IAsyncEnumerable&lt;int&gt; GetItemsAsync(int maxItems)</code> supporting cancellation.</p><p>You cannot just write an async iterator method <code class="language-plaintext highlighter-rouge">async IAsyncEnumerable&lt;int&gt; GetItemsAsync(int maxItems)</code> because that does not give you access to any cancellation token.</p><p>You also cannot write an async iterator method <code class="language-plaintext highlighter-rouge">async IAsyncEnumerable&lt;int&gt; GetItemsAsync(int maxItems, CancellationToken token)</code> because:</p><ol><li>if a method has its own cancellation token and wants to enumerate an async enumerable it received, it could not use the token it wants with that enumerable (the cancellation token would be already built into the enumerable),</li><li>the same cancellation token would be used in every enumerator when the collection is enumerated multiple times,</li></ol><p>So instead, you need to implement the enumerable yourself and put your business logic in <code class="language-plaintext highlighter-rouge">async IAsyncEnumerator&lt;int&gt; GetAsyncEnumerable(CancellationToken cancellationToken)</code>.</p><p>Here’s what that looks like:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="k">static</span><span class="n">IAsyncEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="nf">GetItemsAsync</span><span class="p">(</span><span class="kt">int</span><span class="n">maxItems</span><span class="p">)</span><span class="p">=&gt;</span><span class="k">new</span><span class="nf">MyCancellableCollection</span><span class="p">(</span><span class="n">maxItems</span><span class="p">);</span><span class="k">class</span><span class="nc">MyCancellableCollection</span><span class="p">:</span><span class="n">IAsyncEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="p">{</span><span class="k">private</span><span class="kt">int</span><span class="n">_maxItems</span><span class="p">;</span><span class="k">internal</span><span class="nf">MyCancellableCollection</span><span class="p">(</span><span class="kt">int</span><span class="n">maxItems</span><span class="p">)</span><span class="p">=&gt;</span><span class="n">_maxItems</span><span class="p">=</span><span class="n">maxItems</span><span class="p">;</span><span class="k">public</span><span class="k">async</span><span class="n">IAsyncEnumerator</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="nf">GetAsyncEnumerator</span><span class="p">(</span><span class="n">CancellationToken</span><span class="n">cancellationToken</span><span class="p">)</span><span class="p">{</span><span class="c1">// Your method body using:</span><span class="c1">// - `_maxItems`</span><span class="c1">// - `cancellationToken.ThrowIfCancelled();`</span><span class="c1">// - `await` and `yield` constructs</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><del>We recognize that this involves boilerplate. We are considering some language design options to further simplify this.</del>
Since originally publishing this, we’ve solved this problem more elegantly by extending the language. The next section explains the updated design.<h3 id="writing-an-async-enumerable-supporting-cancellation-improved-method">Writing an async enumerable supporting cancellation (improved method)</h3><p>In an updated preview of C# 8.0 (shipping in Visual Studio 2019 version 16.1), we’ll be adding support for the <code class="language-plaintext highlighter-rouge">[EnumeratorCancellation]</code> token. The attribute allows you to write an async-iterator method, returning <code class="language-plaintext highlighter-rouge">IAsyncEnumerable&lt;T&gt;</code> as you intend, but tells the compiler to store the token from <code class="language-plaintext highlighter-rouge">GetAsyncEnumerator(CancellationToken)</code> into one of your method’s parameters.</p><p>In the above example, you would just declare the method as <code class="language-plaintext highlighter-rouge">async IAsyncEnumerable&lt;int&gt; GetItemsAsync(int maxItems, [EnumeratorCancellation] CancellationToken token)</code>. Because of the attribute, the <code class="language-plaintext highlighter-rouge">token</code> parameter will be set to a synthesized cancellation token that combines two token: the one passed as an argument to the method, and the other given to <code class="language-plaintext highlighter-rouge">GetAsyncEnumerator</code>. This synthesized token gets cancelled when either of the two given tokens is cancelled.</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span><span class="n">IAsyncEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="nf">GetItemsAsync</span><span class="p">(</span><span class="kt">int</span><span class="n">maxItems</span><span class="p">,</span><span class="p">[</span><span class="n">EnumeratorCancellation</span><span class="p">]</span><span class="n">CancellationToken</span><span class="n">token</span><span class="p">)</span><span class="p">{</span><span class="c1">// Your method body using:</span><span class="c1">// - `_maxItems`</span><span class="c1">// - `token.ThrowIfCancelled();`</span><span class="c1">// - `await` and `yield` constructs</span><span class="p">}</span></code></pre></div></div><p>Note: in dev16.1 preview5, we have not yet implemented this method of combining tokens, we took a simpler approach whereby any non-default token given to <code class="language-plaintext highlighter-rouge">GetAsyncEnumerator</code> will override the token passed as an argument. I expect to implement the more elaborate method of combining tokens in preview6 timeframe.</p><h3 id="consuming-an-async-enumerable-with-cancellation">Consuming an async enumerable with cancellation</h3><p>With the above implementation, if you wrote <code class="language-plaintext highlighter-rouge">await foreach (var item in GetItemsAsync(maxItems: 10)) ...</code>, a <code class="language-plaintext highlighter-rouge">default</code> cancellation token would be passed to the cancellable method.</p><p>Users of enumerables could try and expand the low-level code for an <code class="language-plaintext highlighter-rouge">await foreach</code> to pass a token, but that’s a terrible solution (defeats the purpose of <code class="language-plaintext highlighter-rouge">await foreach</code>).</p><p>To help with this, we provide a <code class="language-plaintext highlighter-rouge">WithCancellation&lt;T&gt;(this IAsyncEnumerable&lt;T&gt; source, CancellationToken cancellationToken)</code><a href="https://github.com/dotnet/coreclr/pull/21939">extension method</a>. It allows you to pass your <code class="language-plaintext highlighter-rouge">token</code> in:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span><span class="n">item</span><span class="k">in</span><span class="nf">GetItemsAsync</span><span class="p">(</span><span class="n">maxItems</span><span class="p">:</span><span class="m">10</span><span class="p">).</span><span class="nf">WithCancellation</span><span class="p">(</span><span class="n">token</span><span class="p">))</span><span class="p">...</span></code></pre></div></div><p>This helper method wraps the enumerable from <code class="language-plaintext highlighter-rouge">GetItemsAsync</code> along with the given cancellation token. When <code class="language-plaintext highlighter-rouge">GetAsyncEnumerator()</code> is invoked on this wrapper, it calls <code class="language-plaintext highlighter-rouge">GetAsyncEnumerator(token)</code> on the underlying enumerable.</p><h3 id="appendix-relevant-interfaces">Appendix: relevant interfaces</h3><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span><span class="nn">System.Threading</span><span class="p">;</span><span class="k">namespace</span><span class="nn">System.Collections.Generic</span><span class="p">{</span><span class="c1">/// &lt;summary&gt;Exposes an enumerator that provides asynchronous iteration over values of a specified type.&lt;/summary&gt;</span><span class="c1">/// &lt;typeparam name="T"&gt;The type of values to enumerate.&lt;/typeparam&gt;</span><span class="k">public</span><span class="k">interface</span><span class="nc">IAsyncEnumerable</span><span class="p">&lt;</span><span class="k">out</span><span class="n">T</span><span class="p">&gt;</span><span class="p">{</span><span class="c1">/// &lt;summary&gt;Returns an enumerator that iterates asynchronously through the collection.&lt;/summary&gt;</span><span class="c1">/// &lt;param name="cancellationToken"&gt;A &lt;see cref="CancellationToken"/&gt; that may be used to cancel the asynchronous iteration.&lt;/param&gt;</span><span class="c1">/// &lt;returns&gt;An enumerator that can be used to iterate asynchronously through the collection.&lt;/returns&gt;</span><span class="n">IAsyncEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="nf">GetAsyncEnumerator</span><span class="p">(</span><span class="n">CancellationToken</span><span class="n">cancellationToken</span><span class="p">=</span><span class="k">default</span><span class="p">);</span><span class="p">}</span><span class="c1">/// &lt;summary&gt;Supports a simple asynchronous iteration over a generic collection.&lt;/summary&gt;</span><span class="c1">/// &lt;typeparam name="T"&gt;The type of objects to enumerate.&lt;/typeparam&gt;</span><span class="k">public</span><span class="k">interface</span><span class="nc">IAsyncEnumerator</span><span class="p">&lt;</span><span class="k">out</span><span class="n">T</span><span class="p">&gt;</span><span class="p">:</span><span class="n">IAsyncDisposable</span><span class="p">{</span><span class="c1">/// &lt;summary&gt;Advances the enumerator asynchronously to the next element of the collection.&lt;/summary&gt;</span><span class="c1">/// &lt;returns&gt;</span><span class="c1">/// A &lt;see cref="ValueTask{Boolean}"/&gt; that will complete with a result of &lt;c&gt;true&lt;/c&gt; if the enumerator</span><span class="c1">/// was successfully advanced to the next element, or &lt;c&gt;false&lt;/c&gt; if the enumerator has passed the end</span><span class="c1">/// of the collection.</span><span class="c1">/// &lt;/returns&gt;</span><span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">bool</span><span class="p">&gt;</span><span class="nf">MoveNextAsync</span><span class="p">();</span><span class="c1">/// &lt;summary&gt;Gets the element in the collection at the current position of the enumerator.&lt;/summary&gt;</span><span class="n">T</span><span class="n">Current</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="p">}</span><span class="p">}</span><span class="c1">/// &lt;summary&gt;Provides a mechanism for releasing unmanaged resources asynchronously.&lt;/summary&gt;</span><span class="k">public</span><span class="k">interface</span><span class="nc">IAsyncDisposable</span><span class="p">{</span><span class="c1">/// &lt;summary&gt;</span><span class="c1">/// Performs application-defined tasks associated with freeing, releasing, or</span><span class="c1">/// resetting unmanaged resources asynchronously.</span><span class="c1">/// &lt;/summary&gt;</span><span class="n">ValueTask</span><span class="nf">DisposeAsync</span><span class="p">();</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>Original code for <a href="https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Collections/Generic/IAsyncEnumerable.cs">IAsyncEnumerable</a>, <a href="https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/Collections/Generic/IAsyncEnumerator.cs">IAsyncEnumerator</a> and <a href="https://github.com/dotnet/corefx/blob/master/src/Common/src/CoreLib/System/IAsyncDisposable.cs">IAsyncDisposable</a>.</p><p>For further details, see the <a href="https://github.com/dotnet/roslyn/blob/master/docs/features/async-streams.md">async-streams design doc</a>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>