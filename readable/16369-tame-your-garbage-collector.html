<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Tame your Garbage Collector -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Tame your Garbage Collector</h1><div><div><textarea id="source">

class: center, middle

# Tame your Garbage Collector
### Konrad Kokosa

---
exclude: true

https://en.wikipedia.org/wiki/Zabbaleen

---
class: center

### @KonradKokosa
#### http://prodotnetmemory.com
.center[![:scale 60%](images\announce.png)]

---
class: center, middle, image
background-image: url(images\\railways.jpg)
.white[
# Java - many choices
.footer[Source: https://www.videoblocks.com/]
]

---
### Java

.center[![:scale 80%](images\javagc1.png)]

---

### Java

```cmd
-server -Xms24G -Xmx24G -XX:PermSize=512m -XX:+UseG1GC 
-XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=20 
-XX:ConcGCThreads=5 
-XX:InitiatingHeapOccupancyPercent=70
```

--
or...

```cmd
-server -Xss4096k -Xms12G -Xmx12G -XX:MaxPermSize=512m 
-XX:+HeapDumpOnOutOfMemoryError -verbose:gc -Xmaxf1 
-XX:+UseCompressedOops -XX:+DisableExplicitGC -XX:+AggressiveOpts 
-XX:+ScavengeBeforeFullGC -XX:CMSFullGCsBeforeCompaction=10 
-XX:CMSInitiatingOccupancyFraction=80 -XX:+UseParNewGC 
-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode 
-XX:+CMSIncrementalPacing -XX:+CMSParallelRemarkEnabled 
-XX:GCTimeRatio=19 -XX:+UseAdaptiveSizePolicy 
-XX:MaxGCPauseMillis=500 -XX:+PrintGCTaskTimeStamps 
-XX:+PrintGCApplicationStoppedTime -XX:+PrintHeapAtGC 
-XX:+PrintTenuringDistribution -XX:+PrintGCDetails 
-XX:+PrintGCDateStamps -XX:+PrintGCApplicationConcurrentTime 
-XX:+PrintTenuringDistribution -Xloggc:gc.log
```

---
exclude: true
class: center, middle

![:scale 80%](images\cargo.jpg)

### Cargo cult programming.

---
exclude: true
class: center, middle

![:scale 80%](images\cargo.jpg)

### Cargo cult .linethrough[programming] configuring.

---
class: center, middle, image
background-image: url(images\\greenfield.jpg)
.green[
# .NET - ...
.footer[Source: https://kvaes.wordpress.com/]
]


---
class: center, middle

# But why different/custom GCs at all?!

---
class: center, middle

![:scale 50%](images\giant-swiss-army-knife.jpg)

#### Jack of all trades is master of none.

---
class: center, middle

### Different workloads, different applications, different expectations...

---
class: center, middle

![:scale 80%](images\gccloud.png)

---
class: center, middle

## GC Pause vs Overhead

---
class: middle

.center[![:scale 100%](images\gc_pauses.png)]

---
class: center, middle

## Throughput vs Latency vs Memory consumption

---
class: middle

.center[![:scale 70%](images\latency.png)]

---
class: center, middle

# "Simple" knobs

--
## GC modes


---
class: center, middle

## Workstation vs. Server Mode

---

.pull-left[
### Workstation
* designed mostly for responsiveness needed in interactive, UI-based applications
	* pauses as short as possible
	* good citizen in the whole interactive environment
* GCs will happen more frequently
	* they will have less work to do (.good[shorter pauses])
	* .good[lower memory usage]
* single Managed Heap 
	* .bad[does not] utilize resources optimally
	* segments are smaller
]
.pull-right[
### Server
* designed for simultaneous, request-based processing applications
	* .good[big throughput] (pauses may be unpredictable, final throughput is what matters)
	* "give me all" citizen in the system
* GCs will happen less frequently
	* pauses may be longer
	* .bad[higher memory usage] ("floating garbage", less aggressive)
* multiple Managed Heaps
	* by default - as many as logical CPU cores
	* .good[optimal resources usage]
]

---
class: center, middle

## Non-Concurrent vs. Concurrent Mode

---

.pull-left[
### Non-Concurrent
* "stop the world" - all managed threads are suspended
* no work, no allocations, no nothing...
* optimal as no floating garbage, everything collected
]
.pull-right[
### Concurrent
* ***some parts*** of GC runs concurrently with managed threads
* normal work possible (mostly)
* produces some floating garbage
* very hard ("impossible") compacting
]

---

.pull-left[
### Non-Concurrent
* "stop the world" - all managed threads are suspended
* .bad[no work], no allocations, no nothing...
* .good[optimal] as no floating garbage, everything collected
]
.pull-right[
### Concurrent
* ***some parts*** of GC runs concurrently with managed threads
* .good[normal work possible] (mostly)
* produces some .bad[floating garbage]
* .bad[very hard] ("impossible") compacting
]

---
class: middle, center
# Configuration

---

#### .NET Framework

`[appName].exe.config`/`Web.config` file:

```xml
&lt;configuration&gt;
   ...
   &lt;runtime&gt;&lt;gcserver enabled="true" /&gt;&lt;gcconcurrent enabled="true" /&gt;&lt;/runtime&gt;&lt;/configuration&gt;
```

#### .NET Core

`SomeApplication.runtimeconfig.json` file:

```json
{
   "runtimeOptions": {
      ...
      "configProperties": {
         "System.GC.Server": true,
         "System.GC.Concurrent": true
      }
   }
}
```

---

#### .NET Core (cont.)

Environment variables:
* `COMPlus_gcServer=0|1`
* `COMPlus_gcConcurrent=0|1`

---
#### Workstation Non-concurrent

.center[![:scale 100%](images\workNC.png)]
--

 
Usage:
* Never...?

--
* A highly saturated environment 

--
* Environment with many lightweight web applications (like "dockerized" microservices)

---
exclude:true

#### Workstation Concurrent (Before 4.0)

.center[![:scale 100%](images\workC.png)]
 
Usage:
* Default in pre-.NET 4.0 UI

---
#### Intro - concurrent GC anatomy

.center[![:scale 100%](images\workB_details.png)]

* **A** - initial step (stop the world)
* **B** - concurrent mark
* **C** - final mark (stop the world)
* **D** - concurrent sweep

---
#### Background Workstation (Since 4.0)

.center[![:scale 100%](images\workB.png)]
--

* most of the time - concurrent

--
	* blocking full-GCs are very rare

--
	* bigger fragmentation - **BGC does not compact**

--
	* concurrent mark - additional "floating" garbage

--
	* concurrent sweep of gen2/LOH - LOH allocations not allowed

--
 
Usage:

--
* Default since .NET 4.0 in Console/Desktop

--
	* but beware of Windows Services!

--
* Saturated environment 

--
* Environment with many lightweight web applications (like "dockerized" microservices)

---

#### Server Non-concurrent

.center[![:scale 100%](images\serverNC.png)]

--
 
Usage:

--
* Default in pre-.NET 4.5 Server

--
	* could be so long that GC notifications were invented

---
### Additional Server GC knobs:

GCHeapCount:

```xml
&lt;configuration&gt;&lt;runtime&gt;&lt;gcserver enabled="true" /&gt;&lt;gcheapcount enabled="6" /&gt;&lt;/runtime&gt;&lt;/configuration&gt;
```

---
### Additional Server GC knobs:

GCNoAffinitize and GCHeapAffinitizeMask:

```xml
&lt;configuration&gt;&lt;runtime&gt;&lt;gcserver enabled="true" /&gt;&lt;gcheapcount enabled="6" /&gt;&lt;gcnoaffinitize enabled="true" /&gt;&lt;gcheapaffinitizemask enabled="144" /&gt;&lt;/runtime&gt;&lt;/configuration&gt;
```

* `GCNoAffinitize` specifies to not affinitize the Server GC threads with CPUs
* you may manually "assign" heap to the CPUs by `GCHeapAffinitizeMask`.

---

#### Scenario: 32 CPUs, four applications. Creating 8 Managed Heaps per app and assigning 8 cores to each:

Process 1: 

```xml
&lt;gcserver enabled="true" /&gt;&lt;gcheapcount enabled="8" /&gt;&lt;gcheapaffinitizemask enabled="255" /&gt;
```

Process 2: 

```xml
&lt;gcserver enabled="true" /&gt;&lt;gcheapcount enabled="8" /&gt;&lt;gcheapaffinitizemask enabled="65280" /&gt;
```

Process 3: 

```xml
&lt;gcserver enabled="true" /&gt;&lt;gcheapcount enabled="8" /&gt;&lt;gcheapaffinitizemask enabled="16711680" /&gt;
```

Process 4: 

```xml
&lt;gcserver enabled="true" /&gt;&lt;gcheapcount enabled="8" /&gt;&lt;gcheapaffinitizemask enabled="4278190080" /&gt;
```

---

#### Background Server

.center[![:scale 80%](images\serverB.png)]

--
 
Usage:

--
* default GC for most server-based applications

--
* "give me all" UI clients (i.e. medical single stations)

--
	, i.e. dnSpy (https://github.com/0xd4d/dnSpy):
	.center[![:scale 60%](images\dnspy.png)]

---
class: center, middle

|             | Concurrent (false)         | Concurrent (true)      |
| ----------- |:-------------------------- |:-----------------------|
| **Workstation** | Non-Concurrent Workstation | Background Workstation |
| **Server**      | Non-Concurrent Server      | Background Server      |

---
class: center, middle

|             | Concurrent (false)         | Concurrent (true)      |
| ----------- |:-------------------------- |:-----------------------|
| **Workstation** | Non-Concurrent Workstation | .good[Background Workstation] |
| **Server**      | Non-Concurrent Server      | .good[Background Server]      |

---

.center[https://github.com/aspnet/AspNetCore/issues/3409]

.center[![:scale 70%](images\githubissue3409.png)]

---

.center[![:scale 70%](images\githubissue3409_3.png)]

--

.center[![:scale 70%](images\githubissue3409_2.png)]

---

.center[![:scale 70%](images\githubissue3409_3.png)]

.pull-left[
.center[![:scale 100%](images\githubissue3409_2.png)]
]
.pull-right[
Let's see:
* 3,902,825,040 bytes / 48 heaps (cores) ~= 77 MB / heap
* and BTW... there were still over 20 GB RAM left!
]

---

.center[https://github.com/aspnet/AspNetCore/issues/1976]

.center[![:scale 100%](images\44788824-bafd9500-aba3-11e8-9603-49f50578efed.png)]

---

.center[[CoreCLR issue 18044](https://github.com/dotnet/coreclr/issues/18044), [CoreCLR issue 19060](https://github.com/dotnet/coreclr/issues/19060) - aka *docker/k8s OOM issue*]

.center[![:scale 70%](images\githubissue18044.png)]

--
.center[
[Troubleshooting high memory usage with ASP.NET Core on Kubernetes](https://blog.markvincze.com/troubleshooting-high-memory-usage-with-asp-net-core-on-kubernetes/)
![:scale 70%](images\increasing-memory-1.png)]
]

---
.center[Solution - fixed in .NET Core 2.1.5 (https://github.com/dotnet/coreclr/pull/19650):]
.center[![:scale 70%](images\githubpull19650.png)]

---
.center[Solution - fixed in .NET Core 2.1.5... almost:]
.center[![:scale 70%](images\githubissue18044_2.png)]

---

#### Prior to .NET Core 3.0:
By default 25% of the container limit is dedicated for the non-GC heap usage (native/runtime memory...). But it may be not enough.

#### Since .NET Core 3.0 (https://github.com/dotnet/coreclr/pull/22180):
Two more configuration knobs:
* GCHeapHardLimit - specifies a hard limit for the GC heap
* GCHeapHardLimitPercent - specifies a percentage of the physical memory this process is allowed to use

Additionally:
* minimum segment size is 16 MB 
	* on 40 CPUs machine and 160 MB limit - it would be only 4 MB per segment! Now it will 10 segments with 16 MB. 

More to read:
* [Running with Server GC in a Small Container Scenario Part 0](https://blogs.msdn.microsoft.com/maoni/2018/11/16/running-with-server-gc-in-a-small-container-scenario-part-0/)
* [Running with Server GC in a Small Container Scenario Part 1 – Hard Limit for the GC Heap](https://blogs.msdn.microsoft.com/maoni/2019/02/04/running-with-server-gc-in-a-small-container-scenario-part-1-hard-limit-for-the-gc-heap/)

---
class: center, middle

|             | Concurrent (false)         | Concurrent (true)      |
| ----------- |:-------------------------- |:-----------------------|
| **Workstation** | Non-Concurrent Workstation | .good[Background Workstation] |
| **Server**      | Non-Concurrent Server      | .good[Background Server]      |

--
# But MEASURE!

---
exclude: true
.center[![:scale 60%](images\workB_events.png)]

---
# Perfview

```
perfview /GCCollectOnly /nogui /accepteula /NoV2Rundown /NoNGENRundown /NoRundown /merge:true /zip:true /BufferSize:3000 
         /CircularMB:3000 /MaxCollectSec:7200 collect
```

---
### Perfview - *GCCollectOnly* trace

.center[![:scale 80%](images\Figure0710.png)]

--

.center[![:scale 100%](images\Figure0711.png)]

---
exclude: true
class: middle, center

### `GCSettings.LargeObjectHeapCompactionMode`

---
exclude: true
class: middle, center

![:scale 80%](images\Figure1010.png)

---
class: middle, center

# Latency Modes

---
class: middle

```csharp
public enum GCLatencyMode
{
   Batch = 0,
   Interactive = 1,
   LowLatency = 2,
   SustainedLowLatency = 3,
   NoGCRegion = 4
}
```

```csharp
GCSettings.LatencyMode = GCLatencyMode.Batch;
```

---
exclude: true
## Batch Latency Mode

* not concerned about pauses length, but rather throughput or memory usage
* default latency setting for non-concurrent GCs
* disable the possibility of Background GC 
* background GC threads:
	* for Server GC - are infinitely suspended
	* for Workstation GC - destroyed after 20 seconds timeout (`GCTerminateConcurrentThread` event)

---
exclude: true
## Interactive Latency Mode

* short pauses are most desired, even in cost of memory usage
* default setting for all concurrent GCs
* enables Background GC possibility
* background GC threads:
	* will be created if they do not exist already (`GCCreateConcurrentThread` event)

---
## LowLatency Mode

* short as possible pauses are essential, at any cost
* available only in Workstation GC mode
* disables all full-GCs (both concurrent and non-concurrent)
	* possible only with low-memory system notification or via explicit trigger
* results:
	* pause times will be really short
	* memory usage will likely grow vastly

---
## LowLatency Mode (cont.)

```csharp
GCLatencyMode oldMode = GCSettings.LatencyMode;
RuntimeHelpers.PrepareConstrainedRegions();
try
{
*   GCSettings.LatencyMode = GCLatencyMode.LowLatency;
   //Perform time-sensitive, short work here
}
finally
{
   GCSettings.LatencyMode = oldMode;
}
```

---
## SustainedLowLatency Mode

* short as possible pauses are essential
* introduced in .NET Framework 4.5
* only non-concurrent full-GCs are disabled
	* possible only with low-memory system notification or via explicit trigger
* only if runtime has started with the concurrent setting enabled (regardless of later `Batch`/`Interactive` changes)
* results:
	* very good compromise between latency and memory usage

---
## SustainedLowLatency Mode (cont.)

```csharp
internal static class GCManager
{
/// &lt;summary&gt;
/// Call this method to suppress expensive blocking Gen 2 garbage GCs in
/// scenarios where high-latency is unacceptable (e.g. processing typing input).
///
/// Blocking GCs will be re-enabled automatically after a short duration unless
/// UseLowLatencyModeForProcessingUserInput is called again.
/// &lt;/summary&gt;
internal static void UseLowLatencyModeForProcessingUserInput()
{
  var currentMode = GCSettings.LatencyMode;
  var currentDelay = s_delay;
  if (currentMode != GCLatencyMode.SustainedLowLatency)
  {
    GCSettings.LatencyMode = GCLatencyMode.SustainedLowLatency;
    // Restore the LatencyMode a short duration after the
    // last request to UseLowLatencyModeForProcessingUserInput.
    currentDelay = new ResettableDelay(s_delayMilliseconds);
    currentDelay.Task.SafeContinueWith(_ =&gt; RestoreGCLatencyMode(currentMode), ...);
    s_delay = currentDelay;
  }
  if (currentDelay != null)
  {
    currentDelay.Reset();
  }
}
```

---
## NoGCRegion Latency Mode

* attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available
* introduced in .NET Framework 4.6
* different API:

 ```csharp
bool GC.TryStartNoGCRegion(long totalSize)
bool GC.TryStartNoGCRegion(long totalSize, 
                               bool disallowFullBlockingGC)
bool GC.TryStartNoGCRegion(long totalSize, long lohSize)
bool GC.TryStartNoGCRegion(long totalSize, long lohSize,
                               bool disallowFullBlockingGC)
```

---
## NoGCRegion Latency Mode (cont.)

```csharp
// in case of previous finally block not executed
if (GCSettings.LatencyMode == GCLatencyMode.NoGCRegion)
   GC.EndNoGCRegion();
if (GC.TryStartNoGCRegion(1024, true))
{
   try
   {
      // Do some work.
   }
   finally
   {
      try
      {
         GC.EndNoGCRegion();
      }
      catch (InvalidOperationException ex)
      {
         // Log message
      }
   }
}
```


---

# Latency Optimization Goals

CoreCLR comment: 

*"Latency modes required user to have specific GC knowledge (e.g., budget, full-blocking GC). We are trying to move away from them
as it makes a lot more sense for users to tell us what’s the most important out of the performance aspects that make sense to them"*

--

Four such goals (levels) are planned:
* *memory footprint* (level 1) - pauses can be long and more frequent but .good[heap size stays small],
* *throughput* (level 2) - pauses are unpredictable and not very frequent, .good[promoting throughput],
* *balance between pauses and throughput* (level 3) - pauses are more predictable and more frequent. The longest pauses are
shorter than level 1 pauses,
* *short pauses* (level 4) - pauses are more predictable and more frequent. The longest pauses are shorter than level 3 pauses.

---

# Latency Optimization Goals

CoreCLR comment: 

*"Latency modes required user to have specific GC knowledge (e.g., budget, full-blocking GC). We are trying to move away from them
as it makes a lot more sense for users to tell us what’s the most important out of the performance aspects that make sense to them"*

Four such goals (levels) are planned:
* ** *memory footprint* (level 1) - pauses can be long and more frequent but .good[heap size stays small],**
* *throughput* (level 2) - pauses are unpredictable and not very frequent, .good[promoting throughput],
* ** *balance between pauses and throughput* (level 3) - pauses are more predictable and more frequent. The longest pauses are
shorter than level 1 pauses,**
* *short pauses* (level 4) - pauses are more predictable and more frequent. The longest pauses are shorter than level 3 pauses.

Available via `GCLatencyLevel` Configuration Knob (i.e. `COMPlus_GCLatencyLevel` environment variable).

---
exclude: true
class: middle, center

# VM Hoarding

---
exclude: true

.center[![:scale 70%](images\vmhoarding.png)]

---
exclude: true

### Configuration
* CLR Hosting STARTUP_HOARD_GC_VM flag 

---
class: middle, center

# But what GC am I using?!

---
* use ETW/LLTNg mechanism
* every time ETW session starts and stops, .NET runtime sends additional diagnostics events 
* we should be interested in the event `Microsoft-Windows-DotNETRuntimeRundown/Runtime/Start`

```cmd
.\etrace.exe --other Microsoft-Windows-DotNETRuntimeRundown --event
Runtime/Start --pid=21316
Processing start time: 30/04/2018 10:21:51
Runtime/Start [PNAME= PID=21316 TID=14648 TIME=30/04/2018 10:21:51]
ClrInstanceID = 9
Sku = 1
BclMajorVersion = 4
BclMinorVersion = 0
BclBuildNumber = 0
BclQfeNumber = 0
VMMajorVersion = 4
VMMinorVersion = 0
VMBuildNumber = 30319
VMQfeNumber = 0
*StartupFlags = 1
StartupMode = 1
CommandLine = F:\IIS\nopCommerce\Nop.Web.exe
ComObjectGuid = 00000000-0000-0000-0000-000000000000
RuntimeDllPath = C:\Windows\Microsoft.NET\Framework\v4.0.30319\clr.dll
```

---

```csharp
public enum StartupFlags
{
	None = 0,
	CONCURRENT_GC = 0x000001,
	LOADER_OPTIMIZATION_SINGLE_DOMAIN = 0x000002,
	LOADER_OPTIMIZATION_MULTI_DOMAIN = 0x000004,
	LOADER_SAFEMODE = 0x000010,
	LOADER_SETPREFERENCE = 0x000100,
	SERVER_GC = 0x001000,
	HOARD_GC_VM = 0x002000,
	SINGLE_VERSION_HOSTING_INTERFACE = 0x004000,
	LEGACY_IMPERSONATION = 0x010000,
	DISABLE_COMMITTHREADSTACK = 0x020000,
	ALWAYSFLOW_IMPERSONATION = 0x040000,
	TRIM_GC_COMMIT = 0x080000,
	ETW = 0x100000,
	SERVER_BUILD = 0x200000,
	ARM = 0x400000,
}
```

--

* i.e. ASP.NET on IIS has value 208919 (`0x33017`): .highlight[`CONCURRENT_GC`], `LOADER_OPTIMIZATION_SINGLE_DOMAIN`, `LOADER_OPTIMIZATION_MULTI_DOMAIN`, `LOADER_SAFEMODE`, .highlight[`SERVER_GC`], .highlight[`HOARD_GC_VM`], `LEGACY_IMPERSONATION`, `DISABLE_COMMITTHREADSTACK`

---
class: center, middle

# That's all! Thank .red[**you**]! Any questions?!

    </textarea></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>