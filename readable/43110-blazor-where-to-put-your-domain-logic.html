<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Blazor - Where to put your domain logic -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Blazor - Where to put your domain logic</h1>
    <section class="post-content"> <p>It&#x2019;s fair to say you&#x2019;re not lacking choices when it comes to choosing how to build the UI part of your web applications these days.</p> <p>Blazor, Razor Pages, MVC, React.js; the list is endless.</p> <p>But with all this choice comes &#x201C;framework fatigue&#x201D;.</p> <p>When something like Blazor arrives on the scene, your inner voice is basically saying&#x2026;</p> <blockquote>
<p>Oh great, now I have to:</p> <p>a) learn YAF (yet another framework)</p> <p>b) decide whether to rebuild all my existing applications</p> <p>c) cross my fingers and hope MS doesn&#x2019;t pivot in another direction so I have to start from scratch again</p>
</blockquote> <p>Blazor itself takes a little learning.</p> <p>You need to re-program your brain to think in components, figure out how to make components talk to each other, work out how to retrieve data etc.</p> <p>It&#x2019;s a lot to learn, and it takes investment (of time and potentially money).</p> <p>But, there&#x2019;s another, more fundamental factor which dictates whether its a) dead simple or b) unbelievably difficult for you to adopt new UI frameworks.</p> <p>And that&#x2019;s your application architecture&#x2026;</p> <p>In this article we&#x2019;ll:</p> <ul>
<li>Explore some of the common architectural pitfalls</li>
<li>Look at some alternatives</li>
<li>See how to implement these alternatives in your Blazor apps</li>
</ul> <h2 id="all-mixed-up-and-nowhere-to-go">All mixed up and nowhere to go</h2> <p>Let&#x2019;s say you&#x2019;ve got an existing online store application built using MVC.</p> <p>It&#x2019;s been built over a number of years, and has grown bigger and bigger, to the point where a lot of important domain/business knowledge is tied up in the code.</p> <p>Now imagine, for whatever reason, a lot of this business logic is buried in controllers.</p> <blockquote>
<p>You can tell if your controllers are doing too much; open one up and if it&#x2019;s big (hundreds or even thousands of lines long), there&#x2019;s probably some business logic mixed up in there!</p>
</blockquote> <p>Business logic is a slippery thing, it has a nasty habit of finding its way into all sorts of weird and wonderful places.</p> <p>But once it gets mixed up with presentation concerns, your ability to &#x201C;plug in&#x201D; different UI frameworks, without expending a lot of time and energy (and taking on a lot of risk) , is severely hampered.</p> <p><center>
<img src="https://jonhilton.net/img/image-20191127102657670.png" alt="image-20191127102657670">
</center></p> <p>In this scenario, if you were to take the image above and light up the boxes which have business logic, you&#x2019;d find most of the boxes lit up.</p> <p>Business logic is pretty much anything which isn&#x2019;t directly related to which markup to show on the screen, so:</p> <ul>
<li>Calculations, formulae</li>
<li>Rules</li>
<li>Auth (permission to perform certain actions, roles etc)</li>
<li>Queries to retrieve data</li>
<li>Commands to change (and save) data etc.</li>
</ul> <p>In our MVC application, this business logic has permeated every part of our app (controllers, views etc).</p> <h2 id="just-swap-out-the-ui-simple-right">Just &#x201C;swap out the UI&#x201D;, simple right?</h2> <p>Now imagine you want to adopt Blazor.</p> <p>The bit you want to &#x201C;swap out&#x201D; is the MVC bit; from this:</p> <p><center>
<img src="https://jonhilton.net/img/image-20191127102545354.png" alt="image-20191127102545354">
</center></p> <p>To Blazor components:</p> <p><center>
<img src="https://jonhilton.net/img/image-20191127102740422.png" alt="image-20191127102740422">
</center></p> <p>But you can&#x2019;t! Because there&#x2019;s important business logic buried in those controllers, possibly even in the views.</p> <p>At this point, you have little choice but to go an a &#x201C;business logic hunt&#x201D; (<a href="https://www.jointhebearhunt.com/">you&#x2019;re not scared</a>).</p> <p>You need to find all the business logic which has found its way into your controllers and views, and move it somewhere else.</p> <p>Depending on the size of your application, this might take hours or days (or, let&#x2019;s face it, weeks).</p> <p>But it&#x2019;s not just the controllers and views you need to worry about; you also run into&#x2026;</p> <h2 id="massively-distributed-features">Massively Distributed Features!</h2> <p>This is 100% a term I just made up, and it might sound like good thing, but it isn&#x2019;t.</p> <p>This is when your features: things like viewing products, adding and updating products, fulfilling orders, are broken up into hundreds of tiny pieces and distributed (or, you might say, littered) all around your application.</p> <p>Want to pull together all the code for checkout, and move it to Blazor? Good luck, the code is split between 15 services, 3 repositories, 2 controllers, 2 views and 6 partials!</p> <p>If you find yourself wearing out the F12 key on your keyboard trying to understand a feature in your application, you might have massively distributed features.</p> <p>Here&#x2019;s a relatively tame example:</p> <p><center>
<img src="https://jonhilton.net/img/image-20191127111055763.png" alt="image-20191127111055763">
</center></p> <p>All the connections (arrows in the diagram) between controllers, services and repositories, represent a path you have to walk down if you&#x2019;re going to understand what a feature does.</p> <p>In any large application this picture is likely to be significantly more complicated and confusing.</p> <p>Suddenly, migrating your application just got harder.</p> <p>You have to spend a lot of time finding all the logic for your features in your services, managers and repositories, unpicking and consolidating it into one cohesive piece, just so you can migrate one feature to Blazor.</p> <h2 id="improving-your-architecture">Improving your architecture</h2> <p>So, we know mixing presentation concerns with business logic, and spreading features around all parts of your codebase makes it harder to manage, maintain and ultimately migrate to a different UI framework.</p> <p>What&#x2019;s the alternative? Whether you&#x2019;re migrating an existing app, or starting with a nice clean fresh Blazor application, there are a few things you can do to keep your application in check.</p> <h3 id="keep-the-ui-logic-separate">Keep the UI logic separate</h3> <p>Give yourself a fighting chance by separating UI and business logic concerns.</p> <p>Ideally, Blazor components, Razor pages and MVC views/controllers will handle:</p> <ul>
<li>Markup</li>
<li>UI logic (showing, hiding elements etc) markup</li>
<li>UI interactions, such as button clicks</li>
<li>Client side validation (because client-side validation provides a better user experience)</li>
<li>Orchestrating with the business domain (to change, query data etc.)</li>
</ul> <p><center>
<img src="https://jonhilton.net/img/image-20191127110823806.png" alt="image-20191127110823806">
</center></p> <p>Beyond that, delegate to the business domain for everything else.</p> <p>When it comes to your domain. Consider organising your code around your features.</p> <p>I&#x2019;m a big fan of feature folders, especially when starting on a reasonably small application (such as our online store example).</p> <p>The key is to really pause and think about the features you need to build.</p> <p>Talk through the system, identify and document the important domain concepts (products, fulfillment etc) then hone in on the features you need to build e.g. viewing products, increasing stock, checkout.</p> <p>Once you&#x2019;ve done that you&#x2019;re ready to start on a feature and at this point I typically create feature folders.</p> <p>The feature folder is where your feature takes shape; components, views, controllers all go in here.</p> <p>Here&#x2019;s an example in Blazor.</p> <p><img src="https://jonhilton.net/img/image-20191127112204699.png" alt="image-20191127112204699"></p> <p>With this approach, it&#x2019;s trivial to find what you&#x2019;re looking for (need to work on Checkout? go to the Checkout folder) and easier to build and maintain specific parts of the application.</p> <h3 id="use-vertical-slices">Use Vertical Slices</h3> <p>Abstractions such as repositories, services, managers etc. tend to spread horizontally.</p> <p>Once a class has a few methods it has this nasty habit of attracting more, and more, and more, growing bigger and bigger.</p> <p><img src="https://jonhilton.net/img/image-20191127115604277.png" alt="image-20191127115604277"></p> <p>As these layers grow, their responsibilities become muddled and it becomes harder to track down what code goes where.</p> <p>One alternative is to use something which Jimmy Bogard refers to as <a href="https://jimmybogard.com/vertical-slice-architecture/">Vertical Slices</a>.</p> <p><img src="https://jonhilton.net/img/image-20191127120232838.png" alt="image-20191127120232838"></p> <p>The gist is, when you&#x2019;re working on any given feature you&#x2019;re going to work on all the &#x201C;layers&#x201D; of that application: the UI code, the business logic, persistence.</p> <p>For example, imagine you need to add a new <code>LastSold</code> field to a product.</p> <p>You&#x2019;re going to:</p> <ul>
<li>Add the field to the entity (so it can be persisted and retrieved)</li>
<li>Map that new field in your business logic (presumably some kind of query, exposed via a service)</li>
<li>Update your Blazor component (or MVC View etc.) to display it</li>
<li>Update validation, business rules etc. to accommodate the new field</li>
</ul> <p>In a big project built on layers, this can lead to a non-trivial amount of time jumping between all the different parts of your code to make this simple change (and it&#x2019;s not always easy to find the code you need to change).</p> <p>With vertical slices, you can avoid creating all those layers and abstractions up front, and instead take a pragmatic approach to building the feature, starting with the least abstractions you can possibly get away with, and crucially, all the code for the feature is one place (after all, if it changes together it belongs together!).</p> <p>One way to adopt vertical slices is to use something like <a href="https://github.com/jbogard/MediatR">MediatR</a> to represent each discreet feature in your system.</p> <p>For example, imagine you want to retrieve a list of products (to show in your Blazor component).</p> <p>You could create a MediatR query, which returns a model for this specific feature (use case).</p> <pre><code class="language-csharp">public class List 
{
    public class Query : IRequest&lt;Model&gt;
    {
    }

    public class Model
    {
        public List&lt;ProductSummary&gt; Products { get; set; }

        public class ProductSummary
        {
            public int Id { get; set; }
            public string Name { get; set; }
        }
    }
}  
</code></pre> <p>This represents a very specific query in the application; which returns a list of products including a little summary detail (<code>id</code> and <code>name</code>).</p> <p>You&#x2019;ll need a handler to actually retrieve the data from a database and map it to <code>ProductSummary</code>.</p> <pre><code class="language-csharp">public class QueryHandler : IRequestHandler&lt;Query, Model&gt;
{
    private readonly ApplicationDbContext dbContext;

    public QueryHandler(ApplicationDbContext dbContext)
    {
        this.dbContext = dbContext;
    }

    public async Task&lt;Model&gt; Handle(Query request, CancellationToken cancellationToken)
    {
        var list = dbContext.Products.Select(x =&gt; new Model.ProductSummary
            {
                Id = x.Id,
                Name = x.Name
            });

        return new Model { Products = list.ToList() };
    }
}
</code></pre> <p>This feature is now ready to be used wherever you see fit; including:</p> <p><strong>From a Blazor component</strong></p> <pre><code class="language-csharp">@using MediatR
@inject IMediator Mediator

&lt;h3&gt;List&lt;/h3&gt;

&lt;ul&gt;
    @foreach (var product in Model.Products)
    {
        &lt;li&gt;
            &lt;a href=&quot;/@product.Id&quot;&gt; @product.Name&lt;/a&gt;
        &lt;/li&gt;
    }
&lt;/ul&gt;

@code {

    protected Queries.List.Model Model;

    protected override async Task OnInitializedAsync()
    {
        Model = await Mediator.Send(new Queries.List.Query());
    }

}
</code></pre> <p><strong>From an MVC controller</strong></p> <pre><code class="language-csharp">public class ProductController : Controller
{
    private readonly IMediator _mediator;

    public Product(IMediator mediator)
    {
        _mediator = mediator;
    }

    public async Task&lt;IActionResult&gt; Index()
    {
        var list = await _mediator.Send(new List.Query());
        return View(list);
    }
}
</code></pre> <p>And just as easily from an API controller, or a Razor Page.</p> <p>This single abstraction (the mediator) manages a few things, it:</p> <ul>
<li>Abstracts at your feature level (encapsulate your features)</li>
<li>Makes your features easily re-usable</li>
<li>Gives you a common interface for executing your business logic from pretty much UI framework</li>
</ul> <p>It works just as well for commands (that change your application&#x2019;s data).</p> <pre><code class="language-csharp">public class Delete
{
    public class Command : IRequest
    {
        public int Id { get; set; }   
    }
}
</code></pre> <p>Which you can also call from anywhere:</p> <pre><code class="language-csharp">@using Architecture.Features.Products.Commands
@using MediatR
@inject IMediator Mediator

&lt;h3&gt;List&lt;/h3&gt;

&lt;ul&gt;
    @foreach (var product in Model.Products)
    {
        &lt;li&gt;
            &lt;a href=&quot;/@product.Id&quot;&gt; @product.Name&lt;/a&gt;
            &lt;button @onclick=&quot;()=&gt;Delete(product.Id)&quot;&gt;Delete&lt;/button&gt;
        &lt;/li&gt;
    }
&lt;/ul&gt;

@code {

    protected Queries.List.Model Model;

    protected override async Task OnInitializedAsync()
    {
        Model = await Mediator.Send(new Queries.List.Query());
    }

    protected async Task Delete(int id)
    {
        await Mediator.Send(new Delete.Command { Id = id });
    }

}
</code></pre> <h3 id="where-to-put-your-handlers">Where to put your handlers</h3> <p>You can start by keeping your MediatR classes (queries and commands) in the feature folder.</p> <p><img src="https://jonhilton.net/img/image-20191127151240203.png" alt="image-20191127151240203"></p> <p>These then represent the distinct operations you can perform on your business domain: list products, update product etc.</p> <h2 id="where-next">Where next?</h2> <p>You can go a long way with this approach, and for a percentage of many applications you can keep the code in a Mediator handler.</p> <p>When your app grows, and features accrue more complex business logic, you can always refactor to push your code &#x201C;down&#x201D; out of the mediator handlers, ideally into domain objects which represent core truths about your business domain.</p> <p>But whatever you do, for your own sake and the next developer&#x2019;s, try to keep domain logic out of your controllers, views and Blazor components!.</p> <p>In summary:</p> <ul>
<li>Separate your UI and business domain concerns</li>
<li>Make it easy to call your business domain from any UI framework</li>
<li>Encapsulate (and organise your code around) features</li>
</ul> <p>Ultimately pragmatism always wins, just try to avoid accidentally boxing yourself into a corner along the way!</p> <h3>Next up</h3> </section>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>