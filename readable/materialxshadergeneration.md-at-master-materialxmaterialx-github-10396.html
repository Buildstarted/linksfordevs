<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>materialx/MaterialX</h1>
        <p>
Reading time: 25-31 minutes        </p>
        <p><a href="https://github.com/materialx/MaterialX/blob/master/documents/DeveloperGuide/ShaderGeneration.md">https://github.com/materialx/MaterialX/blob/master/documents/DeveloperGuide/ShaderGeneration.md</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    <article itemprop="text">
<h2>1.1 Scope</h2>
<p>A shader generation framework is implemented as part of MaterialX. This can help applications to transform the agnostic MaterialX data description into executable shader code for a specific renderer. A library module named MaterialXGenShader contains the core shader generation features, and support for specific languages resides in separate libraries, e.g. <a href="https://github.com/materialx/MaterialX/blob/master/source/MaterialXGenGlsl">MaterialXGenGlsl</a>, <a href="https://github.com/materialx/MaterialX/blob/master/source/MaterialXGenOsl">MaterialXGenOsl</a>.</p>
<p>Note that this system has no runtime and the output produced is source code, not binary executable code. The source code produced needs to be compiled by a shading language compiler before being executed by the renderer. See Figure 1 for a high level overview of the system.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/materialx/MaterialX/blob/master/documents/Images/shadergen.png"><img src="https://github.com/materialx/MaterialX/raw/master/documents/Images/shadergen.png" alt="Shader generation with multiple shader generators"></a></p>
<p><strong>Figure 1</strong>: Shader generation with multiple shader generators.</p>
<h2>1.2 Languages and Shader Generators</h2>
<p>The MaterialX description is free from device specific details and all implementation details needs to be taken care of by shader generators. There is one shader generator for each supported shading language. However for each language there can also be variations needed for different renderers. For example; OpenGL renderers supporting GLSL can use forward rendering or deferred rendering, each with very different requirements for how the shaders are constructed. Another example is different renderers supporting OSL but with different sets of closures or closure parameters. Hence a separate shader generator can be defined for each language/target combination.</p>
<p>Class inheritance and specialization is used to create support for new languages or to customize existing language support for a new target. To add a new shader generator for a target you add a new C++ class derived from the base class <code>ShaderGenerator</code>, or one of the existing derived shader generator classes (<code>GlslShaderGenerator</code>, <code>OslShaderGenerator</code>, etc.), and override the methods you need to customize. You might also need to derive a new <code>Syntax</code> class, which is used to handle syntactical differences between different shading languages. Then you need to make sure there are implementations defined for all the nodes you want to support, standard library nodes and nodes from other libraries, by either reusing existing implementations where applicable or adding in new ones. See <strong>1.3 Node Implementations</strong> on how that is done.</p>
<p>Note that a shader generator doesnâ€™t need to be defined at the time when node definitions are added. New shader generators can be added later, and node implementations for new targets can be added for existing nodes.</p>
<h2>1.3 Node Implementations</h2>
<p>There are four different methods to define the implementation of a node:</p>
<ol>
<li>Using an inline expression.</li>
<li>Using a function written in the target language.</li>
<li>Using a nodegraph that defines the operation performed by the node.</li>
<li>Using a C++ class that emits code dynamically during shader generation.</li>
</ol>
<p>In the following sub-sections each of these methods are explained. For all methods the implementation is tied to a specific <code>nodedef</code> with a well defined interface of typed inputs and outputs.</p>
<h3>1.3.1 Inline Expression</h3>
<p>Provided code generators support a very simple expression language for inlining code. This is useful for simple nodes where the operation can be expressed as a single line of code. Inlining will reduce the number of function calls and produce more compact code. The syntax to use is the same as the target shading language, with the addition of using the nodeâ€™s input ports as variables wrapped in double curly brackets: <code>{{input}}</code>. The code generator will replace these variables with values assigned or connected to the respective inputs. Figure 2 gives an example.</p>
<p>Connecting the expression to the nodedef is done using an <code>&lt;implementation&gt;</code> element as seen in
Figure 2. The file extension is used to differentiate inline expressions from source code functions, using <code>filename.inline</code>.</p>
<div><pre>// Nodedef elements for node &lt;<span>add</span>&gt;
&lt;<span>nodedef</span> <span>name</span>=<span><span>"</span>ND_add_float<span>"</span></span> <span>node</span>=<span><span>"</span>add<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span> <span>defaultinput</span>=<span><span>"</span>in1<span>"</span></span>&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>in1<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>/&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>in2<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>/&gt;
&lt;/<span>nodedef</span>&gt;
&lt;<span>nodedef</span> <span>name</span>=<span><span>"</span>ND_add_color3<span>"</span></span> <span>node</span>=<span><span>"</span>add<span>"</span></span> <span>type</span>=<span><span>"</span>color3<span>"</span></span> <span>defaultinput</span>=<span><span>"</span>in1<span>"</span></span>&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>in1<span>"</span></span> <span>type</span>=<span><span>"</span>color3<span>"</span></span>/&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>in2<span>"</span></span> <span>type</span>=<span><span>"</span>color3<span>"</span></span>/&gt;
&lt;/<span>nodedef</span>&gt;
&lt;... more types ...&gt;

// Implementation elements for node &lt;<span>add</span>&gt;
&lt;<span>implementation</span> <span>name</span>=<span><span>"</span>IM_add_float<span>"</span></span> <span>nodedef</span>=<span><span>"</span>ND_add_float<span>"</span></span> <span>file</span>=<span><span>"</span>mx_add.inline<span>"</span></span>/&gt;
&lt;<span>implementation</span> <span>name</span>=<span><span>"</span>IM_add_color3<span>"</span></span> <span>nodedef</span>=<span><span>"</span>ND_add_color3<span>"</span></span> <span>file</span>=<span><span>"</span>mx_add.inline<span>"</span></span>/&gt;
&lt;... more types ...&gt;

// Nodedef elements for node &lt;<span>mix</span>&gt;
&lt;<span>nodedef</span> <span>name</span>=<span><span>"</span>ND_mix_float<span>"</span></span> <span>node</span>=<span><span>"</span>mix<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span> <span>defaultinput</span>=<span><span>"</span>bg<span>"</span></span>&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>fg<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>/&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>bg<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>/&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>mix<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>/&gt;
&lt;/<span>nodedef</span>&gt;
&lt;<span>nodedef</span> <span>name</span>=<span><span>"</span>ND_mix_color3<span>"</span></span> <span>node</span>=<span><span>"</span>mix<span>"</span></span> <span>type</span>=<span><span>"</span>color3<span>"</span></span> <span>defaultinput</span>=<span><span>"</span>bg<span>"</span></span>&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>fg<span>"</span></span> <span>type</span>=<span><span>"</span>color3<span>"</span></span>/&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>bg<span>"</span></span> <span>type</span>=<span><span>"</span>color3<span>"</span></span>/&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>mix<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>/&gt;
&lt;/<span>nodedef</span>&gt;
&lt;... more types ...&gt;

// Implementation elements for node &lt;<span>mix</span>&gt;
&lt;<span>implementation</span> <span>name</span>=<span><span>"</span>IM_mix_float<span>"</span></span> <span>nodedef</span>=<span><span>"</span>ND_mix_float<span>"</span></span> <span>file</span>=<span><span>"</span>mx_mix.inline<span>"</span></span>/&gt;
&lt;<span>implementation</span> <span>name</span>=<span><span>"</span>IM_mix_color3<span>"</span></span> <span>nodedef</span>=<span><span>"</span>ND_mix_color3<span>"</span></span> <span>file</span>=<span><span>"</span>mx_mix.inline<span>"</span></span>/&gt;
&lt;... more types ...&gt;</pre></div>
<div><pre><span><span>//</span> File 'mx_add.inline' contains:</span>
{{in1}} + {{in2}}

<span><span>//</span> File 'mx_mix.inline' contains:</span>
<span>mix</span>({{bg}}, {{fg}}, {{mix}})</pre></div>
<p><strong>Figure 2</strong>: Inline expressions for implementing nodes <code>&lt;add&gt;</code> and <code>&lt;mix&gt;</code>.</p>
<h3>1.3.2 Shading Language Function</h3>
<p>For nodes that canâ€™t be implemented by inline expressions a function definition can be used instead. The function signature should match the nodedefs interface with inputs and outputs. See Figure 3 for an example. Connecting the source code to the nodedef is done using an <code>&lt;implementation&gt;</code> element, see the <a href="https://github.com/materialx/MaterialX/blob/master/documents/Specification/MaterialX.v1.36.Spec.pdf">MaterialX specification</a> for more information.</p>
<div><pre>// Nodedef element
&lt;<span>nodedef</span> <span>name</span>=<span><span>"</span>ND_image_color3<span>"</span></span> <span>node</span>=<span><span>"</span>image<span>"</span></span> <span>type</span>=<span><span>"</span>color3<span>"</span></span> <span>default</span>=<span><span>"</span>0.0, 0.0, 0.0<span>"</span></span>&gt;
  &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>file<span>"</span></span> <span>type</span>=<span><span>"</span>filename<span>"</span></span>/&gt;
  &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>layer<span>"</span></span> <span>type</span>=<span><span>"</span>string<span>"</span></span> <span>value</span>=<span><span>"</span><span>"</span></span>/&gt;
  &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>default<span>"</span></span> <span>type</span>=<span><span>"</span>color3<span>"</span></span> <span>value</span>=<span><span>"</span>0.0, 0.0, 0.0<span>"</span></span>/&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>texcoord<span>"</span></span> <span>type</span>=<span><span>"</span>vector2<span>"</span></span> <span>defaultgeomprop</span>=<span><span>"</span>texcoord<span>"</span></span>/&gt;
  &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>filtertype<span>"</span></span> <span>type</span>=<span><span>"</span>string<span>"</span></span> <span>value</span>=<span><span>"</span>linear<span>"</span></span>/&gt;
  &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>uaddressmode<span>"</span></span> <span>type</span>=<span><span>"</span>string<span>"</span></span> <span>value</span>=<span><span>"</span>periodic<span>"</span></span>/&gt;
  &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>vaddressmode<span>"</span></span> <span>type</span>=<span><span>"</span>string<span>"</span></span> <span>value</span>=<span><span>"</span>periodic<span>"</span></span>/&gt;
  &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>framerange<span>"</span></span> <span>type</span>=<span><span>"</span>string<span>"</span></span> <span>value</span>=<span><span>"</span><span>"</span></span>/&gt;
  &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>frameoffset<span>"</span></span> <span>type</span>=<span><span>"</span>integer<span>"</span></span> <span>value</span>=<span><span>"</span>0<span>"</span></span>/&gt;
  &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>frameendaction<span>"</span></span> <span>type</span>=<span><span>"</span>string<span>"</span></span> <span>value</span>=<span><span>"</span>black<span>"</span></span>/&gt;
&lt;/<span>nodedef</span>&gt;

// Implementation element
&lt;<span>implementation</span> <span>name</span>=<span><span>"</span>IM_image_color3_osl<span>"</span></span> <span>nodedef</span>=<span><span>"</span>ND_image_color3<span>"</span></span>
    <span>file</span>=<span><span>"</span>mx_image_color3.osl<span>"</span></span> <span>language</span>=<span><span>"</span>osl<span>"</span></span>/&gt;</pre></div>
<div><pre><span><span>//</span> File 'mx_image_color3.osl' contains:</span>
<span>void</span> <span>mx_image_color3</span>(string file, string layer, color defaultvalue,
                     vector2 texcoord, string filtertype,
                     string uaddressmode, string vaddressmode,
                     string framerange, <span>int</span> frameoffset,
                     string frameendaction, output color out)
{
    <span><span>//</span> Sample the texture</span>
    out = <span>texture</span>(file, texcoord.<span>x</span>, texcoord.<span>y</span>,
                  <span><span>"</span>interp<span>"</span></span>, filtertype,
                  <span><span>"</span>subimage<span>"</span></span>, layer,
                  <span><span>"</span>missingcolor<span>"</span></span>, defaultvalue,
                  <span><span>"</span>wrap<span>"</span></span>, uaddressmode);
}</pre></div>
<p><strong>Figure 3</strong>: Shading language function's implementation for node <code>&lt;image&gt;</code> in OSL.</p>
<h3>1.3.3 Node Graph Implementation</h3>
<p>As an alternative to defining source code, there is also an option to reference a nodegraph as the implementation of a nodedef. The only requirement is that the nodegraph and nodedef have matching inputs and outputs.</p>
<p>This is useful for creating a compound for a set of nodes performing some common operation. It can then be referenced as a node inside other nodegraphs. It is also useful for creating compatibility graphs for unknown nodes. If a node is created by some third party, and its implementation is unknown or proprietary, a compatibility graph can be created using known nodes and be referenced as a stand-in implementation. Linking a nodegraph to a nodedef is done by simply setting a nodedef attribute on the nodegraph definition. See Figure 4 for an example.</p>
<div><pre>&lt;<span>nodedef</span> <span>name</span>=<span><span>"</span>ND_checker_float<span>"</span></span> <span>node</span>=<span><span>"</span>checker<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>&gt;
  &lt;<span>input</span> <span>name</span>=<span><span>"</span>scale<span>"</span></span> <span>type</span>=<span><span>"</span>vector2<span>"</span></span> <span>value</span>=<span><span>"</span>8.0, 8.0<span>"</span></span>/&gt;
&lt;/<span>nodedef</span>&gt;
&lt;<span>nodegraph</span> <span>name</span>=<span><span>"</span>IM_checker_float<span>"</span></span> <span>nodedef</span>=<span><span>"</span>ND_checker_float<span>"</span></span>&gt;
  &lt;<span>texcoord</span> <span>name</span>=<span><span>"</span>texcoord1<span>"</span></span> <span>type</span>=<span><span>"</span>vector2<span>"</span></span>&gt;
    &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>index<span>"</span></span> <span>type</span>=<span><span>"</span>integer<span>"</span></span> <span>value</span>=<span><span>"</span>0<span>"</span></span>/&gt;
  &lt;/<span>texcoord</span>&gt;
  &lt;<span>multiply</span> <span>name</span>=<span><span>"</span>mult1<span>"</span></span> <span>type</span>=<span><span>"</span>vector2<span>"</span></span>&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in1<span>"</span></span> <span>type</span>=<span><span>"</span>vector2<span>"</span></span> <span>nodename</span>=<span><span>"</span>texcoord1<span>"</span></span>/&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in2<span>"</span></span> <span>type</span>=<span><span>"</span>vector2<span>"</span></span> <span>interfacename</span>=<span><span>"</span>scale<span>"</span></span>/&gt;
  &lt;/<span>multiply</span>&gt;
  &lt;<span>swizzle</span> <span>name</span>=<span><span>"</span>swizz_x<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in<span>"</span></span> <span>type</span>=<span><span>"</span>vector2<span>"</span></span> <span>nodename</span>=<span><span>"</span>mult1<span>"</span></span>/&gt;
    &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>channels<span>"</span></span> <span>type</span>=<span><span>"</span>string<span>"</span></span> <span>value</span>=<span><span>"</span>x<span>"</span></span>/&gt;
  &lt;/<span>swizzle</span>&gt;
  &lt;<span>swizzle</span> <span>name</span>=<span><span>"</span>swizz_y<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in<span>"</span></span> <span>type</span>=<span><span>"</span>vector2<span>"</span></span> <span>nodename</span>=<span><span>"</span>mult1<span>"</span></span>/&gt;
    &lt;<span>parameter</span> <span>name</span>=<span><span>"</span>channels<span>"</span></span> <span>type</span>=<span><span>"</span>string<span>"</span></span> <span>value</span>=<span><span>"</span>y<span>"</span></span>/&gt;
  &lt;/<span>swizzle</span>&gt;
  &lt;<span>floor</span> <span>name</span>=<span><span>"</span>floor1<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span> <span>nodename</span>=<span><span>"</span>swizz_x<span>"</span></span>/&gt;
  &lt;/<span>floor</span>&gt;
  &lt;<span>floor</span> <span>name</span>=<span><span>"</span>floor2<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span> <span>nodename</span>=<span><span>"</span>swizz_y<span>"</span></span>/&gt;
  &lt;/<span>floor</span>&gt;
  &lt;<span>add</span> <span>name</span>=<span><span>"</span>add1<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in1<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span> <span>nodename</span>=<span><span>"</span>floor1<span>"</span></span>/&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in2<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span> <span>nodename</span>=<span><span>"</span>floor2<span>"</span></span>/&gt;
  &lt;/<span>add</span>&gt;
  &lt;<span>modulo</span> <span>name</span>=<span><span>"</span>mod1<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span>&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in1<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span> <span>nodename</span>=<span><span>"</span>add1<span>"</span></span>/&gt;
    &lt;<span>input</span> <span>name</span>=<span><span>"</span>in2<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span> <span>value</span>=<span><span>"</span>2.0<span>"</span></span>/&gt;
  &lt;/<span>modulo</span>&gt;
  &lt;<span>output</span> <span>name</span>=<span><span>"</span>out<span>"</span></span> <span>type</span>=<span><span>"</span>float<span>"</span></span> <span>nodename</span>=<span><span>"</span>mod1<span>"</span></span>/&gt;
&lt;/<span>nodegraph</span>&gt;</pre></div>
<p><strong>Figure 4</strong>: Checker node implementation using a nodegraph.</p>
<h3>1.3.4 Dynamic Code Generation</h3>
<p>In some situations static source code is not enough to implement a node. The code might need to be customized depending on parameters set on the node. Or for a hardware render target vertex streams or uniform inputs might need to be created in order to supply the data needed for the node implementation.</p>
<p>In this case, a C++ class can be added to handle the implementation of the node. The class should be derived from the base class <code>ShaderNodeImpl</code>. It should specify what language and target it is for by overriding <code>getLanguage()</code> and <code>getTarget()</code>. It can also be specified to support all languages or all targets by setting the identifier to an empty string, as done for the target identifier in the example below. It then needs to be registered for a <code>ShaderGenerator</code> by calling <code>ShaderGenerator::registerImplementation()</code>. See Figure 5 for an example.</p>
<p>When a <code>ShaderNodeImpl</code> class is used for a nodedef the corresponding <code>&lt;implementation&gt;</code>
element doesnâ€™t need a file attribute, since no static source code is used. The <code>&lt;implementation&gt;</code> element will then act only as a declaration that there exists an implementation for the nodedef for a particular language and target.</p>
<p>Note that by using a <code>ShaderNodeImpl</code> class for your node's implementation it is no longer data driven, as in the other three methods above. So it's recommneded to use this only when inline expressions or static source code functions are not enough to handle the implementation of a node.</p>
<div><pre><span><span>//</span>/ Implementation of â€™foo' node for OSL</span>
<span>class</span> <span>FooOsl</span> : <span>public</span> <span>ShaderNodeImpl</span>
{
  <span>public:</span>
    <span>static</span> ShaderNodeImplPtr <span>create</span>() { <span>return</span> std::make_shared&lt;FooOsl&gt;(); }

    <span>const</span> string&amp; <span>getLanguage</span>() <span>const</span> <span>override</span> { <span>return</span> LANGUAGE_OSL; }
    <span>const</span> string&amp; <span>getTarget</span>() <span>const</span> <span>override</span> { <span>return</span> EMPTY_STRING; }

    <span>void</span> <span>emitFunctionDefinition</span>(<span>const</span> ShaderNode&amp; node, GenContext&amp; context,
                                ShaderStage&amp; stage) <span>const</span> <span>override</span>
    {
        <span><span>//</span> Emit function definition if needed for the node</span>
    }

    <span>void</span> <span>emitFunctionCall</span>(<span>const</span> ShaderNode&amp; node, GenContext&amp; context,
                          ShaderStage&amp; stage) <span>const</span> <span>override</span>
    {
        <span><span>//</span> Emit function call, or inline shader code, for the node</span>
    }
};</pre></div>
<div><pre><span>OslShaderGenerator::OslShaderGenerator</span>() :
    ShaderGenerator(std::make_shared&lt;OslSyntax&gt;())
{
    ...
    <span><span>//</span> Register foo implementation for nodedefs it should be used for</span>
    <span>registerImplementation</span>(<span><span>"</span>IM_foo_color2_osl<span>"</span></span>, FooOsl::create);
    <span>registerImplementation</span>(<span><span>"</span>IM_foo_color3_osl<span>"</span></span>, FooOsl::create);
    <span>registerImplementation</span>(<span><span>"</span>IM_foo_color4_osl<span>"</span></span>, FooOsl::create);
    ...
}</pre></div>
<p><strong>Figure 5</strong>: C++ class for dynamic code generation.</p>
<h2>1.4 Shader Generation Steps</h2>
<p>This section outlines the steps taken in general to produce a shader from the MaterialX description. The <code>ShaderGenerator</code> base class and its supporting classes will handle this for you, but itâ€™s good to know the steps involved if custom changes are needed to support a new target.</p>
<p>Shader generation supports generating a shader starting from either an <code>output</code> element or a <code>shaderref</code> element in a material. The <code>output</code> can be an output port on a nodegraph or an output element inserted anywhere in a node network. A shader is generated by calling your shader generator class with either of these element types as input. The given element and all dependencies upstream will be translated into a single monolithic shader in the target shading language.</p>
<div><pre><span><span>//</span> Generate a shader starting from the given element, translating</span>
<span><span>//</span> the element and all dependencies upstream into shader code.</span>
ShaderPtr <span>ShaderGenerator::generate</span>(<span>const</span> string&amp; name,
                                    ElementPtr element,
                                    GenContext&amp; context)</pre></div>
<p>The shader generation process can be divided into initialization and code generation. The initialization consists of a number of steps:</p>
<ol>
<li>Create an optimized version of the graph as a tree with the given input element as root, and with only the used dependencies connected upstream. This involves removing unused paths in the graph, converting constant nodes to constant values, and adding in any default nodes for ports that are unconnected but have default connections specified. Removal of unused paths typically involves constant folding and pruning of conditional branches that will never be taken. Since the resulting shader in the end will be compiled by a shading language compiler, and receive a lot of additional optimizations, we donâ€™t need to do too much work in this optimization step. However, a few graph level optimizations can make the resulting shader a lot smaller and save time and memory during shader compilation. It will also produce more readable source code which is good for debugging purposes. This optimization step is also a good place to do other custom optimizations needed by a particular target. For example simplification of the graph, which could involve substituting expensive nodes with approximate nodes, identification of common subgraphs that can be merged, etc.</li>
<li>The nodes are sorted in topological order. Since a node can be referenced by many other nodes in the graph we need an ordering of the nodes so that nodes that have a dependency on other nodes come after all dependent nodes. This step also makes sure there are no cyclic dependencies in the graph.</li>
<li>The stages for the shader are created. For a HW shader this is normally a vertex stage and a pixel stage, but other stages can be added as needed. At the minumum a single pixel stage is required, so even shaders that has no concept of multiple stages, like OSL, needs to have a single pixel stage created.</li>
<li>The shader stages interface of uniforms and varyings are established. This consists of the graph interface ports that are in use, as well as internal ports that have been published to the interface (an example of the latter is for a hardware shader generator where image texture filenames get converted to texture samplers which needs to be published in order to be bound by the target application). Each node in the graph is also called for a chance to create any uniforms or varyings needed by its implementation.</li>
<li>Information about scope is tracked for each node. This information is needed to handle branching by conditional nodes. For example, if a node is used only by a particular branch on a varying conditional we want to calculate this node only inside that scope, when that corresponding branch is taken. A node can be used in global scope, in a single conditional scope or by multiple conditional scopes.</li>
</ol>
<p>The output from the initialization step is a new graph representation constructed using the classes <code>ShaderNode</code>, <code>ShaderInput</code>, <code>ShaderOutput</code>, <code>ShaderGraph</code>, etc. This is a graph representation optimized for shader generation with quick access and traversal of nodes and ports, as well as caching of extra information needed by shader generation.</p>
<p>After initialization the code generation steps are handled by the <code>ShaderGenerator</code> class and derived classes. This part is specific to the particular generator being used, but in general it consists of the following steps:</p>
<ol>
<li>Typedefs are emitted as specified by the Syntax class.</li>
<li>Function definitions are emitted for all the atomic nodes that have shading
language functions for their implementations. For nodes using dynamic code generation their <code>ShaderNodeImpl</code> instances are called to generate the functions. For nodes that are implemented by graphs a function definition representing the graph computation is emitted.</li>
<li>The shader signature is emitted with all uniforms set to default values. The shader uniforms can later be accessed on the returned <code>Shader</code> instance in order for applications to be able to bind values to them.</li>
<li>The function calls for all nodes are emitted, in the right dependency order, propagating
output results from upstream nodes as inputs to downstream nodes. Inline expressions are
emitted instead of functions calls for nodes that use this.</li>
<li>The final shader output is produced and assigned to the shader output variable.</li>
</ol>
<p>Note that if a single monolithic shader for the whole graph is not appropriate for your system the generator can be called on <code>output</code> elements at any point in your graph, and generate code for sub-parts. It is then up to the application to decide where to split the graph, and to assemble the shader code for sub-parts after all have been generated.</p>
<h2>1.5 Shader Stages</h2>
<p>Creation of multiple shader stages is supported. This is needed in order to generate separate code for multiple stages on hardware render targets. A <code>pixel</code> stage must always be created by all targets, even for shading languages like OSL that natively doensn't have a concept of stages. The stage is where the generated shader code is stored as well as all uniforms, inputs and outputs for the shader. This is handled by the <code>ShaderStage</code> class, and the data can be retrieved from it when generation is completed.</p>
<p>One or more <code>ShaderStage</code> instances are created and stored on the <code>Shader</code> class. In addition to the <code>pixel</code> stage, hardware generators always specify a <code>vertex</code> stage. If additional stages are needed they can be added as well. When creating shader input variables you specify which stage the variable should be used in, see 1.7 for more information on shader variable creation.</p>
<p>Node implementations using static source code (function or inline expressions) are always emitted to the <code>pixel</code> stage. Controlling the <code>vertex</code> stage, or other stages, is not supported using static source code. In order to do that you must use dynamic code generation with a custom <code>ShaderNodeImpl</code> sub-class for your node. You are then able to control how it affects all stages separately. Inside <code>emitFunctionDefinition</code> and <code>emitFunctionCall</code> you can add separate sections for each stage using begin/end shader stage macros. Figure 6 shows how the texcoord node for GLSL is emitting different code into the <code>vertex</code> and <code>pixel</code> stages.</p>
<h2>1.6 Shader Variables</h2>
<p>When generating a shader from a node graph or shaderref the inputs and parameters on those elements will be published as shader uniforms on the resulting shader. A listing of the created uniforms can be read from the produced <code>Shader</code> and <code>ShaderStage</code> instances. The shader uniforms can then be presented to the user and have their values set by the application.</p>
<h3>1.6.1 Variable Creation</h3>
<p>Adding new uniforms, input and outputs to a shader stage is done by first creating a <code>VariableBlock</code> to store them. There are some predefined identifiers for commonly used variable blocks. For uniforms there are e.g. one named <code>HW::PUBLIC_UNIFORMS</code> and another named <code>HW::PRIVATE_UNIFORMS</code>. Public is used for uniforms to be published to the user, as described above, and private is used for uniforms needed by node implementations but set by the application and not published. For hardware targets there are also specific variable blocks called <code>connector blocks</code> which are used to send data from one stage to another, connecting the stages. A connector block named <code>HW::VERTEX_DATA</code> is used for sending data from the  <code>vertex</code> stage to the <code>pixel</code> stage. Variable block creation and handling can be customized as needed by each shader generator target.</p>
<p>All variable blocks can be queried and accessed by the application from the <code>ShaderStage</code> instances after generation.</p>
<p>Figure 6 shows how creation of shader inputs and connector variables are done for a node implementation that requires this.</p>
<div><pre><span><span>//</span> Implementation of 'texcoord' node for GLSL</span>
<span>class</span> <span>TexCoordGlsl</span> : <span>public</span> <span>ShaderNodeImpl</span>
{
  <span>public:</span>
    <span>static</span> ShaderNodeImplPtr <span>create</span>()
    {
        <span>return</span> std::make_shared&lt;TexCoordGlsl&gt;();
    }

    <span>void</span> <span>TexCoordNodeGlsl::createVariables</span>(<span>const</span> ShaderNode&amp; node, GenContext&amp;,
                                           Shader&amp; shader) <span>const</span>
    {
        <span>const</span> ShaderOutput* output = node.<span>getOutput</span>();
        <span>const</span> ShaderInput* indexInput = node.<span>getInput</span>(INDEX);
        <span>const</span> string <span>index</span> = indexInput ? indexInput-&gt;<span>getValue</span>()-&gt;<span>getValueString</span>() : <span><span>"</span>0<span>"</span></span>;

        ShaderStage&amp; vs = shader.<span>getStage</span>(Stage::VERTEX);
        ShaderStage&amp; ps = shader.<span>getStage</span>(Stage::PIXEL);

        <span>addStageInput</span>(HW::VERTEX_INPUTS, output-&gt;<span>getType</span>(), <span><span>"</span>i_texcoord_<span>"</span></span> + <span>index</span>, vs);
        <span>addStageConnector</span>(HW::VERTEX_DATA, output-&gt;<span>getType</span>(), <span><span>"</span>texcoord_<span>"</span></span> + <span>index</span>, vs, ps);
    }

    <span>void</span> <span>TexCoordNodeGlsl::emitFunctionCall</span>(<span>const</span> ShaderNode&amp; node,
                                            GenContext&amp; context,
                                            ShaderStage&amp; stage) <span>const</span>
    {
        <span>const</span> ShaderGenerator&amp; shadergen = context.<span>getShaderGenerator</span>();

        <span>const</span> ShaderInput* indexInput = node.<span>getInput</span>(INDEX);
        <span>const</span> string <span>index</span> = indexInput ? indexInput-&gt;<span>getValue</span>()-&gt;<span>getValueString</span>() : <span><span>"</span>0<span>"</span></span>;
        <span>const</span> string variable = <span><span>"</span>texcoord_<span>"</span></span> + <span>index</span>;

        <span>BEGIN_SHADER_STAGE</span>(stage, Stage::VERTEX)
            VariableBlock&amp; vertexData = stage.<span>getOutputBlock</span>(HW::VERTEX_DATA);
            <span>const</span> string prefix = vertexData.<span>getInstance</span>() + <span><span>"</span>.<span>"</span></span>;
            ShaderPort* texcoord = vertexData[variable];
            <span>if</span> (!texcoord-&gt;<span>isEmitted</span>())
            {
                shadergen.<span>emitLine</span>(prefix + texcoord-&gt;<span>getVariable</span>() + <span><span>"</span> = i_<span>"</span></span> + variable, stage);
                texcoord-&gt;<span>setEmitted</span>();
            }
        <span>END_SHADER_STAGE</span>(shader, Stage::VERTEX)

        <span>BEGIN_SHADER_STAGE</span>(stage, Stage::PIXEL)
            VariableBlock&amp; vertexData = stage.<span>getInputBlock</span>(HW::VERTEX_DATA);
            <span>const</span> string prefix = vertexData.<span>getInstance</span>() + <span><span>"</span>.<span>"</span></span>;
            ShaderPort* texcoord = vertexData[variable];
                shadergen.<span>emitLineBegin</span>(stage);
            shadergen.<span>emitOutput</span>(node.<span>getOutput</span>(), <span>true</span>, <span>false</span>, context, stage);
            shadergen.<span>emitString</span>(<span><span>"</span> = <span>"</span></span> + prefix + texcoord-&gt;<span>getVariable</span>(), stage);
            shadergen.<span>emitLineEnd</span>(stage);
        <span>END_SHADER_STAGE</span>(shader, Stage::PIXEL)
    }
};</pre></div>
<p><strong>Figure 6</strong>: Implementation of node <code>texcoord</code> in GLSL. Using a <code>ShaderNodeImpl</code> sub-class in order to control shader variable creation and code generation into separate shader stages.</p>
<h3>1.6.2 Variable Naming Convention</h3>
<p>Creating shader variables and binding values to them needs to be done in agreement with the shader generator side and application side. The application must know what a variable is for in order to bind meaningful data to it. One way of handling this is by using semantics. All shader variables created can be assigned a semantic if that is used by the target application. Shader generation does not impose a specific set of semantics to use, so for languages and applications that use this any semantics can be used. For languages that do not use semantics a variable naming convention needs to be used instead.</p>
<p>Built-in shader generators and accompanying node implementations have a naming convention for shader variables. A custom shader generator that derives from and takes advantage of built-in features should preferably use the same convention. Uniform variables are prefixed with <code>u_</code> and vertex inputs with <code>i_</code> . For languages not using semantics, Figure 7 shows the naming used for variables (inputs and uniforms) with predefined binding rules:</p>
<p>App data input variables</p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>TYPE</th>
<th>BINDING</th>
</tr>
</thead>
<tbody>
<tr>
<td>i_position</td>
<td>vec3</td>
<td>Vertex position in object space.</td>
</tr>
<tr>
<td>i_normal</td>
<td>vec3</td>
<td>Vertex normal in object space.</td>
</tr>
<tr>
<td>i_tangent</td>
<td>vec3</td>
<td>Vertex tangent in object space.</td>
</tr>
<tr>
<td>i_bitangent</td>
<td>vec3</td>
<td>Vertex bitangent in object space.</td>
</tr>
<tr>
<td>i_texcoord_N</td>
<td>vec2</td>
<td>Vertex texture coord for N:th uv set.</td>
</tr>
<tr>
<td>i_color_N</td>
<td>vec4</td>
<td>Vertex color for N:th color set.</td>
</tr>
</tbody>
</table>
<p>Uniform variables</p>
<table>
<thead>
<tr>
<th>NAME</th>
<th>TYPE</th>
<th>BINDING</th>
</tr>
</thead>
<tbody>
<tr>
<td>u_worldMatrix</td>
<td>mat4</td>
<td>World transform.</td>
</tr>
<tr>
<td>u_worldInverseMatrix</td>
<td>mat4</td>
<td>World transform, inverted.</td>
</tr>
<tr>
<td>u_worldTransposeMatrix</td>
<td>mat4</td>
<td>World transform, transposed.</td>
</tr>
<tr>
<td>u_worldInverseTransposeMatrix</td>
<td>mat4</td>
<td>World transform, inverted, transposed.</td>
</tr>
<tr>
<td>u_viewMatrix</td>
<td>mat4</td>
<td>View transform.</td>
</tr>
<tr>
<td>u_viewInverseMatrix</td>
<td>mat4</td>
<td>View transform, inverted.</td>
</tr>
<tr>
<td>u_viewTransposeMatrix</td>
<td>mat4</td>
<td>View transform, transposed.</td>
</tr>
<tr>
<td>u_viewInverseTransposeMatrix</td>
<td>mat4</td>
<td>View transform, inverted, transposed.</td>
</tr>
<tr>
<td>u_projectionMatrix</td>
<td>mat4</td>
<td>Projection transform.</td>
</tr>
<tr>
<td>u_projectionInverseMatrix</td>
<td>mat4</td>
<td>Projection transform, inverted.</td>
</tr>
<tr>
<td>u_projectionTransposeMatrix</td>
<td>mat4</td>
<td>Projection transform, transposed.</td>
</tr>
<tr>
<td>u_projectionInverseTransposeMatrix</td>
<td>mat4</td>
<td>Projection transform, inverted, transposed.</td>
</tr>
<tr>
<td>u_worldViewMatrix</td>
<td>mat4</td>
<td>World-view transform.</td>
</tr>
<tr>
<td>u_viewProjectionMatrix</td>
<td>mat4</td>
<td>View-projection transform.</td>
</tr>
<tr>
<td>u_worldViewProjectionMatrix</td>
<td>mat4</td>
<td>World-view-projection transform.</td>
</tr>
<tr>
<td>u_viewPosition</td>
<td>vec3</td>
<td>World-space position of the viewer.</td>
</tr>
<tr>
<td>u_viewDirection</td>
<td>vec3</td>
<td>World-space direction of the viewer.</td>
</tr>
<tr>
<td>u_frame</td>
<td>float</td>
<td>The current frame number as defined by the host application.</td>
</tr>
<tr>
<td>u_time</td>
<td>float</td>
<td>The current time in seconds.</td>
</tr>
<tr>
<td>u_geomattr_&lt;name&gt;</td>
<td>&lt;type&gt;</td>
<td>A named attribute of given &lt;type&gt; where &lt;name&gt; is the name of the variable on the geometry.</td>
</tr>
<tr>
<td>u_numActiveLightSources</td>
<td>int</td>
<td>The number of currently active light sources. Note that in shader this is clamped against the maximum allowed number of light sources.</td>
</tr>
<tr>
<td>u_lightData[]</td>
<td>struct</td>
<td>Array of struct LightData holding parameters for active light sources. The <code>LightData</code> struct is built dynamically depending on requirements for bound light shaders.</td>
</tr>
<tr>
<td>u_&lt;unitType&gt;UnitTarget[]</td>
<td>integer</td>
<td>An attribute indicating the target unit for a given unit type definition (&lt;unitType&gt;).</td>
</tr>
</tbody>
</table>
<p><strong>Figure 7</strong> : Listing of predefined variables with their binding rules.</p>
</article>
  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>

</body>
</html>