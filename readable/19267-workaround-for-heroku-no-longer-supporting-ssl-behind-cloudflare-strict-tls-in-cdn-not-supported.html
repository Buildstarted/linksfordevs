<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Workaround for Heroku no longer supporting SSL behind Cloudflare (&quot;Strict TLS in CDN not supported&quot;)? -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Workaround for Heroku no longer supporting SSL behind Cloudflare ("Strict TLS in CDN not supported")?</h1><div><div class="post-text" itemprop="text"><p>A few days ago we received the error "Strict TLS in CDN not supported" on 1 Heroku app that's behind Cloudflare's proxy (orange cloud, if you know Cloudflare).</p><p>Basically, client requests to <a href="https://foo.example.com" rel="nofollow noreferrer">https://foo.example.com</a> are proxied through Cloudflare, who then make the requests to <a href="https://foo.herokuapp.com" rel="nofollow noreferrer">https://foo.herokuapp.com</a>, caches the response, and passes the result back to the client. Notice that the entire chain is over HTTPS. We've configured Clouflare to <em>only</em> communicate with the end server over HTTPS, and we don't want the end server to ever send out responses over HTTP.</p><p>It seems that Heroku's policy no longer allows serving over SSL when they detect that you're behind a proxy that's already handling SSL. Over the past week, more apps have begun showing this error and we've had to disable Cloudflare's proxy. <a href="https://devcenter.heroku.com/articles/automated-certificate-management#strict-tls-in-cdn-not-supported" rel="nofollow noreferrer">Here's their documentation</a> on this, and the reason given is "because Cloudflare provides SSL certificates."</p><p>Anyone else encounter this and have a workaround? While Cloudflare still prevents certain vulnerabilities from the client to Cloudflare, this leaves other vulnerabilities open from Cloudflare to the end server.</p><p><strong>Update:</strong> I've heard back from Heroku on this:</p><blockquote><p>ACM can be used with Full or Flexible, and can be made to work with "Full (Strict)", but is not recommended. "Full (Strict)" mode ... can be used after ACM completes. If "Full (Strict)" is necessary we recommend a longer term, CA-issued certificate with a CSR signing process instead.</p></blockquote><p>However, I have not found the above to be true. On either setting (Full or Strict), Heroku always reports the above error. I've installed origin certs from Cloudflare to resolve this issue. </p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>