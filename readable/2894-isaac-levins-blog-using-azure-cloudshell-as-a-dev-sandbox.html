<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Isaac Levin&#x27;s Blog | Using Azure CloudShell as a Dev Sandbox -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Isaac Levin's Blog  | Using Azure CloudShell as a Dev Sandbox</h1><div><div id="" class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id="have-you-heard-of-cloudshell">Have You Heard of CloudShell?</h2><p><br>Back in around the Build 2017 timeframe, the first implementation of <a href="https://docs.microsoft.com/azure/cloud-shell/overview">Azure CloudShell</a> was rolled out, bringing the ability to run Azure CLI commands from the context of a logged in Azure session, from anywhere the Azure Portal could be loaded (i.e. a browser). This allowed you to do many things via the command line in the Azure world without having to use the GUI or have the tooling installed on your machine. Since that time, there have been a ton of features rolled out to CloudShell, and it can be accessed via it's own url <a href="https://shell.azure.com/">https://shell.azure.com/</a>, though you can still access it via the portal like so.</p><p><br><a href="/images/cloud-shell/get-started.png"></a></p><figure><a href="/images/cloud-shell/get-started.png"><img src="/images/cloud-shell/get-started.png"></a></figure><br><p></p><p>After initiating CloudShell if you haven't before, it will ask you a few things, like what Resource Group you want to install CloudShell in (CloudShell is temporary but needs Azure Files to persist your files). You are also given the option to default what terminal interface you want (PowerShell of Linux Bash). The experience you see when opening CloudShell is a terminal view that is connected to your chosen Azure Directory.</p><p><br><a href="/images/cloud-shell/first-view.png"></a></p><figure><a href="/images/cloud-shell/first-view.png"><img src="/images/cloud-shell/first-view.png"></a></figure><br><p></p><p>From here, you can do some typical Azure things, like maybe create a resource group and see the output.</p><p><br><a href="/images/cloud-shell/resource-group.png"></a></p><figure><a href="/images/cloud-shell/resource-group.png"><img src="/images/cloud-shell/resource-group.png"></a></figure><br><p></p><p>That is pretty cool, the idea of being able to do many things Azure related in the browser without the tooling on your matching is pretty powerful.</p><p><br>I was poking around at the idea of doing some dev tasks on my <a href="https://www.microsoft.com/p/surface-go/8v9dp4lnknsz">Surface Go</a>, which didn't have VS Code on it yet, using what online tools I had. I wanted to take a look at CloudShell and see how far I could go, since there are some cool features and tools built in. I asked around with some of my friends on Twitter, and found out there are a whole slew of <a href="https://docs.microsoft.com/azure/cloud-shell/features#tools">tools pre-installed on CloudShell</a>, like .NET Core, Node.js, Java, Python, git and many more.</p><p><br><a href="/images/cloud-shell/tools.png"></a></p><figure><a href="/images/cloud-shell/tools.png"><img src="/images/cloud-shell/tools.png"></a></figure><br><p></p><h2 id="an-idea">An Idea</h2><p><br>Than I had a fun thought, could I create an ASP.NET Core application, using the .NET CLI, make some coding changes to it via the built-in VS Code support for CloudShell, test it using some method of ip forwarding, check my code into GitHub and finally deploy the code to Azure App Service. I was pretty certain all this could be done.
</p><p>I did my first step, creating a ASP.NET Core App and validating the correct bits were put there.</p><p><br><a href="/images/cloud-shell/new-api.png"></a></p><figure><a href="/images/cloud-shell/new-api.png"><img src="/images/cloud-shell/new-api.png"></a></figure><br><p></p><p>If I simply run <code>code .</code> in the context of the generated project folder, an instance of VS Code will open inside CloudShell</p><p><br><a href="/images/cloud-shell/code.png"></a></p><figure><a href="/images/cloud-shell/code.png"><img src="/images/cloud-shell/code.png"></a></figure><br><p></p><p>At this point, I can make coding changes per my need, and now I want to be able to run the application and test it in a browser. I than saw my friend Anthony Chu mentioned the ability to run <a href="https://ngrok.com/">ngrok</a>(a way to expose local server to public internet) inside of CloudShell.</p><p>So what I will need to do is get ngrok running on my CloudShell instance. Well I know if I run a this command, I will get some high-level system info about the CloudShell OS
</p><p><br><a href="/images/cloud-shell/lsb.png"></a></p><figure><a href="/images/cloud-shell/lsb.png"><img src="/images/cloud-shell/lsb.png"></a></figure><br><p></p><p>Ok, I have x64 Ubuntu, to work with, so I can go download the zip from the <a href="https://ngrok.com/download">download page</a>(be sure to signup for a free account), unzip the file, and save the application to our path.</p><p><br><strong>NOTE: The url and my path may/will be different than yours.</strong></p><p><strong>NOTE: Also you can upload the files directly with CloudShell instead of using curl.</strong></p><div class="highlight"><pre><code class="language-bash" data-lang="bash">mkdir DevSandbox
cd DevSandBox
curl https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip -o ngrok.zip
unzip ngrok.zip
export PATH<span>=</span><span>"</span>$PATH<span>:/home/isaac_levin/DevSandBox</span><span>"</span><span># This line will connect your ngrok account using your auth token</span>
ngrok authtoken &lt;YOUR_AUTH_TOKEN&gt;
</code></pre></div><p><br><strong>NOTE: Ngrok does not work over https, which is on by default with ASP.NET Core 2.1 and on. Disabling the https redirect in <code>Startup.cs</code> will resolve this.</strong><br></p><p><br>Now I can run ngrok from my terminal, and a tunnel to whatever port I specify and I will get a unique url. One thing that I will need to do is run my application, and than run ngrok against the port that my application is running on. To do this, I will need to have 2 running terminal sessions. Good thing, I can split sessions with <a href="https://eoinoc.net/tmux-for-noobs">tmux</a>. Here is some more information on <a href="http://azurepost.com/split-azure-cloud-console-multiple-panes/">tmux support</a></p><p>Than I just run my app in one session, and tunnel with ngrok in the other. Take the url generated and open it in a browser.</p><p>Pretty darn cool! To add an extra layer, let me open VS Code in CloudShell, and make some changes.</p><p><strong>WOAH!!!</strong></p><p>So with this, I can create, develop and test my webapp in CloudShell, no tools on my machine, just the browser. For grins and giggles, better commit this code to a GitHub repo I created.
</p><div class="highlight"><pre><code class="language-bash" data-lang="bash">echo <span>"# TestApp"</span> &gt;&gt; README.md
git init
git add README.md
git commit -m <span>"first commit"</span>
git remote add origin https://github.com/isaacrlevin/TestApp.git
git push -u origin master
</code></pre></div><p><br><a href="/images/cloud-shell/github.png"></a></p><figure><a href="/images/cloud-shell/github.png"><img src="/images/cloud-shell/github.png"></a></figure><br><p></p><p>And finally, maybe we should deploy the code to the cloud. So I need to create an Azure App Service and deploy to it. Here is snippet for that
</p><div class="highlight"><pre><code class="language-bash" data-lang="bash"><span># create some variables that will be used all over</span>
resourceGroup<span>=</span><span>"levin-cli-demo"</span>
webAppName<span>=</span><span>"levin-cli-demo-app"</span>
publishFolder<span>=</span><span>"publish"</span><span># create our resource group</span>
az group create --location eastus --name $resourceGroup

<span># now the app service plan</span>
az appservice plan create --name $webAppName --resource-group $resourceGroup --sku FREE

<span># and finally the web app</span>
az webapp create --name $webAppName --resource-group $resourceGroup --plan $webAppName

<span># publish the app with dotnet cli</span>
dotnet publish -c release -o $publishFolder
cd publish

<span># zip artifacts</span>
zip $publishFolder *

<span># deploy zip folder to webapp</span>
az webapp deployment source config-zip --resource-group $resourceGroup --name $webAppName --src publish.zip

<span># get the url of the newly deployed app service and open in the browser</span>
site1<span>=</span><span>`</span>az webapp show -n $webAppName -g $resourceGroup --query <span>"defaultHostName"</span> -o tsv<span>`</span>
echo $site1
</code></pre></div><p>Now you have the url of your webapp in Azure. Putting that in a browser takes you to the site that you just deployed to Azure.</p><p>Pretty great stuff here! Being able to create, develop, test, and deploy an application to Azure <strong>AND</strong> commit to source control with no tooling other than a browser is pretty powerful. This example was with .NET but there are tons of languages supported in CloudShell (look above for all of them).</p><h2 id="super-thanks">Super Thanks</h2><p><br>Thanks to the folks that enlightened and inspired me to blog about this.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>