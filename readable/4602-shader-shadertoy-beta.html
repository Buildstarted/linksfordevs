<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Shader - Shadertoy BETA -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Shader - Shadertoy BETA</h1><div><div class="dialogContentBody"><p class="readability-styled" style="display: inline;">

        This help only covers the parts of GLSL ES that are relevant for Shadertoy. For the complete specification please have a look at        </p><a class="user" href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf">GLSL ES specification</a><h2>Language:</h2><hr><ul><li><b>Version:</b> WebGL 2.0</li><li><b>Arithmetic:</b> ( ) + - ! * / %</li><li><b>Logical/Relatonal:</b> ~  &lt;  &gt;  &lt;=   &gt;=  ==  !=  &amp;&amp;  ||</li><li><b>Bit Operators:</b> &amp; ^ | &lt;&lt; &gt;&gt;</li><li><b>Comments:</b> // /* */</li><li><b>Types:</b> void bool int uint float vec2 vec3 vec4 bvec2 bvec3 bvec4 ivec2 ivec3 ivec4 uvec2 uvec3 uvec4 mat2 mat3 mat4 mat?x? sampler2D, sampler3D, samplerCube</li><li><b>Format:</b> float a = 1.0; int b = 1; uint i = 1U; int i = 0x1;</li><li><b>Function Parameter Qualifiers:</b> [none], in, out, inout</li><li><b>Global Variable Qualifiers:</b> const</li><li><b>Vector Components:</b> .xyzw .rgba .stpq</li><li><b>Flow Control:</b> if else for return break continue switch/case</li><li><b>Output:</b> vec4 fragColor</li><li><b>Input:</b> vec2 fragCoord</li><li><b>Preprocessor:</b> # #define #undef #if #ifdef #ifndef #else #elif #endif #error #pragma #line</li></ul><br><h2>Built-in Functions:</h2><hr><table><tbody><tr><td valign="top"><ul><li>type radians (type degrees)</li><li>type degrees (type radians)</li><li>type sin (type angle)</li><li>type cos (type angle)</li><li>type tan (type angle)</li><li>type asin (type x)</li><li>type acos (type x)</li><li>type atan (type y, type x)</li><li>type atan (type y_over_x)</li><li>type sinh (type x)</li><li>type cosh (type x)</li><li>type tanh (type x)</li><li>type asinh (type x)</li><li>type acosh (type x)</li><li>type atanh (type x)</li></ul><ul><li>type pow (type x, type y)</li><li>type exp (type x)</li><li>type log (type x)</li><li>type exp2 (type x)</li><li>type log2 (type x)</li><li>type sqrt (type x)</li><li>type inversesqrt (type x)</li></ul><ul><li>type abs (type x)</li><li>type sign (type x)</li><li>type floor (type x)</li><li>type ceil (type x)</li><li>type trunc (type x)</li><li>type fract (type x)</li><li>type mod (type x, float y)</li><li>type modf (type x, out type i)</li><li>type min (type x, type y)</li><li>type max (type x, type y)</li><li>type clamp (type x, type minV, type maxV)</li><li>type mix (type x, type y, type a)</li><li>type step (type edge, type x)</li><li>type smoothstep (type a, type b, type x)</li></ul><ul><li>float length (type x)</li><li>float distance (type p0, type p1)</li><li>float dot (type x, type y)</li><li>vec3 cross (vec3 x, vec3 y)</li><li>type normalize (type x)</li><li>type faceforward (type N, type I, type Nref)</li><li>type reflect (type I, type N)</li><li>type refract (type I, type N,float eta)</li><li>float determinant(mat? m)</li><li>mat?x? outerProduct(vec? c, vec? r)</li><li>type matrixCompMult (type x, type y)</li><li>type inverse (type inverse)</li><li>type transpose (type inverse)</li></ul></td><td valign="top"><ul><li>vec4  texture( sampler? , vec? coord [, float bias])</li><li>vec4  textureLod(  sampler, vec? coord, float lod)</li><li>vec4  textureLodOffset( sampler? sampler, vec? coord, float lod, ivec? offset)</li><li>vec4  textureGrad( sampler? , vec? coord, vec2 dPdx, vec2 dPdy)</li><li>vec4  textureGradOffset sampler? , vec? coord, vec? dPdx, vec? dPdy, vec? offset)</li><li>vec4  textureProj( sampler? , vec? coord [, float bias])</li><li>vec4  textureProjLod( sampler? , vec? coord, float lod)</li><li>vec4  textureProjLodOffset( sampler? , vec? coord, float lod, vec? offset)</li><li>vec4  textureProjGrad( sampler? , vec? coord, vec2 dPdx, vec2 dPdy)</li><li>vec4  texelFetch( sampler? , ivec? coord, int lod)</li><li>vec4  texelFetchOffset( sampler?, ivec? coord, int lod, ivec? offset )</li><li>ivec? textureSize( sampler? , int lod)</li></ul><ul><li>type dFdx (type x)</li><li>type dFdy (type x)</li><li>type fwidth (type p)</li></ul><ul><li>type isnan (type x)</li><li>type isinf (type x)</li><li>float intBitsToFloat (int v)</li><li>uint uintBitsToFloat (uint v)</li><li>int  floatBitsToInt (float v)</li><li>uint floatBitsToUint (float v)</li><li>uint packSnorm2x16 (vec2 v)</li><li>uint packUnorm2x16 (vec2 v)</li><li>vec2 unpackSnorm2x16 (uint p)</li><li>vec2 unpackUnorm2x16 (uint p)</li></ul><ul><li>bvec lessThan (type x, type y)</li><li>bvec lessThanEqual (type x, type y)</li><li>bvec greaterThan (type x, type y)</li><li>bvec greaterThanEqual (type x, type y)</li><li>bvec equal (type x, type y)</li><li>bvec notEqual (type x, type y)</li><li>bool any (bvec x)</li><li>bool all (bvec x)</li><li>bvec not (bvec x)</li></ul></td></tr></tbody></table><br><h2>How-to</h2><hr><ul><li><b>Use structs:</b> struct myDataType { float occlusion; vec3 color; }; myDataType myData = myDataType(0.7, vec3(1.0, 2.0, 3.0));</li><li><b>Initialize arrays:</b>float[] x = float[] (0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6);</li><li><b>Do conversions:</b> int a = 3; float b = float(a);</li><li><b>Do component swizzling:</b> vec4 a = vec4(1.0,2.0,3.0,4.0); vec4 b = a.zyyw;</li><li><b>Access matrix components:</b> mat4 m; m[1] = vec4(2.0); m[0][0] = 1.0; m[2][3] = 2.0;</li></ul><br><h2>Be careful!</h2><hr><ul><li><b>the <i>f</i> suffix for floating pont numbers:</b> 1.0f is illegal in GLSL. You must use 1.0</li><li><b>saturate():</b> saturate(x) doesn't exist in GLSL. Use clamp(x,0.0,1.0) instead</li><li><b>pow/sqrt:</b> please don't feed sqrt() and pow() with negative numbers. Add an abs() or max(0.0,) to the argument</li><li><b>mod:</b> please don't do mod(x,0.0). This is undefined in some platforms</li><li><b>variables:</b> initialize your variables! Don't assume they'll be set to zero by default</li><li><b>functions:</b> don't call your functions the same as some of your variables</li></ul><br><h2>Shadertoy Inputs</h2><hr><table><tbody><tr><td><b>vec3</b></td><td><b>iResolution</b></td><td>image/buffer</td><td>The viewport resolution (z is pixel aspect ratio, usually 1.0)</td></tr><tr><td><b>float</b></td><td><b>iTime</b></td><td>image/sound/buffer</td><td>Current time in seconds</td></tr><tr><td><b>float</b></td><td><b>iTimeDelta</b></td><td>image/buffer</td><td>Time it takes to render a frame, in seconds</td></tr><tr><td><b>int</b></td><td><b>iFrame</b></td><td>image/buffer</td><td>Current frame</td></tr><tr><td><b>float</b></td><td><b>iFrameRate</b></td><td>image/buffer</td><td>Number of frames rendered per second</td></tr><tr><td><b>float</b></td><td><b>iChannelTime[4]</b></td><td>image/buffer</td><td>Time for channel (if video or sound), in seconds</td></tr><tr><td><b>vec3</b></td><td><b>iChannelResolution[4]</b></td><td>image/buffer/sound</td><td>Input texture resolution for each channel</td></tr><tr><td><b>vec4</b></td><td><b>iMouse</b></td><td>image/buffer</td><td>xy = current pixel coords (if LMB is down). zw = click pixel</td></tr><tr><td><b>sampler2D</b></td><td><b>iChannel{i}</b></td><td>image/buffer/sound</td><td>Sampler for input textures i</td></tr><tr><td><b>vec4</b></td><td><b>iDate</b></td><td>image/buffer/sound</td><td>Year, month, day, time in seconds in .xyzw</td></tr><tr><td><b>float</b></td><td><b>iSampleRate</b></td><td>image/buffer/sound</td><td>The sound sample rate (typically 44100)</td></tr></tbody></table><br><h2>Shadertoy Outputs</h2><hr><p class="readability-styled" style="display: inline;">
        Image shaders: fragColor is used as output channel. It is not, for now, mandatory but recommended to leave the alpha channel to 1.0.</p><p>Sound shaders: the mainSound() function returns a vec2 containing the left and right (stereo) sound channel wave data.
        </p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>