<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Difference Between IEnumerable and IQueryable Explained -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>The Difference Between IEnumerable and IQueryable Explained</h1>
    <article id="post-176" class="post-176 post type-post status-publish format-standard has-post-thumbnail hentry category-csharp category-programming tag-csharp tag-dotnet tag-ienumerable tag-iqueryable tag-programming"> <div class="entry-content"> <figure class="wp-block-image size-large"><img src="https://i0.wp.com/thesharperdev.com/wp-content/uploads/2019/10/freestocks-org-Qf9JKLysUg-unsplash.jpg?resize=740%2C494&amp;ssl=1" alt class="wp-image-242" srcset="https://i0.wp.com/thesharperdev.com/wp-content/uploads/2019/10/freestocks-org-Qf9JKLysUg-unsplash.jpg?resize=1024%2C683&amp;ssl=1 1024w, https://i0.wp.com/thesharperdev.com/wp-content/uploads/2019/10/freestocks-org-Qf9JKLysUg-unsplash.jpg?resize=300%2C200&amp;ssl=1 300w, https://i0.wp.com/thesharperdev.com/wp-content/uploads/2019/10/freestocks-org-Qf9JKLysUg-unsplash.jpg?resize=768%2C512&amp;ssl=1 768w, https://i0.wp.com/thesharperdev.com/wp-content/uploads/2019/10/freestocks-org-Qf9JKLysUg-unsplash.jpg?w=1480&amp;ssl=1 1480w, https://i0.wp.com/thesharperdev.com/wp-content/uploads/2019/10/freestocks-org-Qf9JKLysUg-unsplash.jpg?w=2220&amp;ssl=1 2220w" sizes="(max-width: 740px) 100vw, 740px"><figcaption>Photo by freestocks.org on Unsplash</figcaption></figure> <p><em>This post is part of this year&#x2019;s <a href="https://crosscuttingconcerns.com/The-Third-Annual-csharp-Advent">C# Advent Series</a>. Which counts down to Christmas with two C# articles published every day from Dec 1 &#x2013; Dec 25.</em></p> <p>I&#x2019;ve always been curious how ORMs work. How does C# code get converted into SQL statements? </p> <p>Research on that topic led me to blog about <a href="https://thesharperdev.com/an-introduction-to-c-expression-trees/">Expressions</a> and the <a href="https://thesharperdev.com/c-design-patterns-the-visitor-pattern/">Visitor Pattern</a>. I&#x2019;ve also read a lot about the difference between the IEnumerable and IQueryable interfaces. But it took me awhile to really understand what made them different. </p> <p>I have recently been walking through a <a href="https://blogs.msdn.microsoft.com/mattwar/2008/11/18/linq-building-an-iqueryable-provider-series/">great series of blog posts</a> by Matt Warren describing in detail how to write a query provider. I&#x2019;ve learned a lot, and seeing and coding examples myself has helped me grasp how they&#x2019;re both used.</p> <p>I wanted to summarize some of the things that I&#x2019;ve learned and provide a resource for anyone else that might be struggling with this same topic.</p> <h2>Similar But Different</h2> <p>In a C# project, if you navigate to the LINQ extension method definitions for IEnumerable and IQueryable, you&#x2019;ll see that they are very similar. </p> <p><strong>IEnumerable:</strong></p> <figure class="wp-block-embed"></figure> <p><strong>IQueryable:</strong></p> <figure class="wp-block-embed"></figure> <p>Since the methods available are basically the same, what really sets these two interfaces apart? The main difference is where these interfaces are intended to be run. </p> <p><strong>IEnumerable</strong> &#x2013; intended to be run against an in memory collection.</p> <p><strong>IQueryable</strong> &#x2013; intended to be run against a &#x201C;queryable&#x201D; collection (ex. a database).</p> <p>Lets take the following examples. </p> <p>When we have an in memory list, this Where LINQ statement is defined on the IEnumerable interface.</p> <figure class="wp-block-embed"></figure> <p>On the other hand, when we are using EF Core to connect to a database, this Where LINQ statement is defined in the IQueryable interface. </p> <figure class="wp-block-embed"></figure> <p>The Users class is a stand in for the Users database table. The Users data doesn&#x2019;t exist in our app. In order to have access to the user who&#x2019;s Id is 1, it needs to run this LINQ statement against a database. Since that&#x2019;s the case, we&#x2019;re using the IQueryable methods. </p> <h2>Source Code</h2> <p>Lets take a look at the implementation for a where statement for the IEnumerable and IQueryable interfaces. <em>(Which I&#x2019;ve slightly modified to make it easier to read)</em></p> <p>In this first IEnumerable example, the where method will basically iterate over the IEnumerable, applying the predicate <code> Where(n =&gt; n.Contains(&quot;J&quot;) </code>, returning any elements for which the predicate is true. </p> <figure class="wp-block-embed"></figure> <p>The IQueryable method on the other hand, invokes an Expression.Call() method? What is the point of that?</p> <figure class="wp-block-embed"></figure> <h2>Expressions and Query Providers</h2> <p>Because a database doesn&#x2019;t exist in memory, we need some mechanism to take our LINQ statements and convert them into a SQL statement. </p> <p>Expressions are the tools that allow us to do that. When LINQ methods on the IQueryable object are called, what really happens is it builds an Expression Tree.</p> <p>Then when results are expected from the IQueryable, that Expression Tree is converted into the source query language (ex. SQL), that source query is run against the source (ex. SQL Database), results returned and mapped to C# objects. </p> <p>The conversion between Expression Trees and a source query language is the responsibility of the Query Provider. </p> <p>There are Query Providers for all kinds of external queryable collections. SQL Server, Oracle Sql, Postgres, MySQL/MariaDb, CosmosDb, Sqlite, etc.</p> <p>If any arbitrary data store wants to allow C# developers to use LINQ to query against their data source, then someone needs to write a Query Provider. </p> <h2>Simple Query Provider</h2> <p>To see the basic workings of a query provider lets go ahead and create a very minimal query provider. This allows us to know how a C# expression tree would be mapped into a SQL statement. </p> <p><em>This example very much builds off the work in <a href="https://blogs.msdn.microsoft.com/mattwar/2008/11/18/linq-building-an-iqueryable-provider-series/">Matt Warren&#x2019;s series</a>, which I mentioned above. </em></p> <p>Lets start off by taking a look at the IQueryable interface. </p> <figure class="wp-block-embed"></figure> <p>You&#x2019;ll notice that it implements from the IEnumerable interface, so IQueryable is an IEnumerable. It has three properties, Type, Expression and IQueryProvider.</p> <p>The IQueryProvider in turn has 4 methods total, a generic and a non generic version of an Execute and CreateQuery.</p> <figure class="wp-block-embed"></figure> <p>Lets start coding by creating a Query class that will implement the IQueryable interface. </p> <figure class="wp-block-embed"></figure> <p>You&#x2019;ll notice that lines 18-20 implement the IQueryable properties we mentioned above. Then the other methods are merely a pass through to the provider. </p> <p>So lets turn our attention to our Query Provider. </p> <figure class="wp-block-embed"></figure> <p>For the most part, this class is responsible for calling the QueryTranslator to get the SQL statement representation of the Expression Tree. </p> <p>Which the QueryTranslator takes the Expression and using the <a href="https://thesharperdev.com/c-design-patterns-the-visitor-pattern/">Visitor Pattern</a>, converts it in a valid SQL statement.</p> <figure class="wp-block-embed"></figure> <p>There are many different types of Expressions, and each Expression has specific rules for how that Expression type gets mapped to some SQL statement. </p> <p>Lets run this example to see what happens. </p> <figure class="wp-block-embed"></figure> <p>This example outputs <code>query: SELECT * FROM (SELECT * FROM Customer) AS T WHERE(Id = 1)</code>. Which is a valid SQL statement! </p> <p>Which means we&#x2019;ve written the simplest QueryProvider ever. </p> <h2>Closing Thoughts</h2> <p>I hope this article was helpful in helping you understand the difference between the IEnumerable and IQueryable interfaces are. </p> <p>If you&#x2019;re interested in learning more about writing a Query Provider I would check out <a href="https://blogs.msdn.microsoft.com/mattwar/2008/11/18/linq-building-an-iqueryable-provider-series/">Matt&#x2019;s series</a> that I have mentioned previously. </p> <p>I hope you enjoy this and the rest of the articles published during the <a href="https://crosscuttingconcerns.com/The-Third-Annual-csharp-Advent">2019 C# Advent</a>! Thanks to Matt Groves for setting this up again this year!</p> <p><em><a href="https://github.com/MorganW09/QueryPro/tree/master">Github Repo</a></em></p> </div> </article>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>