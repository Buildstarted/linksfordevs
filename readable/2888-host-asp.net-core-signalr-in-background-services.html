<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Host ASP.NET Core SignalR in background services -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Host ASP.NET Core SignalR in background services</h1><div><div id="main" class="content "><p>By <a href="https://twitter.com/bradygaster" data-linktype="external">Brady Gaster</a></p><p>This article provides guidance for:</p><ul><li>Hosting SignalR Hubs using a background worker process hosted with ASP.NET Core.</li><li>Sending messages to connected clients from within a .NET Core <a href="/en-us/dotnet/api/microsoft.extensions.hosting.backgroundservice" data-linktype="absolute-path">BackgroundService</a>.</li></ul><p><a href="https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/signalr/background-service/sample/" data-linktype="external">View or download sample code</a><a href="../?view=aspnetcore-2.2#how-to-download-a-sample" data-linktype="relative-path">(how to download)</a></p><h2 id="enable-signalr-in-startup">Enable SignalR in startup</h2><div data-moniker="aspnetcore-3.0 aspnetcore-3.1"><p>Hosting ASP.NET Core SignalR Hubs in the context of a background worker process is identical to hosting a Hub in an ASP.NET Core web app. In the <code>Startup.ConfigureServices</code> method, calling <code>services.AddSignalR</code> adds the required services to the ASP.NET Core Dependency Injection (DI) layer to support SignalR. In <code>Startup.Configure</code>, the <code>MapHub</code> method is called in the <code>UseEndpoints</code> callback to connect the Hub endpoints in the ASP.NET Core request pipeline.</p><pre><code class="lang-csharp">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddSignalR();
        services.AddHostedService&lt;Worker&gt;();
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseRouting();
        app.UseEndpoints(endpoints =&gt;
        {
            endpoints.MapHub&lt;ClockHub&gt;("/hubs/clock");
        });
    }
}
</code></pre></div><div data-moniker="aspnetcore-2.2"><p>Hosting ASP.NET Core SignalR Hubs in the context of a background worker process is identical to hosting a Hub in an ASP.NET Core web app. In the <code>Startup.ConfigureServices</code> method, calling <code>services.AddSignalR</code> adds the required services to the ASP.NET Core Dependency Injection (DI) layer to support SignalR. In <code>Startup.Configure</code>, the <code>UseSignalR</code> method is called to connect the Hub endpoint(s) in the ASP.NET Core request pipeline.</p><pre><code class="lang-csharp" name="Startup">public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        services.AddSignalR();
        services.AddHostedService&lt;Worker&gt;();
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }

        app.UseSignalR((routes) =&gt;
        {
            routes.MapHub&lt;ClockHub&gt;("/hubs/clock");
        });
    }
}
</code></pre></div><p>In the preceding example, the <code>ClockHub</code> class implements the <code>Hub&lt;T&gt;</code> class to create a strongly typed Hub. The <code>ClockHub</code> has been configured in the <code>Startup</code> class to respond to requests at the endpoint <code>/hubs/clock</code>.</p><p>For more information on strongly typed Hubs, see <a href="hubs?view=aspnetcore-2.2#strongly-typed-hubs" data-linktype="relative-path">Use hubs in SignalR for ASP.NET Core</a>.</p><div class="NOTE"><p>Note</p><p>This functionality isn't limited to the <a href="/en-us/dotnet/api/microsoft.aspnetcore.signalr.hub-1" data-linktype="absolute-path">Hub&lt;T&gt;</a> class. Any class that inherits from <a href="/en-us/dotnet/api/microsoft.aspnetcore.signalr.hub" data-linktype="absolute-path">Hub</a>, such as <a href="/en-us/dotnet/api/microsoft.aspnetcore.signalr.dynamichub" data-linktype="absolute-path">DynamicHub</a>, will also work.</p></div><pre><code class="lang-csharp" name="Startup">public class ClockHub : Hub&lt;IClock&gt;
{
    public async Task SendTimeToClients(DateTime dateTime)
    {
        await Clients.All.ShowTime(dateTime);
    }
}
</code></pre><p>The interface used by the strongly typed <code>ClockHub</code> is the <code>IClock</code> interface.</p><pre><code class="lang-csharp" name="Startup">public interface IClock
{
    Task ShowTime(DateTime currentTime);
}
</code></pre><h2 id="call-a-signalr-hub-from-a-background-service">Call a SignalR Hub from a background service</h2><p>During startup, the <code>Worker</code> class, a <code>BackgroundService</code>, is enabled using <code>AddHostedService</code>.</p><pre><code class="lang-csharp">services.AddHostedService&lt;Worker&gt;();
</code></pre><p>Since SignalR is also enabled up during the <code>Startup</code> phase, in which each Hub is attached to an individual endpoint in ASP.NET Core's HTTP request pipeline, each Hub is represented by an <code>IHubContext&lt;T&gt;</code> on the server. Using ASP.NET Core's DI features, other classes instantiated by the hosting layer, like <code>BackgroundService</code> classes, MVC Controller classes, or Razor page models, can get references to server-side Hubs by accepting instances of <code>IHubContext&lt;ClockHub, IClock&gt;</code> during construction.</p><pre><code class="lang-csharp" name="Startup">public class Worker : BackgroundService
{
    private readonly ILogger&lt;Worker&gt; _logger;
    private readonly IHubContext&lt;ClockHub, IClock&gt; _clockHub;

    public Worker(ILogger&lt;Worker&gt; logger, IHubContext&lt;ClockHub, IClock&gt; clockHub)
    {
        _logger = logger;
        _clockHub = clockHub;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            _logger.LogInformation("Worker running at: {Time}", DateTime.Now);
            await _clockHub.Clients.All.ShowTime(DateTime.Now);
            await Task.Delay(1000);
        }
    }
}
</code></pre><p>As the <code>ExecuteAsync</code> method is called iteratively in the background service, the server's current date and time are sent to the connected clients using the <code>ClockHub</code>.</p><h2 id="react-to-signalr-events-with-background-services">React to SignalR events with background services</h2><p>Like a Single Page App using the JavaScript client for SignalR or a .NET desktop app can do using the using the <a href="dotnet-client?view=aspnetcore-2.2" data-linktype="relative-path">ASP.NET Core SignalR .NET Client</a>, a <code>BackgroundService</code> or <code>IHostedService</code> implementation can also be used to connect to SignalR Hubs and respond to events.</p><p>The <code>ClockHubClient</code> class implements both the <code>IClock</code> interface and the <code>IHostedService</code> interface. This way it can be enabled during <code>Startup</code> to run continuously and respond to Hub events from the server.</p><pre><code class="lang-csharp">public partial class ClockHubClient : IClock, IHostedService
{
}
</code></pre><p>During initialization, the <code>ClockHubClient</code> creates an instance of a <code>HubConnection</code> and enables the <code>IClock.ShowTime</code> method as the handler for the Hub's <code>ShowTime</code> event.</p><pre><code class="lang-csharp" name="The ClockHubClient constructor">private readonly ILogger&lt;ClockHubClient&gt; _logger;
private HubConnection _connection;

public ClockHubClient(ILogger&lt;ClockHubClient&gt; logger)
{
    _logger = logger;
    
    _connection = new HubConnectionBuilder()
        .WithUrl(Strings.HubUrl)
        .Build();

    _connection.On&lt;DateTime&gt;(Strings.Events.TimeSent, 
        dateTime =&gt; _ = ShowTime(dateTime));
}

public Task ShowTime(DateTime currentTime)
{
    _logger.LogInformation("{CurrentTime}", currentTime.ToShortTimeString());

    return Task.CompletedTask;
}
</code></pre><p>In the <code>IHostedService.StartAsync</code> implementation, the <code>HubConnection</code> is started asynchronously.</p><pre><code class="lang-csharp" name="StartAsync method">public async Task StartAsync(CancellationToken cancellationToken)
{
    // Loop is here to wait until the server is running
    while (true)
    {
        try
        {
            await _connection.StartAsync(cancellationToken);

            break;
        }
        catch
        {
            await Task.Delay(1000);
        }
    }
}
</code></pre><p>During the <code>IHostedService.StopAsync</code> method, the <code>HubConnection</code> is disposed of asynchronously.</p><pre><code class="lang-csharp" name="StopAsync method">    public Task StopAsync(CancellationToken cancellationToken)
    {
        return _connection.DisposeAsync();
    }
}
</code></pre><h2 id="additional-resources">Additional resources</h2></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>