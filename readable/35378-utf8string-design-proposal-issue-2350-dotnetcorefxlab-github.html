<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Utf8String design proposal &#xB7; Issue #2350 &#xB7; dotnet/corefxlab &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Utf8String design proposal · Issue #2350 · dotnet/corefxlab · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><h2>Utf8String design overview</h2><h3>Audience and scenarios</h3><p><code>Utf8String</code> and related concepts are meant for modern internet-facing applications that need to speak "the language of the web" (or i/o in general, really). Currently applications spend some amount of time transcoding into formats that aren't particularly useful, which wastes CPU cycles and memory.</p><p>A naive way to accomplish this would be to represent UTF-8 data as <code>byte[]</code> / <code>Span&lt;byte&gt;</code>, but this leads to a usability pit of failure. Developers would then become dependent on situational awareness and code hygiene to be able to know whether a particular <code>byte[]</code> instance is meant to represent binary data or UTF-8 textual data, leading to situations where it's very easy to write code like <code>byte[] imageData = ...; imageData.ToUpperInvariant();</code>. This defeats the purpose of using a typed language.</p><p>We want to expose enough functionality to make the <code>Utf8String</code> type <em>usable</em> and <em>desirable</em> by our developer audience, but it's not intended to serve as a full drop-in replacement for its sibling type <code>string</code>. For example, we might add <code>Utf8String</code>-related overloads to existing APIs in the <code>System.IO</code> namespace, but we wouldn't add an overload <code>Assembly.LoadFrom(Utf8String assemblyName)</code>.</p><p>In addition to networking and i/o scenarios, it's expected that there will be an audience who will want to use <code>Utf8String</code> for interop scenarios, especially when interoperating with components written in Rust or Go. Both of these languages use UTF-8 as their native string representation, and providing a type which can be used as a data exchange type for that audience will make their scenarios a bit easier.</p><p>Finally, we should afford power developers the opportunity to improve their throughput and memory utilization by limiting data copying where feasible. This doesn't imply that we must be allocation-free or zero-copy for every scenario. But it does imply that we should investigate common operations and consider alternative ways of performing these tasks as long as it doesn't compromise the usability of the mainline scenarios.</p><p>It's important to call out that <code>Utf8String</code> is not intended to be a replacement for <code>string</code>. The standard UTF-16 <code>string</code> will remain the core primitive type used throughout the .NET ecosystem and will enjoy the largest supported API surface area. We expect that developers who use <code>Utf8String</code> in their code bases will do so deliberately, either because they're working in one of the aforementioned scenarios or because they find other aspects of <code>Utf8String</code> (such as its API surface or behavior guarantees) desirable.</p><h3>Design decisions and type API</h3><p>To make internal <code>Utf8String</code> implementation details easier, and to allow consumers to better reason about the type's behavior, the <code>Utf8String</code> type maintains the following invariants:</p><ul><li><p>Instances are <strong>immutable</strong>. Once data is copied to the <code>Utf8String</code> instance, it is unchanging for the lifetime of the instance. All members on <code>Utf8String</code> are thread-safe.</p></li><li><p>Instances are <strong>heap-allocated</strong>. This is a standard reference type, like <code>string</code> and <code>object</code>.</p></li><li><p>The backing data is <strong>guaranteed well-formed UTF-8</strong>. It can be round-tripped through <code>string</code> (or any other Unicode-compatible encoding) and back without any loss of fidelity. It can be passed verbatim to any other component whose contract requires that it operate only on well-formed UTF-8 data.</p></li><li><p>The backing data is <strong>null-terminated</strong>. If the <code>Utf8String</code> instance is pinned, the resulting <code>byte*</code> can be passed to any API which takes a <code>LPCUTF8STR</code> parameter. (Like <code>string</code>, <code>Utf8String</code> instances can contain embedded nulls.)</p></li></ul><p>These invariants help shape the proposed API and usage examples as described throughout this document.</p><div class="highlight highlight-source-cs"><pre>[<span class="pl-en">Serializable</span>]
<span class="pl-k">public</span><span class="pl-k">sealed</span><span class="pl-k">class</span><span class="pl-en">Utf8String</span> : <span class="pl-en">IComparable</span>&lt;<span class="pl-en">Utf8String</span>&gt;, <span class="pl-en">IEquatable</span>&lt;<span class="pl-en">Utf8String</span>&gt;, <span class="pl-en">ISerializable</span>
{
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">readonly</span><span class="pl-en">Utf8String</span><span class="pl-smi">Empty</span>; <span class="pl-c"><span class="pl-c">//</span> matches String.Empty</span><span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * CTORS AND FACTORIES</span><span class="pl-c">     *</span><span class="pl-c">     * These ctors all have "throw on invalid data" behavior since it's intended that data should</span><span class="pl-c">     * be faithfully retained and should be round-trippable back to its original encoding.</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-en">Utf8String</span>(byte[]? value, <span class="pl-k">int</span><span class="pl-smi">startIndex</span>, <span class="pl-k">int</span><span class="pl-smi">length</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span>(char[]? value, <span class="pl-k">int</span><span class="pl-smi">startIndex</span>, <span class="pl-k">int</span><span class="pl-smi">length</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span>(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span>(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">char</span>&gt; <span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span>(<span class="pl-k">string</span><span class="pl-smi">value</span>) { }

    <span class="pl-c"><span class="pl-c">//</span> These ctors expect null-terminated UTF-8 or UTF-16 input.</span><span class="pl-c"><span class="pl-c">//</span> They'll compute strlen / wcslen on the caller's behalf.</span><span class="pl-k">public</span><span class="pl-k">unsafe</span><span class="pl-en">Utf8String</span>(byte* value);
    <span class="pl-k">public</span><span class="pl-k">unsafe</span><span class="pl-en">Utf8String</span>(char* value);

    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">Create</span>&lt;<span class="pl-en">TState</span>&gt;(<span class="pl-k">int</span><span class="pl-smi">length</span>, <span class="pl-en">TState</span><span class="pl-smi">state</span>, <span class="pl-en">SpanAction</span>&lt;<span class="pl-k">byte</span>, <span class="pl-en">TState</span>&gt; <span class="pl-smi">action</span>);

    <span class="pl-c"><span class="pl-c">//</span> "Try" factories are non-throwing equivalents of the above methods. They use a try pattern instead</span><span class="pl-c"><span class="pl-c">//</span> of throwing if invalid input is detected.</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">TryCreateFrom</span>(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">buffer</span>, <span class="pl-k">out</span><span class="pl-en">Utf8String</span>? <span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">TryCreateFrom</span>(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">char</span>&gt; <span class="pl-smi">buffer</span>, <span class="pl-k">out</span><span class="pl-en">Utf8String</span>? <span class="pl-smi">value</span>);

    <span class="pl-c"><span class="pl-c">//</span> "Loose" factories also perform validation, but if an invalid sequence is detected they'll</span><span class="pl-c"><span class="pl-c">//</span> silently fix it up by performing U+FFFD substitution in the returned Utf8String instance</span><span class="pl-c"><span class="pl-c">//</span> instead of throwing.</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">CreateFromLoose</span>(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">buffer</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">CreateFromLoose</span>(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">char</span>&gt; <span class="pl-smi">buffer</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">CreateLoose</span>&lt;<span class="pl-en">TState</span>&gt;(<span class="pl-k">int</span><span class="pl-smi">length</span>, <span class="pl-en">TState</span><span class="pl-smi">state</span>, <span class="pl-en">SpanAction</span>&lt;<span class="pl-k">byte</span>, <span class="pl-en">TState</span>&gt; <span class="pl-smi">action</span>);

    <span class="pl-c"><span class="pl-c">//</span> "Unsafe" factories skip validation entirely. It's up to the caller to uphold the invariant</span><span class="pl-c"><span class="pl-c">//</span> that Utf8String instances only ever contain well-formed UTF-8 data.</span>

    [<span class="pl-en">RequiresUnsafe</span>]
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">UnsafeCreateWithoutValidation</span>(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">utf8Contents</span>);
    [<span class="pl-en">RequiresUnsafe</span>]
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">UnsafeCreateWithoutValidation</span>&lt;<span class="pl-en">TState</span>&gt;(<span class="pl-k">int</span><span class="pl-smi">length</span>, <span class="pl-en">TState</span><span class="pl-smi">state</span>, <span class="pl-en">SpanAction</span>&lt;<span class="pl-k">byte</span>, <span class="pl-en">TState</span>&gt; <span class="pl-smi">action</span>);

    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * ENUMERATION</span><span class="pl-c">     *</span><span class="pl-c">     * Since there's no this[int] indexer on Utf8String, these properties allow enumeration</span><span class="pl-c">     * of the contents as UTF-8 code units (Bytes), as UTF-16 code units (Chars), or as</span><span class="pl-c">     * Unicode scalar values (Runes). The enumerable struct types are defined at the bottom</span><span class="pl-c">     * of this type.</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-en">ByteEnumerable</span><span class="pl-smi">Bytes</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-en">CharEnumerable</span><span class="pl-smi">Chars</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-en">RuneEnumerable</span><span class="pl-smi">Runes</span> { <span class="pl-k">get</span>; }

    <span class="pl-c"><span class="pl-c">//</span> Also allow iterating over extended grapheme clusters (not yet ready).</span><span class="pl-c"><span class="pl-c">//</span> public GraphemeClusterEnumerable GraphemeClusters { get; }</span><span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * COMPARISON</span><span class="pl-c">     *</span><span class="pl-c">     * All comparisons are Ordinal unless the API takes a parameter such</span><span class="pl-c">     * as a StringComparison or CultureInfo.</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-c"><span class="pl-c">//</span> The "AreEquivalent" APIs compare UTF-8 data against UTF-16 data for equivalence, where</span><span class="pl-c"><span class="pl-c">//</span> equivalence is defined as "the texts would transcode as each other".</span><span class="pl-c"><span class="pl-c">//</span> (Shouldn't these methods really be on a separate type?)</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">AreEquivalent</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">utf8Text</span>, <span class="pl-k">string</span>? <span class="pl-smi">utf16Text</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">AreEquivalent</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">utf8Text</span>, <span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">char</span>&gt; <span class="pl-smi">utf16Text</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">AreEquivalent</span>(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">utf8Text</span>, <span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">char</span>&gt; <span class="pl-smi">utf16Text</span>);
    
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">CompareTo</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">other</span>);
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">CompareTo</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">other</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-k">object</span>? <span class="pl-smi">obj</span>); <span class="pl-c"><span class="pl-c">//</span> 'obj' must be Utf8String, not string</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">left</span>, <span class="pl-en">Utf8String</span>? <span class="pl-smi">right</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">left</span>, <span class="pl-en">Utf8String</span>? <span class="pl-smi">right</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-k">operator</span><span class="pl-en">!=</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">left</span>, <span class="pl-en">Utf8String</span>? <span class="pl-smi">right</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-k">operator</span><span class="pl-en">==</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">left</span>, <span class="pl-en">Utf8String</span>? <span class="pl-smi">right</span>);

    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * SEARCHING</span><span class="pl-c">     *</span><span class="pl-c">     * Like comparisons, all searches are Ordinal unless the API takes a</span><span class="pl-c">     * parameter dictating otherwise.</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-c"><span class="pl-c">//</span> TryFind is the equivalent of IndexOf. It returns a Range instead of an integer</span><span class="pl-c"><span class="pl-c">//</span> index because there's no this[int] indexer on the Utf8String type, and encouraging</span><span class="pl-c"><span class="pl-c">//</span> developers to slice by integer indices will almost certainly lead to bugs.</span><span class="pl-c"><span class="pl-c">//</span> More on this later.</span><span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);

    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * SLICING</span><span class="pl-c">     *</span><span class="pl-c">     * All slicing operations uphold the "well-formed data" invariant and</span><span class="pl-c">     * validate that creating the new substring instance will not split a</span><span class="pl-c">     * multi-byte UTF-8 subsequence. This check is O(1).</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-k">this</span>[<span class="pl-en">Range</span><span class="pl-smi">range</span>] { <span class="pl-k">get</span>; }

    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOn</span>(<span class="pl-k">char</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOn</span>(<span class="pl-k">char</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOn</span>(<span class="pl-en">Rune</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOn</span>(<span class="pl-en">Rune</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOn</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOn</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOnLast</span>(<span class="pl-k">char</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOnLast</span>(<span class="pl-k">char</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOnLast</span>(<span class="pl-en">Rune</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOnLast</span>(<span class="pl-en">Rune</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOnLast</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span> (<span class="pl-en">Utf8String</span><span class="pl-en">Before</span>, <span class="pl-en">Utf8String</span>? <span class="pl-en">After</span>) <span class="pl-en">SplitOnLast</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * INSPECTION &amp; MANIPULATION</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-c"><span class="pl-c">//</span> some number of overloads to help avoid allocation in the common case</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">Concat</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-k">params</span><span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">values</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">Concat</span>&lt;<span class="pl-en">T0</span>, <span class="pl-en">T1</span>&gt;(<span class="pl-en">T0</span><span class="pl-smi">value0</span>, <span class="pl-en">T1</span><span class="pl-smi">value1</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">Concat</span>&lt;<span class="pl-en">T0</span>, <span class="pl-en">T1</span>, <span class="pl-en">T2</span>&gt;(<span class="pl-en">T0</span><span class="pl-smi">value0</span>, <span class="pl-en">T1</span><span class="pl-smi">value1</span>, <span class="pl-en">T2</span><span class="pl-smi">value2</span>);

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">IsAscii</span>();

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">IsNormalized</span>(<span class="pl-en">NormalizationForm</span><span class="pl-smi">normalizationForm</span><span class="pl-k">=</span><span class="pl-smi">NormalizationForm</span>.<span class="pl-smi">FormC</span>);

    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">Join</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-k">char</span><span class="pl-smi">separator</span>, <span class="pl-k">params</span><span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">values</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">Join</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-en">Rune</span><span class="pl-smi">separator</span>, <span class="pl-k">params</span><span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">values</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8String</span><span class="pl-en">Join</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-en">Utf8String</span>? <span class="pl-smi">separator</span>, <span class="pl-k">params</span><span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">values</span>);

    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Normalize</span>(<span class="pl-en">NormalizationForm</span><span class="pl-smi">normalizationForm</span><span class="pl-k">=</span><span class="pl-smi">NormalizationForm</span>.<span class="pl-smi">FormC</span>);

    <span class="pl-c"><span class="pl-c">//</span> Do we also need Insert, Remove, etc.?</span><span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Replace</span>(<span class="pl-k">char</span><span class="pl-smi">oldChar</span>, <span class="pl-k">char</span><span class="pl-smi">newChar</span>); <span class="pl-c"><span class="pl-c">//</span> Ordinal</span><span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Replace</span>(<span class="pl-k">char</span><span class="pl-smi">oldChar</span>, <span class="pl-k">char</span><span class="pl-smi">newChar</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Replace</span>(<span class="pl-k">char</span><span class="pl-smi">oldChar</span>, <span class="pl-k">char</span><span class="pl-smi">newChar</span>, <span class="pl-k">bool</span><span class="pl-smi">ignoreCase</span>, <span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Replace</span>(<span class="pl-en">Rune</span><span class="pl-smi">oldRune</span>, <span class="pl-en">Rune</span><span class="pl-smi">newRune</span>); <span class="pl-c"><span class="pl-c">//</span> Ordinal</span><span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Replace</span>(<span class="pl-en">Rune</span><span class="pl-smi">oldRune</span>, <span class="pl-en">Rune</span><span class="pl-smi">newRune</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Replace</span>(<span class="pl-en">Rune</span><span class="pl-smi">oldRune</span>, <span class="pl-en">Rune</span><span class="pl-smi">newRune</span>, <span class="pl-k">bool</span><span class="pl-smi">ignoreCase</span>, <span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Replace</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">oldText</span>, <span class="pl-en">Utf8String</span><span class="pl-smi">newText</span>); <span class="pl-c"><span class="pl-c">//</span> Ordinal</span><span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Replace</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">oldText</span>, <span class="pl-en">Utf8String</span><span class="pl-smi">newText</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Replace</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">oldText</span>, <span class="pl-en">Utf8String</span><span class="pl-smi">newText</span>, <span class="pl-k">bool</span><span class="pl-smi">ignoreCase</span>, <span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);

    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToLower</span>(<span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToLowerInvariant</span>();

    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToUpper</span>(<span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToUpperInvariant</span>();

    <span class="pl-c"><span class="pl-c">//</span> The Trim* APIs only trim whitespace for now. When we figure out how to trim</span><span class="pl-c"><span class="pl-c">//</span> additional data we can add the appropriate overloads.</span><span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Trim</span>();
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">TrimStart</span>();
    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">TrimEnd</span>();

    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * PROJECTING</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-en">AsBytes</span>(); <span class="pl-c"><span class="pl-c">//</span> perhaps an extension method instead?</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">explicit</span><span class="pl-k">operator</span><span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt;(<span class="pl-en">Utf8String</span>? <span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">implicit</span><span class="pl-k">operator</span><span class="pl-en">Utf8Span</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">value</span>);

    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * MISCELLANEOUS</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">int</span><span class="pl-en">GetHashCode</span>(); <span class="pl-c"><span class="pl-c">//</span> Ordinal</span><span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">GetHashCode</span>(<span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-c"><span class="pl-c">//</span> Used for pinning and passing to p/invoke. If the input Utf8String</span><span class="pl-c"><span class="pl-c">//</span> instance is empty, returns a reference to the null terminator.</span>

    [<span class="pl-en">EditorBrowsable</span>(<span class="pl-smi">EditorBrowsableState</span>.<span class="pl-smi">Never</span>)]
    <span class="pl-k">public</span><span class="pl-k">ref</span><span class="pl-k">readonly</span><span class="pl-k">byte</span><span class="pl-en">GetPinnableReference</span>();

    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">IsNullOrEmpty</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">IsNullOrWhiteSpace</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">value</span>);

    <span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">string</span><span class="pl-en">ToString</span>(); <span class="pl-c"><span class="pl-c">//</span> transcode to UTF-16</span><span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * SERIALIZATION</span><span class="pl-c">     * (Throws an exception on deserialization if data is invalid.)</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-c"><span class="pl-c">//</span> Could also use an IObjectReference if we didn't want to implement the deserialization ctor.</span><span class="pl-k">private</span><span class="pl-en">Utf8String</span>(<span class="pl-en">SerializationInfo</span><span class="pl-smi">info</span>, <span class="pl-en">StreamingContext</span><span class="pl-smi">context</span>);
    void ISerializable.<span class="pl-en">GetObjectData</span>(<span class="pl-en">SerializationInfo</span><span class="pl-smi">info</span>, <span class="pl-en">StreamingContext</span><span class="pl-smi">context</span>);

    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * HELPER NESTED STRUCTS</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">struct</span><span class="pl-en">ByteEnumerable</span> : <span class="pl-en">IEnumerable</span>&lt;<span class="pl-k">byte</span>&gt; { <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span> }
    <span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">struct</span><span class="pl-en">CharEnumerable</span> : <span class="pl-en">IEnumerable</span>&lt;<span class="pl-k">char</span>&gt; { <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span> }
    <span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">struct</span><span class="pl-en">RuneEnumerable</span> : <span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">Rune</span>&gt; { <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span> }
}

<span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">class</span><span class="pl-en">MemoryExtensions</span>
{
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">ReadOnlyMemory</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-en">AsMemory</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">ReadOnlyMemory</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-en">AsMemory</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>, <span class="pl-k">int</span><span class="pl-smi">offset</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">ReadOnlyMemory</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-en">AsMemory</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>, <span class="pl-k">int</span><span class="pl-smi">offset</span>, <span class="pl-k">int</span><span class="pl-smi">count</span>);
}</pre></div><h2>Non-allocating types</h2><p>While <code>Utf8String</code> is an allocating, heap-based, null-terminated type; there are scenarios where a developer may want to represent a segment (or "slice") of UTF-8 data from an existing buffer without incurring an allocation.</p><p>The <code>Utf8Segment</code> (alternative name: <code>Utf8Memory</code>) and <code>Utf8Span</code> types can be used for this purpose. They represent a view into UTF-8 data, with the following guarantees:</p><ul><li>They are <em>immutable</em> views into <em>immutable</em> data.</li><li>They are <em>guaranteed</em> well-formed UTF-8 data. (Tearing will be covered shortly.)</li></ul><p>These types have <code>Utf8String</code>-like methods hanging off of them as instance methods where appropriate. Additionally, they can be projected as <code>ROM&lt;byte&gt;</code> and <code>ROS&lt;byte&gt;</code> for developers who want to deal with the data at the raw binary level or who want to call existing extension methods on the <code>ROM</code> and <code>ROS</code> types.</p><p>Since <code>Utf8Segment</code> and <code>Utf8Span</code> are standalone types distinct from <code>ROM</code> and <code>ROS</code>, they can have behaviors that developers have come to expect from string-like types. For example, <code>Utf8Segment</code> (unlike <code>ROM&lt;char&gt;</code> or <code>ROM&lt;byte&gt;</code>) can be used as a key in a dictionary without jumping through hoops:</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Dictionary</span>&lt;<span class="pl-en">Utf8Segment</span>, <span class="pl-k">int</span>&gt; <span class="pl-smi">dict</span><span class="pl-k">=</span> ...;

<span class="pl-en">Utf8String</span><span class="pl-smi">theString</span><span class="pl-k">=</span><span class="pl-smi">u</span><span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>;
<span class="pl-en">Utf8Segment</span><span class="pl-smi">segment</span><span class="pl-k">=</span><span class="pl-smi">theString</span>.<span class="pl-en">AsMemory</span>(<span class="pl-c1">0</span>, <span class="pl-c1">5</span>); <span class="pl-c"><span class="pl-c">//</span> u"hello"</span><span class="pl-k">if</span> (<span class="pl-smi">dict</span>.<span class="pl-en">TryGetValue</span>(<span class="pl-smi">segment</span>, <span class="pl-k">out</span><span class="pl-k">int</span><span class="pl-smi">value</span>))
{
    <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-smi">value</span>);
}</pre></div><p><code>Utf8Span</code> instances can be compared against each other:</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Utf8Span</span><span class="pl-smi">data1</span><span class="pl-k">=</span> ...;
<span class="pl-en">Utf8Span</span><span class="pl-smi">data2</span><span class="pl-k">=</span> ...;

<span class="pl-k">int</span><span class="pl-smi">hashCode</span><span class="pl-k">=</span><span class="pl-smi">data1</span>.<span class="pl-en">GetHashCode</span>(); <span class="pl-c"><span class="pl-c">//</span> Marvin32 hash</span><span class="pl-k">if</span> (<span class="pl-smi">data1</span><span class="pl-k">==</span><span class="pl-smi">data2</span>) { <span class="pl-c"><span class="pl-c">/*</span> ordinal comparison of contents <span class="pl-c">*/</span></span> }</pre></div><p>An alternative design that was considered was to introduce a type <code>Char8</code> that would represent an 8-bit code unit - it would serve as the elemental type of <code>Utf8String</code> and its slices. However, <code>ReadOnlyMemory&lt;Char8&gt;</code> and <code>ReadOnlySpan&lt;Char8&gt;</code> were a bit unweildy for a few reasons.</p><p>First, there was confusion as to what <code>ROS&lt;Char8&gt;</code> actually meant when the developer could use <code>ROS&lt;byte&gt;</code> for everything. Was <code>ROS&lt;Char8&gt;</code> actually providing guarantees that <code>ROS&lt;byte&gt;</code> couldn't? (No.) When would I ever want to use a lone <code>Char8</code> by itself rather than as part of a larger sequence? (You probably wouldn't.)</p><p>Second, it introduced a complication that if you had a <code>ROM&lt;Char8&gt;</code>, it couldn't be converted to a <code>ROM&lt;byte&gt;</code>. This impacted the ability to perform text manipulation and then act on the data in a binary fashion, such as sending it across the network.</p><h3>Creating segment types</h3><p>Segment types can be created safely from <code>Utf8String</code> backing objects. As mentioned earlier, we enforce that data in the UTF-8 segment types is well-formed. This implies that an instance of a segment type cannot represent data that has been sliced in the middle of a multibyte boundary. Calls to slicing APIs will throw an exception if the caller tries to slice the data in such a manner.</p><p>The <code>Utf8Segment</code> type introduces additional complexity in that it could be torn in a multi-threaded application, and that tearing may invalidate the well-formedness assumption by causing the torn segment to begin or end in the middle of a multi-byte UTF-8 subsequence. To resolve this issue, any instance method on <code>Utf8Segment</code> (including its projection to <code>ROM&lt;byte&gt;</code>) must first validate that the instance has not been torn. If the instance has been torn, an exception is thrown. This check is <em>O(1)</em> algorithmic complexity.</p><p>It is possible that the developer will want to create a <code>Utf8Segment</code> or <code>Utf8Span</code> instance from an existing buffer (such as a pooled buffer). There are zero-cost APIs to allow this to be done; however, they are unsafe because they easily allow the developer to violate invariants held by these types.</p><p>If the developer wishes to call the unsafe factories, they must maintain the following three invariants hold.</p><ol><li><p>The provided buffer (<code>ROM&lt;byte&gt;</code> or <code>ROS&lt;byte&gt;</code>) remains "alive" and immutable for the duration of the <code>Utf8Segment</code> or <code>Utf8Span</code>'s existence. Whichever component receives a <code>Utf8Segment</code> or <code>Utf8Span</code> - however the instance has been created - must never observe that the underlying contents change or that dereferencing the contents might result in an AV or other undefined behavior.</p></li><li><p>The provided buffer contains only well-formed UTF-8 data, and the boundaries of the buffer do not split a multibyte UTF-8 sequence.</p></li><li><p>For <code>Utf8Segment</code> in particular, the caller <strong>must not</strong> create a <code>Utf8Segment</code> instance wrapped around a <code>ROM&lt;byte&gt;</code> in circumstances where the component which receives the newly created <code>Utf8Segment</code> might tear it. The reason for this is that the "check that the <code>Utf8Segment</code> instance was not torn across a multi-byte subsequence" protection is only reliable when the <code>Utf8Segment</code> instance is backed by a <code>Utf8String</code>. The <code>Utf8Segment</code> type makes a best effort to offer protection for other backing buffers, but this protection is not ironclad in those scenarios. This could lead to a violation of invariant (2) immediately above.</p></li></ol><p>The type design here - including the constraints placed on segment types and the elimination of the <code>Char8</code> type - also draws inspiration from the Go, Swift, and Rust communities.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">ref</span><span class="pl-k">struct</span><span class="pl-en">Utf8Span</span>
{
    <span class="pl-k">public</span><span class="pl-en">Utf8Span</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">value</span>);

    <span class="pl-c"><span class="pl-c">//</span> This "Unsafe" ctor wraps a Utf8Span around an arbitrary span. It is non-copying.</span><span class="pl-c"><span class="pl-c">//</span> The caller must uphold Utf8Span's invariants: that it's immutable and well-formed</span><span class="pl-c"><span class="pl-c">//</span> for the lifetime that any component might be consuming the Utf8Span instance.</span><span class="pl-c"><span class="pl-c">//</span> Consumers (and Utf8Span's own internal APIs) rely on this invariant, and</span><span class="pl-c"><span class="pl-c">//</span> violating it could lead to undefined behavior at runtime.</span>

    [<span class="pl-en">RequiresUnsafe</span>]
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8Span</span><span class="pl-en">UnsafeCreateWithoutValidation</span>(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">buffer</span>);

    <span class="pl-c"><span class="pl-c">//</span> The equality operators and GetHashCode() operate on the underlying buffers.</span><span class="pl-c"><span class="pl-c">//</span> Two Utf8Span instances containing the same data will return equal and have</span><span class="pl-c"><span class="pl-c">//</span> the same hash code, even if they're referencing different memory addresses.</span>

    [<span class="pl-en">EditorBrowsable</span>(<span class="pl-smi">EditorBrowsableState</span>.<span class="pl-smi">Never</span>)]
    [<span class="pl-en">Obsolete</span>(<span class="pl-s"><span class="pl-pds">"</span>Equals(object) on Utf8Span will always throw an exception. Use Equals(Utf8Span) or == instead.<span class="pl-pds">"</span></span>)]
    <span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-k">object</span>? <span class="pl-smi">obj</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">other</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">other</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">left</span>, <span class="pl-en">Utf8Span</span><span class="pl-smi">right</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">left</span>, <span class="pl-en">Utf8Span</span><span class="pl-smi">right</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">int</span><span class="pl-en">GetHashCode</span>();
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">GetHashCode</span>(<span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-k">operator</span><span class="pl-en">!=</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">left</span>, <span class="pl-en">Utf8Span</span><span class="pl-smi">right</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-k">operator</span><span class="pl-en">==</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">left</span>, <span class="pl-en">Utf8Span</span><span class="pl-smi">right</span>);

    <span class="pl-c"><span class="pl-c">//</span> Unlike Utf8String.GetPinnableReference, Utf8Span.GetPinnableReference returns</span><span class="pl-c"><span class="pl-c">//</span> null if the span is zero-length. This is because we're not guaranteed that the</span><span class="pl-c"><span class="pl-c">//</span> backing data has a null terminator at the end, so we don't know whether it's</span><span class="pl-c"><span class="pl-c">//</span> safe to dereference the element just past the end of the span.</span><span class="pl-k">public</span><span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">Bytes</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-smi">IsEmpty</span> { <span class="pl-k">get</span>; }
    [<span class="pl-en">EditorBrowsable</span>(<span class="pl-smi">EditorBrowsableState</span>.<span class="pl-smi">Never</span>)]
    <span class="pl-k">public</span><span class="pl-k">ref</span><span class="pl-k">readonly</span><span class="pl-k">byte</span><span class="pl-en">GetPinnableReference</span>();

    <span class="pl-c"><span class="pl-c">//</span> For the most part, Utf8Span's remaining APIs mirror APIs already on Utf8String.</span><span class="pl-c"><span class="pl-c">//</span> There are some exceptions: methods like ToUpperInvariant have a non-allocating</span><span class="pl-c"><span class="pl-c">//</span> equivalent that allows the caller to specify the buffer which should</span><span class="pl-c"><span class="pl-c">//</span> contain the result of the operation. Like Utf8String, all APIs are assumed</span><span class="pl-c"><span class="pl-c">//</span> Ordinal unless the API takes a parameter which provides otherwise.</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8Span</span><span class="pl-smi">Empty</span> { <span class="pl-k">get</span>; }

    <span class="pl-k">public</span><span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">Bytes</span> { <span class="pl-k">get</span>; } <span class="pl-c"><span class="pl-c">//</span> returns ROS&lt;byte&gt;, not custom enumerable</span><span class="pl-k">public</span><span class="pl-en">CharEnumerable</span><span class="pl-smi">Chars</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-en">RuneEnumerable</span><span class="pl-smi">Runes</span> { <span class="pl-k">get</span>; }

    <span class="pl-c"><span class="pl-c">//</span> Also allow iterating over extended grapheme clusters (not yet ready).</span><span class="pl-c"><span class="pl-c">//</span> public GraphemeClusterEnumerable GraphemeClusters { get; }</span><span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">CompareTo</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">other</span>);
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">CompareTo</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">other</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Contains</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">EndsWith</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">IsAscii</span>();

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">IsEmptyOrWhiteSpace</span>();

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">IsNormalized</span>(<span class="pl-en">NormalizationForm</span><span class="pl-smi">normalizationForm</span><span class="pl-k">=</span><span class="pl-smi">NormalizationForm</span>.<span class="pl-smi">FormC</span>);

    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">Normalize</span>(<span class="pl-en">NormalizationForm</span><span class="pl-smi">normalizationForm</span><span class="pl-k">=</span><span class="pl-smi">NormalizationForm</span>.<span class="pl-smi">FormC</span>);
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">Normalize</span>(<span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">destination</span>, <span class="pl-en">NormalizationForm</span><span class="pl-smi">normalizationForm</span><span class="pl-k">=</span><span class="pl-smi">NormalizationForm</span>.<span class="pl-smi">FormC</span>);

    <span class="pl-k">public</span><span class="pl-en">Utf8Span</span><span class="pl-k">this</span>[<span class="pl-en">Range</span><span class="pl-smi">range</span>] { <span class="pl-k">get</span>; }

    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOn</span>(<span class="pl-k">char</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOn</span>(<span class="pl-k">char</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOn</span>(<span class="pl-en">Rune</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOn</span>(<span class="pl-en">Rune</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOn</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOn</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOnLast</span>(<span class="pl-k">char</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOnLast</span>(<span class="pl-k">char</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOnLast</span>(<span class="pl-en">Rune</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOnLast</span>(<span class="pl-en">Rune</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOnLast</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">separator</span>);
    <span class="pl-k">public</span><span class="pl-en">SplitResult</span><span class="pl-en">SplitOnLast</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">separator</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, System.<span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">StartsWith</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);

    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">ToChars</span>(<span class="pl-en">Span</span>&lt;<span class="pl-k">char</span>&gt; <span class="pl-smi">destination</span>);

    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToLower</span>(<span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">ToLower</span>(<span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">destination</span>, <span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);

    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToLowerInvariant</span>();
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">ToLowerInvariant</span>(<span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">destination</span>);

    <span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">string</span><span class="pl-en">ToString</span>();

    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToUpper</span>(<span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">ToUpper</span>(<span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">destination</span>, <span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);

    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToUpperInvariant</span>();
    <span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">ToUpperInvariant</span>(<span class="pl-en">Span</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">destination</span>);

    <span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToUtf8String</span>();

    <span class="pl-c"><span class="pl-c">//</span> Should we also have Trim* overloads that return a range instead</span><span class="pl-c"><span class="pl-c">//</span> of the span directly? Does this actually enable any new scenarios?</span><span class="pl-k">public</span><span class="pl-en">Utf8Span</span><span class="pl-en">Trim</span>();
    <span class="pl-k">public</span><span class="pl-en">Utf8Span</span><span class="pl-en">TrimStart</span>();
    <span class="pl-k">public</span><span class="pl-en">Utf8Span</span><span class="pl-en">TrimEnd</span>();

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFind</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);

    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-k">char</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-en">Rune</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);
    <span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">TryFindLast</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">range</span>);

    <span class="pl-c"><span class="pl-c">/*</span></span><span class="pl-c">     * HELPER NESTED STRUCTS</span><span class="pl-c"><span class="pl-c">*/</span></span><span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">ref</span><span class="pl-k">struct</span><span class="pl-en">CharEnumerable</span> { <span class="pl-c"><span class="pl-c">/*</span> pattern match for 'foreach' <span class="pl-c">*/</span></span> }
    <span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">ref</span><span class="pl-k">struct</span><span class="pl-en">RuneEnumerable</span> { <span class="pl-c"><span class="pl-c">/*</span> pattern match for 'foreach' <span class="pl-c">*/</span></span> }

    <span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">ref</span><span class="pl-k">struct</span><span class="pl-en">SplitResult</span>
    {
        <span class="pl-k">private</span><span class="pl-en">SplitResult</span>();

        [<span class="pl-en">EditorBrowsable</span>(<span class="pl-smi">EditorBrowsable</span>.<span class="pl-smi">Never</span>)]
        <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Deconstruct</span>(<span class="pl-k">out</span><span class="pl-en">Utf8Span</span><span class="pl-smi">before</span>, <span class="pl-k">out</span><span class="pl-en">Utf8Span</span><span class="pl-smi">after</span>);
    }
}

<span class="pl-k">public</span><span class="pl-k">readonly</span><span class="pl-k">struct</span><span class="pl-en">Utf8Segment</span> : <span class="pl-en">IComparable</span>&lt;<span class="pl-en">Utf8Segment</span>&gt;, <span class="pl-en">IEquatable</span>&lt;<span class="pl-en">Utf8Segment</span>&gt;
{
    <span class="pl-k">private</span><span class="pl-k">readonly</span><span class="pl-en">ReadOnlyMemory</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">_data</span>;

    <span class="pl-k">public</span><span class="pl-en">Utf8Span</span><span class="pl-smi">Span</span> { <span class="pl-k">get</span>; }

    <span class="pl-c"><span class="pl-c">//</span> Not all span-based APIs are present. APIs on Utf8Span that would</span><span class="pl-c"><span class="pl-c">//</span> return a new Utf8Span (such as Trim) should be present here, but</span><span class="pl-c"><span class="pl-c">//</span> other APIs that return bool / int (like Contains, StartsWith)</span><span class="pl-c"><span class="pl-c">//</span> should only be present on the Span type to discourage heavy use</span><span class="pl-c"><span class="pl-c">//</span> of APIs hanging directly off of this type.</span><span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-k">object</span>? <span class="pl-smi">other</span>); <span class="pl-c"><span class="pl-c">//</span> ok to call</span><span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8Segment</span><span class="pl-smi">other</span>); <span class="pl-c"><span class="pl-c">//</span> defaults to Ordinal</span><span class="pl-k">public</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8Segment</span><span class="pl-smi">other</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);

    <span class="pl-k">public</span><span class="pl-k">override</span><span class="pl-k">int</span><span class="pl-en">GetHashCode</span>(); <span class="pl-c"><span class="pl-c">//</span> Ordinal</span><span class="pl-k">public</span><span class="pl-k">int</span><span class="pl-en">GetHashCode</span>(<span class="pl-en">StringComparison</span><span class="pl-smi">comparison</span>);

    <span class="pl-c"><span class="pl-c">//</span> Caller is responsible for ensuring:</span><span class="pl-c"><span class="pl-c">//</span> - Input buffer contains well-formed UTF-8 data.</span><span class="pl-c"><span class="pl-c">//</span> - Input buffer is immutable and accessible for the lifetime of this Utf8Segment instance.</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8Segment</span><span class="pl-en">UnsafeCreateWithoutValidation</span>(<span class="pl-en">ReadOnlyMemory</span>&lt;<span class="pl-k">byte</span>&gt; <span class="pl-smi">data</span>);
}</pre></div><h3>Supporting types</h3><p>Like <code>StringComparer</code>, there's also a <code>Utf8StringComparer</code> which can be passed into the <code>Dictionary&lt;,&gt;</code> and <code>HashSet&lt;&gt;</code> constructors. This <code>Utf8StringComparer</code> also implements <code>IEqualityComparer&lt;Utf8Segment&gt;</code>, which allows using <code>Utf8Segment</code> instances directly as the keys inside dictionaries and other collection types.</p><p>The <code>Dictionary&lt;,&gt;</code> class is also being enlightened to understand that these types have both non-randomized and randomized hash code calculation routines. This allows dictionaries instantiated with <em>TKey = <code>Utf8String</code></em> or <em>TKey = <code>Utf8Segment</code></em> to enjoy the same performance optimizations as dictionaries instantiated with <em>TKey = <code>string</code></em>.</p><p>Finally, the <code>Utf8StringComparer</code> type has convenience methods to compare <code>Utf8Span</code> instances against one another. This will make it easier to compare texts using specific cultures, even if that specific culture is not the current thread's active culture.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">class</span><span class="pl-en">Utf8StringComparer</span> : <span class="pl-en">IComparer</span>&lt;<span class="pl-en">Utf8Segment</span>&gt;, <span class="pl-en">IComparer</span>&lt;<span class="pl-en">Utf8String</span>?&gt;, <span class="pl-en">IEqualityComparer</span>&lt;<span class="pl-en">Utf8Segment</span>&gt;, <span class="pl-en">IEqualityComparer</span>&lt;<span class="pl-en">Utf8String</span>?&gt;
{
    <span class="pl-k">private</span><span class="pl-en">Utf8StringComparer</span>(); <span class="pl-c"><span class="pl-c">//</span> all implementations are internal</span><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8StringComparer</span><span class="pl-smi">CurrentCulture</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8StringComparer</span><span class="pl-smi">CurrentCultureIgnoreCase</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8StringComparer</span><span class="pl-smi">InvariantCulture</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8StringComparer</span><span class="pl-smi">InvariantCultureIgnoreCase</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8StringComparer</span><span class="pl-smi">Ordinal</span> { <span class="pl-k">get</span>; }
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8StringComparer</span><span class="pl-smi">OrdinalIgnoreCase</span> { <span class="pl-k">get</span>; }

    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8StringComparer</span><span class="pl-en">Create</span>(<span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>, <span class="pl-k">bool</span><span class="pl-smi">ignoreCase</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8StringComparer</span><span class="pl-en">Create</span>(<span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>, <span class="pl-en">CompareOptions</span><span class="pl-smi">options</span>);
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-en">Utf8StringComparer</span><span class="pl-en">FromComparison</span>(<span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>);

    <span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">int</span><span class="pl-en">Compare</span>(<span class="pl-en">Utf8Segment</span><span class="pl-smi">x</span>, <span class="pl-en">Utf8Segment</span><span class="pl-smi">y</span>);
    <span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">int</span><span class="pl-en">Compare</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">x</span>, <span class="pl-en">Utf8String</span>? <span class="pl-smi">y</span>);
    <span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">int</span><span class="pl-en">Compare</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">x</span>, <span class="pl-en">Utf8Span</span><span class="pl-smi">y</span>);
    <span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8Segment</span><span class="pl-smi">x</span>, <span class="pl-en">Utf8Segment</span><span class="pl-smi">y</span>);
    <span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8String</span>? <span class="pl-smi">x</span>, <span class="pl-en">Utf8String</span>? <span class="pl-smi">y</span>);
    <span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">bool</span><span class="pl-en">Equals</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">x</span>, <span class="pl-en">Utf8Span</span><span class="pl-smi">y</span>);
    <span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">int</span><span class="pl-en">GetHashCode</span>(<span class="pl-en">Utf8Segment</span><span class="pl-smi">obj</span>);
    <span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">int</span><span class="pl-en">GetHashCode</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">obj</span>);
    <span class="pl-k">public</span><span class="pl-k">abstract</span><span class="pl-k">int</span><span class="pl-en">GetHashCode</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">obj</span>);
}</pre></div><h2>Manipulating UTF-8 data</h2><h3>CoreFX and Azure scenarios</h3><ul><li><p>What exchange types do we use when passing around UTF-8 data into and out of Framework APIs?</p></li><li><p>How do we generate UTF-8 data in a low-allocation manner?</p></li><li><p>How do we apply a series of transformations to UTF-8 data in a low-allocation manner?</p><ul><li><p>Leave everything as <code>Span&lt;byte&gt;</code>, use a special <code>Utf8StringBuilder</code> type, or something else?</p></li><li><p>Do we need to support UTF-8 string interpolation?</p></li><li><p>If we have builders, who is ultimately responsible for lifetime management?</p></li><li><p>Perhaps should look at <code>ValueStringBuilder</code> for inspiration.</p></li><li><p>A <code>MutableUtf8Buffer</code> type would be promising, but we'd need to be able to generate <code>Utf8Span</code> slices from it, and if the buffer is being modified continually the spans could end up holding invalid data. Example below:</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">MutableUtf8Buffer</span><span class="pl-smi">buffer</span><span class="pl-k">=</span><span class="pl-en">GetBuffer</span>();
<span class="pl-en">Utf8Span</span><span class="pl-smi">theSpan</span><span class="pl-k">=</span><span class="pl-smi">buffer</span>[<span class="pl-c1">0</span>..<span class="pl-c1">1</span>];

<span class="pl-smi">buffer</span>.<span class="pl-en">InsertAt</span>(<span class="pl-c1">0</span>, <span class="pl-en">utf8</span>(<span class="pl-s"><span class="pl-pds">"</span>💣<span class="pl-pds">"</span></span>)); <span class="pl-c"><span class="pl-c">//</span> U+1F483 ([ F0 9F 92 A3 ])</span><span class="pl-c"><span class="pl-c">//</span> 'theSpan' now contains only the first byte ([ F0 ]).</span><span class="pl-c"><span class="pl-c">//</span> Trying to use it could corrupt the application.</span><span class="pl-c"><span class="pl-c">//</span></span><span class="pl-c"><span class="pl-c">//</span> Any such mutable UTF-8 type would necessarily be unsafe. This</span><span class="pl-c"><span class="pl-c">//</span> also matches Rust's semantics: direct byte manipulation can only</span><span class="pl-c"><span class="pl-c">//</span> take place within an unsafe context.</span><span class="pl-c"><span class="pl-c">//</span> See:</span><span class="pl-c"><span class="pl-c">//</span> * https://doc.rust-lang.org/std/string/struct.String.html#method.as_mut_vec</span><span class="pl-c"><span class="pl-c">//</span> * https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes_mut</span></pre></div></li></ul></li><li><p>Some folks will want to perform operations in-place.</p></li></ul><h3>Sample operations on arbitrary buffers</h3><p>(Devs may want to perform these operations on arbitrary byte buffers, even if those buffers aren't guaranteed to contain valid UTF-8 data.)</p><ul><li><p>Validate that buffer contains well-formed UTF-8 data.</p></li><li><p>Convert ASCII data to upper / lower in-place, leaving all non-ASCII data untouched.</p></li><li><p>Split on byte patterns. (Probably shouldn't split on runes or UTF-8 string data, since we can't guarantee data is well-formed UTF-8.)</p></li></ul><p>These operations could be on the newly-introduced <code>System.Text.Unicode.Utf8</code> static class. They would take <code>ROS&lt;byte&gt;</code> and <code>Span&lt;byte&gt;</code> as input parameters because they can operate on arbitrary byte buffers. Their runtime performance would be subpar compared to similar methods on <code>Utf8String</code>, <code>Utf8Span</code>, or other types where we can guarantee that no invalid data will be seen, as the APIs which operate on raw byte buffers would need to be defensive and would probably operate over the input in an iterative fashion rather than in bulk. One potential behavior could be skipping over invalid data and leaving it unchanged as part of the operation.</p><h3>Sample <code>Utf8StringBuilder</code> implementation for private use</h3><div class="highlight highlight-source-cs"><pre><span class="pl-k">internal</span><span class="pl-k">ref</span><span class="pl-k">struct</span><span class="pl-en">Utf8StringBuilder</span>
{
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Append</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-en">T</span><span class="pl-smi">value</span>) <span class="pl-k">where</span><span class="pl-en">T</span> : <span class="pl-en">IUtf8Formattable</span>;
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Append</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-en">T</span><span class="pl-smi">value</span>, <span class="pl-k">string</span><span class="pl-smi">format</span>, <span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>) <span class="pl-k">where</span><span class="pl-en">T</span> : <span class="pl-en">IUtf8Formattable</span>;

    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Append</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Append</span>(<span class="pl-en">Utf8Segment</span><span class="pl-smi">value</span>);
    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Append</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>);

    <span class="pl-c"><span class="pl-c">//</span> Some other Append methods, resize methods, etc.</span><span class="pl-c"><span class="pl-c">//</span> Methods to query the length.</span><span class="pl-k">public</span><span class="pl-en">Utf8String</span><span class="pl-en">ToUtf8String</span>();

    <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Dispose</span>(); <span class="pl-c"><span class="pl-c">//</span> when done with the instance</span>
}

<span class="pl-c"><span class="pl-c">//</span> Would be implemented by numeric types (int, etc.),</span><span class="pl-c"><span class="pl-c">//</span> DateTime, String, Utf8String, Guid, other primitives,</span><span class="pl-c"><span class="pl-c">//</span> Uri, and anything else we might want to throw into</span><span class="pl-c"><span class="pl-c">//</span> interpolated data.</span><span class="pl-k">internal</span><span class="pl-k">interface</span><span class="pl-en">IUtf8Formattable</span>
{
    <span class="pl-k">void</span><span class="pl-en">Append</span>(<span class="pl-k">ref</span><span class="pl-en">Utf8StringBuilder</span><span class="pl-smi">builder</span>);
    <span class="pl-k">void</span><span class="pl-en">Append</span>(<span class="pl-k">ref</span><span class="pl-en">Utf8StringBuilder</span><span class="pl-smi">builder</span>, <span class="pl-k">string</span><span class="pl-smi">format</span>, <span class="pl-en">CultureInfo</span><span class="pl-smi">culture</span>);
}</pre></div><h2>Code samples and metadata representation</h2><p>The C# compiler could detect support for UTF-8 strings by looking for the existence of the <code>System.Utf8String</code> type and the appropriate helper APIs on <code>RuntimeHelpers</code> as called out in the samples below. If these APIs don't exist, then the target framework does not support the concept of UTF-8 strings.</p><h3>Literals</h3><p>Literal UTF-8 strings would appear as regular strings in source code, but would be prefixed by a <em>u</em> as demonstrated below. The <em>u</em> prefix would denote that the return type of this literal string expression should be <code>Utf8String</code> instead of <code>string</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Utf8String</span><span class="pl-smi">myUtf8String</span><span class="pl-k">=</span><span class="pl-smi">u</span><span class="pl-s"><span class="pl-pds">"</span>A literal string!<span class="pl-pds">"</span></span>;</pre></div><pre lang="txt"><code>// Normal ldstr to literal UTF-16 string in PE string table, followed by
// call to helper method which translates this to a UTF-8 string literal.
// The end result of these calls is that a Utf8String instance sits atop
// the stack.

ldstr "A literal string!"
call class System.Utf8String System.Runtime.CompilerServices.RuntimeHelpers.InitializeUtf8StringLiteral(string)
</code></pre><p>The <em>u</em> prefix would also be combinable with the <em>@</em> prefix and the <em>$</em> prefix (more on this below).</p><p>Additionally, literal UTF-8 strings <strong>must</strong> be well-formed Unicode strings.</p><div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> Below line would be a compile-time error since it contains ill-formed Unicode data.</span><span class="pl-en">Utf8String</span><span class="pl-smi">myUtf8String</span><span class="pl-k">=</span><span class="pl-smi">u</span><span class="pl-s"><span class="pl-pds">"</span>A malformed <span class="pl-cce">\u</span>d800 literal string!<span class="pl-pds">"</span></span>;</pre></div><p>Three alternative designs were considered. One was to use RVA statics (through <code>ldsflda</code>) instead of literal UTF-16 strings (through <code>ldstr</code>) before calling a "load from RVA" method on <code>RuntimeHelpers</code>. The overhead of using RVA statics is somewhat greater than the overhead of using the normal UTF-16 string table, so the normal UTF-16 string literal table should still be the more optimized case for small-ish strings, which we believe to be the common case.</p><p>Another alternative considered was to introduce a new opcode <code>ldstr.utf8</code>, which would act as a UTF-8 equivalent to the normal <code>ldstr</code> opcode. This would be a breaking change to the .NET tooling ecosystem, and the ultimate decision was that there would be too much pain to the ecosystem to justify the benefit.</p><p>The third alternative considered was to smuggle UTF-8 data in through a normal UTF-16 string in the string table, then call a <code>RuntimeHelpers</code> method to reinterpret the contents. This would result in a "garbled" string for anybody looking at the raw IL. While that in itself isn't terrible, there is the possibility that smuggling UTF-8 data in this manner could result in a literal string which has ill-formed UTF-16 data. Not all .NET tooling is resilient to this. For example, xunit's test runner produces failures if it sees attributes initialized from literal strings containing ill-formed UTF-16 data. There is a risk that other tooling would behave similarly, potentially modifying the DLL in such a manner that errors only manifest themselves at runtime. This could result in difficult-to-diagnose bugs.</p><p>We may wish to reconsider this decision in the future. For example, if we see that it is common for developers to use large UTF-8 literal strings, maybe we'd want to dynamically switch to using RVA statics for such strings. This would lower the resulting DLL size. However, this would add extra complexity to the compilation process, so we'd want to tread lightly here.</p><h3>Constant handling</h3><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">MyClass</span>
{
    <span class="pl-k">public</span><span class="pl-k">const</span><span class="pl-en">Utf8String</span><span class="pl-smi">MyConst</span><span class="pl-k">=</span><span class="pl-smi">u</span><span class="pl-s"><span class="pl-pds">"</span>A const string!<span class="pl-pds">"</span></span>;
}</pre></div><pre lang="txt"><code>// Literal field initialized to literal UTF-16 value. The runtime doesn't care about
// this (modulo FieldInfo.GetRawConstantValue, which perhaps we could fix up), so
// only the C# compiler would need to know that this is a UTF-8 constant and that
// references to it should get the same (ldstr, call) treatment as stated above.

.field public static literal class System.Utf8String MyConst = "A const string!";
</code></pre><h3>String concatenation</h3><p>There would be APIs on <code>Utf8String</code> which mirror the <code>string.Concat</code> APIs. The compiler should special-case the <code>+</code> operator to call the appropriate overload n-ary overload of <code>Concat</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Utf8String</span><span class="pl-smi">a</span><span class="pl-k">=</span> ...;
<span class="pl-en">Utf8String</span><span class="pl-smi">b</span><span class="pl-k">=</span> ...;

<span class="pl-en">Utf8String</span><span class="pl-smi">c</span><span class="pl-k">=</span><span class="pl-smi">a</span><span class="pl-k">+</span><span class="pl-smi">u</span><span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span><span class="pl-k">+</span><span class="pl-smi">b</span>; <span class="pl-c"><span class="pl-c">//</span> calls Utf8String.Concat(...)</span></pre></div><p>Since we expect use of <code>Utf8String</code> to be "deliberate" when compared to <code>string</code> (see the beginning of this document), we should consider that a developer who is using UTF-8 wants to stay in UTF-8 during concatenation operations. This means that if there's a line which involves the concatenation of both a <code>Utf8String</code> and a <code>string</code>, the final type post-concatenation should be <code>Utf8String</code>.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Utf8String</span><span class="pl-smi">a</span><span class="pl-k">=</span> ...;
<span class="pl-k">string</span><span class="pl-smi">b</span><span class="pl-k">=</span> ...;

<span class="pl-en">Utf8String</span><span class="pl-smi">concatFoo</span><span class="pl-k">=</span><span class="pl-smi">a</span><span class="pl-k">+</span><span class="pl-smi">b</span>;
<span class="pl-k">string</span><span class="pl-smi">concatBar</span><span class="pl-k">=</span> (<span class="pl-k">object</span>)<span class="pl-smi">a</span><span class="pl-k">+</span><span class="pl-smi">b</span>; <span class="pl-c"><span class="pl-c">//</span> compiler can't statically determine that any argument is Utf8String</span></pre></div><p>This is still open for discussion, as the behavior may be surprising to people. Another alternative is to produce a build warning if somebody tries to mix-and-match UTF-8 strings and UTF-16 strings in a single concatenation expression.</p><p>If string interpolation is added in the future, this shouldn't result in ambiguity. The <code>$</code> interpolation operator will be applied to a literal <code>Utf8String</code> or a literal <code>string</code>, and that would dictate the overall return type of the operation.</p><h3>Equality comparisons</h3><p>There are standard <code>==</code> and <code>!=</code> operators defined on the <code>Utf8String</code> class.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">bool</span><span class="pl-smi">operator</span> ==(<span class="pl-smi">Utf8String</span><span class="pl-smi">a</span>, <span class="pl-smi">Utf8String</span><span class="pl-smi">b</span>);
<span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-smi">bool</span><span class="pl-smi">operator</span><span class="pl-k">!=</span>(<span class="pl-smi">Utf8String</span><span class="pl-smi">a</span>, <span class="pl-smi">Utf8String</span><span class="pl-smi">b</span>);</pre></div><p>The C# compiler should special-case when either side of an equality expression is known to be a literal null object, and if so the compiler should emit a referential check against the null object instead of calling the operator method. This matches the <code>if (myString == null)</code> behavior that the <code>string</code> type enjoys today.</p><p>Additionally, equality / inequality comparisons between <code>Utf8String</code> and <code>string</code> should produce compiler warnings, as they will never succeed.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Utf8String</span><span class="pl-smi">a</span><span class="pl-k">=</span> ...;
<span class="pl-k">string</span><span class="pl-smi">b</span><span class="pl-k">=</span> ...;

<span class="pl-c"><span class="pl-c">//</span> Below line should produce a warning since it will end up being the equivalent</span><span class="pl-c"><span class="pl-c">//</span> of Object.ReferenceEquals, which will only succeed if both arguments are null.</span><span class="pl-c"><span class="pl-c">//</span> This probably wasn't what the developer intended to check.</span><span class="pl-k">if</span> (<span class="pl-smi">a</span><span class="pl-k">==</span><span class="pl-smi">b</span>) { <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span> }</pre></div><p>I attempted to define <code>operator ==(Utf8String a, string b)</code> so that I could slap <code>[Obsolete]</code> on it and generate the appropriate warning, but this had the side effect of disallowing the user to write the code <code>if (myUtf8String == null)</code> since the compiler couldn't figure out which overload of <code>operator ==</code> to call. This was also one of the reasons I had opened <a class="issue-link js-issue-link" data-error-text="Failed to load issue title" data-id="420835723" data-permission-text="Issue title is private" data-url="https://github.com/dotnet/csharplang/issues/2340" data-hovercard-type="issue" data-hovercard-url="/dotnet/csharplang/issues/2340/hovercard" href="https://github.com/dotnet/csharplang/issues/2340">dotnet/csharplang#2340</a>.</p><h3>Marshaling behaviors</h3><p>Like the <code>string</code> type, the <code>Utf8String</code> type shall be marshalable across p/invoke boundaries. The corresponding unmanaged type shall be <code>LPCUTF8</code> (equivalent to a <code>BYTE*</code> pointing to null-terminated UTF-8 data) unless a different unmanaged type is specified in the p/invoke signature.</p><p>If a different <code>[MarshalAs]</code> representation is specified, the stub routine creates a temporary copy in the desired representation, performs the p/invoke, then destroys the temporary copy or allows the GC to reclaim the temporary copy.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">class</span><span class="pl-en">NativeMethods</span>
{
    [<span class="pl-en">DllImport</span>]
    <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">extern</span><span class="pl-k">int</span><span class="pl-en">MyPInvokeMethod</span>(
        [<span class="pl-en">In</span>] <span class="pl-en">Utf8String</span><span class="pl-smi">marshaledAsLPCUTF8</span>,
        [<span class="pl-en">In</span>, <span class="pl-en">MarshalAs</span>(<span class="pl-smi">UnmanagedType</span>.<span class="pl-smi">LPUTF8Str</span>)] <span class="pl-en">Utf8String</span><span class="pl-smi">alsoMarshaledAsLPCUTF8</span>,
        [<span class="pl-en">In</span>, <span class="pl-en">MarshalAs</span>(<span class="pl-smi">UnmanagedType</span>.<span class="pl-smi">LPWStr</span>)] <span class="pl-en">Utf8String</span><span class="pl-smi">marshaledAsLPCWSTR</span>,
        [<span class="pl-en">In</span>, <span class="pl-en">MarshalAs</span>(<span class="pl-smi">UnmanagedType</span>.<span class="pl-smi">BStr</span>)] <span class="pl-en">Utf8String</span><span class="pl-smi">marshaledAsBSTR</span>);
}</pre></div><p>If a <code>Utf8String</code> must be marshaled from native-to-managed (e.g., a reverse p/invoke takes place on a delegate which has a <code>Utf8String</code> parameter), the stub routine is responsible for fixing up invalid UTF-8 data before creating the <code>Utf8String</code> instance (or it may let the <code>Utf8String</code> constructor perform the fixup automatically).</p><p>Unmanaged routines must not modify the contents of any <code>Utf8String</code> instance marshaled across the p/invoke boundary. <code>Utf8String</code> instances are assumed to be immutable once created, and violating this assumption could cause undefined behaviors within the runtime.</p><p>There is no default marshaling behavior for <code>Utf8Segment</code> or <code>Utf8Span</code> since they are not guaranteed to be null-terminated. If in the future the runtime allows marshaling <code>{ReadOnly}Span&lt;T&gt;</code> across a p/invoke boundary (presumably as a non-null-terminated array equivalent), library authors may fetch the underlying <code>ReadOnlySpan&lt;byte&gt;</code> from the <code>Utf8Segment</code> or <code>Utf8Span</code> instance and directly marshal that span across the p/invoke boundary.</p><h3>Automatic coercion of UTF-16 literals to UTF-8 literals</h3><p>If possible, it would be nice if UTF-16 literals (not arbitrary <code>string</code> instances) could be automatically coerced to UTF-8 literals (via the <code>ldstr / call</code> routines mentioned earlier). This coercion would only be considered if attempting to leave the data as a <code>string</code> would have caused a compilation error. This could help eliminate some errors resulting from developers forgetting to put the <em>u</em> prefix in front of the string literal, and it could make the code cleaner. Some examples follow.</p><div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> String literal being assigned to a member / local of type Utf8String.</span><span class="pl-k">public</span><span class="pl-k">const</span><span class="pl-en">Utf8String</span><span class="pl-smi">MyConst</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>A literal!<span class="pl-pds">"</span></span>;

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Foo</span>(<span class="pl-k">string</span><span class="pl-smi">s</span>);
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Foo</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">s</span>);

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">FooCaller</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Calls Foo(string) since it's an exact match.</span><span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>A literal!<span class="pl-pds">"</span></span>);
}

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Bar</span>(<span class="pl-k">object</span><span class="pl-smi">o</span>);
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Bar</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">s</span>);

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">BarCaller</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Calls Bar(object), passing in the string literal,</span><span class="pl-c"><span class="pl-c">//</span> since it's the closest match.</span><span class="pl-en">Bar</span>(<span class="pl-s"><span class="pl-pds">"</span>A literal!<span class="pl-pds">"</span></span>);
}

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Baz</span>(<span class="pl-k">int</span><span class="pl-smi">i</span>);
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Baz</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">s</span>);

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">BazCaller1</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Calls Baz(Utf8String), passing in the UTF-8 literal,</span><span class="pl-c"><span class="pl-c">//</span> since there's no closer match.</span><span class="pl-en">Baz</span>(<span class="pl-s"><span class="pl-pds">"</span>A literal!<span class="pl-pds">"</span></span>);
}

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">BazCaller2</span>(<span class="pl-k">string</span><span class="pl-smi">someInput</span>)
{
    <span class="pl-c"><span class="pl-c">//</span> Compiler error. The input isn't a literal, so no auto-coercion</span><span class="pl-c"><span class="pl-c">//</span> takes place. Dev should call Baz(new Utf8String(someInput)).</span><span class="pl-en">Baz</span>(<span class="pl-smi">someInput</span>);
}

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Quux</span>&lt;<span class="pl-en">T</span>&gt;(<span class="pl-en">ReadOnlySpan</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">value</span>);
<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Quux</span>(<span class="pl-en">Utf8String</span><span class="pl-smi">s</span>);

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">QuuxCaller</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Calls Quux&lt;char&gt;(ReadOnlySpan&lt;char&gt;), passing in the string literal,</span><span class="pl-c"><span class="pl-c">//</span> since string satisfies the constraints.</span><span class="pl-en">Quux</span>(<span class="pl-s"><span class="pl-pds">"</span>A literal!<span class="pl-pds">"</span></span>);
}

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Glomp</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">value</span>);

<span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">GlompCaller</span>()
{
    <span class="pl-c"><span class="pl-c">//</span> Calls Glomp(Utf8Span), passing in the UTF-8 literal, since there's</span><span class="pl-c"><span class="pl-c">//</span> no closer match and Utf8String can be implicitly cast to Utf8Span.</span><span class="pl-en">Glomp</span>(<span class="pl-s"><span class="pl-pds">"</span>A literal!<span class="pl-pds">"</span></span>);
}</pre></div><h3>UTF-8 String interpolation</h3><p>The string interpolation feature is undergoing significant churn (see <a class="issue-link js-issue-link" data-error-text="Failed to load issue title" data-id="417412970" data-permission-text="Issue title is private" data-url="https://github.com/dotnet/csharplang/issues/2302" data-hovercard-type="issue" data-hovercard-url="/dotnet/csharplang/issues/2302/hovercard" href="https://github.com/dotnet/csharplang/issues/2302">dotnet/csharplang#2302</a>). I envision that when a final design is chosen, there would be a UTF-8 counterpart for symmetry. The internal <code>IUtf8Formattable</code> interface as proposed above is being designed partly with this feature in mind in order to allow single-allocation <code>Utf8String</code> interpolation.</p><h3><code>ustring</code> contextual language keyword</h3><p>For simplicity, we may want to consider a contextual language keyword which corresponds to the <code>System.Utf8String</code> type. The exact name is still up for debate, as is whether we'd want it at all, but we could consider something like the below.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Utf8String</span><span class="pl-smi">a</span><span class="pl-k">=</span><span class="pl-smi">u</span><span class="pl-s"><span class="pl-pds">"</span>Some UTF-8 string.<span class="pl-pds">"</span></span>;

<span class="pl-c"><span class="pl-c">//</span> 'ustring' and 'System.Utf8String' are aliases, as shown below.</span><span class="pl-en">ustring</span><span class="pl-smi">b</span><span class="pl-k">=</span><span class="pl-smi">a</span>;
<span class="pl-en">Utf8String</span><span class="pl-smi">c</span><span class="pl-k">=</span><span class="pl-smi">b</span>;</pre></div><p>The name <code>ustring</code> is intended to invoke "Unicode string". Another leading candidate was <code>utf8</code>. We may wish not to ship with this keyword support in v1 of the <code>Utf8String</code> feature. If we opt not to do so we should be mindful of how we might be able to add it in the future without introducing breaking changes.</p><p>An alternative design to use a <code>u</code> suffix instead of a <code>u</code> prefix. I'm mostly impartial to this, but there is a nice symmetry to having the characters <code>u</code>, <code>$</code>, and <code>@</code> all available as prefixes on literal strings.</p><p>We could also drop the <code>u</code> prefix entirely and rely solely on type targeting:</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">ustring</span><span class="pl-smi">a</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Literal string type-targeted to UTF-8.<span class="pl-pds">"</span></span>;
<span class="pl-k">object</span><span class="pl-smi">b</span><span class="pl-k">=</span> (<span class="pl-smi">ustring</span>)<span class="pl-s"><span class="pl-pds">"</span>Another literal string type-targeted to UTF-8.<span class="pl-pds">"</span></span>;</pre></div><p>This has implications for string interpolation, as it wouldn't be possible to prepend both the <code>(ustring)</code> coercion hint and the <code>$</code> interpolation operator simultaneously.</p><h3>Switching and pattern matching</h3><p>If a value whose type is statically known to be <code>Utf8String</code> is passed to a <code>switch</code> statement, the corresponding <code>case</code> statements should allow the use of literal <code>Utf8String</code> values.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Utf8String</span><span class="pl-smi">value</span><span class="pl-k">=</span> ...;

<span class="pl-k">switch</span> (<span class="pl-smi">value</span>)
{
    <span class="pl-k">case</span><span class="pl-smi">u</span><span class="pl-s"><span class="pl-pds">"</span>Some literal<span class="pl-pds">"</span></span>: <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span><span class="pl-k">case</span><span class="pl-smi">u</span><span class="pl-s"><span class="pl-pds">"</span>Some other literal<span class="pl-pds">"</span></span>: <span class="pl-c"><span class="pl-c">/*</span> ... <span class="pl-c">*/</span></span><span class="pl-k">case</span><span class="pl-s"><span class="pl-pds">"</span>Yet another literal<span class="pl-pds">"</span></span>: <span class="pl-c"><span class="pl-c">/*</span> target typing also works <span class="pl-c">*/</span></span>
}</pre></div><p>Since pattern matching operates on input values of arbitrary types, I'm pessimistic that pattern matching will be able to take advantage of target typing. This may instead require that developers specify the <code>u</code> prefix on <code>Utf8String</code> literals if they wish such values to participate in pattern matching.</p><h2>A brief interlude on indexers and <code>IndexOf</code></h2><p><code>Utf8String</code> and related types do not expose an elemental indexer (<code>this[int]</code>) or a typical <code>IndexOf</code> method because they're trying to rid the developer of the notion that bytewise indices into UTF-8 buffers can be treated equivalently as charwise indices into UTF-16 buffers. Consider the naïve implementation of a typical "string split" routine as presented below.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">void</span><span class="pl-en">SplitString</span>(<span class="pl-k">string</span><span class="pl-smi">source</span>, <span class="pl-k">string</span><span class="pl-smi">target</span>, <span class="pl-en">StringComparison</span><span class="pl-smi">comparisonType</span>, <span class="pl-k">out</span><span class="pl-k">string</span><span class="pl-smi">beforeTarget</span>, <span class="pl-k">out</span><span class="pl-k">string</span><span class="pl-smi">afterTarget</span>)
{
    <span class="pl-c"><span class="pl-c">//</span> Locates 'target' within 'source', splits on it, then populates the two out parameters.</span><span class="pl-c"><span class="pl-c">//</span> ** NOTE ** This code has a bug, as will be explained in detail below.</span><span class="pl-k">int</span><span class="pl-smi">index</span><span class="pl-k">=</span><span class="pl-smi">source</span>.<span class="pl-en">IndexOf</span>(<span class="pl-smi">target</span>, <span class="pl-smi">comparisonType</span>);
    <span class="pl-k">if</span> (<span class="pl-smi">index</span><span class="pl-k">&lt;</span><span class="pl-c1">0</span>) { <span class="pl-k">throw</span><span class="pl-k">new</span><span class="pl-en">Exception</span>(<span class="pl-s"><span class="pl-pds">"</span>Target string not found!<span class="pl-pds">"</span></span>); }

    <span class="pl-smi">beforeTarget</span><span class="pl-k">=</span><span class="pl-smi">source</span>.<span class="pl-en">Substring</span>(<span class="pl-c1">0</span>, <span class="pl-smi">index</span>);
    <span class="pl-smi">afterTarget</span><span class="pl-k">=</span><span class="pl-smi">source</span>.<span class="pl-en">Substring</span>(<span class="pl-smi">index</span><span class="pl-k">+</span><span class="pl-smi">target</span>.<span class="pl-smi">Length</span>, <span class="pl-smi">source</span>.<span class="pl-smi">Length</span><span class="pl-k">-</span><span class="pl-smi">index</span><span class="pl-k">-</span><span class="pl-smi">target</span>.<span class="pl-smi">Length</span>);
}</pre></div><p>One subtlety of the above code is that when culture-sensitive or case-insensitive comparers are used (such as <em>OrdinalIgnoreCase</em> in the above example), the target string doesn't have to be an exact char-for-char match of a sequence present in the source string. For example, consider the UTF-16 string "GREEN" (<code>[ 0047 0052 0045 0045 004E ]</code>). Performing an <em>OrdinalIgnoreCase</em> search for the substring "e" (<code>[ 0065 ]</code>) will result in a match, as 'e' (<code>U+0065</code>) and 'E' (<code>U+0045</code>) compare as equal under an <em>OrdinalIgnoreCase</em> comparer.</p><p>As another example, consider the UTF-16 string "preſs" (<code>[ 0070 0072 0065 017F 0073 ]</code>), whose fourth character is the <em>Latin long s</em> 'ſ' (<code>U+017F</code>). Performing an <em>OrdinalIgnoreCase</em> search for the substring "S" (<code>[ 0053 ]</code>) will result in a match, as 'ſ' (<code>U+017F</code>) and 'S' (<code>U+0053</code>) compare as equal under an <em>OrdinalIgnoreCase</em> comparer.</p><p>There are also scenarios where the length of the match within the search string might not be equal to the length of the target string. Consider the UTF-16 string "encyclopædia" (<code>[ 0065 006E 0063 0079 0063 006C 006F 0070 00E6 0064 0069 0061 ]</code>), whose ninth character is the ligature 'æ' (<code>U+00E6</code>). Performing an <em>InvariantCultureIgnoreCase</em> search for the substring "ae" (<code>[ 0061 0065 ]</code>) will result in a match at index 8, as "æ" (<code>[ 00E6 ]</code>) and "ae" (<code>[ 0061 0065 ]</code>) compare as equal under an <em>InvariantCultureIgnoreCase</em> comparer.</p><p>This result is interesting and should give us pause. Since <code>"æ".Length == 1</code> and <code>"ae".Length == 2</code>, the arithmetic at the end of the method will actually result in the wrong substrings being returned to the caller.</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">beforeTarget</span><span class="pl-k">=</span><span class="pl-smi">source</span>.<span class="pl-en">Substring</span>(<span class="pl-c1">0</span>, <span class="pl-c1">8</span><span class="pl-c"><span class="pl-c">/*</span> index <span class="pl-c">*/</span></span>); <span class="pl-c"><span class="pl-c">//</span> = "encyclop"</span><span class="pl-smi">afterTarget</span><span class="pl-k">=</span><span class="pl-smi">source</span>.<span class="pl-en">Substring</span>(
    <span class="pl-c1">10</span><span class="pl-c"><span class="pl-c">/*</span> index + target.Length <span class="pl-c">*/</span></span>,
    <span class="pl-c1">2</span><span class="pl-c"><span class="pl-c">/*</span> source.Length - index - target.Length <span class="pl-c">*/</span></span>); <span class="pl-c"><span class="pl-c">//</span> = "ia" (expected "dia"!)</span></pre></div><p>Due to the nature of UTF-16 (used by <code>string</code>), when performing an <em>Ordinal</em> or an <em>OrdinalIgnoreCase</em> comparison, the length of the matched substring within the source will always have a <code>char</code> count equal to <code>target.Length</code>. The length mismatch as demonstrated by "encyclopædia" above can only happen with a culture-sensitive comparer or any of the <em>InvariantCulture</em> comparers.</p><p>However, in UTF-8, these same guarantees do not hold. Under UTF-8, only when performing an <em>Ordinal</em> comparison is there a guarantee that the length of the matched substring within the source will have a <code>byte</code> count equal to the target. All other comparers - including <em>OrdinalIgnoreCase</em> - have the behavior that the byte length of the matched substring can change (either shrink or grow) when compared to the byte length of the target string.</p><p>As an example of this, consider the string "preſs" from earlier, but this time in its UTF-8 representation (<code>[ 70 72 65 C5 BF 73 ]</code>). Performing an <em>OrdinalIgnoreCase</em> for the target UTF-8 string "S" <code>([ 53 ]</code>) will match on the <code>([ C5 BF ]</code>) portion of the source string. (This is the UTF-8 representation of the letter 'ſ'.) To properly split the source string along this search target, the caller need to know not only where the match was, <em>but also how long the match was within the original source string</em>.</p><p>This fundamental problem is why <code>Utf8String</code> and related types don't expose a standard <code>IndexOf</code> function or a standard <code>this[int]</code> indexer. It's still possible to index directly into the underlying byte buffer by using an API which projects the data as a <code>ROS&lt;byte&gt;</code>. But for splitting operations, these types instead offer a simpler API that performs the split on the caller's behalf, handling the length adjustments appropriately. For callers who want the equivalent of <code>IndexOf</code>, the types instead provide <code>TryFind</code> APIs that return a <code>Range</code> instead of a typical integral index value. This <code>Range</code> represents the matching substring within the original source string, and new C# language features make it easy to take this result and use it to create slices of the original source input string.</p><p>This also addresses feedback that was given in a previous prototype: users weren't sure how to interpret the result of the <code>IndexOf</code> method. (Is it a byte count? Is it a char count? Is it something else?) Similarly, there was confusion as to what parameters should be passed to a <code>this[int]</code> indexer or a <code>Substring(int, int)</code> method. By having the APIs promote use of <code>Range</code> and related C# language features, this confusion should subside. Power developers can inspect the <code>Range</code> instance directly to extract raw byte offsets if needed, but most devs shouldn't need to query such information.</p><h2>API usage samples</h2><p><strong>Scenario:</strong> Split an incoming string of the form "LastName, FirstName" into individual <em>FirstName</em> and <em>LastName</em> components.</p><div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> Using Utf8String input and producing Utf8String instances</span><span class="pl-k">void</span><span class="pl-en">SplitSample</span>(<span class="pl-en">ustring</span><span class="pl-smi">input</span>)
{
    <span class="pl-c"><span class="pl-c">//</span> Method 1: Use the SplitOn API to find the ',' char, then trim manually.</span>

    (<span class="pl-en">ustring</span><span class="pl-en">lastName</span>, <span class="pl-en">ustring</span><span class="pl-en">firstName</span>) <span class="pl-k">=</span><span class="pl-smi">input</span>.<span class="pl-en">Split</span>(<span class="pl-s">','</span>);
    <span class="pl-k">if</span> (<span class="pl-smi">firstName</span><span class="pl-k">is</span><span class="pl-en">null</span>) { <span class="pl-c"><span class="pl-c">/*</span> ERROR: no ',' detected in input <span class="pl-c">*/</span></span> }

    <span class="pl-smi">lastName</span><span class="pl-k">=</span><span class="pl-smi">lastName</span>.<span class="pl-en">Trim</span>();
    <span class="pl-smi">firstName</span><span class="pl-k">=</span><span class="pl-smi">firstName</span>.<span class="pl-en">Trim</span>();

    <span class="pl-c"><span class="pl-c">//</span> Method 2: Use the SplitOn API to find the ", " target string, assuming no trim needed.</span>

    (<span class="pl-en">ustring</span><span class="pl-en">lastName</span>, <span class="pl-en">ustring</span><span class="pl-en">firstName</span>) <span class="pl-k">=</span><span class="pl-smi">input</span>.<span class="pl-en">Split</span>(<span class="pl-smi">u</span><span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span>);
    <span class="pl-k">if</span> (<span class="pl-smi">firstName</span><span class="pl-k">is</span><span class="pl-en">null</span>) { <span class="pl-c"><span class="pl-c">/*</span> ERROR: no ", " detected in input <span class="pl-c">*/</span></span> }
}

<span class="pl-c"><span class="pl-c">//</span> Using Utf8Span input and producing Utf8Span instances</span><span class="pl-k">void</span><span class="pl-en">SplitSample</span>(<span class="pl-en">Utf8Span</span><span class="pl-smi">input</span>)
{
    <span class="pl-c"><span class="pl-c">//</span> Method 1: Use the SplitOn API to find the ',' char, then trim manually.</span>

    (<span class="pl-en">Utf8Span</span><span class="pl-en">lastName</span>, <span class="pl-en">Utf8Span</span><span class="pl-en">firstName</span>) <span class="pl-k">=</span><span class="pl-smi">input</span>.<span class="pl-en">Split</span>(<span class="pl-s">','</span>);
    <span class="pl-smi">lastName</span><span class="pl-k">=</span><span class="pl-smi">lastName</span>.<span class="pl-en">Trim</span>();
    <span class="pl-smi">firstName</span><span class="pl-k">=</span><span class="pl-smi">firstName</span>.<span class="pl-en">Trim</span>();
    <span class="pl-k">if</span> (<span class="pl-smi">firstName</span>.<span class="pl-smi">IsEmpty</span>) { <span class="pl-c"><span class="pl-c">/*</span> ERROR: trailing ',', or no ',' detected in input <span class="pl-c">*/</span></span> }

    <span class="pl-c"><span class="pl-c">//</span> Method 2: Use the SplitOn API to find the ", " target string, assuming no trim needed.</span>

    (<span class="pl-en">Utf8Span</span><span class="pl-en">lastName</span>, <span class="pl-en">Utf8Span</span><span class="pl-en">firstName</span>) <span class="pl-k">=</span><span class="pl-smi">input</span>.<span class="pl-en">Split</span>(<span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span>);
    <span class="pl-k">if</span> (<span class="pl-smi">firstName</span>.<span class="pl-smi">IsEmpty</span>) { <span class="pl-c"><span class="pl-c">/*</span> ERROR: trailing ", ", or no ", " detected in input <span class="pl-c">*/</span></span> }
}</pre></div><p>Additionally, the <code>SplitResult</code> struct returned by <code>Utf8Span.Split</code> implements both a standard <code>IEnumerable&lt;T&gt;</code> pattern and the C# <em>deconstruct</em> pattern, which allows it to be used separately from enumeration for simple cases where only a small handful of values are returned.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Utf8Span</span><span class="pl-smi">str</span><span class="pl-k">=</span> ...;

<span class="pl-c"><span class="pl-c">//</span> The result of Utf8Span.Split can be used in an enumerator</span><span class="pl-k">foreach</span> (<span class="pl-en">Utf8Span</span><span class="pl-smi">substr</span><span class="pl-k">in</span><span class="pl-smi">str</span>.<span class="pl-en">Split</span>(<span class="pl-s">','</span>))
{
    <span class="pl-c"><span class="pl-c">/*</span> operate on substr <span class="pl-c">*/</span></span>
}

<span class="pl-c"><span class="pl-c">//</span> Or it can be used in tuple deconstruction</span><span class="pl-c"><span class="pl-c">//</span> (See docs for description of behavior for each arity.)</span>

(<span class="pl-smi">Utf8Span</span><span class="pl-smi">before</span>, <span class="pl-smi">Utf8Span</span><span class="pl-smi">after</span>) <span class="pl-k">=</span><span class="pl-smi">str</span>.<span class="pl-en">Split</span>(<span class="pl-s">','</span>);
(<span class="pl-smi">Utf8Span</span><span class="pl-smi">part1</span>, <span class="pl-smi">Utf8Span</span><span class="pl-smi">part2</span>, <span class="pl-smi">Utf8Span</span><span class="pl-smi">part3</span>, ...) <span class="pl-k">=</span><span class="pl-smi">str</span>.<span class="pl-en">Split</span>(<span class="pl-s">','</span>);</pre></div><p><strong>Scenario:</strong> Split a comma-delimited input into substrings, then perform an operation with each substring.</p><div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> Using Utf8String input and producing Utf8String instances</span><span class="pl-c"><span class="pl-c">//</span> The Utf8Span code would look  identical (sub. 'Utf8Span' for 'ustring')</span><span class="pl-k">void</span><span class="pl-en">SplitSample</span>(<span class="pl-en">ustring</span><span class="pl-smi">input</span>)
{
    <span class="pl-k">while</span> (<span class="pl-smi">input</span>.<span class="pl-smi">Length</span><span class="pl-k">&gt;</span><span class="pl-c1">0</span>)
    {
        <span class="pl-c"><span class="pl-c">//</span> 'TryFind' is the 'IndexOf' equivalent. It returns a Range instead</span><span class="pl-c"><span class="pl-c">//</span> of an integer index because there's no this[int] indexer on Utf8String.</span><span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-smi">input</span>.<span class="pl-en">TryFind</span>(<span class="pl-s">','</span>, <span class="pl-k">out</span><span class="pl-en">Range</span><span class="pl-smi">matchedRange</span>))
        {
            <span class="pl-c"><span class="pl-c">//</span> The remainder of the input string is empty, but no comma</span><span class="pl-c"><span class="pl-c">//</span> was found in the remaining portion. Process the remainder</span><span class="pl-c"><span class="pl-c">//</span> of the input string, then finish.</span><span class="pl-en">ProcessValue</span>(<span class="pl-smi">input</span>);
            <span class="pl-k">break</span>;
        }

        <span class="pl-c"><span class="pl-c">//</span> We found a comma! Substring and process.</span><span class="pl-c"><span class="pl-c">//</span> The 'matchedRange' local contains the range for the ',' that we found.</span><span class="pl-en">ProcessValue</span>(<span class="pl-smi">input</span>[..<span class="pl-smi">matchedRange</span>.<span class="pl-smi">Start</span>]); <span class="pl-c"><span class="pl-c">//</span> fetch segment to the left of the comma, then process it</span><span class="pl-smi">input</span><span class="pl-k">=</span><span class="pl-smi">input</span>[<span class="pl-smi">matchedRange</span>.<span class="pl-smi">End</span>..]; <span class="pl-c"><span class="pl-c">//</span> set 'input' to the remainder of the input string and loop</span>
    }

    <span class="pl-c"><span class="pl-c">//</span> Could also have an IEnumerable&lt;ustring&gt;-returning version if we wanted, I suppose.</span>
}</pre></div><h2>Miscellaneous topics and open questions</h2><p><strong>What about comparing UTF-16 and UTF-8 data?</strong></p><p>Currently there is a set of APIs <code>Utf8String.AreEquivalent</code> which will decode sequences of UTF-16 and UTF-8 data and compare them for ordinal equality. The general code pattern is below.</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">ustring</span><span class="pl-smi">a</span><span class="pl-k">=</span> ...;
<span class="pl-k">string</span><span class="pl-smi">b</span><span class="pl-k">=</span> ...;

<span class="pl-c"><span class="pl-c">//</span> The below line fails to compile because there's no operator==(Utf8String, string) defined.</span><span class="pl-k">bool</span><span class="pl-smi">result</span><span class="pl-k">=</span> (<span class="pl-smi">a</span><span class="pl-k">==</span><span class="pl-smi">b</span>);

<span class="pl-c"><span class="pl-c">//</span> The below line is probably what the developer intended to write.</span><span class="pl-k">bool</span><span class="pl-smi">result</span><span class="pl-k">=</span><span class="pl-smi">ustring</span>.<span class="pl-en">AreEquivalent</span>(<span class="pl-smi">a</span>, <span class="pl-smi">b</span>);

<span class="pl-c"><span class="pl-c">//</span> The below line should compile since literal strings can be type targeted to Utf8String.</span><span class="pl-k">bool</span><span class="pl-smi">result</span><span class="pl-k">=</span> (<span class="pl-smi">a</span><span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>Hello!<span class="pl-pds">"</span></span>);</pre></div><p>Do we want to add an <code>operator==(Utf8String, string)</code> overload which would allow easy <code>==</code> comparison of UTF-8 and UTF-16 data? There are three main downsides to this which caused me to vote no, but I'm open to reconsideration.</p><ol><li><p>The compiler would need to special-case <code>if (myUtf8String == null)</code>, which would now be ambiguous between the two overloads. (If the compiler is already special-casing null checks, this is a non-issue.)</p></li><li><p>The performance of UTF-16 to UTF-8 comparison is much worse than the performance of UTF-16 to UTF-16 (or UTF-8 to UTF-8) comparison. When the representation is the same on both sides, certain shortcuts can be implemented to avoid the <em>O(n)</em> comparison, and even the <em>O(n)</em> comparison itself can be implemented as a simple <em>memcmp</em> operation. When the representations are heterogeneous, the opportunity for taking shortcuts is much more restricted, and the <em>O(n)</em> comparison itself has a higher constant factor. Developers might not expect such a performance characteristic from an equality operator.</p></li><li><p>Comparing a <code>Utf8String</code> against a literal string would no longer go through the fast path, as target typing would cause the compiler to emit a call to <code>operator==(Utf8String, string)</code> instead of <code>operator==(Utf8String, Utf8String)</code>. The comparison itself would then have the lower performance described by bullet (2) above.</p></li></ol><p>One potential upside to having such a comparison is that it would prevent developers from using the antipattern <code>if (myUtf8String.ToString() == someString)</code>, which would result in unnecessary allocations. If we are concerned about this antipattern one way to address it would be through a Code Analyzer.</p><p><strong>What if somebody passes invalid data to the "skip validation" factories?</strong></p><p>When calling the "unsafe" APIs, callers are fully responsible for ensuring that the invariants are maintained. Our debug builds could double-check some of these invariants (such as the initial <code>Utf8String</code> creation consisting only of well-formed data). We could also consider allowing applications to opt-in to these checks at runtime by enabling an MDA or other diagnostic facility. But as a guiding principle, when "unsafe" APIs are called the Framework should trust the developer and should have as little overhead as possible.</p><p><strong>Consider consolidating the unsafe factory methods under a single unsafe type.</strong></p><p>This would prevent pollution of the type's normal API surface and could help write tools which audit use of a single "unsafe" type.</p><p>Some of the methods may need to be extension methods instead of normal static factories. (Example: Unsafe slicing routines, should we choose to expose them.)</p><h2>Potential APIs to enlighten</h2><h3><em>System</em> namespace</h3><p>Include <code>Utf8String</code> / <code>Utf8Span</code> overloads on <code>Console.WriteLine</code>. Additionally, perhaps introduce an API <code>Console.ReadLineUtf8</code>.</p><h3><em>System.Data.*</em> namepace</h3><p>Include generalized support for serializing Utf8String properties as a primitive with appropriate mapping to <code>nchar</code> or <code>nvarchar</code>.</p><h3><em>System.Diagnostics.*</em> namespace</h3><p>Enlighten <code>EventSource</code> so that a caller can write <code>Utf8String</code> / <code>Utf8Span</code> instances cheaply. Additionally, some types like <code>ActivitySpanId</code> already have <code>ROS&lt;byte&gt;</code> ctors; overloads can be introduced here.</p><h3><em>System.Globalization.*</em> namespace</h3><p>The <code>CompareInfo</code> type has many members which operate on <code>string</code> instances. These should be spanified foremost, and <code>Utf8String</code> / <code>Utf8Span</code> overloads should be added. Good candidates are <code>Compare</code>, <code>GetHashCode</code>, <code>IndexOf</code>, <code>IsPrefix</code>, and <code>IsSuffix</code>.</p><p>The <code>TextInfo</code> type has members which should be treated similarly. <code>ToLower</code> and <code>ToUpper</code> are good candidates. Can we get away without enlightening <code>ToTitleCase</code>?</p><h3><em>System.IO.*</em> namespace</h3><p><code>BinaryReader</code> and <code>BinaryWriter</code> should have overloads which operate on <code>Utf8String</code> and <code>Utf8Span</code>. These overloads could potentially be cheaper than the normal <code>string</code> / <code>ROS&lt;char&gt;</code> based overloads, since the reader / writer instances may in fact be backed by UTF-8 under the covers. If this is the case then writing is simple projection, and reading is validation (faster than transcoding).</p><p><code>File</code>: <code>WriteAllLines</code>, <code>WriteAllText</code>, <code>AppendAllText</code>, etc. are good candidates for overloads to be added. On the read side, there's <code>ReadAllTextUtf8</code> and <code>ReadAllLinesUtf8</code>.</p><p><code>TextReader.ReadLine</code> and <code>TextWriter.Write</code> are also good candidates to overload. This follows the same general premise as <code>BinaryReader</code> and <code>BinaryWriter</code> as mentioned above.</p><p>Should we also enlighten <code>SerialPort</code> or GPIO APIs? I'm not sure if UTF-8 is a bottleneck here.</p><h3><em>System.Net.Http.*</em> namespace</h3><p>Introduce <code>Utf8StringContent</code>, which automatically sets the <em>charset</em> header. This type already exists in the <em>System.Utf8String.Experimental</em> package.</p><h3><em>System.Text.*</em> namespace</h3><p><code>UTF8Encoding</code>: Overload candidates are <code>GetChars</code>, <code>GetString</code>, and <code>GetCharCount</code> (of <code>Utf8String</code> or <code>Utf8Span</code>). These would be able to skip validation after transcoding as long as the developer hasn't subclassed the type.</p><p><code>Rune</code>: Add <code>ToUtf8String</code> API. Add <code>IsDefined</code> API to query the OS's NLS tables (could help with databases and other components that need to adhere to strict case / comparison processing standards).</p><p><code>TextEncoder</code>: Add <code>Encode(Utf8String): Utf8String</code> and <code>FindFirstIndexToEncode(Utf8Span): Index</code>. This is useful for HTML-escaping, JSON-escaping, and related operations.</p><p><code>Utf8JsonReader</code>: Add read APIs (<code>GetUtf8String</code>) and overloads to both the ctor and <code>ValueTextEquals</code>.</p><p><code>JsonEncodedText</code>: Add an <code>EncodedUtf8String</code> property.</p><p>Regex is a bit of a special case because there has been discussion about redoing the regex stack all-up. If we did proceed with redoing the stack, then it would make sense to add first-class support for UTF-8 here.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>