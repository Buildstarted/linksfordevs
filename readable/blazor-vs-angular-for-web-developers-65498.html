<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Blazor vs Angular for Web Developers - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Blazor vs Angular for Web Developers - linksfor.dev(s)"/>
    <meta property="og:description" content="A comparison of Blazor and Angular when it comes to modern web development&#x2014;a review of the pros and cons. Does Blazor stack up?"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.telerik.com/blogs/blazor-vs-angular-web-developers"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Blazor vs Angular for Web Developers</title>
<div class="readable">
        <h1>Blazor vs Angular for Web Developers</h1>
            <div>Reading time: 18-23 minutes</div>
        <div>Posted here: 11 Aug 2020</div>
        <p><a href="https://www.telerik.com/blogs/blazor-vs-angular-web-developers">https://www.telerik.com/blogs/blazor-vs-angular-web-developers</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
  
  
			<p><span>A comparison of Blazor and Angular when it comes to modern web development—a review of the pros and cons. Does Blazor stack up?</span></p>
<p>Blazor WebAssembly has landed, and brings the possibility of writing modern web applications using C#, but how does it stack up compared to the other, more established options for building "modern" web applications, such as Angular?&nbsp;&nbsp;</p>
<p>Today we'll take a good look at Blazor and see how it stacks up against Angular.</p>
<blockquote>
<p>Note: Interested in how Blazor stacks up against React instead? Check out a <a href="https://www.telerik.com/blogs/blazor-vs-react-web-developers" title="" target="">comparison of Blazor and React here</a>.</p>
</blockquote>
<p>Specifically, we'll explore how the following aspects work (for both Blazor and Angular):</p>
<ul>
    <li>Getting started</li>
    <li>Building the UI</li>
    <li>Passing data between components</li>
    <li>Handling forms</li>
    <li>Routing</li>
    <li>Fetching data from an API</li>
    <li>Pros and cons of each</li>
</ul>
<p>Before we dig in, it's worth noting this article focuses on Blazor WASM, which runs in the browser using WebAssembly. That said, many of the points are equally valid if you're looking at using Blazor Server instead.</p>
<h2 id="angularthetwominuteoverview">Angular—The Two-Minute Overview</h2>
<p>Angular is a <strong>JavaScript framework</strong> which enables you to run client web applications in the browser, but also create native (mobile) and desktop apps.</p>
<p>Broadly speaking, your Angular app will consist of lots of components, written using JavaScript (or TypeScript) and decorated with something Angular refers to as “directives” to handle things like binding your markup (HTML) to data.</p>
<p>The code you write with Angular cannot run directly in the browser, so you need a compiler to transform your code into something the browser can run.</p>
<p>Since Angular 9, the default option is to use the "Ahead-of-time compiler" to transform your code into efficient JavaScript as part of a build/publish process. The browser can then download and run this compiled JavaScript code.</p>
<p>Alternatively, you can use the "Just-in-time compiler" to compile your app in the browser at runtime.</p>
<p>When a user accesses your Angular application, the browser's JavaScript engine kicks in to execute your application's code.</p>
<h2 id="howdoesblazorcompare">How Does Blazor Compare?</h2>
<p>Blazor is also a <strong>framework</strong> that enables you to build client web applications that run in the browser, but using C# instead of TypeScript.</p>
<p>When you create a new Blazor app it arrives with a few carefully selected packages (the essentials needed to make everything work) and you can install additional packages using NuGet.</p>
<p>From here, you build your app as a series of components, using the Razor markup language, with your UI logic written using C#.</p>
<p>The browser can't run C# code directly, so just like the Angular AOT approach you'll lean on the C# compiler to compile your C# and Razor code into a series of .dll files.</p>
<p>To publish your app, you can use dot net's built-in <code>publish</code> command, which bundles up your application  into a number of files (HTML, CSS, JavaScript and DLLs), which can then be published to any web server that can serve static files.</p>
<p>When a user accesses your Blazor WASM application, a Blazor JavaScript file takes over, which downloads the .NET runtime, your application and its dependencies before running your app using WebAssembly.</p>
<p>Blazor then takes care of updating the DOM, rendering elements and forwarding events (such as button clicks) to your application code.</p>
<h2 id="creatinganewangularapp">Creating a New Angular App</h2>
<p>Angular has its own CLI for creating projects and generating application code.</p>
<p>You can install it using Yarn or npm.</p>

<p>Spinning up a new app is a case of running this command.</p>

<p>The CLI gives you a few options at this point, specifically asking whether you want to include Angular Routing and which stylesheet format you want (CSS, SCSS etc.).</p>
<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-08/angular-cli-add-component.png" alt="Angular CLI add component questions" title="Angular CLI add component prompts"></p>
<p>Then you can run your app using this command.</p>

<h2 id="creatinganewblazorapp">Creating a New Blazor App</h2>
<p>For Blazor, you can use Visual Studio or the .NET Core CLI (which is included with the .NET Core SDK).</p>

<p>You have a few other options, like the ability to include infrastructure for authenticating users, and whether to host your Blazor app in an ASP.NET web application, but the command above is the simplest option to get started.</p>
<h2 id="buildingyouruiwithangular">Building Your UI with Angular</h2>
<p>Angular adopts a component approach to building your UI.</p>
<p>For example, let's create a simple Hello World component which lets the user enter their name for a more personalized greeting.</p>
<p>You can use the Angular CLI to generate a new component.</p>

<p>This gives you four files:</p>
<ul>
    <li>hello-world.component.css</li>
    <li>hello-world.component.html</li>
    <li>hello-world.component.spec.ts</li>
    <li>hello-world.component.ts</li>
</ul>
<p>By default Angular leans quite heavily on TypeScript, which then gets compiled to regular JavaScript to run in the browser.</p>
<p>We can build a simple Hello World UI...</p>
<p><strong>hello-world.component.html</strong></p>

<p>This is a mix of standard HTML and Angular syntax to handle DOM events and display data.</p>
<p><code>(keyup)="onKey($event)"</code> directs Angular to invoke an <code>onKey</code> function every time the user types something into the text input.</p>
<p><code>{{name}}</code> uses Angular's interpolation syntax <code>{{ }}</code> to render the current value of a <code>name</code> field, which is declared in the corresponding hello-world.component.ts file.</p>
<p><strong>hello-world.component.ts</strong></p>

<p>You can see there's a bit of boilerplate code here.</p>
<p>We have the <code>@Component</code> declaration which tells Angular how we'll reference this component from other components (the selector), where its UI markup (HTML) and styles (CSS) live.</p>
<p>Then follows a TypeScript class called <code>HelloWorldComponent</code> which houses our main component logic.</p>
<p>This class implements <code>OnInit</code> from the Angular core library which, in turn, requires us to implement an <code>ngOnInit</code> method in our class.</p>
<p>Finally, we have the <code>name</code> field we're using to store the entered name, and the <code>onKey</code> function that will be invoked as our users type something into the text input.</p>
<p>To view this component, we need to render it somewhere in our application, which we can do using the <code>selector</code> we defined earlier.</p>

<p>With all that in place (and sticking to Angular's "out of the box" default styles) we get a functional, if slightly bland looking, personalized greeting!</p>
<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-08/angular-hello-world.png" alt="Angular example showing how typing a name changes the greeting" title="Angular Hello World in action"></p>
<p>In summary, an Angular UI:</p>
<ul>
    <li>Comprises one or more components</li>
    <li>Is typically written using TypeScript or JavaScript and special Angular directives</li>
    <li>Runs on the browser's JavaScript engine</li>
</ul>
<h2 id="buildingyouruiwithblazor">Building Your UI with Blazor</h2>
<p>Blazor adopts a very similar approach to Angular in that you build your UI using components, but you get to use Razor and C# (instead of Angular directives and JavaScript) to write your markup and UI logic.</p>
<p><strong>Greeting.razor</strong></p>

<p>This operates exactly the same way as the Angular example when you run it in the browser.</p>
<p>We've got roughly similar markup, but this time we have used Blazor's <code>@bind</code> syntax to bind our input to a property called <code>Name</code>.</p>
<p>When the user enters their name, the <code>Name</code> property will be updated with the value they enter.</p>
<p>By default Blazor would update the value of <code>Name</code> on blur (when we clicked out of the text input) so we've added  <code>@bind-value:event="oninput"</code> to make it update the property as soon as we start typing.</p>
<p>As with Angular, you're now free to render this component wherever (and as often as) you like.</p>

<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-08/blazor-hello-world.gif" alt="Blazor example showing how typing in a name changes the greeting" title="Blazor Hello World in action"></p>
<p>In summary, a Blazor UI:</p>
<ul>
    <li>Comprises one or more components</li>
    <li>Is written using Razor and C# (which takes your markup and data, and combines them together)</li>
    <li>Runs on WebAssembly in the browser</li>
</ul>
<h2 id="passingdataaroundangular">Passing Data Around—Angular</h2>
<p>We've already seen one way to handle state in Angular components, by <strong>storing it in a field</strong> (as with <code>name</code> in our Hello world example).</p>
<p>But another common approach is to <strong>pass values into a component</strong>.</p>
<p>For example, you might choose to pass in a custom headline when you declare an instance of our Hello World component...</p>

<p>This enables us to use this same component in different places, but with different headlines for each one.</p>
<p>Angular makes this possible using something called <code>Input</code>.</p>
<p>We can modify our component to accept a headline by adding an <code>@Input</code> to the existing <code>HelloWorldComponent</code> class.</p>

<p>We can now pass a value or headline into our component, but it isn't rendered anywhere yet. To solve that, we can use Angular's interpolation syntax <code>{{ }}</code> to show the value of <code>headline</code> wherever we want...</p>
<p><strong>hello-world.component.html</strong></p>

<p>Now when we run this in the browser, we'll see the custom headline.</p>
<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-08/angular-component-inputs.png" alt="Angular example showing an Input bound from a parent component" title="Angular component Inputs"></p>
<h2 id="passingdataaroundblazor">Passing Data Around—Blazor</h2>
<p>Broadly speaking, Blazor has the same two primary options for managing state.</p>
<p>You can store data in the component itself using properties (as with <code>Name</code> in our example) or take data in via parameters.</p>

<p>Here we've declared a <code>Headline</code> parameter in the <code>@code</code> section of our component.</p>
<p>As with the Angular example, when you render <code>Greeting</code> you can pass in a headline and it will be rendered accordingly.</p>

<h2 id="handlingformsinangular">Handling Forms in Angular</h2>
<p>Handling <code>keyup</code> and similar events works fine to a point, but there are some limitations.</p>
<p>For example, in our HelloWorld component, if you change the value of <code>name</code> programmatically in the <code>HelloWorldComponent</code> class, this won't be reflected in the text input.</p>
<p>For this two-way binding requirement we need a different approach.</p>
<p>Enter the humble HTML form!</p>
<p>Angular has two primary options for handling forms:</p>
<ul>
    <li>Reactive Forms</li>
    <li>Template Driven Forms</li>
</ul>
<p>Arguably, <strong>Reactive Forms</strong> are closer to Blazor's forms, so that's what we'll focus on here.</p>
<p>Here's the markup for a "contact us" Reactive Form by way of example.</p>

<p>There's a bit to unpack here.</p>
<p>We've declared a <strong>FormGroup</strong> which points to a corresponding <code>form</code> field in our component's TypeScript. </p>
<p><strong>Form Groups</strong> in Angular manage the values and validity status of fields in a form.</p>
<p>Each individual form control (in this case, each text input field) points to its own <strong>FormControl</strong>, which manages its own value and validity status.</p>
<p>We've used <code>(ngSubmit</code>) to point this form to an <code>onSubmit()</code> function which will be invoked when the form is submitted.</p>
<p>The TypeScript code for this form looks like this:</p>

<p>Besides the regular Angular component boilerplate, we have our form group (<code>form</code>).</p>
<p>In the constructor we've created and assigned a new form group to our <code>form</code> field, and declared our individual form controls for <code>name</code> and <code>comments</code>.</p>

<p>We've flagged <code>name</code> as a required field using <code>Validators.required</code>.</p>
<p><code>onSubmit</code> will log the form's values to the console when the form is submitted. </p>
<p>We also needed a way to access <code>name</code> from our component markup (to conditionally show or hide the validation errors) and that's handled by this line:</p>

<h2 id="handlingformswithblazor">Handling Forms with Blazor</h2>
<p>By contrast, Blazor has a much simpler built-in mechanism for handling form data and validation, using something called <code>EditForm</code>.</p>
<p>Here's the markup for an equivalent form to our Angular example.</p>

<p>We're using Blazor's <code>InputText</code> component for our input fields.</p>
<p>Technically it's entirely possible to use standard HTML elements and forms with Blazor, but using the built-in controls make certain things a lot easier (validation being one, as we'll see in a moment).</p>
<p><code>@bind-Value</code> takes care of both reading the value from a field and updating it when a user types in a new value. </p>
<p>The form itself is attached to a <code>Model</code> of our choosing (where the form values will live) and we've told it to invoke a method called <code>HandleValidSubmit</code> when the form is submitted (and is valid). </p>
<p>Note we've included a <code>DataAnnotationsValidator</code> and <code>ValidationSummary</code>; these components wire up the form to automatically respect any validation rules we set up on our model.</p>
<p>Here's the rest of the code:</p>

<p>The <code>ContactUsModel</code> class could live anywhere in our project.</p>
<p>We have a <code>FormModel</code> property and <code>HandleValidSubmit</code> method.</p>
<p>When someone fills in the form, if they've met the validation rules (a <code>Name</code> has been entered), then <code>HandleValidSubmit</code> will be invoked.</p>
<p>Otherwise, the <code>ValidationSummary</code> will be used to show which fields have validation errors.</p>
<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-08/blazor-validation.png" alt="Blazor example of form with validation errors" title="Blazor validation example"></p>
<h2 id="routinginangular">Routing in Angular</h2>
<p>In most applications you'll want to be able to handle routes.</p>
<p>So, for example, if someone accesses "/about" they might see your about "page" (which will actually render one or more components).</p>
<p>Angular handles routes via <code>@angular/router</code> and by default it looks for routes defined in an array in <strong>app-routing.module.ts</strong>.</p>

<p>In this example, any request to <code>/greetMe</code> will now attempt to render our <code>HelloWorldComponent</code>.</p>
<p>But this still won't show up anywhere until we give Angular a bit more direction.</p>
<p>Specifically, we need to include a <strong>router outlet</strong> in our application's main template, something like this in <strong>app.component.html</strong>:</p>

<p>With that in place, navigating to <code>/greetMe</code> will result in the <code>HelloWorldComponent</code> being displayed in place of our <code>router-outlet</code> element.</p>
<h2 id="routinginblazor">Routing in Blazor</h2>
<p>Blazor ships routing "out of the box" and leans on ASP.NET's existing routing engine. </p>
<p>You can easily make any Blazor component "routable" by adding a <code>@page</code> declaration at the top of your component...</p>

<p>Now any request to <code>http://&lt;your-web-site-here&gt;/GreetMe</code> will render this component.</p>
<p>You can also pass data in via the route, like this:</p>

<p>With this, any request to <code>http://&lt;your-web-site-here&gt;/GreetMe/Jon</code> will render a more personalized greeting (well, if your name's Jon according to this example!).</p>
<h2 id="fetchingdatafromanapiusingangular">Fetching Data from an API Using Angular</h2>
<p>Angular advocates using services to fetch or save data in your components.</p>
<p>The concept is that the component itself should be unaware of the specific details of how data is fetched or saved.</p>
<p>You can generate a service using the Angular CLI:</p>

<p>Here's an example service for fetching a list of support tickets.</p>
<p><strong>ticket.service.ts</strong></p>

<p>This leans on Angular's dependency injection to bring in an instance of <code>HttpClient</code>.</p>
<p>We can then make the HTTP call, mapping the response to an <strong>Observable</strong> array of tickets.</p>
<p>Now we can use <code>getTickets</code> in our component.</p>
<p><strong>ticket-list.component.ts</strong></p>

<p>We inject an instance of <code>TicketService</code>, subscribe to its <code>getTickets</code> observable and assign the resulting array to the <code>tickets</code> field.</p>
<p>Finally, we can loop over this array in our component's template, using <code>*ngFor</code>.</p>

<h2 id="fetchingdatafromanapiusingblazor">Fetching Data from an API Using Blazor</h2>
<p>Blazor leans on .NET's <code>HttpClient</code> for fetching data. </p>
<p>Under the hood, this defers to the native <code>fetch</code> API, but you can generally just ignore that and use the abstraction.</p>
<p>Here's an example:</p>

<p>As with Angular, you could easily move this to a separate service and inject that into your component (to avoid directly calling <code>HttpClient</code>).</p>


<p>Blazor has a useful trick up its sleeve (compared to Angular, or any other existing frontend framework) when it comes to the interaction between your UI and API.</p>
<p>Because you're writing your web app in C#, you can use the same data models in your frontend and backend (API) code.</p>
<p>Let's say for example you need to retrieve a list of people.</p>
<p><img src="https://d585tldpucybw.cloudfront.net/sfimages/default-source/blogs/2020/2020-08/shared-models.png" alt="Diagram showing how it works using one shared model between client and API with Blazor" title="Blazor Shared Model Overview"></p>
<p>The <code>Person</code> model lives in a shared class library.</p>
<p>Both your Web API and Blazor Client projects reference this shared library.</p>
<p>Now your API can be strongly typed, returning (and accepting) data using the <code>Person</code> model.</p>
<p>The data is still serialized and sent "over the wire" as JSON data, but your Blazor application can deserialize the JSON data using the exact same <code>Person</code> model that was used to serialize it in the first place.</p>
<p>Now if you make breaking changes to your <code>Person</code> model, you'll immediately see compilation errors if you've introduced any breaking changes which affect either the client or server use of the model.</p>
<h2 id="prosandcons">Pros and Cons</h2>
<p>So all this brings us to the obvious question, which one should you choose?</p>
<p>Well naturally this will depend on your own background, skills and preferences. </p>
<p>We've seen how there are a number of similarities between the two, but also a few key differences.</p>
<h3 id="angular">Angular</h3>
<p>Angular gives you all the tools you need to build complex web applications, composed from lots of smaller components.</p>
<p>But it also requires you to learn its own highly opinionated abstractions in order to build your application "the Angular way."</p>
<p>For example, you will need to understand how <strong>Reactive</strong> and <strong>Template-Driven</strong> forms work (and the differences between them) to choose the best option for your particular scenario.</p>
<p>Native TypeScript support is really useful in catching errors that might otherwise occur at runtime (you know the sort, those errors which crop up  when a "simple property name change" spirals into an afternoon of whack-a-mole!)</p>
<p>But TypeScript also brings its own learning curve, which, coupled with learning the nuances of Angular's vast framework, gives you a steep hill to climb, especially if you're just looking to build a small, "simple" web application to start with.</p>
<p><strong>Angular Pros</strong></p>
<ul>
    <li>Well-established framework</li>
    <li>Everything you need is included</li>
    <li>TypeScript support is baked in and offers reliable type safety</li>
    <li>You can build Angular apps for web, native desktop and native mobile</li>
</ul>
<p><strong>Angular Cons</strong></p>
<ul>
    <li>TypeScript brings its own learning curve</li>
    <li>Whether you use TypeScript or not, you're essentially required to write your components using JavaScript (either a pro or a con depending on your feelings toward JavaScript!)</li>
    <li>Angular itself carries a steep learning curve</li>
    <li>Angular's docs, while comprehensive, are jam-packed with Angular-specific terminology and concepts which can be hard to digest and fully understand on first read</li>
    <li>The component code and markup you write is generally more verbose than the Blazor equivalent</li>
</ul>
<h3 id="blazor">Blazor</h3>
<p><strong>Blazor</strong> offers a few advantages, especially if you're coming from a C# background.</p>
<p>You can bring your existing C# skills, experience and knowledge to the modern web application party!</p>
<p>You can stick to the ecosystem you already know (NuGet, the <code>dotnet</code> tooling, Visual Studio or VS Code).</p>
<p>You get to share models between client and backend API. This is a big deal and makes it much harder to inadvertently break your application.</p>
<p>Routing, form handling and validation are baked in, but generally use simpler abstractions than Angular's equivalents.</p>
<p>You can still call out to JavaScript if you need to.</p>
<p><strong>Blazor Pros</strong></p>
<ul>
    <li>Write modern web apps using C#</li>
    <li>Built-in form handling, validation, routing and data fetching client</li>
    <li>Ability to bring in third-party code via NuGet packages</li>
    <li>You can use the tools you already know (Visual Studio, VS Code, Rider etc.)</li>
    <li>Can be deployed as static files</li>
    <li>Shared models significantly reduce the chances of accidentally breaking the client</li>
    <li>You can use the same component model in the browser (using WebAssembly) or on the server (using Blazor Server)</li>
    <li>Support to use the same Blazor component model on windows and for mobile development is coming</li>
</ul>
<p><strong>Blazor Cons</strong></p>
<ul>
    <li>New framework, will take time to bed in and gain adoption</li>
    <li>Sizeable initial download of .NET framework to browser on first load</li>
    <li>Tooling also young and will evolve over time</li>
    <li>Fewer resources available on the internet (tutorials, etc.) compared to Angular</li>
    <li>Does depend on WebAssembly support in the browser (although this is now widely supported)</li>
    <li>The initial download for the .NET runtime is relatively big</li>
</ul>
<p>One thing to call out here is the initial download time.</p>
<p>When someone accesses your Blazor WASM app for the first time, their browser will download a version of the .NET framework as well as your application's files.</p>
<p>Once they have these files, they don't need to download them again, but it does mean you're likely to see a "loading..." indicator first time around.</p>
<p>The team at Microsoft has done a lot of work to get this initial download size down, but naturally this means Blazor is better suited to some web applications than others. </p>
<p>You probably wouldn't want to use it for things like product landing pages where there's little to no business logic and it's imperative that the page loads as quickly as possible.</p>
<p>But, for any Line of Business apps, this initial download is unlikely to pose a major issue.</p>
<h2 id="overtoyou">Over to You!</h2>
<p>So, are you thinking of using Blazor? Is it a contender or your next project, or will you be sticking with Angular for now?</p>
<p>The choice is yours!</p>
	<hr>
          
                   
   </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>