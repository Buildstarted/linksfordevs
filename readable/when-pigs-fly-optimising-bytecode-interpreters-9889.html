<!DOCTYPE html>
<html lang="en">
<head>
    <title>
When pigs fly: optimising bytecode interpreters - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="When pigs fly: optimising bytecode interpreters - linksfor.dev(s)"/>
    <meta property="article:author" content="Vladimir Kazanov"/>
    <meta property="og:description" content="This is part two in my series of articles about bytecode interpreters, based on a small stack virtual machine which I have nicknamed PM&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://badootech.badoo.com/when-pigs-fly-optimising-bytecode-interpreters-f64fb6bfa20f?gi=180d73a81384"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - When pigs fly: optimising bytecode interpreters</title>
<div class="readable">
        <h1>When pigs fly: optimising bytecode interpreters</h1>
            <div>by Vladimir Kazanov</div>
            <div>Reading time: 22-28 minutes</div>
        <div>Posted here: 20 Mar 2019</div>
        <p><a href="https://badootech.badoo.com/when-pigs-fly-optimising-bytecode-interpreters-f64fb6bfa20f?gi=180d73a81384">https://badootech.badoo.com/when-pigs-fly-optimising-bytecode-interpreters-f64fb6bfa20f?gi=180d73a81384</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a href="https://badootech.badoo.com/@vladimir.kazanov?source=post_page-----f64fb6bfa20f----------------------" rel="noopener"><img alt="Vladimir Kazanov" src="https://miro.medium.com/fit/c/48/48/0*Re1gNrtRgcp3X8od.jpg" width="48" height="48"></a></p></div></div></div></div><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/0*lngZ1avoFp-19sB_?q=20" width="1101" height="793" role="presentation"></p><p><img width="1101" height="793" role="presentation" src="https://miro.medium.com/max/1101/0*lngZ1avoFp-19sB_"></p></div></div></div></div></figure><blockquote><p>“No matter how hard you try, you can’t make a racehorse out of a pig. You can, however, make a faster pig.” <br> — A comment in the Emacs source code.</p></blockquote><p id="fe59" data-selectable-paragraph="">Everyone knows that pigs can’t fly — just like everyone <em>thinks</em> they know that bytecode interpreters, as a technology for executing high-level languages, can’t be sped up without resorting to labour-intensive dynamic compilation.</p><p id="8451" data-selectable-paragraph="">This is part two in my series of articles about bytecode interpreters, based on a small stack virtual machine which I have nicknamed PM (The Piglet Machine). In it, I will attempt to show you that, in the case of ambitious, hardworking “piglets” and working within the confines of standard C (for the most part), it is entirely possible to speed up the work of such interpreters by a factor of at least 1 ½.</p><p id="88de" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://badootech.badoo.com/home-grown-bytecode-interpreters-51e12d59b25c">Part 1 - Home-grown bytecode interpreters</a><br><a target="_blank" rel="noopener" href="https://badootech.badoo.com/regex-bytecode-interpreter-looking-for-needles-in-session-haystacks-9bbff9db09bc">Part 3 - Regex bytecode interpreter: looking for needles in session haystacks</a></p><p id="887b" data-selectable-paragraph="">Let’s start with some introductions.</p><p id="5feb" data-selectable-paragraph="">The “<a href="https://github.com/vkazanov/bytecode-interpreters-post/blob/master/pigletvm.c" target="_blank" rel="noopener">Piglet Machine</a>” is a middle-of-the-road stack machine based on the<a href="https://github.com/vkazanov/bytecode-interpreters-post/blob/master/interpreter-stack-machine.c" target="_blank" rel="noopener"> example</a> I gave in<a target="_blank" rel="noopener" href="https://badootech.badoo.com/home-grown-bytecode-interpreters-51e12d59b25c"> part one</a> of this series. Our “pig” only understands one kind of data — a 64-bit word — and performs all calculations (involving integers only) on a stack with a maximum depth of 256 words. Besides the stack, this piglet has a working memory with a capacity of 65,536 words. The result of running the program, namely a single machine word, can either be put in the result register or simply printed to standard output (stdout).</p><p id="1ca5" data-selectable-paragraph="">Everything in the Piglet Machine is stored in a single structure:</p><pre><span id="ee94" data-selectable-paragraph="">static struct {<br>    /* Current instruction pointer */<br>    uint8_t *ip;</span><span id="83d4" data-selectable-paragraph="">/* Fixed-size stack */<br>    uint64_t stack[STACK_MAX];<br>    uint64_t *stack_top;</span><span id="2348" data-selectable-paragraph="">/* Operational memory */<br>    uint64_t memory[MEMORY_SIZE];</span><span id="68b8" data-selectable-paragraph="">/* A single register containing the result */<br>    uint64_t result;<br>} vm;</span></pre><p id="668e" data-selectable-paragraph="">The items listed above allow this machine to be categorised as a low-level virtual machine, in which almost all overheads are spent on servicing the main program loop:</p><pre><span id="7ea0" data-selectable-paragraph="">interpret_result vm_interpret(uint8_t *bytecode)<br>{<br>    vm_reset(bytecode);</span><span id="55ec" data-selectable-paragraph="">for (;;) {<br>        uint8_t instruction = NEXT_OP();<br>        switch (instruction) {<br>        case OP_PUSHI: {<br>            /* get the argument, push it onto stack */<br>            uint16_t arg = NEXT_ARG();<br>            PUSH(arg);<br>            break;<br>        }<br>        case OP_ADD: {<br>            /* Pop 2 values, add 'em, push the result back to the stack */<br>            uint64_t arg_right = POP();<br>            *TOS_PTR() += arg_right;<br>            break;<br>        }</span><span id="e689" data-selectable-paragraph="">/*<br>        * ...<br>        * Lots of other instruction handlers here<br>        * ...<br>        */</span><span id="d09c" data-selectable-paragraph="">case OP_DONE: {<br>            return SUCCESS;<br>        }<br>        default:<br>            return ERROR_UNKNOWN_OPCODE;<br>        }<br>    }</span><span id="e19a" data-selectable-paragraph="">return ERROR_END_OF_STREAM;<br> }</span></pre><p id="17ce" data-selectable-paragraph="">As the code demonstrates, in the case of each opcode the piglet has to:</p><ol><li id="d41b" data-selectable-paragraph="">Extract the opcode from the instruction stream;</li><li id="5094" data-selectable-paragraph="">Ensure that the opcode fits into the permissible interval for opcode values (compiler C adds this logic when the switch code is generated);</li><li id="422f" data-selectable-paragraph="">Jump to the body of the instruction;</li><li id="d425" data-selectable-paragraph="">Extract arguments for the instruction from the stack or decode the argument for the instruction located directly in the bytecode;</li><li id="3026" data-selectable-paragraph="">Perform the operation;</li><li id="bff0" data-selectable-paragraph="">Put it in the stack if the calculation yields a result; and</li><li id="4748" data-selectable-paragraph="">Move the pointer from the current instruction to the following one.</li></ol><p id="0e14" data-selectable-paragraph="">Only point five is useful. All the others just represent overheads.</p><p id="4b66" data-selectable-paragraph="">In short, the ‘pig’ has exceeded its recommended body-mass ratio. If we want to get it into shape, we’re going to have to do something about all these excesses.</p><p id="bbb6" data-selectable-paragraph="">Let’s start off by agreeing the rules of the game.</p><p id="143d" data-selectable-paragraph="">Writing programs for a virtual machine directly in C is bad form, but creating a programming language takes a lot of time. On that basis, we decided to go with a pig assembler language.</p><p id="02df" data-selectable-paragraph="">This is what the program that calculates the sum of numbers from 1 to 65,536 looks like in the assembler language:</p><pre><span id="522e" data-selectable-paragraph=""># sum numbers from 1 to 65535</span><span id="f917" data-selectable-paragraph=""># init the current sum and the index<br>PUSHI 1<br>PUSHI 1<br># stack s=1, i=1<br>STOREI 0<br># stack: s=1</span><span id="d960" data-selectable-paragraph=""># routine: increment the counter, add it to the current sum<br>incrementandadd:</span><span id="cf1a" data-selectable-paragraph=""># check if index is too big<br>LOADI 0<br># stack: s, i<br>ADDI 1<br># stack: s, i+1<br>DUP<br># stack: s, i+1, i+1<br>GREATER_OR_EQUALI 65535<br># stack: s, i+1, 1 or 0<br>JUMP_IF_TRUE done<br># stack: s, i+1<br>DUP<br># stack: s, i+1, i+1<br>STOREI 0<br># stack: s, i+1<br>ADD<br># stack: s+i+1<br>JUMP incrementandadd</span><span id="496a" data-selectable-paragraph="">done:<br>DISCARD<br>PRINT<br>DONE</span></pre><p id="b0ee" data-selectable-paragraph="">This is not Python, of course, but we have everything here that you’d need to make a pig happy: comments, labels, conditional and unconditional transitions between them, mnemonics for instructions and the option of specifying direct arguments for instructions.</p><p id="f9fa" data-selectable-paragraph="">The Piglet Machine comes with an assembler and a disassembler, which brave readers with a lot of free time on their hands can try out for themselves.</p><p id="f2c0" data-selectable-paragraph="">The numbers add up very quickly, so I wrote another program to test productivity: a naïve implementation of the<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="noopener"> Sieve of Eratosthenes</a>.</p><p id="582d" data-selectable-paragraph="">In actual fact the pig is able to run quite fast on its own (its instructions are close to machine instructions), so in order to obtain clear results, I am going to perform each measurement for a hundred program launches.</p><p id="cb5c" data-selectable-paragraph="">The first version of our non-optimised pig runs something like this:</p><pre><span id="518c" data-selectable-paragraph="">&gt; ./pigletvm runtimes test/sieve-unoptimized.bin 100 &gt; /dev/null<br>PROFILE: switch code finished took 545ms</span></pre><p id="ec43" data-selectable-paragraph="">Half a second! Granted, the comparison isn’t fair, but the same algorithm in Python performs much slower in the case of a hundred launches:</p><pre><span id="dd94" data-selectable-paragraph="">&gt; python test/sieve.py &gt; /dev/null<br>4.66692185402</span></pre><p id="6074" data-selectable-paragraph="">4.5 seconds, or nine times slower. Give the pig its due: it’s not that bad at maths! Now let’s see how it gets on when we put it through its paces.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*Z2ArVrlDgUxCGmdOfyFKRw.jpeg?q=20" width="1101" height="793" role="presentation"></p><p><img width="1101" height="793" role="presentation"></p></div></div></div></div></figure><p id="19e1" data-selectable-paragraph="">The first rule of fast code is not to do extra work. The second rule of fast code is never to do any extra work. So, what is the extra work the Piglet Machine’s doing?</p><p id="1673" data-selectable-paragraph="">Observation one: the profiling for our program reveals that there is one particular sequence of instructions that we encounter more often than others. Let’s not torture our pig and limit ourselves to just a couple of instructions:</p><ol><li id="6563" data-selectable-paragraph="">LOADI 0, ADD — push a number from the memory to the stack, mapping it to 0, and add it to the number at the top of the stack.</li><li id="605f" data-selectable-paragraph="">PUSHI 65536, GREATER_OR_EQUAL — push a number to the stack and compare it with the number which was previously at the top of the stack, pushing the result of the comparison (0 or 1) back to the stack.</li><li id="99de" data-selectable-paragraph="">PUSHI 1, ADD — push a number to the stack, add it to the number which was previously at the top of the stack, and push the resulting sum back to the stack.</li></ol><p id="d841" data-selectable-paragraph="">Our Piglet Machine has just over 20 instructions. We represent every instruction using a single byte, which means we have 256 possible instruction codes. Introducing new instructions isn’t a problem, so that’s what we’ll do:</p><pre><span id="a0ca" data-selectable-paragraph="">for (;;) {<br>    uint8_t instruction = NEXT_OP();<br>    switch (instruction) {<br>    /*<br>     * Other instructions here<br>     * */<br>    case OP_LOADADDI: {<br>        /* get immediate argument as an memory address , add it to value from the address to the top<br>         * of the stack */<br>        uint16_t addr = NEXT_ARG();<br>        uint64_t val = vm.memory[addr];<br>        *TOS_PTR() += val;<br>        break;<br>    }<br>    case OP_GREATER_OR_EQUALI:{<br>        /* get the immediate argument, compare it with the value from the address to the top of the stack */<br>        uint64_t arg_right = NEXT_ARG();<br>        *TOS_PTR() = PEEK() &gt;= arg_right;<br>        break;<br>    }<br>    case OP_ADDI: {<br>        /* Add immediate value to the top of the stack */<br>        uint16_t arg_right = NEXT_ARG();<br>        *TOS_PTR() += arg_right;<br>        break;<br>    }<br>    /*<br>     * Other instructions here<br>     * */<br>}</span></pre><p id="a72d" data-selectable-paragraph="">Nothing complicated here. Let’s see what the outcome is:</p><pre><span id="10cc" data-selectable-paragraph="">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null<br>PROFILE: switch code finished took 410ms</span></pre><p id="7c50" data-selectable-paragraph="">Wow! Only three new instructions in the code and yet we’ve “won” ourselves 150 or so milliseconds!</p><p id="ff79" data-selectable-paragraph="">The gains achieved here are thanks to the fact that our piglet, when performing these instructions, isn’t performing any extra moves: the execution thread isn’t straying into the main loop, there isn’t anything extra being decoded and the arguments for instructions are not being sent through the stack again unnecessarily.</p><p id="6997" data-selectable-paragraph="">This is what we call static superinstructions, since additional instructions are determined statically — that is to say, by the virtual machine programmer at the development stage. This is a simple and effective technique which, in one way or another, all programming language virtual machines use.</p><p id="6ddb" data-selectable-paragraph="">The main problem in the case of static superinstructions is that, without a specific program, it isn’t possible to determine which particular instructions should be combined. Various programs use various sequences of instructions, and these sequences can only be found out once you run a given code.</p><p id="62be" data-selectable-paragraph="">The next step could have been the dynamic compilation of superinstructions within the context of a particular program, that is to say dynamic superinstructions. In the 90s and the early 2000s, this technique was used in primitive JIT compilers. However, it’s a lengthy step, so we’ll be skipping it this time.</p><p id="74b6" data-selectable-paragraph="">Normal С doesn’t allow you to create instructions ‘on the go’, and our piglet is within its rights not to consider this a fair contest. Fortunately, I have a couple of better exercises for it.</p><p id="37ae" data-selectable-paragraph="">According to our rules for fast code, let’s ask that age-old question once again: what can we NOT do?</p><p id="4795" data-selectable-paragraph="">When we were first introduced to the set up for the Piglet Machine, I listed off all the actions a virtual machine performs for each opcode. And point 2 (checking whether the opcode value fits into the permissible interval of switch values) is the one which raises the most questions.</p><p id="9ecb" data-selectable-paragraph="">Let’s look more closely at how GCC compiles the switch construction:</p><ol><li id="4982" data-selectable-paragraph="">A transitions table is built, that is to say a table which displays the opcode value, mapping it to the code which executes the instruction body;</li><li id="850a" data-selectable-paragraph="">The code is inserted, checking whether the opcode obtained fits into the interval for all possible switch values, and sends it to the “default” label if there is no handler for the opcode;</li><li id="15c0" data-selectable-paragraph="">Code is inserted which transitions to the handler.</li></ol><p id="026d" data-selectable-paragraph="">But why perform a value interval check for each instruction? We consider that the opcode is either correct (terminating execution by means of an OP_DONE instruction) or incorrect, straying outside bytecode. The tail of the opcode stream is marked by a zero, and zero is the opcode for the OP_ABORT instruction, which terminates execution of the bytecode with an error.</p><p id="cf0b" data-selectable-paragraph="">It turns out that this check isn’t needed at all! And the piglet must be able to communicate this to the compiler. Let’s try to correct the main switch a little:</p><pre><span id="bcb5" data-selectable-paragraph="">uint8_t instruction = NEXT_OP();<br>/* Let the compiler know that opcodes are always between 0 and 31 */<br>switch (instruction &amp; 0x1f) {<br>   /* All the instructions here */<br>   case 26 ... 0x1f: {<br>       /*Handle the remaining 5 non-existing opcodes*/<br>       return ERROR_UNKNOWN_OPCODE;<br>   }<br>}</span></pre><p id="4824" data-selectable-paragraph="">Knowing that we only have 26 instructions, we use a bitmask (hexadecimal value 0x1f — this is binary 0b11111, covering the values interval from 0 to 31) on the opcode and add handlers for unused values in the interval from 26 to 31.</p><p id="17b2" data-selectable-paragraph="">Bit instructions are some of the cheapest in the x86 architecture, and they are definitely cheaper than problematic conditional transitions along the lines of the one used by the values interval check. Theoretically, we should be able to win several cycles for each instruction due to be performed, if the compiler gets our hint.</p><p id="75c3" data-selectable-paragraph="">Incidentally, the means for specifying the values interval in ‘case’ is not standard C, but a GCC extension. However, for our purposes this code will do, especially since it isn’t complicated to redo it for several handlers for each of the unnecessary values.</p><p id="090b" data-selectable-paragraph="">Let’s give it a try:</p><pre><span id="3a50" data-selectable-paragraph="">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null<br>PROFILE: switch code finished took 437ms<br>PROFILE: switch code (no range check) finished took 383ms</span></pre><p id="4cb1" data-selectable-paragraph="">Another 50 milliseconds! Piglet, it’s as if you’re starting to get into shape!</p><p id="0cd7" data-selectable-paragraph="">What other exercises might help our piglet out? The greatest time savings were achieved thanks to superinstructions. They reduce instances of interaction with the main loop and allow you to cut out associated overheads.</p><p id="0cc5" data-selectable-paragraph="">The central switch is the main problem area for any processor that’s executing instructions out of order. Contemporary branch predictors have learnt how to predict even such complex indirect transitions and are now not bad at doing so, but spreading branch points throughout the code could help the processor to transition quickly from one instruction to another.</p><p id="c55b" data-selectable-paragraph="">Another problem is the byte-by-byte reading of opcodes for instructions and direct arguments from the bytecode. Hardware machines operate using a 64-bit machine word and don’t like it very much when the code operates using lower values.</p><p id="f73b" data-selectable-paragraph="">Compilers often operate using<a href="https://en.wikipedia.org/wiki/Basic_block" target="_blank" rel="noopener"> basic blocks (BB)</a>, that is to say sequences of instructions without internal branches or labels. A basic block starts either from the start of a program or from a label, and finishes at the end of a program, a conditional branch or a direct jump to a label beginning the next basic block.</p><p id="93ab" data-selectable-paragraph="">There are lots of advantages to working with basic blocks, but our pig is specifically interested in its key distinguishing feature, namely that instructions within the scope of a basic block are carried out in sequence. It would be great to somehow highlight these basic blocks and perform instructions in them, not losing time on interaction with the main loop.</p><p id="9f3e" data-selectable-paragraph="">In our case we can even broaden out the definition of the basic block to include a full trace. A trace, in terms of the Pig Machine, would include all basic blocks connected in sequence (through unconditional jumps).</p><p id="25eb" data-selectable-paragraph="">Besides the sequential execution of instructions, it also wouldn’t be a bad idea in advance to decode direct arguments for instructions.</p><p id="00b8" data-selectable-paragraph="">This all sounds rather scary and is reminiscent of dynamic compilation, the use of which we decided against. This even made our ‘pig’ begin to doubt its abilities somewhat, but in practice it didn’t all turn so bad.</p><p id="d15c" data-selectable-paragraph="">Let’s begin by thinking how we might represent an instruction included in the trace:</p><pre><span id="6f37" data-selectable-paragraph="">struct scode {<br>    uint64_t arg;<br>    trace_op_handler *handler;<br>};</span></pre><p id="78ac" data-selectable-paragraph="">Here arg is a previously decoded instruction argument, and handler a pointer to a function which executes the instruction logic.</p><p id="6736" data-selectable-paragraph="">The representation for each trace now looks like this:</p><pre><span id="d668" data-selectable-paragraph="">typedef scode trace[MAX_TRACE_LEN];</span></pre><p id="beff" data-selectable-paragraph="">So a trace is a sequence of s-codes of limited length. The cache itself of the trace, inside the virtual machine, looks like this:</p><pre><span id="ef61" data-selectable-paragraph="">trace trace_cache[MAX_CODE_LEN];</span></pre><p id="ca67" data-selectable-paragraph="">This is simply an array of traces of a length not exceeding the permissible length for the bytecode. This is a ‘lazy’ solution; in the interests of saving memory it makes sense to use a hash table.</p><p id="18f7" data-selectable-paragraph="">When the interpreter starts working, the first handler for each of the traces will compile itself:</p><pre><span id="3dbb" data-selectable-paragraph="">for (size_t trace_i = 0; trace_i &lt; MAX_CODE_LEN; trace_i++ )<br>    vm_trace.trace_cache[trace_i][0].handler =<br>    trace_compile_handler;</span></pre><p id="cc18" data-selectable-paragraph="">The main interpreter loop now looks like this:</p><pre><span id="912c" data-selectable-paragraph="">while(vm_trace.is_running) {<br>   scode *code = &amp;vm_trace.trace_cache[vm_trace.pc][0];<br>   code-&gt;handler(code);<br>}</span></pre><p id="05ce" data-selectable-paragraph="">The handler that compiles the trace is slightly more complicated and, apart from forming the trace, with the current instruction as its starting point, it does the following:</p><pre><span id="3f96" data-selectable-paragraph="">static void trace_compile_handler(scode *trace_head)<br>{<br>    scode *trace_tail = trace_head;<br>   /*<br>     * Trace building here<br>     */<br>   /* now, run the chain that has a trace_compile_handler replaced with proper instruction handler<br>     * function pointer */<br>    trace_head-&gt;handler(trace_head);<br>}</span></pre><p id="2e8c" data-selectable-paragraph="">Normal instruction handler:</p><pre><span id="4abc" data-selectable-paragraph="">static void op_add_handler(scode *code)<br>{<br>    uint64_t arg_right = POP();<br>    *TOS_PTR() += arg_right;</span><span id="cf95" data-selectable-paragraph="">/*<br>    * Call the next trace handler<br>    * */</span><span id="a4a7" data-selectable-paragraph="">/* scodes are located in an array so we can use pointer arithmetic to get the next handler */<br>    code++;<br>    code-&gt;handler(code);<br>}</span></pre><p id="997b" data-selectable-paragraph="">The work of each trace is terminated by a handler which doesn’t make any calls in the tail of the function:</p><pre><span id="7558" data-selectable-paragraph="">static void op_done_handler(scode *code)<br>{<br>    (void) code;</span><span id="cdf5" data-selectable-paragraph="">vm_trace.is_running = false;<br>    vm_trace.error = SUCCESS;<br>}</span></pre><p id="93e8" data-selectable-paragraph="">All of this is, of course, more complicated than adding superinstructions, but let’s see if it gives us anything:</p><pre><span id="641b" data-selectable-paragraph="">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null<br>PROFILE: switch code finished took 427ms<br>PROFILE: switch code (no range check) finished took 395ms<br>PROFILE: trace code finished took 367ms</span></pre><p id="eb71" data-selectable-paragraph="">Hurray, another 30 milliseconds!</p><p id="4917" data-selectable-paragraph="">How is that? Instead of simple transitions following labels we are creating a chain of calls to handlers of instructions, investing time on calls and on sending arguments, but our ‘piglet’ can still run along traces faster than a simple switch with its labels.</p><p id="7808" data-selectable-paragraph="">This improvement is achieved thanks to three factors:</p><ol><li id="8267" data-selectable-paragraph="">It is easy to predict branches which are spread out in various areas of the code.</li><li id="05c3" data-selectable-paragraph="">Handler arguments are always pre-decoded into a whole machine word and this is only done once, namely when compiling the trace.</li><li id="3ffc" data-selectable-paragraph="">The compiler turns the actual chains of functions into a single call to the first function/handler — which is possible thanks to optimisation of the<a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener"> tail call</a>.</li></ol><p id="c799" data-selectable-paragraph="">Before drawing conclusions from our training sessions, along with the pig we decided to try out another ancient technique for interpreting programs, namely threaded code.</p><p id="7da9" data-selectable-paragraph="">Any pig interested in the history of interpreters will have heard of <em>threaded code</em>. This technique has many variations, but they all come down to, instead of an array of opcodes, proceeding along an array, for example, of pointers for functions or labels, transitioning between them directly, without intervening opcode-based dispath.</p><p id="3659" data-selectable-paragraph="">Function calls are expensive and don’t make particular sense in our day and age; for the most part other versions of threaded code cannot be implemented within the confines of standard C. Even the technique discussed below uses a widespread, but, nevertheless, non-standard C extension, namely pointers to labels.</p><p id="22c7" data-selectable-paragraph="">The version of threaded code which I have chosen for our ‘piggish’ purposes, namely token threaded code, saves on bytecode, but, before interpretation starts, we create a table showing opcodes for instructions and which instruction handler labels they map to:</p><pre><span id="46a9" data-selectable-paragraph="">const void *labels[] = {<br>    [OP_PUSHI] = &amp;&amp;op_pushi,<br>    [OP_LOADI] = &amp;&amp;op_loadi,<br>    [OP_LOADADDI] = &amp;&amp;op_loadaddi,<br>    [OP_STORE] = &amp;&amp;op_store,<br>    [OP_STOREI] = &amp;&amp;op_storei,<br>    [OP_LOAD] = &amp;&amp;op_load,<br>    [OP_DUP] = &amp;&amp;op_dup,<br>    [OP_DISCARD] = &amp;&amp;op_discard,<br>    [OP_ADD] = &amp;&amp;op_add,<br>    [OP_ADDI] = &amp;&amp;op_addi,<br>    [OP_SUB] = &amp;&amp;op_sub,<br>    [OP_DIV] = &amp;&amp;op_div,<br>    [OP_MUL] = &amp;&amp;op_mul,<br>    [OP_JUMP] = &amp;&amp;op_jump,<br>    [OP_JUMP_IF_TRUE] = &amp;&amp;op_jump_if_true,<br>    [OP_JUMP_IF_FALSE] = &amp;&amp;op_jump_if_false,<br>    [OP_EQUAL] = &amp;&amp;op_equal,<br>    [OP_LESS] = &amp;&amp;op_less,<br>    [OP_LESS_OR_EQUAL] = &amp;&amp;op_less_or_equal,<br>    [OP_GREATER] = &amp;&amp;op_greater,<br>    [OP_GREATER_OR_EQUAL] = &amp;&amp;op_greater_or_equal,<br>    [OP_GREATER_OR_EQUALI] = &amp;&amp;op_greater_or_equali,<br>    [OP_POP_RES] = &amp;&amp;op_pop_res,<br>    [OP_DONE] = &amp;&amp;op_done,<br>    [OP_PRINT] = &amp;&amp;op_print,<br>    [OP_ABORT] = &amp;&amp;op_abort,<br>};</span></pre><p id="04b2" data-selectable-paragraph="">Notice the symbols &amp;&amp;: these are pointers to labels with bodies of instructions, the very same non-standard GCC extension.</p><p id="14f8" data-selectable-paragraph="">To start executing the code it is sufficient to jump, following the pointer, to a label corresponding to the program’s first opcode:</p><pre><span id="3a03" data-selectable-paragraph="">goto *labels[NEXT_OP()];</span></pre><p id="ae21" data-selectable-paragraph="">There is no loop here and nor will there be one: each instruction jumps to the next handler by itself:</p><pre><span id="710c" data-selectable-paragraph="">op_pushi: {<br>        /* get the argument, push it onto stack */<br>        uint16_t arg = NEXT_ARG();<br>        PUSH(arg);<br>        /* jump to the next instruction*/<br>        goto *labels[NEXT_OP()];<br>    }</span></pre><p id="ba8f" data-selectable-paragraph="">The absence of a ‘switch’ spreads the branching points across the bodies of instructions, which, in theory, should assist the branch predictor when performing instructions out-of-order. We have, as it were, integrated the switch directly into the instructions and have built the transitions table manually.</p><p id="a756" data-selectable-paragraph="">And that is the whole technique. The pig liked it because it was simple. Let’s see how it works out in practice:</p><pre><span id="6b94" data-selectable-paragraph="">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null<br>PROFILE: switch code finished took 443ms<br>PROFILE: switch code (no range check) finished took 389ms<br>PROFILE: threaded code finished took 477ms<br>PROFILE: trace code finished took 364ms</span></pre><p id="9873" data-selectable-paragraph="">Whoops! This is the slowest of all our techniques! How did that happen? Let’s recall the tests, excluding all GCC optimisations:</p><pre><span id="fe95" data-selectable-paragraph="">&gt; ./pigletvm runtimes test/sieve.bin 100 &gt; /dev/null<br>PROFILE: switch code finished took 969ms<br>PROFILE: switch code (no range check) finished took 940ms<br>PROFILE: threaded code finished took 824ms<br>PROFILE: trace code finished took 1169ms</span></pre><p id="9a0b" data-selectable-paragraph="">Here threaded coded comes out looking better.</p><p id="8430" data-selectable-paragraph="">Here there are three factors at play:</p><ol><li id="7e81" data-selectable-paragraph="">The optimising compiler itself is no worse at building a transitions table than our manual table with labels.</li><li id="d587" data-selectable-paragraph="">Contemporary compilers are excellent at cutting out unnecessary function calls.</li><li id="b45d" data-selectable-paragraph="">Going back about as far as the Haswell generation of processors, Intel branch predictors learnt how to precisely predict the transitions via a single branching point.</li></ol><p id="724f" data-selectable-paragraph="">If memory serves, in some cases there is code that still uses this technique, for example, in the case of the Python VM interpreter, but, to be honest, in our day and age it is already rather outdated.</p><p id="ac12" data-selectable-paragraph="">Let’s finish off by drawing some conclusions and evaluating the success achieved by our ‘pig’.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/0*NKzofC3_tG7kt6PB?q=20" width="1101" height="793" role="presentation"></p><p><img width="1101" height="793" role="presentation"></p></div></div></div></div></figure><p id="bc73" data-selectable-paragraph="">I am not sure whether our ‘pig’ has actually flown, but it has certainly covered a lot of ground from 550 milliseconds for 100 runs based on the ‘sieve’ to a final time of 370 milliseconds. We used various techniques: superinstructions, cutting out checks for value intervals, a complicated trace mechanism and, finally, even threaded code. In doing so, generally speaking, we acted within the confines of what is implemented in all popular C compilers. Speeding things up by a factor of 1 ½, it seems to me, isn’t a bad result and our pig has earned itself an edible reward.</p><p id="6cb1" data-selectable-paragraph="">One of the implicit conditions which, along with our pig, we set ourselves, was to retain the stack architecture of our Piglet Machine. Migrating to a register architecture, as a rule, reduces the quantity of instructions necessary for the programs’ logic and can help cut out unnecessary interactions with the instruction dispatcher. I think another 10–20% of our time could be saved on that.</p><p id="8dac" data-selectable-paragraph="">Our main condition, the absence of dynamic compilation, isn’t a hard-and-fast rule either. In our day and age it isn’t complicated to pump a pig full of “steroids” in the form of JIT compilation: libraries such as<a href="https://en.wikipedia.org/wiki/GNU_lightning" target="_blank" rel="noopener"> GNU Lightning</a> or<a href="https://www.gnu.org/software/libjit/" target="_blank" rel="noopener"> LibJIT</a> have already done the preliminary dirty work for us. However, this majorly increases the time invested in development and also the overall volume of code, even when making use of libraries.</p><p id="f030" data-selectable-paragraph="">There are, of course, other approaches that our pig hasn’t tried yet, but our journey has to come to an end at some point. If you can think of any interesting ways of getting our pig moving, we’d be glad to give them a try.</p><p id="4d58" data-selectable-paragraph=""><strong>PS </strong>— Special thanks go to my sister, Renata Kazanova, for her initial sketches for the illustrations, and to our illustrator, <a href="https://www.instagram.com/vovazomb/" target="_blank" rel="noopener">Vladimir Shopotov</a> for the final drawings.</p><p id="3625" data-selectable-paragraph=""><strong>PPS</strong> — The original piglet wasn’t very talkative and only understood a primitive assembler. However, by some magic, in the space of just a few hours<a href="https://habr.com/users/true-grue/" target="_blank" rel="noopener"> true-grue</a> created a little language for him called<a href="https://github.com/true-grue/PigletC" target="_blank" rel="noopener"> PigletC</a>. Now he can oink away to his heart’s content!</p><p id="343f" data-selectable-paragraph=""><strong>PPPS</strong> — A reader called<a href="https://habr.com/users/iliazeus/" target="_blank" rel="noopener"> iliazeus</a> has suggested yet another optimisation: caching the top of the stack in a separate variable. Unexpectedly, this change makes threaded code the fastest option of all and the sieve of Eratosthenes works twice as fast as the naïve, original version of the interpreter. I invite all those who may be curious to take a look at the relevant code<a href="https://github.com/vkazanov/bytecode-interpreters-post/blob/master/pigletvm-rcache.c" target="_blank" rel="noopener"> here</a> or benchmarks <a href="https://github.com/vkazanov/bytecode-interpreters-post/#pigletvm-a-trivial-stack-machine" target="_blank" rel="noopener">here</a>.</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>