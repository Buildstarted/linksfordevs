<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Writing A Compiler In Go | Thorsten Ball - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Writing A Compiler In Go | Thorsten Ball - linksfor.dev(s)"/>
    <meta property="article:author" content="About the author"/>
    <meta property="og:description" content="This is the sequel to Writing An Interpreter In Go and this time we&#x27;re writing a compiler and a virtual machine for Monkey. Same codebase, same approach, new goals. Code front and center, step by step explained, fully unit tested and runnable."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://compilerbook.com/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Writing A Compiler In Go | Thorsten Ball</title>
<div class="readable">
        <h1>Writing A Compiler In Go | Thorsten Ball</h1>
            <div>by About the author</div>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 19 Mar 2019</div>
        <p><a href="https://compilerbook.com/">https://compilerbook.com/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
    <div>
      <p><img alt="Cover of Writing A Compiler In Go" src="https://compilerbook.com/images/cover-514e0936.png">
      </p>

      <p>
        This is the sequel to <a href="https://interpreterbook.com/">Writing An Interpreter In Go</a>.
      </p>

      <p>
       We're picking up right where we left off and write <mark>a&nbsp;compiler and a&nbsp;virtual&nbsp;machine</mark> for Monkey.
      </p>

      <p>
        Runnable and tested code front and center, built from the ground up, step by step â€” just like before.
      </p>

      <p>
        But this time, we're going to define bytecode, compile Monkey and execute it in our very own virtual machine.
      </p>

      <p>
        It's the next step in Monkey's evolution.
      </p>
    </div>
  </div><div>
    <div>
      <div>
        <h3 id="its-the-sequel-to--a-programming-language">It's the sequel to â€¦ a programming language</h3>



<p><em>Writing A Compiler In Go</em> is the <strong>sequel</strong> to <a href="https://interpreterbook.com/">Writing An Interpreter In
Go</a>. It starts right where the first one stopped, with a fully-working,
fully-tested Monkey interpreter in hand, connecting both books seamlessly,
ready to build a compiler and a virtual machine for Monkey.</p>

<p>In this book, we use the codebase (included in the book!) from the first part
and extend it. We take the lexer, the parser, the AST, the REPL and the object
system and use them to build a new, faster implementation of Monkey, right next
to the tree-walking evaluator we built in the first book.</p>

<p>The approach is unchanged, too. Working, tested code is the focus, we build
everything from scratch, do baby steps, write tests firsts, use no
3rd-party-libraries and see and understand how all the pieces fit together.</p>

<p>It's a continuation in prose and in code.</p>

<p><strong>Do you need to read the first part before this one?</strong> If you're okay with
treating the code from the first book as a black box, then no. But that's not
what these books are about; they're about <em>opening up black boxes, looking
inside and shining a light</em>. You'll have the best understanding of where we're
going in this book, if you know where we started.</p>


      </div>
      <div>
        <h3 id="learn-how-to-write-a-compiler-and-a-virtual-machine">Learn how to write a compiler and a virtual machine</h3>

<p>Our main goal in in this book is to evolve Monkey. We change its
architecture and turn it into <strong>a bytecode compiler and virtual
machine</strong>.</p>

<p>We'll take the lexer, the parser, the AST and the object system we
wrote in the first book and use them to build our own Monkey compiler
and virtual machine â€¦ <strong>from scratch</strong>! We'll build them
side-by-side so that we'll always have a running system we can
steadily evolve.</p>



<p>What we end up with is not only much closer to the programming
languages we use every day, giving us a better understanding of how
they work, but also <strong>3x faster</strong>. And that's without explicitly
aiming for performance.</p>

<div>
  <p><img alt="Preview of Chapter 1" src="https://compilerbook.com/images/sample_thumbnail_2-97fc96b3.png">
    <img alt="Preview of Chapter 09" src="https://compilerbook.com/images/sample_thumbnail_3-98f2197a.png">
  </p>
</div>

<p>Here's what we'll do:</p>

<ul>
  <li>We define our own <strong>bytecode instructions</strong>, specifying their
operands and their encoding. Along the way, we also build a
<strong>mini-disassembler</strong> for them.</li>
  <li>We write a <strong>compiler</strong> that takes in a Monkey AST and turns it into
bytecode by emitting instructions</li>
  <li>At the same time we build a <strong>stack-based virtual machine</strong> that executes the
bytecode in its main loop</li>
</ul>



<p>We'll learn a lot about computers, how they work, what machine code
and opcodes are, what <em>the stack</em> is and how to work with stack
pointers and frame pointers, what it means to define a <strong>calling
convention</strong>, and much more.</p>

<p>We also</p>

<ul>
  <li>build a <strong>symbol table</strong> and a <strong>constant pool</strong></li>
  <li>do <strong>stack arithmetic</strong></li>
  <li>generate <strong>jump instructions</strong></li>
  <li>build <strong>frames</strong> into our VM to execute <strong>functions with local bindings and arguments</strong>!</li>
  <li>add <strong>built-in functions</strong> to the VM</li>
  <li>get <strong>real closures</strong> working in the virtual machine and learn why closure-compilation is so tricky</li>
</ul>

      </div>
      <div>
        <h3 id="the-monkey-programming-language">The Monkey Programming Language</h3>

<p>The implementation of Monkey we build in <em>this book</em> is markedly
different from the tree-walking interpreter we built in <a href="https://interpreterbook.com/">Writing An
Interpreter In Go</a>, but Monkey <strong>stays the same</strong>.</p>

<p>At the end, Monkey will still look and work like this:</p>

<div><pre><code><span>// Integers &amp; arithmetic expressions</span>
<span>let</span> <span>version</span> <span>=</span> <span>1</span> <span>+</span> <span>(</span><span>50</span> <span>/</span> <span>2</span><span>)</span> <span>-</span> <span>(</span><span>8</span> <span>*</span> <span>3</span><span>);</span>

<span>// Strings</span>
<span>let</span> <span>name</span> <span>=</span> <span>"The Monkey programming language"</span><span>;</span>

<span>// Booleans</span>
<span>let</span> <span>isMonkeyFastNow</span> <span>=</span> <span>true</span><span>;</span>

<span>// Arrays &amp; Hashes</span>
<span>let</span> <span>people</span> <span>=</span> <span>[{</span><span>"name"</span><span>:</span> <span>"Anna"</span><span>,</span> <span>"age"</span><span>:</span> <span>24</span><span>},</span> <span>{</span><span>"name"</span><span>:</span> <span>"Bob"</span><span>,</span> <span>"age"</span><span>:</span> <span>99</span><span>}];</span>

<span>// Functions</span>
<span>let</span> <span>getName</span> <span>=</span> <span>fn</span><span>(</span><span>person</span><span>)</span> <span>{</span> <span>person</span><span>[</span><span>"name"</span><span>];</span> <span>};</span>
<span>getName</span><span>(</span><span>people</span><span>[</span><span>0</span><span>]);</span> <span>// =&gt; "Anna"</span>
<span>getName</span><span>(</span><span>people</span><span>[</span><span>1</span><span>]);</span> <span>// =&gt; "Bob"</span>
</code></pre></div>
<p>And it will still support <strong>recursive functions</strong>, <strong>conditionals</strong>, <strong>implicit and explicit returning of values</strong>:</p>

<div><pre><code><span>let</span> <span>fibonacci</span> <span>=</span> <span>fn</span><span>(</span><span>x</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>x</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>0</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>if</span> <span>(</span><span>x</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
      <span>return</span> <span>1</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>fibonacci</span><span>(</span><span>x</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>fibonacci</span><span>(</span><span>x</span> <span>-</span> <span>2</span><span>);</span>
    <span>}</span>
  <span>}</span>
<span>};</span>
</code></pre></div>
<p>The crown-jewel we'll build into our new Monkey implementation are <strong>closures</strong>:</p>

<div><pre><code><span>// `newAdder` returns a closure that makes use of the free variables `a` and `b`:</span>
<span>let</span> <span>newAdder</span> <span>=</span> <span>fn</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>{</span>
    <span>fn</span><span>(</span><span>c</span><span>)</span> <span>{</span> <span>a</span> <span>+</span> <span>b</span> <span>+</span> <span>c</span> <span>};</span>
<span>};</span>
<span>// This constructs a new `adder` function:</span>
<span>let</span> <span>adder</span> <span>=</span> <span>newAdder</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>);</span>

<span>adder</span><span>(</span><span>8</span><span>);</span> <span>// =&gt; 11</span>
</code></pre></div>
<p>Yes, we'll <strong>compile</strong> all of that to <strong>bytecode</strong> and execute it in a
<strong>stack-based virtual machine</strong>. That not only works, but is also tremendous
fun to build.</p>


      </div>
      <div>
        <h3>What readers are saying about this book:</h3>

<blockquote>
  <p>
    "This is a very polished pair of books that together give a steady path to
    follow for learning some of the real techniques that are used to implement
    programming languages. They're both well above average for their depth,
    technical clarity, and accessibility. I've been recommending them to
    everyone I work with who wants to get involved in compilers."
  </p>
  <cite>
    <img src="https://avatars.io/twitter/chrisgseaton/small">
    Chris Seaton (<a href="https://twitter.com/ChrisGSeaton">@ChrisGSeaton</a>)<br>
    Researcher at <a href="https://www.shopify.com/">Shopify</a>, PhD in Ruby, Founder of <a href="https://chrisseaton.com/truffleruby/">Truffle Ruby</a>
  </cite>
</blockquote>

<blockquote>
  <p>
    "Longing for implementing a compiler, but lacking the guidance? Then
    this book is for you. Thorsten offers invaluable mentorship for tackling the multiple
    challenges that arise when writing a single-pass compiler and a virtual
    machine to execute the resulting code, in a pragmatic and test-driven
    approach. After going over this book, you'll certainly feel inspired to go
    further, such as extending the compiler with code transformations of
    your own."
  </p>
  <cite>
    <img src="https://avatars.io/twitter/rnsanchez/small">
    Ricardo Nabinger Sanchez (<a href="https://twitter.com/rnsanchez">@rnsanchez</a>)<br>
    Performance Engineer at <a href="https://www.taghos.com.br/en/">Taghos Tecnologia</a>
  </cite>
</blockquote>

<blockquote>
  <p>
    "Making is understanding. The book carefully teaches us how VM-backed
    interpreters work, while building our own compiler and virtual machine.
    Written in a TDD style, a step-by-step manner and with a humane tone. I've
    enjoyed the wonderful journey!"
  </p>
  <cite>
    <img src="https://avatars.io/twitter/darashi/small">
    Yoji Shidara (<a href="https://twitter.com/darashi">@darashi</a>)<br>
    Programmer, English/Japanese Translator of <a href="https://interpreterbook.com/">Writing An Interpreter In Go</a>
  </cite>
</blockquote>

<blockquote>
  <p>
    "I think that it's one of the best self-published books on the market I've
    ever read, not only in Go area, but whole technical market."
  </p>
  <cite>
    <img src="https://avatars.io/twitter/bartsmykla/small">
    Bart Smykla (<a href="https://twitter.com/bartsmykla">@bartsmykla</a>)<br>
    Open Source engineer at VMWare
  </cite>
</blockquote>

<blockquote>
  <p>
    "Finally, a compiler book that you don't have to fight each and every page
    to get through! Other books burden the reader with so many details and
    subtleties that you'll never make progress. But if you want to make an
    actual compiler, read this. I'll definitely be recommending this to my
    students."
  </p>
  <cite>
    <img src="https://avatars.io/twitter/austinzhenley/small">
    Austin Henley (<a href="https://twitter.com/austinzhenley">@austinzhenley</a>)<br>
    Assistant Professor, Department of Electrical Engineering &amp; Computer Science, University of Tennessee
  </cite>
</blockquote>

<blockquote>
  <p>
    "If you are scared of <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Dragons</a>
    but want to understand how compilers work, this book is for you. Not only
    does it make a daunting subject approachable but it also make it fun and
    enjoyable."
  </p>
  <cite>
    <img src="https://avatars.io/twitter/frje/small">
    Franck JEANNIN (<a href="https://twitter.com/frje">@frje</a>)<br>
    Founder DataNuage
  </cite>
</blockquote>

<blockquote>
  <p>
    "The Monkey books are everything I've ever wanted in programming books, but could never find until now. They are a real labor of love and it shows on every page. The books are fun to read and showcase the Go programming language, but what makes them extraordinary is the fact that they're completely focused on giving the reader an accessible, conceptual understanding of the implementation of interpreters and compilers. It's hard to overstate just how rare yet extremely valuable that focus on understanding is in an educational book."
  </p>
  <cite>
    <img src="https://compilerbook.com/images/headshot_brandon-6cbb6e12.jpg">
    Brandon Ramos<br>
    Product Owner/Developer
  </cite>
</blockquote>

<blockquote>
  <p>
    "Just awesome books. If we had books like this on other subjects (search engines, DB systems), I think developers would have less fear of contributing to large open source projects. - Thank you <a href="https://twitter.com/thorstenball">@thorstenball</a>. This is already paying off in my DB internals course."
  </p>
  <cite>
    <img src="https://avatars.io/twitter/evanxg852000/small">
    Evance Soumaoro (<a href="https://twitter.com/evanxg852000">@evanxg852000</a>)<br>
    Software Engineer | System Programming Enthusiast
  </cite>
</blockquote>

      </div>
      <div>
        <h3>What readers said about the first book:</h3>

<blockquote>
  <p>
  "Compilers was the most surprisingly useful university course I ever took.
  Learning to write a parser and runtime for a toy language helps take away a
  lot of "magic" in various parts of computer science. I recommend any engineer
  who isn't familiar with lexers, parsers, and evaluators to read Thorsten's
  book."
  </p>
  <cite>
    <img src="https://avatars.io/twitter/mitchellh/small">
    Mitchell Hashimoto (<a href="https://twitter.com/mitchellh">@mitchellh</a>)<br>
    Founder of <a href="https://www.hashicorp.com/">HashiCorp</a>
  </cite>
</blockquote>

<blockquote>
  <p>
  "Thorsten took a topic that is usually very dry and CS heavy and made it
  accessible and easy to understand. After reading this book I felt confident
  enough to write <a href="https://github.com/gobuffalo/plush">Plush</a>, the
  templating language Iâ€™ve always wanted in Go! If you have yet to read
  Thorsten's book, I can't recommend it enough. Please go and buy it!"
  </p>
  <cite>
    <img src="https://avatars.io/twitter/markbates/small">
    Mark Bates (<a href="https://twitter.com/markbates">@markbates</a>)<br>
    Creator of <a href="http://gobuffalo.io/">gobuffalo.io</a>
  </cite>
</blockquote>

<blockquote>
  <p>
  "Great book. I loved it because everything is built by hand, so you get to think
  about all the details, and it does so in a gradual way, which is didactic. The
  implementation itself is also nice and simple ðŸ™Œ"
  </p>
  <cite>
    <img src="https://avatars.io/twitter/fxn/small">
    Xavier Noria (<a href="https://twitter.com/fxn">@fxn</a>)<br>
    Everlasting student, Rails Core Team, Ruby Hero, Freelance, Live lover
  </cite>
</blockquote>

<blockquote>
  <p>
  "This book demystifies and makes the topic of interpreters approachable and
  fun. Don't be surprised if you become a better Go programmer after working
  your way through it."
  </p>
  <cite>
    <img src="https://avatars.io/twitter/jboursiquot/small">
    Johnny Boursiquot (<a href="https://twitter.com/jboursiquot">@jboursiquot</a>)<br>
    Go Programmer, <a href="https://twitter.com/BaltimoreGolang">@BaltimoreGolang</a> Organizer,
    <a href="https://twitter.com/GolangBridge">@GolangBridge</a> Core Member
  </cite>
</blockquote>

<blockquote>
  <p>
  "Thorsten's writing style is fun and easy to understand with detailed
  explanations and even better code. Even if you've written an interpreter
  before, this book is a great refresher. I picked it up as <a href="https://www.influxdata.com/blog/rust-can-be-difficult-to-learn-and-frustrating-but-its-also-the-most-exciting-thing-in-software-development-in-a-long-time/">a project to learn
    Rust</a>, translating the example Go code into Rust as I read through. Lexers,
  parsers, and interpreters are such a fundamental part of CS, these skills are
  valuable to more than just programmers implementing programming languages. As
  a project for picking up a new language, this book is perfect because it only
  requires the standard library and has extensive test driven development,
  which means you get quick feedback as you go along. I highly recommend it for
  programmers wanting to learn more about lexers, parsers, and interpreters or
  Go programmers picking up a new language looking for a project to learn
  through."
  </p>
  <cite>
    <img src="https://avatars.io/twitter/pauldix/small">
    Paul Dix (<a href="https://twitter.com/pauldix">@pauldix</a>)<br>
    CTO of <a href="https://www.influxdata.com/">InfluxDB</a>
  </cite>
</blockquote>

      </div>
    </div>
  </div><div>
    <div>
      <div>
        

<p><img src="https://compilerbook.com/images/author-b16de846.jpg"></p>

<p>Hello there! My name is Thorsten Ball. I'm a writer and programmer
living in Aschaffenburg, Germany. In my professional life as a
software developer, I build web applications and platforms. I have
deployed Ruby, JavaScript, Go and C code to production systems.</p>

<p>In my spare time, though, I like to do what I call <em>recreational
programming</em>, where I dig deep into various topics and their
codebases, taking them apart, recreating them in my own code, trying
to peel away layers of what seems like magic, hoping to come out the
other end with a better understanding of what it is that I do when I
program.</p>

<p>For the last few years, the two topics that kept my attention are
systems programming and programming languages: interpreters,
compilers, virtual machines, JIT compilers, assembly language â€“ I
can't get enough of it.</p>

<p>Writing an interpreter from scratch and writing <a href="https://interpreterbook.com/">a book about
that</a> has been one of the most wonderful and satisfying things
I ever did as a programmer. It has been so much fun, in fact, that I
couldn't stop doing it, which is why you're looking at the next book.</p>

<p>You can follow <a href="https://twitter.com/thorstenball">@thorstenball on Twitter</a> to know what I'm up
to. If you want to know more about me, visit <a href="http://thorstenball.com/">my blog and
website</a> or take a look at my <a href="https://github.com/mrnugget">GitHub profile</a>.</p>


      </div>
    </div>
  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>