<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How CDNs Generate Certificates - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="How CDNs Generate Certificates - linksfor.dev(s)"/>
    <meta property="og:description" content="Say Hi to Thomas. Thomas&#x27;s first weeks at Fly have been hectic, but he&#x27;s been taking notes, copious notes that can teach you all about the wild world of certificate infrastructure. Read on to discover more..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://fly.io/blog/how-cdns-generate-certificates/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - How CDNs Generate Certificates</title>
<div class="readable">
        <h1>How CDNs Generate Certificates</h1>
            <div>Reading time: 12-16 minutes</div>
        <div>Posted here: 01 Jul 2020</div>
        <p><a href="https://fly.io/blog/how-cdns-generate-certificates/">https://fly.io/blog/how-cdns-generate-certificates/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><p>It’s been a hectic first couple of weeks at Fly, and I’m writing things up as I go along, because if I have to learn, so do you. This is going to be a bit of a meander; you’ll have to deal.</p> <p>Let’s start with “<a href="https://news.ycombinator.com/item?id=22616857">what’s Fly?</a>” Briefly: Fly is a content delivery network for Docker containers. Applications hosted on Fly are fast because they’re running on machines close to users. To do that, we run bare metal servers in a bunch of cities and host containers on them in <a href="https://firecracker-microvm.github.io/">Firecracker VMs</a>. We proxy traffic from edge servers to containers through a global <a href="https://www.wireguard.com/">WireGuard</a> mesh. It’s much easier to play with than ECS or K8s is, so <a href="https://fly.io/">signing up for a free account</a> is probably the best way to get a feel for it, and a pleasant way to burn 5-10 minutes.</p> <p>Obviously, to do stuff like this, you need to generate certificates. The reasonable way to do that in 2020 is with LetsEncrypt. We do that for our users automatically, but “it just works” makes for a pretty boring writeup, so let’s see how complicated and meandering I can make this.</p> <p>It's time to talk about certificate infrastructure.</p> <h3 id="acme"><a aria-hidden="" href="#acme"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><g buffered-rendering="static"><path vector-effect="non-scaling-stroke" d="M12.354 16.596l-3.183 3.182c-1.171 1.172-3.071 1.172-4.243 0l-.707-.707c-1.17-1.171-1.17-3.071.001-4.241l4.597-4.597c1.172-1.172 3.071-1.172 4.243 0l.707.708M11.647 7.403l3.182-3.181c1.172-1.171 3.07-1.171 4.242 0l.707.707c1.172 1.171 1.172 3.071 0 4.242l-4.596 4.596c-1.172 1.173-3.071 1.173-4.242 0"></path></g></svg></a>ACME</h3><p>Rather than verifying information from <a href="https://www.dnb.com/">“Qualified Independent Information Sources”</a>, LetsEncrypt does domain-validated certificates, based simply on proof of ownership of a domain, and is driven by a protocol called ACME. ACME is really simple. It’s been <a href="https://github.com/acmesh-official/acme.sh/blob/master/acme.sh">implemented in almost pure Bourne shell</a>. The most complicated thing about it is JWS signatures, which are awful, but at least standardized. The ACME protocol is itself done over normal HTTP requests; the flow is roughly:</p> <ol> <li>You make an account and associate an ECDSA/EdDSA key with it, which subsequently authenticates all your requests. </li><li>You then post an “order” for a certificate, specifying the DNS names you need it for. You’re given “authorization” and “finalization” URLs in return. </li><li>You retrieve the authorizations and select challenges to prove you own the domains. </li><li>You set up the challenges on your own side, and then poll a status URL to verify that the challenges have completed. </li><li>You post the CSR for your certificate to the “finalization” URL. </li></ol> <p>ACME challenges are intended to verify your ownership of a domain. There are three of them (four, if you count preauthorization, which LetsEncrypt doesn’t do); originally, they were:</p> <ol> <li><p><code>tls-http-01</code>, in which you’re given a token to put on your server, under /.well-known/acme-challenge, and serve to LetsEncrypt’s client on 80/tcp. This is simple to describe and implement, but requires you to respond to HTTP requests on 80/tcp, which lots of people (sensibly) don’t want to do.</p> </li><li><p><code>tls-dns-01</code>, in which you’re given a token to put in a TXT record in your DNS zone. This directly proves control over a domain, but it can be hard for operators to do. In particular, especially in larger organizations, the people who need certificates are not necessarily given access to DNS configuration.</p> </li><li><p><code>tns-sni-01</code>, in which you’re given a token to embed in the SAN of a certificate you serve to TLS clients who request it through TLS SNI, which is TLS’s equivalent of the HTTP “Host” header. This is more complicated to implement, but is the most seamless of the challenges: all you need to do it is to run the TLS server you were going to run anyways.</p> </li></ol> <h3 id="the-story-of-tls-sni-01"><a aria-hidden="" href="#the-story-of-tls-sni-01"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><g buffered-rendering="static"><path vector-effect="non-scaling-stroke" d="M12.354 16.596l-3.183 3.182c-1.171 1.172-3.071 1.172-4.243 0l-.707-.707c-1.17-1.171-1.17-3.071.001-4.241l4.597-4.597c1.172-1.172 3.071-1.172 4.243 0l.707.708M11.647 7.403l3.182-3.181c1.172-1.171 3.07-1.171 4.242 0l.707.707c1.172 1.171 1.172 3.071 0 4.242l-4.596 4.596c-1.172 1.173-3.071 1.173-4.242 0"></path></g></svg></a>The Story Of tls-sni-01</h3><p>But <code>tls-sni-01</code> no longer exists, because <a href="https://labs.detectify.com/2018/01/12/how-i-exploited-acme-tls-sni-01-issuing-lets-encrypt-ssl-certs-for-any-domain-using-shared-hosting/">it’s insecure</a>. The problem with SNI challenges is shared hosting.</p> <p>Because IP addresses are scarce, many hosting providers arrange for customers to share IP addresses. As requests arrive for customers, they’re routed based on SNI.</p> <p>In the same way that you can configure a local nginx to respond to any Host header without breaking the Internet, hosting providers routinely allow people to “claim” arbitrary hostnames on their platforms. This ostensibly doesn’t matter, because without control of the DNS, you can’t get people to talk to your claimed hostname.</p> <p>Similarly, hosting providers will often let you provide your own TLS certificates.</p> <p>You may see where this is going already. Here’s what LetsEncrypt did to verify domain ownership using SNI:</p> <ol> <li>It generated a token for you to put in a self-signed certificate, in the form of an “.acme.invalid” hostname. </li><li>It resolved the hostname you were generating a certificate for in the DNS and connected to it. </li><li>It asked for the token via TLS SNI specifying the “.acme.invalid” name. </li><li>It read the certificate generated and checked to make sure the token was present. </li></ol> <p>If a hosting provider let you claim names in the “.invalid” TLD, and upload your own certificate for them, you could get a certificate issued for all the customers hosted on your IP. Heroku let you do this, as did AWS Cloudfront, and who knows who else.</p> <p>LetsEncrypt quickly <a href="https://community.letsencrypt.org/t/important-what-you-need-to-know-about-tls-sni-validation-issues/50811">took the SNI challenges</a> down while hosting providers deployed fixes. Ultimately, SNI was so widely used this way that CAs concluded SNI was fundamentally unsafe to use as a challenge, and the ACME SNI challenge was deprecated, and finally removed last year.</p> <p>This attack is an instance of a broader attack class called “subdomain takeover”, which is a mainstay among bug bounty hunters. <a href="https://www.hackerone.com/blog/Guide-Subdomain-Takeovers">HackerOne will tell you all about it</a>, if you want to make $50 or so in an evening.</p> <p>So, any time you’re hosting content for customer domains, you have the problem of what happens when the customer stops using your service. As you might expect, lots of times you’ll forget to stop forwarding DNS to old expired services. But your account on those services has lapsed, and that usually means that other people can claim the same names you were using. Since you’re still directing traffic to the service, the new claimant has now hijacked one of your subdomains.</p> <p>Which is bad for all kinds of reasons; it allows you to steal cookies, violate CORS, bypass CSP; it even impacts OAuth2.</p> <p>Fly mitigates this problem for ALPN challenges by not reusing IP addresses. Every application gets a unique, routable IPv6 address, and we won’t attempt Lets Encrypt validation unless the target hostname resolves via CNAME to that IPv6 address. (We do something similar for DNS challenges).</p> <h3 id="alpn"><a aria-hidden="" href="#alpn"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><g buffered-rendering="static"><path vector-effect="non-scaling-stroke" d="M12.354 16.596l-3.183 3.182c-1.171 1.172-3.071 1.172-4.243 0l-.707-.707c-1.17-1.171-1.17-3.071.001-4.241l4.597-4.597c1.172-1.172 3.071-1.172 4.243 0l.707.708M11.647 7.403l3.182-3.181c1.172-1.171 3.07-1.171 4.242 0l.707.707c1.172 1.171 1.172 3.071 0 4.242l-4.596 4.596c-1.172 1.173-3.071 1.173-4.242 0"></path></g></svg></a>ALPN</h3><p>Recall the virtue of the <code>tls-sni-01</code> challenge: it doesn’t require you to have access to your DNS configuration, nor do you need to open 80/tcp. You want a challenge that works this way. And there is one: the new third ACME challenge, <code>tls-alpn-01</code>.</p> <p>To grok <code>tls-alpn-01</code>, you’ll of course need to know what ALPN is. It’s an easy concept: Imagine TLS was a transport protocol in its own right, alongside TCP and UDP; ALPN would be its port number. I mean, they’re strings, not numbers, but same idea.</p> <p>Why does TLS need such a thing? Most things that use TLS have their own TCP ports already. The answer is, of course, <a href="https://daniel.haxx.se/http2/">HTTP/2</a>. HTTP/2 isn’t wire-compatible with HTTP/1 (it’s a binary protocol optimized for pipelining). But it can’t have its own TCP port, because if it did, nobody would be able to speak it: huge chunks of the Internet are locked down to ports 80 and 443.</p> <p>(We’re not, at Fly, by the way; you can run any TCP service you want here. But I digress from my digressions).</p> <p>To solve this problem, when Google was designing SPDY (HTTP/2’s predecessor), they came up with NPN, <a href="https://tools.ietf.org/id/draft-agl-tls-nextprotoneg-03.html">“Next Protocol Negotiation”.</a> The way NPN worked was:</p> <ol> <li>A TLS client added an NPN extension to their ClientHello, the message TLS clients send to open up a connection. </li><li>A supportive TLS server would respond with a ServerHello that had an NPN extension populated with the protocols it supported. </li><li>A key exchange having been completed, both sides of the connection would switch on encryption. </li><li>The TLS client would send an encrypted NextProtocol message that chose a next protocol (which technically may or may not have been one listed by the server, if both sides were trying to be sneaky about things). </li></ol> <p>By doing this, Chrome could opt into SPDY when talking to Google servers without burning a round trip for the negotiation.</p> <p>When SPDY turned into HTTP/2, something like NPN needed to get standardized, too. But the IETF tls-wg wasn’t a fan of NPN; in particular, it reversed the normal order of TLS negotiation, where the client proposes and the server chooses. So the IETF came up with ALPN, <a href="https://tools.ietf.org/html/rfc7301">Application Layer Protocol Negotiation</a>. ALPN works like this:</p> <ol> <li>A TLS client adds an ALPN extension to its ClientHello indicating all the protocols it supports. </li><li>A TLS server indicates which protocol it selected in the ALPN extension in its ServerHello. </li><li>That’s pretty much it. </li></ol> <p>There’s a clear privacy implication here, right? Because the ALPN protocol you might be asking for is “tor”. The IETF ruins everything. And that’s true, but it’s complicated.</p> <p>First, the security offered by the encrypted NextProtocol frame was a little sketchy. Here’s an <a href="https://mailarchive.ietf.org/arch/msg/tls/ZptP2xSKLPOgJElh5TEhNbolV8c/">outline of an attack:</a></p> <ol> <li>Alice connects to Bob, and Mallory really wants to know what protocol Alice is going to ask for. </li><li>Mallory MITMs the connection and downgrades its security. Remember that NPN is running /inside/ the handshake, not /after/ it, when the “Finished” message has cryptographically authenticated the handshake. </li><li>Alice sends her NextProtocol frame to Mallory on the downgraded connection. </li><li>Mallory drops the connection and reads the NextProtocol. </li><li>Alice, meanwhile, re-connects, because that’s what you do, and repeats the exact same process with Bob directly, sending the same NextProtocol. </li></ol> <p>In practice, with Firefox, you could at one point do this <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=925791">simply by sending a bogus certificate</a>; Firefox would complete the handshake, NPN included, even if the certificate didn’t validate.</p> <p>(For what it’s worth, some of the privacy issues here got mooted in <a href="https://crypto.iacr.org/2018/affevents/cwtls/medias/Eric_Rescorla.pdf">TLS 1.3</a>).</p> <h3 id="the-jpeg-cat-extension"><a aria-hidden="" href="#the-jpeg-cat-extension"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><g buffered-rendering="static"><path vector-effect="non-scaling-stroke" d="M12.354 16.596l-3.183 3.182c-1.171 1.172-3.071 1.172-4.243 0l-.707-.707c-1.17-1.171-1.17-3.071.001-4.241l4.597-4.597c1.172-1.172 3.071-1.172 4.243 0l.707.708M11.647 7.403l3.182-3.181c1.172-1.171 3.07-1.171 4.242 0l.707.707c1.172 1.171 1.172 3.071 0 4.242l-4.596 4.596c-1.172 1.173-3.071 1.173-4.242 0"></path></g></svg></a>The JPEG Cat Extension</h3><p>Additionally, while privacy was doubtlessly on Adam Langley’s mind when he wrote the NPN spec, the more important problem was probably middlebox compatibility.</p> <p>The way middleboxes work is, enterprises buy them. They’re quite expensive, and enterprises buy big ghastly bunches of them in one go, so vendors work really hard to win those deals. And one straightforward way to win a bakeoff is to come to it with more features than your competitors. Here’s a feature: “filter connections based on what application protocol the client selects”. The Chrome team, presumably seeing that dumb feature a mile away, took it off the table by encrypting NPN selections.</p> <p>(This sounds paranoid, but only if you’ve never worked on real-world TLS. In the NPN vs. ALPN tls-wg thread, AGL cited an ISP they found in the UK that took it upon themselves to block all the ECDHE ciphersuites. Why? Who knows? People do stuff like this.)</p> <p>Ultimately, ALPN beat out NPN in the tls-wg. But, just as they were wrapping up the standard, Brian Smith at Mozilla (and author of Rust’s ring crypto library) <a href="https://mailarchive.ietf.org/arch/msg/tls/lAqVI-bqWp_KltFHK2OoSflRvL8/">threw a wrench in the works</a>.</p> <p>It had been Mozilla’s experience that, in some cases, middleboxes would hang when they got a ClientHello that was more than 255 bytes long. Hanging is very bad, because Mozilla needed timeout logic to detect it and try a simpler handshake, but that logic would also fire for people on crappy Internet connections, and had the effect of preventing those people from using modern TLS at all.</p> <p>Miraculously, a day later, Xiaoyong Wu at F5 <a href="https://mailarchive.ietf.org/arch/msg/tls/8wXwhM1d5WSmROHFSgrTyFmWN2o/">jumped onto the thread</a> to explain that older F5 software confused 256 byte ClientHello frames with TLSv2. TLS frame lengths are 2 bytes wide; once the ClientHello ticks past 255 bytes, the high length byte becomes 01h. That byte occupies the same point in the frame as the message type in SSLv2. To the F5, the frame could be a long-ish ClientHello… or a very long SSLV2<em>MT</em>CLIENTHELLO, which was also 01h. The F5 chose SSLv2.</p> <p>The fix? Send /more/ bytes! At 512 bytes, the high length byte is no longer 01h. And thus was born the “jpeg-of-a-cat” extension, which AGL took the fun out of by renaming it <a href="https://tools.ietf.org/html/rfc7685">“the TLS ClientHello Padding Extension”.</a></p> <h3 id="back-to-acme"><a aria-hidden="" href="#back-to-acme"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><g buffered-rendering="static"><path vector-effect="non-scaling-stroke" d="M12.354 16.596l-3.183 3.182c-1.171 1.172-3.071 1.172-4.243 0l-.707-.707c-1.17-1.171-1.17-3.071.001-4.241l4.597-4.597c1.172-1.172 3.071-1.172 4.243 0l.707.708M11.647 7.403l3.182-3.181c1.172-1.171 3.07-1.171 4.242 0l.707.707c1.172 1.171 1.172 3.071 0 4.242l-4.596 4.596c-1.172 1.173-3.071 1.173-4.242 0"></path></g></svg></a>Back To ACME</h3><p>This is a little anti-climactic, but we’ve come all this way, so you might as well understand how Fly (and other CDNs, and things like Caddy) generates certificates with ACME:</p> <ol> <li>We request a <code>tls-alpn-01</code> challenge from LetsEncrypt for your hostname, using our ACME account. </li><li>LetsEncrypt gives us a token, for which we generate a self-signed certificate with the token embedded, that we load into our distributed certificate storage. </li><li>We say (in ACME) “go ahead”, and LetsEncrypt looks up the hostname we’re serving, connects to it, and sends a ClientHello with “acme-tls/1” set as the ALPN protocol. </li><li>Our Rust proxy catches the ACME ALPN case, retrieves the challenge certificate, and feeds it to LetsEncrypt. </li><li>LetsEncrypt drops the connection, sets the challenge to completed, and allows us to complete the certificate generation. </li></ol> <p>The ALPN challenge is more explicit than the SNI challenge; we had to specifically set up a subservice to complete ALPN challenges for customers, rather than doing it sort of implicitly based on our native SNI handling. (We wouldn’t have had the problem anyways based on how our certificate handling works, but this is the logic behind why ALPN is OK and SNI isn’t).</p> <p>This process is pretty much seamless; all you have to do is say “yeah, I want a TLS certificate for my app’s custom domain”. It only works with individual hostnames, though, which may be fine, but if it isn’t, you can do a DNS challenge with us to generate a wildcard certificate.</p> </section></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>