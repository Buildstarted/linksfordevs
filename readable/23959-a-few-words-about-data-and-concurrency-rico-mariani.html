<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A few words about data and concurrency - Rico Mariani -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>A few words about data and concurrency - Rico Mariani</h1><div><div class="ac ae af ag ah cz aj ak"><p id="46e9" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">“I need an atomic integer”</p><p id="9f9b" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">Oh Lord, here we go.</p><p id="226a" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">I find it completely astonishing observing what people think they need with regard to concurrent constructs and especially data sharing. It’s super hard to even understand all the considerations, even for experts, which is why not sharing data between threads at all has to be the first line of defense.</p><p id="b364" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">But ok, you want to go there, I strongly recommend you don’t, but at least let me tell you what some of the concerns are and maybe I will scare you out of it. That would be good.</p><p id="1917" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">This is a good place to remind everyone that what I’m going to write is only approximately correct, mainly in the interest of brevity.</p><p id="cf92" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu"><strong class="fv gh">Primitives are already atomic for simple read/write</strong></p><p id="4c4e" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">In virtually all the cases you will encounter on any modern processor every primitive type (e.g. int) is an atomic read or write. It writes or it doesn’t. Most times when people are talking about atomic primitives they actually aren’t referring to atomicity at all, but maybe ordering or observability.</p><p id="b682" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">Why call it this at all? Well, maybe because of some of the elementary operations you can expect on an “atomic” type. Even if integer storage is atomic, incrementing it might not be, it’s a read-modify-write operation. So maybe you’d like to have something that you can ++ that has an atomic++ operator on it. You might call that an atomic int right? So I guess the question is, what are the atomic operations you want? How are they offered? Do you want/need a datatype for that?</p><p id="e1ce" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">There are some notable exceptions to atomicity. Generally it requires natural alignment of the data type in question (else it might take two writes to update it) and it must be a processor supported type (e.g. some 32 bit systems have C compilers that offer 64 bit integers, but they aren’t a primitive type as far as the processor is concerned).</p><p id="cddc" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu"><strong class="fv gh">Can’t I just fix everything by sprinkling volatile everywhere?</strong></p><p id="e1df" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">Well, no, actually most of the time people don’t even know what it does and it most likely won’t help you by itself. Briefly, the volatile keyword tells the compiler that the value in question might change without the code seeming to do anything. Classically this was because you were storing something like the address of a memory mapped timer device in a variable.</p><pre class="gi gj gk gl gm gn go gp"><span id="633b" class="gq gr dc bk gs b en gt gu r gv">int *timer = (int *)0xF0001122;</span><span id="353a" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">int time1 = *timer;</span><span id="cf24" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">...</span><span id="246f" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">int time2 = *timer;</span></pre><p id="c4f1" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">A clever compiler might remove the second timer read noting that you read the same address and nothing modified it in between. The following was designed to prevent just such a thing.</p><pre class="gi gj gk gl gm gn go gp"><span id="417c" class="gq gr dc bk gs b en gt gu r gv">volatile int *timer = (int *)0xF0001122;</span><span id="4600" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">int time1 = *timer;</span><span id="9357" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">...</span><span id="8e2f" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">int time2 = *timer;</span></pre><p id="2cbb" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">When volatile is used it tells the compiler that it may not elide any reads/writes from/to the pointer. It must emit exactly one read/write for each appearance in the code and it may not reorder them relative to other volatile operations. Note the consequences of getting this wrong can be very painful. This loop for instance could be quite bad if the timer wasn’t read on every iteration:</p><pre class="gi gj gk gl gm gn go gp"><span id="3a11" class="gq gr dc bk gs b en gt gu r gv">int *timer = (int *)0xF0001122;</span><span id="8405" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">*timer = 0;</span><span id="1589" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">while (*timer &lt; 1000) ;  // ultra dumb example (might spin forever)</span></pre><p id="da7b" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">Concurrent programming can provide similar kinds of “changed when I wasn’t looking” behavior because some other thread might be modifying the timer variable. Some compilers (e.g. MSC) were changed to include certain processor memory fences on volatile reads and writes to help with that. Those things are generally gone now. You’re left with <em class="hb">volatile means read and write exactly the number of times I specify and never skip or reorder a read or write</em>.</p><p id="240d" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu"><strong class="fv gh">Some microprocessor basics</strong></p><p id="2543" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">To understand what’s left, you have to know a few things about modern processors with multiple cores and therefore multiple concurrent threads of execution.</p><ul class=""><li id="635a" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg hc hd he">when you write data, the data might not be written immediately, processors routinely queue up writes and flush them when it’s convenient</li><li id="714c" class="ft fu dc bk fv b fw hf fy hg ga hh gc hi ge hj gg hc hd he">the processor might not flush the writes in the order that you did the writing</li><li id="5f8e" class="ft fu dc bk fv b fw hf fy hg ga hh gc hi ge hj gg hc hd he"><em class="hb">on any given thread of execution</em> if you write data and read it back you will see what you wrote, even if it hasn’t been flushed yet, the processor lies :)</li><li id="d319" class="ft fu dc bk fv b fw hf fy hg ga hh gc hi ge hj gg hc hd he">any other thread looking at the same data might see a previous value because a pending write has not yet retired</li><li id="14b9" class="ft fu dc bk fv b fw hf fy hg ga hh gc hi ge hj gg hc hd he">you might see writes “out of order” because of the processor shenanigans above</li></ul><p id="bb49" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">Sometimes when people want to avoid these problems they say “I need an atomic int” — atomicity probably isn’t what they need at all, it’s some kind of write ordering guarantee.</p><p id="b0ae" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">Let me give you a concrete semi-realistic scenario. Suppose I have a simple linked list and one thread adding items to it periodically. For simplicity items are never removed.</p><p id="d856" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">The writing thread does this:</p><pre class="gi gj gk gl gm gn go gp"><span id="73d8" class="gq gr dc bk gs b en gt gu r gv">Foo *head;</span><span id="69de" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">Foo *foo = malloc(sizeof(Foo));</span><span id="bfa2" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">foo-&gt;data = 1;<br>foo-&gt;next = head;<br>head = foo;<br></span></pre><p id="e5e1" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">You might be forgiven for thinking that this is a safe thing to do. After all, you safely make a nice fresh foo, then you set it up, and finally point the head at it atomically. The other thread will either see the new head or it won’t, and if you don’t care about a little delay all is well. It will see the new head soon enough. Right?</p><p id="f34e" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">Well, no. There are several problems here.</p><p id="9f73" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">There are three writes here, foo-&gt;data, foo-&gt;next, and head. They can be retired in any order. So there is some chance that the reading thread will see the new head before it sees the new foo-&gt;next. That’s bad because there’s junk in your foo object at that point… Similarly foo-&gt;data might still have junk in it.</p><p id="69fc" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">So another service sometimes provided by “atomic” primitives is some kind of write-barrier. Applying this to head would effectively turn the code into something like this:</p><pre class="gi gj gk gl gm gn go gp"><span id="4a28" class="gq gr dc bk gs b en gt gu r gv">foo-&gt;data = 1;<br>foo-&gt;next = head;</span><span id="5f0f" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">_flush_primitive();<br>head = foo;</span></pre><p id="cb8b" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">Which means that if you see the new head you will for sure also see the other writes that preceded it. The symmetric thing can be done on the reader side. This are sometimes called “load acquire” and “store release” semantics (store release shown above.)</p><p id="68d2" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">Importantly, if there is no data ordering necessary, then none of this is needed. For instance if you want to tell a background thread that your user did something and you have no other actions to take no synchronization is needed at all! But this is tricky business. Allow me to illustrate:</p><pre class="gi gj gk gl gm gn go gp"><span id="f6d8" class="gq gr dc bk gs b en gt gu r gv">int user_did_it = 0;</span><span id="4c99" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">// user does something<br>user_did_it = 1;</span><span id="101f" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">// sometime later, on a different thread<br>if (user_did_it) { coolness_ensues(); }</span></pre><p id="3f37" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">That’s fair enough, but this code which is nearly the same won’t work:</p><pre class="gi gj gk gl gm gn go gp"><span id="a0e6" class="gq gr dc bk gs b en gt gu r gv">int user_did_it = 0;</span><span id="e6dc" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">// user does something<br>prepare_for_coolness();<br>user_did_it = 1;</span><span id="8e53" class="gq gr dc bk gs b en gw gx gy gz ha gu r gv">// sometime later, on a different thread<br>if (user_did_it) { coolness_ensues(); }</span></pre><p id="2ab0" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">The problem being that the background thread might not see the prepared coolness before it sees user_did_it. Now you need a fence at least.</p><p id="80c1" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">And I left off all the volatiles that are needed so that the compiler won’t mess it all up.</p><p id="ffb7" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu"><strong class="fv gh">Summary</strong></p><ul class=""><li id="d76d" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg hc hd he">volatile gives you a fighting chance at getting concurrency correct because it prevents the compiler from removing and/or reordering and rewriting your operations.</li><li id="d55f" class="ft fu dc bk fv b fw hf fy hg ga hh gc hi ge hj gg hc hd he">volatile isn’t sufficient because the processor is also reordering writes, so you need some operations that give you more sane memory order guarantees</li><li id="cb67" class="ft fu dc bk fv b fw hf fy hg ga hh gc hi ge hj gg hc hd he">sometimes these are called “atomic” services but they often have very little to do with atomicity (except maybe atomic ++ operators and such)</li></ul><p id="7eec" class="ft fu dc bk fv b fw fx fy fz ga gb gc gd ge gf gg cu">In general this stuff is fantastically hard to get right and so you basically never want to do it. It’s hard enough to get simple critical sections correct…</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>