<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Improving performance of GraalVM native images with profile-guided optimizations - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Improving performance of GraalVM native images with profile-guided optimizations - linksfor.dev(s)"/>
    <meta property="article:author" content="Jaroslav Tulach"/>
    <meta property="og:description" content="Use profile-guided optimizations to significantly improve throughput of the GraalVM native images"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/graalvm/improving-performance-of-graalvm-native-images-with-profile-guided-optimizations-9c431a834edb"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Improving performance of GraalVM native images with profile-guided optimizations</title>
<div class="readable">
        <h1>Improving performance of GraalVM native images with profile-guided optimizations</h1>
            <div>by Jaroslav Tulach</div>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 30 Aug 2019</div>
        <p><a href="https://medium.com/graalvm/improving-performance-of-graalvm-native-images-with-profile-guided-optimizations-9c431a834edb">https://medium.com/graalvm/improving-performance-of-graalvm-native-images-with-profile-guided-optimizations-9c431a834edb</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@jaroslav.tulach?source=post_page-----9c431a834edb----------------------"><img alt="Jaroslav Tulach" src="https://miro.medium.com/fit/c/96/96/0*pbdkvPUNRgzVDdfY" width="48" height="48"></a></p></div></div></div></div><p id="5cc0" data-selectable-paragraph=""><strong>GraalVM Native Image</strong> tool rightfully attracts a lot of attention as it offers significant improvements in terms of startup speed and overall memory usage. However, if you create some benchmarks to evaluate peak performance you may observe that the native image sometimes doesn‚Äôt offer better throughput too.</p><p id="e6a3" data-selectable-paragraph="">In this article we look at pros and cons of GraalVM <strong>Native Image</strong>. We show an easy way of generating PGO profiles for native images <a target="_blank" rel="noopener" href="https://medium.com/graalvm/graalvm-19-2-new-tools-b78a70f54b06">introduced in GraalVM 19.2</a> that significantly improves throughput of generated native images for known workloads.</p></div></div><div><div><p id="c828" data-selectable-paragraph="">Are you seeking a system with fast startup, low system requirements and multi-threaded communication? Do you want to code in a higher level language than C? Do you want to enjoy the benefits of memory safety and automatic garbage collection? There are few languages especially designed to fit such a design landscape and you may be considering to rewrite your application in one of those. However, if you are living in the JVM world then there is an easier option. Use GraalVM‚Äôs <code>native-image</code>tool!</p><p id="bb3a" data-selectable-paragraph="">The Native Image takes the bytecode of your application and compiles it to a native executable ahead of time. As a result one can program in any JVM language: Java, Scala, Kotlin ‚Äî and get a single, self-contained executable file as output. Single file has many benefits: It can be <em>easily copied</em> from one system to another just by itself ‚Äî it contains all the application code as well as necessary runtime support, like the garbage collector for example. Single file gets loaded and is ready to run ‚Äî no need to seek for various JAR, properties &amp; other miscellaneous files and wait for them to open, load and initialize. The file generated by Native Image gives us <em>instant startup</em>. In addition to that the Native Image tool is able to capture a snapshot of an application memory ‚Äî e.g. you can bring your system into <em>ready to run state</em> and when the generated native executable is started it continues exactly from where it was. This eliminates repetitive initialization and makes the startup time even more instant.</p><p id="6b63" data-selectable-paragraph="">Another benefit of ahead of time compilation is lower memory consumption. A typical JVM keeps enormous amount of metadata in memory in addition to the JIT generated native code. These metadata are needed to be able to de-optimize at almost any moment. Nothing like that is needed in case of Native Image ‚Äî the generated code covers all the possible code paths and never de-optimizes. The native code is known to be enough and all the metadata can be dropped when the native executable is being generated.</p><p id="4fd1" data-selectable-paragraph="">In spite of all the above goodies, the Native Image fulfils the most important aspects of a JVM ‚Äî one can use a language of own choice ‚Äî be it Java, Scala, Kotlin, etc. One can benefit from all the development tools available for the JVM. One can use the strong concurrency guarantees of a JVM and one doesn‚Äôt need to care about garbage collection. The rich ecosystem of JVM full of useful libraries, tools and frameworks awaits to be compiled ahead of time.</p><p id="a1ac" data-selectable-paragraph="">The previous text might make you believe that Native Image is great and it should replace the Java HotSpot VM immediately. That would not be accurate. The benefits brought by Native Image aren‚Äôt for free ‚Äî they come with a cost. As such there are some aspects where Native Image limits its users more than classical Java HotSpot VM would.</p><p id="d955" data-selectable-paragraph="">Obviously the native executable can only run on a single platform. If you generate the image for 64-bit Linux, it only runs on Linux. If for Mac, it runs on Mac. If the executable is generated for Windows, it is going to run only on Windows. The portability is restricted compared to classical JAR file. Another limitation is caused by missing metadata during runtime. The previous section mentioned missing metadata as a benefit, but it also has its cost. Since by default native image doesn‚Äôt retain information about classes and methods, one‚Äôs ability to perform reflection is limited. The reflection is still possible, but it has to be configured and compiled into the native executable. As there are many Java frameworks that rely on reflective access, getting them run on Native Image may require additional configuration. Yet another restriction comes from the fact that the Native Image<strong> </strong>runtime may not support all features of Java. Running Swing UI toolkit may not be possible as it is too dynamic. On the other hand, Native Image successfully managed to execute <em>Javac</em>, <em>Netty</em>, <em>Micronaut</em>, <em>Helidon</em> and <em>Fn Project</em> ‚Äî all large and nontrivial applications running on top of JDK.</p><p id="39b5" data-selectable-paragraph="">The last drawback associated with the ahead-of-time compilation is speed. What? I thought Native Image starts faster! Well, it does start significantly faster than similar JVM application, but at the end, when the application runs for a long time, the just-in-time compiler can actually outperform the AOT one. As the <a href="https://www.infoq.com/news/2019/07/helidon-supports-graalvm/" target="_blank" rel="noopener nofollow">helidon.io</a> team puts it:</p><p id="f3e9" data-selectable-paragraph=""><em>‚ÄúOn the other hand, everything is always a tradeoff. Long running applications on traditional JVMs are still demonstrating better performance than GraalVM native executables due to runtime optimization. The key word here is long-running; for short-running applications like serverless functions, native executables have a performance advantage. So, you need to decide yourself between fast startup time and small size (and the additional step of building the native executable) versus better performance for long-running applications.‚Äù</em></p><p id="bf28" data-selectable-paragraph="">Now we are getting to the main topic of this post. Let‚Äôs take a look why the peak performance of AOT compilation is slower and then let‚Äôs speed it up!</p><p id="5250" data-selectable-paragraph="">By removing most of the typical metadata associated with JVM execution, native image gives up on further optimizations based on execution profiles. The ahead of time generated code is what one gets. There is no chance to do more inlining, co-locate code on hot paths or aggressively over optimize and rely on a trap to signal the need for de-optimization and less optimal compilation. These are exactly the optimizations that make JVM so great for reaching excellent peak performance. During ahead of time compilation <strong>Native Image</strong> doesn‚Äôt have enough information to generate such optimal code.</p><p id="845f" data-selectable-paragraph="">On the other hand, there is no need for initial interpretation of the bytecode. There is no need for deoptimizations and there is no support for random reflection poking around your classes. As a result for short-lived application native image starts faster, overall uses less memory. The benefits are huge, however everything comes at some cost. There is no free lunch. Or is it?</p><p id="ba3e" data-selectable-paragraph="">Commonly used technique to mitigate the missing just in time optimization is to gather the execution profiles at one run and then use them to optimize subsequent compilation(s). GraalVM 19.2.0 Enterprise comes with an improved <em>Profile Guide Optimizations</em> system. Let‚Äôs demonstrate its functionality on a classical object oriented demo application ‚Äî let‚Äôs work with shapes of geometric objects:</p><figure><div></div><figcaption>Shape.java</figcaption></figure><p id="3217" data-selectable-paragraph="">The above program introduces the <code>Shape</code> interface and its four implementations: <code>Circle</code>, <code>Square</code>, <code>Rectangle</code> and <code>Triangle</code>. The base interface defines <code>area()</code> method and each of the geometric classes overrides it and provides different implementation, suitable for its shape. Those who know how object oriented languages are implemented can already smell the problem. Right, if we create an array of shapes and go through it, the code will have to be ready for <em>virtual method dispatch</em>. Let's do it:</p><figure><div></div><figcaption>computeArea method</figcaption></figure><p id="698d" data-selectable-paragraph="">The array of <code>all</code> shapes can contain any instances and as such the call <code>shape.area()</code> has to be able to call any of the actual methods. That's usually done with a virtual method table associated with each geometric class. Find out the current <code>shape</code> is <code>Circle</code>, then lookup the actual implementation of <code>Circle.area()</code> method and call it. Doing this requires a bit of calculation. To demonstrate that let's generate a huge array of random objects and measure how much time invoking the <code>computeArea</code> method takes:</p><figure><div></div><figcaption>the main method which generates shapes and measures time</figcaption></figure><p id="8e18" data-selectable-paragraph="">If you put all the above code into file <code><a href="https://gist.github.com/JaroslavTulach/3d10da1ad1cc2e6fb7d9bacb78ea77ea" target="_blank" rel="noopener nofollow">Shape.java</a></code> (do it in an empty directory), you can compile it with GraalVM's <strong>Native Image </strong>tool. To get started <a href="https://www.graalvm.org/downloads/" target="_blank" rel="noopener nofollow">download GraalVM enterprise edition</a> as well as GraalVM Enterprise Edition Native Image tool. Unpack GraalVM and use its <code>gu</code> tool to install (<code>gu install --file native-image-installable-svm-svmee-*-19.2.0.jar</code>) the <code>bin/native-image</code> utility. Then you can:</p><pre><span id="c9fb" data-selectable-paragraph="">$ /graalvm-ee-19.2.0/bin/javac Shape.java</span><span id="7e65" data-selectable-paragraph="">$ /graalvm-ee-19.2.0/bin/native-image Shape</span><span id="85df" data-selectable-paragraph="">$ ls -1<br>graalvm-ee-19.2.0<br>shape<br>'Shape$Circle.class'<br>'Shape$Rectangle.class'<br>'Shape$Square.class'<br>'Shape$Triagle.class'<br>Shape.class<br>Shape.java</span></pre><p id="2e4f" data-selectable-paragraph="">A <code>shape</code> executable has been generated. When you run it, it is going to be completely standalone, start fast, require little memory, but it won't be optimized. Try it:</p><pre><span id="1bd0" data-selectable-paragraph="">$ ./shape 15000<!-- --> <!-- -->43243223423<!-- --> <!-- -->30<!-- --> <!-- -->square rectangle<br>last round 35<!-- --> <!-- -->ms.</span><span id="cbb1" data-selectable-paragraph="">$ ./shape 15000<!-- --> <!-- -->43243223423<!-- --> <!-- -->30<!-- --> <!-- -->triangle circle<br>last round 34<!-- --> <!-- -->ms</span></pre><p id="5847" data-selectable-paragraph="">The actual execution time may vary depending on the speed of your computer. The absolute values do not matter much, we just want to make the execution faster. Let‚Äôs train our program to be ready for square and rectangle. To do so we need to capture the data about the actual program execution. Let‚Äôs thus generate the PGO data.</p><pre><span id="cc67" data-selectable-paragraph="">$ /graalvm-ee-19.2.0/bin/java -Dgraal.PGOInstrument=shape.iprof Shape 15000<!-- --> <!-- -->43243223423<!-- --> <!-- -->130<!-- --> <!-- -->square rectangle</span></pre><p id="7225" data-selectable-paragraph="">The <code>shape.iprof</code> file is generated once the execution is over. If you inspect its content, you may find out there is a reference to <code>Shape$Square</code>, but there is no reference to <code>Shape$Circle</code>. Of course - we've been training the program for square and rectangles, not circles! The fact that <code>Shape$Circle</code> is missing in the <code>shape.iprof</code> file signals that the training was successful. Let's now use the data and regenerate our native image:</p><pre><span id="d7c5" data-selectable-paragraph="">$ /graalvm-ee-19.2.0/bin/native-image --pgo=shape.iprof Shape</span><span id="448c" data-selectable-paragraph="">$ ./shape 15000<!-- --> <!-- -->43243223423<!-- --> <!-- -->30<!-- --> <!-- -->square rectangle<br>last round 25<!-- --> <!-- -->ms.</span></pre><p id="cd75" data-selectable-paragraph="">Speedup! Instead of 35ms we can now execute the trained program in 25ms. Just by training it, recording the compiler decisions and using them to guide the compilation, we have sped up our program <strong>by almost 30%</strong>.</p><p id="03e5" data-selectable-paragraph="">Note that this result is still not exactly on par with running with a warmed up JIT compiler. If we run the same code on with a JIT compiler we still see better results.</p><pre><span id="ffe3" data-selectable-paragraph=""> $ java Shape 15000 43243223423 130 square rectangle<br>last round 17 ms.</span></pre><p id="91af" data-selectable-paragraph="">We‚Äôre working on enabling better optimizations in the GraalVM compiler used ahead-of-time, so the performance of native images should improve further in the future.</p><p id="8edb" data-selectable-paragraph="">If you‚Äôre wondering whether the PGO optimization numbers translate well to the real world applications, you can try profile-guided optimizations on some larger project, for example on the <a href="https://guides.micronaut.io/micronaut-creating-first-graal-app/guide/index.html" target="_blank" rel="noopener nofollow">Micronaut demo application for GraalVM</a>. From our initial tests PGO shows good results there. We plan to expand on this topic in further articles.</p><p id="6eda" data-selectable-paragraph="">Of course, the speed up from PGO is only visible when the real workload mimics the one that we‚Äôve been training for. If the program input diverges and the execution gets into the non-optimized paths, it can actually be even slower than without any profiles:</p><pre><span id="d252" data-selectable-paragraph="">$ ./shape 15000<!-- --> <!-- -->43243223423<!-- --> <!-- -->30<!-- --> <!-- -->triangle circle<br>last round 49<!-- --> <!-- -->ms.</span></pre><p id="ce71" data-selectable-paragraph="">Should something like that happen, it is time to re-profile your application, gather new PGO data and recompile. Note that prior to 19.2.0 one needed to create a special instrumented native image of the program to collect the profile information, but doing it by running application without preparing an instrumented native image is much simpler.</p><p id="09b9" data-selectable-paragraph="">It is well known that GraalVM Native image gives you quick startup and consumes less memory. GraalVM 19.2.0 Enterprise brings you simplified way to use profile-guided optimizations (PGO) ‚Äî with its help it is possible to train your application for specific workloads and significantly improve the peak performance. <a href="https://www.oracle.com/technetwork/graalvm/downloads/index.html" target="_blank" rel="noopener nofollow">Download GraalVM 19.2.0 Enterprise and try it yourself</a>.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
</body>
</html>