<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using strongly-typed entity IDs to avoid primitive obsession (Part 3) -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Using strongly-typed entity IDs to avoid primitive obsession (Part 3)</h1><div><div class="post-content"><p>In a <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-1/">previous post</a>, I described a common problem in which primitive arguments (e.g. <code>System.Guid</code> or <code>string</code>) are passed in the wrong order to a method, resulting in bugs. This problem is a symptom of primitive obsession: using primitive types to represent higher-level concepts. In <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/">my second post</a>, I showed how to create a <code>JsonConverter</code> and <code>TypeConverter</code> to make using the strongly-typed IDs easier with ASP.NET Core.</p><blockquote><p><a href="https://disq.us/p/213e7lq">Martin Liversage noted</a> that JSON.NET will use a <code>TypeConverter</code> where one exists, so you generally don't need the custom <code>JsonConverter</code> I provided <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/#strongly-typed-ids-make-for-ugly-json-apis">in the previous post</a>!</p></blockquote><p>In this post, I discuss using strongly-typed IDs with EF Core. I personally don't use EF Core a huge amount, but after a little playing I came up with something that I thought worked pretty well. Unfortunately, there's one huge flaw which puts a cloud over the whole approach, as <a href="#custom-value-converters-result-in-client-side-evaluation">I'll describe later</a> üôÅ. </p><h2 id="interfacing-with-external-system-using-strongly-typed-ids" class="heading-with-anchor">Interfacing with external system using strongly typed IDs<a href="#interfacing-with-external-system-using-strongly-typed-ids"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>As a very quick reminder, strongly-typed IDs are types that can be used to represent the ID of an object, for example an <code>OrderId</code> or a <code>UserId</code>. A basic implementation (ignoring the overloads and converters etc.) looks something like this:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">readonly</span><span class="token keyword">struct</span> OrderId <span class="token punctuation">:</span> IComparable<span class="token operator">&lt;</span>OrderId<span class="token operator">&gt;</span><span class="token punctuation">,</span> IEquatable<span class="token operator">&lt;</span>OrderId<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token class-name">Guid</span> Value <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token function">OrderId</span><span class="token punctuation">(</span><span class="token class-name">Guid</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        Value <span class="token operator">=</span><span class="token keyword">value</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>You only get the full benefit of strongly-typed IDs if you can use them throughout your application. That includes at the "edges" of the app, where you interact with external systems. In the <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/">previous post</a> I described the interaction at the public-facing end of your app, in ASP.NET Core MVC controllers. </p><p>The other main external system you will likely need to interface with is the database. At the <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/#other-type-converters-for-interfacing-with-the-world-">end of the last post</a>, I very briefly described a converter for using strongly-typed IDs with Dapper by creating a custom <code>TypeHandler</code>:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">class</span><span class="token class-name">OrderIdTypeHandler</span><span class="token punctuation">:</span><span class="token class-name">SqlMapper<span class="token punctuation">.</span>TypeHandler</span><span class="token operator">&lt;</span>OrderId<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token keyword">override</span><span class="token keyword">void</span><span class="token function">SetValue</span><span class="token punctuation">(</span><span class="token class-name">IDbDataParameter</span> parameter<span class="token punctuation">,</span><span class="token class-name">OrderId</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        parameter<span class="token punctuation">.</span>Value <span class="token operator">=</span><span class="token keyword">value</span><span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">override</span><span class="token class-name">OrderId</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token keyword">object</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token keyword">new</span><span class="token class-name">OrderId</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Guid<span class="token punctuation">)</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>This needs to be registered globally using <code>SqlMapper.AddTypeHandler(new OrderIdTypeHandler());</code> to be used directly in your Dapper database queries.</p><p>Dapper is the ORM that I use the most in my day job, but EF Core is possibly going to be the most common ORM in ASP.NET Core apps. Making EF Core play nicely with the strongly-typed IDs is possible, but requires a bit more work.</p><h2 id="building-an-ef-core-data-model-using-strongly-typed-ids" class="heading-with-anchor">Building an EF Core data model using strongly typed IDs<a href="#building-an-ef-core-data-model-using-strongly-typed-ids"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>We'll start by creating a very simple data model that uses strongly-typed IDs. The classic ecommerce <code>Order</code>/<code>OrderLine</code> example contains everything we need:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">Order</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token class-name">OrderId</span> OrderId <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">string</span> Name <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> ICollection<span class="token operator">&lt;</span>OrderLine<span class="token operator">&gt;</span> OrderLines <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">OrderLine</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token class-name">OrderId</span> OrderId <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token class-name">OrderLineId</span> OrderLineId <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">string</span> ProductName <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>We have two entities:</p><ul><li><code>Order</code> which has an <code>OrderId</code>, and has a collection of <code>OrderLine</code>s. </li><li><code>OrderLine</code> which has as <code>OrderLineId</code> and an <code>OrderId</code>. All of the IDs are strongly-typed. </li></ul><p>After creating these entities, we need to add them to the EF Core <code>DbContext</code>. We create a <code>DbSet&lt;Order&gt;</code> for the collection of <code>Order</code>s, and let EF Core discover the <code>OrderLine</code> entity itself:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">ApplicationDbContext</span><span class="token punctuation">:</span><span class="token class-name">DbContext</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token function">ApplicationDbContext</span><span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span> options<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> DbSet<span class="token operator">&lt;</span>Order<span class="token operator">&gt;</span> Orders <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Unfortunately, if we try and generate a new migration for updated model using the <code>dotnet ef</code> tool, we'll get an error:</p><pre class="language-bash"><code class="language-bash"><span class="token operator">&gt;</span> dotnet ef migrations add OrderSchema

System.InvalidOperationException: The property <span class="token string">'Order.OrderId'</span> could not be mapped, 
because it is of <span class="token function">type</span><span class="token string">'OrderId'</span><span class="token function">which</span> is not a supported primitive <span class="token function">type</span> or a valid 
entity type. Either explicitly map this property, or ignore it using the 
<span class="token string">'[NotMapped]'</span> attribute or by using <span class="token string">'EntityTypeBuilder.Ignore'</span><span class="token keyword">in</span><span class="token string">'OnModelCreating'</span><span class="token keyword">.</span></code></pre><p>EF Core complains that it doesn't know how to map our strongly-typed IDs (<code>OrderId</code>) to a database type. Luckily, there's a mechanism we can use to control this as of EF Core 2.1: value converters.</p><h2 id="creating-a-custom-valueconverter-for-ef-core" class="heading-with-anchor">Creating a custom ValueConverter for EF Core<a href="#creating-a-custom-valueconverter-for-ef-core"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>As <a href="https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions">described in the EF Core documentation</a>: </p><blockquote><p>Value converters allow property values to be converted when reading from or writing to the database. This conversion can be from one value to another of the same type (for example, encrypting strings) or from a value of one type to a value of another type (for example, converting enum values to and from strings in the database.)</p></blockquote><p>The latter conversion, converting from one type to another, is what we need for the strongly-typed IDs. By using a value converter, we can convert our IDs into a <code>Guid</code>, just before they're written to the database. When reading a value, we convert the <code>Guid</code> value from the database into a strongly typed ID.</p><p>EF Core allows you to <a href="https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions#configuring-a-value-converter">configure value converters manually for each property in your modelling code using lambdas</a>. Alternatively, you can create reusable, standalone, custom value converters for each type. That's the approach I show here.</p><p>To implement a custom value converter you create an instance of a <code>ValueConverter&lt;TModel, TProvider&gt;</code>. <code>TModel</code> is the type being converted (the strongly-typed ID in our case), while <code>TProvider</code> is the database type. To create the converter you provide two lambda functions in the constructor arguments:</p><ul><li><code>convertToProviderExpression</code>: an expression that is used to convert the strongly-typed ID to the database value (a <code>Guid</code>)</li><li><code>convertFromProviderExpression</code>: an expression that is used to convert the database value (a <code>Guid</code>) into an instance of the strongly-typed ID.</li></ul><p>You can create an instance of the generic <code>ValueConverter&lt;&gt;</code> directly, but I chose to create a derived converter to simplify instantiating a new converter. Taking the <code>OrderId</code> example, we can create a custom <code>ValueConverter&lt;&gt;</code> using the following:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">OrderIdValueConverter</span><span class="token punctuation">:</span><span class="token class-name">ValueConverter</span><span class="token operator">&lt;</span>OrderId<span class="token punctuation">,</span> Guid<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token function">OrderIdValueConverter</span><span class="token punctuation">(</span><span class="token class-name">ConverterMappingHints</span> mappingHints <span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span>
            id <span class="token operator">=</span><span class="token operator">&gt;</span> id<span class="token punctuation">.</span>Value<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token keyword">new</span><span class="token class-name">OrderId</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            mappingHints
        <span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>The lambda functions are simple - to obtain a <code>Guid</code> we use the <code>Value</code> property of the ID, and to create a new instance of the ID we pass the <code>Guid</code> to the constructor. The <code>ConverterMappingHints</code> parameter can allow setting things such as <code>Scale</code> and <code>Precision</code> for some database types. We don't need it here but I've included it for completeness in this example.</p><h2 id="registering-the-custom-valueconverter-with-ef-core-s-db-context" class="heading-with-anchor">Registering the custom ValueConverter with EF Core's DB Context<a href="#registering-the-custom-valueconverter-with-ef-core-s-db-context"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>The value converters describe how to store our strongly-typed IDs in the database, but EF Core need's to know <em>when</em> to use each converter. There's no way to do this using attributes, so you need to customise the model in <code>DbContext.OnModelCreating</code>. That makes for some pretty verbose code:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">ApplicationDbContext</span><span class="token punctuation">:</span><span class="token class-name">IdentityDbContext</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token function">ApplicationDbContext</span><span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span> options<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> DbSet<span class="token operator">&lt;</span>Order<span class="token operator">&gt;</span> Orders <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span><span class="token keyword">override</span><span class="token keyword">void</span><span class="token function">OnModelCreating</span><span class="token punctuation">(</span><span class="token class-name">ModelBuilder</span> builder<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnModelCreating</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>

        builder
            <span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Order</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">&gt;</span> o<span class="token punctuation">.</span>OrderId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasConversion</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token class-name">OrderIdValueConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        builder
            <span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">OrderLine</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">&gt;</span> o<span class="token punctuation">.</span>OrderLineId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasConversion</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token class-name">OrderLineIdValueConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        builder
            <span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Entity</span><span class="token punctuation">&lt;</span><span class="token class-name">Order</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">&gt;</span> o<span class="token punctuation">.</span>OrderId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasConversion</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token class-name">OrderIdValueConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>It's clearly not optimal having to add a manual mapping for <em>each</em> usage of a strongly-typed ID in your entities. Luckily we can simplify this code somewhat.</p><h2 id="automatically-using-a-value-converter-for-all-properties-of-a-given-type-" class="heading-with-anchor">Automatically using a value converter for all properties of a given type.<a href="#automatically-using-a-value-converter-for-all-properties-of-a-given-type-"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>Ideally our custom value converters would be used automatically by EF Core every time a given strongly-typed ID is used. <a href="https://github.com/aspnet/EntityFrameworkCore/issues/10784">There's an issue on GitHub for exactly this functionality</a>, but in the meantime, we can emulate the behaviour by looping over all the model entities, as <a href="https://github.com/aspnet/EntityFrameworkCore/issues/10784#issuecomment-415769754">described in a comment on that issue</a>.</p><p>In the code below, we loop over every entity in the model, and for each entity, find all those properties that are of the required type (<code>OrderId</code> for the <code>OrderIdValueConverter</code>). For each property we register the <code>ValueConverter</code>, in a process similar to the manual registrations above:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">static</span><span class="token keyword">class</span><span class="token class-name">ModelBuilderExtensions</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token keyword">static</span><span class="token class-name">ModelBuilder</span><span class="token function">UseValueConverter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token class-name">ModelBuilder</span> modelBuilder<span class="token punctuation">,</span><span class="token class-name">ValueConverter</span> converter<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> type <span class="token operator">=</span> converter<span class="token punctuation">.</span>ModelClrType<span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> entityType <span class="token keyword">in</span> modelBuilder<span class="token punctuation">.</span>Model<span class="token punctuation">.</span><span class="token function">GetEntityTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> properties <span class="token operator">=</span> entityType
                <span class="token punctuation">.</span>ClrType
                <span class="token punctuation">.</span><span class="token function">GetProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>p <span class="token operator">=</span><span class="token operator">&gt;</span> p<span class="token punctuation">.</span>PropertyType <span class="token operator">==</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> property <span class="token keyword">in</span> properties<span class="token punctuation">)</span><span class="token punctuation">{</span>
                modelBuilder
                    <span class="token punctuation">.</span><span class="token function">Entity</span><span class="token punctuation">(</span>entityType<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>property<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasConversion</span><span class="token punctuation">(</span>converter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> modelBuilder<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>All that remains is to register the value converter for each strongly-typed ID type in the DbContext:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">ApplicationDbContext</span><span class="token punctuation">:</span><span class="token class-name">IdentityDbContext</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token function">ApplicationDbContext</span><span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span> options<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> DbSet<span class="token operator">&lt;</span>Order<span class="token operator">&gt;</span> Orders <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span><span class="token keyword">override</span><span class="token keyword">void</span><span class="token function">OnModelCreating</span><span class="token punctuation">(</span><span class="token class-name">ModelBuilder</span> builder<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnModelCreating</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>

        builder<span class="token punctuation">.</span><span class="token function">UseValueConverter</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token class-name">OrderIdValueConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        builder<span class="token punctuation">.</span><span class="token function">UseValueConverter</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token class-name">OrderLineIdValueConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>It's a bit frustrating having to manually register each of these value converters - every time you create a new strongly typed ID you have to remember to register it in the <code>DbContext</code>. </p><blockquote><p>Creating the <code>ValueConverter</code> implementation itself for every strongly-typed ID is not a big deal if you're using snippets to generate your IDs, like I <a href="/using-strongly-typed-entity-ids-to-avoid-primitive-obsession-part-2/#that-s-a-lot-of-boilerplate-code-">described in the last post</a>.</p></blockquote><p>It would be nice if we were able to generate a new ID, use it in an entity, and not have to remember to update the <code>OnModelCreating</code> method.</p><h2 id="automatically-registering-value-converters-for-strongly-typed-ids" class="heading-with-anchor">Automatically registering value converters for strongly typed IDs<a href="#automatically-registering-value-converters-for-strongly-typed-ids"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>We can achieve this functionality with a little bit of reflection and some attributes. We'll start by creating an attribute that we can use to link each strongly-typed ID to a specific value converter, called <code>EfCoreValueConverterAttribute</code>:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">EfCoreValueConverterAttribute</span><span class="token punctuation">:</span><span class="token class-name">Attribute</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token function">EfCoreValueConverterAttribute</span><span class="token punctuation">(</span><span class="token class-name">Type</span> valueConverter<span class="token punctuation">)</span><span class="token punctuation">{</span>
        ValueConverter <span class="token operator">=</span> valueConverter<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token class-name">Type</span> ValueConverter <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>We'll decorate each strongly typed ID with the attribute as part of the snippet generation, which will give something like the following:</p><pre class="language-csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token class-name">EfCoreValueConverter</span><span class="token punctuation">(</span><span class="token function">typeod</span><span class="token punctuation">(</span>OrderIdValueConverter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">public</span><span class="token keyword">readonly</span><span class="token keyword">struct</span> OrderId <span class="token punctuation">:</span> IComparable<span class="token operator">&lt;</span>OrderId<span class="token operator">&gt;</span><span class="token punctuation">,</span> IEquatable<span class="token operator">&lt;</span>OrderId<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token class-name">Guid</span> Value <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token function">OrderId</span><span class="token punctuation">(</span><span class="token class-name">Guid</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        Value <span class="token operator">=</span><span class="token keyword">value</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">OrderIdValueConverter</span><span class="token punctuation">:</span><span class="token class-name">ValueConverter</span><span class="token operator">&lt;</span>OrderId<span class="token punctuation">,</span> Guid<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token function">OrderIdValueConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span>
                id <span class="token operator">=</span><span class="token operator">&gt;</span> id<span class="token punctuation">.</span>Value<span class="token punctuation">,</span><span class="token keyword">value</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token keyword">new</span><span class="token class-name">OrderId</span><span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Next, we'll add another method to the <code>ModelBuilderExtensions</code> this loops through all the types in an <code>Assembly</code> and finds all those that are decorated with the <code>EfCoreValueConverterAttribute</code> (i.e. the strongly typed IDs). The <code>Type</code> of the value converter is extracted from the custom attribute, and an instance of the value converter is created using the <code>ValueConverter</code>. We can then pass that to the <code>UseValueConverter</code> method we created previously.</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">static</span><span class="token keyword">class</span><span class="token class-name">ModelBuilderExtensions</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token keyword">static</span> ModelBuilder <span class="token generic-method"><span class="token function">AddStronglyTypedIdValueConverters</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token class-name">ModelBuilder</span> modelBuilder<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> assembly <span class="token operator">=</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span>Assembly<span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> type <span class="token keyword">in</span> assembly<span class="token punctuation">.</span><span class="token function">GetTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> attribute <span class="token operator">=</span> type
                    <span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetCustomAttributes</span><span class="token punctuation">&lt;</span><span class="token class-name">EfCoreValueConverterAttribute</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>attribute <span class="token keyword">is</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> converter <span class="token operator">=</span><span class="token punctuation">(</span>ValueConverter<span class="token punctuation">)</span> Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>attribute<span class="token punctuation">.</span>ValueConverter<span class="token punctuation">)</span><span class="token punctuation">;</span>
                modelBuilder<span class="token punctuation">.</span><span class="token function">UseValueConverter</span><span class="token punctuation">(</span>converter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> modelBuilder<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">static</span><span class="token class-name">ModelBuilder</span><span class="token function">UseValueConverter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token class-name">ModelBuilder</span> modelBuilder<span class="token punctuation">,</span><span class="token class-name">ValueConverter</span> converter<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> type <span class="token operator">=</span> converter<span class="token punctuation">.</span>ModelClrType<span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> entityType <span class="token keyword">in</span> modelBuilder<span class="token punctuation">.</span>Model<span class="token punctuation">.</span><span class="token function">GetEntityTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> properties <span class="token operator">=</span> entityType
                    <span class="token punctuation">.</span>ClrType
                    <span class="token punctuation">.</span><span class="token function">GetProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>p <span class="token operator">=</span><span class="token operator">&gt;</span> p<span class="token punctuation">.</span>PropertyType <span class="token operator">==</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">foreach</span><span class="token punctuation">(</span><span class="token keyword">var</span> property <span class="token keyword">in</span> properties<span class="token punctuation">)</span><span class="token punctuation">{</span>
                    modelBuilder
                        <span class="token punctuation">.</span><span class="token function">Entity</span><span class="token punctuation">(</span>entityType<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Property</span><span class="token punctuation">(</span>property<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">HasConversion</span><span class="token punctuation">(</span>converter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> modelBuilder<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>With this code in place, we can register <em>all</em> our value converters in one fell swoop in the <code>DbContext.OnModelCreating</code> method:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">ApplicationDbContext</span><span class="token punctuation">:</span><span class="token class-name">IdentityDbContext</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token function">ApplicationDbContext</span><span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span> options<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">base</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> DbSet<span class="token operator">&lt;</span>Order<span class="token operator">&gt;</span> Orders <span class="token punctuation">{</span><span class="token keyword">get</span><span class="token punctuation">;</span><span class="token keyword">set</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span><span class="token keyword">override</span><span class="token keyword">void</span><span class="token function">OnModelCreating</span><span class="token punctuation">(</span><span class="token class-name">ModelBuilder</span> builder<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">base</span><span class="token punctuation">.</span><span class="token function">OnModelCreating</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>
        builder<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddStronglyTypedIdValueConverters</span><span class="token punctuation">&lt;</span><span class="token class-name">OrderId</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>The type parameter <code>OrderId</code> in the above example is used to identify the <code>Assembly</code> to scan to find the strongly-typed IDs. If required, it would be simple to add another overload to allowing scanning multiple assemblies. </p><p>With the code above, we don't have to touch the <code>DbContext</code> when we add a new strongly-typed ID, which is a much better experience for developers. If we run the migrations now, all is well:</p><pre class="language-bash"><code class="language-bash"><span class="token operator">&gt;</span> dotnet ef migrations add OrderSchema

Done. To undo this action, use <span class="token string">'ef migrations remove'</span></code></pre><p>If you check the generated migration, you'll see that the <code>OrderId</code> column is created as a non-nullable <code>Guid</code>, and is the primary key, as you'd expect.</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">partial</span><span class="token keyword">class</span><span class="token class-name">OrderSchema</span><span class="token punctuation">:</span><span class="token class-name">Migration</span><span class="token punctuation">{</span><span class="token keyword">protected</span><span class="token keyword">override</span><span class="token keyword">void</span><span class="token function">Up</span><span class="token punctuation">(</span><span class="token class-name">MigrationBuilder</span> migrationBuilder<span class="token punctuation">)</span><span class="token punctuation">{</span>
        migrationBuilder<span class="token punctuation">.</span><span class="token function">CreateTable</span><span class="token punctuation">(</span>
            name<span class="token punctuation">:</span><span class="token string">"Orders"</span><span class="token punctuation">,</span>
            columns<span class="token punctuation">:</span> table <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token keyword">new</span><span class="token punctuation">{</span>
                OrderId <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Column</span><span class="token punctuation">&lt;</span><span class="token class-name">Guid</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>nullable<span class="token punctuation">:</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                Name <span class="token operator">=</span> table<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">Column</span><span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>nullable<span class="token punctuation">:</span><span class="token keyword">true</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            constraints<span class="token punctuation">:</span> table <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
                table<span class="token punctuation">.</span><span class="token function">PrimaryKey</span><span class="token punctuation">(</span><span class="token string">"PK_Orders"</span><span class="token punctuation">,</span> x <span class="token operator">=</span><span class="token operator">&gt;</span> x<span class="token punctuation">.</span>OrderId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>This solves most of the problems you'll encounter using strongly typed IDs with EF Core, but there's one place where this doesn't quite work, and unfortunately, it might be a deal breaker.</p><p>Saving entities that use your strongly-typed IDs to the database is no problem for EF Core. However, if you try and load an entity from the database, and filter based on the strongly-typed ID:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">var</span> order <span class="token operator">=</span> _dbContext<span class="token punctuation">.</span>Orders
    <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>order <span class="token operator">=</span><span class="token operator">&gt;</span> order<span class="token punctuation">.</span>OrderId <span class="token operator">==</span> orderId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>then you'll see a warning in the logs that the <code>where</code> clause must be evaluated <em>client-side</em>: </p><pre class="language-bash"><code class="language-bash">warn: Microsoft.EntityFrameworkCore.Query<span class="token punctuation">[</span>20500<span class="token punctuation">]</span>
      The LINQ expression <span class="token string">'where ([x].OrderId == __orderId_0)'</span> 
      could not be translated and will be evaluated locally.

info: Microsoft.EntityFrameworkCore.Database.Command<span class="token punctuation">[</span>20101<span class="token punctuation">]</span>
      Executed DbCommand <span class="token punctuation">(</span>12ms<span class="token punctuation">)</span><span class="token punctuation">[</span>Parameters<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>, CommandType<span class="token operator">=</span><span class="token string">'Text'</span>, CommandTimeout<span class="token operator">=</span><span class="token string">'30'</span><span class="token punctuation">]</span>
      SELECT <span class="token punctuation">[</span>x<span class="token punctuation">]</span>.<span class="token punctuation">[</span>OrderId<span class="token punctuation">]</span>, <span class="token punctuation">[</span>x<span class="token punctuation">]</span>.<span class="token punctuation">[</span>Name<span class="token punctuation">]</span>
      FROM <span class="token punctuation">[</span>Orders<span class="token punctuation">]</span> AS <span class="token punctuation">[</span>x<span class="token punctuation">]</span></code></pre><p>That's terrible. This query has got to be a contender for the most common thing you'll ever do, and the above solution will not be good enough. Fetching an <code>Order</code> by ID with client-side execution involves loading <em>all</em><code>Order</code>s into memory and filtering in memory!</p><p>In fairness <a href="https://docs.microsoft.com/en-us/ef/core/modeling/value-conversions">the documentation</a> does mention this limitation right at the bottom of the page (emphasis mine):</p><blockquote><p>Use of value conversions <strong>may</strong> impact the ability of EF Core to translate expressions to SQL. A warning will be logged for such cases. Removal of these limitations is being considered for a future release.</p></blockquote><p>But this value converter is pretty much the most basic you could imagine - if this converter results in client-side evaluation, they all will! </p><p>There is <a href="https://github.com/aspnet/EntityFrameworkCore/issues/12045">an issue to track this problem</a>, but unfortunately there's no easy work around to this one. üôÅ </p><p>All is not <em>entirely</em> lost. It's not pretty, but after some playing I eventually found something that will let you use strongly-typed IDs in your EF Core models that doesn't force client-side evaluation.</p><p>The key is adding implicit or explicit conversion operators to the strongly-typed IDs, such that EF Core doesn't bork on seeing the strongly-typed ID in a query. There's two possible options, an explicit conversion operator, or an implicit conversion operator.</p><h3 id="using-an-explicit-conversion-operator-with-strongly-typed-ids" class="heading-with-anchor">Using an explicit conversion operator with strongly typed IDs<a href="#using-an-explicit-conversion-operator-with-strongly-typed-ids"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h3><p>The first approach is to add an explicit conversion operator to your strongly-typed ID to go from the ID type to a <code>Guid</code>:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">readonly</span><span class="token keyword">struct</span> OrderId
<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token keyword">static</span><span class="token keyword">explicit</span><span class="token keyword">operator</span><span class="token function">Guid</span><span class="token punctuation">(</span><span class="token class-name">OrderId</span> orderId<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span> orderId<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Adding this sort of operator means you can cast an <code>OrderId</code> to a <code>Guid</code>, for example:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">var</span> orderId <span class="token operator">=</span><span class="token keyword">new</span><span class="token class-name">OrderId</span><span class="token punctuation">(</span>Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> result <span class="token operator">=</span><span class="token punctuation">(</span>Guid<span class="token punctuation">)</span> orderId<span class="token punctuation">;</span></code></pre><p>So how does that help? Essentially we can trick EF Core into running the query server-side, by using a construction similar to the following:</p><pre class="language-csharp"><code class="language-csharp"><span class="token class-name">Guid</span> orderIdValue <span class="token operator">=</span> orderId<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token keyword">var</span> order <span class="token operator">=</span> _dbContext<span class="token punctuation">.</span>Orders
    <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>order <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>Guid<span class="token punctuation">)</span> order<span class="token punctuation">.</span>OrderId <span class="token operator">==</span> orderIdValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The key point is the explicit conversion of <code>order.OrderId</code> to a <code>Guid</code>. When EF Core evaluates the query, it no longer sees an <code>OrderId</code> type that it doesn't know what to do with, and instead generates the SQL we wanted in the first place:</p><pre class="language-bash"><code class="language-bash">info: Microsoft.EntityFrameworkCore.Database.Command<span class="token punctuation">[</span>20101<span class="token punctuation">]</span>
      Executed DbCommand <span class="token punctuation">(</span>7ms<span class="token punctuation">)</span><span class="token punctuation">[</span>Parameters<span class="token operator">=</span><span class="token punctuation">[</span>@__orderId_Value_0<span class="token operator">=</span><span class="token string">'?'</span><span class="token punctuation">(</span>DbType <span class="token operator">=</span> Guid<span class="token punctuation">)</span><span class="token punctuation">]</span>, CommandType<span class="token operator">=</span><span class="token string">'Text'</span>, CommandTimeout<span class="token operator">=</span><span class="token string">'30'</span><span class="token punctuation">]</span>
      SELECT TOP<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span>.<span class="token punctuation">[</span>OrderId<span class="token punctuation">]</span>, <span class="token punctuation">[</span>x<span class="token punctuation">]</span>.<span class="token punctuation">[</span>Name<span class="token punctuation">]</span>
      FROM <span class="token punctuation">[</span>Orders<span class="token punctuation">]</span> AS <span class="token punctuation">[</span>x<span class="token punctuation">]</span>
      WHERE <span class="token punctuation">[</span>x<span class="token punctuation">]</span>.<span class="token punctuation">[</span>OrderId<span class="token punctuation">]</span><span class="token operator">=</span> @__orderId_Value_0
</code></pre><p>This shows the <code>where</code> clause being sent to the database, so all is well again. Well, apart from the fact it's an ugly hack. üòï Implicit operators make the process very slightly less ugly.</p><h3 id="using-an-implicit-conversion-operator-with-strongly-typed-ids" class="heading-with-anchor">Using an implicit conversion operator with strongly typed IDs<a href="#using-an-implicit-conversion-operator-with-strongly-typed-ids"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h3><p>The implicit conversion operator implementation is almost identical to the explicit implementation, just with a different keyword:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">readonly</span><span class="token keyword">struct</span> OrderId
<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token keyword">static</span><span class="token keyword">implicit</span><span class="token keyword">operator</span><span class="token function">Guid</span><span class="token punctuation">(</span><span class="token class-name">OrderId</span> orderId<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span> orderId<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>With this code, you no longer need an explicit <code>(Guid)</code> cast to convert an <code>OrderId</code> to a <code>Guid</code>, so we can write the query as:</p><pre class="language-csharp"><code class="language-csharp"><span class="token class-name">Guid</span> orderIdValue <span class="token operator">=</span> orderId<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token keyword">var</span> order <span class="token operator">=</span> _dbContext<span class="token punctuation">.</span>Orders
    <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>order <span class="token operator">=</span><span class="token operator">&gt;</span> order<span class="token punctuation">.</span>OrderId <span class="token operator">==</span> orderIdValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This query generates identical SQL, so technically you could use either approach. But which should you choose?</p><h3 id="implicit-vs-explicit-operators" class="heading-with-anchor">Implicit vs Explicit operators<a href="#implicit-vs-explicit-operators"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h3><p>For simple ugliness, the implicit operator seems slightly preferable, as you don't have to add the extra cast, but I'm not sure if that's a bad thing. The trouble is that the implicit conversions apply throughout your code base, so suddenly code like this will compile:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token class-name">Order</span><span class="token function">GetOrderForUser</span><span class="token punctuation">(</span><span class="token class-name">Guid</span> orderId<span class="token punctuation">,</span><span class="token class-name">Guid</span> userId<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token class-name">OrderId</span> orderId <span class="token operator">=</span> OrderId<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">UserId</span> userId <span class="token operator">=</span> UserId<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> order <span class="token operator">=</span><span class="token function">GetOrderForUser</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> orderId<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The <code>GetOrderForUser()</code> method should obviously be using the strongly-typed IDs, but the fact that this is possible without any indication of errors just makes me a little uneasy. For that reason, I think I prefer the explicit operators. </p><p>Either way, you should definitely hide away the cast from callers wherever possible:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">OrderService</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token class-name">Order</span><span class="token function">GetOrder</span><span class="token punctuation">(</span><span class="token class-name">OrderId</span> orderId<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token function">GetOrder</span><span class="token punctuation">(</span>orderId<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token class-name">Order</span><span class="token function">GetOrder</span><span class="token punctuation">(</span><span class="token class-name">Guid</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _dbContext<span class="token punctuation">.</span>Orders
            <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>Guid<span class="token punctuation">)</span> x<span class="token punctuation">.</span>OrderId <span class="token operator">==</span> orderId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">OrderService</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token class-name">Order</span><span class="token function">GetOrder</span><span class="token punctuation">(</span><span class="token class-name">OrderId</span> orderId<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token function">GetOrder</span><span class="token punctuation">(</span>orderId<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token class-name">Order</span><span class="token function">GetOrder</span><span class="token punctuation">(</span><span class="token class-name">Guid</span> orderId<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> _dbContext<span class="token punctuation">.</span>Orders
            <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">&gt;</span> x<span class="token punctuation">.</span>OrderId <span class="token operator">==</span> orderId<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">FirstOrDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>It's probably also worth configuring your <code>DbContext</code> to throw an error when client-side evaluation occurs so you don't get client-side errors creeping in without you noticing. Override the <code>DbContext.OnConfiguring</code> method, and configure the options:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">protected</span><span class="token keyword">override</span><span class="token keyword">void</span><span class="token function">OnConfiguring</span><span class="token punctuation">(</span><span class="token class-name">DbContextOptionsBuilder</span> optionsBuilder<span class="token punctuation">)</span><span class="token punctuation">{</span>
    optionsBuilder<span class="token punctuation">.</span><span class="token function">ConfigureWarnings</span><span class="token punctuation">(</span>warning <span class="token operator">=</span><span class="token operator">&gt;</span> 
            warning<span class="token punctuation">.</span><span class="token function">Throw</span><span class="token punctuation">(</span>RelationalEventId<span class="token punctuation">.</span>QueryClientEvaluationWarning<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Even with all this effort, there's still gotchas. As well as standard <code>IQueryable&lt;T&gt;</code> LINQ syntax, the <code>DbSet&lt;&gt;</code> exposes a <code>Find</code> method which is effectively a shorthand for <code>SingleOrDefault()</code> for querying by an entities primary key. Unfortunately, nothing we do here will work:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">var</span> orderId <span class="token operator">=</span><span class="token keyword">new</span><span class="token class-name">OrderId</span><span class="token punctuation">(</span>Guid<span class="token punctuation">.</span><span class="token function">NewGuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
_dbContext<span class="token punctuation">.</span>Orders<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>
_dbContext<span class="token punctuation">.</span>Orders<span class="token punctuation">.</span><span class="token function">Find</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>Value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>So close‚Ä¶</p><p>This post is plenty long enough, and I haven't <em>quite</em> worked out a final solution but I have a couple of ideas. Check back in a couple of days, and hopefully I'll have it figured out üôÇ</p><h2 id="summary" class="heading-with-anchor">Summary<a href="#summary"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>In this post I explored possible solutions that would allow you to use strongly-typed IDs directly in your EF Core entities. The <code>ValueConverter</code> approach described in this post gets you 90% of the way there, but unfortunately the fact that queries will be executed client-side really makes the whole approach more difficult <a href="https://github.com/aspnet/EntityFrameworkCore/issues/12045">until this issue is resolved</a>. You can get <em>some</em> success by using explicit or implicit conversions, but there are still edge cases. I'm playing with a different approach as we speak, and hope to have something working in a couple of days, so check back soon!</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>