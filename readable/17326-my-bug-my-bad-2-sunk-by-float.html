<!DOCTYPE html>
<html lang="en">
<head>
    <title>
My Bug, My Bad #2: Sunk by Float -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>My Bug, My Bad #2: Sunk by Float</h1><div><div class="ninecol" xmlns="http://www.w3.org/1999/xhtml"><p class="meta">posted by Craig Gidney on March 19, 2013</p><p>Last week I read a post that sparked my interest: Comparing an Integer With a Floating-Point Number (<a href="http://www.drdobbs.com/cpp/comparing-an-integer-with-a-floating-poi/240150323">Part 1</a>, <a href="http://www.drdobbs.com/cpp/comparing-an-integer-with-a-floating-poi/240150886">Part 2</a>). The problem from the post is interesting because a) it involves floating point numbers and b) neither type (32-bit integers, single precision floats) can represent all values of the other type (and you’re not allowed to cheat by casting to double).</p><p>The post starts solving the float/int comparison problem with an approach based on boundaries: find the smallest float guaranteed to be a whole number, do different things on either side of that boundary, etc. I find this distasteful because it screams “easy to get wrong and not realize it!”. You’re in danger of testing the wrong corner cases if you compute the wrong boundary value (i.e. it’s difficult to repeat yourself differently in the tests), so a mistake might go unnoticed.</p><p>I figured I would try to come up with a different approach, and I did:</p><pre><code class="prettyprint">bool Equals(int i, float f) {
    // warning: this is wrong
    float iToF = (float)i;
    return (int)iToF == i &amp;&amp; f == iToF;
}</code></pre><p>The main idea behind the above code is that only integers that can be represented as floats will survive unchanged through a round-trip casting to float and back to int. If an integer can be represented as a float, then we can use its float version for the comparison. If an integer can’t be represented as a float, then there’s no way it’s equal to any float.</p><p>The other idea behind the above code is being <strong>horribly, terribly wrong</strong>. Wrong stacked on top of wrong stacked on top of even more wrong, in a never-ending cycle of pain and unreliable knowledge… but maybe I’m being a bit hard on myself. <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">Working with floating point numbers</a> is <a href="http://www.exploringbinary.com/why-volatile-fixes-the-2-2250738585072011e-308-bug/">notoriously difficult</a>, after all. Lets break down the issues in the above code.</p><h3>Wrong #1: Rounding out of range</h3><p>The code assumes round-tripping a 32-bit integer through float will give back a proper 32-bit integer. That’s actually not the case. For example, the maximum 32-bit signed integer is rounded <em>up</em> when you convert it to float: from <img src="http://twistedoakstudios.com/blog/wp-content/ql-cache/quicklatex.com-7e13f7b5154c77142a2e71d5b8b3b5b4_l3.png" class="ql-img-inline-formula " alt="2^{31}-1" title="Rendered by QuickLaTeX.com" height="16" width="53"> to <img src="http://twistedoakstudios.com/blog/wp-content/ql-cache/quicklatex.com-f2c9371b7b52480d726c372310cbd29b_l3.png" class="ql-img-inline-formula " alt="2^{31}" title="Rendered by QuickLaTeX.com" height="15" width="22">. When you convert the float back to an Int32, it’s out of the valid range.</p><p>Bad things happen when you try to convert a too-large/out-of-range float into an int. <a href="http://stackoverflow.com/questions/3986795/casting-float-inf-to-integer">In C it’s undefined behavior</a>, which is <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">very very bad</a>. Even in a “safe” language like C# the spec says the cast either throws an exception or returns an “unspecified value”, depending on if you’re in a checked or unchecked context.</p><p>Relying on undefined behavior or on an unspecified value is a great way to turn your code into a time bomb. Everyone loves wasting time figuring out why apparently working code broke when you started using a more recent compiler… right?</p><p>Before even getting into the muck of floating point precision, the code is wrong. The round-trip might fail more than it should. On the other hand, a few ‘is it in range?’ checks could bypass this problem. The wrong goes so much deeper.</p><h3>Wrong #2: Precision</h3><p>The code assumes floats have a fixed amount of precision. This sounds reasonable, except in reality the compiler and the hardware will “help out” by providing more precision in some cases.</p><p>For example, the compiler is likely to keep the value of the local variable <code>iToF</code> in a register, instead of in memory. On x86, floating point registers have <a href="http://en.wikipedia.org/wiki/Extended_precision">more bits of precision</a> than required. The extra precision, whether it comes from registers or from optimizations, has observable effects. Consider this C# code:</p><pre><code class="prettyprint">float f = (float)(1 &lt;&lt; 24);
int i0 = (1 &lt;&lt; 24) + 1;
int i1 = (int)(f + 1f);
int i2 = (int)(float)(f + 1f);
Console.WriteLine(i0); // 16777217
Console.WriteLine(i1); // 16777217
Console.WriteLine(i2); // 16777216</code></pre><p>Those well versed in the dangers of floating points will notice that floats don't have enough precision to represent the integer <img src="http://twistedoakstudios.com/blog/wp-content/ql-cache/quicklatex.com-310309fa3043affa9909defdfcff058e_l3.png" class="ql-img-inline-formula " alt="2^{24}+1 = 16777217" title="Rendered by QuickLaTeX.com" height="16" width="150">. That's the first level of trickery. It explains <code>i2</code> printing <img src="http://twistedoakstudios.com/blog/wp-content/ql-cache/quicklatex.com-90064c59b123fc2bbd3f135c22be5be7_l3.png" class="ql-img-inline-formula " alt="16777216" title="Rendered by QuickLaTeX.com" height="14" width="71"> instead of <img src="http://twistedoakstudios.com/blog/wp-content/ql-cache/quicklatex.com-d2badf3b0869586c812b555c33764dbe_l3.png" class="ql-img-inline-formula " alt="16777217" title="Rendered by QuickLaTeX.com" height="14" width="71">. The second level of trickery is the "bonus" precision, which allows the apparently impossible feat of converting a float to an int and getting <img src="http://twistedoakstudios.com/blog/wp-content/ql-cache/quicklatex.com-d2badf3b0869586c812b555c33764dbe_l3.png" class="ql-img-inline-formula " alt="16777217" title="Rendered by QuickLaTeX.com" height="14" width="71"> stored in <code>i1</code> despite the fact that floats can't represent <img src="http://twistedoakstudios.com/blog/wp-content/ql-cache/quicklatex.com-d2badf3b0869586c812b555c33764dbe_l3.png" class="ql-img-inline-formula " alt="16777217" title="Rendered by QuickLaTeX.com" height="14" width="71">.</p><p>Note that the above sample might behave differently on your machine or in the future. The C# spec does not specify how extra precision is handled, stating nothing more concrete than "Floating-point operations may be performed with higher precision than the result type of the operation.".</p><p>(Terrible Trivia You've Just Learned: In C# is there any type T such that casting from T to T is not guaranteed to be a no-op? Yup. Float. In the above sample, on my machine, casting a float expression to float removes the extra precision.)</p><p>In terms of my wrong code for solving the integer/float comparison problem, extended precision means the round-trip might succeed more often than it should. Even if the integer can't be represented as a float, there's no guarantee extended precision won't be used (in the future or on other machines or at different optimization levels) to allow the round-trip to preserve all integers.</p><p>For those keeping track: that's a total of two time bombs accidentally written into the same two-line function.</p><p>Actually, this whole extended precision thing calls into question the problem itself.</p><h3>Wrong #3: Assuming Floats Have a Consistent Value</h3><p>The truly terrifying thing about "bonus" precision is that you don't control it. It can be available for one comparison, but not the next, creating some <a href="http://gcc.gnu.org/ml/gcc-bugs/1999-05n/msg00133.html">truly nasty bugs</a>.</p><p>Consider the following code:</p><pre><code class="prettyprint">if (someFloat &gt; 1) Print("More");
if (someFloat &lt;= 1) Print("Not More");</code></pre><p>You might be surprised to find out that it's possible for the above code to print "More" <strong>and</strong> "Not More" at the same time. If <code>someFloat</code> has extra precision and is barely larger than 1, then it passes the 'greater than 1' check. If it then loses that precision, perhaps due to the call to Print needing floating point registers, then it will be rounded to 1 in time to also pass the 'less than or equal to 1' check.</p><p>Basically, any code that compares a float to the same value twice can be broken by a sufficiently evil compiler, even a compliant-to-spec one. If that doesn't immediately terrify you, maybe a practical example will:</p><pre><code class="prettyprint">Vector2 Normal(Vector2 v) {
    var length = Math.Sqrt(v.x*v.x + v.y*v.y);
    if (length == 0) return new Vector2(0, 0);
    return new Vector2(v.x / length, v.y / length);
}</code></pre><p>The above is a typical function to get the normal of a vector. Similar code appears in almost every geometry library ever. It's not really "wrong", exactly, but bad things happen if you look at it through the eyes of a sufficiently evil compiler.</p><p>You might assume that, given an input vector with real coordinates (not infinity or NaN), this function is guaranteed to return a vector with real coordinates with a length approximately equal to 1 or 0. Except, if you take the normal of a vector near zero then the extra precision might be available for the length == 0 check but not for the divisions, resulting in non-real outputs. So much for the assumed "real preserving" invariant. Ugh.</p><p>Using a <img src="http://twistedoakstudios.com/blog/wp-content/ql-cache/quicklatex.com-cbf6ce6af0d1f7c31e179a8b77a39182_l3.png" class="ql-img-inline-formula " alt="length \leq \epsilon" title="Rendered by QuickLaTeX.com" height="17" width="81"> check improves the situation a lot, by preventing the evil compiler from rounding to zero for the division. On the other hand, it increases the size of the boundary where the compiler might flip the result from a unit vector to the zero vector or from the zero vector to a unit vector.</p><p>What I'm getting at is that floats flout the idea of being comparable. The idea that we can write a function that tells if an integer is equal to a float is, frankly, a little bit misguided. We'll either get false positives, when precision is lost after the check, or false negatives, when precision is temporarily lost (or purposefully removed) during the check.</p><p>So, in a sense, even the function specification I was implementing was wrong. No code can implement it perfectly. Compilers just don't treat floats that way.</p><h3>A Corrected Solution</h3><p>To correct the code I gave above, the three wrongs I listed (rounding, extra precision, impossible spec) need to be addressed.</p><p>The rounding issue is the easiest to fix. It only happens in one case (numbers near int.MaxValue), and can be caught with an explicit check. The other two issues will be fixed by slightly altering the spec.</p><p>To make the function independent of the whims of the compiler, I will avoid comparing against the overprecise-by-unknown-amount runtime value of the float. Instead, the function will compare against the nearest representable <a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE single precision float</a> (i.e. what you'd naively expect the function to do, before learning about extended precision). You can get that value, in many languages, by casting to a <code>volatile float</code> or storing in a <code>volatile float</code> field.</p><p>Applying both of these fixes (while still trying to avoid risky boundaries) gives a corrected solution in C#:</p><pre><code class="prettyprint">private static volatile float staticVolatileFloat;
private static float RemoveExtendedPrecision(float f) {
    // thread safe? what's that?
    staticVolatileFloat = f;
    return staticVolatileFloat;
}

public static bool EqualAfterRemovingExtendedPrecision(int i, float f) {
    f = RemoveExtendedPrecision(f);
    var iToF = RemoveExtendedPrecision((float)i);
    
    if (iToF == RemoveExtendedPrecision((float)int.MaxValue))
        return false; // rounded out of range, can't be represented
    if ((int)iToF != i)
        return false; // rounded to a different value, can't be represented
    
    // can be represented faithfully, naive equality check will work
    return iToF == f;
}</code></pre><p>(To be honest, I'm drawing a blank trying to think of natural uses for a function like <code>EqualAfterRemovingExtendedPrecision</code>.)</p><p>I tested that the function corresponds to what happens if you compare after casting both inputs to <code>double</code>, so <em>hopefully</em> it's correct now and forever. Maybe someone who knows even more about floating point horrors will correct that optimism.</p><p><em>Update</em>: If a different <a href="http://en.wikipedia.org/wiki/Ieee_float#Rounding_rules">valid IEEE rounding rule</a> is being used, (float)int.MaxValue might be rounded down instead of up. As a result, the "corrected" code would wrongly categorize the largest integer representable as a float as being not representable and create false negatives. Pessimism increased.</p><h3>Summary</h3><p>Floats are terrifying. Maybe not as terrifying as unicode, but pretty darn terrifying.</p><p>Remember: floats are fundamentally imprecise approximations of continuous quantities. Not only because of their representation, but because of how they are treated by compilers and CPUs. As a result, trying to force a precise discrete result out of a float (by rounding or doing a comparison) is just inherently risky. Prepare to compromise.</p><p>---</p><p>---</p><blockquote><h3><spacer></spacer></h3><span><em><br>Twisted Oak Studios offers consulting and development on high-tech interactive projects. Check out our <a href="http://twistedoakstudios.com/portfolio/">portfolio</a>, or <a href="mailto:contact@twistedoakstudios.com">Give us a shout</a> if you have anything you think some really rad engineers should help you with.<br></em></span></blockquote></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>