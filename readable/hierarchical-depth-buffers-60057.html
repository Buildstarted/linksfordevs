<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Hierarchical Depth Buffers - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Hierarchical Depth Buffers - linksfor.dev(s)"/>
    <meta property="og:description" content="Overview A hierarchical depth buffer is a multi-level depth (Z) buffer used as an acceleration structure for depth queries. As with normal texture mip chains, the dimensions of each level are generally successive power-of-2 fractions of the full-resolution buffer&#x2019;s dimensions. In this article I present two techniques for generating a hierarchical depth buffer from a full-resolution one.&#xA;First I show how to generate the full mip chain for a depth buffer in a way that preserves depth query accuracy in texture coordinate (or NDC) space even for non-power-of-2 depth buffer dimensions."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://miketuritzin.com/post/hierarchical-depth-buffers/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Hierarchical Depth Buffers</title>
<div class="readable">
        <h1>Hierarchical Depth Buffers</h1>
            <div>Reading time: 23-29 minutes</div>
        <div>Posted here: 25 Mar 2020</div>
        <p><a href="https://miketuritzin.com/post/hierarchical-depth-buffers/">https://miketuritzin.com/post/hierarchical-depth-buffers/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="content-container">
        
        <div id="post-content">
            
<p>A hierarchical depth buffer is a multi-level depth (Z) buffer used as an acceleration structure for depth queries. As with normal texture mip chains, the dimensions of each level are generally successive power-of-2 fractions of the full-resolution buffer’s dimensions. In this article I present two techniques for generating a hierarchical depth buffer from a full-resolution one.</p>
<p>First I show how to generate the full mip chain for a depth buffer in a way that preserves depth query accuracy in texture coordinate (or NDC) space even for non-power-of-2 depth buffer dimensions. (I’ve seen sample code online that doesn’t provide this guarantee, which makes accurately querying higher mip levels trickier.)</p>
<p>Second, for cases where only a single downsampled level is needed, I show how to generate this level using a single compute shader invocation that uses atomic operations in workgroup shared memory. For my application—where only 1/16th x 1/16th resolution (mip level 4) is needed—the compute shader technique is <strong>2–3x faster</strong> than the usual multi-pass mip chain downsampling approach.</p>

<p>Hierarchical depth (also known as Hi-Z) is a technique that comes up often in graphics. It’s used to accelerate occlusion culling (on the <a href="https://software.intel.com/en-us/articles/software-occlusion-culling">CPU</a> and <a href="http://rastergrid.com/blog/2010/10/hierarchical-z-map-based-occlusion-culling/">the</a> <a href="https://interplayoflight.wordpress.com/2017/11/15/experiments-in-gpu-based-occlusion-culling/">GPU</a>), <a href="http://bitsquid.blogspot.com/2017/08/notes-on-screen-space-hiz-tracing.html">screen-space reflections</a>, <a href="https://bartwronski.files.wordpress.com/2014/08/bwronski_volumetric_fog_siggraph2014.pdf">volumetric fog</a>, and more.</p>
<p>Additionally, it’s common for GPUs to <a href="https://pdfs.semanticscholar.org/ef95/d232b78146cc16e6212cc062fb622136f3f3.pdf">implement Hi-Z</a> as part of the rasterization pipeline. Fast Hi-Z lookups in on-chip caches allow full tiles of fragments to be skipped when they’re fully-occluded by previously-rendered primitives.</p>
<p>The general idea of Hi-Z is to accelerate depth queries by reading from reduced-resolution buffers. This is faster than reading from the full-res depth buffer for two reasons:</p>
<ol>
<li>A single texel (or just a few texels) of the reduced-res buffer can be used as a proxy for many at full-res.</li>
<li>The reduced-res buffer can be small enough to fit in cache, making all lookups (especially random-access ones) fast.</li>
</ol>
<p>The contents of the downsampled levels of a Hi-Z buffer vary depending on usage (e.g., whether the depth buffer is <a href="https://developer.nvidia.com/content/depth-precision-visualized">“reversed”</a> or not, and what types of queries need to be enabled). Generally a texel in a level of a Hi-Z buffer stores the <code>min</code> or <code>max</code> of all the texels it subsumes from the previous level. Sometimes both <code>min</code> and <code>max</code> values are stored. It’s rare to store a simple average (as is often done for texture mip levels), as average depths are rarely useful for the types of queries desired.</p>
<p>Hi-Z buffers are most commonly queried as an “early out” to avoid further processing—and particularly more-precise lookups in the full-res buffer. For example, if we store the <code>max</code> values for a non-reversed depth buffer (where larger depth values are further away), we can quickly determine if a particular screen-space position is definitely occluded by the depth buffer (if it’s Z coordinate is &gt; the (max) value stored at some higher (lower-res) level of the Hi-Z buffer).</p>
<p>Note the usage of the word “definitely” in the previous sentence: if the Z coordinate tested is &lt;= to the (max) value retrieved, then it may or may not be occluded. For some applications, full-res depth lookups may be needed for the “maybe” case; for others, they may not (e.g., if all that’s at stake is wasted computation, rather than correctness).</p>

<p>I encountered the need for Hi-Z usage when implementing <a href="https://miketuritzin.com/post/rendering-particles-with-compute-shaders/">compute shader particle rendering</a> in the engine for my VR aoo <a href="https://miketuritzin.com/particulate/">PARTICULATE</a>. Because this rendering technique forgoes fixed-function rasterization, it must do its own depth tests—one for each single-pixel particle. And because particles are not sorted in any way, access to the depth buffer is (in the worst case) effectively random.</p>
<p>Random-access lookups in a full-screen texture are a recipe for poor performance. To mitigate this cost, I first do the depth lookups in a 1x16th x 1x16th resolution downsampled depth buffer. This buffer contains <code>min</code> depth values, which allows the rendering compute shader to skip the full-res depth test for the vast majority of visible particles. (If a particle’s depth is &lt; the min depth stored in the reduced-res buffer, then we know that it’s definitely visible. If it’s &gt;= the min, then we must check the full-res depth buffer.)</p>
<p>This makes the depth test generally cheap for visible particles. (It’s more expensive for occluded particles, but that’s fine because they don’t incur the rendering cost, so they are already cheap.).</p>
<p>First doing reduced-res depth lookups (as just described) <strong>reduced particle rendering times by up to 35%</strong> compared to always doing full-res lookups, so Hi-Z is a big win for my application.</p>
<p>I will now discuss two techniques for generating a hierarchical depth buffer.</p>

<p>Many Hi-Z applications require the full depth buffer mip chain. Hi-Z occlusion culling, for instance, works by projecting a bounding volume into screen-space and using the projected size to choose the appropriate mip level (so that a fixed number of texels are accessed per occlusion test).</p>
<p>It’s generally straightforward to generate the mip chain from the full-res depth buffer—for each texel in level N, take the <code>max</code> (or <code>min</code>, or both) of the corresponding 4 texels in the previously-generated level N-1. Do successive passes of this (halving both dimensions each time) until the final 1x1 mip level is generated.</p>
<p>However, things are more complicated for depth buffers with non-power-of-2 dimensions. Because we’re often building Hi-Z for depth buffers of typical screen resolutions (which are rarely power-of-2), this is something that should be dealt with robustly.</p>
<p>Let’s first establish what the value in each texel of a depth buffer mip level is supposed to represent. For the purposes of this discussion, assume the mip chain stores <code>min</code> values. Depth lookups should use nearest-neighbor filtering, as interpolating <code>min</code> values is not useful and would also interfere with the intended hierarchical nature of the depth mip chain.</p>
<p>So when we get the value of a particular texel in mip level N, what does its value signify, precisely? It should be the <code>min</code> of all texels in the full-res depth buffer that occupy the same footprint in (normalized) texture coordinate space.</p>
<p>To put it another way, if a particular texture coordinate (in  <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">]</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex"> [0, 1]^2 </annotation></semantics></math></span></span></span>) maps (using nearest-neighbor filtering) to a particular texel in the full-res buffer, then that full-res texel must be considered for the <code>min</code> that is computed for the texel in each higher mip level that the same texture coordinate also maps to.</p>
<p>When this correspondence is guaranteed, we know that a lookup in the higher mip levels will never yield a depth value that is &gt; the value of the texel the same texture coordinate maps to in the full-res buffer (level 0). For a particular level N, this guarantee also holds true for all levels under that level (&lt; N).</p>
<p>For even level dimensions (which for power-of-2-dimensioned full-res buffers will be the case for every level until a dimension becomes 1), this is easy. In the one-dimensional case, for a texel in level N with index <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex"> i </annotation></semantics></math></span></span></span>, we need to consider the texels in level N-1 with indices <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi></mrow><annotation encoding="application/x-tex"> 2i </annotation></semantics></math></span></span></span> and <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> 2i + 1 </annotation></semantics></math></span></span></span> for the <code>min</code>. Thus, <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>N</mi></msub><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mtext>min</mtext><mo stretchy="false">(</mo><msub><mi>D</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">[</mo><mn>2</mn><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><msub><mi>D</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">[</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> D_{N}[i] = \text{min}(D_{N-1}[2i], D_{N-1}[2i + 1]) </annotation></semantics></math></span></span></span>. There is a direct 2-to-1 mapping between texels (and thus texture coordinate footprints) because the dimension of each level is exactly half of the previous.</p>
<figure>
    <img src="https://miketuritzin.com/post/hierarchical-depth-buffers/even-level-dimensions.svg" alt="Example for even level dimensions: The 6 texels in this level reduce to 3 in the next level up. The texture coordinate footprints of the (3) higher-level texels each overlap exactly 2 texels from the lower level. (Circles are texel centers, and the boxes around them represent texture coordinate footprints when using nearest-neighbor filtering.)" width="50%"> <figcaption>
            <p>Example for <strong>even</strong> level dimensions: The 6 texels in this level reduce to 3 in the next level up. The texture coordinate footprints of the (3) higher-level texels each overlap exactly 2 texels from the lower level. (Circles are texel centers, and the boxes around them represent texture coordinate footprints when using nearest-neighbor filtering.)</p>
        </figcaption>
</figure>

<p>For odd level dimensions (of which there will be at least one for non-power-of-2 full-res dimensions), things are more complicated. For a level N-1 of odd dimension <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>d</mi><mi>i</mi><mi>m</mi></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex"> \mathit{dim}_{N-1} </annotation></semantics></math></span></span></span>, the dimension of the next highest level (N) will be <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>d</mi><mi>i</mi><mi>m</mi></mrow><mi>N</mi></msub><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><msub><mrow><mi>d</mi><mi>i</mi><mi>m</mi></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex"> \mathit{dim}_{N} = \lfloor \frac{\mathit{dim}_{N-1}}{2} \rfloor </annotation></semantics></math></span></span></span>, which is <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo><mfrac><msub><mrow><mi>d</mi><mi>i</mi><mi>m</mi></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex"> \neq \frac{\mathit{dim}_{N-1}}{2} </annotation></semantics></math></span></span></span>.</p>
<p>What this means is that there is no longer a straightforward 2-to-1 mapping of texels in level N-1 to level N. Instead, the texture-coordinate-space footprint of each texel in level N overlaps the footprint of <em>3</em> texels in level N-1.</p>
<figure>
    <img src="https://miketuritzin.com/post/hierarchical-depth-buffers/odd-level-dimensions.svg" alt="Example for odd level dimensions: The 7 texels in this level reduce to 3 in the next level up. The texture coordinate footprints of the (3) higher-level texels each overlap the footprints of 3 texels from the lower level." width="58%"> <figcaption>
            <p>Example for <strong>odd</strong> level dimensions: The 7 texels in this level reduce to 3 in the next level up. The texture coordinate footprints of the (3) higher-level texels each overlap the footprints of 3 texels from the lower level.</p>
        </figcaption>
</figure>

<p>Thus, <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>N</mi></msub><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mtext>min</mtext><mo stretchy="false">(</mo><msub><mi>D</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">[</mo><mn>2</mn><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><msub><mi>D</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">[</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><msub><mi>D</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">[</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> D_{N}[i] = \text{min}(D_{N-1}[2i], D_{N-1}[2i + 1], D_{N-1}[2i + 2]) </annotation></semantics></math></span></span></span>. This means that the same texel in level N-1 sometimes contributes to the <code>min</code> computed for <em>2</em> texels in level N. This is necessary to maintain the correspondence earlier described.</p>
<p>The above description was done in one dimension for simplicity. For two dimensions, if both dimensions of level N-1 are even, a 2x2 texel region in level N-1 maps to a single texel in level N. If one dimension is odd, then either a 2x3 or 3x2 region in level N-1 maps to a single texel in level N. If <em>both</em> dimensions are odd, then the “corner” texel shared by the row and column extensions must also be considered—so a 3x3 region in level N-1 maps to a single texel in level N.</p>
<h2 id="example-code">Example code</h2>
<p>The following GLSL fragment shader code implements the algorithm just described. It should be run for each successive mip level, starting with level 1 (level 0 being full-res).</p>
<div><pre><code data-lang="glsl"><span>uniform</span> <span>sampler2D</span> <span>u_depthBuffer</span><span>;</span>
<span>uniform</span> <span>int</span> <span>u_previousLevel</span><span>;</span>
<span>uniform</span> <span>ivec2</span> <span>u_previousLevelDimensions</span><span>;</span>

<span>void</span> <span>main</span><span>()</span> <span>{</span>
	<span>ivec2</span> <span>thisLevelTexelCoord</span> <span>=</span> <span>ivec2</span><span>(</span><span>gl_FragCoord</span><span>);</span>
	<span>ivec2</span> <span>previousLevelBaseTexelCoord</span> <span>=</span> <span>2</span> <span>*</span> <span>thisLevelTexelCoord</span><span>;</span>

	<span>vec4</span> <span>depthTexelValues</span><span>;</span>
	<span>depthTexelValues</span><span>.</span><span>x</span> <span>=</span> <span>texelFetch</span><span>(</span><span>u_depthBuffer</span><span>,</span>
                                    <span>previousLevelBaseTexelCoord</span><span>,</span>
                                    <span>u_previousLevel</span><span>).</span><span>r</span><span>;</span>
	<span>depthTexelValues</span><span>.</span><span>y</span> <span>=</span> <span>texelFetch</span><span>(</span><span>u_depthBuffer</span><span>,</span>
                                    <span>previousLevelBaseTexelCoord</span> <span>+</span> <span>ivec2</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>),</span>
                                    <span>u_previousLevel</span><span>).</span><span>r</span><span>;</span>
	<span>depthTexelValues</span><span>.</span><span>z</span> <span>=</span> <span>texelFetch</span><span>(</span><span>u_depthBuffer</span><span>,</span>
                                    <span>previousLevelBaseTexelCoord</span> <span>+</span> <span>ivec2</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>),</span>
                                    <span>u_previousLevel</span><span>).</span><span>r</span><span>;</span>
	<span>depthTexelValues</span><span>.</span><span>w</span> <span>=</span> <span>texelFetch</span><span>(</span><span>u_depthBuffer</span><span>,</span>
                                    <span>previousLevelBaseTexelCoord</span> <span>+</span> <span>ivec2</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>),</span>
                                    <span>u_previousLevel</span><span>).</span><span>r</span><span>;</span>

	<span>float</span> <span>minDepth</span> <span>=</span> <span>min</span><span>(</span><span>min</span><span>(</span><span>depthTexelValues</span><span>.</span><span>x</span><span>,</span> <span>depthTexelValues</span><span>.</span><span>y</span><span>),</span>
                         <span>min</span><span>(</span><span>depthTexelValues</span><span>.</span><span>z</span><span>,</span> <span>depthTexelValues</span><span>.</span><span>w</span><span>));</span>

    <span>// Incorporate additional texels if the previous level's width or height (or both)
</span>
    <span>// are odd.
</span>
	<span>bool</span> <span>shouldIncludeExtraColumnFromPreviousLevel</span> <span>=</span> <span>((</span><span>u_previousLevelDimensions</span><span>.</span><span>x</span> <span>&amp;</span> <span>1</span><span>)</span> <span>!=</span> <span>0</span><span>);</span>
	<span>bool</span> <span>shouldIncludeExtraRowFromPreviousLevel</span> <span>=</span> <span>((</span><span>u_previousLevelDimensions</span><span>.</span><span>y</span> <span>&amp;</span> <span>1</span><span>)</span> <span>!=</span> <span>0</span><span>);</span>
	<span>if</span> <span>(</span><span>shouldIncludeExtraColumnFromPreviousLevel</span><span>)</span> <span>{</span>
		<span>vec2</span> <span>extraColumnTexelValues</span><span>;</span>
		<span>extraColumnTexelValues</span><span>.</span><span>x</span> <span>=</span> <span>texelFetch</span><span>(</span><span>u_depthBuffer</span><span>,</span>
                                              <span>previousLevelBaseTexelCoord</span> <span>+</span> <span>ivec2</span><span>(</span><span>2</span><span>,</span> <span>0</span><span>),</span>
                                              <span>u_previousLevel</span><span>).</span><span>r</span><span>;</span>
		<span>extraColumnTexelValues</span><span>.</span><span>y</span> <span>=</span> <span>texelFetch</span><span>(</span><span>u_depthBuffer</span><span>,</span>
                                              <span>previousLevelBaseTexelCoord</span> <span>+</span> <span>ivec2</span><span>(</span><span>2</span><span>,</span> <span>1</span><span>),</span>
                                              <span>u_previousLevel</span><span>).</span><span>r</span><span>;</span>

		<span>// In the case where the width and height are both odd, need to include the
</span>
        <span>// 'corner' value as well.
</span>
		<span>if</span> <span>(</span><span>shouldIncludeExtraRowFromPreviousLevel</span><span>)</span> <span>{</span>
			<span>float</span> <span>cornerTexelValue</span> <span>=</span> <span>texelFetch</span><span>(</span><span>u_depthBuffer</span><span>,</span>
                                                <span>previousLevelBaseTexelCoord</span> <span>+</span> <span>ivec2</span><span>(</span><span>2</span><span>,</span> <span>2</span><span>),</span>
                                                <span>u_previousLevel</span><span>).</span><span>r</span><span>;</span>
			<span>minDepth</span> <span>=</span> <span>min</span><span>(</span><span>minDepth</span><span>,</span> <span>cornerTexelValue</span><span>);</span>
		<span>}</span>
		<span>minDepth</span> <span>=</span> <span>min</span><span>(</span><span>minDepth</span><span>,</span> <span>min</span><span>(</span><span>extraColumnTexelValues</span><span>.</span><span>x</span><span>,</span> <span>extraColumnTexelValues</span><span>.</span><span>y</span><span>));</span>
	<span>}</span>
	<span>if</span> <span>(</span><span>shouldIncludeExtraRowFromPreviousLevel</span><span>)</span> <span>{</span>
		<span>vec2</span> <span>extraRowTexelValues</span><span>;</span>
		<span>extraRowTexelValues</span><span>.</span><span>x</span> <span>=</span> <span>texelFetch</span><span>(</span><span>u_depthBuffer</span><span>,</span>
                                           <span>previousLevelBaseTexelCoord</span> <span>+</span> <span>ivec2</span><span>(</span><span>0</span><span>,</span> <span>2</span><span>),</span>
                                           <span>u_previousLevel</span><span>).</span><span>r</span><span>;</span>
		<span>extraRowTexelValues</span><span>.</span><span>y</span> <span>=</span> <span>texelFetch</span><span>(</span><span>u_depthBuffer</span><span>,</span>
                                           <span>previousLevelBaseTexelCoord</span> <span>+</span> <span>ivec2</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>),</span>
                                           <span>u_previousLevel</span><span>).</span><span>r</span><span>;</span>
		<span>minDepth</span> <span>=</span> <span>min</span><span>(</span><span>minDepth</span><span>,</span> <span>min</span><span>(</span><span>extraRowTexelValues</span><span>.</span><span>x</span><span>,</span> <span>extraRowTexelValues</span><span>.</span><span>y</span><span>));</span>
	<span>}</span>

	<span>gl_FragDepth</span> <span>=</span> <span>minDepth</span><span>;</span>
<span>}</span>
</code></pre></div><h2 id="caveats-with-this-listing">Caveats with this listing</h2>
<p>For full-res depth buffers where one dimension is greater than 2x the magnitude of the other dimension, the calls to <code>texelFetch</code> may index out of the bounds of <code>u_depthBuffer</code>. (In such cases the smaller dimension will become 1 before the other does.) I wanted to use <code>texelFetch</code> (which takes integer coordinates) in this example to make what’s happening as clear as possible, and I have not personally encountered these especially wide/tall depth buffers. If you do, you can <code>clamp</code> the coordinates passed to <code>texelFetch</code> or use <code>texture</code> and normalized texture coordinates (with clamp-to-edge set for the sampler). When computing <code>min</code> or <code>max</code> its always fine to consider the same texel multiple times for the boundary cases.</p>
<p>Second, though the first 4 <code>texelFetch</code> calls could be replaced with a single <code>textureGather</code>, this complicates things (as <code>textureGather</code> can’t specify mip level), and I have not observed a speedup from <code>textureGather</code>.</p>
<h2 id="performance">Performance</h2>
<p>I used the above fragment shader to generate the full mip chain for the (two) per-eye depth buffers in my VR engine. For the test, each eye’s resolution was 1648x1776, which results in 10 additional downsampled mip levels (and thus 10 passes). The time to generate the full chain for both eyes together was 0.25 ms on an NVIDIA GTX 980 and 0.30 ms on an AMD R9 290.</p>
<figure>
    <img src="https://miketuritzin.com/post/hierarchical-depth-buffers/color-buffer.jpg" width="40%"> 
</figure>

<figure>
    <img src="https://miketuritzin.com/post/hierarchical-depth-buffers/mips-4-5-6.png" alt="Mip levels 4, 5, and 6 generated from the depth buffer corresponding to the color buffer shown above them. (Note that much of the scene is transparent and thus does not affect the depth buffer.) Mip level 4 is the first whose dimensions (103x111) are not evenly divisible by 2." width="80%"> <figcaption>
            <p>Mip levels 4, 5, and 6 generated from the depth buffer corresponding to the color buffer shown above them. (Note that much of the scene is transparent and thus does not affect the depth buffer.) Mip level 4 is the first whose dimensions (103x111) are not evenly divisible by 2.</p>
        </figcaption>
</figure>

<h2 id="an-alternative-method-of-generating-the-mip-chain">An alternative method of generating the mip chain</h2>
<p>The goal of the previously-described algorithm is to preserve depth query accuracy in texture coordinate (or NDC) space. For completeness (and because I forgo this guarantee for <a href="#technique-2">Technique 2</a> below), I want to show another method that I’ve seen presented (e.g., in <a href="http://rastergrid.com/blog/2010/10/hierarchical-z-map-based-occlusion-culling/">this article</a>).</p>
<p>Note that as with the previous method, this alternative method is designed to address non-power-of-2 full-res buffers (though of course it works on power-of-2 buffers as well).</p>
<p>In this alternative method, when downsampling a level with odd width (or height), instead of incorporating an additional column (or row) of texels from the previous (lower) level for every output texel, we do this only for the output’s highest-indexed “edge” texels. The only thing that changes in the above fragment shader is how <code>shouldIncludeExtraColumnFromPreviousLevel</code> and <code>shouldIncludeExtraRowFromPreviousLevel</code> are set:</p>
<div><pre><code data-lang="glsl"><span>// If the previous level's width is odd and this is the highest-indexed "edge" texel for
</span>
<span>// this level, incorporate the rightmost edge texels from the previous level. The same goes
</span>
<span>// for the height.
</span>
<span>bool</span> <span>shouldIncludeExtraColumnFromPreviousLevel</span> <span>=</span>
    <span>(</span><span>previousMipLevelBaseTexelCoords</span><span>.</span><span>x</span> <span>==</span> <span>u_previousLevelDimensions</span><span>.</span><span>x</span> <span>-</span> <span>3</span><span>);</span>
<span>bool</span> <span>shouldIncludeExtraRowFromPreviousLevel</span> <span>=</span>
    <span>(</span><span>previousMipLevelBaseTexelCoords</span><span>.</span><span>y</span> <span>==</span> <span>u_previousLevelDimensions</span><span>.</span><span>y</span> <span>-</span> <span>3</span><span>);</span>
</code></pre></div><p>The effect of this is that the highest-indexed edge texels become very “fat”, as each division by 2 of an odd dimension causes them to occupy a proportionally wider range of normalized texture coordinate space.</p>
<p>The downside of doing things this way is that it becomes trickier to query the depth of higher mip levels accurately. Instead of simply using normalized texture coordinates, it’s necessary to first determine the full-res texel that corresponds to these coordinates and then translate that texel’s coordinates to the corresponding ones in the mip level being queried.</p>
<p>The following code snippet does the translation from NDC space (<span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">]</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex"> [-1, 1]^2 </annotation></semantics></math></span></span></span>) to texel coordinates in mip level <code>higherMipLevel</code>:</p>
<div><pre><code data-lang="glsl"><span>vec2</span> <span>windowCoords</span> <span>=</span> <span>(</span><span>0.5</span> <span>*</span> <span>ndc</span><span>.</span><span>xy</span> <span>+</span> <span>vec2</span><span>(</span><span>0.5</span><span>))</span> <span>*</span> <span>textureSize</span><span>(</span><span>u_depthBuffer</span><span>,</span> <span>0</span><span>);</span>
<span>// Account for texel centers being halfway between integers.
</span>
<span>ivec2</span> <span>texelCoords</span> <span>=</span> <span>ivec2</span><span>(</span><span>round</span><span>(</span><span>windowCoords</span><span>.</span><span>xy</span> <span>-</span> <span>vec2</span><span>(</span><span>0.5</span><span>)));</span>
<span>ivec2</span> <span>higherMipLevelTexelCoords</span> <span>=</span>
    <span>min</span><span>(</span><span>texelCoords</span> <span>/</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>higherMipLevel</span><span>),</span>
        <span>textureSize</span><span>(</span><span>u_depthBuffer</span><span>,</span> <span>higherMipLevel</span><span>).</span><span>xy</span> <span>-</span> <span>ivec2</span><span>(</span><span>1</span><span>));</span>
</code></pre></div>
<p>Generating the full mip chain is pretty fast, but I was slightly bothered that my app was generating all those levels and then using only one of them (level 4). Besides this small inefficiency, I also wanted to see how much faster I could get things if I used a single compute shader dispatch to generate just the level I needed. (Note that my app could stop with level 4 when using the multi-pass fragment shader approach, so that’s what I use as the basis for comparison in the timings at the end of this section.)</p>
<p>A large fraction of Hi-Z use cases only need one downsampled depth level, so I believe this is a common scenario. I wrote a compute shader for my specific need (generating level 4, which is 1/16th x 1/16th resolution). Similar code could be used to generate different levels.</p>
<p>A compute shader is a good fit for this problem because it can take advantage of workgroup shared memory for inter-thread communication. Each workgroup is responsible for a single output texel (of the downsampled buffer), and the threads in the workgroup divide the work of <code>min</code>'ing the corresponding full-res texels, communicating their results through shared memory.</p>
<p>I tried two main compute-shader-based approaches. The first was to have each thread call <code>atomicMin</code> on a single shared memory variable.</p>
<p>Note that because it’s not possible (without vendor-specific extensions) to do atomic ops on non-integer values (and my depths are stored as <code>float</code>), a trick is necessary here. Because non-negative IEEE 754 floating point values maintain their ordering when their bits are interpreted as unsigned integers, we can use <code>floatBitsToUint</code> to “reinterpret cast” <code>float</code> depth values to <code>uint</code> before calling <code>atomicMin</code> (and then <code>uintBitsToFloat</code> on the final minimum <code>uint</code> value).</p>
<p>The most obvious <code>atomicMin</code> approach is to have 16x16 thread groups, where each thread fetches a single texel and <code>atomicMin</code>'s it with the shared memory value. I compared this to having smaller thread blocks (8x8, 4x8, 4x4, 2x4, 2x2), where each thread fetches a region of texels and computes its own local minimum before calling <code>atomicMin</code>.</p>
<p>The fastest of all these <code>atomicMin</code> approaches on both the NVIDIA and AMD GPUs I tested was 4x4 thread blocks (where each thread itself fetches a 4x4 region of texels). I am not entirely sure why this was the fastest, but perhaps it reflects a tradeoff between atomic op contention and independent thread computation. Note also that the 4x4 workgroup size uses only 16 threads per warp/wave (compared to the available 32 or 64), which is curious. The example code below implements this approach.</p>
<p>As an alternative to using <code>atomicMin</code>, I tried doing a parallel reduction using the techniques in <a href="http://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf">this commonly-cited NVIDIA presentation</a>. (The basic idea is to use a shared memory array of the same size as the number of threads in the workgroup and <span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> \log_{2} (n) </annotation></semantics></math></span></span></span> passes to successively <code>min</code> together the per-thread minimums until the final workgroup-wide minimum is obtained.)</p>
<p>I tried this approach with all the same workgroup dimensions as I tried for the <code>atomicMin</code> approach. Even with all the optimizations in the NVIDIA presentation linked above, the parallel reduction approach was slightly slower (by a single-digit percentage on both GPUs) than the <code>atomicMin</code> approach I had arrived at. The <code>atomicMin</code> approach was also substantially simpler code-wise.</p>
<h2 id="example-code-1">Example code</h2>
<p>For this method, it’s simplest if don’t try to maintain the correspondence in normalized texture coordinate space between reduced- and full-res texels. It’s easy to convert from full-res texel coordinates to reduced-res texel coordinates:</p>
<div><pre><code data-lang="glsl"><span>ivec2</span> <span>reducedResTexelCoords</span> <span>=</span> <span>texelCoords</span> <span>/</span> <span>ivec2</span><span>(</span><span>downscalingFactor</span><span>);</span>
</code></pre></div><p>For my usage (generating the equivalent of mip level 4), <code>downscalingFactor</code> is 16.</p>
<p>As mentioned above, this GLSL compute shader implements the <code>atomicMin</code> approach with 4x4 workgroup size and each thread fetching a 4x4 texel region from the full-res buffer. The resulting downsampled <code>min</code> depth buffer is 1/16th x 1/16th the size of the full-res one (rounded up when the full-res dimensions aren’t evenly divisible by 16).</p>
<div><pre><code data-lang="glsl"><span>uniform</span> <span>sampler2D</span> <span>u_inputDepthBuffer</span><span>;</span>
<span>uniform</span> <span>restrict</span> <span>writeonly</span> <span>image2DArray</span> <span>u_outputDownsampledMinDepthBufferImage</span><span>;</span>
<span>// The dimension in normalized texture coordinate space of a single texel in
</span>
<span>// u_inputDepthBuffer.
</span>
<span>uniform</span> <span>vec2</span> <span>u_texelDimensions</span><span>;</span>

<span>// Resulting image is 1/16th x 1/16th resolution, but we fetch 4x4 texels per thread, hence
</span>
<span>// the divisions by 4 here.
</span>
<span>layout</span><span>(</span><span>local_size_x</span> <span>=</span> <span>16</span><span>/</span><span>4</span><span>,</span> <span>local_size_y</span> <span>=</span> <span>16</span><span>/</span><span>4</span><span>,</span> <span>local_size_z</span> <span>=</span> <span>1</span><span>)</span> <span>in</span><span>;</span>

<span>// This is stored as uint because atomicMin only works on integer types. Luckily
</span>
<span>// (non-negative) floats maintain their order when their bits are interpreted as uint (using
</span>
<span>// floatBitsToUint).
</span>
<span>shared</span> <span>uint</span> <span>s_workgroupMinDepthEncodedAsUint</span><span>;</span>

<span>void</span> <span>main</span><span>()</span> <span>{</span>
	<span>if</span> <span>(</span><span>gl_LocalInvocationIndex</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>// Initialize to 1.0 (max depth) before performing atomicMin's.
</span>
		<span>s_workgroupMinDepthEncodedAsUint</span> <span>=</span> <span>floatBitsToUint</span><span>(</span><span>1.0</span><span>);</span>
	<span>}</span>

	<span>memoryBarrierShared</span><span>();</span>
	<span>barrier</span><span>();</span>

	<span>// Fetch a 4x4 texel region per thread with 4 calls to textureGather. 'gatherCoords'
</span>
    <span>// are set up to be equidistant from the centers of the 4 texels being gathered (which
</span>
    <span>// puts them on integer values). In my tests textureGather was not faster than 
</span>
    <span>// individually fetching each texel - I use it here only for conciseness.
</span>
    <span>//
</span>
    <span>// Note that in the case of the full-res depth buffer's dimensions not being evenly 
</span>
    <span>// divisible by the downscaling factor (16), these textureGather's may try to fetch 
</span>
    <span>// out-of-bounds coordinates - that's fine as long as the texture sampler is set to 
</span>
    <span>// clamp-to-edge, as redundant values don't affect the resulting min.
</span>

	<span>uvec2</span> <span>baseTexelCoords</span> <span>=</span> <span>4</span> <span>*</span> <span>gl_GlobalInvocationID</span><span>.</span><span>xy</span><span>;</span>
	<span>vec2</span> <span>gatherCoords1</span> <span>=</span> <span>(</span><span>baseTexelCoords</span> <span>+</span> <span>uvec2</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>))</span> <span>*</span> <span>u_texelDimensions</span><span>;</span>
	<span>vec2</span> <span>gatherCoords2</span> <span>=</span> <span>(</span><span>baseTexelCoords</span> <span>+</span> <span>uvec2</span><span>(</span><span>3</span><span>,</span> <span>1</span><span>))</span> <span>*</span> <span>u_texelDimensions</span><span>;</span>
	<span>vec2</span> <span>gatherCoords3</span> <span>=</span> <span>(</span><span>baseTexelCoords</span> <span>+</span> <span>uvec2</span><span>(</span><span>1</span><span>,</span> <span>3</span><span>))</span> <span>*</span> <span>u_texelDimensions</span><span>;</span>
	<span>vec2</span> <span>gatherCoords4</span> <span>=</span> <span>(</span><span>baseTexelCoords</span> <span>+</span> <span>uvec2</span><span>(</span><span>3</span><span>,</span> <span>3</span><span>))</span> <span>*</span> <span>u_texelDimensions</span><span>;</span>

	<span>vec4</span> <span>gatheredTexelValues1</span> <span>=</span> <span>textureGather</span><span>(</span><span>u_inputDepthBuffer</span><span>,</span> <span>gatherCoords1</span><span>);</span>
	<span>vec4</span> <span>gatheredTexelValues2</span> <span>=</span> <span>textureGather</span><span>(</span><span>u_inputDepthBuffer</span><span>,</span> <span>gatherCoords2</span><span>);</span>
	<span>vec4</span> <span>gatheredTexelValues3</span> <span>=</span> <span>textureGather</span><span>(</span><span>u_inputDepthBuffer</span><span>,</span> <span>gatherCoords3</span><span>);</span>
	<span>vec4</span> <span>gatheredTexelValues4</span> <span>=</span> <span>textureGather</span><span>(</span><span>u_inputDepthBuffer</span><span>,</span> <span>gatherCoords4</span><span>);</span>

	<span>// Now find the min across the 4x4 region fetched, and apply that to the workgroup min
</span>
    <span>// using atomicMin.
</span>
	<span>vec4</span> <span>gatheredTexelMins</span> <span>=</span> <span>min</span><span>(</span><span>min</span><span>(</span><span>gatheredTexelValues1</span><span>,</span> <span>gatheredTexelValues2</span><span>),</span>
                                 <span>min</span><span>(</span><span>gatheredTexelValues3</span><span>,</span> <span>gatheredTexelValues4</span><span>));</span>
	<span>float</span> <span>finalMin</span> <span>=</span> <span>min</span><span>(</span><span>min</span><span>(</span><span>gatheredTexelMins</span><span>.</span><span>x</span><span>,</span> <span>gatheredTexelMins</span><span>.</span><span>y</span><span>),</span>
                         <span>min</span><span>(</span><span>gatheredTexelMins</span><span>.</span><span>z</span><span>,</span> <span>gatheredTexelMins</span><span>.</span><span>w</span><span>));</span>
	<span>atomicMin</span><span>(</span><span>s_workgroupMinDepthEncodedAsUint</span><span>,</span> <span>floatBitsToUint</span><span>(</span><span>finalMin</span><span>));</span>

	<span>memoryBarrierShared</span><span>();</span>
	<span>barrier</span><span>();</span>

    <span>// Thread 0 writes workgroup-wide min to image.
</span>
	<span>if</span> <span>(</span><span>gl_LocalInvocationIndex</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
		<span>float</span> <span>workgroupMinDepth</span> <span>=</span> <span>uintBitsToFloat</span><span>(</span><span>s_workgroupMinDepthEncodedAsUint</span><span>);</span>

		<span>imageStore</span><span>(</span><span>u_outputDownsampledMinDepthBufferImage</span><span>,</span>
		           <span>ivec2</span><span>(</span><span>gl_WorkGroupID</span><span>.</span><span>xy</span><span>),</span>
                   <span>// imageStore can only be passed vec4, but only a float is stored.
</span>
				   <span>vec4</span><span>(</span><span>workgroupMinDepth</span><span>));</span>
	<span>}</span>
<span>}</span>
</code></pre></div><h2 id="performance-1">Performance</h2>
<p>I used the above compute shader to process the same full-res depth buffer dimensions as I used when generating the full mip chain (two 1648x1776 eye buffers). It ran in 0.12 ms on an NVIDIA GTX 980 and 0.08 ms on an AMD R9 290. Compared to the time to generate just mip levels 1–4 (0.22 ms on NVIDIA, 0.25 ms on AMD), the compute shader approach was <strong>87% faster on the NVIDIA GPU</strong> and <strong>197% faster on the AMD one</strong>.</p>
<p>Granted this is not a huge speedup in an absolute sense, but every 0.1 ms counts, especially for VR :)</p>

        </div>
        
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>