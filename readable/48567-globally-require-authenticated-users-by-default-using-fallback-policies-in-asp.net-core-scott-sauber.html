<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Globally Require Authenticated Users By Default Using Fallback Policies in ASP.NET Core &#x2013; Scott Sauber -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Globally Require Authenticated Users By Default Using Fallback Policies in ASP.NET Core ‚Äì Scott Sauber</h1><div><div class="entry-content"><h2><span>tldr;</span></h2><p>You can use Fallback Policies in ASP.NET Core 3.0+ to require an Authenticated User by default. Conceptually, you can think of this as adding an <code>[Authorize]</code> attribute by default to every single Controller and Razor Page ONLY WHEN no other attribute is specified on a Controller or Razor Page (like <code>[AllowAnonymous]</code> or <code>[Authorize(PolicyName="PolicyName")]</code>).&nbsp; See lines 9-11 below.</p><h2></h2><h2><span>A Quick Lap Around the [Authorize] and [AllowAnonymous] Attributes</span></h2><p>In ASP.NET Core (and even previously in ASP.NET), we‚Äôve had the ability to add a <code>[Authorize]</code> attribute to a resource (such as a Controller or Razor Page) in order to tell ASP.NET Core not to let a user access that resource unless they are authenticated.</p><p>The <code>[Authorize]</code> attribute can also take a PolicyName parameter that tells it what <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies">Authorization Policy</a> to execute.&nbsp; The Policy below says only Admins can access this page.</p><p>You can follow <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies">this link</a> to learn more how to set up policies in ASP.NET Core and how to enforce your own custom rules (such as what defines an Admin).</p><p>By default, if you do not add an <code>[Authorize]</code> attribute, then the resource will <span><strong>not</strong></span> be secured and will be accessible to unauthenticated users.&nbsp; A resource can also be accessible to unauthenticated users by explicitly adding a <code>[AllowAnonymous]</code> attribute.</p><blockquote><p><strong>Word of Caution:</strong> Adding the <code>[AllowAnonymous]</code>attribute bypasses all Authorization, and short-circuits out of the Authorization pipeline, even if Authorization is set further up the stack.</p></blockquote><h2><span>The Problem ‚Äì Having to remember to add [Authorize] attributes everywhere</span></h2><p>When you create a new Controller or Razor Page in ASP.NET Core, by default the resource will be accessible to anyone, because there is no <code>[Authorize]</code> attribute.&nbsp; This is a problem if you‚Äôre creating a site where a majority of the site is protected by some sort of authentication.&nbsp; It is really easy to forget to add an <code>[Authorize]</code> attribute which could open up your application to a security vulnerability, and leave you with a potential‚Ä¶ let‚Äôs call it a ‚Äúresume updating event.‚Äù üôÇ</p><h2><span>What are Fallback Policies?</span></h2><p>ASP.NET Core 3.0 turned on <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1#endpoint-routing" target="_blank" rel="noopener">Endpoint Routing</a> by default, which was a way to get Routing information out of being tightly coupled to MVC and make Routing more global to the entire stack (such as Middleware).&nbsp; The 3.0 release introduced the concept of Fallback Policies with Endpoint Routing.</p><p><strong>A Fallback Policy means that if no other policy or attribute is specified on a Controller or Razor Page, the Authorization middleware will use the Fallback Policy.</strong>&nbsp; Therefore, if you do not add any other attribute (such as <code>[AllowAnonymous]</code> or <code>[Authorize(PolicyName="PolicyName")]</code>, then ASP.NET Core will use the Fallback Policy.</p><h2><span>The Solution ‚Äì Using a Fallback Policy to require authentication by default</span></h2><p>So by leveraging a Fallback Policy, we can specify that a user must always be authenticated for every Controller or Razor Page in our application.&nbsp; You can wire this up under <code>ConfigureServices</code> via the <code>AuthorizationOptions</code> in <code>services.AddAuthorization</code>.&nbsp; &nbsp;See lines 9-11 below:</p><p>Conceptually, you can think of this as adding an <code>[Authorize]</code> attribute by default to every single Controller and Razor Page ONLY WHEN no other attribute is specified on a Controller or Razor Page (like <code>[AllowAnonymous]</code> or <code>[Authorize(PolicyName="PolicyName")]</code>).</p><p>Of course, you could also take this one step further, by having your Fallback Policy be a policy that requires certain claims instead of just being authenticated.&nbsp; The choice is up to you!</p><h2><span>What do we gain by doing this?</span></h2><ol><li><strong>A</strong><strong>more secure default.&nbsp;</strong> A developer doesn‚Äôt have to remember to add an <code>[Authorize]</code> attribute to every Controller or Razor Page.</li><li><strong>Less boilerplate.&nbsp;</strong> Every Controller and Razor Page requiring authentication has one less line of boilerplate code to worry about.</li><li><strong>You don‚Äôt give up any flexibility.</strong><ol><li>If a Controller or Razor Page is supposed to be public to unauthenticated users (such as a Login page or Forgot Password page), then you can still add a <code>[AllowAnonymous]</code> attribute and the Fallback Policy is bypassed.</li><li>If a Controller or Razor Page needs a specific policy, you can still add an Authorize attribute with a custom policy name.&nbsp; That will take precedence over the Fallback Policy such as <code>[Authorize(PolicyName="PolicyName")]</code>.</li></ol></li></ol><h2><span>Default Policy vs. Fallback Policy</span></h2><p>You might get confused when seeing that there‚Äôs also a ‚ÄúDefault Policy‚Äù in addition to Fallback Policies (or at least I did).&nbsp; In my head I thought ‚Äúoh the Fallback Policy is kind of like the default policy that runs‚Ä¶ but wait‚Ä¶ what‚Äôs a Default Policy then?‚Äù</p><p>The Default Policy is the policy that gets evaluated when authorization is required, but no explicit policy is specified.&nbsp; In other words, it‚Äôs the policy that evaluates when you add an <code>[Authorize]</code> attribute without any PolicyName.&nbsp; Out of the box, the Default Policy is set to requiring Authenticated Users.</p><p>A Fallback Policy, on the other hand, is the policy that gets evaluated if no other policy is specified (such as when no <code>[AllowAnonymous]</code> or <code>[Authorize]</code> attribute exists on a Controller or Razor Page)</p><h2><span>The Old Solution in ASP.NET Core 2.x</span></h2><h2><span>A common solution to this problem in ASP.NET Core 2.x was to add a Global Filter to MVC such as lines 10-13 below:</span></h2><h2><span>Conclusion</span></h2><p>In my opinion, the new way using a Fallback Policy makes a lot more sense. It keeps everything inside the Authorization configuration and doesn‚Äôt sprinkle Authorization logic into MVC Filters.&nbsp; The only thing that‚Äôs a little goofy is the naming between a Default Policy and Fallback Policy, but once you learn that nuance, the naming makes sense.</p><p>In a future post, I‚Äôll go over other tips and tricks for leveraging the ASP.NET Core authorization system.&nbsp; Stay tuned.</p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>