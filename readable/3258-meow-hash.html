<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Meow Hash -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Meow Hash</h1><div><div class="q"><div class="r"><p class="readability-styled" style="display: inline;">The Meow hash is a high-speed hash function named after the character Meow in </p><a class="A" href="https://meowtheinfinite.com/">Meow the Infinite</a><p class="readability-styled" style="display: inline;">.  We developed the hash function at </p><a class="A" href="https://mollyrocket.com/">Molly Rocket</a><p class="readability-styled" style="display: inline;"> for use in the asset pipeline of </p><a class="A" href="https://molly1935.com/">1935</a><p class="readability-styled" style="display: inline;">.
</p><p class="readability-styled" style="display: inline;">Because we have to process hundreds of gigabytes of art assets to build game packages, we wanted a fast, non-cryptographic hash for use in change detection and deduplication.  We had been using a cryptographic hash (</p><a class="A" href="https://en.m.wikipedia.org/wiki/SHA-1">SHA-1</a><p class="readability-styled" style="display: inline;">), but it was unnecessarily slowing things down.
</p><p class="readability-styled" style="display: inline;">To our surprise, we found a lack of published, well-optimized, large-data hash functions.  Most hash work seems to focus on small input sizes (for things like dictionary lookup) or on cryptographic quality.  We wanted the fastest possible hash that would be collision-free in practice (like SHA-1 was), and we didn’t need any cryptograhic security.
</p><p class="readability-styled" style="display: inline;">We ended up creating Meow to fill this niche.
</p></div><div class="r"><p class="readability-styled" style="display: inline;">It’s the fastest hash function we know of, and we have benchmarked all the ones we could find.  On modern Intel x64 CPUs, it hashes 16 bytes </p><i>per cycle</i><p class="readability-styled" style="display: inline;"> single-threaded.  This means in cache it can hash at a rate of 64 </p><i>gigabytes</i><p class="readability-styled" style="display: inline;"> per second on a 4.2gHz machine.  Out of cache, it hashes at whatever speed your main memory bus can provide to a single core, since that is usually the limiting factor on modern x64 CPUs.
</p><p class="readability-styled" style="display: inline;">It has also now been tuned to be the fastest hash on </p><i>small</i><p class="readability-styled" style="display: inline;"> inputs, too.  Despite the fact that it is a full 128-bit hash, it </p><i>still outperforms</i><p class="readability-styled" style="display: inline;"> “fast” 64-bit hashes across all input sizes.  So whether you have data buffers of a few bytes or a few gigabytes, Meow is the fastest hash available.
</p></div><div class="r"><p class="readability-styled" style="display: inline;">The Meow hash is not designed for cryptography and therefore we make no claims about its security.  Assume it is </p><i>completely insecure</i><p class="readability-styled" style="display: inline;">.
</p><p class="readability-styled" style="display: inline;">That said, it is extremely robust for its designed purpose.  It cleanly passes every test in </p><a class="A" href="https://github.com/aappleby/smhasher">smhasher</a><p class="readability-styled" style="display: inline;"> and has produced no collisions on our large datasets as yet.  Also, unlike other “fast hashes”, it is not a small 32-bit or 64-bit hash.  It produces a full 128 bits of usable hash every time.
</p><p class="readability-styled" style="display: inline;">The Meow hash also passes </p><a class="A" href="https://github.com/aappleby/smhasher">smhasher</a><p class="readability-styled" style="display: inline;"> cleanly at every truncation level down to 32 bits, so you can safely truncate a Meow hash value to the size you want to store.  Both 32 bit and 64 bit truncations have been tested themselves and separate hashes, and pass smhasher cleanly.
</p></div></div><div class="q"><div class="r"><p class="readability-styled" style="display: inline;">It is a very basic license and should make it easy to use.
</p></div><div class="r"><p class="readability-styled" style="display: inline;">The </p><a class="A" href="https://github.com/cmuratori/meow_hash">source code</a><p class="readability-styled" style="display: inline;"> includes a number of files, but only </p><i>meow_<wbr>hash.h</i><p class="readability-styled" style="display: inline;"> is actually necessary.  The rest of the files may or may not be necessary depending on how you want to use Meow.  Currently, the distribution supports x64, ARM, and vanilla C implementations.
</p><p class="readability-styled" style="display: inline;">To use the Meow hash in a program, just </p><i>#include</i><p class="readability-styled" style="display: inline;"> the headers then call it:
</p></div></div><div class="q"><div class="r"><p class="readability-styled" style="display: inline;">Note that there are two headers to include: </p><i>meow_<wbr>intrinsics.h</i><p class="readability-styled" style="display: inline;"> for the platform support, and </p><i>meow_<wbr>hash.h</i><p class="readability-styled" style="display: inline;"> for the function itself.  This is intentional &nbsp;—&nbsp; you </p><i>do not</i><p class="readability-styled" style="display: inline;"> need to include </p><i>meow_<wbr>intrinsics.h</i><p class="readability-styled" style="display: inline;"> if you don’t want to!  Instead, you can choose to make your own set of </p><i>#define</i><p class="readability-styled" style="display: inline;">’s before including </p><i>meow_<wbr>hash.h</i><p class="readability-styled" style="display: inline;">, so that you can provide the foundation pieces for Meow to use.  This can be very useful if you are trying to integrate Meow into a codebase that already has its own conventions for 128-bit SIMD.
</p></div><div class="r"><p class="readability-styled" style="display: inline;">The Meow hash was designed for very specific scenarios.  There are two very good reasons </p><i>not</i><p class="readability-styled" style="display: inline;"> to use it:
</p><table class="W"><tbody><tr class="X"><td class="Y">•&nbsp;</td><td><p>Never use the Meow hash for anything involving security unless you are a cryptographer and know exactly what you are doing.  The Meow hash was not designed for cryptography and has no cryptographic security proofs or analysis whatsoever.</p></td></tr></tbody></table><table class="W"><tbody><tr class="X"><td class="Y">•&nbsp;</td><td><p>Don’t base a system on the Meow hash if your primary deployment target uses a non-AES-capable CPU.  Modern ARM and x64 cores usually have the AES instructions necessary to implement a Meow hash at high speed, but other CPUs might not.  CPUs that <i>don’t</i> have AES instructions will be signficantly slower at running the Meow hash, so you <i>do not</i> want to use it in deployments that expect to use primarily non-AES-enabled CPU cores.</p></td></tr></tbody></table></div><div class="D"><p class="readability-styled" style="display: inline;">Building the entire Meow suite
</p></div><div class="r"><p class="readability-styled" style="display: inline;">If you download the entire Meow repository, you can build it all using simple batch files on both Windows and Linux.  From the root of the repository, on Windows:
</p></div></div><div class="q"><div class="r"><p class="readability-styled" style="display: inline;">Both will build several executables for testing.  On Linux, there will only be a CLANG build, and it will be placed in a </p><i>build</i><p class="readability-styled" style="display: inline;"> directory.  On Windows, it will attempt to build with cl into </p><i>build_<wbr>msvc</i><p class="readability-styled" style="display: inline;"> and CLANG into </p><i>build_<wbr>clang</i><p class="readability-styled" style="display: inline;">, depending on which compilers you have installed.
</p></div><div class="r"><p class="readability-styled" style="display: inline;">The executable </p><i>meow_<wbr>example.exe</i><p class="readability-styled" style="display: inline;"> (built from </p><i>meow_<wbr>example.cpp</i><p class="readability-styled" style="display: inline;">) is an example of the basic ways you might use a Meow hash.  You can run it from the command line with no arguments to have it hash a random buffer, with one argument to print the hash of a file, and with two arguments to have it compare the hashes of two files.  </p><i>meow_<wbr>example.cpp</i><p class="readability-styled" style="display: inline;"> is designed to be very simple, and should provide an easy way to see how Meow hashes are used in practice.
</p></div><div class="r"><p class="readability-styled" style="display: inline;">The executable </p><i>meow_<wbr>test.exe</i><p class="readability-styled" style="display: inline;"> will test the Meow hash build for obvious defects.  It’s not a replacement for serious testing (like </p><a class="A" href="https://github.com/aappleby/smhasher">smhasher</a><p class="readability-styled" style="display: inline;">), but it will give you a quick sanity check that you haven’t done something horribly wrong with the build.
</p></div></div><div class="q"><div class="r"><p class="readability-styled" style="display: inline;">Hash collisions are subject to the </p><a class="A" href="https://en.wikipedia.org/wiki/Birthday_problem">birthday paradox</a><p class="readability-styled" style="display: inline;">, which means that once you process enough hashes, collisions are </p><i>expected</i><p class="readability-styled" style="display: inline;"> for various hash truncation levels.  You should expect to see Meow32 collisions once you reach 16 bits worth of files (32-64 thousand files), Meow64 collisions once you get 32 bits worth of files (2-4 billion files), and Meow128 collisions once… well… you really shouldn’t be able to amass enough files for that!  So if you find a collision with Meow128, please report it to us on the </p><a class="A" href="https://github.com/cmuratori/meow_hash">GitHub</a><p class="readability-styled" style="display: inline;">!  We may need to look into it in more detail.
</p></div><div class="r"><p class="readability-styled" style="display: inline;">You can also use Meow hash via a streaming API and a vanilla C API for compatibility.  These are defined in </p><i>meow_<wbr>more.h</i><p class="readability-styled" style="display: inline;">.  To use the streaming API:
</p></div></div><div class="q"><div class="r"><p class="readability-styled" style="display: inline;">Generally speaking, if you are trying to use the C version for compatibility purposes, you will need to do some kind of CPU detection appropriate to your platform and then pick whether to call </p><i>MeowHash_<wbr>Accelerated</i><p class="readability-styled" style="display: inline;"> or </p><i>MeowHash_<wbr>C</i><p class="readability-styled" style="display: inline;">.  The proper way to detect this varies from platform to platform, and is outside the scope of Meow’s implementation, so it is expected that you will implement that part of the code yourself during the startup of your application.  An example implementation using try/catch is given in </p><i>meow_<wbr>more_<wbr>example.cpp</i><p class="readability-styled" style="display: inline;">.
</p></div><div class="r"><p class="readability-styled" style="display: inline;">The Meow hash is still in alpha form.  We would love to get feedback on people who can test it on their datasets, especially if you find any collisions or other problems with the hash quality.  Please </p><a class="A" href="https://github.com/cmuratori/meow_hash">post issues on the GitHub</a><p class="readability-styled" style="display: inline;"> as you find them!
</p></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>