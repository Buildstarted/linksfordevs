<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Try the new System.Text.Json APIs -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Try the new System.Text.Json APIs</h1><div><div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://secure.gravatar.com/avatar/d8c7f4505134c363a71463dcf46f8854?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 photo avatar-default"><p>Immo</p></div></div></div><p>June 13th, 2019</p><p>For .NET Core 3.0, we’re shipping a brand new namespace called&nbsp;<a href="https://nuget.org/packages/System.Text.Json" rel="nofollow">System.Text.Json</a>&nbsp;with support for a reader/writer, a document object model (DOM), and a serializer. In this blog post, I’m telling you why we built it, how it works, and how you can try it.</p><p>We also have a video:</p><h2><a id="user-content-getting-the-new-json-library" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#getting-the-new-json-library" aria-hidden="true"></a>Getting the new JSON library</h2><ul><li><strong>If you’re targeting .NET Core</strong>. Install the latest version of the&nbsp;<a href="https://dotnet.microsoft.com/download/dotnet-core/3.0" rel="nofollow">.NET Core 3.0 preview</a>. This gives you the new JSON library and the ASP.NET Core integration.</li><li><strong>If you’re targeting .NET Standard or .NET Framework</strong>. Install the&nbsp;<a href="https://nuget.org/packages/System.Text.Json" rel="nofollow">System.Text.Json</a>&nbsp;NuGet package (make sure to include previews and install version 4.6.0-preview6.19303.8 or higher). In order to get the integration with ASP.NET Core, you must target .NET Core 3.0.</li></ul><h2><a id="user-content-the-future-of-json-in-net-core-30" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#the-future-of-json-in-net-core-30" aria-hidden="true"></a>The future of JSON in .NET Core 3.0</h2><p>JSON has become an essential part of virtually all modern .NET applications and in many cases even surpassed the usage of XML. However, .NET hasn’t had a (great) built-in way to deal with JSON. Instead, we’ve relied on Json.NET until now, which continues to serve the .NET ecosystem well.</p><p>We’ve decided that we needed to build a new JSON library:</p><ul><li><strong>Provide high-performance JSON APIs</strong>. We needed a new set of JSON APIs that are highly tuned for performance by using&nbsp;<code>Span&lt;T&gt;</code>&nbsp;and can process UTF-8 directly without having to transcode to UTF-16&nbsp;<code>string</code>&nbsp;instances. Both aspects are critical for ASP.NET Core, where throughput is a key requirement. We considered contributing changes to Json.NET, but this was deemed close to impossible without either breaking existing Json.NET customers or compromising on the performance we could achieve. With&nbsp;<code>System.Text.Json</code>, we were able to gain 1.3x – 5x speed up, depending on the scenario (see below for more details). And we believe we can still squeeze out more.</li><li><strong>Remove Json.NET dependency from ASP.NET Core</strong>. Today, ASP.NET Core has a dependency on Json.NET. While this provides a tight integration between ASP.NET Core and Json.NET, it also means the version of Json.NET is dictated by the underlying platform. However, Json.NET is frequently updated and application developers often want to — or even have to — use a specific version. Thus, we want to remove the Json.NET dependency from ASP.NET Core 3.0, so that customers can choose which version to use, without fearing they might accidentally break the underlying platform.</li><li><strong>Provide an ASP.NET Core integration package for Json.NET</strong>. Json.NET has basically become the Swiss Army knife of JSON processing in .NET. It provides many options and facilities that allow customers to handle their JSON needs with ease. We don’t want to compromise on the Json.NET support customers are getting today. For example, the ability to configure the JSON serialization in ASP.NET Core via the&nbsp;<code>AddJsonOptions</code>&nbsp;extension method. Thus, we want to provide the Json.NET integration for ASP.NET Core as a NuGet package that developers can optionally install, so they get all the bells and whistles they get from Json.NET today. The other part of this work item is to ensure we have the right extension points so that other parties can provide similar integration packages for their JSON library of choice.</li></ul><p>For more details on the motivation and how it relates to Json.NET, take a look at&nbsp;<a href="https://github.com/dotnet/corefx/issues/33115">the announcement</a>&nbsp;we made back in October.</p><h2><a id="user-content-using-systemtextjson-directly" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#using-systemtextjson-directly" aria-hidden="true"></a>Using System.Text.Json directly</h2><p>For all the samples, make sure you import the following two namespaces:</p><h3><a id="user-content-using-the-serializer" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#using-the-serializer" aria-hidden="true"></a>Using the serializer</h3><p>The&nbsp;<code>System.Text.Json</code>&nbsp;serializer can read and write JSON asynchronously and is optimized for UTF-8 text, making it ideal for REST API and back-end applications.</p><p>By default, we produce minified JSON. If you want to produce something that is human readable, you can pass in an instance of&nbsp;<code>JsonSerializerOptions</code>&nbsp;to the serializer. This is also the way you configure other settings, such as handling of comments, trailing commas, and naming policies.</p><p>Deserialization works similarly:</p><p>We also support asynchronous serialization and deserialization:</p><p>You can also use custom attributes to control serialization behavior, for example, ignoring properties and specifying the name of the property in the JSON:</p><p>We currently don’t have support for F# specific behaviors (such as discriminated unions and record types), but we&nbsp;<a href="https://github.com/dotnet/corefx/issues/38348">plan on adding this in the future</a>.</p><h3><a id="user-content-using-the-dom" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#using-the-dom" aria-hidden="true"></a>Using the DOM</h3><p>Sometimes you don’t want to deserialize a JSON payload, but you still want structured access to its contents. For example, let’s say we have a collection of temperatures and want to average out the temperatures on Mondays:</p><p>The&nbsp;<a href="https://docs.microsoft.com/dotnet/api/system.text.json.jsondocument" rel="nofollow">JsonDocument</a>&nbsp;class allows you to access the individual properties and values quite easily.</p><h3><a id="user-content-using-the-writer" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#using-the-writer" aria-hidden="true"></a>Using the writer</h3><p>The writer is straight forward to use:</p><p>The reader requires you to switch on the token type:</p><h2><a id="user-content-integration-with-aspnet-core" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#integration-with-aspnet-core" aria-hidden="true"></a>Integration with ASP.NET Core</h2><p>Most use of JSON inside of ASP.NET Core is provided via the automatic serialization when accepting or returning object payloads, which in turn means that most of your application’s code is agnostic to which JSON library ASP.NET Core is using. That makes it easy to switch from one to another.</p><p>You can see the details on how you can enable the new JSON library in MVC and SignalR later on in this post.</p><h3><a id="user-content-integration-with-aspnet-core-mvc" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#integration-with-aspnet-core-mvc" aria-hidden="true"></a>Integration with ASP.NET Core MVC</h3><p>In Preview 5, ASP.NET Core MVC added support for reading and writing JSON using&nbsp;<code>System.Text.Json</code>. Starting with Preview 6, the new JSON library is used by default for serializing and deserializing JSON payloads.</p><p>Options for the serializer can be configured using&nbsp;<a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.mvcoptions" rel="nofollow">MvcOptions</a>:</p><p>If you’d like to switch back to the previous default of using&nbsp;<code>Newtonsoft.Json</code>, do the following:</p><ol><li>Install the&nbsp;<a href="https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson" rel="nofollow">Microsoft.AspNetCore.Mvc.NewtonsoftJson</a>&nbsp;NuGet package.</li><li>In&nbsp;<code>ConfigureServices()</code>&nbsp;add a call to&nbsp;<code>AddNewtonsoftJson()</code><br></li></ol><p><strong>Known issues</strong></p><ul><li>Support for&nbsp;<a href="https://docs.microsoft.com/aspnet/core/tutorials/web-api-help-pages-using-swagger" rel="nofollow">OpenAPI / Swagger</a>&nbsp;when using&nbsp;<code>System.Text.Json</code>&nbsp;is ongoing and unlikely to be available as part of the 3.0 release.</li></ul><h3><a id="user-content-integration-with-signalr" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#integration-with-signalr" aria-hidden="true"></a>Integration with SignalR</h3><p><code>System.Text.Json</code>&nbsp;is now the default Hub Protocol used by SignalR clients and servers starting in ASP.NET Core 3.0 Preview 5.</p><p>If you’d like to switch back to the previous default of using&nbsp;<code>Newtonsoft.Json</code>, then you can do so on both the client and server.</p><ol><li>Install the&nbsp;<code>Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson</code>&nbsp;NuGet package.</li><li>On the client add&nbsp;<code>.AddNewtonsoftJsonProtocol()</code>&nbsp;to the&nbsp;<code>HubConnectionBuilder</code>:<br></li><li>On the server add&nbsp;<code>.AddNewtonsoftJsonProtocol()</code>&nbsp;to the&nbsp;<code>AddSignalR()</code>&nbsp;call:<br></li></ol><h2><a id="user-content-performance" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#performance" aria-hidden="true"></a>Performance</h2><p>Since this feature is heavily motivated by performance, we’d like to share some high-level performance characteristics of the new APIs.</p><p>Please keep in mind that these are based on preview builds and the final numbers will most likely differ. We’re also still tweaking default behaviors which will affect performance (for example, case sensitivity). Please note that these are micro benchmarks. Your mileage will most certainly differ, so if performance is critical for you, make sure to make your own measurements for scenarios that best represent your workload. If you encounter scenarios you’d like us to optimize further,&nbsp;<a href="https://github.com/dotnet/corefx/issues/new">please file a bug</a>.</p><h3><a id="user-content-raw-systemtextjson" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#raw-systemtextjson" aria-hidden="true"></a>Raw System.Text.Json</h3><p>Just doing micro benchmarks to compare&nbsp;<code>System.Text.Json</code>&nbsp;with Json.NET yields the following output:</p><table><thead><tr><th align="left">Scenario</th><th align="left">Speed</th><th align="left">Memory</th></tr></thead><tbody><tr><td align="left"><strong>Deserialization</strong></td><td align="left">2x faster</td><td align="left">Parity or lower</td></tr><tr><td align="left"><strong>Serialization</strong></td><td align="left">1.5x faster</td><td align="left">Parity or lower</td></tr><tr><td align="left"><strong>Document</strong>&nbsp;(read-only)</td><td align="left">3-5x faster</td><td align="left">~Allocation free for sizes &lt; 1 MB</td></tr><tr><td align="left"><strong>Reader</strong></td><td align="left">2-3x faster</td><td align="left">~Allocation free (until you materialize values)</td></tr><tr><td align="left"><strong>Writer</strong></td><td align="left">1.3-1.6x faster</td><td align="left">~Allocation free</td></tr></tbody></table><h3><a id="user-content-systemtextjson-in-aspnet-core-mvc" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#systemtextjson-in-aspnet-core-mvc" aria-hidden="true"></a>System.Text.Json in ASP.NET Core MVC</h3><p>We’ve written an ASP.NET Core app that generates&nbsp;<a href="https://github.com/aspnet/Benchmarks/blob/5beb0cccac53a32dda42cf29686efeb732a1e5d1/src/Benchmarks/Controllers/HomeController.cs#L18-L35">data on the fly</a>&nbsp;that is then serialized and deserialized from&nbsp;<a href="https://github.com/aspnet/Benchmarks/blob/5beb0cccac53a32dda42cf29686efeb732a1e5d1/src/Benchmarks/Controllers/HomeController.cs#L42-L55">MVC controllers</a>. We then varied the payload sizes and measured the results:</p><p><strong>JSON deserialization (input)</strong></p><table cellpadding="0px 10px 0px 10px"><thead><tr><th align="right">Description</th><th align="right">RPS</th><th align="right">CPU (%)</th><th align="right">Memory (MB)</th></tr></thead><tbody><tr><td align="right"><code>Newtonsoft.Json</code>&nbsp;– 500 B</td><td align="right">136,435</td><td align="right">95</td><td align="right">172</td></tr><tr><td align="right"><code>System.Text.Json</code>&nbsp;– 500 B</td><td align="right">167,861</td><td align="right">94</td><td align="right">169</td></tr><tr><td align="right"><code>Newtonsoft.Json</code>&nbsp;– 2.4 KB</td><td align="right">97,137</td><td align="right">97</td><td align="right">174</td></tr><tr><td align="right"><code>System.Text.Json</code>&nbsp;– 2.4 KB</td><td align="right">132,026</td><td align="right">96</td><td align="right">169</td></tr><tr><td align="right"><code>Newtonsoft.Json</code>&nbsp;– 40 KB</td><td align="right">7,712</td><td align="right">88</td><td align="right">212</td></tr><tr><td align="right"><code>System.Text.Json</code>&nbsp;– 40 KB</td><td align="right">16,625</td><td align="right">96</td><td align="right">193</td></tr></tbody></table><p><strong>JSON serialization (output)</strong></p><table cellpadding="0px 10px 0px 10px"><thead><tr><th align="right">Description</th><th align="right">RPS</th><th align="right">CPU (%)</th><th align="right">Memory (MB)</th></tr></thead><tbody><tr><td align="right"><code>Newtonsoft.Json</code>&nbsp;– 500 B</td><td align="right">120,273</td><td align="right">94</td><td align="right">174</td></tr><tr><td align="right"><code>System.Text.Json</code>&nbsp;– 500 B</td><td align="right">145,631</td><td align="right">94</td><td align="right">173</td></tr><tr><td align="right"><code>Newtonsoft.Json</code>&nbsp;– 8 KB</td><td align="right">35,408</td><td align="right">98</td><td align="right">187</td></tr><tr><td align="right"><code>System.Text.Json</code>&nbsp;– 8 KB</td><td align="right">56,424</td><td align="right">97</td><td align="right">184</td></tr><tr><td align="right"><code>Newtonsoft.Json</code>&nbsp;– 40 KB</td><td align="right">8,416</td><td align="right">99</td><td align="right">202</td></tr><tr><td align="right"><code>System.Text.Json</code>&nbsp;– 40 KB</td><td align="right">14,848</td><td align="right">98</td><td align="right">197</td></tr></tbody></table><p>For the most common payload sizes,&nbsp;<code>System.Text.Json</code>&nbsp;offers about 20% throughput increase in MVC during input and output formatting with a smaller memory footprint.</p><h2><a id="user-content-summary" class="anchor" href="https://github.com/microsoft/dotnet-blog/blob/master/2019/06-Jun/json/2019-06-json.md#summary" aria-hidden="true"></a>Summary</h2><p>In .NET Core 3.0, we’ll ship the new&nbsp;<code>System.Text.Json</code>&nbsp;APIs, which provide built-in support for JSON, including reader/writer, read-only DOM, and serializer/deserializer. The primary goal was performance and we see typical speedups of up to 2x over Json.NET, but it depends on your scenario and your payload, so make sure you measure what’s important to you.</p><p>ASP.NET Core 3.0 includes support for&nbsp;<code>System.Text.Json</code>, which is enabled by default.</p><p>Give&nbsp;<code>System.Text.Json</code>&nbsp;a try and&nbsp;<a href="https://github.com/dotnet/corefx/issues/new">send us feedback</a>!</p><p><code>{"happy": "coding!"}</code></p><div class="authorinfoarea"><div><p>Program Manager,&nbsp;.NET</p><p><strong>Follow Immo</strong>&nbsp;&nbsp;&nbsp;<a class="no-underline stayinformed" aria-label="Immo Landwerth Twitter profile" target="_blank" href="https://twitter.com/terrajobst"></a><a class="no-underline stayinformed" aria-label="Immo Landwerth LinkedIn profile" target="_blank" href="https://www.linkedin.com/in/immol/"><i class="fa fa-linkedin"></i></a><a class="no-underline stayinformed" aria-label="Immo Landwerth GitHub profile" target="_blank" href="https://github.com/terrajobst"><i class="fa fa-github"></i></a><a class="no-underline stayinformed" aria-label="Immo Landwerth Stackoverflow profile" target="_blank" href="https://stackoverflow.com/users/847438/immo-landwerth"><i class="fa fa-stack-overflow"></i></a><a class="no-underline stayinformed hvr-pop" aria-label="Immo Landwerth RSS Feed" target="_blank" href="https://devblogs.microsoft.com/dotnet/author/terrajobstweb-de/feed/"></a></p></div></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>