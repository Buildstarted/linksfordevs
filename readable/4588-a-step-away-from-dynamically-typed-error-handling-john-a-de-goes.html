<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A Step Away from Dynamically-Typed Error Handling &#x2013; John A De Goes -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>A Step Away from Dynamically-Typed Error Handling – John A De Goes</h1><div><div class="article-wrap" itemprop="text"><p><em>Bifunctor IO</em>.</p><p>The subject is currently one of the hottest topics in the Scala functional programming community, inspiring both fear and awe in equal measure, as well as a proliferation of tickets, pull requests, and blog posts.</p><p>The occasion? Scalaz 8 IO has a new bifunctor design that challenges our assumptions about error handling in effect types, and functional programmers all over Scala’s community are trying to decide if and how this design helps us write better software.</p><p>Scalaz 8’s greenfield design presents a unique opportunity to re-examine every assumption about functional programming in Scala. The bifunctor design joins other innovations in the effect system (such as fine-grained interruption, resource safety, and fiber concurrency), as well as a <a href="https://www.slideshare.net/jdegoes/scalaz-8-a-whole-new-game">growing number of novel features</a> intended to radically improve FP in Scala.</p><p>Fibers and interruption were hotly debated when I first introduced them at Scala IO and <a href="https://www.youtube.com/watch?v=wi_vLNULh9Y">Scale by the Bay</a>, but now <a href="http://github.com/typelevel/cats-effect">even competitive libraries</a> have moved in the direction of Scalaz 8 IO.</p><p>What of bifunctor IO? Is this design going to change the way we manage errors in Scala effect types? Or will it be an interesting footnote in the history of functional programming in Scala?</p><p>As a contributor, I’m certainly biased, but I do believe bifunctor IO, which introduces typed errors, is here to stay, and that it’s going to greatly improve our ability to reason about our software. Bifunctor IO helps us describe the properties of our code through the type system, which is what drove many of us to statically-typed FP.</p><p>In this post, I’m going to give you an overview of the design and debunk some common myths. You can then decide for yourself if the increased precision is useful.</p><h2 id="what-is-io">What is IO?</h2><p>In many libraries, including Scalaz 7.2 and prior, <code class="language-plaintext highlighter-rouge">IO[A]</code> (or <code class="language-plaintext highlighter-rouge">Task[A]</code>) is an immutable data type that models an effectful program that runs forever, fails with a <code class="language-plaintext highlighter-rouge">Throwable</code>, or computes an <code class="language-plaintext highlighter-rouge">A</code>.</p><p>Like everything else in purely functional programming, <code class="language-plaintext highlighter-rouge">IO</code> is referentially-transparent—and all of its methods, excepting <code class="language-plaintext highlighter-rouge">unsafePerformIO</code> or its equivalent, are total, deterministic, and free of side effects.</p><p>You can use <code class="language-plaintext highlighter-rouge">IO</code> values to build other <code class="language-plaintext highlighter-rouge">IO</code> values, in the same way you can use <code class="language-plaintext highlighter-rouge">String</code> values to build other <code class="language-plaintext highlighter-rouge">String</code> values. It’s very similar to programming with immutable lists, maps, and other data structures common in functional programming, except instead of modeling data structures, the type models IO operations (so-called <em>effects</em>).</p><p>Inside your application’s main function, you convert <code class="language-plaintext highlighter-rouge">IO</code> into the effects that it models by <em>performing</em> those operations. In Scala, this execution function ships with every effect system, so you can run effects as easily as <code class="language-plaintext highlighter-rouge">unsafePerformIO(myProgram)</code>.</p><p>While “running” an effect is not purely functional, for impure languages like Scala, it’s a necessary evil—at least (and ideally, at most) one place in your application.</p><p>I mentioned earlier that <code class="language-plaintext highlighter-rouge">IO[A]</code> can fail with a <code class="language-plaintext highlighter-rouge">Throwable</code> or produce an <code class="language-plaintext highlighter-rouge">A</code>. This bifurcation should remind you of <code class="language-plaintext highlighter-rouge">Either[E, A]</code>, and indeed, <code class="language-plaintext highlighter-rouge">IO</code> data types are effectful versions of <code class="language-plaintext highlighter-rouge">Either[E, A]</code>, where the <code class="language-plaintext highlighter-rouge">E</code> type is either untyped or loosely typed.</p><p>Effect types do not throw exceptions, of course. Their notion of failure is exactly like the notion of “failure” with <code class="language-plaintext highlighter-rouge">Either[E, A]</code>. Failure is a value and merely short-circuits the remainder of the computation unless the failure is handled. This behaves similar to an exception in all the ways that matter, but it’s just an ordinary value (semantically, anyway, if not always in the implementation).</p><p>All effect types ship with equivalents of the following two error management functions:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span><span class="nc">IO</span><span class="o">{</span><span class="c1">// A function defined on the `IO` companion object:
</span><span class="k">def</span><span class="nf">fail</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">t</span><span class="k">:</span><span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="o">???</span><span class="o">}</span><span class="k">trait</span><span class="nc">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="o">{</span><span class="o">...</span><span class="c1">// A method defined on the `IO` data type:
</span><span class="k">def</span><span class="nf">attempt</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Throwable</span><span class="kt">\/</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="o">???</span><span class="o">...</span><span class="o">}</span></code></pre></figure><p>where <code class="language-plaintext highlighter-rouge">type \/[A, B] = Either[A, B]</code>.</p><p>These two functions allow you to produce a value that describes a failed computation (<code class="language-plaintext highlighter-rouge">IO.fail</code>), as well as handle a value that describes a failed computation (<code class="language-plaintext highlighter-rouge">io.attempt</code>). They satisfy the obvious properties (e.g. <code class="language-plaintext highlighter-rouge">IO.fail(t).attempt === IO.point(\/.left(t))</code>, where <code class="language-plaintext highlighter-rouge">IO.point</code> lifts a pure <code class="language-plaintext highlighter-rouge">A</code> into <code class="language-plaintext highlighter-rouge">IO[A]</code>).</p><p>General-purpose effect types like <code class="language-plaintext highlighter-rouge">IO</code> are how we usually model effects in purely functional programs. Because <code class="language-plaintext highlighter-rouge">IO</code> can represent any type of effect and has reasonably high performance, it tends to be the foundation that functional programs are built on. While FP programs may use other effect types, those types usually end up translated into <code class="language-plaintext highlighter-rouge">IO</code>.</p><p>Lots of programming languages have <code class="language-plaintext highlighter-rouge">IO</code>-like types, including of course Haskell (from which the Scala effect types are inspired!), PureScript, TypeScript, Kotlin, and many other languages.</p><p>Interestingly, every <code class="language-plaintext highlighter-rouge">IO[A]</code> data type in all of these languages has a bifurcated model of computation: either the effect fails with some (dynamically-typed) error, or it succeeds with some value of type <code class="language-plaintext highlighter-rouge">A</code>.</p><h2 id="whats-bifunctor-io">What’s Bifunctor IO?</h2><p>I came up with a bifunctor design for IO in late 2017, and recently upgraded Scalaz 8 IO to support the new design. In this design, <code class="language-plaintext highlighter-rouge">IO[E, A]</code> is an immutable data type that models an effectful program that runs forever, fails with an <code class="language-plaintext highlighter-rouge">E</code>, or computes an <code class="language-plaintext highlighter-rouge">A</code>.</p><p><code class="language-plaintext highlighter-rouge">IO[E, A]</code> is a “bifunctor” because you can define an instance of the type class <code class="language-plaintext highlighter-rouge">Bifunctor</code> (defined <a href="https://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Bifunctor.scala">here</a>), which lets you map over not just the value (<code class="language-plaintext highlighter-rouge">A =&gt; A2</code>), but also over the error (<code class="language-plaintext highlighter-rouge">E =&gt; E2</code>).</p><p>This bifunctor capability of the data type is essential, as it allows you to “lift” programs that produce one class of errors into programs that produce another (typically larger) class of errors.</p><p>In bifunctor IO, the two core error management functions are nearly unchanged, but become significantly more general:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span><span class="nc">IO</span><span class="o">{</span><span class="k">def</span><span class="nf">fail</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span><span class="kt">E</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="o">???</span><span class="o">}</span><span class="k">trait</span><span class="nc">IO</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span><span class="o">{</span><span class="o">...</span><span class="k">def</span><span class="nf">attempt</span><span class="o">[</span><span class="kt">E2</span><span class="o">]</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">E2</span>, <span class="kt">E</span><span class="kt">\/</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="o">???</span><span class="o">...</span><span class="o">}</span></code></pre></figure><p>Instead of being forced to fail an <code class="language-plaintext highlighter-rouge">IO</code> with a poorly typed <code class="language-plaintext highlighter-rouge">Throwable</code>, you can create <code class="language-plaintext highlighter-rouge">IO</code> values that model failure <em>for any error type at all</em>, including strings, numbers, ADTs, or even type-level sets, all of which make sense in different circumstances.</p><p>Most functional programs will mix and match many different types of errors at different levels of the application, varying them in response to the local needs of each part of the application.</p><p>The <code class="language-plaintext highlighter-rouge">attempt</code> function becomes polymorphic in the new error type, allowing you to choose any type of error. This represents a compile-time guarantee that the attempted <code class="language-plaintext highlighter-rouge">IO</code> cannot fail, because there is no way it can summon a value of an arbitrary type <code class="language-plaintext highlighter-rouge">E2</code> into existence. You can easily choose the error type of an attempted effect to be <code class="language-plaintext highlighter-rouge">Nothing</code> or equivalent (<code class="language-plaintext highlighter-rouge">Void</code> in Scalaz, Haskell, PureScript, and others), thus proving that failure is impossible.</p><p>The power of this approach can be demonstrated in the following snippet:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">right</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">v</span><span class="k">:</span><span class="kt">Void</span><span class="kt">\/</span><span class="kt">A</span><span class="o">)</span><span class="k">:</span><span class="kt">A</span><span class="o">=</span><span class="nv">v</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">absurd</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">identity</span><span class="o">)</span><span class="k">val</span><span class="nv">io</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="o">???</span><span class="k">val</span><span class="nv">attempt1</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Void</span>, <span class="kt">E</span><span class="kt">\/</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nv">io</span><span class="o">.</span><span class="py">attempt</span><span class="o">[</span><span class="kt">Void</span><span class="o">]</span><span class="k">val</span><span class="nv">attempt2</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Void</span>, <span class="kt">Void</span><span class="kt">\/</span><span class="o">(</span><span class="kt">E</span><span class="kt">\/</span><span class="kt">A</span><span class="o">)]</span><span class="k">=</span><span class="nv">attempt1</span><span class="o">.</span><span class="py">attempt</span><span class="o">[</span><span class="kt">Void</span><span class="o">]</span><span class="k">val</span><span class="nv">attempt3</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Void</span>, <span class="kt">E</span><span class="kt">\/</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nv">attempt2</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">right</span><span class="o">)</span></code></pre></figure><p>This snippet proves the intuitive fact that repeated attempts cannot fail. The fact that you can express this guarantee at compile-time, using types that communicate rich information to developers, is quite remarkable and powerful.</p><p>While error management changes only in minor ways, the resulting ramifications to the error model are profound. Before I explore them, however, we must talk about the different types of errors.</p><h2 id="types-of-errors">Types of Errors</h2><p>There are two classes of errors in applications:</p><ol><li><strong>Recoverable Errors</strong>. Recoverable errors refer to the errors we expect to happen occasionally. For example, when we perform an HTTP request, we expect that sometimes, it will not succeed because the server is down or there are network issues. Because we expect these errors to happen, we want to build our code in a way that acknowledges the failure scenarios. We want graceful fallbacks at some level of the application (perhaps not locally, but at the edges).</li><li><strong>Non-Recoverable Errors</strong>. Non-recoverable errors refer to the errors we do not expect to happen. For example, if a user has configured the JRE with 10k of memory for the stack, then a lot of ordinary (non-recursive) code will stack overflow, producing a <code class="language-plaintext highlighter-rouge">StackOverflowError</code>. This is not a normal error we expect to happen, nor is there a sane way to recover from it.</li></ol><p>In Java, the convention is to use <code class="language-plaintext highlighter-rouge">Exception</code> for recoverable errors, and <code class="language-plaintext highlighter-rouge">Error</code> for non-recoverable errors. Both of these are subclasses of <code class="language-plaintext highlighter-rouge">Throwable</code>, which is the only error type supported by the JVM.</p><p>In languages like Erlang and C, recoverable errors are modeled with ordinary values, and non-recoverable errors do not have an explicit representation and resolve outside application logic (with a crash in Erlang, and with undefined behavior in C).</p><p>The distinction between failure scenarios that we expect to happen and failure scenarios that we do not expect to happen is <em>extremely important</em>:</p><ul><li>Failure scenarios that we expect to happen can be recovered from in application code. In statically-typed functional programming, we have the ability to guarantee at compile-time that expected failures are handled, or at least tracked, so we know the consequences of interacting with such code.</li><li>Failure scenarios that we do <em>not</em> expect to happen cannot be sanely recovered from, and the reason is precisely this: we did <em>not</em> expect these errors, so we do not know <em>where</em> they will occur, <em>what</em> these errors will be, or whether it makes sense to continue, and if so, what remedial actions permit a well-defined recovery.</li></ul><p>Attempting to recover from an unexpected error puts your program into an undefined state: it is undefined precisely because you do not know where the error occurred, which means you don’t know the state of the application or its external environment; and you do not know what the error is, which means you don’t know if and how to recover.</p><p>Non-recoverable errors are almost always defects, but sometimes they occur for catastrophic reasons outside the direct control of the programmer (such as running out of memory). A C program may overwrite an arbitrary piece of memory (defect), a Java program may try to allocate more memory than reserved for the heap (catastrophic), or an Erlang actor may make a false assumption about data (defect).</p><p>The distinction between recoverable and non-recoverable errors fully informs the design of the Scalaz 8 IO error model. In the next section, I’ll introduce this error model and talk about its implications.</p><h2 id="a-principled-error-model">A Principled Error Model</h2><p><img src="/images/scalaz-8-error-model.png" alt="Scalaz 8 Error Model"></p><p>In the Scalaz 8 IO error model, the distinction between recoverable and non-recoverable errors is explicit. This distinction forms the foundation of the error model.</p><p>Recoverable errors are statically-typed, and modeled by the <code class="language-plaintext highlighter-rouge">E</code> type parameter in <code class="language-plaintext highlighter-rouge">IO[E, A]</code>.</p><p>Effects of type <code class="language-plaintext highlighter-rouge">IO[E, A]</code> can fail for any <code class="language-plaintext highlighter-rouge">E</code>, and can be recovered from to yield <code class="language-plaintext highlighter-rouge">IO[E2, E \/ A]</code>, for any type <code class="language-plaintext highlighter-rouge">E2</code>, including uninhabited types like <code class="language-plaintext highlighter-rouge">Nothing</code> or Scalaz’s <code class="language-plaintext highlighter-rouge">Void</code> type. The type system tells you <em>if</em> and <em>how</em> an effect can fail.</p><p>Non-recoverable errors are <em>weakly typed</em>, and include the full range of runtime errors on the JVM, which is any type that extends <code class="language-plaintext highlighter-rouge">Throwable</code>. Execution of any <code class="language-plaintext highlighter-rouge">IO[E, A]</code> may fail due to some non-recoverable error—probably a defect, but possibly a catastrophic error outside the control of the program.</p><p>Non-recoverable errors are, as their name suggests, not recoverable, which is the case in languages like C and Erlang. If one of these errors occurs, the fiber running the effect will be terminated.</p><p>This error model implies that, aside from non-termination, there are exactly three possible outcomes from running an effect <code class="language-plaintext highlighter-rouge">IO[E, A]</code>:</p><ul><li>The effect fails due to an unhandled <code class="language-plaintext highlighter-rouge">E</code> created with <code class="language-plaintext highlighter-rouge">IO.fail</code>.</li><li>The effect is terminated due to a non-recoverable <code class="language-plaintext highlighter-rouge">Throwable</code>.</li><li>The effect computes an <code class="language-plaintext highlighter-rouge">A</code>.</li></ul><p>In the sections that follow, I’ll dive into specifics of the error model by covering some of the practical benefits to developers.</p><h3 id="benefit-1-no-dynamically-typed-errors">Benefit 1: No Dynamically-Typed Errors</h3><p>The most distinguishing feature of the error model is that it allows us to move away from dynamically-typed errors.</p><p>Programming with <code class="language-plaintext highlighter-rouge">IO[A]</code> provides no compile-time guarantees about failure. From the type alone, you must assume that all effects may fail for any reason at any time, even if you’ve already handled them or they can only fail in specific ways.</p><p>With <code class="language-plaintext highlighter-rouge">IO[E, A]</code>, you know all possible (recoverable) failure scenarios:</p><ul><li>If you handle some failure scenarios but not others, you can express this in the type by choosing a suitable sum type for <code class="language-plaintext highlighter-rouge">E</code>.</li><li>If the effect cannot fail, you can express this with <code class="language-plaintext highlighter-rouge">IO[Void, A]</code> or equivalent.</li><li>If the effect may truly fail for any reason, then you can express this with <code class="language-plaintext highlighter-rouge">IO[Throwable, E]</code> (or even, heaven forbid, <code class="language-plaintext highlighter-rouge">IO[AnyRef, E]</code>).</li></ul><p>For one practical application among many, suppose that you want your REST API to return errors in the JSON format. In this case, you can simply express the requirement in the type:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">serve</span><span class="o">(</span><span class="n">handler</span><span class="k">:</span><span class="kt">HTTPRequest</span><span class="o">=&gt;</span><span class="nc">IO</span><span class="o">[</span><span class="kt">Void</span>, <span class="kt">JSON</span><span class="o">])</span></code></pre></figure><p>The type here demands that the handler you pass to the <code class="language-plaintext highlighter-rouge">serve</code> function handle all its own errors and encode them into JSON. Now you don’t have to worry about code forgetting to handle some error and then not knowing how to transcribe the error into the required JSON format.</p><p>As another example, suppose we have an evaluator in a spreadsheet application for some domain-specific scripting language. In this case, we want to know precisely how evaluation may fail, because failure is expected and we must handle different failures in different ways.</p><p>In this case, we can model the evaluator as follows:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">sealed</span><span class="k">trait</span><span class="nc">EvaluationError</span><span class="k">case</span><span class="k">class</span><span class="nc">ParseError</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">expected</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Symbol</span><span class="o">])</span><span class="k">extends</span><span class="nc">EvaluationError</span><span class="k">case</span><span class="k">class</span><span class="nc">TypeError</span><span class="o">(</span><span class="n">expected</span><span class="k">:</span><span class="kt">Type</span><span class="o">,</span><span class="n">actual</span><span class="k">:</span><span class="kt">Type</span><span class="o">)</span><span class="k">extends</span><span class="nc">EvaluationError</span><span class="k">case</span><span class="k">class</span><span class="nc">RuntimeError</span><span class="o">(</span><span class="n">function</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">extends</span><span class="nc">EvaluationError</span><span class="k">def</span><span class="nf">evaluate</span><span class="o">(</span><span class="n">script</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">EvaluationError</span>, <span class="kt">Unit</span><span class="o">]</span><span class="k">=</span><span class="o">???</span></code></pre></figure><p>Both statically-typed values <em>and</em> statically-typed errors let us use the compiler to prove properties of our programs. In the case of statically-typed errors, we can prove that effects only fail in specific ways, or that they don’t fail at all.</p><p>Further, we can vary our propositions in different parts of our program, because we have the flexibility to vary the type of error.</p><h3 id="feature-2-no-lost-errors">Feature 2: No Lost Errors</h3><p>Most programming languages have lossy error models. By lossy, I mean it is possible for exceptions to be swallowed.</p><p>In the following snippet, two errors will be swallowed:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">try</span><span class="o">{</span><span class="k">try</span><span class="o">{</span><span class="k">try</span><span class="k">throw</span><span class="k">new</span><span class="nc">Error</span><span class="o">(</span><span class="s">"e1"</span><span class="o">)</span><span class="k">finally</span><span class="k">throw</span><span class="k">new</span><span class="nc">Error</span><span class="o">(</span><span class="s">"e2"</span><span class="o">)</span><span class="o">}</span><span class="k">finally</span><span class="k">throw</span><span class="k">new</span><span class="nc">Error</span><span class="o">(</span><span class="s">"e3"</span><span class="o">)</span><span class="o">}</span><span class="k">catch</span><span class="o">{</span><span class="k">case</span><span class="n">e</span><span class="k">:</span><span class="kt">Error</span><span class="o">=&gt;</span><span class="nf">println</span><span class="o">(</span><span class="n">e</span><span class="o">)</span><span class="o">}</span></code></pre></figure><p>Most Scala (or Java) developers don’t know which error will be caught and reported in the outermost <code class="language-plaintext highlighter-rouge">catch</code> block, but one fact is clear from the structure: at most one exception will be reported. The other two will be lost forever.</p><p>Scalaz 8 IO dramatically improves on this broken error model by <em>guaranteeing</em> that no errors are lost, whether they are recoverable errors modeled with <code class="language-plaintext highlighter-rouge">E</code>, or non-recoverable errors that result from defects or catastrophic runtime errors.</p><p>This guarantee is provided with a <em>hierarchy of supervisors</em>. A <em>supervisor</em> is just a function <code class="language-plaintext highlighter-rouge">Throwable =&gt; IO[Void, Unit]</code>, which will receive all unhandled errors from a fiber.</p><p>The root fiber, which runs the application <code class="language-plaintext highlighter-rouge">main</code> function, has a default supervisor, which can be overridden. The default supervisor prints the stack trace of the error to the console.</p><p>Other supervisors are specified by the application when forking an effect. For example, if you want to run some work in a separate fiber, you call <code class="language-plaintext highlighter-rouge">fork0</code> and specify the supervisor for the fiber:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span><span class="o">{</span><span class="n">fiber</span><span class="k">&lt;-</span><span class="nv">work</span><span class="o">.</span><span class="py">fork0</span><span class="o">(</span><span class="n">t</span><span class="k">=&gt;</span><span class="nf">logError</span><span class="o">(</span><span class="n">t</span><span class="o">))</span><span class="o">...</span><span class="o">}</span><span class="nf">yield</span><span class="o">()</span></code></pre></figure><p>In this example, the supervisor merely logs the error to a file, to ensure if there is a defect in our program, we know that it happened. Other sensible choices include logging to a remote server, restarting a fiber, or returning diagnostic information in an API.</p><p>Supervisors are hierarchical. If you don’t specify a supervisor when forking an effect, then it will inherit the supervisor of the fiber that performed the forking.</p><p>The supervisor hierarchy provides a modular way of dealing with unhandled errors. Lower levels of an application can decide how to supervise their children, or simply delegate to the parent.</p><h3 id="benefit-3-no-resource-leaks">Benefit 3: No Resource Leaks</h3><p>Scalaz 8 IO has a built-in primitive called <code class="language-plaintext highlighter-rouge">bracket</code>, which is a more structured version of <code class="language-plaintext highlighter-rouge">try</code> / <code class="language-plaintext highlighter-rouge">finally</code>.</p><p>The <code class="language-plaintext highlighter-rouge">bracket</code> primitive allows you to acquire a resource in one effect, use the resource in another effect, and finally, close the resource in a different effect.</p><p>Using this primitive is quite simple:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="nf">openFile</span><span class="o">(</span><span class="s">"data.csv"</span><span class="o">).</span><span class="py">bracket</span><span class="o">(</span><span class="nf">closeFile</span><span class="o">(</span><span class="k">_</span><span class="o">))</span><span class="o">{</span><span class="n">handle</span><span class="k">=&gt;</span><span class="c1">// Use resource in here...
</span><span class="o">}</span></code></pre></figure><p>Resources acquired with <code class="language-plaintext highlighter-rouge">bracket</code> will <em>always</em> be released, even if the body fails due to an unhandled <code class="language-plaintext highlighter-rouge">E</code>, a defect in the code, fiber interruption, or a catastrophic external error.</p><p>Resource safety lets you build bullet-proof, long-lived applications that are resilient to failures, whether expected or unexpected.</p><h3 id="benefit-4-no-changes-needed">Benefit 4: No Changes Needed</h3><p>A remarkable property of the Scalaz 8 <code class="language-plaintext highlighter-rouge">IO</code> bifunctor design is that it generalizes over both the <em>existing</em> dynamically-typed error effect types and so-called <em>non-exceptional</em> effect types.</p><p>Existing effect types may fail at any time, for any reason. To model this type of effect type, we can use the following type alias:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span><span class="kt">Task</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nc">IO</span><span class="o">[</span><span class="kt">Throwable</span>, <span class="kt">A</span><span class="o">]</span></code></pre></figure><p>With one notable exception, there is <em>no difference</em> between this definition of <code class="language-plaintext highlighter-rouge">Task</code> and other dynamically-typed error effects. This is the preferred migration option if you are moving to Scalaz 8 from Scalaz 7.2 <code class="language-plaintext highlighter-rouge">IO</code> or <code class="language-plaintext highlighter-rouge">Task</code>, Monix <code class="language-plaintext highlighter-rouge">Task</code>, or cats-effect <code class="language-plaintext highlighter-rouge">IO</code>.</p><p>The only difference relates to how <em>defects</em> are handled. Older error models conflate recoverable errors with non-recoverable errors, which “works” because they fix the error type to <code class="language-plaintext highlighter-rouge">Throwable</code>. These types encourage users to write code like <code class="language-plaintext highlighter-rouge">IO.point(42).map(_ =&gt; throw Error("Surprise!")).attempt</code>.</p><p>In Scalaz 8 IO, defects in your code cannot be “caught”, similar to Erlang, C, and many other real-world programming languages. Since we use values to represent failure in functional programming (in the case of <code class="language-plaintext highlighter-rouge">IO</code>, values constructed with <code class="language-plaintext highlighter-rouge">IO.fail</code>), throwing exceptions from pure code is considered a defect, and the fiber running the effect will be terminated.</p><p>The cause for the termination will, of course, be passed to the fiber’s supervisor, so it can be logged or otherwise made visible. Or, depending on the context, you might decide to restart a fiber that fails due to a defect, similar to supervision in actor systems.</p><p>Aside from this one difference, users who prefer only using <code class="language-plaintext highlighter-rouge">Throwable</code>, or who wish to introduce typed errors selectively, can simply use <code class="language-plaintext highlighter-rouge">IO[Throwable, A]</code> as their default effect type.</p><p>No changes to error handling are necessary, because the bifunctor design completely subsumes older designs.</p><h3 id="benefit-5-no-errors">Benefit 5: No Errors</h3><p>As discussed previously, <code class="language-plaintext highlighter-rouge">IO</code> can also model effects that cannot fail. The following snippet creates a type synonym to do just this:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span><span class="kt">Unexceptional</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">=</span><span class="nc">IO</span><span class="o">[</span><span class="kt">Void</span>, <span class="kt">A</span><span class="o">]</span></code></pre></figure><p>Effects of type <code class="language-plaintext highlighter-rouge">Unexceptional[A]</code> cannot (recoverably) fail, meaning if they fail, it’s because of a non-recoverable defect in your code or because of a catastrophic error like <code class="language-plaintext highlighter-rouge">OutOfMemoryError</code>.</p><p>As you can see, <code class="language-plaintext highlighter-rouge">IO[E, A]</code> generalizes over both non-exceptional effect types and dynamically-typed effect types. In other words, the bifunctor design of Scalaz 8 IO is <em>strictly more expressive</em> than all other effect types. Other effect types fall out elegantly as special cases.</p><p>Developers who complain about the bifunctor design are really complaining because they have <em>gained</em> the ability to be more precise, not because they are <em>required</em> to be more precise. This is rather like complaining about optional type annotations—if you don’t like them, don’t use them!</p><p>The alternative to the bifunctor design is to introduce special-case types for non-exceptional or strongly-typed effect types. For example, cats-effect will probably get <code class="language-plaintext highlighter-rouge">UIO</code>, which is a non-exceptional effect type, and may at some point get a bifunctor <code class="language-plaintext highlighter-rouge">BIO</code>. Such proliferation of effect types (with massive redundancy in the implementations!) is unnecessary with the bifunctor design, because a single generalized type <code class="language-plaintext highlighter-rouge">IO[E, A]</code> is capable of modeling everything.</p><h2 id="debunking-myths-of-bifunctor-io">Debunking Myths of Bifunctor IO</h2><p>The bifunctor design for the Scalaz 8 IO effect type is so new, there’s not much documentation on the subject. Up until recently, the main source of documentation has been the code itself! As a result, the design has been subject to a lot of speculation.</p><p>In the next sections, I want to debunk what I perceive to be common myths around the bifunctor design. Arguably, some of these myths are instead <em>strong biases</em> toward dynamically-typed error handling, but most of you who read this blog probably prefer static types, and will share my own bias in this regard.</p><h3 id="myth-1-composition-destroys-specific-error-types">Myth 1: Composition Destroys Specific Error Types</h3><p>This myth states that composing two effects <code class="language-plaintext highlighter-rouge">IO[E1, A]</code> and <code class="language-plaintext highlighter-rouge">IO[E2, B]</code> will result in an error type that erases the distinction between <code class="language-plaintext highlighter-rouge">E1</code> and <code class="language-plaintext highlighter-rouge">E2</code>. Stated simply, <em>composing effects leads to a loss of precise error types</em>.</p><p>This myth is false because users themselves define how error types compose, and they are not required to use <em>common supertype</em> composition. For example, I can easily combine two effects <code class="language-plaintext highlighter-rouge">IO[E1, A]</code> and <code class="language-plaintext highlighter-rouge">IO[E2, B]</code> with different errors in a lossless way using a disjunction type, such as <code class="language-plaintext highlighter-rouge">E1 \/ E2</code>.</p><p>This technique is demonstrated in the following snippet:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span><span class="nv">io</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">E1</span><span class="kt">\/</span><span class="kt">E2</span>, <span class="o">(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">))</span><span class="k">=</span><span class="k">for</span><span class="o">{</span><span class="n">a</span><span class="k">&lt;-</span><span class="nv">op1</span><span class="o">.</span><span class="py">leftMap</span><span class="o">(\/.</span><span class="py">left</span><span class="o">)</span><span class="n">b</span><span class="k">&lt;-</span><span class="nv">op2</span><span class="o">.</span><span class="py">leftMap</span><span class="o">(\/.</span><span class="py">right</span><span class="o">)</span><span class="o">}</span><span class="nf">yield</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span></code></pre></figure><p>In general, error types always compose in a completely lossless way using sum types.</p><p>In some cases, you may want a built-in sum type like <code class="language-plaintext highlighter-rouge">\/</code> (<code class="language-plaintext highlighter-rouge">Either</code>), as shown in the above snippet. In other cases, it is more convenient to define a custom sum type, such as the previously introduced <code class="language-plaintext highlighter-rouge">EvaluationError</code>:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">sealed</span><span class="k">trait</span><span class="nc">EvaluationError</span><span class="k">case</span><span class="k">class</span><span class="nc">ParseError</span><span class="o">(</span><span class="n">line</span><span class="k">:</span><span class="kt">Int</span><span class="o">,</span><span class="n">expected</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">Symbol</span><span class="o">])</span><span class="k">extends</span><span class="nc">EvaluationError</span><span class="k">case</span><span class="k">class</span><span class="nc">TypeError</span><span class="o">(</span><span class="n">expected</span><span class="k">:</span><span class="kt">Type</span><span class="o">,</span><span class="n">actual</span><span class="k">:</span><span class="kt">Type</span><span class="o">)</span><span class="k">extends</span><span class="nc">EvaluationError</span><span class="k">case</span><span class="k">class</span><span class="nc">RuntimeError</span><span class="o">(</span><span class="n">function</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">extends</span><span class="nc">EvaluationError</span></code></pre></figure><p>Others still may prefer to use type-level sets to represent errors, because this makes it very easy to add and subtract errors, while still providing the ability to handle some or all errors.</p><p>The <a href="https://twitter.com/propensive/status/993422307388424192">Mitigation library</a> by <a href="http://twitter.com/propensive">Jon Pretty</a>, based on Totalitarian, provides a convenient and powerful solution for managing sets of errors. Look for <code class="language-plaintext highlighter-rouge">scalaz-mitigation</code> in the near future! (Bug Jon and me about it until we do something!)</p><h3 id="myth-2-you-dont-recover-from-errors-often">Myth 2: You Don’t Recover From Errors Often</h3><p>This myth states that typed errors are not useful because most code doesn’t recover from most types of errors.</p><p>This is only true when recoverable errors are conflated with non-recoverable errors. If an error is not expected, and therefore cannot be recovered from, then it will neither appear in any type signature, nor affect the development experience.</p><p>For example, take the following snippet of code:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">for</span><span class="o">{</span><span class="n">r1</span><span class="k">&lt;-</span><span class="n">op1</span><span class="n">r2</span><span class="k">&lt;-</span><span class="n">op2</span><span class="n">r3</span><span class="k">&lt;-</span><span class="n">op3</span><span class="o">}</span><span class="k">yield</span><span class="n">r1</span><span class="o">+</span><span class="n">r2</span><span class="o">+</span><span class="n">r3</span></code></pre></figure><p>If <code class="language-plaintext highlighter-rouge">op1</code>, <code class="language-plaintext highlighter-rouge">op2</code>, and <code class="language-plaintext highlighter-rouge">op3</code> do not fail in recoverable ways, then they will have type <code class="language-plaintext highlighter-rouge">IO[Void, A]</code> (for some type <code class="language-plaintext highlighter-rouge">A</code>), which means they compose with effects of any other error type, and we know from looking at the type signature that these operations do not fail.</p><p>Only recoverable errors, which we expect to happen, and which we need to deal with in our programs, are reflected in the error type.</p><h3 id="myth-3-the-error-type-is-an-encapsulation-leak">Myth 3: The Error Type is an Encapsulation Leak</h3><p>This myth states that having statically-typed errors leaks implementation details. This is not true at all—in fact, it is poor API design that leaks implementation details.</p><p>Let’s take the following API:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">read</span><span class="o">(</span><span class="n">id</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">FileNotFoundException</span>, <span class="kt">ByteVector</span><span class="o">]</span></code></pre></figure><p>This API states that <code class="language-plaintext highlighter-rouge">read</code> can fail with <code class="language-plaintext highlighter-rouge">FileNotFoundException</code>. However, we may want to abstract over different ways of reading a resource (in-memory versus over HTTP, for example). If we want to abstract over reading, then <code class="language-plaintext highlighter-rouge">FileNotFoundException</code> is a poor way to represent failure. Instead, we should design the API as follows:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">read</span><span class="o">(</span><span class="n">id</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">ResourceNotFound</span>, <span class="kt">ByteVector</span><span class="o">]</span></code></pre></figure><p>Or possibly even more simply:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">read</span><span class="o">(</span><span class="n">id</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Void</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">ByteVector</span><span class="o">]]</span></code></pre></figure><p>Whether or not an effect may fail in a recoverable way is part of an API’s public contract, and should be reflected clearly in the types.</p><p>API design requires skill, and types alone cannot stop us from making bad design choices. Even without typed errors, we are free to design APIs that leak implementation details.</p><p>For example, consider the following API:</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">def</span><span class="nf">resolve</span><span class="o">(</span><span class="n">path</span><span class="k">:</span><span class="kt">String</span><span class="o">)</span><span class="k">:</span><span class="kt">Task</span><span class="o">[</span><span class="kt">File</span><span class="o">]</span></code></pre></figure><p>This API resolves a <code class="language-plaintext highlighter-rouge">path</code> to a <code class="language-plaintext highlighter-rouge">File</code> resource (<code class="language-plaintext highlighter-rouge">java.util.File</code>). However, <code class="language-plaintext highlighter-rouge">File</code> only represents local files, and could easily be generalized to <code class="language-plaintext highlighter-rouge">URI</code> or something similar. If we must abstract over different resource locations, then <code class="language-plaintext highlighter-rouge">File</code> is a poor choice.</p><p>No one would suggest that because it is possible to return <code class="language-plaintext highlighter-rouge">File</code>, and that <code class="language-plaintext highlighter-rouge">File</code> leaks implementation details, we should therefore use <code class="language-plaintext highlighter-rouge">AnyRef</code> for all return values so we can let implementations vary.</p><p>In the same way, just because it is possible to leak implementation details in the type of an error channel, doesn’t mean we should use dynamically-typed errors.</p><p>There is no connection whatsoever between typed errors and the leaking of implementation details. They are completely orthogonal.</p><h3 id="myth-4-it-pushes-complexity-to-the-user">Myth 4: It Pushes Complexity to the User</h3><p>This myth states that using typed errors pushes “complexity” to the user. The myth conflates <em>inherent complexity</em> with <em>incidental complexity</em>.</p><p><em>Inherent complexity</em> is complexity that is inherent to the task of properly modeling a domain. For example, if we wish to precisely model the domain of JSON values, then we <em>must</em> have a sum type that supports boolean, null, numbers, arrays, and objects. Further, our number type must support arbitrary precision.</p><figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">sealed</span><span class="k">trait</span><span class="nc">JSON</span><span class="k">case</span><span class="k">object</span><span class="nc">JNull</span><span class="k">extends</span><span class="nc">JSON</span><span class="k">case</span><span class="k">class</span><span class="nc">JBool</span><span class="o">(</span><span class="n">value</span><span class="k">:</span><span class="kt">Boolean</span><span class="o">)</span><span class="k">extends</span><span class="nc">JSON</span><span class="k">case</span><span class="k">class</span><span class="nc">JNum</span><span class="o">(</span><span class="n">value</span><span class="k">:</span><span class="kt">BigDecimal</span><span class="o">)</span><span class="k">extends</span><span class="nc">JSON</span><span class="k">case</span><span class="k">class</span><span class="nc">JArr</span><span class="o">(</span><span class="n">value</span><span class="k">:</span><span class="kt">List</span><span class="o">[</span><span class="kt">JSON</span><span class="o">])</span><span class="k">extends</span><span class="nc">JSON</span><span class="k">case</span><span class="k">class</span><span class="nc">JObj</span><span class="o">(</span><span class="n">value</span><span class="k">:</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">JSON</span><span class="o">])</span><span class="k">extends</span><span class="nc">JSON</span></code></pre></figure><p>This is complexity, but it is inherent complexity because it is intrinsic to the problem of precisely modeling JSON values.</p><p><em>Incidental complexity</em> is complexity that arises not because of the problem domain, but because of implementation decisions that could have been otherwise without sacrificing correctness. For example, dependency injection frameworks have much <em>incidental complexity</em>—they are a very complex way of passing arguments to functions.</p><p>Precisely modeling data types always comes with some cost due to <em>inherent complexity</em>. Stated differently, making illegal states unrepresentable requires work. If we want to precisely describe <em>if</em> and <em>how</em> our effects may fail, then this, too, will require work, but this complexity is inherent to precise error handling.</p><p>A design like Scalaz 8 <code class="language-plaintext highlighter-rouge">IO</code> lets you choose how precise you want to be. It has the flexibility to describe infallible effects or effects that fail in only pre-defined ways, but you only need to use this flexibility when you decide the precision adds sufficient value.</p><p>Legacy designs remove the choice from you, forcing you into a dynamically-typed error model that offers no ability to make illegal (error) states unrepresentable. They are antithetical to the goals that drive us to statically-typed functional programming.</p><h3 id="myth-5-the-bifunctor-io-doesnt-reflect-the-runtime">Myth 5: The Bifunctor IO Doesn’t Reflect the Runtime</h3><p>This myth states that any effect type should “reflect the runtime”, which is vague enough to warrant <a href="https://twitter.com/djspiewak/status/983805298526699520">sourcing the claim</a>:</p><blockquote><p>“IO needs to reflect and describe the capabilities of the runtime, for good or for bad. All it takes is an ‘innocent’ throw to turn it all into a lie, and you can’t prevent that.”</p></blockquote><p>This is an argument to catch defects, such as exceptions thrown from pure code, so users can attempt recovery. It’s also an argument to fix the failure type to <code class="language-plaintext highlighter-rouge">Throwable</code>, because this is what the JVM does.</p><p>The argument is incoherent, as can be seen by examining the implications of consistently “reflecting the runtime”.</p><p>The JVM does not support parametric polymorphism, which means the <code class="language-plaintext highlighter-rouge">A</code> in <code class="language-plaintext highlighter-rouge">IO[A]</code> is erased at runtime (equivalent to <code class="language-plaintext highlighter-rouge">IO[AnyRef]</code>). Because of this type erasure and the lack of type safety in Scala, this means having a value of type <code class="language-plaintext highlighter-rouge">IO[A]</code> is no guarantee the <code class="language-plaintext highlighter-rouge">IO</code> value will actually compute an <code class="language-plaintext highlighter-rouge">A</code>.</p><p>To “reflect the runtime” in the <code class="language-plaintext highlighter-rouge">IO</code> data type, it would be necessary to avoid using parametric polymorphism entirely, because this feature is not supported by the JVM, and it’s impossible to enforce that <code class="language-plaintext highlighter-rouge">IO[A]</code> actually produces anything of type <code class="language-plaintext highlighter-rouge">A</code>. After all, <em>reflecting the runtime</em> would argue, it just takes one innocent, accidental coercion to turn <code class="language-plaintext highlighter-rouge">IO[A]</code> into a lie, and you can’t prevent that!</p><p>Additionally, the JVM uses <code class="language-plaintext highlighter-rouge">null</code> for optionality, not <code class="language-plaintext highlighter-rouge">Option</code> or <code class="language-plaintext highlighter-rouge">Maybe</code>. <em>Reflecting the runtime</em> would argue for embracing <code class="language-plaintext highlighter-rouge">null</code> for optionality, and expecting <code class="language-plaintext highlighter-rouge">null</code> everywhere in the interface to <code class="language-plaintext highlighter-rouge">IO</code>.</p><p>Doing functional programming, <a href="http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.pdf">even in languages like Haskell</a>, requires a set of assumptions. In Scala, these assumptions include no runtime reflection, no coercion, no exceptions, no side effects, no null, and so forth.</p><p>Without these assumptions (often called the <a href="http://www.lihaoyi.com/post/StrategicScalaStylePracticalTypeSafety.html#scalazzi-scala">Scalazzi subset</a> of Scala, after Scalaz), you would program fearfully, constantly checking the runtime class of every value, testing to make sure no values are null, obsessively try/catching, and fearing that a function like <code class="language-plaintext highlighter-rouge">def identity[A](a: A): A</code> may generate a novel <code class="language-plaintext highlighter-rouge">A</code> through runtime reflection.</p><p>Principled development requires sane assumptions, and pragmatic development requires we know when these assumptions go wrong. The Scalaz 8 error model provides both in a single package, because even though the design assumes you work in Scalazzi, if you don’t, your defects will be captured and reported to supervisors.</p><h3 id="myth-6-bifunctor-io-doesnt-let-you-use-impure-code">Myth 6: Bifunctor IO Doesn’t Let You Use Impure Code</h3><p>This myth states that because the bifunctor design doesn’t automatically catch defects, you can’t use the effect type with Java code or impure Scala code.</p><p>This is not true at all. All code, including exception throwing, impure code, can be trivially imported into <code class="language-plaintext highlighter-rouge">IO</code>. In fact, there are three utility functions in Scalaz 8 that do just this:</p><ul><li><code class="language-plaintext highlighter-rouge">def syncThrowable[A](eff: =&gt; A): IO[Throwable, A]</code> — This function imports code that may throw <code class="language-plaintext highlighter-rouge">Throwable</code> values, properly translating them into <code class="language-plaintext highlighter-rouge">IO.fail</code> values.</li><li><code class="language-plaintext highlighter-rouge">def syncException[A](eff: =&gt; A): IO[Exception, A]</code> — This function imports code that may throw <code class="language-plaintext highlighter-rouge">Exception</code> values, properly translating them into <code class="language-plaintext highlighter-rouge">IO.fail</code> values.</li><li><code class="language-plaintext highlighter-rouge">def syncCatch[E, A](eff: =&gt; A)(pf: PartialFunction[Throwable, E]): IO[E, A]</code> — This function imports code that may throw a user-defined range of errors, properly translating them into <code class="language-plaintext highlighter-rouge">IO.fail</code> values.</li></ul><p>These functions let you safely interact with dysfunctional code, which performs side-effects and throws exceptions. You can import this code into pure values, which can interface with your functional code.</p><p>Wrapping unsafe code with <code class="language-plaintext highlighter-rouge">Try</code>, to safely convert exceptions into values, is something that many Scala developers are already doing. With Scalaz 8, the method you use changes, but not much else.</p><h3 id="myth-7-bifunctor-io-is-just-eithert">Myth 7: Bifunctor IO Is Just EitherT</h3><p>This myth states that bifunctor IO is unnecessary, since we can already achieve the same benefits by stacking the <code class="language-plaintext highlighter-rouge">EitherT</code> monad transformer on top of ordinary <code class="language-plaintext highlighter-rouge">IO</code>.</p><p>There are two flaws in this argument:</p><ol><li>For older effect types <code class="language-plaintext highlighter-rouge">F[_]</code> (such as Monix <code class="language-plaintext highlighter-rouge">Task</code>, cats-effect <code class="language-plaintext highlighter-rouge">IO</code>, and Scalaz 7.2 <code class="language-plaintext highlighter-rouge">IO</code> / <code class="language-plaintext highlighter-rouge">Task</code>), <code class="language-plaintext highlighter-rouge">EitherT[IO, E, ?]</code> has two error channels, overlapping instances for <code class="language-plaintext highlighter-rouge">MonadError</code> (one having an error type fixed to <code class="language-plaintext highlighter-rouge">Throwable</code>), two conflicting ways of failing, and two conflicting ways of recovering from failures. Contrast this to <code class="language-plaintext highlighter-rouge">IO[E, A]</code>, which has a single error channel.</li><li>Scalaz 8 bifunctor IO is functionally equivalent to <code class="language-plaintext highlighter-rouge">EitherT[UIO, E, A]</code> for some infallible effect type <code class="language-plaintext highlighter-rouge">UIO</code>. Although Scalaz 8 IO could be redesigned to be infallible, this would mean as much as a <em>5x performance penalty</em> for recapturing error handling using an <code class="language-plaintext highlighter-rouge">EitherT</code> monad transformer. As discussed in my <a href="http://degoes.net/articles/effects-without-transformers">last blog post</a>, monad transformers are not practical in Scala.</li></ol><p>Scalaz 8 IO brings something genuinely new to the table over <code class="language-plaintext highlighter-rouge">EitherT</code>: a clean, typed, single error channel, and high-performance, wrapped in a package that generalizes over all existing effect types.</p><h2 id="final-words">Final Words</h2><p>Like other changes in Scalaz 8, including the fiber concurrency model, fine-grained interruption, and resource safety, the bifunctor design of <code class="language-plaintext highlighter-rouge">IO</code> requires rethinking assumptions.</p><p>This new model doesn’t <em>require</em> you to be more precise, since you’re free to stick with <code class="language-plaintext highlighter-rouge">Throwable</code> for all your errors. But it does <em>empower</em> you to describe failure scenarios precisely, and vary <em>if</em> and <em>how</em> effects fail at different levels of your application.</p><p>Benefits of the error model are many, and include being able to model infallible effects (non-exceptional <code class="language-plaintext highlighter-rouge">IO</code>), use effects the way you’re familiar with (using <code class="language-plaintext highlighter-rouge">Throwable</code> everywhere) so you can gradually incorporate typed errors wherever useful, guarantee no resource leaks (even in the event of non-recoverable errors), never lose any errors (unlike other error models), and have strong, compile-time guarantees about <em>if</em> and <em>how</em> your effects can fail.</p><p>While there are myths out there about the new bifunctor design, this is expected since there is a scarcity of documentation. Without good documentation, there will always be questions about how a new design works or what the tradeoffs are. Hopefully this blog post succeeds in making the bifunctor design more accessible.</p><p>If I’ve convinced you the bifunctor design has value, vote with your feet: support projects like Scalaz 8 IO, encourage contributions like Luka Jacobowitz’s <a href="https://github.com/LukaJCB/cats-bio">bifunctor IO</a>, and contribute issues and pull requests to your favorite effect type.</p><p>Scalaz 8 IO may be the first one to adopt this design, but from the looks of things, it’s not the last. I greatly look forward to seeing others adopt and improve upon the design, to the benefit of the entire Scala functional programming community.</p><hr><footer role="contentinfo"><p class="byline"><strong>Bifunctor IO: A Step Away from Dynamically-Typed Error Handling</strong> was published on <time datetime="2018-05-10T00:00:00-06:00" itemprop="datePublished">May 10, 2018</time> by <span itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><span itemprop="name"><a href="http://degoes.net/about" title="About John A De Goes" itemprop="url">John A De Goes</a></span></span>.</p></footer></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>