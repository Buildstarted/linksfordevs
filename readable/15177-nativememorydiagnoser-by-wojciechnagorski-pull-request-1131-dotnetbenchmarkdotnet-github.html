<!DOCTYPE html>
<html lang="en">
<head>
    <title>
NativeMemoryDiagnoser by WojciechNagorski &#xB7; Pull Request #1131 &#xB7; dotnet/BenchmarkDotNet &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>NativeMemoryDiagnoser by WojciechNagorski · Pull Request #1131 · dotnet/BenchmarkDotNet · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>I've finally found some time. I've had a hard time.</p><p>I moved <code>IntroNativeMemory.cs</code> into <code>BenchmarkDotNet.Samples</code> and I used <code>Bitmap</code> and <code>Graphics</code> from <code>System.Drawing</code> to make native allocation instead of using custom <code>C++</code> dll.</p><p>I created two tests:</p><div class="highlight highlight-source-cs"><pre>        [<span class="pl-en">Benchmark</span>]
        <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">BitmapWithLeaks</span>()
        {
            <span class="pl-k">var</span><span class="pl-smi">flag</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Bitmap</span>(<span class="pl-c1">200</span>, <span class="pl-c1">100</span>);
            <span class="pl-k">var</span><span class="pl-smi">graphics</span><span class="pl-k">=</span><span class="pl-smi">Graphics</span>.<span class="pl-en">FromImage</span>(<span class="pl-smi">flag</span>);
            <span class="pl-k">var</span><span class="pl-smi">blackPen</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Pen</span>(<span class="pl-smi">Color</span>.<span class="pl-smi">Black</span>, <span class="pl-c1">3</span>);
            <span class="pl-smi">graphics</span>.<span class="pl-en">DrawLine</span>(<span class="pl-smi">blackPen</span>, <span class="pl-c1">100</span>, <span class="pl-c1">100</span>, <span class="pl-c1">500</span>, <span class="pl-c1">100</span>);
        }

        [<span class="pl-en">Benchmark</span>]
        <span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">Bitmap</span>()
        {
            <span class="pl-k">using</span> (<span class="pl-k">var</span><span class="pl-smi">flag</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Bitmap</span>(<span class="pl-c1">200</span>, <span class="pl-c1">100</span>))
            {
                <span class="pl-k">using</span> (<span class="pl-k">var</span><span class="pl-smi">graphics</span><span class="pl-k">=</span><span class="pl-smi">Graphics</span>.<span class="pl-en">FromImage</span>(<span class="pl-smi">flag</span>))
                {
                    <span class="pl-k">using</span> (<span class="pl-k">var</span><span class="pl-smi">blackPen</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Pen</span>(<span class="pl-smi">Color</span>.<span class="pl-smi">Black</span>, <span class="pl-c1">3</span>))
                    {
                        <span class="pl-smi">graphics</span>.<span class="pl-en">DrawLine</span>(<span class="pl-smi">blackPen</span>, <span class="pl-c1">100</span>, <span class="pl-c1">100</span>, <span class="pl-c1">500</span>, <span class="pl-c1">100</span>);
                    }
                }
            }
        }</pre></div><p>Below is the result of these tests.<br><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/17333903/59953461-7b7c9e00-9480-11e9-8637-ff012e0a8430.png"><img src="https://user-images.githubusercontent.com/17333903/59953461-7b7c9e00-9480-11e9-8637-ff012e0a8430.png" alt="image"></a></p><p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/17333903/59953475-89caba00-9480-11e9-99ef-768ee47d9eaf.png"><img src="https://user-images.githubusercontent.com/17333903/59953475-89caba00-9480-11e9-99ef-768ee47d9eaf.png" alt="image"></a></p><p><strong><strong>TODOs</strong></strong></p><ol><li>I have to compare this result with <code>PerfView</code>.</li></ol><p><strong><strong>Additional information</strong></strong><br>Thanks <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/kayle/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/kayle">@kayle</a> for your suggestions. Bellow are my answers:</p><blockquote><p>The docs indicate that heap profiling will likely cause severe slowdowns. Is it helpful/possible to force a single iteration with no warmup? Maybe hide the time metrics entirely or warn that they shouldn't be used?</p></blockquote><ol><li>NativeMemoryDiagnoser is used only in the extra diagnostic run. I set <code>performExtraBenchmarksRun=true</code> in <code>EtwProfilerConfig</code>.</li></ol><blockquote><p>Would it be better to have separate managed/native diagnosers, or a single diagnoser that can optionally collect both types of information. In theory, the managed type allocations are easier to track. I had started a prototype here (<a class="commit-link" data-hovercard-type="commit" data-hovercard-url="https://github.com/kayle/BenchmarkDotNet/commit/7d4a237/hovercard" href="https://github.com/kayle/BenchmarkDotNet/commit/7d4a237">kayle/BenchmarkDotNet@<tt>7d4a237</tt></a>)</p></blockquote><ol start="2"><li>Currently managed memory diagnoser does not use ETW at all. If we create new ETW Managed memory diagnoser then BenchmarkDotNet will have two different diagnosers. I'm not sure if it will be accepted by <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/adamsitnik/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/adamsitnik">@adamsitnik</a> or <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/AndreyAkinshin/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>.</li></ol><blockquote><p>Regarding adding a c++ project to this repository, I suspect there's a pinvoke available that would allocate on the native heap (or picking a class that uses SafeHandle internally since those need to free native resources).</p></blockquote><ol start="3"><li>It is a good suggestion. I used the <code>System.Drawing</code> instead of custom <code>C++</code> project. I'll try to find some example with native type.</li></ol><blockquote><p>How much disk I/O happens when collecting these ETW events? Ideally, we could process ETW with real-time listeners by default, and optionally save the ETL to disk for manual inspection.</p></blockquote><ol start="4"><li>It is a good suggestion. First I was trying to do real-time listeners but I didn't have all the information. Now I think it will be easy to do. I'll try.</li></ol><blockquote><p>I'm guessing a common case is to expect 0 allocations during a benchmark. It'd be nice to offer a simple pass/fail option for this case.</p></blockquote><ol start="5"><li>It is a good idea. I can do it but first I would like to finish current PR.</li></ol><blockquote><p>Leak tracking seems like more of a correctness issue than performance. I know you already did the hard part of the work, but it might be simpler and less work for this repo to only track raw allocations. To diagnose leaks, users could load the ETL file in perfview.</p></blockquote><ol start="6"><li>I think that <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/adamsitnik/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/adamsitnik">@adamsitnik</a> or <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/AndreyAkinshin/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a> should comment on this point. I will not have a problem removing this feature. But for me, the best solution will be tracking memory leaks without information about type. In this case, I could remove a big part of the code.</li></ol></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>