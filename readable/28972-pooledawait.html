<!DOCTYPE html>
<html lang="en">
<head>
    <title>
PooledAwait -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>PooledAwait</h1>
    <section class="main-content"> <p>Low-allocation utilies for writing <code class="highlighter-rouge">async</code> methods, and related tools</p> <h3 id="contents">Contents</h3> <h2 id="pooledvaluetask--pooledvaluetaskt"><code class="highlighter-rouge">PooledValueTask</code> / <code class="highlighter-rouge">PooledValueTask&lt;T&gt;</code></h2> <p>These are the main tools of the library; their purpose is to remove the boxing of the async state-machine and builder that happens when a method
marked <code class="highlighter-rouge">async</code> performs an <code class="highlighter-rouge">await</code> on an awaitable target that <em>is not yet complete</em>, i.e.</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">SomeMethod</span><span class="p">()</span>
<span class="p">{</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span> <span class="c1">// *is not yet complete*</span> <span class="k">return</span> <span class="m">42</span>
<span class="p">}</span>
</code></pre></div></div> <p>If you&#x2019;ve ever looked at an application that uses <code class="highlighter-rouge">async</code> / <code class="highlighter-rouge">await</code> in a memory profiler and seen things like <code class="highlighter-rouge">System.Runtime.CompilerServices.AsyncTaskMethodBuilder</code><code class="highlighter-rouge">1.AsyncStateMachineBox</code><code class="highlighter-rouge">1</code>
or <code class="highlighter-rouge">YourLib.&lt;&lt;SomeMethod&gt;g__Inner|8_0&gt;d</code>, then that&#x2019;s what I&#x2019;m talking about. You can avoid this by simply using a different return type:</p> <ul> <li><code class="highlighter-rouge">PooledValueTask&lt;T&gt;</code> instead of <code class="highlighter-rouge">ValueTask&lt;T&gt;</code></li> <li><code class="highlighter-rouge">PooledValueTask</code> instead of <code class="highlighter-rouge">ValueTask</code></li>
</ul> <p>For <code class="highlighter-rouge">private</code> / <code class="highlighter-rouge">internal</code> methods, you can probably just <em>change the return type directly</em>:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">async</span> <span class="n">PooledValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">SomeMethod</span><span class="p">()</span>
<span class="p">{</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span> <span class="c1">// *is not yet complete*</span> <span class="k">return</span> <span class="m">42</span>
<span class="p">}</span>
</code></pre></div></div> <p>For methods on your <code class="highlighter-rouge">public</code> API surface, you can use a &#x201C;local function&#x201D; to achieve the same thing without changing the exposed return type:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">SomeMethod</span><span class="p">()</span> <span class="c1">// not marked async</span>
<span class="p">{</span> <span class="k">return</span> <span class="nf">Impl</span><span class="p">();</span> <span class="k">async</span> <span class="n">PooledValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;()</span> <span class="nf">Impl</span><span class="p">()</span> <span class="p">{</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span> <span class="c1">// *is not yet complete*</span> <span class="k">return</span> <span class="m">42</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>(all of the <code class="highlighter-rouge">Pooled*</code> types have <code class="highlighter-rouge">implicit</code> conversion operators to their more well-recognized brethren).</p> <p>And that&#x2019;s it! That&#x2019;s all you have to do. The &#x201C;catch&#x201D; (there&#x2019;s always a catch) is that awaiting the same pending operation <em>more than once</em> <strong>no longer works</strong>:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">pending</span> <span class="p">=</span> <span class="nf">SomeIncompleteMethodAsync</span><span class="p">();</span> <span class="c1">// note no &quot;await&quot; here</span> <span class="kt">var</span> <span class="n">x</span> <span class="p">=</span> <span class="k">await</span> <span class="n">pending</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">y</span> <span class="p">=</span> <span class="k">await</span> <span class="n">pending</span><span class="p">;</span> <span class="c1">// BOOM! await the **same result**</span>
</code></pre></div></div> <p>In reality, <strong>this almost never happens</strong>. Usually you <code class="highlighter-rouge">await</code> something <em>once</em>, <em>almost always</em> right away. So&#x2026; yeah.</p> <h2 id="pooledtask--pooledtaskt"><code class="highlighter-rouge">PooledTask</code> / <code class="highlighter-rouge">PooledTask&lt;T&gt;</code></h2> <p>These work very similarly to <code class="highlighter-rouge">PooledValueTask[&lt;T&gt;]</code>, but for the <code class="highlighter-rouge">Task[&lt;T&gt;]</code> API. It can&#x2019;t be <em>quite</em> as frugal, as in most cases a <code class="highlighter-rouge">Task[&lt;T&gt;]</code>
will still need to be allocated (unless it is the non-generic <code class="highlighter-rouge">PooledTask</code> signature, and the operation completes synchronously), but it
still avoids the state-machine box etc. Note that this API <strong>is not</strong> impacted by the &#x201C;you can only await it once&#x201D; change (you can
await these as many times as you like - they are, after all, <code class="highlighter-rouge">Task[&lt;T&gt;]</code>), but again: <em>this is used incredibly rarely anyway</em>.</p> <h2 id="fireandforget"><code class="highlighter-rouge">FireAndForget</code></h2> <p>Ever find yourself needing a fire-and-forget API? This adds one. All you do is declare the return type as <code class="highlighter-rouge">FireAndForget</code>:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FireAndForget</span> <span class="nf">SomeMethod</span><span class="p">(...)</span> <span class="p">{</span> <span class="c1">// .. things before the first incomplete await happen on the calling thread</span> <span class="k">await</span> <span class="nf">SomeIncompleteMethod</span><span class="p">();</span> <span class="c1">// .. other bits continue running in the background</span>
<span class="p">}</span>
</code></pre></div></div> <p>As soon as the method uses <code class="highlighter-rouge">await</code> against an incomplete operation, the calling
task regains control as though it were complete; the rest of the operation continues in the background. The caller can simply <code class="highlighter-rouge">await</code>
the fire-and-forget method with confidence that it only runs synchronously to the first incomplete operation. If you&#x2019;re not in an <code class="highlighter-rouge">async</code>
method, you can use &#x201C;discard&#x201D; to tell the compiler not to tell you to <code class="highlighter-rouge">await</code> it:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_</span> <span class="p">=</span> <span class="nf">SomeFireAndForgetMethodAsync</span><span class="p">();</span>
</code></pre></div></div> <p>You won&#x2019;t get unobserved-task-exception problems. If you want to see any exceptions that happen, there is an event <code class="highlighter-rouge">FireAndForget.Exception</code>
that you can subscribe to. Otherwise, they just evaporate.</p> <h2 id="valuetaskcompletionsourcet"><code class="highlighter-rouge">ValueTaskCompletionSource&lt;T&gt;</code></h2> <p>Do you make use of <code class="highlighter-rouge">TaskCompletionSource&lt;T&gt;</code>? Do you hate that this adds another allocation <em>on top of</em> the <code class="highlighter-rouge">Task&lt;T&gt;</code> that you actually wanted?
<code class="highlighter-rouge">ValueTaskCompletionSource&lt;T&gt;</code> is your friend. It uses smoke and magic to work like <code class="highlighter-rouge">TaskCompletionSource&lt;T&gt;</code>, but without the extra
allocation (unless it discovers that the magic isn&#x2019;t working for your system). Usage:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="n">ValueTaskCompletionSource</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;.</span><span class="nf">Create</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">source</span><span class="p">.</span><span class="nf">TrySetResult</span><span class="p">(</span><span class="m">42</span><span class="p">);</span> <span class="c1">// etc</span>
</code></pre></div></div> <p>The main difference here is that you now have a <code class="highlighter-rouge">struct</code> instead of a <code class="highlighter-rouge">class</code>. If you want to test whether an instance is a <em>real</em> value
(as opposed to the <code class="highlighter-rouge">default</code>), check <code class="highlighter-rouge">.HasTask</code>.</p> <h2 id="pooledvaluetasksource--pooledvaluetasksourcet"><code class="highlighter-rouge">PooledValueTaskSource</code> / <code class="highlighter-rouge">PooledValueTaskSource&lt;T&gt;</code></h2> <p>These again work like <code class="highlighter-rouge">TaskCompletionSource&lt;T&gt;</code>, but a: for <code class="highlighter-rouge">ValueType[&lt;T&gt;]</code>, and b: with the same zero-allocation features that
<code class="highlighter-rouge">PooledValueTask</code> / <code class="highlighter-rouge">PooledValueTask&lt;T&gt;</code> exhibit. Once again, the &#x201C;catch&#x201D; is that you can only await their <code class="highlighter-rouge">.Task</code> <em>once</em>. Usage:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">source</span> <span class="p">=</span> <span class="n">PooledValueTaskSource</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;.</span><span class="nf">Create</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">source</span><span class="p">.</span><span class="nf">TrySetResult</span><span class="p">(</span><span class="m">42</span><span class="p">);</span> <span class="c1">// etc</span>
</code></pre></div></div> <h2 id="pool"><code class="highlighter-rouge">Pool</code></h2> <p>Ever need a light-weight basic pool of objects? That&#x2019;s this. Nothing fancy. The first API is a simple get/put:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">Pool</span><span class="p">.</span><span class="n">TryRent</span><span class="p">&lt;</span><span class="n">SomeType</span><span class="p">&gt;()</span> <span class="p">??</span> <span class="k">new</span> <span class="nf">SomeType</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="n">Pool</span><span class="p">.</span><span class="nf">Return</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</code></pre></div></div> <p>Note that it leaves creation to you (hence the <code class="highlighter-rouge">?? new SomeType()</code>), and it is the caller&#x2019;s responsibility to not retain and access
a reference object that you have notionally returned to the pool.</p> <p>Considerations:</p> <ul> <li>you may wish to use <code class="highlighter-rouge">try</code>/<code class="highlighter-rouge">finally</code> to put things back into the pool even if you leave through failure</li> <li>if the object might <strong>unnecessarily</strong> keep large graphs of sub-objects &#x201C;reachable&#x201D; (in terms of GC), you should ensure that any references are wiped before putting an object into the pool</li> <li>if the object implements <code class="highlighter-rouge">IResettable</code>, the pool will automatically call the <code class="highlighter-rouge">Reset()</code> method for you before storing items in the pool</li>
</ul> <p>A second API is exposed for use with value-types; there are a lot of scenarios in which you have some state that you need to expose
to an API that takes <code class="highlighter-rouge">object</code> - especially with callbacks like <code class="highlighter-rouge">WaitCallback</code>, <code class="highlighter-rouge">SendOrPostCallback</code>, <code class="highlighter-rouge">Action&lt;object&gt;</code>, etc. The data
will only be unboxed once at the receiver - so: rather than use a <em>regular</em> box, we can <em>rent</em> a box. Also, if you have multiple items of
state that you need to convey - consider a value-tuple.</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">id</span> <span class="p">=</span> <span class="p">...</span>
<span class="kt">string</span> <span class="n">name</span> <span class="p">=</span> <span class="p">...</span>
<span class="kt">var</span> <span class="n">obj</span> <span class="p">=</span> <span class="n">Pool</span><span class="p">.</span><span class="nf">Box</span><span class="p">((</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
<span class="c1">// ... probably pass obj to a callback-API</span>
</code></pre></div></div> <p>then later:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">var</span> <span class="n">id</span><span class="p">,</span> <span class="kt">var</span> <span class="n">name</span><span class="p">)</span> <span class="p">=</span> <span class="n">Pool</span><span class="p">.</span><span class="n">UnboxAndReturn</span><span class="p">&lt;(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">)&gt;(</span><span class="n">obj</span><span class="p">);</span>
<span class="c1">// use id/name as usual</span>
</code></pre></div></div> <p>It is the caller&#x2019;s responsibility to only access the state once.</p> </section>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>