<!DOCTYPE html>
<html lang="en">
<head>
    <title>
System.Buffers - .NET - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="System.Buffers - .NET - linksfor.dev(s)"/>
    <meta property="article:author" content="Rick-Anderson"/>
    <meta property="og:description" content="This article provides an overview of types that help read data that runs across multiple buffers. They&#x27;re primarily used to support PipeReader objects."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://docs.microsoft.com/en-us/dotnet/standard/io/buffers"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - System.Buffers - .NET</title>
<div class="readable">
        <h1>System.Buffers - .NET</h1>
            <div>by Rick-Anderson</div>
            <div>Reading time: 15-19 minutes</div>
        <div>Posted here: 10 Dec 2019</div>
        <p><a href="https://docs.microsoft.com/en-us/dotnet/standard/io/buffers">https://docs.microsoft.com/en-us/dotnet/standard/io/buffers</a></p>
        <hr/>
<div id="readability-page-1" class="page">


	<div data-bi-name="body">

		<div>

			

			<section>
				<div>


				<div id="main-column">

					<main id="main" role="main" data-bi-name="content" lang="en-us" dir="ltr">



						

						<ul data-bi-name="page info" lang="en-us" dir="ltr">
							<li>
								<time role="presentation" datetime="2019-12-05T00:00:00.000Z" data-article-date-source="ms.date">12/05/2019</time>
							</li>
								<li>9 minutes to read</li>
							<li>
								<a href="https://github.com/dotnet/docs/blob/master/docs/standard/io/buffers.md" title="1 Contributor" aria-label="1 Contributor">
									<ul data-bi-name="contributors" aria-hidden="true">
												<li><img src="https://github.com/Rick-Anderson.png?size=32" data-src="https://github.com/Rick-Anderson.png?size=32" role="presentation"></li>
									</ul>
								</a>
							</li>

						</ul>

						<nav id="center-doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">
							<h3>In this article</h3>
						<ol><li><a href="#ibufferwritert">IBufferWriter&lt;T&gt;</a></li><li><a href="#readonlysequencet">ReadOnlySequence&lt;T&gt;</a></li><li><a href="#sequencereadert">SequenceReader&lt;T&gt;</a></li></ol></nav>


						<!-- <content> -->
							
<p>This article provides an overview of types that help read data that runs across multiple buffers. They're primarily used to support <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader" data-linktype="absolute-path">PipeReader</a> objects.</p>
<h2 id="ibufferwritert">IBufferWriter&lt;T&gt;<a href="#ibufferwritert" aria-labelledby="ibufferwritert"></a></h2>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.ibufferwriter-1" data-linktype="absolute-path">System.Buffers.IBufferWriter&lt;T&gt;</a> is a contract for synchronous buffered writing. At the lowest level, the interface:</p>
<ul>
<li>Is basic and not difficult to use.</li>
<li>Allows access to a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.memory-1" data-linktype="absolute-path">Memory&lt;T&gt;</a> or <a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1" data-linktype="absolute-path">Span&lt;T&gt;</a>. The <code>Memory&lt;T&gt;</code> or <code>Span&lt;T&gt;</code> can be written to and you can determine how many <code>T</code> items were written.</li>
</ul>
<pre tabindex="0"><code data-author-content="void WriteHello(IBufferWriter<byte> writer)
{
    // Request at least 5 bytes.
    Span<byte> span = writer.GetSpan(5);
    ReadOnlySpan<char> helloSpan = &quot;Hello&quot;.AsSpan();
    int written = Encoding.ASCII.GetBytes(helloSpan, span);

    // Tell the writer how many bytes were written.
    writer.Advance(written);
}
"><span><span><span>void</span> <span>WriteHello</span>(<span>IBufferWriter&lt;<span>byte</span>&gt; writer</span>)</span>
{
    <span>// Request at least 5 bytes.</span>
    Span&lt;<span>byte</span>&gt; span = writer.GetSpan(<span>5</span>);
    ReadOnlySpan&lt;<span>char</span>&gt; helloSpan = <span>"Hello"</span>.AsSpan();
    <span>int</span> written = Encoding.ASCII.GetBytes(helloSpan, span);

    <span>// Tell the writer how many bytes were written.</span>
    writer.Advance(written);
}
</span></code></pre>
<p>The preceding method:</p>
<ul>
<li>Requests a buffer of at least 5 bytes from the <code>IBufferWriter&lt;byte&gt;</code> using <code>GetSpan(5)</code>.</li>
<li>Writes bytes for the ASCII string "Hello" to the returned <code>Span&lt;byte&gt;</code>.</li>
<li>Calls  <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.ibufferwriter-1" data-linktype="absolute-path">IBufferWriter&lt;T&gt;</a> to indicate how many bytes were written to the buffer.</li>
</ul>
<p>This method of writing uses the <code>Memory&lt;T&gt;</code>/<code>Span&lt;T&gt;</code> buffer provided by the <code>IBufferWriter&lt;T&gt;</code>. Alternatively, the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.buffersextensions.write" data-linktype="absolute-path">Write</a> extension method can be used to copy an existing buffer to the <code>IBufferWriter&lt;T&gt;</code>. <code>Write</code> does the work of calling <code>GetSpan</code>/<code>Advance</code> as appropriate, so there's no need to call <code>Advance</code> after writing:</p>
<pre tabindex="0"><code data-author-content="void WriteHello(IBufferWriter<byte> writer)
{
    byte[] helloBytes = Encoding.ASCII.GetBytes(&quot;Hello&quot;);

    // Write helloBytes to the writer. There's no need to call Advance here
    // since Write calls Advance.
    writer.Write(helloBytes);
}
"><span><span><span>void</span> <span>WriteHello</span>(<span>IBufferWriter&lt;<span>byte</span>&gt; writer</span>)</span>
{
    <span>byte</span>[] helloBytes = Encoding.ASCII.GetBytes(<span>"Hello"</span>);

    <span>// Write helloBytes to the writer. There's no need to call Advance here</span>
    <span>// since Write calls Advance.</span>
    writer.Write(helloBytes);
}
</span></code></pre>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraybufferwriter-1" data-linktype="absolute-path">ArrayBufferWriter&lt;T&gt;</a> is an implementation of <code>IBufferWriter&lt;T&gt;</code> whose backing store is a single contiguous array.</p>
<h3 id="ibufferwriter-common-problems">IBufferWriter common problems<a href="#ibufferwriter-common-problems" aria-labelledby="ibufferwriter-common-problems"></a></h3>
<ul>
<li><code>GetSpan</code> and <code>GetMemory</code> return a buffer with at least the requested amount of memory. Don't assume exact buffer sizes.</li>
<li>There's no guarantee that successive calls will return the same buffer or the same-sized buffer.</li>
<li>A new buffer must be requested after calling <code>Advance</code> to continue writing more data. A previously acquired buffer cannot be written to after <code>Advance</code> has been called.</li>
</ul>
<h2 id="readonlysequencet">ReadOnlySequence&lt;T&gt;<a href="#readonlysequencet" aria-labelledby="readonlysequencet"></a></h2>
<p><img src="https://docs.microsoft.com/en-us/dotnet/standard/io/media/buffers/ro-sequence.png" alt="ReadOnlySequence showing memory in pipe and below that sequence position of read-only memory" data-linktype="relative-path"></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.readonlysequence-1" data-linktype="absolute-path">ReadOnlySequence&lt;T&gt;</a> is a struct that can represent a contiguous or noncontiguous sequence of <code>T</code>. It can be constructed from:</p>
<ol>
<li>A <code>T[]</code></li>
<li>A <code>ReadOnlyMemory&lt;T&gt;</code></li>
<li>A pair of linked list node <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.readonlysequencesegment-1" data-linktype="absolute-path">ReadOnlySequenceSegment&lt;T&gt;</a> and index to represent the start and end position of the sequence.</li>
</ol>
<p>The third representation is the most interesting one as it has performance implications on various operations on the <code>ReadOnlySequence&lt;T&gt;</code>:</p>

<p>Because of this mixed representation, the <code>ReadOnlySequence&lt;T&gt;</code> exposes indexes as <code>SequencePosition</code> instead of an integer. A <code>SequencePosition</code>:</p>
<ul>
<li>Is an opaque value that represents an index into the <code>ReadOnlySequence&lt;T&gt;</code> where it originated.</li>
<li>Consists of two parts, an integer and an object. What these two values represent are tied to the implementation of <code>ReadOnlySequence&lt;T&gt;</code>.</li>
</ul>
<h3 id="access-data">Access data<a href="#access-data" aria-labelledby="access-data"></a></h3>
<p>The <code>ReadOnlySequence&lt;T&gt;</code> exposes data as an enumerable of <code>ReadOnlyMemory&lt;T&gt;</code>. Enumerating each of the segments can be done using a basic foreach:</p>
<pre tabindex="0"><code data-author-content="long FindIndexOf(in ReadOnlySequence<byte> buffer, byte data)
{
    long position = 0;

    foreach (ReadOnlyMemory<byte> segment in buffer)
    {
        ReadOnlySpan<byte> span = segment.Span;
        var index = span.IndexOf(data);
        if (index != -1)
        {
            return position + index;
        }

        position += span.Length;
    }

    return -1;
}
"><span><span><span>long</span> <span>FindIndexOf</span>(<span><span>in</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, <span>byte</span> data</span>)</span>
{
    <span>long</span> position = <span>0</span>;

    <span>foreach</span> (ReadOnlyMemory&lt;<span>byte</span>&gt; segment <span>in</span> buffer)
    {
        ReadOnlySpan&lt;<span>byte</span>&gt; span = segment.Span;
        <span>var</span> index = span.IndexOf(data);
        <span>if</span> (index != <span>-1</span>)
        {
            <span>return</span> position + index;
        }

        position += span.Length;
    }

    <span>return</span> <span>-1</span>;
}
</span></code></pre>
<p>The preceding method searches each segment for a specific byte. If you need to keep track of each segment's <code>SequencePosition</code>,
<a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.readonlysequence-1.tryget" data-linktype="absolute-path">ReadOnlySequence&lt;T&gt;.TryGet</a> is more appropriate. The next sample changes the preceding code to return a <code>SequencePosition</code> instead of an integer. Returning a <code>SequencePosition</code> has the benefit of allowing the caller to avoid a second scan to get the data at a specific index.</p>
<pre tabindex="0"><code data-author-content="SequencePosition? FindIndexOf(in ReadOnlySequence<byte> buffer, byte data)
{
    SequencePosition position = buffer.Start;

    while (buffer.TryGet(ref position, out ReadOnlyMemory<byte> segment))
    {
        ReadOnlySpan<byte> span = segment.Span;
        var index = span.IndexOf(data);
        if (index != -1)
        {
            return buffer.GetPosition(position, index);
        }
    }
    return null;
}
"><span>SequencePosition? FindIndexOf(<span>in</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, <span>byte</span> data)
{
    SequencePosition position = buffer.Start;

    <span>while</span> (buffer.TryGet(<span>ref</span> position, <span>out</span> ReadOnlyMemory&lt;<span>byte</span>&gt; segment))
    {
        ReadOnlySpan&lt;<span>byte</span>&gt; span = segment.Span;
        <span>var</span> index = span.IndexOf(data);
        <span>if</span> (index != <span>-1</span>)
        {
            <span>return</span> buffer.GetPosition(position, index);
        }
    }
    <span>return</span> <span>null</span>;
}
</span></code></pre>
<p>The combination of <code>SequencePosition</code> and <code>TryGet</code> acts like an enumerator. The position field is modified at the start of each iteration to be start of each segment within the <code>ReadOnlySequence&lt;T&gt;</code>.</p>
<p>The preceding method exists as an extension method on <code>ReadOnlySequence&lt;T&gt;</code>. <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.buffersextensions.positionof" data-linktype="absolute-path">PositionOf</a> can be used to simplify the preceding code:</p>
<pre tabindex="0"><code data-author-content="SequencePosition? FindIndexOf(in ReadOnlySequence<byte> buffer, byte data) => buffer.PositionOf(data);
"><span>SequencePosition? FindIndexOf(<span>in</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, <span>byte</span> data) =&gt; buffer.PositionOf(data);
</span></code></pre>
<h4 id="process-a-readonlysequencet">Process a ReadOnlySequence&lt;T&gt;<a href="#process-a-readonlysequencet" aria-labelledby="process-a-readonlysequencet"></a></h4>
<p>Processing a <code>ReadOnlySequence&lt;T&gt;</code> can be challenging since data may be split across multiple segments within the sequence. For the best performance, split code into two paths:</p>
<ul>
<li>A fast path that deals with the single segment case.</li>
<li>A slow path that deals with the data split across segments.</li>
</ul>
<p>There are a few approaches that can be used to process data in multi-segmented sequences:</p>
<ul>
<li>Use the <a href="#sequencereadert" data-linktype="self-bookmark"><code>SequenceReader&lt;T&gt;</code></a>.</li>
<li>Parse data segment by segment, keeping track of the <code>SequencePosition</code> and index within the segment parsed. This avoids unnecessary allocations but may be inefficient, especially for small buffers.</li>
<li>Copy the <code>ReadOnlySequence&lt;T&gt;</code> to a contiguous array and treat it like a single buffer:
<ul>
<li>If the size of the <code>ReadOnlySequence&lt;T&gt;</code> is small, it may be reasonable to copy the data into a stack-allocated buffer using the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/stackalloc" data-linktype="relative-path">stackalloc</a> operator.</li>
<li>Copy the <code>ReadOnlySequence&lt;T&gt;</code> into a pooled array using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.arraypool-1.shared" data-linktype="absolute-path">ArrayPool&lt;T&gt;.Shared</a>.</li>
<li>Use <a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.buffersextensions.toarray" data-linktype="absolute-path"><code>ReadOnlySequence&lt;T&gt;.ToArray()</code></a>. This isn't recommended in hot paths as it allocates a new <code>T[]</code> on the heap.</li>
</ul>
</li>
</ul>
<p>The following examples demonstrate some common cases for processing <code>ReadOnlySequence&lt;byte&gt;</code>:</p>
<h5 id="process-binary-data">Process binary data<a href="#process-binary-data" aria-labelledby="process-binary-data"></a></h5>
<p>The following example parses a 4-byte big-endian integer length from the start of the <code>ReadOnlySequence&lt;byte&gt;</code>.</p>
<pre tabindex="0"><code data-author-content="bool TryParseHeaderLength(ref ReadOnlySequence<byte> buffer, out int length)
{
    // If there's not enough space, the length can't be obtained.
    if (buffer.Length < 4)
    {
        length = 0;
        return false;
    }

    // Grab the first 4 bytes of the buffer.
    var lengthSlice = buffer.Slice(buffer.Start, 4);
    if (lengthSlice.IsSingleSegment)
    {
        // Fast path since it's a single segment.
        length = BinaryPrimitives.ReadInt32BigEndian(lengthSlice.First.Span);
    }
    else
    {
        // There are 4 bytes split across multiple segments. Since it's so small, it 
        // can be copied to a stack allocated buffer. This avoids a heap allocation.
        Span<byte> stackBuffer = stackalloc byte[4];
        lengthSlice.CopyTo(stackBuffer);
        length = BinaryPrimitives.ReadInt32BigEndian(stackBuffer);
    }

    // Move the buffer 4 bytes ahead.
    buffer = buffer.Slice(lengthSlice.End);

    return true;
}
"><span><span><span>bool</span> <span>TryParseHeaderLength</span>(<span><span>ref</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, <span>out</span> <span>int</span> length</span>)</span>
{
    <span>// If there's not enough space, the length can't be obtained.</span>
    <span>if</span> (buffer.Length &lt; <span>4</span>)
    {
        length = <span>0</span>;
        <span>return</span> <span>false</span>;
    }

    <span>// Grab the first 4 bytes of the buffer.</span>
    <span>var</span> lengthSlice = buffer.Slice(buffer.Start, <span>4</span>);
    <span>if</span> (lengthSlice.IsSingleSegment)
    {
        <span>// Fast path since it's a single segment.</span>
        length = BinaryPrimitives.ReadInt32BigEndian(lengthSlice.First.Span);
    }
    <span>else</span>
    {
        <span>// There are 4 bytes split across multiple segments. Since it's so small, it </span>
        <span>// can be copied to a stack allocated buffer. This avoids a heap allocation.</span>
        Span&lt;<span>byte</span>&gt; stackBuffer = <span>stackalloc</span> <span>byte</span>[<span>4</span>];
        lengthSlice.CopyTo(stackBuffer);
        length = BinaryPrimitives.ReadInt32BigEndian(stackBuffer);
    }

    <span>// Move the buffer 4 bytes ahead.</span>
    buffer = buffer.Slice(lengthSlice.End);

    <span>return</span> <span>true</span>;
}
</span></code></pre><h5 id="process-text-data">Process text data<a href="#process-text-data" aria-labelledby="process-text-data"></a></h5>
<p>The following example:</p>
<ul>
<li>Finds the first newline (<code>\r\n</code>) in the <code>ReadOnlySequence&lt;byte&gt;</code> and returns it via the out 'line' parameter.</li>
<li>Trims that line, excluding the <code>\r\n</code> from the input buffer.</li>
</ul>
<pre tabindex="0"><code data-author-content="static bool TryParseLine(ref ReadOnlySequence<byte> buffer, out ReadOnlySequence<byte> line)
{
    SequencePosition position = buffer.Start;
    SequencePosition previous = position;
    var index = -1;
    line = default;

    while (buffer.TryGet(ref position, out ReadOnlyMemory<byte> segment))
    {
        ReadOnlySpan<byte> span = segment.Span;

        // Look for \r in the current segment.
        index = span.IndexOf((byte)'\r');

        if (index != -1)
        {
            // Check next segment for \n.
            if (index + 1 >= span.Length)
            {
                var next = position;
                if (!buffer.TryGet(ref next, out ReadOnlyMemory<byte> nextSegment))
                {
                    // You're at the end of the sequence.
                    return false;
                }
                else if (nextSegment.Span[0] == (byte)'\n')
                {
                    //  A match was found.
                    break;
                }
            }
            // Check the current segment of \n.
            else if (span[index + 1] == (byte)'\n')
            {
                // It was found.
                break;
            }
        }

        previous = position;
    }

    if (index != -1)
    {
        // Get the position just before the \r\n.
        var delimeter = buffer.GetPosition(index, previous);

        // Slice the line (excluding \r\n).
        line = buffer.Slice(buffer.Start, delimeter);

        // Slice the buffer to get the remaining data after the line.
        buffer = buffer.Slice(buffer.GetPosition(2, delimeter));
        return true;
    }

    return false;
}
"><span><span><span>static</span> <span>bool</span> <span>TryParseLine</span>(<span><span>ref</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, <span>out</span> ReadOnlySequence&lt;<span>byte</span>&gt; line</span>)</span>
{
    SequencePosition position = buffer.Start;
    SequencePosition previous = position;
    <span>var</span> index = <span>-1</span>;
    line = <span>default</span>;

    <span>while</span> (buffer.TryGet(<span>ref</span> position, <span>out</span> ReadOnlyMemory&lt;<span>byte</span>&gt; segment))
    {
        ReadOnlySpan&lt;<span>byte</span>&gt; span = segment.Span;

        <span>// Look for \r in the current segment.</span>
        index = span.IndexOf((<span>byte</span>)<span>'\r'</span>);

        <span>if</span> (index != <span>-1</span>)
        {
            <span>// Check next segment for \n.</span>
            <span>if</span> (index + <span>1</span> &gt;= span.Length)
            {
                <span>var</span> next = position;
                <span>if</span> (!buffer.TryGet(<span>ref</span> next, <span>out</span> ReadOnlyMemory&lt;<span>byte</span>&gt; nextSegment))
                {
                    <span>// You're at the end of the sequence.</span>
                    <span>return</span> <span>false</span>;
                }
                <span>else</span> <span>if</span> (nextSegment.Span[<span>0</span>] == (<span>byte</span>)<span>'\n'</span>)
                {
                    <span>//  A match was found.</span>
                    <span>break</span>;
                }
            }
            <span>// Check the current segment of \n.</span>
            <span>else</span> <span>if</span> (span[index + <span>1</span>] == (<span>byte</span>)<span>'\n'</span>)
            {
                <span>// It was found.</span>
                <span>break</span>;
            }
        }

        previous = position;
    }

    <span>if</span> (index != <span>-1</span>)
    {
        <span>// Get the position just before the \r\n.</span>
        <span>var</span> delimeter = buffer.GetPosition(index, previous);

        <span>// Slice the line (excluding \r\n).</span>
        line = buffer.Slice(buffer.Start, delimeter);

        <span>// Slice the buffer to get the remaining data after the line.</span>
        buffer = buffer.Slice(buffer.GetPosition(<span>2</span>, delimeter));
        <span>return</span> <span>true</span>;
    }

    <span>return</span> <span>false</span>;
}
</span></code></pre><h5 id="empty-segments">Empty segments<a href="#empty-segments" aria-labelledby="empty-segments"></a></h5>
<p>It's valid to store empty segments inside of a <code>ReadOnlySequence&lt;T&gt;</code>. Empty segments may occur while enumerating segments explicitly:</p>
<pre tabindex="0"><code data-author-content="static void EmptySegments()
{
    // This logic creates a ReadOnlySequence<byte> with 4 segments,
    // two of which are empty.
    var first = new BufferSegment(new byte[0]);
    var last = first.Append(new byte[] { 97 })
                    .Append(new byte[0]).Append(new byte[] { 98 });

    // Construct the ReadOnlySequence<byte> from the linked list segments.
    var data = new ReadOnlySequence<byte>(first, 0, last, 1);

    // Slice using numbers.
    var sequence1 = data.Slice(0, 2);

    // Slice using SequencePosition pointing at the empty segment.
    var sequence2 = data.Slice(data.Start, 2);

    Console.WriteLine($&quot;sequence1.Length={sequence1.Length}&quot;); // sequence1.Length=2
    Console.WriteLine($&quot;sequence2.Length={sequence2.Length}&quot;); // sequence2.Length=2

    // sequence1.FirstSpan.Length=1
    Console.WriteLine($&quot;sequence1.FirstSpan.Length={sequence1.FirstSpan.Length}&quot;);

    // Slicing using SequencePosition will Slice the ReadOnlySequence<byte> directly 
    // on the empty segment!
    // sequence2.FirstSpan.Length=0
    Console.WriteLine($&quot;sequence2.FirstSpan.Length={sequence2.FirstSpan.Length}&quot;);

    // The following code prints 0, 1, 0, 1.
    SequencePosition position = data.Start;
    while (data.TryGet(ref position, out ReadOnlyMemory<byte> memory))
    {
        Console.WriteLine(memory.Length);
    }
}

class BufferSegment : ReadOnlySequenceSegment<byte>
{
    public BufferSegment(Memory<byte> memory)
    {
        Memory = memory;
    }

    public BufferSegment Append(Memory<byte> memory)
    {
        var segment = new BufferSegment(memory)
        {
            RunningIndex = RunningIndex + Memory.Length
        };
        Next = segment;
        return segment;
    }
}
"><span><span><span>static</span> <span>void</span> <span>EmptySegments</span>(<span></span>)</span>
{
    <span>// This logic creates a ReadOnlySequence&lt;byte&gt; with 4 segments,</span>
    <span>// two of which are empty.</span>
    <span>var</span> first = <span>new</span> BufferSegment(<span>new</span> <span>byte</span>[<span>0</span>]);
    <span>var</span> last = first.Append(<span>new</span> <span>byte</span>[] { <span>97</span> })
                    .Append(<span>new</span> <span>byte</span>[<span>0</span>]).Append(<span>new</span> <span>byte</span>[] { <span>98</span> });

    <span>// Construct the ReadOnlySequence&lt;byte&gt; from the linked list segments.</span>
    <span>var</span> data = <span>new</span> ReadOnlySequence&lt;<span>byte</span>&gt;(first, <span>0</span>, last, <span>1</span>);

    <span>// Slice using numbers.</span>
    <span>var</span> sequence1 = data.Slice(<span>0</span>, <span>2</span>);

    <span>// Slice using SequencePosition pointing at the empty segment.</span>
    <span>var</span> sequence2 = data.Slice(data.Start, <span>2</span>);

    Console.WriteLine(<span>$"sequence1.Length=<span>{sequence1.Length}</span>"</span>); <span>// sequence1.Length=2</span>
    Console.WriteLine(<span>$"sequence2.Length=<span>{sequence2.Length}</span>"</span>); <span>// sequence2.Length=2</span>

    <span>// sequence1.FirstSpan.Length=1</span>
    Console.WriteLine(<span>$"sequence1.FirstSpan.Length=<span>{sequence1.FirstSpan.Length}</span>"</span>);

    <span>// Slicing using SequencePosition will Slice the ReadOnlySequence&lt;byte&gt; directly </span>
    <span>// on the empty segment!</span>
    <span>// sequence2.FirstSpan.Length=0</span>
    Console.WriteLine(<span>$"sequence2.FirstSpan.Length=<span>{sequence2.FirstSpan.Length}</span>"</span>);

    <span>// The following code prints 0, 1, 0, 1.</span>
    SequencePosition position = data.Start;
    <span>while</span> (data.TryGet(<span>ref</span> position, <span>out</span> ReadOnlyMemory&lt;<span>byte</span>&gt; memory))
    {
        Console.WriteLine(memory.Length);
    }
}

<span>class</span> <span>BufferSegment</span> : <span>ReadOnlySequenceSegment</span>&lt;<span>byte</span>&gt;
{
    <span><span>public</span> <span>BufferSegment</span>(<span>Memory&lt;<span>byte</span>&gt; memory</span>)</span>
    {
        Memory = memory;
    }

    <span><span>public</span> BufferSegment <span>Append</span>(<span>Memory&lt;<span>byte</span>&gt; memory</span>)</span>
    {
        <span>var</span> segment = <span>new</span> BufferSegment(memory)
        {
            RunningIndex = RunningIndex + Memory.Length
        };
        Next = segment;
        <span>return</span> segment;
    }
}
</span></code></pre>
<p>The preceding code creates a <code>ReadOnlySequence&lt;byte&gt;</code> with empty segments and shows how those empty segments affect the various APIs:</p>
<ul>
<li><code>ReadOnlySequence&lt;T&gt;.Slice</code> with a <code>SequencePosition</code> pointing to an empty segment preserves that segment.</li>
<li><code>ReadOnlySequence&lt;T&gt;.Slice</code> with an int skips over the empty segments.</li>
<li>Enumerating the <code>ReadOnlySequence&lt;T&gt;</code> enumerates the empty segments.</li>
</ul>
<h3 id="potential-problems-with-readonlysequencet-and-sequenceposition">Potential problems with ReadOnlySequence&lt;T&gt; and SequencePosition<a href="#potential-problems-with-readonlysequencet-and-sequenceposition" aria-labelledby="potential-problems-with-readonlysequencet-and-sequenceposition"></a></h3>
<p>There are several unusual outcomes when dealing with a <code>ReadOnlySequence&lt;T&gt;</code>/<code>SequencePosition</code> vs. a normal <code>ReadOnlySpan&lt;T&gt;</code>/<code>ReadOnlyMemory&lt;T&gt;</code>/<code>T[]</code>/<code>int</code>:</p>
<ul>
<li><code>SequencePosition</code> is a position marker for a specific <code>ReadOnlySequence&lt;T&gt;</code>, not an absolute position. Because it's relative to a specific <code>ReadOnlySequence&lt;T&gt;</code>, it doesn't have meaning if used outside of the <code>ReadOnlySequence&lt;T&gt;</code> where it originated.</li>
<li>Arithmetic can't be performed on <code>SequencePosition</code> without the <code>ReadOnlySequence&lt;T&gt;</code>. That means doing basic things like <code>position++</code> is written <code>ReadOnlySequence&lt;T&gt;.GetPosition(position, 1)</code>.</li>
<li><code>GetPosition(long)</code> does <strong>not</strong> support negative indexes. That means it's impossible to get the second to last character without walking all segments.</li>
<li>Two <code>SequencePosition</code> can't be compared, making it difficult to:
<ul>
<li>Know if one position is greater than or less than another position.</li>
<li>Write some parsing algorithms.</li>
</ul>
</li>
<li><code>ReadOnlySequence&lt;T&gt;</code> is bigger than an object reference and should be passed by <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier" data-linktype="relative-path">in</a> or <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref" data-linktype="relative-path">ref</a> where possible. Passing <code>ReadOnlySequence&lt;T&gt;</code> by <code>in</code> or <code>ref</code> reduces copies of the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/struct" data-linktype="relative-path">struct</a>.</li>
<li>Empty segments:
<ul>
<li>Are valid within a <code>ReadOnlySequence&lt;T&gt;</code>.</li>
<li>Can appear when iterating using the <code>ReadOnlySequence&lt;T&gt;.TryGet</code> method.</li>
<li>Can appear slicing the sequence using the <code>ReadOnlySequence&lt;T&gt;.Slice()</code> method with <code>SequencePosition</code> objects.</li>
</ul>
</li>
</ul>
<h2 id="sequencereadert">SequenceReader&lt;T&gt;<a href="#sequencereadert" aria-labelledby="sequencereadert"></a></h2>
<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.buffers.sequencereader-1" data-linktype="absolute-path">SequenceReader&lt;T&gt;</a>:</p>
<ul>
<li>Is a new type that was introduced in .NET Core 3.0 to simplify the processing of a <code>ReadOnlySequence&lt;T&gt;</code>.</li>
<li>Unifies the differences between a single segment <code>ReadOnlySequence&lt;T&gt;</code> and multi-segment <code>ReadOnlySequence&lt;T&gt;</code>.</li>
<li>Provides helpers for reading binary and text data (<code>byte</code> and <code>char</code>) that may or may not be split across segments.</li>
</ul>
<p>There are built-in methods for dealing with processing both binary and delimited data. The following section demonstrates what those same methods look like with the <code>SequenceReader&lt;T&gt;</code>:</p>
<h3 id="access-data-1">Access data<a href="#access-data-1" aria-labelledby="access-data-1"></a></h3>
<p><code>SequenceReader&lt;T&gt;</code> has methods for enumerating data inside of the <code>ReadOnlySequence&lt;T&gt;</code> directly. The following code is an example of processing a <code>ReadOnlySequence&lt;byte&gt;</code> a <code>byte</code> at a time:</p>
<pre tabindex="0"><code data-author-content="while (reader.TryRead(out byte b))
{
    Process(b);
}
"><span><span>while</span> (reader.TryRead(<span>out</span> <span>byte</span> b))
{
    Process(b);
}
</span></code></pre>
<p>The <code>CurrentSpan</code> exposes the current segment's <code>Span</code>, which is similar to what was done in the method manually.</p>
<h3 id="use-position">Use position<a href="#use-position" aria-labelledby="use-position"></a></h3>
<p>The following code is an example implementation of <code>FindIndexOf</code> using the <code>SequenceReader&lt;T&gt;</code>:</p>
<pre tabindex="0"><code data-author-content="SequencePosition? FindIndexOf(in ReadOnlySequence<byte> buffer, byte data)
{
    var reader = new SequenceReader<byte>(buffer);

    while (!reader.End)
    {
        // Search for the byte in the current span.
        var index = reader.CurrentSpan.IndexOf(data);
        if (index != -1)
        {
            // It was found, so advance to the position.
            reader.Advance(index);

            return reader.Position;
        }
        // Skip the current segment since there's nothing in it.
        reader.Advance(reader.CurrentSpan.Length);
    }

    return null;
}
"><span>SequencePosition? FindIndexOf(<span>in</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, <span>byte</span> data)
{
    <span>var</span> reader = <span>new</span> SequenceReader&lt;<span>byte</span>&gt;(buffer);

    <span>while</span> (!reader.End)
    {
        <span>// Search for the byte in the current span.</span>
        <span>var</span> index = reader.CurrentSpan.IndexOf(data);
        <span>if</span> (index != <span>-1</span>)
        {
            <span>// It was found, so advance to the position.</span>
            reader.Advance(index);

            <span>return</span> reader.Position;
        }
        <span>// Skip the current segment since there's nothing in it.</span>
        reader.Advance(reader.CurrentSpan.Length);
    }

    <span>return</span> <span>null</span>;
}
</span></code></pre><h3 id="process-binary-data-1">Process binary data<a href="#process-binary-data-1" aria-labelledby="process-binary-data-1"></a></h3>
<p>The following example parses a 4-byte big-endian integer length from the start of the <code>ReadOnlySequence&lt;byte&gt;</code>.</p>
<pre tabindex="0"><code data-author-content="bool TryParseHeaderLength(ref ReadOnlySequence<byte> buffer, out int length)
{
    var reader = new SequenceReader<byte>(buffer);
    return reader.TryReadBigEndian(out length);
}
"><span><span><span>bool</span> <span>TryParseHeaderLength</span>(<span><span>ref</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, <span>out</span> <span>int</span> length</span>)</span>
{
    <span>var</span> reader = <span>new</span> SequenceReader&lt;<span>byte</span>&gt;(buffer);
    <span>return</span> reader.TryReadBigEndian(<span>out</span> length);
}
</span></code></pre><h3 id="process-text-data-1">Process text data<a href="#process-text-data-1" aria-labelledby="process-text-data-1"></a></h3>
<pre tabindex="0"><code data-author-content="static ReadOnlySpan<byte> NewLine => new byte[] { (byte)'\r', (byte)'\n' };

static bool TryParseLine(ref ReadOnlySequence<byte> buffer, 
                         out ReadOnlySequence<byte> line)
{
    var reader = new SequenceReader<byte>(buffer);

    if (reader.TryReadTo(out line, NewLine))
    {
        buffer = buffer.Slice(reader.Position);

        return true;
    }

    line = default;
    return false;
}
"><span><span>static</span> ReadOnlySpan&lt;<span>byte</span>&gt; NewLine =&gt; <span>new</span> <span>byte</span>[] { (<span>byte</span>)<span>'\r'</span>, (<span>byte</span>)<span>'\n'</span> };

<span><span>static</span> <span>bool</span> <span>TryParseLine</span>(<span><span>ref</span> ReadOnlySequence&lt;<span>byte</span>&gt; buffer, 
                         <span>out</span> ReadOnlySequence&lt;<span>byte</span>&gt; line</span>)</span>
{
    <span>var</span> reader = <span>new</span> SequenceReader&lt;<span>byte</span>&gt;(buffer);

    <span>if</span> (reader.TryReadTo(<span>out</span> line, NewLine))
    {
        buffer = buffer.Slice(reader.Position);

        <span>return</span> <span>true</span>;
    }

    line = <span>default</span>;
    <span>return</span> <span>false</span>;
}
</span></code></pre><h3 id="sequencereadert-common-problems">SequenceReader&lt;T&gt; common problems<a href="#sequencereadert-common-problems" aria-labelledby="sequencereadert-common-problems"></a></h3>
<ul>
<li>Because <code>SequenceReader&lt;T&gt;</code> is a mutable struct, it should always be passed by <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref" data-linktype="relative-path">reference</a>.</li>
<li><code>SequenceReader&lt;T&gt;</code> is a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref#ref-struct-types" data-linktype="relative-path">ref struct</a> so it can only be used in synchronous methods and can't be stored in fields. For more information, see <a href="https://docs.microsoft.com/en-us/dotnet/csharp/write-safe-efficient-code" data-linktype="relative-path">Write safe and efficient C# code</a>.</li>
<li><code>SequenceReader&lt;T&gt;</code> is optimized for use as a forward-only reader. <code>Rewind</code> is intended for small backups that can't be addressed utilizing other <code>Read</code>, <code>Peek</code>, and <code>IsNext</code> APIs.</li>
</ul>

						<!-- </content> -->

						</main>

						<!-- recommended content page section -->

							<nav data-bi-name="recommendation-bottom" hidden="" id="recommended-content-center" aria-labelledby="recommended-content-center-title">
								<h3 id="recommended-content-center-title">Related Articles</h3>
							</nav>

						<!-- end recommended content page section -->

						<!-- rating mobile section -->
								
						<!-- end rating mobile section -->

						<!-- feedback section -->



<section data-bi-name="feedback-section">

	<h2 id="feedback">Feedback</h2>

	

	

	

	<div data-tab-group-independent="" hidden="" data-bi-name="tab-group">
		<ul role="tablist">
			<li role="presentation">
				<a href="#tabpanel-issues-open" role="tab" aria-controls="tabpanel-issues-open" data-tab="issues-open" data-bi-name="tab" aria-selected="true" tabindex="0"></a>
			</li>
			<li role="presentation">
				<a href="#tabpanel-issues-closed" role="tab" aria-controls="tabpanel-issues-closed" data-tab="issues-closed" data-bi-name="tab" aria-selected="false" tabindex="-1"></a>
			</li>
		</ul>
		<section id="tabpanel-issues-open" role="tabpanel" data-tab="issues-open">
			
			<ul aria-label="Open Issues"></ul>
		</section>
		<section id="tabpanel-issues-closed" role="tabpanel" data-tab="issues-closed" hidden="hidden" aria-hidden="true">
			<div>There are no closed issues</div>
			<ul aria-label="Closed Issues"></ul>
		</section>
	</div>
	
</section>

						<!-- end feedback section -->

						<!-- feedback report section -->
						<!-- end feedback report section -->

						
					</div>

					

					<!--end of div.columns -->
				</div>

			<!--end of .primary-holder -->
			</section>

			
		</div>

		<!--end of .mainContainer -->
	</div>

	

	

		
		
	


</div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>