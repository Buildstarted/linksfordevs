<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Spying on .NET Garbage Collector with .NET Core EventPipes -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Spying on .NET Garbage Collector with .NET Core EventPipes</h1><div><div class="ac ae af ag ah ea aj ak"><p id="e5ad" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This post of the series shows how to generate GC logs in .NET Core with the new event pipes architecture and details the events emitted by the CLR during a collection.</p><p id="67ff" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 1: <a href="http://labs.criteo.com/2018/06/replace-net-performance-counters-by-clr-event-tracing" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Replace .NET performance counters by CLR event tracing</a>.</p><p id="959f" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 2: <a href="http://labs.criteo.com/2018/07/grab-etw-session-providers-and-events/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Grab ETW Session, Providers and Events</a>.</p><p id="86db" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 3: CLR Threading events with TraceEvent.</p><p id="ef71" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 4: <a class="da by hc hd he hf" target="_blank" rel="noopener" href="/criteo-labs/spying-on-net-garbage-collector-with-traceevent-f49dc3117de">Spying on .NET Garbage Collector with TraceEvent</a>.</p><p id="f4ab" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 5: <a class="da by hc hd he hf" target="_blank" rel="noopener" href="/criteo-labs/c-building-your-own-java-like-gc-logs-in-net-992205fd8d4f">Building your own Java GC logs in .NET</a></p><h1 id="bfce" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Introduction</h1><p id="ba16" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">The previous episode of the series introduced the notion of “GC log”, well known in the Java world and how to implement it in .NET thanks to ETW and TraceEvent on Windows. This solution is easy but requires to create an ETW session (and to remember to close it)… and is also not supported on Linux. However, <a class="da by hc hd he hf" target="_blank" rel="noopener" href="/criteo-labs/c-in-process-clr-event-listeners-with-net-core-2-2-ef4075c14e87">.NET Core 2.2 introduced</a> the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventlistener?view=netcore-2.2" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">EventListener class</a> as the best way to receive CLR events both on Windows and Linux but only from inside the process itself. As of today, TraceEvent is not supporting live session with EventPipe/EventListener, only <a href="https://github.com/Microsoft/perfview/blob/master/src/TraceEvent/EventPipe/EventPipeEventSource.cs#L28" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">a file-based constructor is available</a>. This is unfortunate because it means that you can’t rely on the huge work done by TraceEvent to parse the CLR events; especially those related to garbage collections. The rest of the post will explain how to decipher raw events.</p><p id="ef00" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In addition, there is a bigger problem: the current .NET Core 2.2 implementation is <a href="https://github.com/dotnet/coreclr/issues/21380" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">not working for all CLR events</a>. Long story short, the <code class="hx hy hz ia ib b">EventPipe</code> class relies on specific Thread Local Storage slot that is not set by GC background worker threads: the events are not emitted in that case. In addition, there is no per event timestamp information in 2.2. The implementation presented in this post relies on tests done with ETW traces and on the <a href="https://github.com/dotnet/coreclr/pull/21817" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Pull Request</a> that fixes the issue for .NET Core 3.0, available in Preview 5.</p><h1 id="c766" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Back to the basics: what events are emitted by the GC?</h1><p id="175b" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">The previous posts of the series were based on C# events raised by the TraceEvent parser with names different from the original CLR events and the <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">corresponding Microsoft Docs</a>. When you implement your EventListener-derived class, each event is received as an <code class="hx hy hz ia ib b">EventWrittenEventArgs</code> object in the <code class="hx hy hz ia ib b">OnEventWritten</code> override. The <code class="hx hy hz ia ib b">EventId</code> and <code class="hx hy hz ia ib b">EventName</code> properties allow you to figure out which event is received. If you have worked with TraceEvent before, you might be using the <code class="hx hy hz ia ib b">Opcode</code> property but even if a property with the same name exists in <code class="hx hy hz ia ib b">EventWrittenEventArgs</code>, the value is completely different and should not be used.</p><p id="67a9" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The CLR is versioning the emitted events to be able to add information over time. For example, the <code class="hx hy hz ia ib b">EventId</code> of the “GCStart” event is 1 but the <code class="hx hy hz ia ib b">EventName</code> could be <em class="ic">GCStart</em>, <em class="ic">GCStart_V1</em> or <em class="ic">GCStart_V2</em> even though the Microsoft Docs seems to be <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events#gcstart_v1_event" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">stuck on version 1</a>. The following table lists the interesting GC events for .NET Core 2.2/3.0:</p><figure class="ie if ig ih ii ij dm dn paragraph-image"><p id="a30b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Look at <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events</a> for the documentation related to each event.</p><p id="8e80" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">If you go back to <a class="da by hc hd he hf" target="_blank" rel="noopener" href="/criteo-labs/c-building-your-own-java-like-gc-logs-in-net-992205fd8d4f">this previous article</a> of the series, you notice that all details provided by the <code class="hx hy hz ia ib b">TraceGC</code> argument are available except for the objects size before and after the collection. These values are embedded in the workload of the <em class="ic">GCPerHeapHistory</em> event by the GC code. Unfortunately, these details are not marshalled by the current <code class="hx hy hz ia ib b">EventPipe</code> implementation to your <code class="hx hy hz ia ib b">OnEventWritten</code> override (read <a href="https://github.com/dotnet/coreclr/issues/24506" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">https://github.com/dotnet/coreclr/issues/24506</a> for more details and when it will be fixed).</p><p id="279b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">There is no strongly typed <code class="hx hy hz ia ib b">EventArgs</code> per event and you need to know the name of the field you are interested in to get its index. From this index, you get its corresponding value from the <code class="hx hy hz ia ib b">Payload</code> property of the received <code class="hx hy hz ia ib b">EventWrittenArgs</code>. The following helper method is doing the heavy lifting for you:</p><figure class="ie if ig ih ii ij"><p id="98c2" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Now that all interesting events are known, it is time to figure out what is the sequence of events emitted during a garbage collection: a new line with the details should be added to the GC log file when the last event is received.</p><h1 id="5fd4" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">What is the exact sequence of GC events</h1><p id="36d4" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">So let’s go back to the main phases of a garbage collection with the related CLR events as shown in the following figure (with <a href="https://twitter.com/konradkokosa" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Konrad Kokosa</a> courtesy from <a href="https://www.amazon.com/Pro-NET-Memory-Management-Performance/dp/148424026X" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">his book</a>)</p><figure class="ie if ig ih ii ij dm dn paragraph-image"><p id="0bd1" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This is the expected events for the most complicated case: a background collection with possible foreground ephemeral (gen0 and gen1) collections while the GC threads are concurrently sweeping. However, it is not possible to rely on this specific order of events because the order changes, depending on workstation/background mode and generation 2/ephemeral. Each type of collection triggers events in different order as shown below:</p><h1 id="2842" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Gen0/Gen1 and Gen 2 (non concurrent)</h1><figure class="ie if ig ih ii ij dm dn paragraph-image"><h1 id="4aa4" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Gen 2 (background)</h1><figure class="ie if ig ih ii ij dm dn paragraph-image"><p id="3b30" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Here is a more visual view of what could happen (dark blue is gen 2 and light blue are ephemeral gen0/1):</p><figure class="ie if ig ih ii ij dm dn paragraph-image"><h1 id="b0b8" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">When exactly does a GC start…</h1><p id="c33c" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">The <strong class="gq ji">GCTriggered</strong> event notifies that a new collection will start except in the case of foreground ephemeral gen0/gen1 collections triggered during a background gen2. In that case, you could rely on the <strong class="gq ji">GCStart</strong> event and check if a background gen2 is running. This <strong class="gq ji">GCStart</strong> event provides the condemned generation in its <code class="hx hy hz ia ib b">Depth</code> property. So I keep track of both the current background GC (if any) and the foreground GC (if any) in a <code class="hx hy hz ia ib b">GCInfo</code> object:</p><figure class="ie if ig ih ii ij"><p id="7b65" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The <code class="hx hy hz ia ib b">GCDetails</code> class keeps tracks of all the details gathered during a garbage collection:</p><figure class="ie if ig ih ii ij"><p id="f6b4" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The <code class="hx hy hz ia ib b">HeapDetails</code> stores the size of each generation after a collection:</p><figure class="ie if ig ih ii ij"><p id="ee53" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The <code class="hx hy hz ia ib b">GCDetails</code> instance is created when the <strong class="gq ji">GCStart</strong> event is received:</p><figure class="ie if ig ih ii ij"><p id="9a3b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This is where it is important to remember if either a background or foreground GC is starting. In the former case, the <code class="hx hy hz ia ib b">CurrentBGC</code> field is set and the <code class="hx hy hz ia ib b">GCInProgress</code> field is set otherwise with a new <code class="hx hy hz ia ib b">GCDetails</code> instance.</p><p id="be4a" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">That way, when either of <strong class="gq ji">GCGlobalHistory</strong> or <strong class="gq ji">GCHeapStarts</strong> is received, it is easy to know what is the GC in progress; i.e. if a foreground GC is in progress, an event happens in its context (until the last one <strong class="gq ji">GCHeapStats </strong>that will clean the <code class="hx hy hz ia ib b">GCInProcess</code> field):</p><figure class="ie if ig ih ii ij"><h1 id="f562" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">… suspend, pause application threads and end of ephemeral collections</h1><p id="a165" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">The suspension and pause time are not that complicated to compute. The garbage collector code is relying on the <code class="hx hy hz ia ib b">SuspendEE</code> and <code class="hx hy hz ia ib b">RestartEE</code> methods provided by the .NET Execution Engine to suspend and restart the application threads respectively. Each of these methods emits a pair of <strong class="gq ji">GCxxxBegin</strong> and <strong class="gq ji">GCxxxEnd</strong> events. After <strong class="gq ji">GCSuspendEEBegin</strong> is emitted, the Execution Engine waits for the application threads to suspend their execution. When all threads are suspended, <strong class="gq ji">GCSuspendEEEnd</strong> gets emitted.</p><p id="a7a5" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The <strong class="gq ji">GCRestartEEBegin</strong> event is emitted when the applications threads begin to resume their execution. When all application threads are resumed, <strong class="gq ji">GCRestartEEEnd</strong> gets emitted. The elapsed time between the <strong class="gq ji">GCSuspendEEEnd</strong> and <strong class="gq ji">GCRestartEEBegin</strong> events is counted as <em class="ic">suspension time</em>. However, for simplicity sake, my current implementation sums both the time spent by the Execution Engine to suspend the threads and the pause time due to the GC work.</p><p id="67d7" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The suspension start time is kept in <strong class="gq ji">GCInfo</strong>:</p><figure class="ie if ig ih ii ij"><p id="e92c" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">It will be set when the <strong class="gq ji">GCSuspendEEBegin</strong> event is received:</p><figure class="ie if ig ih ii ij"><p id="4a43" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This implementation decision does not provide the same level of suspension details (no fine grain suspension time for inner foreground collections) as the one provided by the TraceEvent parsing.</p><p id="d753" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The sibling <strong class="gq ji">GCRestartEEEnd</strong> event is used to (1) compute the total pause time and (2) detect when gen0/gen1/non concurrent gen2 collections end:</p><figure class="ie if ig ih ii ij"><h1 id="04cc" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Detect other collections end (and more details)</h1><p id="82b0" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">As shown in the events workflow figure, the <strong class="gq ji">GCRestartEEBegin</strong>/<strong class="gq ji">GCRestartEEEnd</strong> duo of events are used to detect the end of non-concurrent gen0/1/2 collections. It is more complicated to detect the end of a gen2 background or inner ephemeral gen0/1 collections: <strong class="gq ji">GCGlobalHeapHistory</strong> for the former and <strong class="gq ji">GCHeapStats</strong> for the latter. However, these two events payload does not contain the piece of information to know if we are in a middle of a background gen 2 or not. With this details in mind, the code of the different event handlers is quite straightforward.</p><p id="8f34" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The generations size are retrieved from the <strong class="gq ji">GCHeapStat</strong> event:</p><figure class="ie if ig ih ii ij"><p id="6eb6" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Remember this is the last event received for a gen0/gen1/foreground gen2 collection so I’m using it to clear the <code class="hx hy hz ia ib b">GCInProgress</code> field: the next event will be for the current background gen2 if any (<code class="hx hy hz ia ib b">CurrentBGC</code> field is not null) or a new collection.</p><p id="1d58" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">As of today with Preview 5, the before/after generation sizes are not marshalled through event pipes (see the <a href="https://github.com/dotnet/coreclr/issues/24506" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">corresponding bug</a> for more details) so the <strong class="gq ji">GCPerHeapHistory </strong>event does not bring any value.</p><p id="10e2" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The last <strong class="gq ji">GCGlobalHeapHistory</strong> event of background gen 2 collection is also used to detect compaction:</p><figure class="ie if ig ih ii ij"><p id="a89b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In case of a background gen 2, this is the last event so there should not be any collection in progress:</p><figure class="ie if ig ih ii ij"><p id="60a8" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The next received event will start a new garbage collection cycle of events.</p><p id="e788" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This post concludes the series about CLR events and how to use them to better understand how the runtime is behaving under the workloads of your applications. The code available on <a href="https://github.com/chrisnas/ClrEvents" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Github</a> has been updated to provide the <code class="hx hy hz ia ib b">EventListenerGcLog</code> class that uses the code demonstrated in this post to generate GC logs with event pipes.</p></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>