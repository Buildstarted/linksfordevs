<!DOCTYPE html>
<html lang="en">
<head>
    <title>
cr.yp.to: 2019.10.24: Why EdDSA held up better than ECDSA against Minerva - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="cr.yp.to: 2019.10.24: Why EdDSA held up better than ECDSA against Minerva - linksfor.dev(s)"/>
    <meta property="og:description" content="&quot;Minerva attack can recover private keys from smart cards, cryptographic libraries&quot;,&#xA;says the ZDNet headline.&#xA;&quot;The Czech team found a problem in the ECDSA and EdDSA algorithms used by the Atmel Toolbox crypto library to sign cryptographic operations on Athena IDProtect cards.&quot;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.cr.yp.to/20191024-eddsa.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - cr.yp.to: 2019.10.24: Why EdDSA held up better than ECDSA against Minerva</title>
<div class="readable">
        <h1>cr.yp.to: 2019.10.24: Why EdDSA held up better than ECDSA against Minerva</h1>
            <div>Reading time: 41-53 minutes</div>
        <div>Posted here: 27 Oct 2019</div>
        <p><a href="https://blog.cr.yp.to/20191024-eddsa.html">https://blog.cr.yp.to/20191024-eddsa.html</a></p>
        <hr/>
<div id="readability-page-1" class="page">

<hr>
<hr>

<p>
<a href="https://www.zdnet.com/article/minerva-attack-can-recover-private-keys-from-smart-cards-cryptographic-libraries/">"Minerva attack can recover private keys from smart cards, cryptographic libraries"</a>,
says the ZDNet headline.
"The Czech team found a problem in the ECDSA and EdDSA algorithms used by the Atmel Toolbox crypto library to sign cryptographic operations on Athena IDProtect cards."
</p>
<p>
The
<a href="https://minerva.crocs.fi.muni.cz/">Minerva research team's web page</a>
claims "practical recovery of the long-term private key"
from various
"implementations of ECDSA/EdDSA in programmable smart cards and cryptographic software libraries".
Concretely:
</p>
<ul>
<li>
The team's experiments reportedly recovered an ECDSA key from a FIPS-certified CC-certified
"Athena IDProtect card with CPLC data 010b.0352.0005".
</li>
<li>
The team located seven other certified devices using the same ECDSA implementation.
Presumably the attack also works against those devices.
The <a href="https://www.golem.de/news/elliptische-kurven-minerva-angriff-zielt-auf-zertifizierte-krypto-chips-1910-144256.html">Golem article</a> on Minerva
says "Einmal mehr wirft der Vorfall Fragen dazu auf, wie sinnvoll solche Zertifizierungen sind"
[Once again, the incident raises questions about how useful such certifications are].
</li>
<li>
The team's measurements make reasonably clear that a similar attack would work against the ECDSA implementations
in libgcrypt 1.3.0 through 1.8.4,
MatrixSSL through 4.2.1,
SunEC/OpenJDK/Oracle JDK 7 through 12,
and Crypto++ through 8.2.0.
It's possible that the attack would also work against wolfSSL/wolfCrypt through 4.0.0,
but the wolfSSL problem "would be very hard to exploit".
</li>
</ul>
<p>
Wait a minute.
If this was supposed to be an "ECDSA/EdDSA" attack,
a shared "problem in the ECDSA and EdDSA algorithms",
then why do these examples say just "ECDSA" and "ECDSA" and "ECDSA"?
</p>
<p>
Here's one theory you might come up with:
"You're being selective in your summary.
I looked through the Minerva page the day it was originally announced,
and it also claimed to break the EdDSA implementation in libgcrypt."
</p>
<p>
Facts:
The team did make this claim, but withdrew the claim two days later, for reasons that I'll explain below.
I'm not being selective in my summary.
</p>
<p>
Here's another theory you might come up with:
"Fundamentally, the attack applies equally to ECDSA and EdDSA.
The only reason that there are more ECDSA attack reports
is that ECDSA is more widely supported."
</p>
<p>
Facts:
I looked at MatrixSSL, JDK, Crypto++, and wolfSSL/wolfCrypt.
I noticed EdDSA (specifically Ed25519) implementations
in everything except JDK.
The Minerva team does not claim to break the EdDSA implementations in libgcrypt, MatrixSSL, Crypto++, and wolfSSL/wolfCrypt.
</p>
<p>
The Minerva web page also says that
OpenSSL, BouncyCastle, BoringSSL, libtomcrypt, Botan, Microsoft CNG, mbedTLS, Intel IPP-Crypto, and 11 cards
were "tested and found not vulnerable".
I noticed EdDSA implementations in
OpenSSL, BouncyCastle, BoringSSL, libtomcrypt, and Botan.
In total,
the Minerva team is claiming to break ECDSA in 4 or possibly 5 out of 13 crypto libraries supporting ECDSA,
and EdDSA in 0 out of 9 crypto libraries supporting EdDSA.
The bottom line is that the attack <i>doesn't</i> apply equally to ECDSA and EdDSA.
</p>
<p>
I'm not saying that it's impossible to implement EdDSA insecurely.
Of course it's <i>possible</i> to implement EdDSA insecurely.
Maybe there are people using insecure EdDSA implementations today.
But the Minerva data points support the theory that
<b>EdDSA implementations are less likely to be broken than ECDSA implementations</b>.
This isn't an accident: it's how EdDSA was designed in the first place.
</p>
<p>
In the rest of this blog post,
I'll take a closer look at the information exploited by the Minerva attack,
and at the EdDSA implementations mentioned above.
Thanks to
<a href="https://hyperelliptic.org/tanja">Tanja Lange</a>
for help with this blog post.
</p>
<p>
<b>Discrete logarithms.</b>
In
<a href="https://tinyurl.com/yyu8634y">ElGamal's signature system</a>,
the signer's public key is g<sup>x</sup> mod p.
Here p is a standard prime,
g is a standard generator mod p,
and x is the signer's long-term signing key,
chosen uniformly at random from {0,1,...,p−2}.
</p>
<p>
Computing (g<sup>x</sup>)<sup>(p−1)/2</sup> mod p reveals x mod 2:
it's 1 if x is even, or p−1 if x is odd.
More generally, for any divisor q of p−1,
one can check a guess for x mod q as follows:
x is congruent to (say) 7 modulo q
if and only if (g<sup>x</sup>)<sup>(p−1)/q</sup> = (g<sup>7</sup>)<sup>(p−1)/q</sup>.
This isn't helpful when q is large:
any particular guess for x mod q is very unlikely to be correct,
and ruling out one guess still leaves many more possibilities.
</p>
<p>
The Pohlig–Hellman discrete-logarithm algorithm is faster,
finding x in only about sqrt(q) operations where q is the largest prime dividing p−1,
but let's assume that all prime divisors of (p−1)/2 are large.
There are also discrete-logarithm algorithms that take time subexponential in the number of bits of p,
but let's assume that p is so large that this isn't a threat.
Shor's quantum discrete-logarithm algorithm takes polynomial time,
but I'll assume throughout this blog post that the attacker doesn't have a quantum computer.
It then seems very difficult to learn anything about x mod (p−1)/2 from g<sup>x</sup> mod p.
</p>
<p>
<b>Linear equations in discrete logarithms.</b>
The first step in signing a message in ElGamal's system is
to choose a "random number k, uniformly between 0 and p−1, such that gcd(k,p−1) = 1."
The gcd condition forces k to be odd.
We're assuming that all prime divisors of (p−1)/2 are large,
so the gcd condition is very unlikely to have any other effect.
</p>
<p>
ElGamal's signatures reveal the coefficients M,R,S of a linear equation M=xR+kS modulo p−1.
This is equivalent to an equation M=xR+kS modulo each of the prime-power divisors of p−1.
In particular, M=xR+kS=xR+S modulo 2, revealing x mod 2 if R is odd;
but we already knew x mod 2, as explained above.
</p>
<p>
The rest of the equation is M=xR+kS modulo (p−1)/2,
or equivalently M=xR+kS modulo q for each prime-power divisor q of (p−1)/2.
This doesn't seem helpful for the attacker,
since k mod q could be <i>almost</i> anything.
For each prime q dividing (p−1)/2,
the attacker knows that k isn't 0 modulo q,
i.e., that M isn't xR modulo q,
which (assuming R is invertible modulo q)
is the same as ruling out M/R as a possibility for x mod q;
but, again, ruling out one guess for x mod q still leaves many more possibilities.
</p>
<p>
Another signature from the same signer reveals another equation M<sub>2</sub>=xR<sub>2</sub>+k<sub>2</sub>S<sub>2</sub>.
ElGamal emphasizes that the signer must choose a new k<sub>2</sub> for M<sub>2</sub>,
rather than taking k<sub>2</sub>=k,
since taking k<sub>2</sub>=k allows the attacker to solve these two linear equations for x.
Repeating k is what
<a href="https://tinyurl.com/y5lqutzk">destroyed the security of the Sony PS3</a>
many years later.
</p>
<p>
Taking a new k<sub>2</sub> seems to eliminate this problem:
each possible x is compatible with some solution (k,k<sub>2</sub>) to the two equations,
except for the invertibility issue described above.
More generally, ElGamal concludes that these equations for any number of signatures
are compatible with a huge number of possibilities for x
as long as "each signature uses a different k".
</p>
<p>
<b>Schnorr's use of a prime-order subgroup.</b>
There's a lot to be said about
<a href="https://blog.cr.yp.to/20140323-ecdsa.html">improvements from ElGamal's system to the Schnorr system and EdDSA</a>.
One of the improvements, simplifying the security analysis,
is to take g as a generator of a subgroup of prime order q
rather than as a generator of the entire group of order p−1.
</p>
<p>
Each Schnorr signature
reveals the coefficients M,R,S of a linear equation M=xR+kS modulo q.
Almost certainly S is nonzero modulo q,
so let's simplify this linear equation to Y=xX+k modulo q,
where Y=M/S and X=R/S.
Schnorr actually obtains X and Y in a simpler way,
eliminating all divisions
and in particular eliminating the need to require gcd{k,q}=1.
Schnorr takes k as a random number in the set {1,...,q}.
</p>
<p>
<b>How NSA biased the linear equations in DSA.</b>
NSA's original DSA proposal
uses prime-order subgroups as in Schnorr's system,
revealing an equation Y=xX+k modulo q for each signature.
Other DSA details are closer to ElGamal's system,
in particular using divisions by k modulo q,
so k is specified to be in the set {1,...,q−1}.
The same comments apply to the subsequent NIST standards for DSA and ECDSA.
</p>
<p>
NSA's proposal included a specific prime q,
namely 0xb20db0b101df0c6624fc1392ba55f77d577481e5,
about 0.7 times 2<sup>160</sup>;
and a specific prime p,
which I won't repeat here,
and which is around 0.8 times 2<sup>512</sup>.
A subsequent update included another prime q,
namely 0xc773218c737ec8ee993b4f2ded30f48edace915f,
about 0.8 times 2<sup>160</sup>;
and another 512-bit prime p.
All of these primes were generated by hashing
in a way that seems to make it very difficult to target particular choices of p and q.
(As a side note, hashing was also used to generate shared parameters
for various other cryptosystems,
but was avoided in NSA's subsequent
<a href="https://projectbullrun.org/dual-ec/index.html">Dual EC DRBG</a> proposal.)
All of these primes are much too small to resist discrete-log attacks,
but the problems I'm about to describe also show up for larger DSA parameters.
</p>
<p>
How do we generate a uniform random element k of {1,...,q−1}?
If q is, say, 2<sup>160</sup>+1 then this is easy:
generate 160 random bits, interpret the result as an integer, and add 1.
But 2<sup>160</sup>+1 isn't prime, and, more to the point, isn't either of the random-looking primes q mentioned above.
</p>
<p>
The literature has many good answers to this question,
and then it has NSA's answer, which I'll get to in a moment.
One good answer, rejection sampling, is to generate a uniform random 160-bit integer
(let's assume q is between 2<sup>159</sup> and 2<sup>160</sup>)
and start over if the integer is outside {1,...,q−1}.
Another good answer, with more predictable performance,
is to generate a uniform random 320-bit integer and reduce that integer modulo q.
The resulting distribution isn't <i>exactly</i> uniform but it's so close that you'll never be able to tell the difference.
Technically, this doesn't guarantee that k is in {1,...,q−1},
but you'd have to be amazingly unlucky for your 320-bit integer to be a multiple of q.
</p>
<p>
NSA's answer is to take a much shorter integer,
a 160-bit (not 320-bit) hash of some new secret,
and reduce the hash modulo q.
Presumably the 160-bit hash is hard to distinguish from a uniform random element of
{0,...,2<sup>160</sup>−1},
but the hash modulo q looks quite different from a uniform random element of {1,...,q−1}.
For example, if q is NSA's 0xb20db0b101df0c6624fc1392ba55f77d577481e5,
then any integer up through 0x4df24f4efe20f399db03ec6d45aa0882a88b7e1a is hit by <i>two</i>
elements of {0,...,2<sup>160</sup>−1},
while any larger integer is hit by only <i>one</i> element of {0,...,2<sup>160</sup>−1}.
</p>
<p>
<b>Interlude: Understanding the importance of distributions for security.</b>
Attack algorithms often work better for some inputs than for others.
For a proper security analysis one has to be clear about the distribution of inputs.
Changing the distribution can increase or decrease security levels,
and can easily make the difference between a broken system and an unbroken system.
</p>
<p>
Here's a non-DSA example.
How difficult is it, by known attacks,
to find all of the prime factors of an integer N in {1,...,2<sup>2048</sup>}?
This question is incomplete, because the distribution of inputs N is unspecified.
Here are four possibilities for the distribution:
</p>
<ul>
<li>Uniform random element of {1,...,2<sup>2048</sup>}.
Often N has only one large prime factor,
and then ECM factors N quite easily.
</li>
<li>Narrower: Product of two independent uniform random primes in {1,...,2<sup>1024</sup>}.
This is harder to factor,
but occasionally N is, say, 30 bits smaller than expected,
which should make NFS almost twice as fast.
</li>
<li>Even narrower: Product of two independent uniform random primes in {2<sup>1023</sup>,...,2<sup>1024</sup>}.
This eliminates all of the small cases described above,
and is the hardest factoring problem on this list.
</li>
<li>Even narrower: Product of two <a href="https://blog.cr.yp.to/20171105-infineon.html">1024-bit Infineon primes</a>.
This is much easier to factor.
</li>
</ul>
<p>
These examples show how unsafe it can be to assume that different distributions have the same security level.
Comparing the first, second, and third cases
shows that reducing randomness can improve security.
Comparing the second and third cases to the fourth case
shows that reducing randomness can damage security.
</p>
<p>
Note that these examples rely critically on understanding which inputs are broken by various factorization algorithms.
Don't believe people who try to replace serious algorithm analysis
with some superficial rule that more randomness is always better.
See also Section 11.1 of
<a href="https://eprint.iacr.org/2008/390">2008 Koblitz–Koblitz–Menezes</a>
for more subtle examples.
</p>
<p>
<b>Security analysis of DSA biases, part 1: lattice attacks.</b>
Back to DSA.
The security of a <i>single</i> signature,
and in particular the amount of information revealed by the equation Y=xX+k modulo q,
can't be affected much by NSA's change in the distribution of k.
An attack that works with a particular probability against NSA's uniform random 160-bit k
also has at least half as much probability of working against ElGamal's uniform random nonzero k modulo q.
The point is that NSA produces any particular integer modulo q with probability at most 1/2<sup>159</sup>
(assuming q is at least 2<sup>159</sup>),
while ElGamal produces the same integer with probability 1/(q−1),
which is at least 1/2<sup>160</sup> (and even somewhat larger than this for the choices of q mentioned above).
Whichever NSA choices of k are affected by the attack
have at least half as much chance of appearing in ElGamal's choices of k.
(This is an example of a "divergence argument".)
</p>
<p>
The same argument also says that NSA can't lose more than 2 bits of security for 2 signatures,
more than 3 bits of security for 3 signatures, etc.
But this is a useless guarantee for a signer generating, say, 1000 signatures.
</p>
<p>
ElGamal went beyond a single equation
and considered the whole system of equations revealed by the signer:
Y<sub>1</sub>=xX<sub>1</sub>+k<sub>1</sub> modulo q,
Y<sub>2</sub>=xX<sub>2</sub>+k<sub>2</sub> modulo q,
Y<sub>3</sub>=xX<sub>3</sub>+k<sub>3</sub> modulo q,
etc.
Any particular k from NSA has nearly as much chance of having been generated by ElGamal,
but the whole sequence (k<sub>1</sub>,k<sub>2</sub>,k<sub>3</sub>,...) from NSA is much less likely to be generated by ElGamal.
(The "divergence" grows rapidly with the number of signatures.)
What effect does this gap have on security?
</p>
<p>
What we know about NSA's (k<sub>1</sub>,k<sub>2</sub>,k<sub>3</sub>,...) is that each k<sub>j</sub> favors elements of {0,...,2<sup>160</sup>−1−q}
over elements of {2<sup>160</sup>−q,...,2<sup>160</sup>−1}.
Let's consider a simpler and larger bias,
where each k<sub>j</sub> is guaranteed to be in a smaller range {0,...,2<sup>b</sup>−1}.
The attacker knows that Y<sub>j</sub>=xX<sub>j</sub>+k<sub>j</sub> modulo q,
i.e., that the vector (Y<sub>1</sub>,Y<sub>2</sub>,Y<sub>3</sub>,...) is the surprisingly short vector (k<sub>1</sub>,k<sub>2</sub>,k<sub>3</sub>,...) plus x(X<sub>1</sub>,X<sub>2</sub>,X<sub>3</sub>,...) plus a multiple of q in each coordinate.
In other words,
(Y<sub>1</sub>,Y<sub>2</sub>,Y<sub>3</sub>,...) is surprisingly close to the public lattice consisting of all multiples of (X<sub>1</sub>,X<sub>2</sub>,X<sub>3</sub>,...) plus all multiples of q in each coordinate.
Finding the lattice vector surprisingly close to (Y<sub>1</sub>,Y<sub>2</sub>,Y<sub>3</sub>,...) immediately reveals x.
</p>
<p>
<a href="https://www.hpl.hp.com/techreports/1999/HPL-1999-90.pdf">Howgrave-Graham and Smart</a>
introduced this lattice view of biased DSA in 1999,
and reported being able to quickly find x from "only 30 signed messages" with 152-bit k<sub>j</sub>,
using a simple algorithm to find the close lattice vector.
Howgrave-Graham and Smart also pointed out that there's nothing special about having the k<sub>j</sub> range start from 0.
For example,
if one knows that k<sub>1</sub> is in the interval {37*2<sup>152</sup>,...,38*2<sup>152</sup>−1},
then one can subtract 37*2<sup>152</sup> from Y<sub>1</sub> and from k<sub>1</sub>,
reducing to the case that k<sub>1</sub> is in the interval {0,...,2<sup>152</sup>−1}.
Or one can reduce to the case that k<sub>1</sub> is in the balanced interval
{−2<sup>151</sup>,...,2<sup>151</sup>−1},
which is even better for the lattice attacks.
</p>
<p>
"It is important that no bits of the ephemeral keys are leaked for whatever reason",
Howgrave-Graham and Smart wrote.
If you assume that "important" means "important for security against known attacks",
then you can object that Howgrave-Graham and Smart were overstating their results.
They had reported an attack using 8 bits of each k<sub>j</sub>;
this does not imply an attack using, say, 4 bits of each k<sub>j</sub>.
Followup papers plugged fancier lattice algorithms into the same ideas,
<a href="https://www.di.ens.fr/~pnguyen/pub_NgSh00.htm">showing</a>
that an attacker knowing 4 bits of each k<sub>j</sub> could quickly find x,
but you can still object that this doesn't apply to
NSA's leak of roughly 0.6 bits of information about each k<sub>j</sub>.
</p>
<p>
On the other hand,
as a cryptosystem designer,
I don't want security reviewers to have to spend time analyzing fancy attacks
that I could have eliminated by tweaking my design.
Security review is the best protection that users have against attacks;
security failures come primarily from having security review spread too thin.
From this perspective,
it <i>is</i> important to eliminate the leak of information about k.
</p>
<p>
<b>Security analysis of DSA biases, part 2: Bleichenbacher's attack.</b>
In October 2001, NIST issued
<a href="https://csrc.nist.gov/CSRC/media/Publications/fips/186/2/archive/2001-10-05/documents/fips186-2-change1.pdf">a new DSA standard with a change notice</a>
saying that an "unpublished attack" had broken NSA's biased DSA randomness
using a "workfactor of 2<sup>64</sup>" and "2<sup>22</sup> known signatures".
This statement doesn't make clear what the units are for measuring this "workfactor",
i.e., how complicated each of the 2<sup>64</sup> steps is.
The statement doesn't even make clear whether the attack is for NSA's 512-bit primes
(which were already known to allow feasible discrete-logarithm attacks),
or for 1024-bit primes, or both.
</p>
<p>
Earlier <a href="https://www.scientificamerican.com/article/are-digital-signatures-sa/">news</a>
had attributed the attack to Bleichenbacher,
and had quoted "Edward Roback, chief of the Computer Security Division in NIST's Information Technology Laboratory"
as saying that
"those who are using DSA can continue to use it with confidence that DSA signatures done under the present standard will remain secure for many more years".
I'm not aware of any publications explaining why NIST thought
that attackers couldn't reach a "workfactor of 2<sup>64</sup>".
</p>
<p>
Bleichenbacher
<a href="https://web.archive.org/web/20060508144518/http://grouper.ieee.org/groups/1363/WorkingGroup/minutes/Nov00.txt">privately reported his attack</a> to an IEEE working group
in November 2000,
but as far as I know didn't immediately post the slides or any other attack details.
A small amount of information about the attack appears in Section 5 of a
<a href="https://www.cryptrec.go.jp/exreport/cryptrec-ex-1002-2001.pdf">2001 report by Vaudenay</a>.
Bleichenbacher's
<a href="https://web.archive.org/web/20041222103252/http://grouper.ieee.org/groups/1363/Research/contributions/Ble2000.tif">slides</a>
(TIFF; here's a <a href="https://blog.cr.yp.to/20191024-bleichenbacher.pdf">PDF version</a>)
were posted in late 2004.
The first serious writeup I saw was
a 2013 paper by <a href="https://eprint.iacr.org/2013/346">De Mulder, Hutter, Marson, and Pearson</a>.
</p>
<p>
Here's a concrete example to illustrate some of the techniques.
Bleichenbacher numerically measures the bias of k as the average over k of the complex number exp(2πik/q).
If k were uniformly distributed modulo q
then this complex number would be equally spaced around the unit circle in the complex plane
and the average would be 0.
However, k isn't uniformly distributed modulo q.
Let's take NSA's original q, around 0.7 times 2<sup>160</sup>;
a short calculation shows that
the bias of k is around 0.05+0.21i.
</p>
<p>
If k<sub>1</sub> and k<sub>2</sub> are independent identically distributed variables
then the bias of k<sub>1</sub>+k<sub>2</sub> is the average of exp(2πi(k<sub>1</sub>+k<sub>2</sub>)/q) = exp(2πik<sub>1</sub>/q)exp(2πik<sub>2</sub>/q),
which factors as the bias of k<sub>1</sub> times the bias of k<sub>2</sub>.
Similarly, the bias of k<sub>1</sub>−k<sub>2</sub> is the bias of k<sub>1</sub> times the complex conjugate of the bias of k<sub>2</sub>.
</p>
<p>
Consider many equations Y<sub>j</sub>=xX<sub>j</sub>+k<sub>j</sub> modulo q from, say, 2<sup>40</sup> signatures under one key.
Assume that each X<sub>j</sub> is reduced modulo q to the range {0,1,...,q−1}.
Sort the equations into increasing order of X<sub>j</sub>.
Consider a difference of two adjacent equations:
Y<sub>j+1</sub>−Y<sub>j</sub>=x(X<sub>j+1</sub>−X<sub>j</sub>)+(k<sub>j+1</sub>−k<sub>j</sub>).
Presumably each difference X<sub>j+1</sub>−X<sub>j</sub> will be on the scale of q/2<sup>40</sup>;
a more precise analysis would look at the distribution of these differences.
Meanwhile the difference k<sub>j+1</sub>−k<sub>j</sub> would have bias (0.048+0.21i)(0.048−0.21i), around 0.047,
if k<sub>j+1</sub> and k<sub>j</sub> were independent;
presumably the sorting of X<sub>j</sub> doesn't noticeably change this bias.
</p>
<p>
Repeat this sort-and-difference process three times,
reducing each X first to about 120 bits with k bias around 0.047,
then to about 80 bits with k bias around 0.047<sup>2</sup>,
then to about 40 bits with k bias around 0.047<sup>4</sup>, i.e., around 2<sup>−17.6</sup>.
Write the resulting equations as Y'<sub>j</sub>=xX'<sub>j</sub>+k'<sub>j</sub>,
where each X'<sub>j</sub> has about 40 bits, and each k'<sub>j</sub> has bias around 2<sup>−17.6</sup>.
</p>
<p>
Say we have a <i>rough</i> guess G for x,
and we compute the average A(G) of exp(2πi(Y'<sub>j</sub>−GX'<sub>j</sub>)/q),
i.e., the average of exp(2πi(x−G)X'<sub>j</sub>/q) exp(2πik'<sub>j</sub>/q).
For most choices of G, this is an average of 2<sup>40</sup> random-looking points on the unit circle,
so presumably it has size around 2<sup>−20</sup>.
However,
if G is within 2<sup>115</sup> of x
then the differences (x−G)X'<sub>j</sub> are bounded by 2<sup>155</sup>
(this is where the smallness of X'<sub>j</sub> is important),
so exp(2πi(x−G)X'<sub>j</sub>/q) is close to 1,
so presumably A(G) is close to the bias of k'<sub>j</sub>, around 2<sup>−17.6</sup>,
which is noticeably bigger than 2<sup>−20</sup>.
</p>
<p>
Now try, e.g., G=0, G=q/2<sup>45</sup>, G=2q/2<sup>45</sup>, G=3q/2<sup>45</sup>, etc.
It's easy to use a fast Fourier transform to compute A(G) simultaneously for all such G
with only about 2<sup>50</sup> multiplications of complex numbers.
Hopefully the largest A(G) value will come from some G close to x,
revealing the top bits of x,
and then one can repeat to find the remaining bits of x.
On the other hand, maybe 2<sup>−20</sup> is too much noise compared to 2<sup>−17.6</sup>.
One can try several of the largest A(G) values,
or reduce the noise by using more equations,
as I'll now explain.
</p>
<p>
How can we generate more equations without starting from more signatures?
One approach is to go beyond adjacent differences X<sub>j+1</sub>−X<sub>j</sub>,
also considering X<sub>j+2</sub>−X<sub>j</sub> and X<sub>j+3</sub>−X<sub>j</sub> and so on up to some size limit.
Presumably there are about 2<sup>50</sup> differences below, say, q/2<sup>30</sup>,
and then about 2<sup>50</sup> differences below q/2<sup>80</sup> at the next level,
and then about 2<sup>50</sup> differences below q/2<sup>130</sup> at the next level.
It's tricky to analyze the randomness of lists that include,
e.g., the difference X<sub>1</sub>−X<sub>0</sub>
and the difference X<sub>2</sub>−X<sub>1</sub>
<i>and</i> the difference X<sub>2</sub>−X<sub>0</sub>, which is the sum of X<sub>1</sub>−X<sub>0</sub> and X<sub>2</sub>−X<sub>1</sub>;
one should carry out experiments
to see how well the algorithm actually works.
(One should carry out experiments even
for algorithms where someone claims to have a complete analysis.)
</p>
<p>
Another approach is to start with only 2<sup>34</sup> signatures and consider all sums X<sub>j</sub>+X<sub>i</sub> mod q.
Presumably there will be almost 2<sup>67</sup> different sums,
and more than 2<sup>50</sup> cases where two sums are within q/2<sup>80</sup> of each other,
and more than 2<sup>50</sup> differences below q/2<sup>130</sup> at the next level.
As Bleichenbacher notes in his slides,
there are standard techniques to find nearby sums with far less memory than storing and sorting all the sums.
(For each j, build a low-memory generator that outputs X<sub>j</sub>+X<sub>i</sub> for all i in increasing order,
and then merge the outputs of these generators.
Bleichenbacher credits 1981 Schroeppel–Shamir.
My <a href="https://cr.yp.to/papers.html#sortedsums">sortedsums</a> paper
cites a 1973 Knuth exercise crediting William S. Brown.
It wouldn't be surprising if there are even earlier references.)
</p>
<p>
Or, starting with fewer signatures, we could consider all sums of four X values,
and directly look for 2<sup>50</sup> sums within q/2<sup>130</sup> of each other.
This is essentially the same as looking for 2<sup>50</sup> sums that collide on the top 130 bits.
If you think it's obvious how quickly such searches can be carried out,
then try to explain why the
<a href="https://eprint.iacr.org/2010/189">2010 Howgrave-Graham–Joux</a> subset-sum algorithm has exponent around 0.337n,
and why the
<a href="https://eprint.iacr.org/2011/474">2011 Becker–Coron–Joux</a> subset-sum algorithm has exponent around 0.291n,
and why the
<a href="https://arxiv.org/abs/1907.04295">2019 Esser–May</a> subset-sum algorithm has exponent around 0.255n.
</p>
<p>
<b>An even larger cloud of attacks.</b>
Back in October 2000,
a month before Bleichenbacher's IEEE presentation,
<a href="https://arxiv.org/abs/cs/0010022">Blum, Kalai, and Wasserman (BKW)</a>
had introduced an algorithm to find a secret vector x of integers modulo 2,
given noisy dot products xX<sub>1</sub>+k<sub>1</sub>, xX<sub>2</sub>+k<sub>2</sub>, etc.
Each X<sub>j</sub> is a random public vector of the same length as x,
and each k<sub>j</sub> is a bit set with some specified probability smaller than 1/2.
</p>
<p>
The BKW algorithm sorts X<sub>j</sub> according to their leading bits,
and then computes successive differences X<sub>j+1</sub>−X<sub>j</sub>,
obtaining noisier dot products x(X<sub>j+1</sub>−X<sub>j</sub>)+(k<sub>j+1</sub>−k<sub>j</sub>).
The BKW algorithm repeats this sort-and-difference process
to clear more and more bits of X,
at the expense of more noise.
Eventually it finds many noisy dot products x(0,0,...,0,1)+k'<sub>j</sub>,
takes the majority vote of these dot products to see the last bit of x, and similarly finds the other bits of x.
</p>
<p>
The problem considered by BKW, where x is a vector modulo 2 and some k<sub>i</sub> bits are set,
is called the "learning parity with noise" (LPN) problem.
In the "learning with errors" (LWE) problem,
x is a vector modulo q and each k<sub>i</sub> is a small integer.
LWE for length-1 vectors, the target of Bleichenbacher's attack,
is called the "hidden-number problem" (HNP),
an example of how scientific terminology
can be selected to minimize the amount of information communicated to the uninitiated.
</p>
<p>
Followups to the BKW paper adapted the BKW idea to the LWE problem
and to various lattice problems,
and eventually added further speedup ideas that Bleichenbacher had used,
such as fast Fourier transforms ("fast Walsh transforms" in the mod-2 case) and non-adjacent differences.
An analysis in 2015 by
<a href="https://eprint.iacr.org/2015/1222">Herold, Kirshanova, and May</a>
showed that one of the latest BKW variants
sometimes had better asymptotics than basis reduction
as an attack against reasonable-looking LWE parameters for lattice-based cryptography;
look at Figure 1 in the paper to get a quick idea of how close the competition is.
Papers are continuing to appear with basis-reduction speedups <i>and</i> with speedups for various BKW/Bleichenbacher-type algorithms.
The literature is complicated, and is continuing to become more complicated.
</p>
<p>
As a cryptosystem designer,
I'm much happier with the literature on conservative prime-field ECC.
There's a much simpler state-of-the-art attack algorithm that includes all known optimizations.
There's a convincing high-precision analysis of the performance of the algorithm.
The literature has clear explanations of quantitative obstacles to other attack ideas such as pairings and decomposition,
and has no ideas for getting around these obstacles.
But NSA's DSA biases spoil the simplicity of the attack picture,
forcing the security reviewer to consider
a much more complicated collection of worrisome attack strategies.
</p>
<p>
<b>Overconfidence in limits on the number of signatures.</b>
NIST's 2001 change notice for the DSA standard
provided two options for users to "defend" against Bleichenbacher's attack.
The first option was for users to continue using NSA's biased DSA randomness
but sign at most 2<sup>21</sup> signatures per key,
half of the "2<sup>22</sup> known signatures" used by the "unpublished attack".
</p>
<p>
Why did NIST think that a limit of 2<sup>21</sup> signatures would be safe?
Was there some quantitative analysis saying that reducing 2<sup>22</sup> signatures to 2<sup>21</sup> signatures
would increase the attack cost to something clearly infeasible?
And what made NIST confident that a new "unpublished attack" was optimal?
</p>
<p>
Bleichenbacher needs enough equations to compensate for the noise.
Sorting equations and then subtracting <i>adjacent</i> equations, as in the BKW paper,
doesn't expand the number of equations available.
But Bleichenbacher's slides were explicitly generating
far more equations as sums of small non-adjacent subsets of the original equations.
I don't understand how anyone could have been confident regarding the tradeoffs here,
even before seeing this decade's breakthroughs in subset-sum algorithms.
</p>
<p>
Here are further examples to illustrate the lack of maturity
of the analysis of these tradeoffs.
In 2012,
<a href="https://eprint.iacr.org/2012/699">Damgård and Park</a>
proposed some cryptosystems based on the supposed hardness of the following example of LPN.
There is a secret n-bit vector x, where n is 768.
The attacker sees a limited number of noisy dot products xX+k,
where X is public and the noise k is 1 with probability 1.5%.
The limit is a small constant times n, where the constant depends on the cryptosystem variant.
The original version of the paper
stated that BKW needs as input a gigantic number of "samples" xX+k,
while, for the paper's cryptosystems,
"the adversary only gets O(n) samples, which is the hardest case, so this suggests that relatively small values of n might be sufficient for security".
The paper was then revised to account for
"recent attacks on LPN that invalidated the conclusions of the previous version".
See, e.g., my
<a href="https://eprint.iacr.org/2012/355">Ring-LPN attack paper with Lange</a>.
</p>
<p>
In the LWE context,
a 2014 paper by
<a href="https://eprint.iacr.org/2014/019">Albrecht, Faugère, Fitzpatrick, and Perret</a>
stated that
"one of the main remaining obstacles for applying the BKW algorithm to cryptographic constructions based on LWE
is that it requires an unbounded number of samples to proceed. Lifting this
requirement, if only heuristically, is hence a pressing research question."
Followup papers then pointed out
that one could use far fewer samples.
</p>
<p>
<b>Safe fixes for DSA.</b>
Instead of trying to pretend that the limits of these attacks are clear,
let's eliminate the applicability of the attacks to DSA,
by fixing the problem at its source.
The problem is that—for NSA's choices of q around, say, 0.7 or 0.8 times 2<sup>160</sup>—taking
160 bits of randomness modulo q
produces a biased result.
</p>
<p>
If we modify q, moving it extremely close to 2<sup>160</sup> or to 2<sup>159</sup>,
then the bias rapidly disappears.
This is also naturally accomplished by ECDSA
<i>if</i> we choose a prime p extremely close to 2<sup>160</sup>
(rather than, say, the Brainpool "random" p)
and choose an elliptic curve with a power-of-2 cofactor such as 1 or 2 or 4 or 8:
q will then be extremely close to 2<sup>160</sup> or 2<sup>159</sup> or 2<sup>158</sup> or 2<sup>157</sup> respectively.
</p>
<p>
The bias also rapidly disappears if we take more bits of randomness.
As I mentioned above, if q is between 2<sup>159</sup> and 2<sup>160</sup>,
then you'll never be able to tell the difference between a uniform random 320-bit integer mod q
and a uniform random element of {0,...,q−1}.
This was NIST's second option for users to protect themselves:
concatenate <i>two</i> 160-bit hashes to obtain a 320-bit integer.
</p>
<p>
Ed25519 has both of these defenses.
It uses Curve25519, with a subgroup of prime order extremely close to 2<sup>252</sup>.
It specifies k as a deterministic, easily testable SHA-512 hash of a secret and the message being signed.
Of course, Ed25519 also moves from NSA's
<a href="https://blog.cr.yp.to/20151120-batchattacks.html">dangerously small cryptosystem sizes</a>
up to a safe security level.
</p>
<p>
<b>Timing attacks against DSA.</b>
The reason this isn't the end of the story is that mathematical biases in the construction of the secret k
aren't the only way to leak bits of k.
For example,
a 2011 paper by
<a href="https://eprint.iacr.org/2011/232">Brumley and Tuveri</a>
steals "the private key of a TLS server where the server authenticates with ECDSA signatures".
The attack was demonstrated against OpenSSL using the NIST B-163 curve.
The choice of q here isn't the issue; q is extremely close to a power of 2.
</p>
<p>
The paper title is "Remote timing attacks are still practical".
OpenSSL computed the kth multiple of an elliptic-curve point
with an algorithm whose time revealed the position of the top bit in k:
the algorithm took the maximum time if k was between 2<sup>b−1</sup> and 2<sup>b</sup>,
less time if k was between 2<sup>b−2</sup> and 2<sup>b−1</sup>, etc.
Sometimes timings would show, e.g., that k is below 2<sup>b−8</sup>,
putting the attacker into the situation of the fast Howgrave-Graham–Smart attack.
</p>
<p>
This was just one in a long line of papers using timing attacks to break DSA, ECDSA, etc.
There are, for example, papers
<a href="https://eprint.iacr.org/2014/434">extracting keys more efficiently from timing information</a>,
and there are papers
<a href="https://eprint.iacr.org/2014/140">collecting such precise timing information that key extraction becomes trivial</a>,
and now there's Minerva applying timing attacks to a remarkable number of different targets.
</p>
<p>
<b>How to stop timing attacks.</b>
A programmer who
<a href="https://blog.cr.yp.to/20140517-insns.html">knows enough about CPU timing</a>
can systematically write software that avoids all data flow from secrets to timings.
For example,
all of the C and assembly implementations from the Ed25519 team are written in this way,
as are the <a href="https://nacl.cr.yp.to/">NaCl</a>
and <a href="https://bearssl.org/">BearSSL</a> crypto libraries.
</p>
<p>
(One can also randomize computations to try to obscure the information leaked through timings:
e.g., add a random 512-bit multiple of q to k before scalar multiplication.
However, it's very difficult for the implementor, and for reviewers,
to figure out how secure randomization is against timing attacks.
A better argument for randomization is that attackers sometimes have access to more invasive side channels
such as power measurements:
truly constant power seems very difficult to achieve,
and randomization seems to be our best bet.
I advise against randomization as a <i>replacement</i> for constant-time software,
but I don't object to randomization as an <i>extra</i> line of defense whenever the user can afford it.)
</p>
<p>
Saying that implementors <i>can</i> write constant-time software
doesn't mean that they <i>do</i> write constant-time software.
I see three basic reasons for this.
First, there's a huge amount of variable-time software in existing crypto libraries,
and getting rid of all of this software is a correspondingly huge effort.
Second, many popular cryptographic functions produce unacceptable slowdowns
when they're implemented in constant time.
Third, and most importantly, many popular cryptographic functions are much <i>simpler</i> to implement in variable time.
</p>
<p>
I noticed many years ago that the evolution of computer architecture was making it easier and easier
to resolve the tension between security and speed:
there's a synergy between what I want to do to avoid timing leaks
and what chip designers want to do for performance.
I've set various cryptographic speed records using constant-time software.
Sometimes there are still some minor speedups possible with variable-time software,
but the tension is much smaller than it was,
making it hard for people to argue that these speedups should outweigh security—especially
since computation in general is becoming less and less expensive.
I'm not saying that <i>all</i> cryptographic designs have such small penalties for constant-time implementations;
having the freedom to throw away NSA's designs has been an important part of this work.
</p>
<p>
I've also tried to resolve the tension between security and simplicity.
Software for X25519, Ed25519, etc. does everything the typical user needs,
is much simpler than traditional software aiming at the same security goals,
and would gain very little in simplicity from using variable-time algorithms.
</p>
<p>
But now consider a crypto library that for years has included variable-time software
for NSA's elliptic-curve cryptosystems,
and that wants to keep supporting those cryptosystems for whatever reason,
but that also wants to add support for Ed25519.
Different notions of simplicity then produce different results.
It's simple for the library to copy an existing constant-time Ed25519 implementation;
this implementation might be close to the simplest possible code for Ed25519;
but the library author might think that there are simpler ways to
<i>simultaneously support Ed25519 and NSA's systems</i>.
</p>
<p>
<b>Case study #1: libgcrypt.</b>
In libgcrypt,
there's a function
<tt>_gcry_mpi_ec_mul_point</tt>
that computes kP on an elliptic curve E, given k and P and E as inputs.
The main loop inside the function has length
<tt>mpi_get_nbits(k)</tt>,
a simple example of what one must not do in constant-time software.
Actually, the function has different loops for different types of curves,
and a complete description of the loop length is more complicated,
but what matters is that a smaller k runs measurably faster.
</p>
<p>
The real fix, the constant-time approach,
would start by changing the interface to replace
<tt>mpi_get_nbits(k)</tt>
with a <tt>maxscalarbits</tt> specified by the caller.
But this would require going through dozens of functions that call
<tt>_gcry_mpi_ec_mul_point</tt>
and figuring out the appropriate <tt>maxscalarbits</tt> for each.
This is an example of tension between simplicity and security.
Even a small tension can push implementors to do something insecure.
The tension increases as more and more elliptic-curve protocols are implemented on top of the existing
<tt>_gcry_mpi_ec_mul_point</tt> interface.
It's not surprising that libgcrypt still has the old variable-time interface.
</p>
<p>
At this point one might think that, well, libgcrypt is leaking the number of bits of k,
so the standard lattice attacks apply,
whether the protocol is ElGamal or Schnorr or DSA or ECDSA or EdDSA.
This is also what Minerva claimed at first.
But let's take a closer look at how large k is.
</p>
<p>
The DSA and ECDSA standards say that k is between 0 and q.
By now there are several different standard methods for generating k.
libgcrypt's <tt>_gcry_dsa_gen_k</tt> uses one of these methods,
namely rejection sampling,
which I described above.
</p>
<p>
EdDSA uses a different name "r" for k,
and says that "r" is SHA-512 applied to various specified inputs.
This is what libgcrypt implements:
hashing the inputs with
<tt>_gcry_md_hash_buffers</tt>,
then reading the 64-byte result into a multiprecision integer <tt>r</tt>
with
<tt>_gcry_mpi_set_buffer</tt>,
then calling
<tt>_gcry_mpi_ec_mul_point</tt>.
</p>
<p>
Now <tt>_gcry_mpi_ec_mul_point</tt> leaks whether "r" has 512 bits, 511 bits, 510 bits, etc.
But this is useless for the attacker.
Say "r" has only 500 bits;
the attacker still has no idea what "r" mod q might be.
This is why Minerva
works against libgcrypt's implementation of ECDSA
and doesn't work against libgcrypt's implementation of EdDSA.
</p>
<p>
The situation would have been different if libgcrypt had inserted an extra line of code
to reduce modulo q before calling
<tt>_gcry_mpi_ec_mul_point</tt>.
But this wouldn't have been as simple,
so it's not such a surprise that this didn't happen.
(The extra reduction work would have produced a speedup,
but copying existing constant-time Ed25519 software would have produced a much larger speedup.)
</p>
<p>
I described this scenario in a CFRG message
<a href="https://mailarchive.ietf.org/arch/msg/cfrg/8z3ZcujGRxFSGEBI-uE7C1tjw4c">five years ago</a>:
</p>
<blockquote>
The best protection we know is to generate much longer nonces—such as
the 512-bit nonces in Ed25519. Then the system isn't broken by a timing
attack revealing the nonce length. Setting the high bit of such a long
nonce is also perfectly safe.
<p>
Of course, an implementor can still get in trouble by (1) reducing these
nonces and then (2) leaking the lengths of the reduced nonces through a
variable-time scalarmult method. So, as another line of defense, we also
choose curves that support simple, fast, constant-time ladders.
</p></blockquote>
<p>
libgcrypt is in the scenario of the first paragraph:
the libgcrypt timing reveals the number of leading zeros in Ed25519's 512-bit hash,
but this doesn't break the system.
libgcrypt doesn't reduce the nonces,
so it doesn't get into the trouble described in the second paragraph.
</p>
<p>
There have been many other timing-attack vulnerabilities in libgcrypt,
and clearly there will be more.
We have to throw away variable-time crypto code <i>without</i> waiting for attacks to be demonstrated.
For example,
libgcrypt should use the constant-time ladders supported by Curve25519.
But this doesn't mean that Minerva broke libgcrypt's Ed25519 implementation:
libgcrypt was saved by another Ed25519 feature, the double-size hash.
</p>
<p>
<b>Case studies #2, #3, #4, #5, #6, #7, and #8.</b>
A quick skim suggests that
BoringSSL, Botan, Crypto++, libtomcrypt, MatrixSSL, OpenSSL, and wolfSSL/wolfCrypt
all started with upstream Ed25519 implementations that advertise being constant-time,
such as
<tt>ref10</tt> from the Ed25519 team,
<tt>donna</tt> from 
<a href="https://github.com/floodyberry/ed25519-donna">Adam Langley and Andrew Moon</a>,
<tt>tweetnacl</tt> from the 
<a href="https://tweetnacl.cr.yp.to/">TweetNaCl team</a>,
and
<tt>fiat</tt> from the
<a href="https://github.com/mit-plv/fiat-crypto">Fiat Crypto team</a>.
</p>
<p>
Of course, a quick skim isn't the same as a serious security review.
The sheer volume of code is horrifying for the reviewer.
Unlike the upstream implementations,
these seven crypto libraries don't declare time variability to be a bug
(unless the bug is shown to be exploitable and, in the case of OpenSSL, remotely exploitable),
so a reviewer who finds time variability isn't automatically rewarded
with an acknowledgment of a valid bug report.
The libraries have so much existing variable-time code
that they're scared to declare time variability to be a bug.
</p>
<p>
So I'm certainly not guaranteeing that timing attacks will fail against all these Ed25519 implementations.
But, given how much of the code in these Ed25519 implementations is coming from people
who say they were engineering it to be immune to all timing attacks,
it wouldn't be surprising if it <i>is</i> immune to all timing attacks.
</p>
<p>
Does the prevalence of constant-time implementations of a primitive
mean that the primitive encourages such implementations?
Superficial answer:
Yes.
New implementations can simply copy the existing constant-time implementations.
This is what these seven libraries did,
protecting the users.
(But, again, one has to verify that the upstream implementations really are constant-time,
and that this wasn't screwed up by whatever modifications happened
as part of the library integration.)
</p>
<p>
Deeper answer:
Not necessarily.
Maybe the primitive is painful to implement in constant time.
Maybe the first implementors suffered through doing this,
but new implementations will cut corners.
</p>
<p>
In the case of Ed25519,
it's clear from
<a href="https://blog.cr.yp.to/20140323-ecdsa.html">a detailed design comparison</a>
that Ed25519 is much friendlier to constant-time implementations than NSA ECC is. 
This doesn't guarantee constant-time implementations,
but it does make them more likely.
</p>
<p>
<b>Case study #9.</b>
Finally,
I looked briefly at BouncyCastle,
which wrote everything from scratch in Java.
BouncyCastle is full of variable-time code.
I don't immediately see why BouncyCastle wasn't broken by Minerva.
BouncyCastle uses scalars smaller than q for scalar multiplication
for ECDSA <i>and</i> EdDSA, unlike libgcrypt,
so BouncyCastle <i>isn't</i> protected by the double-size hash.
</p>
<p>
If BouncyCastle's implementations of ECDSA and EdDSA <i>are</i> broken by timing attacks
then the tallies turn into
13 crypto libraries supporting ECDSA with timing attacks on 5 or possibly 6,
and
9 crypto libraries supporting EdDSA with timing attacks on just 1.
This still sounds like a big win for EdDSA overall,
but it's interesting to contemplate ways that we could have saved BouncyCastle too.
</p>
<p>
Why didn't BouncyCastle use a simple constant-time ladder?
This is clear from the code:
BouncyCastle has many complications that are aiming for speed
at the expense of simplicity.
In particular,
BouncyCastle sacrifices a small amount of code simplicity to reduce k mod q,
and sacrifices even more code simplicity to use precomputed tables of various multiples
of the fixed base point P.
These steps obviously make signatures several times faster.
</p>
<p>
Precomputed tables are still compatible with constant-time code,
as shown in previous Ed25519 implementations.
Why didn't BouncyCastle use this approach?
This isn't as clear.
Variable-time fixed-base scalar multiplication
is at best marginally faster than constant-time fixed-base scalar multiplication.
Perhaps there haven't been enough tutorials showing how to implement
constant-time fixed-base scalar multiplication.
</p>
<p>
We don't want reviewers to have to analyze the security consequences
of <i>any</i> timing leaks,
so, at a lower level,
it's also important to perform field arithmetic in constant time.
BouncyCastle doesn't do this:
it implements prime-field arithmetic on top of a big-integer library
that computes the size of each integer at run time.
But why didn't BouncyCastle copy constant-time arithmetic mod 2<sup>255</sup>−19
from previous implementations,
as a fast path for Ed25519 separate from the existing big-integer code?
</p>
<p>
One possible answer is along the following lines:
"A crypto library should support 82 elliptic curves
but, for simplicity, shouldn't separately implement 82 finite fields."
I would say that, for simplicity and security,
a crypto library should <i>not</i> support 82 elliptic curves.
I think we've made some progress in convincing the community of this.
There has also been considerable progress in building automatic generators for finite-field code,
although there is still much more work to be done.
</p>
<p>
[<b>2019.11.01 correction:</b>
BouncyCastle
<i>does</i> have a separate implementation of
<a href="https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/math/ec/rfc7748/X25519Field.java">arithmetic
modulo 2<sup>255</sup>−19</a>,
and higher-level implementations of
<a href="https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/math/ec/rfc7748/X25519.java">X25519</a>
and
<a href="https://github.com/bcgit/bc-java/blob/master/core/src/main/java/org/bouncycastle/math/ec/rfc8032/Ed25519.java">Ed25519</a>
on top of this.
BouncyCastle's EdDSA implementation consists of
this Ed25519 implementation and a similar implementation for Ed448.
These implementations are designed to run in constant time
(except for clearly marked <tt>Var</tt> subroutines applied to public data).
Looks like another win for EdDSA.
BouncyCastle has also been making some progress
in removing variable-time code elsewhere:
for example, for ECDSA,
BouncyCastle 1.59 removed some variable-time array lookups,
although it is still using the variable-time big-integer library.
Thanks to Peter Dettman for the information.]
</p>
<p>
More fundamentally,
why didn't BouncyCastle call existing high-speed code in other languages
for arithmetic mod 2<sup>255</sup>−19, or for the full Ed25519 operations?
Sure, some people might want to use BouncyCastle on platforms
that don't have this code and that don't make it easy to install this code,
but calling the code whenever it <i>is</i> available
would give BouncyCastle much better Ed25519 speeds—and,
as a side effect, would stop timing attacks.
</p>
<p>
The Ed25519 team could have provided a constant-time Java implementation from the outset.
To me this feels like the wrong direction:
every extra piece of crypto code is an extra problem for reviewers and
shouldn't be created in the first place unless there's a clear argument that it's needed.
A few implementations of a few cryptographic primitives have been computer-verified,
and improved tools will cover much more in the foreseeable future,
but verifying a Java implementation
is surely a lower priority than verifying a faster implementation that can be called from Java <i>and</i> from many other languages.
</p>
<p>
I see cryptography as a basic operating-system service,
just like access to network cards.
We don't, and we shouldn't, write network-card drivers in many different application languages;
we write them in a few network-card-driver languages,
and on top of this we provide simple networking abstractions to the designers of other languages,
who in turn provide various higher-level networking abstractions to applications.
There's much more to be said about the design of network-card-driver languages,
and about the design of languages for cryptography,
but that's a topic for another blog post.
</p>
<hr><span size="1"><b>Version:</b>
This is version 2019.11.01 of the 20191024-eddsa.html web page.
</span>

</div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>