<!DOCTYPE html>
<html lang="en">
<head>
    <title>
An Introduction to SequenceReader -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>An Introduction to SequenceReader</h1>
    <div class="entry-content"> <p>In this post, I want to explore a new feature of .NET Core 3.0, which simplifies working with a <span class="tadv-color"><strong>ReadOnlySequence</strong></span>. You may find yourself using a ReadOnlySequence if you work with a <span class="tadv-color"><strong>PipeReader</strong></span> from System.IO.Pipelines. Before .NET Core 3.0, one would need to manually slice through the ReadOnlySequence from the Buffer property on the <strong><span class="tadv-color">ReadResult</span></strong>. With <strong><span class="tadv-color">SequenceReader</span></strong>, we can simplify these tasks and let the framework do some of the repetitive work for us in the most optimal way.</p> <p>At the time of
writing, SequenceReader isn&#x2019;t documented anywhere, so I wanted to cover an
example use case here to help people get started. We won&#x2019;t touch the entire API
surface, but hopefully, there&#x2019;s enough here to get you up to speed with the
core functionality.</p> <h2>What is a ReadOnlySequence?</h2> <p>It&#x2019;s
probably worth addressing this question first since this is a reasonably new
type in .NET Core and there are limited cases where you&#x2019;ll come across it.</p> <p>Some time ago, the <strong><span class="tadv-color">Span&lt;T&gt;</span></strong> and <strong><span class="tadv-color">Memory&lt;T&gt;</span></strong> types where added. These both support working with continuous regions of memory of various types, through consistent APIs. Since then, many new constructs have built upon the foundation that these types provide. One such example is <a href="https://devblogs.microsoft.com/dotnet/system-io-pipelines-high-performance-io-in-net/">System.IO.Pipelines</a> which is a high-performance API for dealing with IO.</p> <p>Traditionally, streams were used for many IO operations. A problem with streams is that they leave you in charge of managing the buffers and copying data between them. Pipelines helps in both cases, by handling the buffers for you internally, exposing the memory without copying where possible. At a simplified conceptual level, the pipe requests some memory from the memory pool, which it then manages, allowing data written to the pipe to be stored in the memory and then read from it. If we know the content length up-front, this simple approach will work very well, but often we don&#x2019;t know the amount of data which will be written in advance.</p> <p>Therefore,
pipelines relies on the concept of a sequence of memory segments. This is
exposed by the PipeReader as a ReadOnlySequence&lt;T&gt;. This is essentially
just a linked list of Memory&lt;T&gt; instances. When data is first written, a
single Memory&lt;T&gt; buffer is used. If that fills up, then a new
Memory&lt;T&gt; segment can be requested. The writing of data can continue into
that second segment. Whilst each Memory&lt;T&gt; instance is a contiguous
region of memory; each instance will likely refer to different regions in
memory. To access the memory across these Memory&lt;T&gt; segments, a sequence
is formed which links them together in the correct order.</p> <p>With
this sequence, we now have a virtual contiguous block of memory that we can
read through.</p> <figure class="wp-block-image"><img src="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/ReadOnlySequence-Diagram.png" alt="ReadOnlySequence logical diagram" class="wp-image-1832" srcset="https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/ReadOnlySequence-Diagram.png 750w, https://www.stevejgordon.co.uk/wp-content/uploads/2019/09/ReadOnlySequence-Diagram-300x149.png 300w" sizes="(max-width: 750px) 100vw, 750px"></figure> <p><em>In this diagram, we have three contiguous blocks of memory referenced via Memory&lt;T&gt;. These can exist in three different memory locations. The ReadOnlySequence logically combines these so that the data can be consumed across the segments.</em></p> <h2>Introducing the Sample Scenario</h2> <p>I&#x2019;ll be using a simple sample to demonstrate the use of SequenceReader for the remainder of this post. You can find the complete sample code in my <a href="https://github.com/stevejgordon/SequenceReaderSample">GitHub repository</a>.</p> <p><em>NOTE: This sample is simplified and skips some steps that you may want to apply when working with pipelines and a ReadOnlySequence. The focus here is on looking at the SequenceReader API and not about ultimate performance optimisation. We can revisit that in a future post and touch on some things we might do to enhance this sample to deal with cases when the sequence contains a single segment, for example.</em></p> <p>The scenario here is that we have a Stream of bytes that we know contains UTF8 data which is a comma-separated list of values. In this case, I&#x2019;ve built the stream manually, but a real-world scenario would be receiving these bytes from an HTTP endpoint. In that case, you&#x2019;d likely get the content stream from the HttpResponseMessage. The setup code is contained within the &#x2018;CreateStreamOfItems method&#x2019;. I won&#x2019;t show that code here as it&#x2019;s not too crucial to describe the SequenceReader API. You can view it in the GitHub repo if you&#x2019;re interested.</p> <h2>Working with the PipeReader</h2> <p>Now that we have a stream, we want to work with it via the Pipelines feature. In .NET Core 3.0, convenience methods have been introduced to make converting a stream to a PipeReader trivial.</p> <p>PipeReader now includes a static factory method called Create which accepts a stream and optionally a StreamPipeReaderOptions. We can pass in our sample stream. For this demo, I&#x2019;m passing in a StreamPipeReaderOptions which sets a small buffer size. This is not required and is used in this demo to ensure we don&#x2019;t get the entire stream of bytes back in a single buffer. This allows us to demonstrate the approach of reading portions of the pipe as distinct sequences which span Memory buffers. Again, you don&#x2019;t need to do this in production, and the defaults are probably going to be okay.</p> <p>The remaining code in the Main method deals with reading from the pipe.</p> <p>We use an infinite loop that we&#x2019;ll break out of once the pipe has been fully read. To begin reading, we can call ReadAsync on the PipeReader which returns a ReadResult. Within the ReadResult, we can access the Buffer property. This gives us our ReadOnlySequence. I pass that into a method called &#x2018;ReadItems&#x2019; which we&#x2019;ll explore more deeply in a moment. We also pass in a bool indicating if the result IsCompleted, which would indicate we have the last of the data from the pipe in the buffer.</p> <p>We use this bool to break from the loop after the last of the data has been processed. In cases where there is still more data, we advance the PipeReader. This method takes the consumed SequencePosition, which is the position of the bytes we&#x2019;ve been able to read and use successfully. It also takes the examined SequencePosition, which indicates what we&#x2019;ve read but not yet consumed. We may have a buffer which contains an incomplete item so while we can examine that data, we won&#x2019;t be able to use it until we have the complete item. Buffers holding consumed bytes can be released once all of the data is consumed. Buffers holding examined data remain available so that on the next pass, once we&#x2019;ve read more data into the internal buffer(s), we can hopefully process the now complete item.</p> <p>When we exit this loop having read all of the data, we mark the PipeReader as complete.</p> <h2>Using SequenceReader&lt;T&gt;</h2> <p>Finally, we&#x2019;ve reached the main focus of this blog post! Let&#x2019;s look at how the SequenceReader can help consume the ReadOnlySequence.</p> <p>I&#x2019;ve factored the majority of the code into a method called &#x2018;ReadItems&#x2019;. There are two reasons for this. First, it breaks up the code in more readable units, which I prefer. Secondly, and most importantly, we have to do this for this demo.</p> <p>The SequenceReader type, like Span&lt;T&gt;, is a <a href="https://blogs.msdn.microsoft.com/mazhou/2018/03/02/c-7-series-part-9-ref-structs/">ref struct</a>, which comes with some limitations about its use. One of those limitations is that it cannot be a method parameter of async methods or lambda expressions. The reason it needs to be defined as a ref struct is that internally it has ReadOnlySpan&lt;T&gt; properties and this forces the cascade of the ref struct rule that instances can only ever be stored on the stack; not the heap.</p> <p>My &#x2018;Main&#x2019; method is async and therefore I can&#x2019;t use a SequenceReader directly there. Instead, by factoring the code into a non-async method, we can now use SequenceReader and call this synchronous method from the asynchronous one.</p> <p>Let&#x2019;s explore the code&#x2026;</p> <p>We start by creating a SequenceReader, passing in the current ReadOnlySequence.</p> <p>We begin a loop which will exit if the reader.End property is true. This will be the case when there is no more data left to be consumed from the sequence.</p> <p>Various methods exist on the SequenceReader to support reading and/or advancing through the sequence. We can use the <strong><span class="tadv-color">TryReadTo</span></strong> method to attempt to read data up to a given delimiter. In this case, we&#x2019;re parsing through comma-separated data, so we provide the byte of a comma as the delimiter argument. </p> <p>If the provided delimiter is found within the sequence, the out parameter will contain the ReadOnlySpan up to (but not including) the delimiter from the current position. In this demo, this will be the bytes for an item. By default, TryReadTo will also advance the sequence reader position past the delimiter, but this can be controlled with the advancePastDelimiter argument.</p> <p>When TryReadTo returns true, it indicates that the reader found a delimiter and we now have the bytes in the itemBytes variable. We can now work with those bytes. For this simple demo, we&#x2019;ll convert them to a string and write that to the console.</p> <p>TryReadTo will return false when the byte value for the delimiter is not found in the sequence. This may occur in one of two cases.</p> <p>It&#x2019;s possible that the Pipe now contains all of the available data and the PipeWriter is completed. In this case, all of the remaining bytes will exist in the ReadResult buffer. When that is the case, the ReadResult.IsCompleted property will be true. Our method accepts this as an argument so we can handle this special case.</p> <p>Since the last item in our data will not include a comma delimiter after it, we need to handle the data a little differently. Our position in the sequence will be at the start of the item, so we can assume that the remaining bytes represent the whole item. We have a separate private method to handle this remaining data, called &#x2018;ReadLastItem&#x2019;. We pass the current sequence to this method, slicing it from the current position to ensure we are only passing the remaining, unprocessed bytes.</p> <p>A a high level, this method copies the remaining bytes from the sequence into a temporary buffer which can then be used to get the string representation of those bytes. The &#x2018;ReadLastItem&#x2019; method achieves this using two potential approaches.</p> <p>The expected case is that we avoid any heap allocations by using a temporary buffer for the bytes which is created on the stack. This is possible, thanks to Span which supports referencing stack memory in a safe way. Since working on the stack has some risks around reaching the stack memory limit, we ensure that the length of the remaining bytes is less than our safe limit of 128. With our sample data, we know this to be true, but we should never assume that something won&#x2019;t change, especially in a real-world case when retrieving this data from an external endpoint.</p> <p>The second flow which occurs only if the length of the data is beyond our stack safe limit. It uses the ArrayPool to get a temporary byte buffer. This also avoids allocations since we&#x2019;re using a pool of re-usable arrays. It&#x2019;s slightly less performant than the stack approach but still pretty efficient overall. We rent an array which will have a capacity at least as large as the length of the bytes we have in the sequence. Be aware that the array is likely to be larger than we require.</p> <p>In both cases, we can copy the bytes from the sequence using the <strong>CopyTo</strong> method into the temporary buffer. We then use the Encoding.UTF8.GetString method to convert the bytes to a string representation. In the case of the ArrayPool code path, we must ensure we slice our array to the correct length since the ArrayPool has likely returned us an array longer than our data. We don&#x2019;t want to try and convert bytes beyond those that we&#x2019;ve copied in.</p> <p>The &#x2018;ReadLastItem&#x2019; method returns the string value for the final item. Back in the ReadItems method, this string is written to the console. The reader is then advanced by the length of the sequence. This should put us at the end of the sequence, which will cause the while loop to exit. We could just as easily used the break keyword here, but I wanted to demonstrate the <strong>Advance</strong> method on the reader.</p> <p>Getting back to the conditions around the <strong>TryReadTo</strong> call, the second possibility is that, the currently buffered bytes from the PipeReader include an incomplete item. In our case, we could, for example, have the bytes representing &#x201C;Ite&#x201D; at the end of the sequence. Until the PipeReader has buffered the remainder of the item, we can&#x2019;t do anything with this partial item. In this case, we hit the last conditional block and break from the while loop. The &#x2018;ReadItems&#x2019; method returns the current SequencePosition that the SequenceReader has reached within the sequence. Remember, only once we&#x2019;ve successfully read a complete item is the position within the sequence advanced. In this situation, the position will indicate the start of the incomplete item that we have found in the sequence.</p> <p>&#x2018;ReadItems&#x2019; returns back to the while loop where we are reading from the PipeReader. This loop continues until all of the data from the Pipe has been consumed successfully.</p> <h2>Summary</h2> <p>I think that&#x2019;s an excellent place to end this post. We&#x2019;ve explored some of the newer APIs in .NET Core 3.0 as well as taking an opportunity to look at System.IO.Pipelines and the new stream connector that makes it easy to take a stream and work with it via a PipeReader. Unless you do a lot of IO work, you may never find yourself using Pipelines, and therefore the ReadOnlySequence and SequenceReader may not be types that you use either.</p> <p>SequenceReader makes consuming the ReadOnlySequence from a PipeReader quite straightforward for this sample case. If you want to work with byte data efficiently, parsing it with as few allocations as possible, Pipelines and the SequenceReader combine to make this possible. I&#x2019;d be interested to see other examples of use cases and approaches which leverage SequenceReader.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>