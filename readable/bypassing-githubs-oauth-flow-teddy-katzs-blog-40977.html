<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Bypassing GitHub&#x2019;s OAuth flow - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Bypassing GitHub&#x2019;s OAuth flow - linksfor.dev(s)"/>
    <meta property="og:description" content="For the past few years, security research has been something I&#x2019;ve done in my spare time. I know there are people that make a living off of bug bounty programs, but I&#x2019;ve personally just spent a few hours here and there whenever I feel like it."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.teddykatz.com/2019/11/05/github-oauth-bypass.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Bypassing GitHub&#x2019;s OAuth flow</title>
<div class="readable">
        <h1>Bypassing GitHub&#x2019;s OAuth flow</h1>
        <p>
Reading time: 7-8 minutes        </p>
        <p><a href="https://blog.teddykatz.com/2019/11/05/github-oauth-bypass.html">https://blog.teddykatz.com/2019/11/05/github-oauth-bypass.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>For the past few years, security research has been something I‚Äôve done in my spare time. I know there are people that make a living off of bug bounty programs, but I‚Äôve personally just spent a few hours here and there whenever I feel like it.</p>

<p>That said, I‚Äôve always wanted to figure out whether I‚Äôd be able to make a living on bug bounties if I chose to work on them full time. So I tried doing that for a couple months this summer, spending a few hours a day looking for security bugs in GitHub.</p>

<p>My main workflow was to download a <a href="https://enterprise.github.com/releases/">trial version of GitHub Enterprise</a>, deobfuscate it using a modified version of <a href="https://gist.github.com/iscgar/e8ea7560c9582e4615fcc439177e22b7">this script</a>, and then just stare at GitHub‚Äôs Rails code for awhile to try to spot anything weird or exploitable. Overall, GitHub‚Äôs code seems very well-architected from a security perspective. I would occasionally find a bug caused by an unhandled case in some application logic, only to realize that the bug didn‚Äôt create a security issue because (e.g.) the code was running a query with reduced privileges anyway. Almost every app has bugs, but one big challenge of security engineering is to make bugs unexploitable without knowing where they are, and GitHub seems to do a very good job of that.</p>

<p>Even so, I managed to find a few interesting issues over the summer, including a complete OAuth authorization bypass.</p>

<h2 id="githubs-oauth-flow">GitHub‚Äôs OAuth Flow</h2>

<p>At one point in June, I was looking at the code that implements GitHub‚Äôs <a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/">OAuth flow</a>. Briefly, the OAuth flow is supposed to work like this:</p>

<ol>
  <li>Some third-party application (‚ÄúFoo App‚Äù) wants to access a user‚Äôs GitHub data. It sends the user to <code>https://github.com/login/oauth/authorize</code> with a bunch of information in the querystring.</li>
  <li>
    <p>GitHub displays an authorization page to the user, like the one below.</p>

    <p><img src="https://blog.teddykatz.com/assets/img/oauth-flow-prompt.png" alt="Screenshot of GitHub's OAuth authorization page. The page says that an OAuth app would like to access the user's GitHub account, and contains an 'Authorize' button." height="400"></p>
  </li>
  <li>If the user chooses to grant access to the app, they click the ‚ÄúAuthorize‚Äù button on the page and are redirected to Foo App with an authorization code in the querystring. This code can then be used to access the requested data. (The user can also decline to give their data to the app.)</li>
</ol>

<p>When reviewing this, I took a look at how the ‚ÄúAuthorize‚Äù button is implemented. It turns out that the button is actually a self-contained HTML form that sends a POST request with some hidden form fields, including a CSRF token. When that POST request is sent (and the CSRF token is validated), the user is considered to have granted permissions to the app. Seems reasonable so far.</p>

<p>Interestingly, the endpoint URL for the ‚ÄúAuthorize‚Äù button is <code>/login/oauth/authorize</code>, which happens to be the same as the URL for the authorization page itself. GitHub figures out which response to send based on the HTTP request method (<code>GET</code> requests return the HTML authorization page, and <code>POST</code> requests grant permissions to the app).</p>

<p>This behavior switch actually happens within application code. The router forwards both <code>GET</code> and <code>POST</code> requests to the same controller:</p>

<div><div><pre><code><span># In the router</span>

<span>match</span> <span>"/login/oauth/authorize"</span><span>,</span> <span># For every request with this path...</span>
  <span>:to</span> <span>=&gt;</span> <span>"[the controller]"</span><span>,</span> <span># ...send it to the controller...</span>
  <span>:via</span> <span>=&gt;</span> <span>[</span><span>:get</span><span>,</span> <span>:post</span><span>]</span> <span># ... as long as it's a GET or a POST request.</span>
</code></pre></div></div>

<div><div><pre><code><span># In the controller</span>

<span>if</span> <span>request</span><span>.</span><span>get?</span>
  <span># serve authorization page HTML</span>
<span>else</span>
  <span># grant permissions to app</span>
<span>end</span>
</code></pre></div></div>

<p>So the router accepts either a <code>GET</code> or a <code>POST</code> request, and the controller checks which type of request was sent and behaves accordingly. At first glance, this doesn‚Äôt seem like a problem ‚Äì and it wouldn‚Äôt be, except that the router isn‚Äôt telling the truth.</p>

<h2 id="http-head-requests-and-why-the-rails-router-sometimes-lies">HTTP HEAD requests, and why the Rails router sometimes lies</h2>

<p>Let‚Äôs talk about HTTP methods.</p>

<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD">HTTP <code>HEAD</code> method</a> has been around since HTTP was originally created, but it doesn‚Äôt get a lot of use. When a server receives a HEAD request, the expected semantics are, ‚Äúpretend this is a GET request, but only send back response headers without a response body‚Äù. This has a few niche uses. For example, a client can send a <code>HEAD</code> request to check the size of a large file (via the <code>Content-Length</code> response header) before deciding whether it wants to start downloading the file.</p>

<p>Naturally, people writing web apps usually don‚Äôt want to take the time to implement behavior for HEAD requests. Getting a product that works is understandably considered more important than compliance with niche parts of the HTTP spec. But in general, it‚Äôs nice if HEAD requests can be processed correctly, provided that app developers don‚Äôt have to deal with them manually. So Rails (along with some other web frameworks) implements a clever hack: it <a href="https://github.com/rails/rails/blob/bc5d9567be44e6241a049c01605ad6cfefe42e10/actionpack/lib/action_dispatch/journey/router.rb#L133-L147">tries to route <code>HEAD</code> requests to the same place as it would route <code>GET</code> requests</a>. Then it runs the controller code, and just omits the response body.</p>

<p>So that‚Äôs nice, but it‚Äôs a leaky abstraction. If a controller calls <code>request.get?</code> on a request like this, it will return false, because it‚Äôs still a <code>HEAD</code> request, not a <code>GET</code> request.</p>

<h2 id="abusing-head-requests">Abusing HEAD requests</h2>

<p>What happens if we send an authenticated <code>HEAD</code> request to <code>https://github.com/login/oauth/authorize</code>? We‚Äôve concluded that the router will treat it like a <code>GET</code> request, so it will get sent to the controller. But once it‚Äôs there, the controller will realize that it‚Äôs not a <code>GET</code> request, and so the request will be handled by the controller as if it was an authenticated <code>POST</code> request. As a result, GitHub will find the OAuth app specified in the request, and grant it access to the authenticated user‚Äôs data.</p>

<p>Why is this useful? Well, GitHub‚Äôs CSRF protection requires all authenticated <code>POST</code> requests to include a CSRF token. But <code>HEAD</code> requests don‚Äôt need a CSRF token, since they‚Äôre not supposed to have side-effects. So we can send a cross-site authenticated <code>HEAD</code> request that will give arbitrary OAuth permissions, without showing the user a confirmation page at all.</p>

<p>As a result, if a user visited an attacker‚Äôs website, the attacker could arbitrarily read or modify private data in the user‚Äôs GitHub account. Here‚Äôs a <a href="https://not-an-aardvark.github.io/oauth-bypass-poc-fbdf56605489c74b2951/">proof-of-concept</a> (which no longer works because the issue has been patched).</p>

<p>I reported this issue to GitHub‚Äôs bug bounty program, and they shipped a fix to production in about three hours. I also got a $25000 bounty (!), which at the time was the highest bounty ever from GitHub‚Äôs program.</p>

<h2 id="timeline">Timeline</h2>

<ul>
  <li><strong>2019-06-19 23:28:56 UTC</strong> Issue reported to GitHub on HackerOne</li>
  <li><strong>2019-06-19 23:36:50 UTC</strong> Issue confirmed by GitHub security team</li>
  <li><strong>2019-06-20 02:44:29 UTC</strong> Issue patched on github.com, GitHub replies on HackerOne to double-check that the patch fully resolves the issue</li>
  <li><strong>2019-06-26 16:19:20 UTC</strong> GitHub Enterprise 2.17.3, 2.16.12, 2.15.17, and 2.14.24 released with the patch (see <a href="https://enterprise.github.com/releases/2.17.3/notes">GitHub‚Äôs announcement</a>).</li>
  <li><strong>2019-06-26 22:30:45 UTC</strong> GitHub awards $25000 bounty</li>
</ul>

  </div>
</article>

      </div>
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>