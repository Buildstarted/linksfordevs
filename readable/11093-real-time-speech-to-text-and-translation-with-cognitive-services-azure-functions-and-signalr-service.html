<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Real-time Speech-to-Text and Translation with Cognitive Services, Azure Functions, and SignalR Service -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Real-time Speech-to-Text and Translation with Cognitive Services, Azure Functions, and SignalR Service</h1><div><div class="main-article"><p><br>When we do a live presentation — whether online or in person — there are often folks in the audience who are not comfortable with the language we're speaking or they have difficulty hearing us. Microsoft created <a href="https://translator.microsoft.com/help/presentation-translator/?WT.mc_id=anthonychuca-blog-antchu">Presentation Translator</a> to solve this problem in PowerPoint by sending real-time translated captions to audience members' devices.</p><p>In this article, we'll look at how (with not too many lines of code) we can build a similar app that runs in the browser. It will transcribe and translate speech using the browser's microphone and broadcast the results to other browsers in real-time. And because we are using serverless and fully managed services, it can scale to support thousands of audience members. Best of all, these services all have generous free tiers so we can get started without paying for anything!</p><h2>Overview</h2><p>The app consists of two projects:</p><ul><li>A Vue.js app that is our main interface. It uses the Microsoft Azure Cognitive Services Speech SDK to listen to the device's microphone and perform real-time speech-to-text and translations.</li><li>An Azure Function app providing serverless HTTP APIs that the user interface will call to broadcast translated captions to connected devices using Azure SignalR Service.</li></ul><p><img src="/post-assets/2019-03-26/architecture.png" alt="Architecture"></p><h2>Speech SDK for Cognitive Services</h2><p>Most of the heavy-lifting required to listen to the microphone from the browser and call Cognitive Speech Services to retrieve transcriptions and translations in real-time is done by the service's <a href="https://docs.microsoft.com/javascript/api/microsoft-cognitiveservices-speech-sdk/?WT.mc_id=anthonychuca-blog-antchu&amp;view=azure-node-latest">JavaScript SDK</a>.</p><p>The SDK requires a Speech Services key. You can create a free account (up to 5 hours of speech-to-text and translation per month) and view its keys by running the following Azure CLI commands:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash">az cognitiveservices account create <span class="nt">-n</span><span class="nv">$SPEECH_SERVICE_NAME</span><span class="nt">-g</span><span class="nv">$RESOURCE_GROUP_NAME</span><span class="nt">--kind</span> SpeechServices <span class="nt">--sku</span> F0 <span class="nt">-l</span> westus
az cognitiveservices account keys list <span class="nt">-n</span><span class="nv">$SPEECH_SERVICE_NAME</span><span class="nt">-g</span><span class="nv">$RESOURCE_GROUP_NAME</span></code></pre></div><p>You can also create a free Speech Services account using the Azure portal using <a href="https://portal.azure.com/?WT.mc_id=anthonychuca-blog-antchu#create/Microsoft.CognitiveServicesSpeechServices">this link</a> (select <em>F0</em> for the free tier).</p><h2>Azure SignalR Service</h2><p>Azure SignalR Service is a fully managed real-time messaging platform that supports WebSockets. We'll use it in combination with Azure Functions to broadcast translated captions from the presenter's browser to each audience member's browser. SignalR Service can scale up to support hundreds of thousands of simultaneous connections.</p><p>SignalR Service has a free tier. To create an instance and obtain its connection string, use the following Azure CLI commands:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash">az signalr create <span class="nt">-n</span><span class="nv">$SIGNALR_NAME</span><span class="nt">-g</span><span class="nv">$RESOURCE_GROUP_NAME</span><span class="nt">--sku</span> Free_DS2 <span class="nt">-l</span> westus
az signalr key list <span class="nt">-n</span><span class="nv">$SIGNALR_NAME</span><span class="nt">-g</span><span class="nv">$RESOURCE_GROUP_NAME</span></code></pre></div><p>You can also use the Azure portal to create one by using <a href="https://portal.azure.com/?WT.mc_id=anthonychuca-blog-antchu#create/Microsoft.SignalRGalleryPackage">this link</a>.</p><h2>Speech-to-text and translation in the browser</h2><p>Cognitive Service's Speech SDK is really easy to use. To get started, we'll pull it into our Vue app:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash">npm install microsoft-cognitiveservices-speech-sdk
</code></pre></div><p>Then we just need to initialize and start it:</p><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// listen to the device's microphone</span><span class="kd">const</span><span class="nx">audioConfig</span><span class="o">=</span><span class="nx">AudioConfig</span><span class="p">.</span><span class="nx">fromDefaultMicrophoneInput</span><span class="p">()</span><span class="c1">// use the key and region created for the Speech Services account</span><span class="kd">const</span><span class="nx">speechConfig</span><span class="o">=</span><span class="nx">SpeechTranslationConfig</span><span class="p">.</span><span class="nx">fromSubscription</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">key</span><span class="p">,</span><span class="nx">options</span><span class="p">.</span><span class="nx">region</span><span class="p">)</span><span class="c1">// configure the language to listen for (e.g., 'en-US')</span><span class="nx">speechConfig</span><span class="p">.</span><span class="nx">speechRecognitionLanguage</span><span class="o">=</span><span class="nx">options</span><span class="p">.</span><span class="nx">fromLanguage</span><span class="c1">// add one or more languages to translate to</span><span class="k">for</span><span class="p">(</span><span class="kd">const</span><span class="nx">lang</span><span class="k">of</span><span class="nx">options</span><span class="p">.</span><span class="nx">toLanguages</span><span class="p">)</span><span class="p">{</span><span class="nx">speechConfig</span><span class="p">.</span><span class="nx">addTargetLanguage</span><span class="p">(</span><span class="nx">lang</span><span class="p">)</span><span class="p">}</span><span class="k">this</span><span class="p">.</span><span class="nx">_recognizer</span><span class="o">=</span><span class="k">new</span><span class="nx">TranslationRecognizer</span><span class="p">(</span><span class="nx">speechConfig</span><span class="p">,</span><span class="nx">audioConfig</span><span class="p">)</span><span class="c1">// assign callback when text is recognized ('recognizing' is a partial result)</span><span class="k">this</span><span class="p">.</span><span class="nx">_recognizer</span><span class="p">.</span><span class="nx">recognizing</span><span class="o">=</span><span class="k">this</span><span class="p">.</span><span class="nx">_recognizer</span><span class="p">.</span><span class="nx">recognized</span><span class="o">=</span><span class="nx">recognizerCallback</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="c1">// start the recognizer</span><span class="k">this</span><span class="p">.</span><span class="nx">_recognizer</span><span class="p">.</span><span class="nx">startContinuousRecognitionAsync</span><span class="p">()</span></code></pre></div><p>And that's it! The <code>recognizerCallback</code> method will be invoked whenever text has been recognized. It is passed an event argument with a <code>translations</code> property that contains all the translations we asked for. For example, we can obtain the French translation with <code>e.translations.get('fr')</code>.</p><h2>Broadcast captions to other clients</h2><p>Now that we can obtain captions and translations thanks to the Cognitive Services Speech SDK, we need to broadcast that information to all viewers who are connected to SignalR Service via WebSocket so that they can display captions in real-time.</p><p>First, we'll create an Azure Function that our UI can call whenever new text is recognized. It's a basic HTTP function that uses an Azure SignalR Service output binding to send messages.</p><p>The output binding is configured in function.json. It takes a SignalR message object returned by the function and sends it to all clients connected to a SignalR Service hub named <code>captions</code>.</p><div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w"></span><span class="s2">"disabled"</span><span class="p">:</span><span class="w"></span><span class="kc">false</span><span class="p">,</span><span class="w"></span><span class="s2">"bindings"</span><span class="p">:</span><span class="w"></span><span class="p">[</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="s2">"authLevel"</span><span class="p">:</span><span class="w"></span><span class="s2">"anonymous"</span><span class="p">,</span><span class="w"></span><span class="s2">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"httpTrigger"</span><span class="p">,</span><span class="w"></span><span class="s2">"direction"</span><span class="p">:</span><span class="w"></span><span class="s2">"in"</span><span class="p">,</span><span class="w"></span><span class="s2">"name"</span><span class="p">:</span><span class="w"></span><span class="s2">"req"</span><span class="p">,</span><span class="w"></span><span class="s2">"methods"</span><span class="p">:</span><span class="w"></span><span class="p">[</span><span class="w"></span><span class="s2">"post"</span><span class="w"></span><span class="p">]</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="s2">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"http"</span><span class="p">,</span><span class="w"></span><span class="s2">"direction"</span><span class="p">:</span><span class="w"></span><span class="s2">"out"</span><span class="p">,</span><span class="w"></span><span class="s2">"name"</span><span class="p">:</span><span class="w"></span><span class="s2">"res"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="s2">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"signalR"</span><span class="p">,</span><span class="w"></span><span class="s2">"name"</span><span class="p">:</span><span class="w"></span><span class="s2">"$return"</span><span class="p">,</span><span class="w"></span><span class="s2">"hubName"</span><span class="p">:</span><span class="w"></span><span class="s2">"captions"</span><span class="p">,</span><span class="w"></span><span class="s2">"direction"</span><span class="p">:</span><span class="w"></span><span class="s2">"out"</span><span class="w"></span><span class="p">}</span><span class="w"></span><span class="p">]</span><span class="w"></span><span class="p">}</span><span class="w"></span></code></pre></div><p>The function simply takes the incoming payload, which includes translations in all available languages, and relays it to clients using SignalR Service. <em>(Sending every language to every client is quite inefficient; we'll improve on this later with SignalR groups.)</em></p><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="o">=</span><span class="k">async</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="nx">req</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">({</span><span class="na">target</span><span class="p">:</span><span class="s1">'newCaption'</span><span class="p">,</span><span class="na">arguments</span><span class="p">:</span><span class="p">[</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">]</span><span class="p">});</span></code></pre></div><p>Back in our Vue app, we bring in the SignalR SDK:</p><div class="highlight"><pre><code class="language-bash" data-lang="bash">npm install @aspnet/signalr
</code></pre></div><blockquote><p>Note that even though this package is under the <em>@aspnet</em> org on npm, it's the JavaScript client for SignalR. It may move to a different org later to make it easier to find.</p></blockquote><p>When an audience member decides to join the captioning session and our Vue component is mounted, we'll start a connection to SignalR Service.</p><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">async</span><span class="nx">mounted</span><span class="p">()</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">connection</span><span class="o">=</span><span class="k">new</span><span class="nx">signalR</span><span class="p">.</span><span class="nx">HubConnectionBuilder</span><span class="p">()</span><span class="p">.</span><span class="nx">withUrl</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">constants</span><span class="p">.</span><span class="nx">apiBaseUrl</span><span class="p">}</span><span class="s2">/api`</span><span class="p">)</span><span class="p">.</span><span class="nx">build</span><span class="p">()</span><span class="k">this</span><span class="p">.</span><span class="nx">connection</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'newCaption'</span><span class="p">,</span><span class="nx">onNewCaption</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">))</span><span class="kr">await</span><span class="k">this</span><span class="p">.</span><span class="nx">connection</span><span class="p">.</span><span class="nx">start</span><span class="p">()</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'connection started'</span><span class="p">)</span><span class="kd">function</span><span class="nx">onNewCaption</span><span class="p">(</span><span class="nx">caption</span><span class="p">)</span><span class="p">{</span><span class="c1">// add the caption for the selected language to the view model</span><span class="c1">// Vue updates the screen</span><span class="p">}</span><span class="p">}</span></code></pre></div><p>Whenever a <code>newCaption</code> event arrives, the <code>onNewCaption</code> callback function is invoked. We pick out the caption that matches the viewer's selected language and add it to the view model. Vue does the rest and updates the screen with the new caption.</p><p>We also add some code to disconnect from SignalR Service when the Vue component is destroyed (e.g, when the user navigates away from the view).</p><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">async</span><span class="nx">beforeDestroy</span><span class="p">()</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">connection</span><span class="p">)</span><span class="p">{</span><span class="kr">await</span><span class="k">this</span><span class="p">.</span><span class="nx">connection</span><span class="p">.</span><span class="nx">stop</span><span class="p">()</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'connection stopped'</span><span class="p">)</span><span class="p">}</span><span class="p">}</span></code></pre></div><p>And that's pretty much the whole app! It captures speech from the microphone, translates it to multiple languages, and broadcasts the translations in real-time to thousands of people.</p><h2>Increase efficiency with SignalR groups</h2><p>There's a flaw in the app we've built so far: each viewer receives captions in every available language but they only need the one they've selected. Sometimes captions are sent multiple times per second, so sending every language to every client uses a lot of unnecessary bandwidth. We can see this by inspecting the WebSocket traffic:</p><p><img src="/post-assets/2019-03-26/websocket-without-groups.png" alt="WebSockets without groups"></p><p>To solve problems like this, SignalR Service has a concept called "groups". Groups allow the application to place users into arbitrary groups. Instead of broadcasting messages to everyone who is connected, we can target messages to a specific group. In our case, we'll treat each instance of the Vue app as a "user", and we will place each of them into a single group based on their selected language.</p><p>Instead of sending a single message containing every language to everyone, we will send smaller, targeted messages that each contains only a single language. Each message is sent to the group of users that have selected to receive captions in that language.</p><h3>Add a unique client ID</h3><p>We can generate a unique ID that represents the Vue instance when the app starts up. The first step to using groups is for the app to authenticate to SignalR Service using that identifier as the user ID. We achieve this by modifying our <em>negotiate</em> Azure Function. The SignalR client calls this function to retrieve an access token that it will use to connect to the service. So far, we've been using anonymous tokens.</p><p>We'll start by changing the route of the negotiate function to include the user ID. We then use the user ID passed in the route as the user ID in the SignalRConnectionInfo input binding. The binding generates a SignalR Service token that is authenticated to that user.</p><div class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w"></span><span class="s2">"disabled"</span><span class="p">:</span><span class="w"></span><span class="kc">false</span><span class="p">,</span><span class="w"></span><span class="s2">"bindings"</span><span class="p">:</span><span class="w"></span><span class="p">[</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="s2">"authLevel"</span><span class="p">:</span><span class="w"></span><span class="s2">"anonymous"</span><span class="p">,</span><span class="w"></span><span class="s2">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"httpTrigger"</span><span class="p">,</span><span class="w"></span><span class="s2">"direction"</span><span class="p">:</span><span class="w"></span><span class="s2">"in"</span><span class="p">,</span><span class="w"></span><span class="s2">"name"</span><span class="p">:</span><span class="w"></span><span class="s2">"req"</span><span class="p">,</span><span class="w"></span><span class="s2">"methods"</span><span class="p">:</span><span class="w"></span><span class="p">[</span><span class="w"></span><span class="s2">"post"</span><span class="w"></span><span class="p">],</span><span class="w"></span><span class="s2">"route"</span><span class="p">:</span><span class="w"></span><span class="s2">"{userId}/negotiate"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="s2">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"http"</span><span class="p">,</span><span class="w"></span><span class="s2">"direction"</span><span class="p">:</span><span class="w"></span><span class="s2">"out"</span><span class="p">,</span><span class="w"></span><span class="s2">"name"</span><span class="p">:</span><span class="w"></span><span class="s2">"res"</span><span class="w"></span><span class="p">},</span><span class="w"></span><span class="p">{</span><span class="w"></span><span class="s2">"type"</span><span class="p">:</span><span class="w"></span><span class="s2">"signalRConnectionInfo"</span><span class="p">,</span><span class="w"></span><span class="s2">"direction"</span><span class="p">:</span><span class="w"></span><span class="s2">"in"</span><span class="p">,</span><span class="w"></span><span class="s2">"userId"</span><span class="p">:</span><span class="w"></span><span class="s2">"{userId}"</span><span class="p">,</span><span class="w"></span><span class="s2">"name"</span><span class="p">:</span><span class="w"></span><span class="s2">"connectionInfo"</span><span class="p">,</span><span class="w"></span><span class="s2">"hubName"</span><span class="p">:</span><span class="w"></span><span class="s2">"captions"</span><span class="w"></span><span class="p">}</span><span class="w"></span><span class="p">]</span><span class="w"></span><span class="p">}</span><span class="w"></span></code></pre></div><p>There are no changes required in the actual function itself.</p><p>Next, we need to change our Vue app to pass the ID in the route (<code>clientId</code> is the unique ID generated by this instance of our app):</p><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">this</span><span class="p">.</span><span class="nx">connection</span><span class="o">=</span><span class="k">new</span><span class="nx">signalR</span><span class="p">.</span><span class="nx">HubConnectionBuilder</span><span class="p">()</span><span class="p">.</span><span class="nx">withUrl</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">constants</span><span class="p">.</span><span class="nx">apiBaseUrl</span><span class="p">}</span><span class="s2">/api/</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">clientId</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span><span class="p">.</span><span class="nx">build</span><span class="p">()</span></code></pre></div><p>The SignalR client will append <code>/negotiate</code> to the end of the URL and call our function with the user ID.</p><h3>Add the client to a group</h3><p>Now that each client connects to SignalR Service with a unique user ID, we'll need a way to add a user ID to the group that represents the client's selected language.</p><p>We can do this by creating an Azure Function named <em>selectLanguage</em> that our app will call to add itself to a group. Like the function that sends messages to SignalR Service, this function also uses the SignalR output binding. Instead of passing SignalR messages to the output binding, we'll pass group action objects that are used to add and remove users to and from groups.</p><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">const</span><span class="nx">constants</span><span class="o">=</span><span class="nx">require</span><span class="p">(</span><span class="s1">'../common/constants'</span><span class="p">);</span><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="o">=</span><span class="k">async</span><span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="nx">req</span><span class="p">)</span><span class="p">{</span><span class="kd">const</span><span class="p">{</span><span class="nx">languageCode</span><span class="p">,</span><span class="nx">userId</span><span class="p">}</span><span class="o">=</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span><span class="kd">const</span><span class="nx">signalRGroupActions</span><span class="o">=</span><span class="nx">constants</span><span class="p">.</span><span class="nx">languageCodes</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">lc</span><span class="o">=&gt;</span><span class="p">({</span><span class="na">userId</span><span class="p">:</span><span class="nx">userId</span><span class="p">,</span><span class="na">groupName</span><span class="p">:</span><span class="nx">lc</span><span class="p">,</span><span class="na">action</span><span class="p">:</span><span class="p">(</span><span class="nx">lc</span><span class="o">===</span><span class="nx">languageCode</span><span class="p">)</span><span class="p">?</span><span class="s1">'add'</span><span class="p">:</span><span class="s1">'remove'</span><span class="p">}));</span><span class="nx">context</span><span class="p">.</span><span class="nx">bindings</span><span class="p">.</span><span class="nx">signalRGroupActions</span><span class="o">=</span><span class="nx">signalRGroupActions</span><span class="p">;</span><span class="p">};</span></code></pre></div><p>The function is invoked with a <code>languageCode</code> and a <code>userId</code> in the body. We'll output a SignalR group action for each language that our application supports — setting an action of <code>add</code> for the language we have chosen to subscribe to, and <code>remove</code> for all the remaining languages. This ensures that any existing subscriptions are deleted.</p><p>Lastly, we need to modify our Vue app to call the <em>selectLanguage</em> function when our component is created. We do this by creating a watch on the language code that will call the function whenever the user updates its value. In addition, we'll set the <code>immediate</code> property of the watch to <code>true</code> so that it will call the function immediately when the watch is initially created.</p><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">methods</span><span class="p">:</span><span class="p">{</span><span class="k">async</span><span class="nx">updateLanguageSubscription</span><span class="p">(</span><span class="nx">languageCode</span><span class="p">)</span><span class="p">{</span><span class="kr">await</span><span class="nx">axios</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">constants</span><span class="p">.</span><span class="nx">apiBaseUrl</span><span class="p">}</span><span class="s2">/api/selectlanguage`</span><span class="p">,</span><span class="p">{</span><span class="nx">languageCode</span><span class="p">,</span><span class="na">userId</span><span class="p">:</span><span class="k">this</span><span class="p">.</span><span class="nx">clientId</span><span class="p">})</span><span class="p">}</span><span class="p">},</span><span class="nx">watch</span><span class="p">:</span><span class="p">{</span><span class="nl">toLanguageCode</span><span class="p">:</span><span class="p">{</span><span class="nx">handler</span><span class="p">()</span><span class="p">{</span><span class="k">return</span><span class="k">this</span><span class="p">.</span><span class="nx">updateLanguageSubscription</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">toLanguageCode</span><span class="p">)</span><span class="p">},</span><span class="nx">immediate</span><span class="p">:</span><span class="kc">true</span><span class="p">}</span><span class="p">},</span></code></pre></div><h3>Send messages to groups</h3><p>The last thing we have to do is modify our Azure Function that broadcasts the captions to split each message into one message per language and send each to its corresponding group. To send a message to a group of clients instead of broadcasting it to all clients, add a <code>groupName</code> property (set to the language code) to the SignalR message:</p><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="o">=</span><span class="k">async</span><span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="nx">req</span><span class="p">)</span><span class="p">{</span><span class="kd">const</span><span class="nx">captions</span><span class="o">=</span><span class="nx">req</span><span class="p">.</span><span class="nx">body</span><span class="p">;</span><span class="kd">const</span><span class="nx">languageCaptions</span><span class="o">=</span><span class="p">[];</span><span class="k">for</span><span class="p">(</span><span class="kd">const</span><span class="nx">language</span><span class="k">in</span><span class="nx">captions</span><span class="p">.</span><span class="nx">languages</span><span class="p">)</span><span class="p">{</span><span class="nx">languageCaptions</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="nx">language</span><span class="p">,</span><span class="na">offset</span><span class="p">:</span><span class="nx">captions</span><span class="p">.</span><span class="nx">offset</span><span class="p">,</span><span class="na">text</span><span class="p">:</span><span class="nx">captions</span><span class="p">.</span><span class="nx">languages</span><span class="p">[</span><span class="nx">language</span><span class="p">]</span><span class="p">});</span><span class="p">}</span><span class="k">return</span><span class="nx">languageCaptions</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">lc</span><span class="o">=&gt;</span><span class="p">({</span><span class="na">target</span><span class="p">:</span><span class="s2">"newCaption"</span><span class="p">,</span><span class="na">groupName</span><span class="p">:</span><span class="nx">lc</span><span class="p">.</span><span class="nx">language</span><span class="p">,</span><span class="na">arguments</span><span class="p">:</span><span class="p">[</span><span class="nx">lc</span><span class="p">]</span><span class="p">}));</span><span class="p">};</span></code></pre></div><p>Now when we run the app, it still works the same as it did before, but if we inspect the SignalR traffic over the WebSocket connection, each caption only contains a single language.</p><p><img src="/post-assets/2019-03-26/websocket-with-groups.png" alt="WebSockets with groups"></p><h2>Next steps</h2><p>Comments? Questions? Find me on <a href="https://twitter.com/nthonyChu">Twitter</a>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>