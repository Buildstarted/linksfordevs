<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>Modern garbage collection</h1>
        <p>
by Mike Hearn <br/>Reading time: 18-23 minutes        </p>
        <p><a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e?gi=fff84a7bf427">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e?gi=fff84a7bf427</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*WgBm6NdWiLpg505QYVb9rg.jpeg?q=20" width="1920" height="1080" role="presentation"></p><p><img width="1920" height="1080" role="presentation" src="https://miro.medium.com/max/1920/1*WgBm6NdWiLpg505QYVb9rg.jpeg"></p></div></div></div></div></figure><p id="d9f5"><h2>A look at the Go GC strategy</h2></p><div><div><div><p><a href="https://blog.plan99.net/@octskyward?source=post_page-----911ef4f8bd8e----------------------" rel="noopener"><img alt="Mike Hearn" src="https://miro.medium.com/fit/c/48/48/0*vCXpXuEWOU7lPZ5C.jpeg" width="48" height="48"></a></p></div></div></div><p id="9302" data-selectable-paragraph=""><em>You can find discussions on </em><a href="https://news.ycombinator.com/item?id=13218550" target="_blank" rel="noopener"><em>Hacker News</em></a><em> and </em><a href="https://www.reddit.com/r/golang/comments/5j7phw/modern_garbage_collection/" target="_blank" rel="noopener"><em>Reddit</em></a></p><p id="59f4" data-selectable-paragraph="">I‚Äôve seen a bunch of articles lately which promote the Go language‚Äôs latest garbage collector in ways that trouble me. Some of these articles come from the Go project itself. They make claims that imply a radical breakthrough in GC technology has occurred.</p><p id="7bc6" data-selectable-paragraph=""><a href="https://blog.golang.org/go15gc" target="_blank" rel="noopener">Here is the initial announcement of a new collector in August 2015</a>:</p><blockquote><p id="3d30" data-selectable-paragraph="">Go is building a garbage collector (GC) <strong>not only for 2015 but for 2025 and beyond </strong>‚Ä¶<strong> Go 1.5‚Äôs GC ushers in a future where stop-the-world pauses are no longer a barrier to moving to a safe and secure language</strong>. It is a future where applications scale effortlessly along with hardware and as hardware becomes more powerful the GC will not be an impediment to better, more scalable software. It‚Äôs a good place to be for the next decade and beyond.</p></blockquote><p id="4c4e" data-selectable-paragraph="">The Go team not only claim to have solved the problem of GC pauses, but also made the entire thing brainless:</p><blockquote><p id="b9cd" data-selectable-paragraph="">At a higher level, one approach to solving performance problems is to add GC knobs, one for each performance issue. The programmer can then turn the knobs in search of appropriate settings for their application. The downside is that after a decade with one or two new knobs each year you end up with the GC Knobs Turner Employment Act. Go is not going down that path. Instead we provide a single knob, called GOGC.</p><p id="1dc8" data-selectable-paragraph="">Furthermore, unencumbered by ongoing support for dozens of knobs, the runtime team can focus on improving the runtime based on feedback from real customer applications.</p></blockquote><p id="319b" data-selectable-paragraph="">I have no doubt that many Go users are very happy with the new runtime. But I have a bone to pick with these claims ‚Äî to me it comes across like a misleading piece of marketing. As these claims are getting repeated across the blogosphere, it‚Äôs time to take a deeper look at them.</p><p id="baa1" data-selectable-paragraph="">The reality is that Go‚Äôs GC does not really implement any new ideas or research. As their announcement admits, it is a straightforward concurrent mark/sweep collector based on ideas from the 1970s. It is notable only because it has been designed to optimise for pause times at the cost of absolutely every other desirable characteristic in a GC. Go‚Äôs <a href="https://talks.golang.org/2015/go-gc.pdf" target="_blank" rel="noopener">tech talks</a> and marketing materials don‚Äôt seem to mention any of these tradeoffs, leaving developers unfamiliar with garbage collection technologies to assume that no such tradeoffs exist, and by implication, that Go‚Äôs competitors are just badly engineered piles of junk. And Go encourages this perception:</p><blockquote><p id="3d86" data-selectable-paragraph="">To create a garbage collector for the next decade, we turned to an algorithm from decades ago. Go‚Äôs new garbage collector is a <em>concurrent</em>, <em>tri-color</em>, <em>mark-sweep</em> collector, an idea first proposed by <a href="http://dl.acm.org/citation.cfm?id=359655" target="_blank" rel="noopener">Dijkstra in 1978</a>. <strong>This is a deliberate divergence from most ‚Äúenterprise‚Äù grade garbage collectors of today</strong>, and one that we believe is well suited to the properties of modern hardware and the latency requirements of modern software</p></blockquote><p id="5911" data-selectable-paragraph="">Reading this announcement, you could be forgiven for thinking that the last 40 years of ‚Äúenterprise‚Äù GC research had achieved nothing at all.</p></div></div></section><section><div><div><p id="93c3" data-selectable-paragraph="">Here are the different factors you will want to think about when designing a garbage collection algorithm:</p><ul><li id="375f" data-selectable-paragraph=""><strong>Program throughput</strong>: how much does your algorithm slow the program down? This is sometimes expressed as a percentage of CPU time spent doing collection vs useful work.</li><li id="6e4b" data-selectable-paragraph=""><strong>GC throughput:</strong> how much garbage can the collector clear given a fixed amount of CPU time?</li><li id="5c64" data-selectable-paragraph=""><strong>Heap overhead:</strong> how much additional memory over the theoretical minimum does your collector require? If your algorithm allocates temporary structures whilst collecting, does that make memory usage of your program very spiky?</li><li id="4959" data-selectable-paragraph=""><strong>Pause times:</strong> how long does your collector stop the world for?</li><li id="924d" data-selectable-paragraph=""><strong>Pause frequency:</strong> how often does your collector stop the world?</li><li id="e88d" data-selectable-paragraph=""><strong>Pause distribution:</strong> do you typically have very short pauses but sometimes have very long pauses? Or do you prefer pauses to be a bit longer but consistent?</li><li id="198c" data-selectable-paragraph=""><strong>Allocation performance:</strong> is allocation of new memory fast, slow, or unpredictable?</li><li id="42b7" data-selectable-paragraph=""><strong>Compaction:</strong> does your collector ever report an out-of-memory (OOM) error even if there‚Äôs sufficient free space to satisfy a request, because that space has become scattered over the heap in small chunks? If it doesn‚Äôt you may find your program slows down and eventually dies, even if it actually had enough memory to continue.</li><li id="0008" data-selectable-paragraph=""><strong>Concurrency:</strong> how well does your collector use multi-core machines?</li><li id="59ae" data-selectable-paragraph=""><strong>Scaling:</strong> how well does your collector work as heaps get larger?</li><li id="5b00" data-selectable-paragraph=""><strong>Tuning:</strong> how complicated is the configuration of your collector, out of the box and to obtain optimal performance?</li><li id="f174" data-selectable-paragraph=""><strong>Warmup time:</strong> does your algorithm self-adjust based on measured behaviour and if so, how long does it take to become optimal?</li><li id="ed28" data-selectable-paragraph=""><strong>Page release:</strong> does your algorithm ever release unused memory back to the OS? If so, when?</li><li id="16d8" data-selectable-paragraph=""><strong>Portability:</strong> does your GC work on CPU architectures that provide weaker memory consistency guarantees than x86?</li><li id="373b" data-selectable-paragraph=""><strong>Compatibility:</strong> what languages and compilers does your collector work with? Can it be run with languages that weren‚Äôt designed for GC, like C++? Does it require compiler modifications? And if so, does changing GC algorithm require recompiling all your program and dependencies?</li></ul><p id="2c45" data-selectable-paragraph="">As you can see, there are a <em>lot</em> of different factors that go into designing a garbage collector and some of them impact the design of the wider ecosystem around your platform. I‚Äôm not even sure I got them all.</p><p id="642c" data-selectable-paragraph="">Because the design space is so complex, garbage collection is a subfield of computer science rich in research papers. New algorithms are proposed and implemented at a steady rate, by both academia and industry. Unfortunately, nobody has yet found a single algorithm that is ideal for all situations.</p><p id="df64" data-selectable-paragraph="">Let‚Äôs make that a bit more concrete.</p><p id="2fe1" data-selectable-paragraph="">The first garbage collection algorithms were designed for uniprocessor machines and programs that had small heaps. CPU and RAM was expensive and users were not very demanding, so visible pauses were OK. Algorithms designed for this world prioritised minimising the CPU and heap overhead of the collector. This meant a GC that did nothing at all until you failed to allocate memory. Then the program would be paused and a full mark/sweep of the heap would be done to mark parts as free as quickly as possible.</p><p id="49d2" data-selectable-paragraph="">These types of collectors are old but still have some advantages ‚Äî they are simple, don‚Äôt slow down your program when not collecting and don‚Äôt add any memory overhead. In the case of conservative collectors like <a href="http://www.hboehm.info/gc/" target="_blank" rel="noopener">the Boehm GC</a> they don‚Äôt even need changes to your compiler or programming language! This can make them appropriate for desktop apps that typically have small heaps, <a href="https://wiki.unrealengine.com/Garbage_Collection_Overview" target="_blank" rel="noopener">including AAA video games</a> where the bulk of RAM is taken by data files which don‚Äôt need to be scanned.</p><p id="e5e9" data-selectable-paragraph="">Stop-the-world (STW) mark/sweep is the GC algorithm most commonly taught in undergrad computer science classes. When doing job interviews I sometimes ask candidates to talk a bit about GC and almost always, they either see GC as a black box and know nothing about it at all, or think it still uses this by now very old technique.</p><p id="67dd" data-selectable-paragraph="">The problem is that simple STW mark/sweep scales very badly. As you add cores and grow your heaps/allocation rates ever larger, this algorithm stops working well. But ‚Äî sometimes you actually do have small heaps and the pause times from even simple approaches are good enough! In that case, maybe you still want to use this approach and keep your overheads low.</p><p id="b295" data-selectable-paragraph="">At the other end of the spectrum, perhaps you are using heaps hundreds of gigabytes in size on a machine with dozens of cores. Perhaps your server is doing trading in financial markets, or running a search engine, and thus low pause times are very important to you. In these cases you are probably willing to use an algorithm that actually slows down your program whilst it runs in order to do collection in the background and with low pause times.</p><p id="01e4" data-selectable-paragraph="">It‚Äôs not a simple spectrum! At the high end you can also have large batch jobs. As they are non-interactive pause times don‚Äôt matter at all, only total runtime. In such situations you are better off with an algorithm that maximises <em>throughput </em>above all else, i.e. the ratio of useful work done to time spent doing collection.</p><p id="b68a" data-selectable-paragraph="">The problem is that there‚Äôs no single algorithm that is perfect in all aspects. Nor can a language runtime know whether your program is a batch job or an interactive latency-sensitive program. That‚Äôs the start of why ‚ÄúGC tuning‚Äù exists ‚Äî it‚Äôs not because runtime engineers are dumb. It reflects fundamental limits in our capabilities in computer science.</p><p id="b49e" data-selectable-paragraph=""><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.122.4295&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">It has been known since 1984</a> that most allocations ‚Äúdie young‚Äù i.e. become garbage very soon after being allocated. This observation is called the generational hypothesis and is one of the strongest empirical observations in the entire PL engineering space. It has been consistently true across very different kinds of programming languages and across decades of change in the software industry: it is true for functional languages, imperative languages, languages that don‚Äôt have value types and languages that do.</p><p id="e48e" data-selectable-paragraph="">Discovering this fact about programs was useful because it meant GC algorithms could be designed to take advantage of it. These new <em>generational collectors</em> had lots of improvements over the old stop-mark-sweep style:</p><ul><li id="c8c1" data-selectable-paragraph=""><strong>GC throughput:</strong> they could collect a lot more garbage a lot faster.</li><li id="ddf5" data-selectable-paragraph=""><strong>Allocation performance:</strong> allocating new memory no longer required searching through the heap looking for a free slot, so allocation became effectively free.</li><li id="1c36" data-selectable-paragraph=""><strong>Program throughput:</strong> allocations became neatly laid out in space next to each other, <a href="http://dl.acm.org/citation.cfm?id=1005693" target="_blank" rel="noopener">which improved cache utilisation significantly</a>. Generational collectors do require the program to do some extra work as it runs, but that hit seems empirically to be outweighed by the improved cache effects.</li><li id="44fe" data-selectable-paragraph=""><strong>Pause times:</strong> most (but not all) pause times became much lower.</li></ul><p id="c52c" data-selectable-paragraph="">They also introduced some downsides:</p><ul><li id="56af" data-selectable-paragraph=""><strong>Compatibility:</strong> implementing a generational collector requires the ability to move things around in memory, and do extra work when the program writes to a pointer in some cases. This means the GC must be tightly integrated with the compiler. There are no generational collectors for C++.</li><li id="ef2a" data-selectable-paragraph=""><strong>Heap overhead:</strong> these collectors work by copying allocations back and forth between various ‚Äòspaces‚Äô. Because there must be space to copy to, these collectors impose some heap overhead. Also, they require various pointer maps to be maintained (the <em>remembered sets</em>), further increasing overhead.</li><li id="c234" data-selectable-paragraph=""><strong>Pause distribution:</strong> whilst many GC pauses were now very fast, some still required doing a full mark/sweep over the entire heap.</li><li id="45fc" data-selectable-paragraph=""><strong>Tuning:</strong> generational collectors introduce the notion of a ‚Äúyoung generation‚Äù or ‚Äúeden space‚Äù, and program performance becomes quite sensitive to the sizing of this space.</li><li id="8870" data-selectable-paragraph=""><strong>Warmup time:</strong> in response to the tuning issue, some collectors dynamically adapt the young generation size by observing how the program runs in practice, but now pause times depend on how long the program is running for as well. In practice this rarely matters outside of benchmarking.</li></ul><p id="639b" data-selectable-paragraph="">Still, the benefits are so huge that basically all modern GC algorithms are generational. If you can afford it ‚Äî and you probably can ‚Äî then you want it. Generational collectors can be enhanced with all sorts of other features, and a typical modern GC will be concurrent, parallel, compacting and generational all together.</p><p id="0992" data-selectable-paragraph="">As Go is a relatively ordinary imperative language with value types, its memory access patterns are probably comparable to C# where the generational hypothesis certainly holds and thus .NET uses a generational collector.</p><p id="6c8c" data-selectable-paragraph="">In fact Go programs are usually request/response processors like HTTP servers, meaning that Go programs exhibit strongly generational behaviour, and the Go team are exploring potentially exploiting that in future with something they call the <a href="https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit" target="_blank" rel="noopener">‚Äúrequest oriented collector‚Äù</a>. It <a href="https://news.ycombinator.com/item?id=11969740" target="_blank" rel="noopener">has been observed that this is essentially a renamed generational GC</a> with a tweaked tenuring policy. Such a GC can be simulated in other runtimes for request/response processors by ensuring the young generation is large enough that all garbage generated by handling a request fits within it.</p><p id="f003" data-selectable-paragraph="">Despite that, Go‚Äôs current GC is <strong>not</strong> generational. It just runs a plain old mark/sweep in the background.</p><p id="a69e" data-selectable-paragraph="">Doing it this way has one advantage ‚Äî you can get very very low pause times ‚Äî but makes almost everything else worse. Like what? Well, from our basic theory above we can see:</p><ul><li id="d0ef" data-selectable-paragraph=""><strong>GC throughput:</strong> The time needed to clear the heap of garbage scales with the size of a heap. Put simply, the more memory your program uses the more slowly memory gets freed up, and the more time your computer spends doing collection vs useful work. The only way this isn‚Äôt true is if your program doesn‚Äôt parallelise at all but you can keep throwing cores at the GC without limit.</li><li id="0a17" data-selectable-paragraph=""><strong>Compaction:</strong> as there‚Äôs no compaction, your program can eventually fragment its heap. I‚Äôll talk about heap fragmentation more below. You also don‚Äôt benefit from having things laid out neatly in the cache.</li><li id="ada5" data-selectable-paragraph=""><strong>Program throughput:</strong> as the GC has to do a lot of work for every cycle, that steals CPU time from the program itself, slowing it down.</li><li id="f261" data-selectable-paragraph=""><strong>Pause distribution:</strong> any garbage collector that runs concurrently with your program can encounter what the Java world calls a ‚Äúconcurrent mode failure‚Äù: your program creates garbage faster than the GC threads can clean it up. In this case the runtime has no choice but to stop your program entirely and wait for the GC cycle to complete. Thus when Go claims GC pauses are very low, this claim can only be true for the case where the GC has sufficient CPU time and headroom to outrun the main program. Additionally <a href="https://github.com/golang/go/issues/10958" target="_blank" rel="noopener">the Go compiler lacks features needed to ensure threads can be reliably paused quickly</a>, meaning that whether pause times are actually low or not depends heavily on what kind of code you‚Äôre running (e.g. base64 decoding a large blob in a single goroutine can cause pause times to go up).</li><li id="c5df" data-selectable-paragraph=""><strong>Heap overhead:</strong> because collecting the heap via mark/sweep is very slow, you need <em>lots</em> of spare space to ensure you don‚Äôt suffer a ‚Äúconcurrent mode failure‚Äù. Go defaults to a heap overhead of 100% ‚Ä¶ it doubles the amount of memory your program needs.</li></ul><p id="3516" data-selectable-paragraph="">We can see these tradeoffs at work in <a href="https://groups.google.com/d/msg/golang-dev/Ab1sFeoZg_8/pv0Yg7tkAwAJ" target="_blank" rel="noopener">posts to golang-dev like this one</a>:</p><blockquote><p id="67f8" data-selectable-paragraph="">The Service 1 allocates more than the Service 2, so STW pauses are higher there. But STW pause duration dropped by an order of magnitude on both services. We see ~20% increase in CPU usage spent in GC after the switch on both services.</p></blockquote><p id="6e63" data-selectable-paragraph="">So in this specific case Go bought an order of magnitude drop in pause times, but at a cost of an even slower collector. Was that a good tradeoff or were pause times low enough already? The poster does not say.</p><p id="5b3d" data-selectable-paragraph="">There comes a point though, where paying for more hardware to get lower pause times no longer makes sense. If your server pause times go from 10msec to 1msec, will your users really notice that? What if you had to double your machine count to get it?</p><p id="0255" data-selectable-paragraph="">Go optimises for pause times as the expense of throughput to such an extent that it seems willing to slow down your program by almost any amount in order to get even just slightly faster pauses.</p><p id="65a1" data-selectable-paragraph="">The HotSpot JVM has several GC algorithms you can choose on the command line. None aim for pause times as low as Go‚Äôs because they balance them against other factors. It‚Äôs worth comparing them to get a feel for the tradeoffs. It‚Äôs possible to switch between GC‚Äôs just by restarting the program because compilation is done whilst the program runs, so the different barriers the different algorithms need can be compiled and optimised into the code as needed.</p><p id="5bb8" data-selectable-paragraph="">The default algorithm on any modern computer is the <em>throughput collector</em>. This is designed for batch jobs and by default does not have any pause time goal (one can be given on the command line). This choice of defaults is one reason people tend to think Java GC must kind of suck: out of the box, Java tries to make your app run as fast as possible, with as little memory overhead as possible, and pause times be damned.</p><p id="2b79" data-selectable-paragraph="">If pause times matter to you more then you might switch to the <em>concurrent mark/sweep collector</em> (CMS). This is the closest comparable algorithm to the one Go uses. But it‚Äôs also generational, and that‚Äôs why it has pause times longer than Go‚Äôs: the young generation is compacted whilst the app is paused because it involves moving objects around. There are two types of pauses in CMS. The first, faster kind, might last around 2‚Äì5 milliseconds. The second might be more like 20 milliseconds. CMS is adaptive: because it‚Äôs concurrent it has to guess when to start running (just like Go). Whereas Go asks you to configure the heap overhead to tune that, CMS will adapt itself at runtime to try and avoid concurrent mode failures. Because the bulk of the heap is ordinary mark/sweep, it‚Äôs possible to hit problems and slowdowns because of heap fragmentation.</p><p id="f0b9" data-selectable-paragraph="">The latest generation Java GC is called ‚ÄúG1‚Äù for ‚Äúgarbage first‚Äù. It‚Äôs not on by default in Java 8, but will be in Java 9. It is intended to be a general purpose one-size-fits-all algorithm, or as close as you can get right now. It is mostly concurrent, generational and compacting for the entire heap. It is also largely self tuning, but because (like all GC algorithms) it can‚Äôt know what you really want, it allows you to specify your preferred tradeoffs: just tell it the maximum amount of RAM you will let it use and a pause time goal in milliseconds, and it‚Äôll adjust everything else as the app runs to try and meet the pause time goal. The default pause time goal is around 100msec, so you shouldn‚Äôt expect to see better than that unless you specify a different goal: G1 will prefer to make your app run faster than pause less than that. Pauses aren‚Äôt entirely consistent ‚Äî most are extremely fast (less than a millisecond), and some will be slower (more like 50 milliseconds) when the heap is being compacted. G1 scales very well. There are reports of people using it with terabyte sized heaps. It also has some neat features, like deduplicating the strings in the heap.</p><p id="2419" data-selectable-paragraph="">Finally, a new GC algorithm has been developed called Shenandoah. It is being contributed to OpenJDK but won‚Äôt be in Java 9 unless you use special Java builds from Red Hat (who sponsor the project). This is designed to give very low pause times regardless of heap size whilst still being compacting. The cost is extra heap overhead and more barriers: to move objects around whilst the app is still running requires both pointer reads and writes to interact with the GC. In this sense it is similar to Azul‚Äôs ‚Äúpauseless‚Äù collector.</p><p id="5b5b" data-selectable-paragraph="">The point of this article is not to convince you to use a different programming language or tool. <mark>But if you take one thing away, let it be this: garbage collection is a hard problem, </mark><mark><em>really</em></mark><mark> hard, one that has been studied by an army of computer scientists for decades. So be very suspicious of supposed breakthroughs that everyone else missed. They are more likely to just be strange or unusual tradeoffs in disguise, avoided by others for reasons that may only become apparent later.</mark></p><p id="0d05" data-selectable-paragraph="">But if you do wish to minimize pause times at the expense of everything else, then by all means, check out the Go GC.</p></div></div></section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>