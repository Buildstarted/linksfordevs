<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The polygons of Another World -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>The polygons of Another World</h1>
    <body><br><center> <div>
<a href="/"><b>FABIEN SANGLARD&apos;S WEBSITE</b><br>
</a></div>
</center>
January 1, 2020
<p><b>The polygons of Another World</b></p> <p> <picture>
<source srcset="http://fabiensanglard.net/another_world_polygons/Another_World_no20.webp" type="image/webp"> <img src="Another_World_no20.png" width="41%"> </picture> There is a playful way to study the architecture of computers of the past. Find a piece of software you know well and try to find out how it was ported to these machine you don&apos;t. A good choice would be DOOM. id Software&apos;s 1994 mega-hit has been ported to everything. It is designed around a core with no layering violations. It is usually easy to find and read the implementation of its six I/O sub-systems.
<p>
An other choice would be Eric Chahi&apos;s 1991 critically acclaimed<a href="#footnote_1"><sup>[1]</sup></a>&quot; title &quot;Another World&quot;, better known in North America as &quot;Out Of This World&quot; which also happens to be ubiquitous. I would argue it is in fact more interesting to study than DOOM because of its polygon based graphics which are suitable to wild optimizations. In some cases, clever tricks allowed Another World to run on hardware built up to five years prior to the game release.</p> This series is a journey thought the video-games hardware of the early 90s. From the Amiga 500, Atari ST, IBM PC, Super Nintendo, up to the Sega Genesis. For each machine, I attempted to discover how Another World was implemented. I found an environment made rich by its diversity where the now ubiquitous CPU/GPU did not exist yet. In the process, I discovered the untold stories of seemingly impossible problems heroically solved by lone programmers. In the best case I was able to get in touch with the original developer. In the worse cases, I found myself staring at disassembly. It was a fun trip. Here are my notes.<p> <picture> <source srcset="http://fabiensanglard.net/another_world_polygons/banner.webp" type="image/webp"> <img src="banner.png" width="100%"> </picture></p></p> <p><b>Another World 101</b></p>
<p> There is very little code in Another World. The original Amiga version was reportedly 6,000 lines of assembly<a href="#footnote_2"><sup>[2]</sup></a>. The PC DOS executable is only 20 KiB. Surprising for such a vast game which shipped on a single 1.44 MiB floppy. That is because most of the business logic is implemented via bytecode. The Another World executable is in fact a virtual machine host which reads and execute uint8_t opcodes.<p> <img src="aw_chart.svg"> </p><p> Another World VM defines 256 variables, 64 threads, 29 opcodes, and three framebuffers<a href="#footnote_3"><sup>[3]</sup></a>. That&apos;s it. If you build a VM host capable of handling these, you can run the game. If you are able to make the VM fast enough to run at 20 frames per seconds, you can actually play the game. </p> The virtual machine&apos;s graphic system uses a coordinate system of 320x200 with 16 palette-based colors. The color limitation may be surprising given that the development platform, the Amiga 500, supported up to 32 colors. This choice was a sweet spot allowing the graphics to be compatible with the other big platform of the era, the Atari ST which supports only 16 colors. The limitation turned out to be a blessing in disguise. It resulted in an unique style which has aged well.<p> <img src="arrival.gif" width="100%"> </p> <img src="lester.gif" width="100%"> <img src="office.gif" width="100%"> Even when it would have been possible to use a specific palette for certain scene, Eric Chahi elected not to do so. During the close encounter with &quot;The Beast&quot;, only three colors are used for the creature with black for the body, red for the eyes, and beige for the teeth. Imagination did the rest.<br> <img src="beast.gif" width="100%"> The palette system turned out to be a strength to illustrate the accident at the origin of Another World. A non-expensive palette swap is enough to evoke a lightning strike.<br> <img src="before.gif" width="100%"> <br> <img src="after.gif" width="100%"> The engine is also capable of translucency effects if the scene features only eight colors. Here the colors are stored within [0x0,0x8].
<p> <picture> <img src="transparency.gif" width="100%"> The Ferrari light beams are translucent. They are drawn with a special color 0x10 which does not exist since only 16 colors are available. The special value is interpreted as &quot;read framebuffer index, add 0x8 and write back&quot;. The last part of the trick is to cleverly chose the 8 next colors in the palette.
Translucency was not used very much in the game but it can be seen one more time during the experiment turning wrong cinematic when the lightning is about to teleport Lester to AnotheR WorlD.<br> <img src="transparency2.gif" width="100%"> </picture></p></p> <p><b>The Three framebuffers</b></p>
<p> Of the three framebuffers, two are used for double buffering while the last one is used to save background (BKGD) composition. This is an optimization to avoid redrawing all the static background polygons in favor of a simple copy operation. In the next video, see how a new scene is drawn first in the BKGD buffer. Each new frame, the BKGD is fully copied to the double buffer not being scanned by the display. There, moving elements such as Lester are drawn. Notice how once the car is &quot;parked&quot; it is also drawn in the BKGD buffer to minimize the number of polygons to render in subsequent frames.
<video width="100%"> <source src="/fd_proxy/anotherWorld_code_review/car-desktop.m4v" type="video/mp4"> Your browser does not support the video tag.
</video>
</p><p> Also notice how composition uses a plain painter algorithm which is simple but result in significant overdraw. This is not a problem since it is largely amortized by the BKGD copy.
</p> <p><b>Virtual Machine Opcodes</b></p>
<p> The next array illustrates the 29 opcodes. We can find here thread (THRD) management, framebuffer (FB) management, and all the register management operations. Most opcodes are &quot;easy&quot; to implement except for &quot;COPY FB&quot;, FILL, and &quot;DRAW_POLY*&quot; which are difficult for performances reasons. <table width="100%"> <tr> <td class="opcode">&#xA0;</td> <td class="opcode">0x00</td> <td class="opcode">0x01</td> <td class="opcode">0x02</td> <td class="opcode">0x03</td> <td class="opcode">0x04</td> <td class="opcode">0x05</td> <td class="opcode">0x06</td> <td class="opcode">0x07</td> <td class="opcode">0x08</td> <td class="opcode">0x09</td> <td class="opcode">0x0A</td> <td class="opcode">0x0B</td> <td class="opcode">0x0C</td> <td class="opcode">0x0D</td> <td class="opcode">0x0E</td> <td class="opcode">0x0F</td> </tr> <tr> <td class="opcode">0x00</td> <td class="opcode">CMOV</td> <td class="opcode">MOV</td> <td class="opcode">ADD</td> <td class="opcode">CADD</td> <td class="opcode">CALL</td> <td class="opcode">RET</td> <td class="opcode">PAUSE<br>THRD</td> <td class="opcode">COND<br>JMP</td> <td class="opcode">SET<br>VECT</td> <td class="opcode">JNZ</td> <td class="opcode">CJMP</td> <td class="opcode">SET<br>PAL</td> <td class="opcode">RESET<br>THRD</td> <td class="opcode">SLCT<br>FB</td> <td class="opcode">FILL<br>FB</td> <td class="opcode">COPY<br>FB</td> </tr> <tr> <td class="opcode">0x10</td> <td class="opcode">BLIT<br>FB</td> <td class="opcode">KILL<br>THRD</td> <td class="opcode">DRAW<br>TEXT</td> <td class="opcode">SUB</td> <td class="opcode">AND</td> <td class="opcode">OR</td> <td class="opcode">SHL</td> <td class="opcode">SHR</td> <td class="opcode">PLAY<br>SOUND</td> <td class="opcode">LOAD<br>RESC</td> <td class="opcode">PLAY<br>MUSIC</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> </tr> <tr> <td class="opcode">0x20</td> <td class="opcode"></td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> </tr> <tr> <td class="opcode">0x30</td> <td class="opcode"></td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> <td class="opcode">&#xA0;</td> </tr> <tr> <td class="opcode">0x40</td> <td class="opcode">DRAW_POLY_SPRITE</td> </tr> <tr> <td class="opcode">0x50</td> </tr> <tr> <td class="opcode">0x60</td> </tr> <tr> <td class="opcode">0x70</td> </tr> <tr> <td class="opcode">0x80</td> <td class="opcode">DRAW_POLY_BACKGROUND</td> </tr> <tr> <td class="opcode">0x90</td> </tr> <tr> <td class="opcode">0xA0</td> </tr> <tr> <td class="opcode">0xB0</td> </tr> <tr> <td class="opcode">0xC0</td> </tr> <tr> <td class="opcode">0xD0</td> </tr> <tr> <td class="opcode">0xE0</td> </tr> <tr> <td class="opcode">0xF0</td> </tr> </table> Both DRAW_POLY_* opcodes span over more than one entry. In the case of DRAW_POLY_BACKGROUND, it takes half the opcode-space from 0x80 to 0xFF. It looks wasteful but it is a space saving trick. Using all opcodes starting with bit &quot;1&quot; allow the 7 other bits to piggy-bag in opcode space as drawing parameters. Since this opcode is used for backgrounds and cinematics, space saving is very significant. <p> The SPRITE version uses all opcodes starting with bits &quot;01&quot; while the other remaining 6 bits are here to encode x, y and zoom in order to draw &quot;sprites&quot; such as lester, friend, and enemies. </p></p> <p><b>Next</b></p>
<p> As mentioned in the previous section, 26 out of the 29 opcodes are easy to implement. The real challenge in porting this game was in manipulating pixels within the machine BUS and CPU bandwidth limitations. What will be done in this series is study how each port manipulated the framebuffers and how they solved the DRAW, FILL and COPY problems. <p> Ready? Let&apos;s dive into Another World on <a href="../another_world_polygons_amiga500/index.html">Amiga 500</a>.
</p></p> <p><b>References</b></p><p id="paperbox"><a></a><a href="#back_1">^</a> [1] Source : <a href="https://fr.wikipedia.org/wiki/Tilt_d%27or#1991">Tilt d&apos;or award year 1991</a><br><a></a><a href="#back_2">^</a> [2] Source : <a href="https://www.youtube.com/watch?v=tiq0OL8rzso">Burgertime 8/9/2015: Out of This World</a><br><a></a><a href="#back_3">^</a> [3] Source : <a href="http://fabiensanglard.net/anotherWorld_code_review/index.php">Another World Source Code Review</a><br> <center>*</center></p></body>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>