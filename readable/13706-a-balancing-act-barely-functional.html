<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A balancing act - barely-functional -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>A balancing act - barely-functional</h1><div><div class="ac ae af ag ah dp aj ak"><figure class="gi gj gk gl gm gn db dc paragraph-image"><p id="97e5" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">It would be so nice to have a set of exact rules on how to design software. With Functional Programming we can get the impression that everything can be normalized, formalized, algebraized to the point where only one implementation remains. I don’t think this is the case though and our mental model should be the one of security experts. What is our “threat model”? What are the things that we are really trying to prevent? And what does it cost us? (that looks like a <a class="fc cf hp hq hr hs" target="_blank" rel="noopener" href="/@AndreRodriguezKatzinger/security-vs-freedom-5536c37b716e">“Freedom vs Security”</a> debate)</p><p id="7088" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">I want to illustrate this dilemma with three ongoing discussions that I am having with my colleagues at work:</p><ol class=""><li id="2081" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho ht hu hv">Part 1: what should be the interfaces between our components (we are using Haskell)?</li><li id="df8e" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho ht hu hv">Part 2: should we throw exceptions?</li><li id="66d5" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho ht hu hv">Part 3: should we use Template Haskell to remove boilerplate?</li></ol><h1 id="cf58" class="ib ic ds ba az id du ie dw if ig ih ii ij ik il im"><strong class="bm">Part 1: Interfaces</strong></h1><p id="94e3" class="hb hc ds ba hd b he in hg io hi ip hk iq hm ir ho dk">We are currently implementing an application in Haskell using “records-of-functions” (this is known as the “<a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html" class="fc cf hp hq hr hs" target="_blank" rel="noopener nofollow">Handle pattern</a>”). I have a strong preference for using this way of structuring Haskell applications because:</p><ul class=""><li id="5081" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho is hu hv">The “MTL” approach using monad transformers does not give us easy ways to fully model a graph of components and to swap full parts of that graph</li><li id="d9a9" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv"><a class="fc cf hp hq hr hs" target="_blank" rel="noopener" href="/barely-functional/freer-doesnt-come-for-free-c9fade793501">I don’t recommend effect libraries anymore</a></li><li id="fbb8" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">I think that the <code class="gv it iu iv iw b"><a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern" class="fc cf hp hq hr hs" target="_blank" rel="noopener nofollow">ReaderT</a></code> design pattern is also too limited because it only allows us to switch leaves in our “application graph”</li><li id="9a11" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">We have <a href="https://github.com/etorreborre/registry" class="fc cf hp hq hr hs" target="_blank" rel="noopener nofollow">an easy way to assemble/re-assemble “records-of-functions”</a> at our disposal</li><li id="2370" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">“records-of-functions” <strong class="hd ix">are very easy to understand</strong> and provide a natural interface/implementation separation which is really what we are after when building applications</li></ul><p id="3752" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">I want to stress that last point. I am not against sophisticated techniques: type systems, specification languages, verification tools. But when they get in the way of understanding our system they are not helping us. And if a fancy effect library gets in the way of refactoring the system so that we have less moving parts, it is <strong class="hd ix"><em class="iy">not</em></strong> working for us. It is also all the more important in my current company where some non-Haskell experts need to be able to read the code and modify some parts of it to implement larger features.</p><p id="7c62" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">That still leaves some open questions:</p><ol class=""><li id="1fc7" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho ht hu hv">what kind of monad should we use as return types for those functions?</li><li id="ad48" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho ht hu hv">passing down the dependencies (“handles”) in the implementation is tedious and possibly error prone (you could accidentally pass a no-op implementation for example)</li></ol><p id="69f2" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">I will deal with the second point in part 3 of that post, let’s focus on point n.1 for now.</p><p id="2eda" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">My proposal for “records-of-functions” is to use <code class="gv it iu iv iw b">IO</code> as the return type. This might be a shocking proposal for some functional programmers. Why do I want this? For two reasons:</p><ul class=""><li id="8e72" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho is hu hv">simplicity of integration: a component having an <code class="gv it iu iv iw b">IO</code> interface can always interact with another component having an <code class="gv it iu iv iw b">IO</code> interface. No type juggling required here, easy refactorings</li><li id="6192" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">maximum encapsulation: a component using <code class="gv it iu iv iw b">IO</code> is basically telling you nothing about its implementation. This means that it is free to do things differently, like running some code concurrently or access a database instead of storing values in-memory and your code won’t be impacted</li></ul><p id="0c67" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">I’m really favouring composition and modularity here. But this doesn’t come for free. Interfacing with <code class="gv it iu iv iw b">IO</code> means that indeed <strong class="hd ix">anything</strong> can happen when using such a component, launching all the nukes you can think of: exceptions, reading the file system, maintaining global state. This is why this is a balancing act. We can’t win them all.</p><p id="7349" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">Let’s investigate some consequences of that choice. Actually I propose to return <code class="gv it iu iv iw b">IO</code> only when constructing a specific component, not when using it. For example here is a logging component</p><figure class="gi gj gk gl gm gn"><p id="5bfb" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">The data types just know about a type <code class="gv it iu iv iw b">m</code> but their constructors are more specific and require <code class="gv it iu iv iw b">IO</code>. Also note that in the implementation of <code class="gv it iu iv iw b">Authenticator</code> we only need to know about <code class="gv it iu iv iw b">Logger</code> using a <code class="gv it iu iv iw b">Monad</code>. No need for <code class="gv it iu iv iw b">IO</code> there.</p><p id="a463" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">You might wonder why not <code class="gv it iu iv iw b">MonadIO m</code> for the <code class="gv it iu iv iw b">Logger</code> constructor?</p><figure class="gi gj gk gl gm gn"><p id="4a3a" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">My question back to you is “Why would you need it?”. Having <code class="gv it iu iv iw b">MonadIO</code> is only useful if we need to layer, later on, additional capabilities on top of that <code class="gv it iu iv iw b">IO</code> monad. But what could we really need? A few possibilities off the top of my head:</p><ol class=""><li id="9bd1" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho ht hu hv"><code class="gv it iu iv iw b">ExceptT</code> to add error management: jump to part 2 of this post where we deal with errors and exceptions</li><li id="1ea9" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho ht hu hv"><code class="gv it iu iv iw b">ReaderT</code> to add a way to inject “<a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern" class="fc cf hp hq hr hs" target="_blank" rel="noopener nofollow">capabilities</a>”: we already have <a href="http://github.com/etorreborre/registry" class="fc cf hp hq hr hs" target="_blank" rel="noopener nofollow">a way to inject capabilities</a></li><li id="9d63" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho ht hu hv"><code class="gv it iu iv iw b">ReaderT</code> to get some context about the context of the caller, for example access a <code class="gv it iu iv iw b">RequestId</code>. More on that in a minute</li><li id="2433" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho ht hu hv"><code class="gv it iu iv iw b">StateT</code> for testing. This way we can have “pure” components for testing where the component state is managed through a state monad</li></ol><h2 id="2f6c" class="ja ic ds ba az id jb jc jd je jf jg jh ji jj jk jl">Pure testing</h2><p id="1617" class="hb hc ds ba hd b he in hg io hi ip hk iq hm ir ho dk">Let’s talk about “pure testing” for a moment. You will find many articles telling you that parametrizing your code with a monad <code class="gv it iu iv iw b">m</code> gives you the ability to replace that <code class="gv it iu iv iw b">m</code> with either <code class="gv it iu iv iw b">Identity</code> or <code class="gv it iu iv iw b">State</code> when testing in order to avoid using <code class="gv it iu iv iw b">IO</code>. I don’t find this to be a compelling argument because</p><ul class=""><li id="e983" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho is hu hv">using mutation for testing is not necessarily harmful especially if those components already represent some effectful behaviour like <code class="gv it iu iv iw b">Database</code>, <code class="gv it iu iv iw b">Logging</code>, <code class="gv it iu iv iw b">S3Client</code>, ...</li><li id="a9fc" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">using <code class="gv it iu iv iw b">State</code> or <code class="gv it iu iv iw b">StateT</code> puts the burden on the client of the component to deal with state. It has to provide a valid initial state and eventually call <code class="gv it iu iv iw b">runState</code>. And if you have several components offering a <code class="gv it iu iv iw b">State</code> interface you have to find a way to run all those states together, providing a valid initial state for each of them even if some of those components are not particularly meaningful for the current test</li></ul><p id="d51b" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">On the contrary a mock offering an <code class="gv it iu iv iw b">IO</code> interface is can be used independently from anything else. For example you can implement a <code class="gv it iu iv iw b">Logger</code> component which will collect all the log messages in an <code class="gv it iu iv iw b">IORef</code> variable to do later checks.</p><figure class="gi gj gk gl gm gn"><p id="68e3" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">This example does not seem to have less boilerplate than a similar example using <code class="gv it iu iv iw b">State</code> however it can easily be extended if <code class="gv it iu iv iw b">Authenticator</code> needs new dependencies like <code class="gv it iu iv iw b">Time IO</code> in order to check that a user can only access a service from 9 to 5 independently from checking the logs. In the test above, if the time behaviour has no influence on the logging, we can just modify:</p><p id="2aba" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk"><code class="gv it iu iv iw b">let authenticator = newAuthenticator logger newFixedTime</code></p><p id="5f22" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">We don’t have to create a special state construct unifying the state for the <code class="gv it iu iv iw b">Logger</code> and the state for <code class="gv it iu iv iw b">Time</code>.</p><p id="45a6" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">Bottom line: <em class="iy">we only need </em><code class="gv it iu iv iw b"><em class="iy">IO</em></code><em class="iy"> as the interface of our components.</em></p><p id="f740" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">Well… almost, there is still the question of <code class="gv it iu iv iw b">RequestIds</code>.</p><h2 id="d8f7" class="ja ic ds ba az id jb jc jd je jf jg jh ji jj jk jl">Accessing a context</h2><p id="aa46" class="hb hc ds ba hd b he in hg io hi ip hk iq hm ir ho dk">When implementing services we need, almost all the time, to track the origin of a given request. For auditing reasons, to trace calls times and diagnose performance issues, for debugging issues. This is an important requirement but also a minor one. What your service does in the first place is a lot more important!</p><p id="f042" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">Unfortunately this is one of those requirements that is very invasive. Tracing request ids means that <em class="iy">almost all of your code</em> needs to be “request-id aware”. And there aren’t too many ways to do this:</p><ul class=""><li id="eb3a" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho is hu hv">you explicitly require almost every function to use a <code class="gv it iu iv iw b">requestId</code> parameter</li><li id="49dd" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">you use <code class="gv it iu iv iw b">ReaderT RequestId IO</code> as a return type</li></ul><p id="64cd" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">Here is the dilemma. <em class="iy">Almost all</em> the functions need a <code class="gv it iu iv iw b">RequestId</code> but not <em class="iy">all</em> of them. This means that if we want to be precise in our software we need to have some component constructors with a <code class="gv it iu iv iw b">ReaderT RequestId IO</code> interface, and if we are even more specific, have only <em class="iy">some functions</em> of the interface return <code class="gv it iu iv iw b">ReaderT RequestId IO</code> while the other ones return <code class="gv it iu iv iw b">IO</code>.</p><p id="4244" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">This now makes the components harder to interoperate because you have to “lift” <code class="gv it iu iv iw b">IO</code>operations into <code class="gv it iu iv iw b">ReaderT RequestId IO</code> and this also has a “viral” effect meaning that <em class="iy">almost all</em> your functions will need to operate in that monad anyway.</p><p id="c95a" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">What is the alternative? You can define a type alias <code class="gv it iu iv iw b">type AppIO = ReaderT RequestId IO</code> and use it everywhere. That’s simple, we get back an easy way to integrate components. What is the downside? There are few places where no <code class="gv it iu iv iw b">RequestId</code> is available and you will have to provide a fake to make that code run. This seems harmless but that also means that your run the risk of forgetting to provide the proper <code class="gv it iu iv iw b">requestId</code> in places where it is available and must be propagated!</p><p id="5fc3" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">My choice here is again to go for simplicity:</p><ul class=""><li id="07f2" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho is hu hv">use <code class="gv it iu iv iw b">AppIO</code> everywhere, for easy integration</li><li id="5424" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">carefully test the application to make sure that entry and exit points really get the proper <code class="gv it iu iv iw b">requestIds</code></li></ul><p id="f105" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">I am trading <strong class="hd ix">compiler-supported correctness of a minor feature of the service against massive convenience for all the rest of the application</strong>. I think this is worth it.</p><h1 id="9f13" class="ib ic ds ba az id du ie dw if ig ih ii ij ik il im">Part 2: exceptions and error management</h1><p id="675c" class="hb hc ds ba hd b he in hg io hi ip hk iq hm ir ho dk">I have been sitting on a blog post on exceptions and error management for a long time now. I seem to be completely unable to deal with that subject in a concise and structured way, and that reflects the state of my mind about it!</p><p id="f254" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">That’s because this is a balancing act as well. Say we settle on using <code class="gv it iu iv iw b">ReaderT Request IO</code> for all of our components. How do we represent errors? Should some components return <code class="gv it iu iv iw b">EitherT DatabaseError (ReaderT RequestId IO)</code> as well? Should the<code class="gv it iu iv iw b">Database</code> component functions throw an exception when they can not connect to the database? Should we abstract the constructor of <code class="gv it iu iv iw b">Database</code> to <code class="gv it iu iv iw b">MonadError DatabaseError</code>?</p><p id="0088" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">Here is my proposal:</p><ol class=""><li id="5336" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho ht hu hv">use concrete error types in the interface of components when the <em class="iy">domain</em> is involved</li><li id="dff9" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho ht hu hv">throw exceptions when there are “operational issues”</li><li id="1bdd" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho ht hu hv">classify “operational issues” based on what the client can do, not what the implementation did</li><li id="21e9" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho ht hu hv">document and test those exceptions</li></ol><h2 id="430f" class="ja ic ds ba az id jb jc jd je jf jg jh ji jj jk jl">Domain errors</h2><p id="eab7" class="hb hc ds ba hd b he in hg io hi ip hk iq hm ir ho dk">Those are errors related to what a given component is supposed to provide in terms of added value:</p><ul class=""><li id="bfd8" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho is hu hv">access a record in the database: was it found?</li><li id="3410" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">parse some text: are there some errors?</li><li id="3807" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">download a file: is the checksum ok?</li></ul><h2 id="d0b6" class="ja ic ds ba az id jb jc jd je jf jg jh ji jj jk jl">Operational issues</h2><p id="0847" class="hb hc ds ba hd b he in hg io hi ip hk iq hm ir ho dk">Those errors cover the cases where the service cannot be delivered:</p><ul class=""><li id="e2a9" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho is hu hv">a dependency does not respond: because it’s too slow, disconnected, overloaded</li><li id="7c9b" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">there is a developer bug: <code class="gv it iu iv iw b">maximum</code> has been called on an empty list</li><li id="2516" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">one invariant is broken: there should be some reference data in the database but it is missing</li></ul><p id="0518" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">There is generally not much we can do about those errors, some of them might be transient or can benefit from some form of “state reset” and can be retried. The others can just be logged. I argue that representing those “operational errors” in the API is not particularly helpful:</p><ul class=""><li id="fa97" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho is hu hv">they are likely to “bubble-up” to the top of the application without any intermediate component being able to do anything anyway</li><li id="dbbd" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">we need a top-level strategy to handle exceptions anyway whether they are declared or not</li><li id="a2eb" class="hb hc ds ba hd b he hw hg hx hi hy hk hz hm ia ho is hu hv">if they are describing in types why they are failing: <code class="gv it iu iv iw b">BrokenDatabaseConnection</code>, <code class="gv it iu iv iw b">IncorrectConfiguration</code>, ... then they are exposing implementation details to user components which will have to be recompiled or modified if that implementation changes</li></ul><p id="7a7b" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">This is why the best thing we can do is roughly to classify those errors into: can be retried / cannot be retried and just carefully log any additional information for further investigation.</p><p id="3b14" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">But this is a balancing act because we lose some knowledge. Now it is harder to know when reading the interface of a component “what can go wrong”. This is why we need to counteract by providing extensive documentation and testing. That’s the price to pay for the convenience of not having to model too much our exceptions.</p><h1 id="7d38" class="ib ic ds ba az id du ie dw if ig ih ii ij ik il im">Part 3: Template Haskell</h1><p id="58b8" class="hb hc ds ba hd b he in hg io hi ip hk iq hm ir ho dk">This is a minor point compared to the other 2 but still significant. The “Handler pattern” is nice because it proposes a very simple way to build and assemble Haskell applications. Unfortunately you have to manually pass down dependencies in the components implementations (cf the use of <code class="gv it iu iv iw b">Logger</code> in <code class="gv it iu iv iw b">Authenticator</code>). This is a bit tedious and possibly error-prone. Can we do better?</p><p id="3f30" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">Yes we can, we can declare a typeclass that offers the same interface as a component and provide a default instance for that typeclass using the component (using a <code class="gv it iu iv iw b">Reader</code>). This is described <a href="https://github.com/etorreborre/registry/blob/master/doc/boilerplate.md" class="fc cf hp hq hr hs" target="_blank" rel="noopener nofollow">here</a>. This can also be automated by a bit of Template Haskell because that code is very mechanical and a machine can totally update the typeclass and the instance when a component is evolving.</p><p id="9cab" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">But this comes with a downside. Now you have some “magic” code. You have some Template Haskell which doesn’t tell you anything about what it is generating. You have to read the documentation, you have to enable <code class="gv it iu iv iw b">-ddump-splices</code> to see the generated code. This is not very newbie-friendly.</p><p id="97eb" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">I don’t have a strong preference here, I’m just happy to whatever consensus we can have on the team. I don’t mind passing components manually and I wouldn’t mind using a typeclass. Another option would be to use the Template Haskell once to generate the code, paste it and then modify it manually as a component evolves.</p><p id="f7af" class="hb hc ds ba hd b he hf hg hh hi hj hk hl hm hn ho dk">Damn, we can not have it all,… in the current state of the art. We can also imagine an enhanced compiler, or enhanced tools giving us ways to expand or regenerate Template Haskell code. This is interesting. This means that there are some situations where our constraints are in complete opposition with each other: we cannot both encapsulate <em class="iy">and</em> expose the implementation of a component. We have to make choices. But there maybe some cases where we can eat our cake and have it too!</p></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>