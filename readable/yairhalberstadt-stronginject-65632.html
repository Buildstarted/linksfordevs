<!DOCTYPE html>
<html lang="en">
<head>
    <title>
YairHalberstadt/stronginject - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="YairHalberstadt/stronginject - linksfor.dev(s)"/>
    <meta property="article:author" content="YairHalberstadt"/>
    <meta property="og:description" content="compile time dependency injection for .Net. Contribute to YairHalberstadt/stronginject development by creating an account on GitHub."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/YairHalberstadt/stronginject"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - YairHalberstadt/stronginject</title>
<div class="readable">
        <h1>YairHalberstadt/stronginject</h1>
            <div>by YairHalberstadt</div>
            <div>Reading time: 16-20 minutes</div>
        <div>Posted here: 14 Aug 2020</div>
        <p><a href="https://github.com/YairHalberstadt/stronginject">https://github.com/YairHalberstadt/stronginject</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    
      <div>
        <article itemprop="text">

<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/yairhalberstadt/stronginject/workflows/.NET%20Core/badge.svg"><img src="https://github.com/yairhalberstadt/stronginject/workflows/.NET%20Core/badge.svg" alt=""></a>
<a href="https://gitter.im/stronginject/community?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" rel="nofollow"><img src="https://camo.githubusercontent.com/0f24c67b5da743856eec97f0a748380f813e62ce/68747470733a2f2f6261646765732e6769747465722e696d2f7374726f6e67696e6a6563742f636f6d6d756e6974792e737667" alt="Join the chat at https://gitter.im/stronginject/community" data-canonical-src="https://badges.gitter.im/stronginject/community.svg"></a></p>

<p>compile time dependency injection for .Net</p>
<h2>Table Of Contents</h2>
<ul>
<li><a href="#aims">Aims</a></li>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#nuget">Nuget</a></li>
<li><a href="#usage">Usage</a>
<ul>
<li><a href="#declaring-a-container">Declaring a container</a></li>
<li><a href="#using-a-container">Using a container.</a></li>
<li><a href="#registration">Registration</a>
<ul>
<li><a href="#basics">Basics</a></li>
<li><a href="#scope">Scope</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#factory-registrations">Factory Registrations</a></li>
<li><a href="#providing-registrations-at-runtime-or-integrating-with-other-ioc-containers">Providing registrations at runtime or integrating with other IOC containers</a></li>
</ul>
</li>
<li><a href="#delegate-support">Delegate Support</a></li>
<li><a href="#post-constructor-initialization">Post Constructor Initialization</a></li>
<li><a href="#async-support">Async Support</a></li>
<li><a href="#disposal">Disposal</a></li>
<li><a href="#thread-safety">Thread Safety</a></li>
</ul>
</li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#need-help">Need Help?</a></li>
</ul>

<h2>Aims</h2>
<ol>
<li><strong>Compile time checked dependency injection.</strong> If the type you're resolving isn't registered you get an error at compile time, not runtime.</li>
<li><strong>Fast.</strong> There's no dictionary lookups, no runtime code generation. Just the fastest code it's possible to generate to resolve your type.</li>
<li><strong>Encourage best practices.</strong> You can't use the container as a service locator. You can't forget to dispose the resolved types.</li>
<li><strong>No reflection or runtime code generation.</strong> Instead StrongInject uses roslyn Source Generators, meaning it's fast, and works well on UWP/IOS too.</li>
<li><strong>Async support.</strong> StrongInject fully supports async initialization and disposal, a feature sorely lacking in many IOC containers.</li>
</ol>
<h2>Requirements</h2>
<p>Source generators are currently in preview and so you will require a preview version of VS and dotnet.</p>
<p><a href="https://visualstudio.microsoft.com/vs/preview/" rel="nofollow">Visual Studio preview version</a></p>
<p><a href="https://dotnet.microsoft.com/download/dotnet/5.0" rel="nofollow">.NET 5 preview version</a></p>
<h2>Nuget</h2>
<p><a href="https://www.nuget.org/packages/StrongInject/" rel="nofollow">https://www.nuget.org/packages/StrongInject/</a></p>
<p>We recommend you use floating versions for now, as <code>StrongInject</code> is still in preview and changing rapidly.
<code>&lt;PackageReference Include="StrongInject" Version="0.0.1-CI-*" /&gt;</code></p>
<h2>Usage</h2>
<h3>Declaring a container</h3>
<p>To create a container for a specific type, declare your container partial and inherit from <code>StrongInject.IContainer&lt;T&gt;</code>:</p>
<div><pre><span>using</span> <span>StrongInject</span>;

<span>public</span> <span>class</span> <span>A</span> {}

[<span>Registration</span>(<span>typeof</span>(<span>A</span>))]
<span>public</span> <span>partial</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>A</span>&gt; {}</pre></div>
<p>If it's possible to resolve the type parameter StrongInject will generate the implementation of IContainer for you. Else it will produce an error diagnostic.</p>
<p>You can implement <code>IContainer&lt;T&gt;</code> for different values of <code>T</code>. They will all share SingleInstance dependencies.</p>
<div><pre><span>using</span> <span>StrongInject</span>;

<span>public</span> <span>class</span> <span>A</span> {}
<span>public</span> <span>class</span> <span>B</span> {}

[<span>Registration</span>(<span>typeof</span>(<span>A</span>))]
[<span>Registration</span>(<span>typeof</span>(<span>B</span>))]
<span>public</span> <span>partial</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>A</span>&gt;, <span>IContainer</span>&lt;<span>B</span>&gt; {}</pre></div>
<h3>Using a container.</h3>
<p>To use a container, you'll want to use the <code>Run</code> extension methods defined in <code>StrongInject.ContainerExtensions</code>, so make sure you're <code>using StrongInject;</code></p>
<p>The <code>Run</code> method on <code>IContainer&lt;T&gt;</code> takes a <code>Func&lt;T&gt;</code>. It resolves an instance of <code>T</code>, calls the func, disposes of any dependencies which require disposal, and then returns the result of the func. This ensures that you can't forget to dispose any dependencies, but you must make sure not too leak those objects out of the delegate. There are also overloads that allow you to pass in a void returning lambda.</p>
<div><pre><span>using</span> <span>StrongInject</span>;

<span>public</span> <span>class</span> <span>Program</span>
{
  <span>public</span> <span>static</span> <span>void</span> <span>Main</span>()
  {
    <span>System</span>.<span>Console</span>.<span>WriteLine</span>(<span>new</span> <span>Container</span>().<span>Run</span>(<span>x</span> <span>=&gt;</span> <span>x</span>.<span>ToString</span>()));
  }
}</pre></div>
<h3>Registration</h3>
<h4>Basics</h4>
<p>As you saw above, you can register a type with a container using the <code>RegistrationAttribute</code>:</p>
<div><pre><span>using</span> <span>StrongInject</span>;

<span>public</span> <span>class</span> <span>A</span> {}
<span>public</span> <span>class</span> <span>B</span> {}

[<span>Registration</span>(<span>typeof</span>(<span>A</span>))]
[<span>Registration</span>(<span>typeof</span>(<span>B</span>))]
<span>public</span> <span>partial</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>A</span>&gt;, <span>IContainer</span>&lt;<span>B</span>&gt; {}</pre></div>
<p>All the dependencies of the container type parameter must be registered or you will get a compile time error.</p>
<p>By default <code>[Registration(typeof(A))]</code> will register an type <code>A</code> as itself. You can however register a type as any base type or implemented interface:</p>
<div><pre><span>using</span> <span>StrongInject</span>;

<span>public</span> <span>class</span> <span>BaseBase</span> {}
<span>public</span> <span>interface</span> <span>IBase</span> {}
<span>public</span> <span>class</span> <span>Base</span> : <span>BaseBase</span>, <span>IBase</span> {}
<span>public</span> <span>interface</span> <span>IA</span> {}
<span>public</span> <span>class</span> <span>A</span> : <span>Base</span>, <span>IA</span> {}

[<span>Registration</span>(<span>typeof</span>(<span>A</span>), <span>typeof</span>(<span>IA</span>), <span>typeof</span>(<span>IBase</span>), <span>typeof</span>(<span>BaseBase</span>))]
<span>public</span> <span>partial</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>BaseBase</span>&gt; {}</pre></div>
<p>If you do so, you will have to explicitly also register it as itself if that is desired: <code>[Registration(typeof(A), typeof(A), typeof(IA), typeof(IBase), typeof(BaseBase))]</code></p>
<p>If there is a single public non-parameterless constructor, StrongInject will use that to construct the type. If there is no public non-parameterless constructor StrongInject will use the parameterless constructor if it exists and is public. Else it will report an error.</p>
<h4>Scope</h4>
<p>The scope of a registration determines how often a new instance is created, how long it lives, and who uses it.</p>
<p>It can be set as the second parameter of a registration:</p>
<div><pre><span>using</span> <span>StrongInject</span>;

<span>public</span> <span>class</span> <span>A</span> {}
<span>public</span> <span>interface</span> <span>IB</span> {}
<span>public</span> <span>class</span> <span>B</span> : <span>IB</span> {}

[<span>Registration</span>(<span>typeof</span>(<span>A</span>), <span>Scope</span>.<span>SingleInstance</span>)]
[<span>Registration</span>(<span>typeof</span>(<span>B</span>), <span>Scope</span>.<span>InstancePerResolution</span>, <span>typeof</span>(<span>IB</span>))]
<span>public</span> <span>partial</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>A</span>&gt;, <span>IContainer</span>&lt;<span>IB</span>&gt; {}</pre></div>
<p>There are currently 3 diferent scopes:</p>
<p><strong>Instance Per Resolution</strong></p>
<p>This is the default scope.</p>
<p>A single instance is shared between all dependencies created for a single resolution.
For example if 'A' debends on 'B' and 'C', and 'B' and 'C' both depend on an instance of 'D',
then when 'A' is resolved 'B' and 'C' will share the same instance of 'D'.</p>
<p>Note every SingleInstance dependency defines a seperate resolution,
so if 'B' and/or 'C' are SingleInstance they would not share an instance of 'D'.</p>
<p><strong>Instance Per Dependency</strong></p>
<p>A new instance is created for every usage.
For example even if type 'B' appears twice in the constructor of 'A',
two different instances will be passed into the constructor.</p>
<p><strong>SingleInstance</strong></p>
<p>A single instance will be shared across all dependencies, from any resolution</p>
<h4>Modules</h4>
<p>You can add registrations to any type, and then import them using the <code>ModuleRegistrationAttribute</code>. This allows you to create reusable modules of common registrations.</p>
<div><pre><span>using</span> <span>StrongInject</span>;

<span>public</span> <span>class</span> <span>A</span> {}

[<span>Registration</span>(<span>typeof</span>(<span>A</span>))]
<span>public</span> <span>class</span> <span>Module</span> {}

[<span>ModuleRegistration</span>(<span>typeof</span>(<span>Module</span>))]
<span>public</span> <span>partial</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>A</span>&gt; {}</pre></div>
<p>If you import multiple modules, and they both register the same type differently, you will get an error.</p>
<p>There are two ways to solve this:</p>
<ol>
<li>Register the type directly. This will override the registrations in imported modules.</li>
<li>Exclude the registration from one of the modules when you import it: <code>[ModuleRegistration(typeof(Module), exclusionList: new [] { typeof(A) })]</code></li>
</ol>
<h4>Factory Registrations</h4>
<p>Sometimes a type requires more complex construction than just calling the constructor. For example you might want to hard code some parameters, or call a factory method. Some types don't have the correct constructors to be registered directly.</p>
<p>For such cases the <code>IFactory&lt;T&gt;</code> interface exists.</p>
<p>You can register a type implementing <code>IFactory&lt;T&gt;</code> as a Factory Registration.
This will automatically register it as both <code>IFactory&lt;T&gt;</code> and <code>T</code>. An instance of <code>T</code> will be constructed by calling <code>IFactory&lt;T&gt;.CreateAsync()</code>.</p>
<div><pre><span>using</span> <span>StrongInject</span>;

<span>public</span> <span>interface</span> <span>IInterface</span> {}
<span>public</span> <span>class</span> <span>A</span> : <span>IInterface</span> {}
<span>public</span> <span>class</span> <span>B</span> : <span>IInterface</span> {}
<span>public</span> <span>record</span> <span>InterfaceArrayFactory</span>(<span>A</span> <span>A</span>, <span>B</span> <span>B</span>) : IFactory&lt;IInterface[]&gt;
{
    <span>public</span> <span>IInterface</span>[] <span>Create</span>() <span>=</span><span>&gt;</span> <span>new</span> <span>IInterface</span>[] { <span>A</span>, <span>B</span> };
}

[<span>Registration</span>(<span>typeof</span>(<span>A</span>))]
[<span>Registration</span>(<span>typeof</span>(<span>B</span>))]
[<span>FactoryRegistration</span>(<span>typeof</span>(<span>InterfaceArrayFactory</span>))]
<span>public</span> <span>partial</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>IInterface</span>[]&gt; { }</pre></div>
<p>Whilst a factory doesn't have to be a record, doing so significantly shortens the amount of code you have to write.</p>
<p>The scope of the factory and the factory target is controlled separately. This allows you to e.g. have a singleton factory, but call <code>CreateAsync</code> on every resolution:</p>
<div><pre>[<span>FactoryRegistration</span>(<span>typeof</span>(<span>InterfaceArrayFactory</span>), <span>scope</span>: <span>Scope</span>.<span>SingleInstance</span>, <span>factoryTargetScope</span>: <span>Scope</span>.<span>InstancePerResolution</span>, <span>typeof</span>(<span>IFactory</span>&lt;<span>IInterface</span>[]&gt;))]</pre></div>
<p>If a factory implements <code>IFactory&lt;T&gt;</code> for multiple <code>T</code>s it will be registered as a factory for all of them.</p>
<h4>Providing registrations at runtime or integrating with other IOC containers</h4>
<p>What if you need to provide configuration for a registration at runtime? Or alternatively what if you need to integrate with an existing container?</p>
<p>For that you can use the <code>IInstanceProvider&lt;T&gt;</code> interface. Any fields of a container which are or implement <code>IInstanceProvider&lt;T&gt;</code> will provide/override any existing registrations for <code>T</code>.</p>
<p>Here is a full fledged example of how you could provide configuration for a registration at runtime, whilst still getting the full benefit of the IOC container to create your types. Of course many cases will be simpler, and not require usage of both a factory and an instanceProvider.</p>
<div><pre><span>using</span> <span>StrongInject</span>;

<span>public</span> <span>interface</span> <span>IInterface</span> { }
<span>public</span> <span>class</span> <span>A</span> : <span>IInterface</span> { }
<span>public</span> <span>class</span> <span>B</span> : <span>IInterface</span> { }

<span>public</span> <span>enum</span> <span>InterfaceToUse</span>
{
    <span>UseA</span>,
    <span>UseB</span>
}

<span>public</span> <span>record</span> <span>InstanceProvider</span>(<span>InterfaceToUse</span> <span>InterfaceToUse</span>) : IInstanceProvider&lt;InterfaceToUse&gt;
{
    <span>public</span> <span>InterfaceToUse</span> <span>Get</span>() <span>=</span><span>&gt;</span> <span>InterfaceToUse</span>;
}

<span>public</span> <span>record</span> <span>InterfaceFactory</span>(<span>A</span> <span>A</span>, <span>B</span> <span>B</span>, <span>InterfaceToUse</span> <span>InterfaceToUse</span>) : IFactory&lt;IInterface&gt;
{
    <span>public</span> <span>IInterface</span> <span>Create</span>() <span>=</span><span>&gt;</span> <span>InterfaceToUse</span> <span>==</span> <span>InterfaceToUse</span>.<span>UseA</span> <span>?</span> (<span>IInterface</span>)<span>A</span> <span>:</span> <span>B</span>;
}

[<span>Registration</span>(<span>typeof</span>(<span>A</span>))]
[<span>Registration</span>(<span>typeof</span>(<span>B</span>))]
[<span>FactoryRegistration</span>(<span>typeof</span>(<span>InterfaceFactory</span>))]
<span>public</span> <span>partial</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>IInterface</span>&gt;
{
    <span>private</span> <span>readonly</span> <span>InstanceProvider</span> <span>_instanceProvider</span>;
    <span>public</span> <span>Container</span>(<span>InstanceProvider</span> <span>instanceProvider</span>) <span>=&gt;</span> <span>_instanceProvider</span> <span>=</span> <span>instanceProvider</span>;
}</pre></div>
<p><code>Get</code> is called once per resolution (equiavalent to Instance Per Resolution scope). Of course the implementation is free to returna singleton or not.</p>
<h3>Delegate Support</h3>
<p>StrongInject can automatically resolve non-void reurning delegates even if they're not registered. It tries to resolve the return type. The delegate parameters can be used in the resolution, and will override any existing resolutions.</p>
<p>There are two reasons you might want to use delegate resolution:</p>
<ol>
<li>To return a new instance of the return type on every call:</li>
</ol>
<div><pre><span>using</span> <span>System</span>;
<span>using</span> <span>StrongInject</span>;

<span>public</span> <span>class</span> <span>A</span>
{
  <span>public</span> <span>A</span>(<span>Func</span>&lt;<span>B</span>&gt; <span>fB</span>) <span>=&gt;</span> <span>Console</span>.<span>WriteLine</span>(<span>fB</span>() <span>!=</span> <span>fB</span>()); <span><span>//</span>prints true</span>
}

<span>public</span> <span>class</span> <span>B</span>{}

[<span>Registration</span>(<span>typeof</span>(<span>A</span>))]
[<span>Registration</span>(<span>typeof</span>(<span>B</span>))]
<span>public</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>A</span>&gt; {}</pre></div>
<ol start="2">
<li>To provide parameters which are not available at resolution time:</li>
</ol>
<div><pre><span>using</span> <span>System</span>;
<span>using</span> <span>StrongInject</span>;

<span>public</span> <span>class</span> <span>Server</span>
{
  <span>private</span> <span>Handler</span> <span>_frobbingHandler</span>;
  <span>private</span> <span>Handler</span> <span>_nonFrobbingHandler</span>;
  <span>public</span> <span>Server</span>(<span>Func</span>&lt;<span>bool</span>, <span>Handler</span>&gt; <span>handlerFunc</span>) <span>=&gt;</span> (<span>_frobbingHandler</span>, <span>_nonFrobbingHandler</span>) <span>=</span> (<span>handlerFunc</span>(<span>true</span>), <span>handlerFunc</span>(<span>false</span>));
  
  <span>public</span> <span>bool</span> <span>HandleRequest</span>(<span>Request</span> <span>request</span>, <span>bool</span> <span>shouldFrob</span>) <span>=&gt;</span> <span>shouldFrob</span> <span>?</span> <span>_frobbingHandler</span>.<span>HandleRequest</span>(<span>request</span>) <span>:</span> <span>_nonFrobbingHandler</span>.<span>HandleRequest</span>(<span>request</span>);
}

<span>public</span> <span>class</span> <span>Handler</span>
{
  <span>public</span> <span>Handler</span>(<span>bool</span> <span>shouldFrob</span>) <span>=&gt;</span> ...
}

[<span>Registration</span>(<span>typeof</span>(<span>Server</span>))]
[<span>Registration</span>(<span>typeof</span>(<span>Handler</span>))]
<span>public</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>Server</span>&gt; {}</pre></div>
<p>If the return type can only be resolved asynchronously (see <a href="#async-support">below</a>), the delegate must return <code>Task&lt;T&gt;</code> or <code>ValueTask&lt;T&gt;</code>. e.g.</p>
<div><pre><span>using</span> <span>System</span>;
<span>using</span> <span>StrongInject</span>;
<span>using</span> <span>System</span>.<span>Threading</span>.<span>Tasks</span>;

<span>public</span> <span>class</span> <span>Server</span>
{
  <span>private</span> <span>Func</span>&lt;<span>bool</span>, <span>Task</span>&lt;<span>Handler</span>&gt;&gt; <span>_handlerFunc</span>;
  <span>public</span> <span>Server</span>(<span>Func</span>&lt;<span>bool</span>, <span>Task</span>&lt;<span>Handler</span>&gt;&gt; <span>handlerFunc</span>) <span>=&gt;</span> <span>_handlerFunc</span> <span>=</span> <span>handlerFunc</span>;
  
  <span>public</span> <span>async</span> <span>Task</span>&lt;<span>bool</span>&gt; <span>HandleRequest</span>(<span>Request</span> <span>request</span>, <span>bool</span> <span>shouldFrob</span>) <span>=&gt;</span> (<span>await</span> <span>_handlerFunc</span>(<span>shouldFrob</span>)).<span>HandleRequest</span>(<span>request</span>);
}

<span>public</span> <span>class</span> <span>Handler</span> : <span>IRequiresAsyncInitialization</span>
{
  <span>public</span> <span>Handler</span>(<span>bool</span> <span>shouldFrob</span>) <span>=&gt;</span> ...
  <span>public</span> <span>async</span> <span>ValueTask</span> <span>ResolveAsync</span>() <span>=</span><span>&gt;</span> ...
}

[<span>Registration</span>(<span>typeof</span>(<span>Server</span>))]
[<span>Registration</span>(<span>typeof</span>(<span>Handler</span>))]
<span>public</span> <span>class</span> <span>Container</span> : <span>IContainer</span>&lt;<span>Server</span>&gt; {}</pre></div>
<h3>Post Constructor Initialization</h3>
<p>If your type implements <code>IRequiresInitialization</code>, <code>Initialize</code> will be called after construction.
Whilst this is only useful in a few edge cases for synchronous methods, <code>IRequiresAsyncInitialization</code> is extremely useful as constructors cannot be async. Therefore I'll leave an example of using this API for the section on async support.</p>
<h3>Async Support</h3>
<p>Every interface use by StrongInject has an asynchronous counterpart.
Theres <code>IAsyncContainer</code>, <code>IAsyncFactory</code>, <code>IRequiresAsyncInitialization</code>, and <code>IAsyncInstanceProvider</code>.</p>
<p>You can resolve an instance of <code>T</code> asynchronously from an <code>IAsyncContainer&lt;T&gt;</code> by calling <code>StrongInject.AsyncContainerExtensions.RunAsync</code>. RunAsync has overloads allowing you to pass in  sync or async lambda. As such <code>IAsycContainer&lt;T&gt;</code> is useful even if resolution is completely synchronous if usage is asynchronous.</p>
<p>It is an error resolving <code>T</code> in an <code>IContainer&lt;T&gt;</code> depends on an asynchronous dependency.</p>
<p>A type can implement both <code>IContainer&lt;T1&gt;</code> and <code>IAsyncCOntainer&lt;T2&gt;</code>. They will share single instance depdendencies.</p>
<p>Here is a full fledged example where data will be loaded from the database as part of resolution using <code>IRequiresAsyncInitialization</code>:</p>
<div><pre><span>using</span> <span>StrongInject</span>;
<span>using</span> <span>System</span>;
<span>using</span> <span>System</span>.<span>Collections</span>.<span>Generic</span>;
<span>using</span> <span>System</span>.<span>Threading</span>;
<span>using</span> <span>System</span>.<span>Threading</span>.<span>Tasks</span>;

<span>public</span> <span>interface</span> <span>IDb</span>
{
    <span>Task</span>&lt;<span>Dictionary</span>&lt;<span>string</span>, <span>string</span>&gt;&gt; <span>GetUserPasswordsAsync</span>();
}

<span>public</span> <span>class</span> <span>PasswordChecker</span> : <span>IRequiresAsyncInitialization</span>, <span>IAsyncDisposable</span>
{
    <span>private</span> <span>readonly</span> <span>IDb</span> <span>_db</span>;

    <span>private</span> <span>Dictionary</span>&lt;<span>string</span>, <span>string</span>&gt; <span>_userPasswords</span>;

    <span>private</span> <span>Timer</span> <span>_timer</span>;

    <span>public</span> <span>PasswordChecker</span>(<span>IDb</span> <span>db</span>)
    {
        <span>_db</span> <span>=</span> <span>db</span>;
    }

    <span>public</span> <span>async</span> <span>ValueTask</span> <span>InitializeAsync</span>()
    {
        <span>_userPasswords</span> <span>=</span> <span>await</span> <span>_db</span>.<span>GetUserPasswordsAsync</span>();
        <span>_timer</span> <span>=</span> <span>new</span> <span>Timer</span>(<span>async</span> <span>_</span> <span>=&gt;</span> { <span>_userPasswords</span> <span>=</span> <span>await</span> <span>_db</span>.<span>GetUserPasswordsAsync</span>(); }, <span>null</span>, <span>60000</span>, <span>60000</span>);
    }

    <span>public</span> <span>bool</span> <span>CheckPassword</span>(<span>string</span> <span>user</span>, <span>string</span> <span>password</span>) <span>=&gt;</span> <span>_userPasswords</span>.<span>TryGetValue</span>(<span>user</span>, <span>out</span> <span>var</span> <span>correctPassword</span>) <span>&amp;&amp;</span> <span>password</span> <span>==</span> <span>correctPassword</span>;

    <span>public</span> <span>ValueTask</span> <span>DisposeAsync</span>()
    {
        <span>return</span> <span>_timer</span>.<span>DisposeAsync</span>();
    }
}

<span>public</span> <span>record</span> <span>DbInstanceProvider</span>(<span>IDb</span> <span>Db</span>) : IInstanceProvider&lt;IDb&gt;
{
    <span>public</span> <span>IDb</span> <span>Get</span>()
    {
        <span>return</span> <span>Db</span>;
    }

    <span>public</span> <span>void</span> <span>Release</span>(<span>IDb</span> <span>instance</span>) {}
}

[<span>Registration</span>(<span>typeof</span>(<span>PasswordChecker</span>), <span>Scope</span>.<span>SingleInstance</span>)]
<span>public</span> <span>partial</span> <span>class</span> <span>Container</span> : <span>IAsyncContainer</span>&lt;<span>PasswordChecker</span>&gt;
{
    <span>private</span> <span>readonlyDbInstanceProvider</span> <span>_dbInstanceProvider</span>;

    <span>public</span> <span>Container</span>(<span>DbInstanceProvider</span> <span>dbInstanceProvider</span>)
    {
        <span>_dbInstanceProvider</span> <span>=</span> <span>dbInstanceProvider</span>;
    }
}

<span>public</span> <span>static</span> <span>class</span> <span>Program</span>
{
  <span>public</span> <span>static</span> <span>async</span> <span>Task</span> <span>Main</span>(<span>string</span>[] <span>args</span>)
  {
    <span>await</span> <span>new</span> <span>Container</span>(<span>new</span> <span>DbInstanceProvider</span>(<span>new</span> <span>Db</span>())).<span>RunAsync</span>(<span>x</span> <span>=&gt;</span> 
      <span>Console</span>.<span>WriteLine</span>(<span>x</span>.<span>CheckPassword</span>(<span>args</span>[<span>0</span>], <span>args</span>[<span>1</span>])
        <span>?</span> <span><span>"</span>Password is valid<span>"</span></span>
        <span>:</span> <span><span>"</span>Password is invalid<span>"</span></span>));
  }
}</pre></div>
<h3>Disposal</h3>
<p>Once a call to <code>Run</code> or <code>RunAsync</code> is complete, any Instance Per Resolution or Instance Per Dependency instances created as part of the call to <code>Run</code> or <code>RunAsync</code> will be disposed.</p>
<p>In <code>RunAsync</code> if the types implement <code>IAsyncDisposable</code> it will be preferred over <code>IDisposable</code>. <code>Dispose</code> and <code>DisposeAsync</code> will not both be called, just <code>DisposeAsync</code>.
In <code>Run</code>, <code>IAsyncDisposable</code> will be ignored. Only <code>Dispose</code> will ever be called.</p>
<p>Since an <code>InstanceProvider&lt;T&gt;</code> is free to create a new instance every time or return a singleton, StrongInject cannot call dispose directly. Instead it calls <code>InstanceProvider&lt;T&gt;.Release(T instance)</code>. The instanceProvider is then free to dispose the class or not. When referencing the .NET Standard 2.1 package <code>Release</code> has a default implementation which does nothing. You only need to implement it if you want custom behaviour. If you reference the .NET Standard 2.0 package you will need to implement it either way.</p>
<p>Single Instance dependencies and their dependencies are disposed when the container is disposed. If the container implements <code>IAsyncDisposable</code> it must be disposed asynchronously even if it also implements <code>IDisposable</code>.</p>
<p>Note that dependencies may not be disposed in the following circumstances:</p>
<ol>
<li>Resolution throws</li>
<li>Disposal of other dependencies throws.</li>
</ol>
<h3>Thread Safety</h3>
<p>StrongInject provides the following thread safety guarantees:</p>
<ol>
<li>Resolution is thread safe, so long as it doesn't call back into the container recursively (e.g. a factory calling <code>container.RunAsync</code>).</li>
<li>If the container is disposed during resolution, then either dependencies will be created by the resolution, and will then be disposed, or resolution will throw and no dependencies will be created. Dependencies will not be created and then not disposed.</li>
<li>A SingleInstance dependency will never be created more than once.</li>
</ol>
<h2>Contributing</h2>
<p>This is currently in preview, meaning we can (and will) make API breaking changes. Now is the best time to file suggestions if you feel like the API could be approved.</p>
<p>Similiarly please do open issues if you spot any bugs.</p>
<p>Please feel free to work on any open issue and open a PR. Ideally open an issue before working on something, so that the effort doesn't go to waste if it's not suitable.</p>
<h2>Need Help?</h2>
<p>I tend to hang around on gitter so feel free to chat at <a href="https://gitter.im/stronginject/community#share" rel="nofollow">https://gitter.im/stronginject/community#share</a>.</p>
<p>You can also <a href="https://github.com/YairHalberstadt/stronginject/issues/new/choose">open an issue</a>, ask on <a href="https://stackoverflow.com/questions/ask" rel="nofollow">stackoverflow</a>, or tag <a href="https://twitter.com/HalberstadtYair" rel="nofollow">me</a> on twitter.</p>
</article>
      </div>
  </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>