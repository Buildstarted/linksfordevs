<!DOCTYPE html>
<html lang="en">
<head>
    <title>
An Introduction to DataFrame | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="An Introduction to DataFrame | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Prashanth GovindarajanFollow"/>
    <meta property="og:description" content="Last month, we announced .NET support for Jupyter notebooks, and showed how to use them to work with .NET for Apache Spark and ML.NET. Today, we&#x2019;re announcing the preview of a DataFrame type for .NET to make data exploration easy. If you&#x2019;ve used Python to manipulate data in notebooks,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/an-introduction-to-dataframe/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - An Introduction to DataFrame | .NET Blog</title>
<div class="readable">
        <h1>An Introduction to DataFrame | .NET Blog</h1>
            <div>by Prashanth GovindarajanFollow</div>
            <div>Reading time: 11-13 minutes</div>
        <div>Posted here: 31 Dec 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-dataframe/">https://devblogs.microsoft.com/dotnet/an-introduction-to-dataframe/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/MicrosoftPic-150x150.jpg" width="58" height="58" alt="Prashanth Govindarajan"></p></div></div></div><p>December 16th, 2019</p><p>Last month, we announced .NET support for Jupyter notebooks, and showed how to use them to work with .NET for Apache Spark and ML.NET. Today, we’re announcing the preview of a <a href="https://www.nuget.org/packages/Microsoft.Data.Analysis/" rel="noopener noreferrer" target="_blank">DataFrame</a> type for .NET to make data exploration easy. If you’ve used Python to manipulate data in notebooks, you’ll already be familiar with the concept of a DataFrame. At a high level, it is an in-memory representation of structured data. In this blog post, I’m going to give an overview of this new type and how you can use it from Jupyter notebooks. To play along, fire up a .NET Jupyter Notebook in a <a href="https://mybinder.org/v2/gh/dotnet/interactive/master?urlpath=lab" rel="noopener noreferrer" target="_blank">browser</a>.</p><h2>How to use DataFrame?</h2><p><code>DataFrame</code> stores data as a collection of columns. Let’s populate a <code>DataFrame</code> with some sample data and go over the major features. The full sample can be found on Github(<a href="https://github.com/dotnet/interactive/blob/467828bae501022734fc5d0d077bef8d36bb0bf8/NotebookExamples/csharp/Samples/DataFrame-Getting%20Started.ipynb" rel="noopener noreferrer" target="_blank">C#</a> and <a href="https://github.com/dotnet/interactive/blob/467828bae501022734fc5d0d077bef8d36bb0bf8/NotebookExamples/fsharp/Samples/DataFrame-Getting%20Started.ipynb" rel="noopener noreferrer" target="_blank">F#</a>). To follow along in your browser, click <a href="https://mybinder.org/v2/gh/dotnet/interactive/master?urlpath=lab" rel="noopener noreferrer" target="_blank">here</a> and navigate to <em>csharp/Samples/DataFrame-Getting Started.ipynb</em>(or <em>fsharp/Samples/DataFrame-Getting Started.ipynb</em>). To get started, let’s import the <a href="https://www.nuget.org/packages/Microsoft.Data.Analysis/" rel="noopener noreferrer" target="_blank">Microsoft.Data.Analysis</a> package and namespace into our .NET Jupyter Notebook (make sure you’re using the C# or F# kernel):</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/Microsoft.Data_.Analysis.png" alt="Microsoft.Data.Analysis package"></p><p>Let’s make three columns to hold values of types <code>DateTime</code>, <code>int</code> and <code>string</code>.</p><pre><code><span>PrimitiveDataFrameColumn</span><span>&lt;</span><span>DateTime</span><span>&gt;</span><span> dateTimes </span><span>=</span><span> </span><span>new</span><span> </span><span>PrimitiveDataFrameColumn</span><span>&lt;</span><span>DateTime</span><span>&gt;(</span><span>"DateTimes"</span><span>);</span><span> </span><span>// Default length is 0.</span><span>
</span><span>PrimitiveDataFrameColumn</span><span>&lt;int&gt;</span><span> ints </span><span>=</span><span> </span><span>new</span><span> </span><span>PrimitiveDataFrameColumn</span><span>&lt;int&gt;</span><span>(</span><span>"Ints"</span><span>,</span><span> </span><span>3</span><span>);</span><span> </span><span>// Makes a column of length 3. Filled with nulls initially</span><span>
</span><span>StringDataFrameColumn</span><span> strings </span><span>=</span><span> </span><span>new</span><span> </span><span>StringDataFrameColumn</span><span>(</span><span>"Strings"</span><span>,</span><span> </span><span>3</span><span>);</span><span> </span><span>// Makes a column of length 3. Filled with nulls initially</span></code></pre><p><code>PrimitiveDataFrameColumn</code> is a generic column that can hold primitive types such as <code>int</code>, <code>float</code>, <code>decimal</code> etc. A <code>StringDataFrameColumn</code> is a specialized column that holds <code>string</code> values. Both the column types can take a <code>length</code> parameter in their contructors and are filled with <code>null</code> values initially. Before we can add these columns to a <code>DataFrame</code> though, we need to append three values to our <code>dateTimes</code> column. This is because the <code>DataFrame</code> constructor expects all its columns to have the same length.</p><pre><code><span>// Append 3 values to dateTimes</span><span>
dateTimes</span><span>.</span><span>Append</span><span>(</span><span>DateTime</span><span>.</span><span>Parse</span><span>(</span><span>"2019/01/01"</span><span>));</span><span>
dateTimes</span><span>.</span><span>Append</span><span>(</span><span>DateTime</span><span>.</span><span>Parse</span><span>(</span><span>"2019/01/01"</span><span>));</span><span>
dateTimes</span><span>.</span><span>Append</span><span>(</span><span>DateTime</span><span>.</span><span>Parse</span><span>(</span><span>"2019/01/02"</span><span>));</span></code></pre><p>Now we’re ready to create a <code>DataFrame</code> with three columns.</p><pre><code><span>DataFrame</span><span> df </span><span>=</span><span> </span><span>new</span><span> </span><span>DataFrame</span><span>(</span><span>dateTimes</span><span>,</span><span> ints</span><span>,</span><span> strings</span><span>);</span><span> </span><span>// This will throw if the columns are of different lengths</span></code></pre><p>One of the benefits of using a notebook for data exploration is the interactive REPL. We can enter <code>df</code> into a new cell and run it to see what data it contains. For the rest of this post, we’ll work in a .NET Jupyter environment. All the sample code will work in a regular console app as well though.</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/ArrayPrint.png" alt="Array Print"></p><p>We immediately see that the formatting of the output can be improved. Each column is printed as an array of values and we don’t see the names of the columns. If <code>df</code> had more rows and columns, the output would be hard to read. Fortunately, in a Jupyter environment, we can write custom formatters for types. Let’s write a formatter for <code>DataFrame</code>.</p><pre><code><span>using</span><span> </span><span>Microsoft</span><span>.</span><span>AspNetCore</span><span>.</span><span>Html</span><span>;</span><span>
</span><span>Formatter</span><span>&lt;</span><span>DataFrame</span><span>&gt;.</span><span>Register</span><span>((</span><span>df</span><span>,</span><span> writer</span><span>)</span><span> </span><span>=&gt;</span><span>
</span><span>{</span><span>
    </span><span>var</span><span> headers </span><span>=</span><span> </span><span>new</span><span> </span><span>List</span><span>&lt;</span><span>IHtmlContent</span><span>&gt;();</span><span>
    headers</span><span>.</span><span>Add</span><span>(</span><span>th</span><span>(</span><span>i</span><span>(</span><span>"index"</span><span>)));</span><span>
    headers</span><span>.</span><span>AddRange</span><span>(</span><span>df</span><span>.</span><span>Columns</span><span>.</span><span>Select</span><span>(</span><span>c </span><span>=&gt;</span><span> </span><span>(</span><span>IHtmlContent</span><span>)</span><span> th</span><span>(</span><span>c</span><span>.</span><span>Name</span><span>)));</span><span>
    </span><span>var</span><span> rows </span><span>=</span><span> </span><span>new</span><span> </span><span>List</span><span>&lt;</span><span>List</span><span>&lt;</span><span>IHtmlContent</span><span>&gt;&gt;();</span><span>
    </span><span>var</span><span> take </span><span>=</span><span> </span><span>20</span><span>;</span><span>
    </span><span>for</span><span> </span><span>(</span><span>var</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>Math</span><span>.</span><span>Min</span><span>(</span><span>take</span><span>,</span><span> df</span><span>.</span><span>Rows</span><span>.</span><span>Count</span><span>);</span><span> i</span><span>++)</span><span>
    </span><span>{</span><span>
        </span><span>var</span><span> cells </span><span>=</span><span> </span><span>new</span><span> </span><span>List</span><span>&lt;</span><span>IHtmlContent</span><span>&gt;();</span><span>
        cells</span><span>.</span><span>Add</span><span>(</span><span>td</span><span>(</span><span>i</span><span>));</span><span>
        </span><span>foreach</span><span> </span><span>(</span><span>var</span><span> obj </span><span>in</span><span> df</span><span>.</span><span>Rows</span><span>[</span><span>i</span><span>])</span><span>
        </span><span>{</span><span>
            cells</span><span>.</span><span>Add</span><span>(</span><span>td</span><span>(</span><span>obj</span><span>));</span><span>
        </span><span>}</span><span>
        rows</span><span>.</span><span>Add</span><span>(</span><span>cells</span><span>);</span><span>
    </span><span>}</span><span>

    </span><span>var</span><span> t </span><span>=</span><span> table</span><span>(</span><span>
        thead</span><span>(</span><span>
            headers</span><span>),</span><span>
        tbody</span><span>(</span><span>
            rows</span><span>.</span><span>Select</span><span>(</span><span>
                r </span><span>=&gt;</span><span> tr</span><span>(</span><span>r</span><span>))));</span><span>

    writer</span><span>.</span><span>Write</span><span>(</span><span>t</span><span>);</span><span>
</span><span>},</span><span> </span><span>"text/html"</span><span>);</span></code></pre><p>This snippet of code register a new <code>DataFrame</code> formatter. All subsequent evaluations of <code>df</code> in a notebook will now output the first 20 rows of a <code>DataFrame</code> along with the column names. In the future, the <code>DataFrame</code> type and other libraries that target Jupyter as one of their environments will be able to ship with their formatters.</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/PrintDataFrame.gif" alt="Print DataFrame"></p><p>Sure enough, when we re-evaluate <code>df</code>, we see that it contains the three columns we created previously. The formatting makes it much easier to inspect our values. There’s also a helpful <code>index</code> column in the output to quickly see which row we’re looking at. Let’s modify our data by indexing into <code>df</code>:</p><pre><code><span>df</span><span>[</span><span>0</span><span>,</span><span> </span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>10</span><span>;</span><span> </span><span>// 0 is the rowIndex, and 1 is the columnIndex. This sets the 0th value in the Ints columns to 10</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/DataFrameIndexing.png" alt="DataFrameIndexing"></p><p>We can also modify the values in the columns through indexers defined on <code>PrimitiveDataFrameColumn</code> and <code>StringDataFrameColumn</code>:</p><pre><code><span>// Modify ints and strings columns by indexing</span><span>
ints</span><span>[</span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>100</span><span>;</span><span>
strings</span><span>[</span><span>1</span><span>]</span><span> </span><span>=</span><span> </span><span>"Foo!"</span><span>;</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/ColumnIndexers.png" alt="ColumnIndexers"></p><p>One caveat to keep in mind here is the data type of the value passed in to the indexers. We passed in the right data types to the column indexers in our sample: an integer value of <code>100</code> to <code>ints[1]</code> and a string <code>"Foo!"</code> to <code>string[1]</code>. If the data types don’t match, an exception will be thrown. For cases where the type of data in the columns is not obvious, there is a handy <code>DataType</code> property defined on each column. The <code>Info</code> method displays the <code>DataType</code> and <code>Length</code> properties of each column:</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/DataType.png" alt="Info"></p><p>The <code>DataFrame</code> and <code>DataFrameColumn</code> classes expose a number of useful APIs: binary operations, computations, joins, merges, handling missing values and more. Let’s look at some of them:</p><pre><code><span>// Add 5 to Ints through the DataFrame</span><span>
df</span><span>[</span><span>"Ints"</span><span>].</span><span>Add</span><span>(</span><span>5</span><span>,</span><span> inPlace</span><span>:</span><span> </span><span>true</span><span>);</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/Add.png" alt="Add"></p><pre><code><span>// We can also use binary operators. Binary operators produce a copy, so assign it back to our Ints column </span><span>
df</span><span>[</span><span>"Ints"</span><span>]</span><span> </span><span>=</span><span> </span><span>(</span><span>ints </span><span>/</span><span> </span><span>5</span><span>)</span><span> </span><span>*</span><span> </span><span>100</span><span>;</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/BinaryOperations.png" alt="BinaryOperations"></p><p>All binary operators are backed by functions that produces a copy by default. The <code>+</code> operator, for example, calls the <code>Add</code> method and passes in <code>false</code> for the <code>inPlace</code> parameter. This lets us elegantly manipulate data using operators without worrying about modifying our existing values. For when in place semantics are desired, we can set the <code>inPlace</code> parameter to <code>true</code> in the binary functions.</p><p>In our sample, <code>df</code> has <code>null</code> values in its columns. <code>DataFrame</code> and <code>DataFrameColumn</code> offer an API to fill <code>nulls</code> with values.</p><pre><code><span>df</span><span>[</span><span>"Ints"</span><span>].</span><span>FillNulls</span><span>(-</span><span>1</span><span>,</span><span> inPlace</span><span>:</span><span> </span><span>true</span><span>);</span><span>
df</span><span>[</span><span>"Strings"</span><span>].</span><span>FillNulls</span><span>(</span><span>"Bar"</span><span>,</span><span> inPlace</span><span>:</span><span> </span><span>true</span><span>);</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/FillNulls.png" alt="Fill Nulls"></p><p><code>DataFrame</code> exposes a <code>Columns</code> property that we can enumerate over to access our columns and a <code>Rows</code> property to access our rows. We can index <code>Rows</code> to access each row. Here’s an example that accesses the first row:</p><pre><code><span>DataFrameRow</span><span> row0 </span><span>=</span><span> df</span><span>.</span><span>Rows</span><span>[</span><span>0</span><span>];</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/BadRowAccess.png" alt="Access Rows"></p><p>To inspect our values better, let’s write a formatter for <code>DataFrameRow</code> that displays values in a single line.</p><pre><code><span>using</span><span> </span><span>Microsoft</span><span>.</span><span>AspNetCore</span><span>.</span><span>Html</span><span>;</span><span>
</span><span>Formatter</span><span>&lt;</span><span>DataFrameRow</span><span>&gt;.</span><span>Register</span><span>((</span><span>dataFrameRow</span><span>,</span><span> writer</span><span>)</span><span> </span><span>=&gt;</span><span>
</span><span>{</span><span>
    </span><span>var</span><span> cells </span><span>=</span><span> </span><span>new</span><span> </span><span>List</span><span>&lt;</span><span>IHtmlContent</span><span>&gt;();</span><span>
    cells</span><span>.</span><span>Add</span><span>(</span><span>td</span><span>(</span><span>i</span><span>));</span><span>
    </span><span>foreach</span><span> </span><span>(</span><span>var</span><span> obj </span><span>in</span><span> dataFrameRow</span><span>)</span><span>
    </span><span>{</span><span>
        cells</span><span>.</span><span>Add</span><span>(</span><span>td</span><span>(</span><span>obj</span><span>));</span><span>
    </span><span>}</span><span>

    </span><span>var</span><span> t </span><span>=</span><span> table</span><span>(</span><span>
        tbody</span><span>(</span><span>
            cells</span><span>));</span><span>

    writer</span><span>.</span><span>Write</span><span>(</span><span>t</span><span>);</span><span>
</span><span>},</span><span> </span><span>"text/html"</span><span>);</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/RowAccess.gif" alt="Access Rows"></p><p>To enumerate over all the rows in a <code>DataFrame</code>, we can write a simple for loop. <code>DataFrame.Rows.Count</code> returns the number of rows in a <code>DataFrame</code> and we can use the loop index to access each row.</p><pre><code><span>for</span><span> </span><span>(</span><span>long</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> df</span><span>.</span><span>Rows</span><span>.</span><span>Count</span><span>;</span><span> i</span><span>++)</span><span>
</span><span>{</span><span>
       </span><span>DataFrameRow</span><span> row </span><span>=</span><span> df</span><span>.</span><span>Rows</span><span>[</span><span>i</span><span>];</span><span>
</span><span>}</span></code></pre><p>Note that each row is a view of the values in the <code>DataFrame</code>. Modifying the values in the <code>row</code> object modifies the values in the <code>DataFrame</code>. We do however lose type information on the returned <code>row</code> object. This is a consequence of <code>DataFrame</code> being a loosely typed data structure.</p><p>Let’s wrap up our <code>DataFrame</code> API tour by looking at the <code>Filter</code>, <code>Sort</code>, <code>GroupBy</code> methods:</p><pre><code><span>// Filter rows based on equality</span><span>
</span><span>PrimitiveDataFrameColumn</span><span>&lt;bool&gt;</span><span> boolFilter </span><span>=</span><span> df</span><span>[</span><span>"Strings"</span><span>].</span><span>ElementwiseEquals</span><span>(</span><span>"Bar"</span><span>);</span><span>
</span><span>DataFrame</span><span> filtered </span><span>=</span><span> df</span><span>.</span><span>Filter</span><span>(</span><span>boolFilter</span><span>);</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/DataFrameFilter.png" alt="DataFrame Filter"></p><p><code>ElementwiseEquals</code> returns a <code>PrimitiveDataFrameColumn&lt;bool&gt;</code> filled with a <code>true</code> for every row that equals <code>"Bar"</code> in the <code>Strings</code> column, and a <code>false</code> when it doesn’t equal <code>"Bar"</code>. In the <code>df.Filter</code> call, each row corresponding to a <code>true</code> value in <code>boolFilter</code> selects a row out of <code>df</code>. The resulting <code>DataFrame</code> contains only these rows.</p><pre><code><span>// Sort our dataframe using the Ints column</span><span>
</span><span>DataFrame</span><span> sorted </span><span>=</span><span> df</span><span>.</span><span>Sort</span><span>(</span><span>"Ints"</span><span>);</span><span>
</span><span>// GroupBy </span><span>
</span><span>GroupBy</span><span> groupBy </span><span>=</span><span> df</span><span>.</span><span>GroupBy</span><span>(</span><span>"DateTimes"</span><span>);</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/SortAndGroupBy.png" alt="Sort And GroupBy"></p><p>The <code>GroupBy</code> method takes in the name of a column and creates groups based on unique values in the column. In our sample, the <code>DateTimes</code> column has two unique values, so we expect one group to be created for <code>2019-01-01 00:00:00Z</code> and one for <code>2019-01-02 00:00:00Z</code>.</p><pre><code><span>// Count of values in each group</span><span>
</span><span>DataFrame</span><span> groupCounts </span><span>=</span><span> groupBy</span><span>.</span><span>Count</span><span>();</span><span>
</span><span>// Alternatively find the sum of the values in each group in Ints</span><span>
</span><span>DataFrame</span><span> intGroupSum </span><span>=</span><span> groupBy</span><span>.</span><span>Sum</span><span>(</span><span>"Ints"</span><span>);</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/GroupBySum.png" alt="GroupBy Sum"></p><p>The <code>GroupBy</code> object exposes a set of methods that can called on each group. Some examples are <code>Max()</code>, <code>Min()</code>, <code>Count()</code> etc. The <code>Count()</code> method counts the number of values in each group and return them in a new <code>DataFrame</code>. The <code>Sum("Ints")</code> method sums up the values in each group.</p><p>Finally, when we want to work with existing datasets, <code>DataFrame</code> exposes a <code>LoadCsv</code> method.</p><pre><code><span>DataFrame</span><span> csvDataFrame </span><span>=</span><span> </span><span>DataFrame</span><span>.</span><span>LoadCsv</span><span>(</span><span>"path/to/file.csv"</span><span>);</span></code></pre><h2>Charting</h2><p>Another cool feature of using a <code>DataFrame</code> in a .NET Jupyter environment is charting. <a href="https://fslab.org/XPlot/" target="_blank">XPlot.Plotly</a> is one option to render charts. We can import the <code>XPlot.Plotly</code> namespace into our notebook and create interactive visualizations of the data in our <code>DataFrame</code>. Let’s populate a <code>PrimitiveDataFrameColumn&lt;double&gt;</code> with a normal distribution and plot a histogram of the samples:</p><pre><code><span>#r "nuget:MathNet.Numerics,4.9.0"</span><span>
</span><span>using</span><span> </span><span>XPlot</span><span>.</span><span>Plotly</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Linq</span><span>;</span><span>
</span><span>using</span><span> </span><span>MathNet</span><span>.</span><span>Numerics</span><span>.</span><span>Distributions</span><span>;</span><span>

</span><span>double</span><span> mean </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span><span>double</span><span> stdDev </span><span>=</span><span> </span><span>0.1</span><span>;</span><span>
</span><span>MathNet</span><span>.</span><span>Numerics</span><span>.</span><span>Distributions</span><span>.</span><span>Normal</span><span> normalDist </span><span>=</span><span> </span><span>new</span><span> </span><span>Normal</span><span>(</span><span>mean</span><span>,</span><span> stdDev</span><span>);</span><span>

</span><span>PrimitiveDataFrameColumn</span><span>&lt;double&gt;</span><span> doubles </span><span>=</span><span> </span><span>new</span><span> </span><span>PrimitiveDataFrameColumn</span><span>&lt;double&gt;</span><span>(</span><span>"Normal Distribution"</span><span>,</span><span> normalDist</span><span>.</span><span>Samples</span><span>().</span><span>Take</span><span>(</span><span>1000</span><span>));</span><span>
display</span><span>(</span><span>Chart</span><span>.</span><span>Plot</span><span>(</span><span>
    </span><span>new</span><span> </span><span>Graph</span><span>.</span><span>Histogram</span><span>()</span><span>
    </span><span>{</span><span>
        x </span><span>=</span><span> doubles</span><span>,</span><span>
        nbinsx </span><span>=</span><span> </span><span>30</span><span>
    </span><span>}</span><span>
</span><span>));</span></code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/Chart.gif" alt="Chart"></p><p>We first create a <code>PrimitiveDataFrameColumn&lt;double&gt;</code> by drawing 1000 samples from a normal distribution and then plot a histogram with 30 bins. The resulting chart is interactive! Hovering over the chart reveals the underlying data and lets us inspect each value precisely.</p><h2>Summary</h2><p>We’ve only explored a subset of the features that <code>DataFrame</code> exposes. <code>Append</code>, <code>Join</code>, <code>Merge</code>, and <code>Aggregations</code> are supported. Each column also implements <code>IEnumerable&lt;T?&gt;</code>, so users can write LINQ queries on columns. The custom <code>DataFrame</code> formatting code we wrote has a simple example. The complete source code(and documentation) for <code>Microsoft.Data.Analysis</code> <a href="https://github.com/dotnet/corefxlab/tree/master/src/Microsoft.Data.Analysis" target="_blank">lives on GitHub</a>. In a follow up post, I’ll go over how to use <code>DataFrame</code> with ML.NET and .NET for Spark. The decision to use column major backing stores (the Arrow format in particular) allows for zero-copy in .NET for Spark User Defined Functions (UDFs)!</p><p>We always welcome the community’s feedback! In fact, please feel free to contribute to the <a href="https://github.com/dotnet/corefxlab/tree/master/src/Microsoft.Data.Analysis" target="_blank">source code</a>. We’ve made it easy for users to create new column types that derive from <code>DataFrameColumn</code> to add new functionality. Support for structs such as <code>DateTime</code> and user defined structs is also not as complete as primitive types such as <code>int</code>, <code>float</code> etc. We believe this preview package allows the community to do data analysis in .NET. Try out <a href="https://www.nuget.org/packages/Microsoft.Data.Analysis/" target="_blank">DataFrame</a> in a <a href="https://mybinder.org/v2/gh/dotnet/interactive/master?urlpath=lab" target="_blank">.NET Jupyter Notebook</a> and let us know what you think!</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>