<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>TomaszRewak/C-sharp-console-gui-framework</h1>
        <p>
by TomaszRewak <br/>Reading time: 14-18 minutes        </p>
        <p><a href="https://github.com/TomaszRewak/C-sharp-console-gui-framework">https://github.com/TomaszRewak/C-sharp-console-gui-framework</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    
        

      <div>
        <article itemprop="text"><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/TomaszRewak/C-sharp-console-gui-framework/workflows/build%20windows/badge.svg"><img src="https://github.com/TomaszRewak/C-sharp-console-gui-framework/workflows/build%20windows/badge.svg" alt=""></a>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/TomaszRewak/C-sharp-console-gui-framework/workflows/build%20linux/badge.svg"><img src="https://github.com/TomaszRewak/C-sharp-console-gui-framework/workflows/build%20linux/badge.svg" alt=""></a>
<a target="_blank" rel="noopener noreferrer" href="https://github.com/TomaszRewak/C-sharp-console-gui-framework/workflows/tests/badge.svg"><img src="https://github.com/TomaszRewak/C-sharp-console-gui-framework/workflows/tests/badge.svg" alt=""></a></p>

<p>ConsoleGUI is a simple layout-driven .NET framework for creating console-based GUI applications.</p>
<p>It provides most essential layout management utilities as well as a set of basic controls.</p>
<p>
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/TomaszRewak/C-sharp-console-gui-framework/blob/master/Resources/example.png?raw=true"><img src="https://github.com/TomaszRewak/C-sharp-console-gui-framework/raw/master/Resources/example.png?raw=true" width="800/"></a>
</p>
<p><em>The example above is not really a playable chess game. The board on the left is simply just a grid with some text in it - it's here for display purposes only. But of course, with a little bit of code behind, it could be made interactive.</em></p>
<h4>Supported platforms</h4>
<p>This framework is platform agnostic and dependency free. The library targets .NET standard 2.0 and should run fine on both Windows and Linux machines.</p>
<h4>Motivation</h4>
<p>What sets this library apart from other projects that provide similar functionalities, is the fact that the ConsoleGUI framework is fully layout-driven. In this regard itâ€™s more like WPF or HTML, than for example Windows Forms. You donâ€™t specify exact coordinates at which a given control should reside, but rather let stack panels, dock panels and other layout managers do their work. I donâ€™t claim itâ€™s THE right way of doing things, itâ€™s just what my background is.</p>
<p>More details about this project (as well as a glimpse at the working example) can be found in this video: <a href="https://youtu.be/YIrmjENTaaU" rel="nofollow">https://youtu.be/YIrmjENTaaU</a></p>
<h2>Setup</h2>
<p>First install the NuGet package:</p>
<div><pre>dotnet add package ConsoleGUI</pre></div>
<p>then include required namespaces in your code:</p>
<div><pre><span>using</span> <span>ConsoleGUI</span>;
<span>using</span> <span>ConsoleGUI</span>.<span>Controls</span>;
<span>using</span> <span>ConsoleGUI</span>.<span>Space</span>;</pre></div>
<p>and finally setup the <code>ConsoleManager</code>:</p>
<div><pre><span><span>//</span> optional: adjusts the buffer size and sets the output encoding to the UTF8</span>
<span>ConsoleManager</span>.<span>Setup</span>();

<span><span>//</span> optional: resizes the console window (the size is set in a number of characters, not pixels)</span>
<span>ConsoleManager</span>.<span>Resize</span>(<span>new</span> <span>Size</span>(<span>150</span>, <span>40</span>));

<span><span>//</span> sets the main layout element and prints it on the screen</span>
<span>ConsoleManager</span>.<span>Content</span> <span>=</span> <span>new</span> <span>TextBlock</span> { <span>Text</span> <span>=</span> <span><span>"</span>Hello world<span>"</span></span> };</pre></div>
<p>And that's it. As you can see most of those steps are optional, depending on how you want to configure your window.</p>
<p>After that, whenever you make a change to any of the controls within the UI tree, the updates will be propagated and displayed automatically. No manual <code>Redraw()</code> calls are required.</p>
<h4>Compatibility mode</h4>
<p>By default, the ConsoleGUI uses the true color formatting to provide the best possible user experience by supporting 16777216 foreground and background colors. Unfortunately this way of formatting is not supported by all terminals. Some of them (depending on the platform and software) support only 16bit colors, or just the 4bit colors defined in the <code>ConsoleColor</code> enum.</p>
<p>Terminals that DO NOT support the true color formatting are (for example): powershell.exe and cmd.exe.</p>
<p>Terminals that DO support the true color formatting are (for example): the new Windows Terminal and the terminal that is built in into the VS.</p>
<p>
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/TomaszRewak/C-sharp-console-gui-framework/blob/master/Resources/Problems.png?raw=true"><img src="https://github.com/TomaszRewak/C-sharp-console-gui-framework/raw/master/Resources/Problems.png?raw=true" width="800/"></a>
</p>
<p>If after starting the application you see the same output as the one on the left, you have to enable the compatibility mode by changing the <code>Console</code> interface used by the framework:</p>
<div><pre><span>ConsoleManager</span>.<span>Console</span> <span>=</span> <span>new</span> <span>SimplifiedConsole</span>();</pre></div>
<p>The <code>SimplifiedConsole</code> translates all of the RGB colors into 4bit values of the ConsoleColor enum. It also prevents the bottom-right character from being printed, to avoid the bug visible on the right image (in some terminals printing the last character can cause the buffer to scroll).</p>
<p>If the output is still being printed incorrectly (or if you want to print it on a non-standard console) you can implement the <code>IConsole</code> interface yourself and set the <code>Console</code> property of the <code>ConsoleManager</code> with the instance of your custom class. Alternatively you can also derive from the <code>StandardConsole</code> class (which is being used by default) and only override its virtual <code>void Write(Position, in Character)</code> method.</p>
<h4>Responsiveness</h4>
<p>If the window size is not set explicitly, the layout will be adjusted to the initial size of that window. It's important to note that this framework doesn't detect terminal size changes automatically (as there is no standard way of listening to such events). If the user resizes the window manually, the layout will become broken.</p>
<p>To adjust the layout to the updated size of the window, remember to call the <code>AdjustBufferSize</code> method of the <code>ConsoleManager</code> on every frame (on every iteration of your program's main loop). It will compare the current window size with its previous value and, if necessary, redraw the entire screen.</p>
<h2>Basic controls</h2>
<p>This is a list of all available controls:</p>
<h5>Background</h5>
<p>Sets the background color of the <code>Content</code> control. If the <code>Important</code> property is set, the background color will be updated even if the stored control already sets its own background color.</p>
<h5>Border</h5>
<p>Draws a border around the <code>Content</code> control. The <code>BorderPlacement</code> and the <code>BorderStyle</code> can be adjusted to change the look of the generated outline.</p>
<h5>Boundary</h5>
<p>Allows the user to modify the <code>MinWidth</code>, <code>MinHeight</code>, <code>MaxWidth</code> and <code>MaxHeight</code> of the <code>Content</code> control in relation to its parent control.</p>
<p>Especially useful to limit the space taken by controls that would otherwise stretch to fill all of the available space (like when storing a <code>HorizontalStackPanel</code> within a horizontal <code>DockPanel</code>)</p>
<h5>Box</h5>
<p>Aligns the <code>Content</code> control vertically (<code>Top</code>/<code>Center</code>/<code>Bottom</code>/<code>Stretch</code>) and horizontally (<code>Left</code>/<code>Center</code>/<code>Right</code>/<code>Stretch</code>).</p>
<h5>BreakPanel</h5>
<p>Breaks a single line of text into multiple lines based on the available vertical space and new line characters. It can be used with any type of control (<code>TextBox</code>, <code>TextBlock</code> but also <code>HorizontalStackPanel</code> and any other).</p>
<h5>Canvas</h5>
<p>Can host multiple child controls, each displayed within a specified rectangle. Allows content overlapping.</p>
<h5>DataGrid</h5>
<p>Displays <code>Data</code> in a grid based on provided column definitions.</p>
<p>The <code>ColumnDefinition</code> defines the column <code>Header</code>, its <code>Width</code> and the data <code>Selector</code>. The <code>Selector</code> can be used to extract text from a data row, specify that cell's color, or even define a custom content generator.</p>
<h5>Decorator</h5>
<p><code>Decorator</code> is an abstract class that allows the user to define custom formatting rules (like applying foreground and background colors based on the content and position of a cell), while preserving the layout of the <code>Content</code> control. See the <code>SimpleDecorator</code> class in the <code>ConsoleGUI.Example</code> project for an example.</p>
<h5>DockPanel</h5>
<p><code>DockPanel</code> consists of two parts: <code>DockedControl</code> and <code>FillingControl</code>. The <code>DockedControl</code> is placed within the available space according to the <code>Placement</code> property value (<code>Top</code>/<code>Right</code>/<code>Bottom</code>/<code>Left</code>). The <code>FillingControl</code> takes up all of the remaining space.</p>
<h5>Grid</h5>
<p>Splits the available space into smaller pieces according to the provided <code>Columns</code> and <code>Rows</code> definitions. Each cell can store up to one child control.</p>
<h5>HorizontalSeparator</h5>
<p>Draws a horizontal line.</p>
<h5>HorizontalStackPanel</h5>
<p>Stacks multiple controls horizontally.</p>
<h5>Margin</h5>
<p>Adds the <code>Offset</code> around the <code>Content</code> control when displaying it. It affects both the <code>MinSize</code> and the <code>MaxSize</code> of the <code>IDrawingContext</code>.</p>
<h5>Overlay</h5>
<p>Allows two controls to be displayed on top of each other. Unlike the <code>Canvas</code>, it uses its own size when specifying size limits for child controls.</p>
<h5>Style</h5>
<p>Modifies the <code>Background</code> and the <code>Foreground</code> colors of its <code>Content</code>.</p>
<h5>TextBlock</h5>
<p>Displays a single line of text.</p>
<h5>TextBox</h5>
<p>An input control. Allows the user to insert a single line of text.</p>
<h5>VerticalScrollPanel</h5>
<p>Allows its <code>Content</code> to expand infinitely in the vertical dimension and displays only the part of it that is currently in view. The <code>ScrollBarForeground</code> and the <code>ScrollBarBackground</code> can be modified to adjust the look of the scroll bar.</p>
<h5>VerticalSeparator</h5>
<p>Draws a vertical line.</p>
<h5>VerticalStackPanel</h5>
<p>Stacks multiple controls vertically.</p>
<h5>WrapPanel</h5>
<p>Breaks a single line of text into multiple lines based on the available vertical space. It can be used with any type of control (<code>TextBox</code>, <code>TextBlock</code> but also <code>HorizontalStackPanel</code> and any other).</p>
<h2>Creating custom controls</h2>
<p>The set of predefined control is relatively small, but it's very easy to create custom ones. There are two main ways to do it.</p>
<h4>Inheriting the <code>SimpleControl</code> class</h4>
<p>If you want to define a control that is simply composed of other controls (like a text box with a specific background and border), inheriting from the <code>SimpleControl</code> class is the way to go.</p>
<p>All you have to do is to set the <code>protected</code> <code>Content</code> property with a content that you want to display.</p>
<div><pre><span>internal</span> <span>sealed</span> <span>class</span> <span>MyControl</span> : <span>SimpleControl</span>
{
	<span>private</span> <span>readonly</span> <span>TextBlock</span> <span>_textBlock</span>;

	<span>public</span> <span>MyControl</span>()
	{
		<span>_textBlock</span> <span>=</span> <span>new</span> <span>TextBlock</span>();

		<span>Content</span> <span>=</span> <span>new</span> <span>Background</span>
		{
			<span>Color</span> <span>=</span> <span>new</span> <span>Color</span>(<span>200</span>, <span>200</span>, <span>100</span>),
			<span>Content</span> <span>=</span> <span>new</span> <span>Border</span>
			{
				<span>Content</span> <span>=</span> <span>_textBlock</span>
			}
		};
	}

	<span>public</span> <span>string</span> <span>Text</span>
	{
		<span>get</span> <span>=&gt;</span> <span>_textBlock</span>.<span>Text</span>;
		<span>set</span> <span>=&gt;</span> <span>_textBlock</span>.<span>Text</span> <span>=</span> <span>value</span>;
	}
}</pre></div>
<h4>Implementing the <code>IControl</code> interface or inheriting the <code>Control</code> class</h4>
<p>This approach can be used to define fully custom controls. All of the basic controls within this library are implemented this way.</p>
<p>The <code>IControl</code> interface requires providing 3 members:</p>
<div><pre><span>public</span> <span>interface</span> <span>IControl</span>
{
	<span>Character</span> <span>this</span>[<span>Position</span> <span>position</span>] { <span>get</span>; }
	<span>Size</span> <span>Size</span> { <span>get</span>; }
	<span>IDrawingContext</span> <span>Context</span> { <span>get</span>; <span>set</span>; }
}</pre></div>
<p>The <code>[]</code> operator must return a character that is to be displayed on the specific position. The position is defined relative to this control's space and not to the screen.</p>
<p>The control can also notify its parent about its internal changes using the provided <code>Context</code>. The <code>IDrawingContext</code> interface is defined as follows:</p>
<div><pre><span>public</span> <span>interface</span> <span>IDrawingContext</span>
{
	<span>Size</span> <span>MinSize</span> { <span>get</span>; }
	<span>Size</span> <span>MaxSize</span> { <span>get</span>; }

	<span>void</span> <span>Redraw</span>(<span>IControl</span> <span>control</span>);
	<span>void</span> <span>Update</span>(<span>IControl</span> <span>control</span>, <span>in</span> <span>Rect</span> <span>rect</span>);

	<span>event</span> <span>SizeLimitsChangedHandler</span> <span>SizeLimitsChanged</span>;
}</pre></div>
<p>If only a part of the control has changed, it should call the <code>Update</code> method, providing a reference to itself and the rect (once again - in its local space) that has to be redrawn. If the <code>Size</code> of the control has changed or the entire control requires redrawing, the control should call the <code>Redraw</code> method of its current <code>Context</code>.</p>
<p>The <code>Context</code> is also used to notify the child control about changes in size limits imposed on it by its parent. The child control should listen to the <code>SizeLimitsChanged</code> event and update its layout according to the <code>MinSize</code> and <code>MaxSize</code> values of the current <code>Context</code>.</p>
<p>When defining a custom control that can host other controls, you might have to implement a custom <code>IDrawingContext</code> class.</p>
<p>Instead of implementing the <code>IControl</code> and <code>IDrawingContext</code> directly, you can also use the <code>Control</code> and <code>DrawingContext</code> base classes. They allow for a similar level of flexibility, at the same time providing more advanced functionalities.</p>
<p>The <code>DrawingContext</code> is an <code>IDisposable</code> non-abstract class that translates the parent's space into the child's space based on the provided size limits and offset. It also ensures that propagated notifications actually come from the hosted control and not from controls that were previously assigned to a given parent.</p>
<p>The <code>Control</code> class not only trims all of the incoming and outgoing messages to the current size limits but also allows to temporarily freeze the control so that only a single update message is generated after multiple related changes are performed.</p>
<p>For more information on how to define custom controls using the <code>IControl</code>/<code>IDrawingContext</code> interfaces or the <code>Control</code>/<code>DrawingContext</code> classes, please see the source code of one of the controls defined within this library.</p>
<h2>Input</h2>
<p>As the standard <code>Console</code> class doesn't provide any event-based interface for detecting incoming characters, the availability of input messages has to be checked periodically within the main loop of your application. Of course, it's not required if your layout doesn't contain any interactive components.</p>
<p>To handle pending input messages, call the <code>ReadInput</code> method of the <code>ConsoleManager</code> class. It accepts a single argument being a collection of <code>IInputListener</code> objects. You can define this collection just once and reuse it - it specifies the list of input elements that are currently active and should be listening to keystrokes. The order of those elements is important, because if one control sets the <code>Handled</code> property of the provided <code>InputEvent</code>, the propagation will be terminated.</p>
<div><pre><span>var</span> <span>input</span> <span>=</span> <span>new</span> <span>IInputListener</span>[]
{
	<span>scrollPanel</span>,
	<span>tabPanel</span>,
	<span>textBox</span>
};

<span>for</span> (<span>int</span> <span>i</span> <span>=</span> <span>0</span>; ; <span>i</span><span>++</span>)
{
	<span>Thread</span>.<span>Sleep</span>(<span>10</span>);
	<span>ConsoleManager</span>.<span>ReadInput</span>(<span>input</span>);
}</pre></div>
<p>The <code>IInputListener</code> interface is not restricted only for classes that implement the <code>IControl</code> interface, but can also be used to define any custom (user defined) controllers that manage application behavior.</p>
<h4>Forms</h4>
<p>As you might have noticed, there is no general purpose <code>Form</code> control available in this framework. Thatâ€™s because itâ€™s very hard to come up with a design that would fit all needs. Of course such an obstacle is not a good reason on its own, but at the same time itâ€™s extremely easy to implement a tailor made form controller within the target application itself. Here is an example:</p>
<div><pre><span>class</span> <span>FromController</span> : <span>IInputListener</span>
{
	<span>IInputListener</span> <span>_currentInput</span>;
	
	<span><span>//</span> ...</span>

	<span>public</span> <span>void</span> <span>OnInput</span>(<span>InputEvent</span> <span>inputEvent</span>)
	{
		<span>if</span> (<span>inputEvent</span>.<span>Key</span>.<span>Key</span> <span>==</span> <span>ConsoleKey</span>.<span>Tab</span>)
		{
			<span>_currentInput</span> <span>=</span> <span><span>//</span> nextInput...</span>
			<span>inputEvent</span>.<span>Handled</span> <span>=</span> <span>true</span>;
		}
		<span>else</span>
		{
			<span>_currentInput</span>.<span>OnInput</span>(<span>inputEvent</span>)
		}
	}
}</pre></div>
<p>After implementing it, all you have to do is to initialize an instance of this class with a list of your inputs and call the <code> ConsoleManager.ReadInput(fromControllers)</code> on each frame.</p>
<p>The biggest strength of this approach is that you decide what is the order of controls within the form, you can do special validation after leaving each input, create a custom layout of the form itself, highlight currently active input, and much, much more. I believe itâ€™s a good tradeoff.</p>
<h2>Mouse</h2>
<p>The ConsoleGUI framework does support mouse input, but it doesnâ€™t create mouse event bindings automatically. That's because intercepting and translating mouse events is a very platform-specific operation that might vary based on the operating system and the terminal you are using.</p>
<p>An example code that properly handles mouse events in the Powershell.exe and cmd.exe terminals can be found in the <code>ConsoleGUI.MouseExample/MouseHandler.cs</code> source file. (To use this example you will have to disable the QuickEdit option of your console window).</p>
<p>When creating your own bindings, all you have to do from the framework perspective, is to set the <code>MousePosition</code> and <code>MouseDown</code> properties of the <code>ConsoleManager</code> whenever a user interaction is detected. For example:</p>
<div><pre><span>private</span> <span>static</span> <span>void</span> <span>ProcessMouseEvent</span>(<span>in</span> <span>MouseRecord</span> <span>mouseEvent</span>)
{
	<span>ConsoleManager</span>.<span>MousePosition</span> <span>=</span> <span>new</span> <span>Position</span>(<span>mouseEvent</span>.<span>MousePosition</span>.<span>X</span>, <span>mouseEvent</span>.<span>MousePosition</span>.<span>Y</span>);
	<span>ConsoleManager</span>.<span>MouseDown</span> <span>=</span> (<span>mouseEvent</span>.<span>ButtonState</span> <span>&amp;</span> <span>0x0001</span>) <span>!=</span> <span>0</span>;
}</pre></div>
<p>The <code>ConsoleManager</code> will take care of the rest. It will find a control that the cursor is currently hovering over and raise a proper method as described in the <code>IMouseListener</code> interface.</p>
<p>
  <a target="_blank" rel="noopener noreferrer" href="https://raw.githubusercontent.com/TomaszRewak/C-sharp-console-gui-framework/master/Resources/input%20example.gif"><img src="https://raw.githubusercontent.com/TomaszRewak/C-sharp-console-gui-framework/master/Resources/input%20example.gif" width="350/"></a>
</p>
<h2>Performance</h2>
<p>This library is designed with high performance applications in mind. It means that if a control requests an <code>Update</code>, only the specified screen rectangle will be recalculated, and only if all of its parent controls agree that this part of the content is actually visible.</p>
<p>As the most expensive operation of the whole process is printing characters on the screen, the <code>ConsoleManager</code> defines its own, additional buffer. If the requested pixel (character) didn't change, it's not repainted.</p>
<h2>Contributions</h2>
<p>I'm open to all sorts of contributions and feedback.</p>
<p>Also, please feel free to request new controls/features through github issues.</p>
</article>
      </div>
  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>