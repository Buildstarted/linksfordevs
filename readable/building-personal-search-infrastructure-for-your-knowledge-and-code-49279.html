<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Building personal search infrastructure for your knowledge and code | beepb00p - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Building personal search infrastructure for your knowledge and code | beepb00p - linksfor.dev(s)"/>
    <meta property="og:description" content="Overview of search tools for desktop and mobile; using Emacs and Ripgrep as desktop search engine"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://beepb00p.xyz/pkm-search.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Building personal search infrastructure for your knowledge and code | beepb00p</title>
<div class="readable">
        <h1>Building personal search infrastructure for your knowledge and code | beepb00p</h1>
            <div>Reading time: 26-34 minutes</div>
        <div>Posted here: 27 Jan 2020</div>
        <p><a href="https://beepb00p.xyz/pkm-search.html">https://beepb00p.xyz/pkm-search.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article>
    
    <section>
    
    <p>Overview of search tools for desktop and mobile; using Emacs and Ripgrep as desktop search engine
    </p></section>
    <!-- are sections appropriate for that? -->

    <section>
    
<div id="outline-container-org0000000">
<h2 id="why"><a href="#why">¶</a><span>1</span> Why search?</h2>
<div id="text-why">
<div><p><span>
Having information in the digital form, collecting and writing notes is incredibly valuable.
Our brains are good at associations, pattern matching and creative thinking, not storing arrays of structured data, and external memory is one of the main thinking hacks computers aid us with. 
</span></p></div>
<p>
However this information is not so useful if you can't access and search it quickly.
Instant search changes the way you think. Ever got sense of flow while working through some problem, and trying different things from Stackoverflow or documentation?
</p>
<p>
These days, if you have decent connection, you are seconds away from finding almost any public knowledge in the internet.
However, there is another aspect of information: personal and specific to <i>your</i> needs, work and hobbies.
It's <i>your</i> todo list, <i>your</i> private notes, books <i>you</i> are reading. Of course, it's not that well integrated with the outside world, hence the tooling and experience of interacting with it is very different.
</p>
<p>
Some examples:
</p>
<ul>
<li><div><p><span>
To find something from <i>my</i> Messenger history with a friend, I need to be online, open Facebook, navigate to search and use the interface Facebook's employees thought convenient (spoiler: it sucks) 
</span></p></div>
<p>
It's <i>my</i> information, something that came out from my brain. Why can't I have it available anywhere, anytime, presented the way I prefer?
</p></li>
<li><p>
To find something in <i>my</i> Kobo ebook, I need to reach my device physically and type the query using the virtual keyboard (yep, e-ink lag!). Not a very pleasant experience.
</p>
<p>
It's something <i>I</i> own and have read. Why does it have to be so hard?
</p></li>
</ul>
<p>
Such things are pretty frustrating to me, so I've been working on making them easier. Search has to be <a href="https://en.wikipedia.org/wiki/Incremental_search">incremental</a>, fast and as convenient to use as possible.
I'll be sharing some of workflows, tricks and thoughts in this post.
</p>
<p>
The post is geared towards using Emacs and Org-mode, but hopefully you'll find some useful tricks for your current tools and workflow even if you don't.
There is (almost) nothing inherently special about Emacs, I'm sure you can achieve similar workflows in other modern text editors given they are flexible enough.
</p>
<p>
Note: throughout the post I will link to my <a href="https://github.com/karlicoss/dotfiles-emacs">emacs config</a> snippets. 
To prevent code references from staling, I use permalinks, but check master branch as well in case of patches or more comments in code.
</p>
</div>
</div>
<div id="outline-container-org0000001">
<h2 id="what"><a href="#what">¶</a><span>2</span> What do I search?</h2>
<div id="text-what">
<p>
I'll write about searching in
</p>
<ul>
<li>my personal notes, tasks and knowledge repository (this blog included)</li>
<li>all digital trace I'm leaving (tweets, internet comments, annotations)</li>
<li>chat logs with people</li>
<li>books and papers I'm reading</li>
<li>code that I'm working on</li>
<li>information on the Internet (duh!)</li>
</ul>
</div>
</div>
<div id="outline-container-org0000004">
<h2 id="personal_information"><a href="#personal_information">¶</a><span>3</span> Searching in personal information</h2>
<p>
By personal information I refer to things like todo list, personal wiki or whatever you use to store information relevant to your life.
</p>
<div id="outline-container-org0000002">
<h3 id="org_mode"><a href="#org_mode">¶</a>Org mode notes</h3>
<div id="text-org_mode">
<p>
For the most part, I keep things in Org mode, and I use Emacs to work with it. Apart from regular means of plaintext search (I'll write about it <a href="#other">later</a>), for me it's important to search over tags:
</p>
<ul>
<li><a href="https://orgmode.org/manual/Matching-tags-and-properties.html"><code>org-tags-view</code></a> is available by default and an easy way to run simple tag searches</li>
<li><p>
<a href="https://github.com/alphapapa/org-ql#screenshots">org-ql</a>
</p>
<p>
It's a relatively new package, with new query syntax as the main feature, which is much easier to use and remember than builtin Org query syntax: <a href="https://github.com/alphapapa/org-ql#comparison-with-org-agenda-searches">comparison</a>.
</p>
<p>
I mainly use these commands:
</p>
<ul>
<li><a href="https://github.com/alphapapa/org-ql#helm-org-ql"><code>helm-org-ql</code></a> for <b>incremental</b> search in the current buffer</li>
<li><a href="https://github.com/alphapapa/org-ql#org-ql-search"><code>org-ql-search</code></a> <b>interactively</b> prompts you for the search target, sort and grouping</li>
</ul></li>
</ul>
<p>
Another notable mention is <a href="https://github.com/alphapapa/org-rifle#screenshots">org-rifle</a>, which is an entry based search, presenting headings along with the matched content in Helm buffer.
However as the author <a href="https://github.com/alphapapa/org-rifle/issues/42#issuecomment-544114082">mentioned</a> it might be obsoleted by org-ql soon. 
</p>
<p>
Here are some typical workflows with my org-mode:
</p>
<ul>
<li><p>
<a id="friends_tags"></a> tags for friends
</p>
<p>
I see an interesting article or think of something which would be good to share with a friend, but at the moment it's not quite a good time to send it.  I can just capture it and attach a tag (e.g. <samp>ann</samp> or <samp>jeremy</samp>). That way next time we chat I can just look up things under their tag and send them.
</p>
<p>
It works the other way around as well: imagine they sent me a link or asked me to do something, but I can't do it immediately. I have a special script that converts chat messages into todo items and automatically attaches the corresponding tag. I write more about it <a href="https://beepb00p.xyz/orger-todos.html#telegram2org">here</a>.
</p></li>
<li><p>
assembling blog posts
</p>
<p>
Unfortunately, I can't just sit and write comprehensible texts without preparation.
Typically I have thoughts on the topic now and then, which I just note down and mark with the tag.
When I feel it's time to prepare the post, I can just search by the tag (e.g. <code>tags:search</code> for this post), and refile the items into the file with the post draft.
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org0000003">
<h3 id="other"><a href="#other">¶</a>Other plaintext, chats and social media</h3>
<div id="text-other">
<p>
As I mentioned, I find having to switch to the browser, wait till the website loads and cope with crappy search implementations very distracting and frustrating.
</p>
<p>
What is more, often you don't even remember whether exactly you were discussing something: on Telegram or Facebook or Reddit? So having a single point of entry to your information and unified search over all of your stuff is extremely helpful.
</p>
<p>
For instant messaging, I'm using plaintext mirrors, so chat history is always available in plaintext on my computers:
</p>
<ul>
<li><a href="https://github.com/karlicoss/telegram-backup-to-txt">Telegram messages</a>
Didn't bother with org-mode because files would be too huge and there isn't much structure anyway.</li>
<li><a href="https://github.com/Totktonada/vk_messages_backup">Vkontakte messages</a>
Sadly export tool stopped working because of API restrictions, but I'm not using VK much anymore either. At least I got historic messages.</li>
</ul>
<p>
Most services where I can comment, write or leave annotation, I'm mirroring as org-mode.
I write about it in detail here: <a href="https://beepb00p.xyz/orger.html">part I</a>, <a href="https://beepb00p.xyz/orger-todos.html">part II</a>.
</p>
<p>
That gives me source data for a search engine over anything I've ever:
</p>
<ul>
<li>tweeted</li>
<li>bookmarked on Pinboard</li>
<li>highlighted in Instapaper or Kobo</li>
<li>saved or upvoted on Reddit</li>
<li>etc., etc.</li>
</ul>
<p>
All these files are either non-Org or somewhat heavy for structured Org-mode search. In addition, I have many old files from my pre-orgmode era when I was using Gitit or Zim.
</p>
<p>
To search over them, I'm using Emacs and Ripgrep (you can read why <a href="#ripgrep">later</a>):
</p>
<p>
<a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L130-L134"><code>my/search</code></a>
runs ripgrep against <code>my/search-targets</code> variable contains paths to notes, chat logs, Orger outputs etc.
</p>
<p>
The interesting bit about <code>my/search</code> is <a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L87-L127"><code>--my/one-off-helm-follow-mode</code></a> call. It's a somewhat horrible hack that  automatically enables helm-follow mode so you don't have to press <code>C-c C-f</code> every time you invoke helm.
</p>
<p>
Finally, to make sure I can invoke search in an instance, I'm using a <a href="#snippet_other">global keybinding</a>.
</p>
<p>
Here's a <b>demo</b> <a href="https://file.globalupload.io/wu7HYYyJaY.gif">gif (5Mb)</a> of using this to search 'greg egan' in my knowledge repository.
You can see that as a result, I'm getting my Kobo highlights (<samp>kobo.org</samp>), my reading list (<samp>read.org</samp>) and even some video (<samp>youtube.org</samp>)!
</p>
</div>
</div>
</div>
<div id="outline-container-org0000005">
<h2 id="recoll"><a href="#recoll">¶</a><span>4</span> Recoll</h2>
<div id="text-recoll">
<p>
Recoll is an indexer that runs as daemon (or a regular cron job) and a full text search tool.
</p>
<p>
It supports many <a href="https://www.lesbonscomptes.com/recoll/features.html">formats and other features</a>, so I suggest checking them out for yourself.
</p>
<p>
Even though I index all my documents, I find it quicker to run grep I described above to search in plaintext. 
So for me, Recoll is mostly for searching and quickly jumping to results in <b>PDFs and EPUBs</b> (see <a href="https://www.lesbonscomptes.com/recoll/pics/recoll-pdf-snippets.html">screenshot</a>).
</p>
<p>
There is <a href="https://github.com/emacs-helm/helm-recoll">helm-recoll</a> Emacs module, but I found it a bit awkward to use, and Recoll GUI feels significantly superior.
Basically only thing helm-recoll does is presenting you list of filenames that match your query.
It feels that it should be straightforward to modify the module and integrate abstract, snippets and other things you can query Recoll for.
</p>
<p>
Considering I don't need use Recoll it too often, I just gave up on helm-recoll and using GUI.
</p>
<p>
I'm also running a <a href="https://github.com/koniu/recoll-webui">Web UI</a> on my VPS, so I can use it from my phone, or potentially from other computers.
</p>
<p>
Recoll's distinguishing features are proper <a href="https://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.SEARCH.LANG.html">search query language</a>
and <a href="https://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.INDEXING.MONITOR.html">realtime, inotify based indexing</a>.
I don't have that much data yet to benefit massively from proper search queries, but I can see that it could be potentially useful in future as amount of personal data grows.
</p>
</div>
</div>
<div id="outline-container-org0000009">
<h2 id="android"><a href="#android">¶</a><span>5</span> Searching on Android</h2>
<div id="text-android">
<p>
Most of my notes and knowledge repository are plaintext, so it is easily and continuously shared on my phone via Dropbox/Syncthing.
</p>
<p>
Since using Emacs on Android is hardly a meaningful experience, I'm working around it by using other apps.
</p>
</div>
<div id="outline-container-org0000006">
<h3 id="org0000006"><a href="#org0000006">¶</a><a href="https://github.com/orgzly/orgzly-android">Orgzly</a></h3>
<div id="text-org0000006">
<p>
I can't recommend it enough, it's got many things done right, very fast and the code is extremely readable and well tested so it's easy to contribute.
</p>
<p>
It has its own small <a href="http://www.orgzly.com/help#search">query language</a> (at the time <a href="https://github.com/alphapapa/org-ql">org-ql</a> didn't exist).
</p>
<p>
You can save <a href="https://lh3.googleusercontent.com/FweBE2T3T3wZwJC64DQgtGj8vv8jKPBGTClnRAApSOHdKq4hiFdpq_JjEBPsMj_nTDA=w2560-h1295">search queries</a>, which ends up being pretty similar to custom Org-mode <b><b>agendas</b></b>.
Searches can be displayed as persistent widgets, e.g. I find convenient to have a phone screen dedicated to 'Buy' search (<code>t.buy</code> query) or 'Do at work' search (<code>t.@work</code> query).
</p>
<p>
As I described <a href="#friends_tags">above</a>, I keep few saved search queries for some friends so I can recall what I wanted to discuss with them.
</p>
</div>
</div>
<div id="outline-container-org0000007">
<h3 id="org0000007"><a href="#org0000007">¶</a><a href="https://play.google.com/store/apps/details?id=com.docsearch.pro">Docsearch +</a></h3>
<div id="text-org0000007">
<p>
Docsearch is a not very well-known tool (e.g. zero search results on Reddit or Twitter), but I don't know any alternatives for it.
</p>
<p>
It's a fulltext indexing and search app for plaintext files, but apparently it even supports EPUBs and PDFs.
<a href="https://lh3.googleusercontent.com/psPhmFoawEzwZQpwBGgVz42ojnR-uAi70Li4DBc4Z13wLOTannvT2suaxZQA9YX_Bg=w2560-h1295">Here's</a> how matches list looks. Screenshots on Google Play give a pretty good idea what the app does.
</p>
<p>
I find it convenient for quick search over things that are not imported in Orgzly, e.g. <samp>.txt</samp> chat logs (Telegram, VK) and huge org-mode files
I described <a href="#other">above</a>.
</p>
<p>
It's a bit backwards in terms of UI (even though I like that it's compact and functional), but main downside is it's not opensource.
I'd be extremely happy to replace this with some open source application, so please let me know if you know one!
</p>
</div>
</div>
<div id="outline-container-org0000008">
<h3 id="recoll_web"><a href="#recoll_web">¶</a>Recoll Web</h3>
<p>
On the rare occasions when I need to search in pdfs or books (which I don't sync on my phone) , I just use Recoll <a href="https://github.com/koniu/recoll-webui">Web UI</a> that I'm selfhosting.
</p>
</div>
</div>
<div id="outline-container-org000000c">
<h2 id="web"><a href="#web">¶</a><span>6</span> Web search</h2>
<div id="text-web">
<p>
If you're reading this at all, chances you're quite good at using web search already. <a href="https://www.gwern.net/Search#search">Gwern</a> got a good writeup on the subject.
</p>
<p>
Knowing how to compose a search query is one thing, but navigating to the service, waiting till it loads, moving to searchbox takes precious time. Many people forget about <a href="https://www.howtogeek.com/114176/how-to-easily-create-search-plugins-add-any-search-engine-to-your-browser">custom search engines</a>. Here are ones I'm using:
</p>
<table>
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td>g</td>
<td>Google</td>
<td><code>https://www.google.com/complete/search?client=firefox&amp;q={searchTerms}</code></td>
</tr>
<tr>
<td>d</td>
<td>DuckDuckGo</td>
<td><code>https://duckduckgo.com/?q={searchTerms}&amp;t=canonical</code></td>
</tr>
<tr>
<td>r</td>
<td>Reddit</td>
<td><code>https://www.reddit.com/search?q={searchTerms}</code></td>
</tr>
<tr>
<td>gh</td>
<td>GitHub</td>
<td><code>https://github.com/search?q={searchTerms}&amp;ref=opensearch</code></td>
</tr>
<tr>
<td>pin</td>
<td>Pinboard: search all</td>
<td><code>https://pinboard.in/search/?query={searchTerms}r&amp;all=Search+All</code></td>
</tr>
<tr>
<td>tw</td>
<td>Twitter</td>
<td><code>https://twitter.com/search</code></td>
</tr>
<tr>
<td>hn</td>
<td>hackernews</td>
<td><code>https://hn.algolia.com/?dateRange=all&amp;page=0&amp;prefix=true&amp;query={searchTerms}&amp;sort=byPopularity&amp;type=all</code></td>
</tr>
<tr>
<td>y</td>
<td>YouTube</td>
<td><code>https://www.youtube.com/results?search_query={searchTerms}&amp;page={startPage?}&amp;utm_source=opensearch</code></td>
</tr>
<tr>
<td>m</td>
<td>Google Maps</td>
<td><code>https://www.google.com/maps/search/{searchTerms}?hl=en&amp;source=opensearch</code></td>
</tr>
<tr>
<td>w</td>
<td>Wikipedia (en)</td>
<td><code>https://en.wikipedia.org/wiki/Special:Search</code></td>
</tr>
<tr>
<td>tl</td>
<td>Google Timeline</td>
<td><code>https://www.google.com/maps/timeline?pb=!1m2!1m1!1s{searchTerms}</code></td>
</tr>
<tr>
<td>cpp</td>
<td>Cppreference</td>
<td><code>https://en.cppreference.com/mwiki/index.php?search={searchTerms}</code></td>
</tr>
<tr>
<td>js</td>
<td>MDN</td>
<td><code>https://developer.mozilla.org/en-US/search?q={searchTerms}</code></td>
</tr>
<tr>
<td>eb</td>
<td>Ebay</td>
<td><code>https://www.ebay.co.uk/sch/i.html?_nkw={searchTerms}</code></td>
</tr>
<tr>
<td>am</td>
<td>Amazon.co.uk</td>
<td><code>https://www.amazon.co.uk/exec/obidos/external-search/</code></td>
</tr>
<tr>
<td>th</td>
<td>thesaurus</td>
<td><code>https://www.powerthesaurus.org/{searchTerms}/synonyms</code></td>
</tr>
<tr>
<td>tru</td>
<td>Translate en-ru</td>
<td><code>https://translate.google.com/#view=home&amp;op=translate&amp;sl=en&amp;tl=ru&amp;text={searchTerms}</code></td>
</tr>
<tr>
<td>tde</td>
<td>Translate en-de</td>
<td><code>https://translate.google.com/#view=home&amp;op=translate&amp;sl=en&amp;tl=de&amp;text={searchTerms}</code></td>
</tr>
<tr>
<td>dd</td>
<td>DevDocs</td>
<td><code>https://devdocs.io/#q={searchTerms}</code></td>
</tr>
<tr>
<td>em</td>
<td>emoji</td>
<td><code>https://emojipedia.org/search/?q={searchTerms}</code></td>
</tr>
</tbody>
</table>
<p>
Some of these obvious, some deserve a separate mention:
</p>
<ul>
<li><p>
reddit contains vast amounts of (somewhat curated) human knowledge
</p>
<p>
Google search often gives dubious and not very meaningful results on certain topics (e.g. product reviews, exercise, dieting).
On reddit, you'd at least find real people sharing their <b>honest and real opinions</b>.
Chances are that if a link is good, you would find it on  on reddit anyway.
</p></li>
<li><p>
twitter is similar: there is certainly more spam there, but sometimes it's interesting to type a link or blog post title in twitter search to see how <b>real people reacted</b>. 
</p>
<p>
That has limited utility, e.g. doesn't work with politicized content, but if the topic of interest is rare, could be very useful.
</p></li>
<li>hackernews: good source of knowledge and high quality discussions for tools and tecnhologies</li>
<li><a href="https://pinboard.in/">pinboard</a> is an awesome source of curated content as well</li>
</ul>
<p>
Next, I find it very convenient to have some code documentation available locally.
First, it helps when you're on wonky internet or just offline for whatever reason.
Second, it's feels <b>really fast</b>, even if you're on fiber.
</p>
<p>
Here's what I'm using for that:
</p>
<table>
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td>py</td>
<td><samp>file:///usr/share/doc/python3/html/search.html?q=%s</samp></td>
</tr>
<tr>
<td>rust</td>
<td><samp>file:///home/karlicos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/share/doc/rust/html/std/option/index.html?search=%s</samp></td>
</tr>
</tbody>
</table>
<p>
Sadly, the extension mentioned above doesn't work with <samp>file://</samp> schema for some reason, so to add it in Firefox,
you can use the method described <a href="https://superuser.com/a/7336/300795">here</a>, it's as easy as adding a bookmark.
</p>
<p>
Recently I ran into <a href="https://devdocs.io/offline">devdocs.io</a>, it's using your browser's <b>offline</b> storage to cache the documentation.
I'm still getting used to it, but it's amazing how faster it is than jumping to documentation online. You can use it with multiple languages, you just type the search engine prefix first, and then language prefix (e.g. <code>dd cpp emplace_back</code>).
</p>
<p>
Finally, it may be convenient to set up <a href="https://github.com/hrs/engine-mode">engine-mode</a> in Emacs, or <a href="https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Bweb-services/search-engine">search-engine layer</a> in Spacemacs. It lets you invoke a browser search directly from Emacs (e.g. <code>SPC s G</code> to do google search). I find it convenient when I need to search many things in bulk.
</p>
</div>
<div id="outline-container-org000000a">
<h3 id="org000000a"><a href="#org000000a">¶</a>Firefox enhancements</h3>
<p>
I find it convenient to enable <a href="https://www.ghacks.net/2016/06/11/firefox-page-search-improvements">'highlight all'</a> for search within a page.
</p>
</div>
<div id="outline-container-org000000b">
<h3 id="org000000b"><a href="#org000000b">¶</a>Chrome enhancements</h3>
<div id="text-org000000b">
<p>
When I used Chrome, one thing that annoyed me was that it populates search engines automatically, and <a href="https://support.google.com/chrome/forum/AAAAP1KN0B0DOS1J_u6N8I">there is not way to disable it</a>.
</p>
<p>
There is a nice open source <a href="https://chrome.google.com/webstore/detail/dont-add-custom-search-en/dnodlcololidkjgbpeoleabmkocdhacc">extension</a> that prevents Chrome from doing it.
</p>
</div>
</div>
</div>
<div id="outline-container-org0000011">
<h2 id="code"><a href="#code">¶</a><span>7</span> Searching in code</h2>
<p>
TLDR: I tried different existing code search tools, was disappointed and ended up using Emacs + Ripgrep.  
</p>
<div id="outline-container-org000000d">
<h3 id="org000000d"><a href="#org000000d">¶</a>Why?</h3>
<div id="text-org000000d">
<p>
I've got lots of personal projects, experiments, data processing and backup scripts on my computer.
I also tend to create a git repository at a slightest opportunity primarily as a means of code backup/rollback and progress tracking, but often it results in actual projects, so I would need a repository anyway.
Naturally, these repositories end up scattered across the whole filesystem, making it tricky to remember where I've put the code or that it even existed in the first place.
</p>
<p>
It's very convenient to have some sort of code search engine if you're in a similar situation to mine for multiple reasons:
</p>
<ul>
<li><p>
Doing potentially breaking code changes
</p>
<p>
For instance, I want to remove some unused function or refactor something in <a href="https://github.com/karlicoss/my"><code>my</code></a> package, which is a Python library to access my personal data.
It's used in lots of scripts or dashboards that run in Cron every day.
</p>
<p>
I could just go for it, remove the function and hope nothing fails, but if it does then I'd have to deal with fixing it again.
It's frustrating and I'd rather search for function usages in all of my code and make sure it's actually safe to remove.
</p></li>
<li><p>
Reusing code snippets and tricks
</p>
<p>
When you're getting familiar to some new library or framework, you often end up googling how to solve problems twice.
Sometimes you remember solving the problem you've already had, but don't quite recall where. 
</p>
<p>
For instance for me, such library is <a href="https://docs.sqlalchemy.org/en/13/core">Sqlalchemy</a>.
It's very convenient for handling databases, but I only need it infrequently, so can never remember how to work with it.
Reading documentation all over again is not very helpful because I've got very few usecases and queries that are specific to my purposes.
</p>
<p>
If I can search for <code>sqlalchemy</code> in my code, it shows every repository where I used it so I can quickly copy bit of code I'm interested at.
</p></li>
<li><p>
Forgotten code
</p>
<p>
It happens that I remember writing code for some purpose, but don't quite recall where I put it.
Even if you keep all your repos in the same location, you might forget how you named it.
</p>
<p>
Full text search, however, allows to find it if you remember some comments or class/function names.
</p></li>
<li><p>
Help and documentation
</p>
<p>
However good is library's documentation, sometimes it just isn't covering your typical needs. If you're a power user, docs are almost never enough and you end up reading the code to bend the library into doing what you want.
</p>
<p>
For me such libraries are <a href="https://code.orgmode.org/bzg/org-mode">Org mode</a> or <a href="https://github.com/jaspervdj/hakyll">Hakyll</a>, so I often had to search in their code on Github.
Searching on Github however is quite awkward. It's slow, it's not incremental and lacks navigation.
</p>
<p>
If I have a local clone of the repository on my disk, I can search over it in an instant (without having it opened in the first place) and use familiar tools (e.g. IDE) for navigation.
</p></li>
</ul>
<p>
At the time, I was just using recursive <code>grep</code> and then opening some of results in vim to refine.
That's a pretty pathetic workflow. 
</p>
</div>
</div>
<div id="outline-container-org000000e">
<h3 id="org000000e"><a href="#org000000e">¶</a>What do I want</h3>
<div id="text-org000000e">
<p>
My ideal code search tool would:
</p>
<ul>
<li><p>
run against code on my filesystem
</p>
<p>
Just any source files, so it wouldn't have to fetch repositories from Github and keep them somewhere separately.
</p></li>
<li><p>
realtime indexing 
</p>
<p>
Ideally, inotify-based, but any means of refreshing search index without having to commit first would be nice.
</p></li>
<li>semantic search in definitions/variables etc with fallback to simple search if the language isn't supported</li>
</ul>
</div>
</div>
<div id="outline-container-org000000f">
<h3 id="org000000f"><a href="#org000000f">¶</a>Existing code search tools</h3>
<div id="text-org000000f">
<p>
So, I wanted some code search and indexing tool that could watch over all the source file on my filesystem and let me search through them.
</p>
<p>
It sounds as a fairly straightforward wish, but to my surprise, none of existing projects I found and tried do the job:
</p>
<ul>
<li><p>
<a href="https://github.com/sourcegraph/sourcegraph">Sourcegraph</a>
</p>
<p>
Lets you index Github/Bitbucket/Gitlab repos etc, but the process for adding local repositories <a href="https://docs.sourcegraph.com/admin/repo/add_from_local_disk">is extremely tedious</a>.
Also apparently, it clones repositories first so it's not exactly realtime indexing.
</p>
<p>
Overall, I feel that it only makes sense for companies that use few monorepos.
</p></li>
<li><a href="https://oracle.github.io/opengrok">OpenGrok</a>: <a href="https://github.com/oracle/opengrok/wiki/How-to-setup-OpenGrok">setup</a> looks extremely heavy, doesn't support realtime search in arbitrary paths</li>
<li><a href="https://github.com/hound-search/hound">Hound</a>: <a href="https://github.com/hound-search/hound/issues/83">doesn't support</a> recursive repository discovery.</li>
<li><a href="https://github.com/google/zoekt">zoekt</a>: manual is pretty confusing and also looks tailored for huge standalone repos</li>
<li><a href="https://livegrep.com/">Livegrep</a>: tailored to huge monorepos (see <a href="https://news.ycombinator.com/item?id=3869880">HN discussion</a>)</li>
</ul>
<p>
As you can see, none of these are convenient for searching in personal code.
</p>
</div>
</div>
<div id="outline-container-org0000010">
<h3 id="org0000010"><a href="#org0000010">¶</a>Solution: use Emacs and Ripgrep</h3>
<div id="text-org0000010">
<p>
Disappointed, I figured that least I could do is at somehow improve my workflow with grep.
</p>
<p>
So, what are the problems with using <code>grep</code>?
</p>
<ul>
<li>running it against all of code results in false positives. <samp>node_modules</samp>, minified javascript, etc., you name it
<ul>
<li>you probably want to at least ignore anything that's ignored by <code>.gitignore</code></li>
</ul></li>
<li>getting bunch of output lines in terminal is not interactive
<ul>
<li>you have to repeat the command to refine the results</li>
<li>you can't quickly navigate to the result, check it and go back</li>
</ul></li>
<li>running it recursively against your filesystem root is ridiculously slow, even if you use an SSD
<ul>
<li>you probably want to restrict your search to directories that look like a project (e.g. repositories), and again, exclude files ignored by version control</li>
</ul></li>
</ul>
<p>
<a id="ripgrep"></a>
As it turns out, <code>ripgrep</code> is the tool!
</p>
<ul>
<li>respects <code>.gitignore</code> files, so by maintaining <code>.gitignore</code> properly (e.g. adding <samp>node_modules/venv</samp> etc) you can make sure you only get <b>meaningful matches</b> when searching for code.</li>
<li>respects <code>.ignore</code> files. Sometimes code has to be under version control, but you don't want it to show up in search (e.g. could happen if you have vendorized code or minified javascript or static html files).
In that case you can use <code>.ignore</code> files with the same syntax to exclude certain patterns from ripgrep's reach without messing with <code>.gitignore</code>.</li>
<li>it's <b>very</b> fast, both by <a href="https://github.com/BurntSushi/ripgrep#quick-examples-comparing-tools">benchmarks</a> and subjective experiments. You can read more comprehensive benchmarks <a href="https://blog.burntsushi.net/ripgrep/#code-search-benchmarks">here</a>.</li>
</ul>
<p>
If you just use ripgrep instead of grep, code search becomes magnitude more pleasant, but it's still not interactive. Long story short, we can use <code>helm</code> in Emacs to achieve <b>interactivity</b> and incremental search.
</p>
<p>
The only thing that's left is restricting the search to git repositories only.
Ripgrep relies on regexes, so we can't do something like Xpath queries and tell it to only search in directories, that contain <code>.git</code> directory. I ended up using a two step approach:
</p>
<ul>
<li><p>
first, <a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L75-L83"><code>my/code-targets</code></a> returns all git repositories it can reach from <code>my/git-repos-search-root</code>.
</p>
<p>
I'm using <a href="https://github.com/sharkdp/fd"><code>fd</code></a> to go through the disk and collect all candidate git repositories.
</p>
<p>
Even though fd is already ridiculously <a href="https://github.com/sharkdp/fd#benchmark">fast</a>, this step still takes some time, so I'm caching the repositories. Cache is refreshed in the background every five minutes so we don't have to crawl the filesystem every time. That saves me few seconds on every search.
</p></li>
</ul>
<ul>
<li>then, <a href="https://github.com/karlicoss/dotfiles-emacs/blob/4ea7a8deb48403cea712f1bd48b553b465da05f4/.spacemacs.d/config.el#L136-L140"><code>my/search-code</code></a> keybindings invokes <code>ripgrep</code> against all my directories with code, defined in <code>my/code-targets</code> function.</li>
</ul>
<p>
So, literally running grep against my code turned out to be a pretty good solution. I've got about 350 repositories and it works in a blink. Note, however, that I'm using SSD.
</p>
<p>
Ripgrep searches in real files on my disk, so any changes are reflected <b>immediately</b>, which removes the need for indexing (apart from performance concerns if you've got too many files to search in).
It would still be nice to avoid unnecessary disk operations, and of course, semantic search would be great, and that is definitely going to require some sort of indexer.
</p>
<p>
I've got a <a href="#snippet_code">global keybinding</a> to invoke Emacs with a prompt to search in code, so I can do in in a blink.
</p>
<p>
Here's a <a href="https://file.globalupload.io/onCac7sh9M.gif">gif (3.5 Mb)</a> showing it <b>in action</b>: say, I am working on testing a browser extension, and need to interact with in via hotkeys. I remember using <code>pyautogui</code> for automating <a href="https://github.com/karlicoss/grasp">Grasp</a> tests, but I forgot which function I actually need to use. Searching for 'pyautogui' brings me all the repositories where I'm using it and lets me quickly find out the command I need without having to read the documentation all over again.
</p>
</div>
</div>
</div>
<div id="outline-container-org0000012">
<h2 id="appendix_cloudmacs"><a href="#appendix_cloudmacs">¶</a><span>8</span> Appendix: searching away from computer</h2>
<p>
I'm running Spacemacs on my VPS, so if I'm not near my computer and <a href="#android">phone search</a> doesn't help for some reason, I can still access and search my data. You can read about it <a href="https://beepb00p.xyz/cloudmacs.html">here</a>.
</p>
</div>
<div id="outline-container-org0000014">
<h2 id="appendix_daemon"><a href="#appendix_daemon">¶</a><span>9</span> Appendix: Lightning fast Emacs</h2>
<div id="text-appendix_daemon">
<p>
As you might have noticed, I'm relying on Emacs as my primary means of interacting with my information, whether it's capturing, accessing or searching.
That means that I want it as fast as possible, in a matter of milliseconds. Seconds spent waiting to launch discourage break your concentration and workflow.
</p>
<p>
Most of the time I've got Emacs window open on one of my desktops anyway, but sometimes it isn't, or I don't want to pollute the current Emacs instance with my search. So I've got a handy helper <a href="https://github.com/karlicoss/dotfiles-emacs/blob/master/bin/gemacsclient">script</a> to quickly invoke persistent Emacs frame for me:
</p>
<div>
<pre><span>bash</span>









<span>ARGS</span>=(
 
 
 
 -a <span>''</span>

 
 --create-frame 
 --frame-parameters=<span>"'(fullscreen . maximized)"</span>

 
 --eval
  
 <span>'(select-frame-set-input-focus (selected-frame))'</span>
)


<span>exec</span> emacsclient <span>"${ARGS[@]}"</span> <span>\</span>
                 <span>"$@"</span>          
</pre>
</div>
<p>
I've got a global keybinding (<code>Win+m</code>) that invokes this script. In addition the script accepts a function to call so you can open Emacs with a search prompt, so I have few more handy keybindings:
</p>
<ul>
<li><a id="snippet_other"></a> <code>Win+F1</code> for searching in my <a href="#other">notes and knowledge repository</a></li>
</ul>
<div>
<pre><span>bash</span>
<span>exec</span> <span>"~/bin/gemacsclient"</span> <span>"(spacemacs/defer-until-after-user-config #'my/search)"</span>
</pre>
</div>
<ul>
<li><a id="snippet_code"></a> <code>Win+F3</code> for searching in my repositories</li>
</ul>
<div>
<pre><span>bash</span>
<span>exec</span> <span>"~/bin/gemacsclient"</span> <span>"(spacemacs/defer-until-after-user-config #'my/search-code)"</span>
</pre>
</div>
<ul>
<li><code>Win+a</code> to open my org-mode agenda</li>
</ul>
<div>
<pre><span>bash</span>
<span>exec</span> <span>"~/bin/gemacsclient"</span> <span>"(spacemacs/defer-until-after-user-config #'my/switch-to-agenda)"</span>
</pre>
</div>
<ul>
<li><code>Win+c</code> to open org-capture</li>
</ul>
<div>
<pre><span>bash</span>
<span>exec</span> <span>"~/bin/gemacsclient"</span> <span>"(spacemacs/defer-until-after-user-config #'org-capture)"</span>
</pre>
</div>
</div>
<div id="outline-container-org0000013">
<h3 id="org0000013"><a href="#org0000013">¶</a>running daemon on startup</h3>
<div id="text-org0000013">
<p>
It might be convenient to always have the daemon running, for that I'm using a systemd unit in <samp>~/.config/systemd/user/emacs-daemon.service</samp>.
</p>
<div>
<pre>[Unit]
<span>Description</span>=Emacs daemon

[Service]
<span>Type</span>=forking

<span>ExecStart</span>=/bin/bash -l -c <span>'/usr/bin/emacs --daemon'</span>
<span>ExecStop</span>=/usr/bin/emacsclient --eval <span>"(kill-emacs)"</span>
<span>Environment</span>=<span>SSH_AUTH_SOCK</span>=%t/keyring/ssh
<span>Restart</span>=always

[Install]
<span>WantedBy</span>=default.target
</pre>
</div>
<p>
It's nothing unusual perhaps apart from using <code>bash -l</code> so Emacs picks up your <code>.profile</code> file. Without it, you almost certainly will encounter issues with missing binaries because they would not be in your <code>PATH</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-org0000015">
<h2 id="appendix_emacs"><a href="#appendix_emacs">¶</a><span>10</span> Appending: general Emacs tips</h2>
<div id="text-appendix_emacs">
<p>
These tips might be pretty obvious, but they belong to this post, so here you go:
</p>
<ul>
<li>if you're on Spacemacs, use <a href="https://github.com/syl20bnr/spacemacs/tree/develop"><code>develop</code></a> branch. Master is pretty backwards.</li>
<li><p>
search with <code>ripgrep</code> instead of <code>grep</code> (not only in Emacs!). It's just <a href="#ripgrep">better</a>.
</p>
<p>
In Spacemacs, set up your <code>init.el</code>:
</p></li>
</ul>
<div>
<pre>dotspacemacs-search-tools '(<span>"rg"</span> <span>"ag"</span> <span>"pt"</span> <span>"ack"</span> <span>"grep"</span>)

dotspacemacs-additional-packages '(helm-rg)
</pre>
</div>
<ul>
<li><p>
use <a href="https://github.com/emacsorphanage/helm-swoop"><code>helm-swoop</code></a> for search within the buffer
</p>
<p>
It's easier to watch a <a href="https://raw.githubusercontent.com/ShingoFukuyama/images/master/helm-swoop.gif">demo GIF</a> than to explain.
Swoop opens a Helm window with search result summary and jumps between results in the original buffer as you navigate in helm (<code>C-j/C-k</code>).
</p>
<p>
I <b><b>highly</b></b> recommend it as a primary way of searching withing a buffer. Bind it it to some convenient combination and get used to it (e.g. mine is <code>SPC RET</code>).
</p>
<p>
There is also <code>helm-occur</code>, which has similar functionality, but it seems inferior to swoop.
</p></li>
<li><p>
use <code>helm-follow-mode</code> (<code>C-c C-f</code> in Helm buffer) to jump between search results in any Helm search
</p>
<p>
E.g. you can use it with <code>helm-org-in-buffer-headings</code> as a neat way to navigate within an Org file.
</p></li>
</ul>
</div>
</div>
<div id="outline-container-org0000016">
<h2 id="future"><a href="#future">¶</a><span>11</span> Future and my holy grail of search</h2>
<div id="text-future">
<p>
My ultimate goal is to have my 'external' knowledge as highly integrated as possible, as if it was imprinted on my brain neurons. 
</p>
<p>
  Ideally I want to be able to do fulltext realtime search over anything that I ever had in my visual field.
Not even necessarily text, but audio and video as well.
</p>
<p>
That way one wouldn't have to distinguish between different services and mediums of information at all, be it digital or analogue.
</p>
<p>
Technically it's not impossible with the current technology:
</p>
<ul>
<li>I believe that state of OCR is pretty good considering existence of products like google instant translate</li>
<li>speech recognition still sucks in noisy environments, but generally works</li>
<li>object recognition and annotation is still at dawn (I think?), but we'll get there eventually</li>
<li>that would be a lot of data, but potentially lots of it can be filtered out (at least until storage gets really compact and cheap to justify keeping everything)</li>
<li>processing and indexing don't have to be realtime as you can still rely on biological memory and could work overnight on expensive (but not astronomically so?) hardware</li>
<li>plaintext indexes can potentially be stored on your phone and you could have some sort of backend to access visual component</li>
<li>to jump back to the content digital media (like e-books/web pages/information screens) could aid this by supplying QR code or something similar</li>
</ul>
<p>
However each of these is a pretty hard problem and hardly with high demand from people.   
</p>
<p>
Considering Google Glass hasn't made it, the technology is not exactly there, so we have to rely on kludges like the ones I described above.
</p>
</div>
</div>
<div id="outline-container-org0000017">
<h2 id="org0000017"><a href="#org0000017">¶</a><span>12</span> --</h2>
<div id="text-12">
<p>
My closing tips would be:
</p>
<ul>
<li><p>
start simple
</p>
<p>
It's better to have a crappy adhoc script or bash alias that runs <code>grep</code> over your <samp>~/notes</samp> directory than no means of searching at all.
</p></li>
<li><p>
keep your things as plaintext as possible
</p>
<p>
This is a somewhat sad advice to give in 2019, but the reality is it's still extremely tedious to work with anything else.
</p></li>
<li><p>
whichever tools you use, make sure they launch in an instant
</p>
<p>
Seconds wasted on waiting break your flow. Better spend time on setting it up once and never think about that later.
</p></li>
<li><p>
give Emacs a try
</p>
<p>
I feel almost sorry advocating Emacs for everything, but despite my disgust at Elisp and frequent frustration, 
it just happens to be superior in terms of bending it to do what you want it to.
</p></li>
</ul>
<p>
As always, I'm open to feedback and would love to hear what is or setup or help you if you're struggling with something!
</p>
</div>
</div>

    </section>

    
    
    

    
    
    <p>Discussion:</p>
    <ul>
    
        <li><a href="https://news.ycombinator.com/item?id=22160572"><strong>hackernews</strong></a></li>
    
        <li><a href="https://www.reddit.com/r/emacs/comments/dq42vk/building_personal_search_engine_using_emacs_and">/r/emacs</a></li>
    
        <li><a href="https://lobste.rs/s/kzpegk/building_personal_search">lobsters</a></li>
    
        <li><a href="https://irreal.org/blog/?p=8422">irreal</a></li>
    
    </ul>
    

    

</article></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>