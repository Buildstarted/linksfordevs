<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>Return of the Obra Dinn [Releasing Oct 18]</h1>
        <p>
Reading time: 12-15 minutes        </p>
        <p><a href="https://forums.tigsource.com/index.php?topic=40832.msg1380618">https://forums.tigsource.com/index.php?topic=40832.msg1380618</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p><b><span size="5">Fullscreen, Round 3</span></b></p><p>Thanks everybody for all the suggestions. I tried everything, literally, and concluded that the best way to maintain the game's style and fix the fullscreen discomfort was to stabilize the swimming dither and subdue the flickering dots. I got there in the end, with a few compromises. This is the 3rd full devlog post I've written on this. For each previous version I'd get an idea or find something else to try while checking over it. At this point, don't even care.</p><p><span size="5"><b>Dithering Process</b></span></p><p>First, a quick explanation. Obra Dinn renders everything internally in 8-bit grayscale then converts the final output to 1-bit in a post-processing pass. The conversion from 8-bit to 1-bit is handled by comparing each source image's pixel to the corresponding dot in a tiling dither pattern. If the image pixel value&nbsp;is greater than the dither pattern dot value, the output bit is set to 1. Otherwise it's 0. The output gets reduced to 1-bit and the viewer's eye will merge the pixels back together to approximate more bits.</p><p><img src="http://3909.co/dev/od/img/Dither2-Exp.png" alt=""></p><p>Thresholding a source image by a dither pattern</p><p>The two components of this process are the source image and the dither pattern. Obra Dinn uses two distinct patterns for different cases: an 8x8 bayer matrix for a smoother range of shades,&nbsp;and a 128x128 blue noise field for a less ordered output.</p><p><img src="http://3909.co/dev/od/img/Dither2-ExpPatterns.png" alt=""></p><p>bayer / blue noise</p><p><img src="http://3909.co/dev/od/img/Dither2-Exp2.png" alt=""></p><p>In-engine result without wireframe lines. Bayer on the sphere, blue noise everywhere else.</p><p><b><span size="5">Hold Still Please</span></b></p><p>The basic dithering process works great for static images and much less great for moving or animated images. When&nbsp;the source image changes from frame-to-frame&nbsp;the static dither pattern and low resolution output&nbsp;become a major problem.&nbsp;What should be solid shapes and shades now read as a wiggling mess of pixels.</p><p><img src="http://3909.co/dev/od/img/Dither2-ExpMoving.gif" alt=""></p><p>Moving the sphere</p><p>These days,&nbsp;dithering is mostly used when the source image is either static or the output has a&nbsp;high resolution. The first thought when seeing this low-res swimming dither effect is not "yeah that's how dither works" but "what is this warping shaking effect and how can I turn it off."</p><p><img src="http://3909.co/dev/od/img/Dither2-Original.gif" alt=""></p><p>Exhibit A. Reduced contrast for your comfort.</p><p>Try to focus on something here when it moves and behold&nbsp;the&nbsp;crinkled&nbsp;heart of Obra Dinn's fullscreen problems. There are ways to fix this that mostly&nbsp;boiling down to "this style doesn't work, change it." I went pretty far down that path, experimenting with different styles, before swinging back and wondering if maybe I shouldn't let these bullshit little pixels push me around.</p><p><b><span size="5">Stabilizing The Dither</span></b></p><p>To give&nbsp;your eyes the best chance at recombining everything, dithering works best when the dither pattern&nbsp;dots have a 1:1 correlation with the output pixels. But, correlating&nbsp;only&nbsp;with the output means that as a scene post effect there's no connection&nbsp;between the geometry being rendered and the pattern that thresholds it. Each frame, moving scene elements threshold against different values. What I want instead is for the dither pattern to be "pinned" to the geometry and to appear stable as it moves with the rest of the scene.</p><p>The core of this is a mapping problem. As told&nbsp;by the length of this post, there's a conflict between the&nbsp;ideal&nbsp;dither pattern mapping (1:1 with the screen) and the&nbsp;ideal scene mapping (x:1 with the geometry) so get ready for some compromises.&nbsp;Most of my work was focused on mapping the input&nbsp;dither pattern into different spaces&nbsp;that better correlate the pattern with the scene geometry. Everything here is done at the pre-thresholding stage.</p><p><span size="5">Texel Space</span></p><p>My first try was to map the dither pattern in texel space. This is equivalent to dithering the object textures during scene rendering instead of in a post-processing pass on the 8-bit output. I didn't expect this to work well but wanted to see what a perfectly scene-matched mapping looked like anyways.</p><p><img src="http://3909.co/dev/od/img/Dither2-TexelMap.png" alt=""></p><p>Dither pattern in texel space</p><p>Ok well, expectations solidly met. The objects are all mapped differently so their pattern scales don't match. Those could be unified. The real problem is the aliasing. Any resampling&nbsp;from one space to another like this will result in aliasing, and dither patterns can't be easily mipped&nbsp;or filtered like traditional textures. Still, to carry it through:</p><p><img src="http://3909.co/dev/od/img/Stable-Texel.gif" alt=""></p><p>Applied to the moving scene</p><p>This isn't a total loss - the&nbsp;pattern is nicely pinned to geometry. The aliasing produces its own swimming effect and unifying or scaling the mappings won't help with that.&nbsp;Texels&nbsp;change size with distance from the camera so there will always be&nbsp;dither pattern pixels that alias badly when resampled to the screen.</p><p><span size="5">Motion Warping</span></p><p>If I want the dither pattern to track the moving geometry beneath it, why not just warp the pattern using the change in position of each rendered pixel in the scene? Indeed why not. This is a bit like a motion blur, where each pixel tracks its movement from the previous frame. In this case, I update the dither texture to keep its pattern moving with the scene. If a scene pixel was not represented in the previous frame, the dither pattern is reloaded&nbsp;there. This&nbsp;technique is made much simpler by the game's static-ness - I only need to worry about the movement of the camera, not individual objects.</p><p><img src="http://3909.co/dev/od/img/Stable-Warp.gif" alt=""></p><p>Warping the dither pattern to maintain frame-to-frame coherence with&nbsp;the scene</p><p>This was a pretty quick &amp; dirty try but a few things are clear. First, it kinda works. Second, a dither pattern needs a neighborhood - it can't be individual pixels. If you consider each pixel individually, as this method does, then you'll get breaks and discontinuities in the pattern which are obvious. I shifted the camera in this test scene to highlight those on the chest here. Viewing the warped dither pattern itself&nbsp;makes this a little easier to see.</p><p><img src="http://3909.co/dev/od/img/Stable-WarpMapping.gif" alt=""></p><p>Thresholding solid gray with the warping dither pattern</p><p>These discontinuities are down to the differing pixel depths and&nbsp;thresholds that I chose. I reasoned an elaborate fix based on tracking regions, averaging their depth and shifting all dither pattern dots in that region by the same amount. A discontinuity along a region boundary could be hidden by sharp lighting changes or a wireframe line.&nbsp;This would've been enabled by the game's existing setup of colored regions for the wireframe generation. When I sat down to implement all that, the depth term dropped out of the first&nbsp;equation I came up with and gave me a much simpler alternative:</p><p><span size="5">Screen-mapping&nbsp;With Offset</span></p><p>When putting together the equations for the warping dither, a very simple transform fell out:</p><div><pre><span>DitherOffset =<span>&nbsp;ScreenSize * CameraRotation / CameraFov</span></span><br></pre></div><p><img src="http://3909.co/dev/od/img/Dither2-ShiftingExp.gif" alt=""></p><p>Shifting the screen-mapped dither pattern based on camera rotation</p><p>Basically, this expresses that I want the screen-mapped dither pattern to shift by exactly one screen&nbsp;when the camera rotates through one field of view. That maintains a 1:1 mapping with the screen while also considering a simplified transform of the scene geometry in view. This really only matches the movement at the center of the screen but bless this fucked up world because it's nearly good enough.</p><p><img src="http://3909.co/dev/od/img/Dither2-Shifting.gif" alt=""></p><p>Offsetting the dither pattern to track one screen per camera fov rotation</p><p>Note how the dithered pixels on the chair appear to mostly move with the geometry. Likewise for the sphere. Planes more perpendicular to the view don't match very well;&nbsp;the floor is still a mess.</p><p>So while not being perfect, simply shifting the screen-mapped dither keeps&nbsp;the overall pattern and scene&nbsp;movement close enough that the eyes can better track them together. I was pretty happy with this. While cleaning up the code and committing everything, maybe writing a devlog post or two, the idea of a&nbsp;perfectly-pinned dither kept nagging at me:</p><p><span size="5">World&nbsp;Space - Cube Mapping</span></p><p>The experiments so far suggest&nbsp;that&nbsp;any&nbsp;correlation between the dither pattern and scene geometry would have to ignore depth information from the scene. What this means practically is that the dither can be pinned to the geometry during camera rotation but not during camera translation. This isn't such a bad thing for Obra Dinn considering the slow pace of the game and the observational&nbsp;role of the player. You're normally walking around, stopping, and looking at things. When walking, so many things are changing onscreen that the swimming&nbsp;dither isn't as obvious.</p><p>With that in mind, my next attempt was&nbsp;mapping the dither pattern to the geometry indirectly by pre-rendering it onto the sides of a cube centered around the camera. The cube translates with the camera but stays oriented to the world. In the mix: little bit of screen, little bit of scene.</p><p><img src="http://3909.co/dev/od/img/Dither2-CameraCube.png" alt="" width="400" height="296"></p><p>Dither pattern mapped to a cube centered around the camera</p><p><img src="http://3909.co/dev/od/img/Dither2-CameraCubeMap.png" alt=""></p><p>Camera's view looking up into a corner. Mapping scaled up for clarity.</p><p>The cube's mapping works well when looking directly into the sides, and not so well when aimed into a corner. Still, the dither pattern stays perfectly fixed in 3D space as the camera rotates.&nbsp;Even rough,&nbsp;the result is&nbsp;promising.</p><p><img src="http://3909.co/dev/od/img/Dither2-CameraCube.gif" alt=""></p><p>Thresholding scene&nbsp;with the cube-mapped dither pattern</p><p>Now we're talking. Being a post-processing pass makes this more general than texel-space mapping, which is good. The problem is now down to the particular cube mapping. An ideal mapping would have&nbsp;one texel on the cube always resolve to exactly one pixel on the screen, regardless of the camera rotation. That's not possible with a cube...</p><p><span size="5">World&nbsp;Space - Sphere Mapping</span></p><p>...but&nbsp;I got pretty close with a sphere.</p><p><img src="http://3909.co/dev/od/img/Dither2-CameraSphereMap.png" alt=""></p><p>Mapping the dither pattern onto the inside of a sphere</p><p>Finding this particular spherical mapping took some time. There's no way to perfectly tile a square texture onto a sphere. It would've been possible to redefine the dither matrices in terms of a hexagon grid or something else that does tile on a sphere. Possible&nbsp;maybe, I didn't try. Instead, I just hacked on the square tiling&nbsp;until this carefully tweaked "rings" mapping of the original dither pattern&nbsp;gave good results.</p><p><img src="http://3909.co/dev/od/img/Dither2-CameraSphere.gif" alt=""></p><p>Applied to the scene</p><p>Better than the cube. Still lots of aliasing. The spherically-mapped dot size is very similar to the screen pixel size - off just enough to cause moire patterns. I could feel the closeness, and a&nbsp;very simple fix for this kind of aliasing is to supersample: apply the dither thresholding at a higher resolution and downsample.</p><p><img src="http://3909.co/dev/od/img/Dither2-CameraSphereMap2.png" alt=""></p><p>Spherically-mapped dither pattern at 2x and downsampled to 1x</p><p><img src="http://3909.co/dev/od/img/Dither2-CameraSphere2.gif" alt=""></p><p>Thresholding at 2x, then&nbsp;downsampling to 1x</p><p>This is the best I got. There are a few compromises:</p><p>&nbsp; &nbsp; <b>1</b>&nbsp;The dither pattern dots get larger and less effective at the edges of the screen<br>&nbsp; &nbsp; <b>2</b>&nbsp;The pattern isn't aligned up-down-left-right for most camera rotations<br>&nbsp; &nbsp; <b>3</b>&nbsp;The output is no longer 1-bit due to the final box-downsample</p><p>But the upside is pretty lofty:</p><p>&nbsp; &nbsp; <b>1</b> The dithering is perfectly pinned for all camera rotations. This feels slightly uncanny in-game.<br>&nbsp; &nbsp; <b>2</b> Discomfort from swimming dither is totally gone, even at fullscreen<br>&nbsp; &nbsp; <b>3</b> The pixellated style of the game is preserved</p><p>It's possible&nbsp;eliminate compromise #3 by reducing the output back to 1-bit with a simple 50% threshold. The result is&nbsp;still better than without supersampling (the triple comparison directly below is thresholded).</p><p><img src="http://3909.co/dev/od/img/Dither2-FinalCompare.gif" alt=""></p><p>Side by side, by side</p><p><img src="http://3909.co/dev/od/img/Dither2-SplitCompare.gif" alt=""></p><p>In the game's default palette</p><p><span size="5"><b>Wrapup</b></span></p><p>It feels a little weird to put 100 hours into something that won't be noticed by its absence. Exactly no one will think, "man this dithering is stable as shit. total magic going on here." I don't want to give people problems they didn't know they should have though so it was worth fixing.</p><p>The screenspace mapping with&nbsp;offset works best at 1x and the sphere mapping&nbsp;works best at 2x.&nbsp;All scene rendering is at 800x450 now (up from 640x360), which helps legibility without sacrificing the low-res style. The final game will have&nbsp;two display modes:&nbsp;</p><p><b>DIGITAL</b><br>Border-boxed, screenspace offset dither, 1-bit output</p><p><b>ANALOG</b><br>Fullscreen, sphere-mapped dither, softened&nbsp;output</p></div><p>Quoting because pagination, and I'm sure there will be some useful discussion. For starters:</p><p>I guess the non-square pixels in the final output are also an inevitable compromise? It kind of breaks the suspension of disbelief.</p><p>I just realized that this compromise may not need to be inevitable, if you apply the treshold at the original pixel resolution (instead of this 2x blow-up). Of course, <i>that</i> would re-introduce the aliasing on the sphere, but if you only apply "lower-res tresholding" to the non-Bayer parts you would avoid that.</p></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>

</body>
</html>