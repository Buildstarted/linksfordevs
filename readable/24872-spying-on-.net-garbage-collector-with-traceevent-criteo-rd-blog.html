<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Spying on .NET Garbage Collector with TraceEvent - Criteo R&amp;D Blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Spying on .NET Garbage Collector with TraceEvent - Criteo R&amp;D Blog</h1><div><div class="ac ae af ag ah ea aj ak"><p id="6eb1" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This post of the series focuses on CLR events related to garbage collection in .NET.</p><p id="5a83" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 1: <a href="http://labs.criteo.com/2018/06/replace-net-performance-counters-by-clr-event-tracing" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Replace .NET performance counters by CLR event tracing</a>.</p><p id="d4f0" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 2: <a href="http://labs.criteo.com/2018/07/grab-etw-session-providers-and-events/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Grab ETW Session, Providers and Events</a>.</p><p id="0d92" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Part 3: <a href="http://labs.criteo.com/2018/09/monitor-finalizers-contention-and-threads-in-your-application/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">CLR Threading events with TraceEvent</a>.</p><h1 id="f8a9" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Introduction</h1><p id="38ae" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">The allocator and garbage collector components of the CLR may have a real impact on the performances of your application. The Book of the Runtime describes the allocator/collector design goals in the must read <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/garbage-collection.md" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Garbage Collection Design page</a> written by Maoni Stephens, lead developer of the GC. In addition, Microsoft provides large <a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">garbage collection documentation</a>. And if you want more details about .NET garbage collector, take a look at <a href="https://www.amazon.com/Pro-NET-Memory-Management-Performance/dp/148424026X" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Pro .NET Memory Management</a> by <a href="https://twitter.com/konradkokosa" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Konrad Kokosa</a>. In this post, I will focus on the events emitted by the CLR and how you could use them to better understand how your application is behaving, related to its memory consumption.</p><p id="b9bf" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The impact on how your application behaves is mostly related to a couple of topics:</p><ol class=""><li id="886b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb hx hy hz"><em class="ia">How many times and how long your threads get suspended during a collection<br></em>Desktop applications and games provide fluent User Interfaces where glitches are less and less acceptable. In the opposite side of the spectrum, low latency server applications have short SLAs to answer each request. In both cases, applications cannot afford freezing for too long while the high priority GC threads are cleaning up the .NET heaps for background GCs or blocking non concurrent GCs.</li><li id="8036" class="go gp ed at gq b gr ib gt ic gv id gx ie gz if hb hx hy hz"><em class="ia">How much memory is dedicated to your process<br></em>With the rise of containers and their quotas, your application needs to trim down its memory consumption. For example, with server GC enabled, the amount of memory used by your application could grows big (depending on the number of cores) before a gen 0 collection kicks in (read <a href="https://github.com/aspnet/AspNetCore/issues/3409" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">this discussion</a> about real world cases including StackOverflow web site and what are the possible solutions)<br>The memory pressure on the system is also taken into account by the GC and could lead to more collections being triggered (read Maoni Stephen blog post about <a href="https://blogs.msdn.microsoft.com/maoni/2018/11/16/running-with-server-gc-in-a-small-container-scenario-part-0/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">how Windows jobs are taken into account by the GC and how to leverage them if needed</a>). It becomes more and more important to detect leaks and memory consumption spikes.</li></ol><p id="6bb2" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In the previous post, you saw how to get the type name of instances being finalized. The CLR provides many more events related to memory management. They definitively help understand the interactions between this crucial part of .NET and your own code. In this article, you will see how to replace <a href="http://labs.criteo.com/2018/06/replace-net-performance-counters-by-clr-event-tracing/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">the not always consistent performance counters</a> such as generation sizes or collection counts. More importantly, you will get very useful metrics information like the type of GC (foreground or background) and your application threads suspension time.</p><h1 id="2b55" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Sequences of events during Garbage Collection phases</h1><p id="eca6" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">Ephemeral collections (of generation 0 and 1) are called “stop-the-world”: your application threads will be frozen during the whole collection. For generation 2 background collections, it is a little bit more complicated. As shown in the following figure (with <a href="https://twitter.com/konradkokosa" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Konrad Kokosa</a> courtesy from <a href="https://www.amazon.com/Pro-NET-Memory-Management-Performance/dp/148424026X" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">his book</a>)</p><figure class="ih ii ij ik il im dm dn paragraph-image"><p id="dada" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The applications threads will be frozen during different phases:</p><ul class=""><li id="7c38" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb ja hy hz">Initial internal step at the beginning of the collection,</li><li id="e185" class="go gp ed at gq b gr ib gt ic gv id gx ie gz if hb ja hy hz">At the end of the marking phase to reconcile the changes (allocations, references updates) done while background collection threads are running (also if compaction is needed). Look for documentation about card table usage to get more details,</li><li id="8cf3" class="go gp ed at gq b gr ib gt ic gv id gx ie gz if hb ja hy hz">If a compaction occurs.</li></ul><p id="a430" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Please read <a href="https://blogs.msdn.microsoft.com/seteplia/2017/01/05/understanding-different-gc-modes-with-concurrency-visualizer/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Understanding different GC modes with Concurrency Visualizer</a> to go deeper and blog posts from <a href="http://mattwarren.org/2017/01/13/Analysing-Pause-times-in-the-.NET-GC/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Matt</a><a href="http://mattwarren.org/2016/06/20/Visualising-the-dotNET-Garbage-Collector/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Warren</a> and <a href="https://blogs.msdn.microsoft.com/maoni/2014/12/25/gc-etw-events-2/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Maoni Stephens</a> about GC pauses.</p><h1 id="3c17" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">What are the available garbage collections metrics?</h1><p id="ca03" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">The <a href="https://github.com/Microsoft/perfview/blob/master/documentation/Downloading.md" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Perfview tool</a> could help you analyze how many garbage collections occurred and for which reason. Select Run in the Collect menu and click the Run Command button.</p><figure class="ih ii ij ik il im dm dn paragraph-image"><p id="b26e" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">You could also trigger a collection after the application is started with Collect | Collect. When you want to stop collecting information, click the Stop Collection. When the .etl file gets generated, go to the GCStats node</p><figure class="ih ii ij ik il im dm dn paragraph-image"><p id="e854" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Look for your application to get statistics related to garbage collections. The first <strong class="gq jh"><em class="ia">GC Rollup By Generation</em></strong> table gives you high level metrics such as the number of collections per generation and the mean pause time:</p><figure class="ih ii ij ik il im dm dn paragraph-image"><p id="ccd2" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The next two sections list the collections with a pause time longer than 200ms before the section that lists all generation 2 collections:</p><figure class="ih ii ij ik il im dm dn paragraph-image"><p id="0fb3" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The <strong class="gq jh"><em class="ia">Suspend Msec</em></strong> columns gives you the time it took to suspend your application threads while <strong class="gq jh"><em class="ia">Pause MSec</em></strong> counts the time during which your threads were actually suspended.</p><p id="d76b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In addition to this, memory details such as the size of all generations after each collection are available:</p><figure class="ih ii ij ik il im dm dn paragraph-image"><p id="26bb" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">However, my goal is to get these details to feed monitoring dashboards <strong class="gq jh">as the application runs</strong>. I can’t use Perfview but I can still rely on the same CLR events.</p><h1 id="ec0d" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">A solution for runtime please!</h1><p id="422f" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">Since version 2 of TraceEvent, there is an easy way to get already computed metrics about GC as <a href="https://blogs.msdn.microsoft.com/maoni/2018/09/09/glad-part-2" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">described by Maoni Stephens</a>. It relies on the same code as Perfview for its <em class="ia">GCStats</em> window.</p><p id="57b4" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">You only need to subscribe to two events; one when a GC starts and one when it ends:</p><figure class="ih ii ij ik il im"><p id="6415" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The <strong class="gq jh">TraceGC</strong> class provides too many details beyond the scope of this post but here are the main fields that should be used in <strong class="gq jh">GCEnd</strong> event handler to monitor your applications:</p><figure class="ih ii ij ik il im dm dn paragraph-image"><p id="898e" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Note that the <strong class="gq jh">IsNotCompacting</strong> method <a href="https://github.com/Microsoft/perfview/issues/811" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">currently returns invalid value</a>.</p><h1 id="38c8" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Final words</h1><p id="d7fa" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">I would like to mention one last event related to memory management. The <strong class="gq jh">GCAllocationTick</strong> CLR event (mapped by the <strong class="gq jh">ClrTraceEventParser.GCAllocationTick</strong> event) is emitted after ~100 KB has been allocated by your application. As you can infer from the <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events#gcallocationtick_v2-event" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Microsoft documentation</a>, the field of the <strong class="gq jh">GCAllocationTickTraceData</strong> argument received by your handler provides the following properties:</p><figure class="ih ii ij ik il im dm dn paragraph-image"><p id="9815" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">As you can see, listening to this <strong class="gq jh">GCAllocationTick</strong> event gives you a sampling of the allocations made in your application. This is not as precise as what a .NET profiler (relying on expensive <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">ObjectAllocated</a> and <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilercallback-objectsallocatedbyclass-method" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">ObjectAllocatedByClass</a><strong class="gq jh">ICorProfilerCallback</strong> hooks) would provide but it is much less intrusive. However, I would not recommend to systematically listen to this event in production, especially if your application is allocating GBs of memory per minute. Unlike what the documentation states, you need to set the verbosity to <strong class="gq jh">TraceEventLevel.Verbose</strong> (and not <strong class="gq jh">Informational</strong>) when you enable the CLR provider and this could impact your application performances due to the high number of emitted CLR events.</p><p id="d72d" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This event could be very helpful in case of unusual LOH allocations because you would get the type of the objects in the LOH almost each time (the 85.000 bytes threshold is close to the 100 KB trigger limit) or simply to have an hint on the most allocated types over time. Note that you won’t get the callstack leading to the allocations triggering the event. Instead, for memory leak or memory usage analysis, I would definitively recommend you to use Perfview. Vance Morrison has published a series of videos that detail <a href="https://channel9.msdn.com/Series/PerfView-Tutorial/PerfView-Tutorial-9-NET-Memory-Investigation-Basics-of-GC-Heap-Snapshots" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">.NET memory investigations</a>, <a href="https://channel9.msdn.com/Series/PerfView-Tutorial/Tutorial-10-Investigating-NET-Heap-Memory-Leaks-Part1-Collecting-the-data" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">collecting the data</a> and <a href="https://channel9.msdn.com/Series/PerfView-Tutorial/Tutorial-11-Investigating-NET-Heap-Memory-Leaks-Part2-Analyzing-the-data" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">analyzing the data</a> with Perfview. You will also find a lot of detailed memory-related investigations guidelines in <a href="https://www.amazon.com/Pro-NET-Memory-Management-Performance/dp/148424026X" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Konrad Kokosa’s book</a>.</p><p id="d6fd" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">You now have a complete view of the CLR events interesting to understand the different phases of a garbage collection and a few interactions (suspension) with the Execution Engine. Everything is in hands to replace the performance counters by CLR events: the metrics are more accurate and you get access to more information such as suspension time or contention time. The code presented during all episodes is available <a href="https://github.com/chrisnas/ClrEvents" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">on Github</a> with an easy to reuse <strong class="gq jh">ClrEventManager</strong> class that you could plug into your own applications or monitoring service!</p></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>