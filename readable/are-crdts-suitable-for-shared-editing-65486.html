<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Are CRDTs suitable for shared editing? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Are CRDTs suitable for shared editing? - linksfor.dev(s)"/>
    <meta property="article:author" content="yjs"/>
    <meta property="og:description" content="Performance analysis of the Yjs CRDT in practice and in the worst case scenario."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Are CRDTs suitable for shared editing?</title>
<div class="readable">
        <h1>Are CRDTs suitable for shared editing?</h1>
            <div>by yjs</div>
            <div>Reading time: 27-35 minutes</div>
        <div>Posted here: 10 Aug 2020</div>
        <p><a href="https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/">https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
        
<div>
  <main>
      <article>
  
  <div>
      <p><a href="https://crdt.tech/">CRDTs</a> are often praised as the "holy grail" for building collaborative applications because they don't require a central authority to resolve sync conflicts. They open up new possibilities to scale the backend infrastructure and are also well-suited as a data-model for distributed apps that don't require a server at all.</p><p>However, several text editor developers report not to use them because they impose a too significant overhead.</p><p>Just recently, Marijn Haverbeke wrote about his considerations against using CRDTs as a data model for <a href="https://codemirror.net/6/">CodeMirror 6</a>:</p><blockquote>[..] the cost of such a representation is significant, and in the end, I judged the requirement for converging positions to be too obscure to justify that level of extra complexity and memory use. <a href="https://marijnhaverbeke.nl/blog/collaborative-editing-cm.html">(source)</a></blockquote><p>The <a href="https://github.com/xi-editor/xi-editor">Xi Editor</a> used a CRDT as its data model to allow different processes (syntax highlighter, type checker, ..) to concurrently access the editor state without blocking the process. They reverted to a synchronous model because ..</p><blockquote>[..] CRDT is not pulling its (considerable) weight. <a href="https://github.com/xi-editor/xi-editor/issues/1187#issuecomment-491473599">(source)</a></blockquote><p>Apparently, everyone recognizes that CRDTs have a lot of potential, but concluded that the memory overhead of using them must be too expensive for real-world applications.</p><p>They bring up a fair point. Most CRDTs assign a unique ID to <em>every character</em> that was ever created in the document. In order to ensure that documents can always converge, the CRDT model preserves this metadata even when characters are deleted.</p><p>This seems to be particularly expensive in dynamic languages like JavaScript. Other languages allow you to efficiently represent all those characters and IDs in-memory using <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">structs</a> (e.g. C or Rust). In JavaScript, everything is represented as an <code>Object</code> - basically a key-value map that needs to keep track of all its keys and values. CRDTs assign multiple properties to every single character in the document to ensure conflict resolution. The memory overhead of merely representing a document as a CRDT could be immense.</p><p>Every user-interaction creates more metadata that the CRDT needs to retain in order to ensure conflict resolution. It is not uncommon that CRDTs create millions of objects to store all this metadata. The JavaScript engine manages these objects on the heap, checks if they are referenced, and, if possible, garbage collects them. Another major problem is that with an increasing number of object creations, the cost of creating additional objects increases exponentially. This is shown in the following graphic:</p><figure><img src="https://blog.kevinjahns.de/content/images/2020/07/scatter-plot.png" alt="" srcset="https://blog.kevinjahns.de/content/images/2020/07/scatter-plot.png 600w"><figcaption>Average time to create one object increases with the number of objects on the heap <a href="https://jsperf.com/cost-of-objects">(Data Source)</a></figcaption></figure><p>So the question arises if CRDTs are actually suitable for shared editing on the web, or if they impose a too significant cost to be viable in practice.</p><p>In case you don't know me, I'm the author of a CRDT implementation named <a href="https://github.com/yjs/yjs">Yjs</a>, that is specifically designed for building shared editing applications on the web.</p><p>In this article, I will introduce you to a simple optimization for CRDTs and examine the exact performance trade-off of using Yjs for shared editing. I hope to convince you that the overhead is actually very small even for large documents with long edit histories.</p><h2 id="yjs">Yjs</h2><p>Yjs is a framework for building collaborative applications using CRDTs as the data model. It has a growing ecosystem of extensions that enable shared editing using different editors (<a href="https://docs.yjs.dev/ecosystem/editor-bindings/yjs-prosemirror"></a><a href="https://docs.yjs.dev/ecosystem/editor-bindings/prosemirror">ProseMirror</a>, <a href="https://www.npmjs.com/package/@remirror/extension-yjs"></a><a href="https://docs.yjs.dev/ecosystem/editor-bindings/remirror"></a><a href="https://docs.yjs.dev/ecosystem/editor-bindings/remirror">Remirror</a>, <a href="https://docs.yjs.dev/ecosystem/editor-bindings/yjs-quilljs"></a><a href="https://docs.yjs.dev/ecosystem/editor-bindings/quill">Quill</a>, <a href="https://docs.yjs.dev/ecosystem/editor-bindings/codemirror">CodeMirror</a>, ..), different networking technologies (<a href="https://docs.yjs.dev/ecosystem/connection-provider/y-websocket">WebSocket</a>, <a href="https://docs.yjs.dev/ecosystem/connection-provider/y-webrtc">WebRTC</a>, <a href="https://docs.yjs.dev/ecosystem/connection-provider/y-hyper">Hyper</a>, ..), and different persistence layers (<a href="https://docs.yjs.dev/ecosystem/database-provider/y-indexeddb">IndexedDB</a>, <a href="https://docs.yjs.dev/ecosystem/database-provider/y-leveldb">LevelDB</a>, <a href="https://docs.yjs.dev/ecosystem/database-provider/y-redis">Redis</a>, ..). Most shared editing solutions are tied to a specific editor and to a specific backend. With Yjs, you can make any of the supported editors collaborative and exchange document updates through your custom communication channel, over a peer-to-peer WebRTC network, or over a scalable server infrastructure. My vision for this project is that you can simply compose your collaborative application using the technologies that make sense for your project. </p><figure><a href="https://github.com/yjs/yjs"><div><p>yjs/yjs</p><p>Peer-to-peer shared types. Contribute to yjs/yjs development by creating an account on GitHub.</p><p><img src="https://github.githubassets.com/favicons/favicon.svg"><span>GitHub</span></p></div><p><img src="https://repository-images.githubusercontent.com/22392639/419c6c00-995d-11ea-87c6-dc7e997553d4"></p></a></figure><p>This is not just some cool prototypical side-project. Yjs is a battle-proven technology that is used by several companies to enable collaboration. I'm only mentioning my sponsors here:</p><ul><li><a href="https://nimbusweb.me/note.php">Nimbus Note</a> scales collaborative note editing horizontally using Yjs.</li><li><a href="https://room.sh/">Room.sh</a> is a meeting software that allows collaborative editing &amp; drawing over WebRTC.</li></ul><p>I maintain a reproducible set of benchmarks that compares different CRDT implementations. Yjs is by far the fastest web-based CRDT implementation with the most efficient encoding. In this article I will often refer to specific benchmarks contained in the <code>crdt-benchmarks</code> repository as, for example, "<a href="https://github.com/dmonad/crdt-benchmarks/#b1-no-conflicts">[B1.11]</a>".</p><figure><a href="https://github.com/dmonad/crdt-benchmarks"><div><p>dmonad/crdt-benchmarks</p><p>A collection of CRDT benchmarks. Contribute to dmonad/crdt-benchmarks development by creating an account on GitHub.</p><p><img src="https://github.githubassets.com/favicons/favicon.svg"><span>dmonad</span><span>GitHub</span></p></div><p><img src="https://repository-images.githubusercontent.com/185183228/89ad9780-b8e8-11ea-998a-91c689c4a511"></p></a></figure><h2 id="data-representation">Data Representation</h2><p>Chances are you're already familiar with the general concepts of how CRDTs work. If not, and you want to dive into this rabbit hole, I recommend this fun interactive series:</p><figure><a href="https://lars.hupel.info/topics/crdt/01-intro/"><div><p>CRDTs: Part 1</p><p><img src="https://lars.hupel.info/img/profile.jpg"><span>Lars Hupel</span><span>Lars Hupel</span></p></div><p><img src="https://lars.hupel.info/img/topics/crdt/world.jpg"></p></a><figcaption>A fun interactive series about CRDTs</figcaption></figure><figure><a href="https://crdt.tech/resources"><div><p>CRDT Resources • Conflict-free Replicated Data Types</p><p>Resources and community around CRDT technology — papers, blog posts, code and more.</p><p><img src="https://crdt.tech/assets/favicons/favicon-192x192.png"><span>Conflict-free Replicated Data Types</span></p></div><p><img src="https://crdt.tech/assets/img/crdt-favicon.png"></p></a><figcaption>Good entry point to find more CRDT related resources</figcaption></figure><p>The concept paper that describes Yjs' conflict resolution algorithm YATA is available on <a href="https://www.researchgate.net/publication/310212186_Near_Real-Time_Peer-to-Peer_Shared_Editing_on_Extensible_Data_Types">Researchgate</a>. The concepts discussed here are pretty generic and could be extended to almost any CRDT.</p><p>In order to determine the performance cost, we are are going to examine how Yjs maintains data. Please bear with me while I describe how the CRDT model is represented using JavaScript objects. This will be relevant later.</p><p>Similarly to other CRDTs, the YATA CRDT assigns a unique ID to every character. These characters are then maintained in a doubly linked list.</p><p>The unique IDs are<a href="https://en.wikipedia.org/wiki/Lamport_timestamp"> Lamport Timestamps</a>. They consist of a unique user identifier and a logical clock that increases with each character insertion.</p><p>When a user types the content "ABC" from left to right, it will perform the following operations: <code>insert(0, "A") • insert(1, "B") • insert(2, "C")</code>. The linked list of the YATA CRDT, which models the textual content, will look like this:</p><figure><img src="https://blog.kevinjahns.de/content/images/2020/07/crdt-datamodel.svg" alt=""><figcaption>CRDT model of inserting content "ABC" (assuming the user has the unique client identifier "1")</figcaption></figure><p>Notice how every character can be uniquely identified by the combination of the unique client-id and an ever-increasing <code>clock</code> counter.</p><p>Yjs represents the items of the linked list as <code>Item</code> objects that contain some content (in this case a String), a unique ID, the links to the adjacent <code>Item</code> objects, and additional metadata that is relevant for the CRDT algorithm.</p><p>All CRDTs assign some kind of unique ID and additional metadata to every character, which is very memory-consuming for large documents. We can't get rid of metadata as it is necessary for conflict resolution. Yjs also uniquely identifies each character and assigns metadata, but represents this information efficiently. Larger document insertions are represented as a single <code>Item</code> object using the character-offset to uniquely identify each character individually. The below <code>Item</code> uniquely identifies character <code>"A"</code> as <code>{ client: 1, clock: 0 }</code>, character <code>"B"</code> as <code>{ client: 1, clock: 1 }</code>, and so on..</p><figure><pre><code>Item {
    id: { client: 1, clock: 0 },
    content: 'ABC',
    ...
}</code></pre><figcaption>Yjs's internal representation of items in the linked list</figcaption></figure><p>If a user copy/pastes a lot of content into the document, the inserted content is represented by a single <code>Item</code>. Furthermore, single-character insertions that are written from left to right can be merged into a single <code>Item</code>. It is just important that we are able to split and merge items without losing any metadata.</p><p>This type of compound representation of the CRDT model and its split-functionality have first been described in <a href="https://kundoc.com/pdf-a-string-wise-crdt-algorithm-for-smart-and-large-scale-collaborative-editing-sys.html">"A string-wise CRDT algorithm for smart and large-scale collaborative systems"</a>. Yjs adapts this approach for YATA and also includes functionality to merge <code>Item</code> objects.</p><h2 id="the-cost-of-operations">The Cost of Operations</h2><p>With this simple optimization in mind, let's have a look at how the number of modifications on a document relates to the amount of metadata that needs to be retained. We will measure metadata by the amount of <code>Item</code> objects created and later examine what the cost of a single <code>Item</code> is.</p><p>Every user interaction with a text editor can be expressed as either an <strong>insert</strong> or a <strong>delete</strong> operation.</p><ul><li><code>insert(index: number, content: string)</code><strong> </strong>Insertions of any size create a single <code>Item</code> that is integrated into the document. In some cases the integration requires to split an existing <code>Item</code>. So we have a maximum of two <code>Item</code> creations per insertion.</li><li><code>delete(index: number, length: number)</code> Deleting an <code>Item</code> only marks it as deleted. I.e <code>item.deleted = true</code>. Therefore, <code>Item</code> deletions are free and will reduce the amount of memory used because the <code>Item.content</code> can be removed. The <code>Item</code> doesn't need to retain the content for doing conflict resolution. But deleting a range of content might require to split two existing items. Therefore, the cost of deletions is a maximum of two <code>Item</code> creations also.</li></ul><p>By using the compound representation of CRDTs, the amount of metadata only relates to the amount of operations produced by a user. Not to the amount of characters inserted. This makes a huge difference in practice. Most larger documents are created by copy-pasting existing content or by moving paragraphs to other positions. Any kind of operation, even copy-paste and undo/redo, only create at most two <code>Item</code> objects.</p><p>Yjs also supports rich-text and structured documents. The above statement, that the amount of metadata only relates to the amount of operations, still holds true for these kinds of documents. But measuring operation-cost for more complex operations is out of scope of this article. An interesting observation in practice is that the document size of long-running editing sessions on structured documents (e.g. using the <a href="https://docs.yjs.dev/yjs-ecosystem/editor-bindings/yjs-prosemirror"></a><a href="https://docs.yjs.dev/ecosystem/editor-bindings/prosemirror">y-prosemirror</a> binding to the <a href="https://prosemirror.net/">ProseMirror</a> editor) is actually much smaller than in linear text documents. This is due to other optimizations that play a role in Yjs and might be examined in another blog-post.</p><h2 id="measuring-performance">Measuring Performance</h2><p>It has become common practice in academic research to measure performance by the amount of (concurrent) operations per second that a CRDT can handle. This might be an important benchmark for database applications that have a high throughput. But in shared editing applications, a relatively small number of users will produce just a few operations per second. So it doesn't matter if the integration process of a single operation takes one nanosecond or one hundred nanoseconds. Furthermore, conflicts rarely happen because most CRDTs address characters relatively, and a conflict only occurs if two users insert a character at the same position at the same time. </p><p>When we only use a specific scenario (e.g. number of insertions at random positions) to benchmark performance, we might end up with a CRDT that only performs well in this specific scenario. In practice, other performance characteristics also play a role. I try to capture relevant performance characteristics in different scenarios in the <a href="https://github.com/dmonad/crdt-benchmarks">crdt-benchmarks</a> repository. It shows that some CRDTs perform well in some scenarios, but perform poorly in others. As an example, the RGA implementations perform well when appending content, but have very bad runtime behavior when content is only prepended. A CRDT for shared editing should perform well in all scenarios. The below list describes the lifetime of a shared editing application and gives more insight into the relevance of different performance characteristics.</p><ol><li>The document is loaded from the network or from a local file. Parsing an encoded document often takes a considerable amount of time, especially if the document is large. <code>parseTime</code> denotes the time it takes to parse an encoded document. In my opinion, <code>parseTime</code> is the most important performance characteristic because it blocks the process at the start of the application. All other tasks can be performed while the user is not working.</li><li>The document is synced with other peers. If the document was modified while offline, conflicts may occur. The <a href="https://github.com/dmonad/crdt-benchmarks#b2-two-users-producing-conflicts">[B2]</a> benchmarks measure sync conflicts produced by only two clients (e.g. in a client-server environment). The <a href="https://github.com/dmonad/crdt-benchmarks#b3-many-conflicts">[B3]</a> benchmarks measure the time it takes to sync conflicts between multiple clients (sync conflicts that may occur in a p2p environment). In most CRDT implementations, sync conflicts need to be resolved again when the document is loaded; so pay special attention to <code>parseTime</code> when looking at the benchmarks.</li><li>A user applies changes to the local document. Yjs uses a linked list to represent characters in the document. Unless the editor directly works on the CRDT model, the editor will apply <code>insert</code> and <code>delete</code> operations using index-positions. The CRDT implementation needs to traverse its internal representation to find the position, perform the change, and then produce an update that is sent to other peers. <code>time</code> denotes the time it takes to perform a certain task (e.g. append one million characters, sync N concurrent changes, ..). The <a href="https://github.com/dmonad/crdt-benchmarks#b1-no-conflicts">[B1]</a> benchmarks simulate a single user performing changes on a document without actually producing conflicts. It shows that some CRDTs have a significant overhead when it comes to simply applying changes on a document.</li><li>Collaborators send document updates to remote peers. We assume that applying a single update on a remote peer doesn't take a considerable amount of time. Applying several operations is covered by the <a href="https://github.com/dmonad/crdt-benchmarks#b2-two-users-producing-conflicts">[B2]</a> and <a href="https://github.com/dmonad/crdt-benchmarks#b3-many-conflicts">[B3]</a> benchmarks. Most CRDT implementations support some form of incremental update functionality. Each change produces a small update that is sent to other peers. <code>avgUpdateSize</code> denotes the average size of a document update. It simply confirms that a CRDT produces small incremental updates. </li><li>The document is stored in a database or sent to remote peers. <code>encodeTime</code> denotes the time it takes to transform a document to a binary representation. <code>docSize</code> denotes the size of the encoded document.</li></ol><p>The <a href="https://github.com/dmonad/crdt-benchmarks">crdt-benchmarks</a> readme shows the performance characteristics of many different scenarios that are relevant for shared editing. In this article, we just cover a few benchmarks measuring <em>the most relevant performance characteristics:</em></p><ul><li><code>memUsed</code> The heap-size of the JavaScript engine after all changes are applied. In the crdt-benchmarks repository <code>memUsed</code> is just an approximation of the memory used, because we can't run the garbage-collector reliably to remove traces of previous benchmarks. I ran the benchmarks of this article individually and measured the heap size directly in the performance inspector to get a more accurate result.</li><li><code>docSize</code> The size of the encoded document. Yjs has a very efficient encoder that writes <code>Item</code> objects to a binary compressed format. It is sent over the wire (WebSocket, HTTP, WebRTC, ..) to other clients, so we want to make sure that the document size is reasonable.</li><li><code>parseTime</code> The time it takes to parse the encoded document. After we received the encoded document from the network, we want to render it as soon as possible. So we expect that it is parsed within a reasonable amount of time.</li></ul><h2 id="a-worst-case-scenario">A worst-case scenario</h2><p>In the best-case scenario for Yjs, a user writes content from left to right. In this case, all operations are merged into a single <code>Item</code>.</p><p>The absolutely worst-case scenario is a user writing content from right to left. While this is not unlikely in some languages, the current implementation of the compound representation can't be applied, and an <code>Item</code> is created for every insertion. This scenario accurately reflects the performance overhead of Yjs without its compound optimization.</p><p>How many insert operations do users usually produce when writing large documents? If I wrote Yjs from scratch in a single file, I would write around 200k characters. The whole <a href="https://codemirror.net/">CodeMirror</a> source code consists of 568k characters. Well, let's say Yjs would need to handle one million insert operations while writing from right to left. That amounts to one really large document. How bad is it?</p><p>We are afraid that Yjs uses too much memory to represent all those <code>Item</code> objects. After all, memory usage in JavaScript seems to be inefficient, and we also have to worry about the exponential increase in time to create JavaScript objects.</p><p>In order to benchmark the worst-case scenario, we are going to create one million <code>Item</code> objects by producing one million single-character insert operations at position 0:</p><figure><pre><code>import * as Y from 'yjs'

const ydoc = new Y.Doc()
const ytext = ydoc.getText('benchmark')

// Insert one million 'y' characters from right to left
for (let i = 0; i &lt; 1000000; i++) {
    ytext.insert(0, 'y')
}

// transform ydoc to its binary representation
const encodedDocument = Y.encodeStateAsUpdateV2(ydoc)
const docSize = encodedDocument.byteLength
console.log(`docSize: ${docSize} bytes`) // =&gt; 1,000,046 bytes

// Measure time to load the Yjs document containing 1M chars
const start = Date.now()
const ydoc2 = new Y.Doc()
Y.applyUpdateV2(ydoc2, encodedDocument)

const parseTime = Date.now() - start
console.log(`parseTime: ${parseTime} ms`) // =&gt; 368.39 ms
</code></pre><figcaption>Benchmark the time to parse a document containing one million character insertions without optimizations. Equivalent to <a href="https://github.com/dmonad/crdt-benchmarks/#b1-no-conflicts">[B1.3]</a> with N=1,000,000</figcaption></figure><h5 id="results"><strong>Results</strong></h5><ul><li><code>memUsed</code>: 112 MB</li><li><code>docSize</code>: 1,000,046 bytes</li><li><code>parseTime</code>: 368.39 ms</li></ul><p>It turns out that the worst-case scenario is not too bad at all. Yjs doesn't consume an excessive amount of memory. I would say that the overall memory consumption of 112 MB is pretty bearable, considering the amount of changes that are applied to the document. Parsing a document of that size in less than 400 ms also doesn't seem that bad. And please keep in mind that this is the absolutely worst-case scenario for Yjs.</p><p>I showed that the amount of metadata is only related to the amount of changes produced and not to the amount of content inserted. To put one million insertions in perspective: A keyboard stress test machine would need 139 hours at 120 keystrokes per minute to generate one million insertions.</p><figure><p><iframe src="https://www.youtube.com/embed/pYXGtxIfprM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" name="fitvid0"></iframe></p></figure><h2 id="examining-memory-usage">Examining memory usage</h2><p>JavaScript objects work like key-value maps. That would mean that each object needs to keep track of all its keys and map them to their respective value. A <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C-struct</a> doesn't need to retain the keys in-memory and only holds the values in an efficiently encoded format. So naturally, there is a lot of fear when working with a lot of objects in JavaScript. But object representation in JavaScript engines is actually pretty efficient. When you create many objects with the same structure (they all have the same key entries), the JavaScript engine represents them almost as efficiently as <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C-structs</a>. In V8/Chrome this optimization is known as <strong>hidden classes.</strong> In SpiderMonkey/Firefox the same optimization is referred to as <strong>shapes</strong>. <a href="https://doi.org/10.1145/74878.74884">This type of optimization</a> is literally older than the web and part of all JavaScript runtime engines. So object representation is not something we need to worry about.</p><figure><a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e"><div><p>How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code</p><p>Couple of weeks ago we started a series aimed at digging deeper into JavaScript and how it actually works: we thought that by knowing the building blocks of JavaScript and how they come to play…</p><p><img src="https://cdn-images-1.medium.com/fit/c/152/152/1*8I-HPL0bfoIzGied-dzOvA.png"><span>Alexander Zlatkov</span><span>SessionStack Blog</span></p></div><p><img src="https://miro.medium.com/max/1200/1*AKKvE3QmN_ZQmEzSj16oXg.png"></p></a><figcaption>A light overview of how V8 optimizes JavaScript code</figcaption></figure><p>Lets' jump back to the worst-case scenario and examine how much memory exactly each <code>Item</code> consumes.</p><figure><img src="https://blog.kevinjahns.de/content/images/2020/07/memory.png" alt="" srcset="https://blog.kevinjahns.de/content/images/size/w600/2020/07/memory.png 600w, https://blog.kevinjahns.de/content/images/2020/07/memory.png 614w"><figcaption>Screenshot of the memory inspector when creating one million items</figcaption></figure><p>An <code>Item</code> consists of some content (in this case <code>ContentString</code>) and an <code>ID</code> object. The <code>ID</code>, in turn, consists of an ever-increasing numeric clock and a numeric client identifier that doesn't change in this scenario. Hence, we only have a bit over one million <code>(number)</code> objects. Therefore, the cost of each <code>Item</code> is 88 bytes of memory usage, excluding its content. You get this number by adding up the "Shallow Size" for <code>Item</code>, <code>ID</code>, and <code>(number)</code>and divide that by the amount of items. Each <code>ContentString</code> object consumes 16 bytes in addition to the size of the inserted string.</p><p>Another 5.2 Mb is used to index these items only using Arrays. Generally, the amount of indexing information needed is negligible compared to the amount of items created.</p><p>The performance of a web-based CRDT implementation is directly tied to the amount of objects that it creates. Analyzing the runtime performance of the worst-case scenario, we can observe that 40% of the time is spent performing V8 memory cleanups (Major &amp; Minor GC).</p><figure><img src="https://blog.kevinjahns.de/content/images/2020/07/memory-scavenge.png" alt=""><figcaption>Time spent when creating one million items</figcaption></figure><p>This is a big drawback of dynamic programming languages. However, in the following section we will see that our optimizations reduces the number of object creations in practice, and therefore also improves performance significantly.</p><h2 id="a-real-world-scenario">A real-world scenario</h2><p>Yjs is optimized for human input behavior. A quite obvious observation is that text is usually inserted from left to right. And although we often need to correct spelling mistakes, we tend to delete the whole word and then start again. Yjs takes advantage of this behavior and optimizes bulk insertions by representing consecutive insertions in a single <code>Item</code>. Copy-pasting a huge text-chunk into the document also just creates a single <code>Item</code>. Furthermore, deletions are free and reduce the amount of memory used. These optimizations make a huge difference in practice, as we can see in a real-world scenario.</p><p>Martin Kleppmann <a href="https://github.com/automerge/automerge-perf">shared the editing trace of text operations</a> that he created when he wrote his 17 page long conference paper on <a href="https://arxiv.org/abs/1608.03960">"A Conflict-Free Replicated JSON Datatype"</a>. The editing trace consists of 182,315 single-character insertions and 77,463 single-character deletions. The final document contains 104,852 characters (including white space).</p><p>The benchmark results <a href="https://github.com/dmonad/crdt-benchmarks/#b4-real-world-editing-dataset"></a><a href="https://github.com/dmonad/crdt-benchmarks/#b4-real-world-editing-dataset">[B4]</a> of applying the editing trace on a Yjs document confirm my prediction that humans usually produce bulk insertions:</p><ul><li><code>memUsed</code>: 19,7 MB</li><li><code>Item</code> objects created: 10,971<br>• 5,799 contain content<br>• 5,172 are marked as deleted and don't contain any content</li><li><code>docSize</code>: 159,927 bytes</li><li><code>parseTime</code>: 20 ms</li></ul><p>A naive implementation would represent each of the 260k single-character insertions/deletions as a separate JavaScript object. In Yjs, the complete document structure consists of only 11k <code>Item</code> objects. The actual amount of memory used is about 2.1 MB. The rest is used for V8 internal code optimizations (the next benchmark confirms that).</p><p>The encoded document has a size of roughly 160 kB. A small overhead of only 53% on the document size won't impact network performance even for slow network devices. Actually, Yjs might be favorable compared to other solutions, because it allows you to store documents in the browser database so that you only need to pull the differences from the network. This works even without a central authority to manage editing history.</p><p>Parsing the editing trace of a complete conference paper in 20 ms is fine. Even though the overhead of parsing in a centralized shared editing solution is close to zero, I would argue that the benefits of decentralization outweigh an overhead that is unnoticeable in practice.</p><h2 id="parsing-huge-documents">Parsing Huge Documents</h2><p>The real-world scenario shows that Yjs doesn't have any significant overhead when working with moderately sized documents like scientific papers. But what about writing really large books with Yjs. Surely, the time to parse such large documents will increase exponentially. At the beginning of this article I gave benchmark results that show that the time to create objects increases exponentially with the amount of objects already created. Furthermore, data structures that index the items should result in at least a logarithmic increase in time.</p><p>The benchmark <a href="https://github.com/dmonad/crdt-benchmarks/#b4-x-100-real-world-editing-dataset-100-times">[B4 x 100]</a> shows that the time to parse the document only increases linearly with the amount of operations. I applied the same editing trace of over 260k insert and delete operations one hundred times resulting in one enormous document. The time to parse this document only increases linearly (20 ms * 100).</p><ul><li><code>memUsed</code>: 220 MB</li><li><code>docSize</code>: 15,989,245 bytes</li><li><code>parseTime</code>: 1952 ms</li><li><code>Item</code> objects: 1,097,100</li></ul><p>The final document contains 10,485,200 characters (18 million insert operations and 8 million delete operations). Again, to put this in perspective: The novel "A Game of Thrones: A Song of Ice and Fire" only contains about 1.6 million characters (no pun intended).</p><p>At 30 characters per minute, a human would need 1.65 years of non-stop writing to to produce 26 million operations. This doesn't even account for cursor movements to produce fragmentation in the document. Yjs comfortably handles 26 million changes using only 220 MB of memory.</p><p>This benchmark shows that Yjs can handle ridiculously large documents and that the time to parse a document only increases linearly, not exponentially as we suspected. Even in this scenario the performance overhead of Yjs is barely noticeable. Pulling a large document with a size of 10 MB from the network and rendering it in the browser will take significantly longer than parsing the document with Yjs.</p><p>The exponential increase in time to create objects doesn't really affect Yjs because it creates very few objects to begin with. Tests confirm that you need to apply the real-world dataset 1000 times to create 10 million items that incur an additional garbage-collection overhead of one second to parse the document. Up to this point, the time to parse the document will only increase linearly.</p><p>As for the data structure that index the <code>Item</code> objects, the time to perform queries indeed increases logarithmically with the amount of items already inserted. However, the overhead is so insignificant that you won't be able to measure it. I also suspect that the JavaScript engine gradually optimizes the executed code and cancels out the logarithmic overhead. In practice, the time to parse documents only increases linearly with the amount of user-interactions.</p><p>Absolutely! It is basically impossible for a human to write a document that Yjs can't handle. I showed exhaustively that Yjs performs exceptionally in real-world scenarios and even performs well if none of the optimizations can be applied.</p><p>The performance trade-off that Yjs imposes is very favorable. In exchange for a small amount of memory per operation, Yjs allows you to sync documents with other peers over any networking stack - even peer-to-peer. Of course, it also has other features that are relevant for shared editing:</p><ul><li>Selective Undo/Redo manager</li><li>Snapshots and being able to revert to an old document state</li><li>Computing the differences between versions and render diffs by the user who created the changes (git blame)</li><li>Syncs changes to a browser database to allow offline editing</li><li>A collaboration-aware model to represent positions like cursor locations</li><li>Awareness functionality (who is currently online, what are they working on, ..)</li></ul><p>In my opinion, the slight overhead that we examined is worth the benefits of having a collaboration-aware model that works in distributed environments.</p><p>If you'd like to know more about Yjs, head over to <a href="https://github.com/yjs/yjs">GitHub</a> and follow <a href="https://twitter.com/kevin_jahns">me on twitter</a> to get notified about the latest developments.</p><figure><a href="https://github.com/yjs/yjs"><div><p>yjs/yjs</p><p>Peer-to-peer shared types. Contribute to yjs/yjs development by creating an account on GitHub.</p><p><img src="https://github.githubassets.com/favicons/favicon.svg"><span>yjs</span><span>GitHub</span></p></div><p><img src="https://repository-images.githubusercontent.com/22392639/419c6c00-995d-11ea-87c6-dc7e997553d4"></p></a></figure><p>Maintaining Yjs, caring for GitHub issues, and managing a growing community takes up a lot of my free time. If you would like me to do more public work, such as writing blog articles, then please fund me on GitHub Sponsors:</p><figure><a href="https://github.com/sponsors/dmonad"><div><p>Sponsor @dmonad on GitHub Sponsors</p><p>I’m the author of Yjs - a CRDT framework for creating collaborative, offline-ready applications.</p><p><img src="https://github.githubassets.com/favicons/favicon.svg"><span>GitHub</span></p></div><p><img src="https://avatars0.githubusercontent.com/u/5553757?u=481cbf7ca1b1a5b9740b088b5a4f7c2515fd137e&amp;v=4"></p></a></figure><p>In the next blog post I'd like to address the notion that CRDTs increase the complexity of an application. Yjs has a collaboration-aware model that is very helpful for implementing features such as commenting, shared cursors, position markers, presence, or suggestions on collaborative (rich)-text documents. Implementing a CRDT like Yjs including its optimizations correctly is not trivial. I will discuss methods that I use to test distributed systems that give me a high confidence that documents will always converge.</p><hr><h3 id="notes-">Notes:</h3><ul><li><a href="https://arxiv.org/abs/1905.01302">Recent publications</a> describe Yjs as a CRDT that performs some kind of garbage collection scheme to collect tombstones to reduce the size of the document. The document size only decreases because of the optimizations that are laid out in this article. Yjs doesn't perform a garbage collection scheme that would result in convergence issues. To be fair, my first publication in 2016 described a garbage collection scheme including its limitations. The mentioned garbage collection scheme did work as intended, but was never enabled by default because it, as it was described, only works under specific circumstances and needed more work. The garbage collection approach has been removed in 2017 and replaced by a compound representation to improve performance. This article shows that tombstone garbage collection is not even necessary for CRDTs to work in practice.</li><li>It is often claimed that CRDTs are faster than <a href="https://en.wikipedia.org/wiki/Operational_transformation">OT</a>. I explained before that academic research mostly measures performance in ops/second, which doesn't really reflect the requirements of shared editing applications. In practice, several CRDTs are unsuitable for shared editing because they don't perform well in certain scenarios. Centralized approaches have an edge over CRDTs when it comes to <code>parseTime</code>. In <a href="https://github.com/share/sharedb">ShareDB</a>, for example, the document is sent to the client with little additional metadata and the document can be parsed much faster. Decentralized approaches send additional metadata that incur a parsing overhead. However, this article shows that this overhead is not that significant in Yjs.</li></ul>
  </div>
    
</article>              


  </main>
</div>
      </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>