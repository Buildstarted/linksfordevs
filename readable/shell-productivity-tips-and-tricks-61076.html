<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Shell productivity tips and tricks - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Shell productivity tips and tricks - linksfor.dev(s)"/>
    <meta property="article:author" content="Balthazar Rouberol"/>
    <meta property="og:description" content="An introduction to shell productivity features: autocompletion, keyboard shortcuts, history navigation and shell expansions."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.balthazar-rouberol.com/shell-productivity-tips-and-tricks.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Shell productivity tips and tricks</title>
<div class="readable">
        <h1>Shell productivity tips and tricks</h1>
            <div>by Balthazar Rouberol</div>
            <div>Reading time: 22-27 minutes</div>
        <div>Posted here: 25 Apr 2020</div>
        <p><a href="https://blog.balthazar-rouberol.com/shell-productivity-tips-and-tricks.html">https://blog.balthazar-rouberol.com/shell-productivity-tips-and-tricks.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
        


    <p><img src="https://balthazar-rouberol-blog.s3.eu-west-3.amazonaws.com/shell-productivity/header.jpg"></p><header>
<p>
    This article is part of a self-published book project by Balthazar Rouberol and <a href="https://etnbrd.com/">Etienne Brodu</a>, ex-roommates, friends and colleagues, aiming at empowering the up and coming generation of developers. We currently are hard at work on it!
</p>
<p>
  If you are interested in the project, we invite you to join the <a href="https://balthazar-rouberol.us4.list-manage.com/subscribe?u=1f6080d496af07a836270ff1d&amp;id=81ebd36adb">mailing list</a>!
</p>
</header>

<h2>Table of Contents</h2>
<!-- MarkdownTOC autolink="true" levels="2" autoanchor="true" -->

<ul>
<li><a href="#tab-completion">Tab completion</a></li>
<li><a href="#keyboard-shortcuts">Keyboard shortcuts</a></li>
<li><a href="#navigating-through-history">Navigating through history</a></li>
<li><a href="#shell-expansions">Shell expansions</a></li>
<li><a href="#real-life-examples">Real-life examples</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#going-further">Going further</a></li>
</ul>
<!-- /MarkdownTOC -->


<p>I estimate that I spend around 50% of my day working in my text editor
and my terminal. Any way I can get more productive in these environments
has a direct and measurable impact on my daily productivity as a whole.</p>
<p>If you spend a good chunk of your day repeatedly hitting the left and
right arrow keys to navigate in long commands or correct typos, or
hitting the up or down arrow keys to navigate your command history, this
chapter should help you get more done quicker. We will cover some shell
features you can leverage to make your shell do more of the work for
you.</p>
<p>On a personal level, I probably use some of these up to 30 times a day,
sometimes even without thinking about it, and it gives me a real sense
of ownership of my tool.</p>
<p>In the immortal words of Kimberly “Sweet Brown” Wilkins:</p>
<blockquote>
<p>Ain't nobody got time for that.</p>
</blockquote>

<h2>Tab completion</h2>
<p>When you are typing in your shell, I suggest you treat the
<kbd>Tab</kbd> key as a superpower. Indeed, the same way your phone
keyboard can autocomplete words for you, so can your shell. It can
suggest completions of command names and even command arguments or
options! This works by pressing <kbd>Tab</kbd> (twice for <code>bash</code> and
once for <code>zsh</code>).</p>
<p>One of the reasons <code>zsh</code> might be favored over <code>bash</code> is its more
powerful auto-completion system, giving more results out-of-the-box and
allowing you to navigate through the auto-completion options.</p>
<p>Here is an example of <code>bash</code> auto-completing a command name:</p>



<p>Here is an example of <code>bash</code> auto-completing a command argument:</p>
<div><pre><span></span>$ <span>man</span> mkd<span>&lt;</span>Tab&gt;
<span>mkdir</span>         mkdirat       mkdtemp       mkdtempat_np
</pre></div>


<p>And finally, an example of <code>bash</code> auto-completing a command option:</p>
<div><pre><span></span>$ <span>python</span> -<span>&lt;</span>Tab&gt;
-    -3   -B   -E   -O   -OO  -Q   -R   -S   -V   -W
-b   -c   -d   -h   -i   -m   -s   -t   -u   -v   -x
</pre></div>


<p>I suggest you get used to using auto-completion as much as possible. It
can save you keystrokes, as well as make you discover command options
you didn't know about.</p>
<p>Pro-tip: if you are using bash, you can get install the
<code>bash-completion</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> package (using your system package-manager) in
order to enable auto-completion for a wide variety of commands that do
not support it out-of-the-box.</p>

<h2>Keyboard shortcuts</h2>
<p>The shell uses a library called <code>readline</code><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> to provide you with many
keyboard shortcuts to navigate, edit, cut, paste, search, etc, in the
command line. Mastering these will help to dramatically increase your
efficiency, instead of copying and pasting with your mouse, and
navigating the command with the <kbd>↑</kbd> and <kbd>↓</kbd> arrow
keys.</p>
<p>The default shortcuts are inspired by the <code>emacs</code><sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> terminal-based
text editor. If you are already familiar with it, a lot of the default
<code>readline</code> shortcuts might feel familiar. <code>emacs</code> isn't the only famous
text editor in the history of computers though: another one, dating back
from 1976, is <code>vi</code>.<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup> <code>vi</code> and <code>emacs</code> are designed in two very
different ways, and have two very different logics. It is possible that
one might “click” more than the other for you. If you happen to be
familiar with the <code>vi</code> editor and are accustomed to its navigation
system, you can replicate it in your shell as well by adding <code>set -o vi</code>
in your shell configuration file. If you are using <code>zsh</code> with the Oh My
Zsh framework that we introduced in the previous chapter, you can also
use the <code>vi-mode</code> plugin to do this.</p>
<p>The advantage of using the same navigation logic and shortcuts in your
text editor and your terminal is that is blurs the line between both,
and brings consistency to your terminal environment. If you have no clue
how <code>emacs</code> or <code>vi</code> work though, I would probably suggest you don't
worry about all this for now and experiment with the default terminal
shortcuts.</p>
<h3>Navigating the current line</h3>
<p>The following navigation shortcuts allow you to move quickly your cursor
in the current command saving you from relying solely on the
<kbd>→</kbd> and <kbd>←</kbd> arrows.</p>
<table>
<thead>
<tr>
<th>Navigation</th>
<th>Shortcut</th>
</tr>
</thead>
<tbody>
<tr>
<td>Go to beginning of line</td>
<td><kbd>Ctrl</kbd> - <kbd>A</kbd></td>
</tr>
<tr>
<td>Go to end of line</td>
<td><kbd>Ctrl</kbd> - <kbd>E</kbd></td>
</tr>
<tr>
<td>Go to next word</td>
<td><kbd>Alt</kbd> - <kbd>F</kbd></td>
</tr>
<tr>
<td>Go to previous word</td>
<td><kbd>Alt</kbd> - <kbd>B</kbd></td>
</tr>
<tr>
<td>Toggle your cursor between its current position and the beginning of line</td>
<td><kbd>Ctrl</kbd> - <kbd>X</kbd> - <kbd>X</kbd></td>
</tr>
</tbody>
</table>
<p>If you however prefer using the <code>vi</code> navigation system, you will first
need to type <kbd>Esc</kbd> to switch from the <em>Insertion</em> mode to an
emulation of <code>vi</code>'s <em>normal</em> mode, in which you can navigate in your
text using the following shortcuts:</p>
<table>
<thead>
<tr>
<th>Navigation</th>
<th>Shortcut</th>
</tr>
</thead>
<tbody>
<tr>
<td>Go to beginning of line</td>
<td><kbd>^</kbd></td>
</tr>
<tr>
<td>Go to end of line</td>
<td><kbd>$</kbd></td>
</tr>
<tr>
<td>Go to next word</td>
<td><kbd>w</kbd></td>
</tr>
<tr>
<td>Go to previous word</td>
<td><kbd>b</kbd></td>
</tr>
<tr>
<td>Move to the end of the previous word</td>
<td><kbd>e</kbd></td>
</tr>
</tbody>
</table>
<p>You can go back to editing your command line by hitting the <code>i</code> key.</p>
<h3>Deleting and editing text</h3>
<p>These shortcuts allow you to quickly edit the current command more
efficiently than by just using the <kbd>Delete</kbd> key.</p>
<table>
<thead>
<tr>
<th>Edition</th>
<th>Shortcut</th>
</tr>
</thead>
<tbody>
<tr>
<td>Delete current character</td>
<td><kbd>Ctrl</kbd> - <kbd>D</kbd></td>
</tr>
<tr>
<td>Delete previous word</td>
<td><kbd>Ctrl</kbd> - <kbd>W</kbd></td>
</tr>
<tr>
<td>Delete next word</td>
<td><kbd>Alt</kbd> - <kbd>D</kbd></td>
</tr>
<tr>
<td>Edit the current command in your text editor</td>
<td><kbd>Ctrl</kbd> - <kbd>X</kbd> <kbd>Ctrl</kbd> - <kbd>E</kbd></td>
</tr>
<tr>
<td>Undo previous action(s)</td>
<td><kbd>Ctrl</kbd> - <kbd>-</kbd></td>
</tr>
</tbody>
</table>
<p>The equivalent <code>vi</code>-style shortcuts are:</p>
<table>
<thead>
<tr>
<th>Edition</th>
<th>Shortcut</th>
</tr>
</thead>
<tbody>
<tr>
<td>Replace current character by another (ex: <em>e</em>)</td>
<td><kbd>r</kbd> - <kbd>e</kbd></td>
</tr>
<tr>
<td>Delete current character</td>
<td><kbd>x</kbd></td>
</tr>
<tr>
<td>Delete previous word</td>
<td><kbd>d</kbd> - <kbd>b</kbd></td>
</tr>
<tr>
<td>Delete next word</td>
<td><kbd>d</kbd> - <kbd>w</kbd></td>
</tr>
<tr>
<td>Edit the current command in your text editor</td>
<td><kbd>v</kbd></td>
</tr>
<tr>
<td>Undo previous action(s)</td>
<td><kbd>u</kbd></td>
</tr>
</tbody>
</table>
<h3>Cutting and pasting</h3>
<p>The shell provides you with shortcuts to cut and paste commands quickly
without using your mouse.</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Shortcut</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cut current word before the cursor</td>
<td><kbd>Ctrl</kbd> - <kbd>W</kbd></td>
</tr>
<tr>
<td>Cut from cursor to end of line</td>
<td><kbd>Ctrl</kbd> - <kbd>K</kbd></td>
</tr>
<tr>
<td>Cut from cursor to start of line</td>
<td><kbd>Ctrl</kbd> - <kbd>U</kbd></td>
</tr>
<tr>
<td>Paste the cut buffer at current position</td>
<td><kbd>Ctrl</kbd> - <kbd>Y</kbd></td>
</tr>
</tbody>
</table>
<p>The equivalent <code>vi</code>-style shortcuts are:</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Shortcut</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cut current word before the cursor</td>
<td><kbd>d</kbd> - <kbd>w</kbd></td>
</tr>
<tr>
<td>Cut from cursor to end of line</td>
<td><kbd>d</kbd> - <kbd>$</kbd></td>
</tr>
<tr>
<td>Cut from cursor to start of line</td>
<td><kbd>d</kbd> - <kbd>^</kbd></td>
</tr>
<tr>
<td>Paste the cut buffer at current position</td>
<td><kbd>p</kbd></td>
</tr>
</tbody>
</table>
<h3>Controlling the terminal</h3>
<p>Finally, these shortcuts will let you interact with the terminal itself.</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Shortcut</th>
<th>Equivalent command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clear the terminal screen</td>
<td><kbd>Ctrl</kbd> - <kbd>L</kbd></td>
<td><code>clear</code></td>
</tr>
<tr>
<td>Close the terminal screen</td>
<td><kbd>Ctrl</kbd> - <kbd>D</kbd></td>
<td><code>exit</code></td>
</tr>
<tr>
<td>Send current command to the background.</td>
<td><kbd>Ctrl</kbd> - <kbd>Z</kbd></td>
<td></td>
</tr>
</tbody>
</table>
<p>Even mastering <em>some</em> of these shortcuts should make you immensely more
productive at typing commands and navigating command-line interfaces. I
suggest you take time to experiment until you feel more accustomed with
them. I can guarantee that you will feel the productivity boost!</p>
<h3>A unified command-line editing experience</h3>
<p>These shortcuts do not just work in your shell, but in any application
using the <code>readline</code> library to allow the user to type and edit
commands. Learning these shortcuts will thus make you productive in all
types of command lines that you might encounter in your career, such as
<code>python</code>, <code>irb</code>, <code>sqlite3</code>, etc.</p>
<p>To make sure you get a smooth and homogeneous editing experience in all
command lines you use in your system, you can set your preferred mode in
the <code>readline</code> configuration file itself.</p>
<div><pre><span></span>$ <span>cat</span> ~/.inputrc
<span>set</span> editing-mode vi  <span># or emacs</span>
</pre></div>



<h2>Navigating through history</h2>
<p>If you find yourself typing a certain command times and times again, you
should probably be aware of how to navigate and search your shell
history, in order to save time and keystrokes.</p>
<p>While the obvious way to re-execute a previous command might seem to
just bash on the <kbd>↑</kbd> key until you find the command you want,
there are faster and smarter ways to accomplish this.</p>
<h3>Searching the history</h3>
<p>A very useful and time-saving trick is searching for a command into your
shell history instead of re-typing it from scratch. You can search your
command history by typing <kbd>Ctrl</kbd> - <kbd>R</kbd> which opens a
<code>reverse-i-search</code> (backwards search) prompt, in which you can search
for previously executed command containing a given search pattern.</p>
<p>Type <kbd>Ctrl</kbd> - <kbd>R</kbd> to navigate through the results,
until you find the one you were looking for and type the
<kbd>Enter</kbd> key to execute it.</p>
<div><pre><span></span>$ <span>&lt;</span>Ctrl-R&gt;
<span>(</span>reverse-i-search<span>)</span>: <span>echo</span> <span>&lt;</span>Ctrl-R&gt; <span>&lt;</span>Enter&gt;
$ <span>echo</span> <span>"hello world"</span>
hello world
</pre></div>


<p>If you want to stop the search, either hit
<kbd>Ctrl</kbd> - <kbd>C</kbd> or <kbd>Ctrl</kbd> - <kbd>G</kbd> to be
sent back into the regular shell prompt.</p>
<p>History search works by looking into the shell history file
(<code>~/.bash_history</code> for <code>bash</code> and <code>~/.zsh_history</code> for <code>zsh</code> by
default). Every time you execute a command, it will be added to your
shell history file (with a maximum number of retained commands defined
by the <code>HISTSIZE</code> environment variable).</p>
<p>The location of your shell history file can be configured by setting the
<code>HISTFILE</code> environment variable.</p>
<h3>Rewriting history</h3>
<p>If you want to remove a sensitive command from your history, you can
simply edit your <code>$HISTFILE</code> history file and remove it.</p>
<div><pre><span></span>$ secret-command --password 1234qwerty  <span># oh no! that should not be in my history!</span>
$ <span>grep</span> secret-command <span>$HISTFILE</span>
secret-command --password 1234qwerty
$ <span>sed</span> -i <span>'/secret-command/d'</span> <span>$HISTFILE</span>  <span># deletion of history line containing 'secret-command'</span>
$ <span>grep</span> secret-command <span>$HISTFILE</span>
$ <span># it's not in history anymore</span>
</pre></div>


<p>You can also use the <code>history</code> built-in command to display your whole
history</p>
<div><pre><span></span>$ <span>history</span> <span>|</span> <span>tail</span> -n <span>5</span>
  <span>496</span>  <span>mkdir</span> <span>test</span>
  <span>497</span>  secret-command --password 1234qwerty
  <span>498</span>  <span>cd</span>
  <span>499</span>  <span>man</span> <span>history</span>
  <span>500</span>  <span>history</span> <span>|</span> <span>tail</span> -n <span>5</span>
</pre></div>


<p>Each history line is prefixed by its index in the history. You can then
use <code>history -d &lt;index&gt;</code> to remove the associated line from history.</p>
<div><pre><span></span>$ <span>history</span> -d <span>497</span>
$ <span>history</span> <span>|</span> <span>tail</span> -n <span>7</span>
  <span>496</span>  <span>mkdir</span> <span>test</span>
  <span>497</span>  <span>cd</span>
  <span>498</span>  <span>man</span> <span>history</span>
  <span>499</span>  <span>history</span> <span>|</span> <span>tail</span> -n <span>5</span>
  <span>500</span>  <span>history</span> -d <span>497</span>
  <span>501</span>  <span>history</span> <span>|</span> <span>tail</span> -n <span>7</span>
</pre></div>


<p>This only works with <code>bash</code>, not <code>zsh</code>.</p>
<h3>Avoiding history</h3>
<p>There is a trick you can use if you want to fly under the radar and
never have a command recorded in history in the first place. Simply
prefix your command by a space.</p>
<p>If you are using <code>zsh</code>, you need to add <code>setopt HIST_IGNORE_SPACE</code> in
your <code>~/.zshrc</code> to make sure that behavior is enabled.</p>
<div><pre><span></span>$  secret-command --password 1234qwerty  <span># notice the space at the start of the command!</span>
$ <span>history</span> <span>|</span> <span>tail</span> -n <span>2</span>
  <span>502</span>  <span>history</span> <span>|</span> <span>tail</span> -n <span>7</span>
  <span>503</span>  <span>history</span> <span>|</span> <span>tail</span> -n <span>2</span>
</pre></div>



<h2>Shell expansions</h2>
<p>The shell can perform expansions, meaning it can replace portions of the
command before executing it. Relying on expansions allows you to type
less and rely on the shell itself to do the heavy lifting. While there
are multiple types of expansions, we will only cover 5:</p>
<ul>
<li>history expansion: quickly access previous commands and arguments
    from history</li>
<li>tilde expansion: replace the <code>~</code> path prefix</li>
<li>pathname expansion: expand a path pattern into a list of files</li>
<li>braces expansion: expand a pattern between braces into a longer
    sequence</li>
<li>command expansion: replace a sub-command by its output</li>
</ul>
<p>Expansions are extremely powerful. When used right, an expansion can
literally save you from writing a script.</p>
<p>As we only over what we think are the most useful expansions and
shortcuts, feel free to refer to the <code>bash</code> manual, section <code>EXPANSION</code>
if you want to see the full list.</p>
<h3>History expansion</h3>
<p>Your shell has multiple tricks up its sleeve to allow you to quickly
reference previous commands or arguments in history with a minimum of
keystrokes. While this section only provides you with what we feel are
the most useful of them, feel free to go to the <code>HISTORY EXPANSION</code>
section of the <code>bash</code> manual.</p>
<h4>Event designators</h4>
<p>An <em>Event designator</em> is a reference to a command line entry in the
history list. It allows you to quickly refer to a previous command
without having to re-type it.</p>
<h5><code>!-n</code></h5>
<p><code>!-n</code> refers to the nth latest command: <code>!-1</code> refers to the latest
command, <code>!-2</code> to the command before that, etc.</p>
<div><pre><span></span>$ <span>echo</span> <span>"hello world!"</span>
hello world!
$ <span>cd</span>
$ !-2  <span># !-1 is "cd" and !-2 is 'echo "hello world!"'</span>
$ <span>echo</span> <span>"hello world"</span>
hello world
</pre></div>


<p><code>!!</code> is a shortcut for <code>!-1</code>, aka the latest command.</p>
<div><pre><span></span>$ <span>echo</span> <span>"hello world!"</span>
hello world!
$ <span>!!</span>
$ <span>echo</span> <span>"hello world"</span>
hello world
</pre></div>


<div>
<p><code>!!</code> is oftentimes used in conjunction with <code>sudo</code>, to re-execute the
previous command with superuser privileges when it failed, due to a lack
of permission.</p>
<div><pre><span></span>$ <span>vim</span> /etc/myfile
vim: /etc/myfile: Permission denied
$ <span>sudo</span> <span>!!</span>
$ <span>sudo</span> <span>vim</span> /etc/myfile
</pre></div>


</div>
<h5><code>^string1^string2</code></h5>
<p><code>^string1^string2</code> is used to repeat the previous command in which
<code>string1</code> is replaced by <code>string2</code>.</p>
<div><pre><span></span>$ <span>cat</span> ./myfile
Just a file full of junk
$ ^cat^rm
$ <span>rm</span> ./myfile
</pre></div>


<p>I personally use and abuse of this technique when I'm about to
irremediably delete some resources (files, folders, containers, etc),
and I want to make sure I'm about to delete the <em>right</em> things by
listing these resources first. If you are familiar with SQL queries, it
is the equivalent of executing a <code>SELECT</code> query before changing the
<code>SELECT</code> to <code>DELETE</code> to make sure you're not going to delete more than
you wanted to.</p>
<h4>Word designators</h4>
<p>Word designators are used to select desired words from a previous
command (by default, the latest). They can be very useful when you want
to type a new command that uses arguments previously typed in a previous
command.</p>
<h5><code>!^</code></h5>
<p><code>!^</code> maps to the first argument of your latest command.</p>
<div><pre><span></span>$ <span>touch</span> first.txt second.txt last.txt
$ <span>vim</span> <span>!^</span>
$ <span>vim</span> first.txt
</pre></div>


<h5><code>!$</code></h5>
<p><code>!$</code> maps to the last argument of your latest command.</p>
<div><pre><span></span>$ <span>touch</span> first.txt second.txt last.txt
$ <span>vim</span> !$
$ <span>vim</span> last.txt
</pre></div>


<h5>Combining event and word designators</h5>
<p>You can even combine event and word designators in more complex shapes
by using the following syntax</p>
<div><pre><span></span><span>[</span><span>EVENT</span> <span>DESIGNATOR</span><span>]</span><span>:</span><span>[</span><span>WORD</span> <span>DESIGNATOR</span><span>]</span>
</pre></div>


<p>For example, you could use the <code>!!</code> event designator to select the last
command, and the <code>2</code> word designator to select the second argument.</p>
<div><pre><span></span>$ <span>touch</span> first.txt second.txt last.txt
$ <span>vim</span> !!:2
$ <span>vim</span> second.txt
</pre></div>


<h3>Tilde expansion</h3>
<p>For each unquoted word starting with <code>~</code> in the command, all characters
preceding a forward slash (<code>/</code>) will be considered a <em>tilde prefix</em>.
Depending on its actual value, the tilde prefix can be expanded several
ways, although the simple <code>~</code> is probably its most common use.</p>
<table>
<thead>
<tr>
<th>Tilde prefix</th>
<th>Expansion</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~</code></td>
<td>Your home directory</td>
</tr>
<tr>
<td><code>~+</code></td>
<td>Your current working directory</td>
</tr>
<tr>
<td><code>~-</code></td>
<td>Your previous working directory</td>
</tr>
</tbody>
</table>
<p><strong>Example</strong></p>
<div><pre><span></span>$ <span>ls</span> <span>~</span>
Android                code       Downloads              Music
AndroidStudioProjects  Desktop    Dropbox                Pictures
bin                    Documents  Firefox_wallpaper.png  Videos
</pre></div>


<p>This lists the content of your home directory, and is the equivalent to
<code>ls $HOME</code>. You can combine the tilde with a suffix to compose an
absolute path to some file or folder in your home directory.</p>
<div><pre><span></span>$ <span>cd</span> ~/code
$ <span>pwd</span>
/home/br/code
</pre></div>


<h3>Pathname expansion</h3>
<p>Pathname expansions allow you to write an short path pattern and have it
expanded in a list of files and directories, saving you from tedious
copy-pastes or a possibly long (and error-prone) command writing.</p>
<h4><code>*</code></h4>
<p>The <em>glob</em>, or <em>wildcard</em> <code>*</code> character matches any string. It allows
you to give a <em>pattern</em> to the shell, that it will then expand to all
files and directories matching the pattern. The wildcard can be prefixed
or suffixed, which will further specify our pattern. For example,
<code>*.jpg</code> matches all files ending with the <code>.jpg</code> extension, and
<code>README.*</code> matches all files named <code>README</code> whatever their extension.</p>
<p>Let us consider the following file and directory structure.</p>
<div><pre><span></span>$ <span>tree</span>
.
<span>|</span>-- pic1.jpg
<span>|</span>-- pic2.jpg
<span>|</span>-- pic3.jpg
<span>|</span>-- pic4.jpg
<span>\_</span>_ pics
<span>|</span>   <span>|</span>-- pic5.jpg
<span>|</span>   <span>|</span>-- pic6.jpg
<span>|</span>   <span>\_</span>_ pic7.jpg
<span>\_</span>_ sounds
    <span>\_</span>_sound1.mp3

<span>2</span> directory, <span>8</span> files
</pre></div>


<p>We want to move all <code>jpg</code> files into our <code>pics</code> directory. Instead of
running 4 different <code>mv</code> commands or manually typing a long <code>mv</code>
command, we can run just one using a pathname expansion.</p>
<div><pre><span></span>$ <span>mv</span> *.jpg pics
$ <span>tree</span>
.
<span>\_</span>_ pics
<span>|</span>   <span>|</span>-- pic1.jpg
<span>|</span>   <span>|</span>-- pic2.jpg
<span>|</span>   <span>|</span>-- pic3.jpg
<span>|</span>   <span>|</span>-- pic4.jpg
<span>|</span>   <span>|</span>-- pic5.jpg
<span>|</span>   <span>|</span>-- pic6.jpg
<span>|</span>   <span>\_</span>_ pic7.jpg
<span>\_</span>_ sounds
    <span>\_</span>_sound1.mp3

<span>2</span> directory, <span>8</span> files
</pre></div>


<p><code>*.jpg</code> was expanded to all files ending with <code>.jpg</code>, causing the shell
to actually run <code>mv pic1.jpg pic2.jpg pic3.jpg pic4.jpg pics</code>, causing
all 4 <code>jpg</code> files to be moved to the <code>pics</code> directory in a single
command.</p>
<div>
<p>We could have executed the following commands for the same result:</p>
<ul>
<li><code>mv pic* pics</code> would have moved all files with name starting by
    <code>pic</code> to the <code>pics</code> directory</li>
<li><code>mv pic*.jpg pics</code> would have moved all files with name starting by
    <code>pic</code> and ending with <code>.jpg</code> to the <code>pics</code> directory</li>
</ul>
</div>
<p>You can use <code>*</code> several times within the same pattern. For example
<code>ls */*</code> will list all files and directories located in a subdirectory.</p>
<div><pre><span></span>$ <span>ls</span> */*
sounds/sound1.mp3   pics/pic2.jpg       pics/pic4.jpg       pics/pic6.jpg
pics/pic1.jpg       pics/pic3.jpg       pics/pic5.jpg       pics/pic7.jpg
</pre></div>


<p>Like in our second example, we can also use <code>*/*.jpg</code> to list all <code>jpg</code>
files located in a subdirectory.</p>
<div><pre><span></span>$ <span>ls</span> */*.jpg
pics/pic1.jpg   pics/pic3.jpg   pics/pic5.jpg  pics/pic7.jpg
pics/pic2.jpg   pics/pic4.jpg   pics/pic6.jpg
</pre></div>


<h4><code>**</code></h4>
<p><code>**</code> is expanded to all files and directories in the children
directories, with a depth limit of 1.</p>
<div><pre><span></span>$ <span>touch</span> README.txt
$ <span>mkdir</span> sounds/lyrics
$ <span>touch</span> sounds/lyrics/sound1.txt
$ <span>tree</span>
.
<span>|</span>-- README.txt
<span>\_</span>_ pics
<span>|</span>   <span>|</span>-- pic1.jpg
<span>|</span>   <span>|</span>-- pic2.jpg
<span>|</span>   <span>|</span>-- pic3.jpg
<span>|</span>   <span>|</span>-- pic4.jpg
<span>|</span>   <span>|</span>-- pic5.jpg
<span>|</span>   <span>|</span>-- pic6.jpg
<span>|</span>   <span>\_</span>_ pic7.jpg
<span>\_</span>_ sounds
    <span>\_</span>_ lyrics
    <span>|</span>   <span>\_</span>_sound1.txt
    <span>\_</span>_sound1.mp3

<span>3</span> directories, <span>10</span> files
$ <span>ls</span> **
README.txt

pics:
pic1.jpg pic2.jpg pic3.jpg pic4.jpg pic5.jpg pic6.jpg pic7.jpg

sounds:
lyrics     sounds.mp3
</pre></div>


<p><code>ls **</code> was expanded into <code>ls README.txt pics/ sounds/</code>, which does not
include the content of <code>sounds/lyrics</code> because of the depth limit of 1.</p>
<h4><code>**/</code></h4>
<p><code>**/</code> is expanded into all directories and subdirectories with a depth
limit of 1 starting from our first directory.</p>
<div><pre><span></span>$ <span>tree</span>
.
<span>|</span>-- README.txt
<span>\_</span>_ pics
<span>|</span>   <span>|</span>-- pic1.jpg
<span>|</span>   <span>|</span>-- pic2.jpg
<span>|</span>   <span>|</span>-- pic3.jpg
<span>|</span>   <span>|</span>-- pic4.jpg
<span>|</span>   <span>|</span>-- pic5.jpg
<span>|</span>   <span>|</span>-- pic6.jpg
<span>|</span>   <span>\_</span>_ pic7.jpg
<span>\_</span>_ sounds
    <span>\_</span>_ lyrics
    <span>|</span>   <span>\_</span>_sound1.txt
    <span>\_</span>_sound1.mp3


<span>3</span> directories, <span>10</span> files
$ <span>ls</span> **/
pics/:
pic1.jpg pic2.jpg pic3.jpg pic4.jpg pic5.jpg pic6.jpg pic7.jpg

sounds/:
lyrics     sounds.mp3

sounds/lyrics/:
sound1.txt
</pre></div>


<p><code>ls **/</code> was expanded into <code>ls sounds/ sounds/lyrics pics/</code>. It thus
listed all files located in our subdirectories.</p>
<h3>Brace expansion</h3>
<p>A brace expansion is a mechanism by which the shell can generate
multiple strings based on a sequence of tokens defined within curly
braces. The brace expansion pattern can be preceded by an optional
<em>preamble</em> and followed by an optional <em>postscript</em>.</p>
<div><pre><span></span>$ <span>mkdir</span> ~/test/<span>{</span>pics,sounds,sprites<span>}</span>
$ <span>ls</span> ~/test
pics  sounds  sprites
</pre></div>


<p><code>~/test/{pics,sounds,sprites}</code> was expanded into
<code>~/test/pics ~/test/sounds ~/test/sprites</code> causing the shell to execute
<code>mkdir ~/test/pics ~/test/sounds ~/test/sprites</code> (which will be expanded
further into
<code>mkdir /home/br/test/pics /home/br/test/sounds /home/br/test/sprites</code> by
a tilde expansion).</p>
<p>We could have done the same thing by factoring the final <code>s</code> of each
token into a postscript.</p>
<div><pre><span></span>$ <span>mkdir</span> ~/test/<span>{</span>pic,sound,sprite<span>}</span>s
</pre></div>


<p>A brace expansion can also have a sequence pattern <code>{x..y[..incr]}</code>
where <code>x</code> and <code>y</code> are either an integer or a single character, and
<code>incr</code> is an optional increment value.</p>
<div><pre><span></span>$ <span>touch</span> ~/test/sounds/noise-<span>{</span><span>1</span>..5<span>}</span>.mp3
$ <span>ls</span> ~/test/sounds
noise-1.mp3 noise-2.mp3 noise-3.mp3 noise-4.mp3 noise-5.mp3
</pre></div>


<p>The default increment is 1 if the sequence end is greater than its
start, and -1 otherwise. However, we could specify a custom increment
value if we want.</p>
<div><pre><span></span>$ <span>touch</span> ~/test/pics/pic<span>{</span><span>1</span>..10..2<span>}</span>.jpg
$ <span>ls</span> ~/test/pics
pic1.jpg pic3.jpg pic5.jpg pic7.jpg pic9.jpg
</pre></div>


<h3>Command expansion</h3>
<p>Your shell can replace a command surrounded by <code>$()</code> with its output.</p>
<p>I personally like use to commands expansions to iterate over a
command's result, or by combining it with a heredoc redirection:</p>
<div><pre><span></span>$ <span>cat</span> <span>&lt;&lt;EOF &gt; aboutme</span>
<span>My name is $(whoami)</span>
<span>and I live in $HOME</span>
<span>EOF</span>
$ <span>cat</span> aboutme
My name is br
and I live in /home/br
</pre></div>



<h2>Real-life examples</h2>
<h3>Moving a pattern of files contained in directories and subdirectories</h3>
<p>What is really powerful with these expansions is that, like almost
everything in the shell, they can be combined. The following example
combines a pathname expansion, a brace expansion and a tilde expansion.</p>
<div><pre><span></span>$ <span>tree</span>
.
<span>|</span>-- README.txt
<span>\_</span>_ pics
<span>|</span>   <span>|</span>-- pic1.jpg
<span>|</span>   <span>|</span>-- pic2.jpg
<span>|</span>   <span>|</span>-- pic3.jpg
<span>|</span>   <span>|</span>-- pic4.jpg
<span>|</span>   <span>|</span>-- pic5.jpg
<span>|</span>   <span>|</span>-- pic6.jpg
<span>|</span>   <span>\_</span>_ pic7.jpg
<span>\_</span>_ sounds
    <span>\_</span>_ lyrics
    <span>|</span>   <span>\_</span>_sound1.txt
    <span>\_</span>_sound1.mp3
$ <span>mv</span> **/*.<span>{</span>jpg,mp3<span>}</span> ~/assets/
$ <span>tree</span>
<span>|</span>-- README.txt
<span>\_</span>_ pics
<span>\_</span>_ sounds
    <span>\_</span>_ lyrics
        <span>\_</span>_sound1.txt
$ <span>ls</span> ~/assets
pic1.jpg   pic2.jpg   pic3.jpg   pic4.jpg   pic5.jpg   pic6.jpg   pic7.jpg   sound1.mp3
</pre></div>


<p>Using these expansions, we were able to move all <code>jpg</code> and <code>mp3</code> files
located in directories and subdirectories to the <code>assets</code> directory
located in your home directory, in exactly 27 characters!</p>
<h3>Renaming multiple directories</h3>
<p>We could use a <code>for</code> loop, pathname expansion and a command expansion to
rename all directories contained in the bcurrent directory to their
uppercase equivalent.</p>
<div><pre><span></span>$ <span>for</span> dir in */<span>;</span> <span>do</span>
    <span>mv</span> <span>"</span><span>$dir</span><span>"</span> <span>"</span><span>$(</span><span>echo</span> <span>$dir</span> <span>|</span> <span>tr</span> <span>'[:lower:]'</span> <span>'[:upper:]'</span><span>)</span><span>"</span>
  <span>done</span>
</pre></div>


<p>Let's decompose that command into its different steps:</p>
<ul>
<li>the <code>*/</code> glob pattern is expanded over the list of
    directories, on which we iterate via a <code>for</code> loop</li>
<li>we execute <code>echo $dir | tr '[:lower:]' '[:upper:]'</code>, which will
    convert the current directory name to uppercase</li>
<li>the <code>$(echo $dir | tr '[:lower:]' '[:upper:]')</code> command is expanded
    into the uppercase directory name</li>
<li>the directory is renamed into an uppercase name</li>
<li>the <code>for</code> loop iterates over the next directory name</li>
<li>we move on to the next directory and repeat the previous steps for
    each of them</li>
</ul>
<p>Iterating over paths with a <code>for</code> loop is brittle as it breaks if a path
contains a space. We will later see how to properly do it using the
<code>find</code> command.</p>

<h2>Summary</h2>
<p>Your shell has so many productivity tricks and shortcuts up its sleeve
it can be a little bit daunting. I suggest you don't try to learn them
all at once, but really just experiment with them and see what feels
natural. Even mastering some of them will make you more productive!</p>
<p>What if there is an action you find useful but you just don't like the
keyboard shortcut? Luckily for you, the next chapter will dive into how
to personalize and customize your shell.</p>

<h2>Going further</h2>
<p><strong>5.1</strong>: Create a directory. Use a bash expansion to move into that
directory without typing its name a second time.</p>
<p><strong>5.2</strong>: Print your 4th last command typed into your terminal without
re-typing it.</p>
<p><strong>5.3</strong>: Create the following empty files <code>README.txt</code>,
<code>requirements.txt</code> and <code>TODO.txt</code> in a single command, without typing
<code>.txt</code> more than once.</p>
<p><strong>5.4</strong>: Delete all the files created in the last question without
typing <code>.txt</code> more than once.</p>
<p><strong>5.5</strong>: Create the following directory tree in a single command.</p>
<div><pre><span></span>files
<span>|</span>-- <span>1</span>
<span>|</span>   <span>|</span>-- 1a
<span>|</span>   <span>|</span>-- 1b
<span>|</span>   <span>|</span>-- 1c
<span>|</span>   <span>|</span>-- 2a
<span>|</span>   <span>|</span>-- 2b
<span>|</span>   <span>|</span>-- 2c
<span>|</span>   <span>|</span>-- 3a
<span>|</span>   <span>|</span>-- 3b
<span>|</span>   <span>\-</span>- 3c
<span>|</span>-- <span>2</span>
<span>|</span>   <span>|</span>-- 1a
<span>|</span>   <span>|</span>-- 1b
<span>|</span>   <span>|</span>-- 1c
<span>|</span>   <span>|</span>-- 2a
<span>|</span>   <span>|</span>-- 2b
<span>|</span>   <span>|</span>-- 2c
<span>|</span>   <span>|</span>-- 3a
<span>|</span>   <span>|</span>-- 3b
<span>|</span>   <span>\-</span>- 3c
<span>\-</span>- <span>3</span>
    <span>|</span>-- 1a
    <span>|</span>-- 1b
    <span>|</span>-- 1c
    <span>|</span>-- 2a
    <span>|</span>-- 2b
    <span>|</span>-- 2c
    <span>|</span>-- 3a
    <span>|</span>-- 3b
    <span>\-</span>- 3c
</pre></div>


<p><strong>5.6</strong>: Remove all subdirectories starting with <code>3</code> created in the
previous command, while keeping the top <code>3</code> directory.</p>
<p><strong>5.7</strong>: Re-execute the command from exercise 5.3 by looking backwards
into your shell history.</p>




        


  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>