<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Fuzzing the .NET JIT Compiler -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Fuzzing the .NET JIT Compiler</h1>
    <div class="post"> <span class="post-date">28 Aug 2018 - 2934 words</span> <p>I recently came across the <a href="https://github.com/jakobbotsch/Fuzzlyn">excellent &#x2018;Fuzzlyn&#x2019; project</a>, created as part of the <a href="https://kursuskatalog.au.dk/en/course/82764/language-based-security">&#x2018;Language-Based Security&#x2019; course at Aarhus University</a>. As per the project description Fuzzlyn is a:</p> <blockquote> <p>&#x2026; fuzzer which utilizes Roslyn to generate random C# programs</p>
</blockquote> <p>And what is a &#x2018;fuzzer&#x2019;, from the <a href="https://en.wikipedia.org/wiki/Fuzzing">Wikipedia page for &#x2018;<em>fuzzing</em>&#x2019;</a>:</p> <blockquote> <p><strong>Fuzzing</strong> or <strong>fuzz testing</strong> is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program.</p>
</blockquote> <p>Or in other words, <strong>a <em>fuzzer</em> is a program that tries to create <em>source code</em> that finds <em>bugs</em> in a compiler</strong>.</p> <p>Massive kudos to the developers behind Fuzzlyn, <a href="https://twitter.com/jakobbotsch">Jakob Botsch Nielsen</a> (who helped answer my questions when writing this post), <a href="https://twitter.com/Chrizzz42">Chris Schmidt</a> and <a href="https://github.com/JonasSL"> Jonas Larsen</a>, it&#x2019;s an impressive project!! (to be clear, I have no link with the project and can&#x2019;t take any of the credit for it)</p> <h2 id="compilation-in-net">Compilation in .NET</h2> <p>But before we dive into &#x2018;Fuzzlyn&#x2019; and what it does, we&#x2019;re going to take a quick look at <strong>&#x2018;compilation&#x2019; in the .NET Framework</strong>. When you write C#/VB.NET/F# code (delete as appropriate) and compile it, the compiler converts it into <a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language">Intermediate Language (IL)</a> code. The IL is then stored in a .exe or .dll, which the Common Language Runtime (CLR) reads and executes when your program is actually run. However it&#x2019;s the job of the <a href="http://mattwarren.org/2017/12/15/How-does-.NET-JIT-a-method-and-Tiered-Compilation/#how-it-works">Just-in-Time (JIT) Compiler</a> to convert the IL code into machine code.</p> <p><strong>Why is this relevant?</strong> Because Fuzzlyn works by comparing the output of a <strong>Debug</strong> and a <strong>Release</strong> version of a program and if they are different, there&#x2019;s a bug! But it turns out that very few optimisations are actually done by the <a href="https://github.com/dotnet/roslyn">&#x2018;Roslyn&#x2019; compiler</a>, compared to what the JIT does, from Eric Lippert&#x2019;s excellent post <a href="https://blogs.msdn.microsoft.com/ericlippert/2009/06/11/what-does-the-optimize-switch-do/">What does the optimize switch do?</a> (2009)</p> <blockquote> <p>The /optimize flag <strong>does not change a huge amount of our emitting and generation logic</strong>. We try to always generate straightforward, verifiable code and then <strong>rely upon the jitter to do the heavy lifting of optimizations</strong> when it generates the real machine code. But we will do some simple optimizations with that flag set. For example, with the flag set:</p>
</blockquote> <p>He then goes on to list the 15 things that the C# Compiler will optimise, before finishing with this:</p> <blockquote> <p>That&#x2019;s pretty much it. These are very straightforward optimizations; <strong>there&#x2019;s no inlining of IL, no loop unrolling, no interprocedural analysis</strong> whatsoever. We let the jitter team worry about optimizing the heck out of the code when it is actually spit into machine code; <strong>that&#x2019;s the place where you can get real wins</strong>.</p>
</blockquote> <p>So in .NET, very few of the techniques that an <a href="https://en.wikipedia.org/wiki/Optimizing_compiler">&#x2018;Optimising Compiler&#x2019;</a> uses are done at <em>compile-time</em>. They are almost all done at <em>run-time</em> by the JIT Compiler (leaving aside <a href="/2018/06/07/CoreRT-.NET-Runtime-for-AOT/">AOT scenarios for the time being</a>).</p> <p>For reference, most of the differences in IL are there to make the code easier to debug, for instance given this C# code:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">M</span><span class="p">()</span> <span class="p">{</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="k">new</span> <span class="p">[]</span> <span class="p">{</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span> <span class="p">})</span> <span class="p">{</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">item</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The differences in IL are shown below (&#x2018;Release&#x2019; on the left, &#x2018;Debug&#x2019; on the right). As you can see there are a few extra <code class="highlighter-rouge">nop</code> instructions to allow the debugger to &#x2018;step-through&#x2019; more locations in the code, plus an extra local variable, which makes it easier/possible to see the value when debugging.</p> <p><a href="/images/2018/08/Release v Debug - IL Differences.png"><img src="/images/2018/08/Release v Debug - IL Differences.png" alt="Release v Debug - IL Differences"></a></p> <p>(click for larger image or you can view the <a href="https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLQBEJinANjASQDsYIFsBjCAgWwAdcIaITYBLAeyIBoYQ3cAHwACABgAEwgIwBuALAAoYQGZJAJnEBhcQG9F4g5NXCALOICyACgCUu/YYdgOSKBQAW4ywDcoCcW1IafyJxIggAd3EAbQBdXXEpbnE1JOUkkwBfa3sHAz0FXIcASGkATksApmsZQxzcjLqGhQygA===">&#x2018;Release&#x2019; version</a> and the <a href="https://sharplab.io/#v2:EYLgZgpghgLgrgJwgZwLQBEJinANjASQDsYIFsBjCAgWwAdcIaITYBLAeyIBoYQ3c3ACYgA1AB8AAgAYABJICMAbgCwAKEkBmeQCZZAYVkBvdbLPztkgCyyAsgAoAlMdPm3YDkigUAFrPsAblAIsmykNKFEskQQAO6yANoAusayCtyyOhmaGVYAvo6ubmYmasVuAJCKAJz2YUyOSuZFxXktbWp5QA===">&#x2018;Debug&#x2019; version</a> on the excellent <a href="https://sharplab.io/">SharpLab</a>)</p> <p>For more information on the differences in Release/Debug code-gen see the &#x2018;Release (optimized)&#x2019; section in this doc on <a href="https://github.com/dotnet/roslyn/blob/master/docs/compilers/CSharp/CodeGen%20Differences.md">CodeGen Differences</a>. Also, because Roslyn is open-source we can see how this is handled in the code:</p> <p><strong>This all means that the &#x2018;Fuzzlyn&#x2019; project has actually been finding bugs in the .NET JIT, not in the Roslyn Compiler</strong></p> <p>(well, except this one <a href="https://github.com/dotnet/roslyn/issues/29481">Finally block belonging to unexecuted try runs anyway</a>, which was <a href="https://github.com/dotnet/roslyn/pull/29517">fixed here</a>)</p> <h2 id="how-it-works">How it works</h2> <p>At the simplest level, Fuzzlyn works by compiling and running a piece of randomly generated code in &#x2018;Debug&#x2019; and &#x2018;Release&#x2019; versions and comparing the output. If the 2 versions produce different results, then it&#x2019;s a bug, specifically a bug in the <strong>optimisations</strong> that the JIT compiler has attempted.</p> <p>The .NET JIT, known as &#x2018;RyuJIT&#x2019;, has several modes. It can produce <strong>fully optimised</strong> code that has the highest-performance, or in can produce more <strong>&#x2018;debug&#x2019; friendly</strong> code that has no optimisations, but is much simpler. You can find out more about the different &#x2018;optimisations&#x2019; that RyuJIT performs in this <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-tutorial.md">excellent tutorial</a>, in this <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/performance/JitOptimizerTodoAssessment.md">design doc</a> or you can search through the code for <a href="https://github.com/dotnet/coreclr/search?q=compDbgCode&amp;unscoped_q=compDbgCode">usages of the &#x2018;compDbgCode&#x2019; flag</a>.</p> <p>From a high-level Fuzzlyn goes through the following steps:</p> <ol> <li><strong>Randomly</strong> generate a C# program</li> <li><strong>Check</strong> if the code produces an error (Debug v. Release)</li> <li><strong>Reduce</strong> the code to it&#x2019;s simplest form</li>
</ol> <p>If you want to see this in action, I ran Fuzzlyn until it produced a randomly generated program with a bug. You can see the <a href="https://gist.github.com/mattwarren/2293de54e15da4f54ac557dae09de386#file-fuzzlyn-bad-program-original-cs">original source</a> (6,802 LOC) and the <a href="https://gist.github.com/mattwarren/7bf0fa2b762b906614babc3ecfd06a80#file-fuzzlyn-bad-program-reduced-cs">reduced version</a> (28 LOC). What&#x2019;s interesting is that you can clearly see the buggy line-of-code in the <a href="https://gist.github.com/mattwarren/2293de54e15da4f54ac557dae09de386#file-fuzzlyn-bad-program-original-cs-L4547">original code</a>, before it&#x2019;s turned into a <a href="https://gist.github.com/mattwarren/7bf0fa2b762b906614babc3ecfd06a80#file-fuzzlyn-bad-program-reduced-cs-L17">simplified version</a>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Generated by Fuzzlyn v1.1 on 2018-08-22 15:19:26</span>
<span class="c1">// Seed: 14928117313359926641</span>
<span class="c1">// Reduced from 256.3 KiB to 0.4 KiB in 00:01:58</span>
<span class="c1">// Debug: Prints 0 line(s)</span>
<span class="c1">// Release: Prints 1 line(s)</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span> <span class="k">static</span> <span class="kt">short</span> <span class="n">s_18</span><span class="p">;</span> <span class="k">static</span> <span class="kt">byte</span> <span class="n">s_33</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="k">static</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">s_40</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[]{</span><span class="m">0</span><span class="p">};</span> <span class="k">static</span> <span class="kt">short</span> <span class="n">s_74</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span> <span class="p">{</span> <span class="n">s_18</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="c1">// This comparision is the bug, in Debug it&apos;s False, in Release it&apos;s True</span> <span class="c1">// However, &apos;(ushort)(s_18 | 2L)&apos; is 65,535 in Debug *and* Release</span> <span class="k">if</span> <span class="p">(((</span><span class="kt">ushort</span><span class="p">)(</span><span class="n">s_18</span> <span class="p">|</span> <span class="m">2L</span><span class="p">)</span> <span class="p">&lt;=</span> <span class="n">s_40</span><span class="p">[</span><span class="m">0</span><span class="p">]))</span> <span class="p">{</span> <span class="n">s_74</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span> <span class="kt">bool</span> <span class="n">vr10</span> <span class="p">=</span> <span class="n">s_74</span> <span class="p">&lt;</span> <span class="n">s_33</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="n">vr10</span><span class="p">)</span> <span class="p">{</span> <span class="n">System</span><span class="p">.</span><span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="random-code-generation">Random Code Generation</h3> <p>Fuzzlyn can&#x2019;t produce every type of C# program, however it does support quite a few language features, from <a href="https://github.com/jakobbotsch/Fuzzlyn#supported-constructs">Supported constructs</a>:</p> <blockquote> <p>Fuzzlyn generates only a limited subset of C#. Most importantly, it does not support loops yet. It supports structs and classes, though it does not generate member methods in these. We make no attempt to fully support all kinds of expressions and statements.</p>
</blockquote> <p>To see the code for these generators, follow the links below:</p> <p>All the statements and expressions that are currently supported are <a href="https://github.com/jakobbotsch/Fuzzlyn/blob/b1391faf9f533d1613c46118d17b7bc2b1af2c3f/Fuzzlyn/Methods/FuncGenerator.cs#L921-L943">listed here</a>. Interestingly enough the <em>type</em> of statement/expression chosen is not completely random, instead that are chosen using <a href="https://github.com/jakobbotsch/Fuzzlyn/blob/bb4b4753ed3dcdcebec52cedec475010324e7688/Fuzzlyn/FuzzlynOptions.cs#L43-L64">probability tables</a>, that look like this:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="n">ProbabilityDistribution</span> <span class="n">StatementTypeDist</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TableDistribution</span><span class="p">(</span><span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">&gt;</span> <span class="p">{</span> <span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">StatementKind</span><span class="p">.</span><span class="n">Assignment</span><span class="p">]</span> <span class="p">=</span> <span class="m">0.57</span><span class="p">,</span> <span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">StatementKind</span><span class="p">.</span><span class="n">If</span><span class="p">]</span> <span class="p">=</span> <span class="m">0.17</span><span class="p">,</span> <span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">StatementKind</span><span class="p">.</span><span class="n">Block</span><span class="p">]</span> <span class="p">=</span> <span class="m">0.1</span><span class="p">,</span> <span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">StatementKind</span><span class="p">.</span><span class="n">Call</span><span class="p">]</span> <span class="p">=</span> <span class="m">0.1</span><span class="p">,</span> <span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">StatementKind</span><span class="p">.</span><span class="n">TryFinally</span><span class="p">]</span> <span class="p">=</span> <span class="m">0.05</span><span class="p">,</span> <span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">StatementKind</span><span class="p">.</span><span class="n">Return</span><span class="p">]</span> <span class="p">=</span> <span class="m">0.01</span><span class="p">,</span> <span class="p">});</span>
</code></pre></div></div> <p>As we saw before, the initial program that Fuzzlyn produces is quite large (over 5,000 LOC), so why does it create and execute a very large program?</p> <p>Partly because it&#x2019;s quicker to do this compared to working with lots of smaller programs, i.e. the steps of generation, compilation and starting new processes can be reduced by running large programs.</p> <p>In addition, Jakob explained the other reasons:</p> <blockquote> <ul> <li><strong>Empirically, other similar projects have shown that larger programs are better</strong>. Csmith authors report that most bugs were found with examples of around 80 KB (I don&#x2019;t remember the exact number). We actually found the same thing in v1.0 &#x2013; our examples had an average size of 76 KB</li> <li><strong>Small programs do not get as many opportunities to generate a lot of patterns</strong>. For example, it is very unlikely that a small program will have a method taking a <code class="highlighter-rouge">byte</code> parameter and at the same time, a method returning a <code class="highlighter-rouge">ref byte</code> (this pattern has a bug on Linux: <a href="https://github.com/dotnet/coreclr/issues/19256">dotnet/coreclr#19256</a>).</li> <li>We mainly adjusted our probabilities based on how the examples looked. <strong>We strived for the generator to produce code that looked relatively like human code</strong>. This included going for a wide range of program sizes. By the way, you can run Fuzzlyn with <code class="highlighter-rouge">--stats --num-programs=10000</code> to get a view of the distribution of program sizes &#x2013; it will output stats for every 500 programs generated.</li> </ul>
</blockquote> <h3 id="checking-for-bugs">&#x2018;Checking&#x2019; for bugs</h3> <p>To check if the behaviour of 2 samples diverge (in &#x2018;Release&#x2019; v &#x2018;Debug&#x2019; mode), the tool inserts <a href="https://github.com/jakobbotsch/Fuzzlyn/blob/master/Fuzzlyn/Execution/ChecksumSite.cs">checksum-related code</a> throughout the program. For example here&#x2019;s a randomly generated method, note the calls to the <code class="highlighter-rouge">Checksum(..)</code> function at the end:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">sbyte</span> <span class="nf">M15</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg0</span><span class="p">)</span>
<span class="p">{</span> <span class="kt">bool</span> <span class="n">var0</span> <span class="p">=</span> <span class="p">-</span><span class="m">71</span> <span class="p">&lt;</span> <span class="n">s_1</span><span class="p">;</span> <span class="kt">uint</span> <span class="n">var1</span> <span class="p">=</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)(</span><span class="m">1U</span><span class="n">L</span> <span class="p">&amp;</span> <span class="n">s_4</span><span class="p">++);</span> <span class="k">if</span> <span class="p">(</span><span class="n">var0</span><span class="p">)</span> <span class="p">{</span> <span class="n">var0</span> <span class="p">=</span> <span class="n">var0</span><span class="p">;</span> <span class="n">arg0</span> <span class="p">=</span> <span class="n">arg0</span><span class="p">;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">ref</span> <span class="kt">ushort</span> <span class="n">var2</span> <span class="p">=</span> <span class="k">ref</span> <span class="n">s_4</span><span class="p">;</span> <span class="n">var2</span> <span class="p">=</span> <span class="n">var2</span><span class="p">;</span> <span class="n">s_rt</span><span class="p">.</span><span class="nf">Checksum</span><span class="p">(</span><span class="s">&quot;c_17&quot;</span><span class="p">,</span> <span class="n">var2</span><span class="p">);</span> <span class="p">}</span> <span class="kt">uint</span> <span class="n">var3</span> <span class="p">=</span> <span class="n">var1</span><span class="p">;</span> <span class="kt">short</span><span class="p">[]</span> <span class="n">var4</span> <span class="p">=</span> <span class="n">s_2</span><span class="p">[</span><span class="m">0</span><span class="p">][</span><span class="m">0</span><span class="p">];</span> <span class="n">s_rt</span><span class="p">.</span><span class="nf">Checksum</span><span class="p">(</span><span class="s">&quot;c_18&quot;</span><span class="p">,</span> <span class="n">arg0</span><span class="p">);</span> <span class="n">s_rt</span><span class="p">.</span><span class="nf">Checksum</span><span class="p">(</span><span class="s">&quot;c_19&quot;</span><span class="p">,</span> <span class="n">var0</span><span class="p">);</span> <span class="n">s_rt</span><span class="p">.</span><span class="nf">Checksum</span><span class="p">(</span><span class="s">&quot;c_20&quot;</span><span class="p">,</span> <span class="n">var1</span><span class="p">);</span> <span class="n">s_rt</span><span class="p">.</span><span class="nf">Checksum</span><span class="p">(</span><span class="s">&quot;c_21&quot;</span><span class="p">,</span> <span class="n">var3</span><span class="p">);</span> <span class="n">s_rt</span><span class="p">.</span><span class="nf">Checksum</span><span class="p">(</span><span class="s">&quot;c_22&quot;</span><span class="p">,</span> <span class="n">var4</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span> <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The checksums calls allow the execution of a program to be compared between &#x2018;Release&#x2019; and &#x2018;Debug&#x2019; modes, if a single variable has a different value, at <em>any point during execution</em>, the checksums will be different.</p> <p>It&#x2019;s also worth pointing out that Roslyn provides in-memory compilation that helps speed up this process because you don&#x2019;t have to <em>shell-out</em> to an external process. As <a href="https://twitter.com/jakobbotsch/status/1004384699840696320">Jakob explains</a>:</p> <blockquote> <p>Additionally since we don&#x2019;t have to start processes for every invocation when we use Roslyn&#x2019;s in-memory compilation, we can compile and check for interesting behavior <em>super</em> fast. This allows our reducer to be really simple and dumb, while still giving great results.</p>
</blockquote> <h3 id="reducing-the-output">&#x2018;Reducing&#x2019; the output</h3> <p>However, the checksums also help Fuzzlyn &#x2018;Reduce&#x2019; the program from the <a href="https://gist.github.com/mattwarren/2293de54e15da4f54ac557dae09de386#file-fuzzlyn-bad-program-original-cs">large initial version</a> to something <a href="https://gist.github.com/mattwarren/7bf0fa2b762b906614babc3ecfd06a80#file-fuzzlyn-bad-program-reduced-cs">much more readable</a>. By using a <a href="https://github.com/jakobbotsch/Fuzzlyn/blob/b1391faf9f533d1613c46118d17b7bc2b1af2c3f/Fuzzlyn/Reduction/Reducer.cs#L306-L384">&#x2018;binary search&#x2019; technique</a> it can remove a section of code and compare the checksums of the remaining code. If the checksums still differ then the remaining code contains the error/bug and Fuzzlyn can carry on reducing it, otherwise it can be discarded.</p> <p>In addition, Fuzzlyn makes good use of the <a href="https://github.com/dotnet/roslyn/wiki/Roslyn-Overview#syntax-trees">Roslyn &#x2018;syntax tree&#x2019; API</a> when removing code. For instance the <a href="https://github.com/jakobbotsch/Fuzzlyn/blob/b1391faf9f533d1613c46118d17b7bc2b1af2c3f/Fuzzlyn/Reduction/CoarseStatementRemover.cs#L11">CoarseStatementRemover class</a> makes use of the Roslyn <code class="highlighter-rouge">CSharpSyntaxWriter</code> class, which is <a href="https://joshvarty.com/2014/08/15/learn-roslyn-now-part-5-csharpsyntaxrewriter/">designed to allow syntax re-writing</a> (also see <a href="https://johnkoerner.com/csharp/using-a-csharp-syntax-rewriter/">Using a CSharp Syntax Rewriter</a>).</p> <h2 id="the-results">The Results</h2> <p>What initially drew me to the Fuzzlyn project (aside from the <a href="https://twitter.com/matthewwarren/status/1004013915876020225">great name</a>) was the <a href="https://twitter.com/matthewwarren/status/1027224393217449986">impressive results I saw it getting</a>. As of the end of Aug 2018, they&#x2019;re reported 22 bugs, of which 11 have already been fixed (kudos to the .NET JIT devs for fixing them so quickly).</p> <p>Here&#x2019;s a list of some of them, taken from the <a href="https://github.com/jakobbotsch/Fuzzlyn/blob/master/README.md#bugs-reported">project README</a>:</p> <blockquote> </blockquote> <p>(for the most up-to-date list see the <a href="https://github.com/dotnet/coreclr/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+author%3Ajakobbotsch">GitHub Issues created by @jakobbotsch</a>)</p> <p>I think that Fuzzlyn is a fantastic project, anything that roots out bugs or undesired behaviour in the JIT is a great benefit to all .NET Developers. If you want a see what the <em>potential</em> side-effects of JIT bugs can be, take a look at <a href="https://nickcraver.com/blog/2015/07/27/why-you-should-wait-on-dotnet-46/">Why you should wait on upgrading to .Net 4.6</a> by <a href="https://twitter.com/Nick_Craver">Nick Craver</a> (one of the developers at Stack Overflow).</p> <p>Now, you could argue that some of the code patterns that Fuzzlyn detects are not ones you&#x2019;d normally write, e.g. <code class="highlighter-rouge">if (((ushort)(s_18 | 2L) &lt;= s_40[0]))</code>. But the wider point is that it&#x2019;s <em>valid C# code</em>, which isn&#x2019;t behaving as it should. Also, if you ever wrote this code you&#x2019;d have a horrible time tracking down the problem because:</p> <p>Discuss this post on <a href="https://news.ycombinator.com/item?id=17863554">Hacker News</a>, <a href="https://www.reddit.com/r/dotnet/comments/9b0qeo/fuzzing_the_net_jit_compiler_performance_is_a/">/r/dotnet</a> or <a href="https://www.reddit.com/r/csharp/comments/9b0qq5/fuzzing_the_net_jit_compiler_performance_is_a/">/r/csharp</a></p> <h2 id="further-reading">Further Reading</h2> <p>Jakob was kind enough to share some additional links with me:</p> <p>Also I asked him &#x201C;<em>Is any part of Fuzzlyn based on well known techniques, is it all implemented from scratch, or somewhere in-between</em>?&#x201D;</p> <blockquote> <p>The state-of-the-art fuzzing techniques are unfortunately not well suited for testing the later stages of compilers (eg. the code output, optimization stages and so on). These techniques are for example symbolic execution, taint tracking, input length exploration, path slicing and more. The problem is that compilers use many intermediate representations, and it is hard to cross reference between what the fuzzer is passing in and what code is being executed at each stage. Even getting something to parse is hard without some kind of knowledge about what the structure needs to be. Fuzzlyn does not these techniques.</p> <p>On the other hand, Fuzzlyn was very inspired by Csmith, which is a similar tool. But most of the code was written from scratch, since there is a big difference in generating C code (Csmith) and C# code. It is much more complicated to generate interesting C code that is free from undefined behavior.</p>
</blockquote> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>