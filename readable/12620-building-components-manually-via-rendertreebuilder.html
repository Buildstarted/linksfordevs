<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Building Components Manually via RenderTreeBuilder -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Building Components Manually via RenderTreeBuilder</h1><div><div class="post-content"><p>We're all very used to seeing Razor Components defined using Razor syntax. No surprises there, after all they're called Razor Components. But you can also skip using Razor and build components manually using C# and Blazors <code>RenderTreeBuilder</code>. </p><h2 id="what-we-ll-build">What we'll build</h2><p>Let's start by looking at what we are going to build. We're going to replicate the following component using the pure C# approach. </p><pre><code class="language-html">&lt;!-- Menu.razor --&gt;

&lt;nav class="menu"&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;NavLink href="/" Match="NavLinkMatch.All"&gt;Home&lt;/NavLink&gt;&lt;/li&gt;
        &lt;li&gt;&lt;NavLink href="/contact"&gt;Contact&lt;/NavLink&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
</code></pre><p>This is a simple menu component that will render a couple of links, nothing fancy. </p><p>Right lets get started.</p><h2 id="scaffolding-the-component">Scaffolding the component</h2><p>We need to create a new class, much the same as when creating a component using Razor, the name of the class is what we'll use to reference the component in any markup. As we're re-creating the menu component above, we'll call our new class Menu. As this is a component, we will also need to inherit from <code>ComponentBase</code>.</p><pre><code class="language-csharp">public class Menu : ComponentBase
{
}
</code></pre><p>That's simple enough. The only thing we need to do now is to override the <code>BuildRenderTree</code> method from the <code>ComponentBase</code> class.</p><pre><code class="language-csharp">public class Menu : ComponentBase
{
    protected override void BuildRenderTree(RenderTreeBuilder builder)
    {
    }
}
</code></pre><p>In terms of the basic setup that is all we need. Everything to do with defining the markup the component produces will happen inside the <code>BuildRenderTree</code> method.</p><h2 id="defining-the-component">Defining the component</h2><p>Now we've scaffolded the component, we need to define what it does. In order to do that we are going to use the <code>RenderTreeBuilder</code>. This class contains a set of methods which we can use to define everything the component does.</p><p>We'll start by calling the base implementation, you need to do this otherwise things go a little screwy. Then we'll define the first line of our menu component.</p><pre><code class="language-csharp">protected override void BuildRenderTree(RenderTreeBuilder builder)
{
    base.BuildRenderTree(builder);
    builder.OpenElement(0, "nav");
    builder.AddAttribute(1, "class", "menu");
}
</code></pre><p>The code above translates into the following Razor markup.</p><pre><code class="language-html">&lt;nav class="menu"&gt;
</code></pre><p>Like most of the methods we're going to use on the <code>RenderTreeBuilder</code>, the <code>OpenElement</code> and <code>AddAttribute</code> methods create a <code>RenderTreeFrame</code>. A <code>RenderTreeFrame</code> is essentially a tiny piece of the UI. It's these building blocks Blazor uses to render the final HTML output.</p><p>OK, let's create the rest of the instructions for our menu component up to the first link.</p><pre><code class="language-csharp">protected override void BuildRenderTree(RenderTreeBuilder builder)
{
    base.BuildRenderTree(builder);
    builder.OpenElement(0, "nav");
    builder.AddAttribute(1, "class", "menu");
    
    builder.OpenElement(2, "ul");
    builder.OpenElement(3, "li");
    builder.OpenComponent&lt;NavLink&gt;(4);
    builder.AddAttribute(5, "href", "/");
    builder.AddAttribute(6, "Match", NavLinkMatch.All);
    builder.AddAttribute(7, "ChildContent", (RenderFragment)((builder2) =&gt; {
        builder2.AddContent(8, "Home");
    }));
    builder.CloseComponent();
    builder.CloseElement();
}
</code></pre><p>The code above now translates into the following Razor markup.</p><pre><code class="language-html">&lt;nav class="menu"&gt;
    &lt;ul&gt;
        &lt;li&gt;
            &lt;NavLink href="/" Match="NavLinkMatch.All"&gt;Home&lt;/NavLink&gt;
        &lt;/li&gt;
</code></pre><p>We've now had to create another component, <code>NavLink</code>. We do this using the <code>OpenComponent</code> method using the type of the component we want. The other point of interest is the child content for the <code>NavLink</code> component. </p><p>Child content is always defined as a <code>RenderFragment</code>. This is just a delegate that writes it's content to a <code>RenderTreeBuilder</code>. We're using a lambda expression to build the child content and then we're passing it to the <code>NavLink</code> component as a parameter.</p><p>Let's go ahead and write out the rest of the instructions to complete our menu component.</p><pre><code class="language-csharp">protected override void BuildRenderTree(RenderTreeBuilder builder)
{
    base.BuildRenderTree(builder);
    builder.OpenElement(0, "nav");
    builder.AddAttribute(1, "class", "menu");
    
    builder.OpenElement(2, "ul");
    builder.OpenElement(3, "li");
    builder.OpenComponent&lt;NavLink&gt;(4);
    builder.AddAttribute(5, "href", "/");
    builder.AddAttribute(6, "Match", NavLinkMatch.All);
    builder.AddAttribute(7, "ChildContent", (RenderFragment)((builder2) =&gt; {
        builder2.AddContent(8, "Home");
    }));
    builder.CloseComponent();
    builder.CloseElement();
    
    builder.OpenElement(9, "li");
    builder.OpenComponent&lt;NavLink&gt;(10);
    builder.AddAttribute(11, "href", "/contact");
    builder.AddAttribute(12, "ChildContent", (RenderFragment)((builder2) =&gt; {
        builder2.AddContent(13, "Contact");
    }
    ));
    builder.CloseComponent();
    builder.CloseElement();
    builder.CloseElement();
    builder.CloseElement();
}
</code></pre><p>The code above now translates into the Razor markup we started with.</p><pre><code class="language-html">&lt;nav class="menu"&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;NavLink href="/" Match="NavLinkMatch.All"&gt;Home&lt;/NavLink&gt;&lt;/li&gt;
        &lt;li&gt;&lt;NavLink href="/contact"&gt;Contact&lt;/NavLink&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
</code></pre><p>We can now reference our C# only component in any razor markup just as you would any other component.</p><pre><code class="language-html">&lt;Menu /&gt;
</code></pre><p>Or even in another C# only component.</p><pre><code class="language-csharp">builder.OpenComponent&lt;Menu&gt;(0);
builder.CloseComponent();
</code></pre><h2 id="sequence-number">Sequence Number</h2><p>You may have noticed that most instructions we added when creating our component had a number associated with them. These are sequence number and are extremely important to understand when building components this way.</p><p>The sequence number is used when Blazor is calculating diffs. To quote Steve Sanderson.</p><blockquote>Unlike <code>.jsx</code> files, <code>.razor</code>/<code>.cshtml</code> files are always compiled. This is potentially a great advantage for <code>.razor</code>, because we can use the compile step to inject information that makes things better or faster at runtime.</blockquote><blockquote>A key example of this are <em>sequence numbers</em>. These indicate to the runtime which outputs came from which distinct and ordered lines of code. The runtime uses this information to generate efficient tree diffs in linear time, which is far faster than is normally possible for a general tree diff algorithm.</blockquote><p>There has been a lot of misunderstanding about how these numbers should be generated. It turns out most of us in the community were getting it wrong and dynamically generating these numbers using code like this.</p><pre><code class="language-csharp">var index = 0;

builder.OpenElement(index++, "div");
</code></pre><p>This led to Steve creating <a href="https://gist.github.com/SteveSandersonMS/ec232992c2446ab9a0059dd0fbc5d0c3">this Gist</a> explaining why these sequence numbers should be hard-coded. I urge everyone to have a read of that Gist before embarking on creating components manually.</p><p>This leads us to the final part of this post...</p><h2 id="why-build-a-component-manually">Why build a component manually?</h2><p>I think my personal opinion on this is that you probably shouldn't. Well, certainly not as a default anyway.</p><p>As you can see in the example above, building component this way is quite verbose and it's harder to read. It's also much easier to make a mistake, you're responsible for ordering all the instructions correctly and closing tags correctly, if you get this wrong you won't know until runtime, as the compiler can't help you. </p><p>This an advanced use of Blazor and most of the time is just not necessary. Dealing with the sequence numbers alone is a maintenance nightmare. I've used this technique when building the <a href="https://github.com/Blazored/Menu">Blazored Menu</a> library. But looking at it now, I fell in the trap of auto generating sequence numbers and I could have achieved the same result using just Razor.</p><h2 id="summary">Summary</h2><p>This has been an interesting post as my view on this approach has changed while writing it. I'm certainly not saying that this method should be avoided at all costs and using it is bad practice, but I think this is an advanced technique for niche situations.</p><p>What are your thoughts? Let me know in the comments.</p><hr><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>