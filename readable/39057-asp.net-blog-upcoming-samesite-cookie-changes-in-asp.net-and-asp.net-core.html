<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ASP.NET Blog | Upcoming SameSite Cookie Changes in ASP.NET and ASP.NET Core -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>ASP.NET Blog | Upcoming SameSite Cookie Changes in ASP.NET and ASP.NET Core</h1>
    <div class="entry-content col-12 sharepostcontent"> <div class="row justify-content-center"><div class="col-md-4"><div><img src="https://secure.gravatar.com/avatar/1346bf943798fb31b65573c78e549706?s=58&amp;d=mm&amp;r=g" width="58" alt="Avatar" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 photo avatar-default"><p>Barry</p></div></div></div> <p>SameSite is a 2016 <a href="https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1">extension to HTTP cookies</a> intended to mitigate cross site request forgery (CSRF). The original design as was an opt-in feature web which could be used by adding a new Samesite property to cookies. It had two property values, Lax and Strict. Setting the property as Lax indicated the cookie should be sent on navigation within the same site, or through GET navigation to your site from other sites. A value of Strict limited the cookie to requests only from the same site. Not setting the property at all placed no restrictions on how the cookie flowed in requests. .NET 4.7.2 and ASP.NET Core 2.0 added support for the SameSite property. OIDC and other features which send POST requests from an external site to the site requesting a login use cookies for correlation and CSRF protection so those cookies needed to opt-out of SameSite by setting the property at all.</p>
<p>Google is now <a href="https://tools.ietf.org/html/draft-west-cookie-incrementalism-00">updating the standard</a> and implementing their proposed changes in an upcoming version Chrome. The change adds a new SameSite value, &#x201C;None&#x201D;, and changes the default behavior to &#x201C;Lax&#x201D;. This breaks OIDC logins, and potentially other features your web site may rely on, these features will have to use cookies whose SameSite property is set to a value of &#x201C;None&#x201D;. However browsers which adhere to the original standard and are unaware of the new value have a different behavior to browsers which use the new standard as the SameSite standard states that if a browser sees a value for SameSite it does not understand it should treat that value as &#x201C;Strict&#x201D;. This means your .NET website will now have to add user agent sniffing to decide whether you send the new None value, or not send the attribute at all.</p>
<p>.NET will issue updates to change the behavior of its SameSite attribute behavior in .NET 4.7.2 and in .NET Core 2.1 and above to reflect Google&#x2019;s introduction of a new value. The updates for the .NET Framework will be available on November 19th as an optional update via Microsoft Update and WSUS if you use the &#x201C;Check for Update&#x201D; functionality. On December 10th it will become widely available and appear in Microsoft Update without you having to specifically check for updates. .NET Core updates will be available with .NET Core 3.1 starting with preview 1, in November.</p>
<p>.NET Core 3.1 will contain an <a href="https://github.com/aspnet/Announcements/issues/390">updated enum definition</a>, SameSite.Unspecified which will not set the SameSite property.</p>
<p>The OIDC middleware for Katana v4 and .NET Core will be updated at the same time as their .NET Framework and .NET updates however we cannot introduce the user agent sniffing code into the framework, this must be implemented in your site code. The implementation of agent sniffing will vary according to what version of ASP.NET or ASP.NET Core you are using and the browsers you wish to support.</p>
<p>For ASP.NET 4.7.2 with Microsoft.Owin 4.1.0 agent sniffing should be implemented in an implementation of <a href="https://docs.microsoft.com/en-us/previous-versions/aspnet/dn800238(v%3Dvs.113)">ICookieManager</a>;</p>
<pre><code>public class SameSiteCookieManager : ICookieManager
{
  private readonly ICookieManager _innerManager;

  public SameSiteCookieManager() : this(new CookieManager())
  {
  }

  public SameSiteCookieManager(ICookieManager innerManager)
  {
    _innerManager = innerManager;
  }

  public void AppendResponseCookie(IOwinContext context, string key, string value,
                                   CookieOptions options)
  {
    CheckSameSite(context, options);
    _innerManager.AppendResponseCookie(context, key, value, options);
}

  public void DeleteCookie(IOwinContext context, string key, CookieOptions options)
  {
    CheckSameSite(context, options);
    _innerManager.DeleteCookie(context, key, options);
  }

  public string GetRequestCookie(IOwinContext context, string key)
  {
    return _innerManager.GetRequestCookie(context, key);
  }

  private void CheckSameSite(IOwinContext context, CookieOptions options)
  {
    if (DisallowsSameSiteNone(context) &amp;&amp; options.SameSite == SameSiteMode.None)
    {
        options.SameSite = null;
    }
  }

  public static bool DisallowsSameSiteNone(IOwinContext context)
  {
    // TODO: Use your User Agent library of choice here.
    var userAgent = context.Request.Headers[&quot;User-Agent&quot;];
    return userAgent.Contains(&quot;BrokenUserAgent&quot;) ||
           userAgent.Contains(&quot;BrokenUserAgent2&quot;)
  }
}
</code></pre>
<p>And then configure OIDC settings to use the new CookieManager;</p>
<pre><code>app.UseOpenIdConnectAuthentication(
    new OpenIdConnectAuthenticationOptions
    {
    // &#x2026; Your preexisting options &#x2026; 
    CookieManager = new SameSiteCookieManager(new SystemWebCookieManager())
});
</code></pre>
<p>For ASP.NET Core you should implement the sniffing code within a <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/cookie?view=aspnetcore-3.0#cookie-policy-middleware">cookie policy </a></p>
<pre><code>private void CheckSameSite(HttpContext httpContext, CookieOptions options)
{
    if (options.SameSite &gt; SameSiteMode.Unspecified)
    {
        var userAgent = httpContext.Request.Headers[&quot;User-Agent&quot;].ToString();
        // TODO: Use your User Agent library of choice here.
        if (/* UserAgent doesn&#x2019;t support new behavior */)
        {
               // For .NET Core &lt; 3.1 set SameSite = -1
               options.SameSite = SameSiteMode.Unspecified;
         }
    }
}

public void ConfigureServices(IServiceCollection services)
{
    services.Configure&lt;CookiePolicyOptions&gt;(options =&gt;
    {
        options.MinimumSameSitePolicy = SameSiteMode.Unspecified;
        options.OnAppendCookie = cookieContext =&gt; 
            CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);
        options.OnDeleteCookie = cookieContext =&gt; 
            CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);
    });
}

public void Configure(IApplicationBuilder app)
{
    app.UseCookiePolicy(); // Before UseAuthentication or anything else that writes cookies.
    app.UseAuthentication();
    // &#x2026;
}
</code></pre>
<p>Under testing with the Azure Active Directory team we have found the following checks work for all the common user agents that Azure Active Directory sees that don&#x2019;t understand the new value.</p>
<pre><code>public&#xA0;static&#xA0;bool&#xA0;DisallowsSameSiteNone(string&#xA0;userAgent)
{
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;Cover&#xA0;all&#xA0;iOS&#xA0;based&#xA0;browsers&#xA0;here.&#xA0;This&#xA0;includes:
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;-&#xA0;Safari&#xA0;on&#xA0;iOS&#xA0;12&#xA0;for&#xA0;iPhone,&#xA0;iPod&#xA0;Touch,&#xA0;iPad
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;-&#xA0;WkWebview&#xA0;on&#xA0;iOS&#xA0;12&#xA0;for&#xA0;iPhone,&#xA0;iPod&#xA0;Touch,&#xA0;iPad
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;-&#xA0;Chrome&#xA0;on&#xA0;iOS&#xA0;12&#xA0;for&#xA0;iPhone,&#xA0;iPod&#xA0;Touch,&#xA0;iPad
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;All&#xA0;of&#xA0;which&#xA0;are&#xA0;broken&#xA0;by&#xA0;SameSite=None,&#xA0;because&#xA0;they&#xA0;use&#xA0;the&#xA0;iOS&#xA0;networking&#xA0;stack
&#xA0;&#xA0;&#xA0;&#xA0;if&#xA0;(userAgent.Contains(&quot;CPU&#xA0;iPhone&#xA0;OS&#xA0;12&quot;)&#xA0;||&#xA0;userAgent.Contains(&quot;iPad;&#xA0;CPU&#xA0;OS&#xA0;12&quot;))
&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return&#xA0;true;
&#xA0;&#xA0;&#xA0;&#xA0;}

&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;Cover&#xA0;Mac&#xA0;OS&#xA0;X&#xA0;based&#xA0;browsers&#xA0;that&#xA0;use&#xA0;the&#xA0;Mac&#xA0;OS&#xA0;networking&#xA0;stack.&#xA0;This&#xA0;includes:
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;-&#xA0;Safari&#xA0;on&#xA0;Mac&#xA0;OS&#xA0;X.
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;This&#xA0;does&#xA0;not&#xA0;include:
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;-&#xA0;Chrome&#xA0;on&#xA0;Mac&#xA0;OS&#xA0;X
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;Because&#xA0;they&#xA0;do&#xA0;not&#xA0;use&#xA0;the&#xA0;Mac&#xA0;OS&#xA0;networking&#xA0;stack.
&#xA0;&#xA0;&#xA0;&#xA0;if&#xA0;(userAgent.Contains(&quot;Macintosh;&#xA0;Intel&#xA0;Mac&#xA0;OS&#xA0;X&#xA0;10_14&quot;)&#xA0;&amp;&amp;&#xA0;
        userAgent.Contains(&quot;Version/&quot;) &amp;&amp; userAgent.Contains(&quot;Safari&quot;))
&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return&#xA0;true;
&#xA0;&#xA0;&#xA0;&#xA0;}

&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;Cover&#xA0;Chrome&#xA0;50-69,&#xA0;because&#xA0;some&#xA0;versions are&#xA0;broken&#xA0;by&#xA0;SameSite=None,&#xA0;
    // and&#xA0;none in this range require&#xA0;it.
&#xA0;&#xA0;&#xA0;&#xA0;//&#xA0;Note:&#xA0;this covers&#xA0;some&#xA0;pre-Chromium&#xA0;Edge&#xA0;versions,&#xA0;
    // but pre-Chromium&#xA0;Edge&#xA0;does&#xA0;not&#xA0;require&#xA0;SameSite=None.
&#xA0;&#xA0;&#xA0;&#xA0;if&#xA0;(userAgent.Contains(&quot;Chrome/5&quot;)&#xA0;||&#xA0;userAgent.Contains(&quot;Chrome/6&quot;))
&#xA0;&#xA0;&#xA0;&#xA0;{
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return&#xA0;true;
&#xA0;&#xA0;&#xA0;&#xA0;}

&#xA0;&#xA0;&#xA0;&#xA0;return&#xA0;false;
}
</code></pre>
<p>This browser list is by no means canonical and you should validate that the common browsers and other user agents your system supports behave as expected once the update is in place.</p>
<p>Chrome is scheduled to <a href="https://www.chromium.org/updates/same-site">turn on the new behavior</a> in February or March 2020, with a temporary mitigation in Chrome 79 Beta. If you want to test against known breaking browsers older versions of Chromium are <a href="http://www.chromium.org/getting-involved/download-chromium">available for download</a>, Chromium 76 and Chromium 74 both will exhibit the incompatible behavior with the new standard.</p>
<p>If you cannot update your framework versions by the time Chrome turns the new behavior in early 2020 you may be able to change your ODIC flow to a Code flow, rather than the default implicit flow that ASP.NET and ASP.NET Core uses, but this should be viewed as a temporary measure.</p> <p>We strongly encourage you to download the updated .NET Framework and .NET Core versions and start planning your update now, before Chrome&#x2019;s changes are rolled out.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>