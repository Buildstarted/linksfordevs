<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Kowainik - Haskell mini-patterns handbook - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Kowainik - Haskell mini-patterns handbook - linksfor.dev(s)"/>
    <meta property="article:author" content="Kowainik  &#x2014; Dmitrii Kovanikov &lt;&gt; Veronika Romashkina"/>
    <meta property="og:description" content="Collection of small Haskell patterns with detailed description, examples and exercises"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://kowainik.github.io/posts/haskell-mini-patterns"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Kowainik - Haskell mini-patterns handbook</title>
<div class="readable">
        <h1>Kowainik - Haskell mini-patterns handbook</h1>
            <div>by Kowainik  &#x2014; Dmitrii Kovanikov &lt;&gt; Veronika Romashkina</div>
            <div>Reading time: 47-60 minutes</div>
        <div>Posted here: 19 Aug 2020</div>
        <p><a href="https://kowainik.github.io/posts/haskell-mini-patterns">https://kowainik.github.io/posts/haskell-mini-patterns</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
          <div>
              <div>
              <p>Navigating in the ocean of Haskell possibilities is challenging even though Haskell is a powerful language that helps to implement robust and maintainable programs. The language supplies you with tons of awesome approaches, but it is not always trivial to see how and where to use them properly.</p>
<p>Fortunately, like any other mainstream programming language, Haskell also has its best-practices and recommended ways for producing high-quality code. Knowing Haskell programming patterns helps you create better libraries and applications and make their users more pleased. And, yes, Haskell actually has FP-oriented programming patterns in addition to the best-practices shared with other languages.</p>
<p>If you are aware of the best ways to solve common problems, you can become a better Haskell developer by using more efficient programming techniques specific to the language. Likewise, you can apply Haskell-specific patterns successfully outside of Haskell.</p>
<p>This blog post contains a structured collection of some programming mini-patterns in Haskell with the detailed description and examples, some small ‚Äúquality of life‚Äù improvements that would help everyone on their developer journey.</p>
<p>üìö In this article, each pattern contains at least one task with the hidden solution, so you can test your understanding of a pattern by solving the proposed task.</p>
<h2 id="newtype">Newtype<a href="#newtype">üîó</a></h2>
<div>

<p>Newtype</p>

<p>Lightweight data wrapper.</p>

<p>When using the same primitive type (<code>Int</code>, <code>Text</code>, etc.) to represent semantically different entities (name, title, description, etc.).</p>

<div>
<ol type="1">
<li>Improves maintainability.</li>
<li>Increases code readability.</li>
<li>Enables writing custom instances.</li>
<li>Allows reusing instance definitions with <a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-via">DerivingVia</a>.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Additional wrapping and unwrapping.</li>
<li>Deriving boilerplate is required to duplicate existing behaviour of the underlying type.</li>
</ol>
</div>
</div>
<p>One of the most common and useful Haskell features is <code>newtype</code>. <code>newtype</code> is an ordinary data type with the name and a constructor. However, you can define a data type as <code>newtype</code> instead of <code>data</code> only if it has <strong>exactly</strong> one constructor with <strong>exactly</strong> one field.</p>
<p>It is extremely easy to define a <code>newtype</code> in Haskell as no extra effort is required from the user compared to the data type declaration. For example, the following are the valid <code>newtype</code> definitions:</p>
<div id="cb1"><pre><code><span id="cb1-1"><span></span></span>
<span id="cb1-2"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Volume</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Volume</span></span></span><span> </span><span><span><span>Double</span></span></span></span>
<span id="cb1-3"></span>
<span id="cb1-4"><span></span></span>
<span id="cb1-5"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Size</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Size</span></span></span></span>
<span id="cb1-6">    {<span> unSize ::</span> <span><span>Int</span></span></span>
<span id="cb1-7">    }</span></code></pre></div>
<p>But you can‚Äôt declare the following data types as a <code>newtype</code>:</p>
<div id="cb2"><pre><code><span id="cb2-1"><span></span></span>
<span id="cb2-2"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Point</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Point</span></span></span></span>
<span id="cb2-3">    {<span> pointX ::</span> <span><span>Int</span></span></span>
<span id="cb2-4">    ,<span> pointY ::</span> <span><span>Int</span></span></span>
<span id="cb2-5">    }</span>
<span id="cb2-6"></span>
<span id="cb2-7"><span></span></span>
<span id="cb2-8"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Shape</span></span></span></span>
<span id="cb2-9">    <span>=</span> <span><span>Circle</span></span> <span><span>Double</span></span></span>
<span id="cb2-10">    <span>|</span> <span><span>Square</span></span> <span><span>Double</span></span></span></code></pre></div>
<p><code>newtype</code>s have a lot of great benefits but I‚Äôm going to focus only on the <em>code maintainability</em> in this section.</p>
<p>You can think of a <code>newtype</code> as a lightweight data type. Newtype has the same representation in memory as the wrapped type. Wrapping and unwrapping are also free operations in runtime. So, <code>newtype</code> is a <strong>zero-cost</strong> abstraction.</p>
<p>Notwithstanding from the compiler point of view, different <code>newtype</code>s are different data types. And since they don‚Äôt have any runtime overhead compared to the ordinary data types, you can provide a safer interface to your API without sacrificing performance.</p>
<p>Shall we look at the example now. Consider, that you have a function which takes a password, a hash and verifies whether the given hash is the hash of the given password. Since both password and hash are merely textual data, we could write the following function:</p>
<div id="cb3"><pre><code><span id="cb3-1"><span><span>validateHash</span> ::</span> <span><span>ByteString</span></span> <span>-&gt;</span> <span><span>ByteString</span></span> <span>-&gt;</span> <span><span>Bool</span></span></span></code></pre></div>
<p>The problem with this function is that you can easily pass arguments in a different order and get faulty results. And you need to think about proper order of arguments each time you are calling this function. Should it be <code>validateHash password hash</code> or <code>validateHash hash password</code>? This approach is error-prone.</p>
<p>But if you define the following <code>newtype</code>s instead:</p>
<div id="cb4"><pre><code><span id="cb4-1"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Password</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Password</span></span></span></span>
<span id="cb4-2">    {<span> unPassword ::</span> <span><span>ByteString</span></span></span>
<span id="cb4-3">    }</span>
<span id="cb4-4"></span>
<span id="cb4-5"><span><span><span>newtype</span></span></span><span> </span><span><span><span>PasswordHash</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>PasswordHash</span></span></span></span>
<span id="cb4-6">    {<span> unPasswordHash ::</span> <span><span>ByteString</span></span></span>
<span id="cb4-7">    }</span></code></pre></div>
<p>You can implement a more type-safe version of the <code>validateHash</code> function, and additionally this improves the code readability:</p>
<div id="cb5"><pre><code><span id="cb5-1"><span><span>validateHash</span> ::</span> <span><span>Password</span></span> <span>-&gt;</span> <span><span>PasswordHash</span></span> <span>-&gt;</span> <span><span>Bool</span></span></span></code></pre></div>
<p>Now, <code>validateHash hash password</code> is a compile-time error, and it makes it impossible to confuse the order of arguments.</p>
<hr>
<p>Another popular way of increasing code readability without sacrificing performance is introducing a new alias (which is simply another name for a data type) by using the <code>type</code> keyword. Unfortunately, this approach is only a partial solution since it helps only a developer, not the compiler as the compiler doesn‚Äôt see the difference between type alias and type itself. And if you don‚Äôt help your compiler, the compiler won‚Äôt be there for you when you need it.</p>
<p>For example, the following code is flawed:</p>
<div id="cb6"><pre><code><span id="cb6-1"><span><span><span>type</span></span></span><span> </span><span><span><span>Attack</span></span></span><span>  </span><span><span>=</span></span><span> </span><span><span><span>Int</span></span></span></span>
<span id="cb6-2"><span><span><span>type</span></span></span><span> </span><span><span><span>Defense</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Int</span></span></span></span>
<span id="cb6-3"></span>
<span id="cb6-4"><span><span>calculateDamage</span> ::</span> <span><span>Attack</span></span> <span>-&gt;</span> <span><span>Defense</span></span> <span>-&gt;</span> <span><span>Attack</span></span></span></code></pre></div>
<p>Of course, the above type signature is better than <code>Int -&gt; Int -&gt; Int</code>, but the compiler sees it exactly like this. So, you still can write <code>calculateDamage monsterDefense playerAttack</code> and get a runtime bug.</p>
<p>The approach of using <code>type</code>s instead of <code>newtype</code> can bring even more damage when you have a lot of similar data types. The more types you have the harder to maintain them without external help. Below you can see a code sample from one of the Haskell libraries:</p>
<div id="cb7"><pre><code><span id="cb7-1"><span><span><span>type</span></span></span><span> </span><span><span><span>WorkerId</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>UUID</span></span></span></span>
<span id="cb7-2"><span><span><span>type</span></span></span><span> </span><span><span><span>SupervisorId</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>UUID</span></span></span></span>
<span id="cb7-3"><span><span><span>type</span></span></span><span> </span><span><span><span>ProcessId</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>UUID</span></span></span></span>
<span id="cb7-4"><span><span><span>type</span></span></span><span> </span><span><span><span>ProcessName</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Text</span></span></span></span>
<span id="cb7-5"><span><span><span>type</span></span></span><span> </span><span><span><span>SupervisorName</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Text</span></span></span></span>
<span id="cb7-6"><span><span><span>type</span></span></span><span> </span><span><span><span>WorkerName</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Text</span></span></span></span></code></pre></div>
<p>The library safety can be improved by replacing all these type aliases with <code>newtype</code>s, and it can even help to discover some bugs that happen due to passing arguments in the wrong order.</p>
<p>Moreover, the <code>newtype</code> approach is more flexible since you can provide your custom instances or restrict some instances allowing you to create values in an unsafe way.</p>
<p>The cost of using <code>newtype</code> is small ‚Äî you only need to wrap and unwrap it when necessary. But the benefits hugely outweigh this small price.</p>
<section id="newtype-task">
<h3>Newtype: Task<a href="#newtype-task">üîó</a></h3>
<p>Improve the following code by applying the <strong>Newtype</strong> pattern.</p>
<div id="cb8"><pre><code><span id="cb8-1"><span><span><span>data</span></span></span><span> </span><span><span><span>Player</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Player</span></span></span></span>
<span id="cb8-2">    {<span> playerHealth    ::</span> <span><span>Int</span></span></span>
<span id="cb8-3">    ,<span> playerArmor     ::</span> <span><span>Int</span></span></span>
<span id="cb8-4">    ,<span> playerAttack    ::</span> <span><span>Int</span></span></span>
<span id="cb8-5">    ,<span> playerDexterity ::</span> <span><span>Int</span></span></span>
<span id="cb8-6">    ,<span> playerStrength  ::</span> <span><span>Int</span></span></span>
<span id="cb8-7">    }</span>
<span id="cb8-8"></span>
<span id="cb8-9"><span><span>calculatePlayerDamage</span> ::</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Int</span></span></span>
<span id="cb8-10"><span>calculatePlayerDamage</span> attack strength <span>=</span> attack <span>+</span> strength</span>
<span id="cb8-11"></span>
<span id="cb8-12"><span><span>calculatePlayerDefense</span> ::</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Int</span></span></span>
<span id="cb8-13"><span>calculatePlayerDefense</span> armor dexterity <span>=</span> armor <span>*</span> dexterity</span>
<span id="cb8-14"></span>
<span id="cb8-15"><span><span>calculateHit</span> ::</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Int</span></span></span>
<span id="cb8-16"><span>calculateHit</span> damage defense health <span>=</span> health <span>+</span> defense <span>-</span> damage</span>
<span id="cb8-17"></span>
<span id="cb8-18"><span></span></span>
<span id="cb8-19"><span><span>hitPlayer</span> ::</span> <span><span>Player</span></span> <span>-&gt;</span> <span><span>Player</span></span> <span>-&gt;</span> <span><span>Player</span></span></span>
<span id="cb8-20"><span>hitPlayer</span> player1 player2 <span>=</span></span>
<span id="cb8-21">    <span><span>let</span></span> damage <span>=</span> calculatePlayerDamage</span>
<span id="cb8-22">            (playerAttack player2)</span>
<span id="cb8-23">            (playerStrength player2)</span>
<span id="cb8-24">        defense <span>=</span> calculatePlayerDefense</span>
<span id="cb8-25">            (playerArmor player1)</span>
<span id="cb8-26">            (playerDexterity player1)</span>
<span id="cb8-27">        newHealth <span>=</span> calculateHit</span>
<span id="cb8-28">            damage</span>
<span id="cb8-29">            defense</span>
<span id="cb8-30">            (playerHealth player1)</span>
<span id="cb8-31">    <span><span>in</span></span> player1 { playerHealth <span>=</span> newHealth }</span></code></pre></div>

<div id="solutionNewtype1">
<h4 id="newtype-solution-1">Newtype: Solution 1<a href="#newtype-solution-1">üîó</a></h4>
<div id="cb9"><pre><code><span id="cb9-1"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Health</span></span></span><span>    </span><span><span>=</span></span><span> </span><span><span><span>Health</span></span></span><span>    </span><span><span><span>Int</span></span></span></span>
<span id="cb9-2"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Armor</span></span></span><span>     </span><span><span>=</span></span><span> </span><span><span><span>Armor</span></span></span><span>     </span><span><span><span>Int</span></span></span></span>
<span id="cb9-3"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Attack</span></span></span><span>    </span><span><span>=</span></span><span> </span><span><span><span>Attack</span></span></span><span>    </span><span><span><span>Int</span></span></span></span>
<span id="cb9-4"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Dexterity</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Dexterity</span></span></span><span> </span><span><span><span>Int</span></span></span></span>
<span id="cb9-5"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Strength</span></span></span><span>  </span><span><span>=</span></span><span> </span><span><span><span>Strength</span></span></span><span>  </span><span><span><span>Int</span></span></span></span>
<span id="cb9-6"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Damage</span></span></span><span>    </span><span><span>=</span></span><span> </span><span><span><span>Damage</span></span></span><span>    </span><span><span><span>Int</span></span></span></span>
<span id="cb9-7"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Defense</span></span></span><span>   </span><span><span>=</span></span><span> </span><span><span><span>Defense</span></span></span><span>   </span><span><span><span>Int</span></span></span></span>
<span id="cb9-8"></span>
<span id="cb9-9"><span><span><span>data</span></span></span><span> </span><span><span><span>Player</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Player</span></span></span></span>
<span id="cb9-10">    {<span> playerHealth    ::</span> <span><span>Health</span></span></span>
<span id="cb9-11">    ,<span> playerArmor     ::</span> <span><span>Armor</span></span></span>
<span id="cb9-12">    ,<span> playerAttack    ::</span> <span><span>Attack</span></span></span>
<span id="cb9-13">    ,<span> playerDexterity ::</span> <span><span>Dexterity</span></span></span>
<span id="cb9-14">    ,<span> playerStrength  ::</span> <span><span>Strength</span></span></span>
<span id="cb9-15">    }</span>
<span id="cb9-16"></span>
<span id="cb9-17"><span><span>calculatePlayerDamage</span> ::</span> <span><span>Attack</span></span> <span>-&gt;</span> <span><span>Strength</span></span> <span>-&gt;</span> <span><span>Damage</span></span></span>
<span id="cb9-18"><span>calculatePlayerDamage</span> (<span><span>Attack</span></span> attack) (<span><span>Strength</span></span> strength) <span>=</span></span>
<span id="cb9-19">    <span><span>Damage</span></span> (attack <span>+</span> strength)</span>
<span id="cb9-20"></span>
<span id="cb9-21"><span><span>calculatePlayerDefense</span> ::</span> <span><span>Armor</span></span> <span>-&gt;</span> <span><span>Dexterity</span></span> <span>-&gt;</span> <span><span>Defense</span></span></span>
<span id="cb9-22"><span>calculatePlayerDefense</span> (<span><span>Armor</span></span> armor) (<span><span>Dexterity</span></span> dexterity) <span>=</span></span>
<span id="cb9-23">    <span><span>Defense</span></span> (armor <span>*</span> dexterity)</span>
<span id="cb9-24"></span>
<span id="cb9-25"><span><span>calculateHit</span> ::</span> <span><span>Damage</span></span> <span>-&gt;</span> <span><span>Defense</span></span> <span>-&gt;</span> <span><span>Health</span></span> <span>-&gt;</span> <span><span>Health</span></span></span>
<span id="cb9-26"><span>calculateHit</span> (<span><span>Damage</span></span> damage) (<span><span>Defense</span></span> defense) (<span><span>Health</span></span> health) <span>=</span></span>
<span id="cb9-27">    <span><span>Health</span></span> (health <span>+</span> defense <span>-</span> damage)</span>
<span id="cb9-28"></span>
<span id="cb9-29"><span></span></span>
<span id="cb9-30"><span><span>hitPlayer</span> ::</span> <span><span>Player</span></span> <span>-&gt;</span> <span><span>Player</span></span> <span>-&gt;</span> <span><span>Player</span></span></span>
<span id="cb9-31"><span>hitPlayer</span> player1 player2 <span>=</span></span>
<span id="cb9-32">    <span><span>let</span></span> damage <span>=</span> calculatePlayerDamage</span>
<span id="cb9-33">            (playerAttack player2)</span>
<span id="cb9-34">            (playerStrength player2)</span>
<span id="cb9-35">        defense <span>=</span> calculatePlayerDefense</span>
<span id="cb9-36">            (playerArmor player1)</span>
<span id="cb9-37">            (playerDexterity player1)</span>
<span id="cb9-38">        newHealth <span>=</span> calculateHit</span>
<span id="cb9-39">            damage</span>
<span id="cb9-40">            defense</span>
<span id="cb9-41">            (playerHealth player1)</span>
<span id="cb9-42">    <span><span>in</span></span> player1 { playerHealth <span>=</span> newHealth }</span></code></pre></div>
<p>Notice how the implementation of the <code>hitPlayer</code> function hasn‚Äôt changed at all. However, if you try to swap some of the arguments in different functions now, the compiler will prevent you from accidentally committing an error.</p>
</div>
</section>
<h2 id="smart-constructor">Smart constructor<a href="#smart-constructor">üîó</a></h2>
<div>

<p>Smart constructor</p>

<p>Providing idiomatic ways for constructing values.</p>

<div>
<ol type="1">
<li>When a data type restricts some values (e.g.&nbsp;not every <code>ByteString</code> is a valid <code>Password</code>).</li>
<li>When you want to make construction of big data types easier.</li>
<li>To avoid runtime errors.</li>
<li>To make illegal states unrepresentable.</li>
</ol>
</div>

<div>
<ol type="1">
<li>More structured and maintainable code.</li>
<li>Separation of concepts.</li>
<li>Control of erroneous data inputs.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Some extra code.</li>
<li>Decide on the approach details.</li>
</ol>
</div>
</div>
<p>Once you have a <code>newtype</code>, first you need to create its value to work with it. And sometimes you want to validate a value before proceeding with it. Usually you would create a value of a data type by using its constructor. However, when programming in a modular way, you want to have boundaries in your interface and avoid providing unsafe ways of constructing values without validation.</p>
<p>This programming pattern in Haskell is called <strong>smart constructor</strong>. It can be understood better by looking at the implementation of such approach based on the <code>Password</code> data type:</p>
<div id="cb10"><pre><code><span id="cb10-1"><span><span>module</span></span> <span>Password</span></span>
<span id="cb10-2">    ( <span><span>Password</span></span> (<span>unPassword</span>)</span>
<span id="cb10-3">    , mkPassword</span>
<span id="cb10-4">    ) <span><span>where</span></span></span>
<span id="cb10-5"></span>
<span id="cb10-6"><span><span>import</span></span> <span>Data.ByteString</span> (<span><span>ByteString</span></span>)</span>
<span id="cb10-7"><span><span>import</span></span> <span><span>qualified</span></span> <span>Data.ByteString</span> <span><span>as</span></span> <span>ByteString</span></span>
<span id="cb10-8"></span>
<span id="cb10-9"></span>
<span id="cb10-10"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Password</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Password</span></span></span></span>
<span id="cb10-11">    {<span> unPassword ::</span> <span><span>ByteString</span></span></span>
<span id="cb10-12">    }</span>
<span id="cb10-13"></span>
<span id="cb10-14"><span></span></span>
<span id="cb10-15"><span><span>mkPassword</span> ::</span> <span><span>ByteString</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Password</span></span></span>
<span id="cb10-16"><span>mkPassword</span> pwd</span>
<span id="cb10-17">    <span>|</span> <span><span>ByteString</span></span><span>.</span><span>null</span> pwd <span>=</span> <span><span>Nothing</span></span></span>
<span id="cb10-18">    <span>|</span> <span>otherwise</span> <span>=</span> <span><span>Just</span></span> (<span><span>Password</span></span> pwd)</span></code></pre></div>
<p>In this module, we want to reject empty passwords. This is what the <code>mkPassword</code> function does. We disincline to export the <code>Password</code> constructor. But we need a way to deconstruct a value of type <code>Password</code> hence the <code>Password (unPassword)</code> line in the export list.</p>
<blockquote>
<p>üë©‚Äçüî¨ It is important to hide the constructor to forbid <a href="http://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Coerce.html">value coercion</a>.</p>
</blockquote>
<p>Even if you don‚Äôt allow creating unvalidated passwords, you may need to create passwords in your test-suite without extra hassle. So we could create a function <code>unsafePassword</code> with a hint in the name.</p>
<div id="cb11"><pre><code><span id="cb11-1"><span></span></span>
<span id="cb11-2"><span><span>unsafePassword</span> ::</span> <span><span>ByteString</span></span> <span>-&gt;</span> <span><span>Password</span></span></span>
<span id="cb11-3"><span>unsafePassword</span> <span>=</span> <span><span>Password</span></span></span></code></pre></div>
<p>If you notice usages of this function in your application code during code review, something is clearly wrong. Moreover, it is even possible to set up some automatic tooling to perform such checks for you.</p>
<hr>
<p>You can find multiple variations of this pattern in the wild that differ in some implementation details:</p>
<ul>
<li>Usage of <a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms">PatternSynonyms</a></li>
<li>Replacing <code>Maybe</code> with <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-Either.html">Either</a> or <a href="http://hackage.haskell.org/package/validation-selective-0.1.0.0/docs/Validation.html">Validation</a> types for better error-reporting</li>
<li>Rename the constructor to <code>UnsafePassword</code> instead of having a separate <code>unsafePassword</code> function (however, this is a less safer approach due to coercions)</li>
<li>Validation of the statically-known values during compile-time, so you get errors in compile-time instead of runtime, and you don‚Äôt need unsafe functions when you know that the values are valid</li>
<li>Others</li>
</ul>
<p>Unfortunately, the community has not reached the consensus on what is the only true way to implement smart constructors. All ways slightly differ in ergonomics and naming schemes, they all do their job and fit various use cases of different systems. But the general idea remains the same across all approaches.</p>
<section id="smart-constructor-task">
<h3>Smart constructor: Task<a href="#smart-constructor-task">üîó</a></h3>
<p>Improve the following code by applying the <strong>Smart constructor</strong> pattern.</p>
<div id="cb12"><pre><code><span id="cb12-1"><span><span>module</span></span> <span>Tag</span> <span><span>where</span></span></span>
<span id="cb12-2"></span>
<span id="cb12-3"><span></span></span>
<span id="cb12-4"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Tag</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Tag</span></span></span><span> </span><span><span><span>String</span></span></span></span>
<span id="cb12-5"></span>
<span id="cb12-6"><span><span>mkTag</span> ::</span> <span><span>String</span></span> <span>-&gt;</span> <span><span>Tag</span></span></span>
<span id="cb12-7"><span>mkTag</span> tag</span>
<span id="cb12-8">    <span>|</span> <span>null</span> tag <span>=</span> <span>error</span> <span><span>"Empty tag!"</span></span></span>
<span id="cb12-9">    <span>|</span> <span>otherwise</span> <span>=</span> <span><span>Tag</span></span> tag</span></code></pre></div>
<div id="cb13"><pre><code><span id="cb13-1"><span><span>module</span></span> <span>TagsList</span> <span><span>where</span></span></span>
<span id="cb13-2"></span>
<span id="cb13-3"><span><span>import</span></span> <span>Data.List.NonEmpty</span> (<span><span>NonEmpty</span></span> (..))</span>
<span id="cb13-4"><span><span>import</span></span> <span>Tag</span> (<span><span>Tag</span></span>, <span>mkTag</span>)</span>
<span id="cb13-5"></span>
<span id="cb13-6"></span>
<span id="cb13-7"><span></span></span>
<span id="cb13-8"><span><span><span>newtype</span></span></span><span> </span><span><span><span>TagsList</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>TagsList</span></span></span><span> (</span><span><span><span>NonEmpty</span></span></span><span> </span><span><span><span>Tag</span></span></span><span>)</span></span>
<span id="cb13-9"></span>
<span id="cb13-10"><span><span>mkTagsList</span> ::</span> [<span><span>String</span></span>] <span>-&gt;</span> <span><span>TagsList</span></span></span>
<span id="cb13-11"><span>mkTagsList</span> [] <span>=</span> <span>error</span> <span><span>"Empty list of tags"</span></span></span>
<span id="cb13-12"><span>mkTagsList</span> (tag<span>:</span>tags) <span>=</span> <span><span>TagsList</span></span> <span>$</span> mkTag tag <span>:|</span> <span>map</span> mkTag tags</span></code></pre></div>

<div id="solutionSmartConstructor1">
<h4 id="smart-constructor-solution">Smart constructor: Solution<a href="#smart-constructor-solution">üîó</a></h4>
<div id="cb14"><pre><code><span id="cb14-1"><span><span>module</span></span> <span>Tag</span> <span><span>where</span></span></span>
<span id="cb14-2"></span>
<span id="cb14-3"><span></span></span>
<span id="cb14-4"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Tag</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Tag</span></span></span><span> </span><span><span><span>String</span></span></span></span>
<span id="cb14-5"></span>
<span id="cb14-6"><span><span>mkTag</span> ::</span> <span><span>String</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Tag</span></span></span>
<span id="cb14-7"><span>mkTag</span> tag</span>
<span id="cb14-8">    <span>|</span> <span>null</span> tag <span>=</span> <span><span>Nothing</span></span></span>
<span id="cb14-9">    <span>|</span> <span>otherwise</span> <span>=</span> <span><span>Just</span></span> (<span><span>Tag</span></span> tag)</span></code></pre></div>
<div id="cb15"><pre><code><span id="cb15-1"><span><span>module</span></span> <span>TagsList</span> <span><span>where</span></span></span>
<span id="cb15-2"></span>
<span id="cb15-3"><span><span>import</span></span> <span>Control.Applicative</span> (<span>liftA2</span>)</span>
<span id="cb15-4"><span><span>import</span></span> <span>Data.List.NonEmpty</span> (<span><span>NonEmpty</span></span> (..))</span>
<span id="cb15-5"><span><span>import</span></span> <span>Tag</span> (<span><span>Tag</span></span>, <span>mkTag</span>)</span>
<span id="cb15-6"></span>
<span id="cb15-7"></span>
<span id="cb15-8"><span></span></span>
<span id="cb15-9"><span><span><span>newtype</span></span></span><span> </span><span><span><span>TagsList</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>TagsList</span></span></span><span> (</span><span><span><span>NonEmpty</span></span></span><span> </span><span><span><span>Tag</span></span></span><span>)</span></span>
<span id="cb15-10"></span>
<span id="cb15-11"><span><span>mkTagsList</span> ::</span> [<span><span>String</span></span>] <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>TagsList</span></span></span>
<span id="cb15-12"><span>mkTagsList</span> [] <span>=</span> <span><span>Nothing</span></span></span>
<span id="cb15-13"><span>mkTagsList</span> (tag<span>:</span>tags) <span>=</span></span>
<span id="cb15-14">    <span><span>TagsList</span></span> <span>&lt;$&gt;</span> liftA2 (<span>:|</span>) (mkTag tag) (<span>traverse</span> mkTag tags)</span></code></pre></div>
</div>
</section>
<h2 id="evidence">Evidence<a href="#evidence">üîó</a></h2>
<div>

<p>Evidence</p>

<p>Replacing boolean blindness with the validation witness.</p>

<div>
<ol type="1">
<li>Always. But most importantly, when you want to make sure that data is validated or you want to reuse that knowledge in the future.</li>
<li>To make illegal states unrepresentable.</li>
</ol>
</div>

<div>
<ol type="1">
<li>More robust code.</li>
<li>Better maintainability (e.g.&nbsp;easier to refactor).</li>
<li>More context in data.</li>
<li>Better error-messages support.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Requires writing code in a slightly different way.</li>
<li>More code.</li>
</ol>
</div>
</div>
<p>This topic naturally completes the previous pattern of ‚ÄúSmart constructors‚Äù. The approach was covered before in various excellent blog posts:</p>
<ul>
<li><a href="https://cs-syd.eu/posts/2016-07-24-overcoming-boolean-blindness-evidence.html">Overcoming Boolean blindness with Evidence</a></li>
<li><a href="https://runtimeverification.com/blog/code-smell-boolean-blindness/">Code smell: Boolean blindness</a></li>
<li><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don‚Äôt validate</a></li>
</ul>
<p>All above posts provide an amazing description and explanation of the <strong>Evidence</strong> pattern. Here we would like to add only a short overview with a small example.</p>
<p>If you ever find yourself writing code like this:</p>
<div id="cb16"><pre><code><span id="cb16-1"><span><span>add</span> ::</span> (a <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Int</span></span>) <span>-&gt;</span> (a <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Int</span></span>) <span>-&gt;</span> a <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Int</span></span></span>
<span id="cb16-2"><span>add</span> f g x <span>=</span></span>
<span id="cb16-3">    <span><span>if</span></span> isNothing (f x) <span>||</span> isNothing (g x)</span>
<span id="cb16-4">    <span><span>then</span></span> <span><span>Nothing</span></span></span>
<span id="cb16-5">    <span><span>else</span></span> <span><span>Just</span></span> (fromJust (f x) <span>+</span> fromJust (g x))</span></code></pre></div>
<p>It is a sign that you are following the boolean blindness anti-pattern and it is time to refactor your code immediately.</p>
<p>The key issue here is that by calling a function that returns <code>Bool</code> you lose the information about earlier performed validation. Instead, you can keep this information by explicitly pattern-matching on the validation or result.</p>
<p>üìö <strong>Exercise:</strong> Try refactoring the above code without using <code>isNothing</code> and <code>fromJust</code> functions. Bonus points for using <code>Maybe</code> as a <code>Monad</code>.</p>
<p>Returning to our previous example with the <code>validateHash</code> function:</p>
<div id="cb17"><pre><code><span id="cb17-1"><span><span>validateHash</span> ::</span> <span><span>Password</span></span> <span>-&gt;</span> <span><span>PasswordHash</span></span> <span>-&gt;</span> <span><span>Bool</span></span></span></code></pre></div>
<p>You still can forget to call this validation function in the application code and allow users to work with invalid passwords.</p>
<div id="cb18"><pre><code><span id="cb18-1"><span>getUserPage</span>,<span> accessDenied ::</span> <span><span>User</span></span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>Page</span></span></span>
<span id="cb18-2"></span>
<span id="cb18-3"><span><span>loginUser</span> ::</span> <span><span>User</span></span> <span>-&gt;</span> <span><span>Password</span></span> <span>-&gt;</span> <span><span>PasswordHash</span></span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>Page</span></span></span>
<span id="cb18-4"><span>loginUser</span> user pwd pwdHash <span>=</span></span>
<span id="cb18-5">    <span><span>if</span></span> validateHash pwd pwdHash</span>
<span id="cb18-6">    <span><span>then</span></span> getUserPage user</span>
<span id="cb18-7">    <span><span>else</span></span> accessDenined user</span></code></pre></div>
<p>The above code has two problems:</p>
<ol type="1">
<li>Even in the <code>else</code> branch you can call <code>getUserPage</code> and allow users to enter with the invalid passwords.</li>
<li>You can simply forget to call <code>validateHash</code> whenever it is needed.</li>
</ol>
<p>One more type-safe approach (but also a bit more heavyweight solution) would be to return some sort of witness for the fact that a password was validated, and then require this witness in the future functions.</p>
<p>To implement this solution, first, we need to change the type of <code>validateHash</code>:</p>
<div id="cb19"><pre><code><span id="cb19-1"><span></span></span>
<span id="cb19-2"><span><span><span>data</span></span></span><span> </span><span><span><span>UserAuth</span></span></span></span>
<span id="cb19-3"></span>
<span id="cb19-4"><span></span></span>
<span id="cb19-5"><span><span>validateHash</span> ::</span> <span><span>Password</span></span> <span>-&gt;</span> <span><span>PasswordHash</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>UserAuth</span></span></span></code></pre></div>
<p>Now we change the type of <code>getUserPage</code> to take <code>UserAuth</code> as a required parameter:</p>
<div id="cb20"><pre><code><span id="cb20-1"><span><span>getUserPage</span> ::</span> <span><span>UserAuth</span></span> <span>-&gt;</span> <span><span>User</span></span> <span>-&gt;</span> <span><span>IO</span></span> <span><span>Page</span></span></span></code></pre></div>
<p>Since <code>UserAuth</code> can be created only with <code>validateHash</code>, the only way to return a user page is by performing password validation:</p>
<div id="cb21"><pre><code><span id="cb21-1"><span><span>loginUser</span> ::</span> <span><span>User</span></span> <span>-&gt;</span> <span><span>Password</span></span> <span>-&gt;</span> <span><span>PasswordHash</span></span> <span>-&gt;</span> <span><span>IO</span></span> ()</span>
<span id="cb21-2"><span>loginUser</span> user pwd pwdHash <span>=</span> <span><span>case</span></span> validateHash pwd pwdHash <span><span>of</span></span></span>
<span id="cb21-3">    <span><span>Nothing</span></span>   <span>-&gt;</span> accessDenined user</span>
<span id="cb21-4">    <span><span>Just</span></span> auth <span>-&gt;</span> getUserPage auth user</span></code></pre></div>
<p>You can see how we made the code safer and more robust by a small change. And, as always, there are multiple ways of solving this problem including usages of more advanced Haskell features for providing better guarantees, with better ergonomics or for solving more difficult problems. For example, the following blog post describes implementation of a similar problem using more advanced Haskell features:</p>
<ul>
<li><a href="https://serokell.io/blog/haskell-type-level-witness">Type Witness in Haskell</a></li>
</ul>
<section id="evidence-task">
<h3>Evidence: Task<a href="#evidence-task">üîó</a></h3>
<p>Improve the following code by applying the <strong>Evidence</strong> pattern.</p>
<div id="cb22"><pre><code><span id="cb22-1"><span><span>import</span></span> <span>Data.IntMap</span> (<span><span>IntMap</span></span>)</span>
<span id="cb22-2"><span><span>import</span></span> <span>Data.Maybe</span> (<span>fromJust</span>)</span>
<span id="cb22-3"></span>
<span id="cb22-4"><span><span>import</span></span> <span><span>qualified</span></span> <span>Data.IntMap</span> <span><span>as</span></span> <span>IntMap</span></span>
<span id="cb22-5"></span>
<span id="cb22-6"></span>
<span id="cb22-7"><span>getNearestValues</span></span>
<span id="cb22-8"><span>    ::</span> <span><span>IntMap</span></span> <span><span>Double</span></span>  <span></span></span>
<span id="cb22-9">    <span>-&gt;</span> <span><span>Int</span></span>            <span></span></span>
<span id="cb22-10">    <span>-&gt;</span> <span><span>Double</span></span></span>
<span id="cb22-11"><span>getNearestValues</span> vals pos</span>
<span id="cb22-12">    <span></span></span>
<span id="cb22-13">    <span>|</span> <span>IntMap</span>.member (pos <span>-</span> <span><span>1</span></span>) vals <span>&amp;&amp;</span> <span>IntMap</span>.member (pos <span>+</span> <span><span>1</span></span>) vals <span>=</span></span>
<span id="cb22-14">        fromJust (<span>IntMap</span>.lookup (pos <span>-</span> <span><span>1</span></span>) vals) <span>+</span> fromJust (<span>IntMap</span>.lookup (pos <span>+</span> <span><span>1</span></span>) vals)</span>
<span id="cb22-15"></span>
<span id="cb22-16">    <span></span></span>
<span id="cb22-17">    <span>|</span> <span>IntMap</span>.member (pos <span>-</span> <span><span>1</span></span>) vals <span>=</span></span>
<span id="cb22-18">        fromJust (<span>IntMap</span>.lookup (pos <span>-</span> <span><span>1</span></span>) vals)</span>
<span id="cb22-19"></span>
<span id="cb22-20">    <span></span></span>
<span id="cb22-21">    <span>|</span> <span>IntMap</span>.member (pos <span>+</span> <span><span>1</span></span>) vals <span>=</span></span>
<span id="cb22-22">        fromJust (<span>IntMap</span>.lookup (pos <span>+</span> <span><span>1</span></span>) vals)</span>
<span id="cb22-23"></span>
<span id="cb22-24">    <span></span></span>
<span id="cb22-25">    <span>|</span> <span>otherwise</span> <span>=</span> <span><span>0.0</span></span></span></code></pre></div>

<div id="solutionEvidence1">
<h4 id="evidence-solution">Evidence: Solution<a href="#evidence-solution">üîó</a></h4>
<div id="cb23"><pre><code><span id="cb23-1"><span><span>import</span></span> <span>Data.IntMap</span> (<span><span>IntMap</span></span>)</span>
<span id="cb23-2"><span><span>import</span></span> <span><span>qualified</span></span> <span>Data.IntMap</span> <span><span>as</span></span> <span>IntMap</span></span>
<span id="cb23-3"></span>
<span id="cb23-4"></span>
<span id="cb23-5"><span>getNearestValues</span></span>
<span id="cb23-6"><span>    ::</span> <span><span>IntMap</span></span> <span><span>Double</span></span>  <span></span></span>
<span id="cb23-7">    <span>-&gt;</span> <span><span>Int</span></span>            <span></span></span>
<span id="cb23-8">    <span>-&gt;</span> <span><span>Double</span></span></span>
<span id="cb23-9"><span>getNearestValues</span> vals pos <span>=</span></span>
<span id="cb23-10">    <span><span>case</span></span> (<span>IntMap</span>.lookup (pos <span>-</span> <span><span>1</span></span>) vals, <span>IntMap</span>.lookup (pos <span>+</span> <span><span>1</span></span>) vals) <span><span>of</span></span></span>
<span id="cb23-11">        (<span><span>Just</span></span> left, <span><span>Just</span></span> right) <span>-&gt;</span> left <span>+</span> right</span>
<span id="cb23-12">        (<span><span>Just</span></span> left, <span><span>Nothing</span></span>)    <span>-&gt;</span> left</span>
<span id="cb23-13">        (<span><span>Nothing</span></span>, <span><span>Just</span></span> right)   <span>-&gt;</span> right</span>
<span id="cb23-14">        (<span><span>Nothing</span></span>, <span><span>Nothing</span></span>)      <span>-&gt;</span> <span><span>0.0</span></span></span></code></pre></div>
</div>
</section>
<h2 id="make-illegal-states-unrepresentable">Make illegal states unrepresentable<a href="#make-illegal-states-unrepresentable">üîó</a></h2>
<div>

<p>Make illegal states unrepresentable</p>

<p>Data types precisely describe the domain allowing to create all valid values and making it impossible to construct invalid values.</p>

<div>
<ol type="1">
<li>To restrict domain of possible values.</li>
<li>When it is feasible to describe the domain precisely.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Correctness.</li>
<li>Need to write fewer tests.</li>
<li>Harder to introduce bugs for people not knowing the whole context of a big picture.</li>
</ol>
</div>

<div>
<ol type="1">
<li>May require writing custom helper data types and functions.</li>
<li>Code can increase in size.</li>
<li>Harder to introduce logic changes.</li>
</ol>
</div>
</div>
<p>This pattern is closely related to <a href="#smart-constructor">smart constructor</a> and <a href="#evidence">evidence</a> patterns, and they can and should be used together.</p>
<p>The <em>make illegal states unrepresentable</em> motto is well-known in the FP community. Functional Programming features such as Algebraic Data Types (ADT), parametric polymorphism and others allow describing the shape of the valid data more precisely to the extent that it is impossible to construct any invalid values.</p>
<p>To give a simple example of this idea, consider a function that takes two optional values and does something with those values, but only when both values are present. The function assumes that you won‚Äôt pass only a single value without the second element, so it doesn‚Äôt bother to handle such cases.</p>
<div id="cb24"><pre><code><span id="cb24-1"><span><span>handleTwoOptionals</span> ::</span> <span><span>Maybe</span></span> a <span>-&gt;</span> <span><span>Maybe</span></span> b <span>-&gt;</span> <span><span>IO</span></span> ()</span>
<span id="cb24-2"><span>handleTwoOptionals</span> (<span><span>Just</span></span> a) (<span><span>Just</span></span> b) <span>=</span> <span>...</span> work with <span>'a'</span> <span>and</span> <span>'b'</span></span>
<span id="cb24-3"><span>handleTwoOptionals</span> <span><span>Nothing</span></span> <span><span>Nothing</span></span> <span>=</span> <span>...</span> proceed without values</span>
<span id="cb24-4"><span>handleTwoOptionals</span> _ _ <span>=</span> <span>error</span> <span><span>"You must specify both values"</span></span></span></code></pre></div>
<p>The type of <code>handleTwoOptionals</code> allows passing <code>Just a</code> and <code>Nothing :: Maybe b</code>, but in reality the function doesn‚Äôt process such a combination. You can notice that it is straightforward to fix this particular problem by changing types barely: instead of passing two <code>Maybe</code>s separately, you need to pass <code>Maybe</code> of a pair.</p>
<div id="cb25"><pre><code><span id="cb25-1"><span><span>handleTwoOptionals</span> ::</span> <span><span>Maybe</span></span> (a, b) <span>-&gt;</span> <span><span>IO</span></span> ()</span>
<span id="cb25-2"><span>handleTwoOptionals</span> (<span><span>Just</span></span> (a, b)) <span>=</span> <span>...</span> work with <span>'a'</span> <span>and</span> <span>'b'</span></span>
<span id="cb25-3"><span>handleTwoOptionals</span> <span><span>Nothing</span></span> <span>=</span> <span>...</span> proceed without values</span></code></pre></div>
<p>With this slight change we made it impossible to specify only a single value as <code>Nothing</code>. If you pass <code>Just</code> of something, you must always provide both values.</p>
<hr>
<p>Let‚Äôs move on to another example. Now we want to write a function that takes two lists, but those lists must have the same length. Our function doesn‚Äôt work when lists have different sizes. The type signature can look like this:</p>
<div id="cb26"><pre><code><span id="cb26-1"><span><span>processTwoLists</span> ::</span> [a] <span>-&gt;</span> [b] <span>-&gt;</span> <span><span>Int</span></span></span></code></pre></div>
<p>It is up to the caller to verify that both lists have the same size. But if you don‚Äôt verify list lengths, the <code>processTwoLists</code> function fails. Moreover, even if a caller checked this property, the type signature still doesn‚Äôt capture the verification result. Note, that it could benefit from the usage of the <a href="#evidence">evidence</a> pattern to bear in mind this fact.</p>
<p>Again, it is pretty easy to fix the problem by changing the type of <code>processTwoLists</code>:</p>
<div id="cb27"><pre><code><span id="cb27-1"><span><span>processTwoLists</span> ::</span> [(a, b)] <span>-&gt;</span> <span><span>Int</span></span></span></code></pre></div>
<p>Instead of passing two lists and expecting them to have the same size, the function simply takes a list of pairs, so it has the same number of <code>a</code>s and <code>b</code>s.</p>
<hr>
<p>And one more example. Imagine, that you are writing a web application with the backend and frontend. And you have a function that deals with the settings for both backend and frontend to launch your app. Both setting configurations can be optional, but at least one of the settings parts should be specified.</p>
<p>You can start approaching this problem by writing the following code:</p>
<div id="cb28"><pre><code><span id="cb28-1"><span><span><span>data</span></span></span><span> </span><span><span><span>Settings</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Settings</span></span></span></span>
<span id="cb28-2">    {<span> settingsBackend  ::</span> <span><span>Maybe</span></span> <span><span>BackendSettings</span></span></span>
<span id="cb28-3">    ,<span> settingsFrontend ::</span> <span><span>Maybe</span></span> <span><span>FrontendSettings</span></span></span>
<span id="cb28-4">    }</span>
<span id="cb28-5"></span>
<span id="cb28-6"><span><span>runApp</span> ::</span> <span><span>Settings</span></span> <span>-&gt;</span> <span><span>IO</span></span> ()</span>
<span id="cb28-7"><span>runApp</span> <span><span>Settings</span></span>{<span>..</span>} <span>=</span> <span><span>case</span></span> (settingsBackend, settingsFrontend) <span><span>of</span></span></span>
<span id="cb28-8">    (<span><span>Just</span></span> back, <span><span>Just</span></span> front) <span>-&gt;</span> configureBack back <span>&gt;&gt;</span> configureFront front <span>&gt;&gt;</span> run</span>
<span id="cb28-9">    (<span><span>Just</span></span> back, <span><span>Nothing</span></span>)    <span>-&gt;</span> configureBack back <span>&gt;&gt;</span> run</span>
<span id="cb28-10">    (<span><span>Nothing</span></span>, <span><span>Just</span></span> front)   <span>-&gt;</span> configureFront front <span>&gt;&gt;</span> run</span>
<span id="cb28-11">    (<span><span>Nothing</span></span>, <span><span>Nothing</span></span>)      <span>-&gt;</span> throw <span><span>"You must specify at least one settings"</span></span></span></code></pre></div>
<p>But the above function has the same problem: the data type makes it possible to specify values that shouldn‚Äôt happen in real life. To fix this problem, we need to change the shape our <code>Settings</code> data type in the following way by using sum types:</p>
<div id="cb29"><pre><code><span id="cb29-1"><span><span><span>data</span></span></span><span> </span><span><span><span>Settings</span></span></span></span>
<span id="cb29-2">    <span>=</span> <span><span>OnlyBackend</span></span> <span><span>BackendSettings</span></span></span>
<span id="cb29-3">    <span>|</span> <span><span>OnlyFrontend</span></span> <span><span>FrontendSettings</span></span></span>
<span id="cb29-4">    <span>|</span> <span><span>BothSettings</span></span> <span><span>BackendSettings</span></span> <span><span>FrontendSettings</span></span></span>
<span id="cb29-5"></span>
<span id="cb29-6"><span><span>runApp</span> ::</span> <span><span>Settings</span></span> <span>-&gt;</span> <span><span>IO</span></span> ()</span>
<span id="cb29-7"><span>runApp</span> <span>=</span> <span><span>case</span></span></span>
<span id="cb29-8">    <span><span>OnlyBackend</span></span> back        <span>-&gt;</span> configureBack back <span>&gt;&gt;</span> run</span>
<span id="cb29-9">    <span><span>OnlyFrontend</span></span> front      <span>-&gt;</span> configureFront front <span>&gt;&gt;</span> run</span>
<span id="cb29-10">    <span><span>BothSettings</span></span> back front <span>-&gt;</span> configureBack back <span>&gt;&gt;</span> configureFront front <span>&gt;&gt;</span> run</span></code></pre></div>
<p>Now, even developers unfamiliar with the codebase won‚Äôt be able to create invalid settings. The shape of our data precisely describes all valid states in our program.</p>
<p>Generally, by pushing requirements for our data types upstream, we can implement more correct code and make the life of our API users easier, because they can‚Äôt shoot themselves in the foot by providing illegal values.</p>
<hr>
<p>However, it is not always possible to easily make all invalid states unrepresentable. Consider the following example. You have an enumeration type representing answers to some questions in a form. And users of this form must enter up to 3 different values in that form. Even if requirements explicitly tell that we must have one, two or three distinct answers, you might go with the a simple data type like this:</p>
<div id="cb30"><pre><code><span id="cb30-1"><span><span><span>data</span></span></span><span> </span><span><span><span>Answers</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Answers</span></span></span></span>
<span id="cb30-2">    {<span> answers1 ::</span> <span><span>Answer</span></span></span>
<span id="cb30-3">    ,<span> answers2 ::</span> <span><span>Maybe</span></span> <span><span>Answer</span></span></span>
<span id="cb30-4">    ,<span> answers3 ::</span> <span><span>Maybe</span></span> <span><span>Answer</span></span></span>
<span id="cb30-5">    }</span></code></pre></div>
<p>Sure, this data type allows many illegal states, and there is a room for improvement. But to be exactly precise in our data description, we probably need to create another enumeration type specifying only valid combinations of <code>Answer</code>s. However, such enumeration will be huge and unmaintainable. Even if your original <code>Answer</code> type has 8 values, the resulting combinations type will have approximately one hundred constructions that you will need to tackle all everytime the original data type changes. In this case, it is not feasible to describe only valid states with a data type, so we don‚Äôt bother doing this.</p>
<section id="make-illegal-states-unrepresentable-task-1">
<h3>Make illegal states unrepresentable: Task 1<a href="#make-illegal-states-unrepresentable-task-1">üîó</a></h3>
<p>Implement the following function by applying the <em>make illegal states unrepresentable</em> pattern.</p>
<div id="cb31"><pre><code><span id="cb31-1"><span></span></span>
<span id="cb31-2"><span></span></span>
<span id="cb31-3"><span></span></span>
<span id="cb31-4"><span><span>group</span></span><span> ::</span> <span><span>Eq</span></span> a <span>=&gt;</span> [a] <span>-&gt;</span> [[a]]</span></code></pre></div>
<blockquote>
<p><strong>Hint:</strong> Use the <code>NonEmpty</code> list.</p>
</blockquote>

<div id="solutionIllegal1">
<h4 id="make-illegal-states-unrepresentable-solution-1">Make illegal states unrepresentable: Solution 1<a href="#make-illegal-states-unrepresentable-solution-1">üîó</a></h4>
<div id="cb32"><pre><code><span id="cb32-1"><span><span>{-# LANGUAGE ScopedTypeVariables #-}</span></span></span>
<span id="cb32-2"></span>
<span id="cb32-3"><span><span>import</span></span> <span>Data.List.NonEmpty</span> (<span><span>NonEmpty</span></span> (..))</span>
<span id="cb32-4"></span>
<span id="cb32-5"><span><span>group</span></span><span> ::</span> <span><span>forall</span></span> a <span>.</span> <span><span>Eq</span></span> a <span>=&gt;</span> [a] <span>-&gt;</span> [<span><span>NonEmpty</span></span> a]</span>
<span id="cb32-6"><span><span>group</span></span> <span>=</span> go</span>
<span id="cb32-7">  <span><span>where</span></span></span>
<span id="cb32-8"><span>    go ::</span> [a] <span>-&gt;</span> [<span><span>NonEmpty</span></span> a]</span>
<span id="cb32-9">    go [] <span>=</span> []</span>
<span id="cb32-10">    go (x <span>:</span> xs) <span>=</span></span>
<span id="cb32-11">        <span><span>let</span></span> (ys, zs) <span>=</span> <span>span</span> (<span>==</span> x) xs</span>
<span id="cb32-12">        <span><span>in</span></span> (x <span>:|</span> ys) <span>:</span> go zs</span></code></pre></div>
</div>
</section>
<section id="make-illegal-states-unrepresentable-task-2">
<h3>Make illegal states unrepresentable: Task 2<a href="#make-illegal-states-unrepresentable-task-2">üîó</a></h3>
<p>Improve the following code by applying the <em>make illegal states unrepresentable</em> pattern.</p>
<div id="cb33"><pre><code><span id="cb33-1"><span></span></span>
<span id="cb33-2"><span><span>sumUpToThree</span> ::</span> <span><span>Num</span></span> a <span>=&gt;</span> [a] <span>-&gt;</span> a</span>
<span id="cb33-3"><span>sumUpToThree</span> []        <span>=</span> <span>error</span> <span><span>"Empty list"</span></span></span>
<span id="cb33-4"><span>sumUpToThree</span> [x]       <span>=</span> x</span>
<span id="cb33-5"><span>sumUpToThree</span> [x, y]    <span>=</span> x <span>+</span> y</span>
<span id="cb33-6"><span>sumUpToThree</span> [x, y, z] <span>=</span> x <span>+</span> y <span>+</span> z</span>
<span id="cb33-7"><span>sumUpToThree</span> _         <span>=</span> <span>error</span> <span><span>"More than three values"</span></span></span></code></pre></div>

<div id="solutionIllegal2">
<h4 id="make-illegal-states-unrepresentable-solution-2">Make illegal states unrepresentable: Solution 2<a href="#make-illegal-states-unrepresentable-solution-2">üîó</a></h4>
<div id="cb34"><pre><code><span id="cb34-1"><span><span>{-# LANGUAGE LambdaCase #-}</span></span></span>
<span id="cb34-2"></span>
<span id="cb34-3"><span><span><span>data</span></span></span><span> </span><span><span><span>UpToThree</span></span></span><span> a</span></span>
<span id="cb34-4">    <span>=</span> <span><span>One</span></span> a</span>
<span id="cb34-5">    <span>|</span> <span><span>Two</span></span> a a</span>
<span id="cb34-6">    <span>|</span> <span><span>Three</span></span> a a a</span>
<span id="cb34-7"></span>
<span id="cb34-8"><span><span>sumUpToThree</span> ::</span> <span><span>Num</span></span> a <span>=&gt;</span> <span><span>UpToThree</span></span> a <span>-&gt;</span> a</span>
<span id="cb34-9"><span>sumUpToThree</span> <span>=</span> <span><span>case</span></span></span>
<span id="cb34-10">    <span><span>One</span></span>   a     <span>-&gt;</span> a</span>
<span id="cb34-11">    <span><span>Two</span></span>   a b   <span>-&gt;</span> a <span>+</span> b</span>
<span id="cb34-12">    <span><span>Three</span></span> a b c <span>-&gt;</span> a <span>+</span> b <span>+</span> c</span></code></pre></div>
</div>
</section>
<h2 id="phantom-type-parameters">Phantom type parameters<a href="#phantom-type-parameters">üîó</a></h2>
<div>

<p>Phantom type parameters</p>

<p>Additional type-level information available during compile-time by introducing extra type variables.</p>

<div>
<ol type="1">
<li>To avoid duplication of many similar data types.</li>
<li>To increase code type-safety.</li>
</ol>
</div>

<div>
<ol type="1">
<li>More compile-time guarantees.</li>
<li>Better ergonomics compared to code duplication.</li>
<li>Flexibility.</li>
<li>Extensibility.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Need to know when not to use it. Can get out of control when applied to unsuitable situations.</li>
<li>Less beginner-friendly.</li>
</ol>
</div>
</div>
<p>Sometimes you can improve benefits gained with the usage of <code>newtype</code>s even further by using ‚Äúphantom type variables‚Äù ‚Äî type variables that are not used after the ‚Äú=‚Äù sign in the data type declaration. You can exploit them to distinguish usages of the same <code>newtype</code> for different purposes. Instead of writing:</p>
<div id="cb35"><pre><code><span id="cb35-1"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Id</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Id</span></span></span></span>
<span id="cb35-2">    {<span> unId ::</span> <span><span>Int</span></span></span>
<span id="cb35-3">    }</span>
<span id="cb35-4"></span>
<span id="cb35-5"><span><span>isCommentByUser</span> ::</span> <span><span>Id</span></span> <span>-&gt;</span> <span><span>Id</span></span> <span>-&gt;</span> <span><span>Bool</span></span></span></code></pre></div>
<p>or more verbose</p>
<div id="cb36"><pre><code><span id="cb36-1"><span><span><span>newtype</span></span></span><span> </span><span><span><span>UserId</span></span></span><span>    </span><span><span>=</span></span><span> </span><span><span><span>UserId</span></span></span><span>    </span><span><span><span>Int</span></span></span></span>
<span id="cb36-2"><span><span><span>newtype</span></span></span><span> </span><span><span><span>CommentId</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>CommentId</span></span></span><span> </span><span><span><span>Int</span></span></span></span>
<span id="cb36-3"></span>
<span id="cb36-4"><span><span>isCommentByUser</span> ::</span> <span><span>UserId</span></span> <span>-&gt;</span> <span><span>CommentId</span></span> <span>-&gt;</span> <span><span>Bool</span></span></span></code></pre></div>
<p>you can have one newtype to represent that all:</p>
<div id="cb37"><pre><code><span id="cb37-1"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Id</span></span></span><span> a </span><span><span>=</span></span><span> </span><span><span><span>Id</span></span></span></span>
<span id="cb37-2">    {<span> unId ::</span> <span><span>Int</span></span></span>
<span id="cb37-3">    }</span>
<span id="cb37-4"></span>
<span id="cb37-5"><span><span>isCommentByUser</span> ::</span> <span><span>Id</span></span> <span><span>User</span></span> <span>-&gt;</span> <span><span>Id</span></span> <span><span>Comment</span></span> <span>-&gt;</span> <span><span>Bool</span></span></span></code></pre></div>
<p>This approach allows you to avoid creating multiple data types that have the same purpose and behaviour.</p>
<p>For example, you can have a lot of instances for your <code>newtype</code>s and don‚Äôt want to repeat them for <code>UserId</code>, <code>AdminId</code>, <code>CommentId</code>, <code>MessageId</code>, etc. but still desire to have more type-safety. Adding a phantom type parameter to a single data type is a minor yet powerful change to your data types that imposes an extra layer of type-safety to your code.</p>
<p>Going back again to our favourite example with passwords: you can have multiple entities that can log into your application (users, administrators, third-parties, etc.). And those different entities may have diverse authentication methods or password validation algorithms. You could use phantom type variables here as well in order to track sign-in information on the type-level and bind the password with its hash using the type-level tag:</p>
<div id="cb38"><pre><code><span id="cb38-1"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Password</span></span></span><span> a </span><span><span>=</span></span><span> </span><span><span><span>Password</span></span></span></span>
<span id="cb38-2">    {<span> unPassword ::</span> <span><span>ByteString</span></span></span>
<span id="cb38-3">    }</span>
<span id="cb38-4"></span>
<span id="cb38-5"><span><span><span>newtype</span></span></span><span> </span><span><span><span>PasswordHash</span></span></span><span> a </span><span><span>=</span></span><span> </span><span><span><span>PasswordHash</span></span></span></span>
<span id="cb38-6">    {<span> unPasswordHash ::</span> <span><span>ByteString</span></span></span>
<span id="cb38-7">    }</span>
<span id="cb38-8"></span>
<span id="cb38-9"><span></span></span>
<span id="cb38-10"><span><span>mkPasswordHash</span> ::</span> <span><span>Password</span></span> a <span>-&gt;</span> <span><span>Maybe</span></span> (<span><span>PasswordHash</span></span> a)</span></code></pre></div>
<p>Now it is no longer possible to validate the password of a user with the hash of an admin.</p>
<p>üìö <strong>Exercise:</strong> The <code>mkPasswordhash</code> function takes a password and maybe returns password hash. Can you notice which one of the previously discussed patterns is used here? üòâ</p>
<section id="phantom-type-parameters-task">
<h3>Phantom type parameters: Task<a href="#phantom-type-parameters-task">üîó</a></h3>
<p>Improve the following code by applying the <em>Phantom type parameters</em> pattern. Don‚Äôt worry about function implementations, they are not important in this task.</p>
<div id="cb39"><pre><code><span id="cb39-1"><span><span>import</span></span> <span>Data.Binary</span> (<span><span>Binary</span></span>)</span>
<span id="cb39-2"><span><span>import</span></span> <span>Data.ByteString</span> (<span><span>ByteString</span></span>)</span>
<span id="cb39-3"></span>
<span id="cb39-4"></span>
<span id="cb39-5"><span><span><span>newtype</span></span></span><span> </span><span><span><span>PrivateKey</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>PrivateKey</span></span></span><span> </span><span><span><span>ByteString</span></span></span></span>
<span id="cb39-6"><span><span><span>newtype</span></span></span><span> </span><span><span><span>PublicKey</span></span></span><span>  </span><span><span>=</span></span><span> </span><span><span><span>PublicKey</span></span></span><span>  </span><span><span><span>ByteString</span></span></span></span>
<span id="cb39-7"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Signature</span></span></span><span>  </span><span><span>=</span></span><span> </span><span><span><span>Signature</span></span></span><span>  </span><span><span><span>ByteString</span></span></span></span>
<span id="cb39-8"></span>
<span id="cb39-9"><span></span></span>
<span id="cb39-10"><span><span>createPublicKey</span> ::</span> <span><span>PrivateKey</span></span> <span>-&gt;</span> <span><span>PublicKey</span></span></span>
<span id="cb39-11"><span>createPublicKey</span> <span>=</span> <span>error</span> <span><span>"Not implemented"</span></span></span>
<span id="cb39-12"></span>
<span id="cb39-13"><span></span></span>
<span id="cb39-14"><span><span>sign</span> ::</span> <span><span>Binary</span></span> a <span>=&gt;</span> <span><span>PrivateKey</span></span> <span>-&gt;</span> a <span>-&gt;</span> <span><span>Signature</span></span></span>
<span id="cb39-15"><span>sign</span> <span>=</span> <span>error</span> <span><span>"Not implemented"</span></span></span>
<span id="cb39-16"></span>
<span id="cb39-17"><span></span></span>
<span id="cb39-18"><span></span></span>
<span id="cb39-19"><span><span>verifySignature</span> ::</span> <span><span>Binary</span></span> a <span>=&gt;</span> <span><span>PublicKey</span></span> <span>-&gt;</span> <span><span>Signature</span></span> <span>-&gt;</span> a <span>-&gt;</span> <span><span>Bool</span></span></span>
<span id="cb39-20"><span>verifySignature</span> <span>=</span> <span>error</span> <span><span>"Not implemented"</span></span></span></code></pre></div>

<div id="solutionPhantom1">
<h4 id="phantom-type-parameters-solution">Phantom type parameters: Solution<a href="#phantom-type-parameters-solution">üîó</a></h4>
<div id="cb40"><pre><code><span id="cb40-1"><span><span>import</span></span> <span>Data.Binary</span> (<span><span>Binary</span></span>)</span>
<span id="cb40-2"><span><span>import</span></span> <span>Data.ByteString</span> (<span><span>ByteString</span></span>)</span>
<span id="cb40-3"></span>
<span id="cb40-4"></span>
<span id="cb40-5"><span><span><span>newtype</span></span></span><span> </span><span><span><span>PrivateKey</span></span></span><span>  </span><span><span>=</span></span><span> </span><span><span><span>PrivateKey</span></span></span><span> </span><span><span><span>ByteString</span></span></span></span>
<span id="cb40-6"><span><span><span>newtype</span></span></span><span> </span><span><span><span>PublicKey</span></span></span><span>   </span><span><span>=</span></span><span> </span><span><span><span>PublicKey</span></span></span><span>  </span><span><span><span>ByteString</span></span></span></span>
<span id="cb40-7"><span><span><span>newtype</span></span></span><span> </span><span><span><span>Signature</span></span></span><span> a </span><span><span>=</span></span><span> </span><span><span><span>Signature</span></span></span><span>  </span><span><span><span>ByteString</span></span></span></span>
<span id="cb40-8"></span>
<span id="cb40-9"><span></span></span>
<span id="cb40-10"><span><span>createPublicKey</span> ::</span> <span><span>PrivateKey</span></span> <span>-&gt;</span> <span><span>PublicKey</span></span></span>
<span id="cb40-11"><span>createPublicKey</span> <span>=</span> <span>error</span> <span><span>"Not implemented"</span></span></span>
<span id="cb40-12"></span>
<span id="cb40-13"><span></span></span>
<span id="cb40-14"><span><span>sign</span> ::</span> <span><span>Binary</span></span> a <span>=&gt;</span> <span><span>PrivateKey</span></span> <span>-&gt;</span> a <span>-&gt;</span> <span><span>Signature</span></span> a</span>
<span id="cb40-15"><span>sign</span> <span>=</span> <span>error</span> <span><span>"Not implemented"</span></span></span></code></pre></div>
<p>Check that the signature for the following <code>verifySignature</code> function is produced by the <code>PublicKey</code>, derived for the corresponding <code>PrivateKey</code> that signed the same type of data. The implementation guarantees that you cannot verify signature for a different type than the signature was created initially.</p>
<div id="cb41"><pre><code><span id="cb41-1"><span><span>verifySignature</span> ::</span> <span><span>Binary</span></span> a <span>=&gt;</span> <span><span>PublicKey</span></span> <span>-&gt;</span> <span><span>Signature</span></span> a <span>-&gt;</span> a <span>-&gt;</span> <span><span>Bool</span></span></span>
<span id="cb41-2"><span>verifySignature</span> <span>=</span> <span>error</span> <span><span>"Not implemented"</span></span></span></code></pre></div>
</div>
</section>
<h2 id="monadfail-sugar">MonadFail sugar<a href="#monadfail-sugar">üîó</a></h2>
<div>

<p>MonadFail sugar</p>

<p>Elegant syntax for pattern-matching on nested or multiple different parts of the data.</p>

<div>
<ol type="1">
<li>When doing pattern-matching a lot and when a particular failure reason is not important.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Clean syntax, less noise.</li>
<li>No runtime errors by avoiding partial functions.</li>
</ol>
</div>

<div>
<ol type="1">
<li>No detailed error messages about failures.</li>
<li>No immediate understanding of what code would do in case of the error to pattern-match.</li>
</ol>
</div>
</div>
<p>When time comes to extract deeply-nested fields of a nested data structure, or to perform multiple validations in a single block, you start thinking on the neat way to do it at the best cost. You obviously fancy to avoid using partial functions because they can sometimes hide unhandled cases and fail at runtime unexpectedly.</p>
<p>There is a nice trick that combines the <code>Maybe</code> data type, <code>do</code>-notation and <code>MonadFail</code> typeclass that allows writing such code. Each piece of this spicy combination will be explained further, but first we need to understand the use-case. Let‚Äôs explore the following example.</p>
<p>When you write a function like this:</p>
<div id="cb42"><pre><code><span id="cb42-1"><span><span>isThisTheAnswer</span> ::</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Bool</span></span></span>
<span id="cb42-2"><span>isThisTheAnswer</span> <span><span>42</span></span> <span>=</span> <span><span>True</span></span></span></code></pre></div>
<p>and if you pass a number like <code>37</code> to this function, it will surely fail.</p>
<p>However, when you pattern-match on any value on the left side of <code>&lt;-</code> inside <code>do</code>-block, a slightly different set of rules is used for handling non-covered patterns. These rules involve usage of the <code>MonadFail</code> typeclass.</p>
<p>The <code>MonadFail</code> definition has nothing exclusive:</p>
<div id="cb43"><pre><code><span id="cb43-1"><span><span><span>class</span></span></span><span> </span><span><span><span>Monad</span></span></span><span> m </span><span><span>=&gt;</span></span><span> </span><span><span><span>MonadFail</span></span></span><span> m </span><span><span><span>where</span></span></span></span>
<span id="cb43-2"><span>    fail ::</span> <span><span>String</span></span> <span>-&gt;</span> m a</span></code></pre></div>
<p>You can use this typeclass directly by calling the <code>fail</code> method. But most of the time you are using this typeclass implicitly, usually with the <code>IO</code>. It is important to mention here that the <code>fail</code> method of the <code>MonadFail</code> typeclass participates in the desugarisation of <code>do</code> blocks.</p>
<p>In other words, the following sweet code</p>
<div id="cb44"><pre><code><span id="cb44-1"><span><span>main</span> ::</span> <span><span>IO</span></span> ()</span>
<span id="cb44-2"><span>main</span> <span>=</span> <span><span>do</span></span></span>
<span id="cb44-3">    [_, arg2] <span>&lt;-</span> getArgs</span>
<span id="cb44-4">    <span>print</span> arg2</span></code></pre></div>
<p>will be desugared into something like this:</p>
<div id="cb45"><pre><code><span id="cb45-1"><span><span>main</span> ::</span> <span><span>IO</span></span> ()</span>
<span id="cb45-2"><span>main</span> <span>=</span> getArgs <span>&gt;&gt;=</span> rgs <span>-&gt;</span> <span><span>case</span></span> args <span><span>of</span></span></span>
<span id="cb45-3">    [_, arg2] <span>-&gt;</span> <span>print</span> arg2</span>
<span id="cb45-4">    _ <span>-&gt;</span> <span>fail</span> <span><span>"Some compiler-generated message"</span></span></span></code></pre></div>
<p>The <code>MonadFail</code> instance for <code>IO</code> throws an IO exception, but the instance for <code>Maybe</code> is rather curious:</p>
<div id="cb46"><pre><code><span id="cb46-1"><span><span><span>instance</span></span></span><span> </span><span><span><span>MonadFail</span></span></span><span> </span><span><span><span>Maybe</span></span></span><span> </span><span><span><span>where</span></span></span></span>
<span id="cb46-2">    <span>fail</span> _ <span>=</span> <span><span>Nothing</span></span>  <span></span></span></code></pre></div>
<p>Now let‚Äôs have a closer look at a more specific example to understand better how <code>Maybe</code> and <code>MonadFail</code> play together. Let‚Äôs say, we want to perform the following check on our data:</p>
<ul>
<li>extract the last line of the text from some buffer (therefore it should contain at least one line)</li>
<li>make sure that it contains exactly 3 words</li>
<li>the first word must be <code>"CMD"</code></li>
<li>the second word is the number 42</li>
</ul>
<p>In case all the above is true, we want to return the last word in this sequence of words. Such verification can be easily written using the <code>Maybe</code> type and its <code>MonadFail</code> instance:</p>
<div id="cb47"><pre><code><span id="cb47-1"><span><span>bufferLastLine</span> ::</span> <span><span>Buffer</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>String</span></span></span>
<span id="cb47-2"></span>
<span id="cb47-3"><span><span>cmdSequence</span> ::</span> <span><span>Buffer</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>String</span></span></span>
<span id="cb47-4"><span>cmdSequence</span> buffer <span>=</span> <span><span>do</span></span></span>
<span id="cb47-5">    line <span>&lt;-</span> bufferLastLine buffer</span>
<span id="cb47-6">    [<span><span>"CMD"</span></span>, number, cmd] <span>&lt;-</span> <span><span>Just</span></span> <span>$</span> <span>words</span> line</span>
<span id="cb47-7">    <span><span>42</span></span> <span>&lt;-</span> readMaybe number</span>
<span id="cb47-8">    <span>pure</span> cmd</span></code></pre></div>
<p>You can see that the code is clean, it does exactly what we expect with a minimal syntactic overhead, and it is also safe as a bonus.</p>
<p>üìö <strong>Exercise:</strong> Desugar the above code manually.</p>
<hr>
<p>In some cases, when performing multiple checks, it is crucial to know which one failed first in order to run the corresponding action next or provide a better error message for users. In that case, you should use <code>Either</code> instead of <code>Maybe</code>. Or if all your verification checks are independent of each other, you can use the <code>Validation</code> data type to output <strong>all</strong> errors that were fired along the way. This is useful to show the informative error messages to users. The approach with <code>Either</code> will stop on the first error, when the <code>Validation</code> approach will perform all checks anyways.</p>
<p>However, when using more detailed error-reporting, you won‚Äôt be able to make use of this <code>MonadFail</code> trick, because both <code>Either</code> and <code>Validation</code> don‚Äôt implement the <code>MonadFail</code> instance, so the manual pattern-matching or other type of handling is required.</p>
<hr>
<p>Interestingly, unlike <code>Either</code>-like data types, the <code>MonadFail</code> instance for lists in Haskell has a similar power to <code>Maybe</code>‚Äôs. If you have a container of a complicated data structure and your goal is to filter it only by some structure-specific criteria, keeping only interesting elements, you can use <a href="https://wiki.haskell.org/List_comprehension">list comprehension</a> and <code>MonadFail</code> for list. List comprehension is a cute syntax sugar for constructing lists. <code>do</code>-notation is a syntax sugar for <code>&gt;&gt;=</code> from <code>Monad</code>, so you can think about list comprehension as a syntax sugar for <code>do</code>-notation specifically for lists.</p>
<blockquote>
<p>üë©‚Äçüî¨ Haskell also has the <a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#monad-comprehensions">MonadComprehensions</a> extension that allows using the list comprehension syntax for other monads.</p>
</blockquote>
<p>Let‚Äôs say, we get a list of pairs with some <code>Either</code> values as both elements of those pairs, and we want to extract only <code>Int</code>s that are inside both <code>Right</code> and are the same. The description is wordy, but the code for this task with the usage of list comprehension is much more elegant:</p>
<div id="cb48"><pre><code><span id="cb48-1"><span><span>keepOnlySameRights</span> ::</span> [(<span><span>Either</span></span> e1 <span><span>Int</span></span>, <span><span>Either</span></span> e2 <span><span>Int</span></span>)] <span>-&gt;</span> [<span><span>Int</span></span>]</span>
<span id="cb48-2"><span>keepOnlySameRights</span> xs <span>=</span> [n <span>|</span> (<span><span>Right</span></span> n, <span><span>Right</span></span> m) <span>&lt;-</span> xs, n <span>==</span> m]</span></code></pre></div>
<p>If you attempt to implement such a function by using manual pattern-matching, it would look a bit less cleaner.</p>
<p>üìö <strong>Exercise:</strong> Try implementing the <code>keepOnlySameRights</code> functions without list comprehensions and the <code>MonadFail</code> instance for list.</p>
<section id="monadfail-sugar-task-1">
<h3>MonadFail sugar: Task 1<a href="#monadfail-sugar-task-1">üîó</a></h3>
<p>Implement the following functions applying the <em>MonadFail sugar</em> pattern.</p>
<div id="cb49"><pre><code><span id="cb49-1"><span></span></span>
<span id="cb49-2"><span></span></span>
<span id="cb49-3"><span></span></span>
<span id="cb49-4"><span></span></span>
<span id="cb49-5"><span></span></span>
<span id="cb49-6"><span><span>sumThree</span> ::</span> <span><span>String</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Int</span></span></span></code></pre></div>

<div id="solutionMonadFail1">
<h4 id="monadfail-sugar-solution-1">MonadFail sugar: Solution 1<a href="#monadfail-sugar-solution-1">üîó</a></h4>
<div id="cb50"><pre><code><span id="cb50-1"><span><span>import</span></span> <span>Text.Read</span> (<span>readMaybe</span>)</span>
<span id="cb50-2"></span>
<span id="cb50-3"><span><span>sumThree</span> ::</span> <span><span>String</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Int</span></span></span>
<span id="cb50-4"><span>sumThree</span> s <span>=</span> <span><span>do</span></span></span>
<span id="cb50-5">    [a, b, c] <span>&lt;-</span> <span>traverse</span> readMaybe <span>$</span> <span>words</span> s</span>
<span id="cb50-6">    <span>pure</span> <span>$</span> a <span>+</span> b <span>+</span> c</span></code></pre></div>
</div>
</section>
<section id="monadfail-sugar-task-2">
<h3>MonadFail sugar: Task 2<a href="#monadfail-sugar-task-2">üîó</a></h3>
<p>Implement the following functions applying the <em>MonadFail sugar</em> pattern.</p>
<div id="cb51"><pre><code><span id="cb51-1"><span></span></span>
<span id="cb51-2"><span><span>catMaybes</span> ::</span> [<span><span>Maybe</span></span> a] <span>-&gt;</span> [a]</span></code></pre></div>

<div id="solutionMonadFail2">
<h4 id="monadfail-sugar-solution-2">MonadFail sugar: Solution 2<a href="#monadfail-sugar-solution-2">üîó</a></h4>
<div id="cb52"><pre><code><span id="cb52-1"><span><span>catMaybes</span> ::</span> [<span><span>Maybe</span></span> a] <span>-&gt;</span> [a]</span>
<span id="cb52-2"><span>catMaybes</span> xs <span>=</span> [x <span>|</span> <span><span>Just</span></span> x <span>&lt;-</span> xs]</span></code></pre></div>
</div>
</section>
<section id="monadfail-sugar-task-3">
<h3>MonadFail sugar: Task 3<a href="#monadfail-sugar-task-3">üîó</a></h3>
<p>Implement the following functions applying the <em>MonadFail sugar</em> pattern.</p>
<div id="cb53"><pre><code><span id="cb53-1"><span></span></span>
<span id="cb53-2"><span><span>mapMaybe</span> ::</span> (a <span>-&gt;</span> <span><span>Maybe</span></span> b) <span>-&gt;</span> [a] <span>-&gt;</span> [b]</span></code></pre></div>

<div id="solutionMonadFail3">
<h4 id="monadfail-sugar-solution-3">MonadFail sugar: Solution 3<a href="#monadfail-sugar-solution-3">üîó</a></h4>
<div id="cb54"><pre><code><span id="cb54-1"><span><span>mapMaybe</span> ::</span> (a <span>-&gt;</span> <span><span>Maybe</span></span> b) <span>-&gt;</span> [a] <span>-&gt;</span> [b]</span>
<span id="cb54-2"><span>mapMaybe</span> f <span>as</span> <span>=</span> [b <span>|</span> a <span>&lt;-</span> <span>as</span>, <span><span>Just</span></span> b <span>&lt;-</span> [f a]]</span></code></pre></div>
</div>
</section>
<section id="monadfail-sugar-task-4">
<h3>MonadFail sugar: Task 4<a href="#monadfail-sugar-task-4">üîó</a></h3>
<p>Implement the following functions applying the <em>MonadFail sugar</em> pattern.</p>
<div id="cb55"><pre><code><span id="cb55-1"><span></span></span>
<span id="cb55-2"><span><span>threeNothing</span> ::</span> <span><span>Maybe</span></span> a <span>-&gt;</span> <span><span>Maybe</span></span> b <span>-&gt;</span> <span><span>Maybe</span></span> c <span>-&gt;</span> <span><span>Maybe</span></span> ()</span></code></pre></div>

<div id="solutionMonadFail4">
<h4 id="monadfail-sugar-solution-4">MonadFail sugar: Solution 4<a href="#monadfail-sugar-solution-4">üîó</a></h4>
<div id="cb56"><pre><code><span id="cb56-1"><span><span>threeNothing</span> ::</span> <span><span>Maybe</span></span> a <span>-&gt;</span> <span><span>Maybe</span></span> b <span>-&gt;</span> <span><span>Maybe</span></span> c <span>-&gt;</span> <span><span>Maybe</span></span> ()</span>
<span id="cb56-2"><span>threeNothing</span> ma mb mc <span>=</span> <span><span>do</span></span></span>
<span id="cb56-3">    <span><span>Nothing</span></span> <span>&lt;-</span> <span><span>Just</span></span> ma</span>
<span id="cb56-4">    <span><span>Nothing</span></span> <span>&lt;-</span> <span><span>Just</span></span> mb</span>
<span id="cb56-5">    <span><span>Nothing</span></span> <span>&lt;-</span> <span><span>Just</span></span> mc</span>
<span id="cb56-6">    <span>pure</span> ()</span></code></pre></div>
</div>
</section>
<h2 id="polymorphisation">Polymorphisation<a href="#polymorphisation">üîó</a></h2>
<div>

<p>Polymorphisation</p>

<p>Assigning a more general type to a function reduces the chances of writing an incorrect implementation or providing incorrect inputs.</p>

<div>
<ol type="1">
<li>To reduce risks of using function incorrectly.</li>
<li>To use the same function on values of different types.</li>
<li>To make illegal states unrepresentable.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Need to write fewer tests (or no tests at all!).</li>
<li>Increases code reusability.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Can make type signatures look more complicated.</li>
<li>Reusing polymorphic types in <code>where</code> requires enabling the <code>ScopedTypeVariables</code> extension, and this might be confusing for beginners.</li>
</ol>
</div>
</div>
<p>Haskell has the <a href="https://wiki.haskell.org/Polymorphism">Polymorphism</a> feature and allows writing and using polymorphic data types and functions. A polymorphic function can be defined only once for some general types, and then it can be called with arguments of different types, satisfying the type signature.</p>
<p>For example, the following function</p>
<div id="cb57"><pre><code><span id="cb57-1"><span><span>firstArg</span> ::</span> a <span>-&gt;</span> b <span>-&gt;</span> a</span>
<span id="cb57-2"><span>firstArg</span> x _ <span>=</span> x</span></code></pre></div>
<p>can have types, depending on arguments, either <code>firstArgs :: Int -&gt; String -&gt; Int</code> or <code>firstArg :: Maybe s -&gt; [a] -&gt; Maybe s</code> but not <code>firstArg :: Int -&gt; Double -&gt; Double</code>.</p>
<p>If a monomorphic function has type <code>Int -&gt; Int</code> then it can do many different things and you can‚Äôt really guess its behaviour by only looking at its type. You can guess by the function name, but naming is hard and you still need to check the documentation and probably even source code.</p>
<p>However, if the function‚Äôs type is general as <code>a -&gt; a</code> then this function can do only one thing and in that case, its name doesn‚Äôt matter, you already know what it does.</p>
<p>üìö <strong>Exercise:</strong> Do you see what the function with the type <code>a -&gt; a</code> does?</p>
<p>The thought that a more general function is less powerful is counter-intuitive. If it can work with more types, how can it be less powerful?</p>
<p>But the more you think about this, the more sense it starts making. The more polymorphic the type is, the less information we know about arguments, the more common types satisfying constraints should be, and the fewer things you can do with them. You can‚Äôt create values of some unknown type <code>a</code> out of nowhere because you don‚Äôt know their constructor methods. On the other hand, you can do a lot of things with some specific type like <code>Int</code>: increment, decrement, divide, square, return always 0, return last digit, etc.</p>
<p>This fact can be used to implement safer interfaces. The following elaborate example demonstrates key features of the polymorphisation approach.</p>
<p>Let‚Äôs say we want to implement a function that compares two pairs of <code>Int</code>s and something else by the first element of a pair:</p>
<div id="cb58"><pre><code><span id="cb58-1"><span>compareByFst</span></span>
<span id="cb58-2"><span>    ::</span> (<span><span>Int</span></span> <span>-&gt;</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Ordering</span></span>)</span>
<span id="cb58-3">    <span>-&gt;</span> (<span><span>Int</span></span>, <span><span>Bool</span></span>)</span>
<span id="cb58-4">    <span>-&gt;</span> (<span><span>Int</span></span>, <span><span>Bool</span></span>)</span>
<span id="cb58-5">    <span>-&gt;</span> <span><span>Ordering</span></span></span></code></pre></div>
<p>This type is fine, however, it‚Äôs possible to implement not exactly what we wanted but still satisfy this type signature. For example:</p>
<div id="cb59"><pre><code><span id="cb59-1"><span>compareByFst</span> cmp (a, _) (b, _) <span>=</span> cmp (a <span>+</span> <span><span>1</span></span>) (b <span>+</span> <span><span>1</span></span>)</span></code></pre></div>
<p>üìö <strong>Exercise:</strong> Can you see when this function can produce wrong results?</p>
<p>We want to restrict what the function can do. So instead of using <code>Int</code> we can use some polymorphic variable:</p>
<div id="cb60"><pre><code><span id="cb60-1"><span><span>compareByFst</span> ::</span> (a <span>-&gt;</span> a <span>-&gt;</span> <span><span>Ordering</span></span>) <span>-&gt;</span> (a, x) <span>-&gt;</span> (a, x) <span>-&gt;</span> <span><span>Ordering</span></span></span></code></pre></div>
<p>Though, since the function produces <code>Ordering</code>, you still can simply ignore all arguments and return <code>EQ</code> in all cases. But we can notice, that there‚Äôs no need to stick to the <code>Ordering</code> as well:</p>
<div id="cb61"><pre><code><span id="cb61-1"><span><span>compareByFst</span> ::</span> (a <span>-&gt;</span> a <span>-&gt;</span> c) <span>-&gt;</span> (a, x) <span>-&gt;</span> (a, x) <span>-&gt;</span> c</span></code></pre></div>
<p>However, this function still has a problem: it is possible to apply arguments in the wrong order. The following two implementations are valid:</p>
<div id="cb62"><pre><code><span id="cb62-1"><span>compareByFst</span> cmp (a, _) (b, _) <span>=</span> cmp a b</span>
<span id="cb62-2"><span>compareByFst</span> cmp (a, _) (b, _) <span>=</span> cmp b a</span></code></pre></div>
<p>When you are working only on this function, you may notice such logic errors during the development. However, programmers are humans. They can be sleepy or they can do some typos which can totally happen when you change a lot of code. And moreover, it is quite troublesome to debug them.</p>
<p>So let‚Äôs do the final step and specify the most general form of this function, renaming it as well since it has nothing to do with <code>compare</code> anymore:</p>
<div id="cb63"><pre><code><span id="cb63-1"><span><span>applyToFst</span> ::</span> (a <span>-&gt;</span> b <span>-&gt;</span> c) <span>-&gt;</span> (a, x) <span>-&gt;</span> (b, y) <span>-&gt;</span> c</span>
<span id="cb63-2"><span>applyToFst</span> f (a, _) (b, _) <span>=</span> f a b</span></code></pre></div>
<p>Now, there is only one way to implement <code>applyToFst</code>! If you write a wrong implementation, the compiler will tell you, and such bugs won‚Äôt be even introduced in the first place before it goes to production. Furthermore, since the function is polymorphic, you don‚Äôt need to change the code that uses this function. We can easily restore our first type signature from a polymorphic one by equating specific types with monomorphic variables:</p>
<div id="cb64"><pre><code><span id="cb64-1"><span>a</span> <span>~</span> <span><span>Int</span></span></span>
<span id="cb64-2"><span>b</span> <span>~</span> <span><span>Int</span></span></span>
<span id="cb64-3"><span>c</span> <span>~</span> <span><span>Ordering</span></span></span>
<span id="cb64-4"><span>x</span> <span>~</span> <span><span>Bool</span></span></span>
<span id="cb64-5"><span>y</span> <span>~</span> <span><span>Bool</span></span></span></code></pre></div>
<p>Moreover, the described approach can be applied to already polymorphic functions, which are not polymorphic enough. Consider the following example of a general-purpose function that can be improved by the Polymorphisation technique:</p>
<div id="cb65"><pre><code><span id="cb65-1"><span><span>partition</span> ::</span> (a <span>-&gt;</span> <span><span>Bool</span></span>) <span>-&gt;</span> [a] <span>-&gt;</span> ([a], [a])</span></code></pre></div>
<p>The intention of this function is to separate elements of the list into two lists by predicate. Unfortunately, this type signature has several problems:</p>
<ol type="1">
<li>It‚Äôs not clear, in which part of the tuple go elements that satisfy the predicate.</li>
<li>In the implementation of this function you still can add elements to a wrong list.</li>
</ol>
<p>A better type signature would be:</p>
<div id="cb66"><pre><code><span id="cb66-1"><span><span>partitionWith</span> ::</span> (a <span>-&gt;</span> <span><span>Either</span></span> b c) <span>-&gt;</span> [a] <span>-&gt;</span> ([b], [c])</span></code></pre></div>
<p>Now it is much harder to implement this function in the wrong way and its type signature also tells us much more about its behaviour!</p>
<p>üìö <strong>Exercise:</strong> Implement <code>partitionWith</code>.</p>
<blockquote>
<p>üë©‚Äçüî¨ It is still possible to implement <code>partition</code> in a wrong way by not adding elements to the result list. However, LinearTypes can help with ensuring this invariant.</p>
</blockquote>
<p>This trick is especially good with the <a href="#monadfail-sugar">MonadFail sugar</a> pattern. Instead of filtering elements by predicate and using unsafe conversion functions, you can use <code>mapMaybe</code> and make illegal states unrepresentable.</p>
<p>Look at the following function:</p>
<div id="cb67"><pre><code><span id="cb67-1"><span></span></span>
<span id="cb67-2"><span></span></span>
<span id="cb67-3"><span><span>sumEven</span> ::</span> <span><span>String</span></span> <span>-&gt;</span> <span><span>Int</span></span></span>
<span id="cb67-4"><span>sumEven</span> <span>=</span></span>
<span id="cb67-5">    <span>sum</span></span>
<span id="cb67-6">    <span>.</span> <span>map</span> (<span>`div`</span> <span><span>2</span></span>)</span>
<span id="cb67-7">    <span>.</span> <span>filter</span> <span>even</span></span>
<span id="cb67-8">    <span>.</span> <span>map</span> <span>read</span></span>
<span id="cb67-9">    <span>.</span> <span>filter</span> isNumber</span>
<span id="cb67-10">    <span>.</span> <span>words</span></span></code></pre></div>
<p>It can be written in a slightly different way, that also allows extending filtering rules easily:</p>
<div id="cb68"><pre><code><span id="cb68-1"><span><span>sumEven</span> ::</span> <span><span>String</span></span> <span>-&gt;</span> <span><span>Int</span></span></span>
<span id="cb68-2"><span>sumEven</span> <span>=</span> <span>sum</span> <span>.</span> mapMaybe parseNumber <span>.</span> <span>words</span></span>
<span id="cb68-3">  <span><span>where</span></span></span>
<span id="cb68-4"><span>    parseNumber ::</span> <span><span>String</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Int</span></span></span>
<span id="cb68-5">    parseNumber str <span>=</span> <span><span>do</span></span>  <span></span></span>
<span id="cb68-6">        num <span>&lt;-</span> readMaybe str</span>
<span id="cb68-7">        guard <span>$</span> <span>even</span> num</span>
<span id="cb68-8">        <span>pure</span> <span>$</span> num <span>`div`</span> <span><span>2</span></span></span></code></pre></div>
<section id="polymorphisation-task-1">
<h3>Polymorphisation: Task 1<a href="#polymorphisation-task-1">üîó</a></h3>
<p>Improve the following functions by applying the <strong>Polymorphisation</strong> pattern.</p>
<div id="cb69"><pre><code><span id="cb69-1"><span></span></span>
<span id="cb69-2"><span></span></span>
<span id="cb69-3"><span></span></span>
<span id="cb69-4"><span><span>maybeConcat</span> ::</span> [<span><span>Maybe</span></span> [<span><span>Int</span></span>]] <span>-&gt;</span> [<span><span>Int</span></span>]</span></code></pre></div>

<div id="solutionPolymorphisation1">
<h4 id="polymorphisation-solution-1">Polymorphisation: Solution 1<a href="#polymorphisation-solution-1">üîó</a></h4>
<div id="cb70"><pre><code><span id="cb70-1"><span><span>import</span></span> <span>Data.Foldable</span> (<span>fold</span>)</span>
<span id="cb70-2"><span><span>import</span></span> <span>Data.Maybe</span> (<span>catMaybes</span>)</span>
<span id="cb70-3"></span>
<span id="cb70-4"></span>
<span id="cb70-5"><span></span></span>
<span id="cb70-6"><span><span>maybeConcatList</span> ::</span> [<span><span>Maybe</span></span> [a]] <span>-&gt;</span> [a]</span>
<span id="cb70-7"><span>maybeConcatList</span> <span>=</span> <span>concat</span> <span>.</span> catMaybes</span>
<span id="cb70-8"></span>
<span id="cb70-9"><span></span></span>
<span id="cb70-10"><span><span>maybeMconcat</span> ::</span> <span><span>Monoid</span></span> m <span>=&gt;</span> [<span><span>Maybe</span></span> m] <span>-&gt;</span> m</span>
<span id="cb70-11"><span>maybeMconcat</span> <span>=</span> <span>mconcat</span> <span>.</span> catMaybes</span>
<span id="cb70-12"></span>
<span id="cb70-13"><span></span></span>
<span id="cb70-14"><span><span>foldMaybes</span> ::</span> (<span><span>Foldable</span></span> f, <span><span>Monoid</span></span> m) <span>=&gt;</span> f (<span><span>Maybe</span></span> m) <span>-&gt;</span> m</span>
<span id="cb70-15"><span>foldMaybes</span> <span>=</span> fold <span>.</span> fold</span></code></pre></div>
</div>
</section>
<section id="polymorphisation-task-2">
<h3>Polymorphisation: Task 2<a href="#polymorphisation-task-2">üîó</a></h3>
<div id="cb71"><pre><code><span id="cb71-1"><span></span></span>
<span id="cb71-2"><span></span></span>
<span id="cb71-3"><span></span></span>
<span id="cb71-4"><span><span>containsInt</span> ::</span> <span><span>Int</span></span> <span>-&gt;</span> [[<span><span>Int</span></span>]] <span>-&gt;</span> [[<span><span>Int</span></span>]]</span></code></pre></div>

<div id="solutionPolymorphisation2">
<h4 id="polymorphisation-solution-2">Polymorphisation: Solution 2<a href="#polymorphisation-solution-2">üîó</a></h4>
<div id="cb72"><pre><code><span id="cb72-1"><span></span></span>
<span id="cb72-2"><span><span>containsElem</span> ::</span> <span><span>Eq</span></span> e <span>=&gt;</span> e <span>-&gt;</span> [[e]] <span>-&gt;</span> [[e]]</span>
<span id="cb72-3"><span>containsElem</span> e <span>=</span> <span>filter</span> (<span>elem</span> e)</span>
<span id="cb72-4"></span>
<span id="cb72-5"><span></span></span>
<span id="cb72-6"><span><span>containsElem</span> ::</span> (<span><span>Foldable</span></span> f, <span><span>Eq</span></span> e) <span>=&gt;</span> e <span>-&gt;</span> [f e] <span>-&gt;</span> [f e]</span>
<span id="cb72-7"><span>containsElem</span> <span>=</span> <span>filter</span> <span>.</span> <span>elem</span></span></code></pre></div>
</div>
</section>
<section id="polymorphisation-task-3">
<h3>Polymorphisation: Task 3<a href="#polymorphisation-task-3">üîó</a></h3>
<pre><code>-- split list <span>in</span> two parts stopping <span>when</span> predicate returns <span>false</span>
-- &gt;&gt;&gt; span (&lt; <span>3</span>) [<span>1</span>, <span>2</span>, <span>4</span>, <span>2</span>]
-- ([<span>1</span>, <span>2</span>], [<span>4</span>, <span>2</span>])
span :: <span><span>(a -&gt; Bool)</span> -&gt;</span> [a] -&gt; ([a], [a])</code></pre>

<div id="solutionPolymorphisation3">
<h4 id="polymorphisation-solution-3">Polymorphisation: Solution 3<a href="#polymorphisation-solution-3">üîó</a></h4>
<div id="cb74"><pre><code><span id="cb74-1"><span><span>{-# LANGUAGE ScopedTypeVariables #-}</span></span></span>
<span id="cb74-2"></span>
<span id="cb74-3"><span><span>import</span></span> <span>Data.Bifunctor</span> (<span>first</span>)</span>
<span id="cb74-4"></span>
<span id="cb74-5"></span>
<span id="cb74-6"><span></span></span>
<span id="cb74-7"><span></span></span>
<span id="cb74-8"><span></span></span>
<span id="cb74-9"><span><span>splitWhile</span> ::</span> <span><span>forall</span></span> b a <span>.</span> (a <span>-&gt;</span> <span><span>Maybe</span></span> b) <span>-&gt;</span> [a] <span>-&gt;</span> ([b], [a])</span>
<span id="cb74-10"><span>splitWhile</span> f <span>=</span> go</span>
<span id="cb74-11">  <span><span>where</span></span></span>
<span id="cb74-12"><span>    go ::</span> [a] <span>-&gt;</span> ([b], [a])</span>
<span id="cb74-13">    go [] <span>=</span> ([], [])</span>
<span id="cb74-14">    go (a<span>:</span><span>as</span>) <span>=</span> <span><span>case</span></span> f a <span><span>of</span></span></span>
<span id="cb74-15">        <span><span>Nothing</span></span> <span>-&gt;</span> ([], a <span>:</span> <span>as</span>)</span>
<span id="cb74-16">        <span><span>Just</span></span> b <span>-&gt;</span> first (b<span>:</span>) (go <span>as</span>)</span></code></pre></div>
</div>
</section>
<h2 id="bidirectional-parsing">Bidirectional parsing<a href="#bidirectional-parsing">üîó</a></h2>
<div>

<p>Bidirectional parsing</p>

<p>Matching only a limited set with exhaustiveness checking and inversing matching function automatically.</p>

<div>
<ol type="1">
<li>When you need to show enumerations and parse them back.</li>
<li>When the <code>show</code> function is injective (maps distinct constructors to distinct values).</li>
<li>Basically, for any bidirectional conversion by implementing only one direction and getting the inverse conversion for free.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Automatic code correctness by implementation.</li>
<li>Easier maintainability.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Extra dependencies or extra code.</li>
<li>Less manual control over code.</li>
</ol>
</div>
</div>
<p>It is often in programs, that you use enumeration types (data types with several constructors without any fields). Enums are classy at least because when we pattern-match on them, GHC yells at us about cases we forgot. But things become a bit more complicated when you also want to be able to parse your enums from strings, which is a completely sane and frequent requirement. This is problematic because when handling strings via pattern-matching, you are physically unable to handle all cases because there is an infinite number of them.</p>
<p>Consider the following example:</p>
<div id="cb75"><pre><code><span id="cb75-1"><span><span><span>data</span></span></span><span> </span><span><span><span>Colour</span></span></span></span>
<span id="cb75-2">    <span>=</span> <span><span>Green</span></span></span>
<span id="cb75-3">    <span>|</span> <span><span>Yellow</span></span></span>
<span id="cb75-4">    <span>|</span> <span><span>Blue</span></span></span>
<span id="cb75-5"></span>
<span id="cb75-6"><span><span>showColour</span> ::</span> <span><span>Colour</span></span> <span>-&gt;</span> <span><span>Text</span></span></span>
<span id="cb75-7"><span>showColour</span> <span>=</span> <span><span>case</span></span></span>
<span id="cb75-8">    <span><span>Green</span></span>  <span>-&gt;</span> <span><span>"green"</span></span></span>
<span id="cb75-9">    <span><span>Yellow</span></span> <span>-&gt;</span> <span><span>"yellow"</span></span></span>
<span id="cb75-10">    <span><span>Blue</span></span>   <span>-&gt;</span> <span><span>"blue"</span></span></span>
<span id="cb75-11"></span>
<span id="cb75-12"><span><span>parseColour</span> ::</span> <span><span>Text</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Colour</span></span></span>
<span id="cb75-13"><span>parseColour</span> <span>=</span> <span><span>case</span></span></span>
<span id="cb75-14">    <span><span>"green"</span></span>  <span>-&gt;</span> <span><span>Just</span></span> <span><span>Green</span></span></span>
<span id="cb75-15">    <span><span>"yellow"</span></span> <span>-&gt;</span> <span><span>Just</span></span> <span><span>Yellow</span></span></span>
<span id="cb75-16">    <span><span>"blue"</span></span>   <span>-&gt;</span> <span><span>Just</span></span> <span><span>Blue</span></span></span>
<span id="cb75-17">    _        <span>-&gt;</span> <span><span>Nothing</span></span></span></code></pre></div>
<blockquote>
<p>It‚Äôs important that you pattern match on all cases of enumeration when possible to avoid having partial functions.</p>
</blockquote>
<p>If you add a new colour constructor, for example <code>Orange</code>, the compiler will warn you to update the <code>showColour</code> function. But, unfortunately, it won‚Äôt remind you to update <code>parseColour</code> as the <code>"orange"</code> string is already covered by the wildcard (<code>_</code>) case. Therefore it is all good from the compiler point of view.</p>
<p>If you have only a few data types with a few constructors and you don‚Äôt update them, then you don‚Äôt have such a problem. Otherwise it is not straightforward to maintain such code.</p>
<p>Fortunately, there is a way to avoid this issue. You can implement helper functions that will parse your enumeration types from text back to safe Haskell data types. One of such functions is <code>inverseMap</code> from <a href="https://hackage.haskell.org/package/relude">relude</a>:</p>
<div id="cb76"><pre><code><span id="cb76-1"><span>inverseMap</span></span>
<span id="cb76-2"><span>    ::</span> <span><span>forall</span></span> e s <span>.</span> (<span><span>Bounded</span></span> e, <span><span>Enum</span></span> e, <span><span>Ord</span></span> s)</span>
<span id="cb76-3">    <span>=&gt;</span> (e <span>-&gt;</span> s)</span>
<span id="cb76-4">    <span>-&gt;</span> s</span>
<span id="cb76-5">    <span>-&gt;</span> <span><span>Maybe</span></span> e</span></code></pre></div>
<p>üìö <strong>Exercise:</strong> Implement the <code>inverseMap</code> function.</p>
<p>Using this function, you can rewrite <code>parseColour</code> in a simpler and more safe way:</p>
<div id="cb77"><pre><code><span id="cb77-1"><span><span>parseColour</span> ::</span> <span><span>Text</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Colour</span></span></span>
<span id="cb77-2"><span>parseColour</span> <span>=</span> inverseMap showColour</span></code></pre></div>
<p>Even if you are not using the <code>showColour</code> function, this approach still can be a better solution, since you can handle cases exhaustively and get a parsing function for free.</p>
<p>You can find <a href="http://hackage.haskell.org/package/relude-0.6.0.0/docs/Relude-Extra-Enum.html#v:inverseMap">more details about this approach in the Haddock documentation</a> for the <code>inverseMap</code> function.</p>
<section id="bidirectional-parsing-task">
<h3>Bidirectional parsing: Task<a href="#bidirectional-parsing-task">üîó</a></h3>
<p>Implement a function that will take a string of two space-separate words ‚Äî colour and fruit name ‚Äî and return them as data types.</p>
<p>Possible colours: red, green, yellow, blue. Possible fruits: apple, orange, lemon, blueberry.</p>
<p>Example:</p>
<div id="cb78"><pre><code><span id="cb78-1"><span>ghci</span><span>&gt;</span> parseFruit <span><span>"red apple"</span></span></span>
<span id="cb78-2"><span><span>Just</span></span></span>
<span id="cb78-3">    ( <span><span>Fruit</span></span></span>
<span id="cb78-4">        { fruitColour <span>=</span> <span><span>Red</span></span></span>
<span id="cb78-5">        , fruitName <span>=</span> <span><span>Apple</span></span></span>
<span id="cb78-6">        }</span>
<span id="cb78-7">    )</span></code></pre></div>

<div id="solutionBiParsing">
<h4 id="bidirectional-parsing-solution">Bidirectional parsing: Solution<a href="#bidirectional-parsing-solution">üîó</a></h4>
<div id="cb79"><pre><code><span id="cb79-1"><span><span>{-# LANGUAGE DerivingStrategies #-}</span></span></span>
<span id="cb79-2"><span><span>{-# LANGUAGE LambdaCase         #-}</span></span></span>
<span id="cb79-3"><span><span>{-# LANGUAGE OverloadedStrings  #-}</span></span></span>
<span id="cb79-4"><span><span>{-# LANGUAGE RecordWildCards    #-}</span></span></span>
<span id="cb79-5"></span>
<span id="cb79-6"><span><span>module</span></span> <span>Bi</span> <span><span>where</span></span></span>
<span id="cb79-7"></span>
<span id="cb79-8"><span><span>import</span></span> <span>Data.Text</span> (<span><span>Text</span></span>)</span>
<span id="cb79-9"><span><span>import</span></span> <span>Relude.Extra.Enum</span> (<span>inverseMap</span>)</span>
<span id="cb79-10"></span>
<span id="cb79-11"><span><span>import</span></span> <span><span>qualified</span></span> <span>Data.Text</span> <span><span>as</span></span> <span>Text</span></span>
<span id="cb79-12"></span>
<span id="cb79-13"></span>
<span id="cb79-14"><span><span><span>data</span></span></span><span> </span><span><span><span>Colour</span></span></span></span>
<span id="cb79-15">    <span>=</span> <span><span>Red</span></span></span>
<span id="cb79-16">    <span>|</span> <span><span>Green</span></span></span>
<span id="cb79-17">    <span>|</span> <span><span>Yellow</span></span></span>
<span id="cb79-18">    <span>|</span> <span><span>Blue</span></span></span>
<span id="cb79-19">    <span><span>deriving</span></span> stock (<span><span>Show</span></span>, <span><span>Enum</span></span>, <span><span>Bounded</span></span>)</span>
<span id="cb79-20"></span>
<span id="cb79-21"><span><span>showColour</span> ::</span> <span><span>Colour</span></span> <span>-&gt;</span> <span><span>Text</span></span></span>
<span id="cb79-22"><span>showColour</span> <span>=</span> <span><span>case</span></span></span>
<span id="cb79-23">    <span><span>Red</span></span>    <span>-&gt;</span> <span><span>"red"</span></span></span>
<span id="cb79-24">    <span><span>Green</span></span>  <span>-&gt;</span> <span><span>"green"</span></span></span>
<span id="cb79-25">    <span><span>Yellow</span></span> <span>-&gt;</span> <span><span>"yellow"</span></span></span>
<span id="cb79-26">    <span><span>Blue</span></span>   <span>-&gt;</span> <span><span>"blue"</span></span></span>
<span id="cb79-27"></span>
<span id="cb79-28"><span><span>parseColour</span> ::</span> <span><span>Text</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Colour</span></span></span>
<span id="cb79-29"><span>parseColour</span> <span>=</span> inverseMap showColour</span>
<span id="cb79-30"></span>
<span id="cb79-31"><span><span><span>data</span></span></span><span> </span><span><span><span>FruitName</span></span></span></span>
<span id="cb79-32">    <span>=</span> <span><span>Apple</span></span></span>
<span id="cb79-33">    <span>|</span> <span><span>Orange</span></span></span>
<span id="cb79-34">    <span>|</span> <span><span>Lemon</span></span></span>
<span id="cb79-35">    <span>|</span> <span><span>Blueberry</span></span></span>
<span id="cb79-36">    <span><span>deriving</span></span> stock (<span><span>Show</span></span>, <span><span>Enum</span></span>, <span><span>Bounded</span></span>)</span>
<span id="cb79-37"></span>
<span id="cb79-38"><span><span>showFruitName</span> ::</span> <span><span>FruitName</span></span> <span>-&gt;</span> <span><span>Text</span></span></span>
<span id="cb79-39"><span>showFruitName</span> <span>=</span> <span><span>case</span></span></span>
<span id="cb79-40">    <span><span>Apple</span></span>     <span>-&gt;</span> <span><span>"apple"</span></span></span>
<span id="cb79-41">    <span><span>Orange</span></span>    <span>-&gt;</span> <span><span>"orange"</span></span></span>
<span id="cb79-42">    <span><span>Lemon</span></span>     <span>-&gt;</span> <span><span>"lemon"</span></span></span>
<span id="cb79-43">    <span><span>Blueberry</span></span> <span>-&gt;</span> <span><span>"blueberry"</span></span></span>
<span id="cb79-44"></span>
<span id="cb79-45"><span><span>parseFruitName</span> ::</span> <span><span>Text</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>FruitName</span></span></span>
<span id="cb79-46"><span>parseFruitName</span> <span>=</span> inverseMap showFruitName</span>
<span id="cb79-47"></span>
<span id="cb79-48"><span><span><span>data</span></span></span><span> </span><span><span><span>Fruit</span></span></span><span> </span><span><span>=</span></span><span> </span><span><span><span>Fruit</span></span></span></span>
<span id="cb79-49">    {<span> fruitColour ::</span> <span>!</span><span><span>Colour</span></span></span>
<span id="cb79-50">    ,<span> fruitName   ::</span> <span>!</span><span><span>FruitName</span></span></span>
<span id="cb79-51">    } <span><span>deriving</span></span> stock (<span><span>Show</span></span>)</span>
<span id="cb79-52"></span>
<span id="cb79-53"><span><span>parseFruit</span> ::</span> <span><span>Text</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> <span><span>Fruit</span></span></span>
<span id="cb79-54"><span>parseFruit</span> t <span>=</span> <span><span>do</span></span></span>
<span id="cb79-55">    [colour, name] <span>&lt;-</span> <span><span>Just</span></span> <span>$</span> <span>Text</span>.words t</span>
<span id="cb79-56">    fruitColour    <span>&lt;-</span> parseColour colour</span>
<span id="cb79-57">    fruitName      <span>&lt;-</span> parseFruitName name</span>
<span id="cb79-58">    <span>pure</span> <span><span>Fruit</span></span>{<span>..</span>}</span></code></pre></div>
</div>
</section>
<h2 id="recursive-go">Recursive go<a href="#recursive-go">üîó</a></h2>
<div>

<p>Recursive <code>go</code></p>

<p>Moving recursion over data types into the separate function.</p>

<div>
<ol type="1">
<li>When recursion reuses some arguments and you want to avoid passing them again.</li>
<li>When recursion uses some internal state.</li>
<li>To avoid revalidating the same data.</li>
</ol>
</div>

<div>
<ol type="1">
<li>Cleaner code.</li>
<li>Possible performance improvements.</li>
</ol>
</div>

<div>
<ol type="1">
<li>More code.</li>
<li>Requires to know about and enable the <code>ScopedTypeVariables</code> extension.</li>
</ol>
</div>
</div>
<blockquote>
<p>üôÖ <strong>Disclaimer</strong> This pattern is not about recursive functions in the Go programming language.</p>
</blockquote>
<p>Quite often Haskell developers end-up writing functions that recursively do some actions on different data types: lists, trees, numeric accumulators, etc. A function that returns the element of the list at the given position (if found) can be considered as the example of such function. And it could be written using pattern matching.</p>
<p>It is important that such a function has a stopping condition, and a step to recursively iterate through the list. In our case the stop signals are:</p>
<ul>
<li>Either you found the element on the given position</li>
<li>Or you traversed the whole list but didn‚Äôt find what you need</li>
</ul>
<p>The step for this function is to examine the tail of the list (throwing away the first element) and decreasing the position number by one (for each thrown element).</p>
<p>Haskell implementation may look like this:</p>
<div id="cb80"><pre><code><span id="cb80-1"><span><span>at</span> ::</span> [a] <span>-&gt;</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> a</span>
<span id="cb80-2">[] <span>`at`</span> _ <span>=</span> <span><span>Nothing</span></span></span>
<span id="cb80-3">(x<span>:</span>_) <span>`at`</span> <span><span>0</span></span> <span>=</span> <span><span>Just</span></span> x</span>
<span id="cb80-4">(_<span>:</span>xs) <span>`at`</span> i <span>=</span> xs <span>`at`</span> (i <span>-</span> <span><span>1</span></span>)</span></code></pre></div>
<p>However, there is another way to write the above function. Here we are going to use the recursive <code>go</code> pattern ‚Äì the pattern when instead of using the function itself for the recursion, you create the internal so-called <code>go</code> function that will do that.</p>
<p>The idea here is to run the <code>go</code> function with the empty ‚Äúaccumulator‚Äù and the starting list, and the <code>go</code> function should recursively update the accumulator and walk the whole list. This accumulator would be compared to the input position (in contrast to the comparison to 0 when you decrease the original value in the previous case).</p>
<p>You can code this idea this way:</p>
<div id="cb81"><pre><code><span id="cb81-1"><span><span>atGo</span> ::</span> [a] <span>-&gt;</span> <span><span>Int</span></span> <span>-&gt;</span> <span><span>Maybe</span></span> a</span>
<span id="cb81-2"><span>l</span> <span>`atGo`</span> n <span>=</span> go <span><span>0</span></span> l</span>
<span id="cb81-3">  <span><span>where</span></span></span>
<span id="cb81-4"><span>    go ::</span> <span><span>Int</span></span> <span>-&gt;</span> [a] <span>-&gt;</span> <span><span>Maybe</span></span> a</span>
<span id="cb81-5">    go _ [] <span>=</span> <span><span>Nothing</span></span></span>
<span id="cb81-6">    go i (x<span>:</span>xs) <span>=</span> <span><span>if</span></span> i <span>==</span> n <span><span>then</span></span> <span><span>Just</span></span> x <span><span>else</span></span> go (i <span>+</span> <span><span>1</span></span>) xs</span></code></pre></div>
<p>The way the <code>go</code> pattern is implemented also is more flexible in the refactoring and ‚Äúrequirements‚Äù-change. If you, for example, need to check the <code>at</code> function index input on the negative number, it would be much easier and much more efficient to add this validation before the <code>go</code> function of <code>atGo</code>. You don‚Äôt need to check the number of negativity with each recursive call. You can do this only once, and the recursive <code>go</code> function will work only with valid data.</p>
<p>üìö <strong>Exercise:</strong> Can you make these <code>at</code>/<code>atGo</code> functions more efficient on the corner cases?</p>
<p>This pattern could be especially handy when you need to do additional actions on the input data after you get the result of the recursive calculations. Or if you want to avoid passing arguments that never change during the recursive traverse of your data structure (e.g.&nbsp;<code>map</code>, <code>filter</code>, <code>foldr</code>, etc.).</p>
<section id="recursive-go-task-1">
<h3>Recursive go: Task 1<a href="#recursive-go-task-1">üîó</a></h3>
<p>Improve the following code by applying the <em>Recursive <code>go</code></em> pattern.</p>
<div id="cb82"><pre><code><span id="cb82-1"><span><span>sum</span></span><span> ::</span> <span><span>Num</span></span> a <span>=&gt;</span> [a] <span>-&gt;</span> a</span>
<span id="cb82-2"><span><span>sum</span></span> [] <span>=</span> <span><span>0</span></span></span>
<span id="cb82-3"><span><span>sum</span></span> (x<span>:</span>xs) <span>=</span> x <span>+</span> <span>sum</span> xs</span></code></pre></div>

<div id="solutionRecursiveGo1">
<h4 id="recursive-go-solution-1">Recursive go: Solution 1<a href="#recursive-go-solution-1">üîó</a></h4>
<div id="cb83"><pre><code><span id="cb83-1"><span><span>{-# LANGUAGE BangPatterns        #-}</span></span></span>
<span id="cb83-2"><span><span>{-# LANGUAGE ScopedTypeVariables #-}</span></span></span>
<span id="cb83-3"></span>
<span id="cb83-4"><span><span>sumGo</span> ::</span> <span><span>forall</span></span> a <span>.</span> <span><span>Num</span></span> a <span>=&gt;</span> [a] <span>-&gt;</span> a</span>
<span id="cb83-5"><span>sumGo</span> <span>=</span> go <span><span>0</span></span></span>
<span id="cb83-6">  <span><span>where</span></span></span>
<span id="cb83-7"><span>    go ::</span> a <span>-&gt;</span> [a] <span>-&gt;</span> a</span>
<span id="cb83-8">    go <span>!</span>acc [] <span>=</span> acc</span>
<span id="cb83-9">    go acc (x<span>:</span>xs) <span>=</span> go (acc <span>+</span> x) xs</span></code></pre></div>
</div>
</section>
<section id="recursive-go-task-2">
<h3>Recursive go: Task 2<a href="#recursive-go-task-2">üîó</a></h3>
<p>Write the <code>ordNub</code> function with the <em>Recursive <code>go</code></em> pattern. The function should return all unique elements from a list in the order of their appearance.</p>
<div id="cb84"><pre><code><span id="cb84-1"><span><span>ordNub</span> ::</span> <span><span>Ord</span></span> a <span>=&gt;</span> [a] <span>-&gt;</span> [a]</span></code></pre></div>
<div id="cb85"><pre><code><span id="cb85-1"><span>&gt;&gt;&gt;</span> ordNub [<span><span>3</span></span>, <span><span>3</span></span>, <span><span>3</span></span>, <span><span>2</span></span>, <span><span>2</span></span>, <span><span>-</span></span><span><span>1</span></span>, <span><span>1</span></span>]</span>
<span id="cb85-2">[<span><span>3</span></span>,<span><span>2</span></span>,<span><span>-</span></span><span><span>1</span></span>,<span><span>1</span></span>]</span></code></pre></div>

<div id="solutionRecursiveGo2">
<h4 id="recursive-go-solution-2">Recursive go: Solution 2<a href="#recursive-go-solution-2">üîó</a></h4>
<div id="cb86"><pre><code><span id="cb86-1"><span><span>{-# LANGUAGE ScopedTypeVariables #-}</span></span></span>
<span id="cb86-2"></span>
<span id="cb86-3"><span><span>import</span></span> <span><span>qualified</span></span> <span>Data.Set</span> <span><span>as</span></span> <span>Set</span></span>
<span id="cb86-4"></span>
<span id="cb86-5"></span>
<span id="cb86-6"><span><span>ordNub</span> ::</span> <span><span>forall</span></span> a <span>.</span> (<span><span>Ord</span></span> a) <span>=&gt;</span> [a] <span>-&gt;</span> [a]</span>
<span id="cb86-7"><span>ordNub</span> <span>=</span> go <span>Set</span>.empty</span>
<span id="cb86-8">  <span><span>where</span></span></span>
<span id="cb86-9"><span>    go ::</span> <span><span>Set</span>.<span>Set</span></span> a <span>-&gt;</span> [a] <span>-&gt;</span> [a]</span>
<span id="cb86-10">    go _ []     <span>=</span> []</span>
<span id="cb86-11">    go s (x<span>:</span>xs) <span>=</span></span>
<span id="cb86-12">      <span><span>if</span></span> x <span>`<span>Set</span>.member`</span> s</span>
<span id="cb86-13">      <span><span>then</span></span> go s xs</span>
<span id="cb86-14">      <span><span>else</span></span> x <span>:</span> go (<span>Set</span>.insert x s) xs</span></code></pre></div>
</div>
</section>
<h2 id="conclusion">Conclusion<a href="#conclusion">üîó</a></h2>
<p>In this blog post we covered some small techniques that increase code maintainability, readability and reusability. You can see how different Haskell features come together. Each pattern is a small improvement, but when used properly, they increase code quality significantly. Try to use them in your next Haskell project and let us know if they help! We hope that the described patterns will help you write better code.</p>
              
              </div>
          </div>
          </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>