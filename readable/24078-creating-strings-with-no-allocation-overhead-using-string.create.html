<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating Strings with No Allocation Overhead Using String.Create -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Creating Strings with No Allocation Overhead Using String.Create</h1><div><div id="pryc-wp-acctp-original-content"><p>In this post, I’ll continue my<a href="https://www.stevejgordon.co.uk/writing-high-performance-csharp-and-dotnet-code"> series about writing high-performance C# and .NET code</a>. This time, I will focus on a new(ish) method available on the String type – String.Create. First introduced in .NET Core 2.1, this method is currently planned for inclusion as part of .NET Standard 2.1 once that is released.</p><h2>What Does String.Create Do?</h2><p>The String.Create method supports the efficient creation of strings that need to be built or computed at runtime. Before I expand on this, let’s take a moment to cover some facts about strings.</p><ul><li>In .NET strings are a prevalent type, used to represent text data.</li><li>Strings are reference types and their data is stored on the managed heap.</li><li>By design, strings are immutable, which means that once created, their data cannot be modified.</li></ul><p>The combination of these facts leads to a problem with strings from a high-performance perspective. At a high-level, our goal when writing high-performance code is often to reduce the execution time of running that code and also to remove memory allocations. Operating on strings often results in an excess of allocations due to their immutable nature. If we want to extract part of a string, it results in the creation of a new string and the copy of the string data between the memory occupied by the old and new strings. If we want to convert a string to uppercase, that too results in a new string being allocated on the heap.</p><p>If we want to create a string programmatically, using data available only at runtime, that also presents a problem. Concatenating strings will also cause allocations and copies. For long strings, particularly those composed of many component parts, this cost can add up significantly.</p><p>This doesn’t mean that strings shouldn’t be used when it’s appropriate to do so, but it becomes a concern when writing highly optimised code. A standard solution, used when constructing strings at runtime, is to use a StringBuilder which uses an internal buffer to which characters are appended. When you call the build method on the StringBuilder, this causes the final string allocation. When concatenating more than a few elements, StringBuilder will usually be more efficient than plain concatenation (always benchmark to validate this in your scenarios). StringBuilder still requires an intermediate buffer for the characters so there’s a heap allocation there, plus a copy when building the string from the buffer. StringBuilder itself is a class, so there’s an allocation involved in using one. In ASP.NET Core the team have worked around this allocation cost on hot paths by pooling and sharing instances of StringBuilder where it makes sense to do so, in places such as middleware for example.</p><h2>When Would I Use String.Create?</h2><p>String.Create is not something that you will need during everyday development. It has a specific purpose, which is to create a string pragmatically from some existing data, or potentially just via an algorithm, in a high-optimised way. The primary optimisation, in this case, is that it helps us avoid unnecessary allocations and copying of data. We’ll look at a worked example in a few minutes, but before that, let’s consider some more general use cases. Inside the Kestrel web server for ASP.NET Core, unique IDs are created per request. In that case, the requirement is to build a string of a known length and format, which will uniquely identify the request. Since this may be done many thousands of times per second, making this perform well is crucial. String.Create allows the string to be constructed efficiently in that scenario.</p><h2>How Does String.Create Work?</h2><p>String.Creates provides a very short window where we are allowed to essentially break the immutability rule of strings. That may sound scary to some, but it’s not as bad as I make that sound. The window where data mutation can occur is only before the first reference to the string is returned. There’s no possibility to modify the data of an existing string after this brief window.</p><p>Internally, String.Create allocates a suitable portion of memory on the heap to contain the char array for the string data. For this to work, the method takes as its first parameter, the length required for the string. This is an important limitation, and you must know or be able to calculate up front, the exact character length of the string that you wish to create.</p><p>Here’s the signature for the Create method:</p><pre>public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);</pre><p>The method takes a second parameter, which is the generic state needed to construct the string. We’ll come back to the state in a few moments.</p><p>Finally, the create method accepts a delegate that is expected to operate on the allocated heap memory to set the final string data. In this case, the parameter is a SpanAction, which is defined in System.Buffers. Since a Span&lt;T&gt; type cannot be used as a generic type argument, the standard Action delegate cannot be used. Instead, SpanAction supports taking the type which will be used as the type for the internal Span&lt;T&gt;. In this case, we’re working with chars.</p><p>The SpanAction delegate is where the power lies. After the char[] memory needed for the string is allocated, the delegate we pass can then be used to populate the characters within that array. Once the delegate completes, the string which uses that array internally is then returned, having had its value set appropriately.</p><p>Let’s consider for a moment one of the lowest allocation ways we could build up the string without this method. We could potentially use a temporary char array as a buffer to build up the data for the string, then pass that array to the constructor for the string. That is essentially what StringBuilder does for us. This approach would result in two allocations, one for the buffer and one for the string. There would also be some memory copying occurring between the arrays involved.</p><p>Here’s what that might look like:</p><p>Another option would be to use unsafe code, or in .NET Core 2.1 and later, we can use the Span&lt;T&gt; support to safely use a small stack allocated buffer instead of the heap allocated array. As long as the size of the buffer is not too large, this would be a good option and we’d be down to one heap allocation, just for the final string. There would, however, be a copy needed to get the data from the stack memory and into the string heap memory. That has a small execution time cost.</p><p>The changes to achieve this in our example Main method would look like this:</p><p>Getting back to String.Create, we can now understand how this gives us the best possible performance. By avoiding the need to pre-buffer our characters, even if that is on the stack, it means that our logic, used to construct the string is acting directly on the final region of memory which the string will reference. Done correctly, we can build strings programmatically, with no intermediate allocations and very high-performance.</p><p>Within the SpanAction, we have access to the Span&lt;char&gt; over the memory which the string occupies. We can modify that memory via the Span, slicing into the appropriate positions and writing characters into the underlying array. The state that we have passed in will allow us to use existing data to build up our string. There’s an important point here which you may already be wondering about. Why does the state get passed into the Create method directly? Why can’t we just reference the data we need from the delegate code?</p><p>The reason is that the latter approach would result in a closure if we capture a variable. The compiler will have to generate a class to deal with this which is a heap allocation we want to avoid here. Also, a closure here would prevent caching of the delegate, which itself is a performance hit we cannot afford. Instead, the Create method accepts the state as a parameter to avoid the need for the delegate to form a closure.</p><p>This is a little complex to explain, but the take away here is to make sure any objects that you need to access in order to create your string are included in the state. If you have more than one object to pass, the recommended pattern is to use a <a href="https://blogs.msdn.microsoft.com/mazhou/2017/05/26/c-7-series-part-1-value-tuples/" target="_blank" rel="noopener">ValueTuple</a>. Since this is a struct it does not allocate anything and once inside the delegate you can deconstruct it to get the constituent parts.</p><h2>A Quick Example of Using String.Create</h2><p>Before we dive into a real-world example, let’s quickly look at how to use String.Create.</p><p>The comments in this code explain what is happening, step-by-step. In summary, we have a ContextData object which contains three strings we want to use to build a final string. First, we calculate the length needed for our final string, which includes the component parts and the spaces between them. We pass the length to string.Create as well as passing the context as the state argument. Finally, we define the code for the SpanAction delegate which slices into the underlying Span&lt;char&gt; to copy the component parts into the correct locations within the final string. All of this occurs with the single heap allocation for the memory needed by the string.</p><h2>How To Use String.Create – A Real World Example</h2><p>Let’s now look at a worked example based on a real situation I faced. Note that this is still demo code. It’s based on a production requirement I had but I have simplified it so that we can focus on specific techniques. I’m reasonably sure it can be further optimised!</p><p>In my talk, ‘Turbocharged: Writing High-Performance C# and .NET Code’, I discuss an example of a service where after reading a message from an AWS SQS queue, I need to store the message body into an S3 bucket. When storing a blob into S3 we must provide a unique key for the object. As a result, this service must compute the key to pass into the AWS SDK when uploading the object. In our case, this occurs 18 million times per day so even a small gain in performance can have a significant effect at scale.</p><p>The key is formed of eight elements from the incoming message. Only lowercase letters, numbers and underscores are allowed in the final key and any spaces should be converted to underscores. The first approach to building the string used an array to hold the constituent parts and then joined the pieces together to form the final string. I won’t show all of the code in this post, but you can check out <a href="https://github.com/stevejgordon/TurbochargedDemos/blob/master/src/1%20-%20ObjectKeyBuilderDemo/S3ObjectKeyGenerator.cs" target="_blank" rel="noopener">an example in my GitHub repo</a>.</p><p>The second iteration used a stack allocated array of chars as a buffer to form the final data for the string. Using a Span&lt;char&gt; over that memory, I was then able to copy the various elements into the stack allocated buffer. Calling ToString on the Span&lt;char&gt; resulted in the creation of the final string for the object key. Again, I won’t show that code here since it’s quite lengthy. That is also <a href="https://github.com/stevejgordon/TurbochargedDemos/blob/master/src/1%20-%20ObjectKeyBuilderDemo/S3ObjectKeyGeneratorNew.cs" target="_blank" rel="noopener">available in my repo</a> if you want to check it out.</p><p>In the final iteration, I utilised String.Create which meant I could avoid the memory copy from the stack allocated buffer into the heap memory for the string. If you’d like to explore that code, that too is in my <a href="https://github.com/stevejgordon/TurbochargedDemos/blob/master/src/1%20-%20ObjectKeyBuilderDemo/S3ObjectKeyGeneratorNewV2.cs" target="_blank" rel="noopener">GitHub repo</a>.</p><p>Do bear in mind that these samples are not fully optimised and are designed to demonstrate some specific techniques rather than complete optimisations. The String.Create in my case is only marginally quicker in the benchmarks that I’ve run. I’ll be exploring that more deeply in the future. Here is my benchmark result comparing the two approaches.</p><p>In most cases, the String.Create approach is a few nanoseconds quicker, but in some benchmark test runs, it came up a few nanoseconds slower. Potentially I have some further optimisations I could apply to the transformation logic which may account for this.&nbsp;Logically, the less work needed to copy data from the stack memory into the strings heap memory should be more efficient, but its always worth testing for your actual scenario.</p><p>To investigate this, I did some benchmarking of purely String.Create vs. stackalloc creation. For shorter lengths of strings, stackalloc seemed to only be marginally quicker. Here’s a benchmark where I combined short strings of 10 characters using both approaches. The count in this case in the number of strings combined in each test. At only five items there’s not much in it at all. By the time it gets to combining 100 strings, the performance improvement from using String.Create is more apparent.</p><p>If you are interested in another example use case for String.Create, I’ve identified a place in the ASP.NET Core code-based where String.Create should improve performance. I’ve <a href="https://github.com/aspnet/AspNetCore/issues/10290" target="_blank" rel="noopener">raised a GitHub issue</a> demonstrating this and hope to be involved in creating a PR to proposed the final optimisation.</p><h2>String.Create Best Practices</h2><p>There has been quite a lot of information in this post to explain a single method. Let’s conclude by reviewing the most important points.</p><ul><li>String.Create provides a high-performance, low allocation approach to programmatically creating a string.</li><li>As with all performance optimisations, benchmark your original solution and ensure that the changes have a positive effect.</li><li>Avoid closures and make sure that you don’t capture external variables in your SpanAction delegate.</li><li>Use ValueTuples to pass multiple objects for the state.</li></ul><h2>Limitations of String.Create</h2><p>Using String.Create is more involved that some of the other ways to create a new string that you may be familiar with. I don’t recommend using this everywhere, but in hot paths, in performant applications, it may provide some worthwhile gains. The biggest limitation which you may hit is that you must know in advance (or be able to calculate) the exact length of the string which you require. You may need to access the lengths of all of the constituent state objects in order to compute the length of the final string. In some cases, where you have a lot of conditional logic when building a string, just knowing the lengths of the parts might not be enough.</p><h2>Summary</h2><p>String.Create is useful in high-performance scenarios. It’s relatively straight-forward to use once you understand the rules about how it operates. Therefore, it’s a tool worth remembering if you are optimising hot paths in your applications and may have a significant gain in applications with parse and produce strings often as part of their primary function.</p><p>Thanks for reading! If you’d like to read more about high-performance .NET and C# code, you can see my full blog post series <a href="https://www.stevejgordon.co.uk/writing-high-performance-csharp-and-dotnet-code">here</a>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>