<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How to make your game run at 60fps - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="How to make your game run at 60fps - linksfor.dev(s)"/>
    <meta property="article:author" content="Tyler Glaiel"/>
    <meta property="og:description" content="Here&#x2019;s the deal. You got a game, and you want to run it at 60 fps on a 60hz monitor. Your computer is fast enough that both rendering and&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@tglaiel/how-to-make-your-game-run-at-60fps-24c61210fe75"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - How to make your game run at 60fps</title>
<div class="readable">
        <h1>How to make your game run at 60fps</h1>
            <div>by Tyler Glaiel</div>
            <div>Reading time: 23-29 minutes</div>
        <div>Posted here: 04 Mar 2019</div>
        <p><a href="https://medium.com/@tglaiel/how-to-make-your-game-run-at-60fps-24c61210fe75">https://medium.com/@tglaiel/how-to-make-your-game-run-at-60fps-24c61210fe75</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@tglaiel?source=post_page-----24c61210fe75----------------------"><img alt="Tyler Glaiel" src="https://miro.medium.com/fit/c/96/96/1*arpIb_Y1PiAvuti-Y7MCIA.png" width="48" height="48"></a></p></div></div></div></div><p id="ce0f" data-selectable-paragraph="">Here’s the deal. You got a game, and you want to run it at 60 fps on a 60hz monitor. Your computer is fast enough that both rendering and updating take a negligible amount of time, so you enable vsync and write your game loop like this:</p><pre><span id="86db" data-selectable-paragraph="">while(running) {<br>    update();<br>    render();<br>    display();<br>}</span></pre><p id="0568" data-selectable-paragraph="">Easy! Your game now runs at 60fps and is smooth as butter. Done. Thanks for reading this post, you can <a href="https://twitter.com/TylerGlaiel" target="_blank" rel="noopener nofollow">follow me on twitter</a> for more hot gamedev tips.</p></div></div></section><hr><section><div><div><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*scIoXZjOu2CdSx-sZ4qMRQ.jpeg?q=20" width="368" height="271" role="presentation"></p><p><img width="368" height="271" role="presentation" src="https://miro.medium.com/max/368/1*scIoXZjOu2CdSx-sZ4qMRQ.jpeg"></p></div></div></div></figure></div></div></section><hr><section><div><div><p id="ad27" data-selectable-paragraph="">Ok obviously this isn’t good enough. What if someone is running on a lower spec computer that can’t render the game fast enough to handle 60fps? What if their monitor is one of those fancy new 144hz monitors? What if they forced vsync off in their driver settings?</p><p id="74df" data-selectable-paragraph="">So you think, well I gotta measure time in here somewhere and make sure I’m updating at the right frequency. It’s fairly simple to do, you just accumulate time every loop and do an update every time it goes over the threshold of 1/60 of a second.</p><pre><span id="cf3d" data-selectable-paragraph="">while(running) {<br>    deltaTime = CurrentTime()-OldTime;<br>    oldTime = CurrentTime();<br>    accumulator += deltaTime;</span><span id="e10f" data-selectable-paragraph="">    while(accumulator &gt; 1.0/60.0){<br>        update();<br>        accumulator -= 1.0/60.0;<br>    }</span><span id="b123" data-selectable-paragraph="">    render();<br>    display();<br>}</span></pre><p id="1936" data-selectable-paragraph="">Done. Boom. Easy. In fact there’s a ton of games out there that ship with code that looks basically exactly like this. But it’s wrong. This works fine for regulating timing but introduces stuttering issues and other kinds of inconsistencies. A common one here is just that frames are not exactly 1/60th of a second even if you have vsync on, there’s a bit of noise in how long they take (and how precise the OS timer is). So you’d get situations where you render a frame, and the game doesn’t think it’s time to update again (because the accumulator is behind by a tiny minuscule amount) so you just repeat the same frame again, but now the game is a frame behind so it does a double update. Stutter!</p><p id="67e2" data-selectable-paragraph="">So there’s a few existing solutions to fixing that stutter you can find with some google searching, for instance you could have your game use a variable timestep instead of a fixed timestep and just skip the accumulator junk in your timing code entirely. Or you can do a fixed timestep with an interpolated renderer, as described in the pretty famous “<a href="https://gafferongames.com/post/fix_your_timestep/" target="_blank" rel="noopener nofollow">Fix Your Timestep</a>” blog post from Glenn Fiedler. Or you can fudge your timer code to be a little bit more lenient, as described in the “<a href="https://web.archive.org/web/20171206005813/http://www.slickentertainment.com/2016/06/" target="_blank" rel="noopener nofollow">Frame Timing Issues</a>” blog post from Slick Entertainment (unfortunately the blog no longer exists).</p></div></div></section><hr><section><div><div><p id="8256" data-selectable-paragraph="">Slick Entertainment’s method of “timing fuzziness” was the easiest to implement in my engine, as it didn’t require any changes within game logic or rendering, so I did that for <a href="https://store.steampowered.com/app/583470/The_End_Is_Nigh/" target="_blank" rel="noopener nofollow">The End is Nigh</a>. It was about as plug and play as it gets. In summary, it basically just lets the game update “a little bit early”, so as to avoid timing inconsistency issues. If the game is vsynced this should let it just use the vsync as the main timer for the game, and you’d get a buttery smooth experience.</p><p id="ea8f" data-selectable-paragraph="">Basically, this is what the code for updating looks like now (the game “can run” at 62 fps, but it still treats each timestep as if it was 60fps. I’m not sure why it needs to clamp it to prevent the accumulator from going below 0, but it doesn’t work without that). You can interpret this as “the game updates in lockstep if its rendering between 60fps and 62fps”:</p><pre><span id="e64f" data-selectable-paragraph="">while(accumulator &gt; 1.0/62.0){<br>    update();<br>    accumulator -= 1.0/60.0;<br>    if(accumulator &lt; 0) accumulator = 0;<br>}</span></pre><p id="4171" data-selectable-paragraph="">If you’re vsynced, this basically just lets the game be in lock step with the monitor’s refresh rate, and you get a buttery smooth experience. The main issue here is you would run *slightly* fast if you were not vsynced, but it’s such a minor difference that nobody would notice.</p><p id="9b19" data-selectable-paragraph="">Speedrunners. Speedrunners noticed. Shortly after the game was released they noticed that some people on the speedrun records list had worse in-game-times but slightly better measured times than others. And this was directly caused by the timing fuzziness and something forcing vsync off in the game (or running on a 144hz monitor). So it was clear I needed to disable that fuzziness if vsync was off.</p><p id="07c8" data-selectable-paragraph="">Oh but there’s no way to check if vsync is off. There’s no OS call for it, and while you can request for vsync to be enabled or disabled from your application, it’s completely up to the OS and graphics driver on whether or not to actually enable it. The only thing you can do is render a bunch of frames and try to measure how long they take, and try to see if they all take about the same time. So that’s what I did for <a href="https://store.steampowered.com/app/583470/The_End_Is_Nigh/" target="_blank" rel="noopener nofollow">The End is Nigh</a>. If it wasn’t vsynced at 60hz, it falls back to the original “strict 60 fps” frame timer. Plus I added a config file setting to force it to not use fuzziness (mainly there for speedrunners who want accurate times), and gave them an accurate in-game timer hook they could use for their autosplitter.</p><p id="e092" data-selectable-paragraph="">Some people still complained about occasional single frame stutters, but they seemed rare enough that they were probably just OS events or something. Not a big deal. Right?</p><p id="3583" data-selectable-paragraph="">Recently when reviewing my timer code I noticed something odd. The accumulator was drifting, every frame would take a little bit longer than 1/60th of a second, so periodically the game would think its a frame behind and do a double update. It turns out my current monitor is 59.94hz instead of 60hz. This meant that once every 1000 frames, it would need to do a double update to “catch up”. Simpleish fix though, instead of having the range of acceptable framerates be 60 to 62, you just make it 59 to 61 instead.</p><pre><span id="7253" data-selectable-paragraph="">while(accumulator &gt; 1.0/61.0){<br>    update();<br>    accumulator -= 1.0/59.0;<br>    if(accumulator &lt; 0) accumulator = 0;<br>}</span></pre><p id="4af0" data-selectable-paragraph="">The previously described issue about disabled vsync and high refresh rate monitors is still there, and the same solution still applies (fall back to the strict timer if the monitor is *not* vsynced at 60).</p><p id="a13b" data-selectable-paragraph="">But how do I know this is an appropriate solution? How can I test this to make sure it works properly on all combinations of computers with different kinds of monitors, vsync on and vsync off, etc? It’s really hard to track this timer stuff in your head and figure out what causes desyncs and weird cycles and stuff.</p></div></div></section><hr><section><div><div><p id="4a9a" data-selectable-paragraph="">While trying to figure out a robust solution for the “59.94hz monitor problem” I realized I can’t just trial and error this on my computer and expect it to be a robust solution. I needed a good way to test various attempts at writing a better timer and an easy way to see if they would cause stuttering or time drift on various monitor configurations.</p><p id="b024" data-selectable-paragraph="">Enter the <a href="https://github.com/TylerGlaiel/MonitorSim" target="_blank" rel="noopener nofollow">Monitor Simulator</a>. It’s a quick and dirty piece of code I wrote that simulates “how a monitor works” and basically prints out a bunch of numbers that tell me how stable whatever timer I’m testing is.</p><p id="4930" data-selectable-paragraph="">The original naive stuttery frame timer prints out this, for instance</p><pre><span id="3335" data-selectable-paragraph="">20211012021011202111020211102012012102012[...]</span><span id="26ec" data-selectable-paragraph="">TOTAL UPDATES: 10001<br>TOTAL VSYNCS: 10002<br>TOTAL DOUBLE UPDATES: 2535<br>TOTAL SKIPPED RENDERS: 0<br>GAME TIME: 166.683<br>SYSTEM TIME: 166.7</span></pre><p id="34ff" data-selectable-paragraph="">It first prints a number each simulated vsync of how many times the game loop “updated” since the last vsync. Anything other than a bunch of 1s in a row is a stuttery experience. At the end it prints some collected statistics.</p><p id="43f8" data-selectable-paragraph="">Using the “fuzzy timer” (with a range of 60–62fps) on a 59.94hz monitor, it prints out this</p><pre><span id="c6e2" data-selectable-paragraph="">111111111111111111111111111111111111111111111[...]</span><span id="cdc6" data-selectable-paragraph="">TOTAL UPDATES: 10000<br>TOTAL VSYNCS: 9991<br>TOTAL DOUBLE UPDATES: 10<br>TOTAL SKIPPED RENDERS: 0<br>GAME TIME: 166.667<br>SYSTEM TIME: 166.683</span></pre><p id="6a42" data-selectable-paragraph="">It takes a while to get a frame stutter, so it can be hard to notice where that happens in the mass of 1s. But the stats it prints clearly shows that it had a few double updates in there, and thus would be a stuttery experience. The fixed version (with a range of 59–61 fps) has 0 skipped or doubled updates.</p><p id="c23c" data-selectable-paragraph="">I can also disable vsync. The rest of the output is irrelevant, but it can clearly show me how much “Time Drift” occurred (system time is off from where game time should be).</p><pre><span id="a88c" data-selectable-paragraph="">GAME TIME: 166.667<br>SYSTEM TIME: 169.102</span></pre><p id="6f18" data-selectable-paragraph="">This is why you need to switch back to the stricter timer if vsync is off. That discrepancy adds up over time.</p><p id="964d" data-selectable-paragraph="">If I set render time to .02 (so it takes “more than a frame” to render), I get stuttering again. Ideally this should make the game’s frame pattern be 202020202020, but it’s slightly uneven.</p><p id="dda8" data-selectable-paragraph="">This timer does slightly better in that situation than the previous one, but its getting more and more complicated and harder to see how or why it works. But hey I can just shove tests at this simulator and see how they do, and then try to figure out why they work later. Trial and error baby!</p><pre><span id="986f" data-selectable-paragraph="">while(accumulator &gt;= 1.0/61.0){<br>    simulate_update();<br>    accumulator -= 1.0/60.0;<br>    if(accumulator &lt; 1.0/59.0–1.0/60.0) accumulator = 0;<br>}</span></pre><p id="09fd" data-selectable-paragraph="">Feel free to download the <a href="https://github.com/TylerGlaiel/MonitorSim" target="_blank" rel="noopener nofollow">monitor simulator</a> yourself and try various timing methods. Absolutely <a href="https://twitter.com/TylerGlaiel" target="_blank" rel="noopener nofollow">tweet at me</a> if you find anything better.</p><p id="8eba" data-selectable-paragraph="">I’m not 100% happy with my solution (it still requires that “detect vsync” hack, and it can still do a single stutter if it ever gets out of sync), but I think this is about as good as you’re going to get for trying to do a lockstep game loop. Part of the problem is its just really difficult to determine the parameters of what counts as “acceptable” here. It’s all about the tradeoff between time drift and doubled/skipped frames. If you shove a 60hz game on a 50hz PAL monitor… what even is the correct solution here? Do you stutter like crazy or do you run noticeably slower? Both options just feel bad.</p></div></div></section><hr><section><div><div><p id="6d6c" data-selectable-paragraph="">After posting this article originally I came up with another way to do a fixed timer that avoids the pitfalls of needing to know whether vsync is enabled or not, and is fairly robust and doesn’t care about sync issues like the previous method did.</p><p id="d7ea" data-selectable-paragraph="">Basically instead of having the accumulator try to account for inaccuracies in the timer, you just snap delta time to 1/60 if the previous frame was “about 1/60 of a second” *before* adding it to the accumulator. And likewise for other multiples of that.</p><pre><span id="12fc" data-selectable-paragraph="">if(abs(delta_frame_time - 1.0/120.0) &lt; .0002){<br>     delta_frame_time = 1.0/120.0;<br>}<br>if(abs(delta_frame_time - 1.0/60.0) &lt; .0002){<br>     delta_frame_time = 1.0/60.0;<br>}<br>if(abs(delta_frame_time - 1.0/30.0) &lt; .0002){<br>     delta_frame_time = 1.0/30.0;<br>}</span><span id="2e41" data-selectable-paragraph="">accumulator += delta_frame_time;</span><span id="28bb" data-selectable-paragraph="">while(accumulator &gt;= 1.0 / 60.0){<br>     update();<br>     accumulator -= 1.0 / 60.0;<br>}</span></pre><p id="a2f7" data-selectable-paragraph="">The thresholds for what counts as “close enough to 1/60” are not thoroughly tested and tuned yet, but you can tweak those as you see fit anyway.</p><p id="893f" data-selectable-paragraph="">This is basically a reformulating of the “fuzzy timing” problem, basically backing up and rethinking what “fuzzy timing” is supposed to solve. And really at it’s core, fuzzy timing was meant to solve the issue of “the game is vsynced but frames don’t ever take exactly 1/60th of a second, there’s some error there”. So instead of a weirder timing method meant to account for that in the wrong place, this just solves that problem in the most direct way possible. Did the previous frame take about 1/60th of a second? It did? Ok then lets just pretend it took *exactly* 1/60th of a second. Likewise for 1/30 and 1/20 and 1/15 and 1/120, etc. If vsync is off, then you basically wont ever hit those values exactly so it never ends up rounding.</p><p id="7bc2" data-selectable-paragraph="">There is an issue with floating point accuracy here, I’ve added an addendum at the bottom that covers that.</p></div></div></section><hr><section><div><div><p id="b940" data-selectable-paragraph="">The previous methods I’ve described are what I refer to as “lockstep rendering”. You update, then render, and whenever you render you’re always showing the most recently computed game state. Rendering and updating are coupled together.</p><p id="9a58" data-selectable-paragraph="">But you can decouple them. That’s what the method in the <a href="https://gafferongames.com/post/fix_your_timestep/" target="_blank" rel="noopener nofollow">Fix Your Timestep</a> post described. I am not going to reiterate what’s in that post, so you should definitely give it a read. This is (as far as I can tell) the “industry standard” method used in AAA games and engines like unity or unreal (Tight action-oriented 2D games usually prefer lockstep though, because sometimes you just need the precision you get from that method).</p><p id="c2c4" data-selectable-paragraph="">In summary though, that post just describes the method where you update at a fixed framerate, but when you render you interpolate between the “current” game state and the “previous” game state using the current accumulator value as the measure of how much to interpolate by. This way you can render at whatever framerate you want, and update at whatever update rate you want, and it will always be smooth. No stutters, works universally.</p><pre><span id="3e43" data-selectable-paragraph="">while(running){<br>    computeDeltaTimeSomehow();<br>    accumulator += deltaTime;</span><span id="e9eb" data-selectable-paragraph="">    while(accumulator &gt;= 1.0/60.0){<br>        previous_state = current_state;<br>        current_state = update();<br>        accumulator -= 1.0/60.0;<br>    }<br>    render_interpolated_somehow(previous_state, current_state, accumulator/(1.0/60.0));<br>    display();<br>}</span></pre><p id="2b08" data-selectable-paragraph="">Boom. Easy. Problem solved.</p><p id="2ecd" data-selectable-paragraph="">Now to just get it so my game can render interpolated game states and… wait that’s actually not simple at all. This post just assumes that’s a thing you can do. Its easy enough to cache the previous transform of your game object and interpolate transforms, but games have a lot more state than just that. There’s animation states and object creation and destruction and a lot of other shit to take into consideration.</p><p id="e0c9" data-selectable-paragraph="">Plus in game logic you now have to care whether or not you’re teleporting an object or smoothly moving it to avoid the interpolator making wrong assumptions about the path a game object took to get where it is. Rotations can be a mess especially if you’re changing a rotation by more than 180 degrees in a single frame. How do you correctly handle objects being created or destroyed?</p><p id="f31d" data-selectable-paragraph="">I’m currently working on this in my own engine, and basically just interpolate transforms and let everything else remain as it was before. You don’t really notice stuttering if something isn’t smoothly moving, so animations skipping frames and object creation/destruction being up to a frame off sync isn’t an issue if everything else is smooth.</p><p id="3920" data-selectable-paragraph="">It is weird however that this method basically has the game render up to 1 game state behind where the simulation currently is. It’s not really noticeable but it can compound with other sources of delay like input lag and monitor refresh rate, and anyone who wants the most responsive game experience (hey speedrunners) would probably much rather have the game be lockstep instead.</p><p id="329f" data-selectable-paragraph="">In my engine I’m just making this be an option. If you have a 60hz monitor and a fast computer, use lockstep with vsync on for the best experience. If you have a monitor with a weirder refresh rate, or a weaker computer that cant consistently render at 60, then turn on frame interpolation. I want to call this “unlock framerate” but am worried people think that just means “turn this on if you got a good computer”. That’s a problem to solve later though.</p><p id="4558" data-selectable-paragraph="">Now there *is* a method that sidesteps that problem though.</p></div></div></section><hr><section><div><div><p id="ebb4" data-selectable-paragraph="">I got a bunch of people asking why not just update with a variable timestep, and often see armchair programmers say “well if a game is programmed CORRECTLY they just update at arbitrary timesteps”.</p><pre><span id="3116" data-selectable-paragraph="">while(running) {<br>    deltaTime = CurrentTime()-OldTime;<br>    oldTime = CurrentTime();</span><span id="0c76" data-selectable-paragraph="">    update(deltaTime);<br>    render();<br>    display();<br>}</span></pre><p id="7aa8" data-selectable-paragraph="">No weird timing junk. No weird interpolated rendering. It’s simple and it works.</p><p id="e57b" data-selectable-paragraph="">Boom. Easy. Problem solved. For good this time! Can’t get any better than this!</p><p id="5e58" data-selectable-paragraph="">Now you just need to make your game logic work on arbitrary timesteps. Easy right, you just go through and change code that looks like this:</p><pre><span id="46e6" data-selectable-paragraph="">position += speed;</span></pre><p id="f623" data-selectable-paragraph="">to this:</p><pre><span id="842a" data-selectable-paragraph="">position += speed * deltaTime;</span></pre><p id="28e8" data-selectable-paragraph="">and you change code that looks like this:</p><pre><span id="e890" data-selectable-paragraph="">speed += acceleration;<br>position += speed;</span></pre><p id="7239" data-selectable-paragraph="">to this:</p><pre><span id="dffa" data-selectable-paragraph="">speed += acceleration * deltaTime;<br>position += speed * deltaTime;</span></pre><p id="1c4d" data-selectable-paragraph="">and you change code that looks like this:</p><pre><span id="0d8a" data-selectable-paragraph="">speed += acceleration;<br>speed *= friction;<br>position += speed;</span></pre><p id="5a73" data-selectable-paragraph="">to this:</p><pre><span id="15bd" data-selectable-paragraph="">Vec3D p0 = position;<br>Vec3D v0 = velocity;<br>Vec3D a = acceleration*(1.0/60.0);<br>double f = friction;<br>double n = dt*60;<br>double fN = pow(friction, n);</span><span id="42bd" data-selectable-paragraph="">position = p0 + ((f*(a*(f*fN-f*(n+1)+n)+(f-1)*v0*(fN-1)))/((f-1)*(f-1)))*(1.0/60.0);<br>velocity = v0*fN+a*(f*(fN-1)/(f-1));</span></pre><p id="11d8" data-selectable-paragraph="">….</p><p id="c67e" data-selectable-paragraph="">wait hold up<br>where the fuck did that come from?</p><p id="adea" data-selectable-paragraph="">Ok that last bit is literally cut and pasted from my engine utility code for “actual correct framerate independent move with speed-limiting friction” function and contains a little bit of extra cruft in there (those multiplies and divides by 60). But that is the “correct” variable timestep version of the previous snippit. I calculated it over the course of an hour or so with gratuitous help from <a href="https://www.wolframalpha.com/" target="_blank" rel="noopener nofollow">wolfram alpha</a>.</p><p id="6895" data-selectable-paragraph="">Now there’s going to be people saying why not just do:</p><pre><span id="1871" data-selectable-paragraph="">speed += acceleration * deltaTime;<br>speed *= pow(friction, deltaTime);<br>position += speed * deltaTime;</span></pre><p id="69d0" data-selectable-paragraph="">And while something like that kinda works, it’s not actually correct. You can test it yourself. Do 2 updates of that with deltaTime set to 1, and do it once with deltaTime set to 2, and the results aren’t actually the same. Typically you want your game to run consistently, so having inconsistencies like this aren’t great. Its probably good enough if you know your deltaTimes are all around the same value, so then you need some code to make sure your updates are running at some kind of fixed rate and… oh. Right. We’re trying to do it the “CORRECT” way now.</p><p id="a276" data-selectable-paragraph="">If that tiny bit of code expands to that monstrous pile of math, imagine more complicated movement patterns involving multiple interacting objects and such. You can clearly see how doing it the “correct” way is infeasible. So the “rough approximation” is basically all you got. Lets ignore that for now and assume you actually do have the “actual correct” version of your movement functions. Good, right?</p><p id="9318" data-selectable-paragraph="">Well, no. Here’s an actual real life example of an issue I had with this in <a href="https://store.steampowered.com/app/246920/Bombernauts/" target="_blank" rel="noopener nofollow">Bombernauts</a>. You can jump about 1 tile high, and the game takes place on a grid of 1 tile blocks. Your feet need to clear the top of the block in order to land on it.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*wMqcS-PG2J0MXOyG46t1iA.png?q=20" width="1034" height="750" role="presentation"></p><p><img width="1034" height="750" role="presentation"></p></div></div></div></div></figure><p id="20fa" data-selectable-paragraph="">But since collision detection here is in discreet steps, if the game was running at a slower framerate your feet would sometimes not actually clear the top of the tile, even though the movement curve they followed was the same, and you would just slide down the wall instead.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*cvOpP6lBAOg4_bhiCoy92Q.png?q=20" width="1071" height="742" role="presentation"></p><p><img width="1071" height="742" role="presentation"></p></div></div></div></div></figure><p id="ce4f" data-selectable-paragraph="">This is obviously a solvable problem. But it illustrates the types of problems you encounter when trying to make your variable timestep game loop work correctly. You lose consistency and determinism, so you can just throw away the ability to do input replays or deterministic multiplayer and such. For a 2D action reflexy game, consistency matters a ton (hey speedrunners).</p><p id="f924" data-selectable-paragraph="">If you’re trying to regulate your timesteps so they aren’t too large or too small then you kinda lose the main benefit you get from doing variable timestep in the first place, and you may as well just use one of the other 2 methods I described here instead. It’s not worth it. There’s too much extra effort involved on the game logic side of things (making sure your movement math is correct) and it requires too many sacrifices in the determinism and consistency department. I would only use this method for something like a rhythm game (where movement equations are simple and you want the maximum responsiveness and smoothness possible). Otherwise gimme that fixed update.</p></div></div></section><hr><section><div><div><p id="f787" data-selectable-paragraph="">You now know how to make your game run at a consistent 60fps. It’s trivially easy and there’s no reason anyone should have ever had any trouble with it before. There’s <a target="_blank" rel="noopener" href="https://medium.com/@alen.ladavac/the-elusive-frame-timing-168f899aec92">no other issues</a> that could complicate this further. Thanks for reading you can <a href="https://twitter.com/TylerGlaiel" target="_blank" rel="noopener nofollow">follow me on twitter</a> for more hot gamedev tips.</p></div></div></section><hr><section><div><div><p id="9b2e" data-selectable-paragraph="">I’m thrilled at the reception this blog post originally received, and I want to make sure this is the most up to date and thorough resource for this common gamedev problem out there. So I will update this article as new information is brought to my attention, and I’m also adding a few more pieces of information here that I couldn’t find the place for in the original article.</p><h2 id="c28c" data-selectable-paragraph="">Hybrid Approaches</h2><p id="dbe4" data-selectable-paragraph="">Unity (and other big engines) use a hybrid approach. Unity provides Update() and FixedUpdate() callbacks separately. Update uses variable time steps and FixedUpdate uses fixed time steps, plus it automatically interpolates stuff like physics states and animation states. If you mix and match both of those update callbacks without knowing how they work under the hood, you end up getting weird stuttering inconsistencies in your unity project. It’s a common problem I’ve seen in unity games, so even if you are using an engine, you still should understand how this all works.</p><h2 id="3d98" data-selectable-paragraph="">1000hz Fixed Update</h2><p id="f056" data-selectable-paragraph="">I’ve seen a few people mention to me their solution to this is to just update at a fixed rate of 1000 times per second. Because the difference between doing 1 and 2 updates per frame is a lot more noticeable than the difference between 16 and 17 updates a frame. You can do this if your game is pretty simple, but it does not scale well to more complicated projects.</p><h2 id="bb24" data-selectable-paragraph="">Timing Anomalies</h2><p id="f10d" data-selectable-paragraph="">You do need to account for various timing anomalies when measuring frame code. If delta time is less than 0, that means that the system timer wrapped around. If it’s really high, you probably don’t want to fast forward your game a ton in one step, so you probably should cap it. If you just clamp deltaTime to between 0 and &lt;maximum delta time&gt; (this is 8/60 (7.5fps) for me), that should account for most anomalies.</p><h2 id="d23a" data-selectable-paragraph="">Resyncing</h2><p id="1fad" data-selectable-paragraph="">In my engine I have a manual callback I can use to “resync” my timer code (set the accumulator to 0 and delta time to 1/60 the next time through the loop), which I do after loading a level or swapping scenes. You need this because you typically don’t want the game to start each level by immediately trying to make up the time it spent loading.</p><h2 id="c72f" data-selectable-paragraph="">Spiral of Doom</h2><p id="cb5c" data-selectable-paragraph="">If your game cannot *update* at 60hz, you end up in a spiral of doom where your game can never catch up to where it should be, and so it will do more and more updates every time until it eventually just freezes. Cap your accumulator to a maximum (I use 8/60 (7.5fps) as the max) and it should prevent that issue. This will not be a fun experience for whoever is trying to play the game, but at least it won’t freeze.</p><h2 id="70fa" data-selectable-paragraph="">Floating Point Inaccuracies</h2><p id="2f76" data-selectable-paragraph="">In this article and my monitor simulator code, I was using doubles for clarity. Using doubles or floats introduces floating point error, like adding 1.0/60.0 60 times in a row will not actually end up being exactly 1. In my engine I actually use 64 bit integers for my timer code instead to sidestep this. <a href="https://wiki.libsdl.org/SDL_GetPerformanceCounter" target="_blank" rel="noopener nofollow">SDL reports the system timer as a 64 bit int</a>, so I just keep it in this format to avoid the loss you get from converting it to a double. In the game itself, this gets converted to double, but the timer code keeps it as an int.</p><h2 id="7ae1" data-selectable-paragraph="">Situations where interpolation is not an option</h2><p id="47d9" data-selectable-paragraph="">Interpolation is the industry standard method of doing this, because it’s a good robust solution that works great in the majority of use cases. But this has resulted in a few people acting as if there is no reason to even consider lockstep, and existing resources about this basically never even discuss it. Ignoring the extra difficulty involved in getting interpolation working, there are a few situations where interpolation just inherently isn’t an option, like emulators. It’s up to you to determine what your needs and options are here for your specific use case.</p><h2 id="bacc" data-selectable-paragraph="">Averaging Delta Time</h2><p id="9e5c" data-selectable-paragraph="">Some games and engines average together the previous few time deltas to smooth out any single frame spikes. For example, instead of a single slow frame resulting in 4 updates on the next frame, it would do 2 updates for the next 3 frames instead. You do this averaging when you compute delta time, before adding to the accumulator.</p><h2 id="5e41" data-selectable-paragraph="">Update Multiplicity</h2><p id="7cca" data-selectable-paragraph="">An uneven framerate is worse than a slow framerate. For this reason I have a setting in my engine called “update multiplicity” that basically just makes the game always do a multiple of N updates at a time.</p><pre><span id="bc91" data-selectable-paragraph="">while(accumulator &gt;= (1.0 / 60.0) * update_multiplicity){<br>    for(int i = 0; i&lt;update_multiplicity; i++){<br>        simulate_update();<br>        accumulator -= 1.0 / 60.0;<br>    }<br>}</span></pre><p id="11f7" data-selectable-paragraph="">Setting update multiplicity to 2 basically says “Act as if this game is running at 30fps even if it isn’t”. For people with low powered machines this is preferable to alternating between 30 and 60 rapidly. There’s probably some way to detect uneven framerates and just fall back to this, but I just have it as a manual setting for now.</p><h2 id="524a" data-selectable-paragraph="">Sample Code</h2><p id="e212" data-selectable-paragraph=""><a href="https://github.com/TylerGlaiel/FrameTimingControl" target="_blank" rel="noopener nofollow">This is production code from my engine that I have commented</a>. It uses many of the techniques and tricks I’ve illustrated in this post. You probably can’t just plug and play this into your engine, but I’ve decided to put this up for reference because sometimes you just wanna see what everything looks like together.</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>