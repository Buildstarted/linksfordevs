<!DOCTYPE html>
<html lang="en">
<head>
    <title>
0xd4d/dnlib: Reads and writes .NET assemblies and modules -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>0xd4d/dnlib: Reads and writes .NET assemblies and modules</h1>
        <div id="readOverlay" class="style-ebook">
        <div id="readInner" class="margin-medium size-medium">
            <h1>0xd4d/dnlib: Reads and writes .NET assemblies and modules</h1><div>
                <div id="" class="markdown-body entry-content p-5">
                    <p>.NET module/assembly reader/writer library</p><h2><a id="user-content-compiling" class="anchor" aria-hidden="true" href="#compiling"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compiling</h2><p>v3.0 requires VS2019 or later to build it. .NET Core SDK 2.1 or later is also required. See below for breaking changes going from 2.1 to 3.0</p><p>An <a href="https://github.com/0xd4d/dnlib/tree/v2.1_VS2010">older v2.1 branch</a> can be used to build with older VS versions. This branch won't get any new updates.</p><h2><a id="user-content-opening-a-net-assemblymodule" class="anchor" aria-hidden="true" href="#opening-a-net-assemblymodule"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Opening a .NET assembly/module</h2><p>First of all, the important namespaces are <code>dnlib.DotNet</code> and <code>dnlib.DotNet.Emit</code>. <code>dnlib.DotNet.Emit</code> is only needed if you intend to read/write method bodies. All the examples below assume you have the appropriate using statements at the top of each source file:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-k">using</span><span class="pl-en">dnlib</span>.<span class="pl-en">DotNet</span>;
                        <span class="pl-k">using</span><span class="pl-en">dnlib</span>.<span class="pl-en">DotNet</span>.<span class="pl-en">Emit</span>;</pre>
                    </div><p>ModuleDefMD is the class that is created when you open a .NET module. It has several <code>Load()</code> methods that will create a ModuleDefMD instance. If it's not a .NET module/assembly, a <code>BadImageFormatException</code> will be thrown.</p><p>Read a .NET module from a file:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-c"><span class="pl-c">//</span> Create a default assembly resolver and type resolver and pass it to Load().</span><span class="pl-c"><span class="pl-c">//</span> If it's a .NET Core assembly, you'll need to disable GAC loading and add</span><span class="pl-c"><span class="pl-c">//</span> .NET Core reference assembly search paths.</span><span class="pl-en">ModuleContext</span><span class="pl-smi">modCtx</span><span class="pl-k">=</span><span class="pl-smi">ModuleDef</span>.<span class="pl-en">CreateModuleContext</span>();
                        <span class="pl-en">ModuleDefMD</span><span class="pl-smi">module</span><span class="pl-k">=</span><span class="pl-smi">ModuleDefMD</span>.<span class="pl-en">Load</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\path\to\file.exe<span class="pl-pds">"</span></span>, <span class="pl-smi">modCtx</span>);</pre>
                    </div><p>Read a .NET module from a byte array:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-k">byte</span>[] <span class="pl-smi">data</span><span class="pl-k">=</span><span class="pl-smi">System</span>.<span class="pl-smi">IO</span>.<span class="pl-smi">File</span>.<span class="pl-en">ReadAllBytes</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\path\of\file.dll<span class="pl-pds">"</span></span>);
                        <span class="pl-c"><span class="pl-c">//</span> See comment above about the assembly resolver</span><span class="pl-en">ModuleContext</span><span class="pl-smi">modCtx</span><span class="pl-k">=</span><span class="pl-smi">ModuleDef</span>.<span class="pl-en">CreateModuleContext</span>();
                        <span class="pl-en">ModuleDefMD</span><span class="pl-smi">module</span><span class="pl-k">=</span><span class="pl-smi">ModuleDefMD</span>.<span class="pl-en">Load</span>(<span class="pl-smi">data</span>, <span class="pl-smi">modCtx</span>);</pre>
                    </div><p>You can also pass in a Stream instance, an address in memory (HINSTANCE) or even a System.Reflection.Module instance:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-smi">System</span>.<span class="pl-smi">Reflection</span>.<span class="pl-smi">Module</span><span class="pl-smi">reflectionModule</span><span class="pl-k">=</span><span class="pl-k">typeof</span>(<span class="pl-k">void</span>).<span class="pl-smi">Module</span>;	<span class="pl-c"><span class="pl-c">//</span> Get mscorlib.dll's module</span><span class="pl-c"><span class="pl-c">//</span> See comment above about the assembly resolver</span><span class="pl-en">ModuleContext</span><span class="pl-smi">modCtx</span><span class="pl-k">=</span><span class="pl-smi">ModuleDef</span>.<span class="pl-en">CreateModuleContext</span>();
                        <span class="pl-en">ModuleDefMD</span><span class="pl-smi">module</span><span class="pl-k">=</span><span class="pl-smi">ModuleDefMD</span>.<span class="pl-en">Load</span>(<span class="pl-smi">reflectionModule</span>, <span class="pl-smi">modCtx</span>);</pre>
                    </div><p>To get the assembly, use its Assembly property:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-en">AssemblyDef</span><span class="pl-smi">asm</span><span class="pl-k">=</span><span class="pl-smi">module</span>.<span class="pl-smi">Assembly</span>;
                        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>Assembly: {0}<span class="pl-pds">"</span></span>, <span class="pl-smi">asm</span>);</pre>
                    </div><p>If it's an obfuscated Unity/Mono assembly, you need to create a <code>ModuleCreationOptions</code> instance and write <code>CLRRuntimeReaderKind.Mono</code> to <code>ModuleCreationOptions.Runtime</code> and pass in this <code>ModuleCreationOptions</code> instance to one of the <code>ModuleDefMD.Load(...)</code> methods.</p><h2><a id="user-content-saving-a-net-assemblymodule" class="anchor" aria-hidden="true" href="#saving-a-net-assemblymodule"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Saving a .NET assembly/module</h2><p>Use <code>module.Write()</code>. It can save the assembly to a file or a Stream.</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">module</span>.<span class="pl-en">Write</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\saved-assembly.dll<span class="pl-pds">"</span></span>);</pre></div><p>If it's a C++/CLI assembly, you should use <code>NativeWrite()</code></p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">module</span>.<span class="pl-en">NativeWrite</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\saved-assembly.dll<span class="pl-pds">"</span></span>);</pre></div><p>To detect it at runtime, use this code:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-k">if</span> (<span class="pl-smi">module</span>.<span class="pl-smi">IsILOnly</span>) {
                        <span class="pl-c"><span class="pl-c">//</span> This assembly has only IL code, and no native code (eg. it's a C# or VB assembly)</span><span class="pl-smi">module</span>.<span class="pl-en">Write</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\saved-assembly.dll<span class="pl-pds">"</span></span>);
    }
                        <span class="pl-k">else</span> {
                        <span class="pl-c"><span class="pl-c">//</span> This assembly has native code (eg. C++/CLI)</span><span class="pl-smi">module</span>.<span class="pl-en">NativeWrite</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\saved-assembly.dll<span class="pl-pds">"</span></span>);
    }</pre>
                    </div><h2><a id="user-content-pdb-files" class="anchor" aria-hidden="true" href="#pdb-files"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PDB files</h2><p>PDB files are read from disk by default. You can change this behaviour by creating a <code>ModuleCreationOptions</code> and passing it in to the code that creates a module.</p><p>To save a PDB file, create a <code>ModuleWriterOptions</code> / <code>NativeModuleWriterOptions</code> and set its <code>WritePdb</code> property to <code>true</code>. By default, it will create a PDB file with the same name as the output assembly but with a <code>.pdb</code> extension. You can override this by writing the PDB file name to <code>PdbFileName</code> or writing your own stream to <code>PdbStream</code>. If <code>PdbStream</code> is initialized, <code>PdbFileName</code> should also be initialized because the name of the PDB file will be written to the PE file.</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-c"><span class="pl-c">//</span> Create a default assembly resolver and type resolver</span><span class="pl-en">ModuleContext</span><span class="pl-smi">modCtx</span><span class="pl-k">=</span><span class="pl-smi">ModuleDef</span>.<span class="pl-en">CreateModuleContext</span>();
                        <span class="pl-k">var</span><span class="pl-smi">mod</span><span class="pl-k">=</span><span class="pl-smi">ModuleDefMD</span>.<span class="pl-en">Load</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\myfile.dll<span class="pl-pds">"</span></span>, <span class="pl-smi">modCtx</span>);
                        <span class="pl-c"><span class="pl-c">//</span> ...</span><span class="pl-k">var</span><span class="pl-smi">wopts</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">dnlib</span>.<span class="pl-k">DotNet</span>.<span class="pl-k">Writer</span>.<span class="pl-en">ModuleWriterOptions</span>(<span class="pl-smi">mod</span>);
                        <span class="pl-smi">wopts</span>.<span class="pl-smi">WritePdb</span><span class="pl-k">=</span><span class="pl-c1">true</span>;
                        <span class="pl-c"><span class="pl-c">//</span> wopts.PdbFileName = @"C:\out2.pdb";	// Set other file name</span><span class="pl-smi">mod</span>.<span class="pl-en">Write</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\out.dll<span class="pl-pds">"</span></span>, <span class="pl-smi">wopts</span>);</pre>
                    </div><p>dnlib supports Windows PDBs, portable PDBs and embedded portable PDBs.</p><h2><a id="user-content-windows-pdbs" class="anchor" aria-hidden="true" href="#windows-pdbs"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Windows PDBs</h2><p>It's only possible to write Windows PDBs on Windows (portable PDBs can be written on any OS). dnlib has a managed Windows PDB reader that supports all OSes.</p><p>There are two <em>native</em> Windows PDB reader and writer implementations, the old <code>diasymreader.dll</code> that ships with .NET Framework and <code>Microsoft.DiaSymReader.Native</code> which has been updated with more features and bug fixes.</p><p>dnlib will use <code>Microsoft.DiaSymReader.Native</code> if it exists and fall back to <code>diasymreader.dll</code> if needed. <code>PdbReaderOptions</code> and <code>PdbWriterOptions</code> can be used to disable one of them.</p><p><code>Microsoft.DiaSymReader.Native</code> is a NuGet package with 32-bit and 64-bit native DLLs. You have to add a reference to this NuGet package if you want dnlib to use it. dnlib doesn't add a reference to it.</p><h2><a id="user-content-strong-name-signing-an-assembly" class="anchor" aria-hidden="true" href="#strong-name-signing-an-assembly"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strong name signing an assembly</h2><p>Use the following code to strong name sign the assembly when saving it:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-k">using</span><span class="pl-en">dnlib</span>.<span class="pl-en">DotNet</span>.<span class="pl-en">Writer</span>;
    ...
                        <span class="pl-c"><span class="pl-c">//</span> Open or create an assembly</span><span class="pl-en">ModuleDef</span><span class="pl-smi">mod</span><span class="pl-k">=</span><span class="pl-smi">ModuleDefMD</span>.<span class="pl-en">Load</span>(.....);
    
                        <span class="pl-c"><span class="pl-c">//</span> Create writer options</span><span class="pl-k">var</span><span class="pl-smi">opts</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ModuleWriterOptions</span>(<span class="pl-smi">mod</span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> Open or create the strong name key</span><span class="pl-k">var</span><span class="pl-smi">signatureKey</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StrongNameKey</span>(<span class="pl-s"><span class="pl-pds">@"</span>c:\my\file.snk<span class="pl-pds">"</span></span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> This method will initialize the required properties</span><span class="pl-smi">opts</span>.<span class="pl-en">InitializeStrongNameSigning</span>(<span class="pl-smi">mod</span>, <span class="pl-smi">signatureKey</span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> Write and strong name sign the assembly</span><span class="pl-smi">mod</span>.<span class="pl-en">Write</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\out\file.dll<span class="pl-pds">"</span></span>, <span class="pl-smi">opts</span>);</pre>
                    </div><h2><a id="user-content-enhanced-strong-name-signing-an-assembly" class="anchor" aria-hidden="true" href="#enhanced-strong-name-signing-an-assembly"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Enhanced strong name signing an assembly</h2><p>See this <a href="http://msdn.microsoft.com/en-us/library/hh415055.aspx" rel="nofollow">MSDN article</a> for info on enhanced strong naming.</p><p>Enhanced strong name signing without key migration:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-k">using</span><span class="pl-en">dnlib</span>.<span class="pl-en">DotNet</span>.<span class="pl-en">Writer</span>;
    ...
                        <span class="pl-c"><span class="pl-c">//</span> Open or create an assembly</span><span class="pl-en">ModuleDef</span><span class="pl-smi">mod</span><span class="pl-k">=</span><span class="pl-smi">ModuleDefMD</span>.<span class="pl-en">Load</span>(....);
    
                        <span class="pl-c"><span class="pl-c">//</span> Open or create the signature keys</span><span class="pl-k">var</span><span class="pl-smi">signatureKey</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StrongNameKey</span>(....);
                        <span class="pl-k">var</span><span class="pl-smi">signaturePubKey</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StrongNamePublicKey</span>(....);
    
                        <span class="pl-c"><span class="pl-c">//</span> Create module writer options</span><span class="pl-k">var</span><span class="pl-smi">opts</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ModuleWriterOptions</span>(<span class="pl-smi">mod</span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> This method will initialize the required properties</span><span class="pl-smi">opts</span>.<span class="pl-en">InitializeEnhancedStrongNameSigning</span>(<span class="pl-smi">mod</span>, <span class="pl-smi">signatureKey</span>, <span class="pl-smi">signaturePubKey</span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> Write and strong name sign the assembly</span><span class="pl-smi">mod</span>.<span class="pl-en">Write</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\out\file.dll<span class="pl-pds">"</span></span>, <span class="pl-smi">opts</span>);</pre>
                    </div><p>Enhanced strong name signing with key migration:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-k">using</span><span class="pl-en">dnlib</span>.<span class="pl-en">DotNet</span>.<span class="pl-en">Writer</span>;
    ...
                        <span class="pl-c"><span class="pl-c">//</span> Open or create an assembly</span><span class="pl-en">ModuleDef</span><span class="pl-smi">mod</span><span class="pl-k">=</span><span class="pl-smi">ModuleDefMD</span>.<span class="pl-en">Load</span>(....);
    
                        <span class="pl-c"><span class="pl-c">//</span> Open or create the identity and signature keys</span><span class="pl-k">var</span><span class="pl-smi">signatureKey</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StrongNameKey</span>(....);
                        <span class="pl-k">var</span><span class="pl-smi">signaturePubKey</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StrongNamePublicKey</span>(....);
                        <span class="pl-k">var</span><span class="pl-smi">identityKey</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StrongNameKey</span>(....);
                        <span class="pl-k">var</span><span class="pl-smi">identityPubKey</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">StrongNamePublicKey</span>(....);
    
                        <span class="pl-c"><span class="pl-c">//</span> Create module writer options</span><span class="pl-k">var</span><span class="pl-smi">opts</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ModuleWriterOptions</span>(<span class="pl-smi">mod</span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> This method will initialize the required properties and add</span><span class="pl-c"><span class="pl-c">//</span> the required attribute to the assembly.</span><span class="pl-smi">opts</span>.<span class="pl-en">InitializeEnhancedStrongNameSigning</span>(<span class="pl-smi">mod</span>, <span class="pl-smi">signatureKey</span>, <span class="pl-smi">signaturePubKey</span>, <span class="pl-smi">identityKey</span>, <span class="pl-smi">identityPubKey</span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> Write and strong name sign the assembly</span><span class="pl-smi">mod</span>.<span class="pl-en">Write</span>(<span class="pl-s"><span class="pl-pds">@"</span>C:\out\file.dll<span class="pl-pds">"</span></span>, <span class="pl-smi">opts</span>);</pre>
                    </div><h2><a id="user-content-exporting-managed-methods-dllexport" class="anchor" aria-hidden="true" href="#exporting-managed-methods-dllexport"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exporting managed methods (DllExport)</h2><p>
                        dnlib supports exporting managed methods so the managed DLL file can be loaded by native code and then executed. .NET Framework supports this feature, but there's no guarantee that other CLRs (eg. .NET Core or Mono/Unity) support this feature.
                        In case of .NET Core please be aware that <code>ijwhost.dll</code> has to be loaded prior to calling your exported method and that ijwhost currently (as of .NET Core 3.0) does not work if the calling app is self-contained.
                    </p><p>The <code>MethodDef</code> class has an <code>ExportInfo</code> property. If it gets initialized, the method gets exported when saving the module. At most 65536 (2^16) methods can be exported. This is a PE file limitation, not a dnlib limitation.</p><p>Exported methods should not be generic.</p><p>The method's calling convention should be changed to eg. stdcall, or cdecl, by adding an optional modifier to <code>MethodDef.MethodSig.RetType</code>. It must be a <code>System.Runtime.CompilerServices.CallConvCdecl</code>, <code>System.Runtime.CompilerServices.CallConvStdcall</code>, <code>System.Runtime.CompilerServices.CallConvThiscall</code>, or a <code>System.Runtime.CompilerServices.CallConvFastcall</code>, eg.:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-k">var</span><span class="pl-smi">type</span><span class="pl-k">=</span><span class="pl-smi">method</span>.<span class="pl-smi">MethodSig</span>.<span class="pl-smi">RetType</span>;
<span class="pl-smi">type</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">CModOptSig</span>(<span class="pl-smi">module</span>.<span class="pl-smi">CorLibTypes</span>.<span class="pl-en">GetTypeRef</span>(<span class="pl-s"><span class="pl-pds">"</span>System.Runtime.CompilerServices<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>CallConvCdecl<span class="pl-pds">"</span></span>), <span class="pl-smi">type</span>);
<span class="pl-smi">method</span>.<span class="pl-smi">MethodSig</span>.<span class="pl-smi">RetType</span><span class="pl-k">=</span><span class="pl-smi">type</span>;</pre>
                    </div><p>Requirements:</p><ul><li>The assembly platform must be x86, x64, IA-64 or ARM (ARM64 isn't supported at the moment). AnyCPU assemblies are not supported. This is as simple as changing (if needed) <code>ModuleWriterOptions.PEHeadersOptions.Machine</code> when saving the file. x86 files should set <code>32-bit required</code> flag and clear <code>32-bit preferred</code> flag in the COR20 header.</li><li><code>ModuleWriterOptions.Cor20HeaderOptions.Flags</code>: The <code>IL Only</code> bit must be cleared.</li><li>It must be a DLL file (see <code>ModuleWriterOptions.PEHeadersOptions.Characteristics</code>). The file will fail to load at runtime if it's an EXE file.</li></ul><p>NOTE: VS' debugger crashes if there's a <code>DebuggableAttribute</code> attribute and if the first ctor arg is 0x107. The workaround is to clear the <code>EnableEditAndContinue</code> bit:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-k">var</span><span class="pl-smi">ca</span><span class="pl-k">=</span><span class="pl-smi">module</span>.<span class="pl-smi">Assembly</span>.<span class="pl-smi">CustomAttributes</span>.<span class="pl-en">Find</span>(<span class="pl-s"><span class="pl-pds">"</span>System.Diagnostics.DebuggableAttribute<span class="pl-pds">"</span></span>);
<span class="pl-k">if</span> (<span class="pl-k">!</span>(<span class="pl-smi">ca</span><span class="pl-k">is</span><span class="pl-en">null</span>) <span class="pl-k">&amp;&amp;</span><span class="pl-smi">ca</span>.<span class="pl-smi">ConstructorArguments</span>.<span class="pl-smi">Count</span><span class="pl-k">==</span><span class="pl-c1">1</span>) {
                        <span class="pl-k">var</span><span class="pl-smi">arg</span><span class="pl-k">=</span><span class="pl-smi">ca</span>.<span class="pl-smi">ConstructorArguments</span>[<span class="pl-c1">0</span>];
                        <span class="pl-c"><span class="pl-c">//</span> VS' debugger crashes if value == 0x107, so clear EnC bit</span><span class="pl-k">if</span> (<span class="pl-smi">arg</span>.<span class="pl-smi">Type</span>.<span class="pl-smi">FullName</span><span class="pl-k">==</span><span class="pl-s"><span class="pl-pds">"</span>System.Diagnostics.DebuggableAttribute/DebuggingModes<span class="pl-pds">"</span></span><span class="pl-k">&amp;&amp;</span><span class="pl-smi">arg</span>.<span class="pl-smi">Value</span><span class="pl-k">is</span><span class="pl-k">int</span><span class="pl-smi">value</span><span class="pl-k">&amp;&amp;</span><span class="pl-smi">value</span><span class="pl-k">==</span><span class="pl-c1">0x107</span>) {
                        <span class="pl-smi">arg</span>.<span class="pl-smi">Value</span><span class="pl-k">=</span><span class="pl-smi">value</span><span class="pl-k">&amp;</span><span class="pl-k">~</span>(<span class="pl-k">int</span>)<span class="pl-smi">DebuggableAttribute</span>.<span class="pl-smi">DebuggingModes</span>.<span class="pl-smi">EnableEditAndContinue</span>;
                        <span class="pl-smi">ca</span>.<span class="pl-smi">ConstructorArguments</span>[<span class="pl-c1">0</span>] <span class="pl-k">=</span><span class="pl-smi">arg</span>;
    }
}</pre>
                    </div><p>See the following issues: <a href="https://github.com/0xd4d/dnlib/issues/271">#271</a>, <a href="https://github.com/0xd4d/dnlib/issues/172">#172</a></p><h2><a id="user-content-type-classes" class="anchor" aria-hidden="true" href="#type-classes"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type classes</h2><p>The metadata has three type tables: <code>TypeRef</code>, <code>TypeDef</code>, and <code>TypeSpec</code>. The classes dnlib use are called the same. These three classes all implement <code>ITypeDefOrRef</code>.</p><p>There's also type signature classes. The base class is <code>TypeSig</code>. You'll find <code>TypeSig</code>s in method signatures (return type and parameter types) and locals. The <code>TypeSpec</code> class also has a <code>TypeSig</code> property.</p><p>All of these types implement <code>IType</code>.</p><p><code>TypeRef</code> is a reference to a type in (usually) another assembly.</p><p><code>TypeDef</code> is a type definition and it's a type defined in some module. This class does <em>not</em> derive from <code>TypeRef</code>. :)</p><p><code>TypeSpec</code> can be a generic type, an array type, etc.</p><p><code>TypeSig</code> is the base class of all type signatures (found in method sigs and locals). It has a <code>Next</code> property that points to the next <code>TypeSig</code>. Eg. a Byte[] would first contain a <code>SZArraySig</code>, and its <code>Next</code> property would point to Byte signature.</p><p><code>CorLibTypeSig</code> is a simple corlib type. You don't create these directly. Use eg. <code>module.CorLibTypes.Int32</code> to get a System.Int32 type signature.</p><p><code>ValueTypeSig</code> is used when the next class is a value type.</p><p><code>ClassSig</code> is used when the next class is a reference type.</p><p><code>GenericInstSig</code> is a generic instance type. It has a reference to the generic type (a <code>TypeDef</code> or a <code>TypeRef</code>) and the generic arguments.</p><p><code>PtrSig</code> is a pointer sig.</p><p><code>ByRefSig</code> is a by reference type.</p><p><code>ArraySig</code> is a multi-dimensional array type. Most likely when you create an array, you should use <code>SZArraySig</code>, and <em>not</em><code>ArraySig</code>.</p><p><code>SZArraySig</code> is a single dimension, zero lower bound array. In C#, a <code>byte[]</code> is a <code>SZArraySig</code>, and <em>not</em> an <code>ArraySig</code>.</p><p><code>GenericVar</code> is a generic type variable.</p><p><code>GenericMVar</code> is a generic method variable.</p><p>Some examples if you're not used to the way type signatures are represented in metadata:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-en">ModuleDef</span><span class="pl-smi">mod</span><span class="pl-k">=</span> ....;
    
                        <span class="pl-c"><span class="pl-c">//</span> Create a byte[]</span><span class="pl-en">SZArraySig</span><span class="pl-smi">array1</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SZArraySig</span>(<span class="pl-smi">mod</span>.<span class="pl-smi">CorLibTypes</span>.<span class="pl-smi">Byte</span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> Create an int[][]</span><span class="pl-en">SZArraySig</span><span class="pl-smi">array2</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SZArraySig</span>(<span class="pl-k">new</span><span class="pl-en">SZArraySig</span>(<span class="pl-smi">mod</span>.<span class="pl-smi">CorLibTypes</span>.<span class="pl-smi">Int32</span>));
    
                        <span class="pl-c"><span class="pl-c">//</span> Create an int[,]</span><span class="pl-en">ArraySig</span><span class="pl-smi">array3</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ArraySig</span>(<span class="pl-smi">mod</span>.<span class="pl-smi">CorLibTypes</span>.<span class="pl-smi">Int32</span>, <span class="pl-c1">2</span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> Create an int[*] (one-dimensional array)</span><span class="pl-en">ArraySig</span><span class="pl-smi">array4</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ArraySig</span>(<span class="pl-smi">mod</span>.<span class="pl-smi">CorLibTypes</span>.<span class="pl-smi">Int32</span>, <span class="pl-c1">1</span>);
    
                        <span class="pl-c"><span class="pl-c">//</span> Create a Stream[]. Stream is a reference class so it must be enclosed in a ClassSig.</span><span class="pl-c"><span class="pl-c">//</span> If it were a value type, you would use ValueTypeSig instead.</span><span class="pl-en">TypeRef</span><span class="pl-smi">stream</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">TypeRefUser</span>(<span class="pl-smi">mod</span>, <span class="pl-s"><span class="pl-pds">"</span>System.IO<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Stream<span class="pl-pds">"</span></span>, <span class="pl-smi">mod</span>.<span class="pl-smi">CorLibTypes</span>.<span class="pl-smi">AssemblyRef</span>);
                        <span class="pl-en">SZArraySig</span><span class="pl-smi">array5</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SZArraySig</span>(<span class="pl-k">new</span><span class="pl-en">ClassSig</span>(<span class="pl-smi">stream</span>));</pre>
                    </div><p>Sometimes you must convert an <code>ITypeDefOrRef</code> (<code>TypeRef</code>, <code>TypeDef</code>, or <code>TypeSpec</code>) to/from a <code>TypeSig</code>. There's extension methods you can use:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-c"><span class="pl-c">//</span> array5 is defined above</span><span class="pl-en">ITypeDefOrRef</span><span class="pl-smi">type1</span><span class="pl-k">=</span><span class="pl-smi">array5</span>.<span class="pl-en">ToTypeDefOrRef</span>();
                        <span class="pl-en">TypeSig</span><span class="pl-smi">type2</span><span class="pl-k">=</span><span class="pl-smi">type1</span>.<span class="pl-en">ToTypeSig</span>();</pre>
                    </div><h2><a id="user-content-naming-conventions-of-metadata-table-classes" class="anchor" aria-hidden="true" href="#naming-conventions-of-metadata-table-classes"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Naming conventions of metadata table classes</h2><p>For most tables in the metadata, there's a corresponding dnlib class with the exact same or a similar name. Eg. the metadata has a <code>TypeDef</code> table, and dnlib has a <code>TypeDef</code> class. Some tables don't have a class because they're referenced by other classes, and that information is part of some other class. Eg. the <code>TypeDef</code> class contains all its properties and events, even though the <code>TypeDef</code> table has no property or event column.</p><p>For each of these table classes, there's an abstract base class, and two sub classes. These sub classes are named the same as the base class but ends in either <code>MD</code> (for classes created from the metadata) or <code>User</code> (for classes created by the user). Eg. <code>TypeDef</code> is the base class, and it has two sub classes <code>TypeDefMD</code> which is auto-created from metadata, and <code>TypeRefUser</code> which is created by the user when adding user types. Most of the XyzMD classes are internal and can't be referenced directly by the user. They're created by <code>ModuleDefMD</code> (which is the only public <code>MD</code> class). All XyzUser classes are public.</p><h2><a id="user-content-metadata-table-classes" class="anchor" aria-hidden="true" href="#metadata-table-classes"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Metadata table classes</h2><p>Here's a list of the most common metadata table classes</p><p><code>AssemblyDef</code> is the assembly class.</p><p><code>AssemblyRef</code> is an assembly reference.</p><p><code>EventDef</code> is an event definition. Owned by a <code>TypeDef</code>.</p><p><code>FieldDef</code> is a field definition. Owned by a <code>TypeDef</code>.</p><p><code>GenericParam</code> is a generic parameter (owned by a <code>MethodDef</code> or a <code>TypeDef</code>)</p><p><code>MemberRef</code> is what you create if you need a field reference or a method reference.</p><p><code>MethodDef</code> is a method definition. It usually has a <code>CilBody</code> with CIL instructions. Owned by a <code>TypeDef</code>.</p><p><code>MethodSpec</code> is a instantiated generic method.</p><p><code>ModuleDef</code> is the base module class. When you read an existing module, a <code>ModuleDefMD</code> is created.</p><p><code>ModuleRef</code> is a module reference.</p><p><code>PropertyDef</code> is a property definition. Owned by a <code>TypeDef</code>.</p><p><code>TypeDef</code> is a type definition. It contains a lot of interesting stuff, including methods, fields, properties, etc.</p><p><code>TypeRef</code> is a type reference. Usually to a type in another assembly.</p><p><code>TypeSpec</code> is a type specification, eg. an array, generic type, etc.</p><h2><a id="user-content-method-classes" class="anchor" aria-hidden="true" href="#method-classes"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Method classes</h2><p>The following are the method classes: <code>MethodDef</code>, <code>MemberRef</code> (method ref) and <code>MethodSpec</code>. They all implement <code>IMethod</code>.</p><h2><a id="user-content-field-classes" class="anchor" aria-hidden="true" href="#field-classes"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Field classes</h2><p>The following are the field classes: <code>FieldDef</code> and <code>MemberRef</code> (field ref). They both implement <code>IField</code>.</p><h2><a id="user-content-comparing-types-methods-fields-etc" class="anchor" aria-hidden="true" href="#comparing-types-methods-fields-etc"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparing types, methods, fields, etc</h2><p>dnlib has a <code>SigComparer</code> class that can compare any type with any other type. Any method with any other method, etc. It also has several pre-created <code>IEqualityComparer&lt;T&gt;</code> classes (eg. <code>TypeEqualityComparer</code>, <code>FieldEqualityComparer</code>, etc) which you can use if you intend to eg. use a type as a key in a <code>Dictionary&lt;TKey, TValue&gt;</code>.</p><p>The <code>SigComparer</code> class can also compare types with <code>System.Type</code>, methods with <code>System.Reflection.MethodBase</code>, etc.</p><p>It has many options you can set, see <code>SigComparerOptions</code>. The default options is usually good enough, though.</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-c"><span class="pl-c">//</span> Compare two types</span><span class="pl-en">TypeRef</span><span class="pl-smi">type1</span><span class="pl-k">=</span> ...;
                        <span class="pl-en">TypeDef</span><span class="pl-smi">type2</span><span class="pl-k">=</span> ...;
                        <span class="pl-k">if</span> (<span class="pl-k">new</span><span class="pl-en">SigComparer</span>().<span class="pl-en">Equals</span>(<span class="pl-smi">type1</span>, <span class="pl-smi">type2</span>))
                        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>They're equal<span class="pl-pds">"</span></span>);

                        <span class="pl-c"><span class="pl-c">//</span> Use the type equality comparer</span><span class="pl-en">Dictionary</span>&lt;<span class="pl-en">IType</span>, <span class="pl-k">int</span>&gt; <span class="pl-smi">dict</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Dictionary</span>&lt;<span class="pl-en">IType</span>, <span class="pl-k">int</span>&gt;(<span class="pl-smi">TypeEqualityComparer</span>.<span class="pl-smi">Instance</span>);
                        <span class="pl-en">TypeDef</span><span class="pl-smi">type1</span><span class="pl-k">=</span> ...;
                        <span class="pl-smi">dict</span>.<span class="pl-en">Add</span>(<span class="pl-smi">type1</span>, <span class="pl-c1">10</span>);

                        <span class="pl-c"><span class="pl-c">//</span> Compare a `TypeRef` with a `System.Type`</span><span class="pl-en">TypeRef</span><span class="pl-smi">type1</span><span class="pl-k">=</span> ...;
                        <span class="pl-k">if</span> (<span class="pl-k">new</span><span class="pl-en">SigComparer</span>().<span class="pl-en">Equals</span>(<span class="pl-smi">type1</span>, <span class="pl-k">typeof</span>(<span class="pl-k">int</span>)))
                        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>They're equal<span class="pl-pds">"</span></span>);</pre>
                    </div><p>It has many <code>Equals()</code> and <code>GetHashCode()</code> overloads.</p><h2><a id="user-content-net-resources" class="anchor" aria-hidden="true" href="#net-resources"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>.NET Resources</h2><p>There's three types of .NET resource, and they all derive from the common base class <code>Resource</code>. <code>ModuleDef.Resources</code> is a list of all resources the module owns.</p><p><code>EmbeddedResource</code> is a resource that has data embedded in the owner module. This is the most common type of resource and it's probably what you want.</p><p><code>AssemblyLinkedResource</code> is a reference to a resource in another assembly.</p><p><code>LinkedResource</code> is a reference to a resource on disk.</p><h2><a id="user-content-win32-resources" class="anchor" aria-hidden="true" href="#win32-resources"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Win32 resources</h2><p><code>ModuleDef.Win32Resources</code> can be null or a <code>Win32Resources</code> instance. You can add/remove any Win32 resource blob. dnlib doesn't try to parse these blobs.</p><h2><a id="user-content-parsing-method-bodies" class="anchor" aria-hidden="true" href="#parsing-method-bodies"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Parsing method bodies</h2><p>This is usually only needed if you have decrypted a method body. If it's a standard method body, you can use <code>MethodBodyReader.Create()</code>. If it's similar to a standard method body, you can derive a class from <code>MethodBodyReaderBase</code> and override the necessary methods.</p><h2><a id="user-content-resolving-references" class="anchor" aria-hidden="true" href="#resolving-references"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resolving references</h2><p><code>TypeRef.Resolve()</code> and <code>MemberRef.Resolve()</code> both use <code>module.Context.Resolver</code> to resolve the type, field or method. The custom attribute parser code may also resolve type references.</p><p>If you call <code>Resolve()</code> or read custom attributes, you should initialize module.Context to a <code>ModuleContext</code>. It should normally be shared between all modules you open.</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-c"><span class="pl-c">//</span> You should pass this context to ModuleDefMD.Load(), but you can also write</span><span class="pl-c"><span class="pl-c">//</span> it to `module.Context`</span><span class="pl-en">ModuleContext</span><span class="pl-smi">modCtx</span><span class="pl-k">=</span><span class="pl-smi">ModuleDef</span>.<span class="pl-en">CreateModuleContext</span>();
                        <span class="pl-c"><span class="pl-c">//</span> It creates the default assembly resolver</span><span class="pl-en">AssemblyResolver</span><span class="pl-smi">asmResolver</span><span class="pl-k">=</span> (<span class="pl-en">AssemblyResolver</span>)<span class="pl-smi">modCtx</span>.<span class="pl-smi">AssemblyResolver</span>;

                        <span class="pl-c"><span class="pl-c">//</span> Enable the TypeDef cache for all assemblies that are loaded</span><span class="pl-c"><span class="pl-c">//</span> by the assembly resolver. Only enable it if all auto-loaded</span><span class="pl-c"><span class="pl-c">//</span> assemblies are read-only.</span><span class="pl-smi">asmResolver</span>.<span class="pl-smi">EnableTypeDefCache</span><span class="pl-k">=</span><span class="pl-c1">true</span>;</pre>
                    </div><p>All assemblies that you yourself open should be added to the assembly resolver cache.</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-en">ModuleDefMD</span><span class="pl-smi">mod</span><span class="pl-k">=</span><span class="pl-smi">ModuleDefMD</span>.<span class="pl-en">Load</span>(...);
                        <span class="pl-smi">mod</span>.<span class="pl-smi">Context</span><span class="pl-k">=</span><span class="pl-smi">modCtx</span>;	<span class="pl-c"><span class="pl-c">//</span> Use the previously created (and shared) context</span><span class="pl-c"><span class="pl-c">//</span> This code assumes you're using the default assembly resolver</span>
    ((<span class="pl-en">AssemblyResolver</span>)<span class="pl-smi">mod</span>.<span class="pl-smi">Context</span>.<span class="pl-smi">AssemblyResolver</span>).<span class="pl-en">AddToCache</span>(<span class="pl-smi">mod</span>);</pre>
                    </div><h2><a id="user-content-resolving-types-methods-etc-from-metadata-tokens" class="anchor" aria-hidden="true" href="#resolving-types-methods-etc-from-metadata-tokens"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resolving types, methods, etc from metadata tokens</h2><p><code>ModuleDefMD</code> has several <code>ResolveXXX()</code> methods, eg. <code>ResolveTypeDef()</code>, <code>ResolveMethod()</code>, etc.</p><h2><a id="user-content-creating-mscorlib-type-references" class="anchor" aria-hidden="true" href="#creating-mscorlib-type-references"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating mscorlib type references</h2><p>Every module has a <code>CorLibTypes</code> property. It has references to a few of the simplest types such as all integer types, floating point types, Object, String, etc. If you need a type that's not there, you must create it yourself, eg.:</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">TypeRef</span><span class="pl-smi">consoleRef</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">TypeRefUser</span>(<span class="pl-smi">mod</span>, <span class="pl-s"><span class="pl-pds">"</span>System<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Console<span class="pl-pds">"</span></span>, <span class="pl-smi">mod</span>.<span class="pl-smi">CorLibTypes</span>.<span class="pl-smi">AssemblyRef</span>);</pre></div><h2><a id="user-content-importing-runtime-types-methods-fields" class="anchor" aria-hidden="true" href="#importing-runtime-types-methods-fields"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Importing runtime types, methods, fields</h2><p>To import a <code>System.Type</code>, <code>System.Reflection.MethodInfo</code>, <code>System.Reflection.FieldInfo</code>, etc into a module, use the <code>Importer</code> class.</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-en">Importer</span><span class="pl-smi">importer</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Importer</span>(<span class="pl-smi">mod</span>);
                        <span class="pl-en">ITypeDefOrRef</span><span class="pl-smi">consoleRef</span><span class="pl-k">=</span><span class="pl-smi">importer</span>.<span class="pl-en">Import</span>(<span class="pl-k">typeof</span>(<span class="pl-k">System</span>.<span class="pl-en">Console</span>));
                        <span class="pl-en">IMethod</span><span class="pl-smi">writeLine</span><span class="pl-k">=</span><span class="pl-smi">importer</span>.<span class="pl-en">Import</span>(<span class="pl-k">typeof</span>(<span class="pl-k">System</span>.<span class="pl-en">Console</span>).<span class="pl-en">GetMethod</span>(<span class="pl-s"><span class="pl-pds">"</span>WriteLine<span class="pl-pds">"</span></span>));</pre>
                    </div><p>You can also use it to import types, methods etc from another <code>ModuleDef</code>.</p><p>All imported types, methods etc will be references to the original assembly. I.e., it won't add the imported <code>TypeDef</code> to the target module. It will just create a <code>TypeRef</code> to it.</p><h2><a id="user-content-using-decrypted-methods" class="anchor" aria-hidden="true" href="#using-decrypted-methods"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using decrypted methods</h2><p>If <code>ModuleDefMD.MethodDecrypter</code> is initialized, <code>ModuleDefMD</code> will call it and check whether the method has been decrypted. If it has, it calls <code>IMethodDecrypter.GetMethodBody()</code> which you should implement. Return the new <code>MethodBody</code>. <code>GetMethodBody()</code> should usually call <code>MethodBodyReader.Create()</code> which does the actual parsing of the CIL code.</p><p>It's also possible to override <code>ModuleDefMD.ReadUserString()</code>. This method is called by the CIL parser when it finds a <code>Ldstr</code> instruction. If <code>ModuleDefMD.StringDecrypter</code> is not null, its <code>ReadUserString()</code> method is called with the string token. Return the decrypted string or null if it should be read from the <code>#US</code> heap.</p><h2><a id="user-content-low-level-access-to-the-metadata" class="anchor" aria-hidden="true" href="#low-level-access-to-the-metadata"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Low level access to the metadata</h2><p>The low level classes are in the <code>dnlib.DotNet.MD</code> namespace.</p><p>Open an existing .NET module/assembly and you get a ModuleDefMD. It has several properties, eg. <code>StringsStream</code> is the #Strings stream.</p><p>The <code>Metadata</code> property gives you full access to the metadata.</p><p>To get a list of all valid TypeDef rids (row IDs), use this code:</p><div class="highlight highlight-source-cs">
                        <pre><span class="pl-k">using</span><span class="pl-en">dnlib</span>.<span class="pl-en">DotNet</span>.<span class="pl-en">MD</span>;
                        <span class="pl-c"><span class="pl-c">//</span> ...</span><span class="pl-en">ModuleDefMD</span><span class="pl-smi">mod</span><span class="pl-k">=</span><span class="pl-smi">ModuleDefMD</span>.<span class="pl-en">Load</span>(...);
                        <span class="pl-en">RidList</span><span class="pl-smi">typeDefRids</span><span class="pl-k">=</span><span class="pl-smi">mod</span>.<span class="pl-smi">Metadata</span>.<span class="pl-en">GetTypeDefRidList</span>();
                        <span class="pl-k">for</span> (<span class="pl-k">int</span><span class="pl-smi">i</span><span class="pl-k">=</span><span class="pl-c1">0</span>; <span class="pl-smi">i</span><span class="pl-k">&lt;</span><span class="pl-smi">typeDefRids</span>.<span class="pl-smi">Count</span>; <span class="pl-smi">i</span><span class="pl-k">++</span>)
                        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>rid: {0}<span class="pl-pds">"</span></span>, <span class="pl-smi">typeDefRids</span>[<span class="pl-smi">i</span>]);</pre>
                    </div><p>You don't need to create a <code>ModuleDefMD</code>, though. See <code>MetadataFactory</code>.</p><h2><a id="user-content-credits" class="anchor" aria-hidden="true" href="#credits"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Credits</h2><p>Big thanks to <a href="https://github.com/yck1509">Ki</a> for writing the managed Windows PDB reader!</p><p><a href="https://github.com/0xd4d/dnlib/graphs/contributors">List of all contributors</a></p>
                </div>
            </div>
        </div>
    </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>