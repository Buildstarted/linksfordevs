<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Random Thoughts -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Random Thoughts</h1><div><div id="" class="post-list"><li><span class="post-meta">Oct 7, 2019</span><p>.NET Core 3.0 introduced over a dozen new APIs for importing and exporting RSA
keys in different formats. Many of them are a variant of another with a slightly
different API, but they are extremely useful for working with private and public
keys from other systems that work with encoding keys.</p><p>RSA keys can be encoded in a variety of different ways, depending on if the key
is public or private or protected with a password. Different programs will
import or export RSA keys in a different format, etc.</p><p>Often times RSA keys can be described as “PEM” encoded, but that is already
ambiguous as to how the key is actually encoded. PEM takes the form of:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-----BEGIN LABEL-----
content
-----END LABEL-----
</code></pre></div></div><p>The content between the labels is base64 encoded. The one that is
probably the most often seen is BEGIN RSA PRIVATE KEY, which is frequently used
in web servers like nginx, apache, etc:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-----BEGIN RSA PRIVATE KEY-----
MII...
-----END RSA PRIVATE KEY-----
</code></pre></div></div><p>The base64-encoded text is an RSAPrivateKey from the <a href="https://tools.ietf.org/html/rfc3447#appendix-A.1.2">PKCS#1 spec</a>, which is
just an ASN.1 SEQUENCE of integers that make up the RSA key. The corresponding
.NET Core 3 API for this is <code class="highlighter-rouge">ImportRSAPrivateKey</code>, or one of its overloads.
If your key is “PEM” encoded, you need to find the base64 text between the label
BEGIN and END headers, base64 decode it, and pass to <code class="highlighter-rouge">ImportRSAPrivateKey</code>.
There is currently an <a href="https://github.com/dotnet/corefx/issues/37748">API proposal</a> to make reading PEM files easier.
If your private key is DER encoded, then that just means you can read the
content directly as bytes in to <code class="highlighter-rouge">ImportRSAPrivateKey</code>.</p><p>Here is an example:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">privateKey</span><span class="p">=</span><span class="s">"MII..."</span><span class="p">;</span><span class="c1">//Get just the base64 content.</span><span class="kt">var</span><span class="n">privateKeyBytes</span><span class="p">=</span><span class="n">Convert</span><span class="p">.</span><span class="nf">FromBase64String</span><span class="p">(</span><span class="n">privateKey</span><span class="p">);</span><span class="k">using</span><span class="nn">var</span><span class="n">rsa</span><span class="p">=</span><span class="n">RSA</span><span class="p">.</span><span class="nf">Create</span><span class="p">();</span><span class="n">rsa</span><span class="p">.</span><span class="nf">ImportRSAPrivateKey</span><span class="p">(</span><span class="n">privateKeyBytes</span><span class="p">,</span><span class="k">out</span><span class="n">_</span><span class="p">);</span></code></pre></div></div><p>When using openssl, the <code class="highlighter-rouge">openssl rsa</code> commands typically output RSAPrivateKey
PKCS#1 private keys, for example <code class="highlighter-rouge">openssl genrsa</code>.</p><p>A different format for a private key is PKCS#8. Unlike the RSAPrivateKey from
PKCS#1, a PKCS#8 encoded key can represent other kinds of keys than RSA. As
such, the PEM label for a PKCS#8 key is “BEGIN PRIVATE KEY” (note the lack of
“RSA” there). The key itself contains an AlgorithmIdentifer of what kind of key
it is.</p><p>PKCS#8 keys can also be encrypted protected, too. In that case, the PEM
label will be “BEGIN ENCRYPTED PRIVATE KEY”.</p><p>.NET Core 3 has APIs for both of these. Unencrypted PKCS#8 keys can be imported
with <code class="highlighter-rouge">ImportPkcs8PrivateKey</code>, and encrypted PKCS#8 keys can be imported with
<code class="highlighter-rouge">ImportEncryptedPkcs8PrivateKey</code>. Their usage is similar to <code class="highlighter-rouge">ImportRSAPrivateKey</code>.</p><p>Public keys have similar behavior. A PEM encoded key that has the label
“BEGIN RSA PUBLIC KEY” should use <code class="highlighter-rouge">ImportRSAPublicKey</code>. Also like private keys,
the public key has a format that self-describes the algorithm of the key called
a Subject Public Key Info (SPKI) which is used heavily in X509 and many other
standards. The PEM header for this is “BEGIN PUBLIC KEY”, and
<code class="highlighter-rouge">ImportSubjectPublicKeyInfo</code> is the correct way to import these.</p><p>All of these APIs have export versions of themselves as well, so if you are
trying to export a key from .NET Core 3 to a particular format, you’ll need to
use the correct export API.</p><p>To summarize each PEM label and API pairing:</p><ol><li>“BEGIN RSA PRIVATE KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importrsaprivatekey?view=netcore-3.0"><code class="highlighter-rouge">RSA.ImportRSAPrivateKey</code></a></li><li>“BEGIN PRIVATE KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importpkcs8privatekey?view=netcore-3.0"><code class="highlighter-rouge">RSA.ImportPkcs8PrivateKey</code></a></li><li>“BEGIN ENCRYPTED PRIVATE KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importencryptedpkcs8privatekey?view=netcore-3.0"><code class="highlighter-rouge">RSA.ImportEncryptedPkcs8PrivateKey</code></a></li><li>“BEGIN RSA PUBLIC KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importrsapublickey?view=netcore-3.0"><code class="highlighter-rouge">RSA.ImportRSAPublicKey</code></a></li><li>“BEGIN PUBLIC KEY” =&gt; <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa.importsubjectpublickeyinfo?view=netcore-3.0"><code class="highlighter-rouge">RSA.ImportSubjectPublicKeyInfo</code></a></li></ol><p>One gotcha with openssl is to pay attention to the output of the key format.
A common enough task from openssl is “Given this PEM-encoded RSA private key, give
me a PEM encoded public-key” and is often enough done like this:</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl rsa <span class="nt">-in</span> key.pem <span class="nt">-pubout</span></code></pre></div></div><p>Even if key.pem is a PKCS#1 RSAPrivateKey (“BEGIN RSA PRIVATE KEY”), the <code class="highlighter-rouge">-pubout</code>
option will output a SPKI (“BEGIN PUBLIC KEY”), not an RSAPublicKey
(“BEGIN RSA PUBLIC KEY”). For that, you would need to use <code class="highlighter-rouge">-RSAPublicKey_out</code>
instead of <code class="highlighter-rouge">-pubout</code>. The openssl <code class="highlighter-rouge">pkey</code> commands will also typically give you
PKCS#8 or SPKI formatted keys.</p></li><li><span class="post-meta">Jul 18, 2019</span><p>One of the nice things about .NET Core being open source is following along with
some of the issues that people report. I tend to keep an eye on System.Security
tagged issues, since those tend to be at the intersection of things that
interest me and things I can maybe help with.</p><p>A user <a href="https://github.com/dotnet/corefx/issues/34202">filed an issue</a> where .NET Framework considered a CMS valid, and .NET
Core did not. This didn’t entirely surprise me. In the .NET Framework, the
<code class="highlighter-rouge">SignedCms</code> class is heavily backed by Windows’ handling of CMS/PKCS#7. In .NET
Core, the implementation is managed (sans the cryptography). The managed
implementation adheres somewhat strictly to the CMS specification. As other issues
have noticed, Windows’, thus .NET Framework’s, implementation was a little more
relaxed in some ways.</p><p>This turned out not to be one of those cases. The CMS part was actually working
just fine. What was failing was RSA itself. The core of the issue was that
different implementations of RSA disagreed on the RSA signature’s validity.</p><p>That seems pretty strange!</p><p>When I talk about different implementations on Windows, I am usually referring
to CAPI vs CNG, or <code class="highlighter-rouge">RSACryptoServiceProvider</code> and <code class="highlighter-rouge">RSACng</code>, respectively. For
now, I’m keeping this post to the .NET Framework. We’ll bring .NET Core in to
the discussion later.</p><p>There are two implementations because, well, Windows has two of them. CNG, or
“Cryptography API: Next Generation” is the newer of the two and is intended to
be future of cryptographic primitives on Windows. It shipped in Windows Vista,
and offers functionality that CAPI cannot do. An example of that is PSS RSA
signatures.</p><p>.NET Framework exposes these implementations as <code class="highlighter-rouge">RSACryptoServiceProvider</code> and
<code class="highlighter-rouge">RSACng</code>. They <em>should</em> be interchangable, and CNG implementations should be
used going forward. However, there is one corner case where the old, CAPI
implementation considers a signature valid while the CNG one does not.</p><p>The issue can be demonstrated like so:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="p">[]</span><span class="n">n</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="kt">byte</span><span class="p">[]</span><span class="n">e</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="kt">byte</span><span class="p">[]</span><span class="n">signature</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="kt">var</span><span class="n">digest</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="m">0x68</span><span class="p">,</span><span class="m">0xB4</span><span class="p">,</span><span class="m">0xF9</span><span class="p">,</span><span class="m">0x26</span><span class="p">,</span><span class="m">0x34</span><span class="p">,</span><span class="m">0x31</span><span class="p">,</span><span class="m">0x25</span><span class="p">,</span><span class="m">0xDD</span><span class="p">,</span><span class="m">0x26</span><span class="p">,</span><span class="m">0x50</span><span class="p">,</span><span class="m">0x13</span><span class="p">,</span><span class="m">0x68</span><span class="p">,</span><span class="m">0xC1</span><span class="p">,</span><span class="m">0x99</span><span class="p">,</span><span class="m">0x26</span><span class="p">,</span><span class="m">0x71</span><span class="p">,</span><span class="m">0x19</span><span class="p">,</span><span class="m">0xA2</span><span class="p">,</span><span class="m">0xDE</span><span class="p">,</span><span class="m">0x81</span><span class="p">,</span><span class="p">};</span><span class="k">using</span><span class="p">(</span><span class="kt">var</span><span class="n">rsa</span><span class="p">=</span><span class="k">new</span><span class="nf">RSACng</span><span class="p">())</span><span class="p">{</span><span class="n">rsa</span><span class="p">.</span><span class="nf">ImportParameters</span><span class="p">(</span><span class="k">new</span><span class="n">RSAParameters</span><span class="p">{</span><span class="n">Modulus</span><span class="p">=</span><span class="n">n</span><span class="p">,</span><span class="n">Exponent</span><span class="p">=</span><span class="n">e</span><span class="p">});</span><span class="kt">var</span><span class="n">valid</span><span class="p">=</span><span class="n">rsa</span><span class="p">.</span><span class="nf">VerifyHash</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span><span class="n">signature</span><span class="p">,</span><span class="n">HashAlgorithmName</span><span class="p">.</span><span class="n">SHA1</span><span class="p">,</span><span class="n">RSASignaturePadding</span><span class="p">.</span><span class="n">Pkcs1</span><span class="p">);</span><span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">valid</span><span class="p">);</span><span class="p">}</span><span class="k">using</span><span class="p">(</span><span class="kt">var</span><span class="n">rsa</span><span class="p">=</span><span class="k">new</span><span class="nf">RSACryptoServiceProvider</span><span class="p">())</span><span class="p">{</span><span class="n">rsa</span><span class="p">.</span><span class="nf">ImportParameters</span><span class="p">(</span><span class="k">new</span><span class="n">RSAParameters</span><span class="p">{</span><span class="n">Modulus</span><span class="p">=</span><span class="n">n</span><span class="p">,</span><span class="n">Exponent</span><span class="p">=</span><span class="n">e</span><span class="p">});</span><span class="kt">var</span><span class="n">valid</span><span class="p">=</span><span class="n">rsa</span><span class="p">.</span><span class="nf">VerifyHash</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span><span class="n">signature</span><span class="p">,</span><span class="n">HashAlgorithmName</span><span class="p">.</span><span class="n">SHA1</span><span class="p">,</span><span class="n">RSASignaturePadding</span><span class="p">.</span><span class="n">Pkcs1</span><span class="p">);</span><span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">valid</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><aside><p>Note: to avoid bloating this blog post with large signatures and RSA
keys, I omitted them. However the full example with public keys is available
<a href="https://gist.github.com/vcsjones/ab4c2327b53ed018eada76b75ef4fd99">
on GitHub here</a>.
</p></aside><p>When used with one of the curious signatures that exhibits this behavior, such
as the one in the GitHub link, the first result will be false, and the second
will be true.</p><p>Nothing jumped out at me as being problematic. The signature padding is PKCS,
the public exponent is the very typical 67,537, and the RSA key is sensible in
size.</p><p>To make it stranger, this signature came off the timestamp of Firefox’s own
signed installer. So why are the results different?</p><p>Jeremy Barton from Microsoft on .NET Core made the observation that the padding
in the RSA signature itself is incorrect, but in a way that CAPI tollerates and
CNG does not, at least by default. Let’s look at the raw signature. To do that,
we need the public key and signature on disk, and we can poke at them with OpenSSL.</p><p>Using the command:</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl rsautl <span class="nt">-verify</span><span class="nt">-in</span> sig.bin <span class="nt">-inkey</span> key.der <span class="se">\</span><span class="nt">-pubin</span><span class="nt">-hexdump</span><span class="nt">-raw</span><span class="nt">-keyform</span> der
</code></pre></div></div><p>We get the following output:</p><pre>0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00e0 - ff ff ff ff ff ff ff ff-ff ff ff 00 68 b4 f9 26
00f0 - 34 31 25 dd 26 50 13 68-c1 99 26 71 19 a2 de 81
</pre><p>This is a PKCS#1 v1.5 padded signature, as indicated by by starting with 00 01.
The digest at the end can be seen, <code class="highlighter-rouge">68 b4 f9 26 ... 19 a2 de 81</code> which matches
the digest above, so we know that the signature is for the right digest.</p><p>What is not correct in this signature is how the digest is encoded. The signature
contains the bare digest. It <em>should</em> be encoded as an ASN.1 sequence along
with the AlgorithmIdentifer of the digest:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DigestInfo ::= SEQUENCE {
	digestAlgorithm AlgorithmIdentifier,
	digest OCTET STRING
}
</code></pre></div></div><p>This goes back all the way to <a href="ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-1.asc">a document</a> (warning: link is to an ftp:// site)
written in 1993 by RSA labratories explaining how PKCS#1 v1.5 works,and was
standardized in to <a href="https://tools.ietf.org/html/rfc2313">an RFC</a> in 1998.</p><p>The RSA signature we have only contains the raw digest. It is not part of a
<code class="highlighter-rouge">DigestInfo</code>. If the digest were properly encoded, it would look something like
this:</p><pre>0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 21 30
00e0 - 09 06 05 2b 0e 03 02 1a-05 00 04 14 68 b4 f9 26
00f0 - 34 31 25 dd 26 50 13 68-c1 99 26 71 19 a2 de 81
</pre><p>The signature now includes <code class="highlighter-rouge">DigestInfo</code> along with the OID 1.3.14.3.2.26 to
indicate that the digest is SHA1.</p><p>At this point we know what the difference is, and the original specification in
part 10.1.2 makes it fairly clear that the “data” should be a digest and should
be encoded as DigestInfo, not a bare digest.</p><p>The source of this signature is from Verisign's timestamp authority at
http://timestamp.verisign.com/​scripts/​timstamp.dll. After checking with
someone at DigiCert (now running this TSA), it was launched in May 1995.</p><p>I suspect that the TSA is old enough that the implementation was made before the
specification was complete or simply got the specification wrong and no one
noticed. Bringing this back to CNG and CAPI, CNG can validate this signatures, but you
must explicitly tell CNG that the signature does not have an object identifier.
<a href="https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-_bcrypt_pkcs1_padding_info"><code class="highlighter-rouge">BCRYPT_PKCS1_PADDING_INFO</code>’s</a> documentation has the detail there, but gist
of it is</p><blockquote><p>If there is no OID in the signature, then verification fails unless this
member is NULL.</p></blockquote><p>This would be used with <code class="highlighter-rouge">{B,N}CryptVerifySignature</code>. To bring this back around
to the .NET Framework, how do we use <code class="highlighter-rouge">RSACng</code> and give <code class="highlighter-rouge">null</code> in for the
padding algorithm? The short answer is: you cannot. If you try, you will get
an explicit <code class="highlighter-rouge">ArgumentException</code> saying that the hash algorithm name cannot be
null.</p><p>For .NET Framework, this solution “keep using <code class="highlighter-rouge">RSACryptoServiceProvider</code>”. If
you need to validate these signatures, chances are you do not need to use CNG’s
newer capabilities like PSS since these malformed signatures appear to be coming
from old systems. Higher level things like <code class="highlighter-rouge">SignedCms</code> and <code class="highlighter-rouge">SignedXml</code> use
<code class="highlighter-rouge">RSACryptoServiceProvider</code> by default, so they will continue to work.</p><p>To bring in .NET Core, the situation is a little more difficult. If you are
using <code class="highlighter-rouge">SignedCms</code> like so:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">signedCms</span><span class="p">=</span><span class="k">new</span><span class="nf">SignedCms</span><span class="p">();</span><span class="n">signedCms</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="n">File</span><span class="p">.</span><span class="nf">ReadAllBytes</span><span class="p">(</span><span class="s">"cms-with-sig.bin"</span><span class="p">));</span><span class="n">signedCms</span><span class="p">.</span><span class="nf">CheckSignature</span><span class="p">(</span><span class="k">true</span><span class="p">);</span></code></pre></div></div><p>This will start throwing when you migrate to .NET Core. .NET Core will use CNG
when run on Windows to validate RSA signatures for <code class="highlighter-rouge">SignedCms</code> and <code class="highlighter-rouge">SignedXml</code>.
This is currently not configurable, either. When used with <code class="highlighter-rouge">SignedCms</code>, it
ultimately calls the <code class="highlighter-rouge">X509Certificate2.GetRSAPublicKey()</code> extension method,
and that will <a href="https://github.com/dotnet/corefx/blob/b26339b6f6c7537875c70b5f3c8af376d0bbded5/src/System.Security.Cryptography.X509Certificates/src/Internal/Cryptography/Pal.Windows/X509Pal.PublicKey.cs#L43">always</a> return an implementation based on CNG.</p><p>If you are using <code class="highlighter-rouge">SignedCms</code> on .NET Core and need to validate a CMS that is
signed with these problematic signatures, you are currently out of luck using
in-the-box components. As far as other platforms go, both macOS and Linux
environments for .NET Core will agree with CNG - that the signature is invalid.</p><p>The good news is, these signatures are not easy to come by. So far, only the
old Verisign timestamp authority is known to have produced signatures like this.</p></li><li><span class="post-meta">Feb 1, 2019</span><p>Since C# 7 there have been a lot of point releases that contain all kinds of
goodies. Many of them are performance focused, such as safe stack allocations
using <code class="highlighter-rouge">Span&lt;T&gt;</code>, or interoperability with improvements to <code class="highlighter-rouge">fixed</code>.</p><p>One that I love, but is not documented well, is some special treatment
that <code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code> gets when its contents are known at compile time.</p><p>Here’s an example of a lookup table I used to aide with hex encoding that uses
a <code class="highlighter-rouge">byte[]</code>:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span><span class="k">static</span><span class="kt">byte</span><span class="p">[]</span><span class="n">LookupTable</span><span class="p">=&gt;</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'0'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'1'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'2'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'3'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'4'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'5'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'6'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'7'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'8'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'9'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'A'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'B'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'C'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'D'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'E'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'F'</span><span class="p">,</span><span class="p">};</span></code></pre></div></div><p>This binary data has to get stored <em>somewhere</em> in our produced library. If we
use <code class="highlighter-rouge">dumpbin</code> we can see it in the .text section of the binary.</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dumpbin /RAWDATA /SECTION:.text mylib.dll
</code></pre></div></div><p>Right at the bottom, we see:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00402A40: 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46  0123456789ABCDEF
</code></pre></div></div><p>I won’t go into the a lot of the details on how this data is compiled into the
<code class="highlighter-rouge">.text</code> section, but at this point we need to get that data into the array
somehow.</p><p>If we look at the jit assembly of <code class="highlighter-rouge">LookupTable</code>, we see:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sub rsp, 0x28
vzeroupper
mov rcx, 0x7ffc4638746a
mov edx, 0x10
call 0x7ffc49b52630
mov rdx, 0x1b51450099c
lea rcx, [rax+0x10]
vmovdqu xmm0, [rdx]
vmovdqu [rcx], xmm0
add rsp, 0x28
ret
</code></pre></div></div><p>Where <code class="highlighter-rouge">0x7ffc49b52630</code> is <code class="highlighter-rouge">InitializeArray</code>.</p><p>With an array, our property leans on <code class="highlighter-rouge">InitializeArray</code>, the source of which is
<a href="https://github.com/dotnet/coreclr/blob/a28b25aacdcd2adb0fdfa70bd869f53ba6565976/src/classlibnative/bcltype/arraynative.cpp#L1377">in the CoreCLR</a>. For little-endian platforms, it boils down to a <code class="highlighter-rouge">memcpy</code>
from a runtime field handle.</p><p>Indeed, with a debugger we finally see:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00007ffd`b18b701a e831a40e00       call    coreclr!memcpy (00007ffd`b19a1450)
</code></pre></div></div><p>Dumping <code class="highlighter-rouge">@rdx L10</code> yields:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000001f0`4c552a90  30 31 32 33 34 35 36 37-38 39 41 42 43 44 45 46  0123456789ABCDEF
</code></pre></div></div><p>So that was a very long-winded way of saying that when using arrays, initializing
a field or variable with bytes results in <code class="highlighter-rouge">memcpy</code> from the image into the array,
which results in more data on the heap.</p><p>Now, starting in 7.3, we can avoid that <code class="highlighter-rouge">memcpy</code> when using <code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code>.</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span><span class="k">static</span><span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;</span><span class="n">LookupTable</span><span class="p">=&gt;</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'0'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'1'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'2'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'3'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'4'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'5'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'6'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'7'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'8'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'9'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'A'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'B'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'C'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'D'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'E'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'F'</span><span class="p">,</span><span class="p">};</span></code></pre></div></div><p>Looking at the jit assembly:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov eax, 0x10
xor edx, edx
mov r8, 0x1b5144c0968
mov [rcx], rdx
mov [rcx+0x8], r8
mov [rcx+0x10], eax
mov rax, rcx
ret
</code></pre></div></div><p>We see that there is <code class="highlighter-rouge">mov r8, 0x1b5144c0968</code>. The contents of <code class="highlighter-rouge">0x1b5144c0968</code>
are:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000001b5`144c0968  30 31 32 33 34 35 36 37-38 39 41 42 43 44 45 46  0123456789ABCDEF
</code></pre></div></div><p>So we see that the method is now returning the data directly and
omitting the <code class="highlighter-rouge">memcpy</code> entirely, so our <code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code> is pointing directly
to the <code class="highlighter-rouge">.text</code> section.</p><p>This works for property getters as shown above, but also as the return of a
method:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;</span><span class="nf">GetBytes</span><span class="p">()</span><span class="p">{</span><span class="k">return</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="p">}</span></code></pre></div></div><p>Which works similar to the getter of the property. In addition, this also works
for locals in a method body as well:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span><span class="nf">Write200Ok</span><span class="p">(</span><span class="n">Stream</span><span class="n">s</span><span class="p">)</span><span class="p">{</span><span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;</span><span class="n">data</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'H'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'T'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'T'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'P'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'/'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'1'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'.'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'1'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">' '</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'2'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'0'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'0'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">' '</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'O'</span><span class="p">,</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'K'</span><span class="p">};</span><span class="n">s</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><p>Which also produces a reasonable JIT disassembly:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sub     rsp, 0x38
xor     eax, eax
mov     qword ptr [rsp+0x28], rax
mov     qword ptr [rsp+0x30], rax
mov     rcx, 0x1e595b42ade
mov     eax, 0x0F
lea     r8, [rsp+0x28]
mov     qword ptr [r8], rcx
mov     dword ptr [r8+8], eax
mov     rcx, rdx
lea     rdx, [rsp+0x28]
cmp     dword ptr [rcx], ecx
call    0x7ff89ede10c8 (Stream.Write(System.ReadOnlySpan`1&lt;Byte&gt;), mdToken: 0000000006000001)
add     rsp, 0x38
ret
</code></pre></div></div><p>Here we see  <code class="highlighter-rouge">mov rcx, 0x1e595b42ade</code> which moves the address of the static
 data directly in to the register with no additional work to create a byte array.</p><p>These optimizations currently only works with <code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code> right now.
Other types will continue to use <code class="highlighter-rouge">InitializeArray</code> due to needing to handle
different platforms and how they handle endianness.</p></li><li><span class="post-meta">Jan 30, 2019</span><p>Visual Studio 2019 preview 2 was released a few days ago and I took the time
to install it. Visual Studio itself is actually rather uninteresting to me,
however the inclusion of the next C# 8 preview got my attention. I glanced at
the feature highlights and posted “looks nice” on Twitter.</p><p>Predictably, I got a few responses like “I’m not sure I like that”, and there is
always a guarantee that if F# has a similar feature, an F# developer will appear
and tell you F# has had this feature for 600 years.</p><p>The one I like a lot is using declarations. This allows a local to automatically
be disposed at the end of the block. Essentially, it hides the <code class="highlighter-rouge">try</code>/<code class="highlighter-rouge">finally</code>
or the <code class="highlighter-rouge">using() {...}</code>. The .NET team’s blog kind of gave a bad example of this,
so I’ll use one from <a href="https://github.com/vcsjones/FiddlerCert">Open OPC SignTool</a>. Here is the original snippet:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span><span class="k">static</span><span class="n">X509Certificate2</span><span class="nf">GetCertificateFromCertificateStore</span><span class="p">(</span><span class="kt">string</span><span class="n">sha1</span><span class="p">)</span><span class="p">{</span><span class="k">using</span><span class="p">(</span><span class="kt">var</span><span class="n">store</span><span class="p">=</span><span class="k">new</span><span class="nf">X509Store</span><span class="p">(</span><span class="n">StoreName</span><span class="p">.</span><span class="n">My</span><span class="p">,</span><span class="n">StoreLocation</span><span class="p">.</span><span class="n">LocalMachine</span><span class="p">))</span><span class="p">{</span><span class="n">store</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">OpenFlags</span><span class="p">.</span><span class="n">OpenExistingOnly</span><span class="p">|</span><span class="n">OpenFlags</span><span class="p">.</span><span class="n">ReadOnly</span><span class="p">);</span><span class="kt">var</span><span class="n">certificates</span><span class="p">=</span><span class="n">store</span><span class="p">.</span><span class="n">Certificates</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="n">X509FindType</span><span class="p">.</span><span class="n">FindByThumbprint</span><span class="p">,</span><span class="n">sha1</span><span class="p">,</span><span class="k">false</span><span class="p">);</span><span class="k">return</span><span class="n">certificates</span><span class="p">.</span><span class="n">Count</span><span class="p">&gt;</span><span class="m">0</span><span class="p">?</span><span class="n">certificates</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="p">:</span><span class="k">null</span><span class="p">;</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>A <code class="highlighter-rouge">using var</code> can make this:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span><span class="k">static</span><span class="n">X509Certificate2</span><span class="nf">GetCertificateFromCertificateStore</span><span class="p">(</span><span class="kt">string</span><span class="n">sha1</span><span class="p">)</span><span class="p">{</span><span class="k">using</span><span class="nn">var</span><span class="n">store</span><span class="p">=</span><span class="k">new</span><span class="nf">X509Store</span><span class="p">(</span><span class="n">StoreName</span><span class="p">.</span><span class="n">My</span><span class="p">,</span><span class="n">StoreLocation</span><span class="p">.</span><span class="n">LocalMachine</span><span class="p">);</span><span class="n">store</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">OpenFlags</span><span class="p">.</span><span class="n">OpenExistingOnly</span><span class="p">|</span><span class="n">OpenFlags</span><span class="p">.</span><span class="n">ReadOnly</span><span class="p">);</span><span class="kt">var</span><span class="n">certificates</span><span class="p">=</span><span class="n">store</span><span class="p">.</span><span class="n">Certificates</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="n">X509FindType</span><span class="p">.</span><span class="n">FindByThumbprint</span><span class="p">,</span><span class="n">sha1</span><span class="p">,</span><span class="k">false</span><span class="p">);</span><span class="k">return</span><span class="n">certificates</span><span class="p">.</span><span class="n">Count</span><span class="p">&gt;</span><span class="m">0</span><span class="p">?</span><span class="n">certificates</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="p">:</span><span class="k">null</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>This has the same effect of <code class="highlighter-rouge">store</code> having <code class="highlighter-rouge">Dispose</code> called on it at the end of
the method. The benefit here being that there is less indentation and braces.
This keeps me focused on the code that matters. I don’t care when <code class="highlighter-rouge">store</code> is
disposed in the method, I can just observe that it has a <code class="highlighter-rouge">using</code> modifier on the
local and be assured that <code class="highlighter-rouge">Dispose</code> will be called.</p><p>This isn’t the same as garbage collection or finalizers. Both of those are non-
deterministic, and can lead to unexpected program behavior. That’s less so in
the case of <code class="highlighter-rouge">X509Store</code>, so let’s look at another example:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span><span class="nn">Stream</span><span class="n">stream</span><span class="p">=</span><span class="n">entry</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span><span class="kt">var</span><span class="n">xmlDocument</span><span class="p">=</span><span class="n">XDocument</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="n">LoadOptions</span><span class="p">.</span><span class="n">PreserveWhitespace</span><span class="p">);</span><span class="k">return</span><span class="k">new</span><span class="nf">OpcRelationships</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="n">xmlDocument</span><span class="p">,</span><span class="n">readOnlyMode</span><span class="p">);</span></code></pre></div></div><p>Not disposing a stream that is backed by a file can cause access errors later in
software that might try to open that file again - it is already open, so not
only is it a bad idea it leave streams to the GC, it is just simply incorrect.</p><p>However again <code class="highlighter-rouge">using</code> on the local ensures it is deterministically closed.</p><p><em>When</em> it gets disposed I can see being slightly unclear to the developer. The
quick explanation is when the local is no longer reachable, not when it is last
used. The C# 8 above gets compiled roughly to:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">stream</span><span class="p">=</span><span class="n">entry</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span><span class="k">try</span><span class="p">{</span><span class="kt">var</span><span class="n">xmlDocument</span><span class="p">=</span><span class="n">XDocument</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="n">LoadOptions</span><span class="p">.</span><span class="n">PreserveWhitespace</span><span class="p">);</span><span class="k">return</span><span class="k">new</span><span class="nf">OpcRelationships</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="n">xmlDocument</span><span class="p">,</span><span class="n">readOnlyMode</span><span class="p">);</span><span class="p">}</span><span class="k">finally</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="n">stream</span><span class="p">!=</span><span class="k">null</span><span class="p">)</span><span class="p">{</span><span class="p">((</span><span class="n">IDisposable</span><span class="p">)</span><span class="n">stream</span><span class="p">).</span><span class="nf">Dispose</span><span class="p">();</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>The disposal is done after the return, when the local is no longer reachable,
not after <code class="highlighter-rouge">XDocument</code> is created.</p><p>I find this very helpful to keep code readable. This doesn’t work when you need
fine control over when <code class="highlighter-rouge">Dispose</code> is called. A place where this does not work
well is when the <code class="highlighter-rouge">Dispose</code> pattern is used for scopes, such as logging. The
AzureSignTool project has code similar to this in <code class="highlighter-rouge">SignCommand</code>:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">logger</span><span class="p">=</span><span class="n">loggerFactory</span><span class="p">.</span><span class="n">CreateLogger</span><span class="p">&lt;</span><span class="n">SignCommand</span><span class="p">&gt;();</span><span class="n">Parallel</span><span class="p">.</span><span class="nf">ForEach</span><span class="p">(</span><span class="n">AllFiles</span><span class="p">,</span><span class="n">options</span><span class="p">,</span><span class="p">()</span><span class="p">=&gt;</span><span class="p">(</span><span class="n">succeeded</span><span class="p">:</span><span class="m">0</span><span class="p">,</span><span class="n">failed</span><span class="p">:</span><span class="m">0</span><span class="p">),</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span><span class="n">pls</span><span class="p">,</span><span class="n">state</span><span class="p">)</span><span class="p">=&gt;</span><span class="p">{</span><span class="k">using</span><span class="p">(</span><span class="kt">var</span><span class="n">loopScope</span><span class="p">=</span><span class="n">logger</span><span class="p">.</span><span class="nf">BeginScope</span><span class="p">(</span><span class="s">"File: {Id}"</span><span class="p">,</span><span class="n">filePath</span><span class="p">))</span><span class="p">{</span><span class="n">logger</span><span class="p">.</span><span class="nf">LogInformation</span><span class="p">(</span><span class="s">"Signing file."</span><span class="p">);</span><span class="c1">//Sign the file. omit a bunch of other code.</span><span class="n">logger</span><span class="p">.</span><span class="nf">LogInformation</span><span class="p">(</span><span class="s">"Done signing the file."</span><span class="p">);</span><span class="p">}</span><span class="n">logger</span><span class="p">.</span><span class="nf">LogDebug</span><span class="p">(</span><span class="s">"Incrementing success count."</span><span class="p">);</span><span class="k">return</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">succeeded</span><span class="p">+</span><span class="m">1</span><span class="p">,</span><span class="n">state</span><span class="p">.</span><span class="n">failed</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><p>Here, we cannot change this to a <code class="highlighter-rouge">using var</code> because then the <code class="highlighter-rouge">LogDebug</code> would
be inside of that logging scope, which it wasn’t before. This is a place where
we continue to want <code class="highlighter-rouge">Dispose</code> to be called at a different time from the when
<code class="highlighter-rouge">loopScope</code> would no longer be in scope.</p><p>My impression from C# developers is that they do not tend to call <code class="highlighter-rouge">Dispose</code> 
on resources as soon as it can be disposed, just at a reasonable point in the
same method. Most developers do not write this code:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="kt">bool</span><span class="nf">MightBeExe</span><span class="p">(</span><span class="kt">string</span><span class="n">filePath</span><span class="p">)</span><span class="p">{</span><span class="kt">var</span><span class="n">firstBytes</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[</span><span class="m">2</span><span class="p">];</span><span class="kt">int</span><span class="n">bytesRead</span><span class="p">;</span><span class="k">using</span><span class="p">(</span><span class="kt">var</span><span class="n">file</span><span class="p">=</span><span class="n">File</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span><span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">))</span><span class="p">{</span><span class="n">bytesRead</span><span class="p">=</span><span class="n">file</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="n">firstBytes</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">2</span><span class="p">);</span><span class="p">}</span><span class="k">return</span><span class="n">bytesRead</span><span class="p">==</span><span class="m">2</span><span class="p">&amp;&amp;</span><span class="n">firstBytes</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="p">==</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'M'</span><span class="p">&amp;&amp;</span><span class="n">firstBytes</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="p">==</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'Z'</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>They will instead write something like:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="kt">bool</span><span class="nf">MightBeExe</span><span class="p">(</span><span class="kt">string</span><span class="n">filePath</span><span class="p">)</span><span class="p">{</span><span class="k">using</span><span class="p">(</span><span class="kt">var</span><span class="n">file</span><span class="p">=</span><span class="n">File</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span><span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">))</span><span class="p">{</span><span class="kt">var</span><span class="n">firstBytes</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[</span><span class="m">2</span><span class="p">];</span><span class="kt">var</span><span class="n">bytesRead</span><span class="p">=</span><span class="n">file</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="n">firstBytes</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">2</span><span class="p">);</span><span class="k">return</span><span class="n">bytesRead</span><span class="p">==</span><span class="m">2</span><span class="p">&amp;&amp;</span><span class="n">firstBytes</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="p">==</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'M'</span><span class="p">&amp;&amp;</span><span class="n">firstBytes</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="p">==</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'Z'</span><span class="p">;</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>Which is a perfect candidate for <code class="highlighter-rouge">using var</code>:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="kt">bool</span><span class="nf">MightBeExe</span><span class="p">(</span><span class="kt">string</span><span class="n">filePath</span><span class="p">)</span><span class="p">{</span><span class="k">using</span><span class="nn">var</span><span class="n">file</span><span class="p">=</span><span class="n">File</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span><span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">);</span><span class="kt">var</span><span class="n">firstBytes</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[</span><span class="m">2</span><span class="p">];</span><span class="kt">var</span><span class="n">bytesRead</span><span class="p">=</span><span class="n">file</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="n">firstBytes</span><span class="p">,</span><span class="m">0</span><span class="p">,</span><span class="m">2</span><span class="p">);</span><span class="k">return</span><span class="n">bytesRead</span><span class="p">==</span><span class="m">2</span><span class="p">&amp;&amp;</span><span class="n">firstBytes</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="p">==</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'M'</span><span class="p">&amp;&amp;</span><span class="n">firstBytes</span><span class="p">[</span><span class="m">1</span><span class="p">]</span><span class="p">==</span><span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">'Z'</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>There are of course some reasonable limitations to this feature. For example,
it cannot be combined with out-variables.</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">Crypto32</span><span class="p">.</span><span class="nf">CryptEncodeObjectEx</span><span class="p">(</span><span class="c1">// other stuff</span><span class="k">out</span><span class="kt">var</span><span class="n">handle</span><span class="p">,</span><span class="k">ref</span><span class="n">size</span><span class="p">)</span><span class="p">)</span><span class="p">{</span><span class="k">using</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span><span class="p">{</span><span class="c1">// Do stuff</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>This does not work:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">Crypto32</span><span class="p">.</span><span class="nf">CryptEncodeObjectEx</span><span class="p">(</span><span class="c1">// other stuff</span><span class="k">out</span><span class="k">using</span><span class="nn">var</span><span class="n">handle</span><span class="p">,</span><span class="k">ref</span><span class="n">size</span><span class="p">)</span><span class="p">)</span><span class="p">{</span><span class="c1">// Do stuff</span><span class="p">}</span></code></pre></div></div><p>Jared Parsons said <a href="https://twitter.com/jaredpar/status/1088832515861663744">on Twitter</a> that C# folks thought of this, and decided
that it had “Too much confusion about ownership.” Thinking about it myself, I
agree, so it’s nice that the feature is limited in that regard.</p><p>Another limitation is that the variable cannot be reassigned. For example:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span><span class="nn">var</span><span class="n">stream</span><span class="p">=</span><span class="n">entry</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span><span class="n">stream</span><span class="p">=</span><span class="n">entry2</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span></code></pre></div></div><p>This will produce error CS1656, “Cannot assign to ‘stream’ because it is a
‘using variable’”.</p><p>All in all, I very much like this small feature in C# 8. It has reasonable guard
rails on it from doing something too weird like re-assigning to it, while giving
the benefit of less blocks, braces, indentation.</p></li><li><span class="post-meta">Oct 23, 2018</span><p>.NET Core 3.0 is tentatively <a href="https://apisof.net/catalog/System.Security.Cryptography.RandomNumberGenerator.GetInt32(Int32,Int32)">set to include</a> a new API for <em>securely</em>
generating a random integer bound to a specific range.</p><p>I won’t be shy in admitting that it was something <a href="https://github.com/dotnet/corefx/issues/30873">I pushed for</a> and made the
initial attempt <a href="https://github.com/dotnet/corefx/pull/31243">at implementing</a>, though it’s unfair to say that I
implemented it by myself given all of the outstanding feedback I got on the
initial pull request (thanks Levi and Jeremy!)</p><p>It’s been known for a while that <code class="highlighter-rouge">System.Random</code> shouldn’t be used when
cryptographic randomness is required. Despite that, there wasn’t anything built
in to .NET that made creating bounded random integers easy. You could either
use <code class="highlighter-rouge">System.Random</code> and hope for the best, or use a CSPRNG like
<code class="highlighter-rouge">RandomNumberGenerator</code> that gave back raw bytes, which requires some thought on
how to to properly convert it to a random integer without introducing any kind
of bias.</p><p>Starting in .NET Core 3.0, you’ll be able to do:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">min</span><span class="p">=</span><span class="m">1</span><span class="p">;</span><span class="kt">var</span><span class="n">max</span><span class="p">=</span><span class="m">1</span><span class="n">_000</span><span class="p">;</span><span class="kt">var</span><span class="n">randomNumber</span><span class="p">=</span><span class="n">RandomNumberGenerator</span><span class="p">.</span><span class="nf">GetInt32</span><span class="p">(</span><span class="n">min</span><span class="p">,</span><span class="n">max</span><span class="p">);</span></code></pre></div></div><p>If you need this before .NET Core 3, well, <a href="https://github.com/dotnet/corefx/pull/31243">the source</a> is right there. It
can be adapted with a bit of effort to work on the .NET Framework as well as other
environments that don’t have <code class="highlighter-rouge">Span&lt;T&gt;</code>.</p></li></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>