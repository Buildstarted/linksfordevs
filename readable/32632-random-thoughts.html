<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Random Thoughts -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Random Thoughts</h1>
    <div class="wrapper"> <p class="home"> <ul class="post-list"> <li> <p>One of the nice things about .NET Core being open source is following along with
some of the issues that people report. I tend to keep an eye on System.Security
tagged issues, since those tend to be at the intersection of things that
interest me and things I can maybe help with.</p> <p>A user <a href="https://github.com/dotnet/corefx/issues/34202">filed an issue</a> where .NET Framework considered a CMS valid, and .NET
Core did not. This didn&#x2019;t entirely surprise me. In the .NET Framework, the
<code class="highlighter-rouge">SignedCms</code> class is heavily backed by Windows&#x2019; handling of CMS/PKCS#7. In .NET
Core, the implementation is managed (sans the cryptography). The managed
implementation adheres somewhat strictly to the CMS specification. As other issues
have noticed, Windows&#x2019;, thus .NET Framework&#x2019;s, implementation was a little more
relaxed in some ways.</p> <p>This turned out not to be one of those cases. The CMS part was actually working
just fine. What as failing was RSA itself. The core of the issue was that
different implementations of RSA disagreed on the RSA signature&#x2019;s validity.</p> <p>That seems pretty strange!</p> <p>When I talk about different implementations on Windows, I am usually referring
to CAPI vs CNG, or <code class="highlighter-rouge">RSACryptoServiceProvider</code> and <code class="highlighter-rouge">RSACng</code>, respectively. For
now, I&#x2019;m keeping this post to the .NET Framework. We&#x2019;ll bring .NET Core in to
the discussion later.</p> <p>There are two implementations because, well, Windows has two of them. CNG, or
&#x201C;Cryptography API: Next Generation&#x201D; is the newer of the two and is intended to
be future of cryptographic primitives on Windows. It shipped in Windows Vista,
and offers functionality that CAPI cannot do. An example of that is PSS RSA
signatures.</p> <p>.NET Framework exposes these implementations as <code class="highlighter-rouge">RSACryptoServiceProvider</code> and
<code class="highlighter-rouge">RSACng</code>. They <em>should</em> be interchangable, and CNG implementations should be
used going forward. However, there is one corner case where the old, CAPI
implementation considers a signature valid while the CNG one does not.</p> <p>The issue can be demonstrated like so:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="p">[]</span> <span class="n">n</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="kt">byte</span><span class="p">[]</span> <span class="n">e</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="kt">byte</span><span class="p">[]</span> <span class="n">signature</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="kt">var</span> <span class="n">digest</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="m">0x68</span><span class="p">,</span> <span class="m">0xB4</span><span class="p">,</span> <span class="m">0xF9</span><span class="p">,</span> <span class="m">0x26</span><span class="p">,</span> <span class="m">0x34</span><span class="p">,</span> <span class="m">0x31</span><span class="p">,</span> <span class="m">0x25</span><span class="p">,</span> <span class="m">0xDD</span><span class="p">,</span> <span class="m">0x26</span><span class="p">,</span> <span class="m">0x50</span><span class="p">,</span> <span class="m">0x13</span><span class="p">,</span> <span class="m">0x68</span><span class="p">,</span> <span class="m">0xC1</span><span class="p">,</span> <span class="m">0x99</span><span class="p">,</span> <span class="m">0x26</span><span class="p">,</span> <span class="m">0x71</span><span class="p">,</span> <span class="m">0x19</span><span class="p">,</span> <span class="m">0xA2</span><span class="p">,</span> <span class="m">0xDE</span><span class="p">,</span> <span class="m">0x81</span><span class="p">,</span> <span class="p">};</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">rsa</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RSACng</span><span class="p">())</span>
<span class="p">{</span> <span class="n">rsa</span><span class="p">.</span><span class="nf">ImportParameters</span><span class="p">(</span><span class="k">new</span> <span class="n">RSAParameters</span> <span class="p">{</span> <span class="n">Modulus</span> <span class="p">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">Exponent</span> <span class="p">=</span> <span class="n">e</span> <span class="p">});</span> <span class="kt">var</span> <span class="n">valid</span> <span class="p">=</span> <span class="n">rsa</span><span class="p">.</span><span class="nf">VerifyHash</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">HashAlgorithmName</span><span class="p">.</span><span class="n">SHA1</span><span class="p">,</span> <span class="n">RSASignaturePadding</span><span class="p">.</span><span class="n">Pkcs1</span><span class="p">);</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">valid</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">rsa</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RSACryptoServiceProvider</span><span class="p">())</span>
<span class="p">{</span> <span class="n">rsa</span><span class="p">.</span><span class="nf">ImportParameters</span><span class="p">(</span><span class="k">new</span> <span class="n">RSAParameters</span> <span class="p">{</span> <span class="n">Modulus</span> <span class="p">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">Exponent</span> <span class="p">=</span> <span class="n">e</span> <span class="p">});</span> <span class="kt">var</span> <span class="n">valid</span> <span class="p">=</span> <span class="n">rsa</span><span class="p">.</span><span class="nf">VerifyHash</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">HashAlgorithmName</span><span class="p">.</span><span class="n">SHA1</span><span class="p">,</span> <span class="n">RSASignaturePadding</span><span class="p">.</span><span class="n">Pkcs1</span><span class="p">);</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">valid</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <aside>
<p>Note: to avoid bloating this blog post with large signatures and RSA
keys, I omitted them. However the full example with public keys is available
<a href="https://gist.github.com/vcsjones/ab4c2327b53ed018eada76b75ef4fd99">
on GitHub here</a>.
</p>
</aside> <p>When used with one of the curious signatures that exhibits this behavior, such
as the one in the GitHub link, the first result will be false, and the second
will be true.</p> <p>Nothing jumped out at me as being problematic. The signature padding is PKCS,
the public exponent is the very typical 67,537, and the RSA key is sensible in
size.</p> <p>To make it stranger, this signature came off the timestamp of Firefox&#x2019;s own
signed installer. So why are the results different?</p> <p>Jeremy Barton from Microsoft on .NET Core made the observation that the padding
in the RSA signature itself is incorrect, but in a way that CAPI tollerates and
CNG does not, at least by default. Let&#x2019;s look at the raw signature. To do that,
we need the public key and signature on disk, and we can poke at them with OpenSSL.</p> <p>Using the command:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl rsautl <span class="nt">-verify</span> <span class="nt">-in</span> sig.bin <span class="nt">-inkey</span> key.der <span class="se">\</span> <span class="nt">-pubin</span> <span class="nt">-hexdump</span> <span class="nt">-raw</span> <span class="nt">-keyform</span> der
</code></pre></div></div> <p>We get the following output:</p> <pre>
0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00e0 - ff ff ff ff ff ff ff ff-ff ff ff 00 68 b4 f9 26
00f0 - 34 31 25 dd 26 50 13 68-c1 99 26 71 19 a2 de 81
</pre> <p>This is a PKCS#1 v1.5 padded signature, as indicated by by starting with 00 01.
The digest at the end can be seen, <code class="highlighter-rouge">68 b4 f9 26 ... 19 a2 de 81</code> which matches
the digest above, so we know that the signature is for the right digest.</p> <p>What is not correct in this signature is how the digest is encoded. The signature
contains the bare digest. It <em>should</em> be encoded as an ASN.1 sequence along
with the AlgorithmIdentifer of the digest:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DigestInfo ::= SEQUENCE {
	digestAlgorithm AlgorithmIdentifier,
	digest OCTET STRING
}
</code></pre></div></div> <p>This goes back all the way to <a href="ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-1.asc">a document</a> (warning: link is to an ftp:// site)
written in 1993 by RSA labratories explaining how PKCS#1 v1.5 works,and was
standardized in to <a href="https://tools.ietf.org/html/rfc2313">an RFC</a> in 1998.</p> <p>The RSA signature we have only contains the raw digest. It is not part of a
<code class="highlighter-rouge">DigestInfo</code>. If the digest were properly encoded, it would look something like
this:</p> <pre>
0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 21 30
00e0 - 09 06 05 2b 0e 03 02 1a-05 00 04 14 68 b4 f9 26
00f0 - 34 31 25 dd 26 50 13 68-c1 99 26 71 19 a2 de 81
</pre> <p>The signature now includes <code class="highlighter-rouge">DigestInfo</code> along with the OID 1.3.14.3.2.26 to
indicate that the digest is SHA1.</p> <p>At this point we know what the difference is, and the original specification in
part 10.1.2 makes it fairly clear that the &#x201C;data&#x201D; should be a digest and should
be encoded as DigestInfo, not a bare digest.</p> <p>The source of this signature is from Verisign&apos;s timestamp authority at
http://timestamp.verisign.com/&#x200B;scripts/&#x200B;timstamp.dll. After checking with
someone at DigiCert (now running this TSA), it was launched in May 1995.</p> <p>I suspect that the TSA is old enough that the implementation was made before the
specification was complete or simply got the specification wrong and no one
noticed. Bringing this back to CNG and CAPI, CNG can validate this signatures, but you
must explicitly tell CNG that the signature does not have an object identifier.
<a href="https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-_bcrypt_pkcs1_padding_info"><code class="highlighter-rouge">BCRYPT_PKCS1_PADDING_INFO</code>&#x2019;s</a> documentation has the detail there, but gist
of it is</p> <blockquote> <p>If there is no OID in the signature, then verification fails unless this
member is NULL.</p>
</blockquote> <p>This would be used with <code class="highlighter-rouge">{B,N}CryptVerifySignature</code>. To bring this back around
to the .NET Framework, how do we use <code class="highlighter-rouge">RSACng</code> and give <code class="highlighter-rouge">null</code> in for the
padding algorithm? The short answer is: you cannot. If you try, you will get
an explicit <code class="highlighter-rouge">ArgumentException</code> saying that the hash algorithm name cannot be
null.</p> <p>For .NET Framework, this solution &#x201C;keep using <code class="highlighter-rouge">RSACryptoServiceProvider</code>&#x201D;. If
you need to validate these signatures, chances are you do not need to use CNG&#x2019;s
newer capabilities like PSS since these malformed signatures appear to be coming
from old systems. Higher level things like <code class="highlighter-rouge">SignedCms</code> and <code class="highlighter-rouge">SignedXml</code> use
<code class="highlighter-rouge">RSACryptoServiceProvider</code> by default, so they will continue to work.</p> <p>To bring in .NET Core, the situation is a little more difficult. If you are
using <code class="highlighter-rouge">SignedCms</code> like so:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">signedCms</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SignedCms</span><span class="p">();</span>
<span class="n">signedCms</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="n">File</span><span class="p">.</span><span class="nf">ReadAllBytes</span><span class="p">(</span><span class="s">&quot;cms-with-sig.bin&quot;</span><span class="p">));</span>
<span class="n">signedCms</span><span class="p">.</span><span class="nf">CheckSignature</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
</code></pre></div></div> <p>This will start throwing when you migrate to .NET Core. .NET Core will use CNG
when run on Windows to validate RSA signatures for <code class="highlighter-rouge">SignedCms</code> and <code class="highlighter-rouge">SignedXml</code>.
This is currently not configurable, either. When used with <code class="highlighter-rouge">SignedCms</code>, it
ultimately calls the <code class="highlighter-rouge">X509Certificate2.GetRSAPublicKey()</code> extension method,
and that will <a href="https://github.com/dotnet/corefx/blob/b26339b6f6c7537875c70b5f3c8af376d0bbded5/src/System.Security.Cryptography.X509Certificates/src/Internal/Cryptography/Pal.Windows/X509Pal.PublicKey.cs#L43">always</a> return an implementation based on CNG.</p> <p>If you are using <code class="highlighter-rouge">SignedCms</code> on .NET Core and need to validate a CMS that is
signed with these problematic signatures, you are currently out of luck using
in-the-box components. As far as other platforms go, both macOS and Linux
environments for .NET Core will agree with CNG - that the signature is invalid.</p> <p>The good news is, these signatures are not easy to come by. So far, only the
old Verisign timestamp authority is known to have produced signatures like this.</p> </li> <li> <p>Since C# 7 there have been a lot of point releases that contain all kinds of
goodies. Many of them are performance focused, such as safe stack allocations
using <code class="highlighter-rouge">Span&lt;T&gt;</code>, or interoperability with improvements to <code class="highlighter-rouge">fixed</code>.</p> <p>One that I love, but is not documented well, is some special treatment
that <code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code> gets when its contents are known at compile time.</p> <p>Here&#x2019;s an example of a lookup table I used to aide with hex encoding that uses
a <code class="highlighter-rouge">byte[]</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="kt">byte</span><span class="p">[]</span> <span class="n">LookupTable</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;0&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;1&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;2&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;3&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;4&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;5&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;6&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;7&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;8&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;9&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;A&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;B&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;C&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;D&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;E&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;F&apos;</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div> <p>This binary data has to get stored <em>somewhere</em> in our produced library. If we
use <code class="highlighter-rouge">dumpbin</code> we can see it in the .text section of the binary.</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dumpbin /RAWDATA /SECTION:.text mylib.dll
</code></pre></div></div> <p>Right at the bottom, we see:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00402A40: 30 31 32 33 34 35 36 37 38 39 41 42 43 44 45 46  0123456789ABCDEF
</code></pre></div></div> <p>I won&#x2019;t go into the a lot of the details on how this data is compiled into the
<code class="highlighter-rouge">.text</code> section, but at this point we need to get that data into the array
somehow.</p> <p>If we look at the jit assembly of <code class="highlighter-rouge">LookupTable</code>, we see:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sub rsp, 0x28
vzeroupper
mov rcx, 0x7ffc4638746a
mov edx, 0x10
call 0x7ffc49b52630
mov rdx, 0x1b51450099c
lea rcx, [rax+0x10]
vmovdqu xmm0, [rdx]
vmovdqu [rcx], xmm0
add rsp, 0x28
ret
</code></pre></div></div> <p>Where <code class="highlighter-rouge">0x7ffc49b52630</code> is <code class="highlighter-rouge">InitializeArray</code>.</p> <p>With an array, our property leans on <code class="highlighter-rouge">InitializeArray</code>, the source of which is
<a href="https://github.com/dotnet/coreclr/blob/a28b25aacdcd2adb0fdfa70bd869f53ba6565976/src/classlibnative/bcltype/arraynative.cpp#L1377">in the CoreCLR</a>. For little-endian platforms, it boils down to a <code class="highlighter-rouge">memcpy</code>
from a runtime field handle.</p> <p>Indeed, with a debugger we finally see:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00007ffd`b18b701a e831a40e00       call    coreclr!memcpy (00007ffd`b19a1450)
</code></pre></div></div> <p>Dumping <code class="highlighter-rouge">@rdx L10</code> yields:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000001f0`4c552a90  30 31 32 33 34 35 36 37-38 39 41 42 43 44 45 46  0123456789ABCDEF
</code></pre></div></div> <p>So that was a very long-winded way of saying that when using arrays, initializing
a field or variable with bytes results in <code class="highlighter-rouge">memcpy</code> from the image into the array,
which results in more data on the heap.</p> <p>Now, starting in 7.3, we can avoid that <code class="highlighter-rouge">memcpy</code> when using <code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code>.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;</span> <span class="n">LookupTable</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;0&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;1&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;2&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;3&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;4&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;5&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;6&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;7&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;8&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;9&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;A&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;B&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;C&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;D&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;E&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;F&apos;</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div> <p>Looking at the jit assembly:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov eax, 0x10
xor edx, edx
mov r8, 0x1b5144c0968
mov [rcx], rdx
mov [rcx+0x8], r8
mov [rcx+0x10], eax
mov rax, rcx
ret
</code></pre></div></div> <p>We see that there is <code class="highlighter-rouge">mov r8, 0x1b5144c0968</code>. The contents of <code class="highlighter-rouge">0x1b5144c0968</code>
are:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000001b5`144c0968  30 31 32 33 34 35 36 37-38 39 41 42 43 44 45 46  0123456789ABCDEF
</code></pre></div></div> <p>So we see that the method is now returning the data directly and
omitting the <code class="highlighter-rouge">memcpy</code> entirely, so our <code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code> is pointing directly
to the <code class="highlighter-rouge">.text</code> section.</p> <p>This works for property getters as shown above, but also as the return of a
method:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;</span> <span class="nf">GetBytes</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p>Which works similar to the getter of the property. In addition, this also works
for locals in a method body as well:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">Write200Ok</span><span class="p">(</span><span class="n">Stream</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">ReadOnlySpan</span><span class="p">&lt;</span><span class="kt">byte</span><span class="p">&gt;</span> <span class="n">data</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[]</span> <span class="p">{</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;H&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;T&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;T&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;P&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;/&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;1&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;.&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;1&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos; &apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;2&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;0&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;0&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos; &apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;O&apos;</span><span class="p">,</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;K&apos;</span> <span class="p">};</span> <span class="n">s</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Which also produces a reasonable JIT disassembly:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sub     rsp, 0x38
xor     eax, eax
mov     qword ptr [rsp+0x28], rax
mov     qword ptr [rsp+0x30], rax
mov     rcx, 0x1e595b42ade
mov     eax, 0x0F
lea     r8, [rsp+0x28]
mov     qword ptr [r8], rcx
mov     dword ptr [r8+8], eax
mov     rcx, rdx
lea     rdx, [rsp+0x28]
cmp     dword ptr [rcx], ecx
call    0x7ff89ede10c8 (Stream.Write(System.ReadOnlySpan`1&lt;Byte&gt;), mdToken: 0000000006000001)
add     rsp, 0x38
ret
</code></pre></div></div> <p>Here we see <code class="highlighter-rouge">mov rcx, 0x1e595b42ade</code> which moves the address of the static data directly in to the register with no additional work to create a byte array.</p> <p>These optimizations currently only works with <code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code> right now.
Other types will continue to use <code class="highlighter-rouge">InitializeArray</code> due to needing to handle
different platforms and how they handle endianness.</p> </li> <li> <p>Visual Studio 2019 preview 2 was released a few days ago and I took the time
to install it. Visual Studio itself is actually rather uninteresting to me,
however the inclusion of the next C# 8 preview got my attention. I glanced at
the feature highlights and posted &#x201C;looks nice&#x201D; on Twitter.</p> <p>Predictably, I got a few responses like &#x201C;I&#x2019;m not sure I like that&#x201D;, and there is
always a guarantee that if F# has a similar feature, an F# developer will appear
and tell you F# has had this feature for 600 years.</p> <p>The one I like a lot is using declarations. This allows a local to automatically
be disposed at the end of the block. Essentially, it hides the <code class="highlighter-rouge">try</code>/<code class="highlighter-rouge">finally</code>
or the <code class="highlighter-rouge">using() {...}</code>. The .NET team&#x2019;s blog kind of gave a bad example of this,
so I&#x2019;ll use one from <a href="https://github.com/vcsjones/FiddlerCert">Open OPC SignTool</a>. Here is the original snippet:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="n">X509Certificate2</span> <span class="nf">GetCertificateFromCertificateStore</span><span class="p">(</span><span class="kt">string</span> <span class="n">sha1</span><span class="p">)</span>
<span class="p">{</span> <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">store</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">X509Store</span><span class="p">(</span><span class="n">StoreName</span><span class="p">.</span><span class="n">My</span><span class="p">,</span> <span class="n">StoreLocation</span><span class="p">.</span><span class="n">LocalMachine</span><span class="p">))</span> <span class="p">{</span> <span class="n">store</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">OpenFlags</span><span class="p">.</span><span class="n">OpenExistingOnly</span> <span class="p">|</span> <span class="n">OpenFlags</span><span class="p">.</span><span class="n">ReadOnly</span><span class="p">);</span> <span class="kt">var</span> <span class="n">certificates</span> <span class="p">=</span> <span class="n">store</span><span class="p">.</span><span class="n">Certificates</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="n">X509FindType</span><span class="p">.</span><span class="n">FindByThumbprint</span><span class="p">,</span> <span class="n">sha1</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span> <span class="k">return</span> <span class="n">certificates</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">?</span> <span class="n">certificates</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">:</span> <span class="k">null</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>A <code class="highlighter-rouge">using var</code> can make this:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="n">X509Certificate2</span> <span class="nf">GetCertificateFromCertificateStore</span><span class="p">(</span><span class="kt">string</span> <span class="n">sha1</span><span class="p">)</span>
<span class="p">{</span> <span class="k">using</span> <span class="nn">var</span> <span class="n">store</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">X509Store</span><span class="p">(</span><span class="n">StoreName</span><span class="p">.</span><span class="n">My</span><span class="p">,</span> <span class="n">StoreLocation</span><span class="p">.</span><span class="n">LocalMachine</span><span class="p">);</span> <span class="n">store</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">OpenFlags</span><span class="p">.</span><span class="n">OpenExistingOnly</span> <span class="p">|</span> <span class="n">OpenFlags</span><span class="p">.</span><span class="n">ReadOnly</span><span class="p">);</span> <span class="kt">var</span> <span class="n">certificates</span> <span class="p">=</span> <span class="n">store</span><span class="p">.</span><span class="n">Certificates</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="n">X509FindType</span><span class="p">.</span><span class="n">FindByThumbprint</span><span class="p">,</span> <span class="n">sha1</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span> <span class="k">return</span> <span class="n">certificates</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">?</span> <span class="n">certificates</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">:</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This has the same effect of <code class="highlighter-rouge">store</code> having <code class="highlighter-rouge">Dispose</code> called on it at the end of
the method. The benefit here being that there is less indentation and braces.
This keeps me focused on the code that matters. I don&#x2019;t care when <code class="highlighter-rouge">store</code> is
disposed in the method, I can just observe that it has a <code class="highlighter-rouge">using</code> modifier on the
local and be assured that <code class="highlighter-rouge">Dispose</code> will be called.</p> <p>This isn&#x2019;t the same as garbage collection or finalizers. Both of those are non-
deterministic, and can lead to unexpected program behavior. That&#x2019;s less so in
the case of <code class="highlighter-rouge">X509Store</code>, so let&#x2019;s look at another example:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">Stream</span> <span class="n">stream</span> <span class="p">=</span> <span class="n">entry</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">xmlDocument</span> <span class="p">=</span> <span class="n">XDocument</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">LoadOptions</span><span class="p">.</span><span class="n">PreserveWhitespace</span><span class="p">);</span>
<span class="k">return</span> <span class="k">new</span> <span class="nf">OpcRelationships</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">xmlDocument</span><span class="p">,</span> <span class="n">readOnlyMode</span><span class="p">);</span>
</code></pre></div></div> <p>Not disposing a stream that is backed by a file can cause access errors later in
software that might try to open that file again - it is already open, so not
only is it a bad idea it leave streams to the GC, it is just simply incorrect.</p> <p>However again <code class="highlighter-rouge">using</code> on the local ensures it is deterministically closed.</p> <p><em>When</em> it gets disposed I can see being slightly unclear to the developer. The
quick explanation is when the local is no longer reachable, not when it is last
used. The C# 8 above gets compiled roughly to:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="n">entry</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span>
<span class="k">try</span>
<span class="p">{</span> <span class="kt">var</span> <span class="n">xmlDocument</span> <span class="p">=</span> <span class="n">XDocument</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">LoadOptions</span><span class="p">.</span><span class="n">PreserveWhitespace</span><span class="p">);</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">OpcRelationships</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">xmlDocument</span><span class="p">,</span> <span class="n">readOnlyMode</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">finally</span>
<span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">stream</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="p">((</span><span class="n">IDisposable</span><span class="p">)</span><span class="n">stream</span><span class="p">).</span><span class="nf">Dispose</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The disposal is done after the return, when the local is no longer reachable,
not after <code class="highlighter-rouge">XDocument</code> is created.</p> <p>I find this very helpful to keep code readable. This doesn&#x2019;t work when you need
fine control over when <code class="highlighter-rouge">Dispose</code> is called. A place where this does not work
well is when the <code class="highlighter-rouge">Dispose</code> pattern is used for scopes, such as logging. The
AzureSignTool project has code similar to this in <code class="highlighter-rouge">SignCommand</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">logger</span> <span class="p">=</span> <span class="n">loggerFactory</span><span class="p">.</span><span class="n">CreateLogger</span><span class="p">&lt;</span><span class="n">SignCommand</span><span class="p">&gt;();</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">ForEach</span><span class="p">(</span><span class="n">AllFiles</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">succeeded</span><span class="p">:</span> <span class="m">0</span><span class="p">,</span> <span class="n">failed</span><span class="p">:</span> <span class="m">0</span><span class="p">),</span> <span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="n">pls</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span> <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">loopScope</span> <span class="p">=</span> <span class="n">logger</span><span class="p">.</span><span class="nf">BeginScope</span><span class="p">(</span><span class="s">&quot;File: {Id}&quot;</span><span class="p">,</span> <span class="n">filePath</span><span class="p">))</span> <span class="p">{</span> <span class="n">logger</span><span class="p">.</span><span class="nf">LogInformation</span><span class="p">(</span><span class="s">&quot;Signing file.&quot;</span><span class="p">);</span> <span class="c1">//Sign the file. omit a bunch of other code.</span> <span class="n">logger</span><span class="p">.</span><span class="nf">LogInformation</span><span class="p">(</span><span class="s">&quot;Done signing the file.&quot;</span><span class="p">);</span> <span class="p">}</span> <span class="n">logger</span><span class="p">.</span><span class="nf">LogDebug</span><span class="p">(</span><span class="s">&quot;Incrementing success count.&quot;</span><span class="p">);</span> <span class="k">return</span> <span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">succeeded</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">state</span><span class="p">.</span><span class="n">failed</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Here, we cannot change this to a <code class="highlighter-rouge">using var</code> because then the <code class="highlighter-rouge">LogDebug</code> would
be inside of that logging scope, which it wasn&#x2019;t before. This is a place where
we continue to want <code class="highlighter-rouge">Dispose</code> to be called at a different time from the when
<code class="highlighter-rouge">loopScope</code> would no longer be in scope.</p> <p>My impression from C# developers is that they do not tend to call <code class="highlighter-rouge">Dispose</code> on resources as soon as it can be disposed, just at a reasonable point in the
same method. Most developers do not write this code:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">MightBeExe</span><span class="p">(</span><span class="kt">string</span> <span class="n">filePath</span><span class="p">)</span>
<span class="p">{</span> <span class="kt">var</span> <span class="n">firstBytes</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="m">2</span><span class="p">];</span> <span class="kt">int</span> <span class="n">bytesRead</span><span class="p">;</span> <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">file</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">))</span> <span class="p">{</span> <span class="n">bytesRead</span> <span class="p">=</span> <span class="n">file</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="n">firstBytes</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span> <span class="p">}</span> <span class="k">return</span> <span class="n">bytesRead</span> <span class="p">==</span> <span class="m">2</span> <span class="p">&amp;&amp;</span> <span class="n">firstBytes</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">==</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;M&apos;</span> <span class="p">&amp;&amp;</span> <span class="n">firstBytes</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">==</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;Z&apos;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>They will instead write something like:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">MightBeExe</span><span class="p">(</span><span class="kt">string</span> <span class="n">filePath</span><span class="p">)</span>
<span class="p">{</span> <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">file</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">))</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">firstBytes</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="m">2</span><span class="p">];</span> <span class="kt">var</span> <span class="n">bytesRead</span> <span class="p">=</span> <span class="n">file</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="n">firstBytes</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span> <span class="k">return</span> <span class="n">bytesRead</span> <span class="p">==</span> <span class="m">2</span> <span class="p">&amp;&amp;</span> <span class="n">firstBytes</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">==</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;M&apos;</span> <span class="p">&amp;&amp;</span> <span class="n">firstBytes</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">==</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;Z&apos;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Which is a perfect candidate for <code class="highlighter-rouge">using var</code>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="kt">bool</span> <span class="nf">MightBeExe</span><span class="p">(</span><span class="kt">string</span> <span class="n">filePath</span><span class="p">)</span>
<span class="p">{</span> <span class="k">using</span> <span class="nn">var</span> <span class="n">file</span> <span class="p">=</span> <span class="n">File</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">);</span> <span class="kt">var</span> <span class="n">firstBytes</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="m">2</span><span class="p">];</span> <span class="kt">var</span> <span class="n">bytesRead</span> <span class="p">=</span> <span class="n">file</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="n">firstBytes</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">2</span><span class="p">);</span> <span class="k">return</span> <span class="n">bytesRead</span> <span class="p">==</span> <span class="m">2</span> <span class="p">&amp;&amp;</span> <span class="n">firstBytes</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">==</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;M&apos;</span> <span class="p">&amp;&amp;</span> <span class="n">firstBytes</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">==</span> <span class="p">(</span><span class="kt">byte</span><span class="p">)</span><span class="sc">&apos;Z&apos;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>There are of course some reasonable limitations to this feature. For example,
it cannot be combined with out-variables.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">Crypto32</span><span class="p">.</span><span class="nf">CryptEncodeObjectEx</span><span class="p">(</span> <span class="c1">// other stuff</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">handle</span><span class="p">,</span> <span class="k">ref</span> <span class="n">size</span><span class="p">)</span>
<span class="p">)</span>
<span class="p">{</span> <span class="k">using</span> <span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Do stuff</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This does not work:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">Crypto32</span><span class="p">.</span><span class="nf">CryptEncodeObjectEx</span><span class="p">(</span> <span class="c1">// other stuff</span> <span class="k">out</span> <span class="k">using</span> <span class="nn">var</span> <span class="n">handle</span><span class="p">,</span> <span class="k">ref</span> <span class="n">size</span><span class="p">)</span>
<span class="p">)</span>
<span class="p">{</span> <span class="c1">// Do stuff</span>
<span class="p">}</span>
</code></pre></div></div> <p>Jared Parsons said <a href="https://twitter.com/jaredpar/status/1088832515861663744">on Twitter</a> that C# folks thought of this, and decided
that it had &#x201C;Too much confusion about ownership.&#x201D; Thinking about it myself, I
agree, so it&#x2019;s nice that the feature is limited in that regard.</p> <p>Another limitation is that the variable cannot be reassigned. For example:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">var</span> <span class="n">stream</span> <span class="p">=</span> <span class="n">entry</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span>
<span class="n">stream</span> <span class="p">=</span> <span class="n">entry2</span><span class="p">.</span><span class="nf">Open</span><span class="p">();</span>
</code></pre></div></div> <p>This will produce error CS1656, &#x201C;Cannot assign to &#x2018;stream&#x2019; because it is a
&#x2018;using variable&#x2019;&#x201D;.</p> <p>All in all, I very much like this small feature in C# 8. It has reasonable guard
rails on it from doing something too weird like re-assigning to it, while giving
the benefit of less blocks, braces, indentation.</p> </li> <li> <p>.NET Core 3.0 is tentatively <a href="https://apisof.net/catalog/System.Security.Cryptography.RandomNumberGenerator.GetInt32(Int32,Int32)">set to include</a> a new API for <em>securely</em>
generating a random integer bound to a specific range.</p> <p>I won&#x2019;t be shy in admitting that it was something <a href="https://github.com/dotnet/corefx/issues/30873">I pushed for</a> and made the
initial attempt <a href="https://github.com/dotnet/corefx/pull/31243">at implementing</a>, though it&#x2019;s unfair to say that I
implemented it by myself given all of the outstanding feedback I got on the
initial pull request (thanks Levi and Jeremy!)</p> <p>It&#x2019;s been known for a while that <code class="highlighter-rouge">System.Random</code> shouldn&#x2019;t be used when
cryptographic randomness is required. Despite that, there wasn&#x2019;t anything built
in to .NET that made creating bounded random integers easy. You could either
use <code class="highlighter-rouge">System.Random</code> and hope for the best, or use a CSPRNG like
<code class="highlighter-rouge">RandomNumberGenerator</code> that gave back raw bytes, which requires some thought on
how to to properly convert it to a random integer without introducing any kind
of bias.</p> <p>Starting in .NET Core 3.0, you&#x2019;ll be able to do:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">min</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">max</span> <span class="p">=</span> <span class="m">1</span><span class="n">_000</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">randomNumber</span> <span class="p">=</span> <span class="n">RandomNumberGenerator</span><span class="p">.</span><span class="nf">GetInt32</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">);</span>
</code></pre></div></div> <p>If you need this before .NET Core 3, well, <a href="https://github.com/dotnet/corefx/pull/31243">the source</a> is right there. It
can be adapted with a bit of effort to work on the .NET Framework as well as other
environments that don&#x2019;t have <code class="highlighter-rouge">Span&lt;T&gt;</code>.</p> </li> <li> <p>.NET Core introduced <a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.cryptographicoperations.fixedtimeequals?view=netcore-2.1"><code class="highlighter-rouge">FixedTimeEquals</code></a> which I have personally found to be
very helpful. It&#x2019;s a small method, but given the kind of code I tend to write,
I was writing it a lot from project to project, and am happy to see it in the box.</p> <p>This API is meant to prevent a timing side-channel when comparing two sequences
of bytes. The goal is, the comparison should take the same amount of time regardless
of the contents of the bytes, assuming they are the same length. This is often
required when doing comparisons of MACs or simple possession demonstrations for
APIs.</p> <p>Consider you had a web API that required an API key and was implemented in such
a way that it just expected a magic string to act as a password to interact with
the API.</p> <p>It required an HTTP header, like</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X-Api-Key: SecretVooDooWord
</code></pre></div></div> <p>and TLS was used to ensure it was kept confidential in transit. The API did
a naive implementation like this:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[HttpGet]</span>
<span class="k">public</span> <span class="n">IActionResult</span> <span class="nf">SuperSensitiveApi</span><span class="p">()</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">key</span> <span class="p">=</span> <span class="n">Request</span><span class="p">.</span><span class="n">Headers</span><span class="p">[</span><span class="s">&quot;X-Api-Key&quot;</span><span class="p">].</span><span class="nf">Single</span><span class="p">();</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="p">!=</span> <span class="s">&quot;SecretVooDooWord&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">Unauthorized</span><span class="p">();</span> <span class="p">}</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">JsonResult</span><span class="p">(</span><span class="k">new</span> <span class="p">{</span> <span class="n">AllTheSecretData</span> <span class="p">=</span> <span class="s">&quot;tada&quot;</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <aside>
<p>
This is a very problematic design! A much better solution would be to use
something that is well defined and specified for API authentication like OIDC,
WS-*, however you want to accomplish it. At the very least, communicating raw
secrets is much less than ideal. Instead, a <em>proof of possession</em> or
challenge should be used. That still isn&apos;t enough to prevent replays and
a myriad of other things that are desirable in API authentication.
</p>
<p>
But let&apos;s focus on the timing side channel for now.
</p>
</aside> <p>The issue here is that neither <code class="highlighter-rouge">!=</code> or <code class="highlighter-rouge">==</code> are fixed-time, and will return false as
soon as there is an immediate difference. In pseudo code, it might look something
like this:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>compare(word1, word2) {
    if word1.length != word2.length
        return false
    i = 0
    while (i &lt; word1.length) {
        letter1 = word1[i]
        letter2 = word2[i]
        if letter1 != letter2
            return false
        else
            i = i + 1
    }
    return true
}
</code></pre></div></div> <p>This function will compare the letters one by one. As soon as it encounters a
difference, it returns false and doesn&#x2019;t bother checking the rest. Why should it?
The answer is going to be false every time.</p> <p>To an attacker that is trying to figure out the contents of the string, carefully
measuring the time can leak the contents of the string. For argument&#x2019;s sake,
let&#x2019;s say that checking each letter takes 2ns and the attacker has a very accurate
way of measuring time over a network and can account for jitter and latency.</p> <pre>
GET /SuperSensitiveApi HTTP/1.1
X-Api-Key: Raaaaaaaaaaaaaaa
</pre> <p>Checking the API key will take 2ns because the first letters do not match. The
attacker moves on to the next letter.</p> <pre>
GET /SuperSensitiveApi HTTP/1.1
X-Api-Key: Saaaaaaaaaaaaaaa
</pre> <p>This time, checking the API key takes 4ns because the first letter matched (2ns)
and the second failed (another 2ns)</p> <pre>
GET /SuperSensitiveApi HTTP/1.1
X-Api-Key: Sbaaaaaaaaaaaaaa
</pre> <p>Fails again taking 4ns to check the API key. After a few more tries&#x2026;</p> <pre>
GET /SuperSensitiveApi HTTP/1.1
X-Api-Key: Seaaaaaaaaaaaaaa
</pre> <p>This time it took 6ns to check the API key because the first and second letter
were checked, and the third failed.</p> <p>The attacker can keep doing this by observing the amount of time each call
takes. The longer it takes, the attacker can assume they have guessed the next
letter. In practice, this is extremely difficult to do over a network and to get
accurate enough timing information, but it is believed that it might be possible
given enough persistence and an adversary that has the means to be in a network
position that is very stable.</p> <p>These kinds of attacks do exist, an example timing side-channel is <a href="https://en.wikipedia.org/wiki/Lucky_Thirteen_attack">Lucky 13</a>,
which affected many library&#x2019;s approach to handling CBC padding in TLS.</p> <p>So <code class="highlighter-rouge">==</code> in C# is a bad way to check strings for equality where timing side
channels need to be mitigated. So you say, perhaps you&#x2019;ll do something like this:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">CheckStringsFixedTime</span><span class="p">(</span><span class="kt">string</span> <span class="n">str1</span><span class="p">,</span> <span class="kt">string</span> <span class="n">str2</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">str1</span><span class="p">.</span><span class="n">Length</span> <span class="p">!=</span> <span class="n">str2</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span> <span class="p">}</span> <span class="kt">var</span> <span class="n">allTheSame</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">str1</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span> <span class="n">allTheSame</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="k">return</span> <span class="n">allTheSame</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This <em>looks</em> like it&#x2019;s constant time, but on modern CPUs and .NET, it&#x2019;s not.
Branch statements, like <code class="highlighter-rouge">if</code>, have timing implications. We can&#x2019;t take a branch.</p> <p>OK, what about this?</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">CheckStringsFixedTime</span><span class="p">(</span><span class="kt">string</span> <span class="n">str1</span><span class="p">,</span> <span class="kt">string</span> <span class="n">str2</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">str1</span><span class="p">.</span><span class="n">Length</span> <span class="p">!=</span> <span class="n">str2</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span> <span class="p">}</span> <span class="kt">var</span> <span class="n">allTheSame</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">str1</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span> <span class="n">allTheSame</span> <span class="p">&amp;=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">==</span> <span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="k">return</span> <span class="n">allTheSame</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This looks somewhat promising for C#. We know from the language specification
that <code class="highlighter-rouge">&amp;=</code> does not short circuit, so <code class="highlighter-rouge">str1[i] == str2[i]</code> will always be
evaluated.</p> <p>We still have a few problems though, and this is where the JIT and x86 can make
things more complicated for us.</p> <p>The first issue is that <code class="highlighter-rouge">allTheSame</code> is a simple true/false flag. That still leaves
the .NET JIT and x86 instruction execution to make a few optimizations that
introduce timing attacks. Timing side channel mitigation should avoid all <em>decisions</em>
until the very end. <code class="highlighter-rouge">&amp;</code> is a decision. However, we can improve that some:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">CheckStringsFixedTime</span><span class="p">(</span><span class="kt">string</span> <span class="n">str1</span><span class="p">,</span> <span class="kt">string</span> <span class="n">str2</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">str1</span><span class="p">.</span><span class="n">Length</span> <span class="p">!=</span> <span class="n">str2</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span> <span class="p">}</span> <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">str1</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span> <span class="n">result</span> <span class="p">|=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">^</span> <span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="k">return</span> <span class="n">result</span> <span class="p">==</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is fairly close to being time-fixed. We update an integer using <code class="highlighter-rouge">|</code> to
combine the bits from the result of an XOR. XOR anything with itself, and the
the result is zero. Anything else, and you get a non-zero value. We use a binary
OR to combine any bits. At the end, if we have a non-zero value, we know one of
the comparison checks failed.</p> <p>There is some debate as to what arithmetic operators are better for fixed time
operations between <code class="highlighter-rouge">str1[x]</code> and <code class="highlighter-rouge">str2[x]</code>. Some implementations use XOR, like
above, other may use SUB for subtraction. Unfortunately, most CPU architectures
make no guarantee if any operations are constant-time.</p> <p>We <em>still</em> have a problem to address. The JIT could be making unintended
optimizations. The C# compiler itself makes very little optimizations. The JIT
on the other hand may do all sorts of things, like unroll a loop or make a variety
of optimizations so the code executes faster.</p> <p>We can tell the JIT to leave it alone, like so.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]</span>
<span class="k">private</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">CheckStringsFixedTime</span><span class="p">(</span><span class="kt">string</span> <span class="n">str1</span><span class="p">,</span> <span class="kt">string</span> <span class="n">str2</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">str1</span><span class="p">.</span><span class="n">Length</span> <span class="p">!=</span> <span class="n">str2</span><span class="p">.</span><span class="n">Length</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span> <span class="p">}</span> <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">str1</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span> <span class="n">result</span> <span class="p">|=</span> <span class="n">str1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">^</span> <span class="n">str2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span> <span class="k">return</span> <span class="n">result</span> <span class="p">==</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>So now the JIT will cease to optimize this method at all and it will be closer
to as-written.</p> <p>This is close to time-independent as possible with the String type. We can improve
things a bit by making the parameters <code class="highlighter-rouge">ReadOnlySpan&lt;char&gt;</code> which will generate
very similar x86 as <code class="highlighter-rouge">string</code> parameters, however the null checks will be
eliminated since a ROS cannot be null.</p> <p>This is what .NET Core 2.1&#x2019;s <code class="highlighter-rouge">FixedTimeEquals</code> does. It just does it over a
<code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code> instead of characters. The x86 produced by the current JIT
will be identical for <code class="highlighter-rouge">ReadOnlySpan&lt;char&gt;</code> and <code class="highlighter-rouge">ReadOnlySpan&lt;byte&gt;</code> with the
exception of the size of the <code class="highlighter-rouge">MOVZX</code>.</p> <p>It&#x2019;s handy that this is just in the box for .NET Core now.</p> </li> </ul> </p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>