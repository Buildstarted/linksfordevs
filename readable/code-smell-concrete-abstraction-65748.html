<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Code Smell: Concrete Abstraction - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Code Smell: Concrete Abstraction - linksfor.dev(s)"/>
    <meta property="og:description" content="This is a hand-wavy philosophical article about programming, without quantifiable justification, but with some actionable advice and a case study."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://matklad.github.io/2020/08/15/concrete-abstraction.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Code Smell: Concrete Abstraction</title>
<div class="readable">
        <h1>Code Smell: Concrete Abstraction</h1>
            <div>Reading time: 7-8 minutes</div>
        <div>Posted here: 16 Aug 2020</div>
        <p><a href="https://matklad.github.io/2020/08/15/concrete-abstraction.html">https://matklad.github.io/2020/08/15/concrete-abstraction.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
    <article>

<p>Aug 15, 2020</p>
<p>This is a hand-wavy philosophical article about programming, without quantifiable justification, but with some actionable advice and a case study.</p>
<p>Suppose that there are two types in the program, <code>Blorb</code> and <code>Gonk</code>.
Suppose also that they both can <code>blag</code>.</p>
<p>Does it make sense to add the following trait?</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>trait</span> <span>Blag</span> <span>{</span>
    <span>fn</span> <span>blag</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>);</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>I claim that it makes sense only if you have a function like</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
</pre></td><td><pre><span>fn</span> <span>blagyify</span><span>&lt;</span><span>T</span><span>:</span> <span>Blag</span><span>&gt;</span><span>(</span><span>x</span><span>:</span> <span>T</span><span>)</span> <span>{</span>
    <span>...</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>That is, if some part of you program is generic over <code>T: Blag</code>.</p>
<p>If in every <code>x.blag()</code> the <code>x</code> is either <code>Blorg</code>, or <code>Gonk</code>, but never a <code>T</code> (each usage is <em>concrete</em>), you don’t need this abstraction.
“Need” is used in a literal sense here: replace a trait with two inherent methods named <code>blag</code>, and the code will be essentially the same.
Using a trait here doesn’t achieve any <a href="https://caseymuratori.com/blog_0015">semantic compression</a>.</p>
<p>Given that abstractions have costs “don’t need” can be strengthen to “probably shouldn’t”.</p>

<p>Not going for an abstraction often allows a for more specific interface.
A monad in Haskell is a thing with <code>&gt;&gt;=</code>.
Which isn’t telling much.
Languages like Rust and OCaml can’t express a general monad, but they still have concrete monads.
The <code>&gt;&gt;=</code> is called <code>and_then</code> for futures and <code>flat_map</code> for lists.
These names are <em>more specific</em> than <code>&gt;&gt;=</code> and are easier to understand.
The <code>&gt;&gt;=</code> is only required if you want to write code generic over type of monad itself, which happens rarely.</p>
<p>Another example of abstraction which is used mostly concretely are collection hierarchies.
In Java or Scala, there’s a whole type hierarchy for things which can hold other things.
Rust’s type system can’t express <code>Collection</code> trait, so we have to get by with using <code>Vec</code>, <code>HashSet</code> and <code>BTreeSet</code> directly.
And it isn’t actually a problem in practice.
Turns out, writing code which is generic over collections (and not just over iterators) is not that useful.
The "but I can change the collection type later" argument also seems overrated — often, there’s only single collection type that makes sense.
Moreover, swapping <code>HashSet</code> for <code>BTreeSet</code> is mostly just a change at the definition site, as the two happen to have almost identical interface anyway.
The only case where I miss Java collections is when I return <code>Vec&lt;T&gt;</code>, but mean a generic <em>unordered</em> collection.
In Java, the difference is captured by <code>List&lt;T&gt;</code> vs <code>Collection&lt;T&gt;</code>.
In Rust, there’s nothing built-in for this.
It is possible to define a <code>VecSet&lt;T&gt;(Vec&lt;T&gt;)</code>, but doesn’t seem worth the effort.</p>
<p>Collections also suffer from <code>&gt;&gt;=</code> problem — collapsing similar synonyms under a single name.
Java’s
<a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html">Queue</a>
has <code>add</code>, <code>offer</code>, <code>remove</code>, and <code>poll</code> methods, because it needs to be a collection, but also is a special kind of collection.
In C++, you have to spell <code>push_back</code> for <code>vector</code>'s push operation, so that it duck-types with <code>deque</code>'s <code>front</code> and <code>back</code>.</p>
<div>
<table>
<tbody><tr>
<td>
<i title="Note"></i>
</td>
<td>
<p>Collection hierarchy is a sufficient, but not necessary condition for mixing up method names.
Rust’s <code>BinaryHeap</code> should have had <code>BinaryHeap::pop_max</code> method.
Alas, we are stuck with <code>pop</code>, which, coupled with the fact that the heap is surprisingly and uselessly a max-heap, means many student-hours wasted on debugging misbehaving Dijkstra algorithm.</p>
</td>
</tr>
</tbody></table>
</div>
<p>Finally, the promised case study!
rust-analyzer needs to convert a bunch of internal type to types suitable for converting them into JSON message of the Language Server Protocol.
<code>ra::Completion</code> is converted into <code>lsp::Completion</code>; <code>ra::Completion</code> contains <code>ra::TextRange</code> which is converted to <code>lsp::Range</code>, etc.</p>
<p>The first implementation started with an abstraction for conversion:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>pub</span> <span>trait</span> <span>Conv</span> <span>{</span>
    <span>type</span> <span>Output</span><span>;</span>
    <span>fn</span> <span>conv</span><span>(</span><span>self</span><span>)</span> <span>-&gt;</span> <span>Self</span><span>::</span><span>Output</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>This abstraction doesn’t work for all cases — sometimes the conversion requires additional context.
For example, to convert a rust-analyzer’s offset (a position of byte in the file) to an LSP position (<code>(line, column)</code> pair), a table with positions of newlines is needed.
This is easy to handle:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre><span>pub</span> <span>trait</span> <span>ConvWith</span><span>&lt;</span><span>CTX</span><span>&gt;</span> <span>{</span>
    <span>type</span> <span>Output</span><span>;</span>
    <span>fn</span> <span>conv_with</span><span>(</span><span>self</span><span>,</span> <span>ctx</span><span>:</span> <span>CTX</span><span>)</span> <span>-&gt;</span> <span>Self</span><span>::</span><span>Output</span><span>;</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Naturally, there was an intricate web of delegating impls.
The typical one looked like this:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td><pre><span>impl</span> <span>ConvWith</span><span>&lt;&amp;</span><span>LineIndex</span><span>&gt;</span> <span>for</span> <span>TextRange</span> <span>{</span>
    <span>type</span> <span>Output</span> <span>=</span> <span>Range</span><span>;</span>
    <span>fn</span> <span>conv_with</span><span>(</span>
        <span>self</span><span>,</span>
        <span>line_index</span><span>:</span> <span>&amp;</span><span>LineIndex</span><span>,</span>
    <span>)</span> <span>-&gt;</span> <span>lsp_types</span><span>::</span><span>Range</span> <span>{</span>
        <span>Range</span><span>::</span><span>new</span><span>(</span>
            <span>self</span><span>.start</span><span>()</span><span>.conv_with</span><span>(</span><span>line_index</span><span>),</span>
            <span>self</span><span>.end</span><span>()</span><span>.conv_with</span><span>(</span><span>line_index</span><span>),</span>
        <span>)</span>
    <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>There were a couple of genuinely generic impls for converting iterators of convertible things.</p>
<p>The code was hard to understand.
It also was hard to use: if calling <code>.conv</code> didn’t work immediately, it took a loot of time to find which specific impl didn’t apply.
Finally, there were many accidental (as in “accidental complexity”) changes to the shape of code: <code>CTX</code> being passed by value or by reference, switching between generic parameters and associated types, etc.</p>
<p>I was really annoyed by how this conceptually simple pure boilerplate operation got expressed as clever and fancy abstraction.
Crucially, almost all of the usages of the abstraction (besides those couple of iterator impls) were concrete.
So I replaced the whole edifice with much simpler code, a bunch of functions:</p>
<div>
<div>
<pre><code data-lang="rust"><table><tbody><tr><td><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td><pre><span>fn</span> <span>range</span><span>(</span>
    <span>line_index</span><span>:</span> <span>&amp;</span><span>LineIndex</span><span>,</span>
    <span>range</span><span>:</span> <span>TextRange</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>lsp_types</span><span>::</span><span>Range</span> <span>{</span>
    <span>let</span> <span>start</span> <span>=</span> <span>position</span><span>(</span><span>line_index</span><span>,</span> <span>range</span><span>.start</span><span>());</span>
    <span>let</span> <span>end</span> <span>=</span> <span>position</span><span>(</span><span>line_index</span><span>,</span> <span>range</span><span>.end</span><span>());</span>
    <span>lsp_types</span><span>::</span><span>Range</span><span>::</span><span>new</span><span>(</span><span>start</span><span>,</span> <span>end</span><span>)</span>
<span>}</span>

<span>fn</span> <span>position</span><span>(</span>
    <span>line_index</span><span>:</span> <span>&amp;</span><span>LineIndex</span><span>,</span>
    <span>offset</span><span>:</span> <span>TextSize</span><span>,</span>
<span>)</span> <span>-&gt;</span> <span>lsp_types</span><span>::</span><span>Position</span> <span>{</span>
    <span>...</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<p>Simplicity and ease of use went up tremendously.
Now instead of typing <code>x.conv()</code> and trying to figure out why an impl I think should apply doesn’t apply, I just auto-complete <code>to_proto::range</code> and let the compiler tell me exactly which types don’t line up.</p>
<p>I’ve lost fancy iterator impls, but the
<a href="https://github.com/rust-analyzer/rust-analyzer/pull/4418/commits/1586bab0b97bef411e6187dfc389557edbc5a16e">total diff</a>
for the commit was <code>+999,-1123</code>.
The was some genuine code re-use in those impls, but it was not justified by the overall compression, even disregarding additional complexity tax.</p>
<p>To sum up, “is this abstraction used exclusively concretely?” is a meaningful question about the overall shape of code.
If the answer is “Yes!”, then the abstraction can be replaced by a number of equivalent non-abstract implementations.
As the latter tend to be simpler, shorter, and more direct, “Concrete Abstraction” can be considered a code smell.
As usual though, any abstract programming advice can be applied only in a concrete context — don’t blindly replace abstractions with concretions, check if provided justifications work for your particular case!</p>

</article>

  </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>