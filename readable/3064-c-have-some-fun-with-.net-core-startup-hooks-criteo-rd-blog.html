<!DOCTYPE html>
<html lang="en">
<head>
    <title>
[C#] Have some fun with .net core startup hooks - Criteo R&amp;D Blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>[C#] Have some fun with .net core startup hooks - Criteo R&amp;D Blog</h1><div><div class="ac ae af ag ah ea aj ak"><p id="642e" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">One feature of .net core 2.2 that didn‚Äôt catch my mind immediately is the <a href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-startup-hook.md" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">startup hooks</a>. Put simply, this is a way to register globally a method in an assembly that will be executed whenever a .net core application is started. This unlocks a whole range of scenarios, from injecting a profiler to tweaking a static context in a given environment.</p><p id="9a79" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">How does it work? First, you need to create a new .net core assembly, and add a StartupHook class. Make sure that it‚Äôs outside of any namespace. That class must define a static Initialize method. That‚Äôs the method that will be called whenever a .net core application is started.</p><p id="392a" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The following hook, for instance, will display ‚ÄúHello world!‚Äù when an application is launched:</p><figure class="hg hh hi hj hk hl"><p id="1651" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">To register the hook, you need to declare a <code class="hq hr hs ht hu b">DOTNET_STARTUP_HOOKS</code> environment variable, pointing to the assembly. Once you‚Äôve done that, you‚Äôll see the message displayed:</p><figure class="hg hh hi hj hk hl dm dn paragraph-image"><p id="92c5" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">It‚Äôs really important to understand that <strong class="gq if">the hook is executed inside of the application process</strong>. And a globally registered hook that runs inside of all .net core processes sounds like a good prank setup for unsuspecting coworkers.</p><h1 id="41aa" class="ig ih ed at as ii ef ij eh ik il im in io ip iq ir">The inverted console</h1><p id="9fe7" class="go gp ed at gq b gr is gt it gv iu gx iv gz iw hb dv">What kind of prank? Let‚Äôs start with something simple: what about overriding the console stream to reverse the displayed text? First we write a custom <code class="hq hr hs ht hu b">TextWriter</code>:</p><figure class="hg hh hi hj hk hl"><p id="c533" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Then we assign it to the console in the startup hook:</p><figure class="hg hh hi hj hk hl"><p id="5678" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Once the startup hook is registered, all .net core 2.2 applications will output inverted text in the console:</p><figure class="hg hh hi hj hk hl dm dn paragraph-image"><p id="55fb" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">And the best part is that it even works for the ‚Äúdotnet.exe‚Äù executable itself!</p><figure class="hg hh hi hj hk hl dm dn paragraph-image"><p id="89b5" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">You can easily imagine the confusion that would come from it.</p><h1 id="764b" class="ig ih ed at as ii ef ij eh ik il im in io ip iq ir">Overriding Array.Empty</h1><p id="aff7" class="go gp ed at gq b gr is gt it gv iu gx iv gz iw hb dv">Is there anything else we can do? I‚Äôve been unsuccessful at replacing the value of <code class="hq hr hs ht hu b">string.Empty</code> (probably because it‚Äôs declared as an intrinsic), but we can instead replace the value of <code class="hq hr hs ht hu b">Array.Empty&lt;T&gt;</code>. For instance for <code class="hq hr hs ht hu b">Array.Empty&lt;string&gt;</code>:</p><figure class="hg hh hi hj hk hl"><p id="c570" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">This sounds rather inoffensive, until you consider the case of methods with <code class="hq hr hs ht hu b">params</code> argument. For instance, this method:</p><figure class="hg hh hi hj hk hl"><p id="6ed3" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">From a C# point of view, you can call it without any parameter (<code class="hq hr hs ht hu b">PrintArgs()</code>). But from an IL perspective, the args parameter is just an ordinary array. The magic is done by the compiler, which automatically inserts an empty array, effectively rewriting the call to <code class="hq hr hs ht hu b">PrintArgs(Array.Empty&lt;string&gt;())</code>. Therefore, with the startup hook registered, the method called without any parameter will actually display ‚ÄúHello world!‚Äù.</p><h1 id="7323" class="ig ih ed at as ii ef ij eh ik il im in io ip iq ir">The async state machine</h1><p id="09da" class="go gp ed at gq b gr is gt it gv iu gx iv gz iw hb dv">Those are already nice ways to confuse coworkers, but I wanted to go even farther. That‚Äôs when I thought of replacing the default <code class="hq hr hs ht hu b">TaskScheduler</code>. What could we do with it? What about‚Ä¶ rewriting values at random in the async state machine? When a method uses async/await, it is converted to a state machine that stores among other things the local variables used by the method (to restore the context when the await continuation starts executing). If we manage to retrieve that state machine, we can therefore change the value of the locals between each await!</p><p id="1356" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">We start by declaring our custom task scheduler (and name it <code class="hq hr hs ht hu b">ThreadPoolTaskScheduler</code> in case somebody would think of inspecting the callstack), and we use it to overwrite <code class="hq hr hs ht hu b">TaskScheduler.Default</code>.</p><figure class="hg hh hi hj hk hl"><p id="5621" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Note that we also always set <code class="hq hr hs ht hu b">s_asyncDebuggingEnabled</code> to true to avoid having a different behavior when the debugger is attached, which would complicate our code. The task scheduler calls an empty <code class="hq hr hs ht hu b">MutateState</code> method, then uses the threadpool to schedule the task execution. Now we need to implement that method.</p><p id="bfaf" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">How to retrieve the state machine? The first step is to retrieve the <code class="hq hr hs ht hu b"><a href="https://github.com/dotnet/corefx/blob/332d12c0a401927c84d8a2c2ea113427481689ab/src/Common/src/CoreLib/System/Runtime/CompilerServices/AsyncMethodBuilder.cs#L1107" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">ContinuationWrapper</a></code>. This is a structure that wraps the task action when <code class="hq hr hs ht hu b">s_asyncDebuggingEnabled</code> is set to true. Depending on the type of task, we can find it either on task action or on the state:</p><figure class="hg hh hi hj hk hl"><p id="e8e0" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">From there, we retrieve the value of the <code class="hq hr hs ht hu b">_continuation</code> field and check if it is an instance of <code class="hq hr hs ht hu b">AsyncStateMachineBox</code>. If it is, then we can find the state machine in the <code class="hq hr hs ht hu b">StateMachine</code> field:</p><figure class="hg hh hi hj hk hl"><p id="2b43" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">What does an async state machine look like?</p><figure class="hg hh hi hj hk hl dm dn paragraph-image"><p id="861b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Two public fields are always there: <code class="hq hr hs ht hu b">&lt;&gt;1__state</code> and <code class="hq hr hs ht hu b">&lt;&gt;t__builder</code>. <code class="hq hr hs ht hu b">&lt;&gt;1__state</code> is used to store the current execution step in the async method. We could use it for instance to rewind the execution of the method. <code class="hq hr hs ht hu b">&lt;&gt;t__builder</code> contains the facilities used to await other methods (nested calls). There‚Äôs plenty of stuff we could do with it, but we‚Äôll focus on the locals.</p><p id="2d90" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The locals are stored in the private fields. In this case, <code class="hq hr hs ht hu b">&lt;&gt;u__1</code> and <code class="hq hr hs ht hu b">&lt;j&gt;5__1</code>. Those are the ones we want to play with:</p><figure class="hg hh hi hj hk hl"><p id="ed3a" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">What we do here is creating a new state machine, then copy the value of the old fields to the new ones. If the field is private and is an int, we replace it by a random value.</p><p id="4d4d" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Now let‚Äôs make a simple program to test the hook:</p><figure class="hg hh hi hj hk hl"><p id="bcb2" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">And you‚Äôll see that‚Ä¶ it doesn‚Äôt work. Why? Because the TPL has been pretty well optimized. In a lot of places, the code checks the current scheduler, and completely bypasses it if it‚Äôs the default one to directly schedule the continuation on the threadpool. For instance, <a href="https://github.com/dotnet/corefx/blob/016839c18266f33eaa6784a9725c542de151eac1/src/Common/src/CoreLib/System/Runtime/CompilerServices/YieldAwaitable.cs#L98" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">in the </a><code class="hq hr hs ht hu b"><a href="https://github.com/dotnet/corefx/blob/016839c18266f33eaa6784a9725c542de151eac1/src/Common/src/CoreLib/System/Runtime/CompilerServices/YieldAwaitable.cs#L98" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">YieldAwaiter</a></code><a href="https://github.com/dotnet/corefx/blob/016839c18266f33eaa6784a9725c542de151eac1/src/Common/src/CoreLib/System/Runtime/CompilerServices/YieldAwaitable.cs#L98" class="da by hc hd he hf" target="_blank" rel="noopener nofollow"> (used by </a><code class="hq hr hs ht hu b"><a href="https://github.com/dotnet/corefx/blob/016839c18266f33eaa6784a9725c542de151eac1/src/Common/src/CoreLib/System/Runtime/CompilerServices/YieldAwaitable.cs#L98" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">Task.Yield</a></code>).</p><p id="359b" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">How can we work around that? We absolutely need our custom task scheduler to be the default one, otherwise it won‚Äôt be used when calling <code class="hq hr hs ht hu b">Task.Run</code>. But if the default task scheduler is assigned to a task, then we won‚Äôt be called back and we won‚Äôt be able to mutate the state. If we check the code of the <code class="hq hr hs ht hu b">YieldAwaiter</code> above, we can see that it‚Äôs doing a simple reference comparison. So we can overwrite the scheduler of the task with a new instance of our custom scheduler to fool those checks:</p><figure class="hg hh hi hj hk hl"><p id="860d" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Are we done? If we go back to our example, we can start debugging step by step:</p><figure class="hg hh hi hj hk hl dm dn paragraph-image"><p id="b0ec" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">i is 42, all good. One more step and‚Ä¶</p><figure class="hg hh hi hj hk hl dm dn paragraph-image"><p id="39f1" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Now go and enjoy the dumbfounded looks of your coworkers!</p><p id="c8c8" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Note that this won‚Äôt work when using <code class="hq hr hs ht hu b">ConfigureAwait(false)</code>, because it directly enqueues the continuation to the threadpool and won‚Äôt even check the current task scheduler (why would it?). One way around that could be to override the task builder with a custom one, but the joke already went far enough as is üôÇ</p><p id="845d" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Of course, all those tricks could have unpredictable effects on the target applications, so make sure to closely supervise the prank and stop as soon as it could become dangerous.</p></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>