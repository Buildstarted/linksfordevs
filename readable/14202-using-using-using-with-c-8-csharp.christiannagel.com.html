<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using, using, using with C# 8 &#x2013; csharp.christiannagel.com -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Using, using, using with C# 8 – csharp.christiannagel.com</h1><div><div class="entry-content"><p>C# has different meanings for the <strong>using</strong> keyword. One is the <em>using directive</em> to import types from namespaces, and to create aliases to types. The second meaning is the <em>using statement</em> as a convenient syntax on using the <em>IDisposable</em> interface. With C# 6, also the <em>using static</em> directive was added to allow accessing static class members without the need to specify the type. C# 8 now adds another variant to the <em>using</em> keyword – one that is related with the <em>using statement</em>, the <strong>using declaration</strong>. I think I will replace most of my usages of the <em>using statement</em> to use the new <em>using declaration</em> instead. This article does not step into the <em>using directive</em>, but gives you information about the new C# 8 feature <em>using declaration</em>.</p><p><img src="https://csharpdotchristiannageldotcom.files.wordpress.com/2019/03/emotions.jpg?w=672" alt="Emotions"></p><h2>Disposing Resources</h2><p>First, let’s start with the traditional <em>using statement</em> and the class <code>AResource</code> which implements the <code>IDisposable</code> interface:</p><pre class="brush: csharp; title: ; notranslate" title="">public class AResource : IDisposable
{
    public void UseIt() =&gt; Console.WriteLine($"{nameof(UseIt)}");
    public void Dispose() =&gt; Console.WriteLine($"Dispose {nameof(AResource)}");
}
</pre><p>The <em>using statement</em> can be used to reference a variable or the result from a method, and at the end of the scope defined by the <em>using statement</em>, the <code>Dispose</code> method gets invoked:</p><pre class="brush: csharp; title: ; notranslate" title="">private static void TraditionalUsingStatement()
{
    using (var r = new AResource())
    {
        r.UseIt();
    }  // r.Dipose is called
}
</pre><p>Behind the scenes, the compiler creates code using <em>try/finally</em> to make sure <code>Dispose</code>is also called when an exception is thrown:</p><pre class="brush: csharp; title: ; notranslate" title="">private static void TraditionalUsingStatementExpanded()
{
    var r = new AResource();
    try
    {
        r.UseIt();
    }
    finally
    {
        r.Dispose();
    }
}
</pre><p>With the new C# 8 <em>using declaration</em>, the code with the <em>using statement can be simplified. Curly brackets are no longer needed. At the end of the scope of the variable r (which is here the end of the method), the <code>Dispose</code> method is invoked. Here, the compiler also creates a *try/finally</em> block to make sure <code>Dispose</code> is called if errors occur.</p><pre class="brush: csharp; title: ; notranslate" title="">private static void NewWithUsingDeclaration()
{
    using var r = new AResource();
    r.UseIt();
}
</pre><p>That’s a small feature of C# 8, but we need to get a little bit more into details.</p><h2>Disposing Multiple Resources</h2><p>Using multiple resources, I’ve often seen code like this with multiple nested using statements:</p><pre class="brush: csharp; title: ; notranslate" title="">private static void TraditionalMultipleUsingStatements()
{
    using (var r1 = new AResource())
    {
        using (var r2 = new AResource())
        {
            r1.UseIt();
            r2.UseIt();
        }
    }
}
</pre><p>Because the body of the outer using statement just consists of a single statement – the inner using statement, it is possible to simplify the code. This looks better than the previous one, and it stays better also if more than two resources need to be disposed:</p><pre class="brush: csharp; title: ; notranslate" title="">private static void TraditionalMultipleUsingStatements2()
{
    using (var r1 = new AResource())
    using (var r2 = new AResource())
    {
        r1.UseIt();
        r2.UseIt();
    }
}
</pre><p>Next let’s do the same with the new <em>using declaration</em>. The following code is even shorter compared to the previous one – no matter how many resources you need to dispose:</p><pre class="brush: csharp; title: ; notranslate" title="">private static void NewMultipleUsingDeclarations()
{
    using var r1 = new AResource();
    using var r2 = new AResource();
    r1.UseIt();
    r2.UseIt();
}
</pre><h2>Using Scopes</h2><p>What if a resource should be disposed before the method ends? You just need to add a separate scope using curly brackets. When the variable is out of scope, the resource is disposed:</p><pre class="brush: csharp; title: ; notranslate" title="">private static void UsingDeclarationWithScope()
{
    {
        using var r1 = new AResource();
        r1.UseIt();
    }  // r1 is disposed here!
    Console.WriteLine("r1 is already disposed");
}
</pre><h2>What can’t be done with the <em>using declaration</em></h2><p>Is there a reason to not use the <em>using declaration</em>, and keep the <em>using statement</em>?</p><p>In case you’ve a method returning a disposable, such as the method <code>GetTheResource</code>,</p><pre class="brush: csharp; title: ; notranslate" title="">public static AResource GetTheResource() =&gt; new AResource();
</pre><p>and you don’t need a variable of this type, you just need to make sure the resource returned is disposed – with the <em>using statement</em> this code is possible:</p><pre class="brush: csharp; title: ; notranslate" title="">private static void TraditionalResourceReturned()
{
    using (GetTheResource())
    {
        // do something here
    }  // resource is disposed here
}
</pre><p>If you try to do the same with the <em>using declaration</em>, you’ll get multiple compilation errors – all in the same code line:</p><pre class="brush: csharp; title: ; notranslate" title="">private static void NewResourceReturned()
{
    using GetTheResource();
    // do something here
}  // resource is disposed here
</pre><ul><li>CS1001: Identifier expected</li><li>CS1528: Expected ; or = (cannot specify constructor arguments in declaration)</li><li>CS1003: Syntax error, ‘[‘ expected</li><li>CS1003: Syntax error, ‘]’ expected</li></ul><blockquote><p>
  Probably a future version of the compiler results in a different compiler error.
</p></blockquote><p>The reason is that the <em>using declaration</em> requires a variable for the scope. In case you don’t need the variable afterwards, there’s an easy fix – just use <code>_</code> for the variable name, and ignore it:</p><pre class="brush: csharp; title: ; notranslate" title="">private static void NewResourceReturned()
{
    using var _ = GetTheResource();
    // do something here
}  // resource is disposed here
</pre><h2>Summary</h2><p>It’s just a small feature of C# 8, but it will change the code in many places. Currently I don’t see a reason to stay with the old <em>using statement</em>. I think I’ll switch to the new <em>using declaration</em> with all my code. The number of curly brackets are reduced, but it can still be seen easily where a resource is disposed. The number of code lines is reduced using the name <em>using declaration</em>.</p><p>If you’ve read this far, consider buying me a coffee which helps me staying up longer and writing more articles.</p><p><a href="https://www.buymeacoffee.com/christiannagel" target="_blank" rel="noopener noreferrer"><img src="https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png" alt="Buy Me A Coffee"></a></p><p>Interesting Links for this article:</p><p><a href="https://github.com/ProfessionalCSharp/MoreSamples">Complete code sample</a></p><p>Other C# 8 articles:</p><p><a href="https://csharp.christiannagel.com/2019/03/20/asyncstreams/">Async Streams with C# 8</a></p><p><a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/async-streams.md">C# 8 Proposal for Async Streams</a></p><p><a href="https://github.com/dotnet/corefx/issues/33909">Proposal: IAsyncEnumerable.WithCancellation Extension Method</a></p><p><a href="https://csharp.christiannagel.com/2018/07/24/indexesandranges/">C# 8: Indexes and Ranges</a></p><p><a href="https://csharp.christiannagel.com/2018/07/03/patternmatchingcs8/">C# 8: Pattern matching extended</a></p><p><a href="https://csharp.christiannagel.com/2018/06/20/nonnullablereferencetypes/">C# 8: No more NullReferenceExceptions – What about legacy code?</a></p><p>More information on C# and programming .NET Core applications is in my book <a href="https://csharp.christiannagel.com/2018/04/16/professionalcsharp7/">Professional C# 7 and .NET Core 2.0</a>, and in my <a href="https://cninnovation.com/Training/">workshops</a>.</p><p>Enjoy learning and programming!</p><p>Christian</p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>