<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Analyzing a nullability example &#xB7; Curiosity is bliss -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Analyzing a nullability example · Curiosity is bliss</h1><div><div id="" class="post"><time datetime="2020-01-15T00:00:00-08:00" class="post-date">15 Jan 2020</time>&nbsp; 
  <p>Cezary Piątek posted a good <a href="https://cezarypiatek.github.io/post/non-nullable-references-in-dotnet-core/">overview of the C# nullable reference types feature</a>. 
It includes a <a href="https://cezarypiatek.github.io/post/non-nullable-references-in-dotnet-core/#there-is-still-room-for-improvement">critique of a code snippet</a>. Examining that snippet is a good way to understand some of the C# LDM’s decisions.
In the following, Cezary expects a warning on a seemingly unreachable branch and no warning on the dereference.</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="n">nullable</span><span class="n">enable</span><span class="k">public</span><span class="k">class</span><span class="nc">User</span><span class="p">{</span><span class="k">public</span><span class="k">static</span><span class="k">void</span><span class="nf">Method</span><span class="p">(</span><span class="n">User</span><span class="n">userEntity</span><span class="p">)</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="n">userEntity</span><span class="p">==</span><span class="k">null</span><span class="p">)</span><span class="c1">// Actual: no warning for seemingly unreachable branch. </span><span class="p">{</span><span class="p">}</span><span class="kt">var</span><span class="n">s</span><span class="p">=</span><span class="n">userEntity</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span><span class="c1">// Actual: warning CS8602: Dereference of a possibly null reference.</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p><a href="https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA+BiAdgVwDZ4CGweMABDFsaQLABQ9AAgMxmMBMZAqgM4xRl6Ab3pkxbVowCMSNijIBZGABcAFhAAmACl78yOPlACiWZQEtlATwCUo8SLrinZMwDMyWg/xPmrZALz+ZLgE1mQA9OHBEGQA7oRQWGZYAOZkrtBkfDAAtskpeJb6WLCEYKrU5MBQhFjlgo7OYg5NYgC+dk2dzgBuCVkB+oY+FpYAdAAqEADKylD5WtYA3BFR8Yn5ZADC0wAcSAAM7CBkACL8MK4XdeQQ7oRkAA4QPDxmJEUheGSwV7A3Y26HTobSAA=">sharplab</a></p><p>Why is there no warning on the seemingly unnecessary null test <code class="language-plaintext highlighter-rouge">if (userEntity == null) ...</code> or the apparently unreachable branch?</p><p>It’s because such tests are useful and encouraged in public APIs. Users should check inputs and the compiler should not get in the way of good practices. The branch of the <code class="language-plaintext highlighter-rouge">if</code> is therefore reachable.</p><p>Then, what is the state of <code class="language-plaintext highlighter-rouge">userEntity</code> within the <code class="language-plaintext highlighter-rouge">if</code> block?</p><p>We take the user’s null test seriously by considering <code class="language-plaintext highlighter-rouge">userEntity</code> to be maybe-null within the <code class="language-plaintext highlighter-rouge">if</code> block. So if the user did <code class="language-plaintext highlighter-rouge">userEntity.ToString()</code> inside the <code class="language-plaintext highlighter-rouge">if</code>, the compiler would rightly warn. This protects the user against a null reference exception that could realistically happen.</p><p>Given those, what should be the state of the <code class="language-plaintext highlighter-rouge">userEntity</code> at the exit of the <code class="language-plaintext highlighter-rouge">if</code>?</p><p>Because we’re merging branches where <code class="language-plaintext highlighter-rouge">userEntity</code> is maybe-null (when the condition of the <code class="language-plaintext highlighter-rouge">if</code> is true) and not-null (in the alternative), the state of <code class="language-plaintext highlighter-rouge">userEntity</code> is maybe-null. Therefore we warn on dereference on <code class="language-plaintext highlighter-rouge">userEntity</code> after the <code class="language-plaintext highlighter-rouge">if</code>.
Note that if the <code class="language-plaintext highlighter-rouge">if</code> block contained a <code class="language-plaintext highlighter-rouge">throw</code>, the <code class="language-plaintext highlighter-rouge">userEntity</code> would be considered not-null after the <code class="language-plaintext highlighter-rouge">if</code>. This is a common patter: <code class="language-plaintext highlighter-rouge">if (userEntity is null) throw new ArgumentNullException(nameof(userEntity));</code>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>