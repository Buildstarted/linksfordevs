<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Abusing the CPU&#x2019;s adder circuits -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Abusing the CPU’s adder circuits</h1><div><div id="main_content" class=""><small>15 June 2019</small><p class="view">by Gianni Tedesco</p><h2 id="where-we-explain-why-kernighans-trick-works">Where we explain why Kernighan’s trick works</h2><p>Have you ever been asked the interview question “how do you count the number of
bits set in an integer?”</p><p>A smart-ass like myself might answer something like:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span><span class="kt">int</span><span class="nf">count_set_bits</span><span class="p">(</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">x</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="n">__builtin_popcount</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><p>Which, on <code class="language-plaintext highlighter-rouge">x86_64</code>, produces:</p><div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">xor</span><span class="n">eax</span><span class="p">,</span><span class="n">eax</span><span class="n">popcnt</span><span class="n">eax</span><span class="p">,</span><span class="n">edi</span><span class="k">ret</span></code></pre></div></div><p>The interviewer, of course, doesn’t like that. He wants to see you come up with
an algorithm. So you come up with something like this:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span><span class="kt">int</span><span class="nf">count_set_bits</span><span class="p">(</span><span class="kt">uint32_t</span><span class="n">x</span><span class="p">)</span><span class="p">{</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i</span><span class="p">,</span><span class="n">ret</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="n">ret</span><span class="o">=</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="p">{</span><span class="n">ret</span><span class="o">+=</span><span class="o">!!</span><span class="p">(</span><span class="n">x</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1U</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">));</span><span class="p">}</span><span class="k">return</span><span class="n">ret</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>Which gives you something like:</p><div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">xor</span><span class="n">r8d</span><span class="p">,</span><span class="n">r8d</span><span class="k">xor</span><span class="n">eax</span><span class="p">,</span><span class="n">eax</span><span class="k">mov</span><span class="n">ecx</span><span class="p">,</span><span class="mi">1</span><span class="p">.</span><span class="n">p2align</span><span class="mi">4</span><span class="p">,,</span><span class="mi">10</span><span class="p">.</span><span class="n">p2align</span><span class="mi">3</span><span class="p">.</span><span class="n">L4</span><span class="o">:</span><span class="n">shlx</span><span class="n">edx</span><span class="p">,</span><span class="n">ecx</span><span class="p">,</span><span class="n">eax</span><span class="k">test</span><span class="n">edx</span><span class="p">,</span><span class="n">edi</span><span class="k">setne</span><span class="n">dl</span><span class="k">movzx</span><span class="n">edx</span><span class="p">,</span><span class="n">dl</span><span class="k">inc</span><span class="n">eax</span><span class="k">add</span><span class="n">r8d</span><span class="p">,</span><span class="n">edx</span><span class="k">cmp</span><span class="n">eax</span><span class="p">,</span><span class="mi">32</span><span class="k">jne</span><span class="p">.</span><span class="n">L4</span><span class="k">mov</span><span class="n">eax</span><span class="p">,</span><span class="n">r8d</span><span class="k">ret</span></code></pre></div></div><p>Which is, of course, dreadful. But the reason the interviewer likes this is
because it sets up the next question: “how can we optimize this?” Or if you
want to be more circumspect: “what if we only expect one or two bits to be
set?” or “what if our data is very sparse?”</p><p>Realistically though, you either know about “Kernighan’s trick”, or, you don’t.
It goes something like this:</p><div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span><span class="kt">int</span><span class="nf">count_set_bits</span><span class="p">(</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">x</span><span class="p">)</span><span class="p">{</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">ret</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="n">ret</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">x</span><span class="p">;</span><span class="n">x</span><span class="o">&amp;=</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="n">ret</span><span class="o">++</span><span class="p">;</span><span class="k">return</span><span class="n">ret</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>Which, at least for an Intel weenie such as myself, was a pointless exercise
because gcc compiles that to:</p><div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">xor</span><span class="n">eax</span><span class="p">,</span><span class="n">eax</span><span class="n">popcnt</span><span class="n">eax</span><span class="p">,</span><span class="n">edi</span><span class="k">mov</span><span class="n">edx</span><span class="p">,</span><span class="mi">0</span><span class="k">test</span><span class="n">edi</span><span class="p">,</span><span class="n">edi</span><span class="k">cmove</span><span class="n">eax</span><span class="p">,</span><span class="n">edx</span><span class="k">ret</span></code></pre></div></div><p>Which looks like a terrible code-generation bug in gcc. But hey, at least clang
does the right thing here:</p><p>Anyway, I digress. Did you notice the <code class="language-plaintext highlighter-rouge">x &amp;= (x - 1)</code> part? That is bitwise
woo-woo magic to unset the rightmost bit in <code class="language-plaintext highlighter-rouge">x</code>. It’s a neat trick, and if you
know it you’ll ace this part of the job interview.</p><p>But later, when you’re at home, alone, contemplating the empty meaninglessness
of the universe, you might ask yourself “but why does it work?”</p><h2 id="twos-complement">Two’s complement</h2><p>Let’s forget the <code class="language-plaintext highlighter-rouge">&amp;</code> part and just focus on what <code class="language-plaintext highlighter-rouge">x - 1</code> is doing for now.</p><p>One thing you’re going to need to know about is
<a href="https://en.wikipedia.org/wiki/Two%27s_complement">two’s complement</a>
arithmetic.</p><p>I won’t bore you by recapitulating the details but we should do well to
remember the following equations:</p><p>Therefore:</p><p>So the magic rune is just adding all one’s to our original value.</p><h2 id="half-adder">Half adder</h2><p>So here’s the part where we get in to how addition really works. You probably
have a good handle on this already from your school days, but let’s refresh.</p><p>The simplest case is if we’re just adding together a couple of 1-bit numbers.</p><p>Let’s write out the truth table for that:</p><table><thead><tr><th>x</th><th>y</th><th>result</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0… oh yeah, we need to carry…</td></tr></tbody></table><p>Let’s try again:</p><table><thead><tr><th>x</th><th>y</th><th>result</th><th>carry</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>Right, if we’re going to expand this to add numbers with more than one bit,
we’re going to need to do something about this carry output.</p><h2 id="full-adder">Full adder</h2><p>Let’s call the last adder with 2 inputs, and 2 outputs, the “half-adder.”</p><p>The full adder is going to have 3 inputs: the 2 operands, and then a carry-in
which is going to be connected to the next least significant bit’s carry-out.</p><table><thead><tr><th>x</th><th>y</th><th>carry-in</th><th>result</th><th>carry-out</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>So you can see in this example of a 4-bit adder that there’s this chain of
carry inputs going from right to left:</p><p><img src="/assets/images/4-bit_ripple_carry_adder.png" alt="there" title="4-bit ripple carry adder"></p><p>Thanks to <a href="https://en.wikipedia.org/wiki/User:Cburnett">Colin M.L. Burnett</a>
for the excellent diagram.</p><h2 id="putting-it-all-together">Putting it all together</h2><p>The basic outline of the algorithm is that we start with an input, <code class="language-plaintext highlighter-rouge">x</code>. And as
long as it isn’t zero, we unset the least significant bit, and increment the
result.</p><p>So if the input is <code class="language-plaintext highlighter-rouge">1000_1100</code>, the loop will iterate 3 times.</p><p><code class="language-plaintext highlighter-rouge">x &amp;= (x - 1)</code> is an operation which clears the least-significant set bit in
the input, <code class="language-plaintext highlighter-rouge">x</code>.</p><p>Since we’re going to do <code class="language-plaintext highlighter-rouge">x &amp;= mask</code>, that must mean that <code class="language-plaintext highlighter-rouge">mask</code> has a zero in
the position we want to zero out. And it can’t have any zeroes where the input
has a one.</p><p>So we abuse the carry-chain to create such a mask. By adding <code class="language-plaintext highlighter-rouge">1111_1111</code> to the
input, we’re essentially ensuring that the carry signal is not asserted until
we hit the first one bit, but after that it will be asserted for all the rest
of the bits (travelling from right to left).</p><p>If we extract the relevant parts of the adder truth table we can see how the
addition operation will produce the mask that we need:</p><table><thead><tr><th>x</th><th>y</th><th>cin</th><th>result</th><th>cout</th><th>explanation</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>Before the first bit, produce ones</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>For the first bit, produce a zero and set the carry going</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>now the result is zero if x was 0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>or 1 if x was one</td></tr></tbody></table><p>What that gives us is a number which is (from right to left):</p><ol><li>all ones (but that’s okay because corresponding input bits are zeroes)</li><li>zero for the first one bit (which ensures that it will be cleared)</li><li>and then equal to the input after that (leaving all higher bits unchanged)</li></ol><small>tags: <em>binary</em> - <em>logic</em> - <em>bitwise-hacks</em></small></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>