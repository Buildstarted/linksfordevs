<!DOCTYPE html>
<html lang="en">
<head>
    <title>
OpenID Connect back-channel logout using Azure Redis Cache and IdentityServer4 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="OpenID Connect back-channel logout using Azure Redis Cache and IdentityServer4 - linksfor.dev(s)"/>
    <meta property="article:author" content="damienbod"/>
    <meta property="og:description" content="This article shows how to implement an OpenID Connect back-channel logout, which uses Azure Redis cache so that the session logout will work with multi instance deployments. Code: Posts in this ser&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://damienbod.com/2018/12/18/openid-connect-back-channel-logout-using-azure-redis-cache-and-identityserver4/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - OpenID Connect back-channel logout using Azure Redis Cache and IdentityServer4</title>
<div class="readable">
        <h1>OpenID Connect back-channel logout using Azure Redis Cache and IdentityServer4</h1>
            <div>by damienbod</div>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://damienbod.com/2018/12/18/openid-connect-back-channel-logout-using-azure-redis-cache-and-identityserver4/">https://damienbod.com/2018/12/18/openid-connect-back-channel-logout-using-azure-redis-cache-and-identityserver4/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>

							<p>This article shows how to implement an <a href="https://openid.net/specs/openid-connect-backchannel-1_0.html">OpenID Connect back-channel logout</a>, which uses <a href="https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/">Azure Redis cache</a> so that the session logout will work with multi instance deployments.</p>
<p><strong>Code:</strong> <a href="https://github.com/damienbod/AspNetCoreBackChannelLogout" rel="nofollow">https://github.com/damienbod/AspNetCoreBackChannelLogout</a></p>
<p>Posts in this series:</p>
<ul>
<li><a href="https://damienbod.com/2018/12/18/openid-connect-back-channel-logout-using-azure-redis-cache-and-identityserver4/">OpenID Connect back-channel logout using Azure Redis Cache and IdentityServer4</a></li>
<li><a href="https://damienbod.com/2018/12/23/using-azure-key-vault-with-asp-net-core-and-azure-app-services/">Using Azure Key Vault with ASP.NET Core and Azure App Services</a></li>
<li><a href="https://damienbod.com/2019/01/07/deploying-asp-net-core-app-services-using-azure-key-vault-and-azure-resource-manager-templates/">Deploying ASP.NET Core App Services using Azure Key Vault and Azure Resource Manager templates</a></li>
<li><a href="https://damienbod.com/2019/02/07/using-azure-key-vault-from-an-non-azure-app/">Using Azure Key Vault from a non-Azure App</a></li>
</ul>
<p><strong>Setting up the Azure Redis Cache</strong></p>
<p>Before using the Azure Redis Cache in the application, this needs to be setup in Azure. Joonas Westlin has a nice <a href="https://joonasw.net/view/redis-cache-session-store">blog </a>about this. The <a href="https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-faq#what-azure-cache-for-redis-offering-and-size-should-i-use">Redis Azure FAQ link</a> is also very good, which should help you decide the configuration which is correct for you. </p>
<p>Click “Create a Resource” and enter Redis Cache in the search input.</p>
<p><img data-attachment-id="11610" data-permalink="https://damienbod.com/2018/12/18/openid-connect-back-channel-logout-using-azure-redis-cache-and-identityserver4/bc_redis_azure_01/" data-orig-file="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_01.png" data-orig-size="894,360" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="BC_Redis_Azure_01" data-image-description="" data-medium-file="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_01.png?w=600" data-large-file="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_01.png?w=640" src="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_01.png?w=640&amp;h=258" alt="" width="640" height="258" srcset="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_01.png?w=640&amp;h=258 640w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_01.png?w=150&amp;h=60 150w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_01.png?w=600&amp;h=242 600w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_01.png?w=768&amp;h=309 768w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_01.png 894w" sizes="(max-width: 640px) 100vw, 640px"></p>
<p>Then create the Redis Cache as required:</p>
<p><img data-attachment-id="11615" data-permalink="https://damienbod.com/2018/12/18/openid-connect-back-channel-logout-using-azure-redis-cache-and-identityserver4/bc_redis_azure_02/" data-orig-file="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_02.png" data-orig-size="779,995" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="BC_Redis_Azure_02" data-image-description="" data-medium-file="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_02.png?w=470" data-large-file="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_02.png?w=640" src="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_02.png?w=640&amp;h=817" alt="" width="640" height="817" srcset="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_02.png?w=640&amp;h=817 640w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_02.png?w=117&amp;h=150 117w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_02.png?w=470&amp;h=600 470w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_02.png?w=768&amp;h=981 768w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_02.png 779w" sizes="(max-width: 640px) 100vw, 640px"></p>
<p>Creating the cache takes some time. Once finished, the connection string can be copied from the Access keys</p>
<p><img data-attachment-id="11618" data-permalink="https://damienbod.com/2018/12/18/openid-connect-back-channel-logout-using-azure-redis-cache-and-identityserver4/bc_redis_azure_03/" data-orig-file="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png" data-orig-size="1279,961" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="BC_Redis_Azure_03" data-image-description="" data-medium-file="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png?w=600" data-large-file="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png?w=640" src="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png?w=640&amp;h=481" alt="" width="640" height="481" srcset="https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png?w=640&amp;h=481 640w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png?w=150&amp;h=113 150w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png?w=600&amp;h=451 600w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png?w=768&amp;h=577 768w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png?w=1024&amp;h=769 1024w, https://damienbod.files.wordpress.com/2018/12/BC_Redis_Azure_03.png 1279w" sizes="(max-width: 640px) 100vw, 640px"></p>
<p>Now that the Azure Redis is setup, you can add the cache to the ASP.NET Core application. In this example, the Microsoft.Extensions.Caching.Redis NuGet package is used to access and use the Azure Redis Cache. Add this to your project.</p>
<p>In the Startup class, add the distributed Redis cache using the AddDistributedRedisCache extension method from the NuGet package.</p>
<div><div id="highlighter_473087"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p></td><td><div><p><code>services.AddDistributedRedisCache(options =&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.Configuration = </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Configuration.GetConnectionString(</code><code>"RedisCacheConnection"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.InstanceName = </code><code>"MvcHybridBackChannelInstance"</code><code>;</code></p><p><code>});</code></p></div></td></tr></tbody></table></div></div>
<p>Add the Redis connection string to the app.settings. This example using the RedisCacheConnection. The values for this can be copied from the access keys tab in the Redis/Access keys menu which was created above. </p>
<p>The connection string should be added as a secret to the application, and not committed in the code.</p>
<div><div id="highlighter_168190"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p></td><td><div><p><code>"ConnectionStrings"</code><code>: {</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"RedisCacheConnection"</code><code>: </code><code>"redis-connection-string"</code></p><p><code>},</code></p></div></td></tr></tbody></table></div></div>
<p><strong>Using the Cache for the Back-Channel logout</strong></p>
<p>The LogoutSessionManager class uses the Azure Redis cache to add or get the different logouts. The OpenID Connect back-channel specification defines how this logout works. The Secure Token Server, implemented using IdentityServer4, requests a logout URL which is handled in the client application.</p>
<p>The LogoutController class is used for this. If all the validation and the checks are ok, the class uses a singleton instance of LogoutSessionManager to manage the logouts for the client. The code used in this example, was created using the IdentityServer4.Samples.</p>
<p>The IDistributedCache is added in the constructor and saved as a read only field in the class.</p>
<div><div id="highlighter_232948"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p></td><td><div><p><code>private</code> <code>static</code> <code>readonly</code> <code>Object _lock = </code><code>new</code> <code>Object();</code></p><p><code>private</code> <code>readonly</code> <code>ILogger&lt;LogoutSessionManager&gt; _logger;</code></p><p><code>private</code> <code>IDistributedCache _cache;</code></p><p><code>private</code> <code>const</code> <code>int</code> <code>cacheExpirationInDays = 8;</code></p><p><code>public</code> <code>LogoutSessionManager(ILoggerFactory loggerFactory, IDistributedCache cache)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_cache = cache;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_logger = loggerFactory.CreateLogger&lt;LogoutSessionManager&gt;();</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p>When a logout is initialized by a user, from an application, this request is sent to the OpenID Connect server. The server does the logout logic, and sends requests back to all applications that have the back-channel configured.</p>
<p>The <a href="https://github.com/damienbod/AspNetCoreBackChannelLogout/blob/master/MvcHybridBackChannel/Controllers/LogoutController.cs">LogoutController </a>handles this request from the Secure Token Server, and adds a key pair to the Redis cache using the sid and the sub.</p>
<p>The Redis cache is shared between all instances of the client application and needs to be thread safe. Then all client instances can check if the user, application needs to be logged out.</p>
<div><div id="highlighter_240508"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p></td><td><div><p><code>public</code> <code>void</code> <code>Add(</code><code>string</code> <code>sub, </code><code>string</code> <code>sid)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_logger.LogWarning($</code><code>"Add a logout to the session: sub: {sub}, sid: {sid}"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>options = </code><code>new</code> <code>DistributedCacheEntryOptions()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>.SetSlidingExpiration(TimeSpan.FromDays(cacheExpirationInDays));</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lock</code> <code>(_lock)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>key = sub + sid;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>logoutSession = _cache.GetString(key);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(logoutSession != </code><code>null</code><code>)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>session = JsonConvert.DeserializeObject&lt;Session&gt;(logoutSession);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>newSession = </code><code>new</code> <code>Session { Sub = sub, Sid = sid };</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_cache.SetString(key, JsonConvert.SerializeObject(newSession), options);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p>The IsLoggedOutAsync method is used to check if a logout request exists for the application, user. This method uses the sid and sub values, to request the Redis value, if it exists.</p>
<div><div id="highlighter_370273"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p></td><td><div><p><code>public</code> <code>async</code> <code>Task&lt;</code><code>bool</code><code>&gt; IsLoggedOutAsync(</code><code>string</code> <code>sub, </code><code>string</code> <code>sid)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>key = sub + sid;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>matches = </code><code>false</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>logoutSession = </code><code>await</code> <code>_cache.GetStringAsync(key);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(logoutSession != </code><code>null</code><code>)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>session = JsonConvert.DeserializeObject&lt;Session&gt;(logoutSession);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>matches = session.IsMatch(sub, sid);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_logger.LogInformation($</code><code>"Logout session exists T/F {matches} : {sub}, sid: {sid}"</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>matches;</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p>The method is used in the CookieEventHandler class in the ValidatePrincipal method to end the session if a logout request was found.</p>
<div><div id="highlighter_297334"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><div><p><code>public</code> <code>override</code> <code>async</code> <code>Task ValidatePrincipal(CookieValidatePrincipalContext context)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(context.Principal.Identity.IsAuthenticated)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>sub = context.Principal.FindFirst(</code><code>"sub"</code><code>)?.Value;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>sid = context.Principal.FindFirst(</code><code>"sid"</code><code>)?.Value;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(</code><code>await</code> <code>LogoutSessions.IsLoggedOutAsync(sub, sid))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>context.RejectPrincipal();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>await</code> <code>context.HttpContext.SignOutAsync(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>CookieAuthenticationDefaults.AuthenticationScheme);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>
<p>The CookieEventHandler was added in the Startup to the cookie configuration.</p>
<div><div id="highlighter_751313"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p></td><td><div><p><code>.AddCookie(options =&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.ExpireTimeSpan = TimeSpan.FromMinutes(60);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.Cookie.Name = </code><code>"mvchybridbc"</code><code>;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>options.EventsType = </code><code>typeof</code><code>(CookieEventHandler);</code></p><p><code>})</code></p></div></td></tr></tbody></table></div></div>
<p>Now Azure Redis cache is used to handle the back-channel logouts from the Secure Token Server. </p>
<p><strong>Configure IdentityServer4 for custom end session Logic</strong></p>
<p>If you want more control over how and what back-channel clients receive a request,  you can implement the IEndSessionRequestValidator interface when using IdentityServer4. The GetClientEndSessionUrlsAsync method could be edited to change the required clients which will be called after a logout event.</p>
<div><div id="highlighter_160391"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><div><p><code>protected</code> <code>virtual</code> <code>async</code> <code>Task&lt;(IEnumerable&lt;</code><code>string</code><code>&gt; frontChannel, </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>IEnumerable&lt;BackChannelLogoutModel&gt; backChannel)&gt; </code></p><p><code>&nbsp;&nbsp;</code><code>GetClientEndSessionUrlsAsync(EndSession endSession)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>frontChannelUrls = </code><code>new</code> <code>List&lt;</code><code>string</code><code>&gt;();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>backChannelLogouts = </code><code>new</code> <code>List&lt;BackChannelLogoutModel&gt;();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>List&lt;</code><code>string</code><code>&gt; backchannelLogouts = </code><code>new</code> <code>List&lt;</code><code>string</code><code>&gt;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"mvc.hybrid.backchannel"</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>"mvc.hybrid.backchanneltwo"</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>};</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>foreach</code> <code>(</code><code>var</code> <code>clientId </code><code>in</code> <code>backchannelLogouts)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p></div></td></tr></tbody></table></div></div>
<p>If the IEndSessionRequestValidator is implemented, this needs to be added to the ASP.NET Core IoC.</p>
<div><div id="highlighter_856447"><table><tbody><tr><td><p>1</p><p>2</p></td><td><div><p><code>services.AddTransient&lt;IEndSessionRequestValidator, </code></p><p><code>&nbsp;&nbsp;&nbsp;</code><code>MyEndSessionRequestValidator&gt;();</code></p></div></td></tr></tbody></table></div></div>
<p><strong>Notes, Problems</strong></p>
<p>One problem with this, is that all logouts are saved to the cache for n-days. If the logouts are removed to early, the logout will not work for a client application which is opened after this, or if the logout items are kept to long, the size of the Redis cache will be very large in size, and cost.</p>
<p><strong>Links:</strong></p>
<p><a href="https://joonasw.net/view/redis-cache-session-store" rel="nofollow">https://joonasw.net/view/redis-cache-session-store</a></p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed?view=aspnetcore-2.2#distributed-redis-cache" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed?view=aspnetcore-2.2#distributed-redis-cache</a></p>
<p><a href="https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/" rel="nofollow">https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/</a></p>
<p><a href="https://blogs.msdn.microsoft.com/luisdem/2016/09/06/azure-redis-cache-on-asp-net-core/" rel="nofollow">https://blogs.msdn.microsoft.com/luisdem/2016/09/06/azure-redis-cache-on-asp-net-core/</a></p>
<p><a href="https://openid.net/specs/openid-connect-backchannel-1_0.html" rel="nofollow">https://openid.net/specs/openid-connect-backchannel-1_0.html</a></p>
<p><a href="http://docs.identityserver.io/en/release/topics/signout.html" rel="nofollow">http://docs.identityserver.io/en/release/topics/signout.html</a></p>


<p><a href="https://ldapwiki.com/wiki/OpenID%20Connect%20Back-Channel%20Logout" rel="nofollow">https://ldapwiki.com/wiki/OpenID%20Connect%20Back-Channel%20Logout</a></p>
<p><a href="https://datatracker.ietf.org/meeting/97/materials/slides-97-secevent-oidc-logout-01" rel="nofollow">https://datatracker.ietf.org/meeting/97/materials/slides-97-secevent-oidc-logout-01</a></p>
<p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-2.2" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-2.2</a></p>
<p><a href="https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart" rel="nofollow">https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart</a></p>

							
							
						</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>