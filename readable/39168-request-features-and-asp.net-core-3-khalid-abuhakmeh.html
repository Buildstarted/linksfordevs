<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Request Features And ASP.NET Core 3 | Khalid Abuhakmeh -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Request Features And ASP.NET Core 3  |
      Khalid Abuhakmeh</h1><div><div class="post-content"><p>With <a href="https://dot.net">ASP.NET Core</a>, developers have several new tools to build their web applications. One feature that I am incredibly excited about is request features.</p><p><strong>In ASP.NET Core, a request feature is an entity created during a user’s HTTP request. The entity is generally created within middleware for the purpose of allowing developers to enhance or modify the current application’s hosting pipeline.</strong></p><p>In this post, I will show you a few things:</p><ol><li>How to create a request feature</li><li>How to register it within your application’s hosting pipeline</li><li>How to retrieve it for use within any subsequent pipeline element</li><li>Mutate the request feature.</li></ol><p>Before we get started with a code sample, let’s talk about some of the features ASP.NET Core comes with by default.</p><p><strong><a href="https://github.com/khalidabuhakmeh/aspnetfeatures">Download the project now</a></strong></p><h2 id="what-is-a-request-feature">What Is A Request Feature</h2><p>As mentioned above, a request feature is a class that helps developers enhance or modify the current application’s hosting pipeline. These features are accessible via the <code class="highlighter-rouge">HttpContext</code> of an incoming request.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HttpContext</span><span class="p">.</span><span class="n">Features</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">MyAwesomeFeature</span><span class="p">&gt;();</span></code></pre></div></div><p>Features can be any class you implement and generally regarded as mutable and scoped within the lifetime of a single user request. ASP.NET Core has default features that include functions around authentication, request accessors, file manipulation, and session management. To get a complete list, I recommend the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/request-features?view=aspnetcore-3.0">Microsoft documentation site</a>.</p><p>One of the more exciting features mentioned in the Microsoft documentation is the <code class="highlighter-rouge">IHttpSendFileFeature</code> .</p><blockquote><p>If the feature exists, it’s used to send the requested static file from its physical path. Otherwise, a slower alternative method is used to send the file. When available, the IHttpSendFileFeature allows the operating system to open the file and perform a direct kernel mode copy to the network card. <cite>–<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/request-features?view=aspnetcore-3.0">Microsoft Docs</a></cite></p></blockquote><p>As you may notice reading through the documentation, Microsoft predominantly uses request features for low-level HTTP manipulation. Don’t let the documentation fool you; request features are not just limited to that.</p><h2 id="how-to-create-a-request-feature">How To Create A Request Feature</h2><p>A request feature is any class you can imagine. I do have some recommendations around what you should consider as a request feature:</p><ol><li>Is feature data generally stable or even read-only?</li><li>Is feature data used in many places throughout my request pipeline?</li><li>Is the feature data dependant on an HTTP element such as cookies, query strings, or headers?</li></ol><p>In this post, I’ll be building a <code class="highlighter-rouge">Clock</code> feature. This feature will allow us to set the time zone of our user and then pass that feature through or pipeline. Let’s look at our class.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="k">class</span><span class="nc">Clock</span><span class="p">{</span><span class="k">public</span><span class="n">DateTimeOffset</span><span class="n">DateTime</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="k">set</span><span class="p">;</span><span class="p">}</span><span class="p">=</span><span class="n">DateTimeOffset</span><span class="p">.</span><span class="n">UtcNow</span><span class="p">;</span><span class="k">public</span><span class="n">TimeZoneInfo</span><span class="n">TimeZone</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="k">set</span><span class="p">;</span><span class="p">}</span><span class="p">=</span><span class="n">TimeZoneInfo</span><span class="p">.</span><span class="n">Utc</span><span class="p">;</span><span class="k">public</span><span class="n">DateTimeOffset</span><span class="n">Local</span><span class="p">=&gt;</span><span class="n">TimeZoneInfo</span><span class="p">.</span><span class="nf">ConvertTimeBySystemTimeZoneId</span><span class="p">(</span><span class="n">DateTime</span><span class="p">,</span><span class="n">TimeZone</span><span class="p">?.</span><span class="n">Id</span><span class="p">??</span><span class="n">TimeZoneInfo</span><span class="p">.</span><span class="n">Utc</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><p>We are utilizing <code class="highlighter-rouge">TimeZoneInfo</code> and <code class="highlighter-rouge">DateTimeOffset</code> to help us determine the local time of our user’s timezone.</p><p>If we take a step back and think about the questions I posed above, we can answer them.</p><ul><li>Is feature data generally stable or even read-only? <strong>Yes, a user’s time zone does not change frequently once selected.</strong></li><li>Is feature data used in many places throughout my request pipeline? <strong>Most likely. If I were building a data application, I might want to know a user’s time zone to convert application times to relevant user times appropriately.</strong></li><li>Is the feature data dependant on an HTTP element such as cookies, query strings, or headers? <strong>We’ll see in the next section, but yes! We are storing the timezone in a cookie. Even if we weren’t, we’d most likely be using a user identifier from the current user.</strong></li></ul><h2 id="how-to-register-a-request-feature">How to Register A Request Feature</h2><p>As you may have read earlier, we register features within a middleware. For this example, we will need to write a <code class="highlighter-rouge">ClockMiddleware</code>.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="k">class</span><span class="nc">ClockMiddleware</span><span class="p">:</span><span class="n">IMiddleware</span><span class="p">{</span><span class="k">public</span><span class="k">const</span><span class="kt">string</span><span class="n">TimeZoneKey</span><span class="p">=</span><span class="s">"clock.timezone"</span><span class="p">;</span><span class="k">public</span><span class="k">async</span><span class="n">Task</span><span class="nf">InvokeAsync</span><span class="p">(</span><span class="n">HttpContext</span><span class="n">context</span><span class="p">,</span><span class="n">RequestDelegate</span><span class="n">next</span><span class="p">)</span><span class="p">{</span><span class="kt">var</span><span class="n">clock</span><span class="p">=</span><span class="k">new</span><span class="nf">Clock</span><span class="p">();</span><span class="k">if</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Request</span><span class="p">.</span><span class="n">Cookies</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">TimeZoneKey</span><span class="p">,</span><span class="k">out</span><span class="kt">var</span><span class="n">timezone</span><span class="p">))</span><span class="p">{</span><span class="n">clock</span><span class="p">.</span><span class="n">TimeZone</span><span class="p">=</span><span class="n">TimeZoneInfo</span><span class="p">.</span><span class="nf">FindSystemTimeZoneById</span><span class="p">(</span><span class="n">timezone</span><span class="p">)</span><span class="p">??</span><span class="n">TimeZoneInfo</span><span class="p">.</span><span class="n">Utc</span><span class="p">;</span><span class="p">}</span><span class="c1">// set the feature</span><span class="n">context</span><span class="p">.</span><span class="n">Features</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="n">clock</span><span class="p">);</span><span class="k">await</span><span class="nf">next</span><span class="p">(</span><span class="n">context</span><span class="p">);</span><span class="p">}</span><span class="k">public</span><span class="k">static</span><span class="k">void</span><span class="nf">SetTimeZone</span><span class="p">(</span><span class="n">HttpResponse</span><span class="n">response</span><span class="p">,</span><span class="kt">string</span><span class="n">timeZoneId</span><span class="p">)</span><span class="p">{</span><span class="n">response</span><span class="p">.</span><span class="n">Cookies</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="n">TimeZoneKey</span><span class="p">,</span><span class="n">timeZoneId</span><span class="p">);</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>This middleware will instantiate a <code class="highlighter-rouge">Clock</code> and push it into the <code class="highlighter-rouge">Features</code> collection that hangs from our <code class="highlighter-rouge">HttpContext</code>. Additionally, if the current user has already set their time zone and has a cookie, we will change our feature to reflect the current time zone.</p><p>To register our middleware, we add it to the application’s pipeline.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">app</span><span class="p">.</span><span class="n">UseMiddleware</span><span class="p">&lt;</span><span class="n">ClockMiddleware</span><span class="p">&gt;();</span></code></pre></div></div><p>As a side note, I used the <code class="highlighter-rouge">IMiddleware</code> interface to create my middleware. The use of the interface means creation occurs with the help of the <code class="highlighter-rouge">MiddlewareFactory</code>. To make our example work, you will need to register our middleware within the services collection of our application.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// this is necessary because we are using</span><span class="c1">// the IMiddleware interface and the Middleware factory</span><span class="n">services</span><span class="p">.</span><span class="n">AddScoped</span><span class="p">&lt;</span><span class="n">ClockMiddleware</span><span class="p">&gt;();</span></code></pre></div></div><p>You can read more about <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write?view=aspnetcore-3.0">middleware</a> at the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write?view=aspnetcore-3.0">Microsoft documentation site</a>.</p><h2 id="retrieve-a-request-feature">Retrieve a Request Feature</h2><p>In my example, I’ve built a simple Razor Pages application. The app allows us to see the local time of any time zone as it relates to the current moment. Select the time zone; see the local time.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="k">void</span><span class="nf">OnGet</span><span class="p">()</span><span class="p">{</span><span class="n">Clock</span><span class="p">=</span><span class="n">HttpContext</span><span class="p">.</span><span class="n">Features</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">Clock</span><span class="p">&gt;();</span><span class="n">TimeZone</span><span class="p">=</span><span class="n">Clock</span><span class="p">.</span><span class="n">TimeZone</span><span class="p">;</span><span class="n">TimeZoneId</span><span class="p">=</span><span class="n">Clock</span><span class="p">.</span><span class="n">TimeZone</span><span class="p">.</span><span class="n">Id</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>By the time we reach the Razor page, our middleware has already instantiated our <code class="highlighter-rouge">Clock</code> and added it to the features collection. It is just a matter of asking for the feature.</p><h2 id="mutate-the-request-feature">Mutate the Request feature.</h2><p>There are several ways to mutate a request feature. Since request features <em>should</em> be limited to the scope of a user request, you could manipulate the properties directly. In the case of our <code class="highlighter-rouge">ClockMiddleware</code>, we know we are reading from an HTTP cookie.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="n">IActionResult</span><span class="nf">OnPost</span><span class="p">()</span><span class="p">{</span><span class="n">ClockMiddleware</span><span class="p">.</span><span class="nf">SetTimeZone</span><span class="p">(</span><span class="n">Response</span><span class="p">,</span><span class="n">TimeZoneId</span><span class="p">);</span><span class="k">return</span><span class="nf">RedirectToPage</span><span class="p">(</span><span class="s">"Index"</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><p>On the following request, our <code class="highlighter-rouge">Clock</code> feature should reflect the updated time zone.</p><p>Here is the application in action.</p><p><img src="https://d33wubrfki0l68.cloudfront.net/4e05da5dba69abd6076b377c426a3d35061ec98c/45665/assets/images/generated/aspnetrequestfeatures/aspnetcore_requestfeatures-800-e1394a.png" alt="working asp.net core request feature sample" srcset="https://d33wubrfki0l68.cloudfront.net/574caaced8c88d4223838880e7b171383a636d39/19a7e/assets/images/generated/aspnetrequestfeatures/aspnetcore_requestfeatures-400-e1394a.png 400w, https://d33wubrfki0l68.cloudfront.net/5ecc46d534b7e736e381291b259e34683e10f8e8/d69fb/assets/images/generated/aspnetrequestfeatures/aspnetcore_requestfeatures-600-e1394a.png 600w, https://d33wubrfki0l68.cloudfront.net/4e05da5dba69abd6076b377c426a3d35061ec98c/45665/assets/images/generated/aspnetrequestfeatures/aspnetcore_requestfeatures-800-e1394a.png 800w, https://d33wubrfki0l68.cloudfront.net/3b0660fc4def503a2f9b79cd2dd5b4579319fdf3/fea95/assets/images/generated/aspnetrequestfeatures/aspnetcore_requestfeatures-1000-e1394a.png 1000w"></p><h2 id="pros-and-cons-of-request-features">Pros and Cons Of Request Features</h2><p>While being new to ASP.NET Core, the request feature collection does look similar to something we’ve had for a long time already: Dependency Injection. The sample I gave could be implemented using an Inversion Of Control (IoC) library. That said, I hope I can convince you to consider a request feature over IoC in some cases by listing the Pros and Cons.</p><h3 id="pros-of-request-features">Pros of Request Features</h3><p>The most compelling reason to use Request Features is the way you can instantiate a feature. Using a piece of middleware to create an object means you can more clearly utilize the incoming HTTP request, and potentially the response.</p><p>If you were to attempt the same code with an IoC library, you would likely end up writing complicated factories with a myriad of dependencies.</p><p>The other compelling reason is it is evident that features are tied to the request context and scoped to the user. Request features can help reduce captured dependencies or cross-threading issues (but not eliminate them).</p><p>Finally, my favorite is <strong>performance</strong>. If your feature is read in many places but doesn’t change frequently, then it makes sense to instantiate early and once. Doing the work upfront in your pipeline reduces unnecessary network calls, object allocations, and more.</p><h3 id="cons-of-request-features">Cons of Request Features</h3><p>The approach can very much feel like the <a href="https://en.wikipedia.org/wiki/Service_locator_pattern">service locator pattern</a>, which shunned by many IoC practitioners.</p><blockquote><p>The service locator pattern is a design pattern or anti-pattern used in software development to encapsulate the processes involved in obtaining a service with a strong abstraction layer. This pattern uses a central registry known as the “service locator,” which on request returns the information necessary to perform a certain task.<cite><a href="https://en.wikipedia.org/wiki/Service_locator_pattern">–Wikipedia</a></cite></p></blockquote><p>Personally, request features feel more like accessing a user’s context. Objects are specific to a user, rather than a dependency like a database, web API, or third party service. If you are a purist, you could always register a factory within the IoC container that injects the <code class="highlighter-rouge">Clock</code> as a constructor or parameter dependency. In <code class="highlighter-rouge">Startup.ConfigureServices</code> add the following:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// for you IoC purists</span><span class="n">services</span><span class="p">.</span><span class="nf">AddScoped</span><span class="p">(</span><span class="n">provider</span><span class="p">=&gt;</span><span class="p">{</span><span class="kt">var</span><span class="n">ctx</span><span class="p">=</span><span class="n">provider</span><span class="p">.</span><span class="n">GetRequiredService</span><span class="p">&lt;</span><span class="n">IHttpContextAccessor</span><span class="p">&gt;();</span><span class="kt">var</span><span class="n">clock</span><span class="p">=</span><span class="n">ctx</span><span class="p">.</span><span class="n">HttpContext</span><span class="p">.</span><span class="n">Features</span><span class="p">.</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">Clock</span><span class="p">&gt;();</span><span class="k">return</span><span class="n">clock</span><span class="p">??</span><span class="k">new</span><span class="nf">Clock</span><span class="p">();</span><span class="p">});</span></code></pre></div></div><p>Another issue might stem from the mutation of our feature. You could experience unexpected behavior based on how many code blocks are mutating your data. If your request feature has connections to a data source, it may just make sense to read it every time and bypass a request feature.</p><p>Request features and the HTTP context are tied together. Request features make sense in a web application, but can be problematic if you share code between multiple hosting environments. Improper implementation can lead to leaked abstractions into unexpected areas of your system.</p><p>Finally, this one is minor but significant to mention. <strong>Ordering your middleware matters.</strong> You must instantiate a feature before you can access it. Register your middleware as early as it makes sense, or you’ll have unexpected and strange exceptions.</p><h2 id="the-difference-between-request-features-and-httpcontextitems">The Difference Between Request Features and HttpContext.Items</h2><p>As an ASP.NET developer, you may also be familiar with <code class="highlighter-rouge">HttpContext.Items</code>. There are a few differences, but both can be used to accomplish the same results. Both collections are <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpcontext.items?view=aspnetcore-3.0">scoped within the lifetime of the request</a> and can hold objects. As for what’s different, here is what I found.</p><h3 id="1-different-keys">1. Different Keys</h3><p>The first difference is the <code class="highlighter-rouge">IFeaturesCollection</code> keys items by the <code class="highlighter-rouge">Type</code> of the feature.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="k">interface</span><span class="nc">IFeatureCollection</span><span class="p">:</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">KeyValuePair</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">,</span><span class="kt">object</span><span class="p">&gt;&gt;,</span><span class="n">IEnumerable</span><span class="p">{</span><span class="kt">bool</span><span class="n">IsReadOnly</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="p">}</span><span class="kt">int</span><span class="n">Revision</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="p">}</span><span class="kt">object</span><span class="k">this</span><span class="p">[</span><span class="n">Type</span><span class="n">key</span><span class="p">]</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="k">set</span><span class="p">;</span><span class="p">}</span><span class="n">TFeature</span><span class="n">Get</span><span class="p">&lt;</span><span class="n">TFeature</span><span class="p">&gt;();</span><span class="k">void</span><span class="n">Set</span><span class="p">&lt;</span><span class="n">TFeature</span><span class="p">&gt;(</span><span class="n">TFeature</span><span class="n">instance</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><p>Whereas the <code class="highlighter-rouge">HttpContext.Items</code> use an <code class="highlighter-rouge">object</code> for both the key and the value.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="k">override</span><span class="n">IDictionary</span><span class="p">&lt;</span><span class="kt">object</span><span class="p">,</span><span class="kt">object</span><span class="p">&gt;</span><span class="n">Items</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="k">set</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><h3 id="2-constraints">2. Constraints</h3><p>Since the <code class="highlighter-rouge">IFeatureCollection</code>  has <code class="highlighter-rouge">Type</code> as a key, you can only have one instance of any specific feature. The constraint is a good thing, since features usually are foundational to an app, and having multiple of the same feature probably means a misconfiguration has occurred. That said, each application is different.</p><h3 id="3-box-allocations">3. Box Allocations</h3><p>This next point may be a micro-optimization but <code class="highlighter-rouge">HttpContext.Items</code> require that you box and unbox both the key and value of the pair. These allocations can lead to additional memory overhead. With request features, you are only unboxing the value, which in this case, is the feature.</p><h2 id="conclusion">Conclusion</h2><p>Request features can help you increase the performance of your web applications by limiting where and when you instantiate objects. It can also lead to more clarity in your pipeline code as you can <em>expect</em> the feature to be ready for use. Think about the questions mentioned above and see if it makes sense to refactor some of your code to make better use of this ASP.NET Core killer addition.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>