<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Do we need effects to get abstraction? - barely-functional -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Do we need effects to get abstraction? - barely-functional</h1><div><div class="ac ae af ag ah dp aj ak"><figure class="gi gj gk gl gm gn db dc paragraph-image"><p id="4f7f" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">Sandy Maguire gave an <a href="https://www.youtube.com/watch?v=-dHFOjcK6pA" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">excellent talk on his latest library: polysemy</a>. I highly encourage you to watch it because Sandy also presents other libraries: <code class="gy hw hx hy hz b">freer</code>, <code class="gy hw hx hy hz b">fused-effect</code>, and how they differ from <code class="gy hw hx hy hz b">polysemy</code> in a quest for expressivity, performance and boilerplate-removal.</p><p id="23be" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">While I am very impressed by the recent improvements in effects libraries I am still thinking “do we need any of this?”. If I scroll back to Sandy’s original motivations for using effects I hear that he was working a system which was a<code class="gy hw hx hy hz b">Big ball o' IO spaghetti</code>, <code class="gy hw hx hy hz b">impossible to test</code>. His conclusion is that we need to write programs at a high-level (he says in a <code class="gy hw hx hy hz b">domain-specific language, a DSL</code>) and run a series of transformations to lower-level DSLs. Thus: effects. I say: maybe not!</p><h1 id="d97d" class="ia ib ds ba az ic du id dw ie if ig ih ii ij ik il">Levels of abstraction</h1><p id="9654" class="he hf ds ba hg b hh im hj in hl io hn ip hp iq hr dk">I fully endorse the intention though. If we can describe our applications / services at different levels of abstraction we get fantastic abilities to understand them, evolve them, test them. And Sandy gives a great example in his presentation, which is more fully developed in <a href="https://reasonablypolymorphic.com/blog/freer-monads/" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">one of his blog posts</a> on freer monads:</p><blockquote class="ir is it"><p id="a2c0" class="he hf ds iu hg b hh hi hj hk hl hm hn ho hp hq hr dk">write a program that fetches a CSV file from FTP, decrypts it, streams its contents to an external pipeline, and tracks its stats in Redis.</p></blockquote><p id="35d1" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">And the program should look like this:</p><figure class="gi gj gk gl gm gn"><p id="6337" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">This is indeed very high-level, we really get the “heart” of the application which is to repeatedly read records and process them. Then with a series of interpreters we can derive the full program which will communicate with FTP, decrypt, and so on:</p><figure class="gi gj gk gl gm gn"><p id="5cb3" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">Pretty cool but <a class="fc cf hs ht hu hv" target="_blank" rel="noopener" href="/barely-functional/freer-doesnt-come-for-free-c9fade793501">I am still unconvinced that we need effect libraries to do any of this</a>.</p><h1 id="519b" class="ia ib ds ba az ic du id dw ie if ig ih ii ij ik il">Interface / Implementation</h1><p id="1223" class="he hf ds ba hg b hh im hj in hl io hn ip hp iq hr dk">What we want is some way to:</p><ul class=""><li id="d4f6" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr iw ix iy">separate an abstract interface from its implementation(s)</li><li id="ebf1" class="he hf ds ba hg b hh iz hj ja hl jb hn jc hp jd hr iw ix iy">connect the two</li></ul><p id="6666" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">This is not a very new idea because it is a the heart of many modularity efforts. Abstract Data Types are an example of that. They were pioneered by Barbara Liskov (yes from the “<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">Liskov substitution principle</a>”) and Stephen Zilles in 1974 and fully adopted in the ADA programming language where they enable the programmer to hide details like memory layout and management. An Abstract Data Type provides the representation of some data as a set of operations (its “interface”) while keeping an internal representation (its “implementation”) hidden. This is not very far from writing: it provides a “DSL” and an “interpreter”.</p><p id="75db" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">So I thought: “can we create the same application without effects?”. In particular can I use simple “records-of-functions” in Haskell +my <code class="gy hw hx hy hz b"><a href="http://github.com/etorreborre/registry" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">registry</a></code> library to get to the same level of abstraction and ease of testing?</p><h1 id="e300" class="ia ib ds ba az ic du id dw ie if ig ih ii ij ik il">With records of functions</h1><p id="8333" class="he hf ds ba hg b hh im hj in hl io hn ip hp iq hr dk">First surprise: I can’t do it! Indeed the <code class="gy hw hx hy hz b">Input</code> effect is quite peculiar. It provides a <code class="gy hw hx hy hz b">Maybe i</code> out of an input source. If you want to declare and implement it as a separate module you either have to:</p><ul class=""><li id="8866" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr iw ix iy">create a <em class="iu">stateful module</em> where you track the current flow of inputs. This requires some <code class="gy hw hx hy hz b">IO</code> and the FP crowd might frown upon that (I don’t)</li><li id="5a42" class="he hf ds ba hg b hh iz hj ja hl jb hn jc hp jd hr iw ix iy">“outsource” the state management to the rest of the program. This is what is done with the effects approach where the meaning of the <strong class="hg je">whole program</strong> is made (functionally) stateful when using the <code class="gy hw hx hy hz b">csvInput</code> interpreter</li></ul><p id="1ca6" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">This is an important realization. With effects you interpret <em class="iu">full programs</em> giving them specific meanings whereas with simple “records of functions” you “inject” a specific behaviour with only a “local” meaning. That’s why approaches like effects or <a href="http://okmij.org/ftp/tagless-final/index.html" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">finally tagless</a> are still valuable for some situations like <a href="https://koka-lang.github.io/koka/doc/kokaspec.html#sec-a-primer-on-effect-handlers" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">non-deterministic effects</a> which are almost equivalent to full program rewrite.</p><p id="5498" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">Is this a blocker? I don’t think so. This capacity to “yield elements on demand” is at the core of any streaming library and Sandy’s application is fundamentally a streaming service. So having a component which, as its interface, returns a <code class="gy hw hx hy hz b">Stream a</code> is almost as good, if not better than returning <code class="gy hw hx hy hz b">Maybe a</code>. You can indeed argue that it is even better because you don’t even have to recurse in the <code class="gy hw hx hy hz b">ingest</code> function. You can have the following <code class="gy hw hx hy hz b">main</code>:</p><figure class="gi gj gk gl gm gn"><p id="6050" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">The top-level application is fairly similar to Sandy’s example and is structured as:</p><ul class=""><li id="67e8" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr iw ix iy">a stream producer: <code class="gy hw hx hy hz b">readInput</code></li><li id="83ba" class="he hf ds ba hg b hh iz hj ja hl jb hn jc hp jd hr iw ix iy">a stream transformer: <code class="gy hw hx hy hz b">saveOutputs</code></li><li id="4768" class="he hf ds ba hg b hh iz hj ja hl jb hn jc hp jd hr iw ix iy">a stream consumer: <code class="gy hw hx hy hz b">saveStats</code></li></ul><p id="a0d7" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">It keeps all the good properties of the original example:</p><ul class=""><li id="5a3d" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr iw ix iy">it is modular in the sense that the way we output elements is fully decoupled from the way we read them for example</li><li id="4f40" class="he hf ds ba hg b hh iz hj ja hl jb hn jc hp jd hr iw ix iy">the details of how we perform the operations are fully encapsulated in each component: <code class="gy hw hx hy hz b">input</code>, <code class="gy hw hx hy hz b">output</code> and <code class="gy hw hx hy hz b">stats</code></li></ul><p id="921c" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">But Sandy has more challenges for us! First challenge: provide records from a <code class="gy hw hx hy hz b">FileProvider</code> which could either be a local file or a file coming from a FTP server. Second challenge: decrypt the file without having to modify the <code class="gy hw hx hy hz b">FileProvider</code> component. Third challenge: batch the outputs to reduce the number of API calls.</p><h1 id="84c6" class="ia ib ds ba az ic du id dw ie if ig ih ii ij ik il">Abstracting over file provenance</h1><p id="40f9" class="he hf ds ba hg b hh im hj in hl io hn ip hp iq hr dk">This one is not hard. If we have a component describing the reading of inputs with the following interface:</p><figure class="gi gj gk gl gm gn"><p id="ffa4" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">We can provide a “constructor” which will create this component with the help of a <code class="gy hw hx hy hz b">FileProvider</code></p><figure class="gi gj gk gl gm gn"><p id="30ae" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">Here we don’t know where the file comes from but we do the job of parsing it as a CSV file and returning a stream. The <code class="gy hw hx hy hz b">FileProvider</code> itself can be implemented as:</p><figure class="gi gj gk gl gm gn"><p id="54dd" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">As you can see we have 2 implementations here, one for FTP, using some <code class="gy hw hx hy hz b">Ftp</code> capability and another one which would just read files from disk. This almost solves the first challenge: have different layers of abstraction and possibly different implementations at each level. What is missing is a way to select a specific set of implementations like Sandy does with all the <code class="gy hw hx hy hz b">runXXX</code> interpreters in his example. This is provided by the <code class="gy hw hx hy hz b">registry</code> library:</p><figure class="gi gj gk gl gm gn"><p id="f84f" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">Here we have the application, <code class="gy hw hx hy hz b">App</code>, containing the top-level components and a <code class="gy hw hx hy hz b">registry</code> describing all the exact constructors needed to build the application (I will not explain here the role of the various operators like <code class="gy hw hx hy hz b">funTo </code>and the type applications, please head to the <code class="gy hw hx hy hz b"><a href="https://github.com/etorreborre/registry/blob/master/README.md" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">registry</a></code><a href="https://github.com/etorreborre/registry/blob/master/README.md" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow"> documentation</a> if you want to know more).</p><p id="2a9b" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">How can we run the application with a<code class="gy hw hx hy hz b">LocalFileProvider</code> instead? Easy, you “override” the registry with the <code class="gy hw hx hy hz b">newLocalFileProvider</code> constructor:</p><figure class="gi gj gk gl gm gn"><p id="6165" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">The program doesn’t change, we are just running it with a different set of implementations.</p><p id="a497" class="he hf ds ba hg b hh im hj in hl io hn ip hp iq hr dk">This fully solves the “testing challenge” because we have an easy way to “tweak” the behaviour of the application under test. By <strong class="hg je">just changing one line</strong>. On the other hand with effects and interpreters you have to rewrite the full <code class="gy hw hx hy hz b">runM . runRedis . runHttp ...</code> function spanning 10 lines to just change one thing. You could even do more crazy things like providing a working <code class="gy hw hx hy hz b">Http</code> component for posting outputs and a failing one for posting statistic (2 different instances for the same type).</p><h1 id="b3c1" class="ia ib ds ba az ic du id dw ie if ig ih ii ij ik il">Decrypting files</h1><p id="7e11" class="he hf ds ba hg b hh im hj in hl io hn ip hp iq hr dk">This is seemingly one of the big advantages of effects. Being able to “intercept” a given effect to give it a slightly different meaning:</p><figure class="gi gj gk gl gm gn"><p id="cf37" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">With components and constructors this can be done by having a “decorator”, a function taking an existing component and adding some functionality on top of it:</p><figure class="gi gj gk gl gm gn"><p id="d01b" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">With an existing <code class="gy hw hx hy hz b">FileProvider</code>, which we tag as <code class="gy hw hx hy hz b">clear</code> we can make another <code class="gy hw hx hy hz b">FileProvider</code>, this time providing decrypted files thanks to a new dependency, the <code class="gy hw hx hy hz b">Encryption</code> component. And the registry library takes care of wiring everything up:</p><figure class="gi gj gk gl gm gn"><p id="9c84" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">When you want to build an <code class="gy hw hx hy hz b">App</code> using the <code class="gy hw hx hy hz b">registry</code>, the library will follow the types and see that:</p><ul class=""><li id="3732" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr iw ix iy">a <code class="gy hw hx hy hz b">FileProvider</code> is required</li><li id="0cae" class="he hf ds ba hg b hh iz hj ja hl jb hn jc hp jd hr iw ix iy">it can be built with the <code class="gy hw hx hy hz b">newDecryptedFileProvider</code></li><li id="adde" class="he hf ds ba hg b hh iz hj ja hl jb hn jc hp jd hr iw ix iy">this requires a tagged <code class="gy hw hx hy hz b">clear</code><code class="gy hw hx hy hz b">FileProvider</code> which we get with <code class="gy hw hx hy hz b">newFtpFileProvider</code>, but also the<code class="gy hw hx hy hz b">Ftp</code> and <code class="gy hw hx hy hz b">Encryption</code> components which we can build with their respective constructor functions</li></ul><p id="1a7a" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">In summary it is possible to take existing components and “decorate” them or “intercept their interpretation” to create enhanced versions of those components.</p><h1 id="b13f" class="ia ib ds ba az ic du id dw ie if ig ih ii ij ik il">Batching outputs</h1><p id="7cc7" class="he hf ds ba hg b hh im hj in hl io hn ip hp iq hr dk">This is also a fantastic example of the power of effects. Someone gives you an additional technical constraint and you should be able to implement it without disrupting the majority of your program. With effects we create a function with the following signature:</p><pre class="gi gj gk gl gm jr js cr"><span id="6646" class="jf ib ds ba hz b ew jt ju r jv">batch<br>:: Int<br>-&gt; Eff (Output [i] ': r) a<br>-&gt; Eff (Output [i] ': r) a</span></pre><p id="b18d" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">Once again we “intercept” an existing effect and regroup the elements so that we send 500 at the time and not one by one. Note that the implementation Sandy provides is probably not totally suited for production since we wait until a batch is complete before posting it. In practice we would also post records after some delay, even if the batch is not complete. This would make the signature of <code class="gy hw hx hy hz b">batch</code> function slightly more complex (requiring an additional <code class="gy hw hx hy hz b">Time</code> effect in the stack).</p><p id="8949" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">Back to our components we have the following interface for the <code class="gy hw hx hy hz b">Output</code> component:</p><figure class="gi gj gk gl gm gn"><p id="e718" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">The <code class="gy hw hx hy hz b">Output</code> component is essentially a “stream transformer” and the <code class="gy hw hx hy hz b">newHttpOutput</code> constructor uses an <code class="gy hw hx hy hz b">Http</code> component to post the records. Here again we can apply the “decorator” pattern and “decorate” that component to create a new one where elements are being batched before being fed to the original one:</p><figure class="gi gj gk gl gm gn"><p id="1940" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk"><code class="gy hw hx hy hz b">batchesOf</code> uses some combinators from the fantastic <code class="gy hw hx hy hz b"><a href="https://hackage.haskell.org/package/streaming" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">streaming</a></code><a href="https://hackage.haskell.org/package/streaming" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow"> library</a> to batch records and we also “unbatch” elements after use because we still need to return a <code class="gy hw hx hy hz b">Stream (Of a) m ()</code> (don’t worry this is all fused at runtime).</p><h1 id="e397" class="ia ib ds ba az ic du id dw ie if ig ih ii ij ik il">Conclusion</h1><p id="6fa6" class="he hf ds ba hg b hh im hj in hl io hn ip hp iq hr dk">I am still amazed by all the hard work and progress made on effect libraries but I worry that the excitement of novelty hides what is really important when building applications:</p><ul class=""><li id="00e3" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr iw ix iy">a proper distinction between interface and implementation</li><li id="3d23" class="he hf ds ba hg b hh iz hj ja hl jb hn jc hp jd hr iw ix iy">an easy to wire and replace components</li></ul><p id="780f" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">There many ways to get there with different trade-offs: effects, records of functions (or the <a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">Handle pattern</a>), typeclasses and monad transformers.</p><p id="282e" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk">I hope that this blog post shows you that we don’t necessarily need <a href="https://chrispenner.ca/posts/mock-effects-with-data-kinds" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow">fancy type-level techniques</a> to build modular, testable applications with the right levels of abstraction.</p><p id="f90b" class="he hf ds ba hg b hh hi hj hk hl hm hn ho hp hq hr dk"><em class="iu">Update: the code for this post is available at </em><a href="https://github.com/etorreborre/ingestion" class="fc cf hs ht hu hv" target="_blank" rel="noopener nofollow"><em class="iu">https://github.com/etorreborre/ingestion</em></a><em class="iu"> if you want to play with it</em></p></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>