<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Build your own&#xA0;.NET memory profiler in C#&#x200A;&#x2014;&#x200A;allocations(1/2) - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Build your own&#xA0;.NET memory profiler in C#&#x200A;&#x2014;&#x200A;allocations(1/2) - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@chnasarre"/>
    <meta property="og:description" content="This post explains how to collect allocations details by writing your own memory profiler in C#."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@chnasarre/build-your-own-net-memory-profiler-in-c-allocations-1-2-9c9f0c86cefd"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Build your own&#xA0;.NET memory profiler in C#&#x200A;&#x2014;&#x200A;allocations(1/2)</title>
<div class="readable">
        <h1>Build your own&#xA0;.NET memory profiler in C#&#x200A;&#x2014;&#x200A;allocations(1/2)</h1>
            <div>by https://medium.com/@chnasarre</div>
            <div>Reading time: 10-13 minutes</div>
        <div>Posted here: 18 Apr 2020</div>
        <p><a href="https://medium.com/@chnasarre/build-your-own-net-memory-profiler-in-c-allocations-1-2-9c9f0c86cefd">https://medium.com/@chnasarre/build-your-own-net-memory-profiler-in-c-allocations-1-2-9c9f0c86cefd</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@chnasarre?source=post_page-----9c9f0c86cefd----------------------"><img alt="Christophe Nasarre" src="https://miro.medium.com/fit/c/96/96/0*p_afBNMUbL9S3Ojv" width="48" height="48"></a></p></div></div></div></div><p id="2d36" data-selectable-paragraph="">In a <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/spying-on-net-garbage-collector-with-net-core-eventpipes-9f2a986d5705">previous post</a>, I explained how to get statistics about the .NET Garbage Collector such as suspension time or generation sizes. But what if you would need more details about your application allocations such as how many times instances of a given type were allocated and for what cumulated size or even the allocation rate? This post explains how to get access to such information by writing your own memory profiler. The next one will show how to collect each sampled allocation stack trace.</p><p id="73ee" data-selectable-paragraph="">I have already used commercial tools to get detailed information about allocated type instances in an application; Visual Studio Profiler, dotTrace, ANTS memory profiler or Perfview to name a few. With these tools in mind, I started to look at the .NET profiler API documentation and it reminded me the first time I read about the .NET profiler API. It was in December 2001 in <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2001/december/under-the-hood-the-net-profiling-api-and-the-dnprofiler-tool" target="_blank" rel="noopener nofollow">Matt Pietrek’s MSDN Magazine article</a> (I still have the paper version). When your application is starting, based on environment variable, the .NET Framework (and now .NET Core) runtime is loading a profiler COM object that implements a specific <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilercallback9-interface" target="_blank" rel="noopener nofollow"><strong>ICorProfilerCallback</strong></a> interface (today, runtimes are supporting the 9th version <strong>ICorProfilerCallback9</strong> interface). The methods of this interface will be called by the runtime at specific moments during the application lifetime. For example, the <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilercallback-objectallocated-method" target="_blank" rel="noopener nofollow"><strong>ObjectAllocated</strong> method</a> is called each time an instance of a class is allocated: perfect for the job but it requires going back to COM and writing native code. Don’t be scared: I won’t go that way :^)</p><p id="5002" data-selectable-paragraph=""><em>However, if you would like to get more details about writing your own .NET profiler in C or C++, I would recommend to look at the Microsoft ClrProfiler </em><a href="https://github.com/microsoftarchive/clrprofiler/tree/master/CLRProfiler" target="_blank" rel="noopener nofollow"><em>initial .NET Framework implementation</em></a><em> and also Pavel Yosifovich DotNext session about </em><a href="https://www.youtube.com/watch?v=TqS4OEWn6hQ" target="_blank" rel="noopener nofollow"><em>Writing a .NET Core cross platform profiler in an hour</em></a><em> with the corresponding (more recent and cross platform) </em><a href="https://github.com/zodiacon/DotNextMoscow2019" target="_blank" rel="noopener nofollow"><em>source code</em></a><em>.</em></p><p id="c7a9" data-selectable-paragraph="">Instead, several events that are emitted by the CLR are providing interesting details:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*8RzRelU9Rgux0TJRdFhzzw.png?q=20" width="2292" height="1344" role="presentation"></p><p><img width="2292" height="1344" srcset="https://miro.medium.com/max/552/1*8RzRelU9Rgux0TJRdFhzzw.png 276w, https://miro.medium.com/max/1104/1*8RzRelU9Rgux0TJRdFhzzw.png 552w, https://miro.medium.com/max/1280/1*8RzRelU9Rgux0TJRdFhzzw.png 640w, https://miro.medium.com/max/1400/1*8RzRelU9Rgux0TJRdFhzzw.png 700w" sizes="700px" role="presentation" src="https://miro.medium.com/max/2292/1*8RzRelU9Rgux0TJRdFhzzw.png"></p></div></div></div></div></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*-DSm_89dq8yj8jI1aZ3ZYg.png?q=20" width="1018" height="594" role="presentation"></p><p><img width="1018" height="594" srcset="https://miro.medium.com/max/552/1*-DSm_89dq8yj8jI1aZ3ZYg.png 276w, https://miro.medium.com/max/1104/1*-DSm_89dq8yj8jI1aZ3ZYg.png 552w, https://miro.medium.com/max/1280/1*-DSm_89dq8yj8jI1aZ3ZYg.png 640w, https://miro.medium.com/max/1400/1*-DSm_89dq8yj8jI1aZ3ZYg.png 700w" sizes="700px" role="presentation" src="https://miro.medium.com/max/1018/1*-DSm_89dq8yj8jI1aZ3ZYg.png"></p></div></div></div></div></figure><p id="38b5" data-selectable-paragraph="">The <strong>GCSampledObjectAllocation</strong> events payload provides a type ID instead of a plain text type name. In order to retrieve the type name given its ID, we need to listen to <strong>TypeBulkType</strong> event that contains the mapping like I described in <a href="https://labs.criteo.com/2018/09/monitor-finalizers-contention-and-threads-in-your-application/" target="_blank" rel="noopener nofollow">my post about finalizers</a>. This is why the last two <strong>GCHeapAndTypeNames</strong> and <strong>Type</strong> keywords are needed.</p><p id="3cba" data-selectable-paragraph="">Remember that if both <strong>GCSampledObjectAllocationLow</strong> and <strong>GCSampledObjectAllocationHigh</strong> keywords are set, an event will be received for EACH allocation. This could be a performance issue both for the monitored application and the profiler. I would recommend to start with either low or high (more on this later).</p><p id="467c" data-selectable-paragraph="">Last but not least, enabling at least one of these keywords is also <a href="https://github.com/dotnet/runtime/blob/fcd862e06413a000f9cafa9d2f359226c60b9b42/src/coreclr/src/vm/jitinterfacegen.cpp#L69" target="_blank" rel="noopener nofollow">switching the CLR to use “slower” allocators</a> . This is why you should check that it does not impact your application performance. These slower allocators are also used when your <strong>ICorProfilerCallback.Initialize</strong> method calls <strong>SetEventMask</strong> with <strong>COR_PRF_ENABLE_OBJECT_ALLOCATED</strong> flag to receive allocation notifications.</p><p id="11c9" data-selectable-paragraph="">When you use <a href="https://github.com/Microsoft/perfview/releases" target="_blank" rel="noopener nofollow">Perfview</a> for memory investigation, you are relying on these events without knowing it. In the Collect/Run dialog, three checkboxes are defining how to get the memory profiling details:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*8kuywni3W8PVleqg5NwWPw.png?q=20" width="1083" height="418" role="presentation"></p><p><img width="1083" height="418" srcset="https://miro.medium.com/max/552/1*8kuywni3W8PVleqg5NwWPw.png 276w, https://miro.medium.com/max/1104/1*8kuywni3W8PVleqg5NwWPw.png 552w, https://miro.medium.com/max/1280/1*8kuywni3W8PVleqg5NwWPw.png 640w, https://miro.medium.com/max/1400/1*8kuywni3W8PVleqg5NwWPw.png 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><ul><li id="37e6" data-selectable-paragraph=""><em>.NET Alloc</em>: use a custom native C++ <strong>ICorProfilerCallback</strong> implementation (noticeable impact on the profiled application performance).</li><li id="2322" data-selectable-paragraph=""><em>.NET SampAlloc</em>: use the same custom native profiler but with sampled events.</li><li id="e6d8" data-selectable-paragraph=""><em>ETW .NET Alloc</em>: use <strong>GCSampledObjectAllocationHigh</strong> events</li></ul><p id="5606" data-selectable-paragraph="">In all cases, the profiled application needs to be started after the collection begins.</p><p id="0de8" data-selectable-paragraph="">As I have already explained in previous posts, the Microsoft <a href="https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent/" target="_blank" rel="noopener nofollow"><strong>TraceEvent</strong> nuget</a> helps you listening to CLR events. First, you create a <strong>TraceEventSession</strong> and setup the providers you want to receive events from:</p><figure><div></div></figure><p id="5ad1" data-selectable-paragraph="">Second, you setup the handlers for the events you are interested in:</p><figure><div></div></figure><p id="10c6" data-selectable-paragraph="">And lastly, the processing of received events is done in a dedicated thread until the session is disposed:</p><figure><div></div></figure><p id="f40d" data-selectable-paragraph="">Now let’s see the difference between the two sets of events.</p><p id="b9ca" data-selectable-paragraph="">My first idea was to use the <strong>AllocationTick</strong> event because it seemed easy: one sampled event with a size, a type name and LOH/ephemeral kind. However, how this sampling works makes it impossible to get an exact per type allocated size. Let’s have a look at this list of events received from a WPF test application:</p><pre><span id="ceb5" data-selectable-paragraph="">Small | 105444 : FreezableContextPair[]<br>Small | 111908 : FreezableContextPair[]<br>Small | 106720 : System.String<br>Small | 102488 : System.String<br>Small | 107028 : System.TimeSpan[]<br>Small | 106100 : System.String</span></pre><p id="eac8" data-selectable-paragraph="">All allocations were <strong>Small</strong> (i.e. not in the LOH: &lt; 85.000 bytes) and the second column gives the cumulated size of all allocations to reach the 100 KB threshold but not for this particular type! There is no easy way to make a valid guess of the specific last allocation size for which we get the type name.</p><p id="ddee" data-selectable-paragraph="">For example, the first array of <strong>FreezableContextPair</strong> triggered the event for a cumulated size of 105.444 bytes. But how big was this array? We don’t know: could have been 100.000 because only 5444 bytes where allocated before or only 10444 bytes because 95.000 were allocated before. It would have been so useful that the size of the last allocated object would be passed in the event payload…</p><p id="097a" data-selectable-paragraph="">It is a little bit different (but not that better) for objects allocated in LOH because they have to be at least 85.000 byte long. For example, allocate 4 byte arrays, each one 85.000 bytes long and let’s see the corresponding events:</p><pre><span id="8805" data-selectable-paragraph="">Large | 170064 : System.Byte[]<br>Large | 170064 : System.Byte[]</span></pre><p id="7602" data-selectable-paragraph="">Two <strong>AllocationTick</strong> events are received with 170064 as cumulated size. Still hard to figure out what was the size of the last allocated array: the only thing we know is that it was larger (or equal) to 85.000 bytes because it was allocated in LOH.</p><p id="5144" data-selectable-paragraph="">For larger objects, it might seem a little bit more accurate. Let’s allocate 2 byte arrays, each one 110.000 bytes long:</p><pre><span id="4f31" data-selectable-paragraph="">Large | 195064 : System.Byte[]<br>Large | 110032 : System.Byte[]</span></pre><p id="5ac1" data-selectable-paragraph="">There are ~85.000 bytes difference between the two events even though the same 110.000 bytes were allocated. You could remove 85.000 bytes from the value and have an approximation of the LOH allocated object: the larger the allocation the less the error. But still: could be 85.000 size error…</p><p id="6a8e" data-selectable-paragraph="">So we won’t be able to rely on the size provided by the <strong>AllocationTick</strong> event; only the type name. In addition, you get a view of objects allocated in LOH. Maybe the other events will provide better results.</p><p id="01ff" data-selectable-paragraph="">When an object is allocated by the GC allocator, a <strong>GCSampledObjectAllocation</strong> event is emitted under certain conditions:</p><ul><li id="53f6" data-selectable-paragraph="">Both <strong>GCSampledObjectAllocationLow</strong> and <strong>GCSampledObjectAllocationHigh</strong> keywords are set on the CLR provider,</li><li id="e5b1" data-selectable-paragraph="">The object size is larger than 10.000 bytes,</li><li id="5015" data-selectable-paragraph="">At least 1000 instances of the type have been allocated,</li><li id="e2be" data-selectable-paragraph="">Just before the application exits, current statistics for all types <a href="https://github.com/dotnet/runtime/blob/61ec7c7bdacb70ffd51dece09e30179f86156a0d/src/coreclr/src/vm/eventtrace.cpp#L3668" target="_blank" rel="noopener nofollow">are flushed</a>,</li><li id="54b1" data-selectable-paragraph="">A <a href="https://github.com/dotnet/runtime/blob/61ec7c7bdacb70ffd51dece09e30179f86156a0d/src/coreclr/src/vm/eventtrace.cpp#L3067" target="_blank" rel="noopener nofollow">complicated piece of code</a> decides based on time since the last event and the type allocation rate.</li></ul><p id="0402" data-selectable-paragraph="">Picking one or the other keyword <a href="https://github.com/dotnet/runtime/blob/61ec7c7bdacb70ffd51dece09e30179f86156a0d/src/coreclr/src/vm/eventtrace.cpp#L2902" target="_blank" rel="noopener nofollow">changes the maximum number of milliseconds between two events</a> for a given type:</p><ul><li id="dfbf" data-selectable-paragraph="">High (10 ms) : 100 events / second</li><li id="ec66" data-selectable-paragraph="">Low (200 ms) : 5 events / second</li></ul><p id="d63d" data-selectable-paragraph="">You should use Low or high depending on the monitored application memory allocation workload to avoid impacting too much the profiler (and even the monitored application performance)</p><p id="42d5" data-selectable-paragraph="">The interesting feature of these events is that, for a given type, the payload contains both the number of allocated instances since the last event and the cumulated size of these instances. Let’s take the same allocation of 4 arrays of byte, each 85000 long:</p><pre><span id="c9c0" data-selectable-paragraph="">226 | 103616 : System.Byte[]<br>  1 |  85012 : System.Byte[]<br>  1 |  85012 : System.Byte[]<br>  1 |  85012 : System.Byte[]</span></pre><p id="d37f" data-selectable-paragraph="">This time, we get the exact count in the first column (<strong>ObjectCountForTypeSample</strong>) and the exact cumulated size in the second column (<strong>TotalSizeForTypeSample</strong>). If the count is 1, we have the exact size of that allocation and if it is bigger than 85000 bytes, we know it has been allocated in the LOH. Same accuracy for the 2 byte array of 110.000 elements:</p><pre><span id="99c4" data-selectable-paragraph="">198 | 123552 : System.Byte[]<br>  1 | 110012 : System.Byte[]</span></pre><p id="98e8" data-selectable-paragraph="">Sounds good. However, you have to remember that profiled applications need to be started after the session was created: it means that you can’t write a tool that will listen to a specific process ID like with <strong>AllocationTick</strong>. Three dictionaries are used by <strong>PerProcessProfilingState</strong> to keep track of per type allocations, type ID mappings and process names:</p><figure><div></div></figure><p id="dacb" data-selectable-paragraph="">The <strong>SampledObjectAllocationMemoryProfiler</strong> class uses it for the events processing:</p><figure><div></div></figure><p id="e425" data-selectable-paragraph="">The constructor of the profiler keeps track of its own process ID in <strong>_currentPid</strong> to skip its own events.</p><p id="e16a" data-selectable-paragraph="">The processing of <strong>TypeBulkType</strong> events is quite straightforward: store the type ID/name association into a per-process dictionary:</p><figure><div></div></figure><p id="0e8c" data-selectable-paragraph="">Remember that I choose to skip events from the current process detected by <strong>FilterOutEvent()</strong>.</p><p id="d52a" data-selectable-paragraph="">Even though each event contains the ID of the emitting process, it would be better to display its name instead. You could use <strong>Process.GetProcessById(pid).ProcessName</strong> when analyzing the details but the process might be long gone at that time.</p><p id="5217" data-selectable-paragraph="">Another solution would be to enable the Kernel ETW provider and listen to the <strong>ProcessStart</strong> event. The <strong>ImageFileName</strong> field of the payload contains the process filename with the extension. However, it is obviously not working on Linux.</p><p id="0f8f" data-selectable-paragraph="">The easiest solution is to use <strong>GetProcessById</strong> but just when you receive the first type mapping for a given process. This is the role of the <strong>AssociateProcess</strong> method called in <strong>GetProcessTypesMapping</strong> shown previously:</p><figure><div></div></figure><p id="2720" data-selectable-paragraph="">It is now time to process allocation events.</p><p id="6060" data-selectable-paragraph="">The <strong>GCSampledObjectAllocationTraceData</strong> payload contains the size and count of instances since the last event. We just need to store them for the corresponding process:</p><figure><div></div></figure><p id="6a36" data-selectable-paragraph="">The <strong>AddAllocation()</strong> helper method is simply accumulating these numbers for a given type in the <strong>ProcessAllocationInfo</strong> associated to the related process.</p><p id="bc81" data-selectable-paragraph="">When the profiling session ends, it is easy to show the allocated count and size per type:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*1zQgewOknfy2R_SHJfGkKQ.png?q=20" width="923" height="347" role="presentation"></p><p><img width="923" height="347" srcset="https://miro.medium.com/max/552/1*1zQgewOknfy2R_SHJfGkKQ.png 276w, https://miro.medium.com/max/1104/1*1zQgewOknfy2R_SHJfGkKQ.png 552w, https://miro.medium.com/max/1280/1*1zQgewOknfy2R_SHJfGkKQ.png 640w, https://miro.medium.com/max/1400/1*1zQgewOknfy2R_SHJfGkKQ.png 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><p id="60f2" data-selectable-paragraph="">The code is using a Linq syntax to get top allocations sorted either by count or by size:</p><figure><div></div></figure><p id="2f01" data-selectable-paragraph="">Another usage could be a long running monitoring system that shows allocation rate: a nice complement to the other GC metrics. However, compared to the other profilers, one important feature is missing: if an unexpected number of instances are created, how to know which part of the code is responsible for the spike?</p><p id="922f" data-selectable-paragraph="">The next post will explain how to enhance such a sampled memory profiler with call stacks per sampled allocation.</p><ul><li id="0293" data-selectable-paragraph="">Source code available <a href="https://github.com/chrisnas/ClrEvents" target="_blank" rel="noopener nofollow">on Github</a>.</li><li id="5f10" data-selectable-paragraph=""><a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/spying-on-net-garbage-collector-with-traceevent-f49dc3117de">Spying on .NET Garbage Collector with TraceEvent</a></li><li id="de34" data-selectable-paragraph="">Pavel Yosifovich — Writing a .NET Core cross platform profiler in an hour : <a href="https://www.youtube.com/watch?v=TqS4OEWn6hQ" target="_blank" rel="noopener nofollow">https://www.youtube.com/watch?v=TqS4OEWn6hQ</a></li><li id="6c9b" data-selectable-paragraph="">Original Microsoft ClrProfiler source code and documentation: <a href="https://github.com/microsoftarchive/clrprofiler/tree/master/CLRProfiler" target="_blank" rel="noopener nofollow">https://github.com/microsoftarchive/clrprofiler/tree/master/CLRProfiler</a></li></ul></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>