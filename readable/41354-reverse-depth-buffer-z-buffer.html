<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Reverse Depth Buffer (z-buffer) -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Reverse Depth Buffer (z-buffer)</h1>
    <div><div class="post"> <p>For distant objects with standard depth where meshes are close together or intersect z fighting will occur as the error rate increases with distance:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://aws1.discourse-cdn.com/standard10/uploads/babylonjs/original/2X/e/e0777437897cae665ead5cc0af2a2be76f31b646.png"><img src="https://aws1.discourse-cdn.com/standard10/uploads/babylonjs/optimized/2X/e/e0777437897cae665ead5cc0af2a2be76f31b646_2_10x10.png" alt="image" width="517" srcset="https://aws1.discourse-cdn.com/standard10/uploads/babylonjs/optimized/2X/e/e0777437897cae665ead5cc0af2a2be76f31b646_2_517x237.png, https://aws1.discourse-cdn.com/standard10/uploads/babylonjs/optimized/2X/e/e0777437897cae665ead5cc0af2a2be76f31b646_2_775x355.png 1.5x, https://aws1.discourse-cdn.com/standard10/uploads/babylonjs/original/2X/e/e0777437897cae665ead5cc0af2a2be76f31b646.png 2x"></a></div></p>
<p>One way to deal with distant objects which Babylon offers is to use a logarithmic depth buffer; however that has some drawbacks.</p>
<ol>
<li>It doesn&#x2019;t work if the distant objects are <strong>very</strong> close together, you still get z-fighting</li>
<li>Calcuating the z value is done in the fragment shader which means the gpu can&#x2019;t do early rejection after the vertex shader and needs to always run the fragment shader (this then violates rule 2. (<em>slowing down the rendering process</em>)</li>
</ol>
<p>An alternative way of dealing with this is reversing the z-buffer so far objects are at 0 and near objects are at 1. This deals with the z fighting quite nicely as it gives more precision to far objects in exchange for less for near objects which isn&#x2019;t required unless you are dealing with tiny, tiny objects and a massive macro zoom.</p>
<p>(obligatory Nvidia article <a href="https://developer.nvidia.com/content/depth-precision-visualized" class="inline-onebox">Depth Precision Visualized | NVIDIA Developer</a>)</p>
<p>Currently you can get most of the way there in Babylon by inverting the depth function:</p>
<pre><code>engine.setDepthFunctionToGreaterOrEqual();
</code></pre>
<p>Turning off auto clear (as it clears depth it to <code>1.0</code> and we now want to clear to <code>0.0</code>)</p>
<pre><code>scene.autoClear = false;
scene.autoClearDepthAndStencil = false;
scene.setRenderingAutoClearDepthStencil(0, false, false, false);
scene.setRenderingAutoClearDepthStencil(1, false, false, false);
</code></pre>
<p>and intercepting the before draw to do a clear of the depth to <code>0.0</code>.</p>
<pre><code>scene.onBeforeDrawPhaseObservable.add((scene, state) =&gt; {
    const gl = scene.getEngine()._gl;
    gl.clearDepth(0.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
});
</code></pre>
<p>You also need to change the camera&#x2019;s projection matrix to output reversed z values, with an infinite far distance</p>
<p><img src="https://aws1.discourse-cdn.com/standard10/uploads/babylonjs/original/2X/d/d10627d5fee751be234e5d6b7992df56a3c78dc5.png" alt="image" width="421"></p>
<p>Something like:</p>
<pre><code>let t = 1.0 / (Math.tan(this.fov * 0.5));
let a = isVerticalFovFixed ? (t / aspect) : t;
let b = isVerticalFovFixed ? t : (t * aspect);

Matrix.FromValuesToRef(
    a, 0.0, 0.0, 0.0,
    0.0, b, 0.0, 0.0,
    0.0, 0.0, -near, 1.0,
    0.0, 0.0, 1.0, 0.0,
    matrix
);
</code></pre>
<p>All well and good so far; however the issue comes when using other components of Babylon that don&#x2019;t expect this; for example the <code>GeometryBufferRenderer</code> which clears its own z-buffer to <code>1.0</code>.</p>
<pre><code>// set default depth value to 1.0 (far away)
this._multiRenderTarget.onClearObservable.add((engine) =&gt; {
    engine.clear(new Color4(0.0, 0.0, 0.0, 1.0), true, true, true);
});
</code></pre>
<p>And also that its operating outside of Babylon using gl calls e.g. <code>gl.clearDepth(0.0);</code></p>
<p>So it would be nice if this could be a regular option.</p>
<p>Pictures from (with further commentary) <a href="http://dev.theomader.com/depth-precision/" class="inline-onebox">Depth Precision | The Devil In The Details</a></p> </div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>