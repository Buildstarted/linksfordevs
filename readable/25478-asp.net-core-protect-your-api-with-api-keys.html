<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ASP.Net Core - Protect your API with API Keys -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }
    </style>
</head>
<body>
    <div class="grid">
            <h1>ASP.Net Core - Protect your API with API Keys</h1>
        
<div class="readable"><div class="inner"> <p class="main-body">
<article class="post-full post tag-asp-net-core tag-api-key tag-c-sharp no-image"> <section class="post-full-content">
<div class="post-content">
<p><em>Note: this is just for internal use, I don&apos;t recommend using API keys on a public API. You can read more here:</em> <a href="https://twitter.com/gregbair/status/1133699139517198337?s=21">https://twitter.com/gregbair/status/1133699139517198337?s=21</a></p>
<h2 id="theproblem">The problem</h2>
<p>We have an API that are going to be used internally. We can choose <strong>not</strong> to protect our API since it will only be available in our local network, right?</p>
<p>No. <a href="https://resources.infosecinstitute.com/owasp-top-10-10-unprotected-apis/">That&apos;s how fuckups happens</a>. We need to protect our API.</p>
<p>The consumers of our API are a lot of different departments in our company like accounting, customer service and so on.</p>
<p>We want to solve the following problems:</p>
<ol>
<li>Protect our endpoints, only authenticated and authorized calls should be allowed access.</li>
<li>Identify who is using our API (which department)</li>
<li>Give different access levels to different departments</li>
</ol>
<h2 id="thesolution">The solution</h2>
<p>We are going to generate API keys, one for each department. They will then need to add the API key in all of their API requests. This will allow us to lock down our endpoints, see who is using our API (and keep a bunch of statistics) and much more!</p>
<p>It&apos;s important to know the difference between <strong>Authentication</strong> and <strong>Authorization</strong>, I will just copy paste <a href="https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-2.2">this straight from Microsoft:</a></p>
<blockquote>
<p>Authentication is a process in which a user provides credentials that are then compared to those stored in an operating system, database, app or resource. If they match, users authenticate successfully, and can then perform actions that they&apos;re authorized for, during an authorization process. The authorization refers to the process that determines what a user is allowed to do.</p>
</blockquote>
<h3 id="authentication">Authentication</h3>
<p>So, let&apos;s start!<br>
First we need to define our <code>ApiKey</code>.<br>
<strong>ApiKey.cs</strong></p>
<pre><code class="language-csharp">public class ApiKey
{
    public ApiKey(int id, string owner, string key, DateTime created, IReadOnlyCollection&lt;string&gt; roles)
    {
        Id = id;
        Owner = owner ?? throw new ArgumentNullException(nameof(owner));
        Key = key ?? throw new ArgumentNullException(nameof(key));
        Created = created;
        Roles = roles ?? throw new ArgumentNullException(nameof(roles));
    }

    public int Id { get; }
    public string Owner { get; }
    public string Key { get; }
    public DateTime Created { get; }
    public IReadOnlyCollection&lt;string&gt; Roles { get; }
}
</code></pre>
<p>We also need a place to store/retrieve our API keys so let&apos;s create the following interface and implementation.<br>
<strong>IGetAllApiKeysQuery.cs</strong></p>
<pre><code class="language-csharp">public interface IGetAllApiKeysQuery
{
    Task&lt;IReadOnlyDictionary&lt;string, ApiKey&gt;&gt; ExecuteAsync();
}
</code></pre>
<p><strong>InMemoryGetAllApiKeysQuery.cs</strong></p>
<pre><code class="language-csharp">public class InMemoryGetAllApiKeysQuery : IGetAllApiKeysQuery
{
    public Task&lt;IReadOnlyDictionary&lt;string, ApiKey&gt;&gt; ExecuteAsync()
    {
        var apiKeys = new List&lt;ApiKey&gt;
        {
            new ApiKey(1, &quot;Finance&quot;, &quot;C5BFF7F0-B4DF-475E-A331-F737424F013C&quot;, new DateTime(2019, 01, 01),
                    new List&lt;string&gt;
                    {
                        Roles.Employee,
                    }),
            new ApiKey(2, &quot;Reception&quot;, &quot;5908D47C-85D3-4024-8C2B-6EC9464398AD&quot;, new DateTime(2019, 01, 01),
                    new List&lt;string&gt;
                    {
                        Roles.Employee
                    }),
            new ApiKey(3, &quot;Management&quot;, &quot;06795D9D-A770-44B9-9B27-03C6ABDB1BAE&quot;, new DateTime(2019, 01, 01),
                    new List&lt;string&gt;
                    {
                        Roles.Employee,
                        Roles.Manager
                    }),
            new ApiKey(4, &quot;Some Third Party&quot;, &quot;FA872702-6396-45DC-89F0-FC1BE900591B&quot;, new DateTime(2019, 06, 01),
                    new List&lt;string&gt;
                    {
                        Roles.ThirdParty
                    })
        };

        IReadOnlyDictionary&lt;string, ApiKey&gt; readonlyDictionary = apiKeys.ToDictionary(x =&gt; x.Key, x =&gt; x);
        return Task.FromResult(readonlyDictionary);
    }
}
</code></pre>
<p>As you can see, for this post we are storing the keys in memory, but in the real world we would use a database.</p>
<p>The endpoints we want to protect looks like this:<br>
<strong>UserController.cs</strong></p>
<pre><code class="language-csharp">[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class UserController : ControllerBase
{
    [HttpGet(&quot;anyone&quot;)]
    public IActionResult Anyone()
    {
        var message = $&quot;Hello from {nameof(Anyone)}&quot;;
        return new ObjectResult(message);
    }

    [HttpGet(&quot;only-authenticated&quot;)]
    public IActionResult OnlyAuthenticated()
    {
        var message = $&quot;Hello from {nameof(OnlyAuthenticated)}&quot;;
        return new ObjectResult(message);
    }

    [HttpGet(&quot;only-employees&quot;)]
    public IActionResult OnlyEmployees()
    {
        var message = $&quot;Hello from {nameof(OnlyEmployees)}&quot;;
        return new ObjectResult(message);
    }

    [HttpGet(&quot;only-managers&quot;)]
    public IActionResult OnlyManagers()
    {
        var message = $&quot;Hello from {nameof(OnlyManagers)}&quot;;
        return new ObjectResult(message);
    }

    [HttpGet(&quot;only-third-parties&quot;)]
    public IActionResult OnlyThirdParties()
    {
        var message = $&quot;Hello from {nameof(OnlyThirdParties)}&quot;;
        return new ObjectResult(message);
    }
}
</code></pre>
<p>So right now, anyone can call any endpoint. Not good, so let&apos;s fix that.<br>
We will start with the <code>OnlyAuthenticated</code>(/api/user/only-authenticated) endpoint.</p>
<p>By adding the <code>[Authorize]</code> attribute, we are saying that (in this example) &quot;as long as you are authenticated, you are allowed access&quot;.</p>
<p><strong>UserController.cs</strong></p>
<pre><code class="language-csharp">[HttpGet(&quot;only-authenticated&quot;)]
[Authorize]
public IActionResult OnlyAuthenticated()
{
    var message = $&quot;Hello from {nameof(OnlyAuthenticated)}&quot;;
    return new ObjectResult(message);
}
</code></pre>
<p>If we try to call our endpoint now with our API key...it will not work, of course. We need to setup the authentication.</p>
<p>First, we add the following to our <code>Startup</code> class<br>
<strong>Startup.cs</strong></p>
<pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(options =&gt;
    {
        options.DefaultAuthenticateScheme = ApiKeyAuthenticationOptions.DefaultScheme;
        options.DefaultChallengeScheme = ApiKeyAuthenticationOptions.DefaultScheme;
    })
    .AddApiKeySupport(options =&gt; {});
</code></pre>
<p>The important thing to notice here is the <code>AddApiKeySupport</code> extension method.<br>
<strong>ApiKeyAuthenticationOptions.cs</strong></p>
<pre><code class="language-csharp">public class ApiKeyAuthenticationOptions : AuthenticationSchemeOptions
{
    public const string DefaultScheme = &quot;API Key&quot;;
    public string Scheme =&gt; DefaultScheme;
    public string AuthenticationType = DefaultScheme;
}
</code></pre>
<p><strong>AuthenticationBuilderExtensions.cs</strong></p>
<pre><code class="language-csharp">public static class AuthenticationBuilderExtensions
{
    public static AuthenticationBuilder AddApiKeySupport(this AuthenticationBuilder authenticationBuilder, Action&lt;ApiKeyAuthenticationOptions&gt; options)
    {
        return authenticationBuilder.AddScheme&lt;ApiKeyAuthenticationOptions, ApiKeyAuthenticationHandler&gt;(ApiKeyAuthenticationOptions.DefaultScheme, options);
    }
}
</code></pre>
<p>In the <code>AddApiKeySupport</code>method we are adding a scheme, we are basically saying that <code>ApiKeyAuthenticationHandler</code> should handle the <code>Api Key</code> scheme.</p>
<p><strong>ApiKeyAuthenticationHandler.cs</strong></p>
<pre><code class="language-csharp">public class ApiKeyAuthenticationHandler : AuthenticationHandler&lt;ApiKeyAuthenticationOptions&gt;
{
    private readonly IGetAllApiKeysQuery _getAllApiKeysQuery;
    private const string ApiKeyHeaderName = &quot;X-Api-Key&quot;;
    public ApiKeyAuthenticationHandler(
        IOptionsMonitor&lt;ApiKeyAuthenticationOptions&gt; options,
        ILoggerFactory logger,
        UrlEncoder encoder,
        ISystemClock clock,
        IGetAllApiKeysQuery getAllApiKeysQuery) : base(options, logger, encoder, clock)
    {
        _getAllApiKeysQuery = getAllApiKeysQuery ?? throw new ArgumentNullException(nameof(getAllApiKeysQuery));
    }

    protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
    {
        if (!Request.Headers.TryGetValue(ApiKeyHeaderName, out var apiKeyHeaderValues))
        {
            return AuthenticateResult.Fail($&quot;No &apos;{ApiKeyHeaderName}&apos; header was present in the request&quot;);
        }

        var providedApiKey = apiKeyHeaderValues.FirstOrDefault();

        if (apiKeyHeaderValues.Count == 0 || string.IsNullOrWhiteSpace(providedApiKey))
        {
            return AuthenticateResult.Fail($&quot;The &apos;{ApiKeyHeaderName}&apos; header value was null or empty&quot;);
        }

        var existingApiKeys = await _getAllApiKeysQuery.ExecuteAsync();

        if (existingApiKeys.ContainsKey(providedApiKey))
        {
            var apiKey = existingApiKeys[providedApiKey];

            var claims = new List&lt;Claim&gt;
            {
                new Claim(ClaimTypes.Name, apiKey.Owner)
            };

            claims.AddRange(apiKey.Roles.Select(role =&gt; new Claim(ClaimTypes.Role, role)));

            var identity = new ClaimsIdentity(claims, Options.AuthenticationType);
            var identities = new List&lt;ClaimsIdentity&gt; { identity };
            var ticket = new AuthenticationTicket(new ClaimsPrincipal(identities), Options.Scheme);

            return AuthenticateResult.Success(ticket);
        }
        return AuthenticateResult.Fail(&quot;Invalid API Key provided.&quot;);
    }
}
</code></pre>
<p>This is were the fun starts!
This method gets called for every request that requires authentication.</p><p>
The logic goes something like this:</p></div></section></article></p>
<ul>
<li>If no <code>X-Api-Key</code>header is present -&gt; Fail the authentication</li>
<li>If the header is present but null or empty -&gt; Fail the authentication</li>
<li>If the provided key is not present in the <code>existingApiKeys</code> -&gt; Fail the authentication.</li>
<li>If the key is valid, create a new identity, add the name claim and add all the roles to the identity.</li>
</ul>
<p>Not <strong>that</strong> hard to follow, right?
Now we only need to add the authentication middleware to our pipeline and we should be good to go.</p><p>
<strong>Startup.cs</strong></p>
<pre><code class="language-csharp">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseAuthentication(); //Important to place before app.UseMvc();
    app.UseMvc();
}
</code></pre>
<p>That is basically all it takes to add <strong>Authentication</strong> based on API keys to our API.</p> <p>Now, say that we want to have specific endpoints that only the upper management can call, how can we achieve that?</p>
<p>Let&apos;s modify our <code>OnlyManagement</code> action method to look like this:<br>
<strong>UserController.cs</strong></p>
<pre><code class="language-csharp">[HttpGet(&quot;only-managers&quot;)]
[Authorize(Policy = Policies.OnlyManagers)]
public IActionResult OnlyManagers()
{
    var message = $&quot;Hello from {nameof(OnlyManagers)}&quot;;
    return new ObjectResult(message);
}
</code></pre>
<p>We&apos;ve added the <code>[Authorize]</code>attribute and set the policy to <code>OnlyManagers</code>.<br>
Think of a policy as something that needs to evaluate to true for us to get access to that specific resource. So in our case, our <code>OnlyManagers</code> policy will, most likely, check that we in fact are managers. You can <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-2.2">read more about policies here</a>.</p>
<p><code>Policies.cs</code></p>
<pre><code class="language-csharp">public static class Policies
{
    public const string OnlyEmployees = nameof(OnlyEmployees);
    public const string OnlyManagers = nameof(OnlyManagers);
    public const string OnlyThirdParties = nameof(OnlyThirdParties);
}
</code></pre>
<p>Let&apos;s start by adding the following to our <code>Startup</code> class:<br>
<strong>Startup.cs</strong></p>
<pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{

 ...............
 services.AddAuthorization(options =&gt;
 {
     options.AddPolicy(Policies.OnlyEmployees, policy =&gt; policy.Requirements.Add(new OnlyEmployeesRequirement()));
     options.AddPolicy(Policies.OnlyManagers, policy =&gt; policy.Requirements.Add(new OnlyManagersRequirement()));
     options.AddPolicy(Policies.OnlyThirdParties, policy =&gt; policy.Requirements.Add(new OnlyThirdPartiesRequirement()));
 });
 
 services.AddSingleton&lt;IAuthorizationHandler, OnlyEmployeesAuthorizationHandler&gt;();
 services.AddSingleton&lt;IAuthorizationHandler, OnlyManagersAuthorizationHandler&gt;();
 services.AddSingleton&lt;IAuthorizationHandler, OnlyThirdPartiesAuthorizationHandler&gt;();
 ......
</code></pre>
<p>So first, we are registering three different policies, <code>OnlyEmployees</code>, <code>OnlyManagers</code> and <code>OnlyThirdParties</code>, and then we are registering a <code>IAuthorizationHandler</code> for each of the policies.</p>
<p>We are focusing on the <code>OnlyManagers</code> policy so let&apos;s check it out.<br>
<strong>OnlyManagersRequirement.cs</strong></p>
<pre><code class="language-csharp">public class OnlyManagersRequirement : IAuthorizationRequirement
{
    // This is empty, but you can have a bunch of properties and methods here if you like that you can later access from the AuthorizationHandler.
}
</code></pre>
<p><strong>OnlyManagersAuthorizationHandler.cs</strong></p>
<pre><code class="language-csharp">public class OnlyManagersAuthorizationHandler : AuthorizationHandler&lt;OnlyManagersRequirement&gt;
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, OnlyManagersRequirement requirement)
    {
        if (context.User.IsInRole(Roles.Manager))
        {
            context.Succeed(requirement);
        }

        return Task.CompletedTask;
    }
}
</code></pre>
<p>So this is really simple, we are just checking if the user is in the <code>Manager</code> role, if true, we call <code>Succeed</code> on the context. If not, we don&apos;t do anything.</p>
<p>So, how do we know that the current user is actually part of the management team?<br>
Well, actually, we don&apos;t <em>know</em> that for sure since we have just created generic API keys that are shared by all the management applications, but we trust them right? :)</p>
<p>Anyhow, let&apos;s recap how we know that the request is actually allowed access to the <code>OnlyManagers</code> endpoint.</p>
<ol>
<li>The request hits our API</li>
<li>We validate that the request contains a valid API key - <strong>Authentication</strong></li>
<li>If the key is valid, we map the roles from the existing API key.<br>
<strong>ApiKeyAuthenticationHandler.cs</strong></li>
</ol>
<pre><code class="language-csharp">.......
var claims = new List&lt;Claim&gt;
{
    new Claim(ClaimTypes.Name, apiKey.Owner)
};

claims.AddRange(apiKey.Roles.Select(role =&gt; new Claim(ClaimTypes.Role, role)));
.......
</code></pre>
<ol>
<li>We then validate that the API key contains the <code>Manager</code> role - <strong>Authorization</strong></li>
<li>P R O F I T</li>
</ol>
<p>A complete project (with integration tests as well!) can be found <a href="https://github.com/joseftw/JOS.ApiKeyAuthentication">here</a>.</p>
<p>Also. If you <strong>don&apos;t</strong> protect your API&apos;s...I know someone that will come for them :)<br>
<img src="https://josefottosson.se/content/images/2019/05/61643839_2061987277246624_7996719859469647872_n-1-.jpg" alt="61643839_2061987277246624_7996719859469647872_n-1-"></p> <aside class="read-next outer"> </aside> </div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>