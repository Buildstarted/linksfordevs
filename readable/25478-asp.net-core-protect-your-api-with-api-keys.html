<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ASP.Net Core - Protect your API with API Keys -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>ASP.Net Core - Protect your API with API Keys</h1><div><div class="post-content"><p><strong>Disclaimer</strong></p><p>There's a bunch of different ways to handle authentication/authorization. As pointed out <a href="https://twitter.com/gregbair/status/1133699139517198337">here on Twitter by Greg Bair</a>, API keys has some limitations/drawbacks.</p><p>One problem is that usually API keys never expires and that's obviously bad from a security point of view. It's better to have <a href="https://stackoverflow.com/questions/34931052/how-does-a-short-lived-access-token-add-security">short lived tokens</a>.</p><p>For my use case (described below) API keys are more than good enough, but if I were to build an application that was publicly available, I would go for something like <a href="https://oauth.net/2/">OAuth 2</a>/<a href="https://identityserver4.readthedocs.io/en/latest/">JWT/Identityserver4</a> instead.<br><strong>It's important to always think twice about security and not just blindly copy/paste code from the internet</strong>.</p><hr><p><strong>2019-09-25 This blog post has now been updated to use ASP.NET Core 3.0. If you are looking for information about how to do this using ASP.NET Core 2.0, just <a href="https://github.com/joseftw/JOS.ApiKeyAuthentication/commit/5bd3d1bf163b9b8c3f51cce74a2d42c4f8d1b8b9">checkout this git commit</a> and you should be good to go.</strong></p><h2 id="theproblem">The problem</h2><p>We've an API that are going to be used <strong>internally</strong> (called by other internal applications).</p><p>The consumers of our API are a lot of different departments in our company like accounting, customer service and so on.</p><p>We want to solve the following problems:</p><ol><li>Identify who is using our API (which department)</li><li>Only authenticated and authorized calls should be allowed access.</li><li>Give different access levels to different departments</li></ol><h2 id="thesolution">The solution</h2><p>We are going to generate API keys, one for each department. They will then need to add the API key in all of their API requests. This will allow us to lock down our endpoints, see who is using our API (and keep a bunch of statistics) and much more!</p><p>It's important to know the difference between <strong>Authentication</strong> and <strong>Authorization</strong>, I will just copy paste <a href="https://docs.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-2.2">this straight from Microsoft:</a></p><blockquote><p>Authentication is a process in which a user provides credentials that are then compared to those stored in an operating system, database, app or resource. If they match, users authenticate successfully, and can then perform actions that they're authorized for, during an authorization process. The authorization refers to the process that determines what a user is allowed to do.</p></blockquote><h3 id="authentication">Authentication</h3><p>So, let's start!<br>First we need to define our <code>ApiKey</code>.<br><strong>ApiKey.cs</strong></p><pre><code class="language-csharp">public class ApiKey
{
    public ApiKey(int id, string owner, string key, DateTime created, IReadOnlyCollection&lt;string&gt; roles)
    {
        Id = id;
        Owner = owner ?? throw new ArgumentNullException(nameof(owner));
        Key = key ?? throw new ArgumentNullException(nameof(key));
        Created = created;
        Roles = roles ?? throw new ArgumentNullException(nameof(roles));
    }

    public int Id { get; }
    public string Owner { get; }
    public string Key { get; }
    public DateTime Created { get; }
    public IReadOnlyCollection&lt;string&gt; Roles { get; }
}
</code></pre><p>We also need a place to store/retrieve our API keys so let's create the following interface and implementation.<br><strong>IGetAllApiKeysQuery.cs</strong></p><pre><code class="language-csharp">public interface IGetApiKeyQuery
{
    Task&lt;ApiKey&gt; Execute(string providedApiKey);
}
</code></pre><p><strong>InMemoryGetApiKeyQuery.cs</strong></p><pre><code class="language-csharp">public class InMemoryGetApiKeyQuery : IGetApiKeyQuery
{
    private readonly IDictionary&lt;string, ApiKey&gt; _apiKeys;

    public InMemoryGetApiKeyQuery()
    {
        var existingApiKeys = new List&lt;ApiKey&gt;
        {
            new ApiKey(1, "Finance", "C5BFF7F0-B4DF-475E-A331-F737424F013C", new DateTime(2019, 01, 01),
                new List&lt;string&gt;
                {
                    Roles.Employee,
                }),
            new ApiKey(2, "Reception", "5908D47C-85D3-4024-8C2B-6EC9464398AD", new DateTime(2019, 01, 01),
                new List&lt;string&gt;
                {
                    Roles.Employee
                }),
            new ApiKey(3, "Management", "06795D9D-A770-44B9-9B27-03C6ABDB1BAE", new DateTime(2019, 01, 01),
                new List&lt;string&gt;
                {
                    Roles.Employee,
                    Roles.Manager
                }),
            new ApiKey(4, "Some Third Party", "FA872702-6396-45DC-89F0-FC1BE900591B", new DateTime(2019, 06, 01),
                new List&lt;string&gt;
                {
                    Roles.ThirdParty
                })
        };

        _apiKeys = existingApiKeys.ToDictionary(x =&gt; x.Key, x =&gt; x);
    }

    public Task&lt;ApiKey&gt; Execute(string providedApiKey)
    {
        _apiKeys.TryGetValue(providedApiKey, out var key);
        return Task.FromResult(key);
    }
}
</code></pre><p>As you can see, for this post we are storing the keys in memory, but in the real world we would use a database.</p><p>The endpoints we want to protect looks like this:<br><strong>UserController.cs</strong></p><pre><code class="language-csharp">[Route("api/[controller]")]
[ApiController]
public class UserController : ControllerBase
{
    [HttpGet("anyone")]
    public IActionResult Anyone()
    {
        var message = $"Hello from {nameof(Anyone)}";
        return new ObjectResult(message);
    }

    [HttpGet("only-authenticated")]
    public IActionResult OnlyAuthenticated()
    {
        var message = $"Hello from {nameof(OnlyAuthenticated)}";
        return new ObjectResult(message);
    }

    [HttpGet("only-employees")]
    public IActionResult OnlyEmployees()
    {
        var message = $"Hello from {nameof(OnlyEmployees)}";
        return new ObjectResult(message);
    }

    [HttpGet("only-managers")]
    public IActionResult OnlyManagers()
    {
        var message = $"Hello from {nameof(OnlyManagers)}";
        return new ObjectResult(message);
    }

    [HttpGet("only-third-parties")]
    public IActionResult OnlyThirdParties()
    {
        var message = $"Hello from {nameof(OnlyThirdParties)}";
        return new ObjectResult(message);
    }
}
</code></pre><p>So right now, anyone can call any endpoint. Not good, so let's fix that.<br>We will start with the <code>OnlyAuthenticated</code>(/api/user/only-authenticated) endpoint.</p><p>By adding the <code>[Authorize]</code> attribute, we are saying that (in this example) "as long as you are authenticated, you are allowed access".</p><p><strong>UserController.cs</strong></p><pre><code class="language-csharp">[HttpGet("only-authenticated")]
[Authorize]
public IActionResult OnlyAuthenticated()
{
    var message = $"Hello from {nameof(OnlyAuthenticated)}";
    return new ObjectResult(message);
}
</code></pre><p>If we try to call our endpoint now with our API key...it will not work, of course. We need to setup the authentication.</p><p>First, we add the following to our <code>Startup</code> class<br><strong>Startup.cs</strong></p><pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(options =&gt;
    {
        options.DefaultAuthenticateScheme = ApiKeyAuthenticationOptions.DefaultScheme;
        options.DefaultChallengeScheme = ApiKeyAuthenticationOptions.DefaultScheme;
    })
    .AddApiKeySupport(options =&gt; {});
</code></pre><p>The important thing to notice here is the <code>AddApiKeySupport</code> extension method.<br><strong>ApiKeyAuthenticationOptions.cs</strong></p><pre><code class="language-csharp">public class ApiKeyAuthenticationOptions : AuthenticationSchemeOptions
{
    public const string DefaultScheme = "API Key";
    public string Scheme =&gt; DefaultScheme;
    public string AuthenticationType = DefaultScheme;
}
</code></pre><p><strong>AuthenticationBuilderExtensions.cs</strong></p><pre><code class="language-csharp">public static class AuthenticationBuilderExtensions
{
    public static AuthenticationBuilder AddApiKeySupport(this AuthenticationBuilder authenticationBuilder, Action&lt;ApiKeyAuthenticationOptions&gt; options)
    {
        return authenticationBuilder.AddScheme&lt;ApiKeyAuthenticationOptions, ApiKeyAuthenticationHandler&gt;(ApiKeyAuthenticationOptions.DefaultScheme, options);
    }
}
</code></pre><p>In the <code>AddApiKeySupport</code>method we are adding a scheme, we are basically saying that <code>ApiKeyAuthenticationHandler</code> should handle the <code>Api Key</code> scheme.</p><p><strong>ApiKeyAuthenticationHandler.cs</strong></p><pre><code class="language-csharp">public class ApiKeyAuthenticationHandler : AuthenticationHandler&lt;ApiKeyAuthenticationOptions&gt;
{
    private const string ProblemDetailsContentType = "application/problem+json";
    private readonly IGetApiKeyQuery _getApiKeyQuery;
    private const string ApiKeyHeaderName = "X-Api-Key";
    public ApiKeyAuthenticationHandler(
        IOptionsMonitor&lt;ApiKeyAuthenticationOptions&gt; options,
        ILoggerFactory logger,
        UrlEncoder encoder,
        ISystemClock clock,
        IGetApiKeyQuery getApiKeyQuery) : base(options, logger, encoder, clock)
    {
        _getApiKeyQuery = getApiKeyQuery ?? throw new ArgumentNullException(nameof(getApiKeyQuery));
    }

    protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()
    {
        if (!Request.Headers.TryGetValue(ApiKeyHeaderName, out var apiKeyHeaderValues))
        {
            return AuthenticateResult.NoResult();
        }

        var providedApiKey = apiKeyHeaderValues.FirstOrDefault();

        if (apiKeyHeaderValues.Count == 0 || string.IsNullOrWhiteSpace(providedApiKey))
        {
            return AuthenticateResult.NoResult();
        }

        var existingApiKey = await _getApiKeyQuery.Execute(providedApiKey);

        if (existingApiKey != null)
        {
            var claims = new List&lt;Claim&gt;
            {
                new Claim(ClaimTypes.Name, existingApiKey.Owner)
            };

            claims.AddRange(existingApiKey.Roles.Select(role =&gt; new Claim(ClaimTypes.Role, role)));

            var identity = new ClaimsIdentity(claims, Options.AuthenticationType);
            var identities = new List&lt;ClaimsIdentity&gt; { identity };
            var principal = new ClaimsPrincipal(identities);
            var ticket = new AuthenticationTicket(principal, Options.Scheme);

            return AuthenticateResult.Success(ticket);
        }

        return AuthenticateResult.Fail("Invalid API Key provided.");
    }

    protected override async Task HandleChallengeAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 401;
        Response.ContentType = ProblemDetailsContentType;
        var problemDetails = new UnauthorizedProblemDetails();

        await Response.WriteAsync(JsonSerializer.Serialize(problemDetails, DefaultJsonSerializerOptions.Options));
    }

    protected override async Task HandleForbiddenAsync(AuthenticationProperties properties)
    {
        Response.StatusCode = 403;
        Response.ContentType = ProblemDetailsContentType;
        var problemDetails = new ForbiddenProblemDetails();

        await Response.WriteAsync(JsonSerializer.Serialize(problemDetails, DefaultJsonSerializerOptions.Options));
    }
}
</code></pre><p>This is were the fun starts!<br>This method gets called for every request that requires authentication.<br>The logic goes something like this:</p><ul><li>If no <code>X-Api-Key</code>header is present -&gt; Return no result, let other handlers (if present) handle the request.</li><li>If the header is present but null or empty -&gt; Return no result.</li><li>If the provided key does not exists -&gt; Fail the authentication.</li><li>If the key is valid, create a new identity, add the name claim and add all the roles to the identity.</li></ul><p>Not <strong>that</strong> hard to follow, right?<br>Now we only need to add the authentication and authorization middleware to our pipeline and we should be good to go.<br><strong>Startup.cs</strong></p><pre><code class="language-csharp">public void Configure(IApplicationBuilder app, IHostEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    
    app.UseRouting();
    app.UseAuthentication();
    app.UseAuthorization();
    app.UseEndpoints(endpoints =&gt;
    {
        endpoints.MapControllers();
    });
}
</code></pre><p>That is basically all it takes to add <strong>Authentication</strong> based on API keys to our API.</p><h3 id="authorization">Authorization</h3><p>Now, say that we want to have specific endpoints that only the upper management can call, how can we achieve that?</p><p>Let's modify our <code>OnlyManagement</code> action method to look like this:<br><strong>UserController.cs</strong></p><pre><code class="language-csharp">[HttpGet("only-managers")]
[Authorize(Policy = Policies.OnlyManagers)]
public IActionResult OnlyManagers()
{
    var message = $"Hello from {nameof(OnlyManagers)}";
    return new ObjectResult(message);
}
</code></pre><p>We've added the <code>[Authorize]</code>attribute and set the policy to <code>OnlyManagers</code>.<br>Think of a policy as something that needs to evaluate to true for us to get access to that specific resource. So in our case, our <code>OnlyManagers</code> policy will, most likely, check that we in fact are managers. You can <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-2.2">read more about policies here</a>.</p><p><code>Policies.cs</code></p><pre><code class="language-csharp">public static class Policies
{
    public const string OnlyEmployees = nameof(OnlyEmployees);
    public const string OnlyManagers = nameof(OnlyManagers);
    public const string OnlyThirdParties = nameof(OnlyThirdParties);
}
</code></pre><p>Let's start by adding the following to our <code>Startup</code> class:<br><strong>Startup.cs</strong></p><pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{

 ...............
 services.AddAuthorization(options =&gt;
 {
     options.AddPolicy(Policies.OnlyEmployees, policy =&gt; policy.Requirements.Add(new OnlyEmployeesRequirement()));
     options.AddPolicy(Policies.OnlyManagers, policy =&gt; policy.Requirements.Add(new OnlyManagersRequirement()));
     options.AddPolicy(Policies.OnlyThirdParties, policy =&gt; policy.Requirements.Add(new OnlyThirdPartiesRequirement()));
 });
 
 services.AddSingleton&lt;IAuthorizationHandler, OnlyEmployeesAuthorizationHandler&gt;();
 services.AddSingleton&lt;IAuthorizationHandler, OnlyManagersAuthorizationHandler&gt;();
 services.AddSingleton&lt;IAuthorizationHandler, OnlyThirdPartiesAuthorizationHandler&gt;();
 ......
</code></pre><p>So first, we are registering three different policies, <code>OnlyEmployees</code>, <code>OnlyManagers</code> and <code>OnlyThirdParties</code>, and then we are registering a <code>IAuthorizationHandler</code> for each of the policies.</p><p>We are focusing on the <code>OnlyManagers</code> policy so let's check it out.<br><strong>OnlyManagersRequirement.cs</strong></p><pre><code class="language-csharp">public class OnlyManagersRequirement : IAuthorizationRequirement
{
    // This is empty, but you can have a bunch of properties and methods here if you like that you can later access from the AuthorizationHandler.
}
</code></pre><p><strong>OnlyManagersAuthorizationHandler.cs</strong></p><pre><code class="language-csharp">public class OnlyManagersAuthorizationHandler : AuthorizationHandler&lt;OnlyManagersRequirement&gt;
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, OnlyManagersRequirement requirement)
    {
        if (context.User.IsInRole(Roles.Manager))
        {
            context.Succeed(requirement);
        }

        return Task.CompletedTask;
    }
}
</code></pre><p>So this is really simple, we are just checking if the user is in the <code>Manager</code> role, if true, we call <code>Succeed</code> on the context. If not, we don't do anything.</p><p>So, how do we know that the current user is actually part of the management team?<br>Well, actually, we don't <em>know</em> that for sure since we have just created generic API keys that are shared by all the management applications, but we trust them right? :)</p><p>Anyhow, let's recap how we know that the request is actually allowed access to the <code>OnlyManagers</code> endpoint.</p><ol><li>The request hits our API</li><li>We validate that the request contains a valid API key - <strong>Authentication</strong></li><li>If the key is valid, we map the roles from the existing API key.<br><strong>ApiKeyAuthenticationHandler.cs</strong></li></ol><pre><code class="language-csharp">.......
var claims = new List&lt;Claim&gt;
{
    new Claim(ClaimTypes.Name, apiKey.Owner)
};

claims.AddRange(apiKey.Roles.Select(role =&gt; new Claim(ClaimTypes.Role, role)));
.......
</code></pre><ol start="4"><li>We then validate that the API key contains the <code>Manager</code> role - <strong>Authorization</strong></li><li>P R O F I T</li></ol><h3 id="revocationofapikeys">Revocation of API Keys</h3><p>It's not covered in this post but it's rather simple to handle it. We created a <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.2">IHostedService</a> that runs every minute and looks for changes in the database. If a key has been removed or added, we simply update the cache.</p><p>A complete project (with integration tests as well!) can be found <a href="https://github.com/joseftw/JOS.ApiKeyAuthentication">here</a>.</p><p>Also. If you <strong>don't</strong> protect your API's...I know someone that will come for them :)<br><img src="https://josefottosson.se/content/images/2019/05/61643839_2061987277246624_7996719859469647872_n-1-.jpg" alt="61643839_2061987277246624_7996719859469647872_n-1-"></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>