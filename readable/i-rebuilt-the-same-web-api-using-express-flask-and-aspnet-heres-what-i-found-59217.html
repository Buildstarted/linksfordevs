<!DOCTYPE html>
<html lang="en">
<head>
    <title>
I rebuilt the same web API using Express, Flask, and ASP.NET. Here&#x27;s what I found. - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="I rebuilt the same web API using Express, Flask, and ASP.NET. Here&#x27;s what I found. - linksfor.dev(s)"/>
    <meta property="article:author" content="Victoria Drake"/>
    <meta property="og:description" content="I&#x27;ve been shopping around for a back end framework to support a tabletop game&#xA;app [https://www.nightpathpub.com/entromancy], and decided to do some research&#xA;to determine the best fit for my needs. &#xA;&#xA;The objective was straightforward: to build a simple RESTful API&#xA;[https://restfulapi.net/] that would allow a front end app to perform basic CRUD&#xA;[https://en.wikipedia.org/wiki/Create,_read,_update_and_delete] operations,&#xA;providing me with an introduction to what the development process would look&#xA;li"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.freecodecamp.org/news/i-built-a-web-api-with-express-flask-aspnet/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - I rebuilt the same web API using Express, Flask, and ASP.NET. Here&#x27;s what I found.</title>
<div class="readable">
        <h1>I rebuilt the same web API using Express, Flask, and ASP.NET. Here&#x27;s what I found.</h1>
            <div>by Victoria Drake</div>
            <div>Reading time: 23-29 minutes</div>
        <div>Posted here: 03 Mar 2020</div>
        <p><a href="https://www.freecodecamp.org/news/i-built-a-web-api-with-express-flask-aspnet/">https://www.freecodecamp.org/news/i-built-a-web-api-with-express-flask-aspnet/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="site-main">
    <div>

        <article>

            

            

            <figure>
                <img srcset="https://images.unsplash.com/photo-1550063873-ab792950096b?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ 300w,
                            https://images.unsplash.com/photo-1550063873-ab792950096b?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ 600w,
                            https://images.unsplash.com/photo-1550063873-ab792950096b?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ 1000w,
                            https://images.unsplash.com/photo-1550063873-ab792950096b?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ 2000w" sizes="(max-width: 800px) 400px,
                            (max-width: 1170px) 700px,
                            1400px" src="https://images.unsplash.com/photo-1550063873-ab792950096b?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" alt="I rebuilt the same web API using Express, Flask, and ASP.NET. Here's what I found." onerror="this.style.display='none'">
            </figure>

            <section>
                <div>
                    <p>I've been shopping around for a back end framework to support a <a href="https://www.nightpathpub.com/entromancy">tabletop game app</a>, and decided to do some research to determine the best fit for my needs. </p><p>The objective was straightforward: to build a simple <a href="https://restfulapi.net/">RESTful API</a> that would allow a front end app to perform basic <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> operations, providing me with an introduction to what the development process would look like.</p><p>There are a lot of back end framework options out there, and I'm most familiar with JavaScript, C#, and Python (in that order), which limited my options somewhat. &nbsp;The natural starting point was to build a simple front end that would send requests to an API, which would in turn read from and write to a local database.</p><p>I began my development process with Express, which, for reasons I'll soon explain, led me to also check out Flask and ASP.NET. I thought my findings might prove useful to others out there who are researching back end frameworks for small projects. In this article, I'll also provide code examples and the resources that I used to build everything.</p><p>You can access the full code on <a href="https://github.com/sominator/web-api-project">GitHub</a>, as well.</p><p>I should caveat that I won't be promoting one framework over another, and haven't yet compared things like deployment, authentication, or scalability. &nbsp;Your mileage may vary if those particulars are important to you!</p><p>I will, however, provide a <strong>TL;DR </strong>at the bottom if you just want to get the summary and key learnings.</p><p>Here we go!</p><h2 id="defining-the-api">Defining the API</h2><p>If you're new to web development, you might be asking, "what's an API?"</p><p>I've had to ask the question a hundred times to find an answer that made sense. And it really wasn't until I built my own that I could say I understood what an API <em>does</em>.</p><p>Put simply, an API, or "application programming interface", allows two different computing systems to talk to one another. In this article, I'll show a simple front end app that displays a "quest" tracker that players can view for their tabletop roleplaying game. Each quest has a "name" and a "description," both of which are displayed in the web browser.</p><p>If I already had all of the quests listed on the website and just wanted players to view them, I would have no need for an API or back end. For this project, however, I want the ability to allow users to add quests, search for them, delete them, and so on. For those operations, I need to store the quests somewhere, but my front end app isn't able to transfer information directly to a database.</p><p>For that, I need an API that can receive HTTP requests from the website, figure out what to do with those requests, interact with my database, and send more information back up the chain so that the user can see what happened.</p><p>The whole thing - the front end "client", the back end "API" or server, and the database - is called a "stack," or more precisely, the "full stack." For this project, I built a simple front end website as the top of the stack, and switched out everything beneath it as I tried out different frameworks and databases.</p><h2 id="project-structure">Project Structure</h2><p>The structure for this project was fairly simple, with the front end client separated from three different servers that I would spin up as necessary to serve the API.</p><!--kg-card-begin: image--><figure><img src="https://www.freecodecamp.org/news/content/images/2020/02/Project-Structure.PNG"></figure><!--kg-card-end: image--><p>I used <a href="https://visualstudio.microsoft.com/vs/community/">Visual Studio Community</a> as my code editor and IDE, with the requisite language packages installed for JavaScript, Python, and C#.</p><p>I'll provide an overview of my experience with each framework in turn, with links to the tutorials and packages that I used to get them to work with the client. But first, let's take a look at the front end!</p><h2 id="the-client-vue-js">The Client: Vue.js</h2><p>The goal for the client was to have a simple website that would receive information from the database through the API and display it to the user. To streamline the process, my requirements were that the client would only need to "read" all of the items in the database, and provide the user with the ability to "create" a new quest. &nbsp;</p><p>These "read" and "create" operations - the "R" and "C" in "CRUD" - are analogous to the HTTP methods of "GET" and "POST," which we'll see in the code below.</p><p>In front end development, I'm most comfortable using <a href="https://vuejs.org/">Vue</a>, and used the <a href="https://cli.vuejs.org/">Vue CLI</a> to scaffold a basic client, with the following file structure: &nbsp; </p><!--kg-card-begin: image--><figure><img src="https://www.freecodecamp.org/news/content/images/2020/02/Client-Structure.PNG"></figure><!--kg-card-end: image--><p>I replaced the boilerplate markup provided by the Vue CLI with the following:</p><!--kg-card-begin: code--><pre><code><span><span><span>&lt;</span>template</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>&gt;</span></span>
        <span><span><span>&lt;</span>h1</span><span>&gt;</span></span>RPG Quests<span><span><span>&lt;/</span>h1</span><span>&gt;</span></span>
        <span><span><span>&lt;</span>p</span> <span>v-for</span><span><span>=</span><span>"</span>(quest, index) in quests<span>"</span></span> <span><span>v-bind:</span>key</span><span><span>=</span><span>"</span>index<span>"</span></span><span>&gt;</span></span>{{quest.name}}: {{quest.description}}<span><span><span>&lt;/</span>p</span><span>&gt;</span></span>
        <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model</span><span><span>=</span><span>"</span>newQuestName<span>"</span></span> <span>placeholder</span><span><span>=</span><span>"</span>Quest Name<span>"</span></span> <span>/&gt;</span></span> <span><span><span>&lt;</span>br</span> <span>/&gt;</span></span>
        <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model</span><span><span>=</span><span>"</span>newQuestDescription<span>"</span></span> <span>placeholder</span><span><span>=</span><span>"</span>Quest Description<span>"</span></span> <span>/&gt;</span></span><span><span><span>&lt;</span>br</span> <span>/&gt;</span></span><span><span><span>&lt;</span>br</span> <span>/&gt;</span></span>
        <span><span><span>&lt;</span>button</span> <span><span>v-on:</span>click</span><span><span>=</span><span>"</span>postQuest<span>"</span></span><span>&gt;</span></span>Add Quest<span><span><span>&lt;/</span>button</span><span>&gt;</span></span>
    <span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
<span><span><span>&lt;/</span>template</span><span>&gt;</span></span></code></pre><!--kg-card-end: code--><p>And the corresponding Vue code:</p><!--kg-card-begin: code--><pre><code><span>import</span> axios <span>from</span> <span>'axios'</span><span>;</span>

    <span>export</span> <span>default</span> <span>{</span>
        name<span>:</span> <span>'App'</span><span>,</span>
        <span>data</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>{</span>
                quests<span>:</span> <span>null</span><span>,</span>
                newQuestName<span>:</span> <span>null</span><span>,</span>
                newQuestDescription<span>:</span> <span>null</span>
            <span>}</span>
        <span>}</span><span>,</span>
        methods<span>:</span> <span>{</span>
            <span>getQuests</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
                axios
                    <span>.</span><span>get</span><span>(</span><span>'http://localhost:3000/quests'</span><span>)</span>
                    <span>.</span><span>then</span><span>(</span><span>response</span> <span>=&gt;</span> <span>(</span><span>this</span><span>.</span>quests <span>=</span> response<span>.</span>data<span>)</span><span>)</span><span>;</span>
            <span>}</span><span>,</span>
            <span>addQuest</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
                axios
                    <span>.</span><span>post</span><span>(</span><span>'http://localhost:3000/quests'</span><span>,</span> <span>{</span>
                        name<span>:</span> <span>this</span><span>.</span>newQuestName<span>,</span>
                        description<span>:</span> <span>this</span><span>.</span>newQuestDescription
                    <span>}</span><span>)</span><span>;</span>
            <span>}</span><span>,</span>
            <span>postQuest</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
                axios<span>.</span><span>all</span><span>(</span><span>[</span><span>this</span><span>.</span><span>addQuest</span><span>(</span><span>)</span><span>,</span> <span>this</span><span>.</span><span>getQuests</span><span>(</span><span>)</span><span>]</span><span>)</span><span>;</span>
                <span>this</span><span>.</span><span>$forceUpdate</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>,</span>
        <span>mounted</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span><span>getQuests</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span></code></pre><!--kg-card-end: code--><p>If you're not familiar with Vue, the specifics of the front end aren't that important! Of significance here is that I'm using a JavaScript package called <a href="https://github.com/axios/axios">Axios</a> to make my GET and POST requests to a potential server. </p><p>When the client loads, it'll make a GET request to the URL http://localhost:3000/quests to load all quests from the database. It also provides a couple of input fields and a button that will POST a new quest.</p><p>Using the Vue CLI to serve the client on http://localhost:8080, the front end of the app looks like this in action:</p><!--kg-card-begin: image--><figure><img src="https://www.freecodecamp.org/news/content/images/2020/02/Client.PNG"></figure><!--kg-card-end: image--><p>Once quests are added to the database, they'll start appearing in between the "RPG Quests" header and the input fields.</p><h3 id="client-resources">Client Resources</h3><p>To build the client, I used:</p><ul><li><a href="https://nodejs.org/en/">NodeJS</a>/<a href="https://www.npmjs.com/">NPM</a> for package management</li><li><a href="https://cli.vuejs.org/">Vue CLI</a> for scaffolding, serving, and building projects</li><li><a href="https://github.com/axios/axios">Axios</a> for making HTTP requests to the API</li><li><a href="https://vuejs.org/v2/cookbook/using-axios-to-consume-apis.html">Vue Axios Documentation</a> for making sense of how to use Axios in concert with the API</li><li><a href="https://www.postman.com/">Postman</a> for testing API requests through the browser before implementing them in the client.</li></ul><h2 id="javascript-api-express">JavaScript API: Express</h2><p><a href="https://expressjs.com/">Express</a> is a lightweight web framework for <a href="https://nodejs.org/en/">NodeJS</a> that allows you to write server-side applications with JavaScript.</p><p>It's un-opinionated, which means that you can build your applications how you like without it defining the architecture for you. You can add packages to improve functionality as you fancy, which I found to be a double-edged sword as a newbie to the framework. More on that later.</p><p>Being most comfortable in JavaScript, I was excited by the prospect of having the entire stack run on just one language instead of several. I had heard of the "MEVN Stack," which denotes a full stack application that is comprised of <a href="https://www.mongodb.com/">MongoDB</a>, Express, Vue, and NodeJS, and decided to try that out for this iteration of the project.</p><p>I followed a <a href="https://dev.to/beznet/build-a-rest-api-with-node-express-mongodb-4ho4">web API tutorial</a> to first build a template app, then used another <a href="https://medium.com/@anaida07/mevn-stack-application-part-1-3a27b61dcae0">MEVN tutorial</a> to fill in the details of how to get the API to communicate with the Vue client that I had built. The Express API that I created for this project follows a similar structure to the former, using MongoDB as the database:</p><!--kg-card-begin: image--><figure><img src="https://www.freecodecamp.org/news/content/images/2020/02/Express-Structure.PNG"></figure><!--kg-card-end: image--><p>If you're coming from a JavaScript background, Express is fairly easy to read, even if you're not familiar with some of the back end terminology. The following is a snippet from /routes/quests.js, for example, which handles the HTTP <a href="https://en.wikipedia.org/wiki/Web_API#Endpoints">endpoint</a> requests:</p><!--kg-card-begin: code--><pre><code>router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>async</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>const</span> quests <span>=</span> <span>await</span> Quest<span>.</span><span>find</span><span>(</span><span>)</span><span>;</span>
        res<span>.</span><span>json</span><span>(</span>quests<span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
        res<span>.</span><span>status</span><span>(</span><span>500</span><span>)</span><span>.</span><span>json</span><span>(</span><span>{</span> message<span>:</span> err<span>.</span>message <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>post</span><span>(</span><span>'/'</span><span>,</span> <span>async</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> quest <span>=</span> <span>new</span> <span>Quest</span><span>(</span><span>{</span>
        name<span>:</span> req<span>.</span>body<span>.</span>name<span>,</span>
        description<span>:</span> req<span>.</span>body<span>.</span>description
    <span>}</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>const</span> newQuest <span>=</span> <span>await</span> quest<span>.</span><span>save</span><span>(</span><span>)</span><span>;</span>
        res<span>.</span><span>status</span><span>(</span><span>201</span><span>)</span><span>.</span><span>json</span><span>(</span>newQuest<span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
        res<span>.</span><span>status</span><span>(</span><span>400</span><span>)</span><span>.</span><span>json</span><span>(</span><span>{</span> message<span>:</span> err<span>.</span>message <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span></code></pre><!--kg-card-end: code--><p>The general theme of the code is to receive a request, attempt to contact the database to do work, and then send a response back to whoever's asking. The specifics can be quite complex, particularly if you're writing your own <a href="https://expressjs.com/en/guide/using-middleware.html">middleware</a> that does things in between the request and response, but the code is at least readable.</p><p>I found MongoDB to be painless to work with as a <a href="https://www.mongodb.com/nosql-explained">NoSQL</a> database. &nbsp;If you're working with Express, you'll most likely use <a href="https://mongoosejs.com/">Mongoose</a> as an <a href="https://en.wikipedia.org/wiki/Object-relational_mapping#Object-oriented_databases">ODM</a> - basically like a "middle person" that translates a model of what your data looks like to the database.</p><p>The model in this app (called a "schema" in Mongoose terms) is really simple, located in /models/quests.js:</p><!--kg-card-begin: code--><pre><code>const questSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true
    },
    description: {
        type: String,
        required: true
    }
});</code></pre><!--kg-card-end: code--><p>The above indicates that the database should store our two fields: a quest name and a quest description. &nbsp;Both of these fields are strings, and required. All GET and POST requests will have to conform to this model to interact with the database.</p><p>After wiring all of this up and POSTing a few new quests, the front end site started populating with data:</p><!--kg-card-begin: image--><figure><img src="https://www.freecodecamp.org/news/content/images/2020/02/Vue-Front-End-1.PNG"></figure><!--kg-card-end: image--><p>The process of setting up the Express API was not without its hair pulling, however. Being a primarily front end and 2D game developer, I've become intimately familiar with how dispersed the JavaScript ecosystem can feel. This frustration was magnified in attempting to build a back end app. There are a <em>lot </em>of packages required to get everything up and running, each of which having its own required configuration and implementation.</p><p>If you're looking for a framework that just does everything out of the box, Express is most certainly not the choice for you. It's lightweight, flexible, and easy to read, in a very "choose-your-own-adventure" fashion. I quite like how clean the code is and the ability to structure my projects as I see fit, but troubleshooting and error handling do leave a lot to be desired.</p><h3 id="javascript-express-resources">JavaScript/Express Resources</h3><p>To build the JavaScript API, I used:</p><ul><li><a href="https://nodejs.org/en/">NodeJS</a>/<a href="https://www.npmjs.com/">NPM</a> for package management</li><li><a href="https://expressjs.com/">Express</a> as the main web framework</li><li><a href="https://www.npmjs.com/package/dotenv">Dotenv</a> to create environment-specific variables</li><li><a href="https://nodemon.io/">Nodemon</a> to watch files for changes and restart the server so I didn't have to</li><li><a href="https://expressjs.com/en/resources/middleware/cors.html">CORS</a> to allow for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">cross-origin requests</a> (basically a pain if you're trying to make requests from a client to a server that are both running locally on your machine)</li><li><a href="https://www.mongodb.com/">MongoDB</a> for the <a href="https://www.mongodb.com/nosql-explained">NoSQL</a> database</li><li><a href="https://mongoosejs.com/">Mongoose</a> for writing models that map onto MongoDB </li><li><a href="https://dev.to/beznet/build-a-rest-api-with-node-express-mongodb-4ho4">This API tutorial</a> to provide a basic understanding of how to create an Express-MongoDB stack</li><li><a href="https://medium.com/@anaida07/mevn-stack-application-part-1-3a27b61dcae0">This MEVN tutorial</a> to fill in the gaps of running a MongoDB-Express-Vue-Node full stack</li></ul><h2 id="python-api-flask">Python API: Flask</h2><p>In the process of building the Express API, I had a conversation with a data science friend who works in Python. This gave me the idea of trying out non-JavaScript frameworks to see if they were better suited for my app.</p><p>I took a cursory look at <a href="https://www.djangoproject.com/">Django</a>, since I'd been hearing about it as a powerhouse back end framework that provides everything out of the box. I was a little intimidated by how opinionated it seemed, and opted to try out <a href="https://palletsprojects.com/p/flask/">Flask</a> instead, which kind of felt like the Python equivalent of Express.</p><p>I followed the first few bits of the excellent <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world">Flask Mega-Tutorial</a> to get my app structure set up, using the companion <a href="https://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask">RESTful API tutorial</a> to fill in the pieces of HTTP requests. The file structure turned out to be only a shade more complex than that of the Express API:</p><!--kg-card-begin: image--><figure><img src="https://www.freecodecamp.org/news/content/images/2020/02/Flask-Structure.PNG"></figure><!--kg-card-end: image--><p>The tutorial I followed uses <a href="https://www.sqlite.org/index.html">SQLite</a> for its database, with <a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/">Flask-SQLAlchemy</a> as an <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a>. The HTTP request code that's most analogous to the Express API is located in /app/routes.py:</p><!--kg-card-begin: code--><pre><code><span>@app<span>.</span>route</span><span>(</span><span>'/quests'</span><span>,</span> methods<span>=</span><span>[</span><span>'GET'</span><span>]</span><span>)</span>
<span>def</span> <span>get_quests</span><span>(</span><span>)</span><span>:</span>
    questQuery <span>=</span> Quest<span>.</span>query<span>.</span><span>all</span><span>(</span><span>)</span>
    quests <span>=</span> <span>{</span><span>}</span>
    <span>for</span> quest <span>in</span> questQuery<span>:</span>
        quests<span>[</span>quest<span>.</span>name<span>]</span> <span>=</span> quest<span>.</span>description
    <span>return</span> jsonify<span>(</span>quests<span>)</span>

@app<span>.</span>route<span>(</span><span>'/quests'</span><span>,</span> methods<span>=</span><span>[</span><span>'POST'</span><span>]</span><span>)</span>
<span>def</span> <span>post_quest</span><span>(</span><span>)</span><span>:</span>
    newQuest <span>=</span> Quest<span>(</span>name<span>=</span>request<span>.</span>json<span>[</span><span>'name'</span><span>]</span><span>,</span> description<span>=</span>request<span>.</span>json<span>[</span><span>'description'</span><span>]</span><span>)</span>
    db<span>.</span>session<span>.</span>add<span>(</span>newQuest<span>)</span>
    db<span>.</span>session<span>.</span>commit<span>(</span><span>)</span>
    <span>return</span> <span>"Quest Added!"</span></code></pre><!--kg-card-end: code--><p>Similarly, the database model (akin to the Mongoose "schema") is in /app/models.py:</p><!--kg-card-begin: code--><pre><code><span>class</span> <span>Quest</span><span>(</span>db<span>.</span>Model<span>)</span><span>:</span>
    name <span>=</span> db<span>.</span>Column<span>(</span>db<span>.</span>String<span>(</span><span>256</span><span>)</span><span>,</span> primary_key<span>=</span><span>True</span><span>,</span> index<span>=</span><span>True</span><span>,</span> unique<span>=</span><span>True</span><span>)</span>
    description <span>=</span> db<span>.</span>Column<span>(</span>db<span>.</span>String<span>(</span><span>256</span><span>)</span><span>,</span> index<span>=</span><span>True</span><span>,</span> unique<span>=</span><span>True</span><span>)</span></code></pre><!--kg-card-end: code--><p>As I mentioned, I'm more familiar with JavaScript and C# than with Python, and working with the latter to build the Flask API felt like cheating. Certain things like pathing, package handling, and writing workable code were just <em>easy</em>, although I did get hung up on getting the API to correctly parse JSON for the client. I suspect that was more of an issue of my unfamiliarity with the language than anything else, but it did take time to troubleshoot.</p><p>To be quite honest, coming from a non-Flask background, I did kind of expect to complete a couple of tutorials and spin up an API without having to do all that much work for it. &nbsp;</p><p>I can't say that it turned out that way, as Python does have its own particulars that require some time to get used to. Still, the Python ecosystem appears to be extremely well organized, and I enjoyed my time building the Flask API.</p><p>I've also heard that Django is a better and more scalable option for larger projects. But it seems like it would involve a separate, and steeper, learning curve to become proficient. </p><p>Flask was easy enough for me as a non-Python developer to pick up and build something over a weekend. I suspect that learning Django would take quite a bit longer, but with potentially greater dividends over the long run. </p><h3 id="python-flask-resources">Python/Flask Resources</h3><p>To build the Flask API, I used:</p><ul><li><a href="https://www.python.org/">Python 3</a>/<a href="https://pip.pypa.io/en/stable/">pip</a> for package management</li><li><a href="https://palletsprojects.com/p/flask/">Flask</a> as the main web framework</li><li><a href="https://pypi.org/project/python-dotenv/">python-dotenv</a> to configure environment variables</li><li><a href="https://www.sqlite.org/index.html">SQLite</a> as the database </li><li><a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/">Flask-SQLAlchemy</a> as the ORM to work with SQLite</li><li><a href="https://flask-migrate.readthedocs.io/en/latest/">Flask-Migrate</a> as an additional tool to migrate data to SQLite </li><li><a href="https://flask-cors.readthedocs.io/en/latest/">Flask-CORS</a> to handle the same CORS issue as with the Express API</li><li>The <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world">Flask Mega-Tutorial</a> to learn the basics</li><li>The <a href="https://blog.miguelgrinberg.com/post/designing-a-restful-api-with-python-and-flask">Flask REST API tutorial</a> to understand how to receive HTTP requests</li></ul><h2 id="c-api-asp-net">C# API: ASP.NET</h2><p>I can't tell you how many times I've Googled ".<a href="https://dotnet.microsoft.com/">NET</a>" to understand what it is, how it's different from <a href="https://dotnet.microsoft.com/apps/aspnet">ASP.NET</a>, and why I'd want to use any of it. My C# knowledge comes mainly from working with <a href="https://unity.com/">Unity</a>, which exists somewhat adjacent to .NET and doesn't provide for a lot of exposure to Microsoft's larger ecosystem.</p><p>I've spent some time researching <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.1&amp;tabs=visual-studio">Razor Pages</a> and <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/overview?view=aspnetcore-3.1">MVC</a>, and finally came to understand ASP.NET's breadth of features as Microsoft's open source web framework. I decided to toss ASP.NET into the hat for a potential back end for my app, and set about working through the <a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mongo-app?view=aspnetcore-3.1&amp;tabs=visual-studio">official web API tutorial</a> with ASP.NET Core and MongoDB.</p><p>The file structure for this version of the API was more complex than the others, given that .NET projects tend to have a much larger footprint:</p><!--kg-card-begin: image--><figure><img src="https://www.freecodecamp.org/news/content/images/2020/02/ASPNet-Structure.PNG"></figure><!--kg-card-end: image--><p>I should also mention that I already had Visual Studio and all of the required workloads installed, which made the setup process easier. Plus, having spent time with MongoDB for the Express API, I found the database portion of the project to be similar, although by default, ASP.NET seems to prefer using Microsoft's <a href="https://www.microsoft.com/en-us/sql-server/default.aspx">SQL Server</a> and the <a href="https://docs.microsoft.com/en-us/ef/">Entity Framework ORM</a>.</p><p>The ASP.NET code for HTTP requests is a bit more complex than what we've seen with the two other APIs, but it's no match for all of the code that sits <em>around </em>it. &nbsp;</p><p>First, consider this snippet in /Controllers/QuestController.cs that handles requests:</p><!--kg-card-begin: code--><pre><code>namespace QuestAPI<span>.</span>Controllers
<span>{</span>
    <span>[</span><span>Route</span><span>(</span><span>"quests/"</span><span>)</span><span>]</span>
    <span>[</span>ApiController<span>]</span>
    public class QuestsController <span>:</span> ControllerBase
    <span>{</span>
        private readonly QuestService _questService<span>;</span>

        public <span>QuestsController</span><span>(</span>QuestService questService<span>)</span>
        <span>{</span>
            _questService <span>=</span> questService<span>;</span>
        <span>}</span>

        <span>[</span>HttpGet<span>]</span>
        public ActionResult<span>&lt;</span>List<span>&lt;</span>Quest<span>&gt;&gt;</span> <span>Get</span><span>(</span><span>)</span> <span>=</span><span>&gt;</span>
            _questService<span>.</span><span>Get</span><span>(</span><span>)</span><span>;</span>

        <span>[</span>HttpPost<span>]</span>
        public ActionResult<span>&lt;</span>Quest<span>&gt;</span> <span>Create</span><span>(</span>Quest quest<span>)</span>
        <span>{</span>
            _questService<span>.</span><span>Create</span><span>(</span>quest<span>)</span><span>;</span>
            <span>return</span> <span>CreatedAtRoute</span><span>(</span><span>"GetQuest"</span><span>,</span> new <span>{</span> id <span>=</span> quest<span>.</span>Id<span>.</span><span>ToString</span><span>(</span><span>)</span> <span>}</span><span>,</span> quest<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span></code></pre><!--kg-card-end: code--><p>Not too terrible, almost kind of readable, in a C# sort of way. The data model in /Models/Quest.cs is even easier:</p><!--kg-card-begin: code--><pre><code>namespace QuestAPI<span>.</span>Models<span>{</span>
    public class Quest
    <span>{</span>
        <span>[</span>BsonId<span>]</span>
        <span>[</span><span>BsonRepresentation</span><span>(</span>BsonType<span>.</span>ObjectId<span>)</span><span>]</span>
        public string Id <span>{</span> get<span>;</span> set<span>;</span> <span>}</span>

        <span>[</span><span>BsonElement</span><span>(</span><span>"Name"</span><span>)</span><span>]</span>
        public string Name <span>{</span> get<span>;</span> set<span>;</span> <span>}</span>

        public string Description <span>{</span> get<span>;</span> set<span>;</span> <span>}</span>
    <span>}</span>
<span>}</span></code></pre><!--kg-card-end: code--><p>These two snippets essentially do the same things as the previous examples that we've seen: take requests from the front end, process them to get or modify data in the database, and send a response back to the client. &nbsp;</p><p>Yet, as you can probably tell from the complex file structure, there's so much code that surrounds these snippets, along with <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/">Interfaces</a>, <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-3.1">Dependency Injection</a>, and other abstractions, that it can be challenging to understand how it all works together.</p><p>Consider the following configuration code in /Startup.cs:</p><!--kg-card-begin: code--><pre><code>        public <span>void</span> <span>ConfigureServices</span><span>(</span>IServiceCollection services<span>)</span>
        <span>{</span>
            services<span>.</span>Configure<span>&lt;</span>QuestDatabaseSettings<span>&gt;</span><span>(</span>Configuration<span>.</span><span>GetSection</span><span>(</span><span>nameof</span><span>(</span>QuestDatabaseSettings<span>)</span><span>)</span><span>)</span><span>;</span>

            services<span>.</span>AddSingleton<span>&lt;</span>IQuestDatabaseSettings<span>&gt;</span><span>(</span>sp <span>=</span><span>&gt;</span> sp<span>.</span>GetRequiredService<span>&lt;</span>IOptions<span>&lt;</span>QuestDatabaseSettings<span>&gt;&gt;</span><span>(</span><span>)</span><span>.</span>Value<span>)</span><span>;</span>

            services<span>.</span>AddSingleton<span>&lt;</span>QuestService<span>&gt;</span><span>(</span><span>)</span><span>;</span>

            services<span>.</span><span>AddCors</span><span>(</span>options <span>=</span><span>&gt;</span>
            <span>{</span>
                options<span>.</span><span>AddPolicy</span><span>(</span>MyAllowSpecificOrigins<span>,</span> builder <span>=</span><span>&gt;</span>
                <span>{</span>
                    builder<span>.</span><span>WithOrigins</span><span>(</span><span>"http://localhost:3000/quests"</span><span>,</span> <span>"http://localhost:8080"</span><span>)</span><span>.</span><span>AllowAnyHeader</span><span>(</span><span>)</span><span>.</span><span>AllowAnyMethod</span><span>(</span><span>)</span><span>;</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span><span>)</span><span>;</span>

            services<span>.</span><span>AddControllers</span><span>(</span><span>)</span><span>;</span>
        <span>}</span></code></pre><!--kg-card-end: code--><p>Or this particularly nested bit from a separate <a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-3.1&amp;tabs=visual-studio">SQL Server web API tutorial</a>:</p><!--kg-card-begin: code--><pre><code>    <span>[</span>HttpGet<span>]</span>
    public async Task<span>&lt;</span>ActionResult<span>&lt;</span>IEnumerable<span>&lt;</span>TodoItemDTO<span>&gt;&gt;</span><span>&gt;</span> <span>GetTodoItems</span><span>(</span><span>)</span>
    <span>{</span>
        <span>return</span> await _context<span>.</span>TodoItems
            <span>.</span><span>Select</span><span>(</span>x <span>=</span><span>&gt;</span> <span>ItemToDTO</span><span>(</span>x<span>)</span><span>)</span>
            <span>.</span><span>ToListAsync</span><span>(</span><span>)</span><span>;</span>
    <span>}</span></code></pre><!--kg-card-end: code--><p>Lol. What?? As a new user, even familiar as I am with C#, I can go line-by-line to understand each abstraction, or I can just trust that the framework is handling everything for me and forget about it.</p><p>I tend to want to know exactly how my code works so that I can fix or alter it if necessary. But I certainly feel like my time spent learning the ins-and-outs of ASP.NET could be better utilized towards mastering another framework.</p><p>To be fair, ASP.NET appears to be similar to Django in being more opinionated and providing you with a ton of stuff out of the box, including an authentication solution, database management, and the lot. If these things are important to you, it's certainly worth considering. &nbsp;</p><p>It also has the full support of Microsoft and an open source community. So if you're looking at developing enterprise-level applications that need to scale, you might want to take a longer look at ASP.NET as a potential solution.</p><h3 id="c-asp-net-resources">C#/ASP.Net Resources</h3><p>To build the ASP.Net API, I used the following resources:</p><ul><li><a href="https://visualstudio.microsoft.com/downloads/">Visual Studio Community</a> as my code editor and IDE, with the ASP.NET and web development workload installed (I already had MongoDB running from the Express API)</li><li>Microsoft's <a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mongo-app?view=aspnetcore-3.1&amp;tabs=visual-studio">official tutorial</a> for building web APIs with ASP.NET and MongoDB</li></ul><h2 id="tl-dr">TL;DR</h2><p>In all, with some slight variations and hiccups among them, I've gotten each of the web APIs to work with the Vue client, with the ability to view quests from and add quests to the database. Hopefully, my explanation of the process has been helpful in your own search for a back end framework, but here are some additional recommendations just in case:</p><ul><li>If you're a JavaScript developer and/or want to manage everything that your application does, including its architecture, consider using Express.</li><li>If you're a Python developer and/or want a pleasant experience in developing small projects, try Flask, but consider using Django if you need more out-of-the-box support and don't mind conforming to an opinionated framework.</li><li>If you're a C# developer and willing to spend the time to learn the most arcane details of C# coding best practices, consider using ASP.NET. Alternatively, if you need enterprise-level support right out of the box, you'd be hard-pressed to find better.</li><li>If you don't know what to use and just want to learn back end development, take a look at Flask. &nbsp;It's easy to work with and will teach you the basics that you'll need to know for building web apps in any coding language.</li><li>If you don't know what to use and want an adventure, choose Express. There's a rabbit hole of package management and Stack Overflow questions waiting that may make you tear your hair out, but you'll learn a lot about the JavaScript ecosystem and web development in general.</li></ul><p>Additionally, two things bear mentioning that threw me for a spin in this process: CORS and environment variables. The former I've mentioned in this article a couple of times already, but it's worth discussing again to understand the scope of building a full stack app on your machine.</p><p>Unless you have an integrated development environment that's handling the whole stack for you, you'll likely have a client, a server, and a database that are all running independently of one another. &nbsp;</p><p>In the Express API section above, for example, I was running </p><ol><li>the Vue CLI server, which rendered my front end app on port 8080; </li><li>an NPM script to spin up the Express API server on port 3000; and</li><li>a separate instance of the Mongo database to get everything working together. That's three command prompts open and a general mess!</li></ol><p>If you dig into the Vue code above (or on GitHub), you'll see that the requests made on behalf of the client, running on http://localhost:8080, are to the server on http://localhost:3000, which is where the Express API is listening. This is called "cross-origin resource sharing," or <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a>, and it's blocked by the browser for security concerns. Most frameworks require you to install an additional package to get the whole thing running in your local environment.</p><p>Second, you'll want to become comfortable with <a href="https://en.wikipedia.org/wiki/Environment_variable">environment variables</a>, which can really help smooth some rough pathing edges at runtime. I used <a href="https://www.npmjs.com/package/dotenv">dotenv</a> and <a href="https://pypi.org/project/Flask-Env/">Flask-Env</a> for the Express and Flask projects, respectively. </p><p>Both packages allow you to configure things like where your database lives, or what default port your application should be using, in one document. Your application then uses that document at runtime to figure out where to find everything, without any further configuration needed from you.</p><p>One final note that may be helpful if you're just working on a back end project and don't want to go through the trouble of building a front end client: consider using a third-party app like <a href="https://www.postman.com/">Postman</a>. I used it to make HTTP requests to each of the APIs to make sure they were working properly before layering on the Vue client and trying to get the whole stack running altogether. </p><p>I hope this article has been helpful for you in your own process of looking for a back end framework. &nbsp;Let me know what you find! </p><p>If you enjoyed this article, please consider <a href="https://www.nightpathpub.com/">checking out my games and books</a> or <a href="https://www.youtube.com/msfarzan?sub_confirmation=1">subscribing to my YouTube channel</a>.</p><p>M. S. Farzan, Ph.D. has written and worked for high-profile video game companies and editorial websites such as Electronic Arts, Perfect World Entertainment, Modus Games, and MMORPG.com, and has served as the Community Manager for games like <em>Dungeons &amp; Dragons Neverwinter</em> and <em>Mass Effect: Andromeda</em>. He is the Creative Director and Lead Game Designer of <em><a href="https://www.nightpathpub.com/rpg">Entromancy: A Cyberpunk Fantasy RPG</a></em> and author of <em><a href="http://nightpathpub.com/books">The Nightpath Trilogy</a></em>. Find M. S. Farzan on Twitter <a href="https://twitter.com/sominator">@sominator</a>.</p>
                </div>
                <hr>
                                
<p>
        Learn to code for free. freeCodeCamp's open source curriculum has helped more than 40,000 people get jobs as
        developers. <a href="https://www.freecodecamp.org/learn">Get started</a>
    </p>            </section>



        </article>
    </div>
</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>