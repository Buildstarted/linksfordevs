<!DOCTYPE html>
<html lang="en">
<head>
    <title>
diagnostics/intermittent_memory_spike.md at master &#xB7; dotnet/diagnostics &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>diagnostics/intermittent_memory_spike.md at master · dotnet/diagnostics · GitHub</h1><div><div id="" class="markdown-body entry-content p-3 p-md-6"><p><strong>IMPORTANT: This tutorial uses API/methods available in dotnet core preview 5. These API/methods are <em>subject to change.</em></strong></p><p><a href="http://localhost:5000/api/diagscenario/memspike/%7Bseconds%7D" rel="nofollow">http://localhost:5000/api/diagscenario/memspike/{seconds}</a></p><p>In this scenario, the endpoint will experience intermittent memory spikes over the specified number of seconds. Memory will go from base line to spike and back to baseline several times. What makes this scenario different from the memory leak scenario is that we will have to figure out a way to automatically trigger the collection of a dump when the memory spikes.</p><h3><a id="user-content-memory-counters" class="anchor" aria-hidden="true" href="#memory-counters"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Memory counters</h3><p>Before we dig into collecting diagnostics data to help us root cause this scenario, we need to convince ourselves that what we are  seeing is an intermittent memory spike. To help with this we can use the dotnet-counters tool which allows us to watch the memory usage for a selected dotnet process (please see <a href="/dotnet/diagnostics/blob/master/documentation/tutorial/installing_the_diagnostics_tools.md">Installing the diagnostics tools</a>).</p><p>Let's run the webapi (dotnet run) and before navigating to the above URL (specifying 300 seconds) check our managed memory counters:</p><blockquote><div class="highlight highlight-source-shell"><pre>dotnet-counters monitor --refresh-interval 1 -p 4807</pre></div></blockquote><p>4807 is the process identifier which can be found using dotnet-trace list-processes. The refresh-interval is the number of seconds before refreshes.</p><p>The output should be similar to the below:</p><p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/15442480/57110730-6429fb80-6cee-11e9-8bd1-4f37496c70fe.png"><img src="https://user-images.githubusercontent.com/15442480/57110730-6429fb80-6cee-11e9-8bd1-4f37496c70fe.png" alt="alt text"></a></p><p>Here we can see that right after startup, the managed heap memory is 4MB.</p><p>Now, let's navigate to the URL (<a href="http://localhost:5000/api/diagscenario/memspike/300" rel="nofollow">http://localhost:5000/api/diagscenario/memspike/300</a>) which will run for 5 minutes giving us ample time to experiment.</p><p>Re-run the dotnet-counters command. We should see an alternating heap size with a baseline of roughly 250MB and the highest spike around 630MB. The memory usage will alternate between baseline and spike every 5 seconds or so.</p><p>Baseline:
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/15442480/57338185-463f0b00-70e1-11e9-8d52-0305d3158dd5.jpg"><img src="https://user-images.githubusercontent.com/15442480/57338185-463f0b00-70e1-11e9-8d52-0305d3158dd5.jpg" alt="alt text"></a></p><p>High:
<a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/15442480/57338164-36272b80-70e1-11e9-843a-604af1ddfd5f.jpg"><img src="https://user-images.githubusercontent.com/15442480/57338164-36272b80-70e1-11e9-843a-604af1ddfd5f.jpg" alt="alt text"></a></p><p>At this point, we can safely say that memory is spiking to a high that is not normal and the next step is to run a collection tool that can help us collect the right data at the right time.</p><h3><a id="user-content-core-dump-generation" class="anchor" aria-hidden="true" href="#core-dump-generation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Core dump generation</h3><p>Let's step back a bit and revisit the high memory scenario earlier in the tutorial. In that scenario, memory grew high and stayed high allowing us the opportunity to run the dotnet-dump command without restriction. However, in our current scenario we have a short memory spike that only lasts about 5 seconds per spike. This makes it difficult to get setup to run the dotnet-dump tool manually. What we would preferably like is a tool that could monitor the dotnet core counters and automatically create a core dump once a threshold has been breached. This is a perfect opportunity to start exploring how we can write our own diagnostics tools to cater to our diagnostics needs.</p><p>What we would like this tool to do is allow the user to specify the pid of the target process as well as the memory consumption threshold (in MBs). It would then continuously monitor the process and create a dump if the threshold is breached:</p><blockquote><div class="highlight highlight-source-shell"><pre>sudo ./triggerdump <span class="pl-k">&lt;</span>pid<span class="pl-k">&gt;</span><span class="pl-k">&lt;</span>memory threshold <span class="pl-k">in</span> MBs<span class="pl-k">&gt;</span></pre></div></blockquote><h4><a id="user-content-some-background-before-we-start-writing-the-tool" class="anchor" aria-hidden="true" href="#some-background-before-we-start-writing-the-tool"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Some background before we start writing the tool...</h4><p>The dotnet core runtime contains a mechanism known as the EventPipe that carries events to interested consumers. There are several different events that flow through the EventPipe including diagnostics information such as counters. The EventPipe is exposed as a Unix domain socket on Linux machines and named pipes on Windows.  EventPipe is set to duplex mode which means that clients can both read and write to the pipe. A diagnostics application can register to consume these events from the EventPipe and create new diagnostics experiences. Rather than communicating directly with EventPipe there is a client library that can be used and implemented in Microsoft.Diagnostics.Tools.RuntimeClient.dll.</p><p>Events that are written to the EventPipe can come from multiple sources (or providers) and as such, clients that receive events over EventPipe can filter those events based on specific providers.</p><h4><a id="user-content-writing-the-tool" class="anchor" aria-hidden="true" href="#writing-the-tool"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Writing the tool...</h4><p>We have two requirements in order to implement a tool that will create a dump file based on memory consumption:</p><ul><li>Read dotnet memory counter to know if the current memory consumptions goes above the specified threshold</li><li>Generate the actual core dump</li></ul><p>Let's start with the first requirement, reading dotnet counters. As explained earlier, we can use the EventPipe mechanism to read counters from the runtime. In this case, the provider that writes counter events is System.Runtime.</p><p><a href="/dotnet/diagnostics/blob/master/documentation/tutorial/src/triggerdump/Program.cs">Full code</a></p><p>Below is the releveant code snippet that is required to consume the counters:</p><div class="highlight highlight-source-cs"><pre><span class="pl-en">Task</span><span class="pl-smi">monitorTask</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">Task</span>(() <span class="pl-k">=&gt;</span> 
{
    <span class="pl-k">var</span><span class="pl-smi">prov</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">List</span>&lt;<span class="pl-en">Provider</span>&gt;();
    <span class="pl-smi">prov</span>.<span class="pl-en">Add</span>(<span class="pl-k">new</span><span class="pl-en">Provider</span>(<span class="pl-s"><span class="pl-pds">"</span>System.Runtime<span class="pl-pds">"</span></span>, <span class="pl-smi">filterData</span>:<span class="pl-s"><span class="pl-pds">"</span>EventCounterIntervalSec=1<span class="pl-pds">"</span></span>));

    <span class="pl-k">var</span><span class="pl-smi">configuration</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SessionConfiguration</span>(
    <span class="pl-smi">circularBufferSizeMB</span>: <span class="pl-c1">1000</span>,
    <span class="pl-smi">outputPath</span>: <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,
    <span class="pl-smi">providers</span>: <span class="pl-smi">prov</span>);
    
    <span class="pl-k">var</span><span class="pl-smi">binaryReader</span><span class="pl-k">=</span><span class="pl-smi">EventPipeClient</span>.<span class="pl-en">CollectTracing</span>(<span class="pl-smi">Int32</span>.<span class="pl-en">Parse</span>(<span class="pl-smi">args</span>[<span class="pl-c1">0</span>]), <span class="pl-smi">configuration</span>, <span class="pl-k">out</span><span class="pl-smi">_sessionId</span>);
    <span class="pl-en">EventPipeEventSource</span><span class="pl-smi">source</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">EventPipeEventSource</span>(<span class="pl-smi">binaryReader</span>);
    <span class="pl-smi">source</span>.<span class="pl-smi">Dynamic</span>.<span class="pl-smi">All</span><span class="pl-k">+=</span><span class="pl-smi">Dynamic_All</span>;
    <span class="pl-smi">source</span>.<span class="pl-en">Process</span>();
});</pre></div><p>The above code first creates the configuration and specifying the buffer size, output path and finally the System.Runtime provider that we are interested in. Next, it calls the CollectTracing method specifying the process identifier we are interested in tracing, the configuration and an out session ID. Once that is completed, we create an EventPipeSource from the reader created in the previous step and attach a callback that will be invoked as the events are delivered over EventPipe. Last, we call the Process method to start processing the events. At this point, the Dynamic_All method will be invoked anytime an event comes through from the System.Runtime provider.</p><p>Now that we have the events flowing through out callback, let's turn our attention to the callback itself and how we can get the counter information:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">private</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Dynamic_All</span>(<span class="pl-en">TraceEvent</span><span class="pl-smi">obj</span>)
{
    <span class="pl-k">if</span> (<span class="pl-smi">obj</span>.<span class="pl-smi">EventName</span>.<span class="pl-en">Equals</span>(<span class="pl-s"><span class="pl-pds">"</span>EventCounters<span class="pl-pds">"</span></span>))
    {
        <span class="pl-en">IDictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt; <span class="pl-smi">payloadVal</span><span class="pl-k">=</span> (<span class="pl-en">IDictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt;)(<span class="pl-smi">obj</span>.<span class="pl-en">PayloadValue</span>(<span class="pl-c1">0</span>));
        <span class="pl-en">IDictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt; <span class="pl-smi">payloadFields</span><span class="pl-k">=</span> (<span class="pl-en">IDictionary</span>&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt;)(<span class="pl-smi">payloadVal</span>[<span class="pl-s"><span class="pl-pds">"</span>Payload<span class="pl-pds">"</span></span>]);

        <span class="pl-en">ICounterPayload</span><span class="pl-smi">payload</span><span class="pl-k">=</span><span class="pl-smi">payloadFields</span>.<span class="pl-smi">Count</span><span class="pl-k">==</span><span class="pl-c1">6</span><span class="pl-k">?</span> (<span class="pl-en">ICounterPayload</span>)<span class="pl-k">new</span><span class="pl-en">IncrementingCounterPayload</span>(<span class="pl-smi">payloadFields</span>) <span class="pl-k">:</span> (<span class="pl-en">ICounterPayload</span>)<span class="pl-k">new</span><span class="pl-en">CounterPayload</span>(<span class="pl-smi">payloadFields</span>);
        <span class="pl-k">string</span><span class="pl-smi">displayName</span><span class="pl-k">=</span><span class="pl-smi">payload</span>.<span class="pl-en">GetDisplay</span>();                
        <span class="pl-k">if</span> (<span class="pl-smi">string</span>.<span class="pl-en">IsNullOrEmpty</span>(<span class="pl-smi">displayName</span>))
        {
            <span class="pl-smi">displayName</span><span class="pl-k">=</span><span class="pl-smi">payload</span>.<span class="pl-en">GetName</span>();
        }

        <span class="pl-k">if</span>(<span class="pl-smi">string</span>.<span class="pl-en">Compare</span>(<span class="pl-smi">displayName</span>, <span class="pl-s"><span class="pl-pds">"</span>GC Heap Size<span class="pl-pds">"</span></span>) <span class="pl-k">==</span><span class="pl-c1">0</span><span class="pl-k">&amp;&amp;</span><span class="pl-smi">Convert</span>.<span class="pl-en">ToInt32</span>(<span class="pl-smi">payload</span>.<span class="pl-en">GetValue</span>())<span class="pl-k">&gt;</span><span class="pl-smi">threshold</span>)
        {
            <span class="pl-c"><span class="pl-c">//</span> Generate dump and exit</span>
        }
    }
}</pre></div><p>Every time the callback is invoked, a TraceEvent is recieved. The TraceEvent contains information about the event that was delivered. In our case, the first thing we do is to make sure the event corresponds to EventCounters. If so, we get the GC Heap Size counter from the event payload and compare it to the threshold that the user set as part of the command line invocation. If the threshold was breached, we are ready to generate a dump.</p><p>The last step of the puzzle is to generate the dump. For brevity, we will focus only on core dump generation on Linux. In preview 5, the way to generate a core dump is to invoke the createdump tool that ships with the runtime. Add the following code to the Dynamic_All method (replacing the Generate dump and exit comment):</p><div class="highlight highlight-source-cs"><pre><span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>Memory threshold has been breached....<span class="pl-pds">"</span></span>);
<span class="pl-smi">System</span>.<span class="pl-smi">Diagnostics</span>.<span class="pl-smi">Process</span><span class="pl-smi">process</span><span class="pl-k">=</span><span class="pl-smi">System</span>.<span class="pl-smi">Diagnostics</span>.<span class="pl-smi">Process</span>.<span class="pl-en">GetProcessById</span>(<span class="pl-smi">pid</span>);

<span class="pl-smi">System</span>.<span class="pl-smi">Diagnostics</span>.<span class="pl-smi">ProcessModule</span><span class="pl-smi">coreclr</span><span class="pl-k">=</span><span class="pl-smi">process</span>.<span class="pl-smi">Modules</span>.<span class="pl-en">Cast</span>&lt;<span class="pl-k">System</span>.<span class="pl-k">Diagnostics</span>.<span class="pl-en">ProcessModule</span>&gt;().<span class="pl-en">FirstOrDefault</span>(<span class="pl-smi">m</span><span class="pl-k">=&gt;</span><span class="pl-smi">string</span>.<span class="pl-en">Equals</span>(<span class="pl-smi">m</span>.<span class="pl-smi">ModuleName</span>, <span class="pl-s"><span class="pl-pds">"</span>libcoreclr.so<span class="pl-pds">"</span></span>));
<span class="pl-k">if</span> (<span class="pl-smi">coreclr</span><span class="pl-k">==</span><span class="pl-c1">null</span>)
{
    <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>Unable to locate .NET runtime associated with this process!<span class="pl-pds">"</span></span>);
    <span class="pl-smi">Environment</span>.<span class="pl-en">Exit</span>(<span class="pl-c1">1</span>);
}
<span class="pl-k">else</span>
{
    <span class="pl-k">string</span><span class="pl-smi">runtimeDirectory</span><span class="pl-k">=</span><span class="pl-smi">Path</span>.<span class="pl-en">GetDirectoryName</span>(<span class="pl-smi">coreclr</span>.<span class="pl-smi">FileName</span>);
    <span class="pl-k">string</span><span class="pl-smi">createDumpPath</span><span class="pl-k">=</span><span class="pl-smi">Path</span>.<span class="pl-en">Combine</span>(<span class="pl-smi">runtimeDirectory</span>, <span class="pl-s"><span class="pl-pds">"</span>createdump<span class="pl-pds">"</span></span>);
    <span class="pl-k">if</span> (<span class="pl-k">!</span><span class="pl-smi">File</span>.<span class="pl-en">Exists</span>(<span class="pl-smi">createDumpPath</span>))
    {
        <span class="pl-smi">Console</span>.<span class="pl-en">WriteLine</span>(<span class="pl-s"><span class="pl-pds">"</span>Unable to locate 'createdump' tool in '{runtimeDirectory}'<span class="pl-pds">"</span></span>);
        <span class="pl-smi">Environment</span>.<span class="pl-en">Exit</span>(<span class="pl-c1">1</span>);                            
    }                        

    <span class="pl-k">var</span><span class="pl-smi">createdump</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">System</span>.<span class="pl-k">Diagnostics</span>.<span class="pl-en">Process</span>()
    {       
        <span class="pl-smi">StartInfo</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-k">System</span>.<span class="pl-k">Diagnostics</span>.<span class="pl-en">ProcessStartInfo</span>()
        {
            <span class="pl-smi">FileName</span><span class="pl-k">=</span><span class="pl-smi">createDumpPath</span>,
            <span class="pl-smi">Arguments</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">$"</span>--name coredump --withheap {<span class="pl-smi">pid</span>}<span class="pl-pds">"</span></span>,
        },
        <span class="pl-smi">EnableRaisingEvents</span><span class="pl-k">=</span><span class="pl-c1">true</span>,
    };

    <span class="pl-smi">createdump</span>.<span class="pl-en">Start</span>();
    <span class="pl-smi">createdump</span>.<span class="pl-en">WaitForExit</span>();

    <span class="pl-smi">Environment</span>.<span class="pl-en">Exit</span>(<span class="pl-c1">0</span>);
}</pre></div><p>We can now build the tool (dotnet build) and run it against our application. Once built, restart the test webapi, get the process id from dotnet-trace and run triggerdump:</p><blockquote><div class="highlight highlight-source-shell"><pre>dotnet-trace list-processes
...
80926 webapi     /home/marioh/webapi/bin/Debug/netcoreapp3.0/webapi
sudo dotnet triggerdump.dll 80926 500</pre></div></blockquote><p>Please note that triggerdump has to be run with sudo. The invocation tells triggerdump to monitor process with a process id of 80926 and to create dump when memory grows above 500MB.</p><p>At this point, you should see triggerdump waiting/monitoring the memory counter. Let's trigger the intermittent memory spike by navigating to:</p><p><a href="http://localhost:5000/api/diagscenario/memspike/300" rel="nofollow">http://localhost:5000/api/diagscenario/memspike/300</a></p><p>After 10-15 seconds, you will notice that triggerdump outputs the following followed by exiting.</p><blockquote><div class="highlight highlight-source-shell"><pre>...
Writing minidump with heap to file coredump
Written 820518912 bytes (200322 pages) to core file</pre></div></blockquote><p>That's it for creating your own diagnostics tool to solve the intermittent memory spike scenario!</p><h3><a id="user-content-analyzing-the-core-dump" class="anchor" aria-hidden="true" href="#analyzing-the-core-dump"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Analyzing the core dump</h3><p>Since the core dump that our tool generates is a standard core dump, we can use the same techniques illustrated in <a href="/dotnet/diagnostics/blob/master/documentation/tutorial/app_is_leaking_memory_eventual_crash.md">Scenario - App is leaking memory</a> to analyze the dump and find out why we're seeing intermittent high memory conditions.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>