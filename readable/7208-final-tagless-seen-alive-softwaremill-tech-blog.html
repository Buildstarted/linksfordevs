<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Final Tagless seen alive - SoftwareMill Tech Blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Final Tagless seen alive - SoftwareMill Tech Blog</h1><div><div class="ac ae af ag ah ea aj ak"><p id="6ebc" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">If you follow the Scala community, you’ve probably heard about John de Goes’s talk “Death of Final Tagless”. If you haven’t, no worries — it’s available online both <a href="https://skillsmatter.com/skillscasts/13247-scala-matters" class="da by gy gz ha hb" target="_blank" rel="noopener">as a video</a> &amp; <a href="http://degoes.net/articles/zio-environment" class="da by gy gz ha hb" target="_blank" rel="noopener">a blog post</a> — and I definitely recommend watching it. The talk starts with a gentle and very clearly presented motivation on why to use functional effects in the first place. It shows that John is an experienced teacher! But more than that, it’s one of those talks which make you rethink some of the fashions in our industry and assumptions you’ve held so far.</p><figure class="hd he hf hg hh hi dm dn paragraph-image"><p id="74c2" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">The talk contains a fair amount of critique of the so-called “Final Tagless” encoding. However, this construct can be used for two purposes: <strong class="gm hz">constraining effect wrappers</strong> and <strong class="gm hz">tracking effects in detail</strong>. In John’s talk these are covered together, but they deserve separate treatment and separate criticism.</p><h1 id="c0d7" class="ia ib ed at as ic ef id eh ie if ig ih ii ij ik il"><strong class="bf">Final Tagless as a way to constrain effect wrappers</strong></h1><p id="3792" class="gk gl ed at gm b gn im gp in gr io gt ip gv iq gx dv">As John mentions in the beginning of his talk, the idea of “programming to an interface” (rather than to a concrete implementation) is well-understood and used pervasively in languages such as Java and Scala. I think we’re all used to defining the interface of a service, and making our code dependent on <strong class="gm hz">some</strong> implementation of that interface.</p><p id="9a00" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Repeating John’s <code class="ht ir is it iu b">Console</code> example, we start with a side-effecting version, where the console service is passed as a constructor parameter to its usage site:</p><pre class="hd he hf hg hh iv iw cl"><span id="727b" class="ix ib ed at iu b fg iy iz r ja">trait Console {<br>def putStrLn(line: String): Unit<br>def getStrLn: String<br>}</span><span id="6564" class="ix ib ed at iu b fg jb jc jd je jf iz r ja">object LiveConsole extends Console {<br>def putStrLn(line: String): Unit = println(line)<br>def getStrLn: String = scala.io.StdIn.readLine()<br>}</span><span id="173b" class="ix ib ed at iu b fg jb jc jd je jf iz r ja">class Main(console: Console) {<br>def run(): String = {<br>console.putStrLn("Good morning, what’s your name?")<br>val name = console.getStrLn<br>console.putStrLn(s"Great to meet you, $name")<br>name<br>}<br>}</span></pre><p id="0c19" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">The first step to improve this code is to introduce some control over side effects, by wrapping them in an <code class="ht ir is it iu b">IO</code> datatype. This is well motivated both in John’s talk and on <a href="https://typelevel.org/cats-effect/datatypes/io.html#introduction" class="da by gy gz ha hb" target="_blank" rel="noopener">various</a><a class="da by gy gz ha hb" target="_blank" rel="noopener" href="/synchronous-or-asynchronous-and-why-wrestle-with-wrappers-2c5667eb7acf">other</a><a href="https://medium.com/@sderosiaux/are-scala-futures-the-past-69bd62b9c001" class="da by gy gz ha hb" target="_blank" rel="noopener">blogs</a>, so I won’t repeat the argument here. We end up with the following code:</p><pre class="hd he hf hg hh iv iw cl"><span id="4361" class="ix ib ed at iu b fg iy iz r ja">trait Console {<br>def putStrLn(line: String): IO[Unit]<br>def getStrLn: IO[String]<br>}</span><span id="2ee5" class="ix ib ed at iu b fg jb jc jd je jf iz r ja">object LiveConsole extends Console {<br>def putStrLn(line: String): IO[Unit] = IO.effect(println(line))<br>def getStrLn: IO[String] = IO.effect(scala.io.StdIn.readLine())<br>}</span><span id="84a1" class="ix ib ed at iu b fg jb jc jd je jf iz r ja">class Main(console: Console) {<br>def run(): IO[String] = {<br>for {<br>_    &lt;- console.putStrLn("Good morning, what’s your name?")<br>name &lt;- console.getStrLn<br>_    &lt;- console.putStrLn(s"Great to meet you, $name")<br>} yield name<br>}<br>}</span></pre><p id="fac3" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Note that our <code class="ht ir is it iu b">Main.run</code> method now builds a data structure which <strong class="gm hz">describes</strong> effectful operations. Side-effects are contained, we can clearly see which methods have side effects (the ones that use <code class="ht ir is it iu b">IO</code>) and which don’t, and we can use the <code class="ht ir is it iu b">IO</code> values without fear in a referentially-transparent way.</p><p id="3569" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">So far so good; no Final Tagless in sight!</p><p id="2e27" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Can we improve further? Well, the <code class="ht ir is it iu b">IO</code> datatype is quite rich. It can describe sequential computations, wrap side effects, run computations in parallel, race two computations nondeterministically, etc. We might want to restrict this to know — just by looking at the signature of a method or class — what kind of operations can be performed on our chosen side-effects wrapper.</p><p id="68ee" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">The problem here is that we are using a <strong class="gm hz">concrete</strong> implementation of <code class="ht ir is it iu b">IO</code>, instead of programming to an interface! Let’s fix this. We need to somehow express that our code is dependent on a wrapper with a specific interface, instead of using a concrete implementation. We’ll start by parametrising our interface with “some” abstract wrapper which we will call <code class="ht ir is it iu b">F</code>:</p><pre class="hd he hf hg hh iv iw cl"><span id="893d" class="ix ib ed at iu b fg iy iz r ja">trait Console[F[_]] {<br>def putStrLn(line: String): F[Unit]<br>def getStrLn: F[String]<br>}</span></pre><p id="faf2" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">In <code class="ht ir is it iu b">LiveConsole</code> and <code class="ht ir is it iu b">Main</code> we are interacting with the <code class="ht ir is it iu b">F</code> wrapper by calling methods on it (e.g. <code class="ht ir is it iu b">flatMap</code> in <code class="ht ir is it iu b">Main.run</code>’s <code class="ht ir is it iu b">for</code>-comprehension), so we need something more: a way to express the fact the the <code class="ht ir is it iu b">F</code> should support a given set of methods. We’ll do this by introducing a dependency to <code class="ht ir is it iu b">LiveConsole</code> and <code class="ht ir is it iu b">Main</code>.</p><p id="e8ee" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">However, working with an effect wrapper (either abstract or concrete) is quite different from working with a regular service. Hence, we are going to introduce that dependency in a way which makes it easy to work with.</p><p id="9d35" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">In Scala, this is done by adding an implicit parameter (instead of a regular one) which <strong class="gm hz">gives capabilities </strong>to the <code class="ht ir is it iu b">F</code> effect wrapper. This is then used by extension methods, which are available on a type, if a specific implicit value is in scope.</p><p id="379f" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">What kind of dependencies do we need to introduce? For <code class="ht ir is it iu b">Main</code>, we only need <strong class="gm hz">sequential composition</strong>: describing an operation which first runs one effectful computation, and then a second one. This is what a <code class="ht ir is it iu b">Monad</code> gives us. For <code class="ht ir is it iu b">LiveConsole</code>, we need a way of <strong class="gm hz">wrapping side-effecting</strong> computations. This is what <code class="ht ir is it iu b"><a href="https://typelevel.org/cats-effect/typeclasses/sync.html" class="da by gy gz ha hb" target="_blank" rel="noopener">Sync</a></code><a href="https://typelevel.org/cats-effect/typeclasses/sync.html" class="da by gy gz ha hb" target="_blank" rel="noopener"> from cats-effect</a> (if we are using cats) represents. Our code now becomes (<code class="ht ir is it iu b">class Main[F[_]: Monad]</code> is just a shorthand notation for <code class="ht ir is it iu b">class Main[F[_]](implicit fm: Monad[F])</code>):</p><pre class="hd he hf hg hh iv iw cl"><span id="98cd" class="ix ib ed at iu b fg iy iz r ja">trait Console[F[_]] {<br>def putStrLn(line: String): F[Unit]<br>def getStrLn: F[String]<br>}</span><span id="448e" class="ix ib ed at iu b fg jb jc jd je jf iz r ja">class LiveConsole[F[_]: Sync] extends Console[F] {<br>def putStrLn(line: String): F[Unit] = <br>Sync[F].effect(println(line))<br>def getStrLn: F[String] = <br>Sync[F].effect(scala.io.StdIn.readLine())<br>}</span><span id="4a31" class="ix ib ed at iu b fg jb jc jd je jf iz r ja">class Main[F[_]: Monad](console: Console[F]) {<br>def run(): F[String] = {<br>for {<br>_    &lt;- console.putStrLn("Good morning, what’s your name?")<br>name &lt;- console.getStrLn<br>_    &lt;- console.putStrLn(s"Great to meet you, $name")<br>} yield name<br>}<br>}</span></pre><p id="fe1c" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">And that’s the whole idea behind Final Tagless — instead of using concrete effectful wrapper, we declare what kind of interface is needed for the wrapper in a particular class or method.</p><h1 id="6458" class="ia ib ed at as ic ef id eh ie if ig ih ii ij ik il"><strong class="bf">Final Tagless as a way to track effects</strong></h1><p id="bc1b" class="gk gl ed at gm b gn im gp in gr io gt ip gv iq gx dv">We can extend the idea presented above to track what kind of side effects our code uses in more detail. Scala gives us quite a wide range of possibilities here. The only question is: <strong class="gm hz">how fine-grained the effect tracking should be?</strong></p><p id="7a50" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Of course: <strong class="gm hz">it depends</strong>!</p><p id="4d1f" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">First, we have the option to <strong class="gm hz">track no effects</strong> at all. That’s what we’ve seen in the very first code snippet: the <code class="ht ir is it iu b">LiveConsole</code> implementation was just doing uncontrolled and unconstrained side effects (in this case, printing/reading from the console).</p><p id="01c0" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Improving on this, we can track side effects at a <strong class="gm hz">binary level</strong>: “has effects” or “has no effects”. Looking at a method signature, we know if it’s declared as being pure (e.g. <code class="ht ir is it iu b">f: List[User] =&gt; Statistics</code>) or if it is declared to have side effects (<code class="ht ir is it iu b">f: List[User] =&gt; IO[SentEmails]</code>).</p><p id="fa45" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Making this jump, from tracking no effects at all, to a has effect/no effect distinction is what makes the biggest difference in most code bases. And in many cases you can stop here.</p><p id="000c" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">However, if you want to, you can go further, and track in the method signatures what kind of effects <strong class="gm hz">exactly</strong> does a method use. <code class="ht ir is it iu b">IO</code> means “some effect”, while you could want to know — does it mean using a database? Sending emails? Interacting with the console?</p><p id="bbfb" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">That’s what various effect systems in Scala want to solve. And that’s also what <a href="https://scalaz.github.io/scalaz-zio/" class="da by gy gz ha hb" target="_blank" rel="noopener">ZIO Environment</a> is about. And it’s not the only proposed possibile solution; contenders in this space include:</p><blockquote class="jo jp jq"><p id="e600" class="gk gl ed jr gm b gn go gp gq gr gs gt gu gv gw gx dv">As a side note: ZIO Environment is not about “injecting dependencies”. Dependency injection and tracking effects are distinct things. The first one, <a class="da by gy gz ha hb" target="_blank" rel="noopener" href="/what-is-dependency-injection-8c9e7805502f">dependency injection</a>, is about creating a static object graph (module graph), where the dependencies are <strong class="gm hz">hidden</strong> from the use sites.</p><p id="1415" class="gk gl ed jr gm b gn go gp gq gr gs gt gu gv gw gx dv">Effect tracking is about making dependencies <strong class="gm hz">explicit</strong> to the use sites; dependencies become part of the interface. That’s why the reader monad is not an alternative to dependency injection, but <a href="https://softwaremill.com/reader-monad-constructor-dependency-injection-friend-or-foe/" class="da by gy gz ha hb" target="_blank" rel="noopener">can be a complement of it</a>.</p></blockquote><p id="2cd5" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">How to extend Final Tagless to track effects? Just as John has shown in his example. Instead of passing <code class="ht ir is it iu b">Console[F]</code> as a constructor parameter to <code class="ht ir is it iu b">Main</code>, we require it as another constraint for our effect wrapper <code class="ht ir is it iu b">F</code> on the method:</p><pre class="hd he hf hg hh iv iw cl"><span id="e06f" class="ix ib ed at iu b fg iy iz r ja">trait Console[F[_]] {<br>def putStrLn(line: String): F[Unit]<br>def getStrLn: F[String]<br>}<br>object Console {<br>def apply[F[_]](implicit F: Console[F]): Console[F] = F<br>}</span><span id="5770" class="ix ib ed at iu b fg jb jc jd je jf iz r ja">class LiveConsole[F[_]: Sync] extends Console[F] {<br>def putStrLn(line: String): F[Unit] = <br>Sync[F].effect(println(line))<br>def getStrLn: F[String] = <br>Sync[F].effect(scala.io.StdIn.readLine())<br>}</span><span id="e1a2" class="ix ib ed at iu b fg jb jc jd je jf iz r ja">object Main {<br>def run[F[_]: Monad: Console](): F[String] = {<br>for {<br>_    &lt;- Console[F].putStrLn("Good morning, what’s your name?")<br>name &lt;- Console[F].getStrLn<br>_    &lt;- Console[F].putStrLn(s"Great to meet you, $name")<br>} yield name<br>}<br>}</span></pre><p id="2241" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">While before the <code class="ht ir is it iu b">console</code> dependency was <strong class="gm hz">hidden</strong> from <code class="ht ir is it iu b">Main</code>’s users, now it is explicit. The dependency must be provided by the caller of the method, not when creating the object graph! Hence, each use-site also needs to have the <code class="ht ir is it iu b">Console</code> dependency, and so on.</p><p id="a4bc" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">We are now clear that <code class="ht ir is it iu b">Main.run</code> has side effects (as it uses an effect wrapper at all) and additionally what kind of side-effects exactly (it interacts with the console).</p><p id="2738" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Note that the <code class="ht ir is it iu b">: Sync</code> and <code class="ht ir is it iu b">: Monad</code> constraints are <strong class="gm hz">different </strong>in their nature from the <code class="ht ir is it iu b">: Console</code> constraint. The first ones describe the capabilities that the <code class="ht ir is it iu b">F</code> effect wrapper has, and form lawful, “true”, typeclasses. The second doesn’t say anything new about <code class="ht ir is it iu b">F</code>, it just constraints the possible side-effects. Such constraints shouldn’t be considered a typeclass in the first place (which is also one of John’s points).</p><h1 id="dca2" class="ia ib ed at as ic ef id eh ie if ig ih ii ij ik il"><strong class="bf">Is Final Tagless a good way to track effects?</strong></h1><p id="0333" class="gk gl ed at gm b gn im gp in gr io gt ip gv iq gx dv">It might be —or it might be not. All of the criticism of Final Tagless from John’s talk is of course valid, however it applies only to using Final Tagless for effect tracking — not constraining effect wrappers!</p><p id="6560" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Is ZIO Environment the answer? It might be — if you need to track effects in your application! Or, it might as well be the case that just knowing <strong class="gm hz">if</strong> a function has side effects or not is sufficient; that is, using “plain old” <code class="ht ir is it iu b">IO[_]</code> (or an abstract <code class="ht ir is it iu b">F[_]</code>).</p><p id="2638" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">We all know what are the shortcomings of Final Tagless, thanks to John’s excellent talk. But we still have to wait for field reports of using ZIO Environment in real projects. Some of the potential shortcomings have already been pointed out by <a href="https://twitter.com/Odomontois/status/1100622968416288768" class="da by gy gz ha hb" target="_blank" rel="noopener">Oleg Nizhnik</a>, so I will refer you to this twitter thread instead of repeating them here.</p><figure class="hd he hf hg hh hi"><p id="fad4" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">What I would add, is that the necessity to use the cake pattern (let’s call it what it is :) ) is quite an intrusive change and might require adapting your codebase. It’s not as simple as just using a “plain old” class with methods.</p><h1 id="ffae" class="ia ib ed at as ic ef id eh ie if ig ih ii ij ik il"><strong class="bf">Do you have to be a functional programming expert to understand all this?</strong></h1><p id="2550" class="gk gl ed at gm b gn im gp in gr io gt ip gv iq gx dv">No. As John says in his talk, you don’t need to understand what a trifunctor is, why <code class="ht ir is it iu b">ZIO[R, E, A]</code> forms a profunctor on its <code class="ht ir is it iu b">R</code>/<code class="ht ir is it iu b">E</code> and <code class="ht ir is it iu b">R</code>/<code class="ht ir is it iu b">A</code> type parameter pairs, or what a profunctor even is to use ZIO. I would argue that the same is true for Final Tagless: to use it as a way to constrain effect wrappers, you don’t need to have a thorough understanding of type classes, higher kinded types or the Monad typeclass hierarchy.</p><p id="a196" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">It’s sufficient to understand why coding to an interface, instead of an implementation is preferable. And being open to alternative ways of expressing dependencies (in this case: not as a parameter, but as an implicit type constraint).</p><p id="2903" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">It’s a very interesting quest to find out how these concept generalise; what a typeclass is; how pervasive monads are; how applicatives differ from monads; how free is equivalent to tagless final; what’s a profunctor; etc. But that’s not necessary to start using them.</p><h1 id="a45f" class="ia ib ed at as ic ef id eh ie if ig ih ii ij ik il"><strong class="bf">Fashion?</strong></h1><p id="7627" class="gk gl ed at gm b gn im gp in gr io gt ip gv iq gx dv">Final Tagless is definitely a victim of hype and fashion. It shouldn’t be used for everything, as that’s how we end up with monstrosities such as we’ve seen in John’s talk:</p><pre class="hd he hf hg hh iv iw cl"><span id="734d" class="ix ib ed at iu b fg iy iz r ja">def genFeed[F[_]: Monad:<br>Logging: UserDatabase:<br>ProfileDatabase: RedisCache:<br>GeoIPService: AuthService:<br>SessionManager: Localization:<br>Config: EventQueue: Concurrent:<br>Async: MetricsManager]: F[Feed] = ???</span></pre><p id="b1d5" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">A couple of years ago Free Monads were the fashionable thing to use in the functional programming community. Using them as the main way to structure programs turned out to be cumbersome, the amount of boilerplate needed greatly exceeded benefits they bring.</p><p id="b7c9" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">However, Free Monads have found their niche. They turn out to be a very good choice for representing general-purpose abstractions. For example, when describing database operations (<code class="ht ir is it iu b">ConnectionIO</code> from <a href="https://tpolecat.github.io/doobie/" class="da by gy gz ha hb" target="_blank" rel="noopener">Doobie</a> or <code class="ht ir is it iu b">DBIOAction</code> from <a href="http://slick.lightbend.com" class="da by gy gz ha hb" target="_blank" rel="noopener">Slick</a>), or when describing concurrent programs (<code class="ht ir is it iu b">IO</code> in ZIO, <code class="ht ir is it iu b">Task</code> in Monix, <code class="ht ir is it iu b">Behavior</code> in Akka-Typed). For these kinds of abstractions, it’s just much more convenient to work with a value-based representation.</p><blockquote class="jo jp jq"><p id="4002" class="gk gl ed jr gm b gn go gp gq gr gs gt gu gv gw gx dv">Yes, <code class="ht ir is it iu b">IO</code>/<code class="ht ir is it iu b">Task</code> itself is another realisation of the “code to an interface” idea. When describing computation using IO, you create a description of the computation (as a value), using IO’s primitives. Only later that is being interpreted, that is, the IO primitives are given specific meaning. In theory, you can have multiple IO interpretations, which correspond to multiple interface implementations.</p></blockquote><p id="f8d5" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">The niche for Final Tagless is constraining effect wrappers. But not — as John’s talk shows quite well — tracking effects in detail in an application.</p><p id="4593" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">I’m quite sure a niche will emerge for ZIO Environment. Such as situations were you need <strong class="gm hz">detailed effect tracking</strong>.</p><h1 id="476b" class="ia ib ed at as ic ef id eh ie if ig ih ii ij ik il"><strong class="bf">Wrapping up</strong></h1><p id="4fb0" class="gk gl ed at gm b gn im gp in gr io gt ip gv iq gx dv">All tools have their proper use. Neither Final Tagless, Free Monads, constructor-based dependency injection nor ZIO Environment should be used for everything.</p><p id="3335" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">There’s many ways in which you can realise the “code to an interface” idea in Scala. In each of them, you have a basic “set of instructions” which you use to build your application logic. These instructions can take various forms:</p><ul class=""><li id="ed0f" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx jg jh ji">calling methods on dependencies passed as parameters (constructor based dependency injection)</li><li id="2a84" class="gk gl ed at gm b gn jj gp jk gr jl gt jm gv jn gx jg jh ji">final tagless: dependencies are passed as implicit capabilities</li><li id="afe8" class="gk gl ed at gm b gn jj gp jk gr jl gt jm gv jn gx jg jh ji">free monads: instructions are represented as values</li><li id="69ed" class="gk gl ed at gm b gn jj gp jk gr jl gt jm gv jn gx jg jh ji">reader monad: a convenient way of passing a single dependency</li></ul><p id="2e17" class="gk gl ed at gm b gn go gp gq gr gs gt gu gv gw gx dv">Summing up, what ZIO Environment is: an interesting combination of an optimized reader monad with the cake pattern. What Final Tagless isn’t: dead.</p></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>