<!DOCTYPE html>
<html lang="en">
<head>
    <title>
We made Windows Server Core container images &gt;40% smaller | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="We made Windows Server Core container images &gt;40% smaller | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard"/>
    <meta property="og:description" content="Over the past year, we&#x2019;ve been working with the Windows Server team to make Windows Server Core container images a lot smaller. They are now 40% smaller! The Windows Server team has already published the new images in the Server Core Insider Docker repo,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/we-made-windows-server-core-container-images-40-smaller/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - We made Windows Server Core container images &gt;40% smaller | .NET Blog</title>
<div class="readable">
        <h1>We made Windows Server Core container images &gt;40% smaller | .NET Blog</h1>
            <div>by Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard</div>
            <div>Reading time: 17-21 minutes</div>
        <div>Posted here: 10 Dec 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/we-made-windows-server-core-container-images-40-smaller/">https://devblogs.microsoft.com/dotnet/we-made-windows-server-core-container-images-40-smaller/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/37f91ebe219df737566a4dc7cdd53b68?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Richard</p></div></div></div><p>December 9th, 2019</p><p>Over the past year, we’ve been working with the Windows Server team to make <a href="https://hub.docker.com/_/microsoft-windows-servercore" target="_blank">Windows Server Core container images</a> a lot smaller. They are now &gt;40% smaller! The Windows Server team has already published the new images in the <a href="https://hub.docker.com/_/microsoft-windows-servercore-insider" target="_blank">Server Core Insider Docker repo</a>, and will eventually publish them to their <a href="https://hub.docker.com/_/microsoft-windows-servercore" target="_blank">stable repo</a> with their 20H1 release. You can check them out for yourself. I’ll tell you how we did it and what you need to know to take advantage of the improvements.</p><p>Let’s start with the numbers:</p><ul><li>Insider images are &gt;40% smaller than the latest (patched) 1903 images.</li><li>Container startup into Windows PowerShell is 30-45% faster.</li></ul><p>These measurements are based on images in the <a href="https://hub.docker.com/_/microsoft-windows-servercore-insider" target="_blank">Windows Server Core insiders Docker repo</a>. We used PowerShell as a proxy for any .NET Framework application, but also because we expect that PowerShell is used a lot in containers.</p><p>The improvements should apply to any scenario where you use Windows Server Core containers images. It should be most beneficial and noticeable for scaling applications in production, CI/CD and any other workflow that pulls images without the benefit of a Docker image cache or that has a need for faster startup.</p><p>The PowerShell and Windows Server Teams also posted on this topic. Check out their posts.</p><ul><li><a href="https://devblogs.microsoft.com/powershell/improvements-in-windows-powershell-container-images/">Improvements in Windows PowerShell Container Images</a></li><li><a href="https://techcommunity.microsoft.com/t5/Containers/Making-Windows-Server-Core-Containers-40-Smaller/ba-p/1058874" target="_blank">Making Windows Server Core Containers 40% Smaller</a></li></ul><h2>A case of playing poorly with container layers</h2><p>We started this project with the hypothesis that the way .NET Framework is packaged and installed does not play nicely with the way <a href="https://docs.docker.com/storage/storagedriver/" target="_blank">Docker layers</a> work. We found that this was the case based on an investigation we did over a year ago.</p><p>As background, Docker creates a read-only layer for each command in a Dockerfile, like <code>FROM</code>, <code>RUN</code> and even <code>ENV</code>. If files are updated in multiple layers, you will end up carrying multiple copies of that file in the image even though there is only one copy in the final image layer (the one you see and use). We found that this situation was common with .NET Framework container images. This is similar to the way Git works with binaries, if you are familiar with that model. If this makes you cringe, then you are following along perfectly well.</p><p><a href="https://github.com/microsoft/dotnet-framework-docker" target="_blank">.NET Framework Dockerfiles are open source</a>, so I will use them as examples in the rest of the post. They are also a good source of Docker-related techniques if you want to customize your own Dockerfiles further.</p><p>The <a href="https://github.com/microsoft/dotnet-framework-docker/blob/master/4.8/runtime/windowsservercore-ltsc2019/Dockerfile" target="_blank">Dockerfile for .NET Framework 4.8 on Windows Server Core 2019</a> demonstrates the anti-pattern we’re wanting to fix, of updating files multiple times in different layers, as follows:</p><pre><code><span># escape=`</span><span>

FROM mcr</span><span>.</span><span>microsoft</span><span>.</span><span>com</span><span>/</span><span>windows</span><span>/</span><span>servercore</span><span>:</span><span>ltsc2019

</span><span># Install .NET 4.8</span><span>
RUN curl </span><span>-</span><span>fSLo dotnet</span><span>-</span><span>framework</span><span>-</span><span>installer</span><span>.</span><span>exe https</span><span>:</span><span>//download.visualstudio.microsoft.com/download/pr/7afca223-55d2-470a-8edc-6a1739ae3252/abd170b4b0ec15ad0222a809b761a036/ndp48-x86-x64-allos-enu.exe `</span><span>
    </span><span>&amp;&amp;</span><span> </span><span>.</span><span>\dotnet</span><span>-</span><span>framework</span><span>-</span><span>installer</span><span>.</span><span>exe </span><span>/</span><span>q </span><span>`
    &amp;&amp; del .\dotnet-framework-installer.exe `</span><span>
    </span><span>&amp;&amp;</span><span> powershell </span><span>Remove</span><span>-</span><span>Item</span><span> </span><span>-</span><span>Force</span><span> </span><span>-</span><span>Recurse</span><span> $</span><span>{</span><span>Env</span><span>:</span><span>TEMP</span><span>}</span><span>\*

</span><span># Apply latest patch</span><span>
RUN curl </span><span>-</span><span>fSLo patch</span><span>.</span><span>msu http</span><span>:</span><span>//download.windowsupdate.com/c/msdownload/update/software/updt/2019/09/windows10.0-kb4515843-x64_181da0224818b03254ff48178c3cd7f73501c9db.msu `</span><span>
    </span><span>&amp;&amp;</span><span> mkdir patch </span><span>`
    &amp;&amp; expand patch.msu patch -F:* `</span><span>
    </span><span>&amp;&amp;</span><span> </span><span>del</span><span> </span><span>/</span><span>F </span><span>/</span><span>Q patch</span><span>.</span><span>msu </span><span>`
    &amp;&amp; DISM /Online /Quiet /Add-Package /PackagePath:C:\patch\Windows10.0-kb4515843-x64.cab `</span><span>
    </span><span>&amp;&amp;</span><span> rmdir </span><span>/</span><span>S </span><span>/</span><span>Q patch

</span><span># ngen .NET Fx</span><span>
ENV COMPLUS_NGenProtectedProcess_FeatureEnabled </span><span>0</span><span>
RUN \Windows\Microsoft</span><span>.</span><span>NET\Framework64\v</span><span>4.0</span><span>.</span><span>30319</span><span>\ngen uninstall </span><span>"Microsoft.Tpm.Commands, Version=10.0.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=amd64"</span><span> </span><span>`
    &amp;&amp; \Windows\Microsoft.NET\Framework64\v4.0.30319\ngen update `</span><span>
    </span><span>&amp;&amp;</span><span> \Windows\Microsoft</span><span>.</span><span>NET\Framework\v</span><span>4.0</span><span>.</span><span>30319</span><span>\ngen update</span></code></pre><p>Lets’s dive into what the Dockerfile is actually doing. The first <code>FROM</code> line pulls Windows Server Core 2019, which includes .NET Framework 4.7.2. The following <code>RUN</code> line then installs .NET Framework 4.8 on top. The middle <code>RUN</code> line services .NET Framework 4.8 with the latest patches. The last <code>RUN</code> line runs the <code>ngen</code> tool to create or update NGEN images, if needed. Many files are being updated multiple times with this series of commands. Each time a file is updated, the size of the image increases by the size of the new “duplicate” file.</p><p>In the worst case scenario, four copies of many files are created, and that doesn’t account for the fact that each file has IL and NGEN variants, for x86 and x64. The size explosion starts to become apparent and is hard to fully grasp without a full accounting in a spreadsheet.</p><p>Stepping back, not all file updates are equal. For example, you can (in theory) update a 1 KB text file 500 times before it will have the same impact of updating a 500 KB file once. We found that NGEN image files were the worst offender. NGEN images are generated by <code>ngen.exe</code> (which you see used in the Dockerfile) to improve startup performance. They are also big, typically 3x larger than their associated IL files. It quickly became clear that NGEN images were going to be a primary target for a solution.</p><h2>Designing a container-friendly approach</h2><p>Architecturally, we had three design characteristics that we wanted in a solution:</p><ul><li>There should be a single copy of each file in the .NET Framework, across all container image layers published by Microsoft.</li><li>NGEN images that are created by default should align with default use cases.</li><li>Maintain startup performance as container image size is reduced.</li></ul><p>The biggest risk was the last characteristic, about maintaining startup performance, given that our primary startup performance lever — NGEN — was the primary target for reducing container image size. You already know how the story ends from the introduction, but let’s keep digging, and look at what we did in preparation for Windows Server Core 20H1 images (what is in Insiders now).</p><p>Here’s what we did in the Windows Server Core base image layer:</p><ul><li>Include a serviced copy of .NET Framework 4.8.</li><li>Remove all NGEN images, except for the three most critical ones, for both x86 and x64. These images are for mscorlib.dll, System.dll and System.Core.dll.</li></ul><p>Here’s what we did in the .NET Framework runtime image layer:</p><ul><li>NGEN assemblies used by Windows PowerShell and ASP.NET (and no more).</li><li>NGEN only 64-bit assemblies. The only 32-bit NGEN images are the three included in the Server Core base image.</li></ul><p>You can see these changes in the <a href="https://github.com/microsoft/dotnet-framework-docker/blob/windowserver-2004/4.8/runtime/windowsservercore-2004/Dockerfile" target="_blank">Dockerfile for .NET Framework 4.8 on the Windows Server Core Insider image</a>, as follows:</p><pre><code><span># escape=`</span><span>

FROM mcr</span><span>.</span><span>microsoft</span><span>.</span><span>com</span><span>/</span><span>windows</span><span>/</span><span>servercore</span><span>/</span><span>insider</span><span>:</span><span>10.0</span><span>.</span><span>19023.1</span><span>

</span><span># Enable detection of running in a container</span><span>
ENV DOTNET_RUNNING_IN_CONTAINER</span><span>=</span><span>true</span><span>

RUN </span><span>`
    # Ngen top of assembly graph to optimize a set of frequently used assemblies
    \Windows\Microsoft.NET\Framework64\v4.0.30319\ngen install "Microsoft.PowerShell.Utility.Activities, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"
    # To optimize 32-bit assemblies, uncomment the next line and add an escape character (`</span><span>)</span><span> to the </span><span>end</span><span> of the previous line
    </span><span># &amp;&amp; \Windows\Microsoft.NET\Framework\v4.0.30319\ngen install "Microsoft.PowerShell.Utility.Activities, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35"</span></code></pre><p>This Dockerfile is much simpler, but we’ll still take a deeper look. The <code>FROM</code> statement pulls the Windows Server Core Insider base image layer, which already contains the (serviced) version of the .NET Framework we want. This is why there are no subsequent <code>RUN</code> statements that download and install later or serviced .NET Framework versions. The single <code>RUN</code> statement uses <code>ngen</code> to pre-compile a curated set of assemblies that we expect will benefit most .NET applications, but only for the 64-bit version of .NET Framework.</p><p>This much more streamlined approach has the following key benefits:</p><ul><li>The Windows Server Core base image is now a lot smaller, and will be a massive benefit for Windows applications that don’t use .NET Framework. They still contain the .NET Framework but only a much smaller set of the NGEN images as compared to the 1903 base image.</li><li>The .NET Framework container image is also significantly smaller because it is now constructed in a way that much better aligns with the way Docker layers and images work and it contains a much smaller and curated set of NGEN images.</li></ul><p>In terms of guidance, this new approach means that you should strongly prefer the .NET Framework runtime (or SDK) image if you are using Windows PowerShell or containerizing a .NET Framework application. It also means that it makes more sense to customize NGEN in your own Dockerfiles since the images Microsoft produces have much fewer NGEN images to start with.</p><p>Looking back at the new .NET Framework runtime Dockerfile, you can see that the last line is commented, which would otherwise NGEN assemblies for the 32-bit .NET Framework. You should consider uncommenting this line if you run 32-bit .NET Framework applications. You would need to either copy this line to your application Dockerfile (typically as the first line after the FROM statement) or use this Dockerfile as an alternative to using the .NET Framework runtime image.</p><p>If you use your own version of this Dockerfile, then you can customize it further. For example, you could target a smaller or different set of assemblies that are specifically chosen for only your application.</p><h2>Performance of the new approach</h2><p>I’m finally going to share the performance numbers! I’ll explain a few more things first, to make sure you’ve got the right context.</p><p>Like I said earlier, our primary goal wasn’t to improve the startup time of PowerShell or ASP.NET, but maintain it as we reduced the size of container images. Turns out that we did better than that, but let me ignore our achievements for a moment to make a point. If you are not familar with containers, it may not be obvious how valuable achieving that goal really is. I’ll explain it.</p><p>For many scenarios, image size ends up being a dominant startup cost because images need to be pulled across a network as part of <code>docker run</code>. This is the case for scenarios where the container environment doesn’t maintain an image cache (more common than you might think).</p><p>If the value here still isn’t popping, I’ll try an anology (I really love analogies). Imagine you and I are racing two cars on a track. I’m racing a white one with a red maple leaf … OK, OK, the color doesn’t matter! The gun goes off and fans are expecting us to start tearing down the track. Instead of hitting the gas pedals, we jump out of the cars and first fill up our gas tanks, then jump back in and finally start moving forward to do the job we were paid to do (race the cars!). That’s basically what <code>docker run</code> has to do if you don’t have a local copy of an image.</p><p>With this improvement in place, we still have to jump out of the cars when the gun goes up, but your car tank is now half the size it was before, so filling it is much quicker, HOWEVER the car still goes the same speed and distance. Unfortunately for me, you win the race because I’m stuck with the older version of the car! Unlucky me.</p><p>I’m going to stretch this analogy a little further. I said that your tank fills up in half the time now, but still goes the same speed and distance. It turns out that we managed to make the car go faster, too, and it can still go just as far. Sounds awesome! That’s basically the same thing we achieved.</p><p>OK, back to reality … let’s look at the actual results we saw, as measured in our performance lab. Performance scenarios are on the left and the different container images in which we measured them are on top.</p><table><thead><tr><th></th><th> 1903</th><th> 1903-FX</th><th> Insider</th><th> Insider-FX</th></tr></thead><tbody><tr><td> Size compressed (GB)</td><td> 2.11</td><td> 2.18</td><td> 1.13</td><td> 1.19</td></tr><tr><td> Size uncompressed (GB)</td><td> 5.03</td><td> 5.29</td><td> 2.63</td><td> 2.89</td></tr><tr><td> Container launch (s)</td><td> 6.7</td><td> 6.67</td><td> 4.68</td><td> 3.61</td></tr><tr><td> PowerShell launch (s)</td><td> 0.64</td><td> 0.13</td><td> 0.73</td><td> 0.15</td></tr></tbody></table><p>Note: The 1903 image is the latest version of 1903, with nearly as year of patches (which increase the size of the image).</p><p>Legend:</p><ul><li><strong>1903:</strong> mcr.microsoft.com/windows/servercore:1903</li><li><strong>1903-FX:</strong> mcr.microsoft.com/dotnet/framework/runtime:4.8-20191008-windowsservercore-1903</li><li><strong>Insider:</strong> mcr.microsoft.com/windows/servercore/insider:10.0.19023.1</li><li><strong>Insider-FX:</strong> image built from <a href="https://github.com/microsoft/dotnet-framework-docker/blob/windowserver-2004/4.8/runtime/windowsservercore-2004/Dockerfile" target="_blank">runtime Dockerfile</a></li><li><strong>Size compressed (GB)</strong> — this is the size of an image, in gigabytes, within a registry and when you pull it (AKA “over the wire”).</li><li><strong>Size uncompressed (GB)</strong> — this is the size of an image, in gigabytes, on disk after you pull it. It is uncompressed so that it is fast to run.</li><li><strong>Container launch (s)</strong> — This is the time it takes, in seconds, to launch a container, into PowerShell. It is equivalent to: <code>docker run --rm  DOCKERIMAGE powershell exit</code>.</li><li><strong>PowerShell launch (s)</strong> — This the time it takes, in seconds, to launch PowerShell within a running container. It is equivalent to: <code>powershell exit</code>.</li></ul><p>I’ll give you the value-oriented summary of what those numbers are actually telling us.</p><p>For the <strong>Windows Server Core Insider base image</strong>:</p><ul><li>The compressed Insider image is 46% smaller than the 1903 base image.</li><li>The uncompressed Insider image is 47% smaller than the 1903 base image.</li><li>Container startup into Windows PowerShell is 30% faster, when using the Insider image compared to the 1903 base image.</li><li>Windows PowerShell startup within a running container is slower with the Insider image than the 1903 base image, by 100ms (15%) on our hardware.</li></ul><p>For the <strong>.NET Framework runtime image</strong>, based on the new Windows Server Core Insider base image:</p><ul><li>The compressed .NET Framework runtime image is 45% smaller than the 1903 runtime image.</li><li>The uncompressed .NET Framework runtime image is 45% smaller than the 1903 runtime image.</li><li>Container startup into Windows PowerShell is 45% faster, using the .NET Framework runtime image compared to the 1903 runtime image.</li><li>Windows PowerShell startup within a running container is slower with the Insider-based runtime image than the 1903 runtime image, by 20ms (15%) on our hardware. We are investigating why startup is slower in this scenario. It shouldn’t be.</li><li>We specifically measured the benefit of not including 32-bit images in the runtime image. It is 70MB in the compressed image and 300 MB in the uncompressed image.</li></ul><p>Note: The drop in size is probably closer to 40% in actuality. We are comparing an Insider image to a serviced 1903 image (nearly a year of patches that cause size increases). Still, the measurements are in the right ball park and a big win. Also, we expect these numbers to change before the Windows Server 20H1 release, either a little better or a little worse, but not far off what I’ve described here.</p><p>If you are interested in the details or reproducing these numbers yourself, the following list details the measurements we made and some of our methodology.</p><ul><li>Size compressed: <a href="https://gist.github.com/MichaelSimons/fb588539dcefd9b5fdf45ba04c302db6" target="_blank">Retrieving Docker Image Sizes </a></li><li>Size uncompressed: <code>docker images</code></li><li>Container launch (run from the host, in PowerShell): <code>powershell<br> $a = @(); 1..5 | % { $a += (measure-command { docker run --rm  DOCKERIMAGE powershell exit }).TotalSeconds }; $a</code></li><li>PowerShell launch (run from inside the container, in PowerShell): <code>powershell<br> $a = @(); 1..5 | % { $a += (measure-command { powershell exit } ).TotalSeconds } ; $a</code></li></ul><p>Note: All launch measurements listed are the average of the middle 3 of 5 test runs.</p><p>PowerShell launch is run from within PowerShell. This approach could be viewed as a weak test methodology. Instead, it is a practical pattern for what we are measuring, which is the reduction of JIT time. The second PowerShell instance will be in a second process. There is some benefit from launching PowerShell from PowerShell because read-only pages will be shared across processes. JITed code is written to read-write pages, which are not shared across process boundaries, such that the actual code execution of PowerShell will be unique in both processes and sensitive to the need to JIT at startup. As a result, the difference in startup numbers is primarily due to the reduction in JIT compilation required during startup. That also explains why we are only measuring <code>powershell exit</code> (we are only targeting startup for the scenario). Feel free to measure this and other scenarios and give us your feedback. We’d appreciate that.</p><p>We haven’t yet started measuring the performance improvement to the <a href="https://hub.docker.com/_/microsoft-dotnet-framework-sdk/" target="_blank">.NET Framework SDK image</a>. We expect to see size and container startup improvements for that image, too. You can see an early version of the <a href="https://github.com/microsoft/dotnet-framework-docker/blob/windowserver-2004/4.8/sdk/windowsservercore-2004/Dockerfile" target="_blank">.NET Framework SDK image Dockerfile</a> that you can see and test.</p><h2>Forward-looking Guidance</h2><p>Starting with the next version of Windows Server, we have the following guidance for Windows container users:</p><ul><li>If you are using .NET Framework applications with Windows containers, including Windows PowerShell, use a <a href="https://hub.docker.com/_/microsoft-dotnet-framework" target="_blank">.NET Framework image</a>.</li><li>If you are not using .NET, use the <a href="https://hub.docker.com/_/microsoft-windows-servercore" target="_blank">Windows Server Core base image</a>, or another image derived from it.</li><li>If you need better startup performance than the .NET Framework runtime image has to offer, we recommend creating your own images with your own profile of NGEN images. This is considered a supported scenario, and doesn’t disqualify you from getting support from Microsoft.</li></ul><h2>Closing</h2><p>A lot of our effort on Docker containers has been <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/">focused on .NET Core</a>, however, we have been looking for opportunities to improve the experience for .NET Framework users as well. This post describes such an improvement. Please tell us about other pain points for using .NET Framework in containers. We’d be interested in talking with you if you are using .NET Framework containers in production to learn more about what is working well and what isn’t.</p><p>Please give us feedback as you start adopting the new Windows Server Core container images. We intend to produce .NET Framework images for the next version of Windows Server Core as soon as 20H1 images are available in the <a href="https://hub.docker.com/_/microsoft-windows-servercore" target="_blank">Windows Docker repo</a>.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>