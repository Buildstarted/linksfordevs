<!DOCTYPE html>
<html lang="en">
<head>
    <title>
apple/llvm-project - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="apple/llvm-project - linksfor.dev(s)"/>
    <meta property="og:description" content="Contribute to apple/llvm-project development by creating an account on GitHub."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/apple/llvm-project/blob/apple/master/clang/docs/PointerAuthentication.rst"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - apple/llvm-project</title>
<div class="readable">
        <h1>apple/llvm-project</h1>
            <div>Reading time: 63-80 minutes</div>
        <div>Posted here: 16 Dec 2019</div>
        <p><a href="https://github.com/apple/llvm-project/blob/apple/master/clang/docs/PointerAuthentication.rst">https://github.com/apple/llvm-project/blob/apple/master/clang/docs/PointerAuthentication.rst</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    <article itemprop="text">

<a name="user-content-introduction"></a>
<h2><a href="#id27">Introduction</a></h2>
<p>Pointer authentication is a technology which offers strong probabilistic protection against exploiting a broad class of memory bugs to take control of program execution.  When adopted consistently in a language ABI, it provides a form of relatively fine-grained control flow integrity (CFI) check that resists both return-oriented programming (ROP) and jump-oriented programming (JOP) attacks.</p>
<p>While pointer authentication can be implemented purely in software, direct hardware support (e.g. as provided by ARMv8.3) can dramatically lower the execution speed and code size costs.  Similarly, while pointer authentication can be implemented on any architecture, taking advantage of the (typically) excess addressing range of a target with 64-bit pointers minimizes the impact on memory performance and can allow interoperation with existing code (by disabling pointer authentication dynamically).  This document will generally attempt to present the pointer authentication feature independent of any hardware implementation or ABI.  Considerations that are implementation-specific are clearly identified throughout.</p>
<p>Note that there are several different terms in use:</p>
<ul>
<li><strong>Pointer authentication</strong> is a target-independent language technology.</li>
<li><strong>ARMv8.3</strong> is an AArch64 architecture revision of that provides hardware support for pointer authentication.  It is implemented on several shipping processors, including the Apple A12 and later.</li>
</ul>
<ul>
<li><strong>arm64e</strong> is a specific ABI for (not yet fully stable) for implementing pointer authentication on ARMv8.3 on certain Apple operating systems.</li>
</ul>
<p>This document serves four purposes:</p>
<ul>
<li>It describes the basic ideas of pointer authentication.</li>
<li>It documents several language extensions that are useful on targets using pointer authentication.</li>
<li>It presents a theory of operation for the security mitigation, describing the basic requirements for correctness, various weaknesses in the mechanism, and ways in which programmers can strengthen its protections (including recommendations for language implementors).</li>
<li>It documents the language ABIs currently used for C, C++, Objective-C, and Swift on arm64e, although these are not yet stable on any target.</li>
</ul>
<a name="user-content-basic-concepts"></a>
<h2><a href="#id28">Basic Concepts</a></h2>
<p>The simple address of an object or function is a <strong>raw pointer</strong>.  A raw pointer can be <strong>signed</strong> to produce a <strong>signed pointer</strong>.  A signed pointer can be then <strong>authenticated</strong> in order to verify that it was <strong>validly signed</strong> and extract the original raw pointer.  These terms reflect the most likely implementation technique: computing and storing a cryptographic signature along with the pointer.  The security of pointer authentication does not rely on attackers not being able to separately overwrite the signature.</p>
<p>An <strong>abstract signing key</strong> is a name which refers to a secret key which can used to sign and authenticate pointers.  The key value for a particular name is consistent throughout a process.</p>
<p>A <strong>discriminator</strong> is an arbitrary value used to <strong>diversify</strong> signed pointers so that one validly-signed pointer cannot simply be copied over another.  A discriminator is simply opaque data of some implementation-defined size that is included in the signature as a salt.</p>
<p>Nearly all aspects of pointer authentication use just these two primary operations:</p>
<ul>
<li><code>sign(raw_pointer, key, discriminator)</code> produces a signed pointer given a raw pointer, an abstract signing key, and a discriminator.</li>
<li><code>auth(signed_pointer, key, discriminator)</code> produces a raw pointer given a signed pointer, an abstract signing key, and a discriminator.</li>
</ul>
<p><code>auth(sign(raw_pointer, key, discriminator), key, discriminator)</code> must succeed and produce <code>raw_pointer</code>.  <code>auth</code> applied to a value that was ultimately produced in any other way is expected to immediately halt the program.  However, it is permitted for <code>auth</code> to fail to detect that a signed pointer was not produced in this way, in which case it may return anything; this is what makes pointer authentication a probabilistic mitigation rather than a perfect one.</p>
<p>There are two secondary operations which are required only to implement certain intrinsics in <code>&lt;ptrauth.h&gt;</code>:</p>
<ul>
<li><code>strip(signed_pointer, key)</code> produces a raw pointer given a signed pointer and a key it was presumptively signed with.  This is useful for certain kinds of tooling, such as crash backtraces; it should generally not be used in the basic language ABI except in very careful ways.</li>
<li><code>sign_generic(value)</code> produces a cryptographic signature for arbitrary data, not necessarily a pointer.  This is useful for efficiently verifying that non-pointer data has not been tampered with.</li>
</ul>
<p>Whenever any of these operations is called for, the key value must be known statically.  This is because the layout of a signed pointer may vary according to the signing key.  (For example, in ARMv8.3, the layout of a signed pointer depends on whether TBI is enabled, which can be set independently for code and data pointers.)</p>
<div>
<p>Note for API designers and language implementors</p>
<p>These are the <em>primitive</em> operations of pointer authentication, provided for clarity of description.  They are not suitable either as high-level interfaces or as primitives in a compiler IR because they expose raw pointers.  Raw pointers require special attention in the language implementation to avoid the accidental creation of exploitable code sequences; see the section on <a href="#attackable-code-sequences">Attackable code sequences</a>.</p>
</div>
<p>The following details are all implementation-defined:</p>
<ul>
<li>the nature of a signed pointer</li>
<li>the size of a discriminator</li>
<li>the number and nature of the signing keys</li>
<li>the implementation of the <code>sign</code>, <code>auth</code>, <code>strip</code>, and <code>sign_generic</code> operations</li>
</ul>
<p>While the use of the terms "sign" and "signed pointer" suggest the use of a cryptographic signature, other implementations may be possible.  See <a href="#alternative-implementations">Alternative implementations</a> for an exploration of implementation options.</p>
<div>
<p>Implementation example: ARMv8.3</p>
<p>Readers may find it helpful to know how these terms map to ARMv8.3:</p>
<ul>
<li>A signed pointer is a pointer with a signature stored in the otherwise-unused high bits.  The kernel configures the signature width based on the system's addressing needs, accounting for whether the AArch64 TBI feature is enabled for the kind of pointer (code or data).</li>
<li>A discriminator is a 64-bit integer.  Constant discriminators are 16-bit integers.  Blending a constant discriminator into an address consists of replacing the top 16 bits of the address with the constant.</li>
<li>There are five 128-bit signing-key registers, each of which can only be directly read or set by privileged code.  Of these, four are used for signing pointers, and the fifth is used only for <code>sign_generic</code>.  The key data is simply a pepper added to the hash, not an encryption key, and so can be initialized using random data.</li>
<li><code>sign</code> computes a cryptographic hash of the pointer, discriminator, and signing key, and stores it in the high bits as the signature. <code>auth</code> removes the signature, computes the same hash, and compares the result with the stored signature.  <code>strip</code> removes the signature without authenticating it.  While ARMv8.3's <code>aut*</code> instructions do not themselves trap on failure, the compiler only ever emits them in sequences that will trap.</li>
<li><code>sign_generic</code> corresponds to the <code>pacga</code> instruction, which takes two 64-bit values and produces a 64-bit cryptographic hash. Implementations of this instruction may not produce meaningful data in all bits of the result.</li>
</ul>
</div>
<a name="user-content-discriminators"></a>
<h3><a href="#id29">Discriminators</a></h3>
<p>A discriminator is arbitrary extra data which alters the signature on a pointer.  When two pointers are signed differently --- either with different keys or with different discriminators --- an attacker cannot simply replace one pointer with the other.  For more information on why discriminators are important and how to use them effectively, see the section on <a href="#substitution-attacks">Substitution attacks</a>.</p>
<p>To use standard cryptographic terminology, a discriminator acts as a salt in the signing of a pointer, and the key data acts as a pepper.  That is, both the discriminator and key data are ultimately just added as inputs to the signing algorithm along with the pointer, but they serve significantly different roles.  The key data is a common secret added to every signature, whereas the discriminator is a signing-specific value that can be derived from the circumstances of how a pointer is signed.  However, unlike a password salt, it's important that discriminators be <em>independently</em> derived from the circumstances of the signing; they should never simply be stored alongside a pointer.</p>
<p>The intrinsic interface in <code>&lt;ptrauth.h&gt;</code> allows an arbitrary discriminator value to be provided, but can only be used when running normal code.  The discriminators used by language ABIs must be restricted to make it feasible for the loader to sign pointers stored in global memory without needing excessive amounts of metadata.  Under these restrictions, a discriminator may consist of either or both of the following:</p>
<ul>
<li>The address at which the pointer is stored in memory.  A pointer signed with a discriminator which incorporates its storage address is said to have <strong>address diversity</strong>.  In general, using address diversity means that a pointer cannot be reliably replaced by an attacker or used to reliably replace a different pointer.  However, an attacker may still be able to attack a larger call sequence if they can alter the address through which the pointer is accessed.  Furthermore, some situations cannot use address diversity because of language or other restrictions.</li>
<li>A constant integer, called a <strong>constant discriminator</strong>. A pointer signed with a non-zero constant discriminator is said to have <strong>constant diversity</strong>.  If the discriminator is specific to a single declaration, it is said to have <strong>declaration diversity</strong>; if the discriminator is specific to a type of value, it is said to have <strong>type diversity</strong>.  For example, C++ v-tables on arm64e sign their component functions using a hash of their method names and signatures, which provides declaration diversity; similarly, C++ member function pointers sign their invocation functions using a hash of the member pointer type, which provides type diversity.</li>
</ul>
<p>The implementation may need to restrict constant discriminators to be significantly smaller than the full size of a discriminator.  For example, on arm64e, constant discriminators are only 16-bit values.  This is believed to not significantly weaken the mitigation, since collisions remain uncommon.</p>
<p>The algorithm for blending a constant discriminator with a storage address is implementation-defined.</p>
<a name="user-content-id1"></a>
<h3><a href="#id30">Signing schemas</a></h3>
<p>Correct use of pointer authentication requires the signing code and the authenticating code to agree about the <strong>signing schema</strong> for the pointer:</p>
<ul>
<li>the abstract signing key with which the pointer should be signed and</li>
<li>an algorithm for computing the discriminator.</li>
</ul>
<p>As described in the section above on <a href="#discriminators">Discriminators</a>, in most situations, the discriminator is produced by taking a constant discriminator and optionally blending it with the storage address of the pointer.  In these situations, the signing schema breaks down even more simply:</p>
<ul>
<li>the abstract signing key,</li>
<li>a constant discriminator, and</li>
<li>whether to use address diversity.</li>
</ul>
<p>It is important that the signing schema be independently derived at all signing and authentication sites.  Preferably, the schema should be hard-coded everywhere it is needed, but at the very least, it must not be derived by inspecting information stored along with the pointer.  See the section on <a href="#attacks-on-pointer-authentication">Attacks on pointer authentication</a> for more information.</p>
<a name="user-content-language-features"></a>
<h2><a href="#id31">Language Features</a></h2>
<p>There are three levels of the pointer authentication language feature:</p>
<ul>
<li>The language implementation automatically signs and authenticates function pointers (and certain data pointers) across a variety of standard situations, including return addresses, function pointers, and C++ virtual functions. The intent is for all pointers to code in program memory to be signed in some way and for all branches to code in program text to authenticate those signatures.</li>
<li>The language also provides extensions to override the default rules used by the language implementation.  For example, the <code>__ptrauth</code> type qualifier can be used to change how pointers are signed when they are stored in a particular variable or field; this provides much stronger protection than is guaranteed by the default rules for C function and data pointers.</li>
<li>Finally, the language provides the <code>&lt;ptrauth.h&gt;</code> intrinsic interface for manually signing and authenticating pointers in code.  These can be used in circumstances where very specific behavior is required.</li>
</ul>
<a name="user-content-language-implementation"></a>
<h3><a href="#id32">Language implementation</a></h3>
<p>For the most part, pointer authentication is an unobserved detail of the implementation of the programming language.  Any element of the language implementation that would perform an indirect branch to a pointer is implicitly altered so that the pointer is signed when first constructed and authenticated when the branch is performed.  This includes:</p>
<ul>
<li>indirect-call features in the programming language, such as C function pointers, C++ virtual functions, C++ member function pointers, the "blocks" C extension, and so on;</li>
<li>returning from a function, no matter how it is called; and</li>
<li>indirect calls introduced by the implementation, such as branches through the global offset table (GOT) used to implement direct calls to functions defined outside of the current shared object.</li>
</ul>
<p>For more information about this, see the <a href="#language-abi">Language ABI</a> section.</p>
<p>However, some aspects of the implementation are observable by the programmer or otherwise require special notice.</p>
<a name="user-content-c-data-pointers"></a>
<h4><a href="#id33">C data pointers</a></h4>
<p>The current implementation in Clang does not sign pointers to ordinary data by default. For a partial explanation of the reasoning behind this, see the <a href="#theory-of-operation">Theory of Operation</a> section.</p>
<p>A specific data pointer which is more security-sensitive than most can be signed using the <a href="#ptrauth-qualifier">__ptrauth qualifier</a> or using the <code>&lt;ptrauth.h&gt;</code> intrinsics.</p>
<a name="user-content-c-function-pointers"></a>
<h4><a href="#id34">C function pointers</a></h4>
<p>The C standard imposes restrictions on the representation and semantics of function pointer types which make it difficult to achieve satisfactory signature diversity in the default language rules.  See <a href="#attacks-on-pointer-authentication">Attacks on pointer authentication</a> for more information about signature diversity.  Programmers should strongly consider using the <code>__ptrauth</code> qualifier to improve the protections for important function pointers, such as the components of of a hand-rolled "v-table"; see the section on the <a href="#ptrauth-qualifier">__ptrauth qualifier</a> for details.</p>
<p>The value of a pointer to a C function includes a signature, even when the value is cast to a non-function-pointer type like <code>void*</code> or <code>intptr_t</code>. On implementations that use high bits to store the signature, this means that relational comparisons and hashes will vary according to the exact signature value, which is likely to change between executions of a program.  In some implementations, it may also vary based on the exact function pointer type.</p>
<a name="user-content-null-pointers"></a>
<h4><a href="#id35">Null pointers</a></h4>
<p>In principle, an implementation could derive the signed null pointer value simply by applying the standard signing algorithm to the raw null pointer value. However, for likely signing algorithms, this would mean that the signed null pointer value would no longer be statically known, which would have many negative consequences.  For one, it would become substantially more expensive to emit null pointer values or to perform null-pointer checks.  For another, the pervasive (even if technically unportable) assumption that null pointers are bitwise zero would be invalidated, making it substantially more difficult to adopt pointer authentication, as well as weakening common optimizations for zero-initialized memory such as the use of <code>.bzz</code> sections.  Therefore it is beneficial to treat null pointers specially by giving them their usual representation.  On AArch64, this requires additional code when working with possibly-null pointers, such as when copying a pointer field that has been signed with address diversity.</p>
<a name="user-content-return-addresses-and-frame-pointers"></a>
<h4><a href="#id36">Return addresses and frame pointers</a></h4>
<p>The current implementation in Clang implicitly signs both return addresses and frame pointers.  While these values are technically implementation details of a function, there are some important libraries and development tools which rely on manually walking the chain of stack frames.  These tools must be updated to correctly account for pointer authentication, either by stripping signatures (if security is not important for the tool, e.g. if it is capturing a stack trace during a crash) or properly authenticating them.  More information about how these values are signed is available in the <a href="#language-abi">Language ABI</a> section.</p>
<a name="user-content-c-virtual-functions"></a>
<h4><a href="#id37">C++ virtual functions</a></h4>
<p>The current implementation in Clang signs virtual function pointers with a discriminator derived from the full signature of the overridden method, including the method name and parameter types.  It is possible to write C++ code that relies on v-table layout remaining constant despite changes to a method signature; for example, a parameter might be a <code>typedef</code> that resolves to a different type based on a build setting.  Such code violates C++'s One Definition Rule (ODR), but that violation is not normally detected; however, pointer authentication will detect it.</p>
<a name="user-content-language-extensions"></a>
<h3><a href="#id38">Language extensions</a></h3>
<a name="user-content-feature-testing"></a>
<h4><a href="#id39">Feature testing</a></h4>
<p>Whether the current target uses pointer authentication can be tested for with a number of different tests.</p>
<ul>
<li><code>__has_feature(ptrauth_intrinsics)</code> is true if <code>&lt;ptrauth.h&gt;</code> provides its normal interface.  This may be true even on targets where pointer authentication is not enabled by default.</li>
<li><code>__has_feature(ptrauth_returns)</code> is true if the target uses pointer authentication to protect return addresses.</li>
<li><code>__has_feature(ptrauth_calls)</code> is true if the target uses pointer authentication to protect indirect branches.  This implies <code>__has_feature(ptrauth_returns)</code> and <code>__has_feature(ptrauth_intrinsics)</code>.</li>
</ul>
<p>Clang provides several other tests only for historical purposes; for current purposes they are all equivalent to <code>ptrauth_calls</code>.</p>
<a name="user-content-ptrauth-qualifier"></a>
<h4><a href="#id40">__ptrauth qualifier</a></h4>
<p><code>__ptrauth(key, address, discriminator)</code> is an extended type qualifier which causes so-qualified objects to hold pointers signed using the specified schema rather than the default schema for such types.</p>
<p>In the current implementation in Clang, the qualified type must be a C pointer type, either to a function or to an object.  It currently cannot be an Objective-C pointer type, a C++ reference type, or a block pointer type; these restrictions may be lifted in the future.</p>
<p>The current implementation in Clang is known to not provide adequate safety guarantees against the creation of <a href="#signing-oracles">signing oracles</a> when assigning data pointers to <code>__ptrauth</code>-qualified gl-values.  See the section on <a href="#safe-derivation">safe derivation</a> for more information.</p>
<p>The qualifier's operands are as follows:</p>
<ul>
<li><code>key</code> - an expression evaluating to a key value from <code>&lt;ptrauth.h&gt;</code>; must be a constant expression</li>
<li><code>address</code> - whether to use address diversity (1) or not (0); must be a constant expression with one of these two values</li>
<li><code>discriminator</code> - a constant discriminator; must be a constant expression</li>
</ul>
<p>See <a href="#discriminators">Discriminators</a> for more information about discriminators.</p>
<p>Currently the operands must be constant-evaluable even within templates. In the future this restriction may be lifted to allow value-dependent expressions as long as they instantiate to a constant expression.</p>
<p>Consistent with the ordinary C/C++ rule for parameters, top-level <code>__ptrauth</code> qualifiers on a parameter (after parameter type adjustment) are ignored when deriving the type of the function.  The parameter will be passed using the default ABI for the unqualified pointer type.</p>
<p>If <code>x</code> is an object of type <code>__ptrauth(key, address, discriminator) T</code>, then the signing schema of the value stored in <code>x</code> is a key of <code>key</code> and a discriminator determined as follows:</p>
<ul>
<li>if <code>address</code> is 0, then the discriminator is <code>discriminator</code>;</li>
<li>if <code>address</code> is 1 and <code>discriminator</code> is 0, then the discriminator is <code>&amp;x</code>; otherwise</li>
<li>if <code>address</code> is 1 and <code>discriminator</code> is non-zero, then the discriminator is <code>ptrauth_blend_discriminator(&amp;x, discriminator)</code>; see <a href="#ptrauth-blend-discriminator">ptrauth_blend_discriminator</a>.</li>
</ul>
<a name="user-content-non-triviality-from-address-diversity"></a>
<h5><a href="#id41">Non-triviality from address diversity</a></h5>
<p>Address diversity must impose additional restrictions in order to allow the implementation to correctly copy values.  In C++, a type qualified with address diversity is treated like a class type with non-trivial copy/move constructors and assignment operators, with the usual effect on containing classes and unions.  C does not have a standard concept of non-triviality, and so we must describe the basic rules here, with the intention of imitating the emergent rules of C++:</p>
<ul>
<li>A type may be <strong>non-trivial to copy</strong>.</li>
<li>A type may also be <strong>illegal to copy</strong>.  Types that are illegal to copy are always non-trivial to copy.</li>
<li>A type may also be <strong>address-sensitive</strong>.</li>
<li>A type qualified with a <code>ptrauth</code> qualifier that requires address diversity is non-trivial to copy and address-sensitive.</li>
<li>An array type is illegal to copy, non-trivial to copy, or address-sensitive if its element type is illegal to copy, non-trivial to copy, or address-sensitive, respectively.</li>
<li>A struct type is illegal to copy, non-trivial to copy, or address-sensitive if it has a field whose type is illegal to copy, non-trivial to copy, or address-sensitive, respectively.</li>
<li>A union type is both illegal and non-trivial to copy if it has a field whose type is non-trivial or illegal to copy.</li>
<li>A union type is address-sensitive if it has a field whose type is address-sensitive.</li>
<li>A program is ill-formed if it uses a type that is illegal to copy as a function parameter, argument, or return type.</li>
<li>A program is ill-formed if an expression requires a type to be copied that is illegal to copy.</li>
<li>Otherwise, copying a type that is non-trivial to copy correctly copies its subobjects.</li>
<li>Types that are address-sensitive must always be passed and returned indirectly. Thus, changing the address-sensitivity of a type may be ABI-breaking even if its size and alignment do not change.</li>
</ul>
<a name="user-content-ptrauth-h"></a>
<h3><a href="#id42"><code>&lt;ptrauth.h&gt;</code></a></h3>
<p>This header defines the following types and operations:</p>
<a name="user-content-ptrauth-key"></a>
<h4><a href="#id43"><code>ptrauth_key</code></a></h4>
<p>This <code>enum</code> is the type of abstract signing keys.  In addition to defining the set of implementation-specific signing keys (for example, ARMv8.3 defines <code>ptrauth_key_asia</code>), it also defines some portable aliases for those keys.  For example, <code>ptrauth_key_function_pointer</code> is the key generally used for C function pointers, which will generally be suitable for other function-signing schemas.</p>
<p>In all the operation descriptions below, key values must be constant values corresponding to one of the implementation-specific abstract signing keys from this <code>enum</code>.</p>
<a name="user-content-ptrauth-extra-data-t"></a>
<h4><a href="#id44"><code>ptrauth_extra_data_t</code></a></h4>
<p>This is a <code>typedef</code> of a standard integer type of the correct size to hold a discriminator value.</p>
<p>In the signing and authentication operation descriptions below, discriminator values must have either pointer type or integer type. If the discriminator is an integer, it will be coerced to <code>ptrauth_extra_data_t</code>.</p>
<a name="user-content-ptrauth-blend-discriminator"></a>
<h4><a href="#id45"><code>ptrauth_blend_discriminator</code></a></h4>
<div><pre><span>ptrauth_blend_discriminator</span>(pointer, integer)</pre></div>
<p>Produce a discriminator value which blends information from the given pointer and the given integer.</p>
<p>Implementations may ignore some bits from each value, which is to say, the blending algorithm may be chosen for speed and convenience over theoretical strength as a hash-combining algorithm.  For example, arm64e simply overwrites the high 16 bits of the pointer with the low 16 bits of the integer, which can be done in a single instruction with an immediate integer.</p>
<p><code>pointer</code> must have pointer type, and <code>integer</code> must have integer type. The result has type <code>ptrauth_extra_data_t</code>.</p>
<a name="user-content-ptrauth-string-discriminator"></a>
<h4><a href="#id46"><code>ptrauth_string_discriminator</code></a></h4>
<div><pre><span>ptrauth_string_discriminator</span>(string)</pre></div>
<p>Produce a discriminator value for the given string.  <code>string</code> must be a string literal of <code>char</code> character type.  The result has type <code>ptrauth_extra_data_t</code>.</p>
<p>The result is always a constant expression.  The result value is never zero and always within range for both the <code>__ptrauth</code> qualifier and <code>ptrauth_blend_discriminator</code>.</p>
<a name="user-content-ptrauth-strip"></a>
<h4><a href="#id47"><code>ptrauth_strip</code></a></h4>
<div><pre><span>ptrauth_strip</span>(signedPointer, key)</pre></div>
<p>Given that <code>signedPointer</code> matches the layout for signed pointers signed with the given key, extract the raw pointer from it.  This operation does not trap and cannot fail, even if the pointer is not validly signed.</p>
<a name="user-content-ptrauth-sign-constant"></a>
<h4><a href="#id48"><code>ptrauth_sign_constant</code></a></h4>
<div><pre><span>ptrauth_sign_constant</span>(pointer, key, discriminator)</pre></div>
<p>Return a signed pointer for a constant address in a manner which guarantees a non-attackable sequence.</p>
<p><code>pointer</code> must be a constant expression of pointer type which evaluates to a non-null pointer.  The result will have the same type as <code>discriminator</code>.</p>
<p>Calls to this are constant expressions if the discriminator is a null-pointer constant expression or an integer constant expression. Implementations may make allow other pointer expressions as well.</p>
<a name="user-content-ptrauth-sign-unauthenticated"></a>
<h4><a href="#id49"><code>ptrauth_sign_unauthenticated</code></a></h4>
<div><pre><span>ptrauth_sign_unauthenticated</span>(pointer, key, discriminator)</pre></div>
<p>Produce a signed pointer for the given raw pointer without applying any authentication or extra treatment.  This operation is not required to have the same behavior on a null pointer that the language implementation would.</p>
<p>This is a treacherous operation that can easily result in <a href="#signing-oracles">signing oracles</a>.  Programs should use it seldom and carefully.</p>
<a name="user-content-ptrauth-auth-and-resign"></a>
<h4><a href="#id50"><code>ptrauth_auth_and_resign</code></a></h4>
<div><pre><span>ptrauth_auth_and_resign</span>(pointer, oldKey, oldDiscriminator, newKey, newDiscriminator)</pre></div>
<p>Authenticate that <code>pointer</code> is signed with <code>oldKey</code> and <code>oldDiscriminator</code> and then resign the raw-pointer result of that authentication with <code>newKey</code> and <code>newDiscriminator</code>.</p>
<p><code>pointer</code> must have pointer type.  The result will have the same type as <code>pointer</code>.  This operation is not required to have the same behavior on a null pointer that the language implementation would.</p>
<p>The code sequence produced for this operation must not be directly attackable.  However, if the discriminator values are not constant integers, their computations may still be attackable.  In the future, Clang should be enhanced to guaranteed non-attackability if these expressions are <a href="#id2"><span id="user-content-id3">:ref:`safely-derived&lt;Safe derivation&gt;`</span></a>.</p>
<a name="user-content-ptrauth-auth-function"></a>
<h4><a href="#id51"><code>ptrauth_auth_function</code></a></h4>
<div><pre><span>ptrauth_auth_function</span>(pointer, key, discriminator)</pre></div>
<p>Authenticate that <code>pointer</code> is signed with <code>key</code> and <code>discriminator</code> and re-sign it to the standard schema for a function pointer of its type.</p>
<p><code>pointer</code> must have function pointer type.  The result will have the same type as <code>pointer</code>.  This operation is not required to have the same behavior on a null pointer that the language implementation would.</p>
<p>This operation makes the same attackability guarantees as <code>ptrauth_auth_and_resign</code>.</p>
<p>If this operation appears syntactically as the function operand of a call, Clang guarantees that the call will directly authenticate the function value using the given schema rather than re-signing to the standard schema.</p>
<a name="user-content-ptrauth-auth-data"></a>
<h4><a href="#id52"><code>ptrauth_auth_data</code></a></h4>
<div><pre><span>ptrauth_auth_data</span>(pointer, key, discriminator)</pre></div>
<p>Authenticate that <code>pointer</code> is signed with <code>key</code> and <code>discriminator</code> and remove the signature.</p>
<p><code>pointer</code> must have object pointer type.  The result will have the same type as <code>pointer</code>.  This operation is not required to have the same behavior on a null pointer that the language implementation would.</p>
<p>In the future when Clang makes <a href="#safe-derivation">safe derivation</a> guarantees, the result of this operation should be considered safely-derived.</p>
<a name="user-content-ptrauth-sign-generic-data"></a>
<h4><a href="#id53"><code>ptrauth_sign_generic_data</code></a></h4>
<div><pre><span>ptrauth_sign_generic_data</span>(value1, value2)</pre></div>
<p>Computes a signature for the given pair of values, incorporating a secret signing key.</p>
<p>This operation can be used to verify that arbitrary data has not be tampered with by computing a signature for the data, storing that signature, and then repeating this process and verifying that it yields the same result.  This can be reasonably done in any number of ways; for example, a library could compute an ordinary checksum of the data and just sign the result in order to get the tamper-resistance advantages of the secret signing key (since otherwise an attacker could reliably overwrite both the data and the checksum).</p>
<p><code>value1</code> and <code>value2</code> must be either pointers or integers.  If the integers are larger than <code>uintptr_t</code> then data not representable in <code>uintptr_t</code> may be discarded.</p>
<p>The result will have type <code>ptrauth_generic_signature_t</code>, which is an integer type.  Implementations are not required to make all bits of the result equally significant; in particular, some implementations are known to not leave meaningful data in the low bits.</p>
<a name="user-content-standard-ptrauth-qualifiers"></a>
<h4><a href="#id54">Standard <code>__ptrauth</code> qualifiers</a></h4>
<p><code>&lt;ptrauth.h&gt;</code> additionally provides several macros which expand to <code>__ptrauth</code> qualifiers for common ABI situations.</p>
<p>For convenience, these macros expand to nothing when pointer authentication is disabled.</p>
<p>These macros can be found in the header; some details of these macros may be unstable or implementation-specific.</p>
<a name="user-content-theory-of-operation"></a>
<h2><a href="#id55">Theory of Operation</a></h2>
<p>The threat model of pointer authentication is as follows:</p>
<ul>
<li>The attacker has the ability to read and write to a certain range of addresses, possibly the entire address space.  However, they are constrained by the normal rules of the process: for example, they cannot write to memory that is mapped read-only, and if they access unmapped memory it will trigger a trap.</li>
<li>The attacker has no ability to add arbitrary executable code to the program.  For example, the program does not include malicious code to begin with, and the attacker cannot alter existing instructions, load a malicious shared library, or remap writable pages as executable.  If the attacker wants to get the process to perform a specific sequence of actions, they must somehow subvert the normal control flow of the process.</li>
</ul>
<p>In both of the above paragraphs, it is merely assumed that the attacker's <em>current</em> capabilities are restricted; that is, their current exploit does not directly give them the power to do these things.  The attacker's immediate goal may well be to leverage their exploit to gain these capabilities, e.g. to load a malicious dynamic library into the process, even though the process does not directly contain code to do so.</p>
<p>Note that any bug that fits the above threat model can be immediately exploited as a denial-of-service attack by simply performing an illegal access and crashing the program.  Pointer authentication cannot protect against this.  While denial-of-service attacks are unfortunate, they are also unquestionably the best possible result of a bug this severe. Therefore, pointer authentication enthusiastically embraces the idea of halting the program on a pointer authentication failure rather than continuing in a possibly-compromised state.</p>
<p>Pointer authentication is a form of control-flow integrity (CFI) enforcement. The basic security hypothesis behind CFI enforcement is that many bugs can only be usefully exploited (other than as a denial-of-service) by leveraging them to subvert the control flow of the program.  If this is true, then by inhibiting or limiting that subversion, it may be possible to largely mitigate the security consequences of those bugs by rendering them impractical (or, ideally, impossible) to exploit.</p>
<p>Every indirect branch in a program has a purpose.  Using human intelligence, a programmer can describe where a particular branch <em>should</em> go according to this purpose: a <code>return</code> in <code>printf</code> should return to the call site, a particular call in <code>qsort</code> should call the comparator that was passed in as an argument, and so on.  But for CFI to enforce that every branch in a program goes where it <em>should</em> in this sense would require CFI to perfectly enforce every semantic rule of the program's abstract machine; that is, it would require making the programming environment perfectly sound.  That is out of scope.  Instead, the goal of CFI is merely to catch attempts to make a branch go somewhere that its obviously <em>shouldn't</em> for its purpose: for example, to stop a call from branching into the middle of a function rather than its beginning.  As the information available to CFI gets better about the purpose of the branch, CFI can enforce tighter and tighter restrictions on where the branch is permitted to go.  Still, ultimately CFI cannot make the program sound.  This may help explain why pointer authentication makes some of the choices it does: for example, to sign and authenticate mostly code pointers rather than every pointer in the program.  Preventing attackers from redirecting branches is both particularly important and particularly approachable as a goal.  Detecting corruption more broadly is infeasible with these techniques, and the attempt would have far higher cost.</p>
<a name="user-content-attacks-on-pointer-authentication"></a>
<h3><a href="#id56">Attacks on pointer authentication</a></h3>
<p>Pointer authentication works as follows.  Every indirect branch in a program has a purpose.  For every purpose, the implementation chooses a <a href="#id4"><span id="user-content-id5">:ref:`signing schema&lt;Signing schemas&gt;`</span></a>.  At some place where a pointer is known to be correct for its purpose, it is signed according to the purpose's schema.  At every place where the pointer is needed for its purpose, it is authenticated according to the purpose's schema.  If that authentication fails, the program is halted.</p>
<p>There are a variety of ways to attack this.</p>
<a name="user-content-attacks-of-interest-to-programmers"></a>
<h4><a href="#id57">Attacks of interest to programmers</a></h4>
<p>These attacks arise from weaknesses in the default protections offered by pointer authentication.  They can be addressed by using attributes or intrinsics to opt in to stronger protection.</p>
<a name="user-content-substitution-attacks"></a>
<h5><a href="#id58">Substitution attacks</a></h5>
<p>An attacker can simply overwrite a pointer intended for one purpose with a pointer intended for another purpose if both purposes use the same signing schema and that schema does not use address diversity.</p>
<p>The most common source of this weakness is when code relies on using the default language rules for C function pointers.  The current implementation uses the exact same signing schema for all C function pointers, even for functions of substantially different type.  While efforts are ongoing to improve constant diversity for C function pointers of different type, there are necessary limits to this.  The C standard requires function pointers to be copyable with <code>memcpy</code>, which means that function pointers can never use address diversity.  Furthermore, even if a function pointer can only be replaced with another function of the exact same type, that can still be useful to an attacker, as in the following example of a hand-rolled "v-table":</p>
<div><pre><span>struct</span> ObjectOperations {
  <span>void</span> (*retain)(Object *);
  <span>void</span> (*release)(Object *);
  <span>void</span> (*deallocate)(Object *);
  <span>void</span> (*logStatus)(Object *);
};</pre></div>
<p>This weakness can be mitigated by using a more specific signing schema for each purpose.  For example, in this example, the <code>__ptrauth</code> qualifier can be used with a different constant discriminator for each field.  Since there's no particular reason it's important for this v-table to be copyable with <code>memcpy</code>, the functions can also be signed with address diversity:</p>
<div><pre>#<span>if</span> __has_feature(ptrauth_calls)
#<span>define</span> <span>objectOperation</span>(<span>discriminator</span>) \
  <span>__ptrauth</span>(ptrauth_key_function_pointer, <span>1</span>, discriminator)
#<span>else</span>
#<span>define</span> <span>objectOperation</span>(<span>discriminator</span>)
#<span>endif</span>

<span>struct</span> ObjectOperations {
  <span>void</span> (*<span>objectOperation</span>(<span>0xf017</span>) retain)(Object *);
  <span>void</span> (*<span>objectOperation</span>(<span>0x2639</span>) release)(Object *);
  <span>void</span> (*<span>objectOperation</span>(<span>0x8bb0</span>) deallocate)(Object *);
  <span>void</span> (*<span>objectOperation</span>(<span>0xc5d4</span>) logStatus)(Object *);
};</pre></div>
<p>This weakness can also sometimes be mitigated by simply keeping the signed pointer in constant memory, but this is less effective than using better signing diversity.</p>
<a name="user-content-id6"></a>
<h5><a href="#id59">Access path attacks</a></h5>
<p>If a signed pointer is often accessed indirectly (that is, by first loading the address of the object where the signed pointer is stored), an attacker can affect uses of it by overwriting the intermediate pointer in the access path.</p>
<p>The most common scenario exhibiting this weakness is an object with a pointer to a "v-table" (a structure holding many function pointers). An attacker does not need to replace a signed function pointer in the v-table if they can instead simply replace the v-table pointer in the object with their own pointer --- perhaps to memory where they've constructed their own v-table, or to existing memory that coincidentally happens to contain a signed pointer at the right offset that's been signed with the right signing schema.</p>
<p>This attack arises because data pointers are not signed by default. It works even if the signed pointer uses address diversity: address diversity merely means that each pointer is signed with its own storage address, which (by design) is invariant to changes in the accessing pointer.</p>
<p>Using sufficiently diverse signing schemas within the v-table can provide reasonably strong mitigation against this weakness.  Always use address diversity in v-tables to prevent attackers from assembling their own v-table.  Avoid re-using constant discriminators to prevent attackers from replacing a v-table pointer with a pointer to totally unrelated memory that just happens to contain an similarly-signed pointer.</p>
<p>Further mitigation can be attained by signing pointers to v-tables. Any signature at all should prevent attackers from forging v-table pointers; they will need to somehow harvest an existing signed pointer from elsewhere in memory.  Using a meaningful constant discriminator will force this to be harvested from an object with similar structure (e.g. a different implementation of the same interface).  Using address diversity will prevent such harvesting entirely.  However, care must be taken when sourcing the v-table pointer originally; do not blindly sign a pointer that is not <a href="#id7"><span id="user-content-id8">:ref:`safely derived&lt;Safe derivation&gt;`</span></a>.</p>
<a name="user-content-id9"></a>
<h5><a href="#id60">Signing oracles</a></h5>
<p>A signing oracle is a bit of code which can be exploited by an attacker to sign an arbitrary pointer in a way that can later be recovered.  Such oracles can be used by attackers to forge signatures matching the oracle's signing schema, which is likely to cause a total compromise of pointer authentication's effectiveness.</p>
<p>This attack only affects ordinary programmers if they are using certain treacherous patterns of code.  Currently this includes:</p>
<ul>
<li>all uses of the <code>__ptrauth_sign_unauthenticated</code> intrinsic and</li>
<li>assigning data pointers to <code>__ptrauth</code>-qualified l-values.</li>
</ul>
<p>Care must be taken in these situations to ensure that the pointer being signed has been <a href="#id10"><span id="user-content-id11">:ref:`safely derived&lt;Safe derivation&gt;`</span></a> or is otherwise not possible to attack.  (In some cases, this may be challenging without compiler support.)</p>
<p>A diagnostic will be added in the future for implicitly dangerous patterns of code, such as assigning a non-safely-derived data pointer to a <code>__ptrauth</code>-qualified l-value.</p>
<a name="user-content-id12"></a>
<h5><a href="#id61">Authentication oracles</a></h5>
<p>An authentication oracle is a bit of code which can be exploited by an attacker to leak whether a signed pointer is validly signed without halting the program if it isn't.  Such oracles can be used to forge signatures matching the oracle's signing schema if the attacker can repeatedly invoke the oracle for different candidate signed pointers. This is likely to cause a total compromise of pointer authentication's effectiveness.</p>
<p>There should be no way for an ordinary programmer to create an authentication oracle using the current set of operations. However, implementation flaws in the past have occasionally given rise to authentication oracles due to a failure to immediately trap on authentication failure.</p>
<p>The likelihood of creating an authentication oracle is why there is currently no intrinsic which queries whether a signed pointer is validly signed.</p>
<a name="user-content-attacks-of-interest-to-implementors"></a>
<h4><a href="#id62">Attacks of interest to implementors</a></h4>
<p>These attacks are not inherent to the model; they arise from mistakes in either implementing or using the sign and auth operations. Avoiding these mistakes requires careful work throughout the system.</p>
<a name="user-content-failure-to-trap-on-authentication-failure"></a>
<h5><a href="#id63">Failure to trap on authentication failure</a></h5>
<p>Any failure to halt the program on an authentication failure is likely to be exploitable by attackers to create an <a href="#id13"><span id="user-content-id14">:ref:`authentication oracle&lt;Authentication oracles&gt;`</span></a>.</p>
<p>There are several different ways to introduce this problem:</p>
<ul>
<li><p>The implementation might try to halt the program in some way that can be intercepted.</p>
<p>For example, the <code>auth</code> instruction in ARMv8.3 does not directly trap; instead it corrupts its result so that it is always an invalid pointer. If the program subsequently attempts to use that pointer, that will be a bad memory access, and it will trap into the kernel.  However, kernels do not usually immediately halt programs that trigger traps due to bad memory accesses; instead they notify the process to give it an opportunity to recover.  If this happens with an <code>auth</code> failure, the attacker may be able to exploit the recovery path in a way that creates an oracle. Kernels should ensure that these sorts of traps are not recoverable.</p>
</li>
<li><p>A compiler might use an intermediate representation (IR) for <code>sign</code> and <code>auth</code> operations that cannot make adequate correctness guarantees.</p>
<p>For example, suppose that an IR uses ARMv8.3-like semantics for <code>auth</code>: the operation merely corrupts its result on failure instead of promising the trap.  A frontend might emit patterns of IR that always follow an <code>auth</code> with a memory access, thinking that this ensures correctness. But if the IR can be transformed to insert code between the <code>auth</code> and the access, or if the <code>auth</code> can be speculated, then this potentially creates an oracle.  It is better for <code>auth</code> to semantically guarantee to trap, potentially requiring an explicit check in the generated code. An ARMv8.3-like target can avoid this explicit check in the common case by recognizing the pattern of an <code>auth</code> followed immediately by an access.</p>
</li>
</ul>
<a name="user-content-attackable-code-sequences"></a>
<h5><a href="#id64">Attackable code sequences</a></h5>
<p>If code that is part of a pointer authentication operation is interleaved with code that may itself be vulnerable to attacks, an attacker may be able to use this to create a <a href="#id15"><span id="user-content-id16">:ref:`signing&lt;Signing oracles&gt;`</span></a> or <a href="#id17"><span id="user-content-id18">:ref:`authentication&lt;Authentication oracles&gt;`</span></a> oracle.</p>
<p>For example, suppose that the compiler is generating a call to a function and passing two arguments: a signed constant pointer and a value derived from a call.  In ARMv8.3, this code might look like so:</p>
<div><pre><span>adr x19</span><span>,</span><span> _callback.</span><span>        ; compute &amp;_callback</span>
<span>paciza x19</span><span>                 ; sign it with a constant discriminator of 0</span>
<span>blr _argGenerator</span><span>          ; call _argGenerator() (returns in x0)</span>
<span>mov</span><span> x1</span><span>,</span><span> x0</span><span>                 ; move call result to second arg register</span>
<span>mov</span><span> x0</span><span>,</span><span> x19</span><span>                ; move signed &amp;_callback to first arg register</span>
<span>blr _function</span><span>              ; call _function</span></pre></div>
<p>This code is correct, as would be a sequencing that does <em>both</em> the <code>adr</code> and the <code>paciza</code> after the call to <code>_argGenerator</code>.  But a sequence that computes the address of <code>_callback</code> but leaves it as a raw pointer in a register during the call to <code>_argGenerator</code> would be vulnerable:</p>
<div><pre><span>adr x19</span><span>,</span><span> _callback.</span><span>        ; compute &amp;_callback</span>
<span>blr _argGenerator</span><span>          ; call _argGenerator() (returns in x0)</span>
<span>mov</span><span> x1</span><span>,</span><span> x0</span><span>                 ; move call result to second arg register</span>
<span>paciza x19</span><span>                 ; sign &amp;_callback</span>
<span>mov</span><span> x0</span><span>,</span><span> x19</span><span>                ; move signed &amp;_callback to first arg register</span>
<span>blr _function</span><span>              ; call _function</span></pre></div>
<p>If <code>_argGenerator</code> spills <code>x19</code> (a callee-save register), and if the attacker can perform a write during this call, then the attacker can overwrite the spill slot with an arbitrary pointer that will eventually be unconditionally signed after the function returns.  This would be a signing oracle.</p>
<p>The implementation can avoid this by obeying two basic rules:</p>
<ul>
<li><p>The compiler's intermediate representations (IR) should not provide operations that expose intermediate raw pointers.  This may require providing extra operations that perform useful combinations of operations.</p>
<p>For example, there should be an "atomic" auth-and-resign operation that should be used instead of emitting an <code>auth</code> operation whose result is fed into a <code>sign</code>.</p>
<p>Similarly, if a pointer should be authenticated as part of doing a memory access or a call, then the access or call should be decorated with enough information to perform the authentication; there should not be a separate <code>auth</code> whose result is used as the pointer operand for the access or call.  (In LLVM IR, we do this for calls, but not yet for loads or stores.)</p>
<p>"Operations" includes things like materializing a signed pointer to a known function or global variable.  The compiler must be able to recognize and emit this as a unified operation, rather than potentially splitting it up as in the example above.</p>
</li>
<li><p>The compiler backend should not be too aggressive about scheduling instructions that are part of a pointer authentication operation.  This may require custom code-generation of these operations in some cases.</p>
</li>
</ul>
<a name="user-content-register-clobbering"></a>
<h5><a href="#id65">Register clobbering</a></h5>
<p>As a refinement of the section on <a href="#attackable-code-sequences">Attackable code sequences</a>, if the attacker has the ability to modify arbitrary <em>register</em> state at arbitrary points in the program, then special care must be taken.</p>
<p>For example, ARMv8.3 might materialize a signed function pointer like so:</p>
<div><pre><span>adr x0</span><span>,</span><span> _callback.</span><span>        ; compute &amp;_callback</span>
<span>paciza x0</span><span>                 ; sign it with a constant discriminator of 0</span></pre></div>
<p>If an attacker has the ability to overwrite <code>x0</code> between these two instructions, this code sequence is vulnerable to becoming a signing oracle.</p>
<p>For the most part, this sort of attack is not possible: it is a basic element of the design of modern computation that register state is private and inviolable.  However, in systems that support asynchronous interrupts, this property requires the cooperation of the interrupt-handling code. If that code saves register state to memory, and that memory can be overwritten by an attacker, then essentially the attack can overwrite arbitrary register state at an arbitrary point.  This could be a concern if the threat model includes attacks on the kernel or if the program uses user-space preemptive multitasking.</p>
<p>(Readers might object that an attacker cannot rely on asynchronous interrupts triggering at an exact instruction boundary.  In fact, researchers have had some success in doing exactly that.  Even ignoring that, though, we should aim to protect against lucky attackers just as much as good ones.)</p>
<p>To protect against this, saved register state must be at least partially signed (using something like <a href="#ptrauth-sign-generic-data">ptrauth_sign_generic_data</a>).  This is required for correctness anyway because saved thread states include security-critical registers such as SP, FP, PC, and LR (where applicable).  Ideally, this signature would cover all the registers, but since saving and restoring registers can be very performance-sensitive, that may not be acceptable. It is sufficient to set aside a small number of scratch registers that will be guaranteed to be preserved correctly; the compiler can then be careful to only store critical values like intermediate raw pointers in those registers.</p>
<p><code>setjmp</code> and <code>longjmp</code> should sign and authenticate the core registers (SP, FP, PC, and LR), but they do not need to worry about intermediate values because <code>setjmp</code> can only be called synchronously, and the compiler should never schedule pointer-authentication operations interleaved with arbitrary calls.</p>
<a name="user-content-attacks-on-relative-addressing"></a>
<h5><a href="#id66">Attacks on relative addressing</a></h5>
<p>Relative addressing is a technique used to compress and reduce the load-time cost of infrequently-used global data.  The pointer authentication system is unlikely to support signing or authenticating a relative address, and in most cases it would defeat the point to do so: it would take additional storage space, and applying the signature would take extra work at load time.</p>
<p>Relative addressing is not precluded by the use of pointer authentication, but it does take extra considerations to make it secure:</p>
<ul>
<li>Relative addresses must only be stored in read-only memory.  A writable relative address can be overwritten to point nearly anywhere, making it inherently insecure; this danger can only be compensated for with techniques for protecting arbitrary data like <a href="#ptrauth-sign-generic-data">ptrauth_sign_generic_data</a>.</li>
<li>Relative addresses must only be accessed through signed pointers with adequate diversity.  If an attacker can perform an access path attack to replace the pointer through which the relative address is accessed, they can easily cause the relative address to point wherever they want.</li>
</ul>
<a name="user-content-signature-forging"></a>
<h5><a href="#id67">Signature forging</a></h5>
<p>If an attacker can exactly reproduce the behavior of the signing algorithm, and they know all the correct inputs to it, then they can perfectly forge a signature on an arbitrary pointer.</p>
<p>There are three components to avoiding this mistake:</p>
<ul>
<li>The abstract signing algorithm should be good: it should not have glaring flaws which would allow attackers to predict its result with better than random accuracy without knowing all the inputs (like the key values).</li>
<li>The key values should be kept secret.  If at all possible, they should never be stored in accessible memory, or perhaps only stored encrypted.</li>
<li>Contexts that are meant to be independently protected should use different key values.  For example, the kernel should not use the same keys as user processes.  Different user processes should also use different keys from each other as much as possible, although this may pose its own technical challenges.</li>
</ul>
<a name="user-content-remapping"></a>
<h5><a href="#id68">Remapping</a></h5>
<p>If an attacker can change the memory protections on certain pages of the program's memory, that can substantially weaken the protections afforded by pointer authentication.</p>
<ul>
<li>If an attacker can inject their own executable code, they can also certainly inject code that can be used as a <a href="#id19"><span id="user-content-id20">:ref:`signing oracle&lt;Signing Oracles&gt;`</span></a>.  The same is true if they can write to the instruction stream.</li>
<li>If an attacker can remap read-only program sections to be writable, then any use of <a href="#id21"><span id="user-content-id22">:ref:`relative addresses`</span></a> in global data becomes insecure.</li>
<li>If an attacker can remap read-only program sections to be writable, then it is unsafe to use unsigned pointers in <a href="#global-offset-tables">global offset tables</a>.</li>
</ul>
<p>Remapping memory in this way often requires the attacker to have already substantively subverted the control flow of the process.  Nonetheless, if the operating system has a mechanism for mapping pages in a way that cannot be remapped, this should be used wherever possible.</p>
<a name="user-content-id23"></a>
<h3><a href="#id69">Safe derivation</a></h3>
<p>Whether a data pointer is stored, even briefly, as a raw pointer can affect the security-correctness of a program.  (Function pointers are never implicitly stored as raw pointers; raw pointers to functions can only be produced with the <code>&lt;ptrauth.h&gt;</code> intrinsics.)  Repeated re-signing can also impact performance.  Clang makes a modest set of guarantees in this area:</p>
<ul>
<li>An expression of pointer type is said to be <strong>safely derived</strong> if:<ul>
<li>it takes the address of a global variable or function, or</li>
<li>it is a load from a gl-value of <code>__ptrauth</code>-qualified type.</li>
</ul>
</li>
<li>If a value that is safely derived is assigned to a <code>__ptrauth</code>-qualified object, including by initialization, then the value will be directly signed as appropriate for the target qualifier and will not be stored as a raw pointer.</li>
<li>If the function expression of a call is a gl-value of <code>__ptrauth</code>-qualified type, then the call will be authenticated directly according to the source qualifier and will not be resigned to the default rule for a function pointer of its type.</li>
</ul>
<p>These guarantees are known to be inadequate for data pointer security. In particular, Clang should be enhanced to make the following guarantees:</p>
<ul>
<li>A pointer should additionally be considered safely derived if it is:<ul>
<li>the address of a gl-value that is safely derived,</li>
<li>the result of pointer arithmetic on a pointer that is safely derived (with some restrictions on the integer operand),</li>
<li>the result of a comma operator where the second operand is safely derived,</li>
<li>the result of a conditional operator where the selected operand is safely derived, or</li>
<li>the result of loading from a safely derived gl-value.</li>
</ul>
</li>
<li>A gl-value should be considered safely derived if it is:<ul>
<li>a dereference of a safely derived pointer,</li>
<li>a member access into a safely derived gl-value, or</li>
<li>a reference to a variable.</li>
</ul>
</li>
<li>An access to a safely derived gl-value should be guaranteed to not allow replacement of any of the safely-derived component values at any point in the access.  "Access" should include loading a function pointer.</li>
<li>Assignments should include pointer-arithmetic operators like <code>+=</code>.</li>
</ul>
<p>Making these guarantees will require further work, including significant new support in LLVM IR.</p>
<p>Furthermore, Clang should implement a warning when assigning a data pointer that is not safely derived to a <code>__ptrauth</code>-qualified gl-value.</p>
<a name="user-content-language-abi"></a>
<h2><a href="#id70">Language ABI</a></h2>
<p>This section describes the pointer-authentication ABI currently implemented in Clang for the Apple arm64e target.  As other targets adopt pointer authentication, this section should be generalized to express their ABIs as well.</p>
<a name="user-content-key-assignments"></a>
<h3><a href="#id71">Key assignments</a></h3>
<p>ARMv8.3 provides four abstract signing keys: <code>IA</code>, <code>IB</code>, <code>DA</code>, and <code>DB</code>. The architecture designates <code>IA</code> and <code>IB</code> for signing code pointers and <code>DA</code> and <code>DB</code> for signing data pointers; this is reinforced by two properties:</p>
<ul>
<li>The ISA provides instructions that perform combined auth+call and auth+load operations; these instructions can only use the <code>I</code> keys and <code>D</code> keys, respectively.</li>
<li>AArch64's TBI feature can be separately enabled for code pointers (controlling whether indirect-branch instructions ignore those bits) and data pointers (controlling whether memory-access instructions) ignore those bits. If TBI is enabled for a kind of pointer, the sign and auth operations preserve the TBI bits when signing with an associated keys (at the cost of shrinking the number of available signing bits by 8).</li>
</ul>
<p>arm64e then further subdivides the keys as follows:</p>
<ul>
<li>The <code>A</code> keys are used for primarily "global" purposes like signing v-tables and function pointers.  These keys are sometimes called <em>process-independent</em> or <em>cross-process</em> because on existing OSes they are not changed when changing processes, although this is not a platform guarantee.</li>
<li>The <code>B</code> keys are used for primarily "local" purposes like signing return addresses and frame pointers.  These keys are sometimes called <em>process-specific</em> because they are typically different between processes. However, they are in fact shared across processes in one situation: systems which provide <code>fork</code> cannot change these keys in the child process; they can only be changed during <code>exec</code>.</li>
</ul>
<a name="user-content-implementation-defined-algorithms-and-quantities"></a>
<h3><a href="#id72">Implementation-defined algorithms and quantities</a></h3>
<p>The cryptographic hash algorithm used to compute signatures in ARMv8.3 is a private detail of the hardware implementation.</p>
<p>arm64e restricts constant discriminators (used in <code>__ptrauth</code> and <code>ptrauth_blend_discriminator</code>) to the range from 0 to 65535, inclusive.  A 0 discriminator generally signifies that no blending is required; see the documentation for <code>ptrauth_blend_discriminator</code>.  This range is somewhat narrow but has two advantages:</p>
<ul>
<li><p>The AArch64 ISA allows an arbitrary 16-bit immediate to be written over the top 16 bits of a register in a single instruction:</p>

<p>This is ideal for the discriminator blending operation because it adds minimal code-size overhead and avoids overwriting any interesting bits from the pointer.  Blending in a wider constant discriminator would either clobber interesting bits (e.g. if it was loaded with <code>movk xN, #0x4c4f, LSL 32</code>) or require significantly more code (e.g. if the discriminator was loaded with a <code>mov+bfi</code> sequence).</p>
</li>
<li><p>It is possible to pack a 16-bit discriminator into loader metadata with minimal compromises, whereas a wider discriminator would require extra metadata storage and therefore significantly impact load times.</p>
</li>
</ul>
<p>The string hash used by <code>ptrauth_string_discriminator</code> is a 64-bit SipHash-2-4 using the constant seed <code>b5d4c9eb79104a796fec8b1b428781d4</code> (big-endian), with the result reduced by modulo to the range of non-zero discriminators (i.e. <code>(rawHash % 65535) + 1</code>).</p>
<a name="user-content-return-addresses"></a>
<h3><a href="#id73">Return addresses</a></h3>
<p>The kernel must ensure that attackers cannot replace LR due to an asynchronous exception; see <a href="#register-clobbering">Register clobbering</a>.  If this is done by generally protecting LR, then functions which don't spill LR to the stack can avoid signing it entirely.  Otherwise, the return address must be signed; on arm64e it is signed with the <code>IB</code> key using the stack pointer on entry as the discriminator.</p>
<p>Protecting return addresses is of such particular importance that the <code>IB</code> key is almost entirely reserved for this purpose.</p>
<a name="user-content-global-offset-tables"></a>
<h3><a href="#id74">Global offset tables</a></h3>
<p>The global offset table (GOT) is not ABI, but it is a common implementation technique for dynamic linking which deserves special discussion here.</p>
<p>Whenever possible, signed pointers should be materialized directly in code rather than via the GOT, e.g. using an <code>adrp+add+pac</code> sequence on ARMv8.3. This decreases the amount of work necessary at load time to initialize the GOT, but more importantly, it defines away the potential for several attacks:</p>
<ul>
<li>Attackers cannot change instructions, so there is no way to cause this code sequence to materialize a different pointer, whereas an access via the GOT always has <em>at minimum</em> a probabilistic chance to be the target of successful <a href="#substitution-attacks">substitution attacks</a>.</li>
<li>The GOT is a dense pool of fixed pointers at a fixed offset relative to code; attackers can search this pool for useful pointers that can be used in <a href="#substitution-attacks">substitution attacks</a>, whereas pointers that are only materialized directly are not so easily available.</li>
<li>Similarly, attackers can use <a href="#access-path-attacks">access path attacks</a> to replace a pointer to a signed pointer with a pointer to the GOT if the signing schema used within the GOT happens to be the same as the original pointer.  This kind of collision becomes much less likely to be useful the fewer pointers are in the GOT in the first place.</li>
</ul>
<p>If this can be done for a symbol, then the compiler need only ensure that it materializes the signed pointer using registers that are safe against <a href="#register-clobbering">register clobbering</a>.</p>
<p>However, many symbols can only be accessed via the GOT, e.g. because they resolve to definitions outside of the current image.  In this case, care must be taken to ensure that using the GOT does not introduce weaknesses.</p>
<ul>
<li>If the entire GOT can be mapped read-only after loading, then no signing is required within the GOT.  In fact, not signing pointers in the GOT is preferable in this case because it makes the GOT useless for the harvesting and access-path attacks above.  Storing raw pointers in this way is usually extremely unsafe, but for the special case of an immutable GOT entry it's fine because the GOT is always accessed via an address that is directly materialized in code and thus provably unattackable.  (But see <a href="#remapping">Remapping</a>.)</li>
<li>Otherwise, GOT entries which are used for producing a signed pointer constant must be signed.  The signing schema used in the GOT need not match the target signing schema for the signed constant.  To counteract the threats of substitution attacks, it's best if GOT entries can be signed with address diversity.  Using a good constant discriminator as well (perhaps derived from the symbol name) can make it less useful to use a pointer to the GOT as the replacement in an <a href="#id24"><span id="user-content-id25">:ref:`access path attack&lt;Access path attacks&gt;`</span></a>.</li>
</ul>
<p>In either case, the compiler must ensure that materializing the address of a GOT entry as part of producing a signed pointer constant is not vulnerable to <a href="#register-clobbering">register clobbering</a>.  If the linker also generates code for this, e.g. for call stubs, this generated code must take the same precautions.</p>
<a name="user-content-id26"></a>
<h3><a href="#id75">C function pointers</a></h3>
<p>On arm64e, C function pointers are currently signed with the <code>IA</code> key without address diversity and with a constant discriminator of 0.</p>
<p>The C and C++ standards do not permit C function pointers to be signed with address diversity by default: in C++ terms, function pointer types are required to be trivially copyable, which means they must be copyable with <code>memcpy</code>.</p>
<p>The use of a uniform constant discriminator is seen as a serious defect which should be remedied, and improving this is under investigation.</p>
<a name="user-content-c-virtual-tables"></a>
<h3><a href="#id76">C++ virtual tables</a></h3>
<p>The pointer to a C++ virtual table is currently signed with the <code>DA</code> key, no address diversity, and a constant discriminator of 0.  The use of no address diversity, as well as the uniform constant discriminator, are seen as weaknesses.  Not using address diversity allows attackers to simply copy valid v-table pointers from one object to another.  However, using a uniform discriminator of 0 does have positive performance and code-size implications on ARMv8.3, and diversity for the most important v-table access pattern (virtual dispatch) is already better assured by the signing schemas used on the virtual functions.  It is also known that some code in practice copies objects containing v-tables with <code>memcpy</code>, and while this is not permitted formally, it is something that may be invasive to eliminate.</p>
<p>Virtual functions in a C++ virtual table are signed with the <code>IA</code> key, address diversity, and a constant discriminator equal to the string hash (see <a href="#ptrauth-string-discriminator">ptrauth_string_discriminator</a>) of the mangled name of the function which originally gave rise to the v-table slot.</p>
<a name="user-content-c-member-function-pointers"></a>
<h3><a href="#id77">C++ member function pointers</a></h3>
<p>A member function pointer is signed with the <code>IA</code> key, no address diversity, and a constant discriminator equal to the string hash (see <a href="#ptrauth-string-discriminator">ptrauth_string_discriminator</a>) of the member pointer type.  Address diversity is not permitted by C++ for member function pointers because they must be trivially-copyable types.</p>
<p>The Itanium C++ ABI specifies that member function pointers to virtual functions simply store an offset to the correct v-table slot.  This ABI cannot be used securely with pointer authentication because there is no safe place to store the constant discriminator for the target v-table slot: if it's stored with the offset, an attacker can simply overwrite it with the right discriminator for the offset.  Even if the programmer never uses pointers to virtual functions, the existence of this code path makes all member function pointer dereferences insecure.</p>
<p>arm64e changes this ABI so that virtual function pointers are stored using dispatch thunks with vague linkage.  Because arm64e supports interoperation with <code>arm64</code> code when pointer authentication is disabled, an arm64e member function pointer dereference still recognizes the virtual-function representation but uses an bogus discriminator on that path that should always trap if pointer authentication is enabled dynamically.</p>
<p>The use of dispatch thunks means that <code>==</code> on member function pointers is no longer reliable for virtual functions, but this is acceptable because the standard makes no guarantees about it in the first place.</p>
<p>The use of dispatch thunks also potentially enables v-tables to be signed using a declaration-specific constant discriminator in the future; otherwise this discriminator would also need to be stored in the member pointer.</p>
<a name="user-content-blocks"></a>
<h3><a href="#id78">Blocks</a></h3>
<p>Block pointers are data pointers which must interoperate with the ObjC id type and therefore cannot be signed themselves.</p>
<p>The invocation pointer in a block is signed with the <code>IA</code> key using address diversity and a constant dicriminator of 0.  Using a uniform discriminator is seen as a weakness to be potentially improved, but this is tricky due to the subtype polymorphism directly permitted for blocks.</p>
<p>Block descriptors and <code>__block</code> variables can contain pointers to functions that can be used to copy or destroy the object.  These functions are signed with the <code>IA</code> key, address diversity, and a constant discriminator of 0.  The structure of block descriptors is under consideration for improvement.</p>
<a name="user-content-objective-c-methods"></a>
<h3><a href="#id79">Objective-C methods</a></h3>
<p>Objective-C method lists sign methods with the <code>IA</code> key using address diversity and a constant discriminator of 0.  Using a uniform constant discriminator is believed to be acceptable because these tables are only accessed internally to the Objective-C runtime.</p>
<p>The Objective-C runtime provides additional protection to methods that have been loaded into the Objective-C method cache; this protection is private to the runtime.</p>
<p>Pointer authentication cannot protect against access-path atacks against the Objective-C <code>isa</code> pointer, through which all dispatch occurs, because of compatibility requirements and existing and important usage of high bits in the pointer.</p>
<a name="user-content-swift-class-methods"></a>
<h3><a href="#id80">Swift class methods</a></h3>
<p>Class methods in Swift are signed in the class object with the <code>IA</code> key using address diversity and a constant discriminator equal to the string hash (see <a href="#ptrauth-string-discriminator">ptrauth_string_discriminator</a>) of the mangling of the original overridable method.</p>
<p>Resilient class-method lookup relies on passing a method descriptor; this method descriptor should be signed but currently isn't.  The lookup function returns a function pointer that is signed using <code>IA</code> without address diversity and with the correct constant discriminator for the looked-up method.</p>
<p>Swift's equivalent of a C++ v-table pointer is the <code>isa</code> pointer of an object.  On arm64e, this is constrained by Objective-C compatibility and cannot be a signed pointer.</p>
<a name="user-content-swift-heap-destructors"></a>
<h3><a href="#id81">Swift heap destructors</a></h3>
<p>Objects that are retained and released with Swift's native reference-counting system, including both native classes and temporary "box" allocations, must provide a destructor function in their metadata.  This destructor function is signed with the <code>IA</code> key using address diversity and a constant discriminator of <code>0xbbbf</code>.</p>
<a name="user-content-swift-protocol-requirements"></a>
<h3><a href="#id82">Swift protocol requirements</a></h3>
<p>Protocol function requirements are signed in the protocol witness table with the <code>IA</code> key using address diversity and a constant discriminator equal to the string hash (see <a href="#ptrauth-string-discriminator">ptrauth_string_discriminator</a>) of the mangling of the protocol requirement.</p>
<a name="user-content-swift-function-types"></a>
<h3><a href="#id83">Swift function types</a></h3>
<p>The invocation pointers of Swift function values are signed using the <code>IA</code> key without address diversity and with a constant discriminator derived loosely from the function type.</p>
<p>Address diversity cannot be used by default for function values because function types are intended to be a "loadable" type which can be held and passed in registers.</p>
<p>The constant discriminator currently accounts for potential abstraction in the function signature in ways that decrease the diversity of signatures; improving this is under investigation.</p>
<a name="user-content-swift-metadata"></a>
<h3><a href="#id84">Swift metadata</a></h3>
<p>Type metadata pointers in Swift are not signed.</p>
<p>Type context descriptors must be signed because they frequently contain <a href="#relative-addresses">relative addresses</a>.  Type context descriptors are signed with the <code>DA</code> key without address diversity (except when stored in type metadata) and with a constant discriminator of <code>0xae86</code>.</p>
<a name="user-content-swift-value-witnesses"></a>
<h3><a href="#id85">Swift value witnesses</a></h3>
<p>Value witness functions in Swift are signed in the value witness table using the <code>IA</code> key with address diversity and an operation-specific constant discriminator which can be found in the Swift project headers.</p>
<a name="user-content-swift-coroutines"></a>
<h3><a href="#id86">Swift coroutines</a></h3>
<p>Resumption functions for Swift coroutines are signed using the <code>IA</code> key without address diversity and with a constant discriminator derived from the yield type of the coroutine.  Resumption functions cannot be signed with address diversity as they are returned directly in registers from the coroutine.</p>
<a name="user-content-alternative-implementations"></a>
<h2><a href="#id87">Alternative implementations</a></h2>
<a name="user-content-signature-storage"></a>
<h3><a href="#id88">Signature storage</a></h3>
<p>It is not critical for the security of pointer authentication that the signature be stored "together" with the pointer, as it is in ARMv8.3. An implementation could just as well store the signature in a separate word, so that the <code>sizeof</code> a signed pointer would be larger than the <code>sizeof</code> a raw pointer.</p>
<p>Storing the signature in the high bits, as ARMv8.3 does, has several trade-offs:</p>
<ul>
<li>Disadvantage: there are substantially fewer bits available for the signature, weakening the mitigation by making it much easier for an attacker to simply guess the correct signature.</li>
<li>Disadvantage: future growth of the address space will necessarily further weaken the mitigation.</li>
<li>Advantage: memory layouts don't change, so it's possible for pointer-authentication-enabled code (for example, in a system library) to efficiently interoperate with existing code, as long as pointer authentication can be disabled dynamically.</li>
<li>Advantage: the size of a signed pointer doesn't grow, which might significantly increase memory requirements, code size, and register pressure.</li>
<li>Advantage: the size of a signed pointer is the same as a raw pointer, so generic APIs which work in types like void * (such as dlsym) can still return signed pointers.  This means that clients of these APIs will not require insecure code in order to correctly receive a function pointer.</li>
</ul>
<a name="user-content-hashing-vs-encrypting-pointers"></a>
<h3><a href="#id89">Hashing vs. encrypting pointers</a></h3>
<p>ARMv8.3 implements <code>sign</code> by computing a cryptographic hash and storing that in the spare bits of the pointer.  This means that there are relatively few possible values for the valid signed pointer, since the bits corresponding to the raw pointer are known.  Together with an <code>auth</code> oracle, this can make it computationally feasible to discover the correct signature with brute force.  (The implementation should of course endeavor not to introduce <code>auth</code> oracles, but this can be difficult, and attackers can be devious.)</p>
<p>If the implementation can instead <em>encrypt</em> the pointer during <code>sign</code> and <em>decrypt</em> it during <code>auth</code>, this brute-force attack becomes far less feasible, even with an <code>auth</code> oracle.  However, there are several problems with this idea:</p>
<ul>
<li>It's unclear whether this kind of encryption is even possible without increasing the storage size of a signed pointer.  If the storage size can be increased, brute-force atacks can be equally well mitigated by simply storing a larger signature.</li>
<li>It would likely be impossible to implement a <code>strip</code> operation, which might make debuggers and other out-of-process tools far more difficult to write, as well as generally making primitive debugging more challenging.</li>
<li>Implementations can benefit from being able to extract the raw pointer immediately from a signed pointer.  An ARMv8.3 processor executing an <code>auth</code>-and-load instruction can perform the load and <code>auth</code> in parallel; a processor which instead encrypted the pointer would be forced to perform these operations serially.</li>
</ul>

</article>
  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>