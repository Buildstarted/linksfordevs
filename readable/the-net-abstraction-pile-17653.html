<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The .NET Abstraction Pile - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The .NET Abstraction Pile - linksfor.dev(s)"/>
    <meta property="og:description" content="2003-04-22 14:02:23"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://ericsink.com/Abstraction_Pile.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The .NET Abstraction Pile</title>
<div class="readable">
        <h1>The .NET Abstraction Pile</h1>
            <div>Reading time: 20-25 minutes</div>
        <div>Posted here: 26 Apr 2019</div>
        <p><a href="https://ericsink.com/Abstraction_Pile.html">https://ericsink.com/Abstraction_Pile.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
<p>2003-04-22 14:02:23</p>
<p>An abstraction is a boundary with two sides.&nbsp; On the top side, the 

abstraction presents a simplified view.&nbsp;&nbsp;Below, there&nbsp;is 

something more complex and more real.&nbsp; The purpose of the abstraction is to 

obscure what is really going on.</p>

<p>The world hidden underneath an abstraction is quite likely to be yet another 

abstraction.&nbsp; In fact, it is typical to have many abstractions stacked 

together, each one attempting to present an illusion which is even further from 

the truth.&nbsp; If you stack them up vertically, the ones at the bottom are 

more <em>real</em> than the ones at the top.</p>

<p>This is what programmers do.&nbsp; We build piles of abstractions.&nbsp; We 

design our own abstractions and then pile them up on top of layers we got from 

somebody else.&nbsp; Abstractions can be great.&nbsp; We use them because they 

save us a lot of time.&nbsp; But abstractions can also cause lots of 

problems.&nbsp; They're never perfect, as Joel Spolsky explains in his excellent 

article on "<a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">The Law of 

Leaky Abstractions</a>".</p>

<p>But you can't have the benefits of an abstraction without&nbsp;its 

risks.&nbsp; We need to make wise decisions about our piles of 

abstractions.&nbsp;&nbsp;I'll start by offering&nbsp;three rules to keep in 

mind:</p>

<p><span face="Arial,Helvetica,sansserif" size="4">Abstractions contain 

bugs.</span></p>

<blockquote dir="ltr">

  <p>Using somebody else's code&nbsp;can save a lot of time.&nbsp; For example, 

  a special GUI component allows you to program at a higher level of 

  abstraction.&nbsp; Why write your own?</p>

  <p>You have to remember that you are accepting a tradeoff.&nbsp; By using 

  somebody else's code you are inheriting somebody else's bugs.&nbsp; Often you 

  are accepting risks that are not under your control.</p></blockquote>

<p><span face="Arial,Helvetica,sansserif" size="4">Abstractions reduce 

performance.</span></p>

<blockquote dir="ltr">

  <p><span face="Times New Roman,Times,serif">Writing in Java is faster than 

  writing in C.&nbsp; But C code runs much faster than Java code.&nbsp; It's a 

  tradeoff that you cannot avoid.&nbsp; All you can do is make the right 

  choice.</span></p></blockquote>

<p><span face="Arial,Helvetica,sansserif" size="4">Abstractions increase overall 

complexity.</span></p>

<blockquote dir="ltr">

  <p><span face="Times New Roman,Times,serif">The goal of each abstraction is to 

  decrease complexity by presenting a simplified view of something else.&nbsp; 

  However, by the time you pile them all up, you've got a lot of complexity 

  which you may have to deal with.&nbsp; In fact, the more layers of abstraction 

  you have, the more complexity you've got involved.</span></p></blockquote>

<p><span face="Arial,Helvetica,sansserif" size="5"><strong>A Really Tall 

Pile</strong></span></p>

<p>Let's work through an example.&nbsp; Suppose that I am working from my home 

and I am ready to checkin some really important code changes to a source code 

file.&nbsp; I'm using the SourceGear Vault client to connect to our server back 

at SourceGear's main office.&nbsp; Below is a list of [almost] all the 

abstractions which are in play.</p>

<ol type="1">

  <li><strong>Vault</strong>.&nbsp; 

  The version control system itself is an abstraction.&nbsp; It presents our 

  users with concepts like Check Out, Check In, Label, Branch, Pin and 

  Share.&nbsp; This layer is obviously very important, since it's the only one 

  we can charge money for.&nbsp; :-)</li>
</ol>

<p><strong><span>Control 

Flow:</span></strong></p>

<ol type="1" start="2">

  <li><strong>C#</strong>.&nbsp; 

  Vault is written entirely in C#, which is a very nice abstraction 

  indeed.&nbsp; From C#&nbsp;we get&nbsp;classes, objects, methods, <a href="http://www.joelonsoftware.com/articles/fog0000000319.html">strings</a>, 

  looping constructs, logical operators, and the ability to attach names to 

  things.&nbsp; Cool. 

  </li>
<li><strong>CLR</strong>.&nbsp; 

  C# runs on the Common Language Runtime, which&nbsp;is a huge 

  abstraction.&nbsp; In fact, if we all weren't so worried about comparing .NET 

  to Java we would be calling the CLR a "virtual machine", which it 

  is. 

  </li>
<li><strong>C++</strong>.&nbsp; 

  The CLR is written in lower level languages like C++ and C. 

  </li>
<li><strong>Assembly</strong>.&nbsp; 

  C++ is implemented by compiling it to x86 assembler code.&nbsp; We've taken a 

  big, big jump here.&nbsp; Compared to C++, assembly language doesn't feel very 

  abstract at all. 

  </li>
<li><strong>Microcode</strong>.&nbsp; 

  Did you think Assembly was the lowest level of programming?&nbsp; Certainly 

  not.&nbsp; Each x86 assembler instruction is a little program written in an 

  even lower level language called microcode.

  </li>
<li><strong>Logical 

  gates</strong>.&nbsp; Microcode is implemented by circuits which provide 

  logical gates, including NOT, AND, OR, and NAND.

  </li>
<li><strong>Transistors</strong>.&nbsp;Logical 

  gates are implemented by transistors, an electronic component with three wires 

  sticking out of it.</li>
</ol>

<p><strong><span>Memory:</span></strong></p>

<ol type="1" start="9">

  <li><strong>ArrayList</strong>.&nbsp; 

  The .NET framework gives us "collections" we can use to manage memory in 

  aggregated ways. 

  </li>
<li><strong>Objects</strong>.&nbsp; 

  From the realm of OOP we get "objects", self-contained pieces of data which 

  are bound to the operations which can be performed on that data.&nbsp; Very 

  handy. 

  </li>
<li><strong>GC</strong>.&nbsp; 

  This is a big one.&nbsp; Because the .NET Common Language Runtime has a 

  garbage collector, we can create objects and know that they will automatically 

  be destroyed later when we are done with them. 

  </li>
<li><strong>Handles</strong>.&nbsp; 

  In reality, memory has to be explicitly requested and released from 

  the&nbsp;operating system.&nbsp; Each chunk of memory is identified by a 

  handle.&nbsp; 

  </li>
<li><strong>Virtual 

  Memory</strong>.&nbsp; This layer gives us another important illusion:&nbsp; 

  There is more memory available than we actually have. 

  </li>
<li><strong>RAM</strong>.&nbsp; 

  Random Access Memory is itself an abstraction.&nbsp;&nbsp;Transistors don't 

  really remember anything.&nbsp; Furthermore, the notion of a bit doesn't 

  really exist.&nbsp;&nbsp;&nbsp; We simply assign conventions.&nbsp; When a 

  wire is at 5V, we call it a one.&nbsp; When it has no voltage on it, we call 

  it a zero.&nbsp; Collect a few hundred million of these in one place and 

  you've got a DIMM.&nbsp; <em>(Actually, it's 3.3V nowadays, 

right?)</em></li>
</ol>

<p><strong><span>The Check In 

Button:</span></strong></p>

<ol type="1" start="15">

  <li><strong>Button</strong>.&nbsp; 

  The Check In dialog has a button on it.&nbsp; When the user presses this 

  button, the Check In operation will commence.&nbsp; But the button itself is 

  an abstraction.&nbsp; It is designed to simulate the concept of a physical 

  button like you might find on your microwave or TV.&nbsp; No such button 

  really exists.&nbsp; Windows Forms provides this abstraction.

  </li>
<li><strong>HWND</strong>.&nbsp; 

  Windows Forms is a layer of abstraction which is built on the Win32 API 

  underneath.&nbsp; The button is actually a window with its own WndProc.&nbsp; 

  .NET tries to hide this world, but it's definitely still there.&nbsp; One of 

  the glaring "leaks" in the Windows Forms abstraction is the absence of the 

  Win32 ScrollWindow() call. 

  </li>
<li><strong>GDI</strong>.&nbsp; 

  The button is actually drawn using graphics primitives from GDI.&nbsp; It 

  doesn't just magically appear.&nbsp; It needs to be drawn using things like 

  DrawRect, fonts and colors.

  </li>
<li><strong>Pixels</strong>.&nbsp; 

  GDI contains primitives like DrawLine, but these are implemented in terms of 

  pixels.&nbsp; Graphics primitives are actually not quite so primitive.&nbsp; 

  If you think line drawing is easy, look up <a href="http://www.google.com/search?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=bresenham&amp;spell=1">Bresenham</a>.

  </li>
<li><strong>Video 

  Card</strong>.&nbsp; The pixels are actually an abstraction presented&nbsp;by 

  a video card.

  </li>
<li><strong>Monitor</strong>.&nbsp; 

  The monitor presents the illusion that all those pixels are organized into 

  pictures and images. 

  </li>
<li><strong>Light</strong>.&nbsp; 

  I stop whenever I get to Physics or Chemistry.&nbsp; For my purposes, light is 

  real, not an abstraction.</li>
</ol>

<p><strong><span>Architecture of 

the Vault Client:</span></strong></p>

<ol type="1" start="22">

  <li><strong>VaultClientPresentationLib</strong>.&nbsp; 

  We wrote this layer as part of Vault.&nbsp; It contains all the windows and 

  dialog boxes necessary to create the Vault GUI client. 

  </li>
<li><strong>VaultClientOperationsLib</strong>.&nbsp; 

  This layer is a big part of Vault.&nbsp; It contains basic non-GUI primitives 

  which are necessary to write a Vault client.&nbsp; Create an instance of the 

  ClientInstance class.&nbsp; The methods on this class will communicate with 

  the Vault server and simultaneously keep your local working folder updated. 

  </li>
<li><strong>VaultClientNetLib</strong>.&nbsp; 

  The previous layer actually calls VaultClientNetLib to communicate with the 

  Vault server.&nbsp; This layer is fairly thin.&nbsp; It is mostly a wrapper 

  around the Proxy Class. 

  </li>
<li><strong>Proxy 

  Class</strong>.&nbsp; This important layer is generated by Visual Studio 

  .NET.&nbsp; It presents the illusion that&nbsp;the XML Web Service on the 

  Vault server is actually a C# class. 

  </li>
<li><strong>SOAP</strong>.&nbsp; 

  When a call is made through the proxy class, the parameters for that call are 

  bundled up in <a href="http://msdn.microsoft.com/library/default.asp?url=/nhp/Default.asp?contentid=28000523">SOAP</a> 

  format.&nbsp; This format presents the concept of a method invocation message. 



  </li>
<li><strong>XML</strong>.&nbsp; 

  SOAP is built on XML, a syntax framework for representing data. 

  </li>
<li><strong>HTTP</strong>.&nbsp; 

  The SOAP message is transported to the server over <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP</a>, the 

  networking protocol on which the Web is built. 

  </li>
<li><strong>DNS</strong>.&nbsp; 

  The Vault user types the <em>name</em> of the server, but that name isn't 

  really useful.&nbsp; It has to be converted to an IP address before real 

  network communication can take place.&nbsp; The Domain Name System is used to 

  look behind the abstract name and get the actual machine address. 

  </li>
<li><strong>SSL</strong>.&nbsp; 

  The Secure Sockets Layer offers the illusion that communication over the 

  Internet can be private.&nbsp; This layer tries to look just like a regular 

  socket, except all of the data is encrypted as it passes through to/from the 

  socket itself. 

  </li>
<li><strong>Sockets</strong>.&nbsp; 

  This layer is a great abstraction.&nbsp; Sockets present us with the illusion 

  of connections and the ability to send and receive data between endpoints. 

  </li>
<li><strong>TCP</strong>.&nbsp; 

  The basic illusion of TCP is the idea that packets of data will arrive and in 

  fact, will arrive in the order they were sent. 

  </li>
<li><strong>IP</strong>.&nbsp; 

  TCP is built on IP, which is even lower level network protocol.&nbsp; At this 

  layer, packets may or may not actually arrive, and they may arrive in a 

  different order than how they were sent. 

  </li>
<li><strong>Ethernet</strong>.&nbsp; 

  The&nbsp;IP packets are carried on a cat5 wire sticking out the back of my 

  computer. 

  </li>
<li><strong>Radio</strong>.&nbsp; 

  The Internet connection at my home is a <a href="http://www.prairieinet.com/">wireless</a> antenna pointed at the top of 

  a grain elevator eight miles away.&nbsp; So right now, the important code 

  change I am trying to checkin is a bunch of radio signals which represent 

  packets that may or may not arrive, but they are flying through the air, 25 

  feet above a corn field.</li>
</ol>

<p><strong><span>Architecture of 

the Vault Server:</span></strong></p>

<ol type="1" start="36">

  <li><strong>VaultService.asmx</strong>.&nbsp; 

  The Vault server is an XML Web Service.&nbsp; This allows us to think of our 

  server as a collection of methods which will invoked in an "RPC-like" 

  fashion. 

  </li>
<li><strong>ASP.NET</strong>.&nbsp;&nbsp;The 

  illusion of XML Web Services is actually provided by ASP.NET. 

  </li>
<li><strong>VaultServiceSQL</strong>.&nbsp; 

  This library provides a wrapper which insulates the rest of the server from 

  having to know anything about SQL. 

  </li>
<li><strong>Stored 

  Procs</strong>.&nbsp; This layer is a collection of stored procedures running 

  inside SQL Server. 

  </li>
<li><strong>SQL</strong>.&nbsp; 

  The SQL language is an enormous abstraction.&nbsp; It presents concepts like 

  tables, rows and indices, as well as atomic transactions. 

  </li>
<li><strong>IO 

  calls</strong>.&nbsp; Somewhere deep inside SQL Server 2000 is the place where 

  data is actually written to the disk file.&nbsp; They probably call the native 

  Win32 IO calls. 

  </li>
<li><strong>NTFS</strong>.&nbsp; 

  The filesystem is a very important abstraction.&nbsp; It presents the concept 

  of files and folders, as well as permissions and attributes. 

  </li>
<li><strong>Partitions</strong>.&nbsp; 

  The filesystem exists on a "partition", which is a portion of the space on a 

  hard disk. 

  </li>
<li><strong>RAID 

  array</strong>.&nbsp; The RAID controller presents the illusion of one hard 

  disk&nbsp;when it is actually several. 

  </li>
<li><strong>Hard 

  disk</strong>.&nbsp; In practical terms, this was the goal of the checkin all 

  along.&nbsp; My bits are finally stored in my hard disk.&nbsp; But the disk 

  itself is actually an abstraction... 

  </li>
<li><strong>Platters</strong>.&nbsp; 

  The term "hard disk" sounds singular, but hard disks today usually have 

  several platters inside.&nbsp; These platters are the magnetic media where the 

  data actually resides.</li>
</ol>

<p>So there you have it -- 46 layers of abstraction which are all involved when 

I try to checkin my code.&nbsp; That means there are&nbsp;46 layers in which 

something might go wrong.</p>

<p>Actually the truth is that several of&nbsp;these abstractions are almost 

perfect.&nbsp; For example, I've actually never had to worry about the layer 

between <strong>Assembly</strong> and <strong>Microcode</strong>.&nbsp; As far 

as I am concerned, <strong>Assembly</strong> is an abstraction that always Just 

Works.</p>

<p>But it would be terribly wrong to ignore all those layers.&nbsp; Yes, 

SourceGear's implementation of Vault required us to only write the code for a 

few of the layers above.&nbsp; However, when it's time for QA and Tech Support, 

all 46 layers are fully in play.&nbsp; Stuff Happens.&nbsp; When a customer has 

a problem with Vault, the actual problem could be almost anywhere.&nbsp; We have 

to figure out what's gone wrong, even if it's in one of the layers we didn't 

create.&nbsp; Ask our tech support team how often layer 29 causes trouble. :-) 

</p>

<p><span face="Arial,Helvetica,sansserif" size="5"><strong>How to Kill Your 

Project</strong></span></p>

<p>When you build software, you're going to end up making a lot of decisions 

about abstractions:</p>

<ul>

  <li>Which abstractions do you want to build on? 

  </li>
<li>Where will you get the implementations of those abstractions (platforms, 

  libraries, components)? 

  </li>
<li>How trustworthy are those implementations?</li>
</ul>

<p>You have lots of alternatives.&nbsp; For example, you can often make a 

tradeoff by choosing to work at a lower level of abstraction.&nbsp; By doing so, 

your development process will move more slowly, but more of the risks will be 

under your control.&nbsp; For example, if I had a really small magnet and really 

fine motor control skills, I could skip layers 1 through 45, drive to my office 

and modify those platters myself.&nbsp; :-)&nbsp; </p>

<p>The stakes are higher than you might think.&nbsp; You can kill your project 

by making the wrong decisions about abstractions.&nbsp; Do you remember the word 

processor called WriteNow?&nbsp; This product was my favorite word processor 

back when I was a Macintosh fanatic.&nbsp;&nbsp;WriteNow was really fast and had 

just the right mix of features.</p>

<p>Today, WriteNow is <a href="http://www.macease.com/writenow-latest_info.html">dead</a> because 

somebody got burned by the decisions they made regarding abstractions.&nbsp; You 

see, WriteNow was really fast because it was written in 68000 assembly 

language.&nbsp; When Apple moved the Macintosh product line to the PowerPC, 

WriteNow had nowhere to go.</p>

<p>These choices are hard, and learning from your mistakes is an excellent (but 

painful) way to learn.&nbsp; But over the years, I've gathered the following 

guidelines which help me make abstraction-related decisions:</p><p><span face="Arial,Helvetica,sansserif" size="4"><span face="Arial,Helvetica,sansserif" size="4">Consider your context.</span></span></p>

<blockquote dir="ltr">

  <p><span face="Times New Roman,Times,serif" size="3">Developing a server 

  operating system is different from developing an web-based HR application so 

  employees can check their vacation days.&nbsp; There is no formula which works 

  well for all kinds of projects.&nbsp; You need to understand what kinds of 

  risks are appropriate for the kind of software you are trying to 

  build.</span></p>

  <p><span face="Times New Roman" size="3">As a general rule, developers of 

  internal corporate applications tend to use more third party components than 

  ISVs.&nbsp; If you're writing code for the IT department of a company whose 

  primary business is not software, then your salary is an expense, not an 

  investment.&nbsp; Your employer wants you to get the app done FAST, because it 

  costs less to get it done that way.&nbsp; Corporate IT developers want every 

  decent abstraction they can get.</span></p>

  <p><span face="Times New Roman" size="3">ISVs like SourceGear face a different 

  set of problems.&nbsp; If a third-party component brings even a 

  minor&nbsp;loss of quality to the app, it can severely affect our sales as 

  prospective customers look at our competitors.&nbsp; But that same competition 

  is tugging you in the other direction, reminding you that time-to-market can 

  be critical.&nbsp; Using third-party apps may be the only way to get your 

  product to market within the window of opportunity, but the risks need to be 

  studied closely.</span></p>

  <p><span face="Times New Roman" size="3">The size of your company should affect 

  your choices as well.&nbsp; Nothing is more frustrating than being unable to 

  ship a product because of a bug that you can't fix because it's in a 

  third-party library.&nbsp; For a very small company, the financial damage of a 

  situation like this can be severe.&nbsp; These are the times when you wish you 

  had chosen to put more of your risks inside your own circle of 

  control.</span></p></blockquote>

<p>Place your trust carefully.</p>

<blockquote dir="ltr">

  <p><span face="Times New Roman,Times,serif">I recommend approaching third 

  party code with a great deal of suspicion.&nbsp; Never assume that an unknown 

  component or platform will Just Work.&nbsp; A little paranoia will probably 

  pay off later.</span></p>

  <p>When picking the pieces of your platform, as a general rule, "older is 

  better".&nbsp; You can walk with less worry on a path which has been well 

  trodden by many people for years.&nbsp;&nbsp;As an extremely 

  obvious&nbsp;example, C is old and mature enough to be a platform which will 

  yield very few surprises.</p>

  <p>Evaluating newer technologies is harder.&nbsp; Try to figure out who else 

  is using the abstraction successfully.&nbsp; Grab the technology and take it 

  for a test drive.&nbsp; In the end, you may not get enough evidence to lead to 

  a completely confident decision.&nbsp; If you really need the convenience 

  offered by the abstraction, you may have to jump out with a little 

faith.</p></blockquote>

<p><span face="Arial,Helvetica,sansserif" size="4">Learn to see through the 

abstractions.&nbsp; </span></p><blockquote dir="ltr"><span face="Arial" size="5">

  </span>
<p><span face="Arial" size="5"><span face="Times New Roman,Times,serif" size="3">The&nbsp;most important 

  point in this whole article is this:&nbsp; You need to understand what's going 

  on inside all your abstraction layers.&nbsp; Each abstraction presents an 

  illusion, but the best decisions happen when you can see <em>through</em> the 

  illusion.</span></span></p>

  <p><span face="Times New Roman" size="3">If you have a deep understanding of all 

  the technology abstractions that are involved with your software, then you 

  have two big advantages:</span></p>

  <blockquote dir="ltr">

    <p dir="ltr"><span face="Times New Roman" size="3">You 

    can quickly isolate problems.</span></p>

    <p dir="ltr"><span face="Times New Roman" size="3">You 

    can develop an intuition which will help you avoid those problems in the 

    first place.</span></p></blockquote>

  <p><span face="Times New Roman,Times,serif" size="3">The first point is fairly 

  obvious.&nbsp; Troubleshooting goes much better when you know what's going 

  on.&nbsp; Have you ever watched someone try to solve a problem in the presence 

  of several abstractions they didn't understand?&nbsp; They feel 

  helpless.&nbsp; Usually, they start making wild guesses about where the 

  problem could be.&nbsp; I call this "stab in the dark debugging".&nbsp; :-) 

  </span></p>

  <p><span face="Times New Roman" size="3">More importantly, if you can see 

  through most abstractions then you can develop an intuition to make much 

  better technology decisions.&nbsp; Choosing the right libraries and components 

  in your platform can prevent lots of problems before they ever 

  happen.</span></p>

  <p><span face="Times New Roman,Times,serif" size="3">Don't assume that this kind 

  of deep technical knowledge becomes less valuable as you climb the management 

  ladder.&nbsp; Understanding this stuff can be a huge advantage in many kinds 

  of decisions, right up to the most executive levels.&nbsp; I believe the 

  technical prowess of Bill Gates was a major reason why Microsoft beat every 

  competitor in the eighties and nineties, even though Bill probably wrote no 

  code, no specs, and no design documents.</span></p></blockquote>

<p><strong>Failures and Successes</strong></p>

<p>It wouldn't be fair to only mention the mistakes of others when I've made so 

many excellent and instructive mistakes of my own.&nbsp; :-)&nbsp; </p>

<p>My most recent blunders in this area happened when we built <a href="http://www.sourcegear.com/collab/">SourceOffSite Collab </a> on a pile of 

abstractions which was way too short.</p>

<ul>

  <li>We built our own implementation of the "server pages" concept because ASP 

  didn't meet our requirements <em>perfectly</em>.&nbsp; Collab includes its own 

  web server which processes pages we call "giglets".&nbsp; In between the &lt;% 

  and %&gt; we process JavaScript using the <a href="http://www.mozilla.org/js/spidermonkey/">Mozilla engine</a> which has 

  been modified with special Collab-specific hooks.&nbsp; In retrospect, we 

  should have found a way to work around the limitations of Microsoft's standard 

  dynamic page generation technology.<br>

  </li>
<li>We also implemented a complete system for XML-based procedure calls.&nbsp; 

  We&nbsp;rationalized this one&nbsp;because <a href="http://www.xmlrpc.com/">XML-RPC</a> and SOAP just weren't quite 

  <em>perfect</em> for our needs.&nbsp; Hindsight now brings us to the same 

  conclusion as above -- changing our requirements to fit the established 

  platforms would have been the wiser choice.</li>
</ul>

<p>Better decisions would have gotten SOS Collab to market sooner and we would 

have fewer code maintenance problems now.</p>

<p>Not all of our decisions went badly.&nbsp; We made a great choice when we 

decided to build Vault using .NET.</p>

<p>From the beginning, I hoped that .NET was "Java done right".&nbsp; I've used 

Java extensively, and I loved the productivity gains we got during the beginning 

and middle of the development cycle.&nbsp; But things got ugly at the end.&nbsp; 

All those layers of abstraction started contributing to our bug list.&nbsp; I've 

been involved in a couple of projects which completely failed because Java was 

chosen.&nbsp; <em>(Yes, this is merely my opinion, and yes, there were other 

factors in the failure of those projects.)</em></p>

<p>Given our bad experiences with Java, our decision to use .NET took a fair 

amount of courage.&nbsp; Early experiments looked promising, but we knew that we 

would have to wait for the endgame to really know if .NET could really be 

trusted all the way through.</p>

<p>As I write this, <a href="http://www.sourcegear.com/vault/">SourceGear Vault 

</a> 1.0 has been shipping for over two months.&nbsp; We have no regrets.&nbsp; 

For an abstraction pile as large as the one described above, it's remarkable 

that&nbsp;this product&nbsp;works at all.&nbsp; :-) </p>

<p>But the fact that it works <em>well</em> is nothing short of amazing.&nbsp; 

We have test applications which continuously try to abuse Vault in ways that are 

abusive and profane.&nbsp; If something goes wrong in <em>any</em> layer of 

abstraction, the whole test will come to a halt.&nbsp; But we can let these 

tests run for days at a time without any problems whatsoever.</p>

<p>This success stands as a testimony to how incredible .NET really is.&nbsp; We 

built a reasonably full-featured version control system in 14 months, and it 

works.&nbsp; Sure, we had some trouble.&nbsp; Layers 25, 37 and 40 didn't always 

behave like they should.&nbsp; But layer 11 was problem-free, quite unlike its 

Java counterpart.&nbsp; Considering the productivity gains we received, I never 

expected things to go so smoothly.</p>

<p><em>Note:&nbsp; In response to the controversy generated by this article, I 

posted some <a href="https://ericsink.com/Pile_Followups.html">followup 

remarks</a>.</em></p>

</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>