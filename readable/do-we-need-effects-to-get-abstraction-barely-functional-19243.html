<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Do we need effects to get abstraction? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Do we need effects to get abstraction? - linksfor.dev(s)"/>
    <meta property="article:author" content="Eric Torreborre"/>
    <meta property="og:description" content="Sandy Maguire gave an excellent talk on his latest library: polysemy. I highly encourage you to watch it because Sandy also presents other&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/barely-functional/do-we-need-effects-to-get-abstraction-7d5dc0edfbef"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Do we need effects to get abstraction?</title>
<div class="readable">
        <h1>Do we need effects to get abstraction?</h1>
            <div>by Eric Torreborre</div>
            <div>Reading time: 9-12 minutes</div>
        <div>Posted here: 03 May 2019</div>
        <p><a href="https://medium.com/barely-functional/do-we-need-effects-to-get-abstraction-7d5dc0edfbef">https://medium.com/barely-functional/do-we-need-effects-to-get-abstraction-7d5dc0edfbef</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@etorreborre_99063?source=post_page-----7d5dc0edfbef----------------------"><img alt="Eric Torreborre" src="https://miro.medium.com/fit/c/96/96/1*1AGYyTcDpK_mrTcfKPtWgg.jpeg" width="48" height="48"></a></p></div></div></div></div><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*Fg8jJ2hbTEGiXtiNyggy2A.jpeg?q=20" width="800" height="450" role="presentation"></p><p><img width="800" height="450" role="presentation" src="https://miro.medium.com/max/800/1*Fg8jJ2hbTEGiXtiNyggy2A.jpeg"></p></div></div></div></div></figure><p id="4f7f" data-selectable-paragraph="">Sandy Maguire gave an <a href="https://www.youtube.com/watch?v=-dHFOjcK6pA" target="_blank" rel="noopener nofollow">excellent talk on his latest library: polysemy</a>. I highly encourage you to watch it because Sandy also presents other libraries: <code>freer</code>, <code>fused-effect</code>, and how they differ from <code>polysemy</code> in a quest for expressivity, performance and boilerplate-removal.</p><p id="23be" data-selectable-paragraph="">While I am very impressed by the recent improvements in effects libraries I am still thinking “do we need any of this?”. If I scroll back to Sandy’s original motivations for using effects I hear that he was working a system which was a<code>Big ball o' IO spaghetti</code>, <code>impossible to test</code>. His conclusion is that we need to write programs at a high-level (he says in a <code>domain-specific language, a DSL</code>) and run a series of transformations to lower-level DSLs. Thus: effects. I say: maybe not!</p><p id="9654" data-selectable-paragraph="">I fully endorse the intention though. If we can describe our applications / services at different levels of abstraction we get fantastic abilities to understand them, evolve them, test them. And Sandy gives a great example in his presentation, which is more fully developed in <a href="https://reasonablypolymorphic.com/blog/freer-monads/" target="_blank" rel="noopener nofollow">one of his blog posts</a> on freer monads:</p><blockquote><p id="a2c0" data-selectable-paragraph="">write a program that fetches a CSV file from FTP, decrypts it, streams its contents to an external pipeline, and tracks its stats in Redis.</p></blockquote><p id="35d1" data-selectable-paragraph="">And the program should look like this:</p><figure><div></div></figure><p id="6337" data-selectable-paragraph="">This is indeed very high-level, we really get the “heart” of the application which is to repeatedly read records and process them. Then with a series of interpreters we can derive the full program which will communicate with FTP, decrypt, and so on:</p><figure><div></div></figure><p id="5cb3" data-selectable-paragraph="">Pretty cool but <a target="_blank" rel="noopener" href="https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501">I am still unconvinced that we need effect libraries to do any of this</a>.</p><p id="1223" data-selectable-paragraph="">What we want is some way to:</p><ul><li id="d4f6" data-selectable-paragraph="">separate an abstract interface from its implementation(s)</li><li id="ebf1" data-selectable-paragraph="">connect the two</li></ul><p id="6666" data-selectable-paragraph="">This is not a very new idea because it is a the heart of many modularity efforts. Abstract Data Types are an example of that. They were pioneered by Barbara Liskov (yes from the “<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener nofollow">Liskov substitution principle</a>”) and Stephen Zilles in 1974 and fully adopted in the ADA programming language where they enable the programmer to hide details like memory layout and management. An Abstract Data Type provides the representation of some data as a set of operations (its “interface”) while keeping an internal representation (its “implementation”) hidden. This is not very far from writing: it provides a “DSL” and an “interpreter”.</p><p id="75db" data-selectable-paragraph="">So I thought: “can we create the same application without effects?”. In particular can I use simple “records-of-functions” in Haskell +my <code><a href="http://github.com/etorreborre/registry" target="_blank" rel="noopener nofollow">registry</a></code> library to get to the same level of abstraction and ease of testing?</p><p id="8333" data-selectable-paragraph="">First surprise: I can’t do it! Indeed the <code>Input</code> effect is quite peculiar. It provides a <code>Maybe i</code> out of an input source. If you want to declare and implement it as a separate module you either have to:</p><ul><li id="8866" data-selectable-paragraph="">create a <em>stateful module</em> where you track the current flow of inputs. This requires some <code>IO</code> and the FP crowd might frown upon that (I don’t)</li><li id="5a42" data-selectable-paragraph="">“outsource” the state management to the rest of the program. This is what is done with the effects approach where the meaning of the <strong>whole program</strong> is made (functionally) stateful when using the <code>csvInput</code> interpreter</li></ul><p id="1ca6" data-selectable-paragraph="">This is an important realization. With effects you interpret <em>full programs</em> giving them specific meanings whereas with simple “records of functions” you “inject” a specific behaviour with only a “local” meaning. That’s why approaches like effects or <a href="http://okmij.org/ftp/tagless-final/index.html" target="_blank" rel="noopener nofollow">finally tagless</a> are still valuable for some situations like <a href="https://koka-lang.github.io/koka/doc/kokaspec.html#sec-a-primer-on-effect-handlers" target="_blank" rel="noopener nofollow">non-deterministic effects</a> which are almost equivalent to full program rewrite.</p><p id="5498" data-selectable-paragraph="">Is this a blocker? I don’t think so. This capacity to “yield elements on demand” is at the core of any streaming library and Sandy’s application is fundamentally a streaming service. So having a component which, as its interface, returns a <code>Stream a</code> is almost as good, if not better than returning <code>Maybe a</code>. You can indeed argue that it is even better because you don’t even have to recurse in the <code>ingest</code> function. You can have the following <code>main</code>:</p><figure><div></div></figure><p id="6050" data-selectable-paragraph="">The top-level application is fairly similar to Sandy’s example and is structured as:</p><ul><li id="67e8" data-selectable-paragraph="">a stream producer: <code>readInput</code></li><li id="83ba" data-selectable-paragraph="">a stream transformer: <code>saveOutputs</code></li><li id="4768" data-selectable-paragraph="">a stream consumer: <code>saveStats</code></li></ul><p id="a0d7" data-selectable-paragraph="">It keeps all the good properties of the original example:</p><ul><li id="5a3d" data-selectable-paragraph="">it is modular in the sense that the way we output elements is fully decoupled from the way we read them for example</li><li id="4f40" data-selectable-paragraph="">the details of how we perform the operations are fully encapsulated in each component: <code>input</code>, <code>output</code> and <code>stats</code></li></ul><p id="921c" data-selectable-paragraph="">But Sandy has more challenges for us! First challenge: provide records from a <code>FileProvider</code> which could either be a local file or a file coming from a FTP server. Second challenge: decrypt the file without having to modify the <code>FileProvider</code> component. Third challenge: batch the outputs to reduce the number of API calls.</p><p id="40f9" data-selectable-paragraph="">This one is not hard. If we have a component describing the reading of inputs with the following interface:</p><figure><div></div></figure><p id="ffa4" data-selectable-paragraph="">We can provide a “constructor” which will create this component with the help of a <code>FileProvider</code></p><figure><div></div></figure><p id="30ae" data-selectable-paragraph="">Here we don’t know where the file comes from but we do the job of parsing it as a CSV file and returning a stream. The <code>FileProvider</code> itself can be implemented as:</p><figure><div></div></figure><p id="54dd" data-selectable-paragraph="">As you can see we have 2 implementations here, one for FTP, using some <code>Ftp</code> capability and another one which would just read files from disk. This almost solves the first challenge: have different layers of abstraction and possibly different implementations at each level. What is missing is a way to select a specific set of implementations like Sandy does with all the <code>runXXX</code> interpreters in his example. This is provided by the <code>registry</code> library:</p><figure><div></div></figure><p id="f84f" data-selectable-paragraph="">Here we have the application, <code>App</code>, containing the top-level components and a <code>registry</code> describing all the exact constructors needed to build the application (I will not explain here the role of the various operators like <code>funTo </code>and the type applications, please head to the <code><a href="https://github.com/etorreborre/registry/blob/master/README.md" target="_blank" rel="noopener nofollow">registry</a></code><a href="https://github.com/etorreborre/registry/blob/master/README.md" target="_blank" rel="noopener nofollow"> documentation</a> if you want to know more).</p><p id="2a9b" data-selectable-paragraph="">How can we run the application with a<code>LocalFileProvider</code> instead? Easy, you “override” the registry with the <code>newLocalFileProvider</code> constructor:</p><figure><div></div></figure><p id="6165" data-selectable-paragraph="">The program doesn’t change, we are just running it with a different set of implementations.</p><h2 id="2009" data-selectable-paragraph="">Aside on testing</h2><p id="a497" data-selectable-paragraph="">This fully solves the “testing challenge” because we have an easy way to “tweak” the behaviour of the application under test. By <strong>just changing one line</strong>. On the other hand with effects and interpreters you have to rewrite the full <code>runM . runRedis . runHttp ...</code> function spanning 10 lines to just change one thing. You could even do more crazy things like providing a working <code>Http</code> component for posting outputs and a failing one for posting statistic (2 different instances for the same type).</p><p id="7e11" data-selectable-paragraph="">This is seemingly one of the big advantages of effects. Being able to “intercept” a given effect to give it a slightly different meaning:</p><figure><div></div></figure><p id="cf37" data-selectable-paragraph="">With components and constructors this can be done by having a “decorator”, a function taking an existing component and adding some functionality on top of it:</p><figure><div></div></figure><p id="d01b" data-selectable-paragraph="">With an existing <code>FileProvider</code>, which we tag as <code>clear</code> we can make another <code>FileProvider</code>, this time providing decrypted files thanks to a new dependency, the <code>Encryption</code> component. And the registry library takes care of wiring everything up:</p><figure><div></div></figure><p id="9c84" data-selectable-paragraph="">When you want to build an <code>App</code> using the <code>registry</code>, the library will follow the types and see that:</p><ul><li id="3732" data-selectable-paragraph="">a <code>FileProvider</code> is required</li><li id="0cae" data-selectable-paragraph="">it can be built with the <code>newDecryptedFileProvider</code></li><li id="adde" data-selectable-paragraph="">this requires a tagged <code>clear</code> <code>FileProvider</code> which we get with <code>newFtpFileProvider</code>, but also the<code>Ftp</code> and <code>Encryption</code> components which we can build with their respective constructor functions</li></ul><p id="1a7a" data-selectable-paragraph="">In summary it is possible to take existing components and “decorate” them or “intercept their interpretation” to create enhanced versions of those components.</p><p id="7cc7" data-selectable-paragraph="">This is also a fantastic example of the power of effects. Someone gives you an additional technical constraint and you should be able to implement it without disrupting the majority of your program. With effects we create a function with the following signature:</p><pre><span id="6646" data-selectable-paragraph="">batch<br>  :: Int<br>  -&gt; Eff (Output [i] ': r) a<br>  -&gt; Eff (Output [i] ': r) a</span></pre><p id="b18d" data-selectable-paragraph="">Once again we “intercept” an existing effect and regroup the elements so that we send 500 at the time and not one by one. Note that the implementation Sandy provides is probably not totally suited for production since we wait until a batch is complete before posting it. In practice we would also post records after some delay, even if the batch is not complete. This would make the signature of <code>batch</code> function slightly more complex (requiring an additional <code>Time</code> effect in the stack).</p><p id="8949" data-selectable-paragraph="">Back to our components we have the following interface for the <code>Output</code> component:</p><figure><div></div></figure><p id="e718" data-selectable-paragraph="">The <code>Output</code> component is essentially a “stream transformer” and the <code>newHttpOutput</code> constructor uses an <code>Http</code> component to post the records. Here again we can apply the “decorator” pattern and “decorate” that component to create a new one where elements are being batched before being fed to the original one:</p><figure><div></div></figure><p id="1940" data-selectable-paragraph=""><code>batchesOf</code> uses some combinators from the fantastic <code><a href="https://hackage.haskell.org/package/streaming" target="_blank" rel="noopener nofollow">streaming</a></code><a href="https://hackage.haskell.org/package/streaming" target="_blank" rel="noopener nofollow"> library</a> to batch records and we also “unbatch” elements after use because we still need to return a <code>Stream (Of a) m ()</code> (don’t worry this is all fused at runtime).</p><p id="6fa6" data-selectable-paragraph="">I am still amazed by all the hard work and progress made on effect libraries but I worry that the excitement of novelty hides what is really important when building applications:</p><ul><li id="00e3" data-selectable-paragraph="">a proper distinction between interface and implementation</li><li id="3d23" data-selectable-paragraph="">an easy to wire and replace components</li></ul><p id="780f" data-selectable-paragraph="">There many ways to get there with different trade-offs: effects, records of functions (or the <a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html" target="_blank" rel="noopener nofollow">Handle pattern</a>), typeclasses and monad transformers.</p><p id="282e" data-selectable-paragraph="">I hope that this blog post shows you that we don’t necessarily need <a href="https://chrispenner.ca/posts/mock-effects-with-data-kinds" target="_blank" rel="noopener nofollow">fancy type-level techniques</a> to build modular, testable applications with the right levels of abstraction.</p><p id="f90b" data-selectable-paragraph=""><em>Update: the code for this post is available at </em><a href="https://github.com/etorreborre/ingestion" target="_blank" rel="noopener nofollow"><em>https://github.com/etorreborre/ingestion</em></a><em> if you want to play with it</em></p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>