<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A First Look at Java Inline Classes  - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A First Look at Java Inline Classes  - linksfor.dev(s)"/>
    <meta property="article:author" content="Ben Evans&#xA;                &#xA;            &#xA;        Follow"/>
    <meta property="og:description" content="Java currently supports only two types of value: primitives and object references. Project Valhalla extends this by introducing inline classes which are a new form of type that exhibit some behaviors of both. These new types open the door to better alignment with modern CPUs and considerable potential performance improvements for Java applications."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.infoq.com/articles/inline-classes-java/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A First Look at Java Inline Classes </title>
<div class="readable">
        <h1>A First Look at Java Inline Classes </h1>
            <div>by Ben Evans&#xA;                &#xA;            &#xA;        Follow</div>
            <div>Reading time: 20-25 minutes</div>
        <div>Posted here: 24 Oct 2019</div>
        <p><a href="https://www.infoq.com/articles/inline-classes-java/">https://www.infoq.com/articles/inline-classes-java/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
							
								<div>
									<h3>Key Takeaways</h3>
									<ul>
	<li>Project Valhalla is developing inline classes to improve affinity of Java programs to modern hardware</li>
	<li>Inline classes enable developers to write types that behave more like Java's inbuilt primitive types</li>
	<li>Instances of inline classes do not have object identity, which opens up a number of optimization opportunities</li>
	<li>The arrival of inline classes reopens the debate around Java's generics and type erasure</li>
	<li>Although promising, this is still a work in progress and not production ready yet</li>
</ul>

									
								</div>
							
							
								
								<p>In this article, I'll introduce <em>inline </em>classes. This feature is the evolution of what were previously referred to as "value types." The exploration and research of this feature is still ongoing and is a major work stream within Project Valhalla, which has already been <a href="https://www.infoq.com/news/2019/07/valhalla-openjdk-lw2-released/">covered by InfoQ</a> and in <a href="https://www.oracle.com/a/ocom/docs/corporate/java-magazine-nov-dec-2018.pdf">Oracle's Java magazine</a>.</p>

<h2>Why Inline Classes?</h2>

<p>The goal of inline classes is to improve the affinity of Java programs to modern hardware. This is to be achieved by revisiting a very fundamental part of the Java platform — the model of Java's data values.</p>

<p>From the very first versions of Java until the present day, Java has had only two types of values: primitive types and object references. This model is extremely simple and easy for developers to understand, but can have performance trade-offs. For example, dealing with arrays of objects involves unavoidable indirections and this can result in processor cache misses.</p>


								
								
									








								
								<p>Many programmers who care about performance would like the ability to work with data that utilizes memory more efficiently. Better layout means fewer indirections, which means fewer cache misses and higher performance.</p>

<p>Another major area of interest is the idea of removing the overhead of needing a full object header for each data composite — <em>flattening </em>the data.</p>

<p>As it stands, each object in Java's heap has a metadata header as well as the actual field content. In Hotspot, this header is essentially two machine words — <em>mark </em>and <em>klass</em>. First the mark word, which contains metadata that is specific to this specific object instance.</p>


								
								
									
								
								<p><img _href="img://1InfoQIllus_v1.001-1570789536495.jpg" alt="" data-src="articles/inline-classes-java/en/resources/1InfoQIllus_v1.001-1570789536495.jpg" src="https://res.infoq.com/articles/inline-classes-java/en/resources/1InfoQIllus_v1.001-1570789536495.jpg" rel="share"></p>

<p>The second word of metadata is known as the <em>klass </em>word, which is a pointer to metadata (stored in the Metaspace area of memory) that is shared with all other instances of the same class. This klass pointer is crucial to understanding how the runtime implements certain language features, such as virtual method lookup.</p>

<p>However, for this discussion of inline classes, the data held in the <em>mark word</em> is especially important, as it is inherently tied to the concept of identity of Java objects.</p>

<h2>Inline Classes and Object Identity</h2>

<p>Recall that in Java, two object instances are not considered equal just because they have the same values for all their fields. Java uses the == operator to determine whether two references are pointing at the same memory location, and objects are not considered identical if they are stored separately in memory.</p>

<p><small><strong>NOTE: This notion of identity is linked with the ability to lock a Java object. In fact the <em>mark word</em> is used to store the object monitor (among other things).</strong></small></p>

<p>For inline classes, however, we want the composites to have semantics that are essentially those of primitive types. In that case the only thing that matters for equality is the bit pattern of the data, not where in memory that pattern appears.</p>

<p>Therefore, by removing the object header, we also remove the composite's unique identity. This change frees the runtime to make significant optimizations in layout, calling convention, compilation, and allocation.</p>

<p><small><strong>NOTE: The removal also has other implications for the design of inline classes. For example they cannot be synchronized upon (because they have neither a unique identity nor anywhere to store the monitor).</strong></small></p>

<p>It is important to realize that Valhalla is a project that goes all the way down through the language and VM and eventually reaches the metal. This means that it might look just like one new construct (<tt>inline class</tt>) to the programmer, but there are so many layers that the feature depends upon.</p>

<p><small><strong>NOTE: Inline classes are not the same as the forthcoming records feature. A Java record is just a regular class that is declared with reduced boilerplate and has some standardized, compiler generated methods. Inline classes, on the other hand, are a fundamentally new concept within the JVM, and change Java's model of memory in fundamental ways.</strong></small></p>

<p>The current prototype of inline classes (referred to as LW2) is functional, but it is still at a very, very early stage. Its target audience is advanced developers, library authors, and toolmakers.</p>

<h2>Working with the LW2 Prototype</h2>

<p>Let's dive into some examples of what can be done with inline classes in their current state in LW2. I will be able to show the effects of inline classes using low-level techniques (such as bytecode and heap histograms). Future prototypes will add more user-visible and higher-level aspects, but they haven't been completed yet, so I will have to stick to the low-level.</p>

<p>To obtain a build of OpenJDK that supports LW2, the easiest option is to download it from <a href="http://jdk.java.net/valhalla/">here</a> — Linux, Windows and Mac builds are available. Alternatively, experienced open-source developers can build their own binary from scratch.</p>

<p>Once the prototype is downloaded and installed, we can develop some inline classes using it.</p>

<p>To make an inline class in LW2, a class declaration is tagged with the inline keyword.</p>

<p>The rules for inline classes (for now — some of these may be relaxed or changed in future prototypes) are:</p>

<ul>
	<li>Interfaces, annotation types, enums cannot be inline classes</li>
	<li>Top level, inner, nested, local classes may be inline classes</li>
	<li>Inline classes are not nullable and instead have a default value</li>
	<li>Inline classes may declare inner, nested, local types</li>
	<li>Inline classes are implicitly <tt>final </tt>so cannot be <tt>abstract</tt></li>
	<li>Inline classes implicitly extend <tt>java.lang.Object</tt> (like enums, annotations, and interfaces)</li>
	<li>Inline classes may explicitly implement regular interfaces</li>
	<li>All instance fields of an inline class are implicitly final</li>
	<li>Inline classes may not declare instance fields of their own type</li>
	<li><tt>javac </tt>automatically generates <tt>hashCode(), equals(), and toString()</tt></li>
	<li><tt>javac </tt>does not allow <tt>clone(), finalize(), wait(),</tt> or <tt>notify() </tt>on inline classes</li>
</ul>

<p>Let's look at our first example of an inline class, and see what an implementation of a type like Optional would look like as an inline class. To reduce indirection and for clarity of demonstration, we are going to write a version of an optional type that holds a primitive value, similar to the type <tt>java.util.OptionalInt</tt> in the standard JDK class library:</p>

<pre><code><span>public</span> inline <span>class</span> <span>OptionalInt</span> <span>{</span>
    <span>private</span> <span>boolean</span> isPresent<span>;</span>
    <span>private</span> <span>int</span> v<span>;</span>

    <span>private</span> <span>OptionalInt</span><span>(</span><span>int</span> val<span>)</span> <span>{</span>
        v <span>=</span> val<span>;</span>
        isPresent <span>=</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> OptionalInt <span>empty</span><span>(</span><span>)</span> <span>{</span>
        
        <span>return</span> OptionalInt<span>.</span><span>default</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> OptionalInt <span>of</span><span>(</span><span>int</span> val<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>OptionalInt</span><span>(</span>val<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAsInt</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span>isPresent<span>)</span>
            <span>throw</span> <span>new</span> <span>NoSuchElementException</span><span>(</span><span>"No value present"</span><span>)</span><span>;</span>
        <span>return</span> v<span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>isPresent</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> isPresent<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>ifPresent</span><span>(</span>IntConsumer consumer<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>isPresent<span>)</span>
            consumer<span>.</span><span>accept</span><span>(</span>v<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>orElse</span><span>(</span><span>int</span> other<span>)</span> <span>{</span>
        <span>return</span> isPresent <span>?</span> v <span>:</span> other<span>;</span>
    <span>}</span>

    @Override
    <span>public</span> String <span>toString</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> isPresent
                <span>?</span> String<span>.</span><span>format</span><span>(</span><span>"OptionalInt[%s]"</span><span>,</span> v<span>)</span>
                <span>:</span> <span>"OptionalInt.empty"</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre>

<p>This should compile using the current LW2 version of javac. To see the effects of the new inline classes technology, we need to look at bytecode, using the javap tool that can be invoked like this:</p>

<pre><code>$ javap <span>-</span>c <span>-</span>p infoq<span>/</span>OptionalInt<span>.</span><span>class</span></code></pre>

<p>Disassembling our OptionalInt type, we see some interesting aspects of the inline class in the bytecode:</p>

<pre><code><span>public</span> <span>final</span> value <span>class</span> <span>infoq<span>.</span>OptionalInt</span> <span>{</span>
  <span>private</span> <span>final</span> <span>boolean</span> isPresent<span>;</span>

  <span>private</span> <span>final</span> <span>int</span> v<span>;</span></code></pre>

<p>The class has a new modifier value that is left over from an earlier prototype where the feature was still called value types. The class and all instance fields have been made final even though that wasn't specified in the source code. Next, let's look at the object construction methods:</p>

<pre><code><span>public</span> <span>static</span> infoq<span>.</span>OptionalInt <span>empty</span><span>(</span><span>)</span><span>;</span>
    Code<span>:</span>
       <span>0</span><span>:</span> defaultvalue  #<span>1</span>                  
       <span>3</span><span>:</span> areturn

  <span>public</span> <span>static</span> infoq<span>.</span>OptionalInt <span>of</span><span>(</span><span>int</span><span>)</span><span>;</span>
    Code<span>:</span>
       <span>0</span><span>:</span> iload_0
       <span>1</span><span>:</span> invokestatic  #<span>11</span>                 
       <span>4</span><span>:</span> areturn

  <span>private</span> <span>static</span> infoq<span>.</span>OptionalInt infoq<span>.</span><span>OptionalInt</span><span>(</span><span>int</span><span>)</span><span>;</span>
    Code<span>:</span>
       <span>0</span><span>:</span> defaultvalue  #<span>1</span>                  
       <span>3</span><span>:</span> astore_1
       <span>4</span><span>:</span> iload_0
       <span>5</span><span>:</span> aload_1
       <span>6</span><span>:</span> swap
       <span>7</span><span>:</span> withfield     #<span>3</span>                  
      <span>10</span><span>:</span> astore_1
      <span>11</span><span>:</span> iconst_1
      <span>12</span><span>:</span> aload_1
      <span>13</span><span>:</span> swap
      <span>14</span><span>:</span> withfield     #<span>7</span>                  
      <span>17</span><span>:</span> astore_1
      <span>18</span><span>:</span> aload_1
      <span>19</span><span>:</span> areturn</code></pre>

<p>For a regular class, we would expect to see a compiled construction sequence like this simple factory method:</p>

<pre><code>  
  <span>public</span> <span>static</span> infoq<span>.</span>OptionalInt <span>of</span><span>(</span><span>int</span><span>)</span><span>;</span>
    Code<span>:</span>
       <span>0</span><span>:</span> <span>new</span>           #<span>5</span>  
       <span>3</span><span>:</span> dup
       <span>4</span><span>:</span> iload_0
       <span>5</span><span>:</span> invokespecial #<span>6</span>  
       <span>8</span><span>:</span> areturn</code></pre>

<p>The difference in the two bytecode sequences is clear — inline classes do not use the new opcode. Instead, we encounter two brand new bytecodes that are specific to inline classes — <tt>defaultvalue</tt> and <tt>withfield</tt>.</p>

<ul>
	<li><tt>defaultvalue </tt>is used to create new value instances</li>
	<li><tt>withfield </tt>is used instead of <tt>setfield</tt></li>
</ul>

<p><small><strong>NOTE: One of the consequences of this design is that the result of <tt>defaultvalue </tt>must, for every inline class, be a consistent and usable value of the type.</strong></small></p>

<p>It's worth noticing that the semantics of <tt>withfield </tt>is to replace the value instance on top of stack with a modified value with an updated field. This is slightly different from <tt>setfield </tt>(which consumes the object reference on the stack) because inline classes are always immutable and are not necessarily always represented as references.</p>

<p><img _href="img://1InfoQIllus_v1.002-1570789537474.jpg" alt="" data-src="articles/inline-classes-java/en/resources/1InfoQIllus_v1.002-1570789537474.jpg" src="https://res.infoq.com/articles/inline-classes-java/en/resources/1InfoQIllus_v1.002-1570789537474.jpg" rel="share"></p>

<p><img _href="img://1InfoQIllus_v1.003-1570789536079.jpg" alt="" data-src="articles/inline-classes-java/en/resources/1InfoQIllus_v1.003-1570789536079.jpg" src="https://res.infoq.com/articles/inline-classes-java/en/resources/1InfoQIllus_v1.003-1570789536079.jpg" rel="share"></p>

<p>To complete our first look at the bytecode, we notice that, among the other methods of the class are auto-generated implementations of <tt>hashCode()</tt> and <tt>equals()</tt> that use invokedynamic as a mechanism.</p>

<pre><code><span>public</span> <span>final</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span><span>;</span>
    Code<span>:</span>
       <span>0</span><span>:</span> aload_0
       <span>1</span><span>:</span> invokedynamic #<span>46</span><span>,</span>  <span>0</span>             
       <span>6</span><span>:</span> ireturn

  <span>public</span> <span>final</span> <span>boolean</span> <span>equals</span><span>(</span>java<span>.</span>lang<span>.</span>Object<span>)</span><span>;</span>
    Code<span>:</span>
       <span>0</span><span>:</span> aload_0
       <span>1</span><span>:</span> aload_1
       <span>2</span><span>:</span> invokedynamic #<span>50</span><span>,</span>  <span>0</span>             
       <span>7</span><span>:</span> ireturn</code></pre>

<p>&nbsp;In our case, we have explicitly provided an override of toString(), but this method would also usually be auto-generated for inline classes.</p>

<pre><code> <span>public</span> java<span>.</span>lang<span>.</span>String <span>toString</span><span>(</span><span>)</span><span>;</span>
    Code<span>:</span>
       <span>0</span><span>:</span> aload_0
       <span>1</span><span>:</span> getfield      #<span>7</span>                  
       <span>4</span><span>:</span> ifeq          <span>29</span>
       <span>7</span><span>:</span> ldc           #<span>28</span>                 
       <span>9</span><span>:</span> iconst_1
      <span>10</span><span>:</span> anewarray     #<span>30</span>                 
      <span>13</span><span>:</span> dup
      <span>14</span><span>:</span> iconst_0
      <span>15</span><span>:</span> aload_0
      <span>16</span><span>:</span> getfield      #<span>3</span>                  
      <span>19</span><span>:</span> invokestatic  #<span>32</span>                 
      <span>22</span><span>:</span> aastore
      <span>23</span><span>:</span> invokestatic  #<span>38</span>                 
      <span>26</span><span>:</span> <span>goto</span>          <span>31</span>
      <span>29</span><span>:</span> ldc           #<span>44</span>                 
      <span>31</span><span>:</span> areturn</code></pre>

<p>To drive our inline class, let's look at a small driver program contained in <tt>Main.java:</tt></p>

<pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span>String<span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span> MAX <span>=</span> 100_000_000<span>;</span>
        OptionalInt<span>[</span><span>]</span> opts <span>=</span> <span>new</span> <span>OptionalInt</span><span>[</span>MAX<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> MAX<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            opts<span>[</span>i<span>]</span> <span>=</span> OptionalInt<span>.</span><span>of</span><span>(</span>i<span>)</span><span>;</span>
            opts<span>[</span><span>++</span>i<span>]</span> <span>=</span> OptionalInt<span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>long</span> total <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> MAX<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            OptionalInt oi <span>=</span> opts<span>[</span>i<span>]</span><span>;</span>
            total <span>+=</span> oi<span>.</span><span>orElse</span><span>(</span><span>0</span><span>)</span><span>;</span>
        <span>}</span>
        <span>try</span> <span>{</span>
            Thread<span>.</span><span>sleep</span><span>(</span>60_000<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        System<span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Total: "</span><span>+</span> total<span>)</span><span>;</span>
    <span>}</span></code></pre>

<p>The bytecode for <code>Main</code> is not shown as it contains no surprises. In fact, it is the same (apart from package names) as the code that would be generated if Main used <code>java.util.OptionalInt</code> instead of our inline class version.</p>

<p>This is, of course, part of the point — to make inline classes minimally intrusive to mainstream Java programmers and provide their benefits without too much cognitive overhead.</p>

<h2>Heap Behaviour for inline classes</h2>

<p>Having noted the features of the compiled value class's bytecode, we can now execute Main and take a quick look at runtime behavior, starting with the contents of the heap.</p>

<pre><code>$ java infoq<span>.</span>Main</code></pre>

<p>Note that the thread delay at the end of the program is only there to allow us to have time to produce a heap histogram from the process.</p>

<p>We do this by running another tool in a separate window: <code>jmap -histo:live &lt;pid&gt;</code>, which produces results like this:</p>

<pre><code> num     #instances         #bytes  <span>class</span> <span>name</span> <span>(</span>module<span>)</span>
<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
   <span>1</span><span>:</span>             <span>1</span>      <span>800000016</span>  <span>[</span>Qinfoq<span>.</span>OptionalInt<span>;</span>
   <span>2</span><span>:</span>          <span>1687</span>          <span>97048</span>  <span>[</span><span>B</span> <span>(</span>java<span>.</span>base@<span>14</span><span>-</span>internal<span>)</span>
   <span>3</span><span>:</span>           <span>543</span>          <span>70448</span>  java<span>.</span>lang<span>.</span><span>Class</span> <span>(</span>java<span>.</span>base@<span>14</span><span>-</span>internal<span>)</span>
   <span>4</span><span>:</span>          <span>1619</span>          <span>51808</span>  java<span>.</span>util<span>.</span>HashMap$<span>Node</span> <span>(</span>java<span>.</span>base@<span>14</span><span>-</span>internal<span>)</span>
   <span>5</span><span>:</span>           <span>452</span>          <span>44600</span>  <span>[</span>Ljava<span>.</span>lang<span>.</span>Object<span>;</span> <span>(</span>java<span>.</span>base@<span>14</span><span>-</span>internal<span>)</span>
   <span>6</span><span>:</span>          <span>1603</span>          <span>38472</span>  java<span>.</span>lang<span>.</span><span>String</span> <span>(</span>java<span>.</span>base@<span>14</span><span>-</span>internal<span>)</span>
   <span>7</span><span>:</span>             <span>9</span>          <span>33632</span>  <span>[</span><span>C</span> <span>(</span>java<span>.</span>base@<span>14</span><span>-</span>internal<span>)</span></code></pre>

<p>This shows that we have allocated one single array of <tt>infoq.OptionalInt </tt>values, and that it occupies roughly 800M (100 million elements each of size 8).</p>

<p><img _href="img://1InfoQIllus_v1.004-1570789538063.jpg" alt="" data-src="articles/inline-classes-java/en/resources/1InfoQIllus_v1.004-1570789538063.jpg" src="https://res.infoq.com/articles/inline-classes-java/en/resources/1InfoQIllus_v1.004-1570789538063.jpg" rel="share"></p>

<p><img _href="img://1InfoQIllus_v1.005-1570789537190.jpg" alt="" data-src="articles/inline-classes-java/en/resources/1InfoQIllus_v1.005-1570789537190.jpg" src="https://res.infoq.com/articles/inline-classes-java/en/resources/1InfoQIllus_v1.005-1570789537190.jpg" rel="share"></p>

<p>As expected, there are no standalone instances of our inline class.</p>

<p><small><strong>NOTE: Readers who are familiar with the internal syntax for Java type descriptors may note the appearance of a new, Q-type descriptor to denote a value of an inline class.</strong></small></p>

<p>To have something to compare this to, let's recompile Main using the version of OptionalInt from java.util instead of our inline class version. Now the histogram looks completely different (output from Java 8):</p>

<pre><code> num     #instances         #bytes  <span>class</span> <span>name</span> <span>(</span>module<span>)</span>
<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
   <span>1</span><span>:</span>      <span>50000001</span>     <span>1200000024</span>  java<span>.</span>util<span>.</span>OptionalInt
   <span>2</span><span>:</span>             <span>1</span>      <span>400000016</span>  <span>[</span>Ljava<span>.</span>util<span>.</span>OptionalInt<span>;</span>
   <span>3</span><span>:</span>          <span>1719</span>          <span>98600</span>  <span>[</span>B
   <span>4</span><span>:</span>           <span>540</span>          <span>65400</span>  java<span>.</span>lang<span>.</span>Class
   <span>5</span><span>:</span>          <span>1634</span>          <span>52288</span>  java<span>.</span>util<span>.</span>HashMap$Node
   <span>6</span><span>:</span>           <span>446</span>          <span>42840</span>  <span>[</span>Ljava<span>.</span>lang<span>.</span>Object<span>;</span>
   <span>7</span><span>:</span>          <span>1636</span>          <span>39264</span>  java<span>.</span>lang<span>.</span>String</code></pre>

<p>We now have a single array comprising 100 million elements of size 4 — which are references to the object type <code>java.util.OptionalInt</code>. We also have 50 million instances of OptionalInt, plus one for the empty value instance, giving a total memory utilization for the non-inline class case of around 1.6G.</p>

<p><img _href="img://1InfoQIllus_v1.006-1570789536875.jpg" alt="" data-src="articles/inline-classes-java/en/resources/1InfoQIllus_v1.006-1570789536875.jpg" src="https://res.infoq.com/articles/inline-classes-java/en/resources/1InfoQIllus_v1.006-1570789536875.jpg" rel="share"></p>

<p><img _href="img://1InfoQIllus_v1.007-1570789537762.jpg" alt="" data-src="articles/inline-classes-java/en/resources/1InfoQIllus_v1.007-1570789537762.jpg" src="https://res.infoq.com/articles/inline-classes-java/en/resources/1InfoQIllus_v1.007-1570789537762.jpg" rel="share"></p>

<p>This means that the use of inline classes reduces memory overhead by about 50%, in this extreme case. This is a good example of what is meant by the phrase "codes like a class, works like an int."</p>

<h2>Benchmarking with JMH</h2>

<p>Let's also take a look at a simple JMH benchmark. This is intended to allow us to see the effect of removing the indirections and cache misses, in terms of reduced program run time.</p>

<p>Details of how to set up and run a JMH benchmark can be found on the <a href="https://openjdk.java.net/projects/code-tools/jmh/">OpenJDK site</a>.</p>

<p>Our benchmark will directly compare our inline implementation of <tt>OptionalInt </tt>with the version found in the JDK.</p>

<pre><code><span>import</span> org<span>.</span>openjdk<span>.</span>jmh<span>.</span>annotations<span>.</span>*<span>;</span>
<span>import</span> java<span>.</span>util<span>.</span>concurrent<span>.</span>TimeUnit<span>;</span>

@<span>State</span><span>(</span>Scope<span>.</span>Thread<span>)</span>
@<span>BenchmarkMode</span><span>(</span>Mode<span>.</span>Throughput<span>)</span>
@<span>OutputTimeUnit</span><span>(</span>TimeUnit<span>.</span>SECONDS<span>)</span>
<span>public</span> <span>class</span> <span>MyBenchmark</span> <span>{</span>

    @Benchmark
    <span>public</span> <span>long</span> <span>timeInlineOptionalInt</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> MAX <span>=</span> 100_000_000<span>;</span>
        infoq<span>.</span>OptionalInt<span>[</span><span>]</span> opts <span>=</span> <span>new</span> <span>infoq<span>.</span>OptionalInt</span><span>[</span>MAX<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> MAX<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            opts<span>[</span>i<span>]</span> <span>=</span> infoq<span>.</span>OptionalInt<span>.</span><span>of</span><span>(</span>i<span>)</span><span>;</span>
            opts<span>[</span><span>++</span>i<span>]</span> <span>=</span> infoq<span>.</span>OptionalInt<span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>long</span> total <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> MAX<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            infoq<span>.</span>OptionalInt oi <span>=</span> opts<span>[</span>i<span>]</span><span>;</span>
            total <span>+=</span> oi<span>.</span><span>orElse</span><span>(</span><span>0</span><span>)</span><span>;</span>
        <span>}</span>

        <span>return</span> total<span>;</span>
    <span>}</span>

    @Benchmark
    <span>public</span> <span>long</span> <span>timeJavaUtilOptionalInt</span><span>(</span><span>)</span> <span>{</span>
        <span>int</span> MAX <span>=</span> 100_000_000<span>;</span>
        java<span>.</span>util<span>.</span>OptionalInt<span>[</span><span>]</span> opts <span>=</span> <span>new</span> <span>java<span>.</span>util<span>.</span>OptionalInt</span><span>[</span>MAX<span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> MAX<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            opts<span>[</span>i<span>]</span> <span>=</span> java<span>.</span>util<span>.</span>OptionalInt<span>.</span><span>of</span><span>(</span>i<span>)</span><span>;</span>
            opts<span>[</span><span>++</span>i<span>]</span> <span>=</span> java<span>.</span>util<span>.</span>OptionalInt<span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>long</span> total <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> MAX<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            java<span>.</span>util<span>.</span>OptionalInt oi <span>=</span> opts<span>[</span>i<span>]</span><span>;</span>
            total <span>+=</span> oi<span>.</span><span>orElse</span><span>(</span><span>0</span><span>)</span><span>;</span>
        <span>}</span>

        <span>return</span> total<span>;</span>
    <span>}</span>
<span>}</span></code></pre>

<p>Performing a single run on a modern, high-spec MacBook Pro gave this result:</p>

<pre><code>Benchmark                             Mode  Cnt  Score   Error  Units
MyBenchmark<span>.</span>timeInlineOptionalInt    thrpt   <span>25</span>  <span>5.155</span> ± <span>0.057</span>  ops<span>/</span>s
MyBenchmark<span>.</span>timeJavaUtilOptionalInt  thrpt   <span>25</span>  <span>0.589</span> ± <span>0.029</span>  ops<span>/</span>s</code></pre>

<p>This shows that inline classes are much, much faster in this specific case. However, it is important not to read too much into this example — it is merely for demonstration purposes.</p>

<p>As the JMH framework itself warns: "Do not assume the numbers tell you what you want them to tell."</p>

<p>For example, in this case the <tt>infoq.OptionalInt</tt> version of the benchmark allocates roughly 50% — is it this reduction in allocation that accounts for the performance speedup? Or are there other performance effects as well? This benchmark, in isolation, does not tell us — it is simply a single data point.</p>

<p>This rough benchmark should not be taken seriously or used as anything other than an indication that inline classes have the potential to show significant speedups under some carefully chosen circumstances.</p>

<p>For example, in the LW2 prototype, only interpreted mode and the C2 (server) JIT compiler are supported. There is no C1 (client) compiler, no tiered compilation, and no Graal. In addition, the interpreter is not optimized, as the focus has been on the JIT implementation. All of these features would be expected to be present in a shipping version of Java, and in their absence all performance numbers are completely unreliable.</p>

<p>In fact, it's not just performance where so much work still remains to be done, compared to the current LW2 preview. Fundamental questions still remain, such as:</p>

<ul>
	<li>How to extend generics to allow abstraction over all types, including primitives, values, and even <tt>void</tt>?</li>
	<li>What should the true inheritance hierarchy look like for inline classes?</li>
	<li>What to do about type erasure and backwards compatibility?</li>
	<li>How to enable existing libraries (especially the JDK) to compatibly evolve to fully take advantage of inline classes?</li>
	<li>How many of the current LW2 constraints can, or should, be relaxed?</li>
</ul>

<p>While most of these are still open questions, one area where LW2 has tried to provide answers is by prototyping a mechanism for inline classes to be used as the type parameter (the "payload") in a generic type.</p>

<h2>Inline classes as type parameters</h2>

<p>In the current LW2 prototype we must overcome a problem, as Java's model of generics implicitly assumes nullability of values, and inline classes are not nullable.</p>

<p>To solve this, LW2 uses a technique called <em>indirect projection</em>. This is like a form of autoboxing for inline classes, and allows us to write a type <tt>Foo</tt>? for any inline type <tt>Foo</tt>.</p>

<p>The end result is that the indirect projection type can be used as the parameter in a generic type (whereas the real inline type cannot) like this:</p>

<pre><code>   <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span>String<span>[</span><span>]</span> args<span>)</span> <span>{</span>
        List<span>&lt;</span>OptionalInt<span>?</span><span>&gt;</span> opts <span>=</span> <span>new</span> <span>ArrayList</span><span>&lt;</span><span>&gt;</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            opts<span>.</span><span>add</span><span>(</span>OptionalInt<span>.</span><span>of</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
            opts<span>.</span><span>add</span><span>(</span>OptionalInt<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span><span>;</span>
            opts<span>.</span><span>add</span><span>(</span>null<span>)</span><span>;</span>
        <span>}</span>
        <span>int</span> total <span>=</span> opts<span>.</span><span>stream</span><span>(</span><span>)</span>
                        <span>.</span><span>mapToInt</span><span>(</span>o <span>-</span><span>&gt;</span> <span>{</span>
                            <span>if</span> <span>(</span>o <span>==</span> null<span>)</span> <span>return</span> <span>0</span><span>;</span>
                            OptionalInt op <span>=</span> <span>(</span>OptionalInt<span>)</span>o<span>;</span>
                            <span>return</span> op<span>.</span><span>orElse</span><span>(</span><span>0</span><span>)</span><span>;</span>
                        <span>}</span><span>)</span>
                        <span>.</span><span>reduce</span><span>(</span><span>0</span><span>,</span> <span>(</span>x<span>,</span> y<span>)</span> <span>-</span><span>&gt;</span> x <span>+</span> y<span>)</span><span>;</span>

        System<span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Total: "</span><span>+</span> total<span>)</span><span>;</span>
    <span>}</span></code></pre>

<p>Instances of the inline class can always be cast to an instance of the indirect projection, but to go the other way, a null check is required, as seen in the body of the lambda in the example.</p>

<p><small><strong>NOTE: The use of indirect projections is still highly experimental. The final version of inline classes may well use a different design altogether.</strong></small></p>

<p>There is still a huge amount of work to be done before inline classes are ready to become a real feature in the Java language. Prototypes like LW2 are fun for the interested developer to experiment with, but it should always be remembered that these are just an intellectual exercise. Nothing in the current builds guarantees anything about the final form that the feature may eventually take.</p>

<h2>About the Author</h2>

<p><strong><img _href="img://1ben-evans-s-1570789177657.jpg" alt="" data-src="articles/inline-classes-java/en/resources/1ben-evans-s-1570789177657.jpg" src="https://res.infoq.com/articles/inline-classes-java/en/resources/1ben-evans-s-1570789177657.jpg" rel="share">Ben Evans</strong> is a co-founder of jClarity, a JVM performance optimization company. He is an organizer for the LJC (London's JUG) and a member of the JCP Executive Committee, helping define standards for the Java ecosystem. Ben is a Java Champion; 3-time JavaOne Rockstar Speaker; author of "The Well-Grounded Java Developer", the new edition of "Java in a Nutshell" and "Optimizing Java" He is a regular speaker on the Java platform, performance, architecture, concurrency, startups and related topics. Ben is sometimes available for speaking, teaching, writing and consultancy engagements - please contact for details.</p>

							
							
						</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>