<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Working with expression trees in C# | Alexey Golub</title>
<div class="readable">
        <h1>Working with expression trees in C# | Alexey Golub</h1>
        <p>
Reading time: 50-63 minutes        </p>
        <p><a href="https://tyrrrz.me/blog/expression-trees/">https://tyrrrz.me/blog/expression-trees/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p><span>
      <span></span>
  <img alt="cover" title="cover" src="https://tyrrrz.me/static/5c35222334456e56ce6ee3a387c363ca/e11df/Cover.png" srcset="/static/5c35222334456e56ce6ee3a387c363ca/01387/Cover.png 320w,
/static/5c35222334456e56ce6ee3a387c363ca/e49a9/Cover.png 640w,
/static/5c35222334456e56ce6ee3a387c363ca/e11df/Cover.png 1000w" sizes="(max-width: 1000px) 100vw, 1000px" loading="lazy">
    </span></p>
<p>Expression trees is an obscure, although very interesting feature in .NET. Most people probably think of it as something synonymous with object-relational mapping frameworks, but despite being its most common use case, it‚Äôs not the only one. There are a lot of creative things you can do with expression trees, including code generation, transpilation, metaprogramming, and more.</p>
<p>In this article I will give an overview of what expression trees are and how to work with them, as well as show some interesting scenarios where I‚Äôve seen them used to great effect.</p>
<h2>What is an expression tree?</h2>
<p>When it comes to programming languages, an expression describes some operation on data that produces a certain result. It‚Äôs one of the foundational constructs of any language.</p>
<p>As an example of a very simple expression, consider <code>2 + 3</code>. It consists of a constant, a plus operator, and another constant. We can evaluate this expression and get the result, which is <code>5</code>.</p>
<p>Of course, expressions vary in complexity and can contain different combinations of constants, variables, operators and function calls. For example, the following piece of code is also an expression:</p>
<div data-language="csharp"><pre><code><span>!</span><span>string</span><span>.</span><span>IsNullOrWhiteSpace</span><span>(</span>personName<span>)</span>
    <span>?</span> <span>"Greetings, "</span> <span>+</span> personName
    <span>:</span> <span>null</span><span>;</span></code></pre></div>
<p>Looking at the above expression, we can also consider two of its aspects: <strong>what it does</strong> and <strong>how it does it</strong>.</p>
<p>When it comes to the former, the answer is pretty simple ‚Äî it generates a greeting based on the person‚Äôs name, or produces a <code>null</code>. If this expression was returned by a function, that would be the extent of information we could derive from its signature:</p>
<div data-language="csharp"><pre><code><span>string</span><span>?</span> <span>GetGreeting</span><span>(</span><span>string</span> personName<span>)</span> <span>{</span>  <span>}</span></code></pre></div>
<p>As for how it does it, however, the answer is a bit more detailed. This expression consists of a ternary conditional operator, whose condition is evaluated by negating the result of a call to method <code>string.IsNullOrWhiteSpace</code> with parameter <code>personName</code>, whose positive clause is made up of a ‚Äúplus‚Äù binary operator that works with a constant string expression <code>"Greetings, "</code> and the parameter expression, and whose negative clause consist of a sole <code>null</code> expression.</p>
<p>The description above may seem like a mouthful, but it outlines the exact syntactic structure of the expression. It is by this higher-order representation that we‚Äôre able to tell how exactly it‚Äôs evaluated.</p>
<p>To make things more clear, we can also illustrate this representation with the following diagram:</p>
<div data-language="csharp"><pre><code> <span>{</span> <span>Ternary</span> conditional <span>}</span>
      <span>|</span>      <span>|</span>     <span>|</span>
    <span>+</span><span>-</span><span>+</span>      <span>|</span>     <span>+</span><span>--</span><span>--</span><span>-</span><span>+</span>
    <span>|</span>        <span>|</span>           <span>|</span>
 <span>(</span><span>true</span><span>)</span>   <span>(</span><span>false</span><span>)</span>   <span>(</span>condition<span>)</span>
    <span>|</span>        <span>|</span>           <span>|</span>
    <span>|</span>        <span>|</span>           <span>+</span><span>--</span><span>--</span> <span>{</span> <span>(</span><span>!</span><span>)</span> <span>}</span>
    <span>|</span>        <span>+</span><span>--</span><span>--</span><span>--</span><span>+</span>             <span>|</span>
 <span>{</span> <span>(</span><span>+</span><span>)</span> <span>}</span>            <span>|</span>             <span>|</span>
   <span>|</span> <span>|</span>           <span>{</span> <span>null</span> <span>}</span>   <span>{</span> <span>Method</span> call <span>}</span>
   <span>|</span> <span>|</span>                         <span>|</span>      <span>|</span>
   <span>|</span> <span>+</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span><span>+</span>               <span>|</span>      <span>|</span>
   <span>|</span>           <span>|</span>               <span>|</span>      <span>+</span><span>--</span><span>--</span><span>--</span><span>-</span> <span>{</span> <span>string</span><span>.</span>IsNullOrWhiteSpace <span>}</span>
   <span>|</span>           <span>|</span>               <span>|</span>
   <span>|</span>     <span>{</span> personName <span>}</span>        <span>+</span><span>--</span><span>--</span><span>--</span><span>--</span> <span>{</span> personName <span>}</span>
   <span>|</span>
   <span>+</span><span>--</span><span>--</span> <span>{</span> <span>"Greetings, "</span> <span>}</span></code></pre></div>
<p>As you can see, at the highest level we have the ternary conditional operator which is itself made up of other expressions, which are made up of other expressions, and so on. The relationship between individual components is hierarchical, resembling an upside-down tree.</p>
<p>Although it‚Äôs inherently obvious to us as humans, in order to interpret this representation programmatically, we need a special data structure. This data structure is what we call an <em>expression tree</em>.</p>
<h2>Constructing expression trees manually</h2>
<p>In C#, expression trees can be used in either of two directions: we can create them directly via an API and then compile them into runtime instructions, or we can disassemble them from supplied lambda expressions. In this part of the article we will focus on the first one.</p>
<p>The framework offers us with an API to construct expression trees through the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions.expression"><code>Expression</code></a> class located in the <code>System.Linq.Expressions</code> namespace. It exposes various factory methods that can be used to produce expressions of different types.</p>
<p>Some of these methods are:</p>
<ul>
<li><code>Expression.Constant(...)</code> ‚Äî creates an expression that represents a value.</li>
<li><code>Expression.Variable(...)</code> ‚Äî creates an expression that represents a variable.</li>
<li><code>Expression.New(...)</code> ‚Äî creates an expression that represents an initialization of a new instance.</li>
<li><code>Expression.Assign(...)</code> ‚Äî creates an expression that represents an assignment operation.</li>
<li><code>Expression.Equal(...)</code> ‚Äî creates an expression that represents an equality comparison.</li>
<li><code>Expression.Call(...)</code> ‚Äî creates an expression that represents a specific method call.</li>
<li><code>Expression.Condition(...)</code> ‚Äî creates an expression that represents branching logic.</li>
<li><code>Expression.Loop(...)</code> ‚Äî creates an expression that represents repeating logic.</li>
</ul>
<p>As a simple exercise, let‚Äôs recreate the expression we‚Äôve looked into in the previous part of the article:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>Expression</span> <span>ConstructGreetingExpression</span><span>(</span><span>)</span>
<span>{</span>
    <span>var</span> personNameParameter <span>=</span> Expression<span>.</span><span>Parameter</span><span>(</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>,</span> <span>"personName"</span><span>)</span><span>;</span>

    
    <span>var</span> isNullOrWhiteSpaceMethod <span>=</span> <span>typeof</span><span>(</span><span>string</span><span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span><span>string</span><span>.</span>IsNullOrWhiteSpace<span>)</span><span>)</span><span>;</span>

    <span>var</span> condition <span>=</span> Expression<span>.</span><span>Not</span><span>(</span>
        Expression<span>.</span><span>Call</span><span>(</span>isNullOrWhiteSpaceMethod<span>,</span> personNameParameter<span>)</span><span>)</span><span>;</span>

    
    <span>var</span> trueClause <span>=</span> Expression<span>.</span><span>Add</span><span>(</span>
        Expression<span>.</span><span>Constant</span><span>(</span><span>"Greetings, "</span><span>)</span><span>,</span>
        personNameParameter<span>)</span><span>;</span>

    
    <span>var</span> falseClause <span>=</span> Expression<span>.</span><span>Constant</span><span>(</span><span>null</span><span>,</span> <span>typeof</span><span>(</span><span>string</span><span>)</span><span>)</span><span>;</span>

    
    <span>return</span> Expression<span>.</span><span>Condition</span><span>(</span>condition<span>,</span> trueClause<span>,</span> falseClause<span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>Let‚Äôs digest what just happened here.</p>
<p>First of all, we‚Äôre calling <code>Expression.Parameter</code> in order to construct a parameter expression. We will be able to use it to resolve the value of a particular parameter.</p>
<p>Following that, we are relying on reflection to resolve a reference to the <code>string.IsNullOrWhiteSpace</code> method. We use <code>Expression.Call</code> to create a method invocation expression that represents a call to <code>string.IsNullOrWhiteSpace</code> with the parameter resolved by the expression we created earlier. To perform a logical ‚Äúnot‚Äù operation on the result, we‚Äôre calling <code>Expression.Not</code> to wrap the method call. Incidentally, this expression constitutes the condition part of the ternary expression we‚Äôre building.</p>
<p>To compose the positive clause, we‚Äôre constructing an ‚Äúadd‚Äù operation with the help of <code>Expression.Add</code>. As the operands, we‚Äôre providing a constant expression for string <code>"Greetings, "</code> and the parameter expression from earlier.</p>
<p>Then, for the negative clause, we‚Äôre using <code>Expression.Constant</code> to create a <code>null</code> constant expression. To ensure that the <code>null</code> value is typed correctly, we explicitly specify the type as the second parameter.</p>
<p>Finally, we‚Äôre combining all of the above parts together to create our ternary conditional operator. If you take a moment to trace what goes into <code>Expression.Condition</code>, you will realize that we have essentially replicated the tree diagram we‚Äôve seen earlier.</p>
<p>However, this expression isn‚Äôt particularly useful on its own. Since we‚Äôve created it ourselves, we‚Äôre not really interested in its structure ‚Äî we want to be able to evaluate it instead.</p>
<p>In order to do that, we have to create an entry point by wrapping everything in a lambda expression. To turn it into an actual lambda, we can call <code>Compile</code> which will produce a delegate that we can invoke.</p>
<p>Let‚Äôs update the method accordingly:</p>
<div data-language="csharp"><pre><code><span>public</span> Func<span>&lt;</span><span>string</span><span>,</span> <span>string</span><span>?</span><span>&gt;</span> <span>ConstructGreetingFunction</span><span>(</span><span>)</span>
<span>{</span>
    <span>var</span> personNameParameter <span>=</span> Expression<span>.</span><span>Parameter</span><span>(</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>,</span> <span>"personName"</span><span>)</span><span>;</span>

    
    <span>var</span> isNullOrWhiteSpaceMethod <span>=</span> <span>typeof</span><span>(</span><span>string</span><span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span><span>string</span><span>.</span>IsNullOrWhiteSpace<span>)</span><span>)</span><span>;</span>

    <span>var</span> condition <span>=</span> Expression<span>.</span><span>Not</span><span>(</span>
        Expression<span>.</span><span>Call</span><span>(</span>isNullOrWhiteSpaceMethod<span>,</span> personNameParameter<span>)</span><span>)</span><span>;</span>

    
    <span>var</span> trueClause <span>=</span> Expression<span>.</span><span>Add</span><span>(</span>
        Expression<span>.</span><span>Constant</span><span>(</span><span>"Greetings, "</span><span>)</span><span>,</span>
        personNameParameter<span>)</span><span>;</span>

    
    <span>var</span> falseClause <span>=</span> Expression<span>.</span><span>Constant</span><span>(</span><span>null</span><span>,</span> <span>typeof</span><span>(</span><span>string</span><span>)</span><span>)</span><span>;</span>

    <span>var</span> conditional <span>=</span> Expression<span>.</span><span>Condition</span><span>(</span>condition<span>,</span> trueClause<span>,</span> falseClause<span>)</span><span>;</span>

    <span>var</span> lambda <span>=</span> Expression<span>.</span>Lambda<span>&lt;</span>Func<span>&lt;</span><span>string</span><span>,</span> <span>string</span><span>?</span><span>&gt;&gt;</span><span>(</span>conditional<span>,</span> personNameParameter<span>)</span><span>;</span>

    <span>return</span> lambda<span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>As you can see, we were able to construct a lambda expression by specifying its body (which is our conditional expression) and the parameter that we defined earlier. We also indicated the exact type of the function this expression represents by supplying a generic argument.</p>
<p>By compiling the expression tree, we can convert the code it represents into runtime instructions. The delegate returned by this method can be used to evaluate the expression:</p>
<div data-language="csharp"><pre><code><span>var</span> getGreeting <span>=</span> <span>ConstructGreetingFunction</span><span>(</span><span>)</span><span>;</span>

<span>var</span> greetingForJohn <span>=</span> <span>getGreeting</span><span>(</span><span>"John"</span><span>)</span><span>;</span></code></pre></div>
<p>However, if we try to run this, we will get an error:</p>
<div data-language="ini"><pre><code>The binary operator Add is not defined for the types 'System.String' and 'System.String'.</code></pre></div>
<p>Hmm, that‚Äôs weird. I‚Äôm pretty sure the <code>+</code> operator is defined for strings, otherwise how else would I be able to write <code>"foo" + "bar"</code>?</p>
<p>Well, actually the error message is correct, this operator is indeed not defined for <code>System.String</code>. Instead what happens is that the C# compiler automatically converts expressions like <code>"foo" + "bar"</code> into <code>string.Concat("foo", "bar")</code>. In cases with more than two strings this provides better performance because it avoids unnecessary allocations.</p>
<p>When dealing with expression trees, we‚Äôre essentially writing the ‚Äúfinal‚Äù version of the code. So instead of <code>Expression.Add</code> we need to call <code>string.Concat</code> directly.</p>
<p>Let‚Äôs change our code to accommodate for that:</p>
<div data-language="csharp"><pre><code><span>public</span> Func<span>&lt;</span><span>string</span><span>,</span> <span>string</span><span>?</span><span>&gt;</span> <span>ConstructGreetingFunction</span><span>(</span><span>)</span>
<span>{</span>
    <span>var</span> personNameParameter <span>=</span> Expression<span>.</span><span>Parameter</span><span>(</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>,</span> <span>"personName"</span><span>)</span><span>;</span>

    
    <span>var</span> isNullOrWhiteSpaceMethod <span>=</span> <span>typeof</span><span>(</span><span>string</span><span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span><span>string</span><span>.</span>IsNullOrWhiteSpace<span>)</span><span>)</span><span>;</span>

    <span>var</span> condition <span>=</span> Expression<span>.</span><span>Not</span><span>(</span>
        Expression<span>.</span><span>Call</span><span>(</span>isNullOrWhiteSpaceMethod<span>,</span> personNameParameter<span>)</span><span>)</span><span>;</span>

    
    <span>var</span> concatMethod <span>=</span> <span>typeof</span><span>(</span><span>string</span><span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span><span>string</span><span>.</span>Concat<span>)</span><span>,</span> <span>new</span><span>[</span><span>]</span> <span>{</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>,</span> <span>typeof</span><span>(</span><span>string</span><span>)</span><span>}</span><span>)</span><span>;</span>

    <span>var</span> trueClause <span>=</span> Expression<span>.</span><span>Call</span><span>(</span>
        concatMethod<span>,</span>
        Expression<span>.</span><span>Constant</span><span>(</span><span>"Greetings, "</span><span>)</span><span>,</span>
        personNameParameter<span>)</span><span>;</span>

    
    <span>var</span> falseClause <span>=</span> Expression<span>.</span><span>Constant</span><span>(</span><span>null</span><span>,</span> <span>typeof</span><span>(</span><span>string</span><span>)</span><span>)</span><span>;</span>

    <span>var</span> conditional <span>=</span> Expression<span>.</span><span>Condition</span><span>(</span>condition<span>,</span> trueClause<span>,</span> falseClause<span>)</span><span>;</span>

    <span>var</span> lambda <span>=</span> Expression<span>.</span>Lambda<span>&lt;</span>Func<span>&lt;</span><span>string</span><span>,</span> <span>string</span><span>?</span><span>&gt;&gt;</span><span>(</span>conditional<span>,</span> personNameParameter<span>)</span><span>;</span>

    <span>return</span> lambda<span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>Now, if we try to compile and run our function, it behaves as expected:</p>
<div data-language="csharp"><pre><code><span>var</span> getGreetings <span>=</span> <span>ConstructGreetingFunction</span><span>(</span><span>)</span><span>;</span>

<span>var</span> greetingsForJohn <span>=</span> <span>getGreetings</span><span>(</span><span>"John"</span><span>)</span><span>;</span> 
<span>var</span> greetingsForNobody <span>=</span> <span>getGreetings</span><span>(</span><span>" "</span><span>)</span><span>;</span>  </code></pre></div>
<p>I think this is pretty awesome. We built an expression tree, compiled it in-memory, and now we can evaluate it using a delegate.</p>
<h2>Constructing statements</h2>
<p>So far we‚Äôve only talked about expressions, but what about statements? Can we dynamically compile code that contains multiple statements or are we limited to expressions?</p>
<p>The main difference between expressions and statements is that statements don‚Äôt produce results. That means we can‚Äôt really string them into a single expression.</p>
<p>For example, consider the following two statements:</p>
<div data-language="csharp"><pre><code>
Console<span>.</span><span>Write</span><span>(</span><span>"Hello "</span><span>)</span><span>;</span>
Console<span>.</span><span>WriteLine</span><span>(</span><span>"world!"</span><span>)</span><span>;</span></code></pre></div>
<p>There‚Äôs no way for us to compose these into one expression, like we could have with <code>StringBuilder</code>, for instance:</p>
<div data-language="csharp"><pre><code>
<span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>.</span><span>Append</span><span>(</span><span>"Hello "</span><span>)</span><span>.</span><span>AppendLine</span><span>(</span><span>"world!"</span><span>)</span><span>;</span></code></pre></div>
<p>Fortunately, the expression tree model allows us to represent statements as well. To do that, we need to put them inside a <code>Block</code> expression.</p>
<p>Here is how it works:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>Expression</span> <span>CreateStatementBlock</span><span>(</span><span>)</span>
<span>{</span>
    <span>var</span> consoleWriteMethod <span>=</span> <span>typeof</span><span>(</span>Console<span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span>Console<span>.</span>Write<span>)</span><span>,</span> <span>new</span><span>[</span><span>]</span> <span>{</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>}</span><span>)</span><span>;</span>

    <span>var</span> consoleWriteLineMethod <span>=</span> <span>typeof</span><span>(</span>Console<span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span>Console<span>.</span>WriteLine<span>)</span><span>,</span> <span>new</span><span>[</span><span>]</span> <span>{</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>}</span><span>)</span><span>;</span>

    <span>return</span> Expression<span>.</span><span>Block</span><span>(</span>
        Expression<span>.</span><span>Call</span><span>(</span>consoleWriteMethod<span>,</span> Expression<span>.</span><span>Constant</span><span>(</span><span>"Hello "</span><span>)</span><span>)</span><span>,</span>
        Expression<span>.</span><span>Call</span><span>(</span>consoleWriteLineMethod<span>,</span> Expression<span>.</span><span>Constant</span><span>(</span><span>"world!"</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>We can then similarly compile a delegate and invoke it:</p>
<div data-language="csharp"><pre><code><span>var</span> block <span>=</span> <span>CreateStatementBlock</span><span>(</span><span>)</span><span>;</span>
<span>var</span> lambda <span>=</span> Expression<span>.</span><span><span>Lambda</span><span>&lt;</span><span>Action</span><span>&gt;</span></span><span>(</span>block<span>)</span><span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>

<span>lambda</span><span>(</span><span>)</span><span>;</span>

</code></pre></div>
<p>Now, if we inspect the <code>block.Type</code> property, which denotes the result type of the expression, we will see that it‚Äôs <code>System.Void</code>. Essentially the lambda expression we‚Äôve built is just this:</p>
<div data-language="csharp"><pre><code><span>var</span> lambda <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span>
<span>{</span>
    Console<span>.</span><span>Write</span><span>(</span><span>"Hello "</span><span>)</span><span>;</span>
    Console<span>.</span><span>WriteLine</span><span>(</span><span>"world!"</span><span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>For more complex use cases, we may declare and reference variables from inside the block expression:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>Expression</span> <span>CreateStatementBlock</span><span>(</span><span>)</span>
<span>{</span>
    <span>var</span> consoleWriteMethod <span>=</span> <span>typeof</span><span>(</span>Console<span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span>Console<span>.</span>Write<span>)</span><span>,</span> <span>new</span><span>[</span><span>]</span> <span>{</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>}</span><span>)</span><span>;</span>

    <span>var</span> consoleWriteLineMethod <span>=</span> <span>typeof</span><span>(</span>Console<span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span>Console<span>.</span>WriteLine<span>)</span><span>,</span> <span>new</span><span>[</span><span>]</span> <span>{</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>}</span><span>)</span><span>;</span>

    <span>var</span> variableA <span>=</span> Expression<span>.</span><span>Variable</span><span>(</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>,</span> <span>"a"</span><span>)</span><span>;</span>
    <span>var</span> variableB <span>=</span> Expression<span>.</span><span>Variable</span><span>(</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>,</span> <span>"b"</span><span>)</span><span>;</span>

    <span>return</span> Expression<span>.</span><span>Block</span><span>(</span>
        
        <span>new</span><span>[</span><span>]</span> <span>{</span>variableA<span>,</span> variableB<span>}</span><span>,</span>

        
        Expression<span>.</span><span>Assign</span><span>(</span>variableA<span>,</span> Expression<span>.</span><span>Constant</span><span>(</span><span>"Foo "</span><span>)</span><span>)</span><span>,</span>
        Expression<span>.</span><span>Assign</span><span>(</span>variableB<span>,</span> Expression<span>.</span><span>Constant</span><span>(</span><span>"bar"</span><span>)</span><span>)</span><span>,</span>

        
        Expression<span>.</span><span>Call</span><span>(</span>consoleWriteMethod<span>,</span> variableA<span>)</span><span>,</span>
        Expression<span>.</span><span>Call</span><span>(</span>consoleWriteLineMethod<span>,</span> variableB<span>)</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>If we compile and evaluate this expression, we will see the following output in the console:</p>
<div data-language="csharp"><pre><code><span>var</span> block <span>=</span> <span>CreateStatementBlock</span><span>(</span><span>)</span><span>;</span>
<span>var</span> lambda <span>=</span> Expression<span>.</span><span><span>Lambda</span><span>&lt;</span><span>Action</span><span>&gt;</span></span><span>(</span>block<span>)</span><span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>

<span>lambda</span><span>(</span><span>)</span><span>;</span>

</code></pre></div>
<p>So despite the fact that we are building <em>expression</em> trees, we are not actually limited only to expressions. We can just as easily model blocks of statements too.</p>
<h2>Converting expressions to readable code</h2>
<p>We know how to compile our expressions into runtime instructions, but what about readable C# code? It could be useful if we wanted to display it or just to have some visual aid while testing.</p>
<p>The good news is that all types that derive from <code>Expression</code> override the <code>ToString</code> method with a more specific implementation. That means we can do the following:</p>
<div data-language="csharp"><pre><code><span>var</span> s1 <span>=</span> Expression<span>.</span><span>Constant</span><span>(</span><span>42</span><span>)</span><span>.</span><span>ToString</span><span>(</span><span>)</span><span>;</span> 

<span>var</span> s2 <span>=</span> Expression<span>.</span><span>Multiply</span><span>(</span>
    Expression<span>.</span><span>Constant</span><span>(</span><span>5</span><span>)</span><span>,</span>
    Expression<span>.</span><span>Constant</span><span>(</span><span>11</span><span>)</span><span>)</span><span>.</span><span>ToString</span><span>(</span><span>)</span><span>;</span>     </code></pre></div>
<p>The bad news, however, is that it only works nicely with simple expressions like the ones above. For example, if we try to call <code>ToString</code> on the ternary expression we compiled earlier, we will get:</p>
<div data-language="csharp"><pre><code><span>var</span> s <span>=</span> lambda<span>.</span><span>ToString</span><span>(</span><span>)</span><span>;</span>

</code></pre></div>
<p>While fairly descriptive, this is probably not the text representation one would hope to see.</p>
<p>Luckily, we can use the <a href="https://github.com/agileobjects/ReadableExpressions">ReadableExpressions</a> NuGet package to get us what we want. By installing it, we should be able to call <code>ToReadableString</code> to get the actual C# code that represents the expression:</p>
<div data-language="csharp"><pre><code><span>var</span> code <span>=</span> lambda<span>.</span><span>ToReadableString</span><span>(</span><span>)</span><span>;</span>

</code></pre></div>
<p>As you can see, it even replaced the <code>string.Concat</code> call with the plus operator to make it closer to code that a developer would typically write.</p>
<p>Additionally, if you are using Visual Studio and want to inspect expressions by visualizing them as code, you can install <a href="https://marketplace.visualstudio.com/items?itemName=vs-publisher-1232914.ReadableExpressionsVisualizers">this extension</a>. It‚Äôs very helpful when debugging large or really complex expressions.</p>
<h2>Optimizing reflection calls</h2>
<p>When it comes to compiled expressions, one of the most common usage scenarios is reflection-heavy code. As we all know, reflection can be quite slow because of late binding, however by compiling the code at runtime we can achieve better performance.</p>
<p>Let‚Äôs imagine we have a class which has a private method that we want to invoke from the outside:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Command</span>
<span>{</span>
    <span>private</span> <span>int</span> <span>Execute</span><span>(</span><span>)</span> <span>=&gt;</span> <span>42</span><span>;</span>
<span>}</span></code></pre></div>
<p>With the help of reflection, this is quite simple:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>int</span> <span>CallExecute</span><span>(</span><span>Command</span> command<span>)</span> <span>=&gt;</span>
    <span>(</span><span>int</span><span>)</span> <span>typeof</span><span>(</span>Command<span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>"Execute"</span><span>,</span> BindingFlags<span>.</span>NonPublic <span>|</span> BindingFlags<span>.</span>Instance<span>)</span>
        <span>.</span><span>Invoke</span><span>(</span>command<span>,</span> <span>null</span><span>)</span><span>;</span></code></pre></div>
<p>Of course, invoking the method like that can cause significant performance issues if we put it in a tight loop. Let‚Äôs see if we can optimize it a bit.</p>
<p>Before we jump into expressions, we can first optimize the above code by separating the part that resolves <code>MethodInfo</code> from the part that invokes it. If we‚Äôre going to call this method more than once, we don‚Äôt have to use <code>GetMethod</code> every time:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>class</span> <span>ReflectionCached</span>
<span>{</span>
    <span>private</span> <span>static</span> <span>MethodInfo</span> ExecuteMethod <span>{</span> <span>get</span><span>;</span> <span>}</span> <span>=</span> <span>typeof</span><span>(</span>Command<span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>"Execute"</span><span>,</span> BindingFlags<span>.</span>NonPublic <span>|</span> BindingFlags<span>.</span>Instance<span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>int</span> <span>CallExecute</span><span>(</span><span>Command</span> command<span>)</span> <span>=&gt;</span> <span>(</span><span>int</span><span>)</span> ExecuteMethod<span>.</span><span>Invoke</span><span>(</span>command<span>,</span> <span>null</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>That should make things better, but we can push it even further by using <code>Delegate.CreateDelegate</code>. This way we can create a re-usable delegate and avoid the overhead that comes with <code>MethodInfo.Invoke</code>. Let‚Äôs do that as well:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>class</span> <span>ReflectionDelegate</span>
<span>{</span>
    <span>private</span> <span>static</span> <span>MethodInfo</span> ExecuteMethod <span>{</span> <span>get</span><span>;</span> <span>}</span> <span>=</span> <span>typeof</span><span>(</span>Command<span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>"Execute"</span><span>,</span> BindingFlags<span>.</span>NonPublic <span>|</span> BindingFlags<span>.</span>Instance<span>)</span><span>;</span>

    <span>private</span> <span>static</span> Func<span>&lt;</span>Command<span>,</span> <span>int</span><span>&gt;</span> Impl <span>{</span> <span>get</span><span>;</span> <span>}</span> <span>=</span>
        <span>(</span>Func<span>&lt;</span>Command<span>,</span> <span>int</span><span>&gt;</span><span>)</span> Delegate<span>.</span><span>CreateDelegate</span><span>(</span><span>typeof</span><span>(</span>Func<span>&lt;</span>Command<span>,</span> <span>int</span><span>&gt;</span><span>)</span><span>,</span> ExecuteMethod<span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>int</span> <span>CallExecute</span><span>(</span><span>Command</span> command<span>)</span> <span>=&gt;</span> <span>Impl</span><span>(</span>command<span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>Alright, that‚Äôs probably as good as it can get with reflection. Now let‚Äôs try to do the same using compiled expressions:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>class</span> <span>ExpressionTrees</span>
<span>{</span>
    <span>private</span> <span>static</span> <span>MethodInfo</span> ExecuteMethod <span>{</span> <span>get</span><span>;</span> <span>}</span> <span>=</span> <span>typeof</span><span>(</span>Command<span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>"Execute"</span><span>,</span> BindingFlags<span>.</span>NonPublic <span>|</span> BindingFlags<span>.</span>Instance<span>)</span><span>;</span>

    <span>private</span> <span>static</span> Func<span>&lt;</span>Command<span>,</span> <span>int</span><span>&gt;</span> Impl <span>{</span> <span>get</span><span>;</span> <span>}</span>

    <span>static</span> <span>ExpressionTrees</span><span>(</span><span>)</span>
    <span>{</span>
        <span>var</span> instance <span>=</span> Expression<span>.</span><span>Parameter</span><span>(</span><span>typeof</span><span>(</span>Command<span>)</span><span>)</span><span>;</span>
        <span>var</span> call <span>=</span> Expression<span>.</span><span>Call</span><span>(</span>instance<span>,</span> ExecuteMethod<span>)</span><span>;</span>
        Impl <span>=</span> Expression<span>.</span>Lambda<span>&lt;</span>Func<span>&lt;</span>Command<span>,</span> <span>int</span><span>&gt;&gt;</span><span>(</span>call<span>,</span> instance<span>)</span><span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>int</span> <span>CallExecute</span><span>(</span><span>Command</span> command<span>)</span> <span>=&gt;</span> <span>Impl</span><span>(</span>command<span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>In all of these approaches we‚Äôre relying on static constructors to initialize the properties in a lazy and thread-safe manner. This ensures that all of the heavy-lifting happens only once, the first time the members of these classes are accessed.</p>
<p>Now let‚Äôs pit all of these techniques against each other and compare their performance using <a href="https://github.com/dotnet/BenchmarkDotNet">Benchmark.NET</a>:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Benchmarks</span>
<span>{</span>
    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Reflection"</span><span>,</span> Baseline <span>=</span> <span>true</span><span>)</span><span>]</span>
    <span>public</span> <span>int</span> <span>Reflection</span><span>(</span><span>)</span> <span>=&gt;</span> <span>(</span><span>int</span><span>)</span> <span>typeof</span><span>(</span>Command<span>)</span>
        <span>.</span><span>GetMethod</span><span>(</span><span>"Execute"</span><span>,</span> BindingFlags<span>.</span>NonPublic <span>|</span> BindingFlags<span>.</span>Instance<span>)</span>
        <span>.</span><span>Invoke</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>)</span><span>,</span> <span>null</span><span>)</span><span>;</span>

    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Reflection (cached)"</span><span>)</span><span>]</span>
    <span>public</span> <span>int</span> <span>Cached</span><span>(</span><span>)</span> <span>=&gt;</span> ReflectionCached<span>.</span><span>CallExecute</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Reflection (delegate)"</span><span>)</span><span>]</span>
    <span>public</span> <span>int</span> <span>Delegate</span><span>(</span><span>)</span> <span>=&gt;</span> ReflectionDelegate<span>.</span><span>CallExecute</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Expressions"</span><span>)</span><span>]</span>
    <span>public</span> <span>int</span> <span>Expressions</span><span>(</span><span>)</span> <span>=&gt;</span> ExpressionTrees<span>.</span><span>CallExecute</span><span>(</span><span>new</span> <span>Command</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>)</span> <span>=&gt;</span> BenchmarkRunner<span>.</span><span><span>Run</span><span>&lt;</span><span>Benchmarks</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<div data-language="r"><pre><code><span>|</span>                Method <span>|</span>       Mean <span>|</span>     Error <span>|</span>    StdDev <span>|</span> Ratio <span>|</span>
<span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span> <span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span>
<span>|</span>            Reflection <span>|</span> <span>192.975</span> ns <span>|</span> <span>1.6802</span> ns <span>|</span> <span>1.4895</span> ns <span>|</span>  <span>1.00</span> <span>|</span>
<span>|</span>   Reflection <span>(</span>cached<span>)</span> <span>|</span> <span>123.762</span> ns <span>|</span> <span>1.1063</span> ns <span>|</span> <span>1.0349</span> ns <span>|</span>  <span>0.64</span> <span>|</span>
<span>|</span> Reflection <span>(</span>delegate<span>)</span> <span>|</span>   <span>6.419</span> ns <span>|</span> <span>0.0646</span> ns <span>|</span> <span>0.0605</span> ns <span>|</span>  <span>0.03</span> <span>|</span>
<span>|</span>           Expressions <span>|</span>   <span>5.383</span> ns <span>|</span> <span>0.0433</span> ns <span>|</span> <span>0.0383</span> ns <span>|</span>  <span>0.03</span> <span>|</span></code></pre></div>
<p>As you can see, compiled expressions outperform reflection across the board, even though the approach with <code>CreateDelegate</code> comes really close. Note however that while the execution times are similar, <code>CreateDelegate</code> is more limited than compiled expressions ‚Äî for example, it cannot be used to call constructor methods.</p>
<p>This approach of using expression trees for dynamic method invocation is commonplace in various frameworks and libraries. For example:</p>
<ul>
<li><a href="https://github.com/AutoMapper/AutoMapper">AutoMapper</a> uses them to speed up object conversion</li>
<li><a href="https://github.com/Particular/NServiceBus">NServiceBus</a> uses them to speed up its behavior pipeline</li>
<li><a href="https://github.com/JasperFx/marten">Marten</a> uses them to speed up entity mapping</li>
</ul>
<h2>Implementing generic operators</h2>
<p>Something else we can do with compiled expressions is implement generic operators. These can be pretty useful if you‚Äôre writing a lot of mathematical code and want to avoid duplication.</p>
<p>As you know, operators in C# are not generic. This means that every numeric type defines its own version of the multiply and divide operators, among other things. As a result, code that uses these operators also can‚Äôt be generic either.</p>
<p>Imagine that you had a function that calculates three-fourths of a number:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>int</span> <span>ThreeFourths</span><span>(</span><span>int</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span>

</code></pre></div>
<p>Defined as it is, it only works when used with numbers of type <code>int</code>. If we wanted to extend it to support other types, we‚Äôd have to add some overloads:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>int</span> <span>ThreeFourths</span><span>(</span><span>int</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span>

<span>public</span> <span>long</span> <span>ThreeFourths</span><span>(</span><span>long</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span>

<span>public</span> <span>float</span> <span>ThreeFourths</span><span>(</span><span>float</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span>

<span>public</span> <span>double</span> <span>ThreeFourths</span><span>(</span><span>double</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span>

<span>public</span> <span>decimal</span> <span>ThreeFourths</span><span>(</span><span>decimal</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span></code></pre></div>
<p>This is suboptimal. We are introducing a lot of code duplication which only gets worse as this method is referenced from other places.</p>
<p>It would‚Äôve been better if we could just do something like this instead:</p>
<div data-language="csharp"><pre><code><span>public</span> T <span><span>ThreeFourths</span><span>&lt;</span><span>T</span><span>&gt;</span></span><span>(</span><span>T</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span></code></pre></div>
<p>But unfortunately that doesn‚Äôt compile, seeing as the <code>*</code> and <code>/</code> operators are not available on every type that can be specified in place of <code>T</code>. Sadly, there‚Äôs also no constraint we could use to limit the generic argument to numeric types.</p>
<p>However, by generating code dynamically with expression trees we can work around this problem:</p>
<div data-language="csharp"><pre><code><span>public</span> T <span><span>ThreeFourths</span><span>&lt;</span><span>T</span><span>&gt;</span></span><span>(</span><span>T</span> x<span>)</span>
<span>{</span>
    <span>var</span> param <span>=</span> Expression<span>.</span><span>Parameter</span><span>(</span><span>typeof</span><span>(</span>T<span>)</span><span>)</span><span>;</span>

    
    <span>var</span> three <span>=</span> Expression<span>.</span><span>Convert</span><span>(</span>Expression<span>.</span><span>Constant</span><span>(</span><span>3</span><span>)</span><span>,</span> <span>typeof</span><span>(</span>T<span>)</span><span>)</span><span>;</span>
    <span>var</span> four <span>=</span> Expression<span>.</span><span>Convert</span><span>(</span>Expression<span>.</span><span>Constant</span><span>(</span><span>4</span><span>)</span><span>,</span> <span>typeof</span><span>(</span>T<span>)</span><span>)</span><span>;</span>

    
    <span>var</span> operation <span>=</span> Expression<span>.</span><span>Divide</span><span>(</span>Expression<span>.</span><span>Multiply</span><span>(</span>param<span>,</span> three<span>)</span><span>,</span> four<span>)</span><span>;</span>

    <span>var</span> lambda <span>=</span> Expression<span>.</span>Lambda<span>&lt;</span>Func<span>&lt;</span>T<span>,</span> T<span>&gt;&gt;</span><span>(</span>operation<span>,</span> param<span>)</span><span>;</span>

    <span>var</span> func <span>=</span> lambda<span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>

    <span>return</span> <span>func</span><span>(</span>x<span>)</span><span>;</span>
<span>}</span>



</code></pre></div>
<p>That works well and we can reuse this method for numbers of any type. Although, seeing as our generic operation doesn‚Äôt have type safety, you may be wondering how is this approach any different from just using <code>dynamic</code>?</p>
<p>Surely, we could just write our code like this and avoid all the trouble:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>dynamic</span> <span>ThreeFourths</span><span>(</span><span>dynamic</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span></code></pre></div>
<p>Indeed, functionally these two approaches are the same. However, the main difference and the advantage of expression trees is the fact they are compiled, while <code>dynamic</code> isn‚Äôt. Compiled code has the potential to perform much faster.</p>
<p>That said, in the example above we‚Äôre not benefitting from this advantage at all because we‚Äôre recompiling our function every time anyway. Let‚Äôs try to change our code so that it happens only once.</p>
<p>In order to achieve that, we can apply the same pattern as the last time. Let‚Äôs put the delegate inside a generic static class and have it initialized from the static constructor. Here‚Äôs how that would look:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>class</span> <span>ThreeFourths</span>
<span>{</span>
    <span>private</span> <span>static</span> <span>class</span> <span>Impl</span><span>&lt;</span>T<span>&gt;</span>
    <span>{</span>
        <span>public</span> <span>static</span> Func<span>&lt;</span>T<span>,</span> T<span>&gt;</span> Of <span>{</span> <span>get</span><span>;</span> <span>}</span>

        <span>static</span> <span>Impl</span><span>(</span><span>)</span>
        <span>{</span>
            <span>var</span> param <span>=</span> Expression<span>.</span><span>Parameter</span><span>(</span><span>typeof</span><span>(</span>T<span>)</span><span>)</span><span>;</span>

            <span>var</span> three <span>=</span> Expression<span>.</span><span>Convert</span><span>(</span>Expression<span>.</span><span>Constant</span><span>(</span><span>3</span><span>)</span><span>,</span> <span>typeof</span><span>(</span>T<span>)</span><span>)</span><span>;</span>
            <span>var</span> four <span>=</span> Expression<span>.</span><span>Convert</span><span>(</span>Expression<span>.</span><span>Constant</span><span>(</span><span>4</span><span>)</span><span>,</span> <span>typeof</span><span>(</span>T<span>)</span><span>)</span><span>;</span>

            <span>var</span> operation <span>=</span> Expression<span>.</span><span>Divide</span><span>(</span>Expression<span>.</span><span>Multiply</span><span>(</span>param<span>,</span> three<span>)</span><span>,</span> four<span>)</span><span>;</span>

            <span>var</span> lambda <span>=</span> Expression<span>.</span>Lambda<span>&lt;</span>Func<span>&lt;</span>T<span>,</span> T<span>&gt;&gt;</span><span>(</span>operation<span>,</span> param<span>)</span><span>;</span>

            Of <span>=</span> lambda<span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> T <span><span>Of</span><span>&lt;</span><span>T</span><span>&gt;</span></span><span>(</span><span>T</span> x<span>)</span> <span>=&gt;</span> Impl<span>&lt;</span>T<span>&gt;</span><span>.</span><span>Of</span><span>(</span>x<span>)</span><span>;</span>
<span>}</span>

</code></pre></div>
<p>Due to the fact that the compiler generates a version of the <code>Impl</code> class for each argument of <code>T</code>, we end up with an implementation of three-fourths for each type encapsulated in a separate class. This approach gives us a thread-safe lazy-evaluated generic dynamic function.</p>
<p>Now, with the optimizations out of the way, let‚Äôs again use Benchmark.NET to compare the different ways we can calculate three-fourths of a value:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Benchmarks</span>
<span>{</span>
    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Static"</span><span>,</span> Baseline <span>=</span> <span>true</span><span>)</span><span>]</span>
    <span>[</span><span>Arguments</span><span>(</span><span>13.37</span><span>)</span><span>]</span>
    <span>public</span> <span>double</span> <span>Static</span><span>(</span><span>double</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span>

    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Expressions"</span><span>)</span><span>]</span>
    <span>[</span><span>Arguments</span><span>(</span><span>13.37</span><span>)</span><span>]</span>
    <span>public</span> <span>double</span> <span>Expressions</span><span>(</span><span>double</span> x<span>)</span> <span>=&gt;</span> ThreeFourths<span>.</span><span>Of</span><span>(</span>x<span>)</span><span>;</span>

    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Dynamic"</span><span>)</span><span>]</span>
    <span>[</span><span>Arguments</span><span>(</span><span>13.37</span><span>)</span><span>]</span>
    <span>public</span> <span>dynamic</span> <span>Dynamic</span><span>(</span><span>dynamic</span> x<span>)</span> <span>=&gt;</span> <span>3</span> <span>*</span> x <span>/</span> <span>4</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>)</span> <span>=&gt;</span> BenchmarkRunner<span>.</span><span><span>Run</span><span>&lt;</span><span>Benchmarks</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<div data-language="r"><pre><code><span>|</span>      Method <span>|</span>     x <span>|</span>       Mean <span>|</span>     Error <span>|</span>    StdDev <span>|</span> Ratio <span>|</span> RatioSD <span>|</span>
<span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span> <span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span> <span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span>
<span>|</span>      Static <span>|</span> <span>13.37</span> <span>|</span>  <span>0.6077</span> ns <span>|</span> <span>0.0176</span> ns <span>|</span> <span>0.0147</span> ns <span>|</span>  <span>1.00</span> <span>|</span>    <span>0.00</span> <span>|</span>
<span>|</span>     Dynamic <span>|</span> <span>13.37</span> <span>|</span> <span>19.3267</span> ns <span>|</span> <span>0.1512</span> ns <span>|</span> <span>0.1340</span> ns <span>|</span> <span>31.82</span> <span>|</span>    <span>0.78</span> <span>|</span>
<span>|</span> Expressions <span>|</span> <span>13.37</span> <span>|</span>  <span>1.9510</span> ns <span>|</span> <span>0.0163</span> ns <span>|</span> <span>0.0145</span> ns <span>|</span>  <span>3.21</span> <span>|</span>    <span>0.08</span> <span>|</span></code></pre></div>
<p>As you can see, the expression-based approach performs about nine times faster than when using <code>dynamic</code>. Considering that these are the only two options we can use to implement generic operators, this is a pretty good case for compiled expression trees.</p>
<h2>Compiling dictionary into a switch expression</h2>
<p>Another fun way we can use expression trees is to create a dictionary with a compiled lookup. Even though the standard .NET <code>System.Collections.Generic.Dictionary</code> is insanely fast on its own, it‚Äôs possible to make its read operations even faster.</p>
<p>While a typical dictionary implementation may be pretty complicated, a lookup can be represented in a form of a simple switch expression:</p>
<div data-language="csharp"><pre><code>
<span>public</span> <span>TValue</span> <span>Lookup</span><span>(</span><span>TKey</span> key<span>)</span> <span>=&gt;</span> key<span>.</span><span>GetHashCode</span><span>(</span><span>)</span> <span>switch</span>
<span>{</span>
    
    <span>9254</span> <span>=&gt;</span> value1<span>,</span>
    <span>-</span><span>101</span> <span>=&gt;</span> value2<span>,</span>

    
    <span>777</span> <span>=&gt;</span> key <span>switch</span>
    <span>{</span>
        key3 <span>=&gt;</span> value3<span>,</span>
        key4 <span>=&gt;</span> value4
    <span>}</span><span>,</span>

    

    
    _ <span>=&gt;</span> <span>throw</span> <span>new</span> <span>KeyNotFoundException</span><span>(</span>key<span>.</span><span>ToString</span><span>(</span><span>)</span><span>)</span>
<span>}</span><span>;</span></code></pre></div>
<p>The function above attempts to match the hash code of the specified key with the hash code of one of the keys contained within the dictionary. If it‚Äôs successful, then the corresponding value is returned.</p>
<p>Even though hash codes are designed to be unique, inevitably there will be collisions. In such cases, when the same hash code matches with multiple different values, there is an inner switch expression that compares the actual key and determines which value to return.</p>
<p>Finally, if none of the cases matched, it throws an exception signifying that the dictionary doesn‚Äôt contain the specified key.</p>
<p>The idea is that, since a switch is faster than a hash table, dynamically compiling all key-value pairs into a switch expression like the one above should result in a faster dictionary lookup.</p>
<p>Let‚Äôs try it out. Here‚Äôs how the code for that would look:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>CompiledDictionary</span><span>&lt;</span>TKey<span>,</span> TValue<span>&gt;</span> <span>:</span> IDictionary<span>&lt;</span>TKey<span>,</span> TValue<span>&gt;</span>
<span>{</span>
    <span>private</span> <span>readonly</span> IDictionary<span>&lt;</span>TKey<span>,</span> TValue<span>&gt;</span> _inner <span>=</span> <span>new</span> <span><span>Dictionary</span><span>&lt;</span><span>TKey</span><span>,</span> <span>TValue</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>

    <span>private</span> Func<span>&lt;</span>TKey<span>,</span> TValue<span>&gt;</span> _lookup<span>;</span>

    <span>public</span> <span>CompiledDictionary</span><span>(</span><span>)</span> <span>=&gt;</span> <span>UpdateLookup</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>UpdateLookup</span><span>(</span><span>)</span>
    <span>{</span>
        
        <span>var</span> keyParameter <span>=</span> Expression<span>.</span><span>Parameter</span><span>(</span><span>typeof</span><span>(</span>TKey<span>)</span><span>)</span><span>;</span>

        
        <span>var</span> keyGetHashCodeCall <span>=</span> Expression<span>.</span><span>Call</span><span>(</span>
            keyParameter<span>,</span>
            <span>typeof</span><span>(</span><span>object</span><span>)</span><span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span>GetHashCode<span>)</span><span>)</span><span>)</span><span>;</span>

        
        <span>var</span> keyToStringCall <span>=</span> Expression<span>.</span><span>Call</span><span>(</span>
            keyParameter<span>,</span>
            <span>typeof</span><span>(</span><span>object</span><span>)</span><span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span>ToString<span>)</span><span>)</span><span>)</span><span>;</span>

        
        <span>var</span> exceptionCtor <span>=</span> <span>typeof</span><span>(</span>KeyNotFoundException<span>)</span>
            <span>.</span><span>GetConstructor</span><span>(</span><span>new</span><span>[</span><span>]</span> <span>{</span><span>typeof</span><span>(</span><span>string</span><span>)</span><span>}</span><span>)</span><span>;</span>

        <span>var</span> throwException <span>=</span> Expression<span>.</span><span>Throw</span><span>(</span>
            Expression<span>.</span><span>New</span><span>(</span>exceptionCtor<span>,</span> keyToStringCall<span>)</span><span>,</span>
            <span>typeof</span><span>(</span>TValue<span>)</span><span>)</span><span>;</span>

        
        <span>var</span> body <span>=</span> Expression<span>.</span><span>Switch</span><span>(</span>
            <span>typeof</span><span>(</span>TValue<span>)</span><span>,</span> 
            keyGetHashCodeCall<span>,</span> 
            throwException<span>,</span> 
            <span>null</span><span>,</span> 
            _inner 
                <span>.</span><span>GroupBy</span><span>(</span>p <span>=&gt;</span> p<span>.</span>Key<span>.</span><span>GetHashCode</span><span>(</span><span>)</span><span>)</span>
                <span>.</span><span>Select</span><span>(</span>g <span>=&gt;</span>
                <span>{</span>
                    
                    <span>if</span> <span>(</span>g<span>.</span><span>Count</span><span>(</span><span>)</span> <span>==</span> <span>1</span><span>)</span>
                        <span>return</span> Expression<span>.</span><span>SwitchCase</span><span>(</span>
                            Expression<span>.</span><span>Constant</span><span>(</span>g<span>.</span><span>Single</span><span>(</span><span>)</span><span>.</span>Value<span>)</span><span>,</span> 
                            Expression<span>.</span><span>Constant</span><span>(</span>g<span>.</span>Key<span>)</span><span>)</span><span>;</span> 

                    
                    <span>return</span> Expression<span>.</span><span>SwitchCase</span><span>(</span>
                        Expression<span>.</span><span>Switch</span><span>(</span>
                            <span>typeof</span><span>(</span>TValue<span>)</span><span>,</span>
                            keyParameter<span>,</span> 
                            throwException<span>,</span>
                            <span>null</span><span>,</span>
                            g<span>.</span><span>Select</span><span>(</span>p <span>=&gt;</span> Expression<span>.</span><span>SwitchCase</span><span>(</span>
                                Expression<span>.</span><span>Constant</span><span>(</span>p<span>.</span>Value<span>)</span><span>,</span>
                                Expression<span>.</span><span>Constant</span><span>(</span>p<span>.</span>Key<span>)</span>
                            <span>)</span><span>)</span><span>)</span><span>,</span>
                        Expression<span>.</span><span>Constant</span><span>(</span>g<span>.</span>Key<span>)</span><span>)</span><span>;</span>
                <span>}</span><span>)</span><span>)</span><span>;</span>

        <span>var</span> lambda <span>=</span> Expression<span>.</span>Lambda<span>&lt;</span>Func<span>&lt;</span>TKey<span>,</span> TValue<span>&gt;&gt;</span><span>(</span>body<span>,</span> keyParameter<span>)</span><span>;</span>

        _lookup <span>=</span> lambda<span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>TValue</span> <span>this</span><span>[</span><span>TKey</span> key<span>]</span>
    <span>{</span>
        <span>get</span> <span>=&gt;</span> <span>_lookup</span><span>(</span>key<span>)</span><span>;</span>
        <span>set</span> <span>=&gt;</span> _inner<span>[</span>key<span>]</span> <span>=</span> <span>value</span><span>;</span>
    <span>}</span>

    
<span>}</span></code></pre></div>
<p>The method <code>UpdateLookup</code> takes all of the key-value pairs contained within the inner dictionary and groups them by the hash codes of their keys, which are then transformed into switch cases. If there is no collision for a particular hash code, then the switch case is made up of a single constant expression that produces the corresponding value. Otherwise, it contains an inner switch expression that further evaluates the key to determine which value to return.</p>
<p>Let‚Äôs see how well this dictionary performs when benchmarked against the standard implementation:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Benchmarks</span>
<span>{</span>
    <span>private</span> <span>readonly</span> Dictionary<span>&lt;</span><span>string</span><span>,</span> <span>int</span><span>&gt;</span> _normalDictionary <span>=</span>
        <span>new</span> <span><span>Dictionary</span><span>&lt;</span><span>string</span><span>,</span> <span>int</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>

    <span>private</span> <span>readonly</span> CompiledDictionary<span>&lt;</span><span>string</span><span>,</span> <span>int</span><span>&gt;</span> _compiledDictionary <span>=</span>
        <span>new</span> <span><span>CompiledDictionary</span><span>&lt;</span><span>string</span><span>,</span> <span>int</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>

    <span>[</span><span>Params</span><span>(</span><span>10</span><span>,</span> <span>1000</span><span>,</span> <span>10000</span><span>)</span><span>]</span>
    <span>public</span> <span>int</span> Count <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>

    <span>public</span> <span>string</span> TargetKey <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>

    <span>[</span><span>GlobalSetup</span><span>]</span>
    <span>public</span> <span>void</span> <span>Setup</span><span>(</span><span>)</span>
    <span>{</span>
        
        <span>foreach</span> <span>(</span><span>var</span> i <span>in</span> Enumerable<span>.</span><span>Range</span><span>(</span><span>0</span><span>,</span> Count<span>)</span><span>)</span>
        <span>{</span>
            <span>var</span> key <span>=</span> $<span>"key_{i}"</span><span>;</span>

            _normalDictionary<span>[</span>key<span>]</span> <span>=</span> i<span>;</span>
            _compiledDictionary<span>[</span>key<span>]</span> <span>=</span> i<span>;</span>
        <span>}</span>

        
        _compiledDictionary<span>.</span><span>UpdateLookup</span><span>(</span><span>)</span><span>;</span>

        
        TargetKey <span>=</span> $<span>"key_{Count / 2}"</span><span>;</span>
    <span>}</span>

    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Standard dictionary"</span><span>,</span> Baseline <span>=</span> <span>true</span><span>)</span><span>]</span>
    <span>public</span> <span>int</span> <span>Normal</span><span>(</span><span>)</span> <span>=&gt;</span> _normalDictionary<span>[</span><span>TargetKey</span><span>]</span><span>;</span>

    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Compiled dictionary"</span><span>)</span><span>]</span>
    <span>public</span> <span>int</span> <span>Compiled</span><span>(</span><span>)</span> <span>=&gt;</span> _compiledDictionary<span>[</span><span>TargetKey</span><span>]</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>)</span> <span>=&gt;</span> BenchmarkRunner<span>.</span><span><span>Run</span><span>&lt;</span><span>Benchmarks</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<div data-language="r"><pre><code><span>|</span>              Method <span>|</span> Count <span>|</span>      Mean <span>|</span>     Error <span>|</span>    StdDev <span>|</span> Ratio <span>|</span>
<span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span> <span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span> <span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span>
<span>|</span> Standard dictionary <span>|</span>    <span>10</span> <span>|</span> <span>24.995</span> ns <span>|</span> <span>0.1821</span> ns <span>|</span> <span>0.1704</span> ns <span>|</span>  <span>1.00</span> <span>|</span>
<span>|</span> Compiled dictionary <span>|</span>    <span>10</span> <span>|</span>  <span>9.366</span> ns <span>|</span> <span>0.0511</span> ns <span>|</span> <span>0.0478</span> ns <span>|</span>  <span>0.37</span> <span>|</span>
<span>|</span>                     <span>|</span>       <span>|</span>           <span>|</span>           <span>|</span>           <span>|</span>       <span>|</span>
<span>|</span> Standard dictionary <span>|</span>  <span>1000</span> <span>|</span> <span>25.105</span> ns <span>|</span> <span>0.0665</span> ns <span>|</span> <span>0.0622</span> ns <span>|</span>  <span>1.00</span> <span>|</span>
<span>|</span> Compiled dictionary <span>|</span>  <span>1000</span> <span>|</span> <span>14.819</span> ns <span>|</span> <span>0.1138</span> ns <span>|</span> <span>0.1065</span> ns <span>|</span>  <span>0.59</span> <span>|</span>
<span>|</span>                     <span>|</span>       <span>|</span>           <span>|</span>           <span>|</span>           <span>|</span>       <span>|</span>
<span>|</span> Standard dictionary <span>|</span> <span>10000</span> <span>|</span> <span>29.047</span> ns <span>|</span> <span>0.1201</span> ns <span>|</span> <span>0.1123</span> ns <span>|</span>  <span>1.00</span> <span>|</span>
<span>|</span> Compiled dictionary <span>|</span> <span>10000</span> <span>|</span> <span>17.903</span> ns <span>|</span> <span>0.0635</span> ns <span>|</span> <span>0.0530</span> ns <span>|</span>  <span>0.62</span> <span>|</span></code></pre></div>
<p>We can see that the compiled dictionary performs lookups about 1.6-2.8 times faster. While the performance of the hash table is consistent regardless of how many elements are in the dictionary, the expression tree implementation becomes slower as the dictionary gets bigger. This can potentially be remedied by adding another switch layer for indexing.</p>
<h2>Parsing DSLs into expressions</h2>
<p>One other interesting usage scenario, that I‚Äôm personally really fond of, is parsing. The main challenge of writing an interpreter for a custom domain-specific language is turning the syntax tree into runtime instructions. By parsing the grammar constructs directly into expression trees, this becomes a solved problem.</p>
<p>As an example, let‚Äôs write a simple program that takes a string representation of a mathematical expression and evaluates its result. To implement the parser, we will use the <a href="https://github.com/sprache/Sprache">Sprache</a> library.</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>class</span> <span>SimpleCalculator</span>
<span>{</span>
    <span>private</span> <span>static</span> <span>readonly</span> Parser<span>&lt;</span>Expression<span>&gt;</span> Constant <span>=</span>
        Parse<span>.</span>DecimalInvariant
            <span>.</span><span>Select</span><span>(</span>n <span>=&gt;</span> <span>double</span><span>.</span><span>Parse</span><span>(</span>n<span>,</span> CultureInfo<span>.</span>InvariantCulture<span>)</span><span>)</span>
            <span>.</span><span>Select</span><span>(</span>n <span>=&gt;</span> Expression<span>.</span><span>Constant</span><span>(</span>n<span>,</span> <span>typeof</span><span>(</span><span>double</span><span>)</span><span>)</span><span>)</span>
            <span>.</span><span>Token</span><span>(</span><span>)</span><span>;</span>

    <span>private</span> <span>static</span> <span>readonly</span> Parser<span>&lt;</span>ExpressionType<span>&gt;</span> Operator <span>=</span>
        Parse<span>.</span><span>Char</span><span>(</span><span>'+'</span><span>)</span><span>.</span><span>Return</span><span>(</span>ExpressionType<span>.</span>Add<span>)</span>
            <span>.</span><span>Or</span><span>(</span>Parse<span>.</span><span>Char</span><span>(</span><span>'-'</span><span>)</span><span>.</span><span>Return</span><span>(</span>ExpressionType<span>.</span>Subtract<span>)</span><span>)</span>
            <span>.</span><span>Or</span><span>(</span>Parse<span>.</span><span>Char</span><span>(</span><span>'*'</span><span>)</span><span>.</span><span>Return</span><span>(</span>ExpressionType<span>.</span>Multiply<span>)</span><span>)</span>
            <span>.</span><span>Or</span><span>(</span>Parse<span>.</span><span>Char</span><span>(</span><span>'/'</span><span>)</span><span>.</span><span>Return</span><span>(</span>ExpressionType<span>.</span>Divide<span>)</span><span>)</span><span>;</span>

    <span>private</span> <span>static</span> <span>readonly</span> Parser<span>&lt;</span>Expression<span>&gt;</span> Operation <span>=</span>
        Parse<span>.</span><span>ChainOperator</span><span>(</span>Operator<span>,</span> Constant<span>,</span> Expression<span>.</span>MakeBinary<span>)</span><span>;</span>

    <span>private</span> <span>static</span> <span>readonly</span> Parser<span>&lt;</span>Expression<span>&gt;</span> FullExpression <span>=</span>
        Operation<span>.</span><span>Or</span><span>(</span>Constant<span>)</span><span>.</span><span>End</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>double</span> <span>Run</span><span>(</span><span>string</span> expression<span>)</span>
    <span>{</span>
        <span>var</span> operation <span>=</span> FullExpression<span>.</span><span>Parse</span><span>(</span>expression<span>)</span><span>;</span>
        <span>var</span> func <span>=</span> Expression<span>.</span>Lambda<span>&lt;</span>Func<span>&lt;</span><span>double</span><span>&gt;&gt;</span><span>(</span>operation<span>)</span><span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>

        <span>return</span> <span>func</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>As you can see, the parsers defined above (<code>Constant</code>, <code>Operator</code>, <code>Operation</code>, <code>FullExpression</code>) all yield objects of type <code>Expression</code> and <code>ExpressionType</code>, which are both defined in <code>System.Linq.Expressions</code>. The expression tree is essentially our syntax tree, so once we parse the input we have all the required information to compile the runtime instructions represented by it.</p>
<p>You can try it out by calling <code>Run</code>:</p>
<div data-language="csharp"><pre><code><span>var</span> a <span>=</span> SimpleCalculator<span>.</span><span>Run</span><span>(</span><span>"2 + 2"</span><span>)</span><span>;</span>        
<span>var</span> b <span>=</span> SimpleCalculator<span>.</span><span>Run</span><span>(</span><span>"3.15 * 5 + 2"</span><span>)</span><span>;</span> 
<span>var</span> c <span>=</span> SimpleCalculator<span>.</span><span>Run</span><span>(</span><span>"1 / 2 * 3"</span><span>)</span><span>;</span>    </code></pre></div>
<p>Note that this simple calculator is just an example of what you can do, it doesn‚Äôt respect operator precedence and doesn‚Äôt understand nested expressions. Implementing a parser for that would be out of scope of covering expression trees, but if you want to see how a proper calculator like that would look, check out <a href="https://github.com/yallie/Sprache.Calc/blob/master/Sprache.Calc/SimpleCalculator.cs">Sprache.Calc</a>. Also, if you want to learn more about parsing, check out my blog posts about <a href="https://tyrrrz.me/blog/monadic-parser-combinators">parsing in C#</a> and <a href="https://tyrrrz.me/blog/parsing-with-fparsec">parsing in F#</a>.</p>
<h2>Making things even faster</h2>
<p>While compiled expressions execute really fast, compiling them can be relatively expensive.</p>
<p>In most cases that‚Äôs completely fine, but you may want to take the performance even further by using <a href="https://github.com/dadhi/FastExpressionCompiler">FastExpressionCompiler</a>. This library provides a drop-in replacement for the <code>Compile</code> method called <code>CompileFast</code>, which executes much faster.</p>
<p>For example, here‚Äôs a simple benchmark that shows the difference:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Benchmarks</span>
<span>{</span>
    <span>private</span> <span>static</span> <span>Expression</span> Body <span>{</span> <span>get</span><span>;</span> <span>}</span> <span>=</span>
        Expression<span>.</span><span>Add</span><span>(</span>Expression<span>.</span><span>Constant</span><span>(</span><span>3</span><span>)</span><span>,</span> Expression<span>.</span><span>Constant</span><span>(</span><span>5</span><span>)</span><span>)</span><span>;</span>

    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Compile"</span><span>,</span> Baseline <span>=</span> <span>true</span><span>)</span><span>]</span>
    <span>public</span> Func<span>&lt;</span><span>int</span><span>&gt;</span> <span>Normal</span><span>(</span><span>)</span> <span>=&gt;</span> Expression<span>.</span>Lambda<span>&lt;</span>Func<span>&lt;</span><span>int</span><span>&gt;&gt;</span><span>(</span>Body<span>)</span><span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>

    <span>[</span><span>Benchmark</span><span>(</span>Description <span>=</span> <span>"Compile (fast)"</span><span>)</span><span>]</span>
    <span>public</span> Func<span>&lt;</span><span>int</span><span>&gt;</span> <span>Fast</span><span>(</span><span>)</span> <span>=&gt;</span> Expression<span>.</span>Lambda<span>&lt;</span>Func<span>&lt;</span><span>int</span><span>&gt;&gt;</span><span>(</span>Body<span>)</span><span>.</span><span>CompileFast</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>)</span> <span>=&gt;</span> BenchmarkRunner<span>.</span><span><span>Run</span><span>&lt;</span><span>Benchmarks</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<div data-language="r"><pre><code><span>|</span>         Method <span>|</span>      Mean <span>|</span>     Error <span>|</span>    StdDev <span>|</span> Ratio <span>|</span> Allocated <span>|</span>
<span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span> <span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>-</span><span>:</span><span>|</span>
<span>|</span>        Compile <span>|</span> <span>38.435</span> us <span>|</span> <span>0.2131</span> us <span>|</span> <span>0.1889</span> us <span>|</span>  <span>1.00</span> <span>|</span>   <span>3.53</span> KB <span>|</span>
<span>|</span> Compile <span>(</span>fast<span>)</span> <span>|</span>  <span>4.497</span> us <span>|</span> <span>0.0662</span> us <span>|</span> <span>0.0619</span> us <span>|</span>  <span>0.12</span> <span>|</span>   <span>1.21</span> KB <span>|</span></code></pre></div>
<p>As you can see, the performance improvement is pretty noticeable. The reason it runs so fast is because the <code>CompileFast</code> version skips all the verifications that normal <code>Compile</code> does to ensure that the expression tree is valid.</p>
<p>This library (as part of <code>FastExpressionCompiler.LightExpression</code>) also offers a drop-in replacement for <code>Expression</code> and all of its static factory methods. These alternative implementations construct expressions which may in some cases perform much faster than their default counterparts. However, I still recommend to benchmark it on your particular use cases to ensure that it actually provides an improvement.</p>
<h2>Inferring expression trees from code</h2>
<p>So far we‚Äôve explored how to construct expression trees manually. The cool thing about expression trees in .NET though is that they can also be created automatically as well.</p>
<p>The way this works is that you can infer an expression tree by simply specifying a lambda expression like you would if you were to define a delegate. C# compiler will take care of the rest.</p>
<p>Consider this snippet of code:</p>
<div data-language="csharp"><pre><code>Func<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>,</span> <span>int</span><span>&gt;</span> div <span>=</span>
    <span>(</span>a<span>,</span> b<span>)</span> <span>=&gt;</span> a <span>/</span> b<span>;</span>

Expression<span>&lt;</span>Func<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>,</span> <span>int</span><span>&gt;&gt;</span> divExpr <span>=</span>
    <span>(</span>a<span>,</span> b<span>)</span> <span>=&gt;</span> a <span>/</span> b<span>;</span></code></pre></div>
<p>Both of these assignments look exactly the same, but the actual assigned value is different. While in the first case we will get a delegate which can be executed directly, the second will provide us with an expression tree that represents the structure of the supplied lambda expression. This is essentially the same <code>LambdaExpression</code> that we were creating when compiling code ourselves, only now it represents code written statically as opposed to dynamically.</p>
<p>For example, we can inspect the expression tree produced by the compiler:</p>
<div data-language="csharp"><pre><code>Expression<span>&lt;</span>Func<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>,</span> <span>int</span><span>&gt;&gt;</span> divExpr <span>=</span>
    <span>(</span>a<span>,</span> b<span>)</span> <span>=&gt;</span> a <span>/</span> b<span>;</span>

<span>foreach</span> <span>(</span><span>var</span> param <span>in</span> divExpr<span>.</span>Parameters<span>)</span>
    Console<span>.</span><span>WriteLine</span><span>(</span>$<span>"Param: {param.Name} ({param.Type.Name})"</span><span>)</span><span>;</span>


</code></pre></div>
<p>And, just like with expression trees created manually, we can compile it into a delegate:</p>
<div data-language="csharp"><pre><code>Expression<span>&lt;</span>Func<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>,</span> <span>int</span><span>&gt;&gt;</span> divExpr <span>=</span>
    <span>(</span>a<span>,</span> b<span>)</span> <span>=&gt;</span> a <span>/</span> b<span>;</span>

<span>var</span> div <span>=</span> divExpr<span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>

<span>var</span> c <span>=</span> <span>div</span><span>(</span><span>10</span><span>,</span> <span>2</span><span>)</span><span>;</span> </code></pre></div>
<p>Essentially, in this context, you can think of <code>divExpr</code> as a recipe that contains the ingredients needed to create <code>div</code>, the final product.</p>
<p>Note, however, that while direct assignment shown previously works, you can‚Äôt do something like this:</p>
<div data-language="csharp"><pre><code>Func<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>,</span> <span>int</span><span>&gt;</span> div <span>=</span> <span>(</span>a<span>,</span> b<span>)</span> <span>=&gt;</span> a <span>/</span> b<span>;</span>


Expression<span>&lt;</span>Func<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>,</span> <span>int</span><span>&gt;&gt;</span> divExpr <span>=</span> div<span>;</span></code></pre></div>
<p>The expression must be defined in-place in order to work. Because the disassembly happens during compile time, not runtime, the compiler needs to know exactly what it‚Äôs dealing with.</p>
<p>Although this approach is incredibly useful, it has certain limitations. Specifically, the supplied lambda expression must not contain any of the following:</p>
<ul>
<li>Null-coalescing operator (<code>obj?.Prop</code>)</li>
<li>Dynamic variables (<code>dynamic</code>)</li>
<li>Asynchronous code (<code>async</code>/<code>await</code>)</li>
<li>Default or named parameters (<code>func(a, b: 5)</code>, <code>func(a)</code>)</li>
<li>Parameters passed by reference (<code>int.TryParse("123", out var i)</code>)</li>
<li>Multi-dimensional array initializers (<code>new int[2, 2] { { 1, 2 }, { 3, 4 } }</code>)</li>
<li>Assignment operations (<code>a = 5</code>)</li>
<li>Increment and decrement (<code>a++</code>, <code>a--</code>, <code>--a</code>, <code>++a</code>)</li>
<li>Base type access (<code>base.Prop</code>)</li>
<li>Dictionary initialization (<code>new Dictionary&lt;string, int&gt; { ["foo"] = 100 }</code>)</li>
<li>Unsafe code (via <code>unsafe</code>)</li>
<li>Throw expressions (<code>throw new Exception()</code>)</li>
<li>Tuple literals (<code>(5, x)</code>)</li>
</ul>
<p>On top of all that, you cannot use this method to construct expression trees from multi-line lambdas. That means this won‚Äôt compile:</p>
<div data-language="csharp"><pre><code>
Expression<span>&lt;</span>Func<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>,</span> <span>int</span><span>&gt;&gt;</span> divExpr <span>=</span> <span>(</span>a<span>,</span> b<span>)</span> <span>=&gt;</span>
<span>{</span>
    <span>var</span> result <span>=</span> a <span>/</span> b<span>;</span>
    <span>return</span> result<span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>And, more importantly, this won‚Äôt work either:</p>
<div data-language="csharp"><pre><code>
Expression<span>&lt;</span>Action<span>&gt;</span> writeToConsole <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span>
<span>{</span>
    Console<span>.</span><span>Write</span><span>(</span><span>"Hello "</span><span>)</span><span>;</span>
    Console<span>.</span><span>WriteLine</span><span>(</span><span>"world!"</span><span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>Most of these limitations come from the fact that this feature was designed with <code>IQueryable</code> in mind and many of the language constructs listed above don‚Äôt really make sense when it comes to querying data. That said, there are a lot of other scenarios where they can be useful.</p>
<p>There is a suggestion to extend compile-time expression trees and it‚Äôs tracked <a href="https://github.com/dotnet/csharplang/issues/158">by this issue on GitHub</a>. We‚Äôll see where it goes.</p>
<p>For now, let‚Äôs move these limitations aside and explore some of the ways we can use expression trees constructed with this approach.</p>
<h2>Identifying type members</h2>
<p>The most common use case for expression trees obtained in such manner is to identify type members. This approach allows us to extract information on fields, properties, or methods from a supplied lambda expression.</p>
<p>For example, assume we have the following class:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Dto</span>
<span>{</span>
    <span>public</span> <span>Guid</span> Id <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>

    <span>public</span> <span>string</span> Name <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
<span>}</span></code></pre></div>
<p>If we wanted to get the <code>PropertyInfo</code> that represents its <code>Id</code> property, we could use reflection to do it like this:</p>
<div data-language="csharp"><pre><code><span>var</span> idProperty <span>=</span> <span>typeof</span><span>(</span>Dto<span>)</span><span>.</span><span>GetProperty</span><span>(</span><span>nameof</span><span>(</span>Dto<span>.</span>Id<span>)</span><span>)</span><span>;</span>

Console<span>.</span><span>WriteLine</span><span>(</span>$<span>"Type: {idProperty.DeclaringType.Name}"</span><span>)</span><span>;</span>
Console<span>.</span><span>WriteLine</span><span>(</span>$<span>"Property: {idProperty.Name} ({idProperty.PropertyType.Name})"</span><span>)</span><span>;</span>


</code></pre></div>
<p>That works completely fine. For example, if we were designing an API for a validation library, it could look like this:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Validator</span><span>&lt;</span>T<span>&gt;</span>
<span>{</span>
    
    <span>public</span> <span>void</span> <span><span>AddValidation</span><span>&lt;</span><span>TProp</span><span>&gt;</span></span><span>(</span><span>string</span> propertyName<span>,</span> Func<span>&lt;</span>TProp<span>,</span> <span>bool</span><span>&gt;</span> predicate<span>)</span>
    <span>{</span>
        <span>var</span> propertyInfo <span>=</span> <span>typeof</span><span>(</span>T<span>)</span><span>.</span><span>GetProperty</span><span>(</span>propertyName<span>)</span><span>;</span>

        <span>if</span> <span>(</span>propertyInfo <span>is</span> <span>null</span><span>)</span>
            <span>throw</span> <span>new</span> <span>InvalidOperationException</span><span>(</span><span>"Please provide a valid property name."</span><span>)</span><span>;</span>

        
    <span>}</span>

    
    <span>public</span> <span>bool</span> <span>Validate</span><span>(</span><span>T</span> obj<span>)</span> <span>{</span>  <span>}</span>

    
<span>}</span></code></pre></div>
<p>Which we would be able to use like this:</p>
<div data-language="csharp"><pre><code><span>var</span> validator <span>=</span> <span>new</span> <span><span>Validator</span><span>&lt;</span><span>Dto</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
validator<span>.</span><span><span>AddValidation</span><span>&lt;</span><span>Guid</span><span>&gt;</span></span><span>(</span><span>nameof</span><span>(</span>Dto<span>.</span>Id<span>)</span><span>,</span> id <span>=&gt;</span> id <span>!=</span> Guid<span>.</span>Empty<span>)</span><span>;</span>
validator<span>.</span><span><span>AddValidation</span><span>&lt;</span><span>string</span><span>&gt;</span></span><span>(</span><span>nameof</span><span>(</span>Dto<span>.</span>Name<span>)</span><span>,</span> name <span>=&gt;</span> <span>!</span><span>string</span><span>.</span><span>IsNullOrWhiteSpace</span><span>(</span>name<span>)</span><span>)</span><span>;</span>

<span>var</span> isValid <span>=</span> validator<span>.</span><span>Validate</span><span>(</span><span>new</span> <span>Dto</span> <span>{</span> Id <span>=</span> Guid<span>.</span><span>NewGuid</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> </code></pre></div>
<p>However, the problem here is that all of our validators are effectively untyped. We have to specify the generic argument in <code>AddValidation</code> so that our predicates are aware of what they‚Äôre working with, but this setup is very volatile.</p>
<p>If we were to, for example, change the type of <code>Dto.Id</code> from <code>Guid</code> to <code>int</code>, everything will still compile but the code will no longer work correctly because our predicate expects the type to be <code>Guid</code>. Also, we‚Äôd be lucky if our users were to provide the property names using <code>nameof</code>, in reality there will probably be magic strings instead. All in all, this code is not refactor-safe.</p>
<p>With expressions we can completely remedy this:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Validator</span><span>&lt;</span>T<span>&gt;</span>
<span>{</span>
    <span>public</span> <span>void</span> <span><span>AddValidation</span><span>&lt;</span><span>TProp</span><span>&gt;</span></span><span>(</span>
        Expression<span>&lt;</span>Func<span>&lt;</span>T<span>,</span> TProp<span>&gt;&gt;</span> propertyExpression<span>,</span>
        Func<span>&lt;</span>TProp<span>,</span> <span>bool</span><span>&gt;</span> predicate<span>)</span>
    <span>{</span>
        <span>var</span> propertyInfo <span>=</span> <span>(</span>propertyExpression<span>.</span><span>Body</span> <span>as</span> MemberExpression<span>)</span><span>?.</span><span>Member</span> <span>as</span> PropertyInfo<span>;</span>

        <span>if</span> <span>(</span>propertyInfo <span>is</span> <span>null</span><span>)</span>
            <span>throw</span> <span>new</span> <span>InvalidOperationException</span><span>(</span><span>"Please provide a valid property expression."</span><span>)</span><span>;</span>

        
    <span>}</span>

    <span>public</span> <span>bool</span> <span>Validate</span><span>(</span><span>T</span> obj<span>)</span> <span>{</span>  <span>}</span>

    
<span>}</span></code></pre></div>
<p>With the new interface we can write our code like this instead:</p>
<div data-language="csharp"><pre><code><span>var</span> validator <span>=</span> <span>new</span> <span><span>Validator</span><span>&lt;</span><span>Dto</span><span>&gt;</span></span><span>(</span><span>)</span><span>;</span>
validator<span>.</span><span>AddValidation</span><span>(</span>dto <span>=&gt;</span> dto<span>.</span>Id<span>,</span> id <span>=&gt;</span> id <span>!=</span> Guid<span>.</span>Empty<span>)</span><span>;</span>
validator<span>.</span><span>AddValidation</span><span>(</span>dto <span>=&gt;</span> dto<span>.</span>Name<span>,</span> name <span>=&gt;</span> <span>!</span><span>string</span><span>.</span><span>IsNullOrWhiteSpace</span><span>(</span>name<span>)</span><span>)</span><span>;</span>

<span>var</span> isValid <span>=</span> validator<span>.</span><span>Validate</span><span>(</span><span>new</span> <span>Dto</span> <span>{</span> Id <span>=</span> Guid<span>.</span><span>NewGuid</span><span>(</span><span>)</span> <span>}</span><span>)</span><span>;</span> </code></pre></div>
<p>This works exactly the same, except that now we don‚Äôt need to specify generic arguments manually, there are no magic strings, and the code is completely safe to refactor. If we change the type of <code>Dto.Id</code> from <code>Guid</code> to <code>int</code>, our code will rightfully no longer compile.</p>
<p>Many existing libraries are using expression trees for this purpose, including:</p>
<ul>
<li><a href="https://github.com/JeremySkinner/FluentValidation">FluentValidation</a> uses it to setup validation rules</li>
<li><a href="https://github.com/dotnet/efcore">EntityFramework</a> uses it for entity configuration</li>
<li><a href="https://github.com/moq/moq4">Moq</a> uses it to build mocks</li>
</ul>
<h2>Providing context to assertions</h2>
<p>Often when I‚Äôm writing test suites for my projects, I find myself spending time decorating assertions with informational error messages. For example:</p>
<div data-language="csharp"><pre><code><span>[</span><span>Test</span><span>]</span>
<span>public</span> <span>void</span> <span>IntTryParse_Test</span><span>(</span><span>)</span>
<span>{</span>
    
    <span>const</span> <span>string</span> s <span>=</span> <span>"123"</span><span>;</span>

    
    <span>var</span> result <span>=</span> <span>int</span><span>.</span><span>TryParse</span><span>(</span>s<span>,</span> <span>out</span> <span>var</span> <span>value</span><span>)</span><span>;</span>

    
    Assert<span>.</span><span>That</span><span>(</span>result<span>,</span> Is<span>.</span>True<span>,</span> <span>"Parsing was unsuccessful"</span><span>)</span><span>;</span>
    Assert<span>.</span><span>That</span><span>(</span><span>value</span><span>,</span> Is<span>.</span><span>EqualTo</span><span>(</span><span>124</span><span>)</span><span>,</span> <span>"Parsed value is incorrect"</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>By doing that, the errors produced by failed assertions become more descriptive. This makes it easier to understand what went wrong without having to look inside the test implementation:</p>
<div data-language="ini"><pre><code>X IntTryParse_Test [60ms]
  Error Message:
    Parsed value is incorrect
  Expected: 124
  But was:  123</code></pre></div>
<p>In a perfect world, however, it would be nice if the error message simply contained the code of the assertion. That way I would know which exact check failed and why.</p>
<p>Luckily, this is something we can do with the help of expressions. To facilitate that, we can create a helper method that will wrap the assertion in an expression:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>class</span> <span>AssertEx</span>
<span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>Express</span><span>(</span>Expression<span>&lt;</span>Action<span>&gt;</span> expression<span>)</span>
    <span>{</span>
        <span>var</span> act <span>=</span> expression<span>.</span><span>Compile</span><span>(</span><span>)</span><span>;</span>

        <span>try</span>
        <span>{</span>
            <span>act</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        <span>catch</span> <span>(</span><span>AssertionException</span> ex<span>)</span>
        <span>{</span>
            <span>throw</span> <span>new</span> <span>AssertionException</span><span>(</span>
                expression<span>.</span>Body<span>.</span><span>ToReadableString</span><span>(</span><span>)</span> <span>+</span>
                Environment<span>.</span>NewLine <span>+</span>
                ex<span>.</span>Message<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>This method is really simple. All it does is try to run the delegate represented by the expression and, if the underlying assertion fails, it prints the expression along with the error.</p>
<p>Let‚Äôs update our test code to make use of this method:</p>
<div data-language="csharp"><pre><code><span>[</span><span>Test</span><span>]</span>
<span>public</span> <span>void</span> <span>IntTryParse_Test</span><span>(</span><span>)</span>
<span>{</span>
    
    <span>const</span> <span>string</span> s <span>=</span> <span>"123"</span><span>;</span>

    
    <span>var</span> result <span>=</span> <span>int</span><span>.</span><span>TryParse</span><span>(</span>s<span>,</span> <span>out</span> <span>var</span> <span>value</span><span>)</span><span>;</span>

    
    AssertEx<span>.</span><span>Express</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> Assert<span>.</span><span>That</span><span>(</span>result<span>,</span> Is<span>.</span>True<span>)</span><span>)</span><span>;</span>
    AssertEx<span>.</span><span>Express</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> Assert<span>.</span><span>That</span><span>(</span><span>value</span><span>,</span> Is<span>.</span><span>EqualTo</span><span>(</span><span>124</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>Now, when this test fails we will instead get the following error message:</p>
<div data-language="ini"><pre><code>X IntTryParse_Test [99ms]
  Error Message:
    Assert.That(value, Is.EqualTo(124))
  Expected: 124
  But was:  123</code></pre></div>
<p>As you can see, the error message now specifies the exact assertion that failed. This gives us more context which helps determine what actually went wrong.</p>
<hr>
<p>With the advent of .NET Core 3.0, the .NET team has also added a new attribute, <code>CallerArgumentExpression</code>. This attribute was meant to be supported by a <a href="https://github.com/dotnet/csharplang/issues/287">language feature</a> that was planned for C# 8 but unfortunately it didn‚Äôt make it. Currently, the attribute doesn‚Äôt do anything, but we should see this change in one of the future versions of the language.</p>
<p>The goal of this attribute is to provide the ability to ‚Äúsniff‚Äù the expression passed to the specified parameter. For example, we should be able to define a method like this:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>void</span> <span>Assert</span><span>(</span>
    <span>bool</span> condition<span>,</span>
    <span>[</span><span>CallerArgumentExpression</span><span>(</span><span>"condition"</span><span>)</span><span>]</span> <span>string</span> expression <span>=</span> <span>""</span><span>)</span>
<span>{</span>
    <span>if</span> <span>(</span><span>!</span>condition<span>)</span>
        <span>throw</span> <span>new</span> <span>AssertionFailedException</span><span>(</span>$<span>"Condition `{expression}` is not true"</span><span>)</span><span>;</span>
<span>}</span></code></pre></div>
<p>Which will then produce a detailed exception message if the assertion fails:</p>

<p>Note that with this approach we will only be able to obtain the expression as a string, which will be the same expression specified in the source code. This can be used to provide a somewhat similar experience as shown with <code>AssertEx.Express</code> above.</p>
<h2>Traversing and rewriting expression trees</h2>
<p>In order to analyze expression trees, we need to be able to traverse them in a recursive descent manner, starting from the body of the lambda expression and going down to every expression it‚Äôs made out of. This could be done manually with a large switch expression that calls into itself.</p>
<p>Fortunately, we don‚Äôt have to reinvent the wheel because the framework already provides a special class for this purpose called <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.expressions.expressionvisitor"><code>ExpressionVisitor</code></a>. It‚Äôs an abstract class that has a visitor method for every expression type so you can simply inherit from it and override the methods you‚Äôre interested in.</p>
<p>For example, we can implement a visitor that prints out all the binary and method call expressions it encounters:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Visitor</span> <span>:</span> <span>ExpressionVisitor</span>
<span>{</span>
    <span>protected</span> <span>override</span> <span>Expression</span> <span>VisitMethodCall</span><span>(</span><span>MethodCallExpression</span> node<span>)</span>
    <span>{</span>
        Console<span>.</span><span>WriteLine</span><span>(</span>$<span>"Visited method call: {node}"</span><span>)</span><span>;</span>

        <span>return</span> <span>base</span><span>.</span><span>VisitMethodCall</span><span>(</span>node<span>)</span><span>;</span>
    <span>}</span>

    <span>protected</span> <span>override</span> <span>Expression</span> <span>VisitBinary</span><span>(</span><span>BinaryExpression</span> node<span>)</span>
    <span>{</span>
        Console<span>.</span><span>WriteLine</span><span>(</span>$<span>"Visited binary expression: {node}"</span><span>)</span><span>;</span>

        <span>return</span> <span>base</span><span>.</span><span>VisitBinary</span><span>(</span>node<span>)</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre></div>
<div data-language="csharp"><pre><code>Expression<span>&lt;</span>Func<span>&lt;</span><span>double</span><span>&gt;&gt;</span> expr <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> Math<span>.</span><span>Sin</span><span>(</span>Guid<span>.</span><span>NewGuid</span><span>(</span><span>)</span><span>.</span><span>GetHashCode</span><span>(</span><span>)</span><span>)</span> <span>/</span> <span>10</span><span>;</span>

<span>new</span> <span>Visitor</span><span>(</span><span>)</span><span>.</span><span>Visit</span><span>(</span>expr<span>)</span><span>;</span>




</code></pre></div>
<p>As you can see by the order of the logs, the visitor first encounters the binary expression that makes up the lambda body, then digs inside, revealing a call to <code>Math.Sin</code> whose parameter is also expressed as a call to <code>GetHashCode</code> on the result of <code>NewGuid</code>.</p>
<p>You may have noticed that the visitor methods on <code>ExpressionVisitor</code> all return <code>Expression</code>s. That means that besides merely inspecting them, the visitor can choose to rewrite or completely replace expressions with different ones.</p>
<p>Let‚Äôs change our visitor so that it catches all calls to method <code>Math.Sin</code> and rewrites them into <code>Math.Cos</code>:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>class</span> <span>Visitor</span> <span>:</span> <span>ExpressionVisitor</span>
<span>{</span>
    <span>protected</span> <span>override</span> <span>Expression</span> <span>VisitMethodCall</span><span>(</span><span>MethodCallExpression</span> node<span>)</span>
    <span>{</span>
        <span>var</span> newMethodCall <span>=</span> node<span>.</span>Method <span>==</span> <span>typeof</span><span>(</span>Math<span>)</span><span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span>Math<span>.</span>Sin<span>)</span><span>)</span>
            <span>?</span> <span>typeof</span><span>(</span>Math<span>)</span><span>.</span><span>GetMethod</span><span>(</span><span>nameof</span><span>(</span>Math<span>.</span>Cos<span>)</span><span>)</span>
            <span>:</span> node<span>.</span>Method<span>;</span>

        <span>return</span> Expression<span>.</span><span>Call</span><span>(</span>newMethodCall<span>,</span> node<span>.</span>Arguments<span>)</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre></div>
<div data-language="csharp"><pre><code>Expression<span>&lt;</span>Func<span>&lt;</span><span>double</span><span>&gt;&gt;</span> expr <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> Math<span>.</span><span>Sin</span><span>(</span>Guid<span>.</span><span>NewGuid</span><span>(</span><span>)</span><span>.</span><span>GetHashCode</span><span>(</span><span>)</span><span>)</span> <span>/</span> <span>10</span><span>;</span>
<span>var</span> result <span>=</span> expr<span>.</span><span>Compile</span><span>(</span><span>)</span><span>(</span><span>)</span><span>;</span>

Console<span>.</span><span>WriteLine</span><span>(</span>$<span>"Old expression: {expr.ToReadableString()}"</span><span>)</span><span>;</span>
Console<span>.</span><span>WriteLine</span><span>(</span>$<span>"Old result: {result}"</span><span>)</span><span>;</span>

<span>var</span> newExpr <span>=</span> <span>(</span>Expression<span>&lt;</span>Func<span>&lt;</span><span>double</span><span>&gt;&gt;</span><span>)</span> <span>new</span> <span>Visitor</span><span>(</span><span>)</span><span>.</span><span>Visit</span><span>(</span>expr<span>)</span><span>;</span>
<span>var</span> newResult <span>=</span> newExpr<span>.</span><span>Compile</span><span>(</span><span>)</span><span>(</span><span>)</span><span>;</span>

Console<span>.</span><span>WriteLine</span><span>(</span>$<span>"New expression: {newExpr.ToReadableString()}"</span><span>)</span><span>;</span>
Console<span>.</span><span>WriteLine</span><span>(</span>$<span>"New result value: {newResult}"</span><span>)</span><span>;</span>




</code></pre></div>
<p>As you can see, the new expression is structurally identical but with <code>Math.Sin</code> replaced by <code>Math.Cos</code>. Both expressions are completely independent and can be compiled to produce their respective delegates.</p>
<p>Using this approach we can arbitrarily rewrite supplied expressions, generating derivatives that behave differently. It can be very helpful when creating dynamic proxies. For example, a popular mocking library <a href="https://github.com/moq/moq4">Moq</a> uses this technique to build stubs at runtime.</p>
<h2>Transpiling code into a different language</h2>
<p>Now that we know that we can use <code>ExpressionVisitor</code> to analyze and rewrite expression trees, it‚Äôs not too hard to guess that we can also use it to transpile expressions into another language. The goal of such a tool would be to convert code from one language to another, while retaining its functional behavior.</p>
<p>Let‚Äôs imagine we‚Äôre building a library that allows users to convert C# expressions to their equivalent F# representations. For example, we want to be able to do this:</p>
<div data-language="csharp"><pre><code>Expression<span>&lt;</span>Action<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>&gt;&gt;</span> expr <span>=</span> <span>(</span>a<span>,</span> b<span>)</span> <span>=&gt;</span> Console<span>.</span><span>WriteLine</span><span>(</span><span>"a + b = {0}"</span><span>,</span> a <span>+</span> b<span>)</span><span>)</span><span>;</span>

<span>var</span> fsharpCode <span>=</span> FSharpTranspiler<span>.</span><span>Convert</span><span>(</span>expr<span>)</span><span>;</span></code></pre></div>
<p>To facilitate that, we can create a class called <code>FSharpTranspiler</code> which will internally use a special <code>ExpressionVisitor</code> to traverse the expression tree and write valid F# code. It could look something like this:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>class</span> <span>FSharpTranspiler</span>
<span>{</span>
    <span>private</span> <span>class</span> <span>Visitor</span> <span>:</span> <span>ExpressionVisitor</span>
    <span>{</span>
        <span>private</span> <span>readonly</span> <span>StringBuilder</span> _buffer<span>;</span>

        <span>public</span> <span>Visitor</span><span>(</span><span>StringBuilder</span> buffer<span>)</span>
        <span>{</span>
            _buffer <span>=</span> buffer<span>;</span>
        <span>}</span>

        
    <span>}</span>

    <span>public</span> <span>static</span> <span>string</span> <span><span>Convert</span><span>&lt;</span><span>T</span><span>&gt;</span></span><span>(</span>Expression<span>&lt;</span>T<span>&gt;</span> expression<span>)</span>
    <span>{</span>
        <span>var</span> buffer <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Visitor</span><span>(</span>buffer<span>)</span><span>.</span><span>Visit</span><span>(</span>expression<span>)</span><span>;</span>

        <span>return</span> buffer<span>.</span><span>ToString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>With this setup, we can inject a <code>StringBuilder</code> into our visitor and use that as the output buffer. While the visitor takes care of navigating the tree, we need to make sure we‚Äôre emitting valid code on each expression type.</p>
<p>Writing a full C# to F# transpiler would be too complicated and way outside of the scope of this article. For the sake of simplicity let‚Äôs limit our job to support expressions similar to the one we‚Äôve seen in the initial example. To handle these, we will need to translate <code>Console.WriteLine</code> into correct usage of <code>printfn</code>.</p>
<p>Here‚Äôs how we can do it:</p>
<div data-language="csharp"><pre><code><span>public</span> <span>static</span> <span>class</span> <span>FSharpTranspiler</span>
<span>{</span>
    <span>private</span> <span>class</span> <span>Visitor</span> <span>:</span> <span>ExpressionVisitor</span>
    <span>{</span>
        <span>private</span> <span>readonly</span> <span>StringBuilder</span> _buffer<span>;</span>

        <span>public</span> <span>Visitor</span><span>(</span><span>StringBuilder</span> buffer<span>)</span>
        <span>{</span>
            _buffer <span>=</span> buffer<span>;</span>
        <span>}</span>

        <span>protected</span> <span>override</span> Expression <span><span>VisitLambda</span><span>&lt;</span><span>T</span><span>&gt;</span></span><span>(</span>Expression<span>&lt;</span>T<span>&gt;</span> node<span>)</span>
        <span>{</span>
            _buffer<span>.</span><span>Append</span><span>(</span><span>"fun ("</span><span>)</span><span>;</span>
            _buffer<span>.</span><span>AppendJoin</span><span>(</span><span>", "</span><span>,</span> node<span>.</span>Parameters<span>.</span><span>Select</span><span>(</span>p <span>=&gt;</span> p<span>.</span>Name<span>)</span><span>)</span><span>;</span>
            _buffer<span>.</span><span>Append</span><span>(</span><span>") -&gt;"</span><span>)</span><span>;</span>

            <span>return</span> <span>base</span><span>.</span><span>VisitLambda</span><span>(</span>node<span>)</span><span>;</span>
        <span>}</span>

        <span>protected</span> <span>override</span> <span>Expression</span> <span>VisitMethodCall</span><span>(</span><span>MethodCallExpression</span> node<span>)</span>
        <span>{</span>
            <span>if</span> <span>(</span>node<span>.</span>Method<span>.</span>DeclaringType <span>==</span> <span>typeof</span><span>(</span>Console<span>)</span> <span>&amp;&amp;</span>
                node<span>.</span>Method<span>.</span>Name <span>==</span> <span>nameof</span><span>(</span>Console<span>.</span>WriteLine<span>)</span><span>)</span>
            <span>{</span>
                _buffer<span>.</span><span>Append</span><span>(</span><span>"printfn "</span><span>)</span><span>;</span>

                <span>if</span> <span>(</span>node<span>.</span>Arguments<span>.</span>Count <span>&gt;</span> <span>1</span><span>)</span>
                <span>{</span>
                    
                    <span>var</span> format <span>=</span> <span>(</span><span>string</span><span>)</span> <span>(</span><span>(</span>ConstantExpression<span>)</span> node<span>.</span>Arguments<span>[</span><span>0</span><span>]</span><span>)</span><span>.</span>Value<span>;</span>
                    <span>var</span> formatValues <span>=</span> node<span>.</span>Arguments<span>.</span><span>Skip</span><span>(</span><span>1</span><span>)</span><span>.</span><span>ToArray</span><span>(</span><span>)</span><span>;</span>

                    _buffer<span>.</span><span>Append</span><span>(</span><span>"\""</span><span>)</span><span>;</span>
                    _buffer<span>.</span><span>Append</span><span>(</span>Regex<span>.</span><span>Replace</span><span>(</span>format<span>,</span> <span>@"\{\d+\}"</span><span>,</span> <span>"%O"</span><span>)</span><span>)</span><span>;</span>
                    _buffer<span>.</span><span>Append</span><span>(</span><span>"\" "</span><span>)</span><span>;</span>

                    _buffer<span>.</span><span>AppendJoin</span><span>(</span><span>" "</span><span>,</span> formatValues<span>.</span><span>Select</span><span>(</span>v <span>=&gt;</span> $<span>"({v.ToReadableString()})"</span><span>)</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>

            <span>return</span> <span>base</span><span>.</span><span>VisitMethodCall</span><span>(</span>node<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>string</span> <span><span>Convert</span><span>&lt;</span><span>T</span><span>&gt;</span></span><span>(</span>Expression<span>&lt;</span>T<span>&gt;</span> expression<span>)</span>
    <span>{</span>
        <span>var</span> buffer <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Visitor</span><span>(</span>buffer<span>)</span><span>.</span><span>Visit</span><span>(</span>expression<span>)</span><span>;</span>

        <span>return</span> buffer<span>.</span><span>ToString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span></code></pre></div>
<p>So now we can try to convert our expression from earlier and see what it returns:</p>
<div data-language="csharp"><pre><code><span>var</span> fsharpCode <span>=</span> FSharpTranspiler<span>.</span>Convert<span>&lt;</span>Action<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>&gt;&gt;</span><span>(</span>
    <span>(</span>a<span>,</span> b<span>)</span> <span>=&gt;</span> Console<span>.</span><span>WriteLine</span><span>(</span><span>"a + b = {0}"</span><span>,</span> a <span>+</span> b<span>)</span><span>)</span><span>;</span>

</code></pre></div>
<p>This produces a string that contains valid F# code which should compile into an equivalent anonymous function. Let‚Äôs run it in F# interactive to make sure it works correctly:</p>
<div data-language="fsharp"><pre><code><span>&gt;</span> <span>let</span> foo <span>=</span> <span>fun</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-&gt;</span> printfn <span>"a + b = %O"</span> <span>(</span>a <span>+</span> b<span>)</span>
<span>val</span> foo <span>:</span> a<span>:</span><span>int</span> <span>*</span> b<span>:</span><span>int <span>-&gt;</span> unit</span>

<span>&gt;</span> foo <span>(</span><span>3</span><span>,</span> <span>5</span><span>)</span>
a <span>+</span> b <span>=</span> <span>8</span>
<span>val</span> it <span>:</span> <span>unit</span> <span>=</span> <span>(</span><span>)</span></code></pre></div>
<p>Translating code from one language to another is definitely not a simple task, but it can be incredibly useful in certain scenarios. One example could be sharing validation rules between backend and frontend by converting C# predicate expressions into JavaScript code.</p>
<h2>Summary</h2>
<p>Expression trees provide us with a formal structure of code that lets us analyze existing expressions or compile entirely new ones directly at runtime. This feature makes it possible to do a bunch of cool things, including writing transpilers, interpreters, code generators, optimize reflection calls, provide contextual assertions, and more. I think it‚Äôs a really powerful tool that deserves a lot more attention.</p>
<p>Some other interesting articles on the topic:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/expression-trees">Introduction to expression trees (Microsoft Docs)</a></li>
<li><a href="https://particular.net/blog/10x-faster-execution-with-compiled-expression-trees">10X faster execution with compiled expression trees (Particular Software)</a></li>
<li><a href="https://lostechies.com/jimmybogard/2016/06/24/automapper-5-0-speed-increases">AutoMapper 5.0 speed increases (Jimmy Bogard)</a></li>
<li><a href="https://jeremydmiller.com/2017/08/01/how-we-did-and-did-not-improve-performance-and-efficiency-in-marten-2-0">How we did (and did not) improve performance and efficiency in Marten 2.0 (Jeremy D. Miller)</a></li>
<li><a href="http://twistedoakstudios.com/blog/Post2540_optimizing-just-in-time-with-expression-trees">Optimizing Just in Time with Expression Trees (Craig Gidney)</a></li>
</ul>
<p>I also recommend reading about <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/code-quotations">code quotations in F#</a> which is a similar feature to expression trees but with more powerful language support.</p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>