<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Securing Blazor WebAssembly with Identity Server 4 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Securing Blazor WebAssembly with Identity Server 4 - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@marcodesanctis2"/>
    <meta property="og:description" content="The new Blazor WebAssembly 3.2.0 Preview 2 adds support to client side authentication, which makes relatively simple to implement OpenID&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@marcodesanctis2/securing-blazor-webassembly-with-identity-server-4-ee44aa1687ef"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Securing Blazor WebAssembly with Identity Server 4</title>
<div class="readable">
        <h1>Securing Blazor WebAssembly with Identity Server 4</h1>
            <div>by https://medium.com/@marcodesanctis2</div>
            <div>Reading time: 14-17 minutes</div>
        <div>Posted here: 06 Apr 2020</div>
        <p><a href="https://medium.com/@marcodesanctis2/securing-blazor-webassembly-with-identity-server-4-ee44aa1687ef">https://medium.com/@marcodesanctis2/securing-blazor-webassembly-with-identity-server-4-ee44aa1687ef</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@marcodesanctis2?source=post_page-----ee44aa1687ef----------------------"><img alt="Marco De Sanctis" src="https://miro.medium.com/fit/c/96/96/0*1Ycmr1Ge2afLYptv." width="48" height="48"></a></p></div></div></div></div><p id="d47e" data-selectable-paragraph="">The new <strong>Blazor WebAssembly 3.2.0 Preview 2</strong> adds <a href="https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-preview-2-release-now-available/" target="_blank" rel="noopener nofollow">support to client side authentication</a>, which makes relatively simple to implement <strong>OpenID Connect </strong>and <strong>OAuth2</strong> in your single page application. In other words, it means that we can finally build applications with the <strong>most recent industry standards </strong>in terms of security, enabling <strong>complex authentication scenarios</strong> and integrating them with the most widely used <strong>identity providers</strong> out there.</p><p id="cafb" data-selectable-paragraph="">Speaking of identity providers, the most popular in the .NET Core sphere is definitely <a href="https://github.com/IdentityServer/IdentityServer4" target="_blank" rel="noopener nofollow"><strong>Identity Server 4</strong></a>, an open source product which is <a href="https://openid.net/certification/" target="_blank" rel="noopener nofollow">certified by the OpenID Foundation</a> and works <strong>like a breeze</strong> with ASP.NET Core.</p><p id="ea0c" data-selectable-paragraph="">In this article we are going to implement the scenario depicted in the image below:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*HKIgXaVF_9U3CSvhxqSPCQ.png?q=20" width="777" height="426" role="presentation"></p><p><img width="777" height="426" srcset="https://miro.medium.com/max/552/1*HKIgXaVF_9U3CSvhxqSPCQ.png 276w, https://miro.medium.com/max/1104/1*HKIgXaVF_9U3CSvhxqSPCQ.png 552w, https://miro.medium.com/max/1280/1*HKIgXaVF_9U3CSvhxqSPCQ.png 640w, https://miro.medium.com/max/1400/1*HKIgXaVF_9U3CSvhxqSPCQ.png 700w" sizes="700px" role="presentation" src="https://miro.medium.com/max/777/1*HKIgXaVF_9U3CSvhxqSPCQ.png"></p></div></div></div></div></figure><p id="ae9d" data-selectable-paragraph="">In a nutshell, we will:</p><ul><li id="d69f" data-selectable-paragraph="">Create a <strong>secure Blazor WebAssembly</strong> application with a protected page</li><li id="8854" data-selectable-paragraph="">Add the capability to <strong>log the user in</strong> using Identity Server 4 as our identity provider, and display some basic info of the user</li><li id="4715" data-selectable-paragraph="">Request an <strong>Access Token</strong> on behalf of the user and use it to call a secured ASP.NET Core Web API endpoint</li></ul><p id="9ffc" data-selectable-paragraph="">We are not going to delve into the details of Identity Server and the nuances of its configuration and capabilities, however it’s fair to say that there’s <a href="https://identityserver4.readthedocs.io/en/latest/" target="_blank" rel="noopener nofollow">plenty of documentation</a> for those of us who want to know more about the functionalities we are going to use.</p><p id="cee0" data-selectable-paragraph="">As a first step, let’s create an empty solution in Visual Studio and add an Identity Server 4 project to it.</p><p id="cc55" data-selectable-paragraph="">For the sake of this article, we are going to use one of the <strong>pre-configured templates</strong> of Identity Server 4. As a first step, we need to <strong>install those templates</strong> through PowerShell:</p><pre><span id="590d" data-selectable-paragraph="">dotnet new -i <strong>IdentityServer4.Templates</strong></span></pre><p id="a46a" data-selectable-paragraph="">Once we have this in place, we can simply create a new project by running the following commands:</p><pre><span id="dfa4" data-selectable-paragraph=""># Create an empty solution<br>dotnet new sln -n BlazorSecurityDemo</span><span id="a402" data-selectable-paragraph=""># Create a new IS4 quickstart project<br>dotnet <strong>new is4aspid</strong> -n IdentityProvider</span><span id="4d10" data-selectable-paragraph=""># Add the project to the solution<br>dotnet sln add IdentityProvider</span></pre><p id="ee78" data-selectable-paragraph="">This will create an Identity Server website with some <strong>basic configuration</strong>, whose identity store is based on <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-3.1&amp;tabs=visual-studio" target="_blank" rel="noopener nofollow">ASP.NET Core Identity</a>, which is more than enough for what we want to demonstrate.</p><p id="e76c" data-selectable-paragraph="">The next step consists in customising the configuration in the <code>Config.cs</code> file. More specifically, we can empty the list of <code>Clients</code> the template creates for us, and replace it with the one for our upcoming Blazor application:</p><pre><span id="58a6" data-selectable-paragraph="">public static IEnumerable&lt;Client&gt; Clients =&gt;<br>    new Client[]<br>    {<br>        new Client<br>        {<br>            ClientId = "blazor",<br>            AllowedGrantTypes = GrantTypes.Code,<br>            RequirePkce = true,<br>            RequireClientSecret = false,<br>            AllowedCorsOrigins = { "<a href="https://localhost:5001/" target="_blank" rel="noopener nofollow">https://localhost:5001</a>" },<br>            AllowedScopes = { "openid", "profile" },<br>            RedirectUris = { "<a href="https://localhost:5001/authentication/login-callback" target="_blank" rel="noopener nofollow">https://localhost:5001/authentication/login-callback</a>" },<br>            PostLogoutRedirectUris = { "<a href="https://localhost:5001/" target="_blank" rel="noopener nofollow">https://localhost:5001/</a>" },<br>            Enabled = true<br>        },<br>    };</span></pre><p id="e067" data-selectable-paragraph="">This is basically where we register the <strong>client application</strong> in Identity Server. In our specific case, we have configured a few interesting options:</p><ul><li id="f011" data-selectable-paragraph="">The <strong>ClientId </strong>is the unique name for the application, which we’ve set to <code>blazor</code></li><li id="332e" data-selectable-paragraph="">We are going to use the <a href="http://docs.identityserver.io/en/latest/topics/grant_types.html" target="_blank" rel="noopener nofollow"><strong>Authorization Code</strong> grant type and require <strong>PKCE</strong></a></li><li id="c793" data-selectable-paragraph="">Since the client application will run on <code>localhost:5001</code> , we’ve <strong>whitelisted this URL in CORS</strong> and set up the allowed <strong>redirect URLs</strong> for the login callback and after the logout</li><li id="2367" data-selectable-paragraph="">We are enabling <code>openid</code> and <code>profile</code> as scopes, in order to allow the execution of the <strong>OpenID Connect</strong> flow and retrieve the <strong>profile of the user</strong> in the <strong>ID Token</strong></li></ul><p id="d3ad" data-selectable-paragraph="">Before we move on, the last thing to do is setting Identity Server to start on <strong>https rather than http</strong> as default, by modifying the <code>launchSettings.json</code> file and setting the protocol accordingly:</p><pre><span id="2bd9" data-selectable-paragraph="">{<br>  ...<br>    "SelfHost": {<br>      "commandName": "Project",<br>      "launchBrowser": true,<br>      "environmentVariables": {<br>        "ASPNETCORE_ENVIRONMENT": "Development"<br>      },<br>      "applicationUrl": "<a href="https://localhost:5000/" target="_blank" rel="noopener nofollow"><strong>https</strong>://localhost:5000</a>"<br>    }<br>  }<br>}</span></pre><p id="401d" data-selectable-paragraph="">If we’ve done all the steps correctly, we should be able to press Ctrl-F5 from Visual Studio and see something similar to the screenshot below:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*qNudqgo0CcOAwphFFib1dA.png?q=20" width="1270" height="684" role="presentation"></p><p><img width="1270" height="684" srcset="https://miro.medium.com/max/552/1*qNudqgo0CcOAwphFFib1dA.png 276w, https://miro.medium.com/max/1104/1*qNudqgo0CcOAwphFFib1dA.png 552w, https://miro.medium.com/max/1280/1*qNudqgo0CcOAwphFFib1dA.png 640w, https://miro.medium.com/max/1400/1*qNudqgo0CcOAwphFFib1dA.png 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><p id="3cbb" data-selectable-paragraph="">We’re now ready to start using this from a <strong>Blazor SPA</strong>!</p><p id="4695" data-selectable-paragraph="">When we create a new <strong>Blazor WebAssembly project</strong>, we have the possibility of choosing <strong>Individual User Accounts</strong> as authentication type.</p><pre><span id="c575" data-selectable-paragraph=""># Create a Blazor Wasm application with Individual User accounts<br>dotnet <strong>new blazorwasm -au individual</strong> -n BlazorClient</span><span id="49fa" data-selectable-paragraph=""># Add the project to the solution<br>dotnet sln add BlazorClient</span></pre><p id="a52a" data-selectable-paragraph="">This setting of the template will add a placeholder for the <strong>OpenID Connect</strong> configuration in the <code>Program.cs</code> file:</p><pre><span id="5db4" data-selectable-paragraph="">public static async Task Main(string[] args)<br>{<br>  ...<br>  builder.Services.AddOidcAuthentication(options =&gt;<br>  {<br>    <strong>options.ProviderOptions.Authority = "...";<br>    options.ProviderOptions.ClientId = "...";</strong><br>  });<br>  ...<br>}</span></pre><p id="74fe" data-selectable-paragraph="">At this point we can <strong>set the parameters</strong> needed to talk to the Identity Server instance we’ve previously created:</p><pre><span id="2eba" data-selectable-paragraph="">builder.Services.AddOidcAuthentication(options =&gt;<br>{<br>  options.ProviderOptions.Authority = "<a href="https://localhost:5000/" target="_blank" rel="noopener nofollow">https://localhost:5000/</a>";<br>  options.ProviderOptions.ClientId = "blazor";<br>  options.ProviderOptions.DefaultScopes = <br>      new List&lt;string&gt; { "openid", "profile" };<br>  options.ProviderOptions.ResponseType = "code";    <br>  options.ProviderOptions.PostLogoutRedirectUri = "/";<br>});</span></pre><p id="7b76" data-selectable-paragraph="">What do these parameters mean? Let’s analyse them one by one:</p><ul><li id="0c06" data-selectable-paragraph=""><strong>Authority </strong>is the URL of Identity Server, this is used both for redirecting purposes but also to verify the signature of the tokens and the identity which issued them</li><li id="8058" data-selectable-paragraph=""><strong>ClientId </strong>is the unique identifier of the client registration we set in the <a href="#f011" rel="noopener">previous step</a></li><li id="405c" data-selectable-paragraph=""><strong>DefaultScopes </strong>are the scope we want to request during the login flow. More specifically, here we are using <code>openid</code> , to indicate that we want to perform an authentication using <strong>OpenID Connect</strong>, and <code>profile</code> , in order to retrieve some basic info of the user, such as his name.</li><li id="9650" data-selectable-paragraph=""><strong>ResponseType </strong>is the grant type we are using, which is — again — <strong>AuthorizationCode</strong></li><li id="a85e" data-selectable-paragraph=""><strong>PostLogoutRedirectUri </strong>is quite self-explanatory, and it’s basically where we want to be redirected once we logout</li></ul><p id="a8d1" data-selectable-paragraph="">I see you being so eager to press F5 and run this 😉 but before you do, just remember to <strong>remove </strong><code>http://localhost:5000</code> from the Blazor launch settings file, or it will clash with the port used by Identity Server:</p><pre><span id="ea52" data-selectable-paragraph="">"BlazorClient": {<br>  "commandName": "Project",<br>  "launchBrowser": true,<br>  "inspectUri": "...",<br><strong>  "applicationUrl": "</strong><a href="https://localhost:5001;http://localhost:5000" target="_blank" rel="noopener nofollow"><strong>https://localhost:5001</strong></a><strong>",</strong><br>  "environmentVariables": {<br>    "ASPNETCORE_ENVIRONMENT": "Development"<br>  }<br>}</span></pre><p id="9248" data-selectable-paragraph="">Now it’s time to finally run the solution! By launching the two projects all together, we should be able to see the Blazor website, click onto the <strong>Log in</strong> button to trigger the OpenID Connect flow with Identity Server, give the consent to the application and finally see our username appearing at the top of the page!</p><figure><div><div><div><div><p><img src="https://miro.medium.com/freeze/max/60/1*R8J8l1p36lG2q83ZWGap9A.gif?q=20" width="1000" height="562" role="presentation"></p><p><img width="1000" height="562" srcset="https://miro.medium.com/max/552/1*R8J8l1p36lG2q83ZWGap9A.gif 276w, https://miro.medium.com/max/1104/1*R8J8l1p36lG2q83ZWGap9A.gif 552w, https://miro.medium.com/max/1280/1*R8J8l1p36lG2q83ZWGap9A.gif 640w, https://miro.medium.com/max/1400/1*R8J8l1p36lG2q83ZWGap9A.gif 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><p id="20de" data-selectable-paragraph="">Those pre-configured scopes we have selected represent the <strong>set of claims</strong> we want to retrieve in the ID Token.</p><p id="8fad" data-selectable-paragraph="">We can customise this logic at any time by simply adding definitions for new <strong>IdentityResources </strong>in Identity Server. For example, if we wanted to include the email address, we could modify the settings in the <code>Config.cs</code> file in this way:</p><pre><span id="449b" data-selectable-paragraph="">public static IEnumerable&lt;IdentityResource&gt; Ids =&gt;<br>  new IdentityResource[]<br>  {<br>    new IdentityResources.OpenId(),<br>    new IdentityResources.Profile(),<br><strong>    new IdentityResources.Email()</strong><br>  };</span><span id="ee04" data-selectable-paragraph="">public static IEnumerable&lt;Client&gt; Clients =&gt;<br>  new Client[]<br>  {<br>    new Client<br>    {<br>      ClientId = "blazor",<br>      AllowedScopes = { "openid", "profile", <strong>"email"</strong> },<br>      ...<br>    },<br> };</span></pre><p id="1edf" data-selectable-paragraph="">Thanks to this, we may now add this new <code>email</code> scope to the default ones in the Blazor client application.</p><pre><span id="a1a2" data-selectable-paragraph="">builder.Services.AddOidcAuthentication(options =&gt;<br>{<br>  ...<br>  options.ProviderOptions.DefaultScopes = <br>    new List&lt;string&gt; { "openid", "profile", <strong>"email"</strong> };<br>});</span></pre><p id="1ef6" data-selectable-paragraph="">The result will be that the <strong>ID Token</strong> will now include also the set of claims associated to this scope, which we will be able to access through the current <strong>ClaimsPrincipal</strong>.</p><p id="1013" data-selectable-paragraph="">The easiest way to access the ClaimsPrincipal — and thus the data about the current user — is by using a component called <strong>AuthorizeView</strong>. For example, we can create a page similar to this to display all the user’s claims:</p><pre><span id="253f" data-selectable-paragraph=""><a href="http://twitter.com/page" target="_blank" rel="noopener nofollow">@page</a> "/claims"</span><span id="eb24" data-selectable-paragraph=""><strong>&lt;AuthorizeView&gt;<br>    &lt;Authorized&gt;</strong><br>        &lt;h2&gt;Hello <a href="http://twitter.com/context" target="_blank" rel="noopener nofollow"><strong>@context</strong></a><strong>.User.Identity.Name, </strong><br>            here's the list of your claims:&lt;/h2&gt;<br>        &lt;ul&gt;<br>            <a href="http://twitter.com/foreach" target="_blank" rel="noopener nofollow">@foreach</a> (var claim in context.User.Claims)<br>            {<br>                &lt;li&gt;&lt;b&gt;<a href="http://twitter.com/claim" target="_blank" rel="noopener nofollow">@claim</a>.Type&lt;/b&gt;: <a href="http://twitter.com/claim" target="_blank" rel="noopener nofollow">@claim</a>.Value&lt;/li&gt;<br>            }<br>        &lt;/ul&gt;<br>    <strong>&lt;/Authorized&gt;</strong><br><strong>    &lt;NotAuthorized&gt;</strong><br>        &lt;p&gt;I'm sorry, I can't display anything until you log in&lt;/p&gt;<br><strong>    &lt;/NotAuthorized&gt;<br>&lt;/AuthorizeView&gt;</strong></span></pre><p id="c4a0" data-selectable-paragraph=""><strong>AuthorizeView </strong>has a couple of interesting capabilities:</p><ul><li id="7049" data-selectable-paragraph="">we can define sub templates to display when the user is either <strong>Authorized </strong>or <strong>NotAuthorized </strong>— there’s also a third template for when the authorisation is in progress</li><li id="cb2c" data-selectable-paragraph="">we can access a <code>context</code> object which contains the current <code>AuthenticationState</code> toghether with the <strong>ClaimsPrincipal</strong>.</li></ul><p id="bc42" data-selectable-paragraph="">After logging in, the page we’ve just created will display all the user claims like in the pic below:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*DaL-EewvHpR0yHBlRRAdLQ.png?q=20" width="1539" height="797" role="presentation"></p><p><img width="1539" height="797" srcset="https://miro.medium.com/max/552/1*DaL-EewvHpR0yHBlRRAdLQ.png 276w, https://miro.medium.com/max/1104/1*DaL-EewvHpR0yHBlRRAdLQ.png 552w, https://miro.medium.com/max/1280/1*DaL-EewvHpR0yHBlRRAdLQ.png 640w, https://miro.medium.com/max/1400/1*DaL-EewvHpR0yHBlRRAdLQ.png 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><p id="1d7f" data-selectable-paragraph="">Authenticating a user in a single page web application isn’t that powerful until you start using his or her identity to <strong>make a call to a protected API</strong> endpoint. Let’s see how we can plug this other feature into the system that we’re building.</p><p id="a764" data-selectable-paragraph="">First and foremost, we need to configure a new <strong>ApiResource</strong> in Identity Server and grant our client the permission to request a token for it. Let’s head to the <strong>Config </strong>class we’ve seen before and make some changes to create a new scope and add it to the allowed ones for Blazor:</p><pre><span id="35ab" data-selectable-paragraph=""><strong>public static IEnumerable&lt;ApiResource&gt; Apis =&gt;<br>  new ApiResource[]<br>  {<br>    new ApiResource("weatherapi", "The Weather API")<br>  };</strong></span><span id="22e3" data-selectable-paragraph="">public static IEnumerable&lt;Client&gt; Clients =&gt;<br>  new Client[]<br>  {<br>    new Client<br>    {<br>      ClientId = "blazor",<br>      ...<br>      AllowedScopes = { "openid", "profile", "email", <strong>"weatherapi"</strong> }<br>    }<br>  };</span></pre><p id="cd0e" data-selectable-paragraph="">Then it’s time to add a Web API project to the solution:</p><pre><span id="b347" data-selectable-paragraph=""># Create a new Web API project<br>dotnet <strong>new webapi </strong>-n WeatherApi</span><span id="8475" data-selectable-paragraph=""># Add JwtBearer authentication package<br>dotnet add WeatherApi package<br>  <strong>Microsoft.AspNetCore.Authentication.JwtBearer</strong></span><span id="9261" data-selectable-paragraph=""># Add it to the solution<br>dotnet sln add WeatherApi</span></pre><p id="00ed" data-selectable-paragraph="">This API at the moment has no security whatsoever around it, so we need to modify to the <strong>Startup </strong>class and configure it to <strong>require a JWT bearer token</strong> in the header:</p><pre><span id="e3d5" data-selectable-paragraph="">public void ConfigureServices(IServiceCollection services)<br>{<br>  services.AddControllers();<br><strong>  services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</strong><br>    .AddJwtBearer(options =&gt;<br>    {<br>      <strong>options.Authority = "</strong><a href="https://localhost:5000/" target="_blank" rel="noopener nofollow"><strong>https://localhost:5000</strong></a><strong>";<br>      options.Audience = "weatherapi";</strong><br>    });<br>}</span><span id="62d5" data-selectable-paragraph="">public void Configure(...)<br>{<br>  ...<br>  <strong>app.UseAuthentication();<br></strong>  app.UseAuthorization();</span><span id="6d36" data-selectable-paragraph="">  app.UseEndpoints(endpoints =&gt;<br>  {<br>    endpoints.MapControllers();<br>  });<br>}</span></pre><p id="20e2" data-selectable-paragraph="">For the sake of this example, we are going to use the <code>WeatherForecastController</code> that comes preconfigured in the Web API template. We just need to add the <code>[Authorize]</code> attribute to protect it against anonymous access:</p><pre><span id="95b4" data-selectable-paragraph=""><strong>[Authorize]<br></strong>[ApiController]<strong><br></strong>[Route("[controller]")]<br>public class WeatherForecastController : ControllerBase<br>{</span></pre><p id="f3d0" data-selectable-paragraph="">For the sake of consistency, we should also modify the <code>launchSettings.json</code> file as usual, this time using port <code>5002</code>:</p><pre><span id="3a51" data-selectable-paragraph="">"WeatherApi": {<br>  "commandName": "Project",<br>  "launchBrowser": true,<br>  "launchUrl": "weatherforecast",<br><strong>  "applicationUrl": "</strong><a href="https://localhost:5002/" target="_blank" rel="noopener nofollow"><strong>https://localhost:5002</strong></a><strong>",</strong><br>  "environmentVariables": {<br>    "ASPNETCORE_ENVIRONMENT": "Development"<br>  }<br>}</span></pre><p id="5bfb" data-selectable-paragraph="">Now that all is set, it’s finally time to call this endpoint from our client application.</p><p id="b600" data-selectable-paragraph="">We are almost there, the only step left is to modify our client, and more specifically the <code>FetchData.razor</code> page, so we can acquire a token for the API and call its endpoint.</p><p id="258d" data-selectable-paragraph="">In order to do that, we require a dependency from the <strong>IAccessTokenProvider </strong>service:</p><pre><span id="6371" data-selectable-paragraph=""><a href="http://twitter.com/page" target="_blank" rel="noopener nofollow">@page</a> "/fetchdata"<br><a href="http://twitter.com/inject" target="_blank" rel="noopener nofollow">@inject</a> HttpClient Http<br><a href="http://twitter.com/inject" target="_blank" rel="noopener nofollow"><strong>@inject</strong></a><strong> IAccessTokenProvider TokenProvider<br>@attribute [Authorize]</strong></span></pre><p id="7296" data-selectable-paragraph="">This object exposes one single method, whose name is quite self explanatory: <code>RequestAccessToken</code>: this will initiate the <strong>OAuth 2 flow</strong> to acquire an <strong>access token</strong> for a given scope from the Identity Provider.</p><pre><span id="c305" data-selectable-paragraph="">protected override async Task OnInitializedAsync()<br>{<br><strong>  var tokenRequest = await this.TokenProvider.RequestAccessToken();</strong></span><span id="5132" data-selectable-paragraph="">  if (<strong>tokenRequest.TryGetToken</strong>(out var token))<br>  {<br>    <strong>this.Http.DefaultRequestHeaders<br>      .Add("Authorization", $"Bearer {token.Value}");</strong></span><span id="132a" data-selectable-paragraph="">    forecasts = await Http.GetJsonAsync&lt;WeatherForecast[]&gt;(<br>      "<a href="https://localhost:5002/WeatherForecast" target="_blank" rel="noopener nofollow">https://localhost:5002/WeatherForecast</a>");<br>  }<br>}</span></pre><p id="b60f" data-selectable-paragraph="">Then we can pass this token in the <strong>Authorization header</strong> just before calling the API endpoint.</p><blockquote><p id="a052" data-selectable-paragraph="">How do we specify that we want a token for the <code>weatherapi</code> scope? we have a couple of ways. One is by using <strong>AccessTokenRequestOptions </strong>and pass it to that method. However this overload <strong>doesn’t currently work</strong> in Preview 3. So the only viable option at the moment is to use the default scopes.</p></blockquote><p id="822e" data-selectable-paragraph="">As you can see, we <strong>haven’t specified any scopes </strong>in the above method. This means that we are going to use the <strong>default scopes</strong> we’ve defined in the <strong>Program</strong> class, to which we need to add the <code>weatherapi</code> scope:</p><pre><span id="a519" data-selectable-paragraph="">builder.Services.AddOidcAuthentication(options =&gt;<br>{<br>  ...<br>  options.ProviderOptions.DefaultScopes = new List&lt;string&gt; {   <br>    "openid", "profile", "email", <strong>"weatherapi"</strong> };<br>});</span></pre><p id="efa9" data-selectable-paragraph="">If we’ve done all the bits correctly, we will finally see our randomised weather forecasts coming through when visiting the page:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*hRxNseIYbuqntgcbsB1GcQ.png?q=20" width="1703" height="861" role="presentation"></p><p><img width="1703" height="861" srcset="https://miro.medium.com/max/552/1*hRxNseIYbuqntgcbsB1GcQ.png 276w, https://miro.medium.com/max/1104/1*hRxNseIYbuqntgcbsB1GcQ.png 552w, https://miro.medium.com/max/1280/1*hRxNseIYbuqntgcbsB1GcQ.png 640w, https://miro.medium.com/max/1400/1*hRxNseIYbuqntgcbsB1GcQ.png 700w" sizes="700px" role="presentation"></p></div></div></div></div></figure><p id="b1f3" data-selectable-paragraph="">In a next article, I’ll dig a bit deeper on how the methods we’ve used work under the hood, however there are <strong>a couple of key points</strong> we need to pay attention when dealing with tokens:</p><ul><li id="7082" data-selectable-paragraph=""><strong>Acquired tokens should be cached</strong> in the browser, in order to not overwhelm the identity provider of requests (and to speed up things on the client side as well)</li><li id="a88a" data-selectable-paragraph=""><strong>Tokens do expire </strong>over time, and therefore cached ones need to be invalidated and refreshed.</li></ul><p id="913e" data-selectable-paragraph="">The good news is that <strong>Blazor deals with all these aspects for us</strong> (well, it’s actually a library called <a href="https://github.com/IdentityModel/oidc-client-js" target="_blank" rel="noopener nofollow"><strong>oidc-client-js</strong></a> doing it 😉), so we don’t have to worry at all about them, just <strong>keep requesting them every time</strong> we need to make a call and they will be picked from the cache if they are valid, or refreshed if they’re not.</p><p id="9b65" data-selectable-paragraph="">It was our first touch point with <strong>security in Blazor WebAssembly</strong>, however we should be proud of what we managed to achieve!</p><p id="1e27" data-selectable-paragraph="">We’ve <strong>protected our application</strong> by integrating it with <strong>Identity Server</strong> and configured the <strong>OpenID Connect </strong>protocol to authenticate users. We’ve also briefly introduced the <strong>concept of scopes</strong> and seen how they <strong>affect the claims</strong> we receive from the identity provider.</p><p id="db8c" data-selectable-paragraph="">Then we’ve moved one step forward by <strong>requesting an access token</strong> and using it to call a <strong>protected Web API</strong> by for it and passing it in the header of the HTTP call.</p><p id="3fb8" data-selectable-paragraph="">I’ve tried to describe all the steps in detail, however, if you don’t want to type, the <strong>full source code</strong> is available at this repository in GitHub: <a href="https://github.com/cradle77/BlazorSecurityDemo" target="_blank" rel="noopener nofollow">https://github.com/cradle77/BlazorSecurityDemo</a></p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>