<!DOCTYPE html>
<html lang="en">
<head>
    <title>
An Introduction to DataFrame | .NET Blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>An Introduction to DataFrame | .NET Blog</h1><div><div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/MicrosoftPic-150x150.jpg" width="58" height="58" alt="Prashanth Govindarajan" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 alignnone photo"></div></div></div><p>December 16th, 2019</p><p>Last month, we announced .NET support for Jupyter notebooks, and showed how to use them to work with .NET for Apache Spark and ML.NET. Today, we’re announcing the preview of a <a href="https://www.nuget.org/packages/Microsoft.Data.Analysis/" rel="noopener noreferrer" target="_blank">DataFrame</a> type for .NET to make data exploration easy. If you’ve used Python to manipulate data in notebooks, you’ll already be familiar with the concept of a DataFrame. At a high level, it is an in-memory representation of structured data. In this blog post, I’m going to give an overview of this new type and how you can use it from Jupyter notebooks. To play along, fire up a .NET Jupyter Notebook in a <a href="https://mybinder.org/v2/gh/dotnet/interactive/master?urlpath=lab" rel="noopener noreferrer" target="_blank">browser</a>.</p><h2>How to use DataFrame?</h2><p><code>DataFrame</code> stores data as a collection of columns. Let’s populate a <code>DataFrame</code> with some sample data and go over the major features. The full sample can be found on Github(<a href="https://github.com/dotnet/interactive/blob/467828bae501022734fc5d0d077bef8d36bb0bf8/NotebookExamples/csharp/Samples/DataFrame-Getting%20Started.ipynb" rel="noopener noreferrer" target="_blank">C#</a> and <a href="https://github.com/dotnet/interactive/blob/467828bae501022734fc5d0d077bef8d36bb0bf8/NotebookExamples/fsharp/Samples/DataFrame-Getting%20Started.ipynb" rel="noopener noreferrer" target="_blank">F#</a>). To follow along in your browser, click <a href="https://mybinder.org/v2/gh/dotnet/interactive/master?urlpath=lab" rel="noopener noreferrer" target="_blank">here</a> and navigate to <em>csharp/Samples/DataFrame-Getting Started.ipynb</em>(or <em>fsharp/Samples/DataFrame-Getting Started.ipynb</em>). To get started, let’s import the <a href="https://www.nuget.org/packages/Microsoft.Data.Analysis/" rel="noopener noreferrer" target="_blank">Microsoft.Data.Analysis</a> package and namespace into our .NET Jupyter Notebook (make sure you’re using the C# or F# kernel):</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/Microsoft.Data_.Analysis.png" alt="Microsoft.Data.Analysis package"></p><p>Let’s make three columns to hold values of types <code>DateTime</code>, <code>int</code> and <code>string</code>.</p><pre><code class="csharp">PrimitiveDataFrameColumn&lt;DateTime&gt; dateTimes = new PrimitiveDataFrameColumn&lt;DateTime&gt;("DateTimes"); // Default length is 0.
PrimitiveDataFrameColumn&lt;int&gt; ints = new PrimitiveDataFrameColumn&lt;int&gt;("Ints", 3); // Makes a column of length 3. Filled with nulls initially
StringDataFrameColumn strings = new StringDataFrameColumn("Strings", 3); // Makes a column of length 3. Filled with nulls initially
</code></pre><p><code>PrimitiveDataFrameColumn</code> is a generic column that can hold primitive types such as <code>int</code>, <code>float</code>, <code>decimal</code> etc. A <code>StringDataFrameColumn</code> is a specialized column that holds <code>string</code> values. Both the column types can take a <code>length</code> parameter in their contructors and are filled with <code>null</code> values initially. Before we can add these columns to a <code>DataFrame</code> though, we need to append three values to our <code>dateTimes</code> column. This is because the <code>DataFrame</code> constructor expects all its columns to have the same length.</p><pre><code class="csharp">// Append 3 values to dateTimes
dateTimes.Append(DateTime.Parse("2019/01/01"));
dateTimes.Append(DateTime.Parse("2019/01/01"));
dateTimes.Append(DateTime.Parse("2019/01/02"));
</code></pre><p>Now we’re ready to create a <code>DataFrame</code> with three columns.</p><pre><code class="csharp">DataFrame df = new DataFrame(dateTimes, ints, strings); // This will throw if the columns are of different lengths
</code></pre><p>One of the benefits of using a notebook for data exploration is the interactive REPL. We can enter <code>df</code> into a new cell and run it to see what data it contains. For the rest of this post, we’ll work in a .NET Jupyter environment. All the sample code will work in a regular console app as well though.</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/ArrayPrint.png" alt="Array Print"></p><p>We immediately see that the formatting of the output can be improved. Each column is printed as an array of values and we don’t see the names of the columns. If <code>df</code> had more rows and columns, the output would be hard to read. Fortunately, in a Jupyter environment, we can write custom formatters for types. Let’s write a formatter for <code>DataFrame</code>.</p><pre><code class="csharp">using Microsoft.AspNetCore.Html;
Formatter&lt;DataFrame&gt;.Register((df, writer) =&gt;
{
    var headers = new List&lt;IHtmlContent&gt;();
    headers.Add(th(i("index")));
    headers.AddRange(df.Columns.Select(c =&gt; (IHtmlContent) th(c.Name)));
    var rows = new List&lt;List&lt;IHtmlContent&gt;&gt;();
    var take = 20;
    for (var i = 0; i &lt; Math.Min(take, df.Rows.Count); i++)
    {
        var cells = new List&lt;IHtmlContent&gt;();
        cells.Add(td(i));
        foreach (var obj in df.Rows[i])
        {
            cells.Add(td(obj));
        }
        rows.Add(cells);
    }

    var t = table(
        thead(
            headers),
        tbody(
            rows.Select(
                r =&gt; tr(r))));

    writer.Write(t);
}, "text/html");
</code></pre><p>This snippet of code register a new <code>DataFrame</code> formatter. All subsequent evaluations of <code>df</code> in a notebook will now output the first 20 rows of a <code>DataFrame</code> along with the column names. In the future, the <code>DataFrame</code> type and other libraries that target Jupyter as one of their environments will be able to ship with their formatters.</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/PrintDataFrame.gif" alt="Print DataFrame"></p><p>Sure enough, when we re-evaluate <code>df</code>, we see that it contains the three columns we created previously. The formatting makes it much easier to inspect our values. There’s also a helpful <code>index</code> column in the output to quickly see which row we’re looking at. Let’s modify our data by indexing into <code>df</code>:</p><pre><code class="csharp">df[0, 1] = 10; // 0 is the rowIndex, and 1 is the columnIndex. This sets the 0th value in the Ints columns to 10
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/DataFrameIndexing.png" alt="DataFrameIndexing"></p><p>We can also modify the values in the columns through indexers defined on <code>PrimitiveDataFrameColumn</code> and <code>StringDataFrameColumn</code>:</p><pre><code class="csharp">// Modify ints and strings columns by indexing
ints[1] = 100;
strings[1] = "Foo!";
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/ColumnIndexers.png" alt="ColumnIndexers"></p><p>One caveat to keep in mind here is the data type of the value passed in to the indexers. We passed in the right data types to the column indexers in our sample: an integer value of <code>100</code> to <code>ints[1]</code> and a string <code>"Foo!"</code> to <code>string[1]</code>. If the data types don’t match, an exception will be thrown. For cases where the type of data in the columns is not obvious, there is a handy <code>DataType</code> property defined on each column. The <code>Info</code> method displays the <code>DataType</code> and <code>Length</code> properties of each column:</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/DataType.png" alt="Info"></p><p>The <code>DataFrame</code> and <code>DataFrameColumn</code> classes expose a number of useful APIs: binary operations, computations, joins, merges, handling missing values and more. Let’s look at some of them:</p><pre><code class="csharp">// Add 5 to Ints through the DataFrame
df["Ints"].Add(5, inPlace: true);
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/Add.png" alt="Add"></p><pre><code class="csharp">// We can also use binary operators. Binary operators produce a copy, so assign it back to our Ints column 
df["Ints"] = (ints / 5) * 100;
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/BinaryOperations.png" alt="BinaryOperations"></p><p>All binary operators are backed by functions that produces a copy by default. The <code>+</code> operator, for example, calls the <code>Add</code> method and passes in <code>false</code> for the <code>inPlace</code> parameter. This lets us elegantly manipulate data using operators without worrying about modifying our existing values. For when in place semantics are desired, we can set the <code>inPlace</code> parameter to <code>true</code> in the binary functions.</p><p>In our sample, <code>df</code> has <code>null</code> values in its columns. <code>DataFrame</code> and <code>DataFrameColumn</code> offer an API to fill <code>nulls</code> with values.</p><pre><code class="csharp">df["Ints"].FillNulls(-1, inPlace: true);
df["Strings"].FillNulls("Bar", inPlace: true);
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/FillNulls.png" alt="Fill Nulls"></p><p><code>DataFrame</code> exposes a <code>Columns</code> property that we can enumerate over to access our columns and a <code>Rows</code> property to access our rows. We can index <code>Rows</code> to access each row. Here’s an example that accesses the first row:</p><pre><code class="csharp">DataFrameRow row0 = df.Rows[0];
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/BadRowAccess.png" alt="Access Rows"></p><p>To inspect our values better, let’s write a formatter for <code>DataFrameRow</code> that displays values in a single line.</p><pre><code class="csharp">using Microsoft.AspNetCore.Html;
Formatter&lt;DataFrameRow&gt;.Register((dataFrameRow, writer) =&gt;
{
    var cells = new List&lt;IHtmlContent&gt;();
    cells.Add(td(i));
    foreach (var obj in dataFrameRow)
    {
        cells.Add(td(obj));
    }

    var t = table(
        tbody(
            cells));

    writer.Write(t);
}, "text/html");
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/RowAccess.gif" alt="Access Rows"></p><p>To enumerate over all the rows in a <code>DataFrame</code>, we can write a simple for loop. <code>DataFrame.Rows.Count</code> returns the number of rows in a <code>DataFrame</code> and we can use the loop index to access each row.</p><pre><code class="csharp">for (long i = 0; i &lt; df.Rows.Count; i++)
{
       DataFrameRow row = df.Rows[i];
}
</code></pre><p>Note that each row is a view of the values in the <code>DataFrame</code>. Modifying the values in the <code>row</code> object modifies the values in the <code>DataFrame</code>. We do however lose type information on the returned <code>row</code> object. This is a consequence of <code>DataFrame</code> being a loosely typed data structure.</p><p>Let’s wrap up our <code>DataFrame</code> API tour by looking at the <code>Filter</code>, <code>Sort</code>, <code>GroupBy</code> methods:</p><pre><code class="csharp">// Filter rows based on equality
PrimitiveDataFrameColumn&lt;bool&gt; boolFilter = df["Strings"].ElementwiseEquals("Bar");
DataFrame filtered = df.Filter(boolFilter);
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/DataFrameFilter.png" alt="DataFrame Filter"></p><p><code>ElementwiseEquals</code> returns a <code>PrimitiveDataFrameColumn&lt;bool&gt;</code> filled with a <code>true</code> for every row that equals <code>"Bar"</code> in the <code>Strings</code> column, and a <code>false</code> when it doesn’t equal <code>"Bar"</code>. In the <code>df.Filter</code> call, each row corresponding to a <code>true</code> value in <code>boolFilter</code> selects a row out of <code>df</code>. The resulting <code>DataFrame</code> contains only these rows.</p><pre><code class="csharp">// Sort our dataframe using the Ints column
DataFrame sorted = df.Sort("Ints");
// GroupBy 
GroupBy groupBy = df.GroupBy("DateTimes");
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/SortAndGroupBy.png" alt="Sort And GroupBy"></p><p>The <code>GroupBy</code> method takes in the name of a column and creates groups based on unique values in the column. In our sample, the <code>DateTimes</code> column has two unique values, so we expect one group to be created for <code>2019-01-01 00:00:00Z</code> and one for <code>2019-01-02 00:00:00Z</code>.</p><pre><code class="csharp">// Count of values in each group
DataFrame groupCounts = groupBy.Count();
// Alternatively find the sum of the values in each group in Ints
DataFrame intGroupSum = groupBy.Sum("Ints");
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/GroupBySum.png" alt="GroupBy Sum"></p><p>The <code>GroupBy</code> object exposes a set of methods that can called on each group. Some examples are <code>Max()</code>, <code>Min()</code>, <code>Count()</code> etc. The <code>Count()</code> method counts the number of values in each group and return them in a new <code>DataFrame</code>. The <code>Sum("Ints")</code> method sums up the values in each group.</p><p>Finally, when we want to work with existing datasets, <code>DataFrame</code> exposes a <code>LoadCsv</code> method.</p><pre><code class="csharp">DataFrame csvDataFrame = DataFrame.LoadCsv("path/to/file.csv");
</code></pre><h2>Charting</h2><p>Another cool feature of using a <code>DataFrame</code> in a .NET Jupyter environment is charting. <a href="https://fslab.org/XPlot/">XPlot.Plotly</a> is one option to render charts. We can import the <code>XPlot.Plotly</code> namespace into our notebook and create interactive visualizations of the data in our <code>DataFrame</code>. Let’s populate a <code>PrimitiveDataFrameColumn&lt;double&gt;</code> with a normal distribution and plot a histogram of the samples:</p><pre><code class="csharp">#r "nuget:MathNet.Numerics,4.9.0"
using XPlot.Plotly;
using System.Linq;
using MathNet.Numerics.Distributions;

double mean = 0;
double stdDev = 0.1;
MathNet.Numerics.Distributions.Normal normalDist = new Normal(mean, stdDev);

PrimitiveDataFrameColumn&lt;double&gt; doubles = new PrimitiveDataFrameColumn&lt;double&gt;("Normal Distribution", normalDist.Samples().Take(1000));
display(Chart.Plot(
    new Graph.Histogram()
    {
        x = doubles,
        nbinsx = 30
    }
));
</code></pre><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/12/Chart.gif" alt="Chart"></p><p>We first create a <code>PrimitiveDataFrameColumn&lt;double&gt;</code> by drawing 1000 samples from a normal distribution and then plot a histogram with 30 bins. The resulting chart is interactive! Hovering over the chart reveals the underlying data and lets us inspect each value precisely.</p><h2>Summary</h2><p>We’ve only explored a subset of the features that <code>DataFrame</code> exposes. <code>Append</code>, <code>Join</code>, <code>Merge</code>, and <code>Aggregations</code> are supported. Each column also implements <code>IEnumerable&lt;T?&gt;</code>, so users can write LINQ queries on columns. The custom <code>DataFrame</code> formatting code we wrote has a simple example. The complete source code(and documentation) for <code>Microsoft.Data.Analysis</code><a href="https://github.com/dotnet/corefxlab/tree/master/src/Microsoft.Data.Analysis">lives on GitHub</a>. In a follow up post, I’ll go over how to use <code>DataFrame</code> with ML.NET and .NET for Spark. The decision to use column major backing stores (the Arrow format in particular) allows for zero-copy in .NET for Spark User Defined Functions (UDFs)!</p><p>We always welcome the community’s feedback! In fact, please feel free to contribute to the <a href="https://github.com/dotnet/corefxlab/tree/master/src/Microsoft.Data.Analysis">source code</a>. We’ve made it easy for users to create new column types that derive from <code>DataFrameColumn</code> to add new functionality. Support for structs such as <code>DateTime</code> and user defined structs is also not as complete as primitive types such as <code>int</code>, <code>float</code> etc. We believe this preview package allows the community to do data analysis in .NET. Try out <a href="https://www.nuget.org/packages/Microsoft.Data.Analysis/">DataFrame</a> in a <a href="https://mybinder.org/v2/gh/dotnet/interactive/master?urlpath=lab">.NET Jupyter Notebook</a> and let us know what you think!</p><div class="authorinfoarea"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>