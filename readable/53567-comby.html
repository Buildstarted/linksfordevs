<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Comby -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Comby</h1>
    <div class="container"> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby is a tool for matching and rewriting code. You start by writing a simple template to match syntax. Look at this Go function:</p>
</div>
</div> <div class="row"> <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>func main() {
    fmt.Println(&quot;hello world&quot;)
}</code></pre> </div> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">We can match the arguments to <code class="hl-bg-source">fmt.Println</code> with this <i>match template</i>:</p>
</div>
</div> <div class="row"> <div class="col-sm-6 offset-sm-3">
<pre class="match"><code>fmt.Println(<code><span class="hole">:[arguments]</span></code>)</code></pre> </div> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">The <code><span class="hole">:[arguments]</span></code> part is called a hole. It saves the matched part to a variable. In this case, the variable is called <code>arguments</code>, but we could have called it something else, like <code><span class="hole">:[1]</span></code> or <code><span class="hole">:[the_1st_arg]</span></code>. Your choice! As long as it only contains alphabet characters, numbers, or underscores.</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">The <code><span class="hole">:[arguments]</span></code> hole matches the <code class="hl-bg-source">&quot;hello world&quot;</code> string. We can use it in a <i>rewrite template</i> to rewrite the function, like this one:</p>
</div>
</div> <div class="row"> <div class="col-sm-8 offset-sm-2">
<pre class="rewrite"><code>fmt.Println(fmt.Sprintf(&quot;comby says %s&quot;, <code><span class="hole">:[arguments]</span></code>))</code></pre> </div> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby takes the match and rewrite templates and replaces the matched part in place:</p>
</div>
</div> <div class="row"> <div class="col-sm-8 offset-sm-2">
<pre class="source"><code>func main() { <code class="hl-bg-rewrite">fmt.Println(fmt.Sprintf(&quot;comby says %s&quot;, &quot;hello world&quot;))</code>
}</code></pre> </div> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Holes are the only special part in match templates, and they always have the form <code><code><span class="hole">:[...]</span></code></code>. <u>All other characters are interpreted literally</u> (there&apos;s a bit of detail about whitespace that we&apos;ll talk about in the next part). The point is that you <u>never</u> have to escape any characters in your template. Just say what you mean!</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><span class="hole">:[hole]</span></code> matches all characters, including newlines. If the match template was <i>just</i><br> <code><span class="hole">:[file_content]</span></code>, it would match all the file content. The way <code><span class="hole">:[hole]</span></code> starts and stops matching depends on the code structure around it. Let&apos;s look at an example, matching on this Javascript code using the match template on the right:</p>
</div>
</div> <div class="row"> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><span class="hole">:[var]</span></code> matches until it sees the <code class="hl-bg-source">&#xA0;<=&nbsp;<> part coming after it and matches <code class="hl-bg-match">width</code>. <code><span class="hole">:[rest]</span></code> matches the rest of the condition: <code class="hl-bg-match">1280 &amp;&amp; height <=>. These holes match lazily: they look for the shortest way to satisfy the match. One way to refine matching is to add concrete context around holes based on what we care about. For example, we could match <code class="hl-bg-match">height</code> to <code><span class="hole">:[height]</span></code> with both of the following templates, which depends on matching different parts of surrounding code:</=></code></=&nbsp;<></code></p>
</div>
</div> <div class="row"> <div class="col-sm-4 offset-sm-2">
<pre class="match"><code>if (<code><span class="hole">:[_]</span></code> &amp;&amp; <code><span class="hole">:[height]</span></code> <code><span class="hole">:[_]</span></code>)</code></pre> </div> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby tries to make matching code forgiving. Whitespace in the template, like a single space, multiple contiguous spaces, or newlines are interpreted all the same: Comby will match the corresponding whitespace in the source code, but will not care about matching the exact number of spaces, or distinguish between spaces and newlines. Not being strict about whitespace tends to be the right default decision for code in most languages. It means our previous match templates all still work in these cases where our Javascript code is formatted differently:</p>
</div>
</div> <div class="row"> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">If you&apos;re wondering about indentation-sensitive languages like Python, be sure to check out the <a href="#faq-what-about-python" class="inline-a">FAQ</a>.</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">If holes only matched lazily and indiscriminately up to patterns like <code class="hl-bg-source"><=<> it wouldn&apos;t be much more special than matching a sequence of characters. But matching is smarter than that. In many languages, balanced delimiters like <code class="hl-bg-source">()</code>, <code class="hl-bg-source">[]</code> and <code class="hl-bg-source">{}</code> are <u>always</u> balanced. By default, a match template like <code class="hl-bg-match">(<code><span class="hole">:[1]</span></code>)</code> will only match characters <u>inside well-balanced parentheses</u>. Here are two example matches in this code:</=<></code></p>
</div>
</div> <div class="row"> <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>result = foo<code class="hl-bg-match">(<code>bar(x)</code>)</code> + foobar<code class="hl-bg-match">(<code>baz(x)</code>)</code>;</code></pre> </div> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">The hole binds to <code class="hl-bg-source">bar(x)</code> and <code class="hl-bg-source">baz(x)</code> respectively, which we can easily rewrite to a different call <code class="hl-bg-source">qux(x)</code>, for example. The observant reader will notice that <code class="hl-bg-source">(<code>x</code>)</code> are nested matches. By default, Comby will match at the toplevel, but nested matches can be found with added context (e.g., <code class="hl-bg-match">bar(<code><span class="hole">:[1]</span></code>)</code>), or by extracting and rerunning Comby on modified code. Note that writing a regular expression to do the same is not easy (simple attempts like <code class="hl-bg-source">\(.*\)</code> <sup><a href="https://regexr.com/4fssh"><i class="fas fa-external-link-alt fa-fw"></i></a></sup> or <code class="hl-bg-source">\(.*?\)</code> <sup><a href="https://regexr.com/4fssk"><i class="fas fa-external-link-alt fa-fw"></i></a></sup> don&apos;t work).</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Let&apos;s change the code above and make it a little more interesting. Suppose it was this Javascript:</p>
</div>
</div> <div class="row"> <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>var result = foo(bar(x <code>/* arg 1) */</code>)) + foobar(<code>&quot;(&quot;</code>);</code></pre> </div> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Now there&apos;s quite a bit of complexity if we want to match the arguments of <code class="hl-bg-source">foo</code> and <code class="hl-bg-source">foobar</code>. A block comment <code class="hl-bg-source"><code>/* arg 1) */</code></code> is inlined for <code class="hl-bg-source">bar</code>. Because this is a comment, it shouldn&apos;t matter whether the parenthesis inside are balanced or not. The same goes for the string literal argument to <code class="hl-bg-source">foobar</code>: it&apos;s not a parenthesis in the code. The special thing here is that our original match template <code class="hl-bg-match">(<code><span class="hole">:[1]</span></code>)</code> can stay <u>exactly the same</u> and still matches the two arguments (in this case, it captures the comment and string)</p>
</div>
</div> <div class="row"> <div class="col-sm-8 offset-sm-2 mb-3">
<pre class="source"><code>var result = foo<code class="hl-bg-match">(<code>bar(x /* arg 1) */)</code>)</code> + foobar(<code class="hl-bg-match"><code>&quot;(&quot;</code></code>);</code></pre> </div> </div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby understands this interaction between delimiters, strings, and comments and makes reasonable guesses for your language based on file extension (you can also force a particular matcher with a command line option, see the <a href="#quick-reference" class="inline-a">Quick Reference</a>). And, you can always fall back to a generic matcher for files or languages that are not explicitly supported. See the <a href="#faq-language-support" class="inline-a">FAQ</a> for language support and extension.</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Note that if we tried to use a regex above, our pattern would need to understand that <code class="hl-bg-source">/* */</code> delineates comments, otherwise it would get confused by the parenthesis inside! The same problem comes up for the string literal argument, which contains an unbalanced parenthesis. A regular expression that takes all of this into account would get ugly fast, and that&apos;s only for Javascript!</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead">Comby supports the following syntax, which carry special meaning for matching:</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code><span class="hole">:[hole]</span></code></code> matches zero or more characters (including whitespace, and across newlines) in a lazy fashion. When <code><code><span class="hole">:[hole]</span></code></code> is used inside delimiters, as in <code>{<code><span class="hole">:[h1]</span></code>, <code><span class="hole">:[h2]</span></code>}</code> or <code>(<code><span class="hole">:[h]</span></code>)</code>, those delimiters set a boundary for what the hole can match, and the hole will then only match patterns <i>within</i> those delimiters. Holes can be used outside of delimiters as well.</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code>:[[hole]]</code></code> matches one or more alphanumeric characters and <code>_</code>.</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code><code><span class="hole">:[hole.]</span></code></code></code> (with a period at the end) matches one or more alphanumeric characters and punctuation (like <code>.</code>, <code>;</code>, and <code>-</code>).</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code><code><span class="hole">:[hole\n]</span></code></code></code> (with a <code>\n</code> at the end) matches one or more characters up to a newline, including the newline.</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code>:[ ]</code></code> (with a space) matches only whitespace characters, excluding newlines. To assign the matched whitespace to variable, put the variable name after the space, like <code>:[
        hole]</code>.</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code class="hl-bg-source"><code><code><span class="hole">:[?hole]</span></code></code></code> (with a <code>?</code> before the variable name) optionally matches syntax. Optional holes work like ordinary holes, except that if they fail to match syntax, the variable is assigned the empty string <code>&quot;&quot;</code>. Optional hole support is currently an <a href="https://github.com/comby-tools/comby/blob/master/docs/FEATURE_TABLE.md#features" class="inline-a">experimental feature</a>.</p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><i class="fas fa-lightbulb"></i>&#xA0;</code> Using <code><span class="hole">:[hole]</span></code> inside string quotes will match only within the string. This is implemented for <a href="#faq-language-support" class="inline-a">most languages</a>. Comby also understands the difference between escapable string literals (like <code>&quot;string&quot;</code> in C) and raw string literals (like <code>`string`</code> in Go), and will know to stop between these delimiters. <sup><a href="https://bit.ly/2WRnxEL"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><i class="fas fa-lightbulb"></i>&#xA0;</code> Use <code>:[[hole]]</code> to match only alphanumeric and underscore characters. This hole does not match across newlines or punctuation.<sup><a href="https://bit.ly/2WUhPCa"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><i class="fas fa-lightbulb"></i>&#xA0;</code> You can refer to the same variable using either <code>:[[hole]]</code> or <code><span class="hole">:[hole]</span></code> in the rewrite template. <sup><a href="https://bit.ly/2ZAQZR0"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><i class="fas fa-lightbulb"></i>&#xA0;</code> You almost never want to start a template with <code><span class="hole">:[hole]</span></code>, since it matches everything including newlines up to its suffix. This can make things slow. <code><span class="hole">:[hole]</span></code> is typically useful inside balanced delimiters.<sup><a href="https://bit.ly/2WVDzh7"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><i class="fas fa-lightbulb"></i>&#xA0;</code> Consider combinations of holes to match interesting properties. For example, to capture leading indentation of a line, use a template like <br><code>:[ leading_indentation]<code><span class="hole">:[everything_until_newline\n]</span></code></code>.<sup><a href="https://bit.ly/31uC6RE"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><i class="fas fa-lightbulb"></i>&#xA0;</code> Optional holes are useful for matching syntax that may or may not exist. For example, a Go function may or may not have a <a href="https://tour.golang.org/methods/1" class="inline-a">receiver</a>. So, to match all Go functions in a project, including ones with a receiver, use an optional <code><span class="hole">:[?receiver]</span></code> hole.<sup><a href="bit.ly/2XH99RD"><i class="fas fa-external-link-alt fa-fw"></i></a></sup></p>
</div>
</div> <div class="row">
<div class="col-sm-8 offset-sm-2">
<p class="lead"><code><i class="fas fa-lightbulb"></i>&#xA0;</code> Looking for inspiration? Check out these simple code rewrites<sup><a href="https://catalog.comby.dev/"><i class="fas fa-external-link-alt fa-fw"></i></a></sup> and the <a href="#faq-applications" class="inline-a">FAQ</a>.</p>
</div>
</div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>