<!DOCTYPE html>
<html lang="en">
<head>
    <title>
grpc-dotnet/examples at master &#xB7; grpc/grpc-dotnet &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>grpc-dotnet/examples at master · grpc/grpc-dotnet · GitHub</h1><div><div id="" class="markdown-body entry-content p-5"><p>Examples of basic gRPC scenarios with gRPC for .NET.</p><p>If you are brand new to gRPC on .NET a good place to start is the getting started tutorial: <a href="https://docs.microsoft.com/aspnet/core/tutorials/grpc/grpc-start" rel="nofollow">Create a gRPC client and server in ASP.NET Core</a></p><p>The greeter shows how to create unary (non-streaming) and server streaming gRPC methods in ASP.NET Core, and call them from a client.</p><h5><a id="user-content-scenarios" class="anchor" aria-hidden="true" href="#scenarios"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Unary call</li><li>Server streaming call</li><li>Client canceling a call</li></ul><p>The counter shows how to create unary (non-streaming) and client streaming gRPC methods in ASP.NET Core, and call them from a client.</p><h5><a id="user-content-scenarios-1" class="anchor" aria-hidden="true" href="#scenarios-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Unary call</li><li>Client streaming call</li></ul><p>The mailer shows how to create a bi-directional streaming gRPC method in ASP.NET Core and call it from a client. The server reacts to messages sent from the client.</p><h5><a id="user-content-scenarios-2" class="anchor" aria-hidden="true" href="#scenarios-2"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Bi-directional streaming call</li></ul><p>The logger shows how to use interceptors on the client and server. The client interceptor adds additional metadata to each call and the server interceptor logs that metadata on the server.</p><h5><a id="user-content-scenarios-3" class="anchor" aria-hidden="true" href="#scenarios-3"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Creating a client interceptor</li><li>Using a client interceptor</li><li>Creating a server interceptor</li><li>Using a server interceptor</li></ul><p>The racer shows how to create a bi-directional streaming gRPC method in ASP.NET Core and call it from a client. The client and the server each send messages as quickly as possible.</p><h5><a id="user-content-scenarios-4" class="anchor" aria-hidden="true" href="#scenarios-4"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Bi-directional streaming call</li></ul><p>The ticketer shows how to use gRPC with <a href="https://docs.microsoft.com/aspnet/core/security" rel="nofollow">authentication and authorization in ASP.NET Core</a>. This example has a gRPC method marked with an <code>[Authorize]</code> attribute. The client can only call the method if it has been authenticated by the server and passes a valid JWT token with the gRPC call.</p><h5><a id="user-content-scenarios-5" class="anchor" aria-hidden="true" href="#scenarios-5"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>JSON web token authentication</li><li>Send JWT token with call</li><li>Authorization with <code>[Authorize]</code> on service</li></ul><p>The reflector shows how to host the <a href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md">gRPC Server Reflection Protocol</a> service and call its methods from a client.</p><h5><a id="user-content-scenarios-6" class="anchor" aria-hidden="true" href="#scenarios-6"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Hosting gRPC Server Reflection Protocol service</li><li>Calling service with <code>Grpc.Reflection</code> client</li></ul><p>The certifier shows how to configure the client and the server to use a <a href="https://blogs.msdn.microsoft.com/kaushal/2015/05/27/client-certificate-authentication-part-1/" rel="nofollow">TLS client certificate</a> with a gRPC call. The server is configured to require a client certificate using <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth" rel="nofollow">ASP.NET Core client certificate authentication</a>.</p><blockquote><p><strong>NOTE:</strong> client.pfx is a self-signed certificate. When running the client you may get an error that the certificate is not trusted: <code>The certificate chain was issued by an authority that is not trusted</code>. <a href="https://www.thesslstore.com/knowledgebase/ssl-install/how-to-import-intermediate-root-certificates-using-mmc/" rel="nofollow">Add the certificate</a> to your computer's trusted root cert store to fix this error. Don't use this certificate in production environments.</p></blockquote><h5><a id="user-content-scenarios-7" class="anchor" aria-hidden="true" href="#scenarios-7"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Client certificate authentication</li><li>Send client certificate with call</li><li>Receive client certificate in a service</li><li>Authorization with <code>[Authorize]</code> on service</li></ul><p>The worker shows how to use call a gRPC server with a <a href="https://docs.microsoft.com/aspnet/core/fundamentals/host/hosted-services" rel="nofollow">.NET worker service</a>. The client uses the worker service to make a gRPC call on a timed internal. The gRPC client factory is used to create a client, which is injected into the service using dependency injection.</p><p>The server is configured as a normal .NET web app, which uses the same <a href="https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host" rel="nofollow">generic host</a> as a worker service to host its web server.</p><p>The client or server can be run as a <a href="https://en.wikipedia.org/wiki/Windows_service" rel="nofollow">Windows service</a> or <a href="https://www.freedesktop.org/wiki/Software/systemd/" rel="nofollow">systemd service</a> with some minor changes to the project file and startup logic:</p><h5><a id="user-content-scenarios-8" class="anchor" aria-hidden="true" href="#scenarios-8"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Worker service</li><li>Client factory</li></ul><p>The aggregator shows how a to make nested gRPC calls (a gRPC service calling another gRPC service). The gRPC client factory is used in ASP.NET Core to inject a client into services. The gRPC client factory is configured to propagate the context from the original call to the nested call. In this example the cancellation from the client will automatically propagate through to nested gRPC calls.</p><p>The aggregator can optionally be run with <a href="https://github.com/open-telemetry/opentelemetry-dotnet">OpenTelemetry</a> enabled. OpenTelemetry is configured to capture tracing information and send it to <a href="https://zipkin.io" rel="nofollow">Zipkin</a>, a distributed tracing system. A Zipkin server needs to be running to receive traces. The simplest way to do that is <a href="https://zipkin.io/pages/quickstart.html" rel="nofollow">run the Zipkin Docker image</a>.</p><p>To run the aggregator server with OpenTelemetry enabled:</p><div class="highlight highlight-text-shell-session"><pre><span class="pl-c1">dotnet run --EnableOpenTelemetry=true</span></pre></div><h5><a id="user-content-scenarios-9" class="anchor" aria-hidden="true" href="#scenarios-9"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Client factory</li><li>Client canceling a call</li><li>Cancellation propagation</li><li>Capture tracing with <a href="https://github.com/open-telemetry/opentelemetry-dotnet">OpenTelemetry</a> (optional)</li></ul><p>The tester shows how to test gRPC services. The unit tests create and test a gRPC service directly. The functional tests show how to use <a href="https://www.nuget.org/packages/Microsoft.AspNetCore.TestHost/" rel="nofollow">Microsoft.AspNetCore.TestHost</a> to host a gRPC service with an in-memory test server and call it using a gRPC client. The functional tests write client and server logs to the test output.</p><blockquote><p><strong>NOTE:</strong> There is a known issue in ASP.NET Core 3.0 that prevents functional testing of bidirectional gRPC methods. Bidirectional gRPC methods can still be unit tested.</p></blockquote><h5><a id="user-content-scenarios-10" class="anchor" aria-hidden="true" href="#scenarios-10"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Unit testing</li><li>Functional testing</li></ul><p>The progressor shows how to use server streaming to notify the caller about progress on the server.</p><h5><a id="user-content-scenarios-11" class="anchor" aria-hidden="true" href="#scenarios-11"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Server streaming</li><li>Using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.progress-1" rel="nofollow"><code>Progress&lt;T&gt;</code></a> to notify progress on the client</li></ul><p>The vigor example shows how to integrate <a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/health-checks" rel="nofollow">ASP.NET Core health checks</a> with the <a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md">gRPC Health Checking Protocol</a> service, and call its methods from a client.</p><h5><a id="user-content-scenarios-12" class="anchor" aria-hidden="true" href="#scenarios-12"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Hosting gRPC Health Checking Protocol service</li><li>Integrate <a href="https://docs.microsoft.com/aspnet/core/host-and-deploy/health-checks" rel="nofollow">ASP.NET Core health checks</a> with gRPC health checks</li><li>Calling service with <code>Grpc.HealthCheck</code> client</li></ul><p>The browser example shows how to use <a href="https://github.com/grpc/grpc-web">gRPC-Web</a> with ASP.NET Core to call a gRPC service from a browser. Browser apps have limited HTTP/2 features and need to use gRPC-Web instead. This example requires <a href="https://nodejs.org/" rel="nofollow">npm and NodeJS</a> to be installed on your computer.</p><p>The gRPC-Web JavaScript client was generated from <em>greet.proto</em> using <a href="https://github.com/protocolbuffers/protobuf/releases"><code>protoc</code></a> with the <a href="https://github.com/grpc/grpc-web/releases"><code>protoc-gen-grpc-web</code></a> plugin.</p><h5><a id="user-content-scenarios-13" class="anchor" aria-hidden="true" href="#scenarios-13"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Configure ASP.NET Core server to support <code>grpc-web</code> and <code>grpc-web-text</code> content types</li><li>Call gRPC services with JavaScript from a browser</li></ul><p>The blazor example shows how to call a gRPC service from a Blazor WebAssembly app. Because Blazor WebAssembly is hosted in the browser it has limited HTTP/2 features and needs to use gRPC-Web instead.</p><p><strong>Known Blazor WebAssembly issues:</strong></p><h5><a id="user-content-scenarios-14" class="anchor" aria-hidden="true" href="#scenarios-14"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Scenarios:</h5><ul><li>Configure ASP.NET Core server to support <code>grpc-web</code> and <code>grpc-web-text</code> content types</li><li>Configure .NET gRPC client in Blazor to use gRPC-Web</li><li>Call gRPC services with Blazor WebAssembly from a browser</li></ul></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>