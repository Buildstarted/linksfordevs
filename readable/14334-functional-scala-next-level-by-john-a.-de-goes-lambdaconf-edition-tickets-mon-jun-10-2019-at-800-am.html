<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Functional Scala: Next Level by John A. De Goes (LambdaConf Edition) Tickets, Mon, Jun 10, 2019 at 8:00 AM -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>Functional Scala: Next Level by John A. De Goes (LambdaConf Edition) Tickets, Mon, Jun 10, 2019 at 8:00 AM</h1><div><div class="js-xd-read-more-contents l-mar-top-3" data-automation="listing-event-description" xmlns="http://www.w3.org/1999/xhtml"><h2>Functional Scala: Next Level by John A. De Goes</h2><p><em>Functional Scala: Next Level</em> is an extensive 3 day course that may be attended remotely (Denver time zone) or locally (Boulder, Colorado). The course instructs functional Scala developers on how to use functional programming to structure and write better code, including how to design well-abstracted, concurrent, and performant code that, compared to its procedural equivalent, is easier to test, easier to reason about, and easier to change safely in whatever directions are required by the business.</p><p>If you are already doing functional Scala, or if you have attended <em>Functional Scala by John A. De Goes</em>, and want to take your functional skills to the next level, then this is the course for you. You will learn how to build code that is both beautiful and practical, correct and testable, and satisfying the ever-changing needs of business.</p><h2><strong>Prerequisites</strong></h2><p>This course assumes prior knowledge of basic programming in Scala. You should ensure that you are comfortable with the following topics to maximize your takeaway from this course:</p><ul><li>Case Classes, Pattern Matching, Basic Recursion, Traits and Objects, Scala Collections, Basic Generics</li><li>Parametric Polymorphism</li><li>Types and Values</li><li>Higher-Kinded Types</li><li>Type Classes </li><li>Functional Abstractions (Monoid, Functor, etc.)</li><li>Basic Functional Effects (<em>IO Monad</em>)</li></ul><h2>Day 1: Functional Architecture</h2><p>In <em>Functional Architecture</em>, you will learn how to structure large-scale applications to benefit from properties unique to functional programming, with a special emphasis on what architectural patterns work best for asynchronous and concurrent applications. By the end of the day, you will have a better feel for how functional programming can answer the big picture questions of application architecture. <strong><em>Note</em></strong>: <em>While the ZIO library will be used in the exercises and examples, the architectural patterns presented can be applied to other functional effect systems</em>.</p><ul><li><strong>Error Management</strong>. In object-oriented programming, errors are usually managed using exceptions (checked or unchecked), which makes it difficult to reason about error behavior, tedious to evade non-recoverable errors, and which fails completely for asynchronous code. In functional programming, thanks to monadic effect systems, new strategies emerge for dealing with errors, which allow local reasoning and error response across subsystems, unify synchronous and asynchronous errors, remove the need for logging errors at edges of the code, and use the Scala compiler to help ensure that recoverable errors are fully dealt with at the edges. You will learn how functional programming allows applications to respond dynamically and precisely to the most complex of error conditions.</li><li><strong>Thread Management</strong>. In object-oriented programming, thread management often happens manually, with passing of implicit execution contexts, or propagating and invoking executors backed by thread pools. Due to the difficulty of manual thread management, it is common for applications to run code on the wrong threads, to leak threads, or to have too many threads that limit application throughput and increase latency. In functional programming, because effects are pure values, thread management can be entirely declarative and automatic, eliminating whole classes of errors and enabling teams to be more productive. You will learn how to isolate blocking operations, how to cleanly terminate blocking operations, and when and how to go beyond the standard two thread pool setup.</li><li><strong>Advanced Concurrency</strong>. In object-oriented programming, concurrency is often introduced using actors, threads, or futures, and data is shared through message passing, locks and condition variables, or standalone (and blocking) concurrent data structures. These techniques have the drawback that they require a different computing model, they do not have compositional transaction semantics, and many of them are blocking rather than asynchronouos. In functional programming, introducing concurrency is as easy as using declarative concurrent and parallel operations, which do not require a different computational model, which are always non-blocking, and which are higher-level than other approaches. You will learn about asynchronous and concurrent data structures, including references, queues, semaphores, and promises, and then graduate to a discussion of software transactional memory (STM), showing how anyone can build custom asynchronous and concurrent structures that compose with other structures using STM.</li></ul><h2>Day 2: Functional Design</h2><p>In <em>Functional Design</em>, you will learn how to design functional interfaces that can be used to flexibly, composably, and type-safely solve domain-specific business problems. By the end of the day, you will have developed skills and instincts that help you build functional APIs whose composability and orthogonality allow you to solve business problems in the 'language' of the domain.</p><ul><li><strong>Type-Driven Development. </strong>In object-oriented programming, lack of purity and limitations of the type system limit the extent to which the types of a model imply its capabilities. In functional programming, types solely determine capabilities, which means that types themselves can be used to guide design of APIs intended to solve domain problems. You will learn how to think about types-as-capabilities, and how to experiment with different types until a desired set of capabilities emerge.</li><li><strong>Abstraction</strong>. In object-oriented programming, solutions to problems often become distracted by too many concrete details, which makes reasoning about and testing code more difficult, and increases the cost of change. In functional programming, abstraction can be used to throw away irrelevant details, making reasoning and testing easier, and improving application flexibility as business requirements change. You will learn structured approaches for throwing away details that may seem relevant, but which are actually unnecessary for a given problem.</li><li><strong>Composable Design</strong>. In object-oriented programming, the effectful nature of most code limits the ability to create composable interfaces. In functional programming, all things are values, which opens up the path to designing an API as a collection of types and operations on values of those types. You will learn how to break apart a business problem into core data types and closed oeprations on values of those types, providing a language in which to natively express solutions to that business problem.</li><li><strong>Orthogonal Design</strong>. In object-oriented programming, the Single Responsibility Principle (SRP) helps programmers avoid conflating different concerns in the same class, but in practice, determining what a single responsibility is has proven difficult. Functional programming has a similar philosophy of design, called <em>orthogonal design</em>, which is easier to identify. You will learn how to spot an orthogonal design, and how to take a design that is not orthogonal, and experiment with it until you converge on an orthogonal design that allows modular solutions and avoids conflating different responsibilities.</li></ul><h2>Day 3: Functional Applications</h2><p>In <em>Functional Applications</em>, you will gain practice using your newfound skills and knowledge to structure a small application and design an API that allows you to express solutions to a business problem. This application will follow best practices for error management and thread management, and will utilize software transactional memory to provide non-blocking updates of shared data, automatic retries for unmet conditions, and safe transactional semantics across different structures. The application will be fully testable, not requiring any interaction with the external world in test scenarios, providing fast, deterministic unit tests that can help ensure business requirements are met. The application will utilize a domain-specific functional API that you design, which will provide a flexible, composable, and type-safe way to express business logic.</p><h2>Daily Structure</h2><ul><li><p>8:00 - Breakfast</p></li><li><p>9:00 - Begin Instruction</p></li><li><p>10:25 - Break</p></li><li><p>10:35 - Resume Instruction</p></li><li><p>12:00 - Catered Lunch</p></li><li><p>13:30 - Resume Instruction</p></li><li><p>14:55 - Break</p></li><li><p>15:05 - Resume Instruction</p></li><li><p>16:25 - Break</p></li><li><p>16:35 - Resume Instruction</p></li><li><p>17:30 - End of Day</p></li></ul><h2>Venue </h2><p>The training course will take place at the Wolf Law Building, co-located with LambdaConf 2019. The Wolf Law Building sits in the heart of Boulder, Colorado, one of the highest-rated places to live in America.</p><h2>Attendance</h2><p>Attendance to <em>Functional Scala: Next Level</em> is local or remote. Local attendees must arrange their own transportation and lodging to the host city. Remote attendees will be provided with a link to a remote meeting session, in which they can see and hear the live workshop, ask the instructor questions, and chat with both local and remote attendees. Motivated remote attendees who participate in all exercises can expect to get nearly as much out of the training as local attendees.<br></p><h2>Materials</h2><p>Attendees will be provided with example code, a course outline, and exercises in electronic form. The workshop is not recorded and recording is strictly prohibited.</p><h2>Financial Aid <br></h2><p>Financial aid is available for qualified applicants. If you would like to attend the training but cannot afford the list prices, please contact the organizer for information on all available aid packages.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>