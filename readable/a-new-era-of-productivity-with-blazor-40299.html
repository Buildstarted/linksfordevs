<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A New Era of Productivity with Blazor - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A New Era of Productivity with Blazor - linksfor.dev(s)"/>
    <meta property="article:author" content="CODE Magazine, EPS Software Corp., Ed Charbeneau"/>
    <meta property="og:description" content="Blazor is a new Web framework that uses .NET Core&#x2019;s architecture, essentially combining the simplicity of Razor with .NET Core concepts. Ed shows you ho..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.codemag.com/article/1911052"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A New Era of Productivity with Blazor</title>
<div class="readable">
        <h1>A New Era of Productivity with Blazor</h1>
            <div>by CODE Magazine, EPS Software Corp., Ed Charbeneau</div>
            <div>Reading time: 28-36 minutes</div>
        <div>Posted here: 01 Nov 2019</div>
        <p><a href="https://www.codemag.com/article/1911052">https://www.codemag.com/article/1911052</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>Web development has never been easy, but over the past decade, it has increased in complexity. Front-end Web development defaults to JavaScript as a solution for every problem. JavaScript frameworks, package managers, and tooling make a vast and powerful ecosystem with a variety of options and they all share a common issue. According to the "State of JavaScript 2018" survey, developers agree that these solutions are complex, bloated, and have a steep learning curve. If you’re skeptical, check out StateOfJS 2018: Most Disliked Aspects of Angular <a href="https://2018.stateofjs.com/front-end-frameworks/angular/dislikes" target="_blank">https://2018.stateofjs.com/front-end-frameworks/angular/dislikes</a>.</p><p>Challenging the status quo is Blazor, a new Web framework that’s not only powerful but productive too. Blazor uses .NET Core’s architecture for common patterns and practices across the entire stack. Blazor leverages .NET Core’s capability to run anywhere by supporting a <b>client-side and server-side hosting</b> model. The duality of Blazor provides choices while remaining flexible enough to switch between hosting modes easily. Blazor combines the ease of <b>Razor</b> with other .NET Core concepts like: <b>dependency injection</b>, <b>configuration</b>, and <b>routing</b>. It’s borrowed the best patterns from popular JavaScript frameworks like Angular and React while leveraging Razor templates and its provided parity with other .NET conventions and tooling.</p><h2>Razor Component Model</h2><p>You’ll find the Razor Component model very familiar from working with ASP.NET MVC or Razor Pages. Razor Components incorporate the Razor syntax with a new method of encapsulating markup into reusable components. With Razor Components, you’ll quickly create the building blocks of your application’s user interface. Components are .NET classes whose properties are component parameters; this basic system makes Razor Components easy to author. By breaking the component model down into three concepts: <b>directives</b>, <b>markup</b>, and <b>code</b>, you can understand how they’re created.</p><p>Components are .NET classes whose properties are component parameters.</p><p>In <b>Figure 1, </b>components use directives to add special functionality like routing or dependency injection. Syntax for directives is similar to that used in ASP.NET MVC or Razor Pages. Component markup is primarily HTML, which is enhanced through the Razor syntax. The Razor syntax allows C# to be used in-line with markup and can render values in the UI. The component’s logic is written inside a <b>@code</b> block. This is where component parameters and data-bound values are defined. Alternatively, code be referenced using a code-behind approach much like ASP.NET WebForms. The Razor Component model allows you to break down your UI into manageable pieces. Components can then be assembled into larger UIs, forming more complex components and pages.</p><figure><img src="https://www.codemag.com/Article/Image/1911052/image1.tiff"><figcaption>      <b>Figure 1</b>: A breakdown of Razor Component, the most basic building block in a Blazor application</figcaption></figure><h2>A Tale of Two Blazors</h2><p>Blazor initially started as a client-side single page application (<b>SPA</b>) framework. The goal of Blazor is to run .NET applications in the browser using WebAssembly and the Razor syntax, and over the course of development, the ASP.NET team added a server-side hosting model to Blazor. Although each hosting model offers fundamentally different strengths, they both rely on the same underlying architecture. This approach enables developers to write most of their code independent of the hosting model. Ideally, the only time code can be identified as server- or client-centric is when data is being fetched. Let’s take a closer look at the two hosting models to further understand their viability.</p><h3>Client-Side Blazor with WebAssembly</h3><p>On the client-side, Blazor is made possible by WebAssembly, this is referred to as a Blazor WebAssembly app. WebAssembly (wasm) is a binary instruction format for Web browsers that’s designed to provide a compilation target for high-level languages like C++. Blazor leverages this technology via the Mono runtime, which is compiled to a WebAssembly module. As you can see in <b>Figure 2, </b>introducing the .NET runtime to the browser enables .NET libraries (.dlls) to run directly on the client. </p><figure><img src="https://www.codemag.com/Article/Image/1911052/image2.tif"><figcaption>      <b>Figure 2</b>: This diagram shows the .NET runtime inside the browser using WebAssembly. Blazor uses this runtime to work directly with standard .NET libraries (.dll).</figcaption></figure><p>There are tradeoffs with this approach in the way of performance and package size, but ultimately, portability is the real strength here. Because Blazor applications use .NET libraries, there’s no need to recompile existing code or use special complier targeting. Application code can be shared across .NET projects resulting in writing less code. In a typical JavaScript front-end application, code for validation and data transfer is often duplicated because it’s required in both .NET and JavaScript layers. This isn’t required in a Blazor application because both client and server code can reference the same libraries. </p><p>There’s no need to recompile existing code or use special complier targeting.</p><p>As with any client-side technology, Blazor WebAssembly apps rely on RESTful Web services for data. Fetching data is done through HttpClient, the standard for the .NET ecosystem. When you make HTTP calls in Blazor, the data is automatically serialized to the specified class object. Let’s examine the <b>HttpClient’s GetJsonAsync&lt;T&gt;</b> method call so you can understand its simplicity.</p><p>In a Web API application, you have a <b>WeatherForecast</b> controller with an endpoint that returns an IEnumerable of WeatherForecast. When the Get method is invoked, ASP.NET automatically serializes the response into a JSON string.</p><pre><code>[<span>ApiController</span>]
[<span>Route(<span>"[controller]"</span>)</span>]
<span>public</span> <span>class</span> <span>WeatherForecastController</span> :
<span>ControllerBase</span>
{
   [<span>HttpGet</span>]
   <span><span>public</span> IEnumerable&lt;WeatherForecast&gt; <span>Get</span>(<span></span>) </span>{…}
}

</code></pre><p>When fetching data from a Blazor application, you create a field to hold a WeatherForecast array. In this example, you’ll leverage the <b>OnInitializedAsync</b> lifetime method to populate the <b>forecasts<i></i></b>field. Using the <b>GetJsonAsync,</b> you make a Get request to the WeatherForecast controller. Because GetJsonAsync is called with the specified type <b>WeatherForecast[]</b>, it returns a serialized result of this type.</p><pre><code>WeatherForecast[] forecasts;
<span><span>protected</span> <span>override</span> <span>async</span>
Task <span>OnInitializedAsync</span>(<span></span>)
</span>{
    forecasts = <span>await</span> Http.
GetJsonAsync&lt;WeatherForecast[]&gt;
(<span>"WeatherForecast"</span>);
}

</code></pre><p>Both the Web API and client application can use the same WeatherForecast class, which results in less code, testing, and complexity.</p><p>You can further reduce complexity in your application by running Blazor server-side. When running server-side, Blazor can use Entity Framework, directly eliminating the need for a Web API application all together.</p><h3>Blazor Server-Side with SignalR</h3><p>A Blazor Server app takes a different approach to building a .NET Web application than Blazor WebAssembly. With a Blazor Server app, <b>instead of using WebAssembly,</b> the browser is treated as a thin client. All of the application code runs on the server using .NET Core runtime. To enable this thin-client operation, a light-weight SignalR library is bootstrapped on the client that allows server code to send asynchronous notifications using Web sockets. Messages sent between the server and client only contain events and updates. As you can see in <b>Figure 3,</b> Blazor runs on the server and communicates with the browser over SignalR while the thin client handles updates to the DOM.</p><figure><img src="https://www.codemag.com/Article/Image/1911052/image3.tiff"><figcaption>      <b>Figure 3</b>: This diagram shows Blazor running server-side and interacting with the Browser using a SignalR connection.</figcaption></figure><p>Because the application code runs completely on the server-side, the data layer may be tightly coupled without the need for a data layer. This approach is ideal for line-of-business applications where a persistent connection is available.</p><p>Blazor Server apps don’t require a Web API service for communicating with a database or services when the data is on the same server. Instead of using the HttpClient as with Blazor WebAssembly, you can instead inject services into the application for direct use. Ultimately, Blazor Server applications require fewer abstractions and can be composed within a single project.</p><p>Fetching data is a simple task from Blazor Server when using Entity Framework Core directly. You’ll begin by creating a field that holds your data. In this example, you’ll leverage the <b>OnInitializedAsync</b> lifetime method to populate the <b>blogs<i></i></b>field. Using the dbContext, you make a call to <b>ToArrayAsync</b>. Because the application runs completely server-side, there’s no Web API endpoint or concern for serialization and deserialization. </p><pre><code>Blog[] blogs;
<span><span>protected</span> <span>override</span> <span>async</span> Task <span>OnInitializedAsync</span>(<span></span>)
</span>{
    blogs = <span>await</span> dbContext.Blogs.ToArrayAsync();
}

</code></pre><p>Using Blazor gives you the choice of building a RESTful client-side application using .NET technologies instead of JavaScript, or a server-side .NET Web application with reduced complexity.</p><h2>Vertical Slices</h2><p>The Blazor framework doesn’t prescribe how you design your application layers. As you build Blazor applications, you’ll see that the application stack is reduced, especially with the Blazor Server app model. This challenges you to re-think the design patterns you may be used to. Modern applications use familiar patterns like Model-View-Controller (MVC), Mode-View-ViewModel (MVVM), or Mode-View-Presenter (MVP). These patterns work well and Blazor can adopt these strategies, but the Blazor framework really shines with <b>Vertical Slices Architecture.</b></p><p>Other application models couple together parts of the application by role: view, data, and unit of work. Vertical Slice Architecture couples the application by common features (ex: Blog Posts), as shown in <b>Figure 4</b>. The reason this approach works so well in Blazor is the component model, routing, and .NET. The entire application stack can be completed with only components and .NET classes.</p><figure><img src="https://www.codemag.com/Article/Image/1911052/image4.tif"><figcaption>      <b>Figure 4</b>: Vertical Slices group code by feature instead of grouping code by function.</figcaption></figure><p>Components handle application routing, which assists in keeping features together. Because many components work together to complete a feature, they can easily be grouped into folders or libraries. Navigating the codebase is easier when using this method over an MVC approach. In a typical application, when a requirement changes, each layer of the application must adopt the change. For example, when a field is added to a form on the UI, the change must carry through each layer, down to adding a column at the database level. With feature slices, the same changes are required but the files being touched all belong to the same slice simplifying the task. In <b>Figure 5</b>, all of the code used in the <b>Post Feature</b> is grouped within a folder, including the data model, forms, and views required to complete the feature. </p><figure><img src="https://www.codemag.com/Article/Image/1911052/image5.tif"><figcaption>      <b>Figure 5</b>: Each Post-related component and class is grouped by feature folder.</figcaption></figure><p>Let’s get an understanding of how the <b>Post</b> feature in <b>Figure 5</b> was created. You’ll start by adding the <b>Post.cs</b> class to describe the data. <b>Listing 1</b> shows that the <b>Post</b> consists of a simplified class with data attributes. The data attributes are common .NET conventions adding metadata that describes how the object is represented by Entity Framework and how it’s validated. You add the <b>Required</b>, <b>MaxLength</b>, and <b>MinLength</b> attributes to the validation behavior for each of the properties. The properties <b>SelectedBlogId</b> and <b>BlogList</b> are used hold additional values in the view and get decorated with <b>NotMapped</b> attributes, which indicates that the properties <b>don’t map to a database</b>. For more complex views, a view model could be used, but this isn’t necessary as you’re only adding two additional properties.</p><pre><code>[<span>NotMapped</span>] 
<span>public</span> Blog[] BlogList { <span>get</span>; <span>set</span>; }

</code></pre><p>Now that the data model is in place, you’ll create a component that acts as an update form. In <b>Listing 2</b>, you create the <b>PostUpdate.razor</b> component that will handle the UI, validate using the Post model attributes, and perform the database operation. At the top of the component, you add a page route that accepts the <b>PostId</b> to be updated. </p><pre><code>@<span>page</span> <span>"/post/update/{PostId:int}"</span>
@* Ex: Route matches /post/<span>update</span>/<span>5</span> *@

</code></pre><p>Using the <b>@inject</b> directive, you resolve the <b>BloggingContext</b> as dbContext. Add an <b>EditForm</b> to the component that accepts a model and provides the method handler <b>OnValidSubmit,</b> which you use to handle an update only when valid data is present. To apply validation to the form, add a <b>DataAnnotationsValidator</b>. In the feature, you have multiple forms with the same schema, so you’re able to condense these inputs into a common <b>PostEditForm</b> component, as shown in <b>Listing 3</b>. The PostEditForm supplies all inputs for the UI and you add two-way databinding to each input using <b>@bind-Value=Model.Property</b>.</p><p>With the form completed, you’ll add logic for populating the form and submitting an update. Inside the <b>@Code</b> block of <b>Listing 1,</b> the properties and fields are used to hold the component’s state. The two methods <b>OnInitializedAsync</b> and <b>HandleValidSubmit</b> are responsible for querying and submitting data. First, populate the state of the component when it initializes with a simple query. To do this, you’ll override OnInitializedAsync and fetch the record from the database by directly using the dbContext object. You’ll fetch the record to be updated using the PostId supplied by routing. By asynchronously calling <b>await dbContext.Posts.FirstAsync(p =&gt; p.PostId == PostId)</b> the post is retrieved and model binding automatically updates the UI. You’ll also populate the select list on the form using a similar query by calling <b>await dbContext.Blogs.ToArrayAsync()</b> and setting the model’s BlogList value. The PostUpdate can now be displayed, and in <b>Figure 6</b> you can see how the component looks in the browser.</p><figure><img src="https://www.codemag.com/Article/Image/1911052/image6.tif"><figcaption>      <b>Figure 6</b>: The update post component rendered in the browser with an invalid form value and validation illuminated.</figcaption></figure><p>Next, you’ll commit changes to the Post object that’s bound to the form. When the submit button of the form is clicked, the EditForm invokes the HandleValidSubmit event handler. Inside the event handler, you simply call <b>dbContext.SaveChangesAsync()</b> to save your changes. Because you’re binding directly to the entity and using two-way databinding, no additional plumbing code is required.</p><p>Each function of the feature, whether it’s creating, updating, or viewing data, follows these principals. The code shares a common pattern while remaining independent of implementation and flexible. As with this example, much of the straightforwardness in the framework comes from the power of the .NET platform.</p><h2>Advantage of .NET</h2><p>When developing client-side Web applications with JavaScript, you lack the ability to effectively work with types, dates, and numbers without requiring large dependencies or adopting TypeScript. The same holds true for JavaScript tooling; you’re often spending valuable time managing packages and configuring build processes. In comparison, the .NET platform gives you the power of a built-in type system, intuitive tooling, and a rich ecosystem. With .NET, you’re immediately in a productive environment for building modern applications with technologies that you already understand, so the learning curve for producing a Blazor application is short.</p><h3>Working with Types</h3><p>Working with strongly typed objects is one of .NET’s most important features. You can see in <b>Listing 1, Listing 2, </b>and<b> Listing 3</b> that strongly typed objects are used throughout the system, including typed properties, parameters, and backing values. This gives reassurance that you’ll avoid errors at or before compile time instead of during run-time. The same system also gives context to which type is needed to fulfill a property or parameter so you can spend less time in documentation and more time coding.</p><p>In <b>Figure 7</b>, you can see that the form’s model is bound to a component and IntelliSense provides quick access to properties available on the object. In addition to the compiler, when using Visual Studio, you receive rich IntelliSense powered by machine learning (a.k.a. IntelliCode) that can predict which properties and methods you’ll likely call on a given object. </p><figure><img src="https://www.codemag.com/Article/Image/1911052/image7.tif"><figcaption>      <b>Figure 7</b>      : IntelliSense automatically suggests properties of the Model object to use for the component’s value.</figcaption></figure><p>IntelliCode prompts are denoted with a <b>star</b> icon, as seen in <b>Figure 8</b>.</p><figure><img src="https://www.codemag.com/Article/Image/1911052/image8.tif"><figcaption>      <b>Figure 8</b>: IntelliCode uses machine learning to improve the accuracy of suggestions made by IntelliSense.</figcaption></figure><p>JavaScript’s number type is used for integers and floating-point operations. The type is actually a 64bit floating point like C#’s double type. This leads to common misconceptions in JavaScript about how numbers compute and evaluate. These misconceptions can result in mistakes and thus program errors. With C#, you use numeric types less interchangeably as you rely on a variety of signed and unsigned integral types as well as three floating point types. Most importantly is C#’s <b>decimal</b> type, a <b>high-precision 128bit floating point type</b> for special use cases like calculating currency.</p><p>In the following example, you can see just how differently doubles and decimals are handled and written. In C#, when using static number values, the compiler is the first sanity check as you must specify the proper suffix, F for double and M for decimal, before assigning values. This is where the type system and compiler assist you by ensuring that arbitrary values aren’t assigned incorrectly. When the floating-point numbers are rounded, the resulting value can vary depending on the value type’s precision. </p><pre><code>Console.WriteLine(<span>"Double"</span>);
Console.WriteLine(<span>0.1F</span> + <span>0.2F</span> == <span>0.3F</span>); 

Console.WriteLine(<span>"Decimal"</span>);
Console.WriteLine(<span>0.1</span>M + <span>0.2</span>M == <span>0.3</span>M); 


</code></pre><p>Working with decimals in Blazor works the same as you would expect in a typical .NET application. Let’s look at decimal usage in the context of a component so you can see how values are handled. Use the fields <b>x </b>and <b>y</b> to hold a decimal with a value of 0.1M and 0.2M respectively. These values are then two-way data-bound to HTML inputs using the <b>@bind<i></i></b>directive. To write the sum of these two values, use a read-only property called <b>Result</b>. In the markup, you call <b>ToString</b> with the format of <b>G17</b>, a general numeric format specifier with the maximum of 17 digits of precision. When the example runs, you have real-time data binding with a decimal type in the browser. This is all possible because the Blazor framework is automatically formatting and parsing the values to the correct type and culture for you through the bind operation.</p><pre><code>&lt;input <span>type</span>=<span>"number"</span> <span>@bind</span>=x /&gt;
&lt;input <span>type</span>=<span>"number"</span> <span>@bind</span>=y /&gt;
Result = <span>@Result</span>.ToString(<span>"G17"</span>)
<span>@code</span> {
    decimal x = <span>0.1</span>M;
    decimal y = <span>0.2</span>M;
    decimal Result =&gt; x + y;
}

</code></pre><p>In addition to a range of numeric types, C# has a robust system for handling dates and times. In a typical JavaScript application, you need to rely on a third-party library like moment.js to work with dates and times in a productive way. Because components in Blazor are using .NET and C# language <b>DateTime</b> types are handled natively. In the following example, you bind two dates to inputs and display the difference between them as the number of days. When the two DateTime values are subtracted, the result is a <b>TimeSpan</b>. Using the TimeSpan, write the number of days by calling the <b>Days</b> method.</p><pre><code>&lt;input <span>type</span>=<span>"date"</span> @<span>bind</span>=<span>"startDate"</span> /&gt;
&lt;input <span>type</span>=<span>"date"</span> @<span>bind</span>=<span>"endDate"</span> /&gt;
&lt;span&gt;@((endDate - startDate).Days) Days&lt;/span&gt;

</code></pre><p>The compiler and Visual Studio’s support of types is a large part of what makes them so functional. This functionality is built into the tooling and helps speed up coding activities while improving discoverability of APIs. </p><h3>Front-End Tooling</h3><p>As with any Web application, a Blazor application requires front-end Web dependencies. In the current climate of front-end Web development, most dependencies are resolved and built using JavaScript tooling such as <b>npm </b>and <b>Webpack</b>. These tools are powerful but can be cumbersome to use, increase the learning curve of the platform, involve writing JavaScript code, and run in the context of Nodejs. Most front-end dependencies don’t actually need these complex tools, nor are you required to directly use them to accomplish what you need. The .NET ecosystem and Visual Studio have tools available to <b>manage front-end dependencies</b> and perform tasks like <b>compiling Sass into CSS</b>.</p><p>Library Manager (<b>LibMan</b>) is a lightweight, front-end dependency acquisition tool. LibMan downloads popular libraries and frameworks from online resources such as <b>CDNJS</b> and <b>unpkg</b>. Dependencies acquired with LibMan are fetched and placed in the desired location within the Blazor project.</p><p>Let’s see how LibMan can be used to pull in the Bootstrap framework’s Sass (.scss) source as a dependency. This will give you an idea of how LibMan is used to manage dependencies at a granular level. To add Bootstrap from Visual Studio, right click on the Blazor project, then choose <b>Add &gt; Client-Side Library</b> from the sub-menu, as shown in <b>Figure 9</b>.</p><figure><img src="https://www.codemag.com/Article/Image/1911052/image9.tif"><figcaption>      <b>Figure 9</b>: The LibMan dialog can be opened through the project context menu.</figcaption></figure><p>The Add Client-Side Library dialog appears so you can configure how LibMan fetches your dependency. From this window, shown in <b>Figure 10</b>, you’ll choose the package source <b>unpkg</b>. The unpkg source is useful in this scenario because it contains the dependency’s complete repository, including source code. To fetch Bootstrap from unpkg, specify the library name and version; <b><a href="mailto://bootstrap@latest">bootstrap@latest</a></b> gives the most current version of the dependency. Next, choose specific files from the library; in this case, you’ll be targeting the <b>scss</b> folder and its contents. Because you’re choosing only the scss folder, you’ll fetch just the files important to your needs, thus avoiding arbitrary files being added to the project. Finally, give a target location for LibMan to deposit your files into; in this case, you’ll use the <b>Themes/Bootstrap</b> folder. Clicking install initializes LibMan by generating a <b>libman.json</b> file and fetching the dependencies.</p><figure><img src="https://www.codemag.com/Article/Image/1911052/image10.tif"><figcaption>      <b>Figure 10</b>: The LibMan dialog configures and initializes a libman.json file describing which front-end dependences should be fetched.</figcaption></figure><p>Even though you used LibMan in the context of Visual Studio for the example, LibMan can execute from the CLI as well. </p><pre><code><span>dotnet</span> <span>tool</span> <span>install</span> <span>-g</span>
<span>Microsoft</span><span>.Web</span><span>.LibraryManager</span><span>.Cli</span>

</code></pre><p>With the Bootstrap scss dependency installed, you need a way to compile the source code into a CSS file. Once again, you’ll use existing .NET infrastructure instead of JavaScript tooling. For scss compilation, you’ll make use of <b>WebCompiler</b>, a simple tool for compiling Web resources like scss, TypeScript, and more. To add WebCompiler to your project, you’ll add the NuGet package <b>BuildWebCompiler,</b> as shown in <b>Figure 11</b>.</p><figure><img src="https://www.codemag.com/Article/Image/1911052/image11.tiff"><figcaption>      <b>Figure 11</b>: The BuildWebCompiler NuGet package used to compile Web resources, as shown in the NuGet explorer window.</figcaption></figure><p>In addition to the NuGet package, an optional Visual Studio plug-in is available that adds context menus for Web resources. The plug-in offers shortcuts for compiling assets and installing the BuildWebCompiler package.</p><p>With the tooling in place, you can define a <b>compilerconfig.json</b> file and specify the <b>outputFile</b>, and <b>inputFile</b> for the Bootstrap library. Configure WebCompiler to find the bootstrap.scss source file and output the compiled asset to the <b>wwwroot<i></i></b>folder in your application, where it can be served to the client. </p><pre><code>[
  {
    <span>"outputFile"</span>:
      <span>"wwwroot/css/bootstrap/bootstrap.css"</span>,
    <span>"inputFile"</span>:
      <span>"Themes/Bootstrap/scss/bootstrap.scss"</span>
  }
]

</code></pre><p>When the config file is saved, the compilation initializes and outputs your file. This process is also triggered when the project is built from either Visual Studio or the CLI.</p><p>Tools like LibMan and WebCompiler get straight to the point and operate with very little configuration or overhead. Although Blazor is the new kid on the block, Web development isn’t new to the .NET ecosystem. Existing tools like these are finding new uses with Blazor and a new ecosystem is finding its place.</p><h2>Blazor Ecosystem</h2><p>Blazor has brought forth a new generation of libraries, packages, and tools to solve common problems. Entire UI frameworks are being developed from the ground up that are built on the Blazor component model. New Blazor-focused frameworks around state management and validation are springing up. And tools for speeding up Blazor development are finding their way to the marketplace.</p><h3>Ready-Made Components</h3><p>In the heyday of ASP.NET WebForms, the Telerik UI components were a staple of Web development. The ability to add rich data grids to an application with very little configuration has shortened the development process. Today, we’re seeing that ease-of-use come back to the Blazor ecosystem with Telerik UI for Blazor, a set of UI components built from the ground up on top of the Razor Component architecture. </p><p>Let’s quickly build the data grid shown in <b>Figure 12</b> including the grouping, sorting, filtering, and paging options. In <b>Listing 4</b>, you start by injecting the <b>WeatherForecastService</b> used to retrieve the data. In the @code block, you’ll create a field named <b>forecasts</b> to hold the data. For the Telerik Grid, this field must implement the <b>IEnumerable</b> interface; an array of <b>WeatherForecast</b> is perfectly suitable. During the component’s <b>OnInitializedAsync</b> method, you fill the forecast array by awaiting <b>GetForecastAsync</b> on the service class. Next, wire up the TelerikGrid component by setting the Data parameter to the forecasts array. The Sortable, Pageable, and Groupable settings are enabled with a simple flag. Filtering is enabled by setting the desired FilterMode, which is filled by IntelliSense. Finally, attach the grid columns by adding one column for each corresponding property on the WeatherForecast object. Grid column fields can be specified with a string value, or by using the C# <b>nameof</b> operator. </p><figure><img src="https://www.codemag.com/Article/Image/1911052/image12.tiff"><figcaption>      <b>Figure 12</b>: The Telerik UI for Blazor data grid uses very little code to display data while allowing sorting, filtering, and grouping.</figcaption></figure><p>These few steps are all that’s required to complete the task. When you run the page, the data grid lights up with data and the features you enabled.</p><h3>Validation</h3><p>Blazor ships with data annotations validators built in. This is a popular method of validating forms throughout many .NET project types. There’s also a popular alternative to data annotations called <b>FluentValidation</b> that takes a more programmatic approach to declaring validation rules. The FluentValidation library has been part of the .NET ecosystem for years and has been extended into many .NET project types, including Blazor. </p><p>The <b>Blazor-Validation </b>NuGet package is a validation-agnostic library for validating forms. With Blazor-Validation, you configure the application to use the validation framework of choice by adding providers to the service container. </p><pre><code>services.AddFormValidation(<span><span>config</span> =&gt;</span>
  config
    .AddDataAnnotationsValidation()
    .AddFluentValidation()
);

</code></pre><p>Once configured, the standard Blazor components <b>ValidationSummary</b> and <b>ValidationMessage</b> now work with the selected validation options.</p><h3>State Management</h3><p>Because Blazor can run either client-side or server-side state management, it differs from a traditional ASP.NET application. In ASP.NET, you made use of the built-in Application or Session state objects. Blazor doesn’t have such a built-in technique for handling state. Blazor leaves the choice of state management up to developers. </p><p>Implementing state in a Blazor application can be as simple as providing a class object that contains basic properties to manage values. This state class object is then registered through dependency injection and resolved as a service in the component level. This method of state management is called the <b>App State pattern</b>.</p><pre><code><span>public</span> <span>class</span> <span>CounterState</span>
{
    <span>public</span> <span>int</span> CurrentCount { <span>get</span>; <span>set</span>; }
}

services.AddScoped&lt;CounterState&gt;();

</code></pre><p>For more complex scenarios, the community has several solutions based on common development patterns like <b>mediator</b> (<b>Blazor-State</b>) and <b>flux</b> (<b>Blazor-Fluxor</b>). These two frameworks approach state management with the idea of a single source of truth. This is a necessity in larger applications when it’s possible to have high-traffic writes to a state object. Frameworks like these are beneficial to providing a gradual progression in application complexity. Blazor applications can have a low barrier to entry while maintaining the ability to scale when it’s needed.</p><h2>The Future of Blazor</h2><p>September marks the first officially supported release for the Blazor Server model with Blazor WebAssembly support, which is expected to ship in the first half of 2020. The Web is a ubiquitous platform that has found its way into desktop and mobile applications through progressive Web applications (<b>PWAs</b>) and hybrid app models like Electron, Cordova, and others. The same technologies that bring the Web everywhere will be combined with the Blazor framework, further expanding the reach of Blazor-powered .NET applications. Throughout 2020, you can expect to see the introduction of <b>PWA support for Blazor WebAssembly</b> and <b>Blazor Electron</b> support as part of the .NET 5 effort. Experimental Blazor Electron bits can already be seen in the AspLabs GitHub repo (<a href="https://github.com/aspnet/AspLabs/tree/master/src/ComponentsElectron" target="_blank">https://github.com/aspnet/AspLabs/tree/master/src/ComponentsElectron</a>). </p><p>In the current state, the <b>Blazor app </b>dialog in Visual Studio seems a bit barren, but hopefully more templates will soon populate the list. In <b>Figure 13</b>, you can see where more templates could exist within the Blazor app dialog. </p><figure><img src="https://www.codemag.com/Article/Image/1911052/image13.tif"><figcaption>      <b>Figure 13</b>: In the future, you’ll likely see more templates in the Blazor app dialog.</figcaption></figure><p>At NDC Oslo 2019, Steve Sanderson of Microsoft’s ASP.NET team shared a tantalizing demo of how Blazor’s HTML renderer could be replaced to enable rendering native controls. This enables native app development using the Blazor component model in a fashion very similar to how React Native functions today but using .NET instead of JavaScript. Nothing has been shared yet as a roadmap for a "Blazor Native," but the possibilities are very exciting!</p><p><b>Table 1</b> shows what a high-level roadmap of what the Blazor landscape might possibly look like throughout 2020 and beyond.</p><p>As powerful as it is convenient, Blazor makes a great choice for new applications. By combining .NET technologies that you’re already using with an intuitive component model, Blazor has created a new era of productivity. Focusing on the .NET stack and tools shortens the learning curve and makes Blazor approachable. When using Blazor on the server, the application architecture can be greatly reduced yet remain extensible when more complexity is needed. As Blazor grows, the community and ecosystem will continue to grow with solutions for common problems. Blazor’s roadmap shows commitment and promise that Blazor is here to stay by delivering innovative technologies to help you build modern applications.</p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>