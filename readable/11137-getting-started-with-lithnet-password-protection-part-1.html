<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Getting started with Lithnet Password Protection - Part 1 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>Getting started with Lithnet Password Protection - Part 1</h1><div><div class="post-body entry-content float-container" id="post-body-5574143854296342881" xmlns="http://www.w3.org/1999/xhtml"><p class="readability-styled" style="display: inline;" xmlns="">
In this guide, we will look at how to set up Lithnet Password Protection for Active Directory (LPP) from scratch. We'll configure a basic password policy, and integrate the haveibeenpwned.com pwned password data set to prevent users from changing their password to one that is known to be compromised.</p><p>This guide will focus on testing in an Active Directory domain, by installing the agent on a domain controller. However, for testing purposes, you can install the agent on a member server or workstation. The only difference is you'll need to test using local accounts, rather than domain accounts.<br></p><h2>
Prerequisites</h2><ol><li>You'll need to be using an x64 version of windows. LPP is a x64-only application.</li><li>You must have local administrator rights on the server you want to install the agent on. For domain controllers, this means being a member of the Domain Admins group.</li><li>Download the latest version of the NTLM passwords from the&nbsp;<a href="https://haveibeenpwned.com/Passwords" target="_blank">haveibeenpwned.com pwned password list</a>&nbsp;(scroll to the end). Make sure you get the <b>"NTLM Ordered by hash"</b> version. Use the torrent link if you are able to so, as this helps minimize bandwidth and costs. Uncompress the file, and place it on your server to import later in the process.</li><li>Download the <a href="https://github.com/lithnet/ad-password-protection/releases" target="_blank">latest version of LPP</a> from the github site.</li><li>Create a user for testing. Once again, if you are installing this on a domain controller, it will need to be a domain user, otherwise it must be a local user.</li></ol><h2>
Selecting your store strategy</h2><p class="readability-styled" style="display: inline;" xmlns="">
The LPP 'store' is essential a flat-file database of password hashes, efficiently stored in a binary format to maximize speed, while conserving space. Each domain controller must have read access to the store in order to compare incoming password changes against the compromised password lists. There are several different ways you can achieve this. Each has its own pros and cons, and you'll need to decide what's best for your environment.</p><br><h4>
Option 1: Each server accesses a single copy of the store via a file share</h4><p class="readability-styled" style="display: inline;" xmlns="">
In this configuration, each server with LPP installed points to a network share that contains the single copy of the store. The benefits are that there is only one copy of the store to be managed, but the downside is that if the file server goes down, the password filter will be unable to perform compromised password checking. This might also be an issue for distributed environments, where bandwidth and latency between domain controllers and the file server is an issue. Remember, the agent must be installed on every writable domain controller in your environment, so they will all need read access to this store. If this is your preferred strategy, create your share, and grant the server's computer accounts read access to the store before you proceed. Users who be managing the store will need read and write access to this folder.</p><br><h4>
Option 2: Each server has its own copy of the store</h4><p class="readability-styled" style="display: inline;" xmlns="">
In this configuration, each server with LPP installed has a local copy of the store. This means the store will always be available, and there will be no bandwidth or latency issues. The downside is that if you want to update the store with new passwords, you need to update it on each server manually. Updates to the store will be infrequent, so this may not be an issue. As the store is flat-file based, it is easy to copy around with a tool like robocopy and xcopy.</p><br><h4>
Option 3: Each server has its own copy of the store, but it is replicated with DFS-R</h4><p class="readability-styled" style="display: inline;" xmlns="">
This is the configuration we recommend. Each server with LPP installed has its own copy of the store, but DFS-R is used to replicate and keep changes in sync. This means that new passwords can be added to a single server, and DFS-R will replicate those changes to the other servers. Do NOT place the store in the SYSVOL folder. Create a dedicated replication group for the LPP store.</p><br><h2>
Part 1: Install the software</h2><p>
1. Once you've completed the prerequisites, and decided on your store strategy, you can begin the installation process. On your chosen server, install the LPP agent, ensuring that you select all features for installation.</p><p class="readability-styled" style="display: inline;" xmlns="">
2. Select a path to hold the store of compromised passwords and banned words. If you are using the 'file server' store strategy outlined above, this will be the UNC path to your share. Otherwise, pick a local path and ensure that the drive that hosts the store has enough space on it. You will need at least 6GB of space to hold the HIBP pwned password list.</p><p class="readability-styled" style="display: inline;" xmlns="">
3. You'll need to reboot the server for the password filter to come online. Note that the password filter will remain inactive even after a reboot until we configure the group policy to enable it.</p><p>4. If you have more than one domain controller, repeat the process on the other domain controllers.<br></p><h2>
Part 2: Build the store</h2><p class="readability-styled" style="display: inline;" xmlns="">
Once you've downloaded the </p><b>NTLM</b>&nbsp;<b>ordered by hash</b><p class="readability-styled" style="display: inline;" xmlns=""> version of the pwned password list, you can start to populate the store. If you're not sure if you downloaded the </p><b>ordered by hash </b><p class="readability-styled" style="display: inline;" xmlns="">version, this is the time to double check. While the 'NTLM ordered by prevalence' version will work, it is </p><b>extremely </b><p class="readability-styled" style="display: inline;" xmlns="">slow to process. The SHA1 hash lists will not work at all.</p><p>If you can, add the store path as an exclusion to your anti-virus software, at least for the process of building the store. It will make the process significantly faster.</p><p>Open a PowerShell window and run the following commands, replacing the store path, and path to the pwned password text file as appropriate.</p><p>This will read the text file and convert the hashes into a much smaller binary format. So while the plain-text hash list is about 20GB in size, the final store size should be about 6GB.</p><p>This process usually takes about 40 minutes, so grab yourself a coffee, and perhaps have read of the <a href="https://github.com/lithnet/ad-password-protection/wiki/PowerShell-reference" target="_blank">PowerShell command reference</a> to familiarize yourself with the other cmdlets available.</p><p>Once the import is complete, you can delete the HIBP text file if you need to save space.</p><p>There is another cmdlet, <a href="https://github.com/lithnet/ad-password-protection/wiki/Import%E2%80%90CompromisedPasswords" target="_blank">Import-CompromisedPasswords</a>, that you can use to import any plain-text password lists you may want to add to your compromised password store.</p><p>If you are using the standalone file store strategy, you should now copy the store folder to your other domain controllers. If you are replicating with DFS-R, create your replication group and wait for the replicas to sync up before proceeding.<br></p><h2>
Part 3: Configure the Group Policy</h2><p class="readability-styled" style="display: inline;" xmlns="">
We can now configure the group policy to enable the agent and check passwords against the store. Open the Group Policy Management MMC, create a new GPO, and link it to an OU that your server is in. There is no harm at linking this at a higher level in the OU hierarchy if you prefer, as the policy only takes effect on machines that have LPP installed.</p><p><i>Note: If you have a specific machine where you perform group policy maintenance from, you'll need to install&nbsp;LPP&nbsp;on there, but select only the "Group Policy Templates (ADMX)" option in the installer. This will only copy the ADMX files to that server to allow you to edit the LPP policy settings. The&nbsp;<a href="https://github.com/lithnet/ad-password-protection/wiki/Configure-group-policy" target="_blank">group policy guide</a>&nbsp;on the wiki has information about setting up a central policy store as an alternative to this.</i></p><p class="readability-styled" style="display: inline;" xmlns="">
Give the policy an appropriate name when prompted, then right-click the policy, and select </p><i>Edit</i><p class="readability-styled" style="display: inline;" xmlns="">. If you are not ready to make the policy live at this stage, right-click the policy, and untick </p><i>Link Enabled</i><p class="readability-styled" style="display: inline;" xmlns="">.</p><p>Navigate to <span>Computer Configuration\Administrative Templates\Lithnet\Password Protection for Active Directory\Default Policy</span></p><p class="readability-styled" style="display: inline;" xmlns="">
Here you can set the policies you want to enforce. Double click </p><i>Reject passwords found in the compromised password store</i><p class="readability-styled" style="display: inline;" xmlns="">, enable the policy, and check both boxes to enable password set and password change operations.</p><p class="readability-styled" style="display: inline;" xmlns="">
Run gpupdate on the server with LPP installed, to ensure it gets these settings.</p><br><h2>
Part 4: Test the policy</h2><p class="readability-styled" style="display: inline;" xmlns="">
The policy is now active, so we can take our test user, and attempt to reset their password to one that we know is in the compromised password store. Let's use </p><span>P@ssw0rd</span><p class="readability-styled" style="display: inline;" xmlns="">, because I know that it is in there.</p><p class="readability-styled" style="display: inline;" xmlns="">
And we should see that the password change was rejected.</p><p class="readability-styled" style="display: inline;" xmlns="">
Unfortunately, the Windows error messages do not tell the user anything other than the standard 'you can't use that password'. You'll need to find a way to communicate to your users that you are checking against known compromised passwords, and if their password change is rejected, it could be because they are using a password that has been compromised.</p><p>We can use Event Viewer to validate that it was LPP that rejected the request. For every attempt, there will be two event entries. The first will be an event to say that a password change or set request was received by the filter.</p><p class="readability-styled" style="display: inline;" xmlns="">
If you don't see this event entry, there are a couple of possible explanations;</p><br><ul><li>You haven't rebooted the server since installing LPP</li><li>The password change was processed by another domain controller. In an Active Directory environment, any writable domain controller can process a password change, and only the one that initially receives the request validate that it meets the requirements. This is why LPP must be installed on all writable domain controllers.&nbsp;</li></ul><div><p class="readability-styled" style="display: inline;" xmlns="">
After that entry, there will be a warning event giving the reason the password was rejected. If you want to build automated reporting based off these events, there is a&nbsp;</p><a href="https://github.com/lithnet/ad-password-protection/wiki/Event-logging-and-reporting" target="_blank">full list of event IDs</a><p class="readability-styled" style="display: inline;" xmlns=""> and descriptions available.</p></div><p class="readability-styled" style="display: inline;" xmlns="">
You can also test password quality without changing them in Active Directory by using the PowerShell module's </p><a href="https://github.com/lithnet/ad-password-protection/wiki/Get%E2%80%90PasswordFilterResult" target="_blank">Get-PasswordFilterResult</a><p class="readability-styled" style="display: inline;" xmlns=""> cmdlet.</p><p class="readability-styled" style="display: inline;" xmlns="">
The cmdlet will return a code that indicates if the password change was approved. Note that this cmdlet only tests the password against the LPP filter. A real password change may still be rejected by other password filters, or Active Directory's out-of-box password policies.</p><br><span><br></span><span>If you just want to test if a compromised password exists in the store, use the <a href="https://github.com/lithnet/ad-password-protection/wiki/Test%E2%80%90IsCompromisedPassword">Test-IsCompromisedPassword</a> cmdlet. Get-PasswordFilterResult will process the password change according to all group policy settings, whereas Test-IsCompromisedPassword justs checks to see if that password is in the store.</span><br><h2>
Part 5: Audit existing users</h2><span>Now that we have stopped users from changing their password to one that has been compromised, what do we do about all the existings users who may already be using compromised passwords? Using the <a href="https://github.com/lithnet/ad-password-protection/wiki/Test%E2%80%90IsADUserPasswordCompromised">Test-IsADUserPasswordCompromised</a>&nbsp;PowerShell cmdlet, you can compare users <i>current</i> password hashes against the compromised password store.&nbsp;</span><p class="readability-styled" style="display: inline;" xmlns="">Read the </p><a href="https://github.com/lithnet/ad-password-protection/wiki/Audit-existing-passwords">full guide on the wiki</a><p class="readability-styled" style="display: inline;" xmlns=""> for the prequisites and example scripts you can use to audit these users.</p><br><h2>
Next Steps</h2><span><a href="https://blog.lithnet.io/2019/01/lppad-2.html">Part 2 of this guide</a>&nbsp;will show you how you can block common and context-based words from being used in passwords.</span></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>