<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Verzekeraar Allianz informeert klanten over datalek -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>Verzekeraar Allianz informeert klanten over datalek</h1><div><div class="posting_content" xmlns="http://www.w3.org/1999/xhtml"><p class="markup_quote"><i>Door Daemon:</i><br>Waarom zou dat zo moeten zijn? Je moet misschien iets meer moeite doen om de data te ontsleutelen alvorens terug te zetten maar daar zijn best goede oplossingen voor te verzinnen.<br></p><p class="readability-styled" style="display: inline;" xmlns="">..  Als je de ervaring hebt dat het regelen van een backup voor DR zo veel moeite kost om iets werkend te krijgen kun je er iets als versleuteling niet bij hebben. Bedenk: ransomware gebruikt het gemis aan een sleutel om de boel werkend te krijgen als afpersmiddel. Jouw voorstel komt neer op het zelf neerzetten van zo'n malware aanval. </p><p class="markup_quote"><br>Dat is een backup van je softwareinfrastructuur en daarmee zou je sneller terug on-line kunnen komen in geval van calamiteiten. Idealiter zitten daarin geen business data. </p><p class="readability-styled" style="display: inline;" xmlns="">Nou nee, een sytemdump bevalt datablokken die via de code verwerkt wordt, ,et registers en traces en wat er nog memory staat kan je op zoek naar sporen van de dader(s). Daar zit echt gewone data tussen. Code en data loopt her en der door elkaar omdat de machine een platte memory layout heeft zonder fysieke segmentering. De bufferoverflow als bekende techniek / probleemveroorzaker.    </p><p>Je link geeft aan dat het om de backup gaat, opgeslagen in een kluis (brand)  en specifiek het pechhulp systeem betreft met het grotere aantal. Het eerdere aantal lijkt op een ander deelsysteem te duiden, direct bij hun afgesloten polissen.<br>Een hot system standby hot failover werkt met synchrone lopende dataopslag. Alleen de laatste niet afgeronde transacties kunnen dan verloren gaan.   Zo'n systeem geeft geen bescherming tegen onbeschikbaar raken van de infra/software. Daarvoor moet je naar off-site off-line backup. Daar is hier duidelijk sprake van.</p><p>Wat mij intrigeert: het is zo te zien een zelfstanding opererend onderdeel, Weinig te vinden over ICT dienstverleners.<br>Met een midrange zoals as/400 (gangbaar bij oudere kleiner fiancials) lees je dat echt niet zomaar elders in als je al weet wat er mee zou moeten. ER worden geen details genoemd. Hebben ze het uit voorzorg gemeld ook als er zeer  waarschijnlijk niets aan de hand omdat het AP hier te onbetrouwbaar is.   Ja er zijn backuptapes buiten beeld geraakt. maar wat is het reeele onderbouwde risico (apparatuur analyses etc)..</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>