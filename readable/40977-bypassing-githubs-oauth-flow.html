<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Bypassing GitHub&#x2019;s OAuth flow -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Bypassing GitHub&#x2019;s OAuth flow</h1>
    <div class="post-content e-content"> <p>For the past few years, security research has been something I&#x2019;ve done in my spare time. I know there are people that make a living off of bug bounty programs, but I&#x2019;ve personally just spent a few hours here and there whenever I feel like it.</p> <p>That said, I&#x2019;ve always wanted to figure out whether I&#x2019;d be able to make a living on bug bounties if I chose to work on them full time. So I tried doing that for a couple months this summer, spending a few hours a day looking for security bugs in GitHub.</p> <p>My main workflow was to download a <a href="https://enterprise.github.com/releases/">trial version of GitHub Enterprise</a>, deobfuscate it using a modified version of <a href="https://gist.github.com/iscgar/e8ea7560c9582e4615fcc439177e22b7">this script</a>, and then just stare at GitHub&#x2019;s Rails code for awhile to try to spot anything weird or exploitable. Overall, GitHub&#x2019;s code seems very well-architected from a security perspective. I would occasionally find a bug caused by an unhandled case in some application logic, only to realize that the bug didn&#x2019;t create a security issue because (e.g.) the code was running a query with reduced privileges anyway. Almost every app has bugs, but one big challenge of security engineering is to make bugs unexploitable without knowing where they are, and GitHub seems to do a very good job of that.</p> <p>Even so, I managed to find a few interesting issues over the summer, including a complete OAuth authorization bypass.</p> <h2 id="githubs-oauth-flow">GitHub&#x2019;s OAuth Flow</h2> <p>At one point in June, I was looking at the code that implements GitHub&#x2019;s <a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/">OAuth flow</a>. Briefly, the OAuth flow is supposed to work like this:</p> <ol> <li>Some third-party application (&#x201C;Foo App&#x201D;) wants to access a user&#x2019;s GitHub data. It sends the user to <code class="language-plaintext highlighter-rouge">https://github.com/login/oauth/authorize</code> with a bunch of information in the querystring.</li> <li> <p>GitHub displays an authorization page to the user, like the one below.</p> <p><img src="/assets/img/oauth-flow-prompt.png"></p> </li> <li>If the user chooses to grant access to the app, they click the &#x201C;Authorize&#x201D; button on the page and are redirected to Foo App with an authorization code in the querystring. This code can then be used to access the requested data. (The user can also decline to give their data to the app.)</li>
</ol> <p>When reviewing this, I took a look at how the &#x201C;Authorize&#x201D; button is implemented. It turns out that the button is actually a self-contained HTML form that sends a POST request with some hidden form fields, including a CSRF token. When that POST request is sent (and the CSRF token is validated), the user is considered to have granted permissions to the app. Seems reasonable so far.</p> <p>Interestingly, the endpoint URL for the &#x201C;Authorize&#x201D; button is <code class="language-plaintext highlighter-rouge">/login/oauth/authorize</code>, which happens to be the same as the URL for the authorization page itself. GitHub figures out which response to send based on the HTTP request method (<code class="language-plaintext highlighter-rouge">GET</code> requests return the HTML authorization page, and <code class="language-plaintext highlighter-rouge">POST</code> requests grant permissions to the app).</p> <p>This behavior switch actually happens within application code. The router forwards both <code class="language-plaintext highlighter-rouge">GET</code> and <code class="language-plaintext highlighter-rouge">POST</code> requests to the same controller:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In the router</span> <span class="n">match</span> <span class="s2">&quot;/login/oauth/authorize&quot;</span><span class="p">,</span> <span class="c1"># For every request with this path...</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="s2">&quot;[the controller]&quot;</span><span class="p">,</span> <span class="c1"># ...send it to the controller...</span> <span class="ss">:via</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:get</span><span class="p">,</span> <span class="ss">:post</span><span class="p">]</span> <span class="c1"># ... as long as it&apos;s a GET or a POST request.</span>
</code></pre></div></div> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In the controller</span> <span class="k">if</span> <span class="n">request</span><span class="p">.</span><span class="nf">get?</span> <span class="c1"># serve authorization page HTML</span>
<span class="k">else</span> <span class="c1"># grant permissions to app</span>
<span class="k">end</span>
</code></pre></div></div> <p>So the router accepts either a <code class="language-plaintext highlighter-rouge">GET</code> or a <code class="language-plaintext highlighter-rouge">POST</code> request, and the controller checks which type of request was sent and behaves accordingly. At first glance, this doesn&#x2019;t seem like a problem &#x2013; and it wouldn&#x2019;t be, except that the router isn&#x2019;t telling the truth.</p> <p>Let&#x2019;s talk about HTTP methods.</p> <p>The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD">HTTP <code class="language-plaintext highlighter-rouge">HEAD</code> method</a> has been around since HTTP was originally created, but it doesn&#x2019;t get a lot of use. When a server receives a HEAD request, the expected semantics are, &#x201C;pretend this is a GET request, but only send back response headers without a response body&#x201D;. This has a few niche uses. For example, a client can send a <code class="language-plaintext highlighter-rouge">HEAD</code> request to check the size of a large file (via the <code class="language-plaintext highlighter-rouge">Content-Length</code> response header) before deciding whether it wants to start downloading the file.</p> <p>Naturally, people writing web apps usually don&#x2019;t want to take the time to implement behavior for HEAD requests. Getting a product that works is understandably considered more important than compliance with niche parts of the HTTP spec. But in general, it&#x2019;s nice if HEAD requests can be processed correctly, provided that app developers don&#x2019;t have to deal with them manually. So Rails (along with some other web frameworks) implements a clever hack: it <a href="https://github.com/rails/rails/blob/bc5d9567be44e6241a049c01605ad6cfefe42e10/actionpack/lib/action_dispatch/journey/router.rb#L133-L147">tries to route <code class="language-plaintext highlighter-rouge">HEAD</code> requests to the same place as it would route <code class="language-plaintext highlighter-rouge">GET</code> requests</a>. Then it runs the controller code, and just omits the response body.</p> <p>So that&#x2019;s nice, but it&#x2019;s a leaky abstraction. If a controller calls <code class="language-plaintext highlighter-rouge">request.get?</code> on a request like this, it will return false, because it&#x2019;s still a <code class="language-plaintext highlighter-rouge">HEAD</code> request, not a <code class="language-plaintext highlighter-rouge">GET</code> request.</p> <p>What happens if we send an authenticated <code class="language-plaintext highlighter-rouge">HEAD</code> request to <code class="language-plaintext highlighter-rouge">https://github.com/login/oauth/authorize</code>? We&#x2019;ve concluded that the router will treat it like a <code class="language-plaintext highlighter-rouge">GET</code> request, so it will get sent to the controller. But once it&#x2019;s there, the controller will realize that it&#x2019;s not a <code class="language-plaintext highlighter-rouge">GET</code> request, and so the request will be handled by the controller as if it was an authenticated <code class="language-plaintext highlighter-rouge">POST</code> request. As a result, GitHub will find the OAuth app specified in the request, and grant it access to the authenticated user&#x2019;s data.</p> <p>Why is this useful? Well, GitHub&#x2019;s CSRF protection requires all authenticated <code class="language-plaintext highlighter-rouge">POST</code> requests to include a CSRF token. But <code class="language-plaintext highlighter-rouge">HEAD</code> requests don&#x2019;t need a CSRF token, since they&#x2019;re not supposed to have side-effects. So we can send a cross-site authenticated <code class="language-plaintext highlighter-rouge">HEAD</code> request that will give arbitrary OAuth permissions, without showing the user a confirmation page at all.</p> <p>As a result, if a user visited an attacker&#x2019;s website, the attacker could arbitrarily read or modify private data in the user&#x2019;s GitHub account. Here&#x2019;s a <a href="https://not-an-aardvark.github.io/oauth-bypass-poc-fbdf56605489c74b2951/">proof-of-concept</a> (which no longer works because the issue has been patched).</p> <p>I reported this issue to GitHub&#x2019;s bug bounty program, and they shipped a fix to production in about three hours. I also got a $25000 bounty (!), which at the time was the highest bounty ever from GitHub&#x2019;s program.</p> <h2 id="timeline">Timeline</h2> <ul> <li><strong>2019-06-19 23:28:56 UTC</strong> Issue reported to GitHub on HackerOne</li> <li><strong>2019-06-19 23:36:50 UTC</strong> Issue confirmed by GitHub security team</li> <li><strong>2019-06-20 02:44:29 UTC</strong> Issue patched on github.com, GitHub replies on HackerOne to double-check that the patch fully resolves the issue</li> <li><strong>2019-06-26 16:19:20 UTC</strong> GitHub Enterprise 2.17.3, 2.16.12, 2.15.17, and 2.14.24 released with the patch (see <a href="https://enterprise.github.com/releases/2.17.3/notes">GitHub&#x2019;s announcement</a>).</li> <li><strong>2019-06-26 22:30:45 UTC</strong> GitHub awards $25000 bounty</li>
</ul> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>