<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Introduction to authentication for Single Page Apps on ASP.NET Core -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Introduction to authentication for Single Page Apps on ASP.NET Core</h1><div><div id="main" class="content "><p>ASP.NET Core 3.0 or later offers authentication in Single Page Apps (SPAs) using the support for API authorization. ASP.NET Core Identity for authenticating and storing users is combined with <a href="https://identityserver.io/" data-linktype="external">IdentityServer</a> for implementing Open ID Connect.</p><p>An authentication parameter was added to the <strong>Angular</strong> and <strong>React</strong> project templates that is similar to the authentication parameter in the <strong>Web Application (Model-View-Controller)</strong> (MVC) and <strong>Web Application</strong> (Razor Pages) project templates. The allowed parameter values are <strong>None</strong> and <strong>Individual</strong>. The <strong>React.js and Redux</strong> project template doesn't support the authentication parameter at this time.</p><h2 id="create-an-app-with-api-authorization-support">Create an app with API authorization support</h2><p>User authentication and authorization can be used with both Angular and React SPAs. Open a command shell, and run the following command:</p><p><strong>Angular</strong>:</p><pre><code class="lang-dotnetcli">dotnet new angular -o &lt;output_directory_name&gt; -au Individual
</code></pre><p><strong>React</strong>:</p><pre><code class="lang-dotnetcli">dotnet new react -o &lt;output_directory_name&gt; -au Individual
</code></pre><p>The preceding command creates an ASP.NET Core app with a <em>ClientApp</em> directory containing the SPA.</p><h2 id="general-description-of-the-aspnet-core-components-of-the-app">General description of the ASP.NET Core components of the app</h2><p>The following sections describe additions to the project when authentication support is included:</p><h3 id="startup-class">Startup class</h3><p>The <code>Startup</code> class has the following additions:</p><ul><li><p>Inside the <code>Startup.ConfigureServices</code> method:</p><ul><li><p>Identity with the default UI:</p><pre><code class="lang-csharp">services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
    options.UseSqlite(Configuration.GetConnectionString("DefaultConnection")));

services.AddDefaultIdentity&lt;ApplicationUser&gt;()
    .AddDefaultUI(UIFramework.Bootstrap4)
    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();
</code></pre></li><li><p>IdentityServer with an additional <code>AddApiAuthorization</code> helper method that sets up some default ASP.NET Core conventions on top of IdentityServer:</p><pre><code class="lang-csharp">services.AddIdentityServer()
    .AddApiAuthorization&lt;ApplicationUser, ApplicationDbContext&gt;();
</code></pre></li><li><p>Authentication with an additional <code>AddIdentityServerJwt</code> helper method that configures the app to validate JWT tokens produced by IdentityServer:</p><pre><code class="lang-csharp">services.AddAuthentication()
    .AddIdentityServerJwt();
</code></pre></li></ul></li><li><p>Inside the <code>Startup.Configure</code> method:</p><ul><li><p>The authentication middleware that is responsible for validating the request credentials and setting the user on the request context:</p><pre><code class="lang-csharp">app.UseAuthentication();
</code></pre></li><li><p>The IdentityServer middleware that exposes the Open ID Connect endpoints:</p><pre><code class="lang-csharp">app.UseIdentityServer();
</code></pre></li></ul></li></ul><h3 id="addapiauthorization">AddApiAuthorization</h3><p>This helper method configures IdentityServer to use our supported configuration. IdentityServer is a powerful and extensible framework for handling app security concerns. At the same time, that exposes unnecessary complexity for the most common scenarios. Consequently, a set of conventions and configuration options is provided to you that are considered a good starting point. Once your authentication needs change, the full power of IdentityServer is still available to customize authentication to suit your needs.</p><h3 id="addidentityserverjwt">AddIdentityServerJwt</h3><p>This helper method configures a policy scheme for the app as the default authentication handler. The policy is configured to let Identity handle all requests routed to any subpath in the Identity URL space "/Identity". The <code>JwtBearerHandler</code> handles all other requests. Additionally, this method registers an <code>&lt;&lt;ApplicationName&gt;&gt;API</code> API resource with IdentityServer with a default scope of <code>&lt;&lt;ApplicationName&gt;&gt;API</code> and configures the JWT Bearer token middleware to validate tokens issued by IdentityServer for the app.</p><h3 id="weatherforecastcontroller">WeatherForecastController</h3><p>In the <em>Controllers\WeatherForecastController.cs</em> file, notice the <code>[Authorize]</code> attribute applied to the class that indicates that the user needs to be authorized based on the default policy to access the resource. The default authorization policy happens to be configured to use the default authentication scheme, which is set up by <code>AddIdentityServerJwt</code> to the policy scheme that was mentioned above, making the <code>JwtBearerHandler</code> configured by such helper method the default handler for requests to the app.</p><h3 id="applicationdbcontext">ApplicationDbContext</h3><p>In the <em>Data\ApplicationDbContext.cs</em> file, notice the same <code>DbContext</code> is used in Identity with the exception that it extends <code>ApiAuthorizationDbContext</code> (a more derived class from <code>IdentityDbContext</code>) to include the schema for IdentityServer.</p><p>To gain full control of the database schema, inherit from one of the available Identity <code>DbContext</code> classes and configure the context to include the Identity schema by calling <code>builder.ConfigurePersistedGrantContext(_operationalStoreOptions.Value)</code> on the <code>OnModelCreating</code> method.</p><h3 id="oidcconfigurationcontroller">OidcConfigurationController</h3><p>In the <em>Controllers\OidcConfigurationController.cs</em> file, notice the endpoint that's provisioned to serve the OIDC parameters that the client needs to use.</p><h3 id="appsettingsjson">appsettings.json</h3><p>In the <em>appsettings.json</em> file of the project root, there's a new <code>IdentityServer</code> section that describes the list of configured clients. In the following example, there's a single client. The client name corresponds to the app name and is mapped by convention to the OAuth <code>ClientId</code> parameter. The profile indicates the app type being configured. It's used internally to drive conventions that simplify the configuration process for the server. There are several profiles available, as explained in the <a href="#application-profiles" data-linktype="self-bookmark">Application profiles</a> section.</p><pre><code class="lang-json">"IdentityServer": {
  "Clients": {
    "angularindividualpreview3final": {
      "Profile": "IdentityServerSPA"
    }
  }
}
</code></pre><h3 id="appsettingsdevelopmentjson">appsettings.Development.json</h3><p>In the <em>appsettings.Development.json</em> file of the project root, there's an <code>IdentityServer</code> section that describes the key used to sign tokens. When deploying to production, a key needs to be provisioned and deployed alongside the app, as explained in the <a href="#deploy-to-production" data-linktype="self-bookmark">Deploy to production</a> section.</p><pre><code class="lang-json">"IdentityServer": {
  "Key": {
    "Type": "Development"
  }
}
</code></pre><h2 id="general-description-of-the-angular-app">General description of the Angular app</h2><p>The authentication and API authorization support in the Angular template resides in its own Angular module in the <em>ClientApp\src\api-authorization</em> directory. The module is composed of the following elements:</p><ul><li>3 components:
<ul><li><em>login.component.ts</em>: Handles the app's login flow.</li><li><em>logout.component.ts</em>: Handles the app's logout flow.</li><li><em>login-menu.component.ts</em>: A widget that displays one of the following sets of links:
<ul><li>User profile management and log out links when the user is authenticated.</li><li>Registration and log in links when the user isn't authenticated.</li></ul></li></ul></li><li>A route guard <code>AuthorizeGuard</code> that can be added to routes and requires a user to be authenticated before visiting the route.</li><li>An HTTP interceptor <code>AuthorizeInterceptor</code> that attaches the access token to outgoing HTTP requests targeting the API when the user is authenticated.</li><li>A service <code>AuthorizeService</code> that handles the lower-level details of the authentication process and exposes information about the authenticated user to the rest of the app for consumption.</li><li>An Angular module that defines routes associated with the authentication parts of the app. It exposes the login menu component, the interceptor, the guard, and the service for consumption from the rest of the app.</li></ul><h2 id="general-description-of-the-react-app">General description of the React app</h2><p>The support for authentication and API authorization in the React template resides in the <em>ClientApp\src\components\api-authorization</em> directory. It's composed of the following elements:</p><ul><li>4 components:
<ul><li><em>Login.js</em>: Handles the app's login flow.</li><li><em>Logout.js</em>: Handles the app's logout flow.</li><li><em>LoginMenu.js</em>: A widget that displays one of the following sets of links:
<ul><li>User profile management and log out links when the user is authenticated.</li><li>Registration and log in links when the user isn't authenticated.</li></ul></li><li><em>AuthorizeRoute.js</em>: A route component that requires a user to be authenticated before rendering the component indicated in the <code>Component</code> parameter.</li></ul></li><li>An exported <code>authService</code> instance of class <code>AuthorizeService</code> that handles the lower-level details of the authentication process and exposes information about the authenticated user to the rest of the app for consumption.</li></ul><p>Now that you've seen the main components of the solution, you can take a deeper look at individual scenarios for the app.</p><h2 id="require-authorization-on-a-new-api">Require authorization on a new API</h2><p>By default, the system is configured to easily require authorization for new APIs. To do so, create a new controller and add the <code>[Authorize]</code> attribute to the controller class or to any action within the controller.</p><h2 id="customize-the-api-authentication-handler">Customize the API authentication handler</h2><p>To customize the configuration of the API's JWT handler, configure its <a href="/en-us/dotnet/api/microsoft.aspnetcore.builder.jwtbeareroptions" data-linktype="absolute-path">JwtBearerOptions</a> instance:</p><pre><code class="lang-csharp">services.AddAuthentication()
    .AddIdentityServerJwt();

services.Configure&lt;JwtBearerOptions&gt;(
    IdentityServerJwtConstants.IdentityServerJwtBearerScheme,
    options =&gt;
    {
        ...
    });
</code></pre><p>The API's JWT handler raises events that enable control over the authentication process using <code>JwtBearerEvents</code>. To provide support for API authorization, <code>AddIdentityServerJwt</code> registers its own event handlers.</p><p>To customize the handling of an event, wrap the existing event handler with additional logic as required. For example:</p><pre><code class="lang-csharp">services.Configure&lt;JwtBearerOptions&gt;(
    IdentityServerJwtConstants.IdentityServerJwtBearerScheme,
    options =&gt;
    {
        var onTokenValidated = options.Events.OnTokenValidated;       
        
        options.Events.OnTokenValidated = async context =&gt;
        {
            await onTokenValidated(context);
            ...
        }
    });
</code></pre><p>In the preceding code, the <code>OnTokenValidated</code> event handler is replaced with a custom implementation. This implementation:</p><ol><li>Calls the original implementation provided by the API authorization support.</li><li>Run its own custom logic.</li></ol><p>Protecting a client-side route is done by adding the authorize guard to the list of guards to run when configuring a route. As an example, you can see how the <code>fetch-data</code> route is configured within the main app Angular module:</p><pre><code class="lang-typescript">RouterModule.forRoot([
  // ...
  { path: 'fetch-data', component: FetchDataComponent, canActivate: [AuthorizeGuard] },
])
</code></pre><p>It's important to mention that protecting a route doesn't protect the actual endpoint (which still requires an <code>[Authorize]</code> attribute applied to it) but that it only prevents the user from navigating to the given client-side route when it isn't authenticated.</p><h2 id="authenticate-api-requests-angular">Authenticate API requests (Angular)</h2><p>Authenticating requests to APIs hosted alongside the app is done automatically through the use of the HTTP client interceptor defined by the app.</p><p>Protect a client-side route by using the <code>AuthorizeRoute</code> component instead of the plain <code>Route</code> component. For example, notice how the <code>fetch-data</code> route is configured within the <code>App</code> component:</p><pre><code class="lang-jsx">&lt;AuthorizeRoute path='/fetch-data' component={FetchData} /&gt;
</code></pre><p>Protecting a route:</p><ul><li>Doesn't protect the actual endpoint (which still requires an <code>[Authorize]</code> attribute applied to it).</li><li>Only prevents the user from navigating to the given client-side route when it isn't authenticated.</li></ul><h2 id="authenticate-api-requests-react">Authenticate API requests (React)</h2><p>Authenticating requests with React is done by first importing the <code>authService</code> instance from the <code>AuthorizeService</code>. The access token is retrieved from the <code>authService</code> and is attached to the request as shown below. In React components, this work is typically done in the <code>componentDidMount</code> lifecycle method or as the result from some user interaction.</p><h3 id="import-the-authservice-into-your-component">Import the authService into your component</h3><pre><code class="lang-javascript">import authService from './api-authorization/AuthorizeService'
</code></pre><h3 id="retrieve-and-attach-the-access-token-to-the-response">Retrieve and attach the access token to the response</h3><pre><code class="lang-javascript">async populateWeatherData() {
  const token = await authService.getAccessToken();
  const response = await fetch('api/SampleData/WeatherForecasts', {
    headers: !token ? {} : { 'Authorization': `Bearer ${token}` }
  });
  const data = await response.json();
  this.setState({ forecasts: data, loading: false });
}
</code></pre><h2 id="deploy-to-production">Deploy to production</h2><p>To deploy the app to production, the following resources need to be provisioned:</p><ul><li>A database to store the Identity user accounts and the IdentityServer grants.</li><li>A production certificate to use for signing tokens.
<ul><li>There are no specific requirements for this certificate; it can be a self-signed certificate or a certificate provisioned through a CA authority.</li><li>It can be generated through standard tools like PowerShell or OpenSSL.</li><li>It can be installed into the certificate store on the target machines or deployed as a <em>.pfx</em> file with a strong password.</li></ul></li></ul><h3 id="example-deploy-to-azure-websites">Example: Deploy to Azure Websites</h3><p>This section describes deploying the app to Azure websites using a certificate stored in the certificate store. To modify the app to load a certificate from the certificate store, the App Service plan needs to be on at least the Standard tier when you configure in a later step. In the app's <em>appsettings.json</em> file, modify the <code>IdentityServer</code> section to include the key details:</p><pre><code class="lang-json">"IdentityServer": {
  "Key": {
    "Type": "Store",
    "StoreName": "My",
    "StoreLocation": "CurrentUser",
    "Name": "CN=MyApplication"
  }
}
</code></pre><ul><li>The store name represents the name of the certificate store where the certificate is stored. In this case, it points to the personal user store.</li><li>The store location represents where to load the certificate from (<code>CurrentUser</code> or <code>LocalMachine</code>).</li><li>The name property on certificate corresponds with the distinguished subject for the certificate.</li></ul><p>To deploy to Azure Websites, deploy the app following the steps in <a href="../../tutorials/publish-to-azure-webapp-using-vs?view=aspnetcore-3.0#deploy-the-app-to-azure" data-linktype="relative-path">Deploy the app to Azure</a> to create the necessary Azure resources and deploy the app to production.</p><p>After following the preceding instructions, the app is deployed to Azure but isn't yet functional. The certificate used by the app still needs to be set up. Locate the thumbprint for the certificate to be used, and follow the steps described in <a href="/en-us/azure/app-service/app-service-web-ssl-cert-load#load-the-certificate-in-code" data-linktype="absolute-path">Load your certificates</a>.</p><p>While these steps mention SSL, there's a <strong>Private certificates</strong> section on the portal where you can upload the provisioned certificate to use with the app.</p><p>After this step, restart the app and it should be functional.</p><h2 id="other-configuration-options">Other configuration options</h2><p>The support for API authorization builds on top of IdentityServer with a set of conventions, default values, and enhancements to simplify the experience for SPAs. Needless to say, the full power of IdentityServer is available behind the scenes if the ASP.NET Core integrations don't cover your scenario. The ASP.NET Core support is focused on "first-party" apps, where all the apps are created and deployed by our organization. As such, support isn't offered for things like consent or federation. For those scenarios, use IdentityServer and follow their documentation.</p><h3 id="application-profiles">Application profiles</h3><p>Application profiles are predefined configurations for apps that further define their parameters. At this time, the following profiles are supported:</p><ul><li><code>IdentityServerSPA</code>: Represents a SPA hosted alongside IdentityServer as a single unit.
<ul><li>The <code>redirect_uri</code> defaults to <code>/authentication/login-callback</code>.</li><li>The <code>post_logout_redirect_uri</code> defaults to <code>/authentication/logout-callback</code>.</li><li>The set of scopes includes the <code>openid</code>, <code>profile</code>, and every scope defined for the APIs in the app.</li><li>The set of allowed OIDC response types is <code>id_token token</code> or each of them individually (<code>id_token</code>, <code>token</code>).</li><li>The allowed response mode is <code>fragment</code>.</li></ul></li><li><code>SPA</code>: Represents a SPA that isn't hosted with IdentityServer.
<ul><li>The set of scopes includes the <code>openid</code>, <code>profile</code>, and every scope defined for the APIs in the app.</li><li>The set of allowed OIDC response types is <code>id_token token</code> or each of them individually (<code>id_token</code>, <code>token</code>).</li><li>The allowed response mode is <code>fragment</code>.</li></ul></li><li><code>IdentityServerJwt</code>: Represents an API that is hosted alongside with IdentityServer.
<ul><li>The app is configured to have a single scope that defaults to the app name.</li></ul></li><li><code>API</code>: Represents an API that isn't hosted with IdentityServer.
<ul><li>The app is configured to have a single scope that defaults to the app name.</li></ul></li></ul><h3 id="configuration-through-appsettings">Configuration through AppSettings</h3><p>Configure the apps through the configuration system by adding them to the list of <code>Clients</code> or <code>Resources</code>.</p><p>Configure each client's <code>redirect_uri</code> and <code>post_logout_redirect_uri</code> property, as shown in the following example:</p><pre><code class="lang-json">"IdentityServer": {
  "Clients": {
    "MySPA": {
      "Profile": "SPA",
      "RedirectUri": "https://www.example.com/authentication/login-callback",
      "LogoutUri": "https://www.example.com/authentication/logout-callback"
    }
  }
}
</code></pre><p>When configuring resources, you can configure the scopes for the resource as shown below:</p><pre><code class="lang-json">"IdentityServer": {
  "Resources": {
    "MyExternalApi": {
      "Profile": "API",
      "Scopes": "a b c"
    }
  }
}
</code></pre><h3 id="configuration-through-code">Configuration through code</h3><p>You can also configure the clients and resources through code using an overload of <code>AddApiAuthorization</code> that takes an action to configure options.</p><pre><code class="lang-csharp">AddApiAuthorization&lt;ApplicationUser, ApplicationDbContext&gt;(options =&gt;
{
    options.Clients.AddSPA(
        "My SPA", spa =&gt;
        spa.WithRedirectUri("http://www.example.com/authentication/login-callback")
           .WithLogoutRedirectUri(
               "http://www.example.com/authentication/logout-callback"));

    options.ApiResources.AddApiResource("MyExternalApi", resource =&gt;
        resource.WithScopes("a", "b", "c"));
});
</code></pre><h2 id="additional-resources">Additional resources</h2></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>