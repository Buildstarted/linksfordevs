<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Sagas - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Sagas - linksfor.dev(s)"/>
    <meta property="og:description" content="Today has been a lively day in some parts of the Twitterverse debating the Saga pattern. As it stands, there are a few frameworks for .NET out there that use the term &quot;Saga&quot; for&#xA0;some framework implementation of a state machine or workflow. Trouble is, that&#x27;s not what a Saga is. A Saga is a failure management pattern. Sagas come out of the realization that particularly long-lived transactions (originally even just inside databases), but also far distributed transactions across location and/or trust boundaries can&#x27;t eaily be handled using the classic ACID model with 2-Phase commit and holding locks for the duration of the work. Instead, a Saga splits work into individual transactions whose effects can be, somehow, reversed after work has been performed and commited.&lt;P align=left&gt;&lt;IMG title=image style=&#x201D;BORDER-LEFT-WIDTH: 0px; BORDER-RIGHT-WIDTH: 0px; BACKGROUND-IMAGE: none; BORDER-BOTTOM-WIDTH: 0px; FLOAT: none; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN-LEFT: auto; DISPLAY: block; PADDING-RIGHT: 0px; BORDER-TOP-WIDTH: 0px; MARGIN-RIGHT: auto&#x201D; border=0 alt=image src=&#x201D;http://vasters.com/binary/Windows-Live-Writer/Sagas_1273E/image_thumb_1.png&#x201D; width=672 height=296&gt;&lt;/P&gt;The picture shows a simple Saga. If you book a travel itinerary, you want a car and a hotel and a flight. If you can&#x27;t get all of them, it&#x27;s probably not worth going. It&#x27;s also very certain that you can&#x27;t enlist all of these providers into a distributed ACID transaction. Instead, you&#x27;ll have an activity for booking rental cars that knows both how to perform a reservation and also how to cancel it - and one for a hotel and one for flights. The activities are grouped in a composite job (routing slip) that&#x27;s handed along the activity chain. If you want, you can sign/encrypt the routing slip items so that they can only be understood and manipulated by the intended receiver. When an activity completes, it adds a record of the completion to the routing slip along with information on where its compensating operation can be reached (e.g. via a Queue). When an activity fails, it cleans up locally and then sends the routing slip backwards to the last completed activity&#x27;s compensation address to unwind the transaction outcome.If you&#x27;re a bit familiar with travel, you&#x27;ll also notice that I&#x27;ve organized the steps by risk. Reserving a rental car almost always succeeds if you book in advance, because the rental car company can move more cars on-site of there is high demand. Reserving a hotel is slightly more risky, but you can commonly back out of a reservation without penalty until 24h before the stay. Airfare often comes with a refund restriction, so you&#x27;ll want to do that last.I created a Gist on Github that you can run as a console application. It illustrates this model in code. Mind that it is a mockup and not a framework. I wrote this in less than 90 minutes, so don&#x27;t expect to reuse this.The main program sets up an examplary routing slip (all the classes are in the one file) and creates three completely independent &quot;processes&quot; (activity hosts) that are each responsible for handling a particular kind of work. The &quot;processes&quot; are linked by a &quot;network&quot; and each kind of activity has an address for forward progress work and one of compensation work. The network resolution is simulated by &#x27;Send&quot;.&lt;/A&gt;&lt;DIV class=csharpcode&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;   1:  &lt;/SPAN&gt;&lt;SPAN class=kwrd&gt;static&lt;/SPAN&gt; ActivityHost[] processes;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;   2:  &lt;/SPAN&gt;&#xA0;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;   3:  &lt;/SPAN&gt;&lt;SPAN class=kwrd&gt;static&lt;/SPAN&gt; &lt;SPAN class=kwrd&gt;void&lt;/SPAN&gt; Main(&lt;SPAN class=kwrd&gt;string&lt;/SPAN&gt;[] args)&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;   4:  &lt;/SPAN&gt;{&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;   5:  &lt;/SPAN&gt;    var routingSlip = &lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; RoutingSlip(&lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; WorkItem[]&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;   6:  &lt;/SPAN&gt;        {&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;   7:  &lt;/SPAN&gt;            &lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; WorkItem&lt;ReserveCarActivity&gt;(&lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; WorkItemArguments),&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;   8:  &lt;/SPAN&gt;            &lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; WorkItem&lt;ReserveHotelActivity&gt;(&lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; WorkItemArguments),&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;   9:  &lt;/SPAN&gt;            &lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; WorkItem&lt;ReserveFlightActivity&gt;(&lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; WorkItemArguments)&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  10:  &lt;/SPAN&gt;        });&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  11:  &lt;/SPAN&gt;&#xA0;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  12:  &lt;/SPAN&gt;&#xA0;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  13:  &lt;/SPAN&gt;    &lt;SPAN class=rem&gt;// imagine these being completely separate processes with queues between them&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  14:  &lt;/SPAN&gt;    processes = &lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; ActivityHost[]&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  15:  &lt;/SPAN&gt;                        {&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  16:  &lt;/SPAN&gt;                            &lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; ActivityHost&lt;ReserveCarActivity&gt;(Send),&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  17:  &lt;/SPAN&gt;                            &lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; ActivityHost&lt;ReserveHotelActivity&gt;(Send),&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  18:  &lt;/SPAN&gt;                            &lt;SPAN class=kwrd&gt;new&lt;/SPAN&gt; ActivityHost&lt;ReserveFlightActivity&gt;(Send)&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  19:  &lt;/SPAN&gt;                        };&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  20:  &lt;/SPAN&gt;&#xA0;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  21:  &lt;/SPAN&gt;    &lt;SPAN class=rem&gt;// hand off to the first address&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  22:  &lt;/SPAN&gt;    Send(routingSlip.ProgressUri, routingSlip);&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  23:  &lt;/SPAN&gt;}&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  24:  &lt;/SPAN&gt;&#xA0;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  25:  &lt;/SPAN&gt;&lt;SPAN class=kwrd&gt;static&lt;/SPAN&gt; &lt;SPAN class=kwrd&gt;void&lt;/SPAN&gt; Send(Uri uri, RoutingSlip routingSlip)&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  26:  &lt;/SPAN&gt;{&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  27:  &lt;/SPAN&gt;    &lt;SPAN class=rem&gt;// this is effectively the network dispatch&lt;/SPAN&gt;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  28:  &lt;/SPAN&gt;    &lt;SPAN class=kwrd&gt;foreach&lt;/SPAN&gt; (var process &lt;SPAN class=kwrd&gt;in&lt;/SPAN&gt; processes)&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  29:  &lt;/SPAN&gt;    {&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  30:  &lt;/SPAN&gt;        &lt;SPAN class=kwrd&gt;if&lt;/SPAN&gt; (process.AcceptMessage(uri, routingSlip))&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  31:  &lt;/SPAN&gt;        {&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  32:  &lt;/SPAN&gt;            &lt;SPAN class=kwrd&gt;break&lt;/SPAN&gt;;&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  33:  &lt;/SPAN&gt;        }&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  34:  &lt;/SPAN&gt;    }&lt;/PRE&gt;&lt;PRE&gt;&lt;SPAN class=lnum&gt;  35:  &lt;/SPAN&gt;}&lt;/PRE&gt;&lt;/DIV&gt;&lt;STYLE type=text/css&gt;.csharpcode, .csharpcode pre{&#x9;font-size: small;&#x9;color: black;&#x9;font-family: consolas, &#x201C;Courier New&#x201D;, courier, monospace;&#x9;background-color: #ffffff;&#x9;/white-space: pre;/}.csharpcode pre { margin: 0em; }.csharpcode .rem { color: #008000; }.csharpcode .kwrd { color: #0000ff; }.csharpcode .str { color: #006080; }.csharpcode .op { color: #0000c0; }.csharpcode .preproc { color: #cc6633; }.csharpcode .asp { background-color: #ffff00; }.csharpcode .html { color: #800000; }.csharpcode .attr { color: #ff0000; }.csharpcode .alt {&#x9;background-color: #f4f4f4;&#x9;width: 100%;&#x9;margin: 0em;}.csharpcode .lnum { color: #606060; }&lt;/STYLE&gt;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://vasters.com/archive/Sagas.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">🎉</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Sagas</title>
<div class="readable">
        <h1>Sagas</h1>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 24 Sep 2019</div>
        <p><a href="https://vasters.com/archive/Sagas.html">https://vasters.com/archive/Sagas.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section itemprop="text">
        <p>Today has been a lively day in some parts of the Twitterverse debating the Saga pattern. As it stands, there are a few frameworks for .NET out there that use the term "Saga" for&nbsp;some framework implementation of a state machine or workflow. Trouble is, that's not what a Saga is. A Saga is a failure management pattern. </p>
<p>Sagas come out of the realization that particularly long-lived transactions (originally even just inside databases), but also far distributed transactions across location and/or trust boundaries can't eaily be handled using the classic ACID model with 2-Phase commit and holding locks for the duration of the work. Instead, a Saga splits work into individual transactions whose effects can be, somehow, reversed after work has been performed and commited.</p>
<p><a href="http://vasters.com/binary/Windows-Live-Writer/Sagas_1273E/image_4.png"><img title="image" alt="image" src="http://vasters.com/binary/Windows-Live-Writer/Sagas_1273E/image_thumb_1.png" width="672" height="296"></a></p>
<p>The picture shows a simple Saga. If you book a travel itinerary, you want a car and a hotel and a flight. If you can't get all of them, it's probably not worth going. It's also very certain that you can't enlist all of these providers into a distributed ACID transaction. Instead, you'll have an activity for booking rental cars that knows both how to perform a reservation and also how to cancel it - and one for a hotel and one for flights. </p>
<p>The activities are grouped in a composite job (routing slip) that's handed along the activity chain. If you want, you can sign/encrypt the routing slip items so that they can only be understood and manipulated by the intended receiver. When an activity completes, it adds a record of the completion to the routing slip along with information on where its compensating operation can be reached (e.g. via a Queue). When an activity fails, it cleans up locally and then sends the routing slip backwards to the last completed activity's compensation address to unwind the transaction outcome.</p>
<p>If you're a bit familiar with travel, you'll also notice that I've organized the steps by risk. Reserving a rental car almost always succeeds if you book in advance, because the rental car company can move more cars on-site of there is high demand. Reserving a hotel is slightly more risky, but you can commonly back out of a reservation without penalty until 24h before the stay. Airfare often comes with a refund restriction, so you'll want to do that last.</p>
<p>I created a <a href="https://gist.github.com/3562597">Gist on Github that you can run as a console application</a>. It illustrates this model in code. Mind that it is a mockup and not a framework. I wrote this in less than 90 minutes, so don't expect to reuse this.</p>
<p>The main program sets up an examplary routing slip (all the classes are in the one file) and creates three completely independent "processes" (activity hosts) that are each responsible for handling a particular kind of work. The "processes" are linked by a "network" and each kind of activity has an address for forward progress work and one of compensation work. The network resolution is simulated by 'Send".</p>

<div><pre><span>   1:  </span><span>static</span> ActivityHost[] processes;</pre><pre><span>   2:  </span>&nbsp;</pre><pre><span>   3:  </span><span>static</span> <span>void</span> Main(<span>string</span>[] args)</pre><pre><span>   4:  </span>{</pre><pre><span>   5:  </span>    var routingSlip = <span>new</span> RoutingSlip(<span>new</span> WorkItem[]</pre><pre><span>   6:  </span>        {</pre><pre><span>   7:  </span>            <span>new</span> WorkItem&lt;ReserveCarActivity&gt;(<span>new</span> WorkItemArguments),</pre><pre><span>   8:  </span>            <span>new</span> WorkItem&lt;ReserveHotelActivity&gt;(<span>new</span> WorkItemArguments),</pre><pre><span>   9:  </span>            <span>new</span> WorkItem&lt;ReserveFlightActivity&gt;(<span>new</span> WorkItemArguments)</pre><pre><span>  10:  </span>        });</pre><pre><span>  11:  </span>&nbsp;</pre><pre><span>  12:  </span>&nbsp;</pre><pre><span>  13:  </span>    <span>// imagine these being completely separate processes with queues between them</span></pre><pre><span>  14:  </span>    processes = <span>new</span> ActivityHost[]</pre><pre><span>  15:  </span>                        {</pre><pre><span>  16:  </span>                            <span>new</span> ActivityHost&lt;ReserveCarActivity&gt;(Send),</pre><pre><span>  17:  </span>                            <span>new</span> ActivityHost&lt;ReserveHotelActivity&gt;(Send),</pre><pre><span>  18:  </span>                            <span>new</span> ActivityHost&lt;ReserveFlightActivity&gt;(Send)</pre><pre><span>  19:  </span>                        };</pre><pre><span>  20:  </span>&nbsp;</pre><pre><span>  21:  </span>    <span>// hand off to the first address</span></pre><pre><span>  22:  </span>    Send(routingSlip.ProgressUri, routingSlip);</pre><pre><span>  23:  </span>}</pre><pre><span>  24:  </span>&nbsp;</pre><pre><span>  25:  </span><span>static</span> <span>void</span> Send(Uri uri, RoutingSlip routingSlip)</pre><pre><span>  26:  </span>{</pre><pre><span>  27:  </span>    <span>// this is effectively the network dispatch</span></pre><pre><span>  28:  </span>    <span>foreach</span> (var process <span>in</span> processes)</pre><pre><span>  29:  </span>    {</pre><pre><span>  30:  </span>        <span>if</span> (process.AcceptMessage(uri, routingSlip))</pre><pre><span>  31:  </span>        {</pre><pre><span>  32:  </span>            <span>break</span>;</pre><pre><span>  33:  </span>        }</pre><pre><span>  34:  </span>    }</pre><pre><span>  35:  </span>}</pre></div>


<p>The activities each implement a reservation step and an undo step. Here's the one for cars:</p>
<div><pre><span>   1:  </span><span>class</span> ReserveCarActivity : Activity</pre><pre><span>   2:  </span>{</pre><pre><span>   3:  </span>    <span>static</span> Random rnd = <span>new</span> Random(2);</pre><pre><span>   4:  </span>&nbsp;</pre><pre><span>   5:  </span>    <span>public</span> <span>override</span> WorkLog DoWork(WorkItem workItem)</pre><pre><span>   6:  </span>    {</pre><pre><span>   7:  </span>        Console.WriteLine(<span>"Reserving car"</span>);</pre><pre><span>   8:  </span>        var car = workItem.Arguments[<span>"vehicleType"</span>];</pre><pre><span>   9:  </span>        var reservationId = rnd.Next(100000);</pre><pre><span>  10:  </span>        Console.WriteLine(<span>"Reserved car {0}"</span>, reservationId);</pre><pre><span>  11:  </span>        <span>return</span> <span>new</span> WorkLog(<span>this</span>, <span>new</span> WorkResult { { <span>"reservationId"</span>, reservationId } });</pre><pre><span>  12:  </span>    }</pre><pre><span>  13:  </span>&nbsp;</pre><pre><span>  14:  </span>    <span>public</span> <span>override</span> <span>bool</span> Compensate(WorkLog item, RoutingSlip routingSlip)</pre><pre><span>  15:  </span>    {</pre><pre><span>  16:  </span>        var reservationId = item.Result[<span>"reservationId"</span>];</pre><pre><span>  17:  </span>        Console.WriteLine(<span>"Cancelled car {0}"</span>, reservationId);</pre><pre><span>  18:  </span>        <span>return</span> <span>true</span>;</pre><pre><span>  19:  </span>    }</pre><pre><span>  20:  </span>&nbsp;</pre><pre><span>  21:  </span>    <span>public</span> <span>override</span> Uri WorkItemQueueAddress</pre><pre><span>  22:  </span>    {</pre><pre><span>  23:  </span>        get { <span>return</span> <span>new</span> Uri(<span>"sb://./carReservations"</span>); }</pre><pre><span>  24:  </span>    }</pre><pre><span>  25:  </span>&nbsp;</pre><pre><span>  26:  </span>    <span>public</span> <span>override</span> Uri CompensationQueueAddress</pre><pre><span>  27:  </span>    {</pre><pre><span>  28:  </span>        get { <span>return</span> <span>new</span> Uri(<span>"sb://./carCancellactions"</span>); }</pre><pre><span>  29:  </span>    }</pre><pre><span>  30:  </span>}</pre></div>


<p>The chaining happens solely through the routing slip. The routing slip is "serializable" (it's not, pretend that it is) and it's the only piece of information that flows between the collaborating activities. There is no central coordination. All work is local on the nodes and once a node is done, it either hands the routing slip forward (on success) or backward (on failure). For forward progress data, the routing slip has a queue and for backwards items it maintains a stack. The routing slip also handles resolving and invoking whatever the "next" thing to call is on the way forward and backward.</p>
<div><pre><span>   1:  </span><span>class</span> RoutingSlip</pre><pre><span>   2:  </span>{</pre><pre><span>   3:  </span>    <span>readonly</span> Stack&lt;WorkLog&gt; completedWorkLogs = <span>new</span> Stack&lt;WorkLog&gt;();</pre><pre><span>   4:  </span>    <span>readonly</span> Queue&lt;WorkItem&gt; nextWorkItem = <span>new</span> Queue&lt;WorkItem&gt;();</pre><pre><span>   5:  </span>&nbsp;</pre><pre><span>   6:  </span>    <span>public</span> RoutingSlip()</pre><pre><span>   7:  </span>    {</pre><pre><span>   8:  </span>    }</pre><pre><span>   9:  </span>&nbsp;</pre><pre><span>  10:  </span>    <span>public</span> RoutingSlip(IEnumerable&lt;WorkItem&gt; workItems)</pre><pre><span>  11:  </span>    {</pre><pre><span>  12:  </span>        <span>foreach</span> (var workItem <span>in</span> workItems)</pre><pre><span>  13:  </span>        {</pre><pre><span>  14:  </span>            <span>this</span>.nextWorkItem.Enqueue(workItem);</pre><pre><span>  15:  </span>        }</pre><pre><span>  16:  </span>    }</pre><pre><span>  17:  </span>&nbsp;</pre><pre><span>  18:  </span>    <span>public</span> <span>bool</span> IsCompleted</pre><pre><span>  19:  </span>    {</pre><pre><span>  20:  </span>        get { <span>return</span> <span>this</span>.nextWorkItem.Count == 0; }</pre><pre><span>  21:  </span>    }</pre><pre><span>  22:  </span>&nbsp;</pre><pre><span>  23:  </span>    <span>public</span> <span>bool</span> IsInProgress</pre><pre><span>  24:  </span>    {</pre><pre><span>  25:  </span>        get { <span>return</span> <span>this</span>.completedWorkLogs.Count &gt; 0; }</pre><pre><span>  26:  </span>    }</pre><pre><span>  27:  </span>&nbsp;</pre><pre><span>  28:  </span>    <span>public</span> <span>bool</span> ProcessNext()</pre><pre><span>  29:  </span>    {</pre><pre><span>  30:  </span>        <span>if</span> (<span>this</span>.IsCompleted)</pre><pre><span>  31:  </span>        {</pre><pre><span>  32:  </span>            <span>throw</span> <span>new</span> InvalidOperationException();</pre><pre><span>  33:  </span>        }</pre><pre><span>  34:  </span>&nbsp;</pre><pre><span>  35:  </span>        var currentItem = <span>this</span>.nextWorkItem.Dequeue();</pre><pre><span>  36:  </span>        var activity = (Activity)Activator.CreateInstance(currentItem.ActivityType);</pre><pre><span>  37:  </span>        <span>try</span></pre><pre><span>  38:  </span>        {</pre><pre><span>  39:  </span>            var result = activity.DoWork(currentItem);</pre><pre><span>  40:  </span>            <span>if</span> (result != <span>null</span>)</pre><pre><span>  41:  </span>            {</pre><pre><span>  42:  </span>                <span>this</span>.completedWorkLogs.Push(result);</pre><pre><span>  43:  </span>                <span>return</span> <span>true</span>;</pre><pre><span>  44:  </span>            }</pre><pre><span>  45:  </span>        }</pre><pre><span>  46:  </span>        <span>catch</span> (Exception e)</pre><pre><span>  47:  </span>        {</pre><pre><span>  48:  </span>            Console.WriteLine(<span>"Exception {0}"</span>, e.Message);</pre><pre><span>  49:  </span>        }</pre><pre><span>  50:  </span>        <span>return</span> <span>false</span>;</pre><pre><span>  51:  </span>    }</pre><pre><span>  52:  </span>&nbsp;</pre><pre><span>  53:  </span>    <span>public</span> Uri ProgressUri</pre><pre><span>  54:  </span>    {</pre><pre><span>  55:  </span>        get</pre><pre><span>  56:  </span>        {</pre><pre><span>  57:  </span>            <span>if</span> (IsCompleted)</pre><pre><span>  58:  </span>            {</pre><pre><span>  59:  </span>                <span>return</span> <span>null</span>;</pre><pre><span>  60:  </span>            }</pre><pre><span>  61:  </span>            <span>else</span></pre><pre><span>  62:  </span>            {</pre><pre><span>  63:  </span>                <span>return</span></pre><pre><span>  64:  </span>                    ((Activity)Activator.CreateInstance(<span>this</span>.nextWorkItem.Peek().ActivityType)).</pre><pre><span>  65:  </span>                        WorkItemQueueAddress;</pre><pre><span>  66:  </span>            }</pre><pre><span>  67:  </span>        }</pre><pre><span>  68:  </span>    }</pre><pre><span>  69:  </span>&nbsp;</pre><pre><span>  70:  </span>    <span>public</span> Uri CompensationUri</pre><pre><span>  71:  </span>    {</pre><pre><span>  72:  </span>        get</pre><pre><span>  73:  </span>        {</pre><pre><span>  74:  </span>            <span>if</span> (!IsInProgress)</pre><pre><span>  75:  </span>            {</pre><pre><span>  76:  </span>                <span>return</span> <span>null</span>;</pre><pre><span>  77:  </span>            }</pre><pre><span>  78:  </span>            <span>else</span></pre><pre><span>  79:  </span>            {</pre><pre><span>  80:  </span>                <span>return</span></pre><pre><span>  81:  </span>                    ((Activity)Activator.CreateInstance(<span>this</span>.completedWorkLogs.Peek().ActivityType)).</pre><pre><span>  82:  </span>                        CompensationQueueAddress;</pre><pre><span>  83:  </span>            }</pre><pre><span>  84:  </span>        }</pre><pre><span>  85:  </span>    }</pre><pre><span>  86:  </span>&nbsp;</pre><pre><span>  87:  </span>    <span>public</span> <span>bool</span> UndoLast()</pre><pre><span>  88:  </span>    {</pre><pre><span>  89:  </span>        <span>if</span> (!<span>this</span>.IsInProgress)</pre><pre><span>  90:  </span>        {</pre><pre><span>  91:  </span>            <span>throw</span> <span>new</span> InvalidOperationException();</pre><pre><span>  92:  </span>        }</pre><pre><span>  93:  </span>&nbsp;</pre><pre><span>  94:  </span>        var currentItem = <span>this</span>.completedWorkLogs.Pop();</pre><pre><span>  95:  </span>        var activity = (Activity)Activator.CreateInstance(currentItem.ActivityType);</pre><pre><span>  96:  </span>        <span>try</span></pre><pre><span>  97:  </span>        {</pre><pre><span>  98:  </span>            <span>return</span> activity.Compensate(currentItem, <span>this</span>);</pre><pre><span>  99:  </span>        }</pre><pre><span> 100:  </span>        <span>catch</span> (Exception e)</pre><pre><span> 101:  </span>        {</pre><pre><span> 102:  </span>            Console.WriteLine(<span>"Exception {0}"</span>, e.Message);</pre><pre><span> 103:  </span>            <span>throw</span>;</pre><pre><span> 104:  </span>        }</pre><pre><span> 105:  </span>&nbsp;</pre><pre><span> 106:  </span>    }</pre><pre><span> 107:  </span>}</pre></div>


<p>The local work&nbsp; and making the decisions is encapsulated in the ActivityHost, which calls ProcessNext() on the routing slip to resolve the next activity and call its DoWork() function on the way forward or will resolve the last executed activity on the way back and invoke its Compensate() function. Again, there's nothing centralized here; all that work hinges on the routing slip and the three activities and their execution is completely disjoint.</p>
<div><pre><span>   1:  </span><span>abstract</span> <span>class</span> ActivityHost</pre><pre><span>   2:  </span>{</pre><pre><span>   3:  </span>    Action&lt;Uri, RoutingSlip&gt; send;</pre><pre><span>   4:  </span>&nbsp;</pre><pre><span>   5:  </span>    <span>public</span> ActivityHost(Action&lt;Uri, RoutingSlip&gt; send)</pre><pre><span>   6:  </span>    {</pre><pre><span>   7:  </span>        <span>this</span>.send = send;</pre><pre><span>   8:  </span>    }</pre><pre><span>   9:  </span>&nbsp;</pre><pre><span>  10:  </span>    <span>public</span> <span>void</span> ProcessForwardMessage(RoutingSlip routingSlip)</pre><pre><span>  11:  </span>    {</pre><pre><span>  12:  </span>        <span>if</span> (!routingSlip.IsCompleted)</pre><pre><span>  13:  </span>        {</pre><pre><span>  14:  </span>            <span>// if the current step is successful, proceed</span></pre><pre><span>  15:  </span>            <span>// otherwise go to the Unwind path</span></pre><pre><span>  16:  </span>            <span>if</span> (routingSlip.ProcessNext())</pre><pre><span>  17:  </span>            {</pre><pre><span>  18:  </span>                <span>// recursion stands for passing context via message</span></pre><pre><span>  19:  </span>                <span>// the routing slip can be fully serialized and passed</span></pre><pre><span>  20:  </span>                <span>// between systems. </span></pre><pre><span>  21:  </span>                <span>this</span>.send(routingSlip.ProgressUri, routingSlip);</pre><pre><span>  22:  </span>            }</pre><pre><span>  23:  </span>            <span>else</span></pre><pre><span>  24:  </span>            {</pre><pre><span>  25:  </span>                <span>// pass message to unwind message route</span></pre><pre><span>  26:  </span>                <span>this</span>.send(routingSlip.CompensationUri, routingSlip);</pre><pre><span>  27:  </span>            }</pre><pre><span>  28:  </span>        }</pre><pre><span>  29:  </span>    }</pre><pre><span>  30:  </span>&nbsp;</pre><pre><span>  31:  </span>    <span>public</span> <span>void</span> ProcessBackwardMessage(RoutingSlip routingSlip)</pre><pre><span>  32:  </span>    {</pre><pre><span>  33:  </span>        <span>if</span> (routingSlip.IsInProgress)</pre><pre><span>  34:  </span>        {</pre><pre><span>  35:  </span>            <span>// UndoLast can put new work on the routing slip</span></pre><pre><span>  36:  </span>            <span>// and return false to go back on the forward </span></pre><pre><span>  37:  </span>            <span>// path</span></pre><pre><span>  38:  </span>            <span>if</span> (routingSlip.UndoLast())</pre><pre><span>  39:  </span>            {</pre><pre><span>  40:  </span>                <span>// recursion stands for passing context via message</span></pre><pre><span>  41:  </span>                <span>// the routing slip can be fully serialized and passed</span></pre><pre><span>  42:  </span>                <span>// between systems </span></pre><pre><span>  43:  </span>                <span>this</span>.send(routingSlip.CompensationUri, routingSlip);</pre><pre><span>  44:  </span>            }</pre><pre><span>  45:  </span>            <span>else</span></pre><pre><span>  46:  </span>            {</pre><pre><span>  47:  </span>                <span>this</span>.send(routingSlip.ProgressUri, routingSlip);</pre><pre><span>  48:  </span>            }</pre><pre><span>  49:  </span>        }</pre><pre><span>  50:  </span>    }</pre><pre><span>  51:  </span>&nbsp;</pre><pre><span>  52:  </span>    <span>public</span> <span>abstract</span> <span>bool</span> AcceptMessage(Uri uri, RoutingSlip routingSlip);</pre><pre><span>  53:  </span>}</pre></div>



<p>That's a Saga.</p>

        
      </section></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>