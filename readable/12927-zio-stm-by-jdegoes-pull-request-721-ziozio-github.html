<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ZIO STM by jdegoes &#xB7; Pull Request #721 &#xB7; zio/zio &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>ZIO STM by jdegoes · Pull Request #721 · zio/zio · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>Provides a minimal, functional, and reasonably well-tested implementation of Software Transactional Memory for ZIO, closely inspired by and with a similar API to the STM in Haskell.</p><p>The two core data types added in this pull request are <code>STM</code> and <code>TRef</code>:</p><ul><li><code>STM[E, A]</code> represents a transaction that may fail with an <code>E</code> or succeed with an <code>A</code>. Like <code>IO[E, A]</code>, it is covariant in both type parameters, with the usual meaning of <code>Nothing</code> in a slot indicating that channel is unused.</li><li><code>TRef[A]</code> represents a transactional reference that may hold immutable values of type <code>A</code>. It is named <code>TRef</code> and not <code>TVar</code> because the main reference abstraction in ZIO is named <code>Ref</code>, so for consistency, <code>TRef</code> (<em>transactional reference</em>) makes a better name.</li></ul><p>Many usual combinators are implemented on <code>STM</code> and the companion object for more parity with <code>IO</code>. These have been given identical names where semantics are identical.</p><p>The test contain some complex logic to ensure that STM behaves correctly. These tests failed early on in the development and now pass always, which is a good sign of correctness.</p><p><strong>STM works correctly in the presence of interruption.</strong> That is, transactions are fully interruptible, and interrupting a transaction that is pending will ensure it does not complete. The STM transaction is translated into an IO interruption as the transaction is committed.</p><p>Separate work for a followup pull requests include:</p><ul><li><strong>Optimization</strong>. The current version is not completely optimized. It has been written with performance in mind, but there are optimizations that can be made both inside and outside the critical section. Before these optimizations are implemented, we need a few basic benchmarks to test different scenarios, and also compare STM performance with Ref performance and the performance of existing concurrent data structures.</li><li><strong>Interruption</strong>. Interruption should, ideally, remove pending retries from the todo lists of transactional references.</li><li><strong>Trampolining</strong>. It's not yet clear if STM requires trampolining, but this should be investigated and implemented if necessary.</li><li><strong>Benchmarking</strong>. See the above comment on optimization.</li><li><strong>Pessimistic Fallback</strong>. In the event of too many retries, STM should use a pessimistic locking strategy to avoid wasting resources. This should be simple to implement, adding a single lock.</li><li><strong>More Tests, More Doscs</strong>. We need a microsite page for STM and more tests are always good.</li><li><strong>Detection</strong>. STM does not suffer from deadlocks. However, it may be interesting to detect situations where two transactions are waiting on each other; or situations where transactions are suspended for a really long time.</li></ul><p>A separate question is to what extend we need the non-transactional versions of the concurrent data structures already inside ZIO. For performance reasons, keeping Queue is absolutely critical. However, benchmarking will show whether or not other data structures like Semaphore and Promise still have a reason to exist. It is possible that with some optimization, STM versions of these structures will be competitive with the existing ones.</p><p>Thanks to <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/wi101/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/wi101">@wi101</a> for her work with me on this, to <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/adamw/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/adamw">@adamw</a> for the invite to Scalar Conf, and for the Haskell community for making such a beautiful and practical abstraction for solving problems in concurrency.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>