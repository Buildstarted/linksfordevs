<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>[C#] Have some fun with&#xA0;.net core startup hooks</h1>
        <p>
by Kevin Gosse <br/>Reading time: 6-8 minutes        </p>
        <p><a href="https://medium.com/criteo-labs/c-have-some-fun-with-net-core-startup-hooks-498b9ad001e1">https://medium.com/criteo-labs/c-have-some-fun-with-net-core-startup-hooks-498b9ad001e1</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@kevingosse?source=post_page-----498b9ad001e1----------------------"><img alt="Kevin Gosse" src="https://miro.medium.com/fit/c/96/96/1*uQa2E6LGdotlsEg6fCm1yw.jpeg" width="48" height="48"></a></p></div></div></div></div><p id="642e" data-selectable-paragraph="">One feature of .net core 2.2 that didn‚Äôt catch my mind immediately is the <a href="https://github.com/dotnet/core-setup/blob/master/Documentation/design-docs/host-startup-hook.md" target="_blank" rel="noopener nofollow">startup hooks</a>. Put simply, this is a way to register globally a method in an assembly that will be executed whenever a .net core application is started. This unlocks a whole range of scenarios, from injecting a profiler to tweaking a static context in a given environment.</p><p id="9a79" data-selectable-paragraph="">How does it work? First, you need to create a new .net core assembly, and add a StartupHook class. Make sure that it‚Äôs outside of any namespace. That class must define a static Initialize method. That‚Äôs the method that will be called whenever a .net core application is started.</p><p id="392a" data-selectable-paragraph="">The following hook, for instance, will display ‚ÄúHello world!‚Äù when an application is launched:</p><figure><div></div></figure><p id="1651" data-selectable-paragraph="">To register the hook, you need to declare a <code>DOTNET_STARTUP_HOOKS</code> environment variable, pointing to the assembly. Once you‚Äôve done that, you‚Äôll see the message displayed:</p><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*PRW34iKkKpq2OazFX7EOLA.png?q=20" width="627" height="193" role="presentation"></p><p><img width="627" height="193" role="presentation" src="https://miro.medium.com/max/627/1*PRW34iKkKpq2OazFX7EOLA.png"></p></div></div></div></figure><p id="92c5" data-selectable-paragraph="">It‚Äôs really important to understand that <strong>the hook is executed inside of the application process</strong>. And a globally registered hook that runs inside of all .net core processes sounds like a good prank setup for unsuspecting coworkers.</p><p id="9fe7" data-selectable-paragraph="">What kind of prank? Let‚Äôs start with something simple: what about overriding the console stream to reverse the displayed text? First we write a custom <code>TextWriter</code>:</p><figure><div></div></figure><p id="c533" data-selectable-paragraph="">Then we assign it to the console in the startup hook:</p><figure><div></div></figure><p id="5678" data-selectable-paragraph="">Once the startup hook is registered, all .net core 2.2 applications will output inverted text in the console:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*xiAUmBiQPlrmcYBvqYWHcA.png?q=20" width="627" height="124" role="presentation"></p><p><img width="627" height="124" role="presentation" src="https://miro.medium.com/max/627/1*xiAUmBiQPlrmcYBvqYWHcA.png"></p></div></div></div></div></figure><p id="55fb" data-selectable-paragraph="">And the best part is that it even works for the ‚Äúdotnet.exe‚Äù executable itself!</p><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*9kYq2gHX_UHt-jAKqwsDxQ.png?q=20" width="627" height="363" role="presentation"></p><p><img width="627" height="363" role="presentation" src="https://miro.medium.com/max/627/1*9kYq2gHX_UHt-jAKqwsDxQ.png"></p></div></div></div></figure><p id="89b5" data-selectable-paragraph="">You can easily imagine the confusion that would come from it.</p><p id="aff7" data-selectable-paragraph="">Is there anything else we can do? I‚Äôve been unsuccessful at replacing the value of <code>string.Empty</code> (probably because it‚Äôs declared as an intrinsic), but we can instead replace the value of <code>Array.Empty&lt;T&gt;</code>. For instance for <code>Array.Empty&lt;string&gt;</code>:</p><figure><div></div></figure><p id="c570" data-selectable-paragraph="">This sounds rather inoffensive, until you consider the case of methods with <code>params</code> argument. For instance, this method:</p><figure><div></div></figure><p id="6ed3" data-selectable-paragraph="">From a C# point of view, you can call it without any parameter (<code>PrintArgs()</code>). But from an IL perspective, the args parameter is just an ordinary array. The magic is done by the compiler, which automatically inserts an empty array, effectively rewriting the call to <code>PrintArgs(Array.Empty&lt;string&gt;())</code>. Therefore, with the startup hook registered, the method called without any parameter will actually display ‚ÄúHello world!‚Äù.</p><p id="09da" data-selectable-paragraph="">Those are already nice ways to confuse coworkers, but I wanted to go even farther. That‚Äôs when I thought of replacing the default <code>TaskScheduler</code>. What could we do with it? What about‚Ä¶ rewriting values at random in the async state machine? When a method uses async/await, it is converted to a state machine that stores among other things the local variables used by the method (to restore the context when the await continuation starts executing). If we manage to retrieve that state machine, we can therefore change the value of the locals between each await!</p><p id="1356" data-selectable-paragraph="">We start by declaring our custom task scheduler (and name it <code>ThreadPoolTaskScheduler</code> in case somebody would think of inspecting the callstack), and we use it to overwrite <code>TaskScheduler.Default</code>.</p><figure><div></div></figure><p id="5621" data-selectable-paragraph="">Note that we also always set <code>s_asyncDebuggingEnabled</code> to true to avoid having a different behavior when the debugger is attached, which would complicate our code. The task scheduler calls an empty <code>MutateState</code> method, then uses the threadpool to schedule the task execution. Now we need to implement that method.</p><p id="bfaf" data-selectable-paragraph="">How to retrieve the state machine? The first step is to retrieve the <code><a href="https://github.com/dotnet/corefx/blob/332d12c0a401927c84d8a2c2ea113427481689ab/src/Common/src/CoreLib/System/Runtime/CompilerServices/AsyncMethodBuilder.cs#L1107" target="_blank" rel="noopener nofollow">ContinuationWrapper</a></code>. This is a structure that wraps the task action when <code>s_asyncDebuggingEnabled</code> is set to true. Depending on the type of task, we can find it either on task action or on the state:</p><figure><div></div></figure><p id="e8e0" data-selectable-paragraph="">From there, we retrieve the value of the <code>_continuation</code> field and check if it is an instance of <code>AsyncStateMachineBox</code>. If it is, then we can find the state machine in the <code>StateMachine</code> field:</p><figure><div></div></figure><p id="2b43" data-selectable-paragraph="">What does an async state machine look like?</p><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*xK9lelp9_IaVgusLST_A2w.png?q=20" width="414" height="180" role="presentation"></p><p><img width="414" height="180" role="presentation"></p></div></div></div></figure><p id="861b" data-selectable-paragraph="">Two public fields are always there: <code>&lt;&gt;1__state</code> and <code>&lt;&gt;t__builder</code>. <code>&lt;&gt;1__state</code> is used to store the current execution step in the async method. We could use it for instance to rewind the execution of the method. <code>&lt;&gt;t__builder</code> contains the facilities used to await other methods (nested calls). There‚Äôs plenty of stuff we could do with it, but we‚Äôll focus on the locals.</p><p id="2d90" data-selectable-paragraph="">The locals are stored in the private fields. In this case, <code>&lt;&gt;u__1</code> and <code>&lt;j&gt;5__1</code>. Those are the ones we want to play with:</p><figure><div></div></figure><p id="ed3a" data-selectable-paragraph="">What we do here is creating a new state machine, then copy the value of the old fields to the new ones. If the field is private and is an int, we replace it by a random value.</p><p id="4d4d" data-selectable-paragraph="">Now let‚Äôs make a simple program to test the hook:</p><figure><div></div></figure><p id="bcb2" data-selectable-paragraph="">And you‚Äôll see that‚Ä¶ it doesn‚Äôt work. Why? Because the TPL has been pretty well optimized. In a lot of places, the code checks the current scheduler, and completely bypasses it if it‚Äôs the default one to directly schedule the continuation on the threadpool. For instance, <a href="https://github.com/dotnet/corefx/blob/016839c18266f33eaa6784a9725c542de151eac1/src/Common/src/CoreLib/System/Runtime/CompilerServices/YieldAwaitable.cs#L98" target="_blank" rel="noopener nofollow">in the </a><code><a href="https://github.com/dotnet/corefx/blob/016839c18266f33eaa6784a9725c542de151eac1/src/Common/src/CoreLib/System/Runtime/CompilerServices/YieldAwaitable.cs#L98" target="_blank" rel="noopener nofollow">YieldAwaiter</a></code><a href="https://github.com/dotnet/corefx/blob/016839c18266f33eaa6784a9725c542de151eac1/src/Common/src/CoreLib/System/Runtime/CompilerServices/YieldAwaitable.cs#L98" target="_blank" rel="noopener nofollow"> (used by </a><code><a href="https://github.com/dotnet/corefx/blob/016839c18266f33eaa6784a9725c542de151eac1/src/Common/src/CoreLib/System/Runtime/CompilerServices/YieldAwaitable.cs#L98" target="_blank" rel="noopener nofollow">Task.Yield</a></code>).</p><p id="359b" data-selectable-paragraph="">How can we work around that? We absolutely need our custom task scheduler to be the default one, otherwise it won‚Äôt be used when calling <code>Task.Run</code>. But if the default task scheduler is assigned to a task, then we won‚Äôt be called back and we won‚Äôt be able to mutate the state. If we check the code of the <code>YieldAwaiter</code> above, we can see that it‚Äôs doing a simple reference comparison. So we can overwrite the scheduler of the task with a new instance of our custom scheduler to fool those checks:</p><figure><div></div></figure><p id="860d" data-selectable-paragraph="">Are we done? If we go back to our example, we can start debugging step by step:</p><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*ftMORiUGcxqcdqDZ7xDOTw.png?q=20" width="327" height="157" role="presentation"></p><p><img width="327" height="157" role="presentation"></p></div></div></div></figure><p id="b0ec" data-selectable-paragraph="">i is 42, all good. One more step and‚Ä¶</p><figure><div><div><div><p><img src="https://miro.medium.com/max/60/1*qHCy5wrFB_p5K-IDe6owSw.png?q=20" width="434" height="157" role="presentation"></p><p><img width="434" height="157" role="presentation"></p></div></div></div></figure><p id="39f1" data-selectable-paragraph="">Now go and enjoy the dumbfounded looks of your coworkers!</p><p id="c8c8" data-selectable-paragraph="">Note that this won‚Äôt work when using <code>ConfigureAwait(false)</code>, because it directly enqueues the continuation to the threadpool and won‚Äôt even check the current task scheduler (why would it?). One way around that could be to override the task builder with a custom one, but the joke already went far enough as is üôÇ</p><p id="845d" data-selectable-paragraph="">Of course, all those tricks could have unpredictable effects on the target applications, so make sure to closely supervise the prank and stop as soon as it could become dangerous.</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>