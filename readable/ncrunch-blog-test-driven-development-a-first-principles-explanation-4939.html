<!DOCTYPE html>
<html lang="en">
<head>
    <title>
NCrunch Blog | Test-Driven Development: A First-Principles Explanation - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="NCrunch Blog | Test-Driven Development: A First-Principles Explanation - linksfor.dev(s)"/>
    <meta property="article:author" content="Hit Subscribe"/>
    <meta property="og:description" content="In today&#x27;s post, we take a first principle approach to explaining why we do test-driven development. We start with some basic truths, and deduce from there."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.ncrunch.net/post/test-driven-development-first-principles-explanation.aspx"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - NCrunch Blog | Test-Driven Development: A First-Principles Explanation</title>
<div class="readable">
        <h1>NCrunch Blog | Test-Driven Development: A First-Principles Explanation</h1>
            <div>by Hit Subscribe</div>
            <div>Reading time: 7-9 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://blog.ncrunch.net/post/test-driven-development-first-principles-explanation.aspx">https://blog.ncrunch.net/post/test-driven-development-first-principles-explanation.aspx</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>
  <span>4. September 2018 22:45</span></p><div><p><span>In 2018, just about every developer has at least heard of test-driven development. But that doesn't mean every team is doing it or that every project has an extensive suite of tests. It doesn't even mean everyone likes it or believes in it.</span></p>
<p><span>Join me as I start out with some basic facts that no one should be able to deny. From there, I'll work towards what TDD is and why we should use it.</span></p>
<p><img src="https://blog.ncrunch.net/image.axd?picture=2018%2f9%2ftest_driven_development_a_first_principles_explanation_.png" alt="" width="639" height="360"></p>
<h2><span>What Is a First Principle?</span></h2>
<p><span><a href="https://en.wikipedia.org/wiki/First_principle">Wikipedia</a> defines a first principle as</span></p>
<blockquote>
<p><span><em>a basic, foundational, self-evident&nbsp;proposition&nbsp;or assumption that cannot be deduced from any other proposition or assumption</em></span></p>
</blockquote>
<p><span>This means we'll have to start from some basic truths that cannot be denied. Just telling people tests improve the design and reliability of your code won't cut it.</span></p>
<p><span>From these basic truths, I'll have to work my way towards explaining why test-driven development is a good idea.</span></p>
<h2><span>What Basic Truths Can We Agree On?</span></h2>
<p><span>I'll put some statements out there that I think we can all agree on:</span></p>
<ul>
<li><span>Everyone makes mistakes.</span></li>
<li><span>Software <em>can</em> be or become complex.</span></li>
</ul>
<p><span>Let's dig into those a bit.</span></p>
<h3><span>We All Make Mistakes</span></h3>
<p><span>The fact that everyone makes mistakes cannot be denied. It's a natural trait of human beings. We make mistakes because of several factors:</span></p>
<ul>
<li><span>Maybe we didn't have all the facts.</span></li>
<li><span>We might ignore some facts because we're tired or unfocused.</span></li>
<li><span>Maybe we achieved what we wanted, but now that we see it in action, we realize we want something else.</span></li>
</ul>
<p><span>There are plenty of reasons why you might see a certain decision or action as a mistake. The fact remains that we all make them. And for developers specifically, this means we'll make mistakes in the development of our software.</span></p>
<p><span>Let's put that statement aside for now, but remember: <em>we all make mistakes while developing software.</em></span></p>
<h3><span>Complexity in Software</span></h3>
<p><span>The other statement I made was the <em>software can be or become complex</em>. Not all software is complex, and some software might start out simple but evolve into something complex. Also, what's complex for one person might not be for another. But at a certain moment, a developer might experience the code of an application as being complex. This might be due to the amount of code, the language, the quality of the code, the paradigms used, the experience of a developer, etc. We'll revisit this statement later.</span></p>
<p><span>So we have these two basic premises that we accept as truth. If you don't agree with me on these two things, you can stop reading. Everything that follows in this article, I will deduce from these two facts. If you don't accept them as facts, the rest of the article has no value. If you do accept my premises, let's move on.</span></p>
<h2><span>We All Make Mistakes While Developing Software</span></h2>
<p><span>Developers are only human, so we're bound to make mistakes as software developers. Software development is more than just writing code. It's reading logs, interacting with users and clients, brainstorming, thinking out solutions, and a lot more. In all these aspects of developing software, we could be making mistakes. I'll focus on one aspect: writing code.</span></p>
<p><span>If we can agree that we make mistakes as humans, we can agree we'll make mistakes as software developers. And from that follows that we will make mistakes while writing code.</span></p>
<p><span>This means that even if everything is clear and we know&nbsp;<em>what</em> we need to implement, we will still, somewhere along the way, make mistakes in <em>how</em> we implement it.<em>&nbsp;</em>This might be as small as writing a "+" (plus) where there must be a "-" (minus), or forgetting to increase a counter in a "for"&nbsp;loop. I know I've done both. But it could also be way more complex. You might write some difficult calculation or algorithm and be implementing it wrong, giving you a result you don't want.</span></p>
<p><span>So we're at the next step in our thought process: we all write bugs.</span></p>
<p><span>I think we can also assume that we don't want bugs. Bugs cause software to not do what we or the user wants, and they can cost money. So how can we avoid this?</span></p>
<h2><span>Testing Your Software</span></h2>
<p><span>Avoiding bugs is easy: run the software and check that it works as you intended. But here our two first truths come back into play: people make mistakes and software can be complex.</span></p>
<p><span>Because software is complex, your test might involve several steps that you have to reproduce perfectly. To make matters worse, you might not be able to perform some tests at certain moments. Logic that works with leap years is a great example of that.</span></p>
<p><span>Even if you can perform the same test over and over again, doing so manually leaves room for human error. You might perform the test wrong and see an outcome you didn't expect. This leaves you with the time-wasting next step of either looking for a bug that isn't there or doing the test again.</span></p>
<p><span>A logical next step in the software industry is to automate these tests. This allows us to put more time and effort into activities that are more valuable to the company, like adding new features. Also, most developers don't like doing the same activity over and over again.</span></p>
<h2><span>Handling Complexity</span></h2>
<p><span>Our second basic truth was that software can be complex. If your software is complex, the possibility of making mistakes should be greater. That's why the more complex the code is, the more it can benefit from test-driven development.</span></p>
<p><span>But it's also valid the other way around. Test-driven development can help you manage the complexity. For this statement to be true, you'll need to introduce a third truth into your team and codebase: your automated tests should be small enough to comprehend. This means they'll usually test one thing and work in isolation. If you can make this a reality, your code should follow. In other words, your code will also be split up into smaller pieces that are more easy to understand.</span></p>
<h2><span>The Scientific Method</span></h2>
<p><span>Once you have a suite of automated tests, you now have a way of (almost)&nbsp;<em>proving</em> your code does what it should do. It's the scientific method of not assuming things but rather trying to prove them. In mathematics, this is done by calculations that work towards the expected outcome. In other fields of science, we can perform experiments to (almost) prove some hypothesis.</span></p>
<p><span>I say&nbsp;<em>almost</em> prove because you can never actually prove a hypothesis right. You can only prove it wrong. Check out this great <a href="https://www.youtube.com/watch?v=EYPapE-3FRw">talk of Richard Feynman on the scientific method</a>, especially starting at 3:47. In short, he states that you start with a hypothesis, then deduce some consequences from that, and finally perform an experiment to measure those assumed consequences. If your measurements fit into the hypothesis, it means your hypothesis is likely to be right.</span></p>
<p><span>We can say the same about software. You assume your code does what it should do, so you write a test like, "if I enter these variables, this should be the outcome." If your tests fail, you've proven your code&nbsp;<em>doesn't</em> do what it should. If they pass, your code <em>likely</em> does what it should, but you haven't proven it. That's because your tests might not cover all situations. If later a user encounters a bug, you know you have a missing test. Write a test to reproduce this bug and you will see your hypothesis was wrong: your code&nbsp;<em>doesn't</em> do what it is supposed to. But you can fix the code, and now your hypothesis is even more likely.</span></p>
<p><span>And that's why we should use TDD. It's what gets us the closest we can get to proving our code does what we want it to do all of the time.</span></p>

<p><span><em>This post was written by Peter Morlion. <a href="https://www.petermorlion.com/" target="_blank">Peter</a> is a passionate programmer that helps people and companies improve the quality of their code, especially in legacy codebases. He firmly believes that industry best practices are invaluable when working towards this goal, and his specialties include TDD, DI, and SOLID principles.&nbsp;</em></span></p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>