<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How the .NET Team uses Azure Pipelines to produce Docker Images | .NET Blog -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>How the .NET Team uses Azure Pipelines to produce Docker Images | .NET Blog</h1>
    <div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://secure.gravatar.com/avatar/2c75388dc7947fa9034c15352e6c6c69?s=58&amp;d=mm&amp;r=g" width="58" alt="Avatar" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 photo avatar-default"><p>Matt</p></div></div></div><p><span>Produc</span><span>ing&#xA0;</span><a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/"><span>Docker images for .NET</span></a><span>&#xA0;might not seem&#xA0;</span><span>like that big of a deal.&#xA0; O</span><span>nce you&#x2019;ve got a&#xA0;</span><span>Dockerfile</span><span>&#xA0;defined, just run&#xA0;</span><span>&#x201C;</span><span>docker build</span><span>&#x201C;</span><span>&#xA0;and&#xA0;</span><span>&#x201C;</span><span>docker&#xA0;</span><span>push</span><span>&#x201C;</span><span>&#xA0;and you&#x2019;re done, right?</span><span>&#xA0;&#xA0;</span><span>Then</span><span>&#xA0;just rinse and repeat&#xA0;</span><span>when&#xA0;</span><span>new versions of .NET&#xA0;</span><span>are released&#xA0;</span><span>and that should be all that&#x2019;s needed.&#xA0; Well, it&#x2019;s not quite that simple.</span><span>&#xA0;</span></p><p><span>When you factor in&#xA0;</span><span>the&#xA0;</span><span>number&#xA0;</span><span>of Linux distro</span><span>s</span><span>&#xA0;and Windows versions, different processor architectures,&#xA0;</span><span>and&#xA0;</span><span>different .NET versions, you end up&#xA0;</span><span>with a substantial matrix of images that need to be</span><span>&#xA0;built and</span><span>&#xA0;</span><span>published</span><span>.&#xA0;&#xA0;</span><span>Then consider that some images have dependencies on others</span><span>&#xA0;which implies a specific order in which to build the images</span><span>.&#xA0; And&#xA0;</span><span>on top</span><span>&#xA0;</span><span>of all that,&#xA0;</span><span>we need to</span><span>&#xA0;</span><span>ensure the&#xA0;</span><span>images&#xA0;</span><span>ar</span><span>e p</span><span>ublished&#xA0;</span><span>as quickly as possible&#xA0;</span><span>so that customers can get their hands on&#xA0;</span><span>newly released product versions and security fixes.</span><span>&#xA0;&#xA0;</span><span>Oh, and by the way, in addition to the&#xA0;</span><a href="https://github.com/dotnet/dotnet-docker"><span>.NET Core</span></a><span>&#xA0;</span><span>images&#xA0;</span><span>we also produce .NET Core&#xA0;</span><a href="https://github.com/dotnet/dotnet-docker/tree/nightly"><span>nightly</span></a><span>&#xA0;images for preview releases,&#xA0;</span><a href="https://github.com/dotnet/dotnet-buildtools-prereqs-docker"><span>images</span></a><span>&#xA0;for developers of .NET Core, as well as images for&#xA0;</span><a href="https://github.com/Microsoft/dotnet-framework-docker"><span>.NET Framework</span></a><span>.</span><span>&#xA0;</span><span>This is starting to look a little daunting.</span><span>&#xA0; Let&#x2019;s dive into what goes into producing the .NET Docker images.</span><span>&#xA0;</span></p><p><span>To keep things &#x201C;simple&#x201D;, let&#x2019;s just consider the Docker images for&#xA0;</span><span>.NET Core</span><span>.&#xA0;&#xA0;</span><span>The same infrastructure is used amongst all the types of images we produce</span><span>&#xA0;but keep in mind that the scope of the work is greater than described here.</span><span>&#xA0;</span></p><p><span>T</span><span>he full set of .NET Core images</span><span>&#xA0;are derived from the following matrix</span><span>:</span><span>&#xA0;</span></p><ul><li><span>Linux: 3 distros / 7 versions</span><span>&#xA0;</span></li><li><span>Windows: 4 versions</span><span>&#xA0;</span></li><li><span>Architectures: AMD64, ARM32, ARM64</span><span>&#xA0;</span></li><li><span>.NET Core: 3 versions</span><span>&#xA0;</span></li></ul><p><span>In total,&#xA0;</span><span>119 distinct images with&#xA0;</span><span>309&#xA0;</span><span>tags</span><span>&#xA0;</span><span>(281 simple and 28 shared)&#xA0;</span><span>are&#xA0;</span><span>being&#xA0;</span><span>produced</span><span>&#xA0;today</span><span>.&#xA0;</span><span>This matrix is constantly evolving as new OS and .NET versions are released.</span><span>&#xA0;</span></p><h2><span>Anatomy of our Pipeline</span><span>&#xA0;</span></h2><p><span>Our</span><span>&#xA0;CI/CD</span><span>&#xA0;pipeline is implemented using&#xA0;</span><a href="https://azure.microsoft.com/services/devops/pipelines"><span>Azure Pipelines</span></a><span>&#xA0;with the core YAML</span><span>-based&#xA0;</span><span>source located&#xA0;</span><a href="https://github.com/dotnet/docker-tools/tree/master/eng/common/templates"><span>here</span></a><span>. It&#x2019;s divided into three stages: build, test, and publish. Build and test each run multiple jobs in parallel. This parallelism&#xA0;</span><span>dramatically reduces&#xA0;</span><span>the&#xA0;</span><span>pipeline&#x2019;s</span><span>&#xA0;</span><span>execution time from start to finish&#xA0;</span><span>by an order of magnitude</span><span>&#xA0;versus running the jobs sequentially</span><span>.</span><span>&#xA0;</span></p><h3><span><span>Build Agents</span>&#xA0;</span></h3><p><span>Since we&#x2019;ve got jobs running in parallel, we also need&#xA0;a number of&#xA0;build agents that can fulfill the execution of those jobs.&#xA0;</span><span>T</span><span>here is a&#xA0;</span><span>self-hosted&#xA0;</span><span>agent pool</span><span>&#xA0;that we use&#xA0;</span><span>for</span><span>&#xA0;</span><span>producing&#xA0;</span><span>.NET&#xA0;</span><span>images&#xA0;</span><span>which&#xA0;</span><span>consists of a variety of&#xA0;</span><span>virtual machines&#xA0;</span><span>and physical hardware to meet our</span><span>&#xA0;platform and</span><span>&#xA0;</span><span>perf demands</span><span>.</span><span>&#xA0;</span></p><p><span>For Linux AMD64 builds,&#xA0;</span><span>we use the Hosted Ubuntu 1604 pool provided by Azure DevOp</span><span>s. That pool meets our performance needs and makes things simple from an operations standpoint.</span><span>&#xA0;</span></p><p><span>For Windows AMD64 builds, we have&#xA0;</span><span>custom Azure VMs configured as Azure Pipeline</span><span>&#xA0;self-hosted</span><span>&#xA0;agents that are</span><span>&#xA0;running four different Windows versions (five agents for each version).</span><span>&#xA0;</span></p><p><span>For&#xA0;</span><span>ARM builds</span><span>, things get a bit&#xA0;</span><span>trickier</span><span>.&#xA0;</span><span>We need to build and test the Docker images on ARM-</span><span>based&#xA0;</span><span>hardware.&#xA0;&#xA0;</span><span>Since the&#xA0;</span><span>Azure Pipeline agent software</span><span>&#x2019;s support for ARM is limited to Linux/ARM32, we</span><span>&#xA0;use AMD-based Linux machines as the agents&#xA0;</span><span>that send commands to&#xA0;</span><span>remote&#xA0;</span><span>Linux</span><span>&#xA0;and Windows ARM devices.</span><span>&#xA0;&#xA0;</span><span>Each of those devices runs a Docker daemon</span><span>.&#xA0; The agent machines act as proxies to send Docker commands to the&#xA0;</span><span>remote&#xA0;</span><span>daemon</span><span>s</span><span>&#xA0;running on the&#xA0;</span><span>ARM&#xA0;</span><span>device</span><span>s</span><span>.</span><span>&#xA0;</span><span>For Linux, we use&#xA0;</span><a href="https://www.nvidia.com/en-us/autonomous-machines/embedded-systems"><span>NVIDA Jetson</span></a><span>&#xA0;</span><span>devices that run on the AArch64 architecture which&#xA0;</span><span>are</span><span>&#xA0;capable of building images that target&#xA0;</span><span>either ARM32 or ARM64</span><span>.</span><span>&#xA0;</span><span>&#xA0;</span><span>For Windows,&#xA0;</span><span>we have</span><span>&#xA0;</span><a href="https://www.solid-run.com/nxp-family/hummingboard/"><span>SolidRun</span><span>&#xA0;</span><span>HummingBoard</span></a><span>&#xA0;</span><span>ARM device</span><span>s.</span><span>&#xA0;</span></p><h3><span>Image&#xA0;Matrix Generation&#xA0;</span></h3><p><span>One of the key features of&#xA0;</span><a href="https://azure.microsoft.com/services/devops/pipelines"><span>Azure Pipelines</span></a><span>&#xA0;</span><span>that we&#xA0;</span><span>rely on&#xA0;</span><span>is&#xA0;</span><span>the&#xA0;</span><a href="https://docs.microsoft.com/azure/devops/pipelines/yaml-schema?view=azure-devops&amp;tabs=schema#matrix"><span>matrix</span></a><span>&#xA0;strategy for build jobs.&#xA0;</span><span>It&#xA0;</span><span>allows a variable number of build jobs to be generated based on a</span><span>n image&#xA0;</span><span>matrix that is defined by our pipeline.&#xA0; An&#xA0;</span><span>illustration</span><span>&#xA0;</span><span>of&#xA0;</span><span>a very simplified&#xA0;</span><span>matrix is the following</span><span>&#xA0;YAML</span><span>:</span><span>&#xA0;</span></p><p><span>3.0-runtime-deps-disco-graph:</span><br> <span>&#xA0;&#xA0;imageBuilderPaths: 3.0/runtime-deps/disco</span><span>&#xA0;</span><span>3.0/runtime/disco</span><span>&#xA0;</span><span>3.0/aspnet/disco</span><br> <span>&#xA0;&#xA0;osType:&#xA0;linux</span><br> <span>&#xA0; architecture: amd64</span><br> <span>3.0-sdk-disco:</span><br> <span>&#xA0;&#xA0;imageBuilderPaths: &#x2013;path 3.0/sdk/disco</span><br> <span>&#xA0;&#xA0;osType:&#xA0;linux</span><br> <span>&#xA0; architecture: amd64</span><span>&#xA0;</span></p><p><span>This matrix</span><span>&#xA0;would cause two&#xA0;</span><span>build jobs to execute in parallel, each running the same set of steps but with different inputs.&#xA0;&#xA0;</span><span>The inputs consist of variables defined by the matrix.&#xA0;&#xA0;</span><span>The first job</span><span>,</span><span>&#xA0;as identified by&#xA0;</span><span>3.0-runtime-deps-disco-graph</span><span>,&#xA0;</span><span>has a variable named&#xA0;</span><span>imageBuilderPaths</span><span>&#xA0;that indicates to the build steps that</span><span>&#xA0;the</span><span>&#xA0;</span><span>.</span><span>NET Core 3.0&#xA0;</span><span>Docker images f</span><span>or&#xA0;</span><span>runtime-deps</span><span>,&#xA0;</span><span>runtime</span><span>, and&#xA0;</span><span>aspnet</span><span>&#xA0;on Ubuntu Disco</span><span>&#xA0;are to be built</span><span>.</span><span>&#xA0; The reason those&#xA0;</span><span>images are built in a single job is because the</span><span>r</span><span>e</span><span>&#xA0;are</span><span>&#xA0;dependencies amongst them.&#xA0;&#xA0;</span><span>The&#xA0;</span><span>runtime</span><span>&#xA0;image depends on&#xA0;</span><span>runtime-deps</span><span>&#xA0;and the&#xA0;</span><span>aspnet</span><span>&#xA0;image depends on the&#xA0;</span><span>runtime</span><span>&#xA0;image; there&#x2019;s no parallelism that can be done within this graph.&#xA0; The&#xA0;</span><span>sdk</span><span>&#xA0;image, however, can be built in parallel with the others because it doesn&#x2019;t depend on them; it depends on&#xA0;</span><a href="https://github.com/docker-library/buildpack-deps/blob/master/disco/scm/Dockerfile"><span>buildpa</span><span>ck-deps:disco-scm</span></a><span>, an&#xA0;</span><span>official Docker&#xA0;image</span><span>.</span><span>&#xA0;</span></p><p><span>The goal is to produce a matrix that&#xA0;</span><span>splits things apart s</span><span>uch that operations are executed in&#xA0;</span><span>parallel whenever possible.&#xA0; You</span><span>&#xA0;might</span><span>&#xA0;</span><span>be&#xA0;</span><span>thinking th</span><span>at such a matrix has got to be a real headache to maintain.</span><span>&#xA0; And you&#x2019;d be right.&#xA0; That&#x2019;s why we don&#x2019;t maintain a statically defined matrix.&#xA0; It&#x2019;s generated for us&#xA0;</span><span>dynamically at build time&#xA0;</span><span>by a multi-purpo</span><span>se&#xA0;</span><span>tool</span><span>&#xA0;</span><span>we&#x2019;ve created&#xA0;</span><span>called&#xA0;</span><a href="https://github.com/dotnet/docker-tools"><span>Image Builder</span></a><span>.</span><span>&#xA0;With this&#xA0;</span><span>tool</span><span>,&#xA0;</span><span>we can execute a command that will consume a&#xA0;</span><span>custom&#xA0;</span><span>manifest file and outputs a matrix&#xA0;</span><span>that is consumed by&#xA0;</span><a href="https://azure.microsoft.com/services/devops/pipelines"><span>Azure Pipelines</span></a><span>.&#xA0; The&#xA0;</span><a href="https://github.com/dotnet/dotnet-docker/blob/master/manifest.json"><span>manifest file</span></a><span>&#xA0;</span><span>contains&#xA0;</span><span>a bunch of metadata about all the images we need to produce&#xA0;</span><span>and includes information like the file paths to the&#xA0;</span><span>Dockerfiles</span><span>&#xA0;and the tags to be assigned to the images.</span><span>&#xA0;</span></p><p><span>We don&#x2019;t just generate one matrix either.&#xA0; Separate matrices are generated based on the&#xA0;</span><span>platform and architecture.&#xA0; For example, there are separate matrices for Linux</span><span>/</span><span>AMD64, Linux</span><span>/</span><span>ARM32,&#xA0;</span><span>Windows Nano Server 1809</span><span>/</span><span>ARM32, etc.&#xA0; The output from Image Builder labels each matrix with its corresponding platform</span><span>/architecture identifier.&#xA0; This identifier determines which build agents will run that&#xA0;</span><span>particular matrix</span><span>.</span><span>&#xA0;</span><span>As an example, t</span><span>he pipeline is configured to run&#xA0;</span><span>the Linux/AMD</span><span>64 matrix on the Hosted Ubuntu 1604 agent pool.</span><span>&#xA0;</span></p><h3><span>Build Stage</span><span>&#xA0;</span></h3><p><span>The&#xA0;</span><span>build stage</span><span>&#xA0;of the pipeline</span><span>&#xA0;is responsible for&#xA0;</span><span>build</span><span>ing</span><span>&#xA0;the</span><span>&#xA0;</span><span>Docker images</span><span>.&#xA0;</span><span>T</span><span>here are 64 jobs that are executed which account for the different platform and product version combinations a</span><span>s well as</span><span>&#xA0;</span><span>image&#xA0;</span><span>dependencies</span><span>.&#xA0;</span><span>Examples of job names include &#x201C;Build-2.2-aspnet-Windows-NanoServer1809-AMD64&#x201D;, &#x201C;</span><span>Build</span><span>-2.</span><span>1-runtime-deps-graph</span><span>-Linux-</span><span>bionic</span><span>-A</span><span>RM32v7</span><span>&#x201D;, and &#x201C;</span><span>Build</span><span>-3.0</span><span>-sdk</span><span>-Linux-bionic-A</span><span>MD64</span><span>&#x201D;.</span><span>&#xA0;</span></p><p><span>The first step of this process is to call&#xA0;</span><a href="https://github.com/dotnet/docker-tools"><span>Image Builder</span></a><span>&#xA0;to generate the build matri</span><span>ces</span><span>.&#xA0;&#xA0;</span><span>Each matrix produces a set of jobs that build the set of Docker images as described by their portion of the matrix.&#xA0;&#xA0;</span><span>Remember the&#xA0;</span><span>imageBuilderPaths</span><span>&#xA0;variable contained in the matrix example mentioned earlier? This value is fed into Image Builder</span><span>&#xA0;so that it knows which Docker images it should b</span><span>uild</span><span>.&#xA0;</span><span>It also uses the metadata in the&#xA0;</span><a href="https://github.com/dotnet/dotnet-docker/blob/master/manifest.json"><span>manifest file</span></a><span>&#xA0;</span><span>to know which tags should be defined for these images.</span><span>&#xA0;This includes the&#xA0;</span><span>definition&#xA0;</span><span>of simple tags</span><span>&#xA0;(</span><span>platform-specific and</span><span>&#xA0;</span><span>map to a single image</span><span>)</span><span>&#xA0;and shared tags</span><span>&#xA0;(</span><span>not platform-specific and&#xA0;</span><span>can map to multiple images</span><span>)</span><span>.</span><span>&#xA0;</span></p><p><span>Because a build agent begins a job in a clean state</span><span>&#xA0;and has no state from its previous run</span><span>, there needs to be an external storage mechanism for the Docker images that are produced</span><span>.&#xA0; For that reason,&#xA0;</span><span>each job pushe</span><span>s the images it has built</span><span>&#xA0;to&#xA0;</span><span>a</span><span>&#xA0;staging location in an</span><span>&#xA0;</span><a href="https://azure.microsoft.com/services/container-registry/"><span>Azure Container Registry (ACR)</span></a><span>&#xA0;</span><span>so</span><span>&#xA0;they can&#xA0;</span><span>later be pulled&#xA0;</span><span>by the agents running&#xA0;</span><span>in&#xA0;</span><span>the test stage</span><span>&#xA0;and eventually published</span><span>.</span><span>&#xA0;&#xA0;</span><span>In some cases, a given image may be used by&#xA0;</span><span>multiple test jobs so having it available&#xA0;</span><span>to be pulled from an external source is necessary.</span><span>&#xA0;</span></p><h3><span>Test Stage</span><span>&#xA0;</span></h3><p><span>Now that&#xA0;</span><span>all</span><span>&#xA0;the images have been built it&#x2019;s time to test them. This is done with a set of smoke tests that verify the basics, such as being able to create and build a project with the SDK image and run it&#xA0;</span><span>with</span><span>&#xA0;the runtime image.&#xA0;</span><span>Even though these tests are very basic, they have sometimes caught product issues and enabled us to halt publishing a .NET Core update</span><span>.</span><span>&#xA0;</span></p><p><span>Like</span><span>&#xA0;the build stage, the test stage is split into a set of&#xA0;</span><span>34 jobs that run in parallel</span><span>.&#xA0;</span><span>Each test job is responsible for testing a&#xA0;</span><span>specific</span><span>&#xA0;.NET Core version&#xA0;</span><span>on a specific operating system version on a specific architecture.&#xA0; Examples of job names include&#xA0;</span><span>&#x201C;</span><span>Test-</span><span>2.1-Windows-NanoServer1809-AMD64&#x201D;,&#xA0;</span><span>&#x201C;</span><span>Test-</span><span>2.2-</span><span>Linux-</span><span>alpine3.9-AMD64</span><span>&#x201D;</span><span>,&#xA0;</span><span>and&#xA0;</span><span>&#x201C;</span><span>Test-</span><span>3.0-</span><span>Linux-</span><span>bionic</span><span>-ARM64v8</span><span>&#x201D;</span><span>.</span><span>&#xA0;&#xA0;</span><span>Notice that</span><span>&#xA0;</span><span>the&#xA0;</span><span>breakdown&#xA0;</span><span>of jobs&#xA0;</span><span>is different</span><span>&#xA0;compared to the build stage&#xA0;</span><span>as the tests have dependencies on images that are different than the build jobs. For example, even though an SDK image might be able to be built independently of the runtime image, both images are needed together in order to test them</span><span>&#xA0;because of how our test scenarios are authored</span><span>.&#xA0;</span><span>T</span><span>here are not separate jobs that test just the runtime image and just the SDK image; rather, there is one job that tests them both for a given platform/architecture/.NET version. That means each test job selectively pulls down only the images it requires from&#xA0;</span><span>the staging location in&#xA0;</span><span>ACR.</span><span>&#xA0;</span></p><h3><span>Publish Stage</span><span>&#xA0;</span></h3><p><span>Once it&#x2019;s known that&#xA0;</span><span>all&#xA0;</span><span>the images are in a good state from the test stage, we can move on to publishing them to</span><span>&#xA0;</span><a href="https://devblogs.microsoft.com/dotnet/net-core-container-images-now-published-to-microsoft-container-registry/"><span>Microsoft Container Registry (MCR)</span></a><span>. Publishing runs relatively quickly (</span><span>the entire</span><span>&#xA0;stage only takes about 3 minutes) because the images are&#xA0;</span><span>efficiently&#xA0;</span><span>transferred</span><span>&#xA0;</span><span>from&#xA0;</span><span>ACR&#xA0;</span><span>to MCR within shared Azure infrastructure</span><span>. MCR detects th</span><span>is transfer</span><span>&#xA0;and makes&#xA0;</span><span>the</span><span>&#xA0;images</span><span>&#xA0;available</span><span>&#xA0;for public consumption</span><span>.</span><span>&#xA0;</span></p><p><span>Included with publishing the images are a&#xA0;</span><span>few other supplemental&#xA0;</span><span>steps</span><span>.&#xA0; The first is</span><span>&#xA0;to publish the&#xA0;</span><a href="https://blog.docker.com/2017/11/multi-arch-all-the-things/"><span>image manifests</span></a><span>&#xA0;to support multi-arch</span><span>&#xA0;</span><span>using the Docker&#xA0;</span><a href="https://github.com/estesp/manifest-tool"><span>manifest tool</span></a><span>.&#xA0;&#xA0;</span><span>Next, the</span><span>&#xA0;README files on&#xA0;</span><a href="https://hub.docker.com/"><span>Docker Hub</span></a><span>&#xA0;are update</span><span>d to reflect the latest content from the repo&#x2019;s README files.&#xA0; Lastly, a</span><span>&#xA0;JSON</span><span>&#xA0;file&#xA0;</span><span>is updated that keeps track of&#xA0;</span><span>metadata about the latest images that have been published.&#xA0; This file serves several purposes</span><span>,&#xA0;</span><span>one of&#xA0;</span><span>which&#xA0;</span><span>is&#xA0;</span><span>to provide a way to determine when we need to&#xA0;</span><span>re-build an image due&#xA0;</span><span>to&#xA0;</span><span>it</span><span>s base image being updated.&#xA0; More on th</span><span>at</span><span>&#xA0;in a future blog post.</span><span>&#xA0;</span></p><h2><span>Conclusion</span><span>&#xA0;</span></h2><p><span>It is a testament to the power and flexibility of Azure Pipelines&#xA0;</span><span>to&#xA0;</span><span>enable us&#xA0;</span><span>to produce Docker images at&#xA0;</span><span>the scale and breadth of platforms that&#xA0;</span><span>we require</span><span>.&#xA0;</span><span>If you&#x2019;re interested</span><span>&#xA0;in the nitty-gritty details</span><span>, check out&#xA0;</span><span>our</span><span>&#xA0;</span><a href="https://github.com/dotnet/docker-tools/tree/master/eng/common/templates"><span>pipeline infrastructure</span></a><span>.</span><span>&#xA0;</span></p><p><span>What are the systems that you have in place for producing your organization&#x2019;s Docker image</span><span>s</span><span>?&#xA0; Did this post spark any ideas on changes you could make to your&#xA0;</span><span>process?&#xA0; Let us know in the comments.</span><span>&#xA0;And if you&#x2019;re a consumer of our Docker images, let us know how we&#x2019;re doing either&#xA0;</span><span>in the comments&#xA0;</span><span>or at&#xA0;</span><span>our</span><span>&#xA0;</span><a href="https://github.com/dotnet/dotnet-docker"><span>GitHub repo</span></a><span>.</span><span>&#xA0;</span></p><p><span>Happy containerizing!</span><span>&#xA0;</span></p></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>