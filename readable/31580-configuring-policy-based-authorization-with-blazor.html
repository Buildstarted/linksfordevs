<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Configuring Policy-based Authorization with Blazor -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Configuring Policy-based Authorization with Blazor</h1><div><div class="post-content"><h2>Securing Your Blazor Apps (Part 4)</h2><hr><p>This is the fourth post in the series: Securing Your Blazor Apps. </p><p><strong>Part 1</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-introduction-to-authentication-with-blazor/">Introduction to Authentication with server-side Blazor</a>‌<br>‌<strong>Part 2</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-authentication-with-clientside-blazor-using-webapi-aspnet-core-identity/">Authentication with client-side Blazor using WebAPI and ASP.NET Core Identity</a><br><strong>Part 3</strong> - <a href="https://chrissainty.com/securing-your-blazor-apps-configuring-role-based-authorization-with-client-side-blazor/">Configuring Role-based Authorization with client-side Blazor</a><br><strong>Part 4</strong> - Configuring Policy-based Authorization with Blazor (this post)</p><hr><p>In <a href="https://chrissainty.com/securing-your-blazor-apps-configuring-role-based-authorization-with-client-side-blazor/">part 3</a> of this series, I showed how to add role based authorization to a client-side Blazor application. In this post, I’m going to show you how to configure the newer, and recommended, policy-based authorization with Blazor.</p><blockquote>All the code for this post is available on <a href="https://github.com/chrissainty/PolicyBasedAuthWithBlazor">GitHub</a>.</blockquote><h2 id="introduction-to-policy-based-authorization">Introduction to Policy-based Authorization</h2><p>Introduced with ASP.NET Core, policy-based authorization allows a much more expressive way of creating authorization rules. The policy model is comprised of three concepts:</p><ul><li><strong>Policy</strong> - Made up of one or more requirements.</li><li><strong>Requirement</strong> - Collection of data parameters which are used by the policy to evaluate the current user principal.</li><li><strong>Handler</strong> - Evaluates the requirements properties to decide if the current user principal has access to the requested resource.</li></ul><p>Policies are most commonly registered at application startup in the <code>Startup</code> classes <code>ConfigureServices</code> method.</p><pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthorization(config =&gt;
    {
        config.AddPolicy("IsDeveloper", policy =&gt; policy.RequireClaim("IsDeveloper", "true"));
    });
}
</code></pre><p>In the example above, the policy <code>IsDeveloper</code> requires that a user have the claim <code>IsDeveloper</code> with a value of <code>true</code>. </p><p>Just as with roles you can apply policies via the <code>Authorize</code> attribute. </p><pre><code class="language-csharp">[Route("api/[controller]")]
[ApiController]
public class SystemController 
{
    [Authorize(Policy = “IsDeveloper”)]
    public IActionResult LoadDebugInfo()
    {
        // ...
    }
}
</code></pre><p>Blazors directives and components also work with policies.</p><pre><code class="language-html">@page "/debug"
@attribute [Authorize(Policy = "IsDeveloper")]
</code></pre><pre><code class="language-html">&lt;AuthorizeView Policy="IsDeveloper"&gt;
    &lt;p&gt;You can only see this if you satisfy the IsDeveloper policy.&lt;/p&gt;
&lt;/AuthorizeView&gt;
</code></pre><h3 id="easier-management">Easier Management</h3><p>The big advantage of policy-based authorization is the improvement to managing authorization within an application. With role-based auth, if we had a couple of roles which were allowed access to protected resources - let’s say <code>admin</code> and <code>moderator</code>. &nbsp;We would need to go to every area they were permitted access and add an <code>Authorize</code> attribute.</p><pre><code class="language-csharp">[Authorize(Roles = "admin,moderator")]
</code></pre><p>This doesn’t seem too bad initially, but what if a new requirement comes in and a third role, <code>superuser</code>, needs the same access? We now need to go round every area and update all of the roles. With policy-based auth we can avoid this. </p><p>We can define a policy in a single place and then apply it once to all the resources which require it. Then when extra roles need to be added, we can just update the policy from the central point without the need to update the individual resources.</p><pre><code>public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthorization(config =&gt;
    {
    config.AddPolicy("IsAdmin", policy =&gt; policy.RequireRole("admin", "moderator", "superuser"));
    });
}
</code></pre><pre><code class="language-csharp">[Authorize(Policy = "IsAdmin")]
</code></pre><h3 id="building-custom-requirements">Building Custom Requirements</h3><p>Policies are very flexible, you can build requirements based on roles, claims or you can even create your own custom requirements. Let’s look at how we can create a custom requirement.</p><p>Normally custom requirements are used when you have complex logic. As mentioned above, we will need to define a <em>requirement</em> and a <em>handler</em> which we then tie together using a policy. </p><p>As an example, let’s create a requirement that checks if a users email address is using a company domain. We need to start by creating a requirement, this class needs to implement the <code>IAuthorizationRequirement</code> interface, which is just an empty marker interface.</p><pre><code class="language-csharp">public class CompanyDomainRequirement : IAuthorizationRequirement
{
    public string CompanyDomain { get; }

    public CompanyDomainRequirement(string companyDomain)
    {
        CompanyDomain = companyDomain;
    }
}
</code></pre><p> Next we need to create a handler for our requirement. This needs to inherit from <code>AuthorizationHandler&lt;T&gt;</code> where <code>T</code> is the requirement to be handled. </p><pre><code class="language-csharp">public class CompanyDomainHandler : AuthorizationHandler&lt;CompanyDomainRequirement&gt;
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, CompanyDomainRequirement requirement)
    {
        if (!context.User.HasClaim(c =&gt; c.Type == ClaimTypes.Email))
        {
            return Task.CompletedTask;
        }
        
        var emailAddress = context.User.FindFirst(c =&gt; c.Type == ClaimTypes.Email).Value;
        
        if (emailAddress.EndsWith(requirement.CompanyDomain))
        {
            return context.Succeed(requirement);
        }
        
        return Task.CompletedTask;
    }
}
</code></pre><p>In the code above, we check if an email claim is present. If it is, then we check if it ends with the domain specified in the requirement. If it does then we return a success, otherwise we just return.</p><p>We just need to wire up our requirement with a policy and register the <code>CompanyDomainHandler</code> with the dependency injection container.</p><pre><code class="language-csharp">public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthorization(config =&gt;
    {
        config.AddPolicy("IsCompanyUser", policy =&gt;
            policy.Requirements.Add(new CompanyDomainRequirement("newco.com")));
    });

    services.AddSingleton&lt;IAuthorizationHandler, CompanyDomainHandler&gt;();
}
</code></pre><p>For more in-depth information on custom requirements I recommend checking out the <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-3.0#authorization-handlers">official docs</a>.</p><h2 id="using-policies-with-blazor">Using policies with Blazor</h2><p>Now we have an understanding of what policies are, let’s look at how we can use them in an application. </p><p>We’re going to swap the client-side Blazor application from <a href="https://chrissainty.com/securing-your-blazor-apps-configuring-role-based-authorization-with-client-side-blazor/">part 3</a> over to policy based authorization. As part of doing this we’re going to see another advantage of policy based authorization, which is the ability to define policies in a shared project and reference them on both the server and the client.</p><h3 id="creating-shared-policies">Creating shared policies</h3><p>We’re going to start by creating the policies in the shared project. We need to install the <code>Microsoft.AspNetCore.Authorization</code> package from NuGet in order to do this. </p><p>Once that’s installed create a new class called <code>Policies</code> with the following code.</p><pre><code class="language-csharp">public static class Policies
{
    public const string IsAdmin = "IsAdmin";
    public const string IsUser = "IsUser";

    public static AuthorizationPolicy IsAdminPolicy()
    {
        return new AuthorizationPolicyBuilder().RequireAuthenticatedUser()
                                               .RequireRole("Admin")
                                               .Build();
    }

    public static AuthorizationPolicy IsUserPolicy()
    {
        return new AuthorizationPolicyBuilder().RequireAuthenticatedUser()
                                               .RequireRole("User")
                                               .Build();
    }
}
</code></pre><p>We start by defining a couple of constants - <code>IsAdmin</code> and <code>IsUser</code>. We’ll use these in a bit when registering the policies. Then there are the two policies themselves, <code>IsAdminPolicy</code> and <code>IsUserPolicy</code>. Here we’re using the <code>AuthorizationPolicyBuilder</code> to define each policy, both require the user to be authenticated then be in either the <code>Admin</code> role or <code>User</code> role, depending on the policy.</p><h3 id="configuring-the-server">Configuring the server</h3><p>Now we have defined our policies we need to tell our server application to use them. We’ll start by registering the policies in <code>ConfigureServices</code> in the <code>Startup</code> class. Add the following code under the existing call to <code>AddAuthentication</code>.</p><pre><code class="language-csharp">services.AddAuthorization(config =&gt;
{
    config.AddPolicy(Policies.IsAdmin, Policies.IsAdminPolicy());
    config.AddPolicy(Policies.IsUser, Policies.IsUserPolicy());
});
</code></pre><p>The code is pretty self explanatory, we’re registering each policy and using the constants we defined in the <code>Policies</code> class to declare their names, which saves using magic strings.</p><p>If we move over to the <code>SampleDataController</code> we can update the <code>Authorize</code> attribute to use the new <code>IsAdmin</code> policy instead of the old role. </p><pre><code class="language-csharp">[Authorize(Policy = Policies.IsAdmin)]
[Route("api/[controller]")]
public class SampleDataController : Controller
</code></pre><p>Again, we can use our name constant to avoid the magic strings.</p><h3 id="configuring-the-client">Configuring the client</h3><p>Our server is now using the new policies we defined, all that’s left to do is to swap over our Blazor client to use them as well.</p><p>As with the server we’ll start by registering the policies in <code>ConfigureServices</code> in the <code>Startup</code> class. We already have a call to <code>AddAuthorizationCore</code> so we just need to update it.</p><pre><code class="language-csharp">services.AddAuthorizationCore(config =&gt;
{
    config.AddPolicy(Policies.IsAdmin, Policies.IsAdminPolicy());
    config.AddPolicy(Policies.IsUser, Policies.IsUserPolicy());
});
</code></pre><p>In <code>Index.razor</code>, update the <code>AuthorizeView</code> component to use policies - still avoiding the magic strings.</p><pre><code class="language-html">&lt;AuthorizeView Policy="@Policies.IsUser"&gt;
    &lt;p&gt;You can only see this if you satisfy the IsUser policy.&lt;/p&gt;
&lt;/AuthorizeView&gt;

&lt;AuthorizeView Policy="@Policies.IsAdmin"&gt;
    &lt;p&gt;You can only see this if you satisfy the IsAdmin policy.&lt;/p&gt;
&lt;/AuthorizeView&gt;
</code></pre><p>Finally, update <code>FetchData.razor</code>s <code>Authorize</code> attribute.</p><pre><code class="language-html">@attribute [Authorize(Policy = Policies.IsAdmin)]
</code></pre><p>That’s it! Our application is now moved over to policy-based authorization. We now have a more flexible authorization system which can use roles, claims, custom policies or any mixture of the above.</p><p>I’ve not specifically talked about server-side Blazor for the simple reason that what we’ve done above should translate into server-side Blazor without any issues. However, I have included a server-side example in the code sample which accompanies this post on <a href="https://github.com/chrissainty/PolicyBasedAuthWithBlazor">GitHub</a>.</p><p><strong>Note:</strong> The server-side sample currently has a build failure caused by <a href="https://github.com/aspnet/AspNetCore/issues/12676">this issue</a>.</p><h2 id="summary">Summary</h2><p>In this post, we’ve looked at policy-based authorization in ASP.NET Core and Blazor. We’ve looked at some of the advantages of using policy-based authorization over the more legacy roles-based authorization. Then we migrated the application from <a href="https://chrissainty.com/securing-your-blazor-apps-configuring-role-based-authorization-with-client-side-blazor/">part 3</a> from roles-based auth to policy-based auth.</p><hr><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>