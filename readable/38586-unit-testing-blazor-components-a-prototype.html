<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Unit testing Blazor components - a prototype -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Unit testing Blazor components - a prototype</h1>
    <div class="body"> <p>One of our design goals for Blazor is to offer an absolutely first-rate testing system. Writing tests for your components should be natural, produtive, and satisfying. Those tests should run fast and reliably. We&#x2019;ve have <a href="https://github.com/aspnet/AspNetCore/issues/5458">a placeholder issue</a> for this, but it&#x2019;s out of scope for the initial (.NET Core 3.0) release.</p> <p>So, I think it&#x2019;s time to start clarifying how this can work.</p> <h3 id="goals">Goals</h3> <p>We do have a lot of experience writing tests for Blazor components. While building the framework itself, a substantial portion of the code we write is:</p> <ul> <li> <p><strong>Unit tests</strong>, which directly execute methods on components and renderers, and make assertions about the resulting render batches and UI diffs inside them. These tests are extremely <strong>fast</strong> and <strong>robust</strong>, but unfortunately also extremely <strong>low-level</strong>. You wouldn&#x2019;t normally want to express your tests in terms of Blazor&#x2019;s low-level internal UI diff description format.</p> </li> <li> <p><strong>End-to-end (E2E) tests</strong>, which use Selenium to control a headless browser instance and make assertions about the state of the browser DOM. These tests are <strong>high-level</strong> (in that they talk about familiar concepts like HTML and actions like <em>clicking</em>), but they are also very <strong>slow</strong> (each one can take multiple seconds to run) and great care has to be taken to make them robust and not depend on the timings of async UI updates. It&#x2019;s also not really possible to mock external services in these tests.</p> </li>
</ul> <p>We think it will be possible for Blazor to include a set of test helpers that give you the benefits of both approaches, and the drawbacks of neither.</p> <p>The core idea is simply to provide unit test helpers that let you mount your components inside a &#x201C;test renderer&#x201D;. This will behave like browser automation, but <em>no actual browser will be involved</em> (not even a headless one). It&#x2019;s just pure .NET code, so runs with the speed and robustness of pure unit tests.</p> <h3 id="a-prototype">A prototype</h3> <p>To get the conversation going, I&#x2019;ve put <a href="https://github.com/SteveSandersonMS/BlazorUnitTestingPrototype">a prototype here</a>. Let&#x2019;s take a look.</p> <p>Consider the classic &#x201C;counter&#x201D; example, in a file called <code class="highlighter-rouge">Counter.razor</code>:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>Counter<span class="nt">&lt;/h1&gt;</span> <span class="nt">&lt;p&gt;</span>Current count: @currentCount<span class="nt">&lt;/p&gt;</span> <span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">&quot;btn btn-primary&quot;</span> <span class="err">@</span><span class="na">onclick=</span><span class="s">&quot;IncrementCount&quot;</span><span class="nt">&gt;</span>Increment<span class="nt">&lt;/button&gt;</span>

@code {
    int currentCount = 0;

    void IncrementCount()
    {
        currentCount++;
    }
}
</code></pre></div></div> <p>My prototype unit test package, <code class="highlighter-rouge">Microsoft.AspNetCore.Components.Testing</code>, provides a class <code class="highlighter-rouge">TestHost</code> that lets you mount components and interact with them inside any traditional unit testing system (e.g., xUnit, NUnit). So if your unit test project has a reference to the application project, you can write tests as follows:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">CounterTest</span>
<span class="p">{</span> <span class="k">private</span> <span class="n">TestHost</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TestHost</span><span class="p">();</span> <span class="p">[</span><span class="n">Fact</span><span class="p">]</span> <span class="k">public</span> <span class="k">void</span> <span class="nf">CountStartsAtZero</span><span class="p">()</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">host</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">Counter</span><span class="p">&gt;();</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">&quot;Current count: 0&quot;</span><span class="p">,</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">).</span><span class="n">InnerText</span><span class="p">);</span> <span class="p">}</span> <span class="p">[</span><span class="n">Fact</span><span class="p">]</span> <span class="k">public</span> <span class="k">void</span> <span class="nf">CanIncrementCount</span><span class="p">()</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">host</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">Counter</span><span class="p">&gt;();</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;button&quot;</span><span class="p">).</span><span class="nf">Click</span><span class="p">();</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">&quot;Current count: 1&quot;</span><span class="p">,</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">).</span><span class="n">InnerText</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>As you can see, <code class="highlighter-rouge">TestHost</code> is a way to render components under unit tests. You can find rendered elements in terms of CSS selectors, then you can either make assertions about them or trigger events on them. This is very much like traditional browser automation, but is implemented without using any actual browser.</p> <p><code class="highlighter-rouge">TestHost</code> also provides a way to supply DI services, such as mock instances, so you can describe how your component must behave when external services do certain things (e.g., when authentication or data access fails). As an example of that, consider the classic &#x201C;weather forecasts&#x201D; page (see <code class="highlighter-rouge">FetchData.razor</code> in any brand-new Blazor project). This uses <code class="highlighter-rouge">HttpClient</code> to fetch and display data from an external source. You could write a unit test for that as follows:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">FetchDataTest</span>
<span class="p">{</span> <span class="k">private</span> <span class="n">TestHost</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TestHost</span><span class="p">();</span> <span class="p">[</span><span class="n">Fact</span><span class="p">]</span> <span class="k">public</span> <span class="k">void</span> <span class="nf">DisplaysLoadingStateThenRendersSuppliedData</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Set up a mock HttpClient that we&apos;ll be able to use to test arbitrary responses</span> <span class="kt">var</span> <span class="n">req</span> <span class="p">=</span> <span class="n">host</span><span class="p">.</span><span class="nf">AddMockHttp</span><span class="p">().</span><span class="nf">Capture</span><span class="p">(</span><span class="s">&quot;/sample-data/weather.json&quot;</span><span class="p">);</span> <span class="c1">// Initially shows loading state</span> <span class="kt">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">host</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">FetchData</span><span class="p">&gt;();</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="s">&quot;Loading...&quot;</span><span class="p">,</span> <span class="n">component</span><span class="p">.</span><span class="nf">GetMarkup</span><span class="p">());</span> <span class="c1">// Now simulate a response from the HttpClient</span> <span class="n">host</span><span class="p">.</span><span class="nf">WaitForNextRender</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">req</span><span class="p">.</span><span class="nf">SetResult</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="k">new</span> <span class="n">FetchData</span><span class="p">.</span><span class="n">WeatherForecast</span> <span class="p">{</span> <span class="n">Summary</span> <span class="p">=</span> <span class="s">&quot;First&quot;</span> <span class="p">},</span> <span class="k">new</span> <span class="n">FetchData</span><span class="p">.</span><span class="n">WeatherForecast</span> <span class="p">{</span> <span class="n">Summary</span> <span class="p">=</span> <span class="s">&quot;Second&quot;</span> <span class="p">},</span> <span class="p">}));</span> <span class="c1">// Now we should be displaying the data</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">DoesNotContain</span><span class="p">(</span><span class="s">&quot;Loading...&quot;</span><span class="p">,</span> <span class="n">component</span><span class="p">.</span><span class="nf">GetMarkup</span><span class="p">());</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Collection</span><span class="p">(</span><span class="n">component</span><span class="p">.</span><span class="nf">FindAll</span><span class="p">(</span><span class="s">&quot;tbody tr&quot;</span><span class="p">),</span> <span class="n">row</span> <span class="p">=&gt;</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="s">&quot;First&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">.</span><span class="n">OuterHtml</span><span class="p">),</span> <span class="n">row</span> <span class="p">=&gt;</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="s">&quot;Second&quot;</span><span class="p">,</span> <span class="n">row</span><span class="p">.</span><span class="n">OuterHtml</span><span class="p">));</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="lets-do-some-tdd">Let&#x2019;s do some TDD</h3> <p>You probably know this, but to recap: Test-driven Development (TDD) is the process of writing software through tests. For each behavior your software should have, you first write a unit test (which fails, because your software doesn&#x2019;t have that behavior yet), then you implement the behavior, and then you see that your test now passes.</p> <p>Whether or not TDD really works depends a lot on whether the type of software you&#x2019;re writing is amenable to unit testing and whether the technologies you&#x2019;re using give you good ways of isolating units of code and a fast enough feedback loop.</p> <p>My hope, then, is that Blazor can offer unit test helpers that give you what you need so that TDD is not only viable but even enjoyable, even when writing components with very detailed user interactions.</p> <p>As an experiment, pretend you&#x2019;re building a &#x201C;todo list&#x201D; component in Blazor. It needs to let users type in items, add them to a list, and check them off when they are done. Pretty obvious stuff. You might start with the following <code class="highlighter-rouge">TodoList.razor</code> component:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@page &quot;/todo&quot; <span class="nt">&lt;h1&gt;</span>Todo<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;ul&gt;</span> @foreach (var item in items) { <span class="nt">&lt;li&gt;</span>@item.Text<span class="nt">&lt;/li&gt;</span> }
<span class="nt">&lt;/ul&gt;</span> <span class="nt">&lt;form&gt;</span> <span class="nt">&lt;input</span> <span class="na">placeholder=</span><span class="s">&quot;Type something...&quot;</span> <span class="nt">/&gt;</span> <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span><span class="nt">&gt;</span>Add<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/form&gt;</span> @code { private List<span class="nt">&lt;TodoItem&gt;</span> items = new List<span class="nt">&lt;TodoItem&gt;</span>();

    class TodoItem
    {
        public string Text { get; set; }
        public bool IsDone { get; set; }
    }
}
</code></pre></div></div> <p><img src="/wp-content/uploads/2019/08/29/todo-initial.png" alt="Initial todo list"></p> <p>Currently, it doesn&#x2019;t do anything. Typing and clicking &#x201C;Add&#x201D; does nothing. Let&#x2019;s write a unit test describing the behavior we want. This would go into a separate unit testing project that references the app project:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">TodoListTest</span>
<span class="p">{</span> <span class="k">private</span> <span class="n">TestHost</span> <span class="n">host</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TestHost</span><span class="p">();</span> <span class="p">[</span><span class="n">Fact</span><span class="p">]</span> <span class="k">public</span> <span class="k">void</span> <span class="nf">InitiallyDisplaysNoItems</span><span class="p">()</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">host</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">TodoList</span><span class="p">&gt;();</span> <span class="kt">var</span> <span class="n">items</span> <span class="p">=</span> <span class="n">component</span><span class="p">.</span><span class="nf">FindAll</span><span class="p">(</span><span class="s">&quot;li&quot;</span><span class="p">);</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Empty</span><span class="p">(</span><span class="n">items</span><span class="p">);</span> <span class="p">}</span> <span class="p">[</span><span class="n">Fact</span><span class="p">]</span> <span class="k">public</span> <span class="k">void</span> <span class="nf">CanAddItem</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Arrange</span> <span class="kt">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">host</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">TodoList</span><span class="p">&gt;();</span> <span class="c1">// Act</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;input&quot;</span><span class="p">).</span><span class="nf">Change</span><span class="p">(</span><span class="s">&quot;My super item&quot;</span><span class="p">);</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;form&quot;</span><span class="p">).</span><span class="nf">Submit</span><span class="p">();</span> <span class="c1">// Assert</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Collection</span><span class="p">(</span><span class="n">component</span><span class="p">.</span><span class="nf">FindAll</span><span class="p">(</span><span class="s">&quot;li&quot;</span><span class="p">),</span> <span class="n">li</span> <span class="p">=&gt;</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">&quot;My super item&quot;</span><span class="p">,</span> <span class="n">li</span><span class="p">.</span><span class="n">InnerText</span><span class="p">.</span><span class="nf">Trim</span><span class="p">()));</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>If you run this either on the command line with <code class="highlighter-rouge">dotnet test</code> or in VS&#x2019;s built-in runner, you&#x2019;ll see that <code class="highlighter-rouge">InitiallyDisplaysNoItems</code> passes, but <code class="highlighter-rouge">CanAddItem</code> fails (because we haven&#x2019;t yet implemented it):</p> <p><img src="/wp-content/uploads/2019/08/29/todo-can-add-fail.png" alt="First test failure"></p> <p>The actual reported failure comes from our call to <code class="highlighter-rouge">.Change</code> - it reports <em>The element does not have an event handler for the event &#x2018;onchange&#x2019;.</em>. This makes sense because we&#x2019;re trying to trigger &#x201C;change&#x201D; on the <code class="highlighter-rouge">input</code>, but there&#x2019;s nothing bound to that element.</p> <p>Let&#x2019;s implement the adding behavior, by using <code class="highlighter-rouge">@bind</code> to wire up a &#x201C;change&#x201D; listener on the <code class="highlighter-rouge">input</code>, plus an <code class="highlighter-rouge">@onsubmit</code> listener on the <code class="highlighter-rouge">form</code> that actually adds items:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;form</span> <span class="err">@</span><span class="na">onsubmit=</span><span class="s">&quot;AddItem&quot;</span><span class="nt">&gt;</span> <span class="nt">&lt;input</span> <span class="na">placeholder=</span><span class="s">&quot;Type something...&quot;</span> <span class="err">@</span><span class="na">bind=</span><span class="s">&quot;newItemText&quot;</span> <span class="nt">/&gt;</span> <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">&quot;submit&quot;</span><span class="nt">&gt;</span>Add<span class="nt">&lt;/button&gt;</span>
<span class="nt">&lt;/form&gt;</span> @code { private string newItemText; private List<span class="nt">&lt;TodoItem&gt;</span> items = new List<span class="nt">&lt;TodoItem&gt;</span>();

    void AddItem()
    {
        items.Add(new TodoItem { Text = newItemText });
    }

    class TodoItem { /* Leave as before */ }
}
</code></pre></div></div> <p>And now, the test passes:</p> <p><img src="/wp-content/uploads/2019/08/29/todo-can-add-pass.png" alt="First test pass"></p> <p>OK, that&#x2019;s good, but I just remembered something else: each time you submit an item, we should auto-clear out the textbox so you can type in the next one. To see whether this already happens, try updating the unit test to check the textbox becomes empty:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">CanAddItem</span><span class="p">()</span>
<span class="p">{</span> <span class="c1">// ... leave the existing code here, and just add the following ...</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Empty</span><span class="p">(</span><span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;input&quot;</span><span class="p">).</span><span class="nf">GetAttributeValue</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>Oops, no - now this test fails with <em>Assert.Empty() Failure</em>. This shows we&#x2019;re not clearing out the textbox after add. To implement this, update the <code class="highlighter-rouge">AddItem</code> method:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">AddItem</span><span class="p">()</span>
<span class="p">{</span> <span class="n">items</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">TodoItem</span> <span class="p">{</span> <span class="n">Text</span> <span class="p">=</span> <span class="n">newItemText</span> <span class="p">});</span> <span class="n">newItemText</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>&#x2026; and now the test passes. We&#x2019;ve implemented the basics of adding items:</p> <p><img src="/wp-content/uploads/2019/08/29/todo-adding.gif" alt="Adding todo items"></p> <p>Now, what about having checkboxes to mark items as done, and counting the number of remaining items? We could express that in a unit test by saying there must be an element with CSS class <code class="highlighter-rouge">.remaining</code> that shows the count, and that each <code class="highlighter-rouge">li</code> should contain a checkbox you can toggle:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">[Fact]</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">ShowsCountOfRemainingItems</span><span class="p">()</span>
<span class="p">{</span> <span class="c1">// Arrange: list with two items</span> <span class="kt">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">host</span><span class="p">.</span><span class="n">AddComponent</span><span class="p">&lt;</span><span class="n">TodoList</span><span class="p">&gt;();</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;input&quot;</span><span class="p">).</span><span class="nf">Change</span><span class="p">(</span><span class="s">&quot;Item 1&quot;</span><span class="p">);</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;form&quot;</span><span class="p">).</span><span class="nf">Submit</span><span class="p">();</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;input&quot;</span><span class="p">).</span><span class="nf">Change</span><span class="p">(</span><span class="s">&quot;Item 2&quot;</span><span class="p">);</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;form&quot;</span><span class="p">).</span><span class="nf">Submit</span><span class="p">();</span> <span class="c1">// Assert 1: shows initial &apos;remaining&apos; count</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">,</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;.remaining&quot;</span><span class="p">).</span><span class="n">InnerText</span><span class="p">);</span> <span class="c1">// Act/Assert 2: updates count when items are checked</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;li:first-child input[type=checkbox]&quot;</span><span class="p">).</span><span class="nf">Change</span><span class="p">(</span><span class="k">true</span><span class="p">);</span> <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">,</span> <span class="n">component</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">&quot;.remaining&quot;</span><span class="p">).</span><span class="n">InnerText</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Of course, this initially fails, because there is no <code class="highlighter-rouge">.remaining</code> item. But we can implement the behavior by changing the markup in <code class="highlighter-rouge">TodoList.razor</code>:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>Todo (<span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;remaining&quot;</span><span class="nt">&gt;</span>@items.Count(x =&gt; !x.IsDone)<span class="nt">&lt;/span&gt;</span>)<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;ul&gt;</span> @foreach (var item in items) { <span class="nt">&lt;li&gt;</span> <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;checkbox&quot;</span> <span class="err">@</span><span class="na">bind=</span><span class="s">&quot;item.IsDone&quot;</span> <span class="nt">/&gt;</span> @item.Text <span class="nt">&lt;/li&gt;</span> }
<span class="nt">&lt;/ul&gt;</span>
</code></pre></div></div> <p>&#x2026; and now the test passes. Not surprisingly, if you run the app in an actual browser, you can also see it working:</p> <p><img src="/wp-content/uploads/2019/08/29/todo-toggling.gif" alt="Toggling todo items"></p> <h3 id="status">Status</h3> <p>So far, this is just a prototype, and we don&#x2019;t plan to ship anything of this kind in the 3.0 release this year. My expectation is that we&#x2019;ll be looking for your feedback as this prototype evolves over time. Maybe the final result will look just like this, or maybe it will be unrecognisably different in the end.</p> <p>At some point I expect we will ship unit test helpers in a preview package so you can get started using them for real, and ultimately have them in the box with the 5.0 release in late 2020.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>