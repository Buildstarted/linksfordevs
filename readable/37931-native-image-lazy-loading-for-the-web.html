<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Native image lazy-loading for the web! -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Native image lazy-loading for the web!</h1><div><div id="post-body" class=""><p>In this post, we'll look at the new <a href="https://github.com/scott-little/lazyload"><code>loading</code></a> attribute which brings native <code>&lt;img&gt;</code> and <code>&lt;iframe&gt;</code> lazy-loading to the web!. For the curious, here's a sneak preview of it in action:</p><div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"celebration.jpg"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="na">alt=</span><span class="s">"..."</span><span class="nt">/&gt;</span><span class="nt">&lt;iframe</span><span class="na">src=</span><span class="s">"video-player.html"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="nt">&gt;&lt;/iframe&gt;</span></code></pre></div><p>We are hoping to ship support for <code>loading</code> in ~<a href="https://chromestatus.com/feature/5645767347798016">Chrome 75</a> and are working on a deep-dive of the feature we'll publish soon. Until then, let's dive into how <code>loading</code> works.</p><h2>Introduction</h2><p>Web pages often contain a large number of images, which contribute to data-usage, <a href="https://httparchive.org/reports/state-of-images">page-bloat</a> and how fast a page can load. Many of these images are offscreen, requiring a user to scroll in order to view them. </p><p>Historically, to limit the impact offscreen images have on page load times, developers have needed to use a JavaScript library (like <a href="https://github.com/aFarkas/lazysizes">LazySizes</a>) in order to defer fetching these images until a user scrolls near them.</p><figure><img data-src="/../assets/images/without-lazyload@2x.png" class="lazyload"><figcaption>A page loading 211 images. The version without lazy-loading fetches 10MB of image data. The lazy-loading version (using LazySizes) loads only 250KB upfront - other images are fetched as the user scrolls through the experience. See <a href="https://webpagetest.org/video/compare.php?tests=190406_2K_30b9b9cd6b48735a41bce2daee27b7f5,190406_6R_4ce0ac65b7e11d2e132e4ea8d887edd9">WPT</a>.</figcaption></figure><p>What if the browser could avoid loading these offscreen images for you? This would help content in the view-port load quicker, reduce overall network data usage and on lower-end devices, reduce memory usage. Well, I'm happy to share that this will soon be possible with the new <code>loading</code> attribute for images and iframes.</p><h2>The <code>loading</code> attribute</h2><p>The <code>loading</code> attribute allows a browser to defer loading offscreen images and iframes until users scroll near them. <code>loading</code> supports three values:</p><ul><li><strong><code>lazy</code></strong>: is a good candidate for lazy loading. </li><li><strong><code>eager</code></strong>: is not a good candidate for lazy loading. Load right away.</li><li><strong><code>auto</code></strong>: browser will determine whether or not to lazily load.</li></ul><p>Not specifying the attribute at all will have the same impact as setting <code>loading=auto</code>.</p><p><img data-src="/../assets/images/loading-attribute@2x.png" class="lazyload"></p><p>The <code>loading</code> attribute for <code>&lt;img&gt;</code> and <code>&lt;iframe&gt;</code> is being worked on as part of the 
<a href="https://github.com/whatwg/html/pull/3752">HTML standard</a>. </p><h3>Examples</h3><p>The <code>loading</code> attribute works on <code>&lt;img&gt;</code> (including with <code>srcset</code> and inside <code>&lt;picture&gt;</code>) as well as on <code>&lt;iframe&gt;</code>:</p><div class="highlight"><pre><code class="language-html" data-lang="html"><span class="c">&lt;!-- Lazy-load an offscreen image when the user scrolls near it --&gt;</span><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"unicorn.jpg"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="na">alt=</span><span class="s">".."</span><span class="nt">/&gt;</span><span class="c">&lt;!-- Load an image right away instead of lazy-loading --&gt;</span><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"unicorn.jpg"</span><span class="na">loading=</span><span class="s">"eager"</span><span class="na">alt=</span><span class="s">".."</span><span class="nt">/&gt;</span><span class="c">&lt;!-- Browser decides whether or not to lazy-load the image --&gt;</span><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"unicorn.jpg"</span><span class="na">loading=</span><span class="s">"auto"</span><span class="na">alt=</span><span class="s">".."</span><span class="nt">/&gt;</span><span class="c">&lt;!-- Lazy-load images in &lt;picture&gt;. &lt;img&gt; is the one driving image </span><span class="c">loading so &lt;picture&gt; and srcset fall off of that --&gt;</span><span class="nt">&lt;picture&gt;</span><span class="nt">&lt;source</span><span class="na">media=</span><span class="s">"(min-width: 40em)"</span><span class="na">srcset=</span><span class="s">"big.jpg 1x, big-hd.jpg 2x"</span><span class="nt">&gt;</span><span class="nt">&lt;source</span><span class="na">srcset=</span><span class="s">"small.jpg 1x, small-hd.jpg 2x"</span><span class="nt">&gt;</span><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"fallback.jpg"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="nt">&gt;</span><span class="nt">&lt;/picture&gt;</span><span class="c">&lt;!-- Lazy-load an image that has srcset specified --&gt;</span><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"small.jpg"</span><span class="na">srcset=</span><span class="s">"large.jpg 1024w, medium.jpg 640w, small.jpg 320w"</span><span class="na">sizes=</span><span class="s">"(min-width: 36em) 33.3vw, 100vw"</span><span class="na">alt=</span><span class="s">"A rad wolf"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="nt">&gt;</span><span class="c">&lt;!-- Lazy-load an offscreen iframe when the user scrolls near it --&gt;</span><span class="nt">&lt;iframe</span><span class="na">src=</span><span class="s">"video-player.html"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="nt">&gt;&lt;/iframe&gt;</span></code></pre></div><p>The exact heuristics for "when the user scrolls near" is left up to the browser. In general, our hope is that browsers will start fetching deferred images and iframe content a little before it comes into the viewport. This will increase the change the image or iframe is done loading by the time the user has scrolled to them.</p><p>Note: I <a href="https://github.com/whatwg/html/pull/3752#issuecomment-478200976">suggested</a> we name this the <code>loading</code> attribute as its naming aligns closer with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decoding"><code>decoding</code></a> attribute. Previous proposals, such as the <code>lazyload</code> attribute didn't make it as we needed to support multiple values (<code>lazy</code>, <code>eager</code> and <code>auto</code>).</p><h2>Feature detection</h2><p>We've kept in mind the importance of being able to fetch and apply a JavaScript library for lazy-loading (for the cross-browser support). Support for <code>loading</code> can be feature-detected as follows:</p><div class="highlight"><pre><code class="language-html" data-lang="html"><span class="nt">&lt;script&gt;</span><span class="k">if</span><span class="p">(</span><span class="s1">'loading'</span><span class="k">in</span><span class="nx">HTMLImageElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span><span class="p">{</span><span class="c1">// Browser supports `loading`..</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">// Fetch and apply a polyfill/JavaScript library</span><span class="c1">// for lazy-loading instead.</span><span class="p">}</span><span class="nt">&lt;/script&gt;</span></code></pre></div><p>Note: You can also use <code>loading</code> as a progressive enhancement. Browsers that support the attribute can get the new lazy-loading behavior with <code>loading=lazy</code> and those that don't will still have images load.</p><h3>Cross-browser image lazy-loading</h3><p>If cross-browser support for lazy-loading images is important, it's not enough to just feature-detect and lazy-load a library if you're using <code>&lt;img src=unicorn.jpg loading=lazy /&gt;</code> in the markup. </p><p>The markup needs to use something like <code>&lt;img data-src=unicorn.jpg /&gt;</code> (rather than <code>src</code>, <code>srcset</code> or <code>&lt;source&gt;</code>) to avoid triggering an eager load in browsers that don't support the new attribute. JavaScript can be used to change those attributes to the proper ones if <code>loading</code> is supported and load a library if not. You could think of this as hybrid lazy-loading.</p><p>Below is an example of what this could look like. </p><ul><li>In-viewport / above-the-fold images are regular <code>&lt;img&gt;</code> tags. A <code>data-src</code> would defeat the preload scanner so we want to avoid it for everything likely to be in the viewport.</li><li>We use <code>data-src</code> on images to avoid an eager load in unsupported browsers. If <code>loading</code> is supported, we swap <code>data-src</code> for <code>src</code>.</li><li>If <code>loading</code> is not supported, we load a fallback (LazySizes) and initiate it. Here, we use <code>class=lazyload</code> as a way to indicate to LazySizes images we want to be lazily-loaded.</li></ul><div class="highlight"><pre><code class="language-html" data-lang="html"><span class="c">&lt;!-- Let's load this in-viewport image normally --&gt;</span><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"hero.jpg"</span><span class="na">alt=</span><span class="s">".."</span><span class="nt">/&gt;</span><span class="c">&lt;!-- Let's lazy-load the rest of these images --&gt;</span><span class="nt">&lt;img</span><span class="na">data-src=</span><span class="s">"unicorn.jpg"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="na">alt=</span><span class="s">".."</span><span class="na">class=</span><span class="s">"lazyload"</span><span class="nt">/&gt;</span><span class="nt">&lt;img</span><span class="na">data-src=</span><span class="s">"cats.jpg"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="na">alt=</span><span class="s">".."</span><span class="na">class=</span><span class="s">"lazyload"</span><span class="nt">/&gt;</span><span class="nt">&lt;img</span><span class="na">data-src=</span><span class="s">"dogs.jpg"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="na">alt=</span><span class="s">".."</span><span class="na">class=</span><span class="s">"lazyload"</span><span class="nt">/&gt;</span><span class="nt">&lt;script&gt;</span><span class="k">if</span><span class="p">(</span><span class="s1">'loading'</span><span class="k">in</span><span class="nx">HTMLImageElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span><span class="p">{</span><span class="kr">const</span><span class="nx">images</span><span class="o">=</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">"img.lazyload"</span><span class="p">);</span><span class="nx">images</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">img</span><span class="o">=&gt;</span><span class="p">{</span><span class="nx">img</span><span class="p">.</span><span class="nx">src</span><span class="o">=</span><span class="nx">img</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">src</span><span class="p">;</span><span class="p">});</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">// Dynamically import the LazySizes library</span><span class="kd">let</span><span class="nx">script</span><span class="o">=</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">"script"</span><span class="p">);</span><span class="nx">script</span><span class="p">.</span><span class="nx">async</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span><span class="nx">script</span><span class="p">.</span><span class="nx">src</span><span class="o">=</span><span class="s2">"https://cdnjs.cloudflare.com/ajax/libs/lazysizes/4.1.8/lazysizes.min.js"</span><span class="p">;</span><span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span><span class="p">}</span><span class="nt">&lt;/script&gt;</span></code></pre></div><p>Here's an alternative to the above that relies on <a href="https://developers.google.com/web/updates/2017/11/dynamic-import">dynamic import</a> to perform the same fallback library fetching:</p><div class="highlight"><pre><code class="language-html" data-lang="html"><span class="c">&lt;!-- Let's load this in-viewport image normally --&gt;</span><span class="nt">&lt;img</span><span class="na">src=</span><span class="s">"hero.jpg"</span><span class="na">alt=</span><span class="s">".."</span><span class="nt">/&gt;</span><span class="c">&lt;!-- Let's lazy-load the rest of these images --&gt;</span><span class="nt">&lt;img</span><span class="na">data-src=</span><span class="s">"unicorn.jpg"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="na">alt=</span><span class="s">".."</span><span class="na">class=</span><span class="s">"lazyload"</span><span class="nt">/&gt;</span><span class="nt">&lt;img</span><span class="na">data-src=</span><span class="s">"cats.jpg"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="na">alt=</span><span class="s">".."</span><span class="na">class=</span><span class="s">"lazyload"</span><span class="nt">/&gt;</span><span class="nt">&lt;img</span><span class="na">data-src=</span><span class="s">"dogs.jpg"</span><span class="na">loading=</span><span class="s">"lazy"</span><span class="na">alt=</span><span class="s">".."</span><span class="na">class=</span><span class="s">"lazyload"</span><span class="nt">/&gt;</span><span class="nt">&lt;script&gt;</span><span class="p">(</span><span class="nx">async</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="s1">'loading'</span><span class="k">in</span><span class="nx">HTMLImageElement</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span><span class="p">{</span><span class="kr">const</span><span class="nx">images</span><span class="o">=</span><span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s2">"img.lazyload"</span><span class="p">);</span><span class="nx">images</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">img</span><span class="o">=&gt;</span><span class="p">{</span><span class="nx">img</span><span class="p">.</span><span class="nx">src</span><span class="o">=</span><span class="nx">img</span><span class="p">.</span><span class="nx">dataset</span><span class="p">.</span><span class="nx">src</span><span class="p">;</span><span class="p">});</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">// Dynamically import the LazySizes library</span><span class="kr">const</span><span class="nx">lazySizesLib</span><span class="o">=</span><span class="nx">await</span><span class="kr">import</span><span class="p">(</span><span class="s1">'/lazysizes.min.js'</span><span class="p">);</span><span class="c1">// Initiate LazySizes (reads data-src &amp; class=lazyload)</span><span class="nx">lazySizes</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span><span class="c1">// lazySizes works off a global.</span><span class="p">}</span><span class="p">})();</span><span class="nt">&lt;/script&gt;</span></code></pre></div><p>Andrea Verlicchi has a good article that also looks at <a href="https://www.smashingmagazine.com/2019/05/hybrid-lazy-loading-progressive-migration-native/">hybrid lazy-loading</a> worth reading. </p><h2>Demo</h2><p><a href="https://mathiasbynens.be/demo/img-loading-lazy">A <code>loading=lazy</code> demo featuring exactly 100 kitten pics</a> is available. Check it out!</p><p>I've also recorded a video of the feature in action you can check out above.</p><h2>Chrome implementation details</h2><p><strong>We strongly recommend waiting until the <code>loading</code> attribute is in a stable release before using it in production. Early testers may find the below notes helpful.</strong></p><h3>Try today</h3><p>Go to <code>chrome://flags</code> and turn on both the "Enable lazy frame loading" and "Enable lazy image loading" flags, then restart Chrome. </p><h3>Configuration</h3><p>Chrome’s lazy-loading implementation is based not just on how near the current scroll position is, but also the connection speed. The lazy frame and image loading distance-from-viewport thresholds for different connection speeds are <a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/frame/settings.json5?l=937-1003&amp;rcl=e8f3cf0bbe085fee0d1b468e84395aad3ebb2cad">hardcoded</a>, but can be overriden from the command-line. Here’s an example that overrides the lazy-loading settings for images:</p><div class="highlight"><pre><code class="language-sh" data-lang="sh">canary --user-data-dir<span class="o">=</span><span class="s2">"$(mktemp -d)"</span> --enable-features<span class="o">=</span>LazyImageLoading --blink-settings<span class="o">=</span><span class="nv">lazyImageLoadingDistanceThresholdPxUnknown</span><span class="o">=</span>5000,lazyImageLoadingDistanceThresholdPxOffline<span class="o">=</span>8000,lazyImageLoadingDistanceThresholdPxSlow2G<span class="o">=</span>8000,lazyImageLoadingDistanceThresholdPx2G<span class="o">=</span>6000,lazyImageLoadingDistanceThresholdPx3G<span class="o">=</span>4000,lazyImageLoadingDistanceThresholdPx4G<span class="o">=</span><span class="m">3000</span><span class="s1">'https://mathiasbynens.be/demo/img-loading-lazy'</span></code></pre></div><p>The above command corresponds to the (current) default configuration. Change all the values to <code>400</code> to start lazy-loading only when the scroll position is within 400 pixels of the image. Below we can also see a 1 pixel variation (which the video earlier in the article uses):</p><div class="highlight"><pre><code class="language-sh" data-lang="sh">canary --user-data-dir<span class="o">=</span><span class="s2">"$(mktemp -d)"</span> --enable-features<span class="o">=</span>LazyImageLoading --blink-settings<span class="o">=</span><span class="nv">lazyImageLoadingDistanceThresholdPxUnknown</span><span class="o">=</span>1,lazyImageLoadingDistanceThresholdPxOffline<span class="o">=</span>1,lazyImageLoadingDistanceThresholdPxSlow2G<span class="o">=</span>1,lazyImageLoadingDistanceThresholdPx2G<span class="o">=</span>1,lazyImageLoadingDistanceThresholdPx3G<span class="o">=</span>1,lazyImageLoadingDistanceThresholdPx4G<span class="o">=</span><span class="m">1</span><span class="s1">'https://mathiasbynens.be/demo/img-loading-lazy'</span></code></pre></div><p>It’s very likely our default configuration will change as the implementation stabilizes over the coming weeks. </p><h3>DevTools</h3><p>An implementation detail of <code>loading</code> in Chrome is that it fetches the first 2KB of images on page-load. If the server supports range requests, the first 2KB likely contains image dimensions. This enables us to generate/display a placeholder with the same dimensions. First 2KB also likely includes the whole image for assets like icons.</p><p><img data-src="/../assets/images/lazy-load-devtools.png" class="lazyload" alt="2KB image fetches in the DevTools Network panel"></p><p>Chrome fetches the rest of the image bytes when the user is about to see them. A caveat for Chrome DevTools is that this can result in (1) double fetches to 'appear' in the DevTools Network panel and (2) Resource Timing to have 2 requests for each image. </p><h2>Determine <code>loading</code> support on the server</h2><p>In a perfect world, you wouldn't need to rely on JavaScript feature detection on the client to decide whether or not a fallback library needs to be loaded - you would handle this before serving HTML that includes a JavaScript lazy-loading library. A Client Hint could enable such a check.</p><p>A hint for conveying <code>loading</code> preferences is being <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=949365">considered</a> but is currently in the early discussion phase.</p><h2>Wrapping up</h2><p>Give <code>&lt;img loading&gt;</code> a spin and let us know what you think. I'm particularly interested in how folks find the cross-browser story and whether there are any edge-cases we've missed. We hope to ship the <code>loading</code> attribute this summer around Chrome 76.</p><h2>References</h2><p><em>With thanks to Simon Pieters, Yoav Weiss and Mathias Bynens for their feedback. A large thanks to Ben Greenstein, Scott Little, Raj T and Houssein Djirdeh for their work on LazyLoad.</em></p><p><strong>Last updated May 7th, 2019</strong></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>