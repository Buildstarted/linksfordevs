<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>Practical Guide to Hyperparameters Optimization for Deep Learning Models</h1>
        <p>
by Charlie Harrington <br/>Reading time: 24-30 minutes        </p>
        <p><a href="https://blog.floydhub.com/guide-to-hyperparameters-search-for-deep-learning-models/">https://blog.floydhub.com/guide-to-hyperparameters-search-for-deep-learning-models/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="site-main">
    <div>

        <article>

            

            <figure>
                <img srcset="https://images.unsplash.com/photo-1509581376349-c9994910b6c0?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=ee30f25b817d82c89ee060cda00f900f 300w,
                            https://images.unsplash.com/photo-1509581376349-c9994910b6c0?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=ee30f25b817d82c89ee060cda00f900f 600w,
                            https://images.unsplash.com/photo-1509581376349-c9994910b6c0?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=ee30f25b817d82c89ee060cda00f900f 1000w,
                            https://images.unsplash.com/photo-1509581376349-c9994910b6c0?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=ee30f25b817d82c89ee060cda00f900f 2000w" sizes="(max-width: 800px) 400px,
                            (max-width: 1170px) 700px,
                            1400px" src="https://images.unsplash.com/photo-1509581376349-c9994910b6c0?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ&amp;s=ee30f25b817d82c89ee060cda00f900f" alt="Practical Guide to Hyperparameters Optimization for Deep Learning Models">
            </figure>

            <section>
                <div>
                    <blockquote>Are you tired of babysitting your DL models? If so, you're in the right place. In this post, we discuss motivations and strategies behind effectively searching for the best set of hyperparameters for any deep learning model. We'll demonstrate how this can be done on FloydHub, as well as which direction the research is moving. When you're done reading this post, you'll have added some powerful new tools to your data science tool-belt ‚Äì making the process of finding the best configuration for your deep learning task as automatic as possible. </blockquote><p>Unlike machine learning models, deep learning models are literally full of hyperparameters. Would you like some some evidence? Just take a look at the <a href="https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py#L1467-L1525">Transformer base v1 hyperparameters definition</a>.</p><p>I rest my case. </p><p>Of course, not all of these variables contribute in the same way to the model's learning process, but, given this additional complexity, <strong>it's clear that finding the best configuration for these variables in such a high dimensional space is not a trivial challenge</strong>. </p><p>Luckily, we have different strategies and tools for tackling the searching problem. Let's dive in!</p><!--kg-card-begin: html--><!--kg-card-end: html--><p><strong>How? </strong></p><p>We want to find the <em>best configuration</em> of hyperparameters which will give us the <em>best score</em> on the metric we care about on the validation / test set. &nbsp;</p><p><strong>Why? </strong></p><p>Every scientist and researcher wants the best model for the task given the available resources: üíª, üí∞ and ‚è≥ (aka <em>compute</em>,<em> money</em>, and <em>time</em>). Effective hyperparameter search is the missing piece of the puzzle that will help us move towards this goal. </p><p><strong>When? </strong></p><ul><li>It's quite common among researchers and hobbyists to try one of these searching strategies during the <em>last steps of development</em>. This helps provide possible improvements from the best model obtained already after several hours of work.</li><li>Hyperparameter search is also common as a stage or component in a <em>semi/fully automatic deep learning pipeline</em>. This is, obviously, more common among data science teams at companies. </li></ul><p>Let's start with the simplest possible definition,</p><blockquote><em><strong>Hyperparameters</strong> are the knobs that you can turn when building your machine / deep learning model. </em></blockquote><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-22-at-17.59.25.png"><figcaption>Hyperparameters - the "knobs" or "dials" metaphor</figcaption></figure><p>Or, alternatively:</p><blockquote><strong>Hyperparameters</strong> are<em> </em>all the training variables set manually with a pre-determined value before starting the training.</blockquote><p>We can likely agree that the Learning Rate and the Dropout Rate are considered hyperparameters, but what about the model design variables? These include embeddings, number of layers, activation function, and so on. Should we consider these variables as hyperparameters?</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-22-at-18.32.53.png"><figcaption>Model Design Variables + Hyperparameters ‚Üí Model Parameters</figcaption></figure><p>For simplicity's sake, yes ‚Äì we can also consider the <strong>model design components</strong> as part of the hyperparameters set.</p><p>Finally, how about the parameters obtained from the training process ‚Äì the variables learned from the data? These weights are known as <strong>model parameters</strong>. We'll exclude them from our hyperparameter set.</p><p>Okay, let's try a real-world example. Take a look at the picture below for an example illustrating the different classifications of variables in a deep learning model.</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-22-at-18.42.51.png"><figcaption>Variables classification example</figcaption></figure><p>Now that we know we want to search for the best configuration of hyperparameters, we're faced with the challenge that <em>searching for hyperparameters is an</em> <em>iterative process </em>constrained by <strong>üíª</strong>,<strong> üí∞ </strong>and<strong> ‚è≥</strong>.</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-22-at-19.06.53.png"><figcaption>The hyperparameters search cycle</figcaption></figure><p>Everything starts with a guess (<em>step 1</em>) of a promising configuration, then we will need to wait until a full training (<em>step 2</em>) to get the actual evaluation on the metric of interest (<em>step 3</em>). We'll track the progress of the searching process (<em>step 4</em>), and then according to our searching strategy, we'll select a new guess (<em>step 1</em>). </p><p>We'll keep going like this until we reach a terminating condition (such as running out of <strong>‚è≥</strong> or <strong>üí∞</strong>). &nbsp;</p><p>We have four main strategies available for searching for the best configuration.</p><ul><li><strong>Babysitting (aka Trial &amp; Error) </strong></li><li><strong>Grid Search</strong></li><li><strong>Random Search</strong></li><li><strong>Bayesian Optimization</strong></li></ul><p>Babysitting is also known as <em>Trial &amp; Error</em> or <em>Grad Student Descent</em> in the academic field. This approach is <strong>100% manual</strong> and the most widely adopted by researchers, students, and hobbyists. </p><p>The end-to-end workflow is really quite simple: a student devises a new experiment that she follows through all the steps of the learning process (from data collection to feature map visualization), then will she iterates sequentially on the hyperparameters until she runs out time (usually due to a deadline) or motivation. </p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-23-at-14.59.35.png"><figcaption>Babysitting</figcaption></figure><p>If you've enrolled in the deeplearning.ai course, then you're familiar with this approach - it is <a href="https://www.coursera.org/lecture/deep-neural-network/hyperparameters-tuning-in-practice-pandas-vs-caviar-DHNcc">the Panda workflow described by Professor Andrew Ng</a>.</p><p>This approach is very educational, but it doesn't scale inside a team or a company where the time of the data scientist is really valuable. &nbsp;</p><p>Thus, we arrive at the question:</p><blockquote><strong><em>‚ÄúIs there a better way to invest my </em>time?<em>‚Äù</em></strong></blockquote><p>Surely, yes! We can optimize your time by defining an automatic strategy for hyperparameter searching!</p><p>Taken from the imperative command "Just try everything!" comes <a href="https://en.wikipedia.org/wiki/Hyperparameter_optimization#Grid_search">Grid Search</a> ‚Äì a naive approach of simply trying every possible configuration.</p><p>Here's the workflow:</p><ul><li>Define a grid on <em>n</em> dimensions, where each of these maps for an hyperparameter. e.g. <em>n</em> = (learning_rate, dropout_rate, batch_size)</li><li>For each dimension, define the range of possible values: e.g. batch_size = [4, 8, 16, 32, 64, 128, 256]</li><li>Search for all the possible configurations and wait for the results to establish the best one: e.g. <em>C1</em> = (0.1, 0.3, 4) -&gt; acc = 92%, <em>C2</em> = (0.1, 0.35, 4) -&gt; acc = 92.3%, etc...</li></ul><p>The image below illustrates a simple grid search on two dimensions for the Dropout and Learning rate. </p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-23-at-15.33.56.png"><figcaption>Grid Search on two variables in a parallel concurrent execution</figcaption></figure><p>This strategy is embarrassingly parallel because it doesn't take into account the computation history (we will expand this soon). But what it does mean is that the more computational resources <strong>üíª</strong> you have available, then the more guesses you can try at the same time!</p><p>The real pain point of this approach is known as the <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality">curse of dimensionality</a>. This means that more dimensions we add, the more the search will explode in time complexity (usually by an exponential factor), ultimately making this strategy unfeasible!</p><p>It's common to use this approach when the dimensions are less than or equal to 4. But, in practice, even if it guarantees to find the best configuration <em>at the end, it's still not preferable.</em> Instead, it's better to use <a href="https://en.wikipedia.org/wiki/Random_search">Random Search</a> ‚Äî which we'll discuss next<em>.</em></p><h3 id="try-grid-search-now-">Try grid search now!</h3><p>Click this button to open a <a href="https://blog.floydhub.com/workspaces/" rel="nofollow">Workspace</a> on <a href="https://www.floydhub.com/?utm_medium=readme&amp;utm_source=hyperparameters_search_examples&amp;utm_campaign=sept_2018" rel="nofollow">FloydHub</a>. You can use the workspace to run the code below (Grid Search using Scikit-learn and Keras) on a fully configured cloud machine. </p><!--kg-card-begin: html--><p><a target="_blank" href="https://floydhub.com/run?template=https://github.com/floydhub/hyperparameters-search-examples">
    <img src="https://static.floydhub.com/button/button.svg" alt="Run">
</a></p><!--kg-card-end: html--><!--kg-card-begin: markdown--><pre><code># Load the dataset
x, y = load_dataset()

# Create model for KerasClassifier
def create_model(hparams1=dvalue,
                 hparams2=dvalue,
                 ...
                 hparamsn=dvalue):
    # Model definition
    ...

model = KerasClassifier(build_fn=create_model) 

# Define the range
hparams1 = [2, 4, ...]
hparams2 = ['elu', 'relu', ...]
...
hparamsn = [1, 2, 3, 4, ...]

# Prepare the Grid
param_grid = dict(hparams1=hparams1, 
                  hparams2=hparams2, 
                  ...
                  hparamsn=hparamsn)

# GridSearch in action
grid = GridSearchCV(estimator=model, 
                    param_grid=param_grid, 
                    n_jobs=, 
                    cv=,
                    verbose=)
grid_result = grid.fit(x, y)

# Show the results
print("Best: %f using %s" % (grid_result.best_score_, grid_result.best_params_))
means = grid_result.cv_results_['mean_test_score']
stds = grid_result.cv_results_['std_test_score']
params = grid_result.cv_results_['params']
for mean, stdev, param in zip(means, stds, params):
    print("%f (%f) with: %r" % (mean, stdev, param))
</code></pre>
<!--kg-card-end: markdown--><p>A few years ago, Bergstra and Bengio published <a href="http://www.jmlr.org/papers/volume13/bergstra12a/bergstra12a.pdf">an amazing paper</a> where they demonstrated the inefficiency of Grid Search.</p><p>The only real difference between Grid Search and Random Search is on the <em>step 1</em> of the strategy cycle ‚Äì Random Search picks the point randomly from the configuration space. </p><p>Let's use the image below (provided in the paper) to show the claims reported by the researchers.</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-24-at-17.09.14.png"><figcaption>Grid Search vs Random Search</figcaption></figure><p>The image compare the two approaches by searching the best configuration on two hyperparameters space. It also assumes that one parameter is more important that the other one. This is a safe assumption because Deep Learning models, as mentioned at the beginning, are really full of hyperparameters, and usually the researcher / scientist / student knows which ones affect the training most significantly.</p><p>In the Grid Layout, it's easy to notice that, even if we have trained 9 models, we have used only 3 values per variable! Whereas, with the Random Layout, it's extremely unlikely that we will select the same variables more than once. It ends up that, with the second approach, we will have trained 9 model using 9 different values for each variables. </p><p>As you can tell from the space exploration at the top of each layout in the image, we have explored the hyperparameters space more widely with Random Search (especially for the more important variables). This will help us to find the best configuration in fewer iterations.</p><p>In summary: Don't use Grid Search if your searching space contains more than 3 to 4 dimensions. Instead, use Random Search, which provides a really good baseline for each searching task.</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-24-at-18.13.43.png"><figcaption>Pros and cons of Grid Search and Random Search</figcaption></figure><h3 id="try-random-search-now-">Try Random Search now!</h3><!--kg-card-begin: html--><p><a target="_blank" href="https://floydhub.com/run?template=https://github.com/floydhub/hyperparameters-search-examples">
    <img src="https://static.floydhub.com/button/button.svg" alt="Run">
</a></p><!--kg-card-end: html--><p>Click this button to open a <a href="https://blog.floydhub.com/workspaces/" rel="nofollow">Workspace</a> on <a href="https://www.floydhub.com/?utm_medium=readme&amp;utm_source=hyperparameters_search_examples&amp;utm_campaign=sept_2018" rel="nofollow">FloydHub</a>. You can use the workspace to run the code below (Random Search using Scikit-learn and Keras.) on a fully configured cloud machine. &nbsp;</p><pre><code># Load the dataset
X, Y = load_dataset()

# Create model for KerasClassifier
def create_model(hparams1=dvalue,
                 hparams2=dvalue,
                 ...
                 hparamsn=dvalue):
    # Model definition
    ...

model = KerasClassifier(build_fn=create_model) 

# Specify parameters and distributions to sample from
hparams1 = randint(1, 100)
hparams2 = ['elu', 'relu', ...]
...
hparamsn = uniform(0, 1)

# Prepare the Dict for the Search
param_dist = dict(hparams1=hparams1, 
                  hparams2=hparams2, 
                  ...
                  hparamsn=hparamsn)

# Search in action!
n_iter_search = 16 # Number of parameter settings that are sampled.
random_search = RandomizedSearchCV(estimator=model, 
                                   param_distributions=param_dist,
                                   n_iter=n_iter_search,
                                   n_jobs=, 
								   cv=, 
								   verbose=)
random_search.fit(X, Y)

# Show the results
print("Best: %f using %s" % (random_search.best_score_, random_search.best_params_))
means = random_search.cv_results_['mean_test_score']
stds = random_search.cv_results_['std_test_score']
params = random_search.cv_results_['params']
for mean, stdev, param in zip(means, stds, params):
    print("%f (%f) with: %r" % (mean, stdev, param))
</code></pre><h2 id="one-step-back-two-steps-forward">One step back, two steps forward</h2><p>As an aside, when you need to set the space for each dimension, <em>it's very important to use the right scale per each variables.</em></p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-24-at-17.44.08.png"><figcaption>Common scale space for batch size and learning rate&nbsp;</figcaption></figure><p>For example, it's common to use values of <a href="https://datascience.stackexchange.com/questions/20179/what-is-the-advantage-of-keeping-batch-size-a-power-of-2">batch size as a power of 2</a> and sample the learning rate in the log scale.</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-24-at-18.03.49.png"><figcaption>Zoom In!</figcaption></figure><p>It's also very common to start with one of the layouts above for a certain number of iterations, and then <em>zoom into </em>a promising subspace by sampling more densely in each variables range, and even starting a new search with the same or a different searching strategy.</p><h2 id="yet-another-problem-independent-guesses-">Yet another problem: independent guesses!</h2><p>Unfortunately, both Grid and Random Search share the common downside:</p><blockquote><strong><em>‚ÄúEach new guess is independent from the previous run!‚Äù</em></strong></blockquote><p>It can sound strange and surprising, but what makes Babysitting effective ‚Äì despite the amount of time required ‚Äì is the ability of the scientist to drive the search and experimentation effectively by using the past as a resource to improve the next runs. </p><p>Wait a minute, this sounds familiar... what if we try to model the hyperparameter search as a machine learning task?! </p><p>Allow me to introduce <a href="https://en.wikipedia.org/wiki/Bayesian_optimization">Bayesian Optimization</a>.</p><p>This search strategy builds a surrogate model that tries to predict the metrics we care about from the hyperparameters configuration. </p><p>At each new iteration, the surrogate we will become more and more confident about which new guess can lead to improvements. Just like the other search strategies, it shares the same termination condition. </p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-24-at-18.21.48.png"><figcaption>Bayesian Opt Workflow</figcaption></figure><p>If this sounds confusing right now, don't worry ‚Äì it's time for another visual example.</p><h2 id="the-gaussian-process-in-action">The Gaussian Process in action</h2><p>We can define the <a href="https://en.wikipedia.org/wiki/Gaussian_process">Gaussian Process</a> as the surrogate that will learn the mapping from hyperparameters configuration to the metric of interest. It will not only produce the prediction as a value, but it will also give us the range of uncertainty (mean and variance). </p><p>Let's dive into the <a href="https://www.iro.umontreal.ca/~bengioy/cifar/NCAP2014-summerschool/slides/Ryan_adams_140814_bayesopt_ncap.pdf">example provided by this great tutorial.</a></p><figure><img src="https://blog.floydhub.com/content/images/2018/08/step1.png"><figcaption>Gaussian Process in action with 2 Points</figcaption></figure><p>In the above image, we are following the first steps of a Gaussian Process optimization on a single variable (on the horizontal axes). In our imaginary example, this can represent the learning rate or dropout rate.</p><p>On the vertical axes, we are plotting the metrics of interest as a function of the single hyperparameter. Since we're looking for the lowest possible value, we can think of it as the loss function. </p><p>The black dots represent the model trained so far. The red line is the ground truth, or, in other words, the function that we are trying to learn. The black line represents the mean of the actual hypothesis we have for the ground truth function and the grey area shows the related uncertainty, or variance, in the space. </p><p>As we can notice, the uncertainty diminishes around the dots because we are quite confident about the results we can get around these points (since we've already trained the model here). The uncertainty, then, increases in the areas where we have less information.</p><p>Now that we've defined the starting point, we're ready to choose the next promising variables on which train a model. For doing this, we need to define an <em>acquisition function</em> which will tell us where to sample the next configuration. </p><p>In this example, we are using the <em>Expected Improvement</em>: a function that is aiming to find the lowest possible value if we will use the proposed configuration from the uncertainty area. The blue dot in the Expected Improvement chart above shows the point selected for the next training. </p><figure><img src="https://blog.floydhub.com/content/images/2018/08/step2.png"><figcaption>Gaussian Process in action with 3 Points</figcaption></figure><p>The more models we train, the more confident the surrogate will become about the next promising points to sample. Here's the chart after 8 trained models:</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/step8.png"><figcaption>Gaussian Process in action with 8 Points</figcaption></figure><p>The Gaussian Process falls under the class of algorithms called<em> Sequential Model Based Optimization (SMBO)</em>. As we've just seen, these algorithms provide a really good baseline to start the search for the best hyperparameter configuration. But, just like every tool, they come with their downsides:</p><ul><li>By definition, the process is sequential</li><li>It can only handle numeric parameters</li><li>It doesn't provide any mechanism to stop the training if it's performing poorly</li></ul><p>Please note that we've really just scratched the surface about this fascinating topic, and if you're interested in a more detailed reading and how to extend SMBO, then take a look at <a href="https://www.cs.ubc.ca/~hutter/papers/10-TR-SMAC.pdf">this paper</a>.</p><h3 id="try-bayesian-optimization-now-">Try Bayesian Optimization now!</h3><!--kg-card-begin: html--><p><a target="_blank" href="https://floydhub.com/run?template=https://github.com/floydhub/hyperparameters-search-examples">
    <img src="https://static.floydhub.com/button/button.svg" alt="Run">
</a></p><!--kg-card-end: html--><p>Click this button to open a <a href="https://blog.floydhub.com/workspaces/" rel="nofollow">Workspace</a> on <a href="https://www.floydhub.com/?utm_medium=readme&amp;utm_source=hyperparameters_search_examples&amp;utm_campaign=sept_2018" rel="nofollow">FloydHub</a>. You can use the workspace to run the code below (Bayesian Optimization (SMBO - TPE) using <a href="https://github.com/maxpumperla/hyperas">Hyperas</a>) on a fully configured cloud machine.</p><!--kg-card-begin: markdown--><pre><code>def data():
    """
    Data providing function:
    This function is separated from model() so that hyperopt
    won't reload data for each evaluation run.
    """
    # Load / Cleaning / Preprocessing
    ...
    return x_train, y_train, x_test, y_test
    
def model(x_train, y_train, x_test, y_test):
    """
    Model providing function:
    Create Keras model with double curly brackets dropped-in as needed.
    Return value has to be a valid python dictionary with two customary keys:
        - loss: Specify a numeric evaluation metric to be minimized
        - status: Just use STATUS_OK and see hyperopt documentation if not feasible
    The last one is optional, though recommended, namely:
        - model: specify the model just created so that we can later use it again.
    """
    # Model definition / hyperparameters space definition / fit / eval
    return {'loss': &lt;metrics_to_minimize&gt;, 'status': STATUS_OK, 'model': model}
    
# SMBO - TPE in action
best_run, best_model = optim.minimize(model=model,
                                      data=data,
                                      algo=tpe.suggest,
                                      max_evals=,
                                      trials=Trials())

# Show the results
x_train, y_train, x_test, y_test = data()
print("Evalutation of best performing model:")
print(best_model.evaluate(x_test, y_test))
print("Best performing model chosen hyper-parameters:")
print(best_run)
</code></pre>
<!--kg-card-end: markdown--><p>It's finally time to summarize what we've covered so far to understand the strengths and weakness of each proposal.</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-30-at-14.50.17.png"><figcaption>Summary</figcaption></figure><p>Bayes SMBO is probably the best candidate as long as resources are not a constraint for you or your team, but you should also consider establishing a baseline with Random Search.</p><p>On the other hand, if you're still learning or in the development phase, then babysitting ‚Äì even if unpractical in term of space exploration ‚Äì is the way to go.</p><p>Just like I mentioned in the SMBO section, none of these strategies provide a mechanism to save our resources if a training is performing poorly or even worse diverging ‚Äì we'll have to wait until the end of the computation. </p><p>Thus, we arrive at the last question of our fantastic quest:</p><blockquote><strong><em>‚ÄúCan we optimize the training time?‚Äù</em></strong></blockquote><p>Let's find out.</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-24-at-19.05.21.png"><figcaption>If I could only help him to stop!</figcaption></figure><p><a href="https://en.wikipedia.org/wiki/Early_stopping">Early Stopping</a> is not only a famous <a href="https://en.wikipedia.org/wiki/Regularization_(mathematics)">regularization</a> technique, but it also provides a great mechanism for preventing a waste of resources when the training is not going in the right direction.</p><p>Here's a diagram of the most adopted stopping criteria:</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-24-at-19.09.10.png"><figcaption>Stopping criteria</figcaption></figure><p>The first three criteria are self-explanatory, so let's focus our attention to the last one.</p><p>It's common to cap the training time according to the class of experiment inside the research lab. This policy acts as a funnel for the experiments and optimizes for the resources inside the team. In this way, we will be able to allocate more resources only to the most promising experiments. </p><p>The <code>floyd-cli</code> (the software used by our users to communicate with FloydHub and that we've <a href="https://github.com/floydhub/floyd-cli">open-sourced on Github</a>) provides a flag with this purpose: our power users are using it massively to regulate their experiments.</p><p>These criteria can be applied manually when babysitting the learning process, or you can do even better by integrated these rules in your experiment through the hooks/callbacks provided in the most common frameworks:</p><ul><li><a href="https://github.com/keras-team/keras">Keras</a> provides a great <a href="https://keras.io/callbacks/#earlystopping">EarlyStopping</a> function and even better a suite of super useful <a href="https://keras.io/callbacks/">callbacks</a>. Since Keras has been recently integrated inside TensorFlow, you will be able to use the <a href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/Callback">callbacks inside your TensorFlow</a> code.</li><li><a href="https://www.tensorflow.org/">TensorFlow</a> provides the <a href="https://www.tensorflow.org/api_guides/python/train#Training_Hooks">Training Hooks</a>, these are probably not intuitive as Keras callbacks (or the tf.keras API), but they provides you more control over the state of the execution. TensorFlow 2.0 (currently in beta) introduces a new API for managing hyperparameters optimization, you can find more info in the <a href="https://www.tensorflow.org/tensorboard/r2/hyperparameter_tuning_with_hparams">official TensorFlow docs</a>.</li><li>There is even more in the TensorFlow/Keras realm! The Keras team has just released an <a href="https://github.com/keras-team/keras-tuner">hyperparameter tuner for Keras</a>, specifically for <code>tf.keras</code> with TensorFlow 2.0.</li></ul><figure><twitter-widget id="twitter-widget-0"></twitter-widget><blockquote data-twitter-extracted-i1581879461695352056="true">‚Äî Fran√ßois Chollet (@fchollet) <a href="https://twitter.com/fchollet/status/1189992078991708160?ref_src=twsrc%5Etfw">October 31, 2019</a></blockquote>

<figcaption>üéâ</figcaption></figure><ul><li>At this time, <a href="https://pytorch.org/">PyTorch</a> hasn't yet provided a hooks or callbacks component, but you can check the <a href="https://github.com/ncullen93/torchsample">TorchSample</a> repo and in the amazing <a href="https://discuss.pytorch.org/">Forum</a>.</li><li>The <a href="http://www.fast.ai/">fast.ai</a> library provides <a href="https://github.com/fastai/fastai/blob/649e5f72981e5ef714d7709598c8b3b64f6d905f/fastai/sgdr.py">callbacks</a> too, &nbsp;you can find more info in the official <a href="https://docs.fast.ai/callbacks.html">fastai callbacks doc page</a>. If you are lost or need some help, I strongly recommend you to reach the <a href="http://forums.fast.ai/">amazing fast.ai community.</a></li><li><a href="https://github.com/pytorch/ignite">Ignite</a> (high-level library of PyTorch) provides callbacks similarly to Keras. The library is actually under active development but it certainly seems a really interesting option. &nbsp;</li></ul><p>I will stop the list here to limit the discussion to the most used / trending frameworks (I hope to not have hurt the sensibility of the other frameworks' authors. If so, you can direct your complaints to me and I'll be happy to update the content!)</p><h3 id="this-is-not-the-end-">This is not the end. </h3><p>There is a subfield of machine learning called ‚ÄúAutoML‚Äù (Automatic Machine Learning) which aims to automate methods for model selection, features extraction and / or hyperparameters optimization. </p><p>This tool is the answer to the last question (I promise!):</p><blockquote><strong><em> ‚ÄúCan we <strong>learn</strong> the whole process?‚Äù</em></strong></blockquote><p>You can think of AutoML as Machine Learning task which is solving another Machine Learning task, similar to what we've done with the Baeysian Optimiziation. Essentially, this is Meta-Machine Learning.</p><p>You have most likely heard of <a href="https://ai.googleblog.com/2018/03/using-evolutionary-automl-to-discover.html">Google's AutoML</a> which is their re-branding for <a href="https://en.wikipedia.org/wiki/Neural_architecture_search">Neural Architecture Search</a>. Remember, all the way at the beginning of the article, we decided to merge the <em>model design component</em> into the hyperparameters variables? Well, Neural Architecture Search is the subfield of AutoML which aims to find the best models for a given task. A full discussion on this topic would require a series of articles. Luckily, Dr. Rachel Thomas at fast.ai did an amazing job that <a href="http://www.fast.ai/2018/07/12/auto-ml-1/">we are happy to link!</a></p><p>I would like to share with you another interesting <a href="https://deepmind.com/blog/population-based-training-neural-networks/">research effort from DeepMind</a> where they used a variant of Evolution Strategy algorithm to perform hyperparameters search called Population Based Training (PTB is also at the foundation of another <a href="https://deepmind.com/blog/capture-the-flag/">amazing research from DeepMind</a> which wasn't quite covered from the press but that I strongly encourage you to check out on your own). Quoting DeepMind:</p><blockquote>PBT - like random search - starts by training many neural networks in parallel with random hyperparameters. But instead of the networks training independently, it uses information from the rest of the population to refine the hyperparameters and direct computational resources to models which show promise. This takes its inspiration from genetic algorithms where each member of the population, known as a worker, can exploit information from the remainder of the population. For example, a worker might copy the model parameters from a better performing worker. It can also explore new hyperparameters by changing the current values randomly.</blockquote><p>Of course, there are probably tons of other super interesting researches in this area. I've just shared with you the ones who gained some recent prominence in the news. </p><p>One of the biggest features of FloydHub is the ability to compare different model you're training when using a different set of hyperparameters. </p><p>The picture below shows a list of jobs in a FloydHub project. You can see that this user is using the job's <code>message</code> field (e.g. <code>floyd run --message "SGD, lr=1e-3, l1_drop=0.3" ...</code> &nbsp;) to highlight the hyperparameters used on each of these jobs.</p><p>Additionally, you can also see the <a href="https://blog.floydhub.com/metrics-on-floydhub/">training metrics</a> for each job. These offer a quick glance to help you understand which of these jobs performed best, as well as the type of machine used and the total training time.</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-24-at-19.10.18.png"><figcaption>Project Page</figcaption></figure><p>The FloydHub dashboard gives you an easy way to compare all the training you've done in your hyperparameter optimization ‚Äì and it updates in real-time.</p><p>Our advice is to create a different FloydHub project for each of the tasks/problems you have to solve. In this way, it's easier for you to organize your work and collaborate with your team.</p><h3 id="training-metrics">Training metrics</h3><p>As mentioned above, you can easily emit <a href="https://blog.floydhub.com/metrics-on-floydhub/">training metrics</a> with your jobs on FloydHub. When you view your job on the FloydHub dashboard, you'll find real-time charts for each of the metrics you've defined. </p><p>This feature is not intended to substitute <a href="https://blog.floydhub.com/tensorboard-on-floydhub/">Tensorboard</a> (we provides this feature as well), but instead aims to highlight the behavior of your training given the configuration of hyperparameters you've selected. </p><p>For example, if you're babysitting the training process, then the training metrics will certainly help you to determine and apply the stopping criteria.</p><figure><img src="https://blog.floydhub.com/content/images/2018/08/Screen-Shot-2018-08-24-at-19.13.18.png"><figcaption>Training metrics</figcaption></figure><p>We are currently planning to release some examples of how to wrap the <code>floyd-cli</code> command line tool with these proposed strategies to effectively run hyperparameters search on FloydHub. <strong>So, stay tuned!</strong></p><h4 id="one-last-thing-">One last thing! </h4><p>Some of the FloydHub users have asked for a simplified hyperparameter search solution (similar to the solution proposed in the <a href="https://ai.google/research/pubs/pub46180">Google Vizier</a> paper) inside FloydHub. If you think this would be useful to you, please let us know by contacting our <a href="mailto:support@floydhub.com">support</a> or by posting on the <a href="https://forum.floydhub.com/">Forum</a>.</p><p>We're really excited to improve FloydHub to meet all your training needs!</p><hr><h3 id="do-you-model-for-living-be-part-of-a-ml-dl-user-research-study-and-get-a-cool-ai-t-shirt-every-month-">Do you model for living? üë©‚Äçüíª ü§ñ Be part of a ML/DL user research study and get a cool AI t-shirt every month üí•</h3><p><br>We are looking for <em>full-time data scientists</em> for a ML/DL user study. You'll be participating in a calibrated user research experiment for 45 minutes. The study will be done over a video call. We've got plenty of funny tees that you can show-off to your teammates. We'll ship you a different one every month for a year!</p><p>Click <a href="https://typings.typeform.com/to/zpYrlW?utm_source=blog&amp;utm_medium=bottom_text_hypersearch&amp;utm_campaign=full_time_ds_user_study">here</a> to learn more.</p><hr><h4 id="floydhub-call-for-ai-writers"><strong>FloydHub Call for AI writers</strong></h4><p>Want to write amazing articles like Alessio and play your role in the long road to Artificial General Intelligence? <a href="https://blog.floydhub.com/write-for-floydhub/?utm_source=floydhub&amp;utm_medium=banner&amp;utm_campaign=call_for_writers_2019">We are looking for passionate writers</a>, to build the world's best blog for practical applications of groundbreaking A.I. techniques. FloydHub has a large reach within the AI community and with your help, we can inspire the next wave of AI. <a href="https://goo.gl/forms/PbOw0VmUnOfO1Lxp1">Apply now</a> and join the crew!</p>
                </div>
            </section>


            


        </article>

    </div>
</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>

</body>
</html>