<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Why are you testing your software? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Why are you testing your software? - linksfor.dev(s)"/>
    <meta property="article:author" content="Nicolas Fr&#xE4;nkel"/>
    <meta property="og:description" content="15 years ago, automated tests didn&#x2019;t exist in the Java ecosystem. One had to build the application and painfully test it manually by using it. I was later introduced to the practice of adding a main method to every class and putting some testing code there. That was only marginally better, as it still required to manually run the methods. Then came JUnit, the reference unit testing framework in Java which brought test execution automation. At that point, I had to convince teams I was part o"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.frankel.ch/why-are-you-testing-software/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Why are you testing your software?</title>
<div class="readable">
        <h1>Why are you testing your software?</h1>
            <div>by Nicolas Fr&#xE4;nkel</div>
            <div>Reading time: 5-7 minutes</div>
        <div>Posted here: 05 Aug 2020</div>
        <p><a href="https://blog.frankel.ch/why-are-you-testing-software/">https://blog.frankel.ch/why-are-you-testing-software/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="site-main" role="main"> <div> <article itemscope="" itemtype="http://schema.org/BlogPosting"> <meta itemprop="mainEntityOfPage" content="//why-are-you-testing-software/"> <meta itemprop="description" content="">  <figure itemscope="" itemprop="image" itemtype="http://schema.org/ImageObject"> <meta itemprop="url" content="https://blog.frankel.ch/assets/resources/why-are-you-testing-software/black-bus-covered-with-white-foam-173414.jpg"> <meta itemprop="height" content="1200"> <meta itemprop="width" content="800"> </figure> <section> <div itemprop="articleBody"> <p>15 years ago, automated tests didn’t exist in the Java ecosystem. One had to build the application and painfully test it manually by using it. I was later introduced to the practice of adding a <code>main</code> method to every class and putting some testing code there. That was only marginally better, as it still required to manually run the methods. Then came <a href="https://junit.org/" target="_blank" rel="noopener">JUnit</a>, the reference unit testing framework in Java which brought test execution automation. At that point, I had to convince teams I was part of that we had to use it to create an automated tests harness to prevent regression bugs. Later, this became an expectation: no tests meant no changes in the code for fear of breaking something.</p> <p>More recently, however, it happened that I sometimes have to advocate for the opposite: <em>not write too many tests</em>. Yes, you read that well, and yet I’m no turncoat. The reason for this lies in the title of the post: why are you testing your software? It may sound like the answer to this question is pretty obvious - but it’s not, and the answer is tightly coupled to the concept of quality.</p> <div> <blockquote> <p>In the context of software engineering, software quality refers to two related but distinct notions that exist wherever quality is defined in a business context:</p> <ul><li><span>Software functional quality reflects how well it complies with or conforms to a given design, based on functional requirements or specifications. That attribute can also be described as the fitness for purpose of a piece of software or how it compares to competitors in the marketplace as a worthwhile product. It is the degree to which the correct software was produced.</span></li><li><span>Software structural quality refers to how it meets non-functional requirements that support the delivery of the functional requirements, such as robustness or maintainability. It is the degree to which the software was produced correctly.</span></li></ul> </blockquote> <p> — Wikipedia </p> </div> <p>Before answering the question of the why, let’s consider some reason why not I’ve already been confronted to:</p> <ul><li><span>Because everyone does it</span></li><li><span>Because the boss/the lead/colleagues/authority figures say so</span></li><li><span>To achieve <a href="https://blog.frankel.ch/100-code-coverage/" target="_blank" rel="noopener">100% of code coverage</a></span></li><li><span>To achieve more code coverage than another team/colleague</span></li><li><span>And so on, and so forth</span></li></ul> <p>All in all, those "reasons" boil down to either plain <em>cargo culting</em> or mistaking a metric for the goal. Which brings us back to the question, why do you test software?</p> <div> <table> <tbody><tr> <td> <i title="Important"></i> </td> <td> <p>The only valid reason for testing is that resources spent in making sure the software conforms to non-/functional requirements will be less over the course of time than the resources spent if not done.</p> </td> </tr> </tbody></table> </div> <p>That’s pure and simple Return Over Investment. If ROI is positive, do test; if it’s negative, don’t. It’s as simple as that.</p> <div> <blockquote> <p>Perfect is the enemy of good</p> </blockquote> </div> <p>The real difficulty lies in estimating the cost of testing vs the cost of not testing. The following is a non-exhaustive list of ROI-influencing parameters:</p> <div> <dl> <dt>Business</dt> <dd> <p>No bugs are allowed in some industries <em>e.g.</em> medical, airplanes, banks without serious consequences to the business, while this is less critical for others such as mobile gaming.</p> </dd> <dt>Estimated lifespan of the app</dt> <dd> <p>the longer the lifespan of an app, the better the ROI because the same amount of testing code will yield more times <em>e.g.</em> nearly no tests for one-shot single-event apps vs. more traditional testing for tradition business apps running for a decade or so.</p> </dd> <dt>Nature of the app</dt> <dd> <p>some technologies are more mature than others, allowing for easier automated testing. The testing echosystem around webapps is richer than around native or mobile apps.</p> </dd> <dt>Architecture of the app</dt> <dd> <p>The more distributed the app, the harder it is to test. In particular, the migration from monoliths to microservices has some interesting side-effects on the testing side. It’s easier to test each component separately, but harder to test the whole system. Also, testing specific scenarios in clustered/distributed environments, such as node failure in a cluster, increase the overall cost.</p> </dd> <dt>Nature and number of infrastructure dependencies</dt> <dd> <p>The higher the number of dependencies, the more test doubles are required to test the app in isolation, which in turns drive up testing costs. Also, some dependencies are more widespread <em>e.g.</em> databases and web services, with many available tools while some are not <em>e.g.</em> FTP servers.</p> </dd> <dt>Size of the app</dt> <dd> <p>Of course, the bigger the size of the app, the bigger the number of possible combinations that needs to be tested.</p> </dd> <dt>Maturity of the developers, and the size of the team(s)</dt> <dd> <p>Obviously, developers range from the ones who don’t care about testing to those who integrate testing requirements in their code from the start. Also, just for developers, adding more testers is subject to the <a href="https://en.wikipedia.org/wiki/Diminishing_returns" target="_blank" rel="noopener">law of diminishing returns</a>.</p> </dd> <dt>Nature of the tests</dt> <dd> <p>I don’t want to start a war, suffice to say there are many kinds of tests - unit, integration, end-to-end, performance, penetration, etc. Each one is good at one specific thing, and has pros and cons. Get to know them and use them wisely.</p> </dd> <dt>Strength of the type system</dt> <dd> <p>Developing in dynamically-typed languages require more tests to handle the job of the compiler in comparison to more statically-typed languages.</p> </dd> </dl> </div> <p>While it’s good to listen to other’s advices - including well-established authority figures and this post, it’s up to every delivery team to draw the line between not enough testing and too much testing according to its own context.</p>   </div> </section>   </article> </div> </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>