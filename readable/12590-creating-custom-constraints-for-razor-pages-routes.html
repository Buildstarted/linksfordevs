<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating Custom Constraints For Razor Pages Routes -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Creating Custom Constraints For Razor Pages Routes</h1><div><p class="abstract" itemprop="description">
            Razor Page already includes a wide range of constraints that can be used to help disambiguate routes. It is also possible for you to create your own custom constraint and then register that with the routing system.
        </p><div id="" class=""><p>Imagine that you have a page that is designed to show the details of a product. Following convention, you create a page named <em>Details.cshtml</em> in a folder named <em>Product</em> within the <em>Pages</em> folder. You want visitors to reach the page using the URL <code>domain.com/product/details/{productname}</code> where the <code>{productname}</code> is the actual name of a specific product (suitably slugified). So you add a route template accordingly:</p><pre>@page "{productname}"</pre><p>Now you can retrieve the <code>RouteData</code> value for productname, and use it to perform a database query. This works fine, but what you soon begin to realise is that sometimes, the database query doesn't return a result. When you review your logs, you see that the value being passed to the database query is not what you expect to see in your URLs. It might be part of the product name, or it might have some extra characters added, or indeed it might bear no resemblance to anything in your database at all. There are countless ways in which links to your site can get broken when they are being shared, or stored by a poorly written bot.</p><p>What you really could do with is some way to prevent the wasted processing that these database look-ups for non-existent values incur, and also inform the requester that the page they are looking for doesn't exist. You want to return a 404 HTTP status code.</p><p>
The solution can be implemented as a custom constraint. Then the routing system will take care of ensuring that the user gets the correct response.</p><h3>An Example Look-up Service</h3><p>The constraint will work by matching incoming route values to existing product names. The product names need to obtained from the database. Obviously you don't want to do this for every request - that would defeat the object of the exercise. So you will use <a href="https://www.learnrazorpages.com/razor-pages/caching">caching</a> as part of your strategy. For the purposes of demonstration, however, the service will just return a <code>List</code></p>
The service conforms to an interface, which is registered with the <a href="https://www.learnrazorpages.com/advanced/dependency-injection">dependency injection system</a>:

<pre>public void ConfigureServices(IServiceCollection services)
{
    ...
    services.AddTransient&lt;IProductService, ProductService&gt;();
}</pre><h3>The Constraint</h3><p>Constraints implement the <code>IRouteConstraint</code> interface, which defines one method: <code>Match</code>. This is where the logic that determines whether a value satisfies the constraint is placed. The method returns a <code>bool</code> indicating success:</p><code>In this example, the <code>ProductService</code> is injected into the constructor. The <code>Match</code> method returns true if there is an entry in the <code>RouteValueDictionary</code> with the specified key that matches any in the database.</code><h3>Registering And Using The Constraint</h3><p>The constraint needs to be registered with the routing system. This is done in the <code>ConfigureServices</code> method in <code>Startup</code>:</p><code>services.Configure<routeoptions>(options =&gt;
{
    options.ConstraintMap.Add("product", typeof(ProductConstraint));
});</routeoptions></code><p>The entry added to the <code>RoutOption.ConstraintMap</code> consists of a <code>string</code> as the key and a <code>Type</code> as the value. The key is used to to identify the constraint when you apply it to a route value parameter:</p><code>@page "{productname:product}"</code><p>A valid value in the URL will result in a successful request:</p><p><img src="https://www.learnrazorpages.com/images/01-04-2019-08-17-59.png" alt="custom constraint"></p><p>Whereas if you request the <em>Details</em> page without passing in an existing value, the framework returns a 404:</p><p><img src="https://www.learnrazorpages.com/images/01-04-2019-08-16-26.png" alt="custom constraint"></p><h3>Summary</h3><p>The built-in set of route constraints are most likely enough for the majority of applications, but if you need to build your own custom constraint, you just need to implement <code>IRouteConstraint</code> and register your implementation with your application's service container. As you can see from the example above, this is not very difficult to do.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>