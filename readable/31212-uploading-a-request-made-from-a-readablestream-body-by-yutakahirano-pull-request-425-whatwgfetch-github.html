<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Uploading a Request made from a ReadableStream body by yutakahirano &#xB7; Pull Request #425 &#xB7; whatwg/fetch &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Uploading a Request made from a ReadableStream body by yutakahirano · Pull Request #425 · whatwg/fetch · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>In case abandoning this feature is being considered, I'd like to pile on a use case:</p><p>The existence of this API has implications for streaming media sourced from browsers and browser-like clients.  Without a way to make a simple HTTP PUT request with a stream from a browser, all of us working in this space have been hacking around the problem by proxying the stream data via Web Socket servers or repeatedly making requests with chunks every second or so.</p><p>For 20 years, we have been streaming media via HTTP PUT on the source end, and HTTP GET on the receiving end.  This works most everywhere, except for the source end on browsers, which is important.  Implementing ReadableStream as a request body would remove the need for a lot of hackarounds.</p><p>I suspect there are many others with different use cases who are generating data on-the-fly where a normal HTTP request would be more appropriate for sending data to the server.  In at least some of these use cases, we don't always have control over the servers, which already support HTTP and may not be able to support other protocols.  Please, when considering this stream-as-request-body feature, keep in mind that it goes far beyond file uploads.  And, thank you for your efforts!</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>