<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A plugin system with .NET Core -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div class="post"> <p class="intro"> <span class="dropcap">I</span>mplementing a (mini) plugin system with .NET Core 3.0
</p> <h3 id="prerequisites">Prerequisites</h3> <p>You need <a href="https://visualstudio.microsoft.com/vs/">VS 2019</a> and <a href="https://dotnet.microsoft.com/download/dotnet-core/3.0">.NET Core 3.0</a> (currently in preview 8 while posting this).</p> <h3 id="getting-started">Getting started</h3> <p>In this post I show how you could implement a plugin system that can unload the plugins dynamically.
I also provide some background information behind the techniques and classes involved.
Unlike the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.appdomain?view=netcore-3.0">AppDomain</a>, the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-3.0">AssemblyLoadContext</a> let&#x2019;s you unload the plugin types and the owned assemblies - sounds promising, right?</p> <h4 id="the-pluginfinder">The PluginFinder</h4> <p>Usually before we load an assembly in our application, we should probe it for plugins that our application supports.</p> <h4 id="the-pluginhost">The PluginHost</h4> <p>The plugin host acts as a registry of the known plugins.</p> <h4 id="the-plugin">The Plugin</h4> <p>Every plugin needs at least a name to be identified and properly hosted by the plugin host.</p> <p class="alert alert-danger"> <b>Be aware that the following implementation is an example and not bullet proof production ready.</b>
</p> <h3 id="implementing-the-pluginfinder-class">Implementing the PluginFinder class</h3> <p>The plugin finder is responsible for loading and scanning an assembly for plugins.
This means we need to store the information about which assemblies have plugins and unload the assembly after scanning.</p> <figure class="highlight"><pre><code class="language-c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">PluginFinder</span><span class="p">&lt;</span><span class="n">TPlugin</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">TPlugin</span> <span class="p">:</span> <span class="n">IPlugin</span>
<span class="p">{</span> <span class="k">public</span> <span class="nf">PluginFinder</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="k">public</span> <span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">FindAssemliesWithPlugins</span><span class="p">(</span><span class="kt">string</span> <span class="n">path</span><span class="p">)</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">assemblies</span> <span class="p">=</span> <span class="n">Directory</span><span class="p">.</span><span class="nf">GetFiles</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;*.dll&quot;</span><span class="p">,</span> <span class="k">new</span> <span class="nf">EnumerationOptions</span><span class="p">()</span> <span class="p">{</span> <span class="n">RecurseSubdirectories</span> <span class="p">=</span> <span class="k">true</span> <span class="p">});</span> <span class="k">return</span> <span class="nf">FindPluginsInAssemblies</span><span class="p">(</span><span class="n">assemblies</span><span class="p">);</span> <span class="p">}</span> <span class="k">private</span> <span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">FindPluginsInAssemblies</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">assemblyPaths</span><span class="p">)</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">assemblyPluginInfos</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span> <span class="kt">var</span> <span class="n">pluginFinderAssemblyContext</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PluginAssemblyLoadingContext</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;PluginFinderAssemblyContext&quot;</span><span class="p">);</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">assemblyPath</span> <span class="k">in</span> <span class="n">assemblyPaths</span><span class="p">)</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">assembly</span> <span class="p">=</span> <span class="n">pluginFinderAssemblyContext</span><span class="p">.</span><span class="nf">LoadFromAssemblyPath</span><span class="p">(</span><span class="n">assemblyPath</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="nf">GetPluginTypes</span><span class="p">(</span><span class="n">assembly</span><span class="p">).</span><span class="nf">Any</span><span class="p">())</span> <span class="p">{</span> <span class="n">assemblyPluginInfos</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">assembly</span><span class="p">.</span><span class="n">Location</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span> <span class="n">pluginFinderAssemblyContext</span><span class="p">.</span><span class="nf">Unload</span><span class="p">();</span> <span class="k">return</span> <span class="n">assemblyPluginInfos</span><span class="p">;</span> <span class="p">}</span> <span class="k">public</span> <span class="k">static</span> <span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">&gt;</span> <span class="nf">GetPluginTypes</span><span class="p">(</span><span class="n">Assembly</span> <span class="n">assembly</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">assembly</span><span class="p">.</span><span class="nf">GetTypes</span><span class="p">()</span> <span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">type</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="n">type</span><span class="p">.</span><span class="n">IsAbstract</span> <span class="p">&amp;&amp;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">TPlugin</span><span class="p">).</span><span class="nf">IsAssignableFrom</span><span class="p">(</span><span class="n">type</span><span class="p">))</span> <span class="p">.</span><span class="nf">ToArray</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <h3 id="implementing-the-pluginhost-class">Implementing the PluginHost class</h3> <p>The plugin host stores all plugin instances by name and allows unloading them.
We load the assembly into the <em>_pluginAssemblyLoadingContext</em>.
After that, the <em>Activator</em> creates a new instance of our plugin types and adds it to the dictionary.</p> <figure class="highlight"><pre><code class="language-c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">PluginHost</span><span class="p">&lt;</span><span class="n">TPlugin</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">TPlugin</span> <span class="p">:</span> <span class="n">IPlugin</span>
<span class="p">{</span> <span class="k">private</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">TPlugin</span><span class="p">&gt;</span> <span class="n">_plugins</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">TPlugin</span><span class="p">&gt;();</span> <span class="k">private</span> <span class="k">readonly</span> <span class="n">PluginAssemblyLoadingContext</span> <span class="n">_pluginAssemblyLoadingContext</span><span class="p">;</span> <span class="k">public</span> <span class="nf">PluginHost</span><span class="p">()</span> <span class="p">{</span> <span class="n">_pluginAssemblyLoadingContext</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">PluginAssemblyLoadingContext</span><span class="p">(</span><span class="s">&quot;PluginAssemblyContext&quot;</span><span class="p">);</span> <span class="p">}</span> <span class="k">public</span> <span class="n">TPlugin</span> <span class="nf">GetPlugin</span><span class="p">(</span><span class="kt">string</span> <span class="n">pluginName</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_plugins</span><span class="p">[</span><span class="n">pluginName</span><span class="p">];</span> <span class="p">}</span> <span class="k">public</span> <span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="n">TPlugin</span><span class="p">&gt;</span> <span class="nf">GetPlugins</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_plugins</span><span class="p">.</span><span class="n">Values</span><span class="p">;</span> <span class="p">}</span> <span class="k">public</span> <span class="k">void</span> <span class="nf">LoadPlugins</span><span class="p">(</span><span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">assembliesWithPlugins</span><span class="p">)</span> <span class="p">{</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">assemblyPath</span> <span class="k">in</span> <span class="n">assembliesWithPlugins</span><span class="p">)</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">assembly</span> <span class="p">=</span> <span class="n">_pluginAssemblyLoadingContext</span><span class="p">.</span><span class="nf">LoadFromAssemblyPath</span><span class="p">(</span><span class="n">assemblyPath</span><span class="p">);</span> <span class="kt">var</span> <span class="n">validPluginTypes</span> <span class="p">=</span> <span class="n">PluginFinder</span><span class="p">&lt;</span><span class="n">TPlugin</span><span class="p">&gt;.</span><span class="nf">GetPluginTypes</span><span class="p">(</span><span class="n">assembly</span><span class="p">);</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">pluginType</span> <span class="k">in</span> <span class="n">validPluginTypes</span><span class="p">)</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">plutinInstance</span> <span class="p">=</span> <span class="p">(</span><span class="n">TPlugin</span><span class="p">)</span><span class="n">Activator</span><span class="p">.</span><span class="nf">CreateInstance</span><span class="p">(</span><span class="n">pluginType</span><span class="p">);</span> <span class="nf">RegisterPlugin</span><span class="p">(</span><span class="n">plutinInstance</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> <span class="k">public</span> <span class="k">void</span> <span class="nf">Unload</span><span class="p">()</span> <span class="p">{</span> <span class="n">_plugins</span><span class="p">.</span><span class="nf">Clear</span><span class="p">();</span> <span class="n">_pluginAssemblyLoadingContext</span><span class="p">.</span><span class="nf">Unload</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <h3 id="implementing-the-plugins-in-another-assembly">Implementing the plugins in another assembly</h3> <p>The plugin interface defined by the application is simple.</p> <figure class="highlight"><pre><code class="language-c#"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IPlugin</span>
<span class="p">{</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>If we leave it that way, our plugin can not do anything yet.
That&#x2019;s boring, right? Lets add another interface to be suitable for math operations.</p> <figure class="highlight"><pre><code class="language-c#"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IMathOperationPlugin</span> <span class="p">:</span> <span class="n">IPlugin</span>
<span class="p">{</span> <span class="kt">decimal</span> <span class="nf">Calculate</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">operand1</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">operand2</span><span class="p">);</span> <span class="p">}</span></code></pre></figure> <p>Don&#x2019;t be surprised by the chosen operations - they are well-known.</p> <figure class="highlight"><pre><code class="language-c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">AdditionOperation</span> <span class="p">:</span> <span class="n">PluginBase</span><span class="p">,</span> <span class="n">IMathOperationPlugin</span>
<span class="p">{</span> <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">=&gt;</span> <span class="k">nameof</span><span class="p">(</span><span class="n">AdditionOperation</span><span class="p">);</span> <span class="k">public</span> <span class="kt">decimal</span> <span class="nf">Calculate</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">operand1</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">operand2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">operand1</span> <span class="p">+</span> <span class="n">operand2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">DivideOperation</span> <span class="p">:</span> <span class="n">PluginBase</span><span class="p">,</span> <span class="n">IMathOperationPlugin</span>
<span class="p">{</span> <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">=&gt;</span> <span class="k">nameof</span><span class="p">(</span><span class="n">DivideOperation</span><span class="p">);</span> <span class="k">public</span> <span class="kt">decimal</span> <span class="nf">Calculate</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">operand1</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">operand2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">operand1</span> <span class="p">/</span> <span class="n">operand2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">MultiplyOperation</span> <span class="p">:</span> <span class="n">PluginBase</span><span class="p">,</span> <span class="n">IMathOperationPlugin</span>
<span class="p">{</span> <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">=&gt;</span> <span class="k">nameof</span><span class="p">(</span><span class="n">MultiplyOperation</span><span class="p">);</span> <span class="k">public</span> <span class="kt">decimal</span> <span class="nf">Calculate</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">operand1</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">operand2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">operand1</span> <span class="p">*</span> <span class="n">operand2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="k">public</span> <span class="k">class</span> <span class="nc">SubstractOperation</span> <span class="p">:</span> <span class="n">PluginBase</span><span class="p">,</span> <span class="n">IMathOperationPlugin</span>
<span class="p">{</span> <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">=&gt;</span> <span class="k">nameof</span><span class="p">(</span><span class="n">SubstractOperation</span><span class="p">);</span> <span class="k">public</span> <span class="kt">decimal</span> <span class="nf">Calculate</span><span class="p">(</span><span class="kt">decimal</span> <span class="n">operand1</span><span class="p">,</span> <span class="kt">decimal</span> <span class="n">operand2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">operand1</span> <span class="p">-</span> <span class="n">operand2</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <h3 id="putting-all-together">Putting all together</h3> <p>Let&#x2019;s get seriously about our code and do some math!</p> <figure class="highlight"><pre><code class="language-c#"><span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span> <span class="nf">DoCalculation</span><span class="p">();</span> <span class="n">GC</span><span class="p">.</span><span class="nf">Collect</span><span class="p">();</span> <span class="n">GC</span><span class="p">.</span><span class="nf">WaitForPendingFinalizers</span><span class="p">();</span> <span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span> <span class="p">}</span> <span class="p">[</span><span class="nf">MethodImpl</span><span class="p">(</span><span class="n">MethodImplOptions</span><span class="p">.</span><span class="n">NoInlining</span><span class="p">)]</span> <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">DoCalculation</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Create a plugin finder and scan the sub directory &quot;Plugins&quot; for assemblies with plugin defined.</span> <span class="kt">var</span> <span class="n">pluginFinder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PluginFinder</span><span class="p">&lt;</span><span class="n">IMathOperationPlugin</span><span class="p">&gt;();</span> <span class="kt">var</span> <span class="n">assemblyPaths</span> <span class="p">=</span> <span class="n">pluginFinder</span><span class="p">.</span><span class="nf">FindAssemliesWithPlugins</span><span class="p">(</span><span class="n">Path</span><span class="p">.</span><span class="nf">Combine</span><span class="p">(</span><span class="n">Directory</span><span class="p">.</span><span class="nf">GetCurrentDirectory</span><span class="p">(),</span> <span class="s">&quot;Plugins&quot;</span><span class="p">));</span> <span class="n">GC</span><span class="p">.</span><span class="nf">Collect</span><span class="p">();</span> <span class="n">GC</span><span class="p">.</span><span class="nf">WaitForPendingFinalizers</span><span class="p">();</span> <span class="c1">// Create a plugin host and load the plugin assemblies.</span> <span class="kt">var</span> <span class="n">pluginHost</span> <span class="p">=</span> <span class="k">new</span> <span class="n">PluginHost</span><span class="p">&lt;</span><span class="n">IMathOperationPlugin</span><span class="p">&gt;();</span> <span class="n">pluginHost</span><span class="p">.</span><span class="nf">LoadPlugins</span><span class="p">(</span><span class="n">assemblyPaths</span><span class="p">);</span> <span class="c1">// Use the plugins and print the result of each calculation.</span> <span class="kt">decimal</span> <span class="n">value1</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span> <span class="kt">decimal</span> <span class="n">value2</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">operation</span> <span class="k">in</span> <span class="n">pluginHost</span><span class="p">.</span><span class="nf">GetPlugins</span><span class="p">())</span> <span class="p">{</span> <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">operation</span><span class="p">.</span><span class="nf">Calculate</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">);</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$&quot;Calculation with </span><span class="p">{</span><span class="n">operation</span><span class="p">.</span><span class="n">Name</span><span class="p">}</span><span class="s">: </span><span class="p">{</span><span class="n">result</span><span class="p">}</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span> <span class="n">pluginHost</span><span class="p">.</span><span class="nf">Unload</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>The <em>[MethodImpl(MethodImplOptions.NoInlining)]</em> attribute is required to ensure the method is not inlined by the runtime - otherwise everything would live until the end of the application and would prevent the unloading of our assemblies.</p> <p>Maybe you wonder about the calls of <em>GC.Collect()</em> and <em>GC.WaitForPendingFinalizers()</em>.
Those calls are added to demonstrate immediately the effect of <em>AssemblyLoadContext.Unload()</em> method.
By design <em>AssemblyLoadContext.Unload()</em> only triggers the unloading process and the actual unloading will happen when the garbage collection runs - this behavior can be observed during debugging. When for whatever reason a type is referenced by long lived object on the heap (e.g. a static field), the assembly can never be unloaded!</p> <p>Let&#x2019;s debug it and see what&#x2019;s happening with our module list.
Before we load any plugin assembly, our module list contains everything that is actually used by the console app.</p> <p><a href="/assets/img/dotnet30-plugin/dotnet-30-before-find-plugin.png"> <img src="/assets/img/dotnet30-plugin/dotnet-30-before-find-plugin.png" alt="dotnet-30-before-find-plugin">
</a></p> <p>Just after the scan, the list is growing and our plugin assembly is added to the list: <strong>CodeTherapistBlogPluginA.dll</strong>.</p> <p><a href="/assets/img/dotnet30-plugin/dotnet-30-after-find-plugin.png"> <img src="/assets/img/dotnet30-plugin/dotnet-30-after-find-plugin.png" alt="dotnet-30-after-find-plugin">
</a></p> <p>Even though we have already called <em>AssemblyLoadContext.Unload()</em> (inside <em>pluginFinder.FindAssemliesWithPlugins</em>), the assembly stays in the module list.
Right after a full GC, the plugin assembly named <strong>CodeTherapistBlogPluginA.dll</strong> is removed.</p> <p><a href="/assets/img/dotnet30-plugin/dotnet-30-after-find-plugin-collected.png"> <img src="/assets/img/dotnet30-plugin/dotnet-30-after-find-plugin-collected.png" alt="dotnet-30-after-find-plugin-collected">
</a></p> <p>The plugin host will load the assembly (<strong>CodeTherapistBlogPluginA.dll</strong>) again and execute all calculations.</p> <p><a href="/assets/img/dotnet30-plugin/dotnet-30-after-calculation.png"> <img src="/assets/img/dotnet30-plugin/dotnet-30-after-calculation.png" alt="dotnet-30-after-calculation">
</a></p> <p>Triggering GC will remove our plugin assembly again.</p> <p><a href="/assets/img/dotnet30-plugin/dotnet-30-after-calculation-plugin-collected.png"> <img src="/assets/img/dotnet30-plugin/dotnet-30-after-calculation-plugin-collected.png" alt="dotnet-30-after-calculation-plugin-collected">
</a></p> <h3 id="the-assemblyloadcontext">The AssemblyLoadContext</h3> <p>Basically the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-3.0">AssemblyLoadContext</a> is the successor of the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.appdomain?view=netcore-3.0">AppDomain</a> and provides identical and more functionality - except the security boundary (isolation).
The smallest security boundary is the process and therefore you would need to use inter-process communication to properly isolate data and code execution.</p> <p>The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.appdomain?view=netcore-3.0">AppDomain</a> is obsolete and you should prefer <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-3.0">AssemblyLoadContext</a> especially for new work and .NET Core.
Under .NET Core the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.appdomain?view=netcore-3.0">AppDomain</a> is already limited. It does not provide isolation, unloading, or security boundaries.</p> <p>Every .NET App has at least one (not collectible) <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-3.0">AssemblyLoadContext</a> named &#x201C;Default&#x201D; where all the assemblies are loaded by the .NET runtime.</p> <h4 id="type--type">Type != Type</h4> <p>When you deal with multiple <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-3.0">AssemblyLoadContext</a> instances you could run in the following exception:</p> <p><img src="/assets/img/dotnet30-plugin/dotnet-30-type!=type.png" alt="dotnet-30-type!=type"></p> <p>This happens because you can load different versions of the same assembly side by side into the same process.
The direct referenced assembly has a different version than the side loaded library.</p> <h4 id="migrate-from-appdomain-to-assemblyloadcontext">Migrate from AppDomain to AssemblyLoadContext</h4> <p>Maybe you still using the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.appdomain?view=netcore-3.0">AppDomain</a> in an application.
Now, the following code shows how to replace <a href="https://docs.microsoft.com/en-us/dotnet/api/system.appdomain?view=netcore-3.0">AppDomain</a> methods by the appropriate equivalent method of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-3.0">AssemblyLoadContext</a>:</p> <figure class="highlight"><pre><code class="language-c#"> <span class="c1">// Create new &quot;context&quot; for loading assemblies:</span> <span class="kt">var</span> <span class="n">appDomain</span> <span class="p">=</span> <span class="n">AppDomain</span><span class="p">.</span><span class="nf">CreateDomain</span><span class="p">(</span><span class="s">&quot;MyAppDomain&quot;</span><span class="p">);</span> <span class="kt">var</span> <span class="n">assemblyLoadContext</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MyAssemblyLoadContext</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;MyAssemblyLoadContext&quot;</span><span class="p">,</span> <span class="n">isCollectible</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span> <span class="c1">// Get all assemblies:</span> <span class="kt">var</span> <span class="n">assembliesFromAppDomain</span> <span class="p">=</span> <span class="n">AppDomain</span><span class="p">.</span><span class="n">CurrentDomain</span><span class="p">.</span><span class="nf">GetAssemblies</span><span class="p">();</span> <span class="kt">var</span> <span class="n">assembliesFromAssemblyLoadContext</span> <span class="p">=</span> <span class="n">AssemblyLoadContext</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="n">Assemblies</span><span class="p">;</span> <span class="c1">// Load an assembly:</span> <span class="n">AppDomain</span><span class="p">.</span><span class="n">CurrentDomain</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="n">AssemblyName</span><span class="p">.</span><span class="nf">GetAssemblyName</span><span class="p">(</span><span class="s">&quot;path&quot;</span><span class="p">));</span> <span class="n">AssemblyLoadContext</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="nf">LoadFromAssemblyName</span><span class="p">(</span><span class="n">AssemblyName</span><span class="p">.</span><span class="nf">GetAssemblyName</span><span class="p">(</span><span class="s">&quot;path&quot;</span><span class="p">));</span> <span class="c1">// Load an assembly from path or byte array:</span> <span class="n">AppDomain</span><span class="p">.</span><span class="n">CurrentDomain</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="n">File</span><span class="p">.</span><span class="nf">ReadAllBytes</span><span class="p">(</span><span class="s">&quot;path&quot;</span><span class="p">));</span> <span class="n">AssemblyLoadContext</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="nf">LoadFromStream</span><span class="p">(</span><span class="n">File</span><span class="p">.</span><span class="nf">OpenRead</span><span class="p">(</span><span class="s">&quot;path&quot;</span><span class="p">));</span> <span class="c1">// or</span> <span class="n">AssemblyLoadContext</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="nf">LoadFromAssemblyPath</span><span class="p">(</span><span class="s">&quot;path&quot;</span><span class="p">);</span></code></pre></figure> <h3 id="conclusion">Conclusion</h3> <p>I&#x2019;m excited about the new capability of the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-3.0">AssemblyLoadContext</a> class and how it is implemented. It extends the possibilities regarding the architecture and functionality of an application.
Hopefully you like my post and you could take something useful away from it. Let me know what you think :)</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>