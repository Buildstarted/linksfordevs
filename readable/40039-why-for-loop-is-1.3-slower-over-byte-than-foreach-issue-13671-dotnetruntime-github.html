<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Why for loop is 1.3 slower over byte[] than foreach &#xB7; Issue #13671 &#xB7; dotnet/runtime &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Why for loop is 1.3 slower over byte[] than foreach  · Issue #13671 · dotnet/runtime · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>This is likely a CQ regression introduced by the fix for <a class="issue-link js-issue-link" data-error-text="Failed to load issue title" data-id="557886472" data-permission-text="Issue title is private" data-url="https://github.com/dotnet/runtime/issues/9486" data-hovercard-type="issue" data-hovercard-url="/dotnet/runtime/issues/9486/hovercard" href="https://github.com/dotnet/runtime/issues/9486">#9486</a>, I'm pretty sure range check elimination was working in this case before that fix.</p><p>The problem is that JIT's value numbering correctly concluded that the 2 <code>_byteData</code> accesses will produce the same value, assuming that there is no thread interference. This assumption is valid for many purposes, since thread interference in this case implies that there's a race condition in the user code and race conditions are basically undefined behavior.</p><p>However, this assumption is not valid for range check elimination because said undefined behavior does not include out of range array access, that would compromise type safety.</p><p>The fix that was done is probably more conservative than it needs to be. At least in this case, the redundant field load is eliminated by CSE so the race condition effectively disappears. Unfortunately CSE is not something that can be guaranteed so performing the optimization correctly is a bit more complicated - it has to be done only after CSE did eliminate the load or it has to somehow force CSE to happen.</p><p>It may be possible to improve this. But at least for the presented example this is completely pointless, there's no reason not to use <code>foreach</code> in this case.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>