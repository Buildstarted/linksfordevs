<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Inlining and explicit tail calls &#xB7; Issue #10487 &#xB7; dotnet/runtime &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Inlining and explicit tail calls · Issue #10487 · dotnet/runtime · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><blockquote><p>former: callee frame is not overly huge; latter: call site is in tail position</p></blockquote><p>Are these checks even required?</p><p>I think, from a programmer's perspective, the following is a reasonable assumption: for any sequence of explicit tail calls, the stack usage will be constant. The important case is when the sequence of explicit tail calls depends on an incoming data structure like a list, where this assumption is necessary to get correct behavior (no stack overflow).</p><p>Even inlining without these two checks should satisfy this assumption. For the former we are bloating the stack somewhat, but only in the beginning of the sequence: presumably the inlinee will also contain an explicit tail call, and if the inlinee is not inlined in tail-call position, this will turn into a regular call. However, once this regular call begins the future call sequence will use only constant amount of stack. So the stack usage is amortized constant in the input.</p><p>For the latter case we have the exact same situation. The explicit tail call may turn into a regular call bloating the stack in the beginning of the sequence. But we still only end up with amortized constant stack usage.</p><p>Now that is not say that it is not beneficial to use these decisions in the profitability analysis. But I think we already get them basically for free, since a callee with a large frame would (usually?) have large IL.</p><blockquote><p>Probably also: if the jit is going to emit a slow tail call (or fail to tail call), consider allowing inlining?</p><ul><li>not clear how many slow tail call candidates will be good inline candidates.</li><li>not clear how easily we can anticipate failure or slowness early on.</li></ul></blockquote><p>I think these are the more important pieces of information. Inlining a callee in tail call position should not be done if it means we end up requiring helper where we wouldn't before. However, I think due to the above points we can basically ignore any explicit tail prefix in inlinees during inlining, in which case we will never end up with helper anyway. What do you think?</p><p>EDIT: I have just realized I am wrong that we can ignore tail prefixes in inlinees – we have to honor them if they are inlined in explicit tail call position, since the inliner could participate in the call sequence. That makes things harder.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>