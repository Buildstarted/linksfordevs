<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Part 5: A better way to handle authorization &#x2013; refreshing user&#x2019;s claims -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Part 5: A better way to handle authorization &#x2013; refreshing user&#x2019;s claims</h1>
    <li>
<ul><li>
<ul><li>Lines 6 to 9: This is looking for changes that could affect an existing user. The table below shows what type of changes could affect a user&#x2019;s current Permissions. There are three classes UserToRole, ModulesForUsers and RolesToPermissions which I decorate with the approriate interfaces to detect any changes that could effect a user&#x2019;s Permissions.</li>
<li>Line ???: If a change is found it calls the AddOrUpdate method in the IAuthChange instance that is injected into the ExtraAuthorizeDbContext. I describe the AuthChange class in section 3.</li>
</ul></li>
</ul>
<p>Once the SaveChanges have detected a change we need to store the time that change happens. This is done via a class called TimeStore which is shown below.</p>
<pre class="brush: csharp; title: ; notranslate">
public class TimeStore
{
    [Key]
    [Required]
    [MaxLength(AuthChangesConsts.CacheKeyMaxSize)]
    public string Key { get; set; }

    public long LastUpdatedTicks { get; set; }
}
</pre>
<p>This is a Key/Value cache, where the Value is a long (Int64) containing the time as ticks when the item was changes. I did this way because I would use this same store to contain changes in any my hierarchical DataKeys (see <a href="https://www.thereformedprogrammer.net/part-4-building-a-robust-and-secure-data-authorization-with-ef-core/">Part4 article</a>), which I don&#x2019;t cover in this article.</p>
<blockquote><p>NOTE: In the <a href="https://www.thereformedprogrammer.net/part-4-building-a-robust-and-secure-data-authorization-with-ef-core/">Part4 article</a> I describe a multi-tenant system which is hierarchical. In that case if I move a SubGroup (e.g. West Coast division) to a different parent, then the DataKey would change, along with all its &#x201C;child&#x201D; data. In this case you MUST refresh any logged-in user&#x2019;s DataKey otherwise a logged-in user would have access to the wrong data. That is why I used a generalized TimeStore so that I could add a per-company &#x201C;LastUpdated&#x201D; value.</p></blockquote>
<p>I also add a the ITimeStore interface ExtraAuthorizationDbContext which the AuthChanges class (see next section) can use. The ITimeStore defines two methods:</p>
<ol><li>GetValueFromStore, which reads a value from the TimeStore</li>
<li>AddUpdateValue, which adds or update the TimeStore</li>
</ol><p>You will see these being used in the next section.</p> <p>I created a small project called CommonCache which lives at the bottom of the solution structure, i.e. it doesn&#x2019;t reference to any other project. This contains AuthChange class, which links between the database and the code handling the authorization.</p>
<p>This AuthChange class provides a method that the authorization code can call to check if the user&#x2019;s authorization Claims are out of date. And at the database end it creates the correct cache key/value when the database detects a change in the authorization database classes.</p>
<p>Here is the AuthChange class code below (see <a href="https://github.com/JonPSmith/PermissionAccessControl2/blob/master/CommonCache/AuthChanges.cs">this link</a> to actual code).</p>
<pre class="brush: csharp; title: ; notranslate">
public class AuthChanges : IAuthChanges
{
    public bool IsOutOfDateOrMissing(string cacheKey, 
        string ticksToCompareString, ITimeStore timeStore)
    {
        if (ticksToCompareString == null)
            //if there is no time claim then you do need to reset the claims
            return true;

        var ticksToCompare = long.Parse(ticksToCompareString);
        return IsOutOfDate(cacheKey, ticksToCompare, timeStore);
    }

    private bool IsOutOfDate(string cacheKey, 
        long ticksToCompare, ITimeStore timeStore)
    {
        var cachedTicks = timeStore.GetValueFromStore(cacheKey);
        if (cachedTicks == null)
            throw new ApplicationException(
                $&quot;You must seed the database with a cache value for the key {cacheKey}.&quot;);

        return ticksToCompare &lt; cachedTicks;
    }

    public void AddOrUpdate(ITimeStore timeStore)
    {
        timeStore.AddUpdateValue(AuthChangesConsts.FeatureCacheKey, 
             DateTime.UtcNow.Ticks);
    }
}
</pre>
<p>The things to note are:</p>
<ul><li>Lines 3 to 12: The IsOutOfDateOrMissing method is called by the ValidateAsync method (described in the next section) uses to find out if the User&#x2019;s claims need recalculating, i.e. it returns true if the User&#x2019;s claims &#x201C;LastUpdated&#x201D; is missing, or it is earlier then the database &#x201C;LastUpdated&#x201D; time. You can see the cache read in line 17 inside the private method that does the time compare.</li>
<li>Lines 25 to 29: The AddOrUpdate method makes sure the ITimeStore has an entry under the key defined by FeatureCacheKey which has the current time in ticks. This is referred to as the database &#x201C;LastUpdated&#x201D; value.</li>
</ul>
<p>In the <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-authorization-in-asp-net-core/#how-do-i-turn-the-roles-into-a-permissions-claim">Part1 article I showed how you can add claims to the user</a> at login time via the Authentication Cookie&#x2019;s OnValidatePrincipal event, but these claims are &#x201C;frozen&#x201D;. However, this event is perfect for our &#x201C;refresh claims&#x201D; feature because the event happens on every HTTP request. So, in the new version 2 <a href="https://github.com/JonPSmith/PermissionAccessControl2">PermissionAccessControl2</a> code I have altered the code to add the &#x201C;refresh claims&#x201D; feature. Below is the new version of the ValidateAsync method, with comments on the key parts of the code at the bottom. (use <a href="https://github.com/JonPSmith/PermissionAccessControl2/blob/master/CommonCache/AuthChanges.cs">this link</a> to go to the actual AuthCookieValidate class which contains these methods)</p>
<pre class="brush: csharp; title: ; notranslate">
public async Task ValidateAsync(CookieValidatePrincipalContext context)
{
    var extraContext = new ExtraAuthorizeDbContext(
        _extraAuthContextOptions, _authChanges);
    //now we set up the lazy values - I used Lazy for performance reasons
    var rtoPLazy = new Lazy&lt;CalcAllowedPermissions&gt;(() =&gt; 
        new CalcAllowedPermissions(extraContext));
    var dataKeyLazy = new Lazy&lt;CalcDataKey&gt;(() =&gt; 
        new CalcDataKey(extraContext));

    var newClaims = new List&lt;Claim&gt;();
    var originalClaims = context.Principal.Claims.ToList();
    if (originalClaims.All(x =&gt; 
        x.Type != PermissionConstants.PackedPermissionClaimType) ||
        _authChanges.IsOutOfDateOrMissing(AuthChangesConsts.FeatureCacheKey, 
            originalClaims.SingleOrDefault(x =&gt; 
                 x.Type == PermissionConstants.LastPermissionsUpdatedClaimType)?.Value,
            extraContext))
    {
        var userId = originalClaims.SingleOrDefault(x =&gt; 
             x.Type == ClaimTypes.NameIdentifier)?.Value;
        newClaims.AddRange(await BuildFeatureClaimsAsync(userId, rtoPLazy.Value));
    }

    //&#x2026; removed DataKey code as not relevant to this article

    if (newClaims.Any())
    {
        newClaims.AddRange(RemoveUpdatedClaimsFromOriginalClaims(
              originalClaims, newClaims));
        var identity = new ClaimsIdentity(newClaims, &quot;Cookie&quot;);
        var newPrincipal = new ClaimsPrincipal(identity);
        context.ReplacePrincipal(newPrincipal);
        context.ShouldRenew = true;             
    }
    extraContext.Dispose(); //be tidy and dispose the context.
}

private IEnumerable&lt;Claim&gt; RemoveUpdatedClaimsFromOriginalClaims(
    List&lt;Claim&gt; originalClaims, List&lt;Claim&gt; newClaims)
{
    var newClaimTypes = newClaims.Select(x =&gt; x.Type);
    return originalClaims.Where(x =&gt; !newClaimTypes.Contains(x.Type));
}

private async Task&lt;List&lt;Claim&gt;&gt; BuildFeatureClaimsAsync(
    string userId, CalcAllowedPermissions rtoP)
{
    var claims = new List&lt;Claim&gt;
    {
        new Claim(PermissionConstants.PackedPermissionClaimType, 
             await rtoP.CalcPermissionsForUserAsync(userId)),
        new Claim(PermissionConstants.LastPermissionsUpdatedClaimType,
             DateTime.UtcNow.Ticks.ToString())
    };
    return claims;
}
</pre>
<p>The things to note are:</p>
<ul><li>Lines 13 to 18: This checks if the PackedPermissionClaimType Claim is missing, or that the LastPermissionsUpdatedClaimType Claim&#x2019;s value is either out of date or missing. If either of these are true then it has to recalculate the user&#x2019;s Permissions, which you can see in lines 19 to 23.</li>
<li>Lines 46 to 57: This adds the two claims needed: the PackedPermissionClaimType Claim with the user&#x2019;s recalculated Permissions, and the LastPermissionsUpdatedClaimType Claim which is given the current time.</li>
</ul><h3 id="5-how-to-tell-your-front-end-that-the-permissions-have-changed">5. How to tell your front-end that the Permissions have changed<a class="anchorlink dashicons-before" href="#5-how-to-tell-your-front-end-that-the-permissions-have-changed"></a></h3>
<p>If you are using some form of front-end framework, like React.js, Angular.js, Vue.js etc. then you will use the Permissions in the front-end to select what buttons, links etc to show. In the Part3 article I showed a <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/#2-working-with-a-javascript-front-end-framework">very simple API to get the Permissions names</a>, but now we need to know when to update the local Permissions in your front end.</p>
<p>My solution is to add a header to every HTTP return that gives you the &#x201C;LastUpdated&#x201D; time when the current user&#x2019;s Permissions where updated. By saving this value in the JavaScript <a href="https://www.w3schools.com/jsref/prop_win_sessionstorage.asp">SessionStorage</a> you can compare the time provided in the header with the last value you had &#x2013; if they are different then you need to re-read the permissions for the current user.</p>
<p>Its pretty easy to add a header, and here is the code inside the Configure method inside the Startup class in your ASP.NET Core project. Here is the code (with thanks to SO answer <a href="https://stackoverflow.com/a/48610119/1434764">https://stackoverflow.com/a/48610119/1434764</a>) and here is <a href="https://github.com/JonPSmith/PermissionAccessControl2/blob/master/PermissionAccessControl2/Startup.cs#L120L133">a link to the actual code</a> in the startup class to see where it goes.</p>
<pre class="brush: csharp; title: ; notranslate">
//This should come AFTER the app.UseAuthentication() call
if (Configuration[&quot;DemoSetup:UpdateCookieOnChange&quot;] == &quot;True&quot;)
{
    app.Use((context, next) =&gt;
    {
        var lastTimeUserPermissionsSet = context.User.Claims
            .SingleOrDefault(x =&gt; 
                 x.Type == PermissionConstants.LastPermissionsUpdatedClaimType)
            ?.Value;
        if (lastTimeUserPermissionsSet != null)
            context.Response.Headers[&quot;Last-Time-Users-Permissions-Updated&quot;] 
                 = lastTimeUserPermissionsSet;
        return next.Invoke();
    });
}
</pre> <p>While the &#x201C;refresh claims&#x201D; feature is useful it does have some downsides. Firstly it is a lot more complex than using the <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/#a-simpler-way-to-add-to-the-users-claims">UserClaimsPrincipalFactory approach explained in the Part3 article</a>. Complexity makes the application harder to understand and can be harder to refactor.</p>
<p>Also, I only got the &#x201C;refresh claims&#x201D; feature to work for Cookie authentication, while the &#x201C;frozen&#x201D; implementation I showed in the Part3 article works with both Cookie or Token authentication. If you need a token solution then a good starting point is the <a href="https://www.blinkingcaret.com/">https://www.blinkingcaret.com/</a> blog (you might find this article useful &#x201C;<a href="https://www.blinkingcaret.com/2018/05/30/refresh-tokens-in-asp-net-core-web-api/">Refresh Tokens in ASP.NET Core Web Api&#x201D;</a>).</p>
<p>The other issue is performance. For every HTTP request a read of the TimeStore is required. Now that request is very small and only take about 750ns on my I7, 4GHz Windows development PC, but with lots of simultaneous users you would be loading up the database. But the good news is that using a database means it automatically works with multiple instances of a web application (known as <a href="https://azure.microsoft.com/en-gb/resources/videos/scale-a-web-app-using-azure-scale-out/">scale-out</a>).</p>
<blockquote><p>NOTE: I did try adding an <a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed?view=aspnetcore-2.2#distributed-memory-cache">ASP.NET Core Distributed Memory Cache</a> to improve local performance, but because the OnValidatePrincipal event lives outside the dependency injection you end up with difference instances of the memory cache (took me a while to work that out!). You could add a cache like Redis because it relies on configuration rather than the same instance, but it does add another level of complexity.</p></blockquote>
<p>The other performance issue is it has to refresh EVERY logged in user, as it doesn&#x2019;t have enough information to target the specific users that need an update. If you have thousands of concurrent users that will bring a higher-than-normal load on the application and the database. Overall recalculating the Permissions aren&#x2019;t that onerous, but it may be worth changing any roles and permissions outside the site&#x2019;s peak usage times.</p>
<p>Overall, I would suggest you think hard as to whether you need the &#x201C;refresh claims&#x201D; feature. Most authentication systems don&#x2019;t have &#x201C;refresh claims&#x201D; feature as standard, so remember the <a href="https://www.martinfowler.com/bliki/Yagni.html">Yagni</a> (&#x201C;You Aren&#x2019;t Gonna Need It&#x201D;) rule. But if you do need it, then now you know one way to implement it!</p>
<h2 id="conclusion">Conclusion<a class="anchorlink dashicons-before" href="#conclusion"></a></h2>
<p>This article has focused on one specific feature that readers of my first article felt was needed. I believe my solution to the &#x201C;refresh claims&#x201D; feature is robust, but there are some (small?) downsides which I have listed. You can find all the code in this article, and a runnable example application, in the GitHub repo <a href="https://github.com/JonPSmith/PermissionAccessControl2">PermissionAccessControl2</a>.</p>
<p>When I first developed the whole feature/data authorization approach for one of my clients we discussed whether we needed the &#x201C;refresh claims&#x201D; feature. They decided it wasn&#x2019;t worth the effort and I think that was right decision for their application.</p>
<p>But if your application/users need the refresh claims feature then you now have a fully worked out approach which will still work even on web apps that scale out, i.e. run multiple instances of the web app to give better scalability.</p>
<p>Happy coding!</p>
<p>PS. Have a look at Andrew Lock&#x2019;s excellent series &#x201C;<a href="https://andrewlock.net/series/adding-feature-flags-to-an-asp-net-core-app/">Adding feature flags to an ASP.NET Core app</a>&#x201D; for another useful feature to add to your web app.</p> <p><span><strong>If you have a ASP.NET Core or Entity Framework Core problem that you want help on then I am available as a freelance contractor. Please send me a contact request via my </strong><a href="https://www.thereformedprogrammer.net/contact/"><strong>Contact</strong></a><strong> page and we can talk some more on Skype.</strong></span></p></li>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>