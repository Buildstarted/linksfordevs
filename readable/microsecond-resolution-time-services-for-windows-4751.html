<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Microsecond Resolution Time Services for Windows - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Microsecond Resolution Time Services for Windows - linksfor.dev(s)"/>
    <meta property="article:author" content="Arno Lentfer"/>
    <meta property="og:description" content="The Windows Timestamp Project provides high resolution timestamp, timekeeping, NTP synchronization, and timer routines for Windows"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://www.windowstimestamp.com/description"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Microsecond Resolution Time Services for Windows</title>
<div class="readable">
        <h1>Microsecond Resolution Time Services for Windows</h1>
            <div>by Arno Lentfer</div>
            <div>Reading time: 96-122 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="http://www.windowstimestamp.com/description">http://www.windowstimestamp.com/description</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="Content">
			
			<h5>Arno Lentfer, June 2012</h5>
			<h5><span>Last Update: Version 3.10, May 2019</span></h5>
			
			<h2>1.&nbsp;&nbsp;Abstract</h2>
				<p>	Various methods for obtaining high resolution time stamping on Windows have been 
					described. The most promising implementations have been proposed by W. Nathaniel Mills: "<a href="http://web.archive.org/web/20111105021250/http://www.ibm.com/developerworks/library/i-seconds/">When microseconds matter</a>"
					<!-- IBM removed the content, thus replaced link with content in web archive <a href="http://www.ibm.com/developerworks/library/i-seconds/">When microseconds matter</a>"-->
					(2002) and Johan Nilsson: "<a href="http://msdn.microsoft.com/en-us/magazine/cc163996.aspx">Implement a Continuously Updating, High-Resolution Time Provider for Windows</a>
					" (2004).</p>	
				<p> Suggested auxiliary initial reading: Keith Wansbrough: "<a href="http://www.lochan.org/2005/keith-cl/useful/win32time.html">Obtaining 
					Accurate Timestamps under Windows XP</a>" (2003), msdn: "<a href="http://web.archive.org/web/20140213124142/http:/msdn.microsoft.com/en-us/windows/hardware/gg463347.aspx">Guidelines 
					for Providing Multimedia Timer Support</a>", and Chuck Walbourn: "<a href="http://msdn.microsoft.com/en-us/library/ee417693(VS.85).aspx">Game 
					Timing and Multicore Processors</a>" (2005).</p>	
				<p> A substantial amount of time and effort has been spent on the attempt to get a proper high resolution time service implemented for Windows. 
					However, the performance of these implementations is still not satisfactory. The complexity arises from the variety of Windows versions
					running on an even greater variety of hardware platforms.</p>
				<p> Proper implementation of an accurate time service for Windows will be discussed and diagnosed within the Windows timestamp project. 
					Test code will be released to prove functionality on a broader range of hardware platforms. Besides the timestamp functionality, 
					high resolution (microsecond) timer functions are also discussed.</p>
			<h2>2.&nbsp;&nbsp;Resources</h2>
			
				<p> Time resources on Windows are mostly interrupt controlled entities. Therefore, they show a certain granularity. Typical interrupt periods are 10 ms to 20 ms. 
					The interrupt period can also be set to be 1 ms or even a little below 1 ms by using API calls to <i>NTSetTimerResolution</i> or 
					<i>timeBeginPeriod</i>. However, for several reasons they can and shall never be set to anything near the 1 μs regime. 
					The best resolution to observe by means of Windows time services is therefore in the 1 ms regime. </p>
				<p>	The best resource for retrieving the system time is the <i>GetSystemTimeAsFileTime</i> 
					API. It is a fast access API that is able to hold sufficiently accurate (100 ns units) values in its arguments. The alternative API is <i>GetSystemTime</i>,
					which is 20 times slower, has double the structure size, and does not provide a well-suited data format. </p>	
				<p> An interrupt independent system resource is used to extend the accuracy into the microsecond regime i.e., the performance counter. 
					The performance counter API provides the asynchronous calls <i>QueryPerformanceCounter</i> and <i>QueryPerformanceFrequency</i>.
					A virtual counter delivers a performance counter value, which increases by a performance counter frequency. The frequency is typically a few MHz 
					and can therefore open the microsecond regime. The counter parameters are typically backed by a physical counter, but they are not necessarily independent of the 
					version of the operating system. A hardware platform can deliver different performance frequencies when running Windows 7 or Windows Vista, for example.</p>
				<p>	The Sleep() API and the WaitableTimer API are further timing resources in the context of this project. Their functionality and their habit also need to be looked at.</p>

				<h3>2.1.&nbsp;&nbsp;GetSystemTimeAsFileTime API</h3>
		
					<p> The GetSystemTimeAsFileTime API provides access to the system time in file time format. It is stated as</p>
					<p>void WINAPI GetSystemTimeAsFileTime(OUT LPFILETIME <i>lpSystemTimeAsFileTime</i>);</p>
					<p> with its argument of type</p>
					<p>typedef struct _FILETIME {<br>
						<span></span>DWORD dwLowDateTime;<br>
						<span></span>DWORD dwHighDateTime;<br>
						} FILETIME;<br>
					</p>	
					<p> A 64-bit FILETIME structure receives the system time as FILETIME in 100ns units, which have been expired since Jan 1, 1601. 
						After some 400 years about 1.28×10<sup>10</sup> seconds or 1.28×10<sup>17</sup> 100ns slices have been accumulated. 
						The 64-bit value can hold almost 2×10<sup>19</sup> 100 ns time slices. The remaining time before this scheme wraps would be about 58,000 years from now. 
						The call to GetSystemTimeAsFileTime typically requires 10 ns to 15 ns.</p>
					<p>	In order to investigate the real accuracy of the system time provided by this API, the granularity that comes along with the time values needs to be discussed. 
						In other words: How often is the system time updated? A first estimate is provided by the hidden API call:</p>

					<p>NTSTATUS NtQueryTimerResolution(<br>
						<span></span>OUT PULONGMinimumResolution,<br>
						<span></span>OUT PULONGMaximumResolution,<br>
						<span></span>OUT PULONGActualResolution);</p>
						
					<p> NtQueryTimerResolution is exported by the native Windows NT library NTDLL.DLL. The <i>ActualResolution</i> reported by this call represents the update period 
						of the system time in 100 ns units, which obviously does not necessarily match the interrupt period. The value depends on the hardware platform. Common hardware platforms 
						report 156,250 or 100,144 for <i>ActualResolution</i>; older platforms may report even larger numbers. This is one of the heartbeats controlling the system. 
						The <i>MinimumResolution</i> and the <i>ActualResolution</i> are relevant for the multimedia timer configuration. 
						Two common hardware platform configurations are discussed here to highlight the details to be dealt with:</p>
				
					<p>Platform configuration A</p>	
						<table>
							<tbody><tr><td>- Min. Res.:</td><td>156,250</td></tr>
							<tr><td>- Max. Res.:</td><td>10,000</td></tr>
							<tr><td>- ActualRes.:</td><td>156,250</td></tr>
						</tbody></table>					
						
					<p>Platform configuration B</p>	
						<table>
							<tbody><tr><td>- Min. Res.:</td><td>100,144</td></tr>
							<tr><td>- Max. Res.:</td><td>10,032</td></tr>
							<tr><td>- ActualRes.:</td><td>100,144</td></tr>
						</tbody></table>					
					<p> Platform A simply has 64 timer interrupts per second (64 x 156,250 x 100 ns = 1 s), but when looking at platform B the difficulties become more obvious: 
						99.856 interrupts per second? Answer: The full second interrupt is not available on all platforms.</p>
					<p> However, the system time may be updated at these interrupt events. An API call to</p>
					<p>BOOL WINAPI GetSystemTimeAdjustment(<br>
						<span></span>OUT PDWORD lpTimeAdjustment,<br>
						<span></span>OUT PDWORD lpTimeIncrement,<br>
						<span></span>OUT PBOOL lpTimeAdjustmentDisabled);</p>
					<p> will disclose the time adjustment and time increment values. The actual purpose of this call is to query the status of the system time correction, which is active when 
						<i>TimeAdjustmentDisabled</i> is FALSE. When <i>TimeAdjustmentDisabled</i> is TRUE, no adjustment takes place and <i>TimeAdjustemt</i> and <i>TimeIncrement</i> are equal 
						and do report exactly what was read as <i>ActualResolution</i> before. For a platform A type system, the call will report that the system time has incrementally increased by 156,250 
						100 ns units every 156,250 100 ns units. Within this description, this is considered the <i>granularity</i> of the system time.</p>
					<p> Knowing the system time granularity raises doubts about its accuracy. Certainly, the <i>TimeIncrement</i> will be applied, thus changes of the system 
						time will always be one <i>TimeIncrement</i>, but does the interrupt period or any multiple of it always match the time increment?</p>
					<p>	Even when the standard setting of <i>ActualResolution</i> corresponds to the <i>MinimumResolution</i>, the <i>ActualResolution</i> may have a setting different from 
						<i>MinimumResolution</i> (see table below). In fact it may be configured to values in the range from <i>MinimumResolution</i> to <i>MaximumResolution</i>. 
						The <i>ActualResolution</i> determines the interrupt period of the system. That is the period after which the timer generates an interrupt to let the system react.
						The <i>ActualResolution</i> can be set by using the API call</p>
					<p>NTSTATUS NtSetTimerResolution(<br>
						<span></span>IN ULONG RequestedResolution,<br>
						<span></span>IN BOOLEAN Set,<br>
						<span></span>OUT PULONG ActualResolution);</p>
					<p> or via the multimedia timer interface</p>
					<p>MMRESULT timeBeginPeriod(UINT uPeriod);</p>
					<p>	with the value of <i>uPeriod</i> derived from the range allowed by</p>
					<p>MMRESULT timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc);</p>
					<p> which fills the structure</p>
					<p>typedef struct {<br>
						<span></span>UINT wPeriodMin;<br>
						<span></span>UINT wPeriodMax;<br>
						<span></span>} TIMECAPS;</p>

					<p> Typical values are 1 ms for <i>wPeriodMin</i> and 1,000,000 ms for <i>wPeriodMax</i>. The 1,000 s period for <i>wPeriodMax</i> is somewhat meaningless within the context 
					of this description. However, the possibility of setting the timer resolution to 1 ms requires a more detailed investigation. When the multimedia timer interface is used to set 
					the multimedia timer to <i>wPeriodMin</i>, the <i>ActualResolution</i> received by a call to <i>NtQueryTimerResolution</i> will show a new value. 
					For the two platform configurations discussed, the examples are as follows:</p>

					
					<table>
						<tbody><tr><td>MinimumRes.</td><td>156,250</td><td>100,144</td></tr>
						<tr><td>MaximumRes.</td><td> 10,000</td><td> 10,032</td></tr>
						<tr><td>ActualRes.</td><td>156,250</td><td>100,144</td></tr>
					</tbody></table>

					<p><i>ActualResolution</i> varies according to the varying multimedia timer periods <i>uPeriod</i> applied by the timeBeginPeriod() API:</p>
					<table>
						<tbody><tr><td>Platform configuration</td><td>A</td><td>B</td><td><i>uPeriod</i></td></tr>
					</tbody></table>
					<table>
						<tbody><tr><td>ActualRes.</td><td>9,766</td><td>10,032</td><td>1 ms</td></tr>
						<tr><td>ActualRes.</td><td>19,532</td><td>20,064</td><td>2 ms</td></tr>
						<tr><td>ActualRes.</td><td>19,532</td><td>30,096</td><td>3 ms</td></tr>
						<tr><td>ActualRes.</td><td>39,063</td><td>39,952</td><td>4 ms</td></tr>
						<tr><td>ActualRes.</td><td>39,063</td><td>49,984</td><td>5 ms</td></tr>
						<tr><td>ActualRes.</td><td>39,063</td><td>60,016</td><td>6 ms</td></tr>
						<tr><td>ActualRes.</td><td>39,063</td><td>70,048</td><td>7 ms</td></tr>
						<tr><td>ActualRes.</td><td>156,250</td><td>80,080</td><td>8 ms</td></tr>
						<tr><td>ActualRes.</td><td>156,250</td><td>89,936</td><td>9 ms</td></tr>
						<tr><td>ActualRes.</td><td>156,250</td><td>100,144</td><td>10 ms</td></tr>
						<tr><td>ActualRes.</td><td>156,250</td><td>100,144</td><td>11 ms</td></tr>
						<tr><td>ActualRes.</td><td>156,250</td><td>100,144</td><td>12 ms</td></tr>
						<tr><td>…</td><td>…</td><td>…</td><td>…</td></tr>
						<tr><td>ActualRes.</td><td>156,250</td><td>100,144</td><td>100 ms</td></tr>
					</tbody></table>
					<p> This list shows the supported interrupt periods for platforms of type A and B in 100 ns units. Platform A only supports four different
						interrupt heartbeat frequencies, while platform B has a better approximation to the desired period. The specific numbers are relevant 
						for the procedures described here and thus need a detailed interpretation.</p>
					<p> Note: <i>TimeIncrement</i> provided by <i>GetSystemTimeAdjustment</i> and <i>ActualResolution</i> provided by <i>NtQueryTimerResolution</i> are not 
						necessarily identical. 
						<span>
						Platform A operates with an ACPI PM timer and platform B operates with a PIT timer. More modern platforms do not show "unsupported" values of <i>uPeriod</i>.
						</span>
						</p>		
					
					<h3>2.1.1.&nbsp;&nbsp;<i>ActualResolution</i> on Platform Type A</h3>
						<p>	The timer intervals are given with 100 ns accuracy in the last digit. Since the true <i>ActualResolution</i> cannot be expressed correctly, 
							rather than reporting the true <i>ActualResolution</i> of 0.9765625 ms the call to <i>NtQueryTimerResolution</i> reports the rounded value of
							0.9766 ms. The other values are also rounded (shall be 1.953125 ms and 3.90625 ms respectively).</p>
						<p> A quick test using the Sleep(dwMilliseconds) API confirms this assumption:</p>
						<p> Sleep(1) = 1.9531 ms = 2 x 0.9765625 ms</p>
						<p> Sleep(2) = 2.9295 ms = 3 x 0.9765625 ms</p>
						<p> Sleep(3) = 3.9062 ms = 4 x 0.9765625 ms</p>
						<p> The Sleep()	will only return when n x <i>ActualResolution</i> exceeds the desired duration. The required accuracy for the interval 
							specification would have to extend to 0.5 ns, in other words show the 100 ps digit. The number would be 156,250,000 for the <i>MinimumResolution</i> 
							and 9,765,625 for the <i>MaximumResolution</i> (in 100 ps or 10<sup>-10</sup> s units).</p>
						<p> Note: Sleep(1) measurements (10,000, with 100 ahead) result in a mean delay of 1953.163824 μs. This is 2.0000397 times
							the interrupt time slice (should have been 1953.125 μs, so the measurement was off by 0.04 μs).</p>

					<h3>2.1.2.&nbsp;&nbsp;<i>ActualResolution</i> on Platform Type B</h3>
						<p>	An interrupt timer period of 1.0032 ms will accumulate 10.032 ms after 10 interrupts and change the system time by 10.0144 ms. 
							A time change of 10.0144 ms after 10.032 ms means that the time is behind by 176 μs. At the 57th of such periods, the deviation 
							has accumulated to 1.0032 ms, which is exactly one timer interrupt period and the time will be updated after just 9 interrupts (9.0288ms). 
							This way the time is updated by 10.0144 ms 56 times after 10.032 ms and one time after 9.0288 ms, which is a total elapsed time of 
							570.8208 ms with an adjustment of 57*10.0144 ms = 570.8208 ms. This corresponds to a total number of interrupts of 569 (57*100,144 = 569*10,032). 
							As a result, the time will lose 176 μs for each of the 56 consecutive system time updates and then gain 9.856 ms in the 57<sup>th</sup> interrupt interval.</p>
		
					<h3>2.1.3.&nbsp;&nbsp;Changes of System File Time</h3>
						<p>	The system time changes according to the described mechanisms after a certain period of time. Additional time changes do
							happen if time corrections are caused by periodic time changes, which are continuously applied to the system time over a 
							longer period of time to adjust to an external time reference. The occurrence and the parameters of this adjustment can be gathered by 
							a call to <i>GetSystemTimeAdjustment</i>. Sudden time changes, for example, introduced by using the clock GUI or <i>SetSystemTime(…)</i> 
							, are not announced or predictable; they happen spontaneously.</p>
						<p>	Changes of the system time will have no influence on the expiration of Sleep periods or waitable timer periods. The actual change will 
							be taken over by the routines here. Nevertheless, system time changes are discontinuities in time, whether they are sudden or spread over a
							longer period of time. What is an accurate time stamp supposed to deliver when the system inserts several hundred seconds at an interval
							of 1.0000032 s? The system will assume that the seconds are that long (elongated) for the time being. This can be accomplished by 
							the temporary adaptation of the performance counter frequency to the applied granular time correction.</p>

					<h3>2.1.4.&nbsp;&nbsp;Windows 7/8/8.1/10 and Server 2008 R2/2012/2012 R2/2016</h3>
						<p> Time services on windows have undergone changes with any new version of Windows. Considerable changes are to be reported beyond VISTA 
							and Server 2008. The synchronous progress in hardware and software development requires the software to stay compatible with a whole 
							variety of hardware platforms. On the other hand new hardware enables the software to conquer better performance. Today's hardware 
							provides the High Precision Event Timer (HPET) and an invariant Time Stamp Counter (TSC). The variety of timers is described in
							"<a href="http://web.archive.org/web/20140213124142/http:/msdn.microsoft.com/en-us/windows/hardware/gg463347.aspx">Guidelines For Providing Multimedia Timer Support</a>".
							The "<a href="http://web.archive.org/web/20070315153153/http:/www.intel.com/hardwaredesign/hpetspec_1.pdf">IA-PC HPET Specification</a>"
							is now more than 10 years old and some of the goals have not yet been reached (e.g. aperiodic interrupts). While QueryPerformanceCounter 
							benefited using the HPET/TSC when compared to ACPI PM timer, these days the HPET is outdated by the invariant TSC for many applications.
							However, the typical HPET signature (<i>TimeIncrement</i> of the function GetSystemTimeAdjustment() and <i>MinimumResolution</i> of the 
							function NtQueryTimerResolution() are 156001) disappeared with Windows 8.1. Windows 8.1 goes back to the roots; it goes back to 156250.
							The TSC frequency is calibrated against HPET periods to finally get proper timekeeping.</p>
						<p> An existing invariant TSC influences the behavior of GetSystemTimeAsFileTime() noticeable. The influence to the functions QueryPerformanceCounter() 
							and QueryPerformanceFrequency() is described in sections 2.4.3. and 2.4.4. Windows 8 introduces the function 
							<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh706895(v=vs.85).aspx">GetSystemTimePreciseAsFileTime()</a> 
							<i>"with the highest possible level of precision (&lt;1us)"</i>. This seems the counterpart to the linux gettimeofday() function.</p>

						<h3>2.1.4.1.&nbsp;&nbsp;Resolution, Granularity, and Accuracy of System Time</h3>
							<p> Since Windows 7, the operating system runs tests on the underlying hardware to see which hardware is best used for timekeeping. 
								When the processors Time Stamp Counter (TSC) is suitable, the operating system uses the TSC for timekeeping. If the TSC cannot 
								be used for timekeeping the operating system reverts to the High Precision Event Timer (HPET). If that does not exist it reverts 
								to the ACPI PM timer. For performance reasons it shall be noted that HPET and ACPI PM timer cause IPC overhead, while the  use 
								of the TSC does not. The evolution of TSC shows a variety of capabilities:</p>
							<ul>
								<li>Constant: The TSC does not change with CPU frequency changes, however it does change on C state transitions.</li>
								<li>Invariant: The TSC increments at a constant rate in all ACPI P-, C- and T-states.</li>
								<li>Nonstop: The TSC has the properties of both Constant and Invariant TSC.</li>
							</ul>
							<p> Details of the TSC capabilities are described in 
								"<a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3b-part-2-manual.pdf">Intel® 64 and IA-32 Architectures Software Developer’s Manual</a>".
								Chapter 17.15.1 of this documentation releases the key for using the TSC for wall clock timer services:</p>
							
							<p><i> "The time stamp counter in newer processors may support an enhancement, referred to as invariant TSC. Processor’s support 
								for invariant TSC is indicated by CPUID.80000007H:EDX[8].</i></p>
							<p><i> The invariant TSC will run at a constant rate in all ACPI P-, C--, and T-states. This is the architectural behavior moving forward. 
								On processors with invariant TSC support, the OS may use the TSC for wall clock timer services (instead of ACPI or HPET timers). 
								TSC reads are much more efficient and do not incur the overhead associated with a ring transition or access to a platform resource."</i></p>
									
							<p> An invariant TSC enables QueryPerformanceCounter(), QueryPerformanceFrequency(), and GetSystemTimeAsFileTime() to be served by the 
								same hardware. Deviations, as described in 2.4.3 are non existing when the performance counter values and the wall clock are supported 
								by the same counter (TSC).</p>
							<p> More information can be obtained in 
								"<a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3b-part-2-manual.pdf">Intel 64® and IA-32 Architectures Software Developer's Manual, Volume 3B: System Programming Guide, Part 2</a>".</p>		
							<p> Polling system time changes by repeated call of GetSystemTimeAsFileTime() discloses a new behavior on Windows 8: Examples given 
								in 2.1.1. and 2.1.2. are typical timekeeping schemes for systems running with a ACPI PM timer a PIT timer respectively. System time changes occurred at 
								some regular base. This is not the case on Windows 8; a whole bunch of varying file time increments is observed when polling on 
								file time transition. A truly periodic cycle can only be approximated by a "mean increment". However, this mean increment matches 
								the result given by ActualResolution. Despite these little hiccups, resolution, granularity, and accuracy of GetSystemTimeAsFileTime() 
								are comparable to earlier Windows versions.</p>
								
						<h3>2.1.4.2.&nbsp;&nbsp;Desktop Applications: GetSystemTimePreciseAsFileTime()</h3>
							<p> This new Windows 8 API is restricted to desktop applications.</p>
							<p>VOID WINAPI GetSystemTimePreciseAsFileTime(<br>
								<span></span>_Out_ LPFILETIME, lpSystemTimeAsFileTime);</p>
							<p> GetSystemTimePreciseAsFileTime() uses the performance counter to achieve the microsecond precision. 
								 Depending on the hardware platform and Windows version, a call to QueryPerformanceCounter may be expensive or not 
								 (HPET, ACPI PM timer, or TSC, see 
								 <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dn553408%28v=vs.85%29.aspx">"MSDN: Acquiring high-resolution time stamps."</a>	
								 ). Consecutive calls may return the same result. The call time is less than the smallest increment of the system time. 
								 The granularity is in the sub-microsecond regime. The function may be used for time measurements but some care has to be taken: 
								 Time differences may be ZERO.</p>
							<p> The function shall also be used with care when a system time adjustment is active. 
								 Current Windows versions treat the performance counter frequency as a constant. The high resolution of GetSystemTimePreciseAsFileTime() 
								 is derived from the performance counter value at the time of the call and the performance counter frequency. However, the performance 
								 counter frequency should be corrected during system time adjustments to adapt to the modified progress in time. Current Windows versions 
								 don't do this. The obtained microsecond part may be severely affected when system time adjustments are active. Seconds may consist of 
								 more or less than 1.000.000 microseconds. Microsoft may or not fix this in one of the next updates/versions.</p>
							<p> GetSystemTimePreciseAsFileTime() works on all platforms.</p>	
							<p> As of Windows 10 (Build 10240), the inaccuracy of GetSystemTimePreciseAsFileTime() during system time adjustments persists.</p>
							
						<h3>2.1.4.3.&nbsp;&nbsp;Timer Periods with Invariant TSC</h3>
							<p> Using the processors invariant time stamp counter for timekeeping requires a calibration of timer periods. 
								The TSC is used as a measure for the progress in time. However, the periodic update of the system time is still done by timer hardware 
								because the TSC does not produce periodic events. Such periodic event may be generated by the HPET. Querying the timer resolutions on 
								such a platform as described in section 2.1 will produce a pattern like this:
							</p>

							
							<table>
								<tbody><tr><td>1,0007</td><td>1 ms</td></tr>
								<tr><td>2,0001</td><td>2 ms</td></tr>
								<tr><td>3,0008</td><td>3 ms</td></tr>
								<tr><td>4,0002</td><td>4 ms</td></tr>
								<tr><td>5,0009</td><td>5 ms</td></tr>
								<tr><td>6,0003</td><td>6 ms</td></tr>
								<tr><td>7,0010</td><td>7 ms</td></tr>
								<tr><td>8,0005</td><td>8 ms</td></tr>
								<tr><td>9,0012</td><td>9 ms</td></tr>
								<tr><td>10,0006</td><td>10 ms</td></tr>
								<tr><td>11,0000</td><td>11 ms</td></tr>
								<tr><td>12,0007</td><td>12 ms</td></tr>
								<tr><td>13,0001</td><td>13 ms</td></tr>
								<tr><td>14,0008</td><td>14 ms</td></tr>
								<tr><td>15,0003</td><td>15 ms</td></tr>
								<tr><td>15,6251</td><td>16 ms</td></tr>
							</tbody></table>
							
							<p> The values of <i>ActualResolution</i> are accompanied by small offsets which may vary from boot to boot but they stay 
								constant during operation. This clearly indicates that the timer periods are calibrated during boot time. Consequently, system time 
								updates are done a those periods with a mean progress of <i>ActualResolution</i>.
							</p>
							<p> The calibration of the performance counter frequency during boot is described in section 2.4. The tiny deviations 
								seen in the list above are a result of the calibration accuracy. Again: The TSC frequency is calibrated against HPET timer periods. 
								This is to be done in a reasonable short time to not extend the boot time too much. The remaining deviations are small but noticeable 
								(e.g. 1.2 μs in 9,0012 for a 9 ms period corresponds to 840ppm!).     
							</p>
							
				<h3>2.2.&nbsp;&nbsp;The Sleep API</h3>
					<p>The Sleep function suspends the execution of the current thread for a specified interval.</p>
					<p>VOID Sleep(DWORD dwMilliseconds);</p>
					<p>	This would indeed be a very useful function if it were doing what it is supposed to do. Unfortunately, a detailed view discloses
						some artifacts, some of which are helpful, and others that are not. The Sleep() function is backed up by the system's interrupt services. As described 
						in section 2.1, the interrupt period can be configured to some extent. This has a direct impact on Sleep(). The call to Sleep() passes 
						the parameter <i>dwMilliseconds</i> to the system and expects the function to return after <i>dwMilliseconds.</i> In practice the 
						Sleep() only returns when two conditions are met: Firstly, the requested delay must be expired and secondly an interrupt has occurred 
						(the test to see if the requested delay has expired is only done with an interrupt). A simple Sleep(1) call may therefore have a number of
						different results. The results also depend on the time at which the call was made with respect to the interrupt period phase.</p>
					<p>	Say the <i>ActualResolution</i> is set to 156,250, the interrupt heartbeat of the system will run at 15.625 ms periods or 64 Hz and a 
						call to Sleep is made with a desired delay of 1 ms. Two scenarios are to be looked at:
					</p><ul>
						<li>The call was made &lt; 1ms (ΔT) ahead of the next interrupt. The next interrupt will not confirm that the desired period of time has expired. 
							Only the following interrupt will cause the call to return. The resulting sleep delay will be ΔT + 15.625ms.</li>
						<li>The call was made &gt;= 1ms (ΔT) ahead of the next interrupt. The next interrupt will force the call to return.
							The resulting sleep delay will be ΔT.</li>
					</ul>	
						<p>	The observed delay heavily depends on the time at which the call was made. This matters particularly when the desired delay is
							shorter than the <i>ActualResolution</i>. However, when the <i>ActualResolution</i> is set to <i>MaximumResolution</i>, the system runs at
							its maximum interrupt frequency and the deviations are in the order of one interrupt period.</p>
						<p> This behavior can be used to synchronize code with the interrupt period in an easy way by simply calling two or more consecutive sleeps. 
							Regardless of what ΔT is, the first will end at the time of an interrupt. Consequently the following sleep call will start at the interrupt 
							time (or at least so close to it that the system will assume that it happened at the same time). As a result a ΔT = 0 applies and the sleep will
							return when N x <i>ActualResolution </i>becomes larger than the desired period. Right after the return of a sleep, the system has just processed 
							an interrupt. Conditional latency may be on board due to a priority and/or task/process switching delay or due to interrupt handler CPU capture reasons. 
							Typical latencies of a few μs can be observed with very little implementation effort.</p>
						<p>	A special case is the call Sleep(0). It looks meaningless, but it is a very powerful tool since it relinquishes the reminder of the thread's time slice. 
							That means that other threads of equal priority level will take over when ready to run. When a number of threads are running at the same priority level 
							and all of them are very responsive, all of them will make frequent calls to Sleep(0) whenever they can afford it. As a result, a task switch can be
							forced to happen in just a few μs.</p>
			
				<h3>2.3.&nbsp;&nbsp;The WaitableTimer API</h3>
					<p>	Another important mechanism for performing timed operations is provided by the waitable timer interface:</p>
					<p>HANDLE WINAPI CreateWaitableTimer(<br>
						<span></span>IN LPSECURITY_ATTRIBUTES lpTimerAttributes,<br>
						<span></span>IN BOOL bManualReset,<br>
						<span></span>IN LPCTSTR lpTimerName);</p>
					<p> The returned handle is used to setup a timer function:</p>
					<p>BOOL WINAPI SetWaitableTimer(<br>
						<span></span>IN HANDLE hTimer,<br>
						<span></span>IN const LARGE_INTEGER* pDueTime,<br>
						<span></span>IN LONG lPeriod,<br>
						<span></span>IN PTIMERAPCROUTINE pfnCompletionRoutine,<br>
						<span></span>IN LPVOID lpArgToCompletionRoutine,<br>
						<span></span>IN BOOL fResume);</p>
					<p> This tool can be unsed in a variety of ways. Below are just a few things that need to be mentioned within the scope of this description:</p>	
					<ul>
						<li>The LARGE_INTEGER structure <i>DueTime</i> specifies when the timer is to be set signaled for the first time. This is
							basically a file time, but formatted as LARGE_INTEGER to allow signed values. The sign is used by the system to allow input of absolute times (positive) or
							relative times (negative). The system time only changes in steps of <i>TimeIncrement</i> and the <i>DueTime</i> is only compared when an interrupt occurs. 
							This effectively means that the timer can only reach a signaled state for the first time when a system time transition occurs.</li>
						<li>The <i>Period</i> parameter specifies whether the timer will be a single shot timer or a periodic timer. 
							With <i>Period</i> = 0, the timer will only get signaled once when the system time has reached the <i>DueTime</i>. With <i>Period</i> &gt; 0, the period 
							specifies a timer period in ms, resulting in a timer heartbeat of <i>Period </i>ms. Similar to the Sleep, the periodic waitable timer will be set signaled 
							when <i>Period</i> expires. But this is only tested when an interrupt occurs. Real cyclic periods can only be observed if <i>Period</i> is a multiple of 
							<i>ActualResolution</i> (the interrupt period) or when the overshoot remains constant. An example for the first case can be easily described for a platform 
							configuration of type A. A timer <i>Period </i>of 1,000 ms hosts exactly 1,024 interrupt intervals of 0.9765625 ms. Such a periodic timer will be truly cyclic.<br>
							If, on such a platform, <i>Period</i> is setup to 995 ms, the timer will expired after 1,019 interrupt periods, resulting in a delay of 995.1171875 ms.
							However, the waitable timer uses the system file time and those overshoots will show deviations when a <i>Period</i> hits a system time transition. 
							In other words: A non-truly cyclic timer setup will suffer from a beat frequency with the system file time increment frequency. A detailed discussion 
							of this behavior falls outside the scope of this description. Evidently, a truly cyclic timer interval can also be set up when the beat frequency 
							stays in phase with the system file time update. A typical scenario can be described for a platform configuration B type system: 	
							<p>Assuming the <i>ActualResolution</i> is set to <i>MaximumResolution</i> (10,032 100 ns units); the 
							   <i>TimeIncrement</i> (100,144 100 ns units) is not a multiple of the <i>ActualResolution</i>. In order to setup a truly cyclic timer, the least common multiple of 100,144 and 10,032 
							   has to be found. The value of 5,708,208 suits this need here; it hosts 57 periods at <i>MinimumResolution</i> or 569 periods at<i> ActualResolution</i>. 
							   The first truly cyclic timer period is therefore 570.8208 ms. It will be set up by a <i>Period</i> value of 570 and will expire after 569 interrupt periods. 
							   At the time of expiration the system will have done 57 system time updates. More truly cyclic timer setups can be created at any multiple of 5,708,208 for this type of platform.<br>
							   (Example: <i>Period</i>= 1,141, the timer will expire after 1,138 interrupt periods or 1141.6416 ms and the system time will have progressed by 114 x 10.0144 ms 
							   which is 1141.6416 ms too.)</p></li>
						<li>An optional asynchronous <i>CompletionRoutine</i> (APC) with an optional pointer to arguments 
							<i>ArgToCompletionRoutine</i> can be passed to the timer. However, the calling thread needs to be in the <i>alertable</i> state to allow execution
							of the APC. The only advantage of the scheme with a completion routine is that this routine is automatically supplied with the systems FILETIME at 
							which the timer was signaled. Calling the APC unfortunately results in a considerable extension of the observed cyclic interval. When the system 
							file time is needed, it can be queried as described in 2.1). The extra time required to do this is a tiny fraction (1/2,000) of the time added to the 
							timer period by calling the APC.</li>
					</ul>	
					<p>	The expired (signaled) timer can be handled by means of an asynchronous procedure (APC) call or by means of a call to <i>WaitForSingleObject</i>, for example.
						According to the last point above, the former is useless when high accuracy is required. The latter suits the needs of the mechanisms described here much
						better. The API needs the handle to the object to wait for and allows specifying a timeout <i>dwMilliseconds</i>, which can be optionally set to INIFINTE.</p>
					<p>DWORD WINAPI WaitForSingleObject(<br>
						<span></span>IN HANDLE hHandle,<br>
						<span></span>IN DWORD dwMilliseconds);</p>
					<p>	Waitable timers synchronize to the rhythm of the systems interrupt period (<i>ActualResolution</i>). This has to be kept in mind because it has 
						severe implications to the system's overall performance. All of the tasks waiting for a Sleep() or a timer to reach a signaled state will continue 
						after the interrupt has occurred. The system's load tends to reach peaks at interrupts.</p>
				<h3>2.4.&nbsp;&nbsp;The QueryPerformanceCounter and QueryPerformanceFrequency API</h3> 	
					<p>	This API is backed by a virtual counter running at a "fixed" frequency started at boot time. The following two basic calls are used to explore
						the microsecond regime: QueryPerformanceCounter() and QueryPerformanceFrequency(). 	The counter values are derived from some hardware counter, which is platform
						dependent. However, the Windows version also influences the results by handling the counter in a version specific manner. Windows 7, in particular 
						has introduced a new way of supplying performance counter values.</p>

					<h3>2.4.1.&nbsp; QueryPerformanceCounter</h3>
						<p>	The call to</p>
						<p>BOOL QueryPerformanceCounter(OUT LARGE_INTEGER *lpPerformanceCount);</p>
						<p> will update the content of the LARGE_INTEGER structure <i>PerformanceCount</i> with a count value. The count value is initialized to zero at boot time.</p>

					<h3>2.4.2.&nbsp; QueryPerformanceFrequency</h3>
						<p>	The call to</p>
						<p>BOOL QueryPerformanceFrequency(OUT LARGE_INTEGER *lpFrequency);</p>
						<p> will update	the content of the LARGE_INTEGER structure <i>PerformanceFrequency</i> with a frequency value. The frequency is treated by 
							the system as a constant.
							<span>
							From Windows 7/Server 2008 R2 onwards the result of QueryPerformanceCounter() may be calibrated at boot time and may therefore 
							return varying results. This depends on  the underlying hardware (see 2.1.4.1.), But QueryPerformanceCounter() never reports any 
							changes of the frequency during operation; its result remains constant. The following chapter describes deviations on systems 
							on which the underlying hardware neither provides an invariant TSC nor provides a HPET for time services.
							</span>
						</p>

					<h3>2.4.3.&nbsp;&nbsp;Performance of the Performance Counter</h3>
						<p>	The range in time that can be held by the LARGE_INTEGER structure <i>PerformanceCount </i>depends on the update rate or the <i>Frequency</i>
							at which the count will incrementally increase. Depending on the hardware platform the counter may be an Intel 8245 at 1,193,000 Hz or an ACPI Power Management 
							Timer chip with an update frequency of 3,579,545 Hz or even another source. A number of Platforms do not have these timers at all; they mimic 
							the timer by providing the CPU clock. As a result of the latter, the frequency can get into the GHz range. <i>PerformanceCount.QuadPart</i> (signed) will 
							change sign after 2<sup>63</sup> increments. At a frequency of say 1GHz (10<sup>9 </sup>s<sup>-1</sup>), such a system can run for about 290 years without 
							reaching the sign bit. Even for multi-GHz platforms, there does not seem to be a serious limit.<br>
							However, apart from the system's treatment, the frequency cannot be considered being constant. Firstly, the frequency generating hardware 
							will deviate from the specified value by an offset and secondly the frequency may vary (i.e., due to thermal drift). The impact of these 
							deviations is not negligible. Oscillators do have tolerances in the range of a few ppm and would consequently introduce errors of a few μs/s in the measured
							time period. Within this description the performance counter will be used to predict time intervals over a few seconds at accuracies better than 1 μs. 
							If an accuracy of 0.1 μs is reached after 10s, the frequency needs to be known to 0.01 ppm, which corresponds to 0.035 Hz at a nominal frequency of 3,579,545 Hz.
							Obviously, that value is not provided by the system and needs to be calibrated. A first estimate of the true frequency can be gathered by querying two counter 
							values at a certain (known) time apart from each other. The code snippet uses the API call</p>
						<p>DWORD timeGetTime(VOID);</p>
						<p> and could look like this:</p>
						<p>DWORD ms_begin, ms_end;<br>
												LARGE_INTEGER count_begin,count_end;<br>
												double ticks_per_second;<br>
												ms_begin = timeGetTime();<br>
												QueryPerformanceCounter(&amp;count_begin);<br>
												Sleep(1000);<br>
												ms_end = timeGetTime();<br>
												QueryPerformanceCounter(&amp;count_end);<br>
												ticks_per_second = (double)(count_end − count_begin) / (ms_end − ms_begin);</p>
						<p> However, due to artifacts described in 2.2, timeGetTime() is accompanied by an inaccuracy of up to 2 ms, thus a Sleep(1,000) would give an accuracy 
							for <i>ticks_per_second</i> of 0.002 (2,000 ppm) at most. An accuracy of 2 ppm would be achievable when the Sleep extends to 1,000,000 ms 
							or 1,000s. In order to obtain 0.01 ppm, the Sleep would have to cover more than 55 hours. This is obviously a hopeless approach. It also averages 
							temporary changes of the frequency and it will not forgive frequency changes due to thermal drifts.
							The thermal drift of the performance counter frequency can be severe:</p>			

							<p><a href="http://www.windowstimestamp.com/thermal_drift.png" target="_blank"><img alt="thermal_drift.png" title="Thermal Drift of Performance Counter Frequency" src="http://www.windowstimestamp.com/thermal_drift.png"></a></p><h6>Fig. 2.4.3.1: Calibrated Performance Counter Offset on ACPI PM timer hardware.</h6>
							   
						<p> This graph shows an older system with heavy thermal drift. At boot time (~8:00) the measured performance counter frequency is
							off by about 60Hz. The system reports the performance counter frequency as 3,579,545 Hz. In fact, it is already at 3,579,605 Hz when it is 
							"cold". After many hours of doing nothing, the system seems to reach a thermal equilibration. At ~14:00 (six hours after boot), the system 
							was heavily loaded for about 45 minutes and consequently warmed up. The load has increased the main board temperature by 5 deg. (centigrade scale) only, but the influence to the measured
							performance counter frequency is quite considerable. It rose to an offset of almost 100 Hz or a true performance counter frequency of 3,579,645 Hz.
							A 100 Hz offset at a base frequency of 3,579,605 Hz is a deviation of about 28 ppm or an error in time of 28 μs/s.</p>
							
						<p>	The calibration procedure used for the time stamp mechanism described here uses a repeated averaging period evaluation and reaches an accuracy 
							of better than 0.05 ppm after about 100s. Thermal drifts can be captured reasonably well and can be applied without much delay. 
							(Note: The declaration of <i>ticks_per_second</i> as a 64-bit float in the code snippet above enables the <i>ticks_per_second</i>
							to hold a number with an accuracy of 15 digits. A value of 3,579,545.12 Hz shows the 0.01 ppm accuracy in the last digit.)</p>

						<p>	The use of QueryPerformanceCounter on multi-processor platforms implies that the call is made on the same processor all the time. 
							The <i>SetThreadAffinityMask</i> API and its associated calls are used to ensure this.
							<span>
							This rule only applies to systems using non invariant TSC hardware. The system analyzed in this chapter operates time services based on ACPI PM hardware.
							</span>
							</p>

					<h3>2.4.4.&nbsp;&nbsp;Is the CPU Time Stamp Counter an Alternative?</h3>
						<p>	The RDTSC specifies a call to query the time stamp counter of the CPU. The advent of multi processor platforms or muti-core processors highly recommends 
							not using RDTSC calls. Newer processors also support adaptive CPU frequency adjustments. This is just another reason to not use RDTSC calls for the 
							purpose discussed here.
							<span>
							Microsoft strongly discourages using the TSC for high-resolution timing 
							(<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee417693(v=vs.85).aspx">"Game Timing and Multicore Processors"</a>).		
							However, the introduction of invariant Time Stamp Counters has changed the situation. Starting with Windows 7/Server 2008 R2, 
							Windows has a clear preference: Look for invariant TSCs, see whether they can be synchronized on different cores and use them 
							for wall clock and performance counter whenever possible 
							(<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dn553408%28v=vs.85%29.aspx">"MSDN: Acquiring high-resolution time stamps."</a>).	
							</span>		
						</p>
							
				<h3>2.5.&nbsp;&nbsp;Discussion of Resources</h3>
					<p>	Some of the resources discussed show a platform-specific behavior. They may deliver results depending on the hardware and/or
						on Windows version. The precision time functions developed within the windows timestamp project mainly rely on four function suites 
						provided by the operating system:</p>
					<ul>
						<li>GetSystemTimeAsFileTime</li>
						<li>QueryPerformanceCounter with QueryPerformanceFrequency</li>
						<li>Sleep</li>
						<li>The WaitableTimer function together with WaitForSingleObject</li>
					</ul>
					<p> The complexity of the system time update with respect to the interrupt settings was explained and is understood. A complex automatic
						diagnosis of the system has to establish proper settings in order to obtain the desired accuracy.
						Particularly, the continuous calibrations of the performance counter frequency described in 2.4.3 is of utmost importance to obtain high accuracy. 
						In addition, the proper interrupt period setting to obtain truly cyclic timer behavior (e.g., as described for example in 2.1) is very important.
						Another set of APIs is used to establish functionality:</p>
					<ul>
						<li>Pipes</li>
						<li>Events</li>
						<li>Shared Memory</li>
						<li>Mutexes</li>
					</ul>
					<p>	The description of these functions falls outside the scope of this description.</p>

					
			<h2>3.&nbsp;&nbsp;Goals</h2>
				<p>	The Windows Timestamp Project provides the tools to enable access to time at microsecond resolution and accuracy. Furthermore, it provides 
					timer functions at the same resolution and accuracy. The high accuracy and microsecond resolution are archived by synchronizing the system time 
					with the performance counter. In fact, the performance counter is phase locked to the system time. A diagnosis determines the system's specific 
					parameters and establishes a "truly cyclic" timer interval for updating the phase of the performance counter value. The drift of the 
					performance counter is permanently evaluated and taken into account while the system is running.</p>
				<p>	The code runs in a real-time priority process providing time information. An auxiliary IO process builds the interface to an optional 
					graphical user interface. Nonblocking IO enables proper performance testing and debugging.</p>

				<h3>3.1.&nbsp;&nbsp;Time Support</h3>
					<p>	Any time providing mechanism needs time for its internals. Thus, the following question arises with respect to time: 
						Is the time requested at the time the call is made or shall the time be reported at the time in which the call returns? 
						This may sound strange, but considering the level of resolution and accuracy aimed for here, it matters.</p>
					<p>Example:</p>
					<ul>
						<li>Something just happened and you want to assign a timestamp to it. 
							In this case, you would want the time at the time you're asking.</li>
						<li>You want to do something at a specific time. 
							In this case, you would want the time at the time you are getting the answer.</li>
					</ul>
					<p>Two time functions are implemented to fulfill these two needs:</p>

					<h3>3.1.1.&nbsp;&nbsp;GetTimeStamp</h3>
						<p>	The function <i>GetTimeStamp</i>, declared as</p>
						<p>void GetTimeStamp(TimeStamp_TYPE * TimeStamp);</p>
						<p>	fills the argument pointed to by <i>TimeStamp</i> with numbers according to the <i>TimeStamp</i> structure definition:</p>
						<p>typedef struct {<br>
							<span>long long Time;</span><br>
							<span>long long ScheduledTime;</span><br>
							<span>double RefinedPCF;</span><br>
							<span>long Accuracy;</span><br>
							<span>int State;</span><br>
							TimeStamp_TYPE;
						</p>
						<p>	The 64-bit value <i>Time</i> represents the number of elapsed 100-nanosecond intervals elapsed since January 1, 1601. <i>ScheduledDueTime</i> 
							reports the system file time at which the next reference time is scheduled for an attempt to update the phase. This value should 
							primarily be used to verify the operation of the precision time mechanism. If <i>ScheduledDueTime</i> is noticeable behind the 
							current system file time, the scheduled update of the time reference must have failed for a number of consecutive attempts.<br>
							Finally the 32-bit value of <i>Accuracy</i> gives an estimate of the assumed accuracy (rms) of the time stamp in 1 ns units (error in ns/s).</p>
							<p>
								RefinedPCF returns the calibrated frequency of results from QueryPerformanceCounter(). 
								GetTimeStamp() may be called at any time, thus it provides information about the state of the calibration. 
								States can be the following: 
							</p>
							<ol>
								<li>
									TIME_STAMP_OFFLINE (1): Time calibration service is offline.
								</li>
								<li>
									TIME_STAMP_AWAITING-_CALIBRATION (2): Calibration service just started but time service not yet calibrated.
								</li>
								<li>
									TIME_STAMP_CALIBRATED (3): Time service calibrated.
								</li>
								<li>
									TIME_STAMP_LICENSE_EXPIRED (4): License expired during runtime.
								</li>
							</ol>
							<p>	The call to <i>GetTimeStamp</i> is fast and it reports the time at the time it is called.
								<span> As of version 2.01, this call is done in 10 to 20 ns on current platforms.</span>
							</p>
							
					<h3>3.1.2.&nbsp;&nbsp;Time</h3>
						<p>	A simple function is stated as</p>
						<p>long long Time(void);</p>
						<p>	The function is as fast as <i>GetTimeStamp</i> and it returns the time at the time the call returns. With the need for a few thousand 
							CPU cycles, the call will require very few μs with the current hardware. The <i>Time()</i> can be used to compare times or to wait until a certain 
							time is observed. The 64-bit return value represents the number of elapsed 100-nanosecond intervals since January 1, 1601.</p>

				<h3>3.2.&nbsp;&nbsp;Timer Support</h3>
				
					<p>	A set of timer functions:</p>
					<ul><li>Creating a timed named event:</li></ul>
					<p>HANDLE CreateTimedEvent(<br>
							<span></span>BOOL bManualReset,<br>
							<span></span>LPCTSTR lpTimerName);</p>

					<p><i>bManualReset</i> [in]</p>
					<p>If this parameter is TRUE, the function creates a manual reset event object, which requires the use of the ResetEvent 
						function to set the event state to nonsignaled. If this parameter is FALSE, the function creates an auto reset event object, and the system automatically 
						resets the event state to nonsignaled after a single waiting thread has been released.</p>
					<p><i>lpTimerName</i> [in, optional]</p>
					<p>The name of the event object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.
						If <i>lpTimerName</i> matches the name of an existing named event object, this function will fail. If <i>lpTimerName</i> is NULL, the event object is created without a name.
						If <i>lpTimerName</i> matches the name of another kind of object in the same namespace (such as an existing semaphore, mutex, waitable timer, job, or file-mapping object), 
						the function fails and the GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace.
						The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can 
						contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented 
						using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support 
						multiple users. The object can be created in a private namespace. For more information, see Object Namespaces.</p>
					<p><i>Return value</i></p>
					<p>If the function succeeds, the return value is a handle to the event object. If the named event object existed before the 
						function call, the function returns NULL and GetLastError returns ERROR_ALREADY_EXISTS. If the function fails, the return value is NULL. 
						To get extended error information, call GetLastError.</p><br>

					<ul><li>Setting the timed event with a DueTime in 100 ns units and an optional Period in 100ns units:</li></ul>
					<p>int SetTimedEvent(<br>
						<span></span>HANDLE hTimerEvent,<br>
						<span></span>long long TimerDueTime,<br>
						<span></span>long long TimerPeriod);</p>
					<p><i>hTimerEvent</i> [in]</p>
					<p> A handle to a named timed event. The <i>CreateTimedEvent()</i> function returns this value.</p>
					<p><i>TimerDueTime</i> [in]</p>
					<p> The time after which the state of the timer is to be set to signal in 100 nanosecond intervals. 
													Positive values indicate absolute time. Be sure to use a UTC-based absolute time,
													since the system uses UTC-based time internally. Negative values indicate relative time.</p>
					<p><i>TimerPeriod</i> [in]</p>
					<p> The period of the timer in 100 ns intervals. If <i>TimerPeriod</i> is zero, the timer is signaled once. 
													If <i>TimerPeriod</i> is greater than zero, the timer is periodic. A periodic timer automatically reactivates each time the period elapses, 
													until the timer is canceled using the CancelTimedEvent function or reset using SetTimedEvent. 
													If <i>TimerPeriod</i> is less than zero, the function fails.</p>
					<p><i>Return value</i></p>
					<p> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. 
													To get extended error information, call GetLastError.</p><br>

					<ul><li>Canceling the timed event:</li></ul>
					<p>int CancelTimedEvent(HANDLE hTimerEvent);</p>
					<p><i>hTimerEvent</i> [in]</p>
					<p> A handle to a named timed event. The <i>CreateTimedEvent()</i> function returns this value.</p>
					<p><i>Return value</i></p>
					<p> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. 
													To get extended error information, call GetLastError.</p><br>

					<ul><li>Opening a timed event:</li></ul>
					<p>HANDLE OpenTimedEvent(LPCTSTR lpTimerName);</p>
					<p><i>lpTimerName</i> [in]</p>
					<p> The timed event name used when the timed event was created.</p>
					<p><i>Return value</i></p>
					<p> If the function succeeds, the return value is the handle to the named timed event. If the function fails, the return value is NULL. 
													To get extended error information, call GetLastError.</p><br>

													
					<ul><li>Deleting the timed event:</li></ul>
					<p>int DeleteTimedEvent(HANDLE hTimerEvent);</p>
					<p><i>hTimerEvent</i> [in]</p>
					<p> A handle to a named timed event. The <i>CreateTimedEvent()</i> function returns this value.</p>
					<p><i>Return value</i></p>
					<p> If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. 
													To get extended error information, call GetLastError.</p>

					<p>	These timer functions are based on timed events. The handle returned by <i>CreateTimedEvent()</i> is in fact a handle to a named event of which 
						signaled state is supervised by a time service routine. Standard wait functions like <i>WaitForSingleObject</i> or <i>WaitForMultipleObjects</i> 
						can be used to wait for the high resolution timer events.</p>

			<h2>4.&nbsp;&nbsp;Implementation</h2>
				<p> Only two hardware platforms were described here to highlight some of the problems to bear in mind when implementing reliable time services for Windows.
					Many more configurations need to be diagnosed to ensure platform independent functionality to a large extent. However a flexible and automatic evaluation
					of hardware specific behavior may result in hardware independence.
				</p><p>	The implementation of all the above into a time service is done by careful separation into different processes and threads. The time
					critical parts are hosted by a process running at real-time priority class. Some of the threads inside this process are even 
					running at time-critical priority level. In the case of a multi-processor or multi-core system, certain threads are assigned to a specific 
					CPU/core. This is the <i>Kernel</i> and hosts the time service routines. For testing and debugging the <i>Kernel</i> process has some IO 
					capabilities shared with the IO process. A later version may not need this additional functionality. The high priority class requires the 
					<i>Kernel</i> process to run with administrator privileges.</p>
					
				<p>	A second process hosts all kinds of less time critical service threads. It shares some IO service with the <i>Kernel</i> process by means
					of piped IO between these two processes. Furthermore it provides pipe services to the graphical user interface (GUI).</p>
					
				<p>	The third process is a graphical user interface (GUI), which runs optionally and helps in the current stage of the development to get an 
					insight into what is going on.</p>
				
				<p> The GUI and the IO process are development tools only. The only process that needs to run to access the time functions discussed here is the <i>Kernel</i> process.</p>

				<h3>4.1.&nbsp;&nbsp;The Real-time Priority Class Process: Kernel</h3>
					<p>	The Kernel is the heart of the time service described here. It provides the important link between the system file time and the performance 
						counter value. The idea in this context is to provide data triplets of system file time, performance counter, and performance counter frequency. 
						Knowing the performance counter value at a certain system file time allows the extrapolation of the system file time to the actual time by applying the 
						performance counter value and the performance counter frequency. As discussed, the performance counter frequency is of insufficient accuracy; a refined performance counter 
						frequency is supplied in format double (64bit float). There is also some internal information which allows a refinement of the performance counter value 
						itself (as a result of some self-calibration). Thus, it is also represented in double (64bit float) format.</p>
					<p>	A typical result of such a data triplet could be:</p>
					<ul>
						<li>int64 FileTime: 129,737,733,817,343,750 (some value captured on Feb. 15, 2012)</li>
						<li>double PerformanceCounter: 20,918,865,472.23</li>
						<li>double PerformanceCounterFrequency: 3,579,515.24</li>
					</ul>
					<p>	This information is sufficient to establish time services. Querying the current performance counter value gives the difference to the value calculated 
						to match the last captured file time. This difference is divided by the performance counter frequency and the result is the elapsed time since the last 
						file time capture. This data triplet is, besides other parameters, written to a mutex protected shared memory section. Other processes/threads have access 
						to this data triplet.<span>As of version 2.02 the mutex scheme has been replaced by a read-copy-update (RCU) scheme to improve the performance.</span></p>
					<p>	As described in sections 2.1 and 2.3, the important part is to get the file time updated correctly. It proves best to gather the data triplet exactly 
						when the file time transits or just transited. Difficulties archiving this have been described for platform examples A and B. At startup, a complex 
						diagnosis of the interrupt timing structure and file time update/transition structure is performed. This results in a timing scheme for updating the data triplet. 
						The desired update period is in the range of 1 to 10 seconds. As discussed, the period duration influences the accuracy. Algorithms are looking for patterns and 
						beat frequencies in the file time update and interrupt timing structure. As a result, a periodic timer is set up to run the data triplet generation and the calibration 
						in parallel. Once exact ∆T file time periods do occur, the true performance counter frequency can be measured and averaged over a number of consecutive 
						measurements. A running average over the last n captures is maintained at all times to provide information about the true (calibrated) performance counter frequency. 
						When the accuracy of the average reaches a certain quality, the phase locking of file time change and performance counter is considered as established and 
						timestamp requests are accompanied by information about their accuracy.</p>
					<p>	Running all of this at utmost priority ensures that there is very little overhead after an interrupt. Remember: Many processes/threads are waiting for 
						interrupts. Therefore, systems do have a workload peak at the occurrence of an interrupt. Even running at such priority settings, it is unavoidable to be 
						influenced by the load of other processes. However, the accuracy of this scheme easily stays below a few microseconds, even with heavy load on the system.</p>
					<p>	The routines Time() and GetTimeStamp() are applying the extrapolation scheme described here. Both calls are done in far less than <span>a few 10 ns</span>, even on older systems.</p>
					<p>	The functionality of the timer routines listed in 3.2 is handled in this real-time process as well. Timed events are registered in a timer event queue. 
						They are monitored with respect to their due time/period. When there is less than one interrupt period left before the due time expires, the timer service polls
						the timed event queue for the precise time to set the event. This may happen for a number of timed events, even within the same interrupt period. 
						However, it should be noted that the time service thread is running at a high priority level and the signaled event may not be accessible to other 
						processes/threads when there is just one CPU. 
						A single CPU/core system simply cannot cope with multiple timed events setup to signal within the same interrupt period.</p>

				<h3>4.2.&nbsp;&nbsp;Less critical services: The IO-Process</h3>
					<p>	In order to implement the kernel as small as possible, much of the functionality is performed by a second process. The IO, in particular, matters. 
						The IO process establishes pipe services to release the kernel from blocking IO. All IO done by the kernel is queued into the IO processes pipe service. 
						These operations are nonblocking. A complex fprintf() can be queued in just a few microseconds. This allows extensive output for diagnosis. 
						Furthermore, output is logged into a file.</p>
					
				<h3>4.3.&nbsp;&nbsp;The Optional GUI-Process</h3>
					<p>	The current GUI is mainly created for developing the time service. Meanwhile, it has become a valuable tool for diagnosing platforms. It runs optionally.</p>
					<p><a href="http://www.windowstimestamp.com/GUI_170.png" target="_blank"><img alt="GUI_170.png" title="The Graphical User Interface" src="http://www.windowstimestamp.com/GUI_170.png"></a></p><h6>Fig. 4.3.1: The Graphical User Interface (Version 1.70).</h6>

					<p>	The output is split into four tabs: the <i>all output</i> tab, the <i>error messages</i> tab, the <i>Calibrated Performance Counter Offset</i> tab,
						and the <i><span>NTP Offset</span></i> tab. The text output within 
						the first two tabs is produced using the queued qfprintf(…) function. This function makes its message time stamped and shows also some other parameters 
						of the output piping thread:</p>
					<p>	The output line format is:</p>
					<p>yyyy-mm-dd hh:ii:ss.μμμμμμ.n (s/a) [PID.THID.Processor.Priority]: <i>Message</i></p>
					<ul>
						<li>yyyy-mm-dd hh:ii:ss: Year-Month-Day Hour:Minute:Second
						</li><li>μμμμμμ: 6 digits microseconds</li>
						<li>n: The 100ns units field</li>
						<li>s/a: Shows "ftime" while calibration is not ready, otherwise accuracy in microseconds/second</li>
						<li>PID: Identifier of the process</li>
						<li>THID: Identifier of the thread</li>
						<li>Processor: The number of the core or processor doing the output. (0…n)</li>
						<li>Prioritylevel: A combination of thread priority level and process priority class. (1…31).</li>
						<li><i>Message</i>: The message</li>	
					</ul>	
					<p>	As already mentioned, the GUI runs optionally and any number of GUI can be started and ended at anytime. Ending a GUI will neither end the
						kernel process nor end the IO process. In order to terminate the whole group of processes, the <i>Kernel</i> process has to be stopped. The <i>Stop Kernel</i> button 
						(lower right corner) stops the kernel. By doing so, queued messages that are supposed to be processed are stuck. A few message windows will pop up to show the contents of
						the unprocessed parts of the queues of all involved processes. These popup windows are not error messages; they just report what was happening while the <i>Kernel</i> 
						was stopped.</p>
					<p>	The plot at the left lower corner shows the history of the accuracy in μs/s during the last 600 seconds. The GUI produces this information by means of 
						GetTimeStamp() imported from the time service DLL.</p>
					<p>	It also provides a tiny test of the timer functionality: A single shot timer can be setup. The due time setting here
						is absolute, thus the time has to be in the future. Hint: Use the <i>Update Date/Time Fields</i> button to get the actual time into the fields and than e.g. 
						incrementally change the minute field by 1. Press the <i>Create Timed Event</i> button quickly before the due time expires. Progress of the timed event approaching its due time
						is shown next to the button, which has now converted into a <i>Stop Timed Event Button</i> to allow cancellation of the timed event. A message window will popup when
						the timed event has signaled. It shows the precise time at which the signaled state was detected and how much it deviates from the requested due time.</p>
					<p> The output can be stopped for the <i>all output</i> tab (<i>Hold Output</i> Button). All output will be queued and the button converts into a <i>Continue Output</i> button until 
						the <i>Continue Output</i> button is pressed. An optional <i>auto cont.</i> check box lets the GUI continue automatically when the queue buffer reaches a critical stage. 
						The <i>auto cont.</i> check box can only be checked when the output is hold.</p>
					<p>	The <span><i>Calibrated Performance Counter Frequency Offset</i></span> tab shows the offset of the calibrated performance counter frequency. 
						The graph shown in 2.4.3 was created within this tab. The graphs context menu (right mouse button) allows saving the graph or clearing the graph's data. 
						Clearing the data will not stop further recording; creation of the graph will continue.
						<span>Version 1.2 introduced the NTP Offset tab, the NTP/autoadjust status line, and the NTP/autoadjust check boxes. Details about these items are given in 
						"<a href="http://www.windowstimestamp.com/PartIIAdjustmentofSystemTime.pdf">Part II: Adjustment of System Time</a>".		
						</span>
						</p>

				<h3>4.4.&nbsp;&nbsp;The Libraries</h3>
					<p> The functions described above are accessible to other processes/threads through a static library (LIB) or a dynamic link library (DLL).</p>
					
			<h2>5.&nbsp;&nbsp;Results</h2>
				<p>	Microsecond resolution time stamps are possible on Windows systems. Resolution in the microsecond regime can be observed at accuracies of a few microseconds 
					without distracting the system too much. Timer functions at the same resolution and accuracy are implemented and tested. Handling many timed events created by those 
					timer functions set up to fire within the same millisecond is tricky but possible. The evaluation at the startup of the services may sometimes take a few seconds and needs all the CPU time. Doing this at utmost priority will freeze 
					single core/processor systems for a moment.</p>
				<p>
					Fine granularity time services are established with the tools described above. System time adjustment following an NTP time server relies on fine granularity 
					of time keeping. The accuracy obtained when synchronizing to an NTP server is determined by the accuracy of the system time. Granularities of 15.625 ms are way 
					to poor to achieve reasonable NTP synchronization. The time keeping has improved with newer windows versions. The function GetSystemTimePreciseAsFileTime() was 
					described in 2.1.4.2. It is proposed to have very fine granularity. Unfortunately GetSystemTimePreciseAsFileTime() shows a misbehavior when a Windows system time 
					adjustment is active. This is counterproductive when the goal is precise synchronization of the system time to an NTP server.
				</p>
				<p>
					The following second part "Adjustment of System Time" deals with  high accuracy system synchronization.
				</p>
				<h2>A pdf version of <i>"Microsecond Resolution Time Services for Windows"</i> can be downloaded <a href="http://www.windowstimestamp.com/pdf_download" target="_blank">here</a>.</h2>
				<p>
					Don't miss more details described on the "<a href="http://www.windowstimestamp.com/news">News</a>" page.
					A pdf version of the <b>News History</b> can be downloaded <a href="http://www.windowstimestamp.com/pdf_download_news" target="_blank">here</a>.
				</p>
				<p>
					Note: Windows is a registered trademark of Microsoft Corporation in the United States and other countries. 
					The Windows Timestamp Project is an independent publication and is not affiliated with, nor has it been authorized, sponsored, or 
					otherwise approved by Microsoft Corporation.
				</p>

			<hr><br>	

			<!--  ***************** P A R T  I I  *********************** -->
			
			
			<h5>Arno Lentfer, June 2012</h5>
			<h5><span>Last Update: Version 3.10, May 2019</span></h5>
			<p> Windows provides the following simple tools to manage and monitor system time adjustments: The Internet Time GUI and the console application w32tm.exe. 
				These tools are sufficient to obtain an initial rough estimate of the performance of the Windows internet time synchronization.</p>
			<h2>1.&nbsp;&nbsp;The Internet Time GUI</h2>
				<p> Synchronization to an internet time server is accomplished directly from the user interface. 
					Windows Vista, Windows 7 and Windows 8 provide the Internet Time Settings window and Windows XP provides 
					the Internet Time tab in the Date and Time Properties window:</p>
				
				<p><a href="http://www.windowstimestamp.com/Fig_1_1_Vista_and_follower_internet_time.png" target="_blank"><img alt="Fig_1_1_Vista_and_follower_internet_time.png" title="Internet Time Setting GUI of Windows Vista and higher" src="http://www.windowstimestamp.com/Fig_1_1_Vista_and_follower_internet_time.png"></a></p><h6>Fig. 1.1: Internet Time Settings window of Windows Vista and higher.</h6>
				
				
				<p><a href="http://www.windowstimestamp.com/Fig_1_2_XP_internet_time.png" target="_blank"><img alt="Fig_1_2_XP_internet_time.png" title="Internet Time Setting GUI of Windows XP" src="http://www.windowstimestamp.com/Fig_1_2_XP_internet_time.png"></a></p><h6>Fig. 1.2: Internet Time Settings window of Windows XP.</h6>
				
				<p> An internet time provider can be chosen from a list or a new NTP server address can be added to the list. 
					It is also possible to add an IP address to the list. Adding an IP address may be advisable when the name represents a pool 
					of servers and the server needs to be explicitly indicated.</p>
				<p> The common "Update Now" button will attempt to synchronize the system time to the time server. 
					This allows synchronization to take place or it becomes active upon confirmation. Note: The message "...has been successfully synchronized..." does 
					not necessarily mean that synchronization has finished. It could also mean that a synchronization process was successfully started. 
					Such processes can last for many hours.</p>
			
			<h2>2.&nbsp;&nbsp;w32tm.exe</h2>
				<p> In order to verify the result or progress of the synchronization, another tool has to be run in parallel. 
					The console application <a href="http://technet.microsoft.com/en-us/library/cc773263%28WS.10%29.aspx">w32tm.exe</a>
					allows monitoring of the offset of the local time to the time of an internet time server.</p>
				<p> The easiest way to do this is from a console window with the following set of parameters:</p>
				<p>w32tm /stripchart /computer:time.windows.com /period:120</p>
				<p> As a result, the system time and its offset to the time server are dumped to the console every 120 seconds:</p>
				<p>
					Tracking time.windows.com [65.55.21.14.123]<br>
					08:38:57 d:+00.0417301s o:+00.1024506s  [        *        ]<br>
					08:40:57 d:+00.0418632s o:+00.1037897s  [        *        ]<br>
					08:42:58 d:+00.0419165s o:+00.1015612s  [        *        ]<br>
					08:44:58 d:+00.0417048s o:+00.0985075s  [        *        ]<br>
					08:46:58 d:+00.0419394s o:+00.0942827s  [        *        ]<br>
					08:48:58 d:+00.0419296s o:+00.0913788s  [        *        ]<br>
					08:50:58 d:+00.0418867s o:+00.0883421s  [        *        ]<br></p>
				<p> Each line consists of the local time (08:38:57), an internal delay (time difference between the udp package received and udp package sent 
					on the server side, i.e., d:+00.0419394s), the actual offset between the local time and the server time 
					(o:+00.1024506s) and a very basic stripchart of the offset. </p>
				<p> The first output line of w32tm will also resolve the name of the time server (time.windows.com) to an IP (UDP port 123 is reserved for NTP). 
					This is important because time.windows.com does not refer to a single server but rather to a pool of servers; therefore, consecutive attempts 
					to synchronize to it may use different physical servers. However, w32tm resolves the IP of the server currently in use with w32tm. 
					This IP can also be chosen as a server for the synchronization. For example, one of the addresses of the time.windows.com pool is 65.55.21.14. 
					The best proof of quality is obtained when the IP address in the internet time GUI described above and the same IP address with the w32tm command are used: </p>	
				<p>w32tm /stripchart /computer:65.55.21.14 /period:120</p>
					
			<h2>3.&nbsp;&nbsp;Results</h2>
				<p> The results obtained with w32tm are difficult to interpret. When the offset in time is large (i.e., several seconds), 
					synchronization of the system time seems to happen in one step. In these cases, the remaining offset is typically larger than a few milliseconds. 
					However, when the offset is less than a few seconds, an algorithm gently adjusts the offset in small steps. This procedure can take many hours.</p>
				<p> It turns out that obtaining detailed insight into this adjustment algorithm by using w32tm is difficult. 
					A more in-depth investigation may uncover the cause of the behavior observed, however, this requires additional software.</p>
			
			<h2>4.&nbsp;&nbsp;Discussion</h2>
				<p> Applying the scheme described above frequently gives very dissatisfying results. Sometimes the synchronization results in a time offset that is worse 
					than the offset prior to synchronization. In particular, Windows Vista and Windows 7 show strange behavior, e.g., seemingly never-ending 
					adjustments to huge offsets.</p>
				<p> A piece of software is necessary to find out the secret of the adjustment algorithm. Actual system time adjustment parameters can be obtained by a call 
					to the function <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724394%28v=vs.85%29.aspx">GetSystemTimeAdjustment</a> because Windows 
					performs the system time adjustment through calls to the function <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724943%28v=vs.85%29.aspx">SetSystemTimeAdjustment</a>.</p>	
				<p>BOOL WINAPI GetSystemTimeAdjustment(<br>
					<span></span>OUT PDWORD lpTimeAdjustment,<br>
					<span></span>OUT PDWORD lpTimeIncrement,<br>
					<span></span>OUT PBOOL lpTimeAdjustmentDisabled);</p>
				<p> MSDN: "For each <i>lpTimeIncrement</i> period of time that actually passes, <i>lpTimeAdjustment</i> will be 
					added to the time of day." Assuming this rule, the adjustment gain can be calculated:</p>
					
					<p><i>gain = (lpTimeAdjustment - lpTimeIncrement)/ lpTimeIncrement</i></p>
					
				<p>	A simple program can call GetSystemTimeAdjustment frequently while a system time adjustment is active and evaluate the gains for individual values of <i>lpTimeAdjustment.</i>
					The function SetSystemTimeAdjustment allows to initiate and control a system time adjustment:</p>
				
				<p>BOOL WINAPI SetSystemTimeAdjustment(<br>
					<span></span>IN DWORD dwTimeAdjustment,<br>
					<span></span>IN BOOL bTimeAdjustmentDisabled);</p>
				<p> System time adjustments occur when <i>bTimeAdjustmentDisabled</i> is set to FALSE and <i>dwTimeAdjustment</i> is set to some meaningful value.   
					Unfortunately, the influence of the values of <i>dwTimeAdjustment</i> depends on the Windows version:  The MSDN description of the SetSystemTimeAdjustment function 
					contains the note: 
					<i>"Currently, Windows Vista and Windows 7 machines will lose any time adjustments set less than 16."</i> Note: Windows 8 is not mentioned here, 
					the related knowledge base article  
					<a href="http://support.microsoft.com/kb/2537623">KB2537623</a> also does not mention Windows 8.
					</p>
				
				<p> The update scheme of the system time and also the scheme of system time adjustments depends on the presence of a 
					High Precision Event Timer [<a href="http://en.wikipedia.org/wiki/High_Precision_Event_Timer">HPET</a>].
					Intel specifies [<a href="http://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/software-developers-hpet-spec-1-0a.pdf">hpetspec.pdf</a>]: 
					<i>"An existing HPET does not replace the RTC Time of Day, the RTC Alarm, and the RTC CMOS functionality. 
					The HPET architecture supplements/replaces only the RTC Periodic Interrupt function."</i> 
					The RTC (Real Time Clock) Periodic Interrupt function used to be the heartbeat of the system time update. However, an existing HPET will replace this
					functionality and remove the system time update activity from the RTC periodic interrupt function. Those systems can typically be identified by a specific value of
					the update period <i>lpTimeIncrement</i>: 156001. HPET and RTC are driven by different hardware. 
					Therefore they are neither synchronized nor are they in phase by default; additionally they may show specific drifts.    
					More information about the evolution of the HPET architecture is given in 
					"<a href="http://web.archive.org/web/20140213124142/http:/msdn.microsoft.com/en-us/windows/hardware/gg463347.aspx">Guidelines For Providing Multimedia Timer Support</a>" [MSDN].
					<span>Newer systems may provide hardware with an invariant Time Stamp Counter (TSC) as described in section 17.17 of 
					"<a href="https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf">Intel® 64 and IA-32 Architectures, Software Developer’s Manual</a>". 
					Windows has a clear preference about what hardware resource is to be used for timekeeping. When suitable TSC characteristics 
					are obtained, Windows uses the TSC for timekeeping. If the TSC is not suitable, Windows uses the HPET when available, 
					and if that is not available or disabled in BIOS Windows uses the ACPI PM timer
					(<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dn553408%28v=vs.85%29.aspx">"MSDN: Acquiring high-resolution time stamps."</a>).	
					</span>	
					</p>

				<p> It was already shown in section 2.3 of <i>Microsecond Resolution Time Services for Windows</i> that the Windows system timing cannot be assumed to show a fixed
					pattern. The evolution of Windows with newly introduced limitations (<i>... will lose any time adjustments set less than 16.</i>) and emerging new hardware results 
					in a big variety of schemes for system time adjustments. A few relevant combinations are diagnosed and described here.
					</p>
				
				<h3>4.1.&nbsp;&nbsp;Windows XP and Windows Server 2003: The Classical Case</h3>
					<p> A call to GetSystemTimeAdjustment reveals a value of 156250 for <i>lpTimeIncrement</i> on most platforms running Windows XP or its server variants 
						(Some specific hardware may return other values e.g. 100144). Note: A value of 156250 represents 15.625 ms, an RTC Periodic Interrupt at 64 Hz. 
						This is a very common hardware fingerprint. 
						</p>
					<p> Using the function SetSystemTimeAdjustment with <i>dwTimeAdjustment</i> = 156250 and <i>bTimeAdjustmentDisabled</i> = FALSE shall initiate a system time adjustment. 
						However, according to the gain equation described in 4. no adjustment shall take place, the gain shall be zero, but the adjustment shall be active 
						with <i>lpTimeAdjustmentDisabled</i> = FALSE.
						</p>
					<p> Setting <i>dwTimeAdjustment</i> to any number different from <i>lpTimeIncrement</i> shall result in a system time adjustment. 
						Example: <i>lpTimeIncrement</i> = 156250 and <i>dwTimeAdjustment</i> = 156257. The system time will advance by 15.6257 ms every 15.6250 ms, 
						the system time will gain 0.0448 ms/s (7/156250). This way the gains are predictable, a small list shows the obtained gains at the 
						neighborhood of 156250 at <i>dwTimeAdjustment</i> from 156255 to 156248:
						</p>
					<p>
						156255: &nbsp;0.032000 ms/s = (156255 - 156250)/156250<br>
						156254: &nbsp;0.025600 ms/s = (156254 - 156250)/156250<br>
						156253: &nbsp;0.019200 ms/s = (156253 - 156250)/156250<br>
						156252: &nbsp;0.012800 ms/s = (156252 - 156250)/156250<br>
						156251: &nbsp;0.006400 ms/s = (156251 - 156250)/156250<br>
						156250: &nbsp;0.000000 ms/s = (156250 - 156250)/156250<br>
						156249: -0.006400 ms/s = (156249 - 156250)/156250<br>
						156248: -0.012800 ms/s = (156248 - 156250)/156250<br>
						</p> 
					<p> These numbers are captured on true hardware. 
						The adjustment gain is zero with <i>dwTimeAdjustment</i> = 156250. 
						The smallest available adjustment on such a platform is 6.4 μs (positive and negative).
						</p>
					<p> A similar scan was carried out on hardware reporting lpTimeIncrement = 100144 (<i>dwTimeAdjustment</i> = 100146 to 100142):
						</p>
					<p>
						100146: &nbsp;0.01997124 ms/s  = (100146 - 100144)/100144<br>
						100145: &nbsp;0.00998562 ms/s  = (100145 - 100144)/100144<br>
						100144: &nbsp;0.00000000 ms/s  = (100144 - 100144)/100144<br>
						100143: -0.00998562 ms/s  = (100143 - 100144)/100144<br>
						100142: -0.01997124 ms/s  = (100142 - 100144)/100144<br>
						</p>
						
					<p> This hardware also consistently follows the gain equation provided by the MSDN description. However, the smallest adjustment gain on 
						this hardware is almost 10 μs/s.
						</p>
						
					<p> Windows XP and Windows Server 2003 do not support a hardware HPET. These Windows versions may use Programmable Interrupt Timers (PIT), 
						Real Time Clocks (RTC), the processors Time Stamp Counter (TSC), and Power Management Timer (PMTIMER) to mimic what is later done by
						the High Precision Event Timer (HPET). These Windows versions increment  the system time at a fixed period every <i>lpTimeIncrement</i>. 
						This period does not depend on settings of the timer resolution by means of the 
						<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd757624%28v=vs.85%29.aspx">timeBeginPeriod()</a> function. 
						This is easiest confirmed by polling system file time transitions over a longer period of time with different settings of timeBeginPeriod().
						As a result, the granularity of the system time is typically in the range of 10 ms to 20 ms.						
						</p>	
				
				<h3>4.2.&nbsp;&nbsp;Windows Vista, Windows 7, <span>Windows 8, 8.1 and Windows 10</span></h3>
					<p> Windows VISTA introduced HPET support. It has been the first public Windows version decoupling the system time update and the system 
						time adjustment from the RTC Periodic Interrupt function or the ACPI PM timer in case of existing HPET hardware. This was a big step towards higher timing 
						accuracy. However, it also caused some inconsistency with a remarkable drawback for Windows VISTA and Windows 7 (<a href="http://support.microsoft.com/kb/2537623">KB2537623</a>) 
						persisting until now. Windows Vista also introduced the influence of the multimedia timer resolution (set by timeBeginPeriod) to the 
						update period of the system time: The system time is updated at a period of <i>ActualResolution</i> returned by the function NtQueryTimerResolution.
						</p>
					<p> The following list of system time gains vs. <i>dwTimeAdjustment</i> (156154 to 156330) was taken with Windows Vista on a platform without HPET/TSC support
						(lpTimeIncrement = 156250):
						</p>
					<p>
						156154 to 156169 [16 element(s)] gain -0.5120328 ms/s.<br>   
						156170 to 156185 [16 element(s)] gain -0.4096262 ms/s.<br>
						156186 to 156201 [16 element(s)] gain -0.3072197 ms/s.<br>   
						156202 to 156217 [16 element(s)] gain -0.2048131 ms/s.<br>  
						156218 to 156233 [16 element(s)] gain -0.1024066 ms/s.<br>   
						156234 to 156250 [17 element(s)] gain +0.0000000 ms/s.<br>   
						156251 to 156266 [16 element(s)] gain +0.1024066 ms/s.<br>   
						156267 to 156282 [16 element(s)] gain +0.2048131 ms/s.<br>   
						156283 to 156298 [16 element(s)] gain +0.3072197 ms/s.<br>   
						156299 to 156314 [16 element(s)] gain +0.4096262 ms/s.<br>   
						156315 to 156330 [16 element(s)] gain +0.5120328 ms/s.<br>   
						</p>
					<p> This list discloses some information contained in "... will lose any time adjustments set less than 16...". 
						It seems that it is not losing time adjustments with values less than 16, but SetSystemTimeAdjustment ignores the lower 4 bits 
						of <i>dwTimeAdjustment</i>. The obtained gain is the same for all <i>dwTimeAdjustment</i> values in one group. 
						The group size is 16. Only the group ranging from 156234 to 156250 has 17 members. It is yet unclear why the 
						scheme shows this exception. However, the gain equation used for the gain calculation obviously does not apply here. 
						Therefore, MSDN: <i>"For each lpTimeIncrement period of time that actually passes, lpTimeAdjustment will be added to the time of day"</i> 
						becomes incorrect for this configuration. Exception: Gain is zero at <i>dwTimeAdjustment</i> = <i>lpTimeIncrement</i>.
						</p>
					<p>
						The next list is taken with Windows Vista on a platform with HPET/TSC support (<i>dwTimeAdjustment</i>: 155908 to 156079, <i>lpTimeIncrement</i> = 156001): 
						</p>
					<p>
						155908 to 155922 [15 element(s)] gain -0.5000000 ms/s.<br>   
						155923 to 155938 [16 element(s)] gain -0.4000000 ms/s.<br>   
						155939 to 155954 [16 element(s)] gain -0.3000000 ms/s.<br>   
						155955 to 155969 [15 element(s)] gain -0.2000000 ms/s.<br>   
						155970 to 155985 [16 element(s)] gain -0.1000000 ms/s.<br>   
						155986 to 156001 [16 element(s)] gain +0.0000000 ms/s.<br>   
						156002 to 156016 [15 element(s)] gain +0.1000000 ms/s.<br>   
						156017 to 156032 [16 element(s)] gain +0.2000000 ms/s.<br>   
						156033 to 156047 [15 element(s)] gain +0.3000000 ms/s.<br>   
						156048 to 156063 [16 element(s)] gain +0.4000000 ms/s.<br>   
						156064 to 156079 [16 element(s)] gain +0.5000000 ms/s.<br>   
						</p>
					<p> The periodic interrupt increments the system time and performs the system time adjustment. 
						However, the "lost 4 bits" idea becomes questionable one more time. Groups have either 15 or 16 elements.</p>
					<p><span>
						The minimum selectable adjustment gain appears to be coarse on Windows VISTA. 
						TSC, HPET, or PM timer configurations show a minimum gain of approx.  +/- 0.1 ms/s.
					</span></p>
				
					<p> Windows 7 and Windows Server 2008 R2 introduced <a href="http://msdn.microsoft.com/en-us/library/windows/hardware/gg463269.aspx">Timer Coalescing</a>
						(more detailed: <a href="http://download.microsoft.com/download/9/C/5/9C5B2167-8017-4BAE-9FDE-D599BAC8184A/TimerCoal.docx">TimerCoal.docx</a>)
						<!-- more detailed: <a href="http://www.google.de/url?q=http://download.microsoft.com/download/9/C/5/9C5B2167-8017-4BAE-9FDE-D599BAC8184A/TimerCoal.docx&ei=F6mwUYz6C8zGtAao64HgCA&sa=X&oi=unauthorizedredirect&ct=targetlink&ust=1370533919200062&usg=AFQjCNEKdm6qdyZInZ6XZUeRXwU5CKrVVA">TimerCoal.docx</a> -->
						to <i>"...improve the efficiency of periodic software activity by expiring multiple distinct software timers at the same time..."</i>. 
						This portion of software shifts interrupts into groups of interrupts. A requested interrupt is accompanied by a tolerance to tell the OS by 
						how much it is allowed to shift the interrupt in time. This may affect the update of the system time and has to be diagnosed carefully.
						Windows 7 does not update the system time by fixed increments. 
						</p>
					<p> Capturing the adjustment gain on a Windows 7 platform with constant TSC support results in the following list 
						(<i>dwTimeAdjustment</i>: 155908 to 156079  <i>lpTimeIncrement</i> = 156001):
						</p>
					<p>
						155908 to 155922 [15 element(s)] gain -0.5571681 ms/s.<br>
						155923 to 155938 [16 element(s)] gain -0.4571738 ms/s.<br>
						155939 to 155954 [16 element(s)] gain -0.3571796 ms/s.<br>
						155955 to 155969 [15 element(s)] gain -0.2571853 ms/s.<br>
						155970 to 155985 [16 element(s)] gain -0.1571910 ms/s.<br>
						155986 to 156001 [16 element(s)] gain -0.0571967 ms/s.<br>
						156002 to 156016 [15 element(s)] gain +0.0427976 ms/s.<br>
						156017 to 156032 [16 element(s)] gain +0.1427918 ms/s.<br>
						156033 to 156047 [15 element(s)] gain +0.2427861 ms/s.<br>
						156048 to 156063 [16 element(s)] gain +0.3427804 ms/s.<br>
						156064 to 156079 [16 element(s)] gain +0.4427747 ms/s.<br>
						</p>
						
					<p> Three important results can be drawn from the list above:
						</p>
						<ul>
						<li>The gain at <i>dwTimeAdjustment</i> = <i>lpTimeIncrement</i> is not 0 ms/s.</li>
						<li>The gain distribution is asymmetric. The gain steps are in the order of 0.1 ms/s, but the smallest positive gain differs from the smallest negative gain.</li> 
						<li>The smallest available adjustment is 42 μs/s in the positive direction and -57 μs/s in the negative direction. 
							This does not appear to be a good resolution when compared to Windows XP and Windows Server 2003.</li> 
						</ul>
		
					<p> This behavior raises the question of whether a specific gain for a specific value of <i>dwTimeAdjustment</i> 
						remains constant over time. Careful evaluation of this matter has not confirmed any variation of the gain 
						(added advancement of the system time) when a constant value of <i>dwTimeAdjustment</i> is applied. Therefore, it remains 
						difficult to predict the adjustment gain for values of <i>dwTimeAdjustment</i> for systems affected by this scheme 
						(Windows Vista and Windows 7 with HPET/TSC support). "For each <i>lpTimeIncrement</i> period of time that actually passes, <i>dwTimeAdjustment</i> 
						will be added to the time of day." In this regard, [<a href="http://msdn.microsoft.com/de-de/library/windows/desktop/ms724943%28v=vs.85%29.aspx">MSDN</a>]'s 
						claim turns out to be wrong on Windows 7 too. 
						<span>Note: This specific asymmetry occurs with the systems interrupt period set the minimum by 
						means of e.g. timeBeginPeriod(wPeriodMin).</span> 
						</p>
					<p> All software packages using SetSystemTimeAdjustment are in serious danger of relying on predictable gains. 
						It should also be noted that there is no <i>dwTimeAdjustment</i> setting for a gain of 0.0 ms/s. It was shown in section 4.1 that 
						earlier versions of Windows had a much more predictable scheme. The scheme observed on Windows VISTA and Windows 7 requires the 
						software to calibrate itself to the appropriate gain for values of <i>dwTimeAdjustment</i> because it cannot be easily evaluated by the 
						given values of <i>lpTimeIncrement</i> and <i>lpTimeAdjustment</i>.
						</p>
					<p> The system time synchronization routines of these newer Windows versions do not seem to take these facts into account. 
						A typical synchronization to an internet time server uses all bits for setting the values of <i>dwTimeAdjustment</i>. 
						This can be easily monitored through frequent use of GetSystemTimeAdjustment. Furthermore, these tools expect the 
						lower 4 bits to be taken into account by the system. Windows calculates a correction scheme ahead of the actual 
						adjustment based on the offset to the network time. Unfortunately, the gains are not set as expected and the 
						predicted scheme messes up the adjustment/synchronization, which results in the synchronization being completely off. 
						This is accompanied by the fact that there is no monitoring of the internet time provider while the system time adjustment progresses. 
						Such an adjustment can run for hours and a big deviation may appear with wrong gain estimates resulting from the synchronization 
						algorithm. Finally, at some point the deviation will be several seconds and the next synchronization will only set the local time 
						to the network time without applying the function SetSystemTimeAdjustment.
						</p>	
					<p> Windows 8 has finally fixed this mishap. This list has been captured on a Windows 8 system with constant TSC support:</p>
					<p>
						155995 to 155995 [1 element(s)] gain -0.0377952 ms/s.<br>
						155996 to 155996 [1 element(s)] gain -0.0316960 ms/s.<br>
						155997 to 155997 [1 element(s)] gain -0.0255968 ms/s.<br>
						155998 to 155998 [1 element(s)] gain -0.0185976 ms/s.<br>
						155999 to 155999 [1 element(s)] gain -0.0127984 ms/s.<br>
						156000 to 156000 [1 element(s)] gain -0.0062992 ms/s.<br>
						156001 to 156001 [1 element(s)] gain +0.0003000 ms/s.<br>
						156002 to 156002 [1 element(s)] gain +0.0073991 ms/s.<br>
						156003 to 156003 [1 element(s)] gain +0.0130983 ms/s.<br>
						156004 to 156004 [1 element(s)] gain +0.0200975 ms/s.<br>
						156005 to 156005 [1 element(s)] gain +0.0257967 ms/s.<br>
						156006 to 156006 [1 element(s)] gain +0.0327959 ms/s.<br>
						156007 to 156007 [1 element(s)] gain +0.0389951 ms/s.<br>
					</p>
					<p> The missing resolution for the value of dwTimeAdjustment is gone, each value has its own gain and the gain is close 
						to the predicted gain (Example: 156003: (156003 - 156001)/156001 = 0.0128 ms/s). The deviation of gains shown in this 
						list are a result of the changes in Windows 8 timekeeping. Windows 8 does not increment the system time by constant 
						increments, it rather applies a variety of increments to achieve a desired mean increment. As a consequence, the above 
						measurement would have to be taken over many more periods to show results with less deviations. However, it is very 
						obvious that the described adjustment scheme if fulfilled with Windows 8. </p>
					<p> As of Windows 8.1, timekeeping has again undergone some modifications. The same hardware now reports 156250 for <i>lpTimeIncrement</i>.
						The list of gains appears as follows:</p>
					<p>
						156244 to 156244 [1 element(s)] gain -0.0382037 ms/s.<br>
						156245 to 156245 [1 element(s)] gain -0.0316040 ms/s.<br>
						156246 to 156246 [1 element(s)] gain -0.0259043 ms/s.<br>
						156247 to 156247 [1 element(s)] gain -0.0184048 ms/s.<br>
						156248 to 156248 [1 element(s)] gain -0.0124051 ms/s.<br>
						156249 to 156249 [1 element(s)] gain -0.0066054 ms/s.<br>
						156250 to 156250 [1 element(s)] gain +0.0004942 ms/s.<br>
						156251 to 156251 [1 element(s)] gain +0.0060939 ms/s.<br>
						156252 to 156252 [1 element(s)] gain +0.0135934 ms/s.<br>
						156253 to 156253 [1 element(s)] gain +0.0188931 ms/s.<br>
						156254 to 156254 [1 element(s)] gain +0.0253928 ms/s.<br>
						156255 to 156255 [1 element(s)] gain +0.0324924 ms/s.<br>
						156256 to 156256 [1 element(s)] gain +0.0385920 ms/s.<br>
					</p>		
					<p> Windows 8.1 has finally returned to the original Windows heartbeat of 64 Hz (1/15.625 ms).
						Each value of <i>dwTimeAdjustment</i> produces an individual gain and the result follows the documentation.</p>
					<p> When operating on a platform with invariant TSC, the scheme looks like this:</p>
					<p>
						156244 to 156244 [1 element(s)] gain -0.0384000 ms/s.<br>
						156245 to 156245 [1 element(s)] gain -0.0320000 ms/s.<br>
						156246 to 156246 [1 element(s)] gain -0.0256000 ms/s.<br>
						156247 to 156247 [1 element(s)] gain -0.0192000 ms/s.<br>
						156248 to 156248 [1 element(s)] gain -0.0128000 ms/s.<br>
						156249 to 156249 [1 element(s)] gain -0.0064000 ms/s.<br>
						156250 to 156250 [1 element(s)] gain +0.0000000 ms/s.<br>
						156251 to 156251 [1 element(s)] gain +0.0064000 ms/s.<br>
						156252 to 156252 [1 element(s)] gain +0.0128000 ms/s.<br>
						156253 to 156253 [1 element(s)] gain +0.0192000 ms/s.<br>
						156254 to 156254 [1 element(s)] gain +0.0256000 ms/s.<br>
						156255 to 156255 [1 element(s)] gain +0.0320000 ms/s.<br>
						156256 to 156256 [1 element(s)] gain +0.0384000 ms/s.<br>
					</p>		
						
					<p> This looks very much like the classical Windows XP adjustment gain scheme. It matches the 
												formula <i>gain = (lpTimeAdjustment - lpTimeIncrement)/ lpTimeIncrement.</i></p>
						
					<p> The system time adjustment will take care that the system time will progress by <i>TimeAdjustment</i> during
						<i>TimeIncrement</i>. This effectively happened with Windows XP. Since Windows 8 (on specific hardware also since Windows 7) 
						this process may also appear as a progress in smaller steps, depending on the setting of the timer resolution. When the timer
						resolution is set to maximum resolution (see section 2.1. of <i>Microsecond Resolution Timer Services for Windows</i>), the
						obtained increments are in the same order of magnitude as the timer resolution. However, Windows 8 and Windows 8.1 maintain
						the average progress of <i>TimeAdjustment</i> during <i>TimeIncrement</i>.
						</p>
							
					<p> This scheme also applies for Windows 10.</p>
					<p> Additional information:
						</p>
					<p> MSDN: <i>"The W32Time service cannot reliably maintain sync time to the range of 1 to 2 seconds. 
						Such tolerances are outside the design specification of the W32Time service."</i> 
						[<a href="http://support.microsoft.com/kb/939322/en-us">Support boundary to configure the Windows Time service for high accuracy environments</a>]			
						</p>
					<p>	MSDN: <i>"If the time difference between the local clock and the selected accurate time sample (also called the time skew) 
						is too large to correct by adjusting the local clock rate, the time service sets the local clock to the correct time."</i>
						[<a href="http://technet.microsoft.com/en-us/library/cc773013%28v=ws.10%29">How the Windows Time Service Works</a>]		
						</p>
					
				<h3>4.3.&nbsp;&nbsp;Monitoring an NTP time provider</h3>
					<p> A much more detailed view of the system time adjustment can be obtained when the local time is compared to a precise remote 
						time while the system time adjustment is active. The accuracy of w32tm.exe is simply too poor to extract meaningful results. 
						Also, the accuracy of time.windows.com is unsatisfactory.
					</p>
					<p> In order to facilitate a closer look at the problems described above, an NTP 
						(<a href="http://www.ntp.org/">Network Time Protocol</a>) client was added to the time services 
						and the user interface was extended by an NTP Offset tab. This allows to see how the local 
						time progresses against a reference time.
						</p>
					<p> The calibrated performance counter frequency receives an additional correction when a system time adjustment is active. 
						The system time adjustment forces the local time to advance slower or faster, thus the performance counter frequency has to 
						be corrected in a way that takes the modified duration of the "second" during the adjustment into account (see section 2.1.3. of 
						<a href="http://www.windowstimestamp.com/description">Microsecond Resolution Time Services for Windows</a>). 
						Consequently, an applied system time adjustment becomes visible in the "Calibrated Performance Counter Frequency Offset" tab.
						<span>
						As of version 1.2, the calibrated performance counter frequency offset is given in ppm. It is referenced to the value 
						given by QueryPerformanceFrequency() and scaled to show deviation in parts per million. This corresponds to μs/s. 
						This way applied system time adjustment gains will directly show in the plot with real numbers. 
						</span>
						</p>
						<p><span>
						The user interface now also provides two checkboxes. When the NTP checkbox is checked, NTP monitoring is activated. 
						The "Autoadjust" checkbox enables permanent synchronization of the local time to a network time: 
						</span></p>	
					
					<p><a href="http://www.windowstimestamp.com/Fig_4_3_1_GUI_170.png" target="_blank"><img alt="Fig_4_3_1_GUI_170.png" title="V1.70 GUI with NTP/Autoadjust check boxes, status lines and NTP tab" src="http://www.windowstimestamp.com/Fig_4_3_1_GUI_170.png"></a></p><h6>Fig. 4.3.1: GUI V1.70 with NTP Offset tab, NTP and Autoadjust checkboxes, and NTP/Autoadjust status lines.</h6>
					
					<p> The NTP status and the current offset to the network time are reported at the bottom in the NTP status line. 
						Another status line contains information about the automatic adjustment (see section 4.4 for more information on automatic adjustment).
						</p>
					<p> The following two plots were captured when the a system time adjustment was triggered by Windows XP:
						</p>
					
					
					<p><a href="http://www.windowstimestamp.com/Fig_4_3_2_XP_good_sync_cpcf.png" target="_blank"><img alt="Fig_4_3_2_XP_good_sync_cpcf.png" title="System time adjustment mapped to performance counter frequency (Windows XP)" src="http://www.windowstimestamp.com/Fig_4_3_2_XP_good_sync_cpcf.png"></a></p><h6>Fig. 4.3.2: System time adjustment mapped to performance counter frequency (Windows XP).</h6>

					
					<p><a href="http://www.windowstimestamp.com/Fig_4_3_3_XP_good_sync_ntp.png" target="_blank"><img alt="Fig_4_3_3_XP_good_sync_ntp.png" title="NTP Offset during the adjustment (Windows XP)" src="http://www.windowstimestamp.com/Fig_4_3_3_XP_good_sync_ntp.png"></a></p><h6>Fig. 4.3.3: NTP Offset during the adjustment (Windows XP).</h6>
					   
					<p> Fig. 4.3.2 shows that the performance counter frequency offset jumps to about 140 ppm. This corresponds to an initial adjustment 
						gain of 120 μs/s because the initial offset was already 20 ppm. The gain was reduced in steps over a long period of time (the total 
						adjustment lasted from 8:46 to around 16:00). In the first part, the gain was reduced after about the same time until about 11:33. 
						At that point, the granularity of <i>dwTimeAdjustment</i> prohibited smaller steps and the time between the modifications of 
						<i>dwTimeAdjustment</i> was extended. This way, the target could be approached with a decreasing adjustment speed. The last step 
						from about 13:50 represents the <i>dwTimeAdjustment</i> = 156250. The system time adjustment was still enabled, however the gain was 0.0 ms/s. 
						At this point, the system drifted with its own drift rate.
						</p>
					<p> Typical drifts of local time are in the area of a few μs/s. However, the smallest gain obtainable on Windows XP is 1/156250 = 6.4 μs. 
						In practice, the drift may be higher than the smallest gain setting. This way, a final adjustment step may not move in the desired direction. 
						This can be seen in Fig. 4.3.3. As mentioned, the whole scheme of how and when the various gain settings are applied is worked out ahead 
						of the actual adjustment; however, the local drift can add a considerable offset when the adjustment takes many hours.
						</p>
					<p> As described in 4.2, a lot can fail during an adjustment on newer Windows versions. The following plot was recorded during an adjustment on Windows 7:
						</p>

					
					<p><a href="http://www.windowstimestamp.com/Fig_4_3_4_system_time_adjustment_on_W7_endless.png" target="_blank"><img alt="Fig_4_3_4_system_time_adjustment_on_W7_endless.png" title="Calibrated performance counter frequency during a system time adjustment (Windows 7)" src="http://www.windowstimestamp.com/Fig_4_3_4_system_time_adjustment_on_W7_endless.png"></a></p><h6>Fig. 4.3.4: Calibrated performance counter frequency during a system time adjustment (Windows 7).</h6>

					<p> The initial offset is about -40 ppm. The jump to 540 ppm indicates an initial gain of about 580 ppm or μs/s. 
						Due to poor resolution (granularity of gain), the sign of the adjustment gain changes after just 2 steps and remains there 
						for a long time (at least for another day). This is a typical example of a failing system time adjustment on a Windows 7 system. 
						The offset time is basically the sum of the adjustments and is completely messed up (large negative offset) during this attempt. 
						</p>

					<p>
						Windows 8 has fixed the limited resolution of dwTimeAdjustment and shows adjustments comparable to Windows XP. 
						The following two plots show a system time adjustment initiated by the Windows 8 internet time GUI:
					</p>					
					
					<p><a href="http://www.windowstimestamp.com/Fig_4_3_5_cpcf_W8_plus500ms.png" target="_blank"><img alt="Fig. 4.3.5: Calibrated performance counter frequency during a system time adjustment (Windows 8)." title="Calibrated performance counter frequency during a system time adjustment (Windows 8)" src="http://www.windowstimestamp.com/Fig_4_3_5_cpcf_W8_plus500ms.png"></a></p><h6>Fig. 4.3.5: Calibrated performance counter frequency during a system time adjustment (Windows 8).</h6>

					
					<p><a href="http://www.windowstimestamp.com/Fig_4_3_6_NTP_offset_W8_plus500ms.png" target="_blank"><img alt="Fig. 4.3.6: NTP offset during a system time adjustment (Windows 8)." title="NTP offset during a system time adjustment (Windows 8)." src="http://www.windowstimestamp.com/Fig_4_3_6_NTP_offset_W8_plus500ms.png"></a></p><h6>Fig. 4.3.6: NTP offset during a system time adjustment (Windows 8).</h6>
						
					<p> NTP monitoring was enabled at 10:15:15. From this point in time no adjustment was active, the system drifted at about 14.4 μs/s 
						until 10:33:13 when the NTP offset reached 0.5 s (500 ms) and the system time adjustment was enabled. The procedure was performed 
						by Windows in 11 steps, starting with dwTimeAdjustment = 156014:
					</p>	
						
					<p>
						156014 from 10:33:13 to 10:50:17, duration: 1024 s, gain = +83.333 μs/s,<br> 	   
						<span></span>gained +85.333 ms, remaining offset: +414.7 ms<br>
						<span>&nbsp;</span><br>
						156012 from 10:50:17 to 11:07:21, duration: 1024 s, gain = +70.512 μs/s,<br>
						<span></span>gained +72.204 ms, remaining offset: +342.5 ms<br>
						<span>&nbsp;</span><br>
						156010 from 11:07:21 to 11:24:25, duration: 1024 s, gain = +57.692 μs/s,<br>
						<span></span>gained +59.077 ms, remaining offset: +283.4 ms<br>
						<span>&nbsp;</span><br>
						156008 from 11:24:25 to 11:41:30, duration: 1025 s, gain = +44.872 μs/s,<br>
						<span></span>gained +45.994 ms, remaining offset: +237.4 ms<br>
						<span>&nbsp;</span><br>
						156007 from 11:41:30 to 11:58:34, duration: 1024 s, gain = +38.461 μs/s,<br>
						<span></span>gained +39.384 ms, remaining offset: +198.0 ms<br>
						<span>&nbsp;</span><br>
						156006 from 11:58:34 to 12:15:37, duration: 1023 s, gain = +32.051 μs/s,<br>
						<span></span>gained +32.788 ms, remaining offset: +165.2 ms<br>
						<span>&nbsp;</span><br>
						156005 from 12:15:37 to 12:32:41, duration: 1024 s, gain = +25.641 μs/s,<br>
						<span></span>gained +26.256 ms, remaining offset: +138.9 ms<br>
						<span>&nbsp;</span><br>
						156004 from 12:32:41 to 13:06:49, duration: 2048 s, gain = +19.231 μs/s,<br>
						<span></span>gained +39.385 ms, remaining offset:  +99.5 ms<br>
						<span>&nbsp;</span><br>
						156003 from 13:06:49 to 13:58:02, duration: 3072 s, gain = +12.820 μs/s,<br>
						<span></span>gained +39.383 ms, remaining offset:  +60.1 ms<br>  
						<span>&nbsp;</span><br>
						156002 from 13:58:02 to 15:06:17, duration: 4095 s, gain =  +6.410 μs/s,<br>
						<span></span>gained +26.249 ms, remaining offset:  +33.8 ms<br> 
						<span>&nbsp;</span><br>
						156001 from 15:06:17 to ?<br> 
					</p>
					<p>	The list shows the progress of the adjustment for each setting of dwTimeAdjustment followed by the period of time 
						during which dwTimeAdjustment was active. The gain was calculated using the expression given in 4. Consequently, 
						the adjustment contribution and the remaining offset was calculated. The adjustment scheme looks identical 
						to the scheme observed on Windows XP. Presumably no changes have been made to the systems adjustment tool. 
						However some more details can be extracted from the list above: 		
					</p>			

					<ul>
						<li> The scheme initially varies the step width of dwTimeAdjustment to obtain a degressive progress of the 
							 adjustment (156014 ... 012 ... 010 ... 008).
						</li> 
						<li> It extends the duration to achieve a similar effect. However, the duration is unnecessarily fixed 
							 to multiples of 1024 seconds (156004: 2048 s, 156003 3072 s ...).
						</li>
						<li> Reaching dwTimeAdjustment = 156003 causes the desired gain of 12.82 μs/s to be below the systems drift. 
							 From this point onwards, the adjustment gain is not capable to compensate for the systems drift. 
							 This also becomes very obvious in the NTP offset plot, from about 13:06 the offset starts to increase again.
						</li>
						<li> Adjustment is effectively disabled at 15:06:17 by setting dwTimeAdjustment to 156001, which causes the (mean-) gain 
							 to be zero. But lpTimeAdjustmentDisabled remains FALSE for an unknown reason. Even many hours later (past 19:10:00) 
							 lpTimeAdjustmentDisabled was kept FALSE by Windows.
						</li>
					</ul>		

					<p> The observed offset at the end of the active adjustment was approx. 270 ms. The total adjustment time was 16386 s 
						(10:33:11 to 15:06:17, 16 x 1024 s). The systems drift was 14.4 μs/s. At a drift rate of 14.4 μs/s the system drifted by 
						235.36 ms over the 16386 seconds. The difference to the observed offset of 270 ms is 34.64 ms. This corresponds to the 
						remaining offset derived from the adjustment progress table.
					</p>		
					<p> This evidently shows that Windows calculates an adjustment scheme based on a one-time offset measurement ahead of the 
						actual adjustment. Unfortunately the scheme captured here does allow for a remarkable remaining offset. The drift is 
						not taken into account at any time. This way an adjustment, like the adjustment shown here, may take several hours to 
						adjust the offset into the few milliseconds regime and just about the same time to be where the offset was prior to 
						the attempt to adjust.   
					</p>
					<p> Larger offsets are not adjusted using such a scheme. An offset of say 10 seconds is simply corrected by setting 
						the system time in one shot. This produces a jump in time which may be confusing to software, particularly when the 
						jump in time is backwards.
					</p>
					
				<h3>4.4.&nbsp;&nbsp;Synchronizing to an NTP time provider</h3>

					<p> Windows broadcasts a WM_TIMECHANGE message to all top level windows when a system time change occurs. This can be used to detect 
						changes of system time but it requires a window. However, there is no notification when the system time is adjusted. As a result, the system time changes 
						gradually without any notification other than the actual changes in the flow of time. The only way to check this is through a 
						frequent call to GetSystemTimeAdjustment. This is an obvious drawback. The state of such asynchronous behavior can only be closely 
						estimated by calling GetSystemTimeAdjustment frequently.
						</p>
					<p> Time control with high accuracy, as proposed by the Windows Timestamp Project, cannot accept the uncertainties and inaccuracies 
						described here. The proposed solution is continuous synchronization of the system time to a network time using NTP. This automatic 
						adjustment can be enabled by checking the "Autoadjust" checkbox of the GUI (Fig. 4.3.1). Synchronizations of the local time may 
						still occur asynchronously when scheduled by the operating system; however, the service described here is capable of detecting 
						and canceling them. Nevertheless, disabling the automatic synchronization provided by Windows (see the Windows GUI in section 1) 
						is recommended in order to obtain the greatest accuracy.
						</p>
					<p> The following graph shows a Windows 8 system:
						</p>
					
					<p><a href="http://www.windowstimestamp.com/Fig_4_4_1_Drift_and_Autoadjust_on_W8.png" target="_blank"><img alt="Fig. 4.4.1: Drift and autoadjust on a Windows 8 system." title="Drift and autoadjust on a Windows 8 system." src="http://www.windowstimestamp.com/Fig_4_4_1_Drift_and_Autoadjust_on_W8.png"></a></p><h6>Fig. 4.4.1: Drift and autoadjust on a Windows 8 system..</h6>
					   
					<p> NTP monitoring was started at around 18:16 and the local time drifted at a rate of about -14.2 μs/s. The NTP offset increased 
						from around 0.0005 s to around 0.015 s within the next 19 min (green plot line). At about 18:35, the autoadjust was enabled 
						and the local time was synchronized to the network time.
						</p>
					<p> The effect of the system time adjustment on the performance counter frequency has been described in section 4.3. 
						The plot of the calibrated performance counter offset for the adjustment shown in Fig. 4.4.1 is given below:
						</p>
					
					<p><a href="http://www.windowstimestamp.com/Fig_4_4_2_PCF_and_Autoadjust_on_W8.png" target="_blank"><img alt="Fig. 4.4.2: Adjustment steps on a Windows 8 system." title="Adjustment steps on a Windows 8 system." src="http://www.windowstimestamp.com/Fig_4_4_2_PCF_and_Autoadjust_on_W8.png"></a></p><h6>Fig. 4.4.2: Adjustment steps on a Windows 8 system.</h6>
					   
					<p> Fig. 4.4.1 shows that the network time is running faster and the local time loses about 14 μs/s. Positive gains are required to catch 
						up with the network time. The time service started by applying the smallest positive gain with <i>dwTimeAdjustment</i> = 156002. This resulted 
						in a gain of 0.0064 ms/s. Afterwards, the value of <i>dwTimeAdjustment</i> was incremented periodically. At a value of 156051, the gain 
						increased to 0.3205 ms/s. The <i>dwTimeAdjustment</i> was decremented periodically after half of the desired offset was adjusted.
						<span>
						A positive gain causes the system time to progress faster; the calibrated performance counter frequency consequently 
						gets lowered with positive gains. As already mentioned, the calibrated performance counter offset is normalized to 
						the performance counter frequency given by the system to show ppm. As a result the plot effectively shows negated gain 
						values (e.g. a gain of +18.2 μs/s will show as -18.2 ppm).
						</span>
						</p>
					<p> The continuous adjustment results in a mean offset of the network time to local time in the range of a few 100 microseconds. 
						However, this may be affected by network bandwidth and/or NTP server quality. The network time server pool used here is 
						<a href="http://www.pool.ntp.org/">pool.ntp.org</a> (it is highly recommended to read the information provided by this site). 
						The accuracy of servers provided by this source typically outperforms the accuracy of time.windows.com. The available bandwidth is essential 
						for very high accuracy. Heavy traffic on the network connection may temporarily drop the level of accuracy to within a few milliseconds.
						</p>
					<p> The next graph shows a continuous adjustment interrupted by a three minute drift phase in between to highlight the narrow band 
						in which the NTP offset is held during the adjustment:
						</p>
					
					<p><a href="http://www.windowstimestamp.com/Fig_4_4_3_W7_continuous_adjustment_interrupted_by_a_three_minutes_drift_phase.png" target="_blank"><img alt="Fig_4_4_3_W7_continuous_adjustment_interrupted_by_a_three_minutes_drift_phase.png" title="Windows 7: Continuous adjustment interrupted by a three minutes drift phase" src="http://www.windowstimestamp.com/Fig_4_4_3_W7_continuous_adjustment_interrupted_by_a_three_minutes_drift_phase.png"></a></p><h6>Fig. 4.4.3: Windows 7: Continuous adjustment interrupted by a three minutes drift phase.</h6>

				   <p> This figure was taken as a screenshot of the GUI to show the estimated local drift. This local drift can be estimated from the mean 
						of the applied gains after a few minutes of continuous operation of "autoadjust". Its value appears in the "all output" tab and at the 
						end of the NTP status line when available.
						</p>
					<p> The quality of adjustment becomes visible when the network time offset drifts. In just three minutes, the offset drifted to about 2.7 ms. 
						If high accuracy is required, it is not only necessary to synchronize the local time to a network time periodically; it is essential 
						to synchronize it continuously.   
						</p>
					<p>
						Note: Version 1.70 introduced the precision mode. The NTP capture leaves this mode when the offset exceeds 2 ms and re-enters it
						when the offset is below 1.5 ms. This behavior was already visible in fig. 4.3.1 and becomes also visible here. 
					</p>
					
				<h3>4.5.&nbsp;&nbsp;Conclusions</h3>
					<p> Windows synchronization to a network time reference has proved to not be very accurate. In particular, Windows versions VISTA and 7  
						seem to have lost some of the capabilities for some unknown reason. Unfortunately, there is not much information on this issue and 
						the little information available basically says that Windows time synchronization should not be expected to be more accurate than a 
						few seconds and that there may be a mishap in the behavior of SetSystemTimeAdjustment with respect to the meaning of the value of 
						<i>dwTimeAdjustment</i>.
						<span>					
						Only Windows 8 has now overcome these drawbacks and its system time adjustment performs like it did on Windows XP.
						</span>
						</p>
					<p> Unfortunately, there are still many NTP synchronization packages around which operate under the assumption of the current 
						MSDN description that "For each <i>lpTimeIncrement</i> period of time that actually passes, <i>lpTimeAdjustment</i> will be added 
						to the time of day". Evidently, this assumption is not true for Windows VISTA and Windows 7. 
						These versions need software that is capable of dealing with the artifacts described here to set the system 
						time correctly to obtain good accuracy. 
						</p>
					<p> 
						<span>					
						Offsets of system time may drift seconds per day. Even on systems with a low drift rate the drift can easily reach half 
						a second per day. This can only be overcome by a correction of the systems knowledge of its clock frequency. Newer Windows 
						versions calibrate the performance counter frequency (result of QueryPerformanceFrequency) at boot time when operating with TSC and/or HPET. 
						This was initially done by Windows 7 and has improved with Windows 8. But there does not seem to be an on the fly correction of 
						this value while a network time synchronization occurs. This is basically the reason for the noticeable drift and the need for 
						a continuous adjustment. Windows 8.1 has not shown any improvements with respect to the "build in" system time adjustment.
						</span>
					</p>
					
			<h2>A pdf version of <i>"Part II: Adjustment of System Time"</i> can be downloaded <a href="http://www.windowstimestamp.com/pdf_download_2" target="_blank">here</a>.</h2>
			<p>
				Don't miss more details described on the "<a href="http://www.windowstimestamp.com/news">News</a>" page.
				A pdf version of the <b>News History</b> can be downloaded <a href="http://www.windowstimestamp.com/pdf_download_news" target="_blank">here</a>.
			</p>

			<p>
				Note: Windows is a registered trademark of Microsoft Corporation in the United States and other countries. 
				The Windows Timestamp Project is an independent publication and is not affiliated with, nor has it been authorized, sponsored, or 
				otherwise approved by Microsoft Corporation.
			</p>

			<center>
				<p>…</p>
				</center>	
		</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>