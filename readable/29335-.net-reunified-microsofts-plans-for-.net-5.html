<!DOCTYPE html>
<html lang="en">
<head>
    <title>
.NET Reunified: Microsoft&#x2019;s Plans for .NET 5 -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>.NET Reunified: Microsoft&#x2019;s Plans for .NET 5</h1>
    <div><div class="article"> <div class="FeatureTitle" id> <p>By <a href="https://msdn.microsoft.com/en-us/magazine/mt149362?author=mark+michaelis">Mark Michaelis</a> | July 2019</p> </div> <p>When Microsoft announced .NET 5 at Microsoft Build 2019 in May, it marked an important step forward for developers working across desktop, Web, mobile, cloud and device platforms. In fact, .NET 5 is that rare platform update that unifies divergent frameworks, reduces code complexity and significantly advances cross-platform reach.</p> <p>This is no small task. Microsoft is proposing to merge the source code streams of several key frameworks&#x2014;.NET Framework, .NET Core and Xamarin/Mono. The effort will even unify threads that separated at inception at the turn of the century, and provide developers one target framework for their work.</p> <p>The source code flow concept in <strong>Figure 1</strong> shows how the timeline for each framework syncs up, and ultimately merges into a single thread as .NET 5 in November 2020. (Note that .NET Framework has been shortened to .NET FW in the image.) When released, .NET 5 will eclipse .NET Framework 4.8, Mono 5.0, and .NET Core 3.0.</p> <div> <p> <a href="https://msdn.microsoft.com/en-us/magazine/mt833477.0719_michaelis_figure1_large(l=en-us).png"> <img alt="Source Code Flow Concept from .NET, Mono, and Shared Source Initiative to .NET 5" src="https://i-msdn.sec.s-msft.com/dynimg/IC880753.png"> </a> <br> <strong>Figure 1 Source Code Flow Concept from .NET, Mono, and Shared Source Initiative to .NET 5</strong> (click for larger version)</p> </div> <p>Admittedly, <strong>Figure 1</strong> is more conceptual than reality, with source code forking (more likely just copying) rather than branching, and features (like Windows Presentation Foundation [WPF] or Windows Forms) migrating rather than merging. Still, the infographic provides a reasonably transparent view of the ancestral history of the .NET source code, showing its evolution from the three major branches all the way to .NET 5.</p> <p>The result of this work is a unified platform with the .NET 5 framework executing on all platforms (desktop, Web, cloud, mobile and so on). <strong>Figure 2</strong> depicts this unified architecture.</p> <div> <p> <img alt=".NET 5&#x2014;a Unified Platform" src="https://i-msdn.sec.s-msft.com/dynimg/IC880768.png"> <br> <strong>Figure 2 .NET 5&#x2014;a Unified Platform</strong> </p> </div> <h2>Origin Story</h2> <p>It&#x2019;s fascinating how the different .NET frameworks&#x2014;such as Microsoft&#x2019;s Shared Source Common Initiative (Rotor), SilverLight, Windows Phone, .NET Core, and .NET Framework (but not Mono)&#x2014;were originally compiled from the same source code. In other words, all the source code was maintained in a single repository and shared by all .NET frameworks. In so doing, Microsoft was able to ensure that APIs that were common to different frameworks would come from the same source code and have the same signatures. The only differences were which APIs were shared. (Note the use of .NET &#x201C;framework,&#x201D; lowercase, referring to all .NET frameworks in general, vs .NET &#x201C;Framework,&#x201D; uppercase, referring to the Windows .NET Framework, such as .NET Framework 4.8.)</p> <p>To achieve a single source targeting different frameworks, various subsetting techniques, such as a multitude of #ifdefs, were used. Also of interest is how an orthogonal set of subsetting techniques (that is, different #ifdefs) were baked into the .NET source code to build Rotor&#x2019;s cross-platform support, enabling rapid development of both Silverlight and (much later) .NET Core from the same code base.</p> <p>While the orthogonal set of subsetting techniques remains, the one that enables cross-platform compilation&#x2014;the subsetting to produce the different frameworks&#x2014;is being removed. (See, for example, the pull request at <a href="http://bit.ly/2WdSzv2">bit.ly/2WdSzv2</a> that removes several #ifdefs that are stale.) The reason it&#x2019;s possible to remove them today is because within days after the .NET 1.1 release, the .NET Core and .NET Framework source code was forked (more like copied). This in fact explains why there are two separate .NET source code Web sites: .NET Framework at <a href="http://referencesource.microsoft.com/">referencesource.microsoft.com</a> and .NET Core at <a href="http://source.dot.net/">source.dot.net</a>. These are two separate code bases.</p> <p>The decision to fork rather than continue the use of subsetting reflects the tension between maintaining backward compatibility (a high priority for the .NET Framework) and innovation (the priority of .NET Core). There were simply too many cases where maintaining compatibility conflicted with correcting or improving the .NET APIs, such that the source code had to be separated if both goals were to be achieved. Using #ifdefs was no longer a functional way to separate out the frameworks when, in fact, the APIs were different and version incompatible.</p> <p>Over time, however, another conflict arose&#x2014;that of allowing developers to create libraries that could successfully execute within both frameworks. To achieve this, an API standard was needed to assure developers that a framework would have a specific set of APIs identified by the standard. That way, if they leveraged only the APIs within the standard, their library would be cross-framework compatible (the exact same assembly could run on different frameworks&#x2014;without even recompiling).</p> <p>With each new feature added to .NET (for example Span&lt;T&gt;), it became more and more difficult to maintain backward compatibility with older versions of the framework. More specifically, the challenge was to support concepts in new .NET Standard versions&#x2014;which were really new .NET Core innovations&#x2014;in the .NET Framework. Furthermore, though less significantly, each new version of the .NET Standard included a larger and larger set of APIs until it became a maintenance burden to preserve .NET Standard compatibility between .NET Framework and .NET Core.</p> <h2>Come Together</h2> <p>The two frameworks began to look more and more alike because of the standard. As the APIs became more consistent, the obvious question began to arise: Why not move the separate code bases back together? And, in fact, starting with .NET Core 3.0 preview, so much of the .NET Framework WPF and Windows API was cherry-picked and merged into the .NET Core 3.0 code base, that this is exactly what happened. The source code for .NET Core 3.0 became one and the same with the modern day (desktop, cloud, mobile and IoT) functionality in .NET Framework 4.8.</p> <p>At this point there&#x2019;s still one major .NET framework that I haven&#x2019;t covered: Mono/Xamarin. Although the source code for Rotor was publicly available, using it would&#x2019;ve violated the license agreement. Instead, Mono began as a separate green field development effort with the vision to create a Linux-compatible version of .NET. The Mono framework continued to grow over time, until the company (Ximian) was acquired in 2003 by Novell and then shuttered eight years later following Novell&#x2019;s sale to Attachmate. Ximian management quickly reformed in May 2011 as Xamarin. And less than two years later, Xamarin developed a cross-platform UI code base that ran on both Android and iOS, leveraging a now closed-source, cross-platform version of Mono under the covers.</p> <p>In 2016 Microsoft acquired Xamarin to bring all the .NET framework source code under the control of a single company. Shortly after, Mono and the Xamarin SDK would be released as open source.</p> <p>This brings us to where we are in the first half of 2019, with essentially two main code bases going forward: .NET Core 3.0 and Mono/Xamarain. (While Microsoft will support .NET Framework 4.8 on Windows for as long as anyone can forecast, .NET Core 3.0 and later .NET 5 will&#xA0; eclipse it as the strategic platform for new applications going forward.) Alongside this is the .NET Standard and the unification of APIs into the soon-to-be-released .NET Standard 2.1.</p> <p>Again, the question arises, with APIs moving closer and closer, can we not merge .NET Core 3.0 with Mono? It&#x2019;s an effort, in fact, that has already begun. Mono today is already one-third Mono source, one-third CoreFx, and one-third .NET Framework reference source. That set the stage for .NET 5 to be announced at Microsoft Build 2019.</p> <h2>The Advantages of .NET 5</h2> <p>This unified version of .NET 5 will support all .NET application types: Xamarin, ASP.NET, IoT and desktop. Furthermore, it will leverage a single CoreFX/Base Class Library (BCL), two separate runtimes and runtime code bases (because it&#x2019;s really hard to single source two runtimes intended to be critically different), and a single tool chain (such as dotnet CLI). The result will be uniformity across behaviors, APIs and developer experiences. For example, rather than having three implementations of the System.* APIs, there will be a single set of libraries that run on each of the different platforms.</p> <p>There are a host of advantages with the unification of .NET. Unifying the framework, runtimes, and developer toolsets into a single code base will result in a reduction in the amount of duplicate code that developers (both Microsoft and the community) will need to maintain and expand. Also, as we&#x2019;ve come to expect from Microsoft these days, all the .NET 5 source code will be open source.</p> <p>With the merger, many of the features exclusive to each individual framework will become available to all platforms. For example, csproj types for these platforms will be unified into the well-loved and simple .NET Core csproj file format. A .NET Framework project type, therefore, will be able to take advantage of the .NET Core csproj file format. While a conversion to .NET Core csproj file formats is necessary for Xamarin and .NET Framework (including WPF and Windows Forms) csproj files, the task is similar to the conversion from ASP.NET to ASP.NET Core. Fortunately, today it&#x2019;s even easier to do thanks to tools like ConvertProjectToNETCore3 (see <a href="http://bit.ly/2W5Lk3D">bit.ly/2W5Lk3D</a>).</p> <p>Another area of significant difference is in the runtime behavior of Xamarin and .NET Core/.NET Framework. The former uses a static compilation model, with ahead-of-time (AOT) compilation that compiles source code down to the native source code of the platform. By contrast, .NET Core and .NET Framework use just-in-time (JIT) compilation. Fortunately, with .NET 5, both models will be supported, depending on the project type target.</p> <p>For example, you can choose to compile your .NET 5 project into a single executable that will use the JIT compiler (jitter) at runtime, or a native compiler to work on iOS or Android platforms. Most projects will leverage the jitter, but for iOS all the code is AOT. For client-side Blazor, the runtime is Web Assembly (WASM), and Microsoft intends to AOT compile a small amount of managed code (around 100kb to 300kb), while the rest will be interpreted. (AOT code is large, so the wire cost is quite a burden to pay.)</p> <p>In .NET Core 3.0 you can compile to a single executable, but that executable is actually a compressed version of all the files needed to execute at runtime. When you execute the file, it first expands itself out into a temporary directory and then executes the entry point of the application from the directory that contains all the files. By contrast, .NET 5 will create a true, single-executable file that can execute directly in place.</p> <p>Another remarkable feature of .NET 5 is interoperability with source code from Java and Objective-C (including Swift). This has been a feature of Xamarin since the early releases, but will extend to all .NET 5 projects. You&#x2019;ll be able to include jar files in your csproj file, for example, and you&#x2019;ll be able to call directly from your .NET code into Java or Objective-C code. (Unfortunately, support for Objective-C will likely come later than Java.) It should be noted that interoperability between .NET 5 and Java/Objective-C is only targeted at in-process communication. Distributed communication to other processes on the same machine or even processes on a different machine will likely require serialization into a REST- or RPC-based distributed invocation.</p> <h2>What&#x2019;s Not in .NET 5</h2> <p>While there&#x2019;s a significant set of APIs available in the .NET 5 framework, it doesn&#x2019;t include everything that might have been developed over the last 20 or so years. It&#x2019;s reasonable to expect that all the APIs identified in .NET Standard 2.1 will be supported, but some of the more &#x201C;legacy&#x201D; APIs, including Web Forms, Windows Communication Foundation (WCF) server and Windows Workflow, will not. These are destined to remain in .NET Framework only. If you wish to achieve the same functionality within .NET 5, consider porting these APIs as follows:</p> <ul> <li>ASP.NET Web Forms =&gt; ASP.NET Blazor</li> <li>WCF server and remoting =&gt; gRPC</li> <li>Windows Workflow (WF) =&gt; Core WF (<a href="http://github.com/UiPath/corewf">github.com/UiPath/corewf</a>)</li> </ul> <p>The lack of WCF server support is no doubt disappointing to some. However, Microsoft recently decided to release the software under an MIT open source license, where its destiny is in control of the community (see <a href="http://github.com/CoreWCF/CoreWCF">github.com/CoreWCF/CoreWCF</a>). There&#x2019;s still a tremendous amount of work to be done to release independently of the .NET Framework, but in the meantime, the client-side WCF APIs are available (see <a href="http://github.com/dotnet/wcf">github.com/dotnet/wcf</a>).</p> <h2>A Declaration of Intent</h2> <p>Even as Microsoft makes plans to unify its developer frameworks under .NET 5, the company has announced that it&#x2019;s adopting a regular cadence for its unified .NET releases (see <strong>Figure 3</strong>). Going forward, you can expect general availability versions of .NET to be released in Q4 of each year. Of these releases, every second version will be a Long Term Support (LTS) release, which Microsoft will support for a minimum of three years or one year after a subsequent LTS release, whichever is longer. In other words, you&#x2019;ll always have at least three years to upgrade your application to the next LTS release. See <a href="http://bit.ly/2Kfkkw0">bit.ly/2Kfkkw0</a>for more information on the .NET Core support policy, and what can be reasonably expected to become the .NET 5 and beyond support policy.</p> <div> <p> <img alt=".NET Release Schedule" src="https://i-msdn.sec.s-msft.com/dynimg/IC880754.png"> <br> <strong>Figure 3 .NET Release Schedule</strong> </p> </div> <p>At this point, .NET 5 is still just an announcement&#x2014;a declaration of intent, if you like. There&#x2019;s lots of work to be done. Even so, the announcement is remarkable. When .NET Core was first released, the goal was to provide a cross-platform .NET version that could highlight Azure (perhaps especially the Platform-as-a-Service [PaaS] portions of Azure and support for .NET on Linux and within Linux containers).</p> <p>In the original concept, the idea that all of .NET Framework could be ported to .NET Core wasn&#x2019;t considered realistic. Around the time of the .NET Core 2.0 release, that began to change. Microsoft realized that it needed to define a framework standard for all .NET framework versions, to enable code running on one framework to be portable to another.</p> <p>This standard, of course, became known as the .NET Standard. Its purpose was to identify the API that a framework needed to support so that libraries targeting the standard could count on a specific set of APIs being available. As it turned out, defining the standard and then implementing it with Xamarin/Mono, .NET Core, and .NET Framework became a key component that made the .NET 5 unification strategy possible.</p> <p>For example, once each framework has implemented code that supports the .NET Standard set of APIs, it seems logical to work toward combining the separate code bases into one (a refactoring of sorts). And, where behavior isn&#x2019;t the same (JIT versus AOT compilation, for example), why not merge the code so that all platforms support both approaches and features? The effort isn&#x2019;t trivial, but the result is a huge step forward in reducing complexity and maintenance, while at the same time unifying the features to all platforms.</p> <p>Perhaps surprisingly, the very .NET Standard that made unification possible will likely make .NET Standard irrelevant. In fact, with the emergence of .NET 5, it&#x2019;s doubtful there will be another version of .NET Standard&#x2014;.NET 5 and each version after that will be the standard.</p> <h2>Wrapping Up</h2> <p>They say timing is everything, and that&#x2019;s true of .NET 5. A virtually comprehensive re-write of the .NET Framework wasn&#x2019;t even conceivable when .NET Core development started. At the time, Microsoft was responding to demand to significantly enhance the Azure hosting experience on Linux, in containers, and on PaaS. As such, the company was laser-focused on getting something out to meet the demands of customers and the Azure product team.</p> <p>With .NET Core 2.0 the mission expanded to matching the functionality found in the .NET Framework. Again, the team was laser-focused on releasing something viable, rather than taking on too much. But things began to change with .NET Core 3.0 and the implementation of .NET Standard 2.1. The idea of having to go in and make changes to three distinct frameworks when a new feature or bug came up was an irritation and an expense. And, like any good developer, the idea soon emerged to refactor the code as much as possible into a single code base.</p> <p>And so, .NET 5 was born. And along with it was born the idea of unifying all the features of each framework&#x2014;whether it was simple csproj formats, adopting open source development models, enabling interoperability with Java and Objective-C (including Swift), or supporting JIT and AOT compilation. Just like that, the idea of a single, unified framework became an obvious next step, and one I expect everyone both inside and outside of Microsoft will celebrate.</p> <div> <p> <strong>Mark Michaelis</strong>&#xA0;<em>is founder of IntelliTect, where he serves as its chief technical architect and trainer. For nearly two decades he has been a Microsoft MVP, and a Microsoft Regional Director since 2007. Michaelis serves on several Microsoft software design review teams, including C#, Microsoft Azure, SharePoint and Visual Studio ALM. He speaks at developer conferences and has written numerous books including his most recent, &#x201C;Essential C# 7.0 (6th Edition)&#x201D; (itl.tc/EssentialCSharp). Contact him on Facebook at <a href="http://facebook.com/Mark.Michaelis">facebook.com/Mark.Michaelis</a>, on his blog at <a href="http://intellitect.com/Mark">IntelliTect.com/Mark</a>, on Twitter: <a href="https://twitter.com/@markmichaelis">@markmichaelis</a> or via e-mail at <a href="mailto:mark@IntelliTect.com">mark@IntelliTect.com</a>.</em></p> </div> <div> <p>Thanks to the follow Microsoft technical expert for reviewing this article: Rich Lander</p> </div> </div></div><hr><h4>Page 2</h4><div><p id="jumpInfo">We&#x2019;re sorry. The content you requested has been removed. You&#x2019;ll be auto redirected in 1 second.</p><div id="content"> <div id="LeftContent"> <div class="navpage"> <div class="mag"> <div> <div class="row"> <div class="col-xs-24 col-md-12" id> <div class="articleBlock"> <div class="articleImg"> <a href="https://msdn.microsoft.com/en-us/magazine/mt833477"> <img alt=".NET Reunified: Microsoft&#x2019;s Plans for .NET 5" src="https://i-msdn.sec.s-msft.com/dynimg/IC786911.png"> </a> </div> <p>Mark Michaelis this month delves into .NET 5, the promised universal framework that unites the parallel threads of .NET Framework, Xamarin/Mono, and .NET Core into a single, universal target for desktop, Web, cloud, and device developers.</p> </div> </div> <div class="col-xs-24 col-md-12" id> <div class="articleBlock"> <p>Ted Neward closes out his series on the Naked Objects Framework with a look at NOF Restful API networking, and how the entire state of the network interaction is stored in a hypermedia document shared between the client and the server.</p> </div> </div> <div class="col-xs-24 col-md-12" id> <div class="articleBlock"> <div class="articleImg"> <a href="https://msdn.microsoft.com/en-us/magazine/mt833478"> <img alt="Understanding Azure AI Services" src="https://i-msdn.sec.s-msft.com/dynimg/IC880767.png" width="452"> </a> </div> <div class="articleAuthor"> <a href="https://msdn.microsoft.com/en-us/magazine/mt149362?author=ashish+sahu">Ashish Sahu</a>, <a href="https://msdn.microsoft.com/en-us/magazine/mt149362?author=sagar+bhanudas+joshi">Sagar Bhanudas Joshi</a></div> <p>Artificial intelligence and machine learning services are more accessible than ever, yet developers and data scientists face the growing challenge of choosing among them. In this hands-on exploration, Ashish Sahu walks through an end-to-end AI scenario and explores how the various Microsoft Azure AI services can be applied at each stage.</p> </div> </div> <div class="col-xs-24 col-md-12" id> <div class="articleBlock"> <p>gRPC is a remote procedure call framework that uses a binary protocol over HTTP/2 to connect clients and remote services. Dino Esposito shows how to use gRPC with ASP.NET Core and .NET Core 3.0.</p> </div> </div> <div class="col-xs-24 col-md-12" id> <div class="articleBlock"> <div class="articleImg"> <a href="https://msdn.microsoft.com/en-us/magazine/mt833479"> <img alt="Restrict Site Access with AI-Driven Authorization Policies in ASP.NET Core" src="https://i-msdn.sec.s-msft.com/dynimg/IC816519.png"> </a> </div> <p>Stefano Tempesta continues his exploration of a biometric security system, as he walks through collecting facial information from cameras registered as IoT devices and streaming data to an IoT Hub in Azure. The solution leverages a machine learning service that analyzes each access request against a historical dataset to thwart unauthorized intrusions.</p> </div> </div> <div class="col-xs-24 col-md-12" id> <div class="articleBlock"> <p>Nearly a decade into his run as back page columnist at MSDN Magazine, David Platt takes a moment to look back and catch up on some of the subjects of his past columns.</p> </div> </div> <div class="col-xs-24 col-md-12" id> <div class="articleBlock"> <div class="articleImg"> <a href="https://msdn.microsoft.com/en-us/magazine/mt833480"> <img alt="Create a Machine Learning Prediction System Using AutoML" src="https://i-msdn.sec.s-msft.com/dynimg/IC872851.png"> </a> </div> <p>Microsoft ML.NET is a large, open source library of machine learning functions that lets you create a prediction model using a C# language program. Writing such a program isn&#x2019;t simple, but as James McCaffrey explains, the AutoML system uses the ML.NET command-line interface (CLI) tool to create a prediction model for you. It also generates customizable sample code that uses the model.</p> </div> </div> <div class="col-xs-24 col-md-12" id> <div class="articleBlock"> <p>.NET 5 unifies .NET Framework, .NET Core, and Xamarin and Mono into a single framework. What does .NET 5 mean for your development efforts going forward?</p> </div> </div> </div> </div> </div>
</div>
</div>
<div id="RightContent"> <div class="navpage"> </div>
</div> </div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>