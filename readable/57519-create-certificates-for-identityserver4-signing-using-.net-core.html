<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Create Certificates for IdentityServer4 signing using .NET&#xA0;Core -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Create Certificates for IdentityServer4 signing using .NET&#xA0;Core</h1>
    <div id="post-13268" class="post-13268 post type-post status-publish format-standard hentry category-net-core category-asp-net-core category-dotnet category-security tag-aspnetcore tag-certificate tag-dotnetcore tag-ecdsa tag-identityserver4 tag-rsa tag-x509"> <div class="entry-content"> <p>This article shows how to create certificates for an IdentityServer4 application to use for signing and token validation. The certificates are created using the <a href="https://www.nuget.org/packages/CertificateManager/">CertificateManager </a>nuget package. Both RSA and ECDsa certificates can be used for signing in IdentityServer4.</p>
<p><strong>Code:</strong> <a href="https://github.com/damienbod/AspNetCoreCertificates/tree/master/src/CreateIdentityServer4Certificates">Certificates for IdentityServer4 signing using .NET Core</a></p>
<p><strong>Creating the Certificates in .NET Core</strong></p>
<p>A simple <a href="https://docs.microsoft.com/en-us/dotnet/core/get-started">.NET Core console</a> application is used to create the certificates. This type of application can run on most of the standard operating systems. Create a new console application and add the package <a href="https://www.nuget.org/packages/CertificateManager/">CertificateManager</a>. The package <em>Microsoft.Extensions.DependencyInjection</em> is also required to initialize the package.</p>
<pre class="brush: xml; title: ; notranslate">
&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

 &lt;PropertyGroup&gt;
  &lt;OutputType&gt;Exe&lt;/OutputType&gt;
  &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;
 &lt;/PropertyGroup&gt;

 &lt;ItemGroup&gt;
  &lt;PackageReference Include=&quot;CertificateManager&quot; Version=&quot;1.0.3&quot; /&gt;
  &lt;PackageReference Include=&quot;Microsoft.Extensions.DependencyInjection&quot; Version=&quot;3.1.1&quot; /&gt;
 &lt;/ItemGroup&gt;

&lt;/Project&gt;

</pre>
<p><strong>Creating a RSA certificate</strong></p>
<p>A self signed RSA certificate can be created using the CertificateManager <strong>NewRsaSelfSignedCertificate</strong> method. The <strong>key size</strong> must be at least <strong>2048</strong>. The following example also adds TLS server and client authentication OID extensions, so that the certificate could also be used for client authentication.</p>
<pre class="brush: csharp; title: ; notranslate">
public static X509Certificate2 CreateRsaCertificate(
	string dnsName, int validityPeriodInYears)
{
	var basicConstraints = new BasicConstraints
	{
		CertificateAuthority = false,
		HasPathLengthConstraint = false,
		PathLengthConstraint = 0,
		Critical = false
	};

	var subjectAlternativeName = new SubjectAlternativeName
	{
		DnsName = new List&lt;string&gt;{ dnsName }
	};

	var x509KeyUsageFlags = X509KeyUsageFlags.DigitalSignature;

	// only if certification authentication is used
	var enhancedKeyUsages = new OidCollection
	{
		new Oid(&quot;1.3.6.1.5.5.7.3.1&quot;),  // TLS Server auth
		new Oid(&quot;1.3.6.1.5.5.7.3.2&quot;),  // TLS Client auth
	};

	var certificate = _cc.NewRsaSelfSignedCertificate(
		new DistinguishedName { CommonName = dnsName },
		basicConstraints,
		new ValidityPeriod
		{
			ValidFrom = DateTimeOffset.UtcNow,
			ValidTo = DateTimeOffset.UtcNow.AddYears(validityPeriodInYears)
		},
		subjectAlternativeName,
		enhancedKeyUsages,
		x509KeyUsageFlags,
		new RsaConfiguration { KeySize = 2048 }
	);

	return certificate;
}
</pre>
<p><strong>Creating a ECDsa certificate</strong></p>
<p>A self signed ECDsa certificate can be created using the CertificateManager <strong>NewECDsaSelfSignedCertificate</strong> method. </p>
<pre class="brush: csharp; title: ; notranslate">
public static X509Certificate2 CreateECDsaCertificate(
	string dnsName, int validityPeriodInYears)
{
	var basicConstraints = new BasicConstraints
	{
		CertificateAuthority = false,
		HasPathLengthConstraint = false,
		PathLengthConstraint = 0,
		Critical = false
	};

	var san = new SubjectAlternativeName
	{
		DnsName = new List&lt;string&gt;{ dnsName }
	};

	var x509KeyUsageFlags = X509KeyUsageFlags.DigitalSignature;

	// only if certification authentication is used
	var enhancedKeyUsages = new OidCollection {
		new Oid(&quot;1.3.6.1.5.5.7.3.1&quot;),  // TLS Server auth
		new Oid(&quot;1.3.6.1.5.5.7.3.2&quot;),  // TLS Client auth
	};

	var certificate = _cc.NewECDsaSelfSignedCertificate(
		new DistinguishedName { CommonName = dnsName },
		basicConstraints,
		new ValidityPeriod
		{
			ValidFrom = DateTimeOffset.UtcNow,
			ValidTo = DateTimeOffset.UtcNow.AddYears(validityPeriodInYears)
		},
		san,
		enhancedKeyUsages,
		x509KeyUsageFlags,
		new ECDsaConfiguration());

	return certificate;
}
</pre>
<p><strong>Creating and exporting the pfx files</strong></p>
<p>The RSA and the ECDsa certificate can then be created and exported as a pfx file. </p>
<pre class="brush: csharp; title: ; notranslate">
static CreateCertificates _cc;

static void Main(string[] args)
{
	var sp = new ServiceCollection()
	   .AddCertificateManager()
	   .BuildServiceProvider();

	_cc = sp.GetService&lt;CreateCertificates&gt;();

	var rsaCert = CreateRsaCertificate(&quot;localhost&quot;, 10);
	var ecdsaCert = CreateECDsaCertificate(&quot;localhost&quot;, 10);

	string password = &quot;1234&quot;;
	var iec = sp.GetService&lt;ImportExportCertificate&gt;();

	var rsaCertPfxBytes = 
		iec.ExportSelfSignedCertificatePfx(password, rsaCert);
	File.WriteAllBytes(&quot;rsaCert.pfx&quot;, rsaCertPfxBytes);

	var ecdsaCertPfxBytes = 
		iec.ExportSelfSignedCertificatePfx(password, ecdsaCert);
	File.WriteAllBytes(&quot;ecdsaCert.pfx&quot;, ecdsaCertPfxBytes);
}
</pre>
<p><strong>Using the Certificates in IdentityServer4</strong></p>
<p>The certificate pfx exports can then be used in IdentityServer4. Depending on how you deploy the web application which contains the IdentityServer4 library, you would choose the best way to load the certificates into the application, for example a thumbprint which loads from the host operating system, or a certificate loaded from Key Vault in Azure.</p>
<p>If using a RSA certificate, you can load this directly using the <strong>AddSigningCredential</strong> IdentityServer4 extension method.</p>
<pre class="brush: csharp; title: ; notranslate">
var rsaCertificate = new X509Certificate2(
	Path.Combine(_environment.ContentRootPath, &quot;rsaCert.pfx&quot;), &quot;1234&quot;);
				
services.AddIdentityServer()
	.AddSigningCredential(rsaCertificate) // rsaCertificate
	.AddInMemoryIdentityResources(Config.GetIdentityResources())
	.AddInMemoryApiResources(Config.GetApiResources())
	.AddInMemoryClients(Config.GetClients())
	.AddAspNetIdentity&lt;ApplicationUser&gt;()
	.AddProfileService&lt;IdentityWithAdditionalClaimsProfileService&gt;();
</pre>
<p>using the jwks endpoint, you can view the certificate public details used for validation:</p>
<p> /.well-known/openid-configuration/jwks</p>
<p><img src="https://damienbod.files.wordpress.com/2020/01/id4_signingcert_01.png?w=640" alt width="640" class="alignnone size-full wp-image-13283" srcset="https://damienbod.files.wordpress.com/2020/01/id4_signingcert_01.png?w=640&amp;h=591 640w, https://damienbod.files.wordpress.com/2020/01/id4_signingcert_01.png?w=150&amp;h=139 150w, https://damienbod.files.wordpress.com/2020/01/id4_signingcert_01.png?w=600&amp;h=554 600w, https://damienbod.files.wordpress.com/2020/01/id4_signingcert_01.png?w=768&amp;h=710 768w, https://damienbod.files.wordpress.com/2020/01/id4_signingcert_01.png 802w" sizes="(max-width: 640px) 100vw, 640px"></p>
<p>When using an ECDsa certificate, you need to create a <strong>ECDsaSecurityKey</strong> instance from the ECDsa certificate private key. This can then be used as a parameter in the AddSigningCredential method.</p>
<pre class="brush: csharp; title: ; notranslate">
var ecdsaCertificate = new X509Certificate2(
	Path.Combine(_environment.ContentRootPath, &quot;ecdsaCert.pfx&quot;), &quot;1234&quot;);
	
ECDsaSecurityKey ecdsaCertificatePublicKey
	= new ECDsaSecurityKey(ecdsaCertificate.GetECDsaPrivateKey());

services.AddIdentityServer()
	.AddSigningCredential(ecdsaCertificatePublicKey, &quot;ES256&quot;) 
	.AddInMemoryIdentityResources(Config.GetIdentityResources())
	.AddInMemoryApiResources(Config.GetApiResources())
	.AddInMemoryClients(Config.GetClients())
	.AddAspNetIdentity&lt;ApplicationUser&gt;()
	.AddProfileService&lt;IdentityWithAdditionalClaimsProfileService&gt;();
</pre>
<p>The jwks endpoint uses an EC certificate.</p>
<p><img src="https://damienbod.files.wordpress.com/2020/01/id4_signingcert_02.png?w=640" alt width="640" class="alignnone size-full wp-image-13284" srcset="https://damienbod.files.wordpress.com/2020/01/id4_signingcert_02.png?w=640&amp;h=346 640w, https://damienbod.files.wordpress.com/2020/01/id4_signingcert_02.png?w=150&amp;h=81 150w, https://damienbod.files.wordpress.com/2020/01/id4_signingcert_02.png?w=600&amp;h=324 600w, https://damienbod.files.wordpress.com/2020/01/id4_signingcert_02.png?w=768&amp;h=415 768w, https://damienbod.files.wordpress.com/2020/01/id4_signingcert_02.png 775w" sizes="(max-width: 640px) 100vw, 640px"></p>
<p><strong>Links:</strong></p>
<p><a href="https://github.com/damienbod/AspNetCoreCertificates">https://github.com/damienbod/AspNetCoreCertificates</a></p>
<p><a href="https://www.nuget.org/packages/CertificateManager/">https://www.nuget.org/packages/CertificateManager/</a></p>
<p><a href="http://docs.identityserver.io/en/latest/topics/crypto.html">http://docs.identityserver.io/en/latest/topics/crypto.html</a></p>
<p><a href="http://docs.identityserver.io/en/latest/topics/mtls.html">http://docs.identityserver.io/en/latest/topics/mtls.html</a></p>
<p><a href="https://docs.microsoft.com/en-us/dotnet/core/get-started">https://docs.microsoft.com/en-us/dotnet/core/get-started</a></p> </div> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>