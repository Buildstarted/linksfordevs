<!DOCTYPE html>
<html lang="en">
<head>
    <title>
VPS&#x27; IP Address will be blocked in Iran and China after using Outline VPN &#xB7; Issue #193 &#xB7; Jigsaw-Code/outline-server &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>VPS' IP Address will be blocked in Iran and China after using Outline VPN · Issue #193 · Jigsaw-Code/outline-server · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><blockquote><p>Maybe VMess is not blocked now, but a handshake fingerprint could make it very easy to block if it gets widely adopted.</p></blockquote><p>TLS is an optional feature for those who require forward secrecy. The bare VMess protocol works with PSK and doesn't have handshake fingerprint.</p><blockquote><p>What attacks do you have in mind? Padding can have significant impact on performance, but it may be an effective measure against fingerprinting the handshake.</p></blockquote><p>As TLS (or HTTP2) gets more and more popular, we assume it will be more often Shadowsocks (or VMess) carries TLS traffic. Shadowsocks itself doesn't have fingerprint, but TLS does. For example, the ClientHello message is around 160 to 170 bytes long, and ServerHello message is 70 to 75 bytes (<a href="http://netsekure.org/2010/03/tls-overhead/" rel="nofollow">reference</a>). Shadowsocks's header is somewhat 30 bytes long. Combining these factors, one may tell that this TCP connection uses an unknown protocol to carry TLS traffic. In such case, the connection (or IP) may be blocked by the firewall without knowing whether it is truly Shadowsocks or not.</p><p>To mitigate such issue, V2Ray introduces an multiplexing feature, named <a href="https://www.v2ray.com/developer/protocols/muxcool.html" rel="nofollow">Mux.Cool</a> (Chinese only, sorry), which combines multiple TCP connections into one. The fingerprint of TLS gets hidden in the master connection.</p><p>We also realize that the fingerprint may get exposed when there is only one TLS connection at a time. That's why we are experimenting the random padding feature.</p><blockquote><p>Does V2Ray support intercepting all the traffic or does it work as a system proxy?</p></blockquote><p>It works as a system proxy, similar to Shadowsocks. Some other developers uses <a href="https://github.com/eycorsican/go-tun2socks">tun2socks</a> to intercept all traffic and then proxy them through V2Ray. I guess you already familiar with that part.</p><blockquote><p>If you operate at the IP layer, how do you route based on domains?</p></blockquote><p>There is one difficulty with IP tunnel. When a domain gets DNS poisoned, IP based proxy will fail. V2Ray (if configured) intercepts HTTP and TLS connection, and then tries to correct the destination address based its handshake info.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>