<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Introducing MVVM architecture. Vanilla javascript implementation. - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Introducing MVVM architecture. Vanilla javascript implementation. - linksfor.dev(s)"/>
    <meta property="article:author" content="Volodymyr Kopytin"/>
    <meta property="og:description" content="The project explains MVVM design pattern implementation in javascript front-end application."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.codeproject.com/Articles/5265632/Introducing-MVVM-architecture-Vanilla-javascript"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Introducing MVVM architecture. Vanilla javascript implementation.</title>
<div class="readable">
        <h1>Introducing MVVM architecture. Vanilla javascript implementation.</h1>
            <div>by Volodymyr Kopytin</div>
            <div>Reading time: 44-56 minutes</div>
        <div>Posted here: 24 Apr 2020</div>
        <p><a href="https://www.codeproject.com/Articles/5265632/Introducing-MVVM-architecture-Vanilla-javascript">https://www.codeproject.com/Articles/5265632/Introducing-MVVM-architecture-Vanilla-javascript</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>The small popularity of MVP and MVVM in favor of MVC architecture is caused by many factors. It is easy to start from any javascript and then evolve to MVC. More efforts would require to build better MVP architecture. And much more practice and efforts would require to build MVVM. Despite that fact, the MVVM architecture is gaining its popularity on mobile platforms as native applications. It is a rare subject for WEB applications.</p><div id="contentdiv">
						



<h2>Introducing MVVM architecture. Vanilla javascript implementation.</h2>

<p>The detailed discussion about data binding is in my previous&nbsp;article&nbsp;<a href="https://www.codeproject.com/Articles/5264704/Two-Way-Data-Binding-in-Pure-JavaScript">Two-Way Data Binding in Pure JavaScript</a></p>

<ul>
	<li>Working example on <a href="https://jsfiddle.net/vkopytin/6rsvcat1/55/" target="_blank">jsfiddle</a></li>	<li>Full example on <a href="https://github.com/vkopytin/databinding/tree/master/src/examples/mvvm-ts" target="_blank">github</a></li></ul>

<p>When it comes to creating an application, the most important part comes with making a decision about developing language, tech stack, architecture patterns. When it comes to making a WEB application - the language choice is javascript or typescript. Back in time, javascript was treated as a weak programming language. That puts a mark on tech stack libraries. Mostly all good libraries and utilities are around MVC architecture. Less for MVP and much more less for MVVM. In practice, while actively gaining popularity on mobile platforms, MVVM for a WEB platform is completely ignored.</p>

<p><em>Data like particles and functions like waves, it is easy to extract data from waves and much harder to gather all particles into a function.</em></p>

<p>The small popularity of MVP and MVVM in favor of MVC architecture is caused by many factors. It is easy to start from any javascript and then evolve to MVC. More efforts would require to build better MVP architecture. And much more practice and efforts would require to build MVVM. Despite that fact, the MVVM architecture is gaining its popularity on mobile platforms as native applications. It is a rare subject for WEB applications.</p>

<h2>MVVM is a game-changer.</h2>

<p>I believe MVVM architecture (it is just a design pattern) is capable to construct middle and big applications. Especially when it comes to modern WEB technologies. Soon or later MVVM design will emerge on the WEB. With this article, I would like to start the fashion.</p>

<p>Let's tear MVVM design pattern on parts. Discuss every layer, its participants, and try to build a full working MVVM draft. Starting with the requirements, usually, it is about making ToDo application. Tech stack - vanilla javascript and WEB API. No more libraries. To accomplish many repeating tasks the utility library will be created for this draft as well. In MVVM a communication between Views and ViewModels goes over data binding technique. That will be covered as well. Communication with the backend will be simulated over an Adapter design pattern. Inversion of control (IoC) will be minimally mentioned.</p>

<h2>Ultimate layers in the draft MVVM.</h2>

<p>The data transfer layer would keep everything that is related to a communication between a WEB application and a backend. Any <code>ajax</code>, <code>fetch</code>, <code>XMLHttpRequest</code> and anything other that is related to requesting and transfer data from/to the backend will be stored in this layer. Rules - Adapter design pattern. Data types, simple types that will work with <code>JSON.stringify</code>. In the draft, the communication with the backend will be simulated.</p>

<p>The Model layer would keep fetched data, will provide data to be pushed to a backend. In this layer, all that application can read or write to the backend will be stored in the form that is easy to use within the solution. All data that should be modified for backend communication interfaces will be adjusted in this layer as well. Rules - Model, the first letter of the MVVM design pattern. A very small part of the business requirements could be there. Just as draft version, with the excuse that it will be moved to a third layer latter.</p>

<p>The ViewModel layer would play an important role in the business logic of the application. Everything that would be related to implementing the requirements will be there. In this layer communication between Model and View will be more intensive. Rules - ViewModel, the last two letters in MVVM design pattern. The layer would build an important set of core commands that would implement the logic of the application. For the small and middle applications, the separation between Models and ViewModels could be minimal, organized as it comes during development. For the big application, that could not be enough. It would be good to plan better separation between ViewModel and Model. Unit Of Work could help to build an extra layer that would allow to group core commands and provide more space to implement more requirements.</p>

<p>The View layer is the visible shape of the application. It is a precious UI that would allow clients to effectively use the application. That part is the ultimate target for many unexpected changes. Clients often would like to discuss the UI. Especially if clients will like the application, better UI they will require. It would be an entry point to all business workflows that are required and requested to implement. In this layer, all communication between ViewModel will be over data binding rules. That would allow us to produce a good separation from the ViewModel. Rules - View, the second letter in the MVVM design pattern, command - the command in MVVM design pattern. Partial requirement implementation that is related to the UI will be there.</p>

<p>There are two kinds of Views, passive and active views. Passive views are views that don't play an active role in picking up the right view model, just read state and update UI accordingly. Active views could pick up the right view models and read state. With the small and middle applications, it would be a great idea to keep passive views. That means View would never know anything about ViewModel. It would just bind and unbind to/from the provided ViewModel. The association of the View and ViewModel is configured over IoC setup. When clients will like the solution it will come a day when a requirement could appear to build "impossible" UI/views. The requirement could be something like that: <em>with the given core solution I (as the client) would like to build my own UI</em>. The simple solution could be to replace all views with commands API, according to the Facade design pattern. That could be a tough period for the application with active Views. Every logic that is responsible to make a decision about the right view logically should be extracted and moved out of the Facade. If left that could make a pain to maintain such a solution. In the case of passive Views, the commands API can be introduced as another View Layer with adjusting to the right ViewModels over IoC setup. Ideally... I think so... maybe... IMHO...</p>

<h3>Utilities, versatile tools</h3>

<p>Invisible to clients but very important to developers. The perfect tech stack, utilities that do all magic to exclude code repeating, long methods names, probably introducing new ways of development, that keep imaginative app developing person to never stop and look up for better libraries for work on the next "impossible" mission. The set that as minimal and effective, would help to resolve important tasks with less pain, sweat, and tears.</p>

<h3>Commands in MVVM</h3>

<p>Commands are defined in ViewModel. Commands are for anything that is out of fetch and display data. It is another small sub-layer in separation between Views and ViewModels. If the task is about to update state on the ViewModel, transfer value from input in UI to the backend, update or refresh UI with new data, a command is a good entry point to run such task. Besides of <code>exec</code> method, the command can have more methods such as <code>canExecute</code> or <code>inProgress</code>. The first is to enable/disable buttons on UI. The second one is to implement an async loading progress overlay on UI.</p>

<h3>Communication with Backend</h3>

<p>It will be organized in a way to keep data transfer types as they come from remote service endpoints. With no conversion to types that will be transferred. Just one rule - convenience to receive and transfer data. Methods that just repeat backend service endpoints. With this approach, it would be easy to investigate issues that are backend related, locate all used endpoint path names, technologies that are used to transfer/receive data. Backend data contact can change with time. In this case, all data will be kept as it is, though, if something will be changed, it would be easy to determine the difference and adjust application.</p>

<p>In the draft version, the backend communication will be simulated by the following "Adapter":</p>

<p><span id="prehide288323" onclick="processCodeBlocks.togglePre(288323);">Hide</span>  &nbsp; <span id="preShrink288323" onclick="processCodeBlocks.shrinkExpand(288323);">Shrink</span> <img id="preimg288323" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(288323);">  &nbsp; <span id="copycode288323" onclick="return processCodeBlocks.copyCode(288323);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre288323" processed="true"><span>export</span> <span>interface</span> ITodoItem {
    id: number;
    title: string;
    complete: <span>boolean</span>;
}
<span>const</span> data = [{
}];
<span>let</span> index = data.length + <span>2</span>;

<span>class</span> TodosAdapter {

    fetchTodos() {
        <span>return</span> <span>new</span> Promise&lt;ITodoItem[]&gt;((resolve) =&gt; {
            setTimeout(() =&gt; {
                <span>const</span> result = [...data.sort((l, r) =&gt; l.id &gt; r.id ? -1 : l.id &lt; r.id ? <span>1</span> : <span>0</span>)];
                utils.text(utils.el(<span>'</span><span>.console'</span>), <span>JSON</span>.stringify(result, <span>null</span>, <span>2</span>));
                resolve(result);
            }, <span>200</span>);
        });
    }

    createTodo(title) {
        <span>return</span> <span>new</span> Promise&lt;boolean&gt;((resolve) =&gt; {
            setTimeout(() =&gt; {
                data.push({
                    id: index++,
                    title: title,
                    complete: <span>false</span>
                });
                resolve(<span>true</span>);
            }, <span>200</span>);
        });
    }

    updateTodo(id, attrs) {
        <span>return</span> <span>new</span> Promise&lt;boolean&gt;((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                <span>const</span> item = utils.find(data, i =&gt; i.id === id);
                <span>if</span> (item) {
                    Object.assign(item, attrs);
                    resolve(<span>true</span>);
                } <span>else</span> {
                    reject(<span>new</span> Error(<span>`</span>Can't update. Todo item with id: ${id} was not found`));
                }
            });
        });
    }

    deleteTodo(id) {
        return new Promise<span>&lt;</span><span>boolean</span><span>&gt;</span>((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                const item = utils.find(data, i =&gt; i.id === id);
                const index = data.indexOf(item);
                if (item) {
                    data.splice(index, 1);
                    resolve(true);
                } else {
                    reject(new Error(`Can't delete. Todo item with id: ${id} was not found`))
                }
            });
        });
    }
}</pre>

<p>It doesn't matter how well the Adapter will be programmed. It could be a well-defined solution with generalized fetch and convert methods or it could be just copy-pasted junks of code that just do data transfer. Matters just public methods, their signatures, and the results they provide.</p>

<h3>IoC - Inversion of Control</h3>

<p>In MVVM many Views can be bound to a one ViewModel. That smells like the singleton design pattern -&nbsp;<code>current(inst)</code>. One useful approach is to separate Views from ViewModels. There IoC setup could be a good solution. It would allow us to keep all composition between Views and ViewModels in a single place. The IoC setup could grow with the future. Though, it would be scary to watch inside of it. However, it would be just one place, instead of spreading between many smart views.</p>

<p>The small IoC:</p>

<p><span id="prehide296295" onclick="processCodeBlocks.togglePre(296295);">Hide</span>  &nbsp; <span id="copycode296295" onclick="return processCodeBlocks.copyCode(296295);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre296295">MainView.prototype.getViewModel = <span>function</span> () {
    <span>return</span> current(MainViewModel);
}&nbsp;</pre>

<p>There are more candidates for IoC setup. It is a relation between a TodosModel and Adapter. Relation between TodosModel and TodoViewModelItem.&nbsp;TodosModel and TodoMainViewModel.</p>

<h3>Base class for ViewModels and maybe Views</h3>

<p>It is expected to actively communicate between Views, Models, and ViewModels, let's think about a central point. It would be convenient to have one Base class that all those guys will inherit. From there it would be possible to provide more functionalities to all participants without updating every class. With that approach, there will be a default public accessor for the internal state of the object. Although event delivering entry point - <code>on</code> and <code>trigger</code> methods. In the real world, there could be a Base class already defined. That's why I keep&nbsp;&nbsp;<code>on</code>&nbsp;and&nbsp;<code>trigger</code>&nbsp;methods separated from the base implementation. In regards to the base class, it is an adjustable solution. And since it is base class would be great to keep the events listed in a clear way and easily located. An object constructor can serve that purpose. I'm going to initialize all events from the parent class constructor. There is a&nbsp;<code>prop('&lt;propName&gt;', &lt;value&gt;)</code>&nbsp;method. In order to don't produce many getter/setter methods, that may be not needed, it would be great to have the default public accessor for the internal objects state.</p>

<p>Something like that - declare events within child object constructor:</p>

<p><span id="prehide885023" onclick="processCodeBlocks.togglePre(885023);">Hide</span>  &nbsp; <span id="copycode885023" onclick="return processCodeBlocks.copyCode(885023);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre885023"><span>constructor</span>() {
    <span>super</span>(
        <span>'</span><span>change:title'</span>,
        <span>'</span><span>change:items'</span>
    );
    ...
}</pre>

<p>Bellow is the final implementation of the Base class:</p>

<p><span id="prehide480827" onclick="processCodeBlocks.togglePre(480827);">Hide</span>  &nbsp; <span id="preShrink480827" onclick="processCodeBlocks.shrinkExpand(480827);">Shrink</span> <img id="preimg480827" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(480827);">  &nbsp; <span id="copycode480827" onclick="return processCodeBlocks.copyCode(480827);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre480827" processed="true"><span>function</span> dispatcher() {

    <span>const</span> handlers = [];

    <span>return</span> {
        add(handler) {
            <span>if</span> (!handler) {
                <span>throw</span> <span>new</span> Error(<span>'</span><span>Can't attach to empty handler'</span>);
            }
            handlers.push(handler);

            <span>return</span> <span>function</span> () {
                <span>const</span> index = handlers.indexOf(handler);
                <span>if</span> (~index) {
                    <span>return</span> handlers.splice(index, <span>1</span>);
                }
                <span>throw</span> <span>new</span> Error(<span>'</span><span>Ohm! Something went wrong with detaching unexisting event handler'</span>);
            };
        },

        notify() {
            <span>const</span> args = [].slice.call(arguments, <span>0</span>);
            <span>for</span> (<span>const</span> handler of handlers) {
                handler.apply(<span>null</span>, args);
            }
        }
    }
}

<span>function</span> initEvents(...args) {
    <span>const</span> events = {};
    <span>for</span> (<span>const</span> key of args) {
        events[key] = dispatcher();
    }
    <span>return</span> {
        on(eventName, handler) {
            <span>return</span> events[eventName].add(handler);
        },
        trigger(eventName) {
            events[eventName].notify();
        }
    };
}

<span>class</span> Base&lt;S = {}&gt; {
    state: S;

    <span>constructor</span>(...args: string[]) {
        <span>const</span> events = initEvents(...args);

        <span>this</span>.on = events.on;
        <span>this</span>.trigger = events.trigger;
    }

    on(eventName, handler) {
        <span>throw</span> <span>new</span> Error(<span>'</span><span>Not implemented'</span>);
    }

    trigger(eventName) {
        <span>throw</span> <span>new</span> Error(<span>'</span><span>Not implemented'</span>);
    }

    prop&lt;K <span>extends</span> keyof S&gt;(propName: K, val?: S[K]): S[K] {
        <span>if</span> (arguments.length &gt; <span>1</span> &amp;&amp; val !== (<span>this</span>.state as any)[propName]) {
            (<span>this</span>.state as any)[propName] = val;
            <span>this</span>.trigger(<span>'</span><span>change:'</span> + propName);
        }

        <span>return</span> <span>this</span>.state[propName];
    }

}</pre>

<h3>Code that shines (utils)</h3>

<p>Let's don't code but just give a thought about the shape of the library. Methods and their signatures. To make life easier, the solution will be based on HTML templates with no transformations. <code>html(html?)</code> - A tool that would help to apply HTML from a template to DOM elements. After HTML is rendered, there should be a tool to pick up elements from the DOM - something like that:&nbsp;<code>el('.selector', &lt;document/element&gt;)</code>. Since it is a todo list, the list would have items. There will be a task to change attributes and text of list item elements: <code>attr('&lt;name&gt;', &lt;value&gt;)</code> and <code>text(&lt;el&gt;, '&lt;text&gt;')</code>. Totally it would require removing, appending items from the todo list. Good chance to have <code>remove(&lt;element&gt;)</code>. The solution will contain data bindings, which means, HTML wouldn't be redrawn, the list items will be <b>refreshed</b>. All items in the list will just update it's data when the list item will change. Each todo task would have states: <i>active</i> and <i>complete</i>. That will be a nice addition to see how MVVM will cope with filtering by active/completed tasks. To make such smart manipulations there should be more tools: <code>find(&lt;items&gt;, &lt;fn&gt;)</code>, <code>filer(&lt;items&gt;, &lt;fn&gt;)</code>, <code>map(&lt;items&gt;, &lt;fn&gt;)</code>, <code>last(&lt;items&gt;, &lt;from&gt;)</code>, <code>first(&lt;items&gt;, &lt;n&gt;)</code>. The last but not least, listen to DOM events: <code>on</code>, <code>trigger</code>.</p>

<p>Here is the example of "utils" library:</p>

<p><span id="prehide243275" onclick="processCodeBlocks.togglePre(243275);">Hide</span>  &nbsp; <span id="preShrink243275" onclick="processCodeBlocks.shrinkExpand(243275);">Shrink</span> <img id="preimg243275" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(243275);">  &nbsp; <span id="copycode243275" onclick="return processCodeBlocks.copyCode(243275);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre243275" processed="true"><span>const</span> instances = <span>new</span> <span>WeakMap</span>();

<span>export</span> <span>function</span> current&lt;T <span>extends</span> {}, O <span>extends</span> {}&gt;(
    ctor: { <span>new</span> (...args): T },
    options?: O
): T {
    <span>if</span> (instances.has(ctor)) {
        <span>return</span> instances.get(ctor);
    }
    <span>const</span> inst = <span>new</span> ctor(options);
    instances.set(ctor, inst);

    <span>return</span> inst;
}

<span>export</span> <span>function</span> html(el, html?: string) {
    <span>if</span> (arguments.length &gt; <span>1</span>) {
        el.innerHTML = html;
    }
    <span>return</span> el.innerHTML;
}

<span>export</span> <span>function</span> el(selector, inst?) {
    inst = inst || <span>document</span>;
    <span>if</span> (!selector) {
        <span>return</span> <span>null</span>;
    }
    <span>if</span> (<span>'</span><span>string'</span> === <span>typeof</span> selector) {
        <span>return</span> inst.querySelector(selector);
    }
    <span>return</span> selector;
}

<span>export</span> <span>function</span> attr(el, name, val?) {
    <span>if</span> (arguments.length &gt; <span>2</span>) {
        el.setAttribute(name, val);
    }
    <span>return</span> el.getAttribute(name);
}

<span>export</span> <span>function</span> text(el, text?) {
    <span>if</span> (arguments.length &gt; <span>1</span>) {
        el.innerText = text;
    }
    <span>return</span> el.innerText;
}

<span>export</span> <span>function</span> remove(el) {
    el.parentNode.removeChild(el);
}

<span>export</span> <span>function</span> on(inst, selector, eventName, fn) {
    <span>const</span> handler = <span>function</span> (evnt) {
        <span>if</span> (evnt.target.matches(selector)) {
            fn(evnt);
        }
    }
    inst.addEventListener(eventName, handler);
    <span>return</span> <span>function</span> () {
        inst.removeEventListener(eventName, handler);
    }
}

<span>export</span> <span>function</span> trigger(el, eventName) {
    el.dispatchEvent(<span>new</span> Event(eventName, { bubbles: <span>true</span> }));
}

<span>export</span> <span>function</span> getResult(inst, getFn) {
    <span>const</span> fnOrAny = getFn &amp;&amp; getFn();
    <span>if</span> (<span>typeof</span> fnOrAny === <span>'</span><span>function'</span>) {
        <span>return</span> fnOrAny.call(inst);
    }
    <span>return</span> fnOrAny;
}

<span>export</span> <span>function</span> find&lt;T&gt;(items: T[], fn: (item: T) =&gt; <span>boolean</span>) {
    <span>for</span> (<span>const</span> item of items) {
        <span>if</span> (fn(item)) {
            <span>return</span> item;
        }
    }
    <span>return</span> <span>null</span>;
}

<span>export</span> <span>function</span> filter&lt;T&gt;(items: T[], fn: (item: T) =&gt; <span>boolean</span>): T[] {
    <span>const</span> res = [] as T[]
    <span>for</span> (<span>const</span> item of items) {
        <span>if</span> (fn(item)) {
            res.push(item);
        }
    }
    <span>return</span> res;
}

<span>export</span> <span>function</span> map&lt;T, Y&gt;(items: T[], fn: (item: T) =&gt; Y): Y[] {
    <span>const</span> res = [] as Y[];
    <span>for</span> (<span>const</span> item of items) {
        res.push(fn(item));
    }
    <span>return</span> res;
}

<span>export</span> <span>function</span> last&lt;T&gt;(items: T[], from = <span>1</span>): T[] {
    <span>const</span> length = items.length;
    <span>return</span> [].slice.call(items, from, length);
}

<span>export</span> <span>function</span> first&lt;t&gt;(items: T[], n = <span>1</span>) {
    <span>return</span> [].slice.call(items, <span>0</span>, n);
}</pre>

<p>The shape of the library is adjusted.</p>

<h2>Three pillows of MVVM</h2>

<p><i>Now we are opening Pandora's box...</i></p>

<p>The TodoModel (model) will reflect the behavior of the todo list. For that case, there should be a way to keep todo tasks, create new todo from a title, update todo and delete todo. The model will request and provide POKO objects to/from backend over the Adapter layer. It will inform participants about the changed state. Keep all fetched data from the backend in the internal state. It will just hold received data. Then data will be passed to ViewModel over events. It should be simple enough to don't mess with every item. For the production version, it should deal with paged data, oauth access token, probably partially update state and inform about particular item change.</p>

<p>The tough question is <i>should a model decide about updating its state (fetch data) when required or allow ViewModel to decide when needs?</i> Let's assume that <code>this.fetch()</code> will be called from within the model when it needs. e.g. when it was called <code>createTodo</code> method. The state of the backend is altered. One item added. And it would be logical to call <code>this.fetch()</code>. It would assure that data will be fresh and the model will inform about the state change. It is convenient and it is a restriction. It would be wise to give a second thought. It could lead to unexpected multiple requests to the backend. For instance, in this solution the <code>updateTodo</code> will be called from two places. First place - it is when changing the title of the todo task item. The <code>updateTodo</code> will be called just once. It is safe to call <code>this.fetch()</code> from the model. And the second place, it is when to mark as complete all items. Sort of bulk update. The <code>updateTodo</code> will be evaluated for every item. That could lead to multiple calls of <code>this.fetch()</code> method. Not a pleasant thought, realizing that it will produce as many fetch requests to the backend as the number of items was updated. Now, let's assume the model will be less restrictive and just inform about internal state change. It would be expected that calling <code>this.fetch()</code> will be triggered out of the model when really needed. Then it would resolve the problem of the bulk update from once side. From another side, it would always require to supply every altering the backend's state method to call <code>this.fetch()</code> method in the end. I like to be less restrictive, though, let's keep passive behavior and let ViewModels make the decision.</p>

<p>The implementation of the ToDo Model:</p>

<p><span id="prehide994822" onclick="processCodeBlocks.togglePre(994822);">Hide</span>  &nbsp; <span id="preShrink994822" onclick="processCodeBlocks.shrinkExpand(994822);">Shrink</span> <img id="preimg994822" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(994822);">  &nbsp; <span id="copycode994822" onclick="return processCodeBlocks.copyCode(994822);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre994822" processed="true"><span>class</span> TodosModel <span>extends</span> Base {
    <span>static</span> inst = <span>null</span> as TodosModel;
    <span>static</span> instance() {
        <span>if</span> (TodosModel.inst === <span>null</span>) {
            TodosModel.inst = <span>new</span> TodosModel();
            TodosModel.inst.fetch();
        }

        <span>return</span> TodosModel.inst;
    }
    adapter = <span>new</span> TodosAdapter();
    items = [] as ITodoItem[];

    <span>constructor</span>() {
        <span>super</span>(<span>'</span><span>change:items'</span>);
    }

    getItems() {
        <span>return</span> <span>this</span>.items;
    }

    setItems(val) {
        <span>if</span> (<span>this</span>.items !== val) {
            <span>this</span>.items = val;
            <span>this</span>.trigger(<span>'</span><span>change:items'</span>);
        }
    }

    async fetch() {
        <span>const</span> items = await <span>this</span>.adapter.fetchTodos();
        <span>this</span>.setItems(items);
    }

    createTodo(title) {
        <span>return</span> <span>this</span>.adapter.createTodo(title);
    }

    updateTodo(item: ITodoItem) {
        <span>const</span> { id, ...attrs } = item;
        <span>return</span> <span>this</span>.adapter.updateTodo(id, attrs);
    }

    deleteTodo(item: ITodoItem) {
        <span>const</span> { id } = item;
        <span>return</span> <span>this</span>.adapter.deleteTodo(id);
    }
}</pre>

<p>For those, who would like to give a more restrictive way, there is a solution. For the small modules in the application, modify&nbsp;<code>this.fetch()</code> method to work as a debouncing method. For medium modules - introduce bulk items update method. It would resolve the bulk update issue and still will be called once. e.g. <code>this.fetch = _.debounce(this.fetch, 200);</code>&nbsp; For the big modules, such restriction could harm network performance and it would be better to keep the model with passive fetch behavior. That would allow to spare some not needed extra requests to the backend. With the tradeoff - ViewModels would contain more code. By the way, implementing bulk updates will lead to more code as well. And it will keep the implementation more clear.</p>

<h3>View Models</h3>

<p>There are two view models in the solution. The first, MainViewModel - it is for the main view. The second one for every todo task - TodoViewModelItem. The main view model is to keep data in a convenient way to show in the main interface. The todo view model is to keep items data to be listed. The view models can be classified into two kinds: view models and view model items. The main difference between thous kinds is in their creation and lifetime. The main view model will be created just once. It would be available for all views. The todo view model item can be created many times. It will be designed with the idea to be easily dropped from memory. Mostly it will hold the logic to convert values to be presented on UI.</p>

<p>The item view model can be divided into four sections. View model Commands, constructor, getters section, command implementation section. Since it will be soon dropped from memory there no data binding commands. It refers to TodoModel singleton and calls updating the backend state logic. Please, take a note, it takes POKO item object from the model as the initial argument. And it has no setters. It can be simply dropped from memory with no memory leaks.</p>

<p>The todo view model item example:</p>

<p><span id="prehide681014" onclick="processCodeBlocks.togglePre(681014);">Hide</span>  &nbsp; <span id="preShrink681014" onclick="processCodeBlocks.shrinkExpand(681014);">Shrink</span> <img id="preimg681014" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(681014);">  &nbsp; <span id="copycode681014" onclick="return processCodeBlocks.copyCode(681014);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre681014" processed="true"><span>class</span> TodoViewModelItem {
    completeCommand = { exec: isComplete =&gt; <span>this</span>.complete(isComplete) };
    deleteCommand = { exec: () =&gt; <span>this</span>.remove() };
    updateTitleCommand = { exec: title =&gt; <span>this</span>.updateTitle(title)};

    <span>constructor</span>(<span>public</span> item: ITodoItem) {
    
    }

    getId() {
        <span>return</span> <span>this</span>.item.id;
    }

    getTitle() {
        <span>return</span> <span>this</span>.item.title;
    }

    getIsComplete() {
        <span>return</span> <span>this</span>.item.complete;
    }

    async updateTitle(title) {
        <span>const</span> todosModel = TodosModel.instance();
        await todosModel.updateTodo({
            ...<span>this</span>.item,
            title: title
        });
        todosModel.fetch();
    }

    async complete(isComplete) {
        <span>const</span> todosModel = TodosModel.instance();
        await todosModel.updateTodo({
            ...<span>this</span>.item,
            complete: isComplete
        });
        todosModel.fetch();
    }

    async remove() {
        <span>const</span> todosModel = TodosModel.instance();
        await todosModel.deleteTodo(<span>this</span>.item);
        todosModel.fetch();
    }
}</pre>

<p>In general, the main view model is more smarter than todo view model item. It has getters/setters implemented within the Base class. It is <code>prop('&lt;propName&gt;', &lt;propValue&gt;)</code>. It can be divided into five sections. The new state section, view model Commands, constructor, getters/setters, and command implementation section. Since it will be heavily used it should contain a way to attach/detach listeners from the model. Creating and destroying the main view model could be a complex task. And it is expected to attach when create and detach when destroy event listeners. It has an empty constructor, all initialization logic is extracted into the initialize methods. This is adjustable, the initialize method can be called from the constructor or from the parent creating routines. It depends on the particular implementation.</p>

<p>The main view model will populate todo tasks to be displayed on UI into its internal state. Then it would inform all subscribed participants about the state change. That logic is hidden within the base class. Here in the main view model, it is adjusted by calling <code>this.prop('&lt;propName&gt;', &lt;propValue&gt;)</code>.</p>

<p><span id="prehide681068" onclick="processCodeBlocks.togglePre(681068);">Hide</span>  &nbsp; <span id="preShrink681068" onclick="processCodeBlocks.shrinkExpand(681068);">Shrink</span> <img id="preimg681068" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(681068);">  &nbsp; <span id="copycode681068" onclick="return processCodeBlocks.copyCode(681068);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre681068" processed="true"><span>class</span> MainViewModel <span>extends</span> Base&lt;MainViewModel[<span>'</span><span>state'</span>]&gt; {
    state = {
        title: <span>'</span><span>'</span>,
        items: [] as TodoViewModelItem[]
    }

    createNewItemCommand = { exec: () =&gt; <span>this</span>.createNewItem() };
    toggleAllCompleteCommand = {
        canExecute: () =&gt; !this.areAllComplete(),
        exec: () =&gt; <span>this</span>.toggleAllCompleteCommand.canExecute() &amp;&amp; <span>this</span>.markAllComplete()
    };
    offChangeItems;

    <span>constructor</span>() {
        <span>super</span>(
            <span>'</span><span>change:title'</span>,
            <span>'</span><span>change:items'</span>
        );
        <span>this</span>.initialize();
    }

    initialize() {
        <span>const</span> todos = TodosModel.instance();
        <span>this</span>.offChangeItems = todos.on(<span>'</span><span>change:items'</span>, () =&gt; {
            <span>this</span>.populateItems();
        });
    }

    populateItems() {
        <span>const</span> todos = TodosModel.instance();
        <span>this</span>.prop(<span>'</span><span>items'</span>, utils.map(todos.getItems(), item =&gt; <span>new</span> TodoViewModelItem(item)));
    }

    async createNewItem() {
        <span>const</span> model = TodosModel.instance();
        await model.createTodo(<span>this</span>.prop(<span>'</span><span>title'</span>));
        model.fetch();
        <span>this</span>.prop(<span>'</span><span>title'</span>, <span>'</span><span>'</span>);
    }

    markAllComplete() {
        utils.map(<span>this</span>.prop(<span>'</span><span>items'</span>), m =&gt; m.complete(<span>true</span>));
    }
    
    areAllComplete() {
        <span>if</span> (!this.prop(<span>'</span><span>items'</span>).length) {
            <span>return</span> <span>false</span>;
        }
        <span>return</span> !utils.find(<span>this</span>.prop(<span>'</span><span>items'</span>), i =&gt; !i.getIsComplete());
    }
}</pre>

<p>To summarize: The view models can be of two types. Heavy - can have event listeners, contain complex logic related to implementing requirements, complex in constructing its instances. It creates light view models many times. And light - minimally implementing requirements, can be many times created and dropped from the memory. Could have data conversion for UI presentation.</p>

<h3>UI layer - Views</h3>

<p>The views can be classified by several kinds as well. Pure views (controls), root views, and item views. Pure views although named as controls. They are responsible just to draw UI, keep child views. And never bound to view models. It will be in a separate folder from the rest of the views.</p>

<p>The perfect example is ListView:</p>

<p><span id="prehide950972" onclick="processCodeBlocks.togglePre(950972);">Hide</span>  &nbsp; <span id="preShrink950972" onclick="processCodeBlocks.shrinkExpand(950972);">Shrink</span> <img id="preimg950972" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(950972);">  &nbsp; <span id="copycode950972" onclick="return processCodeBlocks.copyCode(950972);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre950972" processed="true"><span>class</span> ListView&lt;T <span>extends</span> IListItemView&lt;VM&gt;, VM = ExtractViewModel&lt;T&gt;&gt; <span>extends</span> Base&lt;ListView&lt;T, VM&gt;[<span>'</span><span>state'</span>]&gt; {
    options = <span>this</span>.initOptions(<span>this</span>.config);
    el = utils.el(<span>this</span>.options.el);
    state = {
        items: [] as ExtractViewModel&lt;T&gt;[],
        children: [] as T[]
    };
    filter = <span>null</span>;
    offChangeItems;
    offChangeFilter;

    <span>constructor</span>(<span>public</span> config: ReturnType&lt;ListView&lt;T, VM&gt;[<span>'</span><span>initOptions'</span>]&gt;) {
        <span>super</span>(
            <span>'</span><span>change:items'</span>,
            <span>'</span><span>change:children'</span>,
            <span>'</span><span>change:filter'</span>
        );
        <span>this</span>.initialize();
    }

    getFilter() {
        <span>return</span> <span>this</span>.filter;
    }

    setFilter(fn: (i: ExtractViewModel&lt;T&gt;) =&gt; <span>boolean</span>) {
        <span>if</span> (<span>this</span>.filter !== fn) {
            <span>this</span>.filter = fn;
            <span>this</span>.trigger(<span>'</span><span>change:filter'</span>);
        }
    }

    initOptions(options = {}) {
        <span>const</span> defOpts = {
            el: <span>'</span><span>'</span>,
            createItem(props?): T {
                <span>return</span> <span>null</span>;
            }
        };
    
        <span>return</span> {
            ...defOpts,
            ...options
        };
    }

    initialize() {
        <span>this</span>.offChangeItems = <span>this</span>.on(<span>'</span><span>change:items'</span>, () =&gt; <span>this</span>.drawItems());
        <span>this</span>.offChangeFilter = <span>this</span>.on(<span>'</span><span>change:filter'</span>, () =&gt; <span>this</span>.drawItems());
    }

    drawItem(viewModel: ExtractViewModel&lt;T&gt;, index: number) {
        <span>const</span> itemViews = <span>this</span>.prop(<span>'</span><span>children'</span>);
        <span>const</span> currentView = itemViews[index];
        <span>const</span> itemView = currentView || <span>this</span>.options.createItem();
        <span>if</span> (!currentView) {
            <span>this</span>.prop(<span>'</span><span>children'</span>, [...<span>this</span>.prop(<span>'</span><span>children'</span>), itemView]);
            <span>this</span>.el.append(itemView.el);
        }
        itemView.setViewModel(viewModel);
    }

    drawItems() {
        <span>const</span> items = <span>this</span>.filter ? utils.filter(<span>this</span>.prop(<span>'</span><span>items'</span>), <span>this</span>.filter) : <span>this</span>.prop(<span>'</span><span>items'</span>),
            length = items.length,
            firstChildren = utils.first(<span>this</span>.prop(<span>'</span><span>children'</span>), length),
            restChildren = utils.last(<span>this</span>.prop(<span>'</span><span>children'</span>), length);

        <span>this</span>.prop(<span>'</span><span>children'</span>, firstChildren);
        <span>for</span> (<span>const</span> itemView of restChildren) {
            itemView.remove();
        }

        <span>for</span> (<span>let</span> i = <span>0</span>; i &lt; length; i++) {
            <span>const</span> model = items[i];
            <span>this</span>.drawItem(model, i);
        }
    }

    remove() {
        utils.getResult(<span>this</span>, () =&gt; <span>this</span>.offChangeItems);
        utils.getResult(<span>this</span>, () =&gt; <span>this</span>.offChangeFilter);
        utils.remove(<span>this</span>.el);
    }
}</pre>

<p>The list view is responsible just to create, destroy, and render children views. It would never communicate with the view models directly. It can be bound to view models over data binding commands from a parent view. Never contain data binding commands within. Acts as a self-sufficient view. The ListView is responsible to draw list items on UI. It can filter items by setting the special filtering function over the <code>setFilter</code> setter. In this example, the ListView is designed in a special way. It will refresh currently rendered child views with the new data. The idea here is to minimally manipulate DOM elements. The todo UI has an input box to edit the todo task title. In the case, DOM will be removed and then inserted (redraw), the currently editing input (focused) will lose its focus. That would impact UI experience. Fortunately, there is data binding. Every field is bound to its source. We can use that as an advantage. The switching view model in the view would lead to filling values that are changed and never replace the same values.</p>

<p>Please check this TodoListItemView - the <code>setViewModel</code> method:</p>

<p><span id="prehide790071" onclick="processCodeBlocks.togglePre(790071);">Hide</span>  &nbsp; <span id="preShrink790071" onclick="processCodeBlocks.shrinkExpand(790071);">Shrink</span> <img id="preimg790071" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(790071);">  &nbsp; <span id="copycode790071" onclick="return processCodeBlocks.copyCode(790071);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre790071" processed="true"><span>function</span> htmlToEl(html) {
    <span>const</span> el = <span>document</span>.createElement(<span>'</span><span>div'</span>);
    utils.html(el, html);

    <span>return</span> el.firstElementChild;
}

<span>class</span> TodoListItemView&lt;T <span>extends</span> TodoViewModelItem&gt; {
    el = htmlToEl(template({}));
    vm: T;
    completeCommand;
    deleteCommand;
    updateTitleCommand;
    offTitleChange;
    offCompletedChange;
    offDeleteClick;

    getId() {
        <span>return</span> utils.attr(<span>this</span>.el, <span>'</span><span>data-id'</span>);
    }

    setId(val) {
        <span>if</span> (<span>this</span>.getId() !== val) {
            utils.attr(<span>this</span>.el, <span>'</span><span>data-id'</span>, val);
        }
        <span>return</span> val;
    }

    getTitle() {
        <span>return</span> utils.el(<span>'</span><span>.title'</span>, <span>this</span>.el).value;
    }

    setTitle(val) {
        <span>if</span> (<span>this</span>.getTitle() !== val) {
            <span>const</span> title = utils.el(<span>'</span><span>.title'</span>, <span>this</span>.el);
            title.value = val;
        }
        <span>return</span> val;
    }

    getCompleted() {
        <span>const</span> el = utils.el(<span>'</span><span>.completed'</span>, <span>this</span>.el);
        <span>return</span> el.checked;
    }

    setCompleted(newValue) {
        <span>const</span> oldValue = <span>this</span>.getCompleted();
        <span>if</span> (oldValue !== newValue) {
            utils.el(<span>'</span><span>.completed'</span>, <span>this</span>.el).checked = newValue;
        }
        <span>return</span> newValue;
    }

    bind() {
        <span>this</span>.unbind();
        <span>this</span>.completeCommand = <span>this</span>.vm.completeCommand;
        <span>this</span>.deleteCommand = <span>this</span>.vm.deleteCommand;
        <span>this</span>.updateTitleCommand = <span>this</span>.vm.updateTitleCommand;
        <span>this</span>.offCompletedChange = utils.on(<span>this</span>.el, <span>'</span><span>.completed'</span>, <span>'</span><span>click'</span>, () =&gt; <span>this</span>.completeCommand.exec(<span>this</span>.getCompleted()));
        <span>this</span>.offDeleteClick = utils.on(<span>this</span>.el, <span>'</span><span>.delete'</span>, <span>'</span><span>click'</span>, () =&gt; <span>this</span>.deleteCommand.exec());
        <span>this</span>.offTitleChange = utils.on(<span>this</span>.el, <span>'</span><span>.title'</span>, <span>'</span><span>input'</span>, () =&gt; <span>this</span>.updateTitleCommand.exec(<span>this</span>.getTitle()));
    }

    unbind() {
        <span>this</span>.completeCommand = <span>null</span>;
        <span>this</span>.updateTitleCommand = <span>null</span>;
        <span>this</span>.deleteCommand = <span>null</span>;
        utils.getResult(<span>this</span>, () =&gt; <span>this</span>.offTitleChange);
        utils.getResult(<span>this</span>, () =&gt; <span>this</span>.offCompletedChange);
        utils.getResult(<span>this</span>, () =&gt; <span>this</span>.offDeleteClick);
    }

    setViewModel(item: T) {
        <span>if</span> (<span>this</span>.vm !== item) {
            <span>this</span>.vm = item;
            <span>this</span>.bind();
            <span>this</span>.setId(item.getId());
            <span>this</span>.setTitle(item.getTitle());
            <span>this</span>.setCompleted(item.getIsComplete());
        }
    }

    remove() {
        <span>this</span>.unbind();
        utils.remove(<span>this</span>.el);
    }
}</pre>

<p>The&nbsp;<code>setViewModel</code>&nbsp;method&nbsp;is a special getter. I even can't call it getter. It is a setting of the view model method. It will be responsible for assigning the view model instance in the right way. Within the example, it has a lack of this.unbind call. This is because it never used without an assigned view model. But it is expected that the todo item view will be removed. The <code>remove</code> method has <code>this.unbind()</code> call within its implementation. And it assigns values from the view model to UI over relevant setters.</p>

<p>The todo item view is designed in the way to keep its state on the DOM elements. That is reflected in getter/setter methods. Setter methods are designed in a special way. Before they set their value, they check for changes individually. This is a good rule to check if the old value is not the same as the new value. That would avoid extra UI refresh and improve UI experience (resetting caret position) when typing in text fields.</p>

<p>In the clean design, one of the main reasons to follow MVVM is because binding commands are ingested into the templating engine. And since the solution has a luck of such engine data binding commands are grouped into a pair of methods unbind/bind. Ideally, bind/unbind methods should be called before and after HTML rendering routines. I have cheated here. Since HTML rendering occurs just during initialization of the instance one time and view model is going to be changed more often, unbind/bind methods are called after every view model change. Technically, it is still doesn't break rules - called after rendering HTML. Even more, it looks like a manual implementation of the complex binding command e.g. <code>'title': 'vm.prop('title')'</code>. Just a big gotcha with the MVVM explanation in this article.</p>

<p>The next is&nbsp; MainView:</p>

<p><span id="prehide101606" onclick="processCodeBlocks.togglePre(101606);">Hide</span>  &nbsp; <span id="preShrink101606" onclick="processCodeBlocks.shrinkExpand(101606);">Shrink</span> <img id="preimg101606" src="https://www.codeproject.com/images/arrow-up-16.png" onclick="processCodeBlocks.shrinkExpand(101606);">  &nbsp; <span id="copycode101606" onclick="return processCodeBlocks.copyCode(101606);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre101606" processed="true"><span>interface</span> MainView <span>extends</span> ReturnType&lt;typeof initialize$MainView&gt; {

}

<span>function</span> initialize$MainView&lt;T&gt;(inst: T, el) {
    <span>return</span> Object.assign(inst, {
        newTitle: utils.el(<span>'</span><span>.new-title'</span>, el),
        allComplete: utils.el(<span>'</span><span>.complete-all'</span>, el),
        filterAll: utils.el(<span>'</span><span>.all'</span>, el),
        filterActive: utils.el(<span>'</span><span>.active'</span>, el),
        filterCompleted: utils.el(<span>'</span><span>.completed'</span>, el),
        todoList: <span>new</span> ListView({
            el: utils.el(<span>'</span><span>.todo-list'</span>, el),
            createItem() {
                <span>return</span> <span>new</span> TodoListItemView&lt;TodoViewModelItem&gt;();
            }
        })
    });
}

<span>class</span> MainView <span>extends</span> Base {
    vm = <span>this</span>.getViewModel();
    options = <span>this</span>.initOptions(<span>this</span>.config);
    el = utils.el(<span>this</span>.options.el);
    offTitleToModel;
    offTitleFromModel;
    offItemsFromModel;

    offOnKeypress;
    offMarkAllComplete;
    offChangeItems;
    offFilter;

    createNewItemCommand = { exec() { <span>return</span>; } };
    toggleAllCompleteCommand = {
        canExecute() { <span>return</span> <span>false</span>; },
        exec() { <span>return</span>; }
    };

    <span>constructor</span>(<span>public</span> config: ReturnType&lt;MainView[<span>'</span><span>initOptions'</span>]&gt;) {
        <span>super</span>(<span>'</span><span>change:items'</span>);
    }

    getTitle() {
        <span>return</span> <span>this</span>.newTitle.value;
    }

    setTitle(val) {
        <span>if</span> (<span>this</span>.newTitle.value !== val) {
            <span>this</span>.newTitle.value = val;
            utils.trigger(<span>this</span>.newTitle, <span>'</span><span>input'</span>);
        }
    }

    getAllComplete() {
        <span>return</span> <span>this</span>.allComplete.checked;
    }

    setAllComplete(val) {
        <span>if</span> (<span>this</span>.allComplete.checked !== val) {
            <span>this</span>.allComplete.checked = val;
            utils.trigger(<span>this</span>.allComplete, <span>'</span><span>change'</span>);
        }
    }

    getFilter() {
        <span>const</span> el = utils.el(<span>'</span><span>.filter input:checked'</span>, <span>this</span>.el);
        <span>return</span> el &amp;&amp; el.value;
    }

    setFilter(newValue: <span>'</span><span>all'</span> | <span>'</span><span>active'</span> | <span>'</span><span>completed'</span>) {
        <span>const</span> oldValue = <span>this</span>.getFilter();
        <span>if</span> (newValue !== oldValue) {
            <span>const</span> el = utils.el(<span>`</span>.filter input[value="${newValue}"]`);
            el.checked = true;
        }
    }

    getViewModel() { 
        return null as MainViewModel;
    }

    setViewModel() {
        this.unbind();
        this.setFilter('all');
        this.setAllComplete(this.toggleAllCompleteCommand.canExecute());
        this.bind();
    }

    initOptions(options = {}) {
        const defOpts = {
            el: 'body'
        };
        return {
            ...defOpts,
            ...options
        };
    }

    initialize() {
        const html = template({
            vid: 1
        });
        utils.html(this.el, html);
        initialize$MainView(this, this.el);

        this.offOnKeypress = utils.on(this.el, '.new-title', 'keypress', evnt =&gt; this.onKeypress(evnt));
        this.offMarkAllComplete = utils.on(this.el, '.complete-all', 'change', () =&gt; this.getAllComplete() &amp;&amp; this.toggleAllCompleteCommand.exec());
        this.offChangeItems = this.todoList.on('change:items', () =&gt; this.setAllComplete(!this.toggleAllCompleteCommand.canExecute()));
        this.offFilter = utils.on(this.el, '.filter input', 'click', () =&gt; this.filterItems(this.getFilter()));

        this.setViewModel();
    }

    bind() {
        this.unbind();
        this.createNewItemCommand = this.vm.createNewItemCommand;
        this.toggleAllCompleteCommand = this.vm.toggleAllCompleteCommand;
        this.offTitleToModel = utils.on(this.el, '.new-title', 'input', () =&gt; this.vm.prop('title', this.getTitle()));
        this.offTitleFromModel = this.vm.on('change:title', () =&gt; this.setTitle(this.vm.prop('title')));
        this.offItemsFromModel = this.vm.on('change:items', () =&gt; this.todoList.prop('items', this.vm.prop('items')));
    }

    unbind() {
        this.createNewItemCommand = { exec() { return; } };
        this.toggleAllCompleteCommand = { canExecute() { return false; }, exec() { return; } };
        utils.getResult(this, () =&gt; this.offTitleToModel);
        utils.getResult(this, () =&gt; this.offTitleFromModel);
        utils.getResult(this, () =&gt; this.offItemsFromModel);
    }

    onKeypress(evnt) {
        if (evnt.which === ENTER_KEY &amp;&amp; ('' + this.newTitle.value).trim()) {
            this.createNewItemCommand.exec();
        }
    }

    filterItems(filterName: 'all' | 'active' | 'completed') {
        switch (filterName) {
            case 'active':
                return this.todoList.setFilter(i =&gt; !i.getIsComplete());
            case 'completed':
                return this.todoList.setFilter(i =&gt; i.getIsComplete());
            default:
                return this.todoList.setFilter(null);
        }
    }

    remove() {
        utils.getResult(this, () =&gt; this.offOnKeypress);
        utils.getResult(this, () =&gt; this.offMarkAllComplete);
        utils.getResult(this, () =&gt; this.offChangeItems);
        utils.getResult(this, () =&gt; this.offFilter);

        utils.remove(this.el);
    }
}</pre>

<p>The <code>MainView</code> is a heavy root view that contains the implementation of requirements. It is bound to the <code>MainViewModel</code> in <code>unbind/bind</code> methods. The main difference between <code>TodoListItemView</code> is a definition of DOM event listeners along with data binding commands. Because initialization of the root view is a complex part of the constructor is extracted within a separate <code>initialize</code> method. It is expected to call the&nbsp;<code>initialize</code> method after instantiating the instance of the&nbsp;<code>MainView</code> class.</p>

<p>Something like this. The <code>App.run</code> entry point which calls <code>main.initialize();</code>:</p>

<p><span id="prehide261024" onclick="processCodeBlocks.togglePre(261024);">Hide</span>  &nbsp; <span id="copycode261024" onclick="return processCodeBlocks.copyCode(261024);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre261024"><span>const</span> template = data =&gt; <span>`</span><span>&lt;</span><span>div</span><span> </span><span>class</span><span>="</span><span>application"</span><span>&gt;</span>Loading...<span>&lt;</span><span>/div</span><span>&gt;</span>`;

class App {
    static run() {
        utils.html(document.body, template({}));
        const main = new MainView({
            el: utils.el('.application')
        });
        main.initialize();
    }
}

setTimeout(() =&gt; {
    App.run();
});</pre>

<p>The <code>MainView</code>, <code>TodoListItemView</code>, and <code>ListView</code> contain just UI related logic. They don't contain any manipulation with data. Anything that is about to manipulate with data (create/read/update/delete) is consolidated in view models.</p>

<p>The initialization of the DOM element properties is extracted into a separate <code>initialize$MainView</code> method. When will be the next iteration of development and the text in an HTML template will be changed with renamed elements or CSS class names -&nbsp;<code>initialize$MainView</code> is the only place where I can look up and adjust these changes. The DOM event listeners are grouped there as well. Since they are a part of the UI there is no point to unbind/bind them. They will exist as long as the instance of the <code>MainView</code> will exist. Then the&nbsp;<code>this.setViewModel();</code>&nbsp;method is called to assign a view model. The unbind/bind methods are constructed to keep commands that are related to the binding view to a view model.</p>

<h3>Commands - Gems in MVVM design:</h3>

<p>There is something that mediates between views and view models. Small pieces of code that could be a part of both of them and still can be separated. MVVM commands. Anything that is signaled from UI, related to updating data, that is directed from UI towards view models can be treated as commands. Special parts of the application, help use the application in the way it is planned to be used. Always reviewed by customers, QA testers, developers in order to find the entry point to any complex logic that could be hidden by simple mouse click (or touch) on UI. They remind a lonely solitude with the black screen of a command-line console that was popular in the earlier times of computer evolution for average users. Now just developers and system administrators live there.</p>

<p>I will list them all. And let them speak for themselves:</p>

<p><span id="prehide838713" onclick="processCodeBlocks.togglePre(838713);">Hide</span>  &nbsp; <span id="copycode838713" onclick="return processCodeBlocks.copyCode(838713);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre838713">createNewItemCommand = { exec: () =&gt; <span>this</span>.createNewItem() };
deleteCommand = { exec: () =&gt; <span>this</span>.remove() };
updateTitleCommand = { exec: title =&gt; <span>this</span>.updateTitle(title)};
completeCommand = { exec: isComplete =&gt; <span>this</span>.complete(isComplete) };
toggleAllCompleteCommand = {
    canExecute: () =&gt; !this.areAllComplete(),
    exec: () =&gt; <span>this</span>.toggleAllCompleteCommand.canExecute() &amp;&amp; <span>this</span>.markAllComplete()
};</pre>

<p>Potentially filer items could be in the commands list as well. Right now filter by <i>all</i>, <i>active</i> and <i>completed</i>&nbsp;UI action are just a part of the UI, since it filters already fetched from the backend items. In the case, backend could provide filtering requests they will become a part of that list as well.</p>

<h3>For those who seek more answers</h3>

<p>Totally, my precious reader has noticed some strange commands. Something like below:</p>

<p><span id="prehide727051" onclick="processCodeBlocks.togglePre(727051);">Hide</span>  &nbsp; <span id="copycode727051" onclick="return processCodeBlocks.copyCode(727051);">Copy Code</span></p><pre lang="jscript" data-lang-orig="jscript" id="pre727051">utils.getResult(<span>this</span>, () =&gt; <span>this</span>.offMarkAllComplete);
utils.getResult(<span>this</span>, () =&gt; <span>this</span>.offChangeItems);
utils.getResult(<span>this</span>, () =&gt; <span>this</span>.offFilter);</pre>

<p>In the Backbone JS, there is a command <code>_.result(object, '&lt;propName')</code>. It extracts value from the method by a provided name from the object. I have decided to use something similar. That <code>utils.getResults</code> is meant for the same case.</p>

<p>The method <code> initialize$MainView</code> can be a part of the <code>MainView</code>. The main reason it is extracted from the class is that in this way I can define custom properties and declare them on the <code>MainView</code> class at the same time.</p>

<p>The file structure of the project:</p>

<p><span id="prehide306112" onclick="processCodeBlocks.togglePre(306112);">Hide</span>  &nbsp; <span id="copycode306112" onclick="return processCodeBlocks.copyCode(306112);">Copy Code</span></p><pre id="pre306112">.
 |-viewModels
 | |-mainViewModel.ts
 | |-index.ts
 | |-todoViewModelItem.ts
 |-utils
 | |-index.ts
 |-models
 | |-todos.ts
 | |-index.ts
 |-controls
 | |-listView.ts
 |-adapters
 | |-todos.ts
 |-templates
 | |-mainView.ts
 | |-listItem.ts
 |-index.ts
 |-views
 | |-todoListItemView.ts
 | |-index.ts
 | |-mainView.ts
 |-base
 | |-base.ts</pre>

<h3>Conclusions about MVVM design pattern:</h3>

<p>MVVM design pattern is easy to follow in the case all parts of the MVVM structure are familiar. There is a filling like I'm just worrying about resolving and implementing requirements instead of fighting with language constructions in the order to find a nice place for the right requirement resolution. The best part is the ability to reprogram UI without altering the core implementations. Though, it can be adjusted for a particular client's demands. It is easy to locate every part of the application and start implementing new requirements.</p>

<p>It is hard to resolve and connect all MVVM ideas from the first try, because of the lack of documentation for the javascript language. I have dug myself over many resources that are from C# WPF.NET. The most confusing part was to resolve the implementation of the idea of a data binding concept. Despite a simplicity in understanding, it is hard to decouple participants and parts of the code that are for binding and part of views and models. It would be really awesome if one day would appear templating language with the meaning of data binding statements. Please, let me know if I've missed cool ideas for MVVM that could be a part of this article.</p>

<h4>Positives:</h4>

<p>It is easy to setup UI with fewer updates/refreshes since every part of the UI is bound to a particular part of the data</p>

<p>It can be introduced into the application on any stage of development</p>

<p>Doesn't demand frameworks or utility libraries</p>

<p>With the rich tools and clear approach will be flexible, restrictions would act as one of the assisting tool</p>

<p>It provides more places to implement business requirements</p>

<p>It would be easy to implement in small and medium applications</p>

<p>The view layer can be replaced with less efforts</p>

<h4>Consequences:</h4>

<p>Since UI is bound to data it could be hard to determine what a part of the module is responsible for what refreshing place on UI</p>

<p>This leads to more code writing</p>

<p>With the weak tools and not clear approach could be more restrictive than flexible</p>

<p>Weak implementation could lead to confusion and less understanding tasks of the MVVM layers</p>

<p>It would demand a good effort to implement in a big application</p>

<p>It could be problematic to implement for some specific framework libraries</p>

<h5>Happy MVVM design development!</h5>

<h2>Articles to look for inspiration:</h2>

<p><a href="https://www.raywenderlich.com/34-design-patterns-by-tutorials-mvvm" target="_blank">Design Patterns by Tutorials: MVVM</a></p>

<p><a href="https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch10s06.html" target="_blank">MVVM - Learning JavaScript Design Patterns [Book] - O'Reilly</a></p>

<p><a href="https://blog.ircmaxell.com/2014/11/alternatives-to-mvc.html" target="_blank">Alternatives To MVC</a></p>

<p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2014/november/mvvm-wpf-commanding-with-the-state-machine-pattern" target="_blank">MVVM: WPF Commanding with the State Machine Pattern</a></p>

<p><a href="http://todomvc.com/" rel="noopener noreferrer" target="_blank">Todo MVC</a></p>


						</div><p>This article, along with any associated source code and files, is licensed under <a href="http://www.opensource.org/licenses/mit-license.php" rel="license">The MIT License</a></p></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>