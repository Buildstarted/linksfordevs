<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Introduction to UEFI: Part 1 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Introduction to UEFI: Part 1 - linksfor.dev(s)"/>
    <meta property="article:author" content="shatter, Mattiwatti"/>
    <meta property="og:description" content="Hello, and welcome to our first article on the site! Today we will be diving into UEFI. We are aiming to provide beginners a brief first look at a few topics, including:"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://secret.club/2020/05/26/introduction-to-uefi-part-1.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Introduction to UEFI: Part 1</title>
<div class="readable">
        <h1>Introduction to UEFI: Part 1</h1>
            <div>by shatter, Mattiwatti</div>
            <div>Reading time: 9-12 minutes</div>
        <div>Posted here: 28 May 2020</div>
        <p><a href="https://secret.club/2020/05/26/introduction-to-uefi-part-1.html">https://secret.club/2020/05/26/introduction-to-uefi-part-1.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div itemprop="articleBody"><p>Hello, and welcome to our first article on the site! Today we will be diving into UEFI. We are aiming to provide beginners a brief first look at a few topics, including:</p><ol><li>What is UEFI?</li><li>Why develop UEFI software?</li><li>UEFI boot phases</li><li>Getting started with developing UEFI software</li></ol><p>Unified Extensible Firmware Interface (UEFI) is an interface that acts as the “middle-man” between the operating system and the platform firmware during the start-up process of the system. It is the successor to the BIOS and provides us with a modern alternative to the restrictive system that preceded it. The UEFI specification allows for many new features including:</p><ul><li>Graphical User Interface (GUI) with mouse support</li><li>Support for GPT drives (including 2TB or greater drives, and more than 4 primary partitions)</li><li>Faster booting (depending on OS support)</li><li>Simplified ACPI access for power management features</li><li>Simplified software development compared to the arcane BIOS</li></ul><p>As you can see, there are many compelling reasons for using UEFI over the legacy BIOS nowadays.</p><p>There are many reasons as to why one would want to develop UEFI software, and today we will be mentioning a few of those reasons to hopefully inspire some of you to attempt to develop or further your knowledge in this subject.</p><h2 id="1-control-over-the-boot-process"> <a href="#1-control-over-the-boot-process">1) Control over the boot process</a></h2><p>One very big use case for UEFI is a boot manager such as GRUB. GRUB (GRand Unified Bootloader) is a multi-boot loader that allows a user to select the operating system they wish to boot into, whilst handling the process of selecting which OS or kernel needs to be loaded into memory. It will then transfer control to the respective OS. This is a very helpful tool, and makes use of UEFI to remove the need for manual interaction in the loading of alternative OS’s.</p><h2 id="2-modification-of-os-kernel-initialization"> <a href="#2-modification-of-os-kernel-initialization">2) Modification of OS kernel initialization</a></h2><p>Sometimes one may want to redirect certain OS kernel initialization procedures or even fully prevent them from running. This is not possible to do with a boot-time driver. Why is this the case? Well, a large part of kernel initialization happens before any drivers are loaded, so any modifications will not be possible after this point in the presence of Kernel Patch Protection (PatchGuard). Another reason is the issue of Driver Signature Enforcement (DSE): Microsoft requires that loaded drivers on Windows must be signed with a valid kernel mode signing certificate, unless test signing mode is enabled.</p><p>An example of a UEFI project that modifies Windows kernel initialization procedures is <a href="https://github.com/Mattiwatti/EfiGuard">EfiGuard</a>. This UEFI driver patches certain parts of the Windows boot loader and kernel at boot time, and can effectively disable PatchGuard and optionally DSE.</p><h2 id="3-develop-low-level-system-knowledge"> <a href="#3-develop-low-level-system-knowledge">3) Develop low level system knowledge</a></h2><p>Another reason for developing UEFI software could be to increase your understanding of the system at a low level. Being able to follow the initialization process of the system allows for a much more in-depth look at how operating systems themselves work. Additionally, the ability to build OS independent drivers, as well as work with a sophisticated toolset giving you full control over a system is something that may be of interest to many people.</p><p>UEFI has six main boot phases, which are all critical in the initialization process of the platform. The combined phases are referred to as the Platform Initialization or PI. Hopefully the brief descriptions of each stage below will give you a basic understanding of this process. Our series will focus primarily on the DXE and RT phases, as these are probably the two main areas of interest for people getting started with UEFI.</p><p><img src="https://i.imgur.com/9bDyREo.png" alt=""></p><h3 id="security-sec"> <a href="#security-sec">Security (SEC)</a></h3><p>This phase is the primary stage of the UEFI boot process, and will generally be used to: initialize a temporary memory store, act as the root of trust in the system and provide information to the Pre-EFI core phase. This root of trust is a mechanism that ensures any code that is executed in the PI is cryptographically validated (digitally signed), creating a “secure boot” environment.</p><h3 id="pre-efi-initialization-pei"> <a href="#pre-efi-initialization-pei">Pre-EFI Initialization (PEI)</a></h3><p>This is the second stage of the boot process and involves using only the CPU’s current resources to dispatch Pre-EFI Initialization Modules (PEIMs). These are used to perform initialization of specific boot-critical operations such as memory initialization, whilst also allowing control to pass to the Driver Execution Environment (DXE).</p><h3 id="driver-execution-environment-dxe"> <a href="#driver-execution-environment-dxe">Driver Execution Environment (DXE)</a></h3><p>The DXE phase is where the majority of the system initialization occurs. In the PEI stage, the memory required for the DXE to operate is allocated and initialized, and upon control being passed to the DXE, the DXE Dispatcher is then invoked. The dispatcher will perform the loading and execution of hardware drivers, runtime services, and any boot services required for the operating system to start.</p><h3 id="boot-device-selection-bds"> <a href="#boot-device-selection-bds">Boot Device Selection (BDS)</a></h3><p>Upon completion of the DXE Dispatcher executing all DXE drivers, control is passed to the BDS. This stage is responsible for initializing console devices and any remaining devices that are required. The selected boot entry is then loaded and executed in preparation for the Transient System Load (TSL).</p><h3 id="transient-system-load-tsl"> <a href="#transient-system-load-tsl">Transient System Load (TSL)</a></h3><p>In this phase, the PI process is now directly between the boot selection and the expected hand-off to the main operating system phase. Here, an application such as the UEFI shell may be invoked, or (more commonly) a boot loader will run in order to prepare the final OS environment. The boot loader is usually responsible for terminating the UEFI Boot Services via the ExitBootServices() call. However, it is also possible for the OS itself to do this, such as the Linux kernel with CONFIG_EFI_STUB.</p><h3 id="runtime-rt"> <a href="#runtime-rt">Runtime (RT)</a></h3><p>The final phase is the runtime one. Here is where the final handoff to the OS occurs. The UEFI compatible OS now takes over the system. The UEFI runtime services remain available for the OS to use, such as for querying and writing variables from NVRAM.</p><p>The SMM (System Management Mode) exists separately from the runtime phase and may also be entered during this phase when an SMI is dispatched. We will not be covering the SMM in this introduction.</p><p>In this section we will be providing you with a list of the most essential tools to help you begin your development journey with UEFI. When it comes to the question of “where to begin?”, there aren’t many resources easily accessible, so here is a shortlist of the development tools we recommend:</p><p><strong>- EDK2</strong></p><p>First and foremost is the EDK2 project, which is described as “a modern, feature-rich, cross-platform firmware development environment for the UEFI and PI specifications from [www.uefi.org.]” The EDK2 project is developed and maintained (together with community volunteers) by many of the same parties that contribute to the UEFI specification.</p><p>This is extremely helpful as EDK2 is guaranteed to contain the latest UEFI protocols (assuming you are using the master branch). In addition to this, there are countless high-quality projects for you to use as a guide. One example is the <a href="https://www.linux-kvm.org/page/OVMF">Open Virtual Machine Firmware (OVMF)</a>. This is a project that is aimed at providing UEFI support for virtual machines and it is very well documented.</p><p>One major downside to EDK2 is the process of setting up the build environment for the first time - it is a long and arduous process, and even with their <a href="https://github.com/tianocore/tianocore.github.io/wiki/Getting-Started-with-EDK-II">Getting started with EDK2</a> guide to make it as simple as possible, it can still be confusing for newcomers.</p><p><strong>- VisualUefi</strong></p><p>The <a href="https://github.com/ionescu007/VisualUefi">VisualUefi</a> project is aimed at allowing EDK2 development inside Visual Studio. We would recommend you to begin your development by using the build tools from EDK2 command line over this project, to allow you to become comfortable with the platform.</p><p>Furthermore, VisualUefi offers headers and libraries that are a subset of the complete EDK2 libraries, and so you may find that not everything you require is easily accessible. It is, however, much easier to set up in comparison to EDK2, and is therefore often favored by avid Visual Studio users.</p><p><strong>- Debugging</strong></p><p>In regards to debugging, there are a few options available to you, each with their pros and cons. These will be listed below, and it is up to you which you favor the most. In part 2 of this series we will be showing you how to debug an example driver, so until then you may want to install all of these (or none!) to help you make an informed decision:</p><ol><li><a href="https://www.qemu.org/"><strong><em>QEMU</em></strong></a> - a multiplatform emulator (though best on Linux) that provides the best debugging facilities due to being an emulator rather than a VM. It is quite complex to set up, and concerning its counterparts, it is also quite slow.</li><li><a href="https://www.virtualbox.org/"><strong><em>VirtualBox</em></strong></a> - a good multiplatform solution, with the exception of it suffering from memory loss due to pretty lackluster non-volatile RAM (NVRAM) emulation.</li><li><a href="https://www.vmware.com/"><strong><em>VMware</em></strong></a> - offers good performance with correctly working NVRAM emulation. If the guest and host are both Windows, it works very well with WinDbg for debugging the TSL and RT phases.</li></ol><p>In this article we have covered a couple of different introductory topics to help you get a basic understanding of what UEFI is. We would expect you to hopefully have some extra questions regarding this topic, and we are more than happy to answer them for you. Part 2 of this series will be more technical, however it will be explained thoroughly to the best of our abilities to make it as simple to follow as possible. We will be providing code for a simple DXE driver built with EDK2, and will show examples of basic console input and output, writing to a serial port, and debugging the driver with QEMU.</p><p>Thank you very much for reading this far, and we look forward to continuing this series in the coming weeks!</p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>