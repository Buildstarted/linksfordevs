<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Dependency Injection / Service Locator as a Language Feature &#xB7; Issue #1690 &#xB7; dotnet/csharplang &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Dependency Injection / Service Locator as a Language Feature · Issue #1690 · dotnet/csharplang · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>The use of dependency injection frameworks has increased over the years; and for good reason. DI frameworks help to enforce good design patterns &amp; principles. We have an opportunity to make CSharp the first language with IOC / DI as a language feature.</p><p><strong>Proposal Version:</strong> v0.1</p><h2>Discussion</h2><p>This proposal isn't perfect and would benefit from some deep discussion on the potential. I think this proposal can lead CSharp toward a language that supports good design practices as a feature.</p><h2>Example Code</h2><p>Before we dive into the details, let's take a high-level look at the implementation. In our example, we have a service and a consumer. Depending on the static / non-static binding, the objects are resolved on demand. Each object's dependencies are then injected via the container automatically.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-smi">container</span><span class="pl-smi">AppContainer</span>
{
    <span class="pl-smi">public</span><span class="pl-smi">static</span><span class="pl-smi">IHttpService</span><span class="pl-en">as</span><span class="pl-smi">HttpService</span>;
    <span class="pl-smi">public</span><span class="pl-smi">ISomeType</span><span class="pl-en">as</span><span class="pl-smi">SomeType</span>;
}

<span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">SomeType</span> : <span class="pl-en">ISomeType</span>
{
    <span class="pl-k">public</span><span class="pl-en">IHttpService</span><span class="pl-smi">HttpService</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span><span class="pl-en">SomeType</span>(<span class="pl-en">inject</span><span class="pl-smi">IHttpService</span> httpService)
    {
         <span class="pl-smi">HttpService</span><span class="pl-k">=</span><span class="pl-smi">httpService</span>;
    }
}

<span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">Program</span>
{
     <span class="pl-k">public</span><span class="pl-k">static</span><span class="pl-k">void</span><span class="pl-en">Main</span>(<span class="pl-k">string</span>[] <span class="pl-smi">args</span>)
     {
          <span class="pl-k">var</span><span class="pl-smi">httpService</span><span class="pl-k">=</span><span class="pl-smi">IHttpService</span><span class="pl-smi">from</span><span class="pl-smi">AppContainer</span>;
          <span class="pl-k">var</span><span class="pl-smi">someType</span><span class="pl-k">=</span><span class="pl-smi">ISomeType</span><span class="pl-smi">from</span><span class="pl-smi">AppContainer</span>;
          <span class="pl-k">var</span><span class="pl-smi">someType2</span><span class="pl-k">=</span><span class="pl-smi">ISomeType</span><span class="pl-smi">from</span><span class="pl-smi">AppContainer</span>;
         
         <span class="pl-c"><span class="pl-c">//</span> ISomeType is bound as a transient, therefore unique instances...        </span><span class="pl-smi">Assert</span>.<span class="pl-en">NotEqual</span>(<span class="pl-smi">someType</span>, <span class="pl-smi">someType2</span>);

         <span class="pl-c"><span class="pl-c">//</span> IHttpService is bound statically, therefore acts like a singleton...</span><span class="pl-smi">Assert</span>.<span class="pl-en">AreEqual</span>(<span class="pl-smi">httpServie</span>, <span class="pl-smi">someType</span>.<span class="pl-smi">HttpService</span>);
     }
}</pre></div><h2>Details</h2><h3>Inject Modifier</h3><p>An inject modifier would make the parameter act like an optional value. If not provided, it would take default(T). The compiler would generate the variations with and without the values passed in.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">SomeType</span> : <span class="pl-en">ISomeType</span>
{
    <span class="pl-k">public</span><span class="pl-en">SomeType</span>(<span class="pl-en">inject</span><span class="pl-smi">IHttpService</span> httpService) { }
    <span class="pl-k">public</span><span class="pl-en">SomeType</span>() {} <span class="pl-c"><span class="pl-c">//</span> Generated...</span>
}

<span class="pl-k">var</span><span class="pl-smi">someType</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SomeType</span>(<span class="pl-smi">service</span>);
<span class="pl-k">var</span><span class="pl-smi">someType2</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SomeType</span>(); <span class="pl-c"><span class="pl-c">//</span> inject treated as optional...</span></pre></div><p>There are cases where constructors cannot be used; For instance, in game engines like Unity3D. In these cases, we could support using the inject modifier on public properties or fields. Typically this is bad practice since it's harder to mock; however we can support these edge cases.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">SomeOtherType</span> : <span class="pl-en">ISomeType</span>
{
    <span class="pl-k">public</span> inject <span class="pl-en">IHttpService</span><span class="pl-smi">HttpService</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }
}</pre></div><h3>Container</h3><p>Typical DI frameworks define a <code>Container</code> that acts like a service locator. The language would introduce a new entity type called container.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-smi">container</span><span class="pl-smi">AppContainer</span>
{
     <span class="pl-smi">public</span><span class="pl-smi">static</span><span class="pl-smi">IHttpService</span><span class="pl-en">as</span><span class="pl-smi">HttpService</span>;
     <span class="pl-smi">public</span><span class="pl-smi">virtual</span><span class="pl-smi">ISomeType</span><span class="pl-en">as</span><span class="pl-smi">SomeType</span>;
}</pre></div><h3>Container Inheritence</h3><p>Inheriting other Containers would share the bindings between the two. Virtual bindings can be overridden just like properties or methods of a class.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-smi">container</span><span class="pl-en">OtherContainer</span> : <span class="pl-smi">AppContainer</span>
{
     <span class="pl-smi">public</span><span class="pl-smi">override</span><span class="pl-smi">ISomeType</span><span class="pl-en">as</span><span class="pl-smi">OtherType</span>;
}</pre></div><h3>Container Behavior Customization</h3><p>You can customize the behavior of the Container by implementing a language provided interface.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">MyResolveStrategy</span> : <span class="pl-en">IContainerResolveStrategy</span>
{
    <span class="pl-k">public</span><span class="pl-en">TInstance</span><span class="pl-en">Resolve</span>&lt;<span class="pl-en">TInstance</span>&gt;(<span class="pl-en">IResolveContext</span><span class="pl-smi">resolveContext</span>) { ... }
    <span class="pl-k">public</span><span class="pl-k">object</span><span class="pl-en">Resolve</span>(<span class="pl-en">IResolveContext</span><span class="pl-smi">resolveContext</span>) { ... }
}

[<span class="pl-en">ContainerResolveStrategy</span>&lt;<span class="pl-en">MyResolveStrategy</span>&gt;()]
<span class="pl-k">public</span><span class="pl-smi">container</span><span class="pl-smi">AppContainer</span>
{
    ...
}</pre></div><h2>Binding</h2><p>Binding types will be done through the container.</p><h3>Binding Transient Types</h3><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-smi">container</span><span class="pl-smi">AppContainer</span>
{
    <span class="pl-smi">public</span><span class="pl-smi">ISomeType</span><span class="pl-en">as</span><span class="pl-smi">SomeType</span>;
}</pre></div><h3>Binding Singleton Types (Statics)</h3><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-smi">container</span><span class="pl-smi">AppContainer</span>
{
    <span class="pl-smi">public</span><span class="pl-smi">static</span><span class="pl-smi">IHttpService</span><span class="pl-en">as</span><span class="pl-smi">HttpService</span>;
}</pre></div><h3>Binding with custom factory</h3><p>Sometimes you need to customize the creation of the types when you resolve. You can instead bind a factory method to the type. The parameters are evaluated and injected at the time of resolution.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-smi">container</span><span class="pl-smi">AppContainer</span>
{
    <span class="pl-smi">public</span><span class="pl-smi">static</span><span class="pl-en">IHttpService</span>(<span class="pl-smi">inject</span><span class="pl-en">ISomeDependency</span><span class="pl-smi">someDependency</span>) 
    {
        <span class="pl-k">return</span><span class="pl-k">new</span><span class="pl-en">HttpService</span>(<span class="pl-smi">someDependency</span>);
    }
}</pre></div><h3>Binding types to the container at Runtime</h3><p>This part needs work.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span><span class="pl-smi">instance</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SomeType</span>();
<span class="pl-smi">AppContainer</span>.<span class="pl-en">Bind</span>&lt;<span class="pl-en">ISomeType</span>&gt;().<span class="pl-en">To</span>(<span class="pl-smi">instance</span>);</pre></div><h3>Runtime Resolving</h3><p>As with traditional DI frameworks, the client can resolve a bound type. This would be supported in the language through syntactic sugar.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span><span class="pl-smi">someType</span><span class="pl-k">=</span><span class="pl-smi">ISomeType</span><span class="pl-smi">from</span><span class="pl-smi">AppContainer</span>;
<span class="pl-k">var</span><span class="pl-smi">someType2</span><span class="pl-k">=</span><span class="pl-smi">ISomeType</span><span class="pl-smi">from</span><span class="pl-smi">OtherContainer</span>;</pre></div><h3>Default Interface Constructors</h3><p>Interfaces would have the ability to have default constructors that must be used by the implementing classes. The value of this can be seen in the next section.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">interface</span><span class="pl-en">ISomeType</span>
{
     ISomeType(inject IHttpService httpService);
}</pre></div><h3>Resolving with additional parameters</h3><p>Since we now allow for default constructors on the interfaces, we can pass through additional (non-injected) parameters at the time of resolving.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span><span class="pl-k">interface</span><span class="pl-en">ILogger</span>
{
     ILogger(string logPath);
}

<span class="pl-k">public</span><span class="pl-k">class</span><span class="pl-en">FileLogger</span> : <span class="pl-en">ILogger</span>
{
     <span class="pl-k">public</span><span class="pl-en">FileLogger</span>(<span class="pl-en">inject</span><span class="pl-smi">IFileWriter</span> fileWriter, <span class="pl-k">string</span><span class="pl-smi">logPath</span>) : base.ILogger(logPath) { ... }
     <span class="pl-k">public</span><span class="pl-en">ILogger</span>(<span class="pl-k">string</span><span class="pl-smi">logPath</span>) {  ... }
}

<span class="pl-k">public</span><span class="pl-smi">container</span><span class="pl-smi">AppContainer</span>
{
    <span class="pl-smi">public</span><span class="pl-smi">static</span><span class="pl-smi">ILogger</span><span class="pl-en">as</span><span class="pl-smi">FileLogger</span>;
}
... 

<span class="pl-k">var</span><span class="pl-smi">logger</span><span class="pl-k">=</span><span class="pl-en">ILogger</span>(<span class="pl-s"><span class="pl-pds">"</span>some/path/log.txt<span class="pl-pds">"</span></span>) <span class="pl-smi">from</span><span class="pl-smi">AppContainer</span>;</pre></div><h2>Unit Testing</h2><p>Since the <code>inject</code> modifier is treated like an optional parameter, you still have the ability to pass in the dependencies through the constructor. Thus, mocking and unit-testing the classes is no different than how it is done today.</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span><span class="pl-smi">someType</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">SomeType</span>(<span class="pl-smi">mockHttpService</span>.<span class="pl-smi">Object</span>);

<span class="pl-smi">Assert</span>.<span class="pl-en">AreEqual</span>(...);</pre></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>