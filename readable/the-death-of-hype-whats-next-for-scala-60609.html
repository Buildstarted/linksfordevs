<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Death of Hype: What&#x27;s Next for Scala - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The Death of Hype: What&#x27;s Next for Scala - linksfor.dev(s)"/>
    <meta property="og:description" content="A recent tweet by a friend of mine noted how the public interest in the Scala programming language seems to have plateaued or waned, which matches my feeling of the latest trends and zeitgeist. This blog post will go into why I think that has happened, where Scala stands now, and what the future holds for the Scala community."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://www.lihaoyi.com/post/TheDeathofHypeWhatsNextforScala.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The Death of Hype: What&#x27;s Next for Scala</title>
<div class="readable">
        <h1>The Death of Hype: What&#x27;s Next for Scala</h1>
            <div>Reading time: 19-25 minutes</div>
        <div>Posted here: 12 Apr 2020</div>
        <p><a href="http://www.lihaoyi.com/post/TheDeathofHypeWhatsNextforScala.html">http://www.lihaoyi.com/post/TheDeathofHypeWhatsNextforScala.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>A recent tweet by a friend of mine noted how the public interest in the Scala programming language seems to have plateaued or waned, which matches my feeling of the latest trends and zeitgeist. This blog post will go into why I think that has happened, where Scala stands now, and what the future holds for the Scala community.</p><hr>
<p>This blogpost was inspired by the following tweet:</p>
<blockquote>
  <p>It's a shame to see friends from Typesafe/Lightbend being laid off, but as I've always said, it's hard to sell free stuff.</p>
  <p>I do wonder about #Scala's adoption now. It's not Clojure-dead, but it seemed to peak around 2016. I have zero data to back that, though.</p>
</blockquote>
<ul>
  <li><a href="https://twitter.com/jamie_allen/status/1248019842877145089">Jamie Allen</a></li>
</ul>
<p>Jamie notes that public interest in the Scala programming language seems to have waned: less interest in meetups, less interest in conferences, and so on. This more or less matches what I am seeing as well. While the Scala-specific conferences targeting enthusiasts are still going strong (or were, until COVID19 shut down the global economy) I think there is no doubt that there is much less <em>talk</em> about Scala in the broader engineering community.</p>
<p>I think that this reduction in public interest is real, but also expected given the typical "Hype Cycle" that follows any new technology:</p>
<p><img src="http://www.lihaoyi.com/post/TheScalaEcosystem/HypeCycle.jpg" alt="HypeCycle.jpg"></p>
<p>Early on, Scala rode a wave of hype that frankly surprised even me: hype around pushing syntactic boundaries, hype around reactive architectures, hype around functional programming, hype around the Apache Spark project. Much of that hype has since died down, and there was a period of backlash and negativity both within the Scala community and outside of it. Since then, even the backlash has faded, and what is left is a reasonable, boring language steadily advancing and providing a great platform for general software engineering.</p><h2 id="the-past-the-peak-of-inflated-expectations">The Past: the Peak of Inflated Expectations<a href="#the-past-the-peak-of-inflated-expectations"></a></h2>
<p>While Scala was initially created in 2004, the language only really started taking off in the early 2010s:</p>
<ul>
  <li>
  <p>~2009: Twitter started picking up the language for production systems</p></li>
  <li>
  <p>~2010: the first tagged release of the Scalaz functional programming library</p></li>
  <li>
  <p>~2011: Lightbend, a company pushing Scala and related technologies, was  founded</p></li>
  <li>
  <p>~2014: Apache Spark was written in Scala</p></li>
  <li>
  <p>~2015: first tagged release of the Cats functional programming library</p></li>
</ul>
<p>While there was no doubt activity in the Scala community before this, these were no doubt major milestones that kickstarted interest in the language. With large-scale commercial adoption, commercial support, and a killer big-data product like Apache Spark, it is not surprising that there was a surge in public interest. A lot of these efforts went into the following domains:</p><h3 id="pushing-syntactic-boundaries">Pushing Syntactic Boundaries<a href="#pushing-syntactic-boundaries"></a></h3>
<p>A lot of early Scala interest was in how flexible the language was: it had extension methods, operator overloading, implicit constructors/conversions, and a very flexible implicit-parameter feature that could be used in all sorts of ways. This flexibility was liberating, as it opened up all sorts of domain-specific-languages and programming styles that would be unheard of in other languages.</p>
<p>These were exemplified by a number of projects, such as the <a href="https://databinder.net/">Databinder Dispatch</a> HTTP client, <a href="http://www.scala-graph.org/">Scala-Graph</a> data structure library, or <a href="https://www.scala-sbt.org/">SBT</a> build tool:</p>
<pre><code>
executer<span>(</span><span>:</span><span>/</span><span>(</span>host<span>,</span> port<span>)</span> <span>/</span> target <span>&lt;</span><span><span>&lt;</span> reqBody <span>&gt;</span></span><span>-</span> <span>{</span> fromRespStr <span>}</span><span>)</span>


<span>val</span> flights <span>=</span> Graph<span>(</span>
	<span>(</span>jfc <span>~</span><span>+</span>#<span>&gt;</span> fra<span>)</span><span>(</span>Flight<span>(</span><span>"LH 400"</span> <span>,</span><span>10</span> o <span>25</span><span>,</span> <span>8</span> h <span>20</span><span>)</span><span>)</span><span>,</span>
	<span>(</span>fra <span>~</span><span>+</span>#<span>&gt;</span> dme<span>)</span><span>(</span>Flight<span>(</span><span>"LH 1444"</span><span>,</span> <span>7</span> o <span>50</span><span>,</span> <span>3</span> h <span>10</span><span>)</span><span>)</span>


url<span>(</span><span>"<a href="http://databinder.net/dispatch/About" rel="nofollow"><span>http</span><span>://</span><span>databinder</span><span>.</span><span>net</span><span>/</span><span>dispatch</span><span>/</span><span>About</span></a>"</span><span>)</span> #<span>&gt;</span> <span>"grep JSON"</span> #<span>&gt;&gt;</span> file<span>(</span><span>"About_JSON"</span><span>)</span> <span>!</span>


<span>"find src -name *.scala -exec grep null {} ;"</span>  #<span>|</span>  <span>"xargs test -z"</span>  #<span>&amp;&amp;</span>  <span>"echo null-free"</span>  #<span>||</span>  <span>"echo null detected"</span>  <span>!</span>
</code></pre>
<p>Many of these libraries have evolved since the early days and have since moved to more boring method-based APIs. It turns out that naming operators <code>&gt;-</code> <code>~+#&gt;</code> or <code>#&amp;&amp;</code>, while possible, was not always the wisest thing to do. Nevertheless, there is no doubt that pushing the boundaries of Scala's syntax using operators and domain-specific-languages was one of the big points of interest for early Scala.</p><h3 id="reactive-architectures">Reactive Architectures<a href="#reactive-architectures"></a></h3>
<p>Reactive architectures, pushed largely by Lightbend via their <a href="https://akka.io/">Akka Actor framework</a>, was another big effort. This was a way of writing code that was very different from "normal" code that someone might learn in school, but allowed high levels of concurrency and performance beyond what is achievable writing code in a traditional style.</p>
<p>In its initial incantation, Akka Actors sacrificed a lot of what Scala what it is: a total lack of type-safety between actors, prohibiting blocking APIs, and many other idiosyncracies. Working with Akka Actors were basically their own language, embedded in Scala, but with their own conventions, syntax, and semantics.</p>
<p>More recently, with Typed Actors and Reactive Streams, the Akka developer experience has shifted to be much closer to the type-checked experience you would expect in typical Scala programs. I think there's also been a shift in the community mood: rather than treating reactive architectures like a general-purpose solution to all problems, they are now being treated as one possible approach for one specific class of problems. That mostly matches my own experience using these techniques in my own applications.</p><h3 id="functional-programming">Functional Programming<a href="#functional-programming"></a></h3>
<p>Functional programming in Scala is best exemplified by the Scalaz and Cats projects. These two libraries attempt to bring much of the functional programming techniques from Haskell to the Scala language: a heavy focus on concepts like Monads or Applicatives, eschewing the object-oriented side of the language for a more pure-functional style.</p>
<p>The two libraries have different styles, and both remain heavily used by portions of the community today. The evangelism has died down, to some extent, but usage remains strong and everyone recognizes functional programming as one possible style in which to write your Scala applications.</p><h3 id="apache-spark">Apache Spark<a href="#apache-spark"></a></h3>
<p>The last big project that drove Scala's early hype was Apache Spark. A distributed big-data process framework, Apache Spark leveraged Scala's functional style and serializable lambdas to take common collection like <code>map</code>, <code>filter</code>, and <code>reduce</code> and run them distributed over a compute cluster processing huge amounts of data. Apache Spark allowed big data processing pipelines to be written in orders of magnitude less code and running in orders of magnitude less time than the earlier Hadoop APIs. Spark proved an instant hit.</p>
<p>Apache Spark was Scala's killer app. A huge fraction of the Scala community is only using Scala because they need to inter-operate with Spark in some way.</p>
<p>Apache Spark now supports developer APIs in many languages: SQL, R, with Python being the most popular. The original collections-like APIs have been largely superseded by a more SQL-like interface that allows better optimizability, an important factor when working with the huge datasets that Apache Spark is often used for. Nevertheless the Apache Spark codebase remains mostly Scala to this day.</p><h2 id="in-the-trough-of-disillusionment">In the Trough of Disillusionment<a href="#in-the-trough-of-disillusionment"></a></h2>
<p>Since the initial spark, there definitely has been some backlash against Scala as the initial hype has died down. Some early contributors have left the community, and there was some inter-personal unhappiness. This was not just in aggregate, but on an individual level as well: I personally know many individuals who got tired of the things they themselves had been hyping, and moved on with a slightly sour taste in their mouths.</p>
<p>It's hard to pin-point an exact time where the hype died down, perhaps around 2016-2018.</p>
<p>Even on a technical level, not all was well. While many organizations used these techniques successfully in their respective niches, others have regretted going all-in on actors and all-in on functional programming. They were finding that these techniques don't fit their problem as well as they would have liked, and had to spend some time backing out of their all-in investment in a particular programming paradigm. I personally know many organizations who have had to make this adjustment.</p>
<p>Even before the fall, in the early 2010s, I was surprised at the amount of hype around some of these technologies. The usage of operators in some of these libraries was clearly through the roof, and sometimes turned even simple tasks into complex brain-teasers. The amount of hype I saw around reactive architectures and functional programming did not match the specialized use cases I found that they fit best: every Scala conference had keynote speakers evangelizing both of these approaches as the be-all end-all future of software architecture.</p>
<p>It surprises me not at all that over time, others would join me in realizing the <em>Trough of Disillusionment</em>.</p><h2 id="the-present-on-the-slope-of-enlightenment">The Present: on the Slope of Enlightenment<a href="#the-present-on-the-slope-of-enlightenment"></a></h2>
<p>Scala had its hype in the early 2010s, followed by a backlash against that hype in the mid-late 2010s. Where does that leave Scala now?</p>
<p><img src="http://www.lihaoyi.com/post/TheScalaEcosystem/Sonatype.png" alt="Sonatype.png"></p>
<p>Despite the apparent downturn in public interest, usage of Scala continues to increase. I maintain a large number of open source libraries, and the number of unique IPs downloading these libraries from the Maven Central package repository has grown just over 2x over the last year. While there is some variation in the number of downloads, or the metrics for each individual package, overall they match this trend quite closely.</p>
<p>While this growth isn't the exponential rocket ship that some projects are hoping for, this is a steady increase in usage that matches my own subjective experience: usage of Scala continues to increase even as the hype has died away. If we can maintain this 2x growth every year, I think the Scala community will continue to be in pretty good shape!</p>
<p>If you look at the most recent <a href="https://redmonk.com/sogrady/2020/02/28/language-rankings-1-20/">Redmonk Rankings</a> or <a href="https://www.tiobe.com/tiobe-index/">Tiobe Rankings</a>, they both show Scala as stably hovering just outside the clique of mainstream languages, ranked 13 and 28 respectively. Uncommon, but not obscure.</p>
<p>With the hype and the backlash both distant memories, we now see Scala for what it is a flexible language supporting multiple programming styles, each with their own tradeoffs and use cases. A lot of the early religiosity and conflict has transformed into people using Scala for steady work, enjoying the language in the way they each choose.</p><h3 id="a-solid-platform-for-production-usage">A Solid Platform for Production Usage<a href="#a-solid-platform-for-production-usage"></a></h3>
<p>Despite the reduction in hype, the Scala language is in a lot better place than it used to be:</p>
<ul>
  <li>
  <p>The SBT build tool has improved by leaps and bounds in the last few years:  massively faster and easier to use.</p></li>
  <li>
  <p>If you don't like SBT, you now have a choice: many organizations use Bazel or  Pants with Scala, while my own  <a href="https://github.com/lihaoyi/mill">Mill build tool</a> is stable and widely used</p></li>
  <li>
  <p>New tools like <a href="https://github.com/coursier/coursier">Coursier</a> are forming a  new foundation for the ecosystem: used by tools from Ammonite to SBT to Mill</p></li>
  <li>
  <p>The <a href="https://github.com/scalameta/metals">Metals</a> project brings Scala support to  VSCode, Sublime Text, and any other editor with language-server support</p></li>
  <li>
  <p>Intellij's own Scala plugin continues to improve: faster, more accurate, and  with support for new tools like Ammonite scripts or the Mill build tool.</p></li>
  <li>
  <p>The new collections library in Scala 2.13 cleans up a huge number of old warts  and significantly improves performance in many cases (e.g.  <a href="https://github.com/databricks/sjsonnet#performance">25-40% speedup on Sjsonnet</a>)</p></li>
  <li>
  <p>"Polish" features like  <a href="https://github.com/scala/scala/pull/7387">pattern matching on strings</a> or  <a href="https://github.com/scala/scala/pull/8373">warning suppression</a> continue to  make life better for everyone</p></li>
  <li>
  <p>The compiler itself is massively sped up, with code compiling literally twice  as fast as it did just three years ago</p></li>
</ul>
<p><img src="http://www.lihaoyi.com/post/TheScalaEcosystem/CompilerGrafana.png" alt="CompilerGrafana.png"></p>
<p>While the language specification has hardly changed at all in the past few years, the amount of quality-of-life improvements that have landed is hard to overstate. If you had talked to any Scala-using engineering organization about halving their compile times back in 2017, they would have showered you with money to make it happen!</p>
<p>Each of the these individually has significantly improved my own personal experience writing Scala, and there are many more improvements that I cannot comprehensively list here.</p><h3 id="a-broad-and-varied-ecosystem">A Broad and Varied Ecosystem<a href="#a-broad-and-varied-ecosystem"></a></h3>
<p>While the hype around the original four efforts has waned, these still form large and active sub-communities within the Scala ecosystem. For example while not everyone may want to use pure functional programming, and any individual may not want to use it all the time, the libraries and ecosystem surrounding it are nevertheless varied, high-quality, and well-maintained. When you do encounter an occasion to use pure functional programming, you will find everything you need.</p>
<p>In a way, the hype has served its purpose: by introducing a large number of people to a particular paradigm, it helps achieve the critical mass for some fraction of those people to sustain that sub-community going forward.</p>
<p>The broad range of styles in Scala can be thought of as a boon: rather than considering it a way of splitting the community apart, it is a way of bringing together communities that would otherwise never interact with each other. Without Scala, these communities may be disparately working in Haskell, Python, Java, and Go systems. By focusing on what's shared, rather than what's different, Scala allows these communities to collaborate on the things that benefit them all while still preserving the things that make each sub-community unique.</p>
<p>I personally do not default to architecting my code reactively using Actors, but I have shipped production code that heavily uses Actors when the situation called for them. I do not default to pure functional programming techniques, but I have used pretty esoteric constructs like Free Applicatives when useful. I think the community as a whole has matured in a similar way: appreciating the different styles, and using them where appropriate, without the dogmatism that plagued the early days of Scala.</p><h2 id="the-future">The Future<a href="#the-future"></a></h2>
<p>So what exciting things do I think lie in Scala's Future?</p>
<p>To me, the Scala language itself is in a relatively good state. An afternoon writing modern Java code is enough to relieve me of any illusions that other languages have "caught up", as does spending days trying (unsuccessfully) to package a Python project into a standalone executable (Hello there, Azure-CLI!).</p>
<p>Where the greatest potential lies is in introducing Scala to new sets of people, or new sets of use cases, that up to this point have been completely out of bounds. I think there are two main things that stand out to me:</p><h3 id="usability">Usability<a href="#usability"></a></h3>
<p>In the initial four Scala efforts, one thing was missing from all of them: the ability for a new developer to start on a codebase and be immediately productive. It doesn't matter whether you were using an operator-heavy dispatch style, a actor-heavy reactive style, or a pure-FP Cats/Scalaz style: someone trying to onboard was going to have a hard time.</p>
<p>Why does that need to be the case?</p>
<p>As a counter-example, developers generally find Python an easy language to get started with: "executable pseudocode" they call it. New programmers learn Python. Non-programmers learn Python. When people write code on a whiteboard with a marker, they often write Python. While Python's performance, concurrency, or large-scale maintenability are questionable, its ease of getting started is unmatched.</p>
<p>Why can't Scala be as easy to get started with as Python?</p>
<p>Answering that question is the goal of the entire suite of libraries that I maintain. Many of my libraries are carbon-copies, shameless clones of their Python equivalents. For example:</p>
<ul>
  <li>
  <p><a href="https://github.com/lihaoyi/Ammonite">Ammonite</a>, a clone of the IPython REPL</p></li>
  <li>
  <p><a href="https://github.com/lihaoyi/upickle">uPickle</a>, a clone of the Python <code>json</code>  module</p></li>
  <li>
  <p><a href="https://github.com/lihaoyi/PPrint">PPrint</a>, a clone of the Python <code>pprint</code>  module</p></li>
  <li>
  <p><a href="https://github.com/lihaoyi/requests-scala">Requests-Scala</a>, a clone of  Kenneth Rietz' Requests module</p></li>
  <li>
  <p><a href="https://github.com/lihaoyi/os-lib">OS-Lib</a>, a clone of the Python <code>os</code>,  <code>sys</code>, and <code>shutil</code> modules</p></li>
  <li>
  <p><a href="https://github.com/lihaoyi/cask">Cask</a>, a clone of the Armin Ronacher's Flask  library</p></li>
</ul>
<p>It turns out that you can make Scala as easy to get started with as Python. And for all of Pythons weaknesses - performance, concurrency, maintainability - Scala already does excellently. Scala has the potential to be the language with the usability and flexiblity of Python with the performance and scalability of Java or Go, and type-safe maintainability far beyond any of those options. Quite literally the best of both worlds!</p>
<p>While there will always be use cases where high-concurrency reactive architectures or pure-functional programming are the best tool for the job, I hope going forward that developers will be able to onboard onto the Scala language in an easy and straightforward way, and only need to learn those more advanced techniques when the need for it comes.</p><h3 id="scala-native">Scala Native<a href="#scala-native"></a></h3>
<p><a href="http://www.scala-js.org/">Scala.js</a> has demonstrated the feasiblity of using Scala on an alternate platform: compiled to Javascript instead of on the JVM, it has a vibrant ecosystem and community, and brings the Scala language into the browser, somewhere it could never be used before.</p>
<p>Scala-Native promises an even bigger revolution: by compiling Scala to self-contained binary executables, that would allow the Scala language to be used in scenarios where the startup time and resource overhead of a JVM or Javascript runtime is unacceptable. While Scala.js brought Scala to the browser, Scala-Native promises to bring Scala to a host of new environments:</p>
<ul>
  <li>
  <p>Command-line tools like <code>git</code>, <code>ls</code>, <code>rsync</code>, etc. which cannot tolerate the  startup time of the JVM.</p></li>
  <li>
  <p>Sidecar processes or background daemons, where the significant memory overhead  of the JVM makes using Scala problematic</p></li>
  <li>
  <p>Mobile development on iOS, running on iPhones and iPads, one of the most  ubiquitous consumer computing devices in the world</p></li>
  <li>
  <p>Desktop applications, where the JVM startup time is too slow or bundling the  JVM too bulky</p></li>
  <li>
  <p>Deep integrations with native libraries, like the Tensorflow machine learning  framework</p></li>
</ul>
<p>These sorts of programs have been traditionally written in unsafe languages like C or C++. More recent implementations are often written in Rust or Go, and there's a whole cottage industry of not-C programming languages like Nim, Zig, or Crystal also trying to fill this space. Scala-Native promises to be able to fill this space, not with a brand-new language, but with an already-popular language with an existing rich ecosystem of libraries and tooling.</p>
<p>Scala-Native will be much more difficult to make successful than Scala.js was. In particular, Scala.js could focus on the compiler and then delegate to an existing Javascript runtime, while Scala-Native has to build its own runtime from first principles: threading, garbage-collection, event-loops, and so on. This is addition to the formidable amount of compiler work necessary. Nevertheless, if successful, this would be a massive boon for broadening the use cases for which the Scala language can be used.</p><h2 id="conclusion">Conclusion<a href="#conclusion"></a></h2>
<p>While amount of <em>hype</em> around the Scala language has definitely died down over the years, the <em>usage</em> seems to be growing at a steady clip, and the experience of using the language has been improving rapidly. This is exactly what you would expect as a language progresses through the hype cycle, and moves from a fad-driven community to a value-driven community. Scala developers are using the language, not as an end unto itself, but instead as a solid tool they can use to accomplish their non-Scala-related technical or business objectives.</p>
<p>In effect, this is what it means for the community to mature.</p>
<p>Going forward, I hope we can see more of this. More focus on outcomes and value, rather than hype. More weighing of tradeoffs, rather than dogmatism. More celebrating the shared core, rather than arguing over the differences. And more 2x compiler speedups!</p>
<p>I think the way we 10x the Scala community is not by spending 10x the effort bikeshedding over the existing language syntax, 10x the effort arguing about functional vs object oriented programming, or 10x the effort trying to make our already-very-type-safe code even more type-safe. It is instead by inclusively expanding the language to reach those developers we could never reach before: the newbies, the non-programmers, the command-line-tool folks, the iOS developers, and so on. If we look at the <a href="https://www.jetbrains.com/lp/devecosystem-2019/python/">2019 Jetbrains Developer Survey for Python</a>, we can see the breadth of different domains in which the Python language is used:</p>
<p><img src="http://www.lihaoyi.com/post/TheScalaEcosystem/JetbrainsSurvey.png" alt="JetbrainsSurvey.png"></p>
<p>Currently Scala is overwhelmingly used for backend services and/or Spark data pipelines, but there is no reason the above use cases couldn't be satisfied by Scala as well. It's up to the community to make using Scala easy and broadly-usable enough that anyone, not just the grizzled backend/data engineers, are able to pick up Scala and and use it while enjoying the conciseness, performance, and type-safety that those within the Scala community already know and love.</p><hr><p><b>About the Author:</b><i> Haoyi is a software engineer, an early contributor to <a href="http://www.scala-js.org/">Scala.js</a>, and the author of many open-source Scala tools such as the <a href="http://www.lihaoyi.com/post/lihaoyi.com/Ammonite">Ammonite REPL</a> and <a href="https://github.com/lihaoyi/fastparse">FastParse</a>. </i></p><p><i>If you've enjoyed this blog, or enjoyed using Haoyi's other open source libraries, please chip in (or get your Company to chip in!) via <a href="https://www.patreon.com/lihaoyi">Patreon</a> so he can continue his open-source work</i></p><hr></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>