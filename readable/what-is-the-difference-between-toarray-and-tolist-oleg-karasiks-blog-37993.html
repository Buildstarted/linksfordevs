<!DOCTYPE html>
<html lang="en">
<head>
    <title>
What is the difference between ToArray and ToList? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="What is the difference between ToArray and ToList? - linksfor.dev(s)"/>
    <meta property="article:author" content="Oleg Karasik"/>
    <meta property="og:description" content="We as .NET developers probably use ToArray and ToList methods every day. But have you ever wonder how they work? What is the difference between them? Is there is a difference? :) If you have asked &#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://olegkarasik.wordpress.com/2019/07/23/what-is-the-difference-between-toarray-and-tolist/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - What is the difference between ToArray and ToList?</title>
<div class="readable">
        <h1>What is the difference between ToArray and ToList?</h1>
            <div>by Oleg Karasik</div>
            <div>Reading time: 31-39 minutes</div>
        <div>Posted here: 01 Oct 2019</div>
        <p><a href="https://olegkarasik.wordpress.com/2019/07/23/what-is-the-difference-between-toarray-and-tolist/">https://olegkarasik.wordpress.com/2019/07/23/what-is-the-difference-between-toarray-and-tolist/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
		
<h2>Introduction</h2>



<hr>



<p>In the beginning of June I attended <a href="https://dotnetsummit.by/">.NET Summit</a> conference in Minsk, Belarus. Besides interesting presentations (recording are available on <a href="https://www.youtube.com/playlist?list=PLpVeA1tdgfCDIuCqslWaTpOUBQRPIHTM2&amp;utm_source=.NET+Summit+2019+-+ORG+Info+for+Attendees&amp;utm_campaign=b75f7fe4a9-90201+RubyConfBY+introduction_COPY_01&amp;utm_medium=email&amp;utm_term=0_44625ef95f-b75f7fe4a9-417654865">YouTube</a>, language is  Russian / English) there were interesting quizzes. </p>



<p>One of the questions was:</p>



<blockquote><p> What is the difference between <code>ToArray</code> and <code>ToList</code>?</p><cite>Software Engineer</cite></blockquote>



<p>Hmm… what could be the difference besides one returns <code>T[]</code> and another one returns <code>List&lt;T&gt;</code>?</p>



<p>If you don’t know the answer or just like digging into sources of <a href="https://github.com/dotnet/corefx/blob/release/3.0/README.md">dotnet/corefx</a> then I invite you to join me and find out the answer!</p>



<div><div>
<div><div>
<p><strong>Note</strong></p>



<div><p>All code snippets were taken from <a href="https://github.com/dotnet/corefx/blob/release/3.0/README.md">release/3.0 branch of dotnet/corefx</a> repository. All code snippets were truncated to make them more representative (removed input argument checks, contracts, …, etc.).</p><p>Tests were targeting .NET Core 3.0 preview 7. However most of the information should be relevant for .NET Core 2.0+ and .NET Framework 4.5+.</p></div>
</div></div>
</div></div>



<h2>Benchmark</h2>



<hr>



<p>Every journey has it’s first step. I usually start with a simple benchmark.</p>



<p>Here is one I’ve created using <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a>:</p>


<div><div id="highlighter_267294"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p></td><td><div><p><code>[CoreJob]</code></p><p><code>[RPlotExporter, MemoryDiagnoser, RankColumn]</code></p><p><code>public</code> <code>class</code> <code>ToArrayToList</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>IEnumerable&lt;</code><code>int</code><code>&gt; data;</code></p><p><code>&nbsp;&nbsp;</code><code>[Params(10, 100, 1000, 10000)]</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>int</code> <code>N;</code></p><p><code>&nbsp;&nbsp;</code><code>[GlobalSetup]</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>void</code> <code>Setup()</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code><code>.data = </code><code>new</code> <code>int</code><code>[</code><code>this</code><code>.N];</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>[Benchmark]</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>int</code><code>[] ToArray() =&gt; </code><code>this</code><code>.data.ToArray();</code></p><p><code>&nbsp;&nbsp;</code><code>[Benchmark]</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>List&lt;</code><code>int</code><code>&gt; ToList() =&gt; </code><code>this</code><code>.data.ToList();</code></p><p><code>}</code></p><p><code>public</code> <code>class</code> <code>Program</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>static</code> <code>void</code> <code>Main(</code><code>string</code><code>[] args)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>summary = BenchmarkRunner.Run&lt;ToArrayToList&gt;();</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>On my machine this benchmark produces the following results:</p>



<figure><table><thead><tr><th>Method</th><th>N</th><th>Mean</th><th>Gen 0</th><th>Gen 1</th><th>Allocated</th></tr></thead><tbody><tr><td>ToArray</td><td>10</td><td>49.527 ns</td><td>0.0153</td><td>–</td><td>64 B</td></tr><tr><td>ToList</td><td>10</td><td>45.850 ns</td><td>0.0229</td><td>–</td><td>96 B</td></tr><tr><td>ToArray</td><td>100</td><td>82.490 ns</td><td>0.1013</td><td>–</td><td>424 B</td></tr><tr><td>ToList</td><td>100</td><td>78.811 ns</td><td>0.1090</td><td>–</td><td>456 B</td></tr><tr><td>ToArray</td><td>1000</td><td>324.100 ns</td><td>0.9613</td><td>–</td><td>4024 B</td></tr><tr><td>ToList</td><td>1000</td><td>321.039 ns</td><td>0.9689</td><td>–</td><td>4056 B</td></tr><tr><td>ToArray</td><td>10000</td><td>3,223.046 ns</td><td>9.5215</td><td>1.1902</td><td>40024 B</td></tr><tr><td>ToList</td><td>10000</td><td>3,278.019 ns</td><td>9.5215</td><td>1.9035</td><td>40056 B</td></tr></tbody></table></figure>



<p>At the first glance there is no significant difference between two methods. However in such cases it is important to be absolutely sure and the only way to make sure is to examine the source code.</p>



<h3>Examining ToArray and ToList methods</h3>



<hr>



<p>All required source code is on <a href="https://github.com/">GitHub </a>so it is easy to find implementations of <code>ToArray</code> and <code>ToList</code> methods inside <a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository:</p>


<div><div id="highlighter_780067"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p></td><td><div><p><code>public</code> <code>static</code> <code>partial</code> <code>class</code> <code>Enumerable</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>static</code> <code>TSource[] ToArray&lt;TSource&gt;(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code> <code>IEnumerable&lt;TSource&gt; source)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>source </code><code>is</code> <code>IIListProvider&lt;TSource&gt; arrayProvider</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>? arrayProvider.ToArray()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: EnumerableHelpers.ToArray(source);</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>static</code> <code>List&lt;TSource&gt; ToList&lt;TSource&gt;(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code> <code>IEnumerable&lt;TSource&gt; source)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>source </code><code>is</code> <code>IIListProvider&lt;TSource&gt; listProvider </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>? listProvider.ToList() </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: </code><code>new</code> <code>List&lt;TSource&gt;(source);</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippets for <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/System.Linq/src/System/Linq/ToCollection.cs#L11">Enumerable.ToArray</a> and <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/System.Linq/src/System/Linq/ToCollection.cs#L23">Enumerable.ToList</a> were obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em> </p>



<p>Both methods start from an attempt to convert input <code>source</code> to <code>IIListProvider&lt;TSource&gt;</code> (lines: 7, 15) and since in benchmark input sequence is initialized as <code>int[]</code> array: </p>


<div><div id="highlighter_600700"><table><tbody><tr><td><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><div><p><code>[GlobalSetup]</code></p><p><code>public</code> <code>void</code> <code>Setup()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>this</code><code>.data = </code><code>new</code> <code>int</code><code>[</code><code>this</code><code>.N];</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>… and in .NET all arrays are descendants of <code>System.Array</code> class which <strong>doesn’t</strong> implement <code>IIListProvider&lt;T&gt;</code> interface – we can be sure that execution proceeds right to the <code>else</code> branch.  </p>



<h3>Stepping into Enumerable.ToArray “else” branch</h3>



<hr>



<p>The <code>else</code> branch of <code>Enumerable.ToArray</code> continues with a call to <code>EnumerableHelpers.ToArray</code> method:</p>


<div><div id="highlighter_750940"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p></td><td><div><p><code>internal</code> <code>static</code> <code>partial</code> <code>class</code> <code>EnumerableHelpers</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>internal</code> <code>static</code> <code>T[] ToArray&lt;T&gt;(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>IEnumerable&lt;T&gt; source)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(source </code><code>is</code> <code>ICollection&lt;T&gt; collection)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>count = collection.Count;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(count == 0)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>Array.Empty&lt;T&gt;();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>result = </code><code>new</code> <code>T[count];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>collection.CopyTo(result, arrayIndex: 0);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>result;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>builder = </code><code>new</code> <code>LargeArrayBuilder&lt;T&gt;(initialize: </code><code>true</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>builder.AddRange(source);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>builder.ToArray();</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs#L93">EnumerableHelpers.ToArray</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>Method starts with an attempt to convert input <code>source</code> to <code>ICollection&lt;T&gt;</code>. Successful conversion results into “happy path” where it allocates new array and copies all <code>source</code> (aliased as <code>collection</code>) items into it. </p>



<h3>Stepping into Enumerable.ToList “else” branch</h3>



<hr>



<p> The <code>else</code> branch of <code>Enumerable.ToList</code> continues with an instantiation of a new <code>List&lt;T&gt;</code> object with <code>source</code> passed as constructor argument:</p>


<div><div id="highlighter_380056"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p></td><td><div><p><code>internal</code> <code>static</code> <code>partial</code> <code>class</code> <code>EnumerableHelpers</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>List(IEnumerable&lt;T&gt; collection)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(collection </code><code>is</code> <code>ICollection&lt;T&gt; c)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>count = c.Count;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(count == 0)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_items = s_emptyArray;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_items = </code><code>new</code> <code>T[count];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>c.CopyTo(_items, 0);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_size = count;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_size = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_items = s_emptyArray;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>using</code> <code>(IEnumerator&lt;T&gt; en = collection!.GetEnumerator())</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>(en.MoveNext())</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Add(en.Current);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L61">List&lt;T&gt;</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>Method starts with the attempt to convert input <code>source</code> to <code>ICollection&lt;T&gt;</code>.  Successful conversion results into “happy path” where it allocates new array and copies all <code>source</code> (aliased as <code>collection</code>) items into it. </p>



<h3>Unexpected discovery</h3>



<hr>



<p>You might already noticed the reason why benchmark results are so close 🙂 If not let’s take another look at the benchmark setup:</p>


<div><div id="highlighter_588308"><table><tbody><tr><td><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><div><p><code>[GlobalSetup]</code></p><p><code>public</code> <code>void</code> <code>Setup()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>this</code><code>.data = </code><code>new</code> <code>int</code><code>[</code><code>this</code><code>.N];</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>Here we initialize sequence with <code>int[]</code> array. As was mentioned previously all arrays are descendants of <code>System.Array</code> class which <strong>does</strong> implement <code>ICollection&lt;T&gt;</code> interface. </p>



<p>So both <code>ToArray</code> and <code>ToList</code> methods basically do the same thing:</p>


<div><div id="highlighter_647473"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p></td><td><div><p><code>var</code> <code>array = </code><code>new</code> <code>T[collection.Count];</code></p><p><code>collection.CopyTo(array, 0);</code></p></div></td></tr></tbody></table></div></div>


<p>While this isn’t quite what one can expect from benchmark it is always important to know the edge cases. </p>



<h2>Benchmark #2</h2>



<hr>



<p>Let’s modify the benchmark to use <code>Enumerable.Range</code> method:</p>


<div><div id="highlighter_424961"><table><tbody><tr><td><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><div><p><code>[GlobalSetup]</code></p><p><code>public</code> <code>void</code> <code>Setup()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>this</code><code>.data = Enumerable.Range(0, </code><code>this</code><code>.N);</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>Executing this new benchmark on my machine produces the following results: </p>



<figure><table><thead><tr><th>Method</th><th>N</th><th>Mean</th><th>Gen 0</th><th>Gen 1</th><th>Allocated</th></tr></thead><tbody><tr><td>ToArray</td><td>10</td><td>15.56 ns</td><td>0.0153</td><td>–</td><td>64 B</td></tr><tr><td>ToList</td><td>10</td><td>31.97 ns</td><td>0.0229</td><td>–</td><td>96 B</td></tr><tr><td>ToArray</td><td>100</td><td>87.93 ns</td><td>0.1013</td><td>–</td><td>424 B</td></tr><tr><td>ToList</td><td>100</td><td>176.19 ns</td><td>0.1090</td><td>–</td><td>456 B</td></tr><tr><td>ToArray</td><td>1000</td><td>771.31 ns</td><td>0.9613</td><td>–</td><td>4024 B</td></tr><tr><td>ToList</td><td>1000</td><td>1,568.32 ns</td><td>0.9689</td><td>–</td><td>4056 B</td></tr><tr><td>ToArray</td><td>10000</td><td>7,296.05 ns</td><td>9.5215</td><td>0.0076</td><td>40024 B</td></tr><tr><td>ToList</td><td>10000</td><td>15,276.89 ns</td><td>9.5215</td><td>0.0153</td><td>40056 B</td></tr></tbody></table></figure>



<p>Wooow! These results looks amazing! Do you feel this? The feeling of uncovered conspiracy theory? 🙂 </p>



<p>Before starting the celebration… Have you noticed one very strange thing in these results?</p>



<p>Here is a union of two tables where (#1 are the results of the first benchmark and #2 are the results of current benchmark):</p>



<figure><table><thead><tr><th>Method</th><th>N</th><th>(#1) Mean</th><th>(#2) Mean </th><th>(#1) Allocated</th><th>(#2) Allocated</th></tr></thead><tbody><tr><td>ToArray</td><td>10</td><td>49.527 ns</td><td>15.56 ns</td><td>64 B</td><td>64 B</td></tr><tr><td>ToList</td><td>10</td><td>45.850 ns</td><td>31.97 ns</td><td>96 B</td><td>96 B</td></tr><tr><td>ToArray</td><td>100</td><td>82.490 ns</td><td>87.93 ns</td><td>424 B</td><td>424 B</td></tr><tr><td>ToList</td><td>100</td><td>78.811 ns</td><td>176.19 ns</td><td>456 B</td><td>456 B</td></tr><tr><td>ToArray</td><td>1000</td><td>324.100 ns</td><td>771.31 ns</td><td>4024 B</td><td>4024 B</td></tr><tr><td>ToList</td><td>1000</td><td>321.039 ns</td><td>1,568.32 ns</td><td>4056 B</td><td>4056 B</td></tr><tr><td>ToArray</td><td>10000</td><td>3,223.046 ns</td><td>7,296.05 ns</td><td>40024 B</td><td>40024 B</td></tr><tr><td>ToList</td><td>10000</td><td>3,278.019 ns</td><td>15,276.89 ns</td><td>40056 B</td><td>40056 B</td></tr></tbody></table></figure>



<p>Can you see it? Both benchmarks allocate absolutely the same amount of memory. This is suspicious because in <strong>“benchmark #1”</strong> we were allocating fixed size array for the entire input sequence which is a by the way a bare minimum of memory we could use to store the sequence, so any extra allocation (which definitely should happen in <strong>“benchmark #2”</strong>) should make a difference.</p>



<h3>Unexpected discovery #2</h3>



<hr>



<p>To better understand what is happening let’s see what is exactly returned by <code>Enumerable.Range</code> method:</p>


<div><div id="highlighter_170052"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p></td><td><div><p><code>public</code> <code>static</code> <code>partial</code> <code>class</code> <code>Enumerable</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>static</code> <code>IEnumerable&lt;</code><code>int</code><code>&gt; Range(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>start, </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>count)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>long</code> <code>max = ((</code><code>long</code><code>)start) + count - 1;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(count == 0)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>Empty&lt;</code><code>int</code><code>&gt;();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>new</code> <code>RangeIterator(start, count);</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/1083657c17b84248ea59896823f605ea63ce78a6/src/System.Linq/src/System/Linq/Range.cs#L12">Enumerable.Range</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>It returns a new instance of <code>RangeIterator</code> class which implements internal <code>IPartition&lt;T&gt;</code> interface:</p>


<div><div id="highlighter_865713"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><div><p><code>private</code> <code>sealed</code> <code>partial</code> <code>class</code> <code>RangeIterator </code></p><p><code>&nbsp;&nbsp;</code><code>: IPartition&lt;</code><code>int</code><code>&gt;</code></p><p><code>{</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/de38804d52f6b65f0f290b81383f01e6943a6d8f/src/System.Linq/src/System/Linq/Range.SpeedOpt.cs#L11">RangeIterator</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p> Which in turn extends <code>IIListProvider&lt;TElement&gt;</code> interface: </p>


<div><div id="highlighter_951117"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><div><p><code>internal</code> <code>interface</code> <code>IPartition&lt;TElement&gt; </code></p><p><code>&nbsp;&nbsp;</code><code>: IIListProvider&lt;TElement&gt;</code></p><p><code>{</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/1083657c17b84248ea59896823f605ea63ce78a6/src/System.Linq/src/System/Linq/IPartition.cs#L10">IPartition&lt;T&gt;</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>So basically the benchmark executes <code>ToArray</code> and <code>ToList</code> methods from <code>RangeIterator</code> class because now <code>source</code> is convertible to <code>IIListProvider&lt;TElement&gt;</code>:</p>


<div><div id="highlighter_507064"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p></td><td><div><p><code>public</code> <code>static</code> <code>partial</code> <code>class</code> <code>Enumerable</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>static</code> <code>TSource[] ToArray&lt;TSource&gt;(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code> <code>IEnumerable&lt;TSource&gt; source)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>source </code><code>is</code> <code>IIListProvider&lt;TSource&gt; arrayProvider</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>? arrayProvider.ToArray()</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: EnumerableHelpers.ToArray(source);</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>static</code> <code>List&lt;TSource&gt; ToList&lt;TSource&gt;(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>this</code> <code>IEnumerable&lt;TSource&gt; source)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>source </code><code>is</code> <code>IIListProvider&lt;TSource&gt; listProvider </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>? listProvider.ToList() </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: </code><code>new</code> <code>List&lt;TSource&gt;(source);</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippets for <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/System.Linq/src/System/Linq/ToCollection.cs#L11">Enumerable.ToArray</a> and <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/System.Linq/src/System/Linq/ToCollection.cs#L23">Enumerable.ToList</a> were obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>Implementation of <code>RangeIterator</code> clearly reveals the reason for such small memory footprint – both methods pre-allocate <code>int[]</code> and <code>List&lt;int&gt;</code>:</p>


<div><div id="highlighter_194830"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p></td><td><div><p><code>private</code> <code>sealed</code> <code>partial</code> <code>class</code> <code>RangeIterator : IPartition&lt;</code><code>int</code><code>&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>int</code><code>[] ToArray()</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code><code>[] array = </code><code>new</code> <code>int</code><code>[_end - _start];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>cur = _start;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>(</code><code>int</code> <code>i = 0; i != array.Length; ++i)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>array[i] = cur;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>++cur;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>array;</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>List&lt;</code><code>int</code><code>&gt; ToList()</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>List&lt;</code><code>int</code><code>&gt; list = </code><code>new</code> <code>List&lt;</code><code>int</code><code>&gt;(_end - _start);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>(</code><code>int</code> <code>cur = _start; cur != _end; cur++)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>list.Add(cur);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>list;</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/de38804d52f6b65f0f290b81383f01e6943a6d8f/src/System.Linq/src/System/Linq/Range.SpeedOpt.cs#L11">RangeIterator</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>This benchmark demonstrates one very important moment – you never know where optimization is. </p>



<h2>Benchmark #3</h2>



<hr>



<p>Let’s modify the benchmark to use compiler generated iterator:</p>


<div><div id="highlighter_650750"><table><tbody><tr><td><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p></td><td><div><p><code>[GlobalSetup]</code></p><p><code>public</code> <code>void</code> <code>Setup()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>this</code><code>.data = </code><code>this</code><code>.GetEnumerable();</code></p><p><code>}</code></p><p><code>private</code> <code>IEnumerable&lt;</code><code>int</code><code>&gt; GetEnumerable()</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>for</code> <code>(</code><code>var</code> <code>i = 0; i &lt; </code><code>this</code><code>.N; ++i)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>yield</code> <code>return</code> <code>i;</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>Executing this new benchmark on my machine produces the following results:  </p>



<figure><table><thead><tr><th>Method</th><th>N</th><th>Mean</th><th>Gen 0</th><th>Gen 1</th><th>Allocated</th></tr></thead><tbody><tr><td>ToArray</td><td>10</td><td>185.7 ns</td><td>0.0610</td><td>–</td><td>256 B</td></tr><tr><td>ToList</td><td>10</td><td>142.7 ns</td><td>0.0610</td><td>–</td><td>256 B</td></tr><tr><td>ToArray</td><td>100</td><td>804.8 ns</td><td>0.2842</td><td>–</td><td>1192 B</td></tr><tr><td>ToList</td><td>100</td><td>761.6 ns</td><td>0.2918</td><td>–</td><td>1224 B</td></tr><tr><td>ToArray</td><td>1000</td><td>5,890.1 ns</td><td>2.0370</td><td>–</td><td>8536 B</td></tr><tr><td>ToList</td><td>1000</td><td>5,770.2 ns</td><td>2.0218</td><td>–</td><td>8464 B</td></tr><tr><td>ToArray</td><td>10000</td><td>56,033.2 ns</td><td>25.2686</td><td>–</td><td>106224 B</td></tr><tr><td>ToList</td><td>10000</td><td>59,923.0 ns</td><td>31.1890</td><td>10.3760</td><td>131440 B</td></tr></tbody></table></figure>



<p>These results looks much more realistic. However there is no absolute winner here but rather a sign to continue our journey (there is no obvious explanation of such a significant difference in <strong>Allocated</strong> column in last benchmark). </p>



<p>Because compiler generated iterator doesn’t implement neither <code>ICollection&lt;T&gt;</code> nor <code>IListProvider&lt;T&gt;</code> interfaces we now can be sure these results are produced by this piece of <code>EnumerableHelpers.ToArray</code> method:</p>


<div><div id="highlighter_617483"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p></td><td><div><p><code>internal</code> <code>static</code> <code>partial</code> <code>class</code> <code>EnumerableHelpers</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>internal</code> <code>static</code> <code>T[] ToArray&lt;T&gt;(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>IEnumerable&lt;T&gt; source)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>var</code> <code>builder = </code><code>new</code> <code>LargeArrayBuilder&lt;T&gt;(initialize: </code><code>true</code><code>);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>builder.AddRange(source);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>builder.ToArray();</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/8750960d3fafa46a9b838c351e995a01fa8b599f/src/Common/src/System/Collections/Generic/EnumerableHelpers.Linq.cs#L93">EnumerableHelpers.ToArray</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>… and this piece of <code>List&lt;T&gt;</code> constructor:</p>


<div><div id="highlighter_861940"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p></td><td><div><p><code>public</code> <code>List(IEnumerable&lt;T&gt; collection)</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>if</code> <code>(collection </code><code>is</code> <code>ICollection&lt;T&gt; c)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_size = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_items = s_emptyArray;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>using</code> <code>(IEnumerator&lt;T&gt; en = collection!.GetEnumerator())</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>(en.MoveNext())</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Add(en.Current);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L61">List&lt;T&gt;</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>To better understand results of last benchmark we need to find out how exactly <code>LargeArrayBuilder&lt;T&gt;</code> and <code>List&lt;T&gt;</code> allocate memory.</p>



<h3>How LargeArrayBuilder&lt;T&gt; allocate?</h3>



<hr>



<p><code>LargeArrayBuilder&lt;T&gt;</code> is an internal struct used to create dynamically sized arrays. On the high-level what it does is it allocates multiple fixed sized arrays to store input items and then combines them into single array. This high-level overview is mostly enough to understand the big picture but in our case details are important. </p>



<p>The <code>EnumerableHelpers.ToArray</code> method invokes the following <code>LargeArrayBuilder&lt;T&gt;</code> methods:</p>



<ul><li><code>LargeArrayBuilder(initialize: true)</code></li><li><code>LargeArrayBuilder&lt;T&gt;.AddRange(source)</code></li><li><code>LargeArrayBuilder&lt;T&gt;.ToArray()</code></li></ul>



<p>Let’s see what each of these invocations does.</p>



<h4>LargeArrayBuilder(initialize: true)</h4>



<hr>



<p>All instances of <code>LargeArrayBuilder&lt;T&gt;</code> structure are initialized with some maximum capacity value. This value limits the amount of memory instance can consume. In our case new instance is initialized with <code>int.MaxValue</code> value:</p>


<div><div id="highlighter_982649"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p></td><td><div><p><code>internal</code> <code>struct</code> <code>LargeArrayBuilder&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>const</code> <code>int</code> <code>StartingCapacity = 4;</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>const</code> <code>int</code> <code>ResizeLimit = 8;</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>readonly</code> <code>int</code> <code>_maxCapacity;&nbsp; </code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>T[] _first;&nbsp;&nbsp; </code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>ArrayBuilder&lt;T[]&gt; _buffers; </code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>T[] _current;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>int</code> <code>_index;</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>int</code> <code>_count;</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>LargeArrayBuilder(</code><code>bool</code> <code>initialize)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: </code><code>this</code><code>(maxCapacity: </code><code>int</code><code>.MaxValue)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>LargeArrayBuilder(</code><code>int</code> <code>maxCapacity)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: </code><code>this</code><code>()</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_first = _current = Array.Empty&lt;T&gt;();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_maxCapacity = maxCapacity;</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L30">LargeArrayBuilder&lt;T&gt;</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>Beside maximum capacity <code>LargeArrayBuider&lt;T&gt;</code> struct has a bunch of private fields and constants. </p>



<p>Let’s see what each of them does:</p>



<figure><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td><strong>ResizeLimit</strong></td><td>Integer constant, has value of 8.</td></tr><tr><td><strong>StartingCapacity</strong></td><td>Integer constant, has value of 4.</td></tr><tr><td><strong>_maxCapacity</strong> </td><td>The maximum capacity builder can have. </td></tr><tr><td><strong>_first</strong> </td><td>The first buffer items are stored in. Resized until <code>ResizeLimit</code>. </td></tr><tr><td><strong>_buffers</strong> </td><td>After <code>ResizeLimit * 2</code>, previously filled out buffers are stored here. </td></tr><tr><td><strong>_current</strong> </td><td>Currently filling buffer. If <code>_count &lt;= ResizeLimit</code>, this is <code>_first</code>. </td></tr><tr><td><strong>_index</strong>  </td><td>Index into the current buffer. </td></tr><tr><td><strong>_count</strong> </td><td>Count of all of the items in this builder. </td></tr></tbody></table></figure>



<h4>LargeArrayBuilder&lt;T&gt;.AddRange(source)</h4>



<hr>



<p>The next stop is <code>LargeArrayBuilder&lt;T&gt;.AddRange</code> method. This method iterates over input sequence and stores items in current buffer (aliased as <code>destination</code> (line: 8)): </p>


<div><div id="highlighter_279083"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p></td><td><div><p><code>internal</code> <code>struct</code> <code>LargeArrayBuilder&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>void</code> <code>AddRange(IEnumerable&lt;T&gt; items)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>using</code> <code>(IEnumerator&lt;T&gt; enumerator = items.GetEnumerator())</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>T[] destination = _current;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>index = _index;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>(enumerator.MoveNext())</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>T item = enumerator.Current;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>((</code><code>uint</code><code>)index &gt;= (</code><code>uint</code><code>)destination.Length)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AddWithBufferAllocation(item, </code><code>ref</code> <code>destination, </code><code>ref</code> <code>index);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>destination[index] = item;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>index++;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_count += index - _index;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_index = index;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L30">LargeArrayBuilder&lt;T&gt;.AddRange</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>When current buffer is filled out (line: 14) control is passed to <code>LargeArrayBuilder&lt;T&gt;.AddWithBufferAllocation</code> method (line: 16):  </p>


<div><div id="highlighter_12384"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p></td><td><div><p><code>internal</code> <code>struct</code> <code>LargeArrayBuilder&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>void</code> <code>AddWithBufferAllocation(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>T item, </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ref</code> <code>T[] destination, </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ref</code> <code>int</code> <code>index)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_count += index - _index;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_index = index;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AllocateBuffer();</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L141">LargeArrayBuilder&lt;T&gt;.AddWithBufferAllocation</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>This method increases count of items stored in builder by number of items filled in the current buffer (line: 9) and calls <code>LargeArrayBuilder&lt;T&gt;.AllocateBuffer</code> method (line: 11): </p>


<div><div id="highlighter_988478"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p></td><td><div><p><code>internal</code> <code>struct</code> <code>LargeArrayBuilder&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>void</code> <code>AllocateBuffer()</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>((</code><code>uint</code><code>)_count &lt; (</code><code>uint</code><code>)ResizeLimit)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{&nbsp; </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>nextCapacity = Math.Min(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_count == 0 ? StartingCapacity : _count * 2,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_maxCapacity);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_current = </code><code>new</code> <code>T[nextCapacity];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Array.Copy(_first, 0, _current, 0, _count);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_first = _current;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>nextCapacity;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(_count == ResizeLimit)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>nextCapacity = ResizeLimit;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_buffers.Add(_current);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>nextCapacity = Math.Min(_count, _maxCapacity - _count);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_current = </code><code>new</code> <code>T[nextCapacity];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_index = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L141">LargeArrayBuilder&lt;T&gt;.AllocateBuffer</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>The <code>LargeArrayBuilder&lt;T&gt;.AllocateBuffer</code> method is responsible for allocating a new buffer. However, what exactly this method does depends on the current count of items stored in builder:</p>



<ul><li>When adding <strong>1st</strong> item (<code>_count == 0</code>) it allocates buffer of <code>StartingCapacity</code> size (which is 4) and stores it in <code>_first</code> and <code>_current</code> fields. This buffer is used to store first 4 items (lines: 9-15).</li><li>When adding <strong>5th</strong> item (<code>_count == 4</code>) it allocates buffer of <code>StartingCapacity * 2</code> (which is 8) size and stores it in <code>_first</code> and <code>_current</code> fields. The items from previous buffer are copied into new buffer. This buffer is used to store first 8 items (lines: 9-15).</li><li>When adding <strong>9th</strong> item (<code>_count == 8</code>) it allocates buffer of <code>ResizeLimit</code> size (which is 8) and stores it in <code>_current</code> field while leaving previous buffer in the <code>_first</code> field. This new buffer is used to store next 8 items (lines: 22, 29).</li><li>When adding <strong>more </strong>items (<code>_count &gt; 8</code>) they are stored in <code>_current</code> buffer. When <code>_current</code> buffer becomes full it is pushed into <code>_buffers</code> list and new buffer of <code>_count</code> size is allocated. This buffer is stored in <code>_current</code> field and used to store next <code>_count</code> items (lines: 26-27, 29).</li></ul>



<p>On return <code>LargeArrayBuilder&lt;T&gt;.AddWithBufferAllocation</code> aliases current buffer (line: 11) and current index (line: 12) as <code>destination</code> and <code>index</code> and stores new item in current buffer (line: 13):</p>


<div><div id="highlighter_512412"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p></td><td><div><p><code>internal</code> <code>struct</code> <code>LargeArrayBuilder&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>void</code> <code>AddWithBufferAllocation(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>T item, </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ref</code> <code>T[] destination, </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>ref</code> <code>int</code> <code>index)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AllocateBuffer();</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>destination = _current;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>index = _index;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_current[index] = item;</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/f7539b726c4bc2385b7f49e5751c1cff2f2c7368/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L141">LargeArrayBuilder&lt;T&gt;.AddWithBufferAllocation</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>This way execution continues until the end of input sequence. </p>



<p>Looks a bit complicated? Let’s take a small example to see how this works for a sequence of 20 items:</p>



<figure><table><thead><tr><th>Item #</th><th>Trace</th><th>_count</th><th>_first</th><th>_current</th><th>_buffers</th></tr></thead><tbody><tr><td>1</td><td><em>4 items buffer allocated (new T1[4])<br>1 item stored in T1[0]<br></em>_<br><em>3 items to store</em></td><td>0</td><td>T1[4]</td><td>T1[4]</td><td>(empty) </td></tr><tr><td>2-4</td><td><em>Storing items in T1[1]-T1[3]</em></td><td>1-4</td><td>–</td><td>–</td><td>–</td></tr><tr><td>5</td><td><em>8 items buffer allocated (new T2[8])<br>4 items copied from T1[0-3] to T2[0-3]<br>1 item stored in T2[4]<br></em>_<br><em>3 items to store</em></td><td>4</td><td>T2[8]</td><td>T2[8]</td><td>(empty) </td></tr><tr><td>6-8</td><td><em>Storing items in T2[5]-T2[7]</em></td><td>5-8</td><td>–</td><td>–</td><td>–</td></tr><tr><td>9</td><td><em>8 items buffer allocated (new T3[8])<br>1 item stored in T3[0]<br>_<br>7 items to store</em></td><td>8</td><td>T2[8]</td><td>T3[8]</td><td>(empty)</td></tr><tr><td>10-16</td><td><em>Storing items in T3[1]-T3[7]</em> </td><td>9-16</td><td>–</td><td>–</td><td>–</td></tr><tr><td>17</td><td><em>16 items buffer allocated (new T4[16])<br>1 buffer stored (T3)<br>1 item stored in T4[0]<br>_<br>15 items to store</em></td><td>16</td><td>T2[8]</td><td>T4[16]</td><td>(T3[8])</td></tr><tr><td>18-20</td><td><em>Storing items in T4[1]-T4[3] </em></td><td>17-20</td><td>–</td><td>–</td><td>–</td></tr><tr><td>20</td><td><em>12 items to store</em></td><td>20</td><td>T2[8] </td><td>T4[16] </td><td>(T3[8]) </td></tr></tbody><tfoot><tr><td><strong>Total</strong></td><td><strong>4 buffers allocated</strong><br><strong>1 buffers stored<br>36 item allocated</strong></td><td></td><td></td><td></td><td> </td></tr></tfoot></table></figure>



<p>As you can see storing sequence of 20 items requires <code>LargeArrayBuilder&lt;T&gt;</code> to allocate memory for 36 items (almost twice as more!). At first glance this may look quite inefficient, however before blaming <code>LargeArrayBuilder&lt;T&gt;</code> in inefficiency you should note that <strong>it will allocate the same 36 items for any input sequence of 17 to 32 items inclusively</strong>.</p>



<p>Now the questions is – How many items it will allocate for sequences of 100, 1000 or 10000 items? </p>



<p>We obviously can’t draw a table for such large sequences (we can but this isn’t a productive way of doing things) but we can calculate this as sum of capacities of all allocated buffers. </p>



<p>We already know how <code>LargeArrayBuilder&lt;T&gt;</code> allocates new buffers, so we can express last current buffer capacity <em>(hereinafter C)</em> as function of input sequence length <em>(hereinafter S)</em>:</p>



<p><img src="https://s0.wp.com/latex.php?latex=C+%3D+f%28S%29+%5Crightarrow+%5Cbegin%7Bcases%7D+4%2C+%26+S+%5Cgeq+1+%5Ctext%7B+and+%7D+S+%5Cleq+4+%5C%5C+8%2C+%26S+%3E+4+%5Ctext%7B+and+%7D+S+%5Cleq+8+%5C%5C+8+%5Ctimes+2%5E%7Bn+-+1%7D%2C+%26S+%3E+8+%5Cend%7Bcases%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C = f(S) \rightarrow \begin{cases} 4, &amp; S \geq 1 \text{ and } S \leq 4 \\ 8, &amp;S > 4 \text{ and } S \leq 8 \\ 8 \times 2^{n - 1}, &amp;S > 8 \end{cases}" title="C = f(S) \rightarrow \begin{cases} 4, &amp; S \geq 1 \text{ and } S \leq 4 \\ 8, &amp;S > 4 \text{ and } S \leq 8 \\ 8 \times 2^{n - 1}, &amp;S > 8 \end{cases}"> </p>



<p>Third case represents capacity as <em>n-th</em> term of <a href="https://en.wikipedia.org/wiki/Geometric_progression">geometric progression</a> where <em>8 </em>is a <em>scale factory</em> and <em>2 </em>is a <em>common ratio</em>. Such representation is possible because when <code>_count</code> exceeds <code>ResizeLimit</code> value (which is 8) new buffer’s capacity is chosen to be equal to <code>_count</code> value which leads to a doubling of the capacity of each subsequent buffer allocation. This allows us to represent all possible capacity values as geometric progression.</p>



<p>Allocating same amount of items as we have already stored leads to another interesting effect – capacity of the last current buffer (<em>hereinafter </em><img src="https://s0.wp.com/latex.php?latex=C_l&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l" title="C_l">) should be enough to store at least half of the input sequence:</p>



<p><img src="https://s0.wp.com/latex.php?latex=C_l+%5Cgeq+S+%5Cdiv+2&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l \geq S \div 2" title="C_l \geq S \div 2"> </p>



<p>Replacing <img src="https://s0.wp.com/latex.php?latex=C_l&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l" title="C_l"> with a formula for <em>n-th</em> term:</p>



<p><img src="https://s0.wp.com/latex.php?latex=8+%5Ctimes+2%5E%7Bn+-+1%7D+%5Cgeq+S+%5Cdiv+2&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="8 \times 2^{n - 1} \geq S \div 2" title="8 \times 2^{n - 1} \geq S \div 2"> </p>



<p>Now we can express <em>n</em> – a position term representing capacity of last current buffer which also equals to count of buffers allocated after <code>_count</code> exceeds <code>ResizeLimit</code>:</p>



<p><img src="https://s0.wp.com/latex.php?latex=n+%3D+%5Cdfrac%7B%5Cln%28S+%5Cdiv+16%29%7D%7B%5Cln%282%29%7D+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n = \dfrac{\ln(S \div 16)}{\ln(2)} + 1" title="n = \dfrac{\ln(S \div 16)}{\ln(2)} + 1"> </p>



<p>Here is a step by step explanation (feel free to skip is solutions is obvious to you):</p>



<div><div>
<div><div>
<p><strong>Equation</strong></p>



<p><img src="https://s0.wp.com/latex.php?latex=8+%5Ctimes+2%5E%7Bn+-+1%7D+%5Cgeq+S+%5Cdiv+2&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="8 \times 2^{n - 1} \geq S \div 2" title="8 \times 2^{n - 1} \geq S \div 2"> </p>
</div></div>



<div><div>
<p><strong>Solution</strong></p>



<p>Divide both sides by <em>8</em>:</p>



<p><img src="https://s0.wp.com/latex.php?latex=2%5E%7Bn+-+1%7D+%3D+S+%5Cdiv+16&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="2^{n - 1} = S \div 16" title="2^{n - 1} = S \div 16"></p>



<p>Then take <img src="https://s0.wp.com/latex.php?latex=%5Clog_%7B2%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\log_{2}" title="\log_{2}"> of both sides:</p>



<p><img src="https://s0.wp.com/latex.php?latex=%5Clog_%7B2%7D%282%5E%7Bn+-+1%7D%29+%3D+%5Clog_%7B2%7D%28S+%5Cdiv+16%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\log_{2}(2^{n - 1}) = \log_{2}(S \div 16)" title="\log_{2}(2^{n - 1}) = \log_{2}(S \div 16)"></p>



<p>Now use the property of logarithms (<a href="https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:logs/x2ec2f6f830c9fb89:log-prop/a/properties-of-logarithms">power rule</a>) to simplify the left side:</p>



<p><img src="https://s0.wp.com/latex.php?latex=%28n+-+1%29+%5Ctimes+%5Clog_%7B2%7D%282%29+%3D+%5Clog_%7B2%7D%28S+%5Cdiv+16%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="(n - 1) \times \log_{2}(2) = \log_{2}(S \div 16)" title="(n - 1) \times \log_{2}(2) = \log_{2}(S \div 16)"></p>



<p>Because <img src="https://s0.wp.com/latex.php?latex=%5Clog_%7B2%7D%282%29+%3D+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\log_{2}(2) = 1" title="\log_{2}(2) = 1">, remove it:</p>



<p><img src="https://s0.wp.com/latex.php?latex=n+-+1+%3D+%5Clog_%7B2%7D%28S+%5Cdiv+16%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n - 1 = \log_{2}(S \div 16)" title="n - 1 = \log_{2}(S \div 16)"></p>



<p>Increment both sides by <em>1</em>:</p>



<p><img src="https://s0.wp.com/latex.php?latex=n+%3D+%5Clog_%7B2%7D%28S+%5Cdiv+16%29+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n = \log_{2}(S \div 16) + 1" title="n = \log_{2}(S \div 16) + 1"> </p>



<p>And <a href="https://www.khanacademy.org/math/algebra2/x2ec2f6f830c9fb89:logs/x2ec2f6f830c9fb89:change-of-base/a/logarithm-change-of-base-rule-intro">change logarithm base</a> from <em>2</em> to <em>e</em>:</p>



<p><img src="https://s0.wp.com/latex.php?latex=n+%3D+%5Cdfrac%7B%5Cln%28S+%5Cdiv+16%29%7D%7B%5Cln%282%29%7D+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n = \dfrac{\ln(S \div 16)}{\ln(2)} + 1" title="n = \dfrac{\ln(S \div 16)}{\ln(2)} + 1"></p>
</div></div>




</div></div>



<p>Now we need to address a very important moment – because allocated buffer store multiple items the above formula should return the same <em>n</em> for a range of sequence lengths (i.e. it should return the same result for sequence of 9 to 16 items).</p>



<p>Such behavior can be achieved by <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions">ceiling</a> rational parts or the equation:</p>



<p><img src="https://s0.wp.com/latex.php?latex=n+%3D+%5Cbigg%5Clceil%5Cdfrac%7B%5Cln%28%5Clceil+S+%5Cdiv+16+%5Crceil%29%7D%7B%5Cln%282%29%7D%5Cbigg%5Crceil+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="n = \bigg\lceil\dfrac{\ln(\lceil S \div 16 \rceil)}{\ln(2)}\bigg\rceil + 1" title="n = \bigg\lceil\dfrac{\ln(\lceil S \div 16 \rceil)}{\ln(2)}\bigg\rceil + 1"></p>



<p>Using <em>n</em> we now can express <strong>total count of buffers allocated</strong>, <strong>total count of items allocated</strong> and <strong>total count of buffers stored</strong> values:</p>



<p><strong>Total count of buffers allocated</strong></p>



<p><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bbuffers+allocated%7D+%3D+%5Cbegin%7Bcases%7D+1%2C+%26S+%5Cgeq+1+%5Ctext%7B+and+%7D+S+%5Cleq+4+%5C%5C+2%2C+%26S+%3E+4+%5Ctext%7B+and+%7D+S+%5Cleq+8+%5C%5C+2+%2B+n%2C+%26S+%3E+8+%5Cend%7Bcases%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{buffers allocated} = \begin{cases} 1, &amp;S \geq 1 \text{ and } S \leq 4 \\ 2, &amp;S > 4 \text{ and } S \leq 8 \\ 2 + n, &amp;S > 8 \end{cases}" title="T_\text{buffers allocated} = \begin{cases} 1, &amp;S \geq 1 \text{ and } S \leq 4 \\ 2, &amp;S > 4 \text{ and } S \leq 8 \\ 2 + n, &amp;S > 8 \end{cases}"> </p>



<blockquote><p>The case for <img src="https://s0.wp.com/latex.php?latex=S+%3E+8&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="S > 8" title="S > 8"> is how many buffers was allocated after 8th item plus number of previously allocated buffers.</p><cite>Author’s note</cite></blockquote>



<p><strong>Total count of items allocated</strong></p>



<p><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bitems+allocated%7D+%3D+%5Cbegin%7Bcases%7D+4%2C+%26S+%5Cgeq+1+%5Ctext%7B+and+%7D+S+%5Cleq+4+%5C%5C+12%2C+%26S+%3E+4+%5Ctext%7B+and+%7D+S+%5Cleq+8+%5C%5C+12+%2B+%28-8+%5Ctimes+%281-2%5En%29%29%2C+%26S+%3E+8+%5Cend%7Bcases%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{items allocated} = \begin{cases} 4, &amp;S \geq 1 \text{ and } S \leq 4 \\ 12, &amp;S > 4 \text{ and } S \leq 8 \\ 12 + (-8 \times (1-2^n)), &amp;S > 8 \end{cases}" title="T_\text{items allocated} = \begin{cases} 4, &amp;S \geq 1 \text{ and } S \leq 4 \\ 12, &amp;S > 4 \text{ and } S \leq 8 \\ 12 + (-8 \times (1-2^n)), &amp;S > 8 \end{cases}">  </p>



<blockquote><p>The case for <img src="https://s0.wp.com/latex.php?latex=S+%3E+8&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="S > 8" title="S > 8"> is a <a href="https://en.wikipedia.org/wiki/Geometric_progression#Geometric_series">sum of geometric progression</a> plus count of previously allocated items.</p><cite>Author’s note</cite></blockquote>



<p><strong>Total count of buffers stored</strong></p>



<p><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bbuffers+stored%7D+%3D+%5Cbegin%7Bcases%7D+0%2C+%26S+%5Cgeq+1+%5Ctext%7B+and+%7D+S+%5Cleq+16+%5C%5C+n+-+1%2C+%26S+%3E+16+%5Cend%7Bcases%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{buffers stored} = \begin{cases} 0, &amp;S \geq 1 \text{ and } S \leq 16 \\ n - 1, &amp;S > 16 \end{cases}" title="T_\text{buffers stored} = \begin{cases} 0, &amp;S \geq 1 \text{ and } S \leq 16 \\ n - 1, &amp;S > 16 \end{cases}"> </p>



<blockquote><p>The last case for <img src="https://s0.wp.com/latex.php?latex=S+%3E+16&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="S > 16" title="S > 16"> is <em>how many buffers was allocated</em> after 8th item minus currently active buffer.</p><cite>Author’s note</cite></blockquote>



<p>Here are the calculations for benchmark sequences:</p>



<figure><table><thead><tr><th>Sequence length </th><th>Total<br>count of buffers<br>allocated</th><th>Total<br>count of items<br>allocated</th><th>Total<br>count of buffers stored</th></tr></thead><tbody><tr><td>10</td><td>3</td><td>20</td><td>0</td></tr><tr><td>100</td><td>6</td><td>132</td><td>3</td></tr><tr><td>1000</td><td>9</td><td>1028</td><td>6</td></tr><tr><td>10000</td><td>13</td><td>16388</td><td>10</td></tr></tbody></table></figure>



<h4>LargeArrayBuilder&lt;T&gt;.ToArray()</h4>



<hr>



<p>The <code>LargeArrayBuilder&lt;T&gt;.ToArray</code> method is responsible for allocating final array (line: 7) and coping buffered items to it (line: 8). The copy part is delegated to <code>LargeArrayBuilder&lt;T&gt;.CopyTo</code> method:</p>


<div><div id="highlighter_27085"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p></td><td><div><p><code>internal</code> <code>struct</code> <code>LargeArrayBuilder&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>T[] ToArray()</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>array = </code><code>new</code> <code>T[_count];</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>CopyTo(array, 0, _count);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>array;</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/1bb52e6a3db7f3673a3825f3677b9f27b9af99aa/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L266">LargeArrayBuilder&lt;T&gt;.ToArray</a> and is obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p><code>LargeArrayBuilder&lt;T&gt;.CopyTo</code> method is very straightforward. It iterates over all allocated buffers and copies items to input array. Correct buffer is selected using <code>LargeArrayBuilder&lt;T&gt;.GetBuffer</code> method: </p>


<div><div id="highlighter_448649"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p></td><td><div><p><code>internal</code> <code>struct</code> <code>LargeArrayBuilder&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>void</code> <code>CopyTo(T[] array, </code><code>int</code> <code>arrayIndex, </code><code>int</code> <code>count)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>(</code><code>int</code> <code>i = 0; count &gt; 0; i++)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>T[] buffer = GetBuffer(index: i);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>toCopy = Math.Min(count, buffer.Length);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Array.Copy(buffer, 0, array, arrayIndex, toCopy);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>count -= toCopy;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>arrayIndex += toCopy;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>T[] GetBuffer(</code><code>int</code> <code>index)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>index == 0 </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>? _first</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: index &lt;= _buffers.Count </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>? _buffers[index - 1] </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: _current;</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippets for <a href="https://github.com/dotnet/corefx/blob/1bb52e6a3db7f3673a3825f3677b9f27b9af99aa/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L157">LargeArrayBuilder&lt;T&gt;.CopyTo</a> and <a href="https://github.com/dotnet/corefx/blob/1bb52e6a3db7f3673a3825f3677b9f27b9af99aa/src/Common/src/System/Collections/Generic/LargeArrayBuilder.SpeedOpt.cs#L243">LargeArrayBuilder&lt;T&gt;.GetBuffer</a> were obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<h4>Summing up</h4>



<hr>



<p>Knowledge of how <code>LargeArrayBuilder&lt;T&gt;</code> allocates memory allows us to estimate how much memory will be required to build an array depending on input sequence length:</p>



<p><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7D+T_%5Ctext%7Bestimated%7D+%3D+V_%5Ctext%7Bbuffers%7D+%2B+V_%5Ctext%7Bfinal+array%7D+%5Cend%7Baligned%7D+%5C%5C%5C%5C%5C%5C+%5Cbegin%7Baligned%7D+%5Ctext%7Bwhere%7D%5C+%26T_%5Ctext%7Bestimated%7D+%26%26-%5C+%5Ctext%7Bis+the+estimated+amount+of+memory+required+in+bytes%7D+%5C%5C+%26V_%5Ctext%7Bbuffers%7D+%26%26-%5C+%5Ctext%7Bis+the+amount+of+memory+required+to+hold+all+buffers%7D+%5C%5C+%26V_%5Ctext%7Bfinal+array%7D+%26%26-%5C+%5Ctext%7Bis+the+amount+of+memory+required+to+hold+final+array%7D+%5Cend%7Baligned%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned} T_\text{estimated} = V_\text{buffers} + V_\text{final array} \end{aligned} \\\\\\ \begin{aligned} \text{where}\ &amp;T_\text{estimated} &amp;&amp;-\ \text{is the estimated amount of memory required in bytes} \\ &amp;V_\text{buffers} &amp;&amp;-\ \text{is the amount of memory required to hold all buffers} \\ &amp;V_\text{final array} &amp;&amp;-\ \text{is the amount of memory required to hold final array} \end{aligned} " title="\begin{aligned} T_\text{estimated} = V_\text{buffers} + V_\text{final array} \end{aligned} \\\\\\ \begin{aligned} \text{where}\ &amp;T_\text{estimated} &amp;&amp;-\ \text{is the estimated amount of memory required in bytes} \\ &amp;V_\text{buffers} &amp;&amp;-\ \text{is the amount of memory required to hold all buffers} \\ &amp;V_\text{final array} &amp;&amp;-\ \text{is the amount of memory required to hold final array} \end{aligned} "> </p>



<p>Memory required to hold a single array instance is calculated as memory required to hold <code>System.Array</code> object plus memory required to hold all array elements:</p>



<p><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7DV_%5Ctext%7Barray%7D+%3D+V_%5Ctext%7Bobject%7D+%2B+N_%5Ctext%7Belements%7D+%5Ctimes+V_%7Belement%7D+%5Cend%7Baligned%7D+%5C%5C%5C%5C%5C%5C+%5Cbegin%7Baligned%7D+%5Ctext%7Bwhere%7D%5C+%26V_%5Ctext%7Bobject%7D+%26%26-%5C+%5Ctext%7Bis+the+size+of+object+in+bytes%7D+%5C%5C+%26V_%5Ctext%7Belement%7D+%26%26-%5C+%5Ctext%7Bis+the+size+of+array+element+in+bytes%7D+%5C%5C+%26N_%5Ctext%7Belements%7D+%26%26-%5C+%5Ctext%7Bis+the+number+of+elements+in+the+array%7D%5Cend%7Baligned%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned}V_\text{array} = V_\text{object} + N_\text{elements} \times V_{element} \end{aligned} \\\\\\ \begin{aligned} \text{where}\ &amp;V_\text{object} &amp;&amp;-\ \text{is the size of object in bytes} \\ &amp;V_\text{element} &amp;&amp;-\ \text{is the size of array element in bytes} \\ &amp;N_\text{elements} &amp;&amp;-\ \text{is the number of elements in the array}\end{aligned}" title="\begin{aligned}V_\text{array} = V_\text{object} + N_\text{elements} \times V_{element} \end{aligned} \\\\\\ \begin{aligned} \text{where}\ &amp;V_\text{object} &amp;&amp;-\ \text{is the size of object in bytes} \\ &amp;V_\text{element} &amp;&amp;-\ \text{is the size of array element in bytes} \\ &amp;N_\text{elements} &amp;&amp;-\ \text{is the number of elements in the array}\end{aligned}"> </p>



<p>Hence, the amount of memory required to hold all buffers can be expressed through  <strong>Total count of buffers allocated</strong> and<strong> Total count of items allocated</strong> values as:</p>



<p><img src="https://s0.wp.com/latex.php?latex=V_%5Ctext%7Bbuffers%7D+%3D+T_%5Ctext%7Bbuffers+allocated%7D+%5Ctimes+V_%5Ctext%7Bobject%7D+%2B+T_%5Ctext%7Bitems+allocated%7D+%5Ctimes+V_%5Ctext%7Belement%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="V_\text{buffers} = T_\text{buffers allocated} \times V_\text{object} + T_\text{items allocated} \times V_\text{element}" title="V_\text{buffers} = T_\text{buffers allocated} \times V_\text{object} + T_\text{items allocated} \times V_\text{element}"></p>



<p>… and amount of memory required to hold final array:</p>



<p><img src="https://s0.wp.com/latex.php?latex=V_%5Ctext%7Bfinal+array%7D+%3D+V_%5Ctext%7Bobject%7D+%2B+S+%5Ctimes+V_%5Ctext%7Belement%7D+%5C%5C%5C%5C%5C%5C+%5Ctext%7Bwhere%7D%5C+S+-%5C+%5Ctext%7Bis+the+length+of+the+input+sequence%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="V_\text{final array} = V_\text{object} + S \times V_\text{element} \\\\\\ \text{where}\ S -\ \text{is the length of the input sequence}" title="V_\text{final array} = V_\text{object} + S \times V_\text{element} \\\\\\ \text{where}\ S -\ \text{is the length of the input sequence}"> </p>



<p>So estimated amount of memory required to build an array can be expressed as:</p>



<p><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7DT_%5Ctext%7Bestimated%7D+%26%3D+T_%5Ctext%7Bbuffers+allocated%7D+%5Ctimes+V_%5Ctext%7Bobject%7D%5C+%2B+%5C%5C+%26%2B+T_%5Ctext%7Bitems+allocated%7D+%5Ctimes+V_%5Ctext%7Belement%7D%5C+%2B+%5C%5C+%26%2B++V_%5Ctext%7Bobject%7D+%2B+S+%5Ctimes+V_%5Ctext%7Belement%7D%5Cend%7Baligned%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned}T_\text{estimated} &amp;= T_\text{buffers allocated} \times V_\text{object}\ + \\ &amp;+ T_\text{items allocated} \times V_\text{element}\ + \\ &amp;+  V_\text{object} + S \times V_\text{element}\end{aligned}" title="\begin{aligned}T_\text{estimated} &amp;= T_\text{buffers allocated} \times V_\text{object}\ + \\ &amp;+ T_\text{items allocated} \times V_\text{element}\ + \\ &amp;+  V_\text{object} + S \times V_\text{element}\end{aligned}"></p>



<p>Considering the following values on 64 bit systems (in bytes): </p>



<p><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7D+%26V_%5Ctext%7Bobject%7D+%26%26%3D+24+%5C%5C++%26V_%5Ctext%7Belement%7D+%26%26%3D+%5Ctext%7Bsizeof%28int%29%7D+%5Crightarrow+4+%5Cend%7Baligned%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned} &amp;V_\text{object} &amp;&amp;= 24 \\  &amp;V_\text{element} &amp;&amp;= \text{sizeof(int)} \rightarrow 4 \end{aligned} " title="\begin{aligned} &amp;V_\text{object} &amp;&amp;= 24 \\  &amp;V_\text{element} &amp;&amp;= \text{sizeof(int)} \rightarrow 4 \end{aligned} "></p>



<p>The above formula can be simplified to:</p>



<p><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bestimated%7D+%3D+24+%5Ctimes+T_%5Ctext%7Bbuffers+allocated%7D+%2B+4+%5Ctimes+T_%5Ctext%7Bitems+allocated%7D+%2B+%284+%5Ctimes+S+%2B+24%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{estimated} = 24 \times T_\text{buffers allocated} + 4 \times T_\text{items allocated} + (4 \times S + 24)" title="T_\text{estimated} = 24 \times T_\text{buffers allocated} + 4 \times T_\text{items allocated} + (4 \times S + 24)"> </p>



<p>Beside memory allocated by instance of <code>LargeArrayBuilder&lt;T&gt;</code> benchmark results also include memory allocated by compiler generated enumerator (40 bytes on x64 system) and memory allocated by <code>ArrayBuilder&lt;T&gt;</code> structure (<code>_buffers</code> field). Because we don’t know how <code>ArrayBuilder&lt;T&gt;</code> allocates we can treat it’s allocations as estimation error, however because we know amount of memory consumed by compiler generated enumerator we should subtract its size from the benchmark results:</p>



<figure><table><thead><tr><th>Sequence length </th><th>Total count of  buffers allocated</th><th>Total count of items allocated</th><th>Total bytes<br>estimated</th><th>Total bytes<br>allocated (iterator adjusted) </th><th>Estimation error %</th></tr></thead><tbody><tr><td>10</td><td>3</td><td>20</td><td>216</td><td>216</td><td>0</td></tr><tr><td>100</td><td>6</td><td>132</td><td>1096</td><td>1152</td><td>0.0486</td></tr><tr><td>1000</td><td>9</td><td>1028</td><td>8352</td><td>8496</td><td>0.0169</td></tr><tr><td>10000</td><td>13</td><td>16388</td><td>105888</td><td>106184</td><td>0.0027</td></tr></tbody></table></figure>



<h3>How List&lt;T&gt; allocates?</h3>



<hr>



<p>When new instance of <code>List&lt;T&gt;</code> is created from the <code>IEnumerable&lt;T&gt;</code> (which isn’t <code>ICollection&lt;T&gt;</code>) all items from input sequence are sequentially added to empty <code>List&lt;T&gt;</code> instance (lines: 16-21):</p>


<div><div id="highlighter_852658"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p></td><td><div><p><code>public</code> <code>class</code> <code>List&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>List(IEnumerable&lt;T&gt; collection)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(collection </code><code>is</code> <code>ICollection&lt;T&gt; c)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_size = 0;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_items = s_emptyArray;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>using</code> <code>(IEnumerator&lt;T&gt; en = collection!.GetEnumerator())</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>(en.MoveNext())</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Add(en.Current);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p>*  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L61">List&lt;T&gt;</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>Items are added using <code>List&lt;T&gt;.Add</code> method:</p>


<div><div id="highlighter_639773"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p></td><td><div><p><code>public</code> <code>class</code> <code>List&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>public</code> <code>void</code> <code>Add(T item)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_version++;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>T[] array = _items;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>size = _size;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>((</code><code>uint</code><code>)size &lt; (</code><code>uint</code><code>)array.Length)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_size = size + 1;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>array[size] = item;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>AddWithResize(item);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>}&nbsp; </code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p> *  <em>the code snippet for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L203">List&lt;T&gt;.Add</a> was obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p>This method checks if there is enough capacity in the internal array to store new item (line: 9) and if not it switches execution to <code>List&lt;T&gt;.AddWithResize</code> method (line: 16): </p>


<div><div id="highlighter_172965"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p></td><td><div><p><code>public</code> <code>class</code> <code>List&lt;T&gt;</code></p><p><code>{</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>void</code> <code>AddWithResize(T item)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>size = _size;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>EnsureCapacity(size + 1);</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_size = size + 1;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>_items[size] = item;</code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>&nbsp;&nbsp;</code><code>private</code> <code>void</code> <code>EnsureCapacity(</code><code>int</code> <code>min)</code></p><p><code>&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(_items.Length &lt; min)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>{</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>int</code> <code>newCapacity = _items.Length == 0 </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>? DefaultCapacity </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>: _items.Length * 2;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>((</code><code>uint</code><code>)newCapacity &gt; Array.MaxArrayLength) </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>newCapacity = Array.MaxArrayLength;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>(newCapacity &lt; min) </code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>newCapacity = min;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>Capacity = newCapacity;</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>} </code></p><p><code>&nbsp;&nbsp;</code><code>}</code></p><p><code>}</code></p></div></td></tr></tbody></table></div></div>


<p> *  <em>the code snippets for <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L221">List&lt;T&gt;.AddWithResize</a> and <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L406">List&lt;T&gt;.EnsureCapacity</a> were obtained from&nbsp;<a href="https://github.com/dotnet/corefx">dotnet/corefx</a> repository</em></p>



<p><code>List&lt;T&gt;.AddWithResize</code> works in pair with <code>List&lt;T&gt;.EnsureCapacity</code> method: the latter ensure there will be enough space to store one more item by recalculating internal array capacity by either setting it to <code>List&lt;T&gt;.DefaultCapacity</code> (which is 4 items) in case when current internal array is empty array (line: 17) or by doubling current capacity value (line: 18). </p>



<blockquote><p>Internal array is reallocated inside of <a href="https://github.com/dotnet/corefx/blob/98db7d16ba21886901efbce6ea7b7e2b4ccec23c/src/Common/src/CoreLib/System/Collections/Generic/List.cs#L98">List&lt;T&gt;.Capacity</a> property setter. Besides array allocation it also copies items from old array to the new one. </p><cite>Author’s note</cite></blockquote>



<p>Looks quite simple. Right? I am sure it is, but still let’s take a small example and see how this works for a sequence of 20 items: </p>



<figure><table><thead><tr><th>Item #</th><th>Trace</th><th>Capacity</th></tr></thead><tbody><tr><td>1</td><td><em>4 items array allocated (T1[4])<br>1 item stored in T1[0]<br>–<br>3 items to store</em></td><td>4</td></tr><tr><td>2-4</td><td><em>Storing items in T1[1]-T1[3]</em></td><td>–</td></tr><tr><td>5</td><td><em>8 items array allocated (T2[8])<br>4 items copied from T1[0-3] to T2[0-3]<br>1 item stored in T2[4]<br>–<br>3 items to store</em></td><td>8</td></tr><tr><td>6-8</td><td><em>Storing items in T2[5]-T2[7] </em></td><td></td></tr><tr><td>9</td><td><em>16 items array allocated (T3[16])<br>8 items copied from T2[0-7] to T3[0-7]<br>1 item stored in T3[8]<br>–<br>7 items to store</em></td><td>16</td></tr><tr><td>10-16</td><td><em>Storing items in T3[9]-T2[15]  </em></td><td>–</td></tr><tr><td>17</td><td><em>32 items array allocated (T4[32])<br>16 items copied from T3[0-15] to T4[0-15]<br>1 item stored in T4[16]<br>–<br>15 items to store</em></td><td>32</td></tr><tr><td>18-20</td><td><em>Storing items in T4[17]-T4[19]  </em></td><td>–</td></tr></tbody><tfoot><tr><td><strong>Total</strong></td><td><strong>4 arrays allocated<br>60 items allocated</strong></td><td></td></tr></tfoot></table></figure>



<p>So <code>List&lt;T&gt;</code> allocates <strong>60 items</strong> in order to store 20 items. It is much more than <code>LargeArrayBuilder&lt;T&gt;</code>, which allocates 36 items for the same input. Before making any decisions let’s calculate how many internal arrays and items are allocated for sequences of 10, 100, 1000 and 10000 items. </p>



<p>This can be easily done because as you might already noticed – <code>List&lt;T&gt;</code> capacity is always doubled… which means it’s value can be expressed through geometric progression where <code>List&lt;T&gt;</code>‘s default capacity <em>4</em> is a <em>scale factor</em> and <em>2</em> is a <em>common ratio</em>:</p>



<p><img src="https://s0.wp.com/latex.php?latex=4%2C+4+%5Ctimes+2%2C+4+%5Ctimes+2%5E2%2C+4+%5Ctimes+2%5E3%2C+...%2C+etc&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="4, 4 \times 2, 4 \times 2^2, 4 \times 2^3, ..., etc" title="4, 4 \times 2, 4 \times 2^2, 4 \times 2^3, ..., etc"> </p>



<p>The <em>n</em> term of the progressions is calculated as: </p>



<p><img src="https://s0.wp.com/latex.php?latex=C_n+%3D+4+%5Ctimes+2%5E%7Bn+-+1%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_n = 4 \times 2^{n - 1}" title="C_n = 4 \times 2^{n - 1}"> </p>



<p>Because <code>List&lt;T&gt;</code>‘s internal array should be able to store all items stored in previous internal array we can say that last internal array capacity (<em>hereinafter </em><img src="https://s0.wp.com/latex.php?latex=C_l&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l" title="C_l">) should be at least enough to hold all sequence items:</p>



<p><img src="https://s0.wp.com/latex.php?latex=C_l+%5Cgeq+S&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l \geq S" title="C_l \geq S"></p>



<p>Replacing <img src="https://s0.wp.com/latex.php?latex=C_l&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="C_l" title="C_l"> with a formula for <em>n-th</em> term:</p>



<p><img src="https://s0.wp.com/latex.php?latex=4+%5Ctimes+2%5E%7Bn+-+1%7D+%5Cgeq+S&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="4 \times 2^{n - 1} \geq S" title="4 \times 2^{n - 1} \geq S"> </p>



<p> The <em>n</em> is then expressed as:</p>



<p><img src="https://s0.wp.com/latex.php?latex=4+%5Ctimes+2%5E%7Bn+-+1%7D+%5Cgeq+S+%5Crightarrow+n+%3D+%5Cbigg%5Clceil%5Cdfrac%7B%5Cln%28%5Clceil+S+%5Cdiv+4+%5Crceil%29%7D%7B%5Cln%282%29%7D%5Cbigg%5Crceil+%2B+1&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="4 \times 2^{n - 1} \geq S \rightarrow n = \bigg\lceil\dfrac{\ln(\lceil S \div 4 \rceil)}{\ln(2)}\bigg\rceil + 1" title="4 \times 2^{n - 1} \geq S \rightarrow n = \bigg\lceil\dfrac{\ln(\lceil S \div 4 \rceil)}{\ln(2)}\bigg\rceil + 1"> </p>



<blockquote><p>I won’t repeat the solution here. It is absolutely the same as we did for <code>LargeArrayBuilder&lt;T&gt;</code>.</p><cite>Author’s note</cite></blockquote>



<p>Using <em>n</em> we now can express <strong>total count of array allocated</strong> and <strong>total count of  items allocated</strong> values: </p>



<p><strong>Total count of arrays allocated</strong> is equal to:</p>



<p><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Barrays+allocated%7D+%3D+n&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{arrays allocated} = n" title="T_\text{arrays allocated} = n"></p>



<p><strong>Total count of items allocated</strong> is equal to:</p>



<p><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bitems+allocated%7D+%3D+-4+%5Ctimes+%281-2%5En%29&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{items allocated} = -4 \times (1-2^n)" title="T_\text{items allocated} = -4 \times (1-2^n)"></p>



<p>Here are the calculations for benchmark sequences: </p>



<figure><table><thead><tr><th> Sequence length </th><th>Total count of arrays allocated </th><th>Total count of items allocated </th></tr></thead><tbody><tr><td>10</td><td>3</td><td>28</td></tr><tr><td>100</td><td>6</td><td>252</td></tr><tr><td>1000</td><td>9</td><td>2044</td></tr><tr><td>10000</td><td>13</td><td>32764</td></tr></tbody></table></figure>



<p>We also can calculate <strong>exactly</strong> how much memory will be required to create <code>List&lt;T&gt;</code> depending on the input sequence length:</p>



<p><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7D+T_%5Ctext%7Bexact%7D+%3D+V_%5Ctext%7Barrays%7D+%2B+V_%5Ctext%7BList+of+T%7D+%5Cend%7Baligned%7D+%5C%5C%5C%5C%5C%5C+%5Cbegin%7Baligned%7D+%5Ctext%7Bwhere%7D%5C+%26T_%5Ctext%7Bexact%7D+%26%26-%5C+%5Ctext%7Bis+the+exact+amount+of+memory+required+in+bytes%7D+%5C%5C+%26V_%5Ctext%7Barrays%7D+%26%26-%5C+%5Ctext%7Bis+the+amount+of+memory+required+to+hold+all+arrays%7D+%5C%5C+%26V_%5Ctext%7BList+of+T%7D+%26%26-%5C+%5Ctext%7Bis+the+amount+of+memory+consumed+by+empty+List+of+T+object%7D%5Cend%7Baligned%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned} T_\text{exact} = V_\text{arrays} + V_\text{List of T} \end{aligned} \\\\\\ \begin{aligned} \text{where}\ &amp;T_\text{exact} &amp;&amp;-\ \text{is the exact amount of memory required in bytes} \\ &amp;V_\text{arrays} &amp;&amp;-\ \text{is the amount of memory required to hold all arrays} \\ &amp;V_\text{List of T} &amp;&amp;-\ \text{is the amount of memory consumed by empty List of T object}\end{aligned}" title="\begin{aligned} T_\text{exact} = V_\text{arrays} + V_\text{List of T} \end{aligned} \\\\\\ \begin{aligned} \text{where}\ &amp;T_\text{exact} &amp;&amp;-\ \text{is the exact amount of memory required in bytes} \\ &amp;V_\text{arrays} &amp;&amp;-\ \text{is the amount of memory required to hold all arrays} \\ &amp;V_\text{List of T} &amp;&amp;-\ \text{is the amount of memory consumed by empty List of T object}\end{aligned}"> </p>



<p>We already know how to calculate memory required to hold a single array instance:</p>



<p><img src="https://s0.wp.com/latex.php?latex=V_%5Ctext%7Barray%7D+%3D+V_%5Ctext%7Bobject%7D+%2B+N_%5Ctext%7Belements%7D+%5Ctimes+V_%7Belement%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="V_\text{array} = V_\text{object} + N_\text{elements} \times V_{element}" title="V_\text{array} = V_\text{object} + N_\text{elements} \times V_{element}"> </p>



<p>Hence, the amount of memory required to hold all arrays can be expressed through  <strong>Total count of allocated arrays</strong> and<strong> Total count of allocated items</strong> values as:</p>



<p><img src="https://s0.wp.com/latex.php?latex=V_%5Ctext%7Barrays%7D+%3D+T_%5Ctext%7Barrays+allocated%7D+%5Ctimes+V_%5Ctext%7Bobject%7D+%2B+T_%5Ctext%7Bitems+allocated%7D+%5Ctimes+V_%5Ctext%7Belement%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="V_\text{arrays} = T_\text{arrays allocated} \times V_\text{object} + T_\text{items allocated} \times V_\text{element}" title="V_\text{arrays} = T_\text{arrays allocated} \times V_\text{object} + T_\text{items allocated} \times V_\text{element}"></p>



<p>Hence, exact amount of memory required is:</p>



<p><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bexact%7D+%3D+T_%5Ctext%7Barrays+allocated%7D+%5Ctimes+V_%5Ctext%7Bobject%7D+%2B+T_%5Ctext%7Bitems+allocated%7D+%5Ctimes+V_%5Ctext%7Belement%7D+%2B+V_%5Ctext%7BList+of+T%7D&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{exact} = T_\text{arrays allocated} \times V_\text{object} + T_\text{items allocated} \times V_\text{element} + V_\text{List of T}" title="T_\text{exact} = T_\text{arrays allocated} \times V_\text{object} + T_\text{items allocated} \times V_\text{element} + V_\text{List of T}"></p>



<p>Considering the following values on 64 bit systems (in bytes): </p>



<p><img src="https://s0.wp.com/latex.php?latex=%5Cbegin%7Baligned%7D+%26V_%5Ctext%7Bobject%7D+%26%26%3D+24+%5C%5C++%26V_%5Ctext%7Belement%7D+%26%26%3D+%5Ctext%7Bsizeof%28int%29%7D+%5Crightarrow+4+%5C%5C+%26V_%5Ctext%7BList+of+T%7D+%26%26%3D+32%5Cend%7Baligned%7D+&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="\begin{aligned} &amp;V_\text{object} &amp;&amp;= 24 \\  &amp;V_\text{element} &amp;&amp;= \text{sizeof(int)} \rightarrow 4 \\ &amp;V_\text{List of T} &amp;&amp;= 32\end{aligned} " title="\begin{aligned} &amp;V_\text{object} &amp;&amp;= 24 \\  &amp;V_\text{element} &amp;&amp;= \text{sizeof(int)} \rightarrow 4 \\ &amp;V_\text{List of T} &amp;&amp;= 32\end{aligned} "></p>



<p>The above formula can be simplified to:</p>



<p><img src="https://s0.wp.com/latex.php?latex=T_%5Ctext%7Bexact%7D+%3D+24+%5Ctimes+T_%5Ctext%7Barrays+allocated%7D+%2B+4+%5Ctimes+T_%5Ctext%7Bitems+allocated%7D+%2B+32&amp;bg=ffffff&amp;fg=000000&amp;s=1" alt="T_\text{exact} = 24 \times T_\text{arrays allocated} + 4 \times T_\text{items allocated} + 32" title="T_\text{exact} = 24 \times T_\text{arrays allocated} + 4 \times T_\text{items allocated} + 32"> </p>



<blockquote><p>You might remember (or not) that in the first <a href="https://olegkarasik.wordpress.com/2018/06/24/what-is-wrong-with-this-code/">What is wrong with this code?</a> post we have counted the size of empty <code>List&lt;T&gt;</code> as 40 bytes.</p><p>This was 100% correct for previous version of .NET Core. In .NET Core 3.0 most of the collection classes have their <code>_syncRoot</code> field removed (here is a <a href="https://github.com/dotnet/corefx/commit/4d6cde1be300d1fb8b3aec2356d18f1f3d071913#diff-81a5ab9c227534a88af5dc319cc9774d">PR</a>) which resulted in smaller collection sizes.</p><cite>Author’s note</cite></blockquote>



<p>Beside memory allocated by instance of <code>List&lt;T&gt;</code> benchmark results also include memory allocated by it’s enumerator (40 bytes on x64 system) which we should subtract from the benchmark results:</p>



<figure><table><thead><tr><th>Sequence length </th><th>Total count of arrays allocated</th><th>Total count of  items allocated</th><th>Total bytes allocated (exact)</th><th>Total bytes allocated (iterator adjusted) </th></tr></thead><tbody><tr><td>10</td><td>3</td><td>28</td><td>216</td><td>216</td></tr><tr><td>100</td><td>6</td><td>252</td><td>1184</td><td>1184</td></tr><tr><td>1000</td><td>9</td><td>2044</td><td>8424</td><td>8424</td></tr><tr><td>10000</td><td>13</td><td>32764</td><td>131400</td><td>131400</td></tr></tbody></table></figure>



<h3>Unexpected discovery #3</h3>



<hr>



<p>Now when understand how both <code>LargeArrayBuilder&lt;T&gt;</code> and <code>List&lt;T&gt;</code> allocate we can compare how many items they allocate for the same amount of input elements:</p>



<figure><table><thead><tr><th>Sequence length </th><th>Total count of  items allocated (<code>List&lt;T&gt;</code>)</th><th>Total count of items allocated + count of items in final array (<code>LargeArrayBuilder&lt;T&gt;</code>)</th></tr></thead><tbody><tr><td>10</td><td>28</td><td>20 + 10 = 30</td></tr><tr><td>100</td><td>252</td><td>132 + 100 = 232</td></tr><tr><td>1000</td><td>2044</td><td>1028 + 1000 = 2028</td></tr><tr><td>10000</td><td>32764</td><td>16388 + 10000 = 26388</td></tr></tbody></table></figure>



<p>This data explains the difference we saw in <strong>Allocated </strong>column for last benchmark – in that case <code>List&lt;T&gt;</code> allocated 6,376 items more than <code>LargeArrayBuilder&lt;T&gt;</code>.</p>



<h2>Conclusion</h2>



<hr>



<p>If you are reading these lines then first of all – Thank you for reading this huge post. I hope you enjoyed it. </p>



<p>Here is a small reward in form of short summary:</p>



<p><strong>Result #1</strong></p>



<p>In cases when <code>source</code> is <code>ICollection&lt;T&gt;</code> both <code>ToArray</code> and <code>ToList</code> methods demonstrate almost the same performance characteristics because internally they execute almost identical code. </p>



<p><strong>Result #2</strong></p>



<p>In cases when input sequence is a product of multiple iterators the performance of both <code>ToArray</code> and <code>ToList</code> methods would depend on the optimizations implemented by those iterators and in some cases can differ significantly. </p>



<p><strong>Result #3</strong></p>



<p>In cases when input sequence is an enumerable both <code>ToArray</code> and <code>ToList</code> methods demonstrate very close performance characteristics in terms of speed. However for large sequences <code>ToArray</code> method could has smaller memory footprint. At the same time it is important to understand – because <code>ToArray</code> causes allocation of multiple independent arrays it could cause memory fragmentation (and even object promotion) because GC wouldn’t be able to clean these arrays until the <code>ToArray</code> operation is done. It is hard to say how critical these differences are but it is always good to know about them.</p>



<h2>Bonus</h2>



<p>Did you know that <code>ArrayBuilder&lt;T&gt;</code> class used inside of <code>LargeArrayBuilder&lt;T&gt;</code> class has the same allocation strategy as <code>List&lt;T&gt;</code>? 🙂</p>
	</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>