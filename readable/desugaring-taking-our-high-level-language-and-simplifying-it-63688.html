<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Desugaring - taking our high-level language and simplifying it! - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Desugaring - taking our high-level language and simplifying it! - linksfor.dev(s)"/>
    <meta property="article:author" content="Mukul Rathi"/>
    <meta property="og:description" content="So far we&#x27;ve talked about checking our Bolt program is correct, but now we&#x27;re moving on to actually running it. One problem though, a lot of our high-level constructs like objects and methods don&#x27;t exist in LLVM IR - we need to map them to simpler constructs."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://mukulrathi.co.uk/create-your-own-programming-language/lower-language-constructs-to-llvm/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Desugaring - taking our high-level language and simplifying it!</title>
<div class="readable">
        <h1>Desugaring - taking our high-level language and simplifying it!</h1>
            <div>by Mukul Rathi</div>
            <div>Reading time: 13-17 minutes</div>
        <div>Posted here: 01 Jul 2020</div>
        <p><a href="https://mukulrathi.co.uk/create-your-own-programming-language/lower-language-constructs-to-llvm/">https://mukulrathi.co.uk/create-your-own-programming-language/lower-language-constructs-to-llvm/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><article><h3>Creating the Bolt Compiler: Part 6</h3><p><h3>July 01, 2020</h3><h3>6 min read</h3></p><div><picture><source srcset="/static/b33e88f12846c60d15fc3fa2d03d50f6/b98be/desugaring.png 158w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/704a2/desugaring.png 315w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/1711c/desugaring.png 630w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/a9ac2/desugaring.png 945w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/dc180/desugaring.png 1260w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/82ba1/desugaring.png 1704w" sizes="(max-width: 630px) 100vw, 630px"><img sizes="(max-width: 630px) 100vw, 630px" srcset="/static/b33e88f12846c60d15fc3fa2d03d50f6/b98be/desugaring.png 158w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/704a2/desugaring.png 315w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/1711c/desugaring.png 630w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/a9ac2/desugaring.png 945w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/dc180/desugaring.png 1260w,
/static/b33e88f12846c60d15fc3fa2d03d50f6/82ba1/desugaring.png 1704w" src="https://mukulrathi.co.uk/static/b33e88f12846c60d15fc3fa2d03d50f6/1711c/desugaring.png" alt="" loading="lazy"></picture></div><nav><h2>Series: Creating the Bolt Compiler</h2><ul><li></li><li></li><li></li><li></li><li></li><li><strong>Part 6: Desugaring - taking our high-level language and simplifying it!</strong></li><li><em>Part 7: Protobuf serialisation - converting from OCaml to C++*</em></li><li><em>Part 8: LLVM's C++ API for the Uninitiated*</em></li><li><em>Part 9: Adding Concurrency to Bolt*</em></li><li><em>Part 10: Inheritance and method overriding in Bolt*</em></li><li><em>Part 11: Generics - adding polymorphism to Bolt*</em></li><p>*coming soon! </p></ul></nav><hr><h2 id="just-give-me-the-code"><a href="#just-give-me-the-code" aria-label="just give me the code permalink"></a>Just give me the code!</h2><p>All the illustrative code snippets in this blog post link to the respective file in the <a href="https://github.com/mukul-rathi/bolt">Bolt repository</a>. There’s more code in there that could be covered without making this post extremely long!</p><p>The first half of this post will be looking at the <a href="https://github.com/mukul-rathi/bolt/tree/master/src/frontend/desugaring">desugaring/ folder</a> and the second half is covering the <a href="https://github.com/mukul-rathi/bolt/tree/master/src/frontend/ir_gen">ir_gen/ folder</a>.</p><h2 id="what-is-desugaring"><a href="#what-is-desugaring" aria-label="what is desugaring permalink"></a>What is desugaring?</h2><p>Programming languages are a series of abstractions. No one writes programs by typing in 0s and 1s - it’s just not human readable. The closest we get to the hardware operations is with <strong>assembly code</strong> e.g. series of <code>add</code> <code>mov</code> and <code>jmp</code> instructions.</p><p>Assembly code is still not really a pleasant programming experience. Even languages we deem as <em>low-level</em> like C / C++ / Rust offer a host of abstractions over assembly code - things you take for granted like <code>if</code> statements and <code>while</code> loops.</p><p>We call these abstractions <strong>syntactic sugar</strong> - named because they make it <em>sweeter</em> for programmers to program in that language.</p><p>When we’re writing a compiler though, we’re going the other way - we’re <em>desugaring</em> the source code - stripping away higher-level constructs. We also refer to this as <em>lowering</em> the high-level language constructs.</p><p>In this post we’ll start by looking at desugaring a for loop. We’ll then look at the “Desugaring” and “IR Lowering” stages in the Bolt compiler frontend. This will wrap up our compiler frontend and set us up to switch to C++ for the compiler backend.</p><h2 id="desugaring-for-loops"><a href="#desugaring-for-loops" aria-label="desugaring for loops permalink"></a>Desugaring For Loops</h2><p>The first case we desugar is actually between the parsing and type-checking phases - desugaring a <code>for</code> loop into a while loop:</p><div><p><span>desugar_for_loop.bolt</span></p><div><pre><p><span>for</span><span> </span><span>(</span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> n</span><span>;</span><span> i</span><span>:</span><span>=</span><span>i</span><span>+</span><span>1</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  doSomething</span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>let</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span></span><span>while</span><span> </span><span>(</span><span>i </span><span>&lt;</span><span> n</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  doSomething</span><span>;</span><span></span></p><p><span>  i</span><span>:</span><span>=</span><span>i</span><span>+</span><span>1</span><span></span></p><p><span></span><span>}</span></p></pre></div></div><p>Note we handle this as a special case when type-checking the expression, however you might imagine if there was more sugar (like <code>++i</code> instead of <code>i:=i+1</code>) that we might add a full desugaring stage between the parsed AST and typed AST:</p><div><p><span><a href="https://github.com/mukul-rathi/bolt/blob/master/src/frontend/typing/type_expr.ml"> <!-- -->type_expr.ml</a></span></p><div><pre><p><span>let</span><span> </span><span>rec</span><span> type</span><span>_</span><span>expr class</span><span>_</span><span>defns function</span><span>_</span><span>defns </span><span>(</span><span>expr </span><span>:</span><span> </span><span>Parsed_ast</span><span>.</span><span>expr</span><span>)</span><span> env </span><span>=</span><span></span></p><p><span></span><span>.</span><span>.</span><span>.</span><span></span></p><p><span></span><span>|</span><span> </span><span>Parsed_ast</span><span>.</span><span>For</span><span></span></p><p><span>      </span><span>(</span><span>loc</span><span>,</span><span> start</span><span>_</span><span>expr</span><span>,</span><span> cond</span><span>_</span><span>expr</span><span>,</span><span> step</span><span>_</span><span>expr</span><span>,</span><span> </span><span>Parsed_ast</span><span>.</span><span>Block</span><span> </span><span>(</span><span>block</span><span>_</span><span>loc</span><span>,</span><span> loop</span><span>_</span><span>expr</span><span>)</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>      type</span><span>_</span><span>block</span><span>_</span><span>with</span><span>_</span><span>defns</span></p><p><span>        </span><span>(</span><span>Parsed_ast</span><span>.</span><span>Block</span><span></span></p><p><span>           </span><span>(</span><span> loc</span></p><p><span>           </span><span>,</span><span> </span><span>[</span><span> start</span><span>_</span><span>expr</span></p><p><span>             </span><span>;</span><span> </span><span>Parsed_ast</span><span>.</span><span>While</span><span></span></p><p><span>                 </span><span>(</span><span>loc</span><span>,</span><span> cond</span><span>_</span><span>expr</span><span>,</span><span></span></p><p><span>                 </span><span>Parsed_ast</span><span>.</span><span>Block</span><span> </span><span>(</span><span>block</span><span>_</span><span>loc</span><span>,</span><span> loop</span><span>_</span><span>expr </span><span>@</span><span> </span><span>[</span><span>step</span><span>_</span><span>expr</span><span>]</span><span>)</span><span>)</span><span></span></p><p><span>             </span><span>]</span><span> </span><span>)</span><span>)</span><span></span></p><p><span>        env</span></p></pre></div></div><h2 id="desugaring-between-type-checking-stages"><a href="#desugaring-between-type-checking-stages" aria-label="desugaring between type checking stages permalink"></a>Desugaring between type-checking stages</h2><p>Desugaring gets its own stage in between the two stages of type-checking. The data-race type-checking is much more complex than the traditional type-checking (<code>int</code>, <code>bool</code> etc), so we simplify the language to <em>avoid having to consider as many cases</em>.</p><h3 id="removing-variable-shadowing"><a href="#removing-variable-shadowing" aria-label="removing variable shadowing permalink"></a>Removing variable shadowing</h3><p>For example, consider variable shadowing, where we can declare the same variable name <code>x</code> in nested scopes: Consider the following:</p><div><p><span>variable_shadowing.bolt</span></p><div><pre><p><span>let</span><span> x </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span></span><span>if</span><span> </span><span>(</span><span>x </span><span>&gt;=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> x </span><span>=</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> y </span><span>=</span><span> x </span><span>+</span><span> </span><span>1</span><span> </span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>else</span><span> </span><span>{</span><span> </span><span></span></p><p><span> x </span><span>:</span><span>=</span><span> </span><span>1</span><span></span></p><p><span></span><span>}</span></p></pre></div></div><p>Variable shadowing is syntactic sugar - we don’t require the programmer to use unique variable names in nested scopes. It makes the <a href="https://mukulrathi.co.uk/create-your-own-programming-language/data-race-dataflow-analysis/">alias liveness analysis previously discussed</a> much harder. How do we know which value of x is being aliased? We could track which scope we’re in <em>orrrr</em> we could avoid it. It’s much easier to deal with once we give variables unique names:</p><div><p><span>unique_variable_names.bolt</span></p><div><pre><p><span>let</span><span> _x0 </span><span>=</span><span> </span><span>0</span><span>;</span><span></span></p><p><span></span><span>if</span><span> </span><span>(</span><span>_x0 </span><span>&gt;=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>let</span><span> _x1 </span><span>=</span><span> </span><span>1</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> y </span><span>=</span><span> _x1</span><span>+</span><span> </span><span>1</span><span></span></p><p><span></span><span>else</span><span> </span><span>{</span><span></span></p><p><span> _x0 </span><span>:</span><span>=</span><span> </span><span>1</span><span></span></p><p><span></span><span>}</span></p></pre></div></div><p>We first create a mapping from old to new variable names. We count the number of times the variable has been declared so far in outer scopes and stick that count on the end of the variable name. And to specify that these are compiler-generated names we prepend them with an <code>_</code>, since in Bolt programmers can’t define a variable starting with an <code>_</code>.</p><div><p><span><a href="https://github.com/mukul-rathi/bolt/blob/master/src/frontend/desugaring/remove_variable_shadowing.ml"> <!-- -->remove_variable_shadowing.ml</a></span></p><div><pre><p><span>type</span><span> var</span><span>_</span><span>name</span><span>_</span><span>map </span><span>=</span><span> </span><span>(</span><span>Var_name</span><span>.</span><span>t </span><span>*</span><span> </span><span>Var_name</span><span>.</span><span>t</span><span>)</span><span> list</span></p><p><span></span><span>let</span><span> set</span><span>_</span><span>unique</span><span>_</span><span>name var</span><span>_</span><span>name var</span><span>_</span><span>name</span><span>_</span><span>map </span><span>=</span><span></span></p><p><span>  </span><span>let</span><span> num</span><span>_</span><span>times</span><span>_</span><span>var</span><span>_</span><span>declared </span><span>=</span><span></span></p><p><span>    </span><span>List</span><span>.</span><span>length </span><span>(</span><span>List</span><span>.</span><span>filter </span><span>~f</span><span>:</span><span>(</span><span>fun</span><span> </span><span>(</span><span>name</span><span>,</span><span> </span><span>_</span><span>)</span><span> </span><span>-&gt;</span><span> name </span><span>=</span><span> var</span><span>_</span><span>name</span><span>)</span><span> var</span><span>_</span><span>name</span><span>_</span><span>map</span><span>)</span><span> </span><span>in</span><span></span></p><p><span>  </span><span>Var_name</span><span>.</span><span>of</span><span>_</span><span>string</span></p><p><span>    </span><span>(</span><span>Fmt</span><span>.</span><span>str </span><span>"_%s%d"</span><span> </span><span>(</span><span>Var_name</span><span>.</span><span>to</span><span>_</span><span>string var</span><span>_</span><span>name</span><span>)</span><span> num</span><span>_</span><span>times</span><span>_</span><span>var</span><span>_</span><span>declared</span><span>)</span></p></pre></div></div><h3 id="desugaring-function--method-overloading"><a href="#desugaring-function--method-overloading" aria-label="desugaring function  method overloading permalink"></a>Desugaring Function / Method Overloading</h3><p>Function overloading is where we define multiple functions with the <em>same</em> name but <em>different</em> parameter types. This is useful if you want to call a different <code>print</code> method based on the type of the arguments passed in:</p><div><p><span>function_overloading.bolt</span></p><div><pre><p><span>function</span><span> </span><span>void</span><span> </span><span>print</span><span>(</span><span>Foo x</span><span>)</span><span>{</span><span></span></p><p><span>  </span><span>...</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>function</span><span> </span><span>void</span><span> </span><span>print</span><span>(</span><span>Bar x</span><span>)</span><span>{</span><span></span></p><p><span>  </span><span>...</span><span></span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>function</span><span> </span><span>void</span><span> </span><span>print</span><span>(</span><span>int x</span><span>)</span><span>{</span><span></span></p><p><span>  </span><span>...</span><span></span></p><p><span></span><span>}</span></p></pre></div></div><p>Again, this is a nice-to-have construct, but we’ve got an issue - which function do we call? We can’t tell from the source code, but we can use the information about the argument types from the previous type-checking stage.</p><p>By desugaring more complex language constructs to simpler language constructs, we make subsequent stages of the compiler simpler - they <strong>do not need to know</strong> about anything that has been desugared.</p><p>We encode the type of the parameters in the function application expression when type-checking it:</p><div><p><span><a href="https://github.com/mukul-rathi/bolt/blob/master/src/frontend/typing/type_expr.ml"> <!-- -->type_expr.ml</a></span></p><div><pre><p><span>|</span><span> </span><span>Parsed_ast</span><span>.</span><span>FunctionApp</span><span> </span><span>(</span><span>loc</span><span>,</span><span> func</span><span>_</span><span>name</span><span>,</span><span> args</span><span>_</span><span>exprs</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>      type</span><span>_</span><span>args type</span><span>_</span><span>with</span><span>_</span><span>defns args</span><span>_</span><span>exprs env</span></p><p><span>      </span><span>&gt;&gt;=</span><span> </span><span>fun</span><span> </span><span>(</span><span>typed</span><span>_</span><span>args</span><span>_</span><span>exprs</span><span>,</span><span> args</span><span>_</span><span>types</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>      get</span><span>_</span><span>matching</span><span>_</span><span>function</span><span>_</span><span>type class</span><span>_</span><span>defns func</span><span>_</span><span>name args</span><span>_</span><span>types function</span><span>_</span><span>defns loc</span></p><p><span>      </span><span>&gt;&gt;|</span><span> </span><span>fun</span><span> </span><span>(</span><span>param</span><span>_</span><span>types</span><span>,</span><span> return</span><span>_</span><span>type</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>      </span><span>(</span><span> </span><span>Typed_ast</span><span>.</span><span>FunctionApp</span><span> </span><span>(</span><span>loc</span><span>,</span><span> return</span><span>_</span><span>type</span><span>,</span><span> param</span><span>_</span><span>types</span><span>,</span><span> func</span><span>_</span><span>name</span><span>,</span><span> typed</span><span>_</span><span>args</span><span>_</span><span>exprs</span><span>)</span><span></span></p><p><span>      </span><span>,</span><span> return</span><span>_</span><span>type </span><span>)</span></p></pre></div></div><h4 id="name-mangling-functions"><a href="#name-mangling-functions" aria-label="name mangling functions permalink"></a>Name mangling functions</h4><p>Now since each overloaded function has differing parameter types, we can map the parameter types to a unique string, which we append onto our function name. We call this process of generating a unique function name <strong>name mangling</strong>.</p><p>We’re going to take the approach used in C++.</p><p>For each of the primitive types, we can map them to a unique single character, whilst for classes we map them to the class name prepended with its length. We then concatenate all param types together.</p><p>Why prepend the length? Consider param types <code>(Foo x, Bar y)</code> and <code>(FooBar x)</code> - both would map to <code>FooBar</code> if we concatenated their parameter names. Only when we prepend the lengths can they be distinguished - <code>3Foo3Bar</code> vs <code>6FooBar</code>.</p><div><p><span><a href="https://github.com/mukul-rathi/bolt/blob/master/src/frontend/desugaring/desugar_overloading.ml"> <!-- -->desugar_overloading.ml</a></span></p><div><pre><p><span>let</span><span> name</span><span>_</span><span>mangle</span><span>_</span><span>param</span><span>_</span><span>types param</span><span>_</span><span>types </span><span>=</span><span></span></p><p><span>  </span><span>String</span><span>.</span><span>concat</span></p><p><span>    </span><span>(</span><span>List</span><span>.</span><span>map</span></p><p><span>       </span><span>~f</span><span>:</span><span>(</span><span>function</span><span></span></p><p><span>         </span><span>|</span><span> </span><span>TEVoid</span><span>                  </span><span>-&gt;</span><span> </span><span>"v"</span><span></span></p><p><span>         </span><span>|</span><span> </span><span>TEInt</span><span>                   </span><span>-&gt;</span><span> </span><span>"i"</span><span></span></p><p><span>         </span><span>|</span><span> </span><span>TEBool</span><span>                  </span><span>-&gt;</span><span> </span><span>"b"</span><span></span></p><p><span>         </span><span>|</span><span> </span><span>TEClass</span><span> </span><span>(</span><span>class</span><span>_</span><span>name</span><span>,</span><span> </span><span>_</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>             </span><span>let</span><span> class</span><span>_</span><span>name</span><span>_</span><span>str </span><span>=</span><span> </span><span>Class_name</span><span>.</span><span>to</span><span>_</span><span>string class</span><span>_</span><span>name </span><span>in</span><span></span></p><p><span>             </span><span>Fmt</span><span>.</span><span>str </span><span>"%d%s"</span><span> </span><span>(</span><span>String</span><span>.</span><span>length class</span><span>_</span><span>name</span><span>_</span><span>str</span><span>)</span><span> class</span><span>_</span><span>name</span><span>_</span><span>str</span><span>)</span><span></span></p><p><span>       param</span><span>_</span><span>types</span><span>)</span></p></pre></div></div><p>And then to name mangle a method or function, we have the following code:</p><div><p><span><a href="https://github.com/mukul-rathi/bolt/blob/master/src/frontend/desugaring/desugar_overloading.ml"> <!-- -->desugar_overloading.ml</a></span></p><div><pre><p><span>let</span><span> name</span><span>_</span><span>mangle</span><span>_</span><span>overloaded</span><span>_</span><span>method meth</span><span>_</span><span>name param</span><span>_</span><span>types </span><span>=</span><span></span></p><p><span>  </span><span>Method_name</span><span>.</span><span>of</span><span>_</span><span>string</span></p><p><span>    </span><span>(</span><span>Fmt</span><span>.</span><span>str </span><span>"_%s%s"</span><span></span></p><p><span>       </span><span>(</span><span>Method_name</span><span>.</span><span>to</span><span>_</span><span>string meth</span><span>_</span><span>name</span><span>)</span><span></span></p><p><span>       </span><span>(</span><span>name</span><span>_</span><span>mangle</span><span>_</span><span>param</span><span>_</span><span>types param</span><span>_</span><span>types</span><span>)</span><span>)</span></p></pre></div></div><p>For example, with this name mangling scheme, <code>testFun(Foo x, Bar y)</code> maps to <code>_testFun3Foo3Bar(Foo x, Bar y)</code>.</p><p>If you look at the master branch of the Bolt repo, you’ll notice the desugaring stage also desugars generics. That’s a topic that deserves its own post later in the series!</p><h2 id="lowering-to-ir"><a href="#lowering-to-ir" aria-label="lowering to ir permalink"></a>Lowering to IR</h2><p>Recapping so far, we first looked at desugaring for loops - this occurs between the parsing and first stage of type-checking. We then looked at the desugaring stage which sits between the two stages of type-checking. We now look at IR lowering stage that occurs after type-checking.</p><p>IR stands for <em>intermediate representation</em> - it is simpler than the source code, but not quite lowered all the way down to assembly code.</p><p>Our goal with this IR is to <strong>get close to the LLVM representation</strong>, to make working with the LLVM API as simple as possible. We’ll also strip away any unnecessary information that we won’t need when running the program.</p><div><h3>Join me on this learning journey!</h3><p>This summer I’m using my blog to teach the topics I’ve learnt this year. It’s a win-win - you get computer science tutorials and I get to share it with you!</p></div><h3 id="lowering-objects-to-structs"><a href="#lowering-objects-to-structs" aria-label="lowering objects to structs permalink"></a>Lowering Objects to Structs</h3><p>Classes are an <strong>abstraction</strong> that group together fields and methods. LLVM IR doesn’t contain classes and objects, only <strong>structs</strong>, which are just a group of fields.</p><p><span>
      <a href="https://mukulrathi.co.uk/static/a394f0ce0e8ccdc6c4aa56d97ee923b1/7f15f/struct-memory.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Struct Memory Representation" title="Struct Memory Representation" src="https://mukulrathi.co.uk/static/a394f0ce0e8ccdc6c4aa56d97ee923b1/a6d36/struct-memory.png" srcset="/static/a394f0ce0e8ccdc6c4aa56d97ee923b1/222b7/struct-memory.png 163w,/static/a394f0ce0e8ccdc6c4aa56d97ee923b1/ff46a/struct-memory.png 325w,/static/a394f0ce0e8ccdc6c4aa56d97ee923b1/a6d36/struct-memory.png 650w,/static/a394f0ce0e8ccdc6c4aa56d97ee923b1/e548f/struct-memory.png 975w,/static/a394f0ce0e8ccdc6c4aa56d97ee923b1/3c492/struct-memory.png 1300w,/static/a394f0ce0e8ccdc6c4aa56d97ee923b1/7f15f/struct-memory.png 1530w" sizes="(max-width: 650px) 100vw, 650px" loading="lazy">
  </a>
    </span></p><p>So how do we map from our Bolt class definition to a struct? We strip away information from our class:</p><ul><li>We dropped the <code>var</code> / <code>const</code> in the field definitions</li><li>We dropped the capability annotations</li><li>We drop type information in the AST except for field types</li><li>We drop <code>loc</code> (line-position information that we used for our type-checker error messages).</li><li>We drop field names</li><li>We no longer associate methods with a class (more on that in a second!)</li></ul><p>Recall, the goal of annotating types and capabilities to our AST is to check the program is correct. If we can assign a type to an expression, then it is <em>well-typed</em> so it satisfies our notion of correctness. Likewise, if we can assign capabilities then we know our program doesn’t have data races. And <code>const</code> is just a compiler check to prevent us reassigning a field.</p><p>Once we’ve checked all that, we can drop that information, since we don’t need it later in the compiler. In fact, our class definition is now quite barebones - just the class name (a <code>string</code>), and a list of field types, which LLVM will use to decide how much memory to allocate to an object:</p><p>Field names are useful to us as programmers, but for the computer we don’t need to name our fields, we can number them instead as an <strong>index</strong> into the struct. Intuitively this is just like array indices.</p><div><p><span><a href="https://github.com/mukul-rathi/bolt/blob/master/src/frontend/ir_gen/ir_gen_env.ml"> <!-- -->ir_gen_env.ml</a></span></p><div><pre><p><span>let</span><span> ir</span><span>_</span><span>gen</span><span>_</span><span>field</span><span>_</span><span>index field</span><span>_</span><span>name class</span><span>_</span><span>name class</span><span>_</span><span>defns </span><span>=</span><span></span></p><p><span>  get</span><span>_</span><span>class</span><span>_</span><span>fields class</span><span>_</span><span>name class</span><span>_</span><span>defns</span></p><p><span>  </span><span>|&gt;</span><span> </span><span>fun</span><span> field</span><span>_</span><span>defns </span><span>-&gt;</span><span></span></p><p><span>  </span><span>List</span><span>.</span><span>find</span><span>_</span><span>mapi</span><span>_</span><span>exn</span></p><p><span>    </span><span>~f</span><span>:</span><span>(</span><span>fun</span><span> index </span><span>(</span><span>TField</span><span> </span><span>(</span><span>_</span><span>,</span><span> </span><span>_</span><span>,</span><span> name</span><span>,</span><span> </span><span>_</span><span>)</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>      </span><span>if</span><span> name </span><span>=</span><span> field</span><span>_</span><span>name </span><span>then</span><span> </span><span>Some</span><span> index </span><span>else</span><span> </span><span>None</span><span>)</span><span></span></p><p><span>    field</span><span>_</span><span>defns</span></p></pre></div></div><p>Note this <code>List.find_mapi_exn</code> function name might seem complex, but the goal is to <code>find</code> the field that matches the given field name by going through (<code>map</code>) each element of the list, along with that field’s index (hence <code>mapi</code> not <code>map</code>), and raising an exception (<code>exn</code>) if it is not found. In practice, this function will never raise an exception because we already have checked in an earlier type-checking stage that the field exists.</p><p>Methods are just ordinary functions that implicitly take in an additional parameter: <code>this</code>, which refers to the object that called the method. In Python, this additional parameter (referred to as <code>self</code>) is explicitly declared in method declarations.</p><p>Note we need to name-mangle our methods again, by prepending the class name. Right now, we have unique method names <em>within</em> a class, when we separate them as normal functions, they need to be <em>globally</em> uniquely named.</p><p><span>
      <a href="https://mukulrathi.co.uk/static/c42e7c83dd7245e132403d79cf89c41e/fa60d/lower-classes.png" target="_blank" rel="noopener">
    <span></span>
  <img alt="Lower Classes" title="Lower Classes" src="https://mukulrathi.co.uk/static/c42e7c83dd7245e132403d79cf89c41e/a6d36/lower-classes.png" srcset="/static/c42e7c83dd7245e132403d79cf89c41e/222b7/lower-classes.png 163w,/static/c42e7c83dd7245e132403d79cf89c41e/ff46a/lower-classes.png 325w,/static/c42e7c83dd7245e132403d79cf89c41e/a6d36/lower-classes.png 650w,/static/c42e7c83dd7245e132403d79cf89c41e/e548f/lower-classes.png 975w,/static/c42e7c83dd7245e132403d79cf89c41e/3c492/lower-classes.png 1300w,/static/c42e7c83dd7245e132403d79cf89c41e/fa60d/lower-classes.png 1792w" sizes="(max-width: 650px) 100vw, 650px" loading="lazy">
  </a>
    </span></p><h3 id="automatically-inserting-locks"><a href="#automatically-inserting-locks" aria-label="automatically inserting locks permalink"></a>Automatically Inserting Locks</h3><p>Bolt has a <code>locked</code> capability, which is similar to the <code>synchronised</code> keyword in Java - this wraps locks around any access. Since we’re dropping this locked capability we need to specify lock/unlock instructions in our IR.</p><div><p><span><a href="https://github.com/mukul-rathi/bolt/blob/master/src/frontend/ir_gen/frontend_ir.mli"> <!-- -->frontend_ir.mli</a></span></p><div><pre><p><span>type</span><span> lock</span><span>_</span><span>type </span><span>=</span><span> </span><span>Reader</span><span>  </span><span>|</span><span> </span><span>Writer</span><span></span></p><p><span></span><span>type</span><span> expr </span><span>=</span><span></span></p><p><span>  </span><span>|</span><span> </span><span>Integer</span><span>     </span><span>of</span><span> int</span></p><p><span>  </span><span>|</span><span> </span><span>Boolean</span><span>     </span><span>of</span><span> bool</span></p><p><span>  </span><span>|</span><span> </span><span>Identifier</span><span>  </span><span>of</span><span> identifier </span><span>*</span><span> lock</span><span>_</span><span>type option</span></p><p><span>  </span><span>.</span><span>.</span><span>.</span><span></span></p><p><span>  </span><span>|</span><span> </span><span>Lock</span><span>        </span><span>of</span><span> string </span><span>*</span><span> lock</span><span>_</span><span>type</span></p><p><span>  </span><span>|</span><span> </span><span>Unlock</span><span>      </span><span>of</span><span> string </span><span>*</span><span> lock</span><span>_</span><span>type</span></p></pre></div></div><p>and our to insert locks, we lock the object (<code>this</code>) and then compute the return value, release the lock and return the value:</p><div><div><pre><p><span>...</span><span> </span><span>{</span><span></span></p><p><span>  methodBody</span></p><p><span></span><span>}</span><span></span></p><p><span></span><span>...</span><span>{</span><span></span></p><p><span>  </span><span>lock</span><span>(</span><span>this</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>let</span><span> retVal </span><span>=</span><span> methodBody</span><span>;</span><span></span></p><p><span>  </span><span>unlock</span><span>(</span><span>this</span><span>)</span><span>;</span><span></span></p><p><span>  retVal</span></p><p><span></span><span>}</span></p></pre></div></div><p>The corresponding generation code is:</p><div><p><span><a href="https://github.com/mukul-rathi/bolt/blob/master/src/frontend/ir_gen/ir_gen_class_and_function_defns.ml"> <!-- -->ir_gen_class_and_function_defns.ml</a></span></p><div><pre><p><span>let</span><span> ir</span><span>_</span><span>gen</span><span>_</span><span>class</span><span>_</span><span>method</span><span>_</span><span>defn class</span><span>_</span><span>defns class</span><span>_</span><span>name</span></p><p><span>    </span><span>(</span><span>Desugared_ast</span><span>.</span><span>TMethod</span><span></span></p><p><span>       </span><span>(</span><span> method</span><span>_</span><span>name</span></p><p><span>       </span><span>,</span><span> </span><span>_</span><span></span></p><p><span>       </span><span>,</span><span> return</span><span>_</span><span>type</span></p><p><span>       </span><span>,</span><span> params</span></p><p><span>       </span><span>,</span><span> capabilities</span><span>_</span><span>used</span></p><p><span>       </span><span>,</span><span> body</span><span>_</span><span>expr </span><span>)</span><span>)</span><span> </span><span>=</span><span></span></p><p><span>    </span><span>.</span><span>.</span><span>.</span><span></span></p><p><span>   </span><span>|&gt;</span><span> </span><span>fun</span><span> ir</span><span>_</span><span>body</span><span>_</span><span>expr </span><span>-&gt;</span><span></span></p><p><span>  </span><span>(</span><span> </span><span>match</span><span></span></p><p><span>      </span><span>List</span><span>.</span><span>find</span></p><p><span>        </span><span>~f</span><span>:</span><span>(</span><span>fun</span><span> </span><span>(</span><span>Ast_types</span><span>.</span><span>TCapability</span><span> </span><span>(</span><span>mode</span><span>,</span><span> </span><span>_</span><span>)</span><span>)</span><span></span></p><p><span>        </span><span>-&gt;</span><span> mode </span><span>=</span><span> </span><span>Ast_types</span><span>.</span><span>Locked</span><span>)</span><span></span></p><p><span>        capabilities</span><span>_</span><span>used</span></p><p><span>    </span><span>with</span><span></span></p><p><span>  </span><span>|</span><span> </span><span>Some</span><span> </span><span>_</span><span>lockedCap </span><span>-&gt;</span><span></span></p><p><span>      </span><span>[</span><span> </span><span>Frontend_ir</span><span>.</span><span>Lock</span><span> </span><span>(</span><span>"this"</span><span>,</span><span> </span><span>Frontend_ir</span><span>.</span><span>Writer</span><span>)</span><span></span></p><p><span>      </span><span>;</span><span> </span><span>Frontend_ir</span><span>.</span><span>Let</span><span> </span><span>(</span><span>"retVal"</span><span>,</span><span> </span><span>Frontend_ir</span><span>.</span><span>Block</span><span> ir</span><span>_</span><span>body</span><span>_</span><span>expr</span><span>)</span><span></span></p><p><span>      </span><span>;</span><span> </span><span>Frontend_ir</span><span>.</span><span>Unlock</span><span> </span><span>(</span><span>"this"</span><span>,</span><span> </span><span>Frontend_ir</span><span>.</span><span>Writer</span><span>)</span><span></span></p><p><span>      </span><span>;</span><span> </span><span>Frontend_ir</span><span>.</span><span>Identifier</span><span> </span><span>(</span><span>Frontend_ir</span><span>.</span><span>Variable</span><span> </span><span>"retVal"</span><span>,</span><span> </span><span>None</span><span>)</span><span> </span><span>]</span><span></span></p><p><span>  </span><span>|</span><span> </span><span>None</span><span> </span><span> </span><span>-&gt;</span><span> ir</span><span>_</span><span>body</span><span>_</span><span>expr </span><span>)</span><span></span></p><p><span>  </span><span>|&gt;</span><span> </span><span>fun</span><span> maybe</span><span>_</span><span>locked</span><span>_</span><span>ir</span><span>_</span><span>body</span><span>_</span><span>expr </span><span>-&gt;</span><span></span></p><p><span>  </span><span>Frontend_ir</span><span>.</span><span>TFunction</span><span></span></p><p><span>    </span><span>(</span><span>ir</span><span>_</span><span>method</span><span>_</span><span>name</span><span>,</span><span> ir</span><span>_</span><span>return</span><span>_</span><span>type</span><span>,</span><span> ir</span><span>_</span><span>params</span><span>,</span><span> maybe</span><span>_</span><span>locked</span><span>_</span><span>ir</span><span>_</span><span>body</span><span>_</span><span>expr</span><span>)</span></p></pre></div></div><p>And for the identifiers, if we’re meant to lock them, we acquire a Reader/Writer Lock depending on whether we’re reading from them or assigning a value to them:</p><div><p><span><a href="https://github.com/mukul-rathi/bolt/blob/master/src/frontend/ir_gen/ir_gen_expr.ml"> <!-- -->ir_gen_expr.ml</a></span></p><div><pre><p><span>let</span><span> </span><span>rec</span><span> ir</span><span>_</span><span>gen</span><span>_</span><span>expr class</span><span>_</span><span>defns expr </span><span>=</span><span></span></p><p><span></span><span>.</span><span>.</span><span>.</span><span></span></p><p><span>  </span><span>|</span><span> </span><span>Desugared_ast</span><span>.</span><span>Identifier</span><span> </span><span>(</span><span>_</span><span>,</span><span> id</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>      ir</span><span>_</span><span>gen</span><span>_</span><span>identifier class</span><span>_</span><span>defns id</span></p><p><span>      </span><span>|&gt;</span><span> </span><span>fun</span><span> </span><span>(</span><span>ir</span><span>_</span><span>id</span><span>,</span><span> should</span><span>_</span><span>lock</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>      </span><span>let</span><span> lock</span><span>_</span><span>held </span><span>=</span><span> </span><span>if</span><span> should</span><span>_</span><span>lock </span><span>then</span><span> </span><span>Some</span><span> </span><span>Frontend_ir</span><span>.</span><span>Reader</span><span> </span><span>else</span><span> </span><span>None</span><span> </span><span>in</span><span></span></p><p><span>      </span><span>Frontend_ir</span><span>.</span><span>Identifier</span><span> </span><span>(</span><span>ir</span><span>_</span><span>id</span><span>,</span><span> lock</span><span>_</span><span>held</span><span>)</span><span></span></p><p><span></span><span>.</span><span>.</span><span>.</span><span></span></p><p><span>  </span><span>|</span><span> </span><span>Desugared_ast</span><span>.</span><span>Assign</span><span> </span><span>(</span><span>_</span><span>,</span><span> </span><span>_</span><span>,</span><span> id</span><span>,</span><span> assigned</span><span>_</span><span>expr</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>      ir</span><span>_</span><span>gen</span><span>_</span><span>identifier class</span><span>_</span><span>defns id</span></p><p><span>      </span><span>|&gt;</span><span> </span><span>fun</span><span> </span><span>(</span><span>ir</span><span>_</span><span>id</span><span>,</span><span> should</span><span>_</span><span>lock</span><span>)</span><span> </span><span>-&gt;</span><span></span></p><p><span>      ir</span><span>_</span><span>gen</span><span>_</span><span>expr class</span><span>_</span><span>defns assigned</span><span>_</span><span>expr</span></p><p><span>      </span><span>|&gt;</span><span> </span><span>fun</span><span> ir</span><span>_</span><span>assigned</span><span>_</span><span>expr </span><span>-&gt;</span><span></span></p><p><span>      </span><span>let</span><span> lock</span><span>_</span><span>held </span><span>=</span><span> </span><span>if</span><span> should</span><span>_</span><span>lock </span><span>then</span><span> </span><span>Some</span><span> </span><span>Frontend_ir</span><span>.</span><span>Writer</span><span> </span><span>else</span><span> </span><span>None</span><span> </span><span>in</span><span></span></p><p><span>      </span><span>Frontend_ir</span><span>.</span><span>Assign</span><span> </span><span>(</span><span>ir</span><span>_</span><span>id</span><span>,</span><span> ir</span><span>_</span><span>assigned</span><span>_</span><span>expr</span><span>,</span><span> lock</span><span>_</span><span>held</span><span>)</span></p></pre></div></div><h2 id="wrapping-up-our-compiler-frontend"><a href="#wrapping-up-our-compiler-frontend" aria-label="wrapping up our compiler frontend permalink"></a>Wrapping Up Our Compiler Frontend</h2><p>As mentioned in the previous parts, the <a href="https://github.com/mukul-rathi/bolt">Bolt repository</a> also contains code for other language features (inheritance and generics, coming in a later post). So don’t worry about “vtables” mentioned in the <code>ir_gen/</code> folder. To see a simpler version of the repository before these features were added, run <code>git checkout simple-compiler-tutorial</code>.</p><p>We’ve now wrapped up our discussion of the compiler frontend!</p><p>Next we’re going to be switching from OCaml to C++ for the LLVM IR Code generation. To do this we’ll be using Protobuf, a cross-language binary serialisation format.</p><p>Once we’ve done that, in a couple of posts we can talk about LLVM’s C++ API!</p></article></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>