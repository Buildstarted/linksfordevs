<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Why I (still) love Vaadin - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Why I (still) love Vaadin - linksfor.dev(s)"/>
    <meta property="article:author" content="Nicolas Fr&#xE4;nkel"/>
    <meta property="og:description" content="It&#x2019;s funny how things come in sequences. Recently, on three separate occasions, I stumbled upon questions asking what people used for front-end technologies. Every time, my answer was Vaadin. Unfortunately, some places, e.g. Twitter, are too limiting to explain my answer in depth. In this blog, I&#x2019;ve no such limitations. In one sentence, Vaadin is a framework to create GUI using plain Java, or any JVM-based language for that matter. One develop in Java, and the framework takes care o"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.frankel.ch/why-love-vaadin/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Why I (still) love Vaadin</title>
<div class="readable">
        <h1>Why I (still) love Vaadin</h1>
            <div>by Nicolas Fr&#xE4;nkel</div>
            <div>Reading time: 10-12 minutes</div>
        <div>Posted here: 07 Jun 2020</div>
        <p><a href="https://blog.frankel.ch/why-love-vaadin/">https://blog.frankel.ch/why-love-vaadin/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="site-main" role="main"> <div> <article itemscope="" itemtype="http://schema.org/BlogPosting"> <meta itemprop="mainEntityOfPage" content="//why-love-vaadin/"> <meta itemprop="description" content="">  <figure itemscope="" itemprop="image" itemtype="http://schema.org/ImageObject"> <meta itemprop="url" content="https://blog.frankel.ch/assets/resources/why-love-vaadin/vaadin-logo-full.svg"> </figure> <section> <div itemprop="articleBody"> <p>It’s funny how things come in sequences. Recently, on three separate occasions, I stumbled upon questions asking what people used for front-end technologies. Every time, my answer was <a href="https://vaadin.com/" target="_blank" rel="noopener">Vaadin</a>. Unfortunately, some places, <em>e.g.</em> Twitter, are too limiting to explain my answer in depth. In this blog, I’ve no such limitations.</p> <p>In one sentence, Vaadin is a framework to create <abbr title="Graphical User Interface">GUI</abbr> using plain Java, or any JVM-based language for that matter. One develop in Java, and the framework takes care of all the rest: this includes the generation of the client-side code, <strong>and</strong> the communication between the client-side code in the browser and the backend code on the server.</p> <div> <h2 id="benefits-of-using-vaadin">Benefits of using Vaadin</h2> <div> <p>This architecture provides the following benefits.</p> <div> <h3 id="easy-onboarding">Easy onboarding</h3> <p>The first and foremost characteristic of Vaadin is that there’s no need to know <em>other</em> technologies. Let’s think what skills are required for a "standard" app that consists of a REST API and a JavaScript front-end:</p> <ol><li><span>Java</span></li><li><span>Jakarta EE API, <em>i.e.</em> Servlets and JAX-RS or the Spring framework</span></li><li><span><abbr title="REpresentational State Transfer">REST</abbr> principles</span></li><li><span><abbr title="Asynchronous JAvaScript + XML">AJAX</abbr> for browser-server inter-communication</span></li><li><span>HTML</span></li><li><span><abbr title="Cascading Style Sheet">CSS</abbr></span></li><li><span>JavaScript (or TypeScript)</span></li><li><span>A front-end framework: the most popular contenders are currently <a href="https://angular.io/" target="_blank" rel="noopener">Angular</a>, <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> or <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a>.</span></li></ol> <p>That’s no less than 8 completely unrelated technologies. And I’m particularly generous: I’ll leave out any additional JavaScript libraries, as well as the build tool necessary to build the front-end artifact. Yet, the latter is required in order to transpile from TypeScript to JavaScript, or from the latest JS version to one that is supported by most browsers.</p> <p>With Vaadin, the list becomes limited to Java…​ and Vaadin.</p> <p>If you read this, you might consider that it’s not that a huge benefit, because you are surrounded by 10 times developers, (<a href="https://blog.frankel.ch/developers-productivity/" target="_blank" rel="noopener">whatever that means</a>). My experience is quite different: I’ve worked more than 15 years as a contractor, for a lot of different customers. Most developers are regular people, happy to work from 9 to 5, and then go back home to live their lives. They have neither the will nor the time to learn yet-another-technology outside of office hours.</p> <p>With the premise that training needs to take place during office time, less technologies mean less training time, and more time dedicated to developing the app.</p> </div> <div> <h3 id="no-integration-phase">No integration phase</h3> <p>The simplicity that Vaadin provides has an additional benefit. If one app’s architecture is separated into a front-end and a back-end that communicate via a REST API, there are two strategies to organize one’s team:</p> <div> <dl> <dt>Development per layer</dt> <dd> <p>This strategy is based on two specialized teams, the front-end team, and the back-end team. They are very good in their own stack. They both work in parallel, in their respective stack. After the slowest of them finishes, they integrate their respective work together.</p> <p>My experience has shown me that in the parallel phase, the work is done (quite) quickly. On the opposite, the integration phase takes a lot of time. My experience is that it takes up to the time spent in the first phase - effectively doubling the development time. The worst is that this second phase is underestimated by most teams, including project managers.</p> </dd> <dt>Development per use-case</dt> <dd> <p>This strategy is based on full-stack developers. This kind of developer is able to work on both ends, front and back. Each developer is assigned a use-case/user story, then needs to understand the business around it, and afterwards is able to develop the whole flow from the GUI to the database.</p> <p>I personally believe that the full-stack developer is a concept which was invented by managers to make developers interchangeable. That way, task planning becomes so much easier for them. Anyway, let’s admit that such unicorns do exist. If one is skilled in that many technologies, one should have had time to learn them. That brings me back to the point made above: most developers have a life beside their job. Of course, there are geeks, but in that case they must be paid accordingly. Unfortunately, regular companies don’t have enough budget: they might afford one, but not a complete team of unicorns.</p> </dd> </dl> </div> <p>In that regard, Vaadin allows non-rockstar developers to develop the application using the 2<sup>nd</sup> strategy. It also allows them to spend more time on the business side of things, and less time on the technical issues.</p> </div> <div> <h3 id="parallelization-between-backend-and-front-end-development">Parallelization between backend and front-end development</h3> <p>By default, Vaadin lets developers who don’t double as graphic designers to develop acceptable-looking GUIs. However, it happens that the product owner has requirements - and sometimes even budget - to customize the design.</p> <p>With the traditional approach, designers achieve that with HTML and CSS. They will design specific HTML templates and CSS classes. Then, developers will be asked to use them.</p> <p>If requirements change mid-way, developers will need to stop their work to integrate the changes required by designers: there’s a high dependency between the workflow of developers and the one of designers. Some technologies such as JSP, JSF and Thymeleaf allow designers' artifacts to be reused as-is by developers. In that case, both will need to work on the same artifacts. Git merge conflicts are always fun when one doesn’t completely grasp upstream changes.</p> <p>Vaadin introduces two abstractions that decouple the work of developers and designers: themes and components.</p> <ul><li><span>A <strong>theme</strong> is a collection of CSS (and <a href="https://sass-lang.com/" target="_blank" rel="noopener">Sass</a>). Because Vaadin generates the HTML, designers know the structure to expect, and can design their CSS accordingly.</span><p>The <em>Lumo</em> theme is applied by default. Another theme, <em>Material</em> is provided out-of-the-box. The ecosystem offers additional themes, each being available as a JAR that only needs to be added to the classpath. It’s also possible for a designer to create one’s own.</p> <p>Note that switching themes is possible through a simple method call.</p></li><li><span>A <strong>component</strong> has both a HTML template, and a Java class that represents it on the server side. Such a component may place other components in a layout. While the Java class manages them as attributes, the HTML template is responsible to the layout. This way, the developer’s work on the Java class - or any other class that uses it - and the designer’s work on the template are completely isolated from each other: they can be fully executed in parallel.</span></li></ul> </div> <div> <h3 id="designed-for-business-applications">Designed for "business" applications</h3> <p>Finally, Vaadin is designed at its core to develop business applications.</p> <ul><li><span>On the UI side, components include widgets frequently used in such applications <em>e.g.</em> fields, combo boxes, forms, tables, etc.</span></li><li><span>Most components display data. The design of those components introduce an abstraction between a component and its data. There are different concretions:</span><ol><li><span>For scalar values <em>e.g.</em> an email displayed in a <em>field</em></span></li><li><span>For collection values <em>e.g.</em> the list of countries displayed in a <em>combo-box</em></span></li><li><span>For two-dimensional values <em>e.g.</em> tabular data displayed in a <em>table</em></span></li></ol></li></ul> </div> </div> </div> <div> <h2 id="arguments-i-heard-against-using-vaadin">Arguments I heard against using Vaadin</h2> <div> <p>In all those years, I’ve heard quite a few arguments against using Vaadin. They mostly all boil down to the following two.</p> <div> <h3 id="but-does-it-scale">"But does it scale?"</h3> <p>You might be interested in knowing that this question is part of the 10 tricks to appear smart in meetings (<a href="https://thecooperreview.com/10-tricks-to-appear-smart-during-meetings/" target="_blank" rel="noopener">#6</a>).</p> <p><span><img src="https://blog.frankel.ch/assets/resources/why-love-vaadin/but-does-it-scale.jpg" alt="But does it scale meme" width="450" height="364"></span></p> <p>On a more serious tone, scaling definitely deserves some digging in. Vaadin stores the state of components server-side. With a huge number of components, and with the increase of the number of clients, this leads to an exponential consumption of memory. In that regard, traditional applications don’t differ that much from Vaadin applications.</p> <p>First, we need to understand that there’s the vast majority of applications are stateful. However, the differentiating factor between them lies in <strong>where the state is stored</strong>. As I mentioned, Vaadin stores it on the server. There are only two other alternatives:</p> <ol><li><span>Store it in the database. Do I need to detail why it’s a bad idea?</span></li><li><span>Store it on the client. I makes a lot of sense to store UI-related data on the client. There’s one not no minor caveat though: if more than one tab is opened, it needs to be handled server-side somehow.</span><div> <table> <tbody><tr> <td> <i title="Note"></i> </td> <td> Vaadin manages multiple tabs by putting a hidden token when it renders the page initially. When the user interacts with the page, the token is checked, and then a new one is sent to the browser again. </td> </tr> </tbody></table> </div></li></ol> <p>While beyond ten thousands of <strong>concurrent</strong> users, I might start thinking about other alternatives than Vaadin, anything below that number is fair game. That’s 99.99% of all applications.</p> </div> <div> <h3 id="not-api-first">Not API-first</h3> <p>Another argument I’ve heard against Vaadin is that it’s not API-first. Good software developers/architects alway develop an API in order to let different kind of clients to use: browsers, but also native clients, and other services - whether internal or third-party.</p> <p>Unfortunately, I think this is herd mentality. API-first is desirable in the context of multiple clients. Most business applications I’ve worked on are just <abbr title="Create Read Update Delete">CRUD</abbr> applications with more or less business logic applied on top.</p> <p>But what if additional clients become necessary in the future? <a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it" target="_blank" rel="noopener">YAGNI</a>! If you do, remember that Twitter was able to rewrite its complete information system from Ruby on Rails to Java: migrating the GUI layer of an application is well within the bounds of the possible.</p> </div> <div> <h3 id="boring">Boring</h3> <p>Finally, while I never heard anything like that, I believe one of the reasons Vaadin is not that popular nor widespread is because it’s so boring. It has been around since more than 15 years, it works as expected, and most challenges around it have already been solved. Unfortunately, this doesn’t fit developers who practice <a href="https://blog.frankel.ch/ego-driven-architecture/" target="_blank" rel="noopener">Résumé-/Hype-/Ego-Driven Development</a>.</p> </div> </div> </div> <div> <h2 id="conclusion">Conclusion</h2> <div>  <p>Version 10 saw a massive rewrite of the framework. Product management steered it toward more web-y features, such as web components, the introduction of routes, etc. I believe this move was done in order to appeal more to web developers. To be fair, I’m not very happy with those changes.</p> <p>However, that doesn’t change the fact I’m still a huge fan of the framework. I admit it’s not as hype as JavaScript frameworks. On the other side, it’s a massive productivity boost when developing business applications compared to any other hype alternative.</p> </div> </div>   </div> </section>   </article> </div> </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>