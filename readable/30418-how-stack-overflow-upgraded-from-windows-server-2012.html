<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How Stack Overflow upgraded from Windows Server 2012 -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>How Stack Overflow upgraded from Windows Server 2012</h1>
    <div class="post-content"> <p><strong>Warning:</strong> This post is long. While working through this massive server upgrade/migration process, tears were shed, many cuss words were said, along with a general feeling of frustration, which ultimately culminated into extreme happiness once the migration was completed. The scale and complexity of the implementation factor into the length of this post, and I&#x2019;ll share my thought process on how this was executed, so here goes.</p> <p>Last year, when we upgraded to <a href="/post/how-we-upgraded-stackoverflow-to-sql-server-2017/">SQL Server 2017</a> we didn&#x2019;t make any changes to the operating system on our main production servers. They were Windows Server 2012 (not R2), and we knew that moving to another operating system would be painful because it would involve tearing down each of the clusters, rebuilding them, and potentially having extended downtime - which we really can&#x2019;t have. It sounded too difficult at the time, so it was punted&#x2026;again.</p> <p>When I was mapping out projects for 2019, at the top of my list was to move from Windows Server 2012 and move to Windows Server 2019, because &#x2018;hey, it&#x2019;s 2019 let&#x2019;s move away from 7 year old OS&#x2019;. From the start, it was obvious this would be extremely complicated, but why not start the new year off with a crazy project that gets us in a position to move to SQL Server 2019. I had never done anything like this before, but in January, I started working out how we were going to upgrade our existing production SQL Servers from Windows 2012. And in this very long post I explain all my planning, testing, unexpected issues, and implementation of this move.</p> <h2 id="reasoning">Reasoning</h2> <p>My first step was to identify the benefits of migrating. I would be spending a considerable amount of time on the project, so it was important to know what we would gain from the upgrade. There were two obvious wins 1) moving away from a 7 year old operating system, and 2) it also would allow us to move to SQL Server 2019 (yay&#x2026; more upgrades). However, the biggest benefit we were hoping for, was an improvement with our availability group log transport throughput. Our current production clusters each have 3 nodes - 2 (primary and local secondary) in New York (actually New Jersey) and 1 (remote secondary) in Colorado - and we tend to see significant delays and non-synchronizing databases in Colorado. Upgrading from 2012 to Windows 2016+ would get us gains in performance, and hopefully reduce some of our syncing issues. For me, that would be a huge plus, as I wanted to avoid seeing stuff like this repeatedly during the week:</p> <p><img src="/image/2019/notsyncing.jpg" alt="Not Synchronizing databases"></p> <h2 id="phase-1-lab-testing-all-the-things">Phase 1: Lab Testing&#x2026;All The Things</h2> <p>I&#x2019;m incredibly lucky to have a lab environment to play with. At the start of this project, I had two lab Windows Server Failover Clusters (<a href="https://docs.microsoft.com/en-us/windows-server/failover-clustering/failover-clustering-overview">WSFC</a>) - each with 2 nodes that were running Windows Server 2016, SQL Server 2017, and each cluster had availability groups (AG), as well as a distributed availability group (DAG) between the two clusters. Since I didn&#x2019;t want to destroy these clusters for the test, I needed to create new servers for testing.</p> <p>My goal was to replicate our production set-up on a much smaller scale. From there, I&#x2019;d work through different scenarios to get to the final desired result. The 2012 production clusters looked like this:</p> <p><img src="/image/2019/2012cluster.jpg" alt="Stack Overflow Windows 2012 Clusters"></p> <p>Production had two WSFCs running Windows Server 2012, each with 3 nodes. Both clusters have at least one availability group, as well as one distributed availability group going to a reporting cluster. Once this project was complete, the new clusters would look the same, however, these would have a new OS, new cluster names, and when finished, the primary SQL Server in each availability group would be the current NY Secondary.</p> <p>In order to properly test, I needed 3 servers running Windows Server 2012. Well, guess what? We didn&#x2019;t even have a way to install Windows Server 2012, and no longer had an image of the software. This left me hunting for a copy of it. Eventually I got one, but then our deployment process needed to be setup to work with 7 year old software. Once all those bits were in place, I was able to <a href="https://twitter.com/tarynpivots/status/1083158959937093632">spin up my 3 servers to test with</a>. At this point, I had a new 2012 cluster with 3 nodes (2 in NY, 1 in CO). All were running SQL Server 2017 with 2 availability groups, one AG that was limited to this cluster, and a second AG that was modeled after one in a distributed availability group.</p> <h3 id="the-will-this-even-work-test">The Will This Even Work Test</h3> <p>Before I started breaking this new test cluster, we had the idea of creating another server with Windows Server 2019 to see if it would work with the new lab cluster - basically, a test to see if the data would sync. I spun up another new server; this time it was on a fancy new operating system, Windows Server 2019, with SQL Server 2017 and was all ready to start testing. The goal was to insert the 2019 server into the mix with 2012, so it would receive data from the old server cluster. I wanted it to look like this:</p> <p><img src="/image/2019/Lab2012Cluster_2019.png" alt="Lab Cluster - single 2019 server"></p> <p>Considering I had no idea what I was doing, I tried many things to get this to work. I even tried things I knew wouldn&#x2019;t work just to cross it off the list of things tested. Here&#x2019;s a brief list of some of the things I tried:</p> <ul>
<li>Putting the 2019 server into the existing 2012 cluster - as expected, this fails due to the operating systems being different</li>
<li>Attempted to just add it to the existing AGs when not being in a cluster - this fails because it&#x2019;s not in a cluster</li>
<li>Created a separate single node cluster for the 2019 server and attempted to add as a replica to the AGs - this fails as well</li>
</ul> <p><a href="https://twitter.com/tarynpivots/status/1088158572486090752">None of these things worked.</a> I was beginning to wonder how we were going to do this. My next test was to create a new distributed availability group for each existing availability group, using that as a way to insert the 2019 server into the mix. I finally hit on something that worked for the single server. After creating a new DAG between the 2012 and 2019 cluster, I had data syncing between two clusters on different operating systems. I was ecstatic to get this to work with one server, but how would I do this with the 3 servers in a single cluster, with all the AGs and distributed AGs already in play?</p> <h3 id="the-mock-up-production-test">The Mock-up Production Test</h3> <p>Once I knew I could have clusters with different operating systems, synchronizing data via distributed AGs, I needed to attempt this with the new 2012 lab cluster. Since it was already working as a stand-alone cluster with SQL Server running, I wanted to set up a test that was as close as possible to what we have in production. I needed a replica of our reporting cluster. A bell went off in my head, &#x2018;Ding! Ding!&#x2019; I had an existing 2016 cluster in my original lab environment - that would be perfect to use for this.</p> <p>My plan of attack for this test was to first setup a DAG between the 2012 cluster and the original lab cluster running on 2016. This would be similar to what we had in production at the time. Basically we&#x2019;d have the following:</p> <p><img src="/image/2019/Lab2012_2016Cluster.png" alt="Lab Cluster - 2012 to 2016"></p> <p>When that was setup and synchronizing, I had a decent, albeit, small version of our production setup. It was now time to start breaking things. My thinking was to start with the NY secondary server and perform the following steps:</p> <ol>
<li>Evict it from the existing 2012 cluster</li>
<li>Rebuild it with the Windows Server 2019</li>
<li>Create a new WSFC with one node</li>
<li>Install SQL Server 2017</li>
<li>Finally, create new distributed AGs from the old cluster to the new one to sync the databases with that AG</li>
</ol> <p>My next step was to do the same thing with the CO secondary in the 2012 cluster. The difference being, it could just be added as a node to the new WSFC, and as a replica to the AGs in the new cluster. At this point in the process, I&#x2019;d have the old 2012 cluster with a single server sending data to two clusters - the mocked up 2016 reporting cluster and the new 2019 cluster. Visually it&#x2019;d look like this:</p> <p><img src="/image/2019/Lab2012_2016_2019cluster.png" alt="Lab Cluster - 2012 to 2016 and 2019"></p> <p>Before upgrading the last 2012 server, I would need to perform a failover of the distributed AGs from the 2012 cluster to the new 2019 cluster. In looking at this, there was one glaring problem&#x2026;the reporting cluster. If I performed a failover of the distributed AGs to the new 2019 cluster, the reporting cluster would stop getting data. I saw there were two options:</p> <ol>
<li>Perform the failover and let the reporting cluster fall out of sync until I could get it everything back in place</li>
<li>Move the reporting cluster and it&#x2019;s distributed AGs to the receive data before I failed over to the new 2019 cluster and &#x201C;hope&#x201D; things just starting syncing again.</li>
</ol> <p>Either way, the databases on the reporting cluster were going to fall out of sync, so I chose the first option for the lab.</p> <p>Now that the decision was made, it was easy peasy to finish the move in the lab. There was only one server left in the old cluster, so my steps were to failover the distributed AGs to the new 2019 cluster (yes, I tested failing back just in case), destroy the 2012 cluster, rebuild the server with Windows 2019, add it to the 2019 WSFC, install SQL Server, and add it as a replica to all the AGs. Yay, everything was done! What&#x2019;s left was just a bit of clean-up of the reporting cluster distributed AGs, and then I was ready to move to production with the plan.</p> <p>I spent the next week writing up all the steps to move to production. There were a lot of moving pieces for production. I had to move the following:</p> <ul>
<li>2 WSFC</li>
<li>6 servers with new OS, fresh SQL Server installs</li>
<li>5 availability groups with a total of about 385 databases</li>
<li>5 AGs means 5 temporary distributed AGs to help with the move</li>
</ul> <p>This also meant we needed new IP addresses for the clusters, AG listeners, as well as new names for the clusters, AGs, distributed AGs, and listeners. During my testing I discovered that you can&#x2019;t use the same names for these objects, even when they&#x2019;re on different servers, which resulted in a lot of legwork to get prepped for the move to production, but I was ready&#x2026;or so I thought.</p> <h2 id="phase-2-the-part-where-i-broke-dev">Phase 2: The Part Where I Broke Dev</h2> <p>Pretty much the entire month of January, I tested and worked through how this would be done in production. I originally targeted February to start the production servers. I was wrong.</p> <p>During the final stages of review, a suggestion was made to test an upgrade to Windows Server 2019 on a few development servers, to ensure we wouldn&#x2019;t hit any hiccups with the OS when it went to production. Our main development servers for Core Q&amp;A have the same hardware and set-up as production, but don&#x2019;t run any AGs - the servers only have copies of the databases for development. In testing the OS against these servers, we&#x2019;d be able to perform some load testing, and I could make sure our deployment process of the OS would work.</p> <p>I picked three servers to test against - two VMs and one physical server. We use <a href="https://theforeman.org/">Foreman</a> to automatically (re)build servers, which made the process relatively painless to deploy and rebuild servers. Since Windows Server 2019 had never been deployed, it wasn&#x2019;t setup in Foreman. This meant I had to upgrade the servers by hand, as an in-place upgrade - this was done on the two VMs. Aside from some minor issues, everything went according to plan. The OS deployed just fine, and I easily reinstalled SQL Server across the board. The servers were back up and running within a few hours.</p> <p>Next, it was time to deploy Windows Server 2019 to a physical server. That&#x2019;s when everything went off the rails.</p> <p>As I mentioned, our main dev servers have similar hardware to our production servers, which means we have a drive for the OS, a data drive for SQL with NVMe/PCIe, and possibly a third drive with spinny disks. The physical server I tested the upgrade against had all three drives. I kicked off the rebuild, and about two hours into the process the dreaded blue screen of death hit:</p> <p><img src="/image/2019/BSOD.jpg" alt="BSOD"></p> <p>Very quickly, we spotted the issue. The NVMe drivers didn&#x2019;t work for Windows Server 2019. Oh crap. Thankfully, I have awesome teammates who jumped into a hangout and helped debug. After discussing, we attempted to upgrade the driver to the new one, and, of course, that bombed. Then one of the NVMe drives looked like it failed. After some poking, the &#x201C;failed&#x201D; drive came back online and we were able to get the server back to its 2016 state pre-upgrade attempt.</p> <p>Now what?</p> <p>We still wanted to move to 2019, but the new driver wasn&#x2019;t working with our NVMe RAID, which meant time to contact both Dell and Intel. With their help, we might be able to get the correct drivers and software to work with our drives and the NVMe RAID. Eventually, we got the necessary bits and had the new drivers in place with software that recognized our RAID. Next, it was time to test another 2019 deployment. After two hours into rebuild #2, I was staring at a 45% completion:</p> <p><img src="/image/2019/2hUpdates.jpg" alt="Upgrade Progress"></p> <p>I tried not to worry and went on to other tasks. At hour 6 of being stuck at 45%, I was concerned. Even though this deployment hadn&#x2019;t finished, it was obviously stuck, so we decided to attempt another fresh rebuild&#x2026;#3.</p> <p>When rebuild 3 began, everything seemed to be going ok. Once up and rebooted, we were back to a 2016 Windows Server. WTH?!?! This time we also had a freshly formatted 2TB NVMe partition&#x2026;meaning all of our SQL data on the NVMe drives was gone. We decided to try once more, this time disabling the PCIe slots in the BIOS and trying another fresh rebuild - this time #4.</p> <p>Our confidence level in moving to Windows Server 2019 was quickly dropping, but we wanted to see if we could get it to work. Our 4th rebuild, finally got 2019 installed on the server, but we hit another issue. When the PCIe slots were re-enabled, we only had 2 disks show up in the RSTe manager and in disk management on the server, but everything was showing in the Device Manager.</p> <p>Ugh, why are they not matching? There were so many weird problems with this server.</p> <p>The next step was to send someone to the data center to physically unplug &amp; drain the power from the box to see if the issues with the PCIe slots would sort itself out - we have done this in the past and it worked. Unfortunately, our trick of draining power didn&#x2019;t work. We still only had two disks show up&#x2026;<em>sigh</em>. That means time for another rebuild.</p> <p>This time we were going to try to rebuild the server to 2016 with the old drivers for the SSDs to see if we could at least get it back to the state it was before the upgrade to 2019. The hope was that if we rolled back the driver, the PCIe slots might come back to life and the drives would miraculously work again. Off to rebuild #5.</p> <p>After fighting with the server to use the older drivers, I finally got them installed and kicked off another rebuild. Unfortunately, this time we had a failure because the deployment failed to join the server to the domain and we couldn&#x2019;t login to the server&#x2026;seriously, the server was possessed.</p> <p>Yay, another rebuild (#6) to try to get it on the domain, with Windows Server 2016, and old drivers so the SSDs work. Guess what? This failed again, due to issues joining the domain. Again, my teammates rescued me and got into a hangout to beat the server into submission and get it joined to the network. Once it was finally joined to the domain, there was another freaking issue.</p> <p><img src="/image/2019/rebuild7.png" alt="Rebuild 7 Failure"></p> <p>It was getting ridiculous with this server. I found a way to <a href="https://www.thewindowsclub.com/computer-restarted-unexpectedly-encountered-unexpected-error">hack it back into submission</a> because at this point anything was worth trying. The OS finally installed, but we had two very dead SSDs. They were showing up as 0GB. We tried upgrading firmware&#x2026;nothing worked. The drives were dead. It was time to open a ticket with Intel since the drives were still under warranty. It was now a waiting game, until Intel confirmed the drives were fried.</p> <p>While we were waiting for new drives from Intel, my teammate, <a href="https://twitter.com/thefarseeker">Mark Henderson</a>, spent time fixing up our Foreman deployment to work with 2019 and to bypass the NVMe drives when installing an OS. You know what that means&#x2026;more rebuilds. Actually 3 more - one to 2016, one to 2019, and then one back to 2016 for a total of 9 rebuilds of Windows (so far) on a single server.</p> <p>You might be wondering why we went back to 2016 after we finally successfully installed 2019?</p> <p>This was done because our confidence level in using 2019 with our SSDs was pretty much gone. Intel no longer makes the drivers public, and referred us to Dell, and then Dell sent us back to Intel - it was a back and forth game - which wasn&#x2019;t a good position to be in for production. Combined with multiple failures and dead SSDs, we didn&#x2019;t feel comfortable moving forward with Windows Server 2019 on our production servers. We couldn&#x2019;t risk killing our SSDs due to the install. We knew that 2016 worked with them because Dev had been using it for years, and we&#x2019;d get the benefits of moving off of Windows Server 2012, so we made the decision to skip Windows Server 2019 at this time.</p> <p>About 2 weeks later, we finally had new SSDs. It was now time to get them installed and test the deployment process again. Here we go with rebuild #10. Time to hopefully get a clean install of Windows Server 2016 - I spoke too soon. The rebuild failed. No, I&#x2019;m really not joking.</p> <p>On top of using Foreman, we use <a href="https://puppet.com/">Puppet</a> to get our servers in a desired state - the failure this time appeared to be due to a Puppet issue, but there was, of course, nothing in the error log that pointed to the issue. We had yet another failure, and we wanted one clean install on this server, meaning no issues whatsoever. That meant another rebuild to see if we could get an install with zero errors. This server wasn&#x2019;t quite ready to be nice, we hit various issues with the install process and it took 4 more times before we had a clean build of the server for a total of 14 times!! After all the issues, we finally had a dev server almost back to its original state - Windows Server 2016, now it just needed SQL Server and that&#x2019;s super easy to install, right?</p> <p>I moved on to installing SQL Server 2017 again, and since this server was terrible on every level we ran into more issues. I have a couple of PowerShell scripts that I use to install SQL Server which work all the time, except on this server. There were errors installing the SqlServer module, then there were really odd issues with SPNs for the server not being tied to the proper account and the server was associated to me - it really was cursed. After a ton of more issues (you really don&#x2019;t want details on everything), we finally had a dev server back in place. All databases were restored, and things were working again.</p> <p>Now what? Well, we had another dev server to test this against, this time our NY dev server. We decided to try a clean install against that server, but first we spent about a week trying to fix all of the weird issues we were hitting with the CO dev server&#x2026;yes, that means more rebuilds. Once everything was working without issue, it was time to move to NY Dev. Our NY Dev server is critical path for pushes to production, so that rebuild involved a bit of juggling, but eventually I was able to rebuild it and yay, there were no issues with SSDs or really anything else that would be a blocker for moving to production.</p> <p>By the time I finally got done with NY Dev, it was about 2 weeks into April, that means it was over two months of working through all the issues with the development deploys. I was totally ready to move this project along and touch production.</p> <h2 id="phase-3-time-for-production">Phase 3: Time For Production</h2> <p>It was now into April, and I thought this was going to be finished in February, so you could say I was extremely anxious to finish this project and move on to other things. Since our development environment was finally done and it appeared that our deployment process was working, I revisited the plan I wrote in January for our production environment.</p> <p>I opened the Google Doc that I initially wrote and started expanding it into a very detailed plan on the deployment process. I spent several days writing out each step for every server we would be moving around. I tried to include everything I could think of. The step for each server even had the code that would be executed on it. This was probably the most detailed plan I had ever written, I attempted to cover everything I would think of. <a href="https://twitter.com/Nick_Craver">Nick Craver</a>, then added more details because the connection strings for each application would be changing due to moving to new listeners.</p> <p>I was ready to go. We were ready to go. The runbook had about <a href="https://twitter.com/tarynpivots/status/1116831409681756160">35 pages of notes and code to execute</a> in the entire plan.</p> <p>Every server had a detailed list of steps including obvious things to more complicated pieces. Inside of the document, you could look up any server and find a list similar to this:</p> <p><strong>Server Name (Date)</strong></p> <ol>
<li>Stop Transaction Log backups on primary</li>
<li>Remove read-only routing from the AGs (this is done on the primary) - including code snippet to run on the primary</li>
<li>Flush connections in the app</li>
<li>Disable full backups on primary</li>
<li>Remove server from the existing AGs on primary</li>
<li>Evict server from current cluster</li>
<li>Setup server in Foreman for 2016 deployment, kick off the rebuild</li>
<li>Make sure puppet is up and running after the rebuild</li>
<li>Once done rebuilding, add Failover Cluster role to the server (this forces a reboot)</li>
<li>Create new WSFC (only on the first server in the cluster)</li>
<li>Once the Cluster Object is created in AD, then move it, if needed, to the proper Cluster Objects OU</li>
<li>After cluster creation, verify the IP addresses are correct and edit them, as needed</li>
<li>Make sure the WFSC cluster object has permissions to create/delete computer objects in AD</li>
<li>Install Dell NVMe tools</li>
<li>Install SQL Server &#x2013; if the tempdb is still located on D:\Data - delete all the files first</li>
<li>Turn on trace flags &#x2013; restart SQL service</li>
<li>Execute scripts to add logins / users / stored procs / linked server</li>
<li>Create New AGs</li>
<li>For each AG create new temporary distributed AG aka the TAG (our temporary distributed availability group for the migration) - created on the current primary and then the secondary</li>
<li>At this point everything should be syncing to the newly built server, and it&#x2019;s a single server on its own cluster</li>
<li>Re-create sql jobs</li>
<li>Disable backup jobs for user databases</li>
<li>Re-enable backup jobs on primary server in old cluster</li>
</ol> <p>While the steps were different for each server, this was basically what I needed to do. By the end of Wednesday, April 17th, 2019, if we were lucky I&#x2019;d have moved 3 servers to the new clusters, and would have SQL Server installed with everything syncing as I tested. The goal by the end of Day 3 was to have things looks a bit like this:</p> <p><img src="/image/2019/Day3Goal.jpg" alt="Goal by Day 3"></p> <p>I <a href="https://meta.stackexchange.com/revisions/326718/3">announced</a> we were going to start on <a href="https://twitter.com/Nick_Craver/status/1116445650453966857">Monday, April 15th</a> and finish the following week. I felt pretty confident that we were ready for production. There was absolutely no way we&#x2019;d have issues like we did on the development servers, right? Wrong. Oh did we ever hit unexpected issues.</p> <h3 id="day-1">Day 1</h3> <p>The very <a href="https://twitter.com/tarynpivots/status/1117724066884931584">early morning of April 15th rolled around</a>, and I kicked off the plan for the very first server, NY-SQL03, the NY secondary in the SE cluster. Everything went according to plan, Windows installed, SQL Server installed, new cluster set-up - all 4 temporary distributed availability groups (aka our TAGs) were in place. We had all databases syncing and reporting green in Opserver at the end of the end. Day 1 done, so far, so good - one server down, 5 more to go.</p> <h3 id="day-2">Day 2</h3> <p>The day started just as early because if things went well, I was going to tackle two servers, NY-SQL01, the NY secondary in the SO cluster, as well as CO-SQL03, our Colorado remote secondary in the SE cluster. I kicked off the rebuild on both servers, and NY-SQL01 was back in working order within a few hours with everything syncing as we expected. The other server, CO-SQL03, was another story.</p> <p>While CO-SQL03 was rebuilding, I started to notice some weirdness&#x2026;yes, weirdness (that&#x2019;s a technical term, right?) with the server I rebuilt the day before - NY-SQL03. As a quick reminder, this server was currently the only node in the new 2016 cluster. It had about 375 databases which were in 4 availability groups, and 4 distributed availability groups - the distributed AGs were being used to keep the data in sync between the old 2012 cluster and the new cluster. The breakdown of number of databases per AG was:</p> <ul>
<li><code>AG-NYOnly</code> - 6 databases syncing via distributed AG - <code>NYOnly_TAG</code></li>
<li><code>AG-Misc</code> - 10 databases syncing via distributed AG - <code>Misc_TAG</code></li>
<li><code>AG-Chat</code> - 3 databases syncing via distributed AG - <code>Chat_TAG</code></li>
<li><code>AG-SENetwork</code> - 354 databases syncing via distributed AG - <code>SENetwork_TAG</code></li>
</ul> <p>Now, that you&#x2019;ve had a reminder of what we had on the server, let me explain what I meant by &#x201C;weirdness&#x201D;. One of the primary ways we monitor our servers is through <a href="https://github.com/opserver/Opserver">Opserver</a>. After hours of what appeared to be databases syncing without any issues I started to notice that we were hitting blocking when trying to get the status of the availability groups and databases when querying the DMVs as Opserver does. And not just a little bit of blocking. This was significant blocking on everything. We couldn&#x2019;t get any details in SSMS on the databases or availability groups. If you attempted to open any details in SSMS (AGs, databases), it would lock your session and you&#x2019;d have to kill it in Task Manager.</p> <p>Everything we tried to get the state of the AGs was locking up, even <a href="https://twitter.com/Nick_Craver/status/1118316671721250816">directly querying the DMVs in SSMS</a>. We were seeing tons of <a href="https://www.sqlskills.com/help/waits/hadr_ag_mutex/">HADR_AG_MUTEX</a> waits:</p> <p><img src="/image/2019/HADR_blocking.png" alt="Waits NY-SQL03"></p> <p>In addition to the locking, we noticed a lot of inconsistencies in what was being returned via the queries. One minute it looked like the availability groups were fine, the next it was in a not-synchronizing state. We realized that we couldn&#x2019;t trust the state of the AGs on the server. After hours of looking at this and trying to debug, I decided to drop our temporary distributed AGs, the TAGs, to see if rebuilding them would work because nothing else was working at this point.</p> <p>I started recreating some of the TAGs to see if things would sync, as I created each one, they would start to sync, but we were still hitting significant waits and locking.</p> <p>We tried restarting the SQL Server service. We tried stopping the availability groups in the WSFC. We were seeing errors in the logs that the AGs were in a failed state, we couldn&#x2019;t query the DMVs, we didn&#x2019;t have any idea what was happening. It looked like the 2 distributed AGs that were small were working, even though checking their health was very slow.</p> <p>It was time to try to recreate the <code>SENetwork_TAG</code>, the one with the 354 databases. Early on in this process, we stopped Transaction Log backups and Daily Backups, so we had a couple of options:</p> <ol>
<li><a href="https://docs.microsoft.com/en-us/sql/database-engine/availability-groups/windows/automatic-seeding-secondary-replicas?view=sql-server-2017">Autoseed the databases</a> as you can with availability groups</li>
<li>Use the old backup of the SE Network databases (the one from before we started the migration process), and restore it to the NY-SQL03 server, letting it get caught up with the AG syncing</li>
<li>Take a new backup of the databases in the AG, restore it to NY-SQL03 again, and then join it to the AG to let things start syncing.</li>
</ol> <p>Considering the slow querying of the DMVs and the AG health, we went with number 3. I took a recent backup of the database from the primary server in the old cluster and restored it to the new server with <code>NORECOVERY</code>. The thinking was that this would prevent overloading the server by automatically trying to seed 354 the databases all at once. Once all the databases were restored, we would execute the following on each one:</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="k">ALTER</span> <span class="k">DATABASE</span> <span class="o">&lt;</span><span class="n">database_name</span><span class="o">&gt;</span> <span class="k">SET</span> <span class="n">HADR</span> <span class="n">Availability</span> <span class="k">Group</span> <span class="o">=</span> <span class="p">[</span><span class="n">AG</span><span class="o">-</span><span class="n">SENetwork</span><span class="p">];</span></code></pre></td></tr></table>
</div>
</div> <p>Problem was, this was really slow. Doing this for each database was taking a <a href="https://twitter.com/tarynpivots/status/1119303103466000385">couple of minutes per database</a> and we have 354 of them. The waits we were hitting were downright unbelievable:</p> <p><img src="/image/2019/wait_stats.jpg" alt="Wait stats"></p> <p>The amount of time to execute the command against each database exponentially increased as we were adding more and more databases. It was going to take hours to get through them all. It was super late in the day, and Nick and I had been debugging and working in a hangout for many, many hours. Nick quickly wrote a script to loop through all of the databases in the <code>SENetwork_AG</code> and execute the SQL above. This automated the process which allowed it to run overnight, and more importantly allowed us to step away from our desks after far too many hours. We hoped everything would be in the AGs in the morning, so we could debug some of the issues we were seeing and potentially move forward with the upgrades.</p> <h3 id="days-3-7">Days 3-7</h3> <p>Yes, that really says Days.</p> <p>The script eventually finished and we had all databases in the AG, however, we were still seeing tons of waits. I was chatting with some of the users on our <a href="https://dba.stackexchange.com/">Database Administrators Stack Exchange</a> site, and there were suggestions to <a href="https://www.sqlskills.com/help/waits/parallel_redo_flow_control/">disable parallel redo</a> on the server, as well as other things. We tried everything we could think of, and still didn&#x2019;t know if things were syncing because we couldn&#x2019;t get an accurate read from the DMVs or get passed the waits. Since nothing was working, it was time to open a ticket with Microsoft. Our ticket was opened, the server was creating plenty of mini-dumps that went sent along with memory dumps, and now it was time to wait for help.</p> <p>A quick aside: while waiting for things to get moving with Microsoft, we attempted to get CO-SQL03 back in a good state. We take local <a href="https://docs.microsoft.com/en-us/sql/relational-databases/backup-restore/copy-only-backups-sql-server?view=sql-server-2017">copy-only</a> backups in Colorado, so we don&#x2019;t have to deal with trying to move terabytes of datafiles from NY to CO in the event of an issue. All of that typically is fine, but due to the issues, we ended up being down for far longer than expected. This meant our backups in CO were very far behind the current state of things in production. In order to get CO-SQL03 in working order, we needed to copy all of the database backups from NY to CO, which was going to take a really, really long time. Good thing we weren&#x2019;t in a hurry, huh? We kicked off a process to copy the current backups from NY and get them moved to CO. With <a href="https://twitter.com/shanemadden">Shane Madden</a> and Nick Craver&#x2019;s quick thinking, we copied all of the files in less than a day. Now that we had good backups, I restored all of the databases in <code>NORECOVERY</code> so they would be ready whenever NY-SQL03 box was back up and running.</p> <p>Our Microsoft ticket was forwarded and we began working with one of our DBA.SE users who happens to work for Microsoft, <a href="https://dba.stackexchange.com/users/41723/sean-gallardy">Sean Gallardy</a>. At this point, it was time to go back to the regularly scheduled painful upgrade process. Based on the memory dumps, one of the first things Sean suggested was to make sure that auto-seeding of the databases in the <code>SENetwork_TAG</code> was disabled, so we executed:</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="k">ALTER</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="p">[</span><span class="n">SENetwork_TAG</span><span class="p">]</span> <span class="k">MODIFY</span> <span class="n">REPLICA</span> <span class="k">ON</span> <span class="s1">&apos;NY-SQL03&apos;</span> <span class="k">WITH</span> <span class="p">(</span><span class="n">SEEDING_MODE</span> <span class="o">=</span> <span class="n">MANUAL</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div> <p>While this prevented the databases from automatically being seeded, it didn&#x2019;t resolve our issue. We were still failing to sync databases on the new cluster, and we were dropping mini-dumps like crazy on NY-SQL03. It was back to the drawing board with ideas to fix all the things. Nick and I got onto a really long hangout with Sean (thanks Sean), to debug and work through various ways to fix the problem. Eventually, Sean suggested that we try the following:</p> <ol>
<li>Destroy the temporary distributed availability group (TAG) for the <code>SENetwork</code>, since that was our problem child</li>
<li>Destroy the availability group on the new cluster</li>
<li>Manually restore the databases to both NY-SQL03 and CO-SQL03 in a restoring state</li>
<li>Recreate the temporary distributed availability group for the <code>SENetwork</code></li>
<li>Add each database to the availability groups on both NY-SQL03 and CO-SQL03 very slowly so they could sync</li>
</ol> <p>That&#x2019;s what we did. Another really slow process, and when I say slow I mean <a href="https://twitter.com/tarynpivots/status/1119407499453452288">2-4 databases at a time</a> - and we had 354 to add, so it was painfully slow, but it worked.</p> <p>We were hitting a <a href="https://support.microsoft.com/en-us/help/4501797/fix-data-movement-to-dag-forwarder-does-not-resume-automatically-after">bug with SQL Server</a>. The bug had to do with distributed availability groups that had more than 15 databases and, of course, we had that. Our <a href="https://twitter.com/tarynpivots/status/1119576626272980997">distributed availability group contained 354 databases</a> and it couldn&#x2019;t handle that many, resulting in it timing out. We got a workaround by following the steps above were able to move forward.</p> <p>By the end of the week we had <a href="https://twitter.com/tarynpivots/status/1119430961010135041">two new clusters up and receiving data from the old 2012 clusters</a>. It was now time to finish moving pieces around so we could perform the failover of the temporary distributed availability groups. Even though we lost several days working through bugs, we were in a better, more stable state and could plan the date of the failover - if everything else went according to plan, it would be in just a <a href="https://twitter.com/tarynpivots/status/1120152909331566595">few days</a>. To help visualize where we were at the end of this week, our servers were in this state:</p> <p><img src="/image/2019/EndofWeek1.jpg" alt="Week 1 State of Servers"></p> <p>After a pretty quiet weekend, only a few minor hiccups with data syncing, we were ready to pick up and go full steam ahead to wrap things up.</p> <h3 id="day-8">Day 8</h3> <p>Monday morning rolled around and there were <a href="https://twitter.com/tarynpivots/status/1120335610307235841">3 servers left and one huge failover</a> to do. Surely, we had hit all of the bugs and it was going to be a clear path to the finish line, right?</p> <p>I started the day by evicting CO-SQL01 from its old cluster and kicking off the rebuild process. Ugh, and I hit some issues. The automated process, Foreman, didn&#x2019;t want to work without some poking and prodding to get it moving, then the server didn&#x2019;t want to find the Windows Updates it needed, but eventually the rebuild finished. I was able to install SQL Server, restore backups in a <code>NORECOVERY</code> state, apply all the transaction logs to bring it up to current state, and just like that, we had syncing data.</p> <p>We finally had 4 servers in the new clusters, and they were reporting green everywhere.</p> <h3 id="day-9-failover-day">Day 9 - Failover Day</h3> <p>The big day was here. It was time to perform the failover of 5 temporary distributed availability groups, with hopefully very little downtime. I previously tested the whole process in the lab, but had never done this in production. And considering all the problems we hit up to now, I was feeling just a <a href="https://twitter.com/tarynpivots/status/1120809488011780096">wee bit stressed out</a>.</p> <p>The morning of the failover, we spent time going over the steps that would be executed that night. We wanted to make sure that we had accounted for all of the application side changes that were needed as well. The complexity of this whole thing wasn&#x2019;t limited to just failing over the SQL Servers. We also needed to rebuild and push out new versions of all of our applications and services due to changes to the connection strings.</p> <p>You might be wondering why we needed to do that? All of our application connection strings point to global listeners and since we had new clusters with new AGs/distributed AGs - they all needed to be created with new listeners (IP Addresses) and new names. This means that prior to the failover, the applications were pointing to the old listeners. In order for them to work when we failed over, the apps needed to be rebuilt to production to point to the new listeners.</p> <p>We also needed to be very deliberate about the order of things on the failover day.</p> <p>The first thing we considered were exceptions. We have a database called <code>NY.Exceptions</code> which we use to capture errors that occur throughout the network. We needed to be sure it would still capture errors, in the event the failover failed. To do this, we removed the <code>NY.Exceptions</code> database from both the old and new AGs and made sure the database was writable on both the new and the old clusters. We also added both databases to our monitoring in Opserver to catch lingering applications pointing to the wrong place. This would let us collect errors, even if things went wrong with a failover.</p> <p>Next, we had to think about how to push our application changes to production. We use <a href="https://www.jetbrains.com/teamcity/">Team City</a> to deploy our applications, which has a database on SQL Server. We needed to be sure that Team City was available before we moved forward. As a result, the <code>NYOnly_AG</code> was the very first one to failover. We pushed a change to the connection string from <code>SQL-NYOnly_AG</code> to <code>SQLAG-NYOnly</code> and built out the application. Once that was done, it was time to do the distributed availability group failover.</p> <p>Based on my testing and the <a href="https://docs.microsoft.com/en-us/sql/database-engine/availability-groups/windows/configure-distributed-availability-groups?view=sql-server-2017#failover">Microsoft Docs</a> performing a failover of a distributed availability group is a manual process. The code needs to be executed on the current primary server, validated, then more code has to be executed, then validated, and repeat until it&#x2019;s all done. In my huge planning document, I wrote all the code to perform the failover steps. Now it was time to execute them. Since we were going to be failing over the temporary distributed availability group called, <code>NYOnly_TAG</code> we executed the following steps:</p> <ol>
<li><p>On the current global primary server in the DAG (NY-SQL04) change the DAG to <code>SYNCHRONOUS_COMMIT</code></p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"> <span class="k">ALTER</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="p">[</span><span class="n">NYOnly_TAG</span><span class="p">]</span> <span class="k">MODIFY</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="k">ON</span> <span class="s1">&apos;NYOnly_AG&apos;</span> <span class="k">WITH</span> <span class="p">(</span><span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">SYNCHRONOUS_COMMIT</span><span class="p">),</span> <span class="s1">&apos;AG-NYOnly&apos;</span> <span class="k">WITH</span> <span class="p">(</span><span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">SYNCHRONOUS_COMMIT</span> <span class="p">);</span>
    </code></pre></td></tr></table>
</div>
</div></li> <li><p>Verify the commit state is <code>SYNCHRONIZED</code> on the global primary (NY-SQL04):</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"> <span class="k">SELECT</span> <span class="n">ag</span><span class="p">.</span><span class="n">name</span> <span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">database_id</span> <span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">group_id</span> <span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">replica_id</span> <span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">synchronization_state_desc</span> <span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">end_of_log_lsn</span> <span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_hadr_database_replica_states</span> <span class="n">drs</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">sys</span><span class="p">.</span><span class="n">availability_groups</span> <span class="n">ag</span> <span class="k">ON</span> <span class="n">drs</span><span class="p">.</span><span class="n">group_id</span> <span class="o">=</span> <span class="n">ag</span><span class="p">.</span><span class="n">group_id</span><span class="p">;</span> 
    </code></pre></td></tr></table>
</div>
</div></li> <li><p>Once we&#x2019;re in a <code>SYNCHRONIZED</code> state, set the global primary (NY-SQL04) to a <code>SECONDARY</code> role</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"> <span class="k">ALTER</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="n">NYOnly_TAG</span> <span class="k">SET</span> <span class="p">(</span><span class="k">ROLE</span> <span class="o">=</span> <span class="n">SECONDARY</span><span class="p">);</span>
    </code></pre></td></tr></table>
</div>
</div></li> <li><p>Now the AG is not available for write traffic. Test that we&#x2019;re ready to failover by executing the following on both the former global primary (NY-SQL04) and the soon to be new global primary (NY-SQL03). This query verifies that the <a href="https://docs.microsoft.com/en-us/sql/relational-databases/backup-restore/recover-to-a-log-sequence-number-sql-server?view=sql-server-2017#LSNs">LSN</a> is the same on both servers.</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"> <span class="k">SELECT</span> <span class="n">ag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">database_id</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">group_id</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">replica_id</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">synchronization_state_desc</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">end_of_log_lsn</span> <span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_hadr_database_replica_states</span> <span class="n">drs</span> <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">sys</span><span class="p">.</span><span class="n">availability_groups</span> <span class="n">ag</span> <span class="k">ON</span> <span class="n">drs</span><span class="p">.</span><span class="n">group_id</span> <span class="o">=</span> <span class="n">ag</span><span class="p">.</span><span class="n">group_id</span><span class="p">;</span>
    </code></pre></td></tr></table>
</div>
</div></li> <li><p>Perform the failover to the new global primary (NY-SQL03)</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"> <span class="k">ALTER</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="n">NYOnly_TAG</span> <span class="n">FORCE_FAILOVER_ALLOW_DATA_LOSS</span><span class="p">;</span>
    </code></pre></td></tr></table>
</div>
</div></li> <li><p>Change the state of the distributed availability group back to <code>ASYNCHRONOUS_COMMIT</code> this is done on the new global primary (NY-SQL03)</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"> <span class="k">ALTER</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="n">NYOnly_TAG</span> <span class="k">MODIFY</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="k">ON</span> <span class="s1">&apos;NYOnly_AG&apos;</span> <span class="k">WITH</span> <span class="p">(</span><span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">),</span> <span class="s1">&apos;AG-NYOnly&apos;</span> <span class="k">WITH</span> <span class="p">(</span><span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">);</span>
    </code></pre></td></tr></table>
</div>
</div></li>
</ol> <p>At this point, our first distributed availability group had failed over and things were writable again. Only 4 more to go!</p> <p>We could capture exceptions and with Team City up an running, it was time to tackle the next DAG, <code>Chat_TAG</code>. We performed the same steps listed above, on that DAG. Chat was selected to be done next, because we use our chat platform internally, and having it accessible is very important. When I&#x2019;m doing regular maintenance on the SQL Servers, the <code>Chat_AG</code> is one of the first AGs we failover, and that the pattern held for the DAG failover. After executing all the steps above, we successfully <a href="https://twitter.com/tarynpivots/status/1120838257200156672">failed over Chat</a>.</p> <p>2 down, 3 to go! Time for the more critical stuff to be tackled.</p> <p>To minimize impact for users, we did the failover during the latter part of the day. Next up in the failover process was the DAG that contained the <code>Careers</code> database. By doing this, it would mean the end of syncing to the reporting cluster. We knew it was going to happen eventually, and held off as long as we could. Our stakeholders knew this was part of this failover process. The goal was to be back online as soon as possible once the entire failover process was complete.</p> <p>Before starting the failover, the old distributed availability group between the 2012 cluster and the reporting cluster was destroyed. This was done because we knew the syncing to the reporting cluster would stop when we failed over. There was no need to have this extra layer of complexity and strain on the NY-SQL04 server. After the <code>HighAvailability_DAG</code> was destroyed, we set the Jobs area of the site to read-only, replaced all the connections strings in the applications, and then rebuilt them. It was then time failover the new DAG, <code>Misc_TAG</code>. Again, everything failed over without any issues. The <code>Careers</code> database was writable again, we moved Jobs out of read-only, and we were now more than half-way done with the failover.</p> <p>The final two failovers were for the <code>StackOverflow_TAG</code> and <code>SENetwork_TAG</code> distributed AGs. These meant that we were going to have a bit of downtime. We were also planning on doing them in rapid succession. These two distributed AGs contain all the databases that handle the entire network of sites, and we wanted to fail them over as fast as possible to reduce the downtime. We pushed all new connection strings, the apps were rebuilt, and we were ready. All sites were set to read-only and it was go time.</p> <p>First up, was the <code>StackOverflow_TAG</code>, as this only had 5 databases, and we figured it&#x2019;d be quicker than our problem DAG, <code>SENetwork_TAG</code> - aka the one with 354 databases. I destroyed the old distributed availability group going to the reporting cluster, and we began the process to failover this DAG. Thankfully we hit no issues with it.</p> <p>We were in the home stretch for the failovers with only one left&#x2026;the big one. We hit so many issues with this distributed availability group when trying to get it set up, we were concerned about what would happen when we failed over. Unable to wait any longer, I kicked off the steps above to start the failover. It moved to <code>SYNCHRONOUS_COMMIT</code> without any problems, the databases on NY-SQL04 all reported to be in a <code>SYNCHRONIZED</code> state, and I moved the server to be a <code>SECONDARY</code> role in the DAG.</p> <p>So far so good. Now it was time to verify the LSNs between the two servers using:</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="k">SELECT</span> <span class="n">ag</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">database_id</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">group_id</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">replica_id</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">synchronization_state_desc</span><span class="p">,</span> <span class="n">drs</span><span class="p">.</span><span class="n">end_of_log_lsn</span>
<span class="k">FROM</span> <span class="n">sys</span><span class="p">.</span><span class="n">dm_hadr_database_replica_states</span> <span class="n">drs</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">sys</span><span class="p">.</span><span class="n">availability_groups</span> <span class="n">ag</span> <span class="k">ON</span> <span class="n">drs</span><span class="p">.</span><span class="n">group_id</span> <span class="o">=</span> <span class="n">ag</span><span class="p">.</span><span class="n">group_id</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div> <p>Executing that query on both servers (NY-SQL04 and NY-SQL03) and trying to verify that the LSNs were the same on 354 databases was not what I&#x2019;d call an enjoyable process. We would verify, then re-verify and something would change, so we&#x2019;d verify again, and again. It took some time to figure out if we were in a good state to failover. Our goal was to not lose any data, but trying to make sure we had a match against all the databases was pretty tough. Once we were reasonably confident, we made the call that it was time to finish the failover of this DAG, so I executed the commands to failover the <code>SENetwork_TAG</code>. Once the failover command was executed, the new primary (NY-SQL03) came up just fine, and was responsive for us to query it. We were done with all of the temporary distributed availability groups, and all of the sites went back to read/write. <a href="https://twitter.com/tarynpivots/status/1120859302296637440">Failover done!</a></p> <p>We thought we were in the clear, but the former primary (NY-SQL04) was very, very angry. After the failover from NY-SQL04, the server was completely unresponsive to anything. All the databases locked, CPU spiked, we were hitting HADR waits, and we didn&#x2019;t get any sort of response for more than 25 minutes. Thankfully, we weren&#x2019;t overly concerned because we had a new primary that was working, and this would be completely rebuilt to Windows Server 2016. We made the decision to just stop the SQL Server service until I got around to the rebuild.</p> <p>All of the failovers were complete and everything was running on the new Windows Server 2016 clusters. Our servers looked like this:</p> <p><img src="/image/2019/PostFailoverServerState.jpg" alt="Post Failover Night State of Servers"></p> <p>We still had two servers in the old 2012 clusters. NY-SQL04 wasn&#x2019;t functioning as a SQL Server because we shutdown the SQL service post failover, and NY-SQL02 was a member of the temporary distributed availability group we just failed over. Those servers were going to be rebuilt the next day, so our focus turned to the reporting cluster. That cluster is used internally for applications, and we needed to get it back up as soon as possible for use.</p> <p>Initially, we thought that if we recreated the distributed availability groups with the reporting clusters as a member, things would just pick back up and sync. We executed the following to recreate the two distributed AGs with the new cluster and reporting cluster:</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="c1">-- run this on NY-SQL03
</span><span class="c1"></span><span class="k">CREATE</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="p">[</span><span class="n">Misc_DAG</span><span class="p">]</span> <span class="k">WITH</span> <span class="p">(</span><span class="n">DISTRIBUTED</span><span class="p">)</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="k">ON</span> <span class="s1">&apos;AG-Misc&apos;</span> <span class="k">WITH</span> <span class="p">(</span> <span class="n">LISTENER_URL</span> <span class="o">=</span> <span class="s1">&apos;&lt;listener&gt;&apos;</span><span class="p">,</span> <span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">,</span> <span class="n">FAILOVER_MODE</span> <span class="o">=</span> <span class="n">MANUAL</span><span class="p">,</span> <span class="n">SEEDING_MODE</span> <span class="o">=</span> <span class="n">AUTOMATIC</span> <span class="p">),</span> <span class="s1">&apos;HighAvailability_RAG&apos;</span> <span class="k">WITH</span> <span class="p">(</span> <span class="n">LISTENER_URL</span> <span class="o">=</span> <span class="s1">&apos;&lt;listener&gt;&apos;</span><span class="p">,</span> <span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">,</span> <span class="n">FAILOVER_MODE</span> <span class="o">=</span> <span class="n">MANUAL</span><span class="p">,</span> <span class="n">SEEDING_MODE</span> <span class="o">=</span> <span class="n">AUTOMATIC</span> <span class="p">);</span> <span class="k">GO</span> <span class="c1">-- run this on NY-RPTSQL01
</span><span class="c1"></span><span class="k">ALTER</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="p">[</span><span class="n">Misc_DAG</span><span class="p">]</span> <span class="k">JOIN</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="k">ON</span> <span class="s1">&apos;AG-Misc&apos;</span> <span class="k">WITH</span> <span class="p">(</span> <span class="n">LISTENER_URL</span> <span class="o">=</span> <span class="s1">&apos;&lt;listener&gt;&apos;</span><span class="p">,</span> <span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">,</span> <span class="n">FAILOVER_MODE</span> <span class="o">=</span> <span class="n">MANUAL</span><span class="p">,</span> <span class="n">SEEDING_MODE</span> <span class="o">=</span> <span class="n">AUTOMATIC</span> <span class="p">),</span> <span class="s1">&apos;HighAvailability_RAG&apos;</span> <span class="k">WITH</span> <span class="p">(</span> <span class="n">LISTENER_URL</span> <span class="o">=</span> <span class="s1">&apos;&lt;listener&gt;&apos;</span><span class="p">,</span> <span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">,</span> <span class="n">FAILOVER_MODE</span> <span class="o">=</span> <span class="n">MANUAL</span><span class="p">,</span> <span class="n">SEEDING_MODE</span> <span class="o">=</span> <span class="n">AUTOMATIC</span> <span class="p">);</span> <span class="k">GO</span> <span class="c1">-- run this on NY-SQL01
</span><span class="c1"></span><span class="k">CREATE</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="p">[</span><span class="n">StackOverflow_DAG</span><span class="p">]</span> <span class="k">WITH</span> <span class="p">(</span><span class="n">DISTRIBUTED</span><span class="p">)</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="k">ON</span> <span class="s1">&apos;AG-StackOverflow&apos;</span> <span class="k">WITH</span> <span class="p">(</span> <span class="n">LISTENER_URL</span> <span class="o">=</span> <span class="s1">&apos;&lt;listener&gt;&apos;</span><span class="p">,</span> <span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">,</span> <span class="n">FAILOVER_MODE</span> <span class="o">=</span> <span class="n">MANUAL</span><span class="p">,</span> <span class="n">SEEDING_MODE</span> <span class="o">=</span> <span class="n">AUTOMATIC</span> <span class="p">),</span> <span class="s1">&apos;StackOverflow_RAG&apos;</span> <span class="k">WITH</span> <span class="p">(</span> <span class="n">LISTENER_URL</span> <span class="o">=</span> <span class="s1">&apos;&lt;listener&gt;&apos;</span><span class="p">,</span> <span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">,</span> <span class="n">FAILOVER_MODE</span> <span class="o">=</span> <span class="n">MANUAL</span><span class="p">,</span> <span class="n">SEEDING_MODE</span> <span class="o">=</span> <span class="n">AUTOMATIC</span> <span class="p">);</span> <span class="k">GO</span> <span class="c1">-- run this on NY-RPTSQL01
</span><span class="c1"></span><span class="k">ALTER</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="p">[</span><span class="n">StackOverflow_DAG</span><span class="p">]</span> <span class="k">JOIN</span> <span class="n">AVAILABILITY</span> <span class="k">GROUP</span> <span class="k">ON</span> <span class="s1">&apos;AG-StackOverflow&apos;</span> <span class="k">WITH</span> <span class="p">(</span> <span class="n">LISTENER_URL</span> <span class="o">=</span> <span class="s1">&apos;&lt;listener&gt;&apos;</span><span class="p">,</span> <span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">,</span> <span class="n">FAILOVER_MODE</span> <span class="o">=</span> <span class="n">MANUAL</span><span class="p">,</span> <span class="n">SEEDING_MODE</span> <span class="o">=</span> <span class="n">AUTOMATIC</span> <span class="p">),</span> <span class="s1">&apos;StackOverflow_RAG&apos;</span> <span class="k">WITH</span> <span class="p">(</span> <span class="n">LISTENER_URL</span> <span class="o">=</span> <span class="s1">&apos;&lt;listener&gt;&apos;</span><span class="p">,</span> <span class="n">AVAILABILITY_MODE</span> <span class="o">=</span> <span class="n">ASYNCHRONOUS_COMMIT</span><span class="p">,</span> <span class="n">FAILOVER_MODE</span> <span class="o">=</span> <span class="n">MANUAL</span><span class="p">,</span> <span class="n">SEEDING_MODE</span> <span class="o">=</span> <span class="n">AUTOMATIC</span> <span class="p">);</span> <span class="k">GO</span> </code></pre></td></tr></table>
</div>
</div> <p>After executing this and recreating the distributed AGs, we realized very quickly we were wrong about them starting to sync again. The reporting cluster wouldn&#x2019;t sync. We tried kicking the databases with various commands, and even tried failing the reporting cluster over to the secondary server in Colorado and then failing back. Nothing was working. After checking the logs on the reporting cluster primary, NY-RPTSQL01, we found lots of errors:</p> <blockquote>
<p>Msg 3456, Level 21, State 1, Line 22</p> <p>Could not redo log record (8278:53574:4), for transaction ID (0:8787310), on page (1:10082), allocation unit 72057594040811520, database &#x2018;CareersAuth&#x2019; (database ID 23). Page: LSN = (8277:108566:2), allocation unit = 72057594040811520, type = 1. Log: OpCode = 6, context 1, PrevPageLSN: (8278:53568:2). Restore from a backup of the database, or repair the database.</p> <p>Msg 3313, Level 21, State 1, Line 22</p> <p>During redoing of a logged operation in database &#x2018;CareersAuth&#x2019;, an error occurred at log record ID (8278:53574:4). Typically, the specific failure is previously logged as an error in the operating system error log. Restore the database from a full backup, or repair the database.</p> <p>Msg 3414, Level 21, State 4, Line 22</p> <p>An error occurred during recovery, preventing the database &#x2018;CareersAuth&#x2019; (23:0) from restarting. Diagnose the recovery errors and fix them, or restore from a known good backup. If errors are not corrected or expected, contact Technical Support.</p>
</blockquote> <p>Well, that stinks. It meant we&#x2019;d have to rebuild the AGs on the Reporting Servers using a recent backup, and then try to get them to synchronize. We started restoring the databases that were impacted in a <code>NORECOVERY</code> state with a local copy so the restore process didn&#x2019;t too long. Once the databases were restored, we executed the following on each database to get them syncing again:</p> <div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-sql"><span class="k">Alter</span> <span class="k">Database</span> <span class="p">[</span><span class="n">database_name</span><span class="p">]</span> <span class="k">Set</span> <span class="n">HADR</span> <span class="n">Availability</span> <span class="k">Group</span> <span class="o">=</span> <span class="p">[</span><span class="n">distributed_AG_Name</span><span class="p">];</span></code></pre></td></tr></table>
</div>
</div> <p>While this all worked great for the primary reporting server, NY-RPTSQL01, we were not as lucky with the secondary server in the reporting cluster, CO-RPTSQL01. We already suffer from throughput issues with CO-RPTSQL01 and all of the de-synchronizing put all of the databases in a state that couldn&#x2019;t be recovered. Unfortunately, all the databases would also have to be rebuilt by restoring copies, then altering them to set them as a part of the availability group. The big problem was we didn&#x2019;t have a local copy in Colorado to restore due to all the other server moves (we had turned off daily backups), so we were going to have to copy the files from NY to CO to then restore on CO-RPTSQL01. That might not be a big deal normally, but we have databases that are several TBs and the move was going to take a while. I decided to call Day 9 done, and pick that process up in the morning, along with other clean-up.</p> <h3 id="day-10-finishing-touches">Day 10 - Finishing Touches</h3> <p>After a <a href="https://twitter.com/tarynpivots/status/1121052238829375496">couple of hours of sleep</a>, it was time to try to finish this up. The list of things left to do was small, but was still quite a bit of work. We had to:</p> <ul>
<li>Restore databases to CO-RPTSQL01 and get the AGs/distributed AGs syncing throughout the reporting cluster</li>
<li>Destroy the temporary distributed availability groups on the new 2016 clusters</li>
<li>Rebuild NY-SQL04 and NY-SQL02 - the last two servers in the old 2012 clusters</li>
<li>Insert the newly rebuilt servers into the new 2016 Windows Clusters, install SQL Server, and add them to the AGs</li>
<li>Turn on all t-log backups and daily full backups</li>
<li>Put read-only routing in place on all availability groups</li>
</ul> <p>The goal was to get through the entire list same day, but that would be too easy. We ran into an issue immediately. Remember that NY-RPTSQL01 we got synchronizing at the end of Day 9 &#x2013; it was lying to us. It said it was syncing, but it really wasn&#x2019;t. If you queried the <code>StackOverflow</code> database, it was several hours behind the current production database&#x2026;uh oh, something was broken. We tried to restart the SQL Service to see if that unblocked it, it didn&#x2019;t. Unfortunately, the only way we were able to get it syncing again was to:</p> <ul>
<li>drop, then restore the databases</li>
<li>manually apply the t-logs to bring it up to date from the current global primary</li>
<li>then after executing some SQL to kick the AGs, like magic, it would be synchronizing again</li>
</ul> <p>We did this for all the impacted databases on the reporting cluster primary, NY-RPTSQL01, and then still had to get CO-RPTSQL01 back online. Nick Craver jumped in and worked on the NY and CO reporting servers, while I started rebuilding the final two servers, NY-SQL04 and NY-SQL02. The rebuild of the final two servers went exactly as expected. Once it came time to put the servers into the availability groups, I took fresh backups from the primaries and restored those. I did this because we weren&#x2019;t going to automatically seed an AG with 354 databases or a 3.5TB one (<code>StackOverflow)</code>, and I wanted to manually apply as few T-logs to the databases as possible to bring it up to current time.</p> <p>It may have taken all day, but eventually we fixed the reporting cluster and had all six of our main SQL Servers moved into the new Windows Server 2016 clusters. By the end of the day, <a href="https://twitter.com/tarynpivots/status/1121145354760507393">Opserver was reporting green everywhere</a>:</p> <p><img src="/image/2019/AllDone.jpg" alt="Final State - All Done"></p> <p>It was such a good feeling to have everything moved over. After months of planning, testing, and frustration from hitting issue after issue, plus a bug in SQL Server, it was incredible to see it all come to fruition.</p> <h2 id="final-thoughts">Final Thoughts</h2> <p>Besides the upgrade to <a href="/post/how-we-upgraded-stackoverflow-to-sql-server-2017/">SQL Server 2017 from the year before</a>, I had never even attempted something with this level of complexity or planning. This project involved a lot of juggling of servers, AGs/distributed AGs, application changes, and considering we don&#x2019;t have maintenance windows at Stack Overflow, it was difficult to imagine how to pull this off without being down for an extended period of time. To know this entire thing was executed with only about 10-15 minutes of downtime for the public facing sites is pretty darn amazing, in my opinion.</p> <p>I have some takeaways from this - most are common sense, but I need to repeat them for my own sanity:</p> <ol>
<li><p>Test, re-test, and then test some more. The initial plan was to jump from the lab to prod, the rebuild of our development environment was unexpected. I also didn&#x2019;t think this upgrade would break our development environment, but by doing this immediate steps we found several bugs in our deployment process which we might have hit in production.</p></li> <li><p>Have a lab environment, if possible. Between creating new lab environments and using my existing lab environments, I was able to work through all the different scenarios I figured we would hit in production. Of course, I wasn&#x2019;t able to test at our scale and find the SQL Server bug, but I felt confident the steps I planned would work for the failovers.</p></li> <li><p>Rely on your team. While I&#x2019;m the only official DBA at Stack Overflow, there were times when I was at a loss on how to fix some of our issues with Foreman, Puppet, and needed extra hands. I can&#x2019;t thank my team enough for stepping in and jumping into hangouts with me when I was stuck or something broke.</p></li> <li><p>Remember that no matter how much you plan, something is going to go sideways. We had a ~35 page planning document that I wrote and none of that mattered when we hit the bug with availability groups.</p></li> <li><p>Try not to stress out over the things out of your control. I hit roadblock after roadblock during this project, and felt that I was letting my team down by not moving it forward faster. When you expect a project to be done in one month and it takes about four, it&#x2019;s hard not to feel like you&#x2019;re failing and be stressed out over it. Each issue (failed drives, bugs) moved us forward and we improved our process, even if it was incredibly slow. In the end, we were in a much better situation because we squashed bugs and moved to better software. Keeping perspective on the end-goal is something to remind yourself when in these types of situations.</p></li> <li><p>Keep notes as you&#x2019;re going through a deployment like this. Every day write yourself a recap of what transpired that day, so you remember what went well or what broke. Unfortunately, I didn&#x2019;t do this during the production part and spent a lot of time going through chat transcripts trying to remember all the steps and roadblocks we hit to document in this post.</p></li>
</ol> <p>I&#x2019;m hoping this is helpful to someone who needs to go through this type of upgrade. Now that this project is done, I guess it&#x2019;s time I start thinking about upgrading to SQL Server 2019.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>