<!DOCTYPE html>
<html lang="en">
<head>
    <title>
NetFabric/NetFabric.Hyperlinq - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="NetFabric/NetFabric.Hyperlinq - linksfor.dev(s)"/>
    <meta property="article:author" content="aalmada"/>
    <meta property="og:description" content=" High performance LINQ implementation with minimal heap allocations. Supports enumerables, async enumerables, arrays and Span&lt;T&gt;. - NetFabric/NetFabric.Hyperlinq"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/NetFabric/NetFabric.Hyperlinq"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - NetFabric/NetFabric.Hyperlinq</title>
<div class="readable">
        <h1>NetFabric/NetFabric.Hyperlinq</h1>
            <div>by aalmada</div>
            <div>Reading time: 6-8 minutes</div>
        <div>Posted here: 21 Feb 2020</div>
        <p><a href="https://github.com/NetFabric/NetFabric.Hyperlinq">https://github.com/NetFabric/NetFabric.Hyperlinq</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>  <p><span itemprop="about">
           High performance LINQ implementation with minimal heap allocations. Supports enumerables, async enumerables, arrays and Span&lt;T&gt;.
        </span>
  </p>
</div><div id="readme">
    
        

      <div>
        <article itemprop="text"><p><a href="https://github.com/NetFabric/NetFabric.Hyperlinq/commits/master"><img src="https://camo.githubusercontent.com/b6782830ddd443f6eef3e50ce60444c9f2d4e233/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6173742d636f6d6d69742f4e65744661627269632f4e65744661627269632e48797065726c696e712f6d6173746572" alt="GitHub last commit (master)" data-canonical-src="https://img.shields.io/github/last-commit/NetFabric/NetFabric.Hyperlinq/master"></a>
<a href="https://github.com/NetFabric/NetFabric.Hyperlinq/actions"><img src="https://camo.githubusercontent.com/16d678e388a3b2553cb66c899abdcba7d3b3a210/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f776f726b666c6f772f7374617475732f4e65744661627269632f4e65744661627269632e48797065726c696e712f2e4e4554253230436f72652f6d6173746572" alt="GitHub Workflow Status (master)" data-canonical-src="https://img.shields.io/github/workflow/status/NetFabric/NetFabric.Hyperlinq/.NET%20Core/master"></a>
<a href="https://coveralls.io/github/NetFabric/NetFabric.Hyperlinq?branch=master" rel="nofollow"><img src="https://camo.githubusercontent.com/6265f77016f07d3f1ceeb417d4ac24ada4503f6e/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f4e65744661627269632f4e65744661627269632e48797065726c696e712f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/NetFabric/NetFabric.Hyperlinq/badge.svg?branch=master"></a>
<a href="https://www.nuget.org/packages/NetFabric.Hyperlinq/" rel="nofollow"><img src="https://camo.githubusercontent.com/fe8b9dd843029532f8d526d94d9179f6ec3f6ae5/68747470733a2f2f696d672e736869656c64732e696f2f6e756765742f762f4e65744661627269632e48797065726c696e712e737667" alt="NuGet Version" data-canonical-src="https://img.shields.io/nuget/v/NetFabric.Hyperlinq.svg"></a>
<a href="https://www.nuget.org/packages/NetFabric.Hyperlinq/" rel="nofollow"><img src="https://camo.githubusercontent.com/f720e71ca9de1fc72c4bc22927b7ba3dd41fd52d/68747470733a2f2f696d672e736869656c64732e696f2f6e756765742f64742f4e65744661627269632e48797065726c696e712e737667" alt="NuGet Downloads" data-canonical-src="https://img.shields.io/nuget/dt/NetFabric.Hyperlinq.svg"></a></p>

<p><em>Hyperlinq</em> outperforms <em>LINQ</em> on collections that implement <code>IReadOnlyList&lt;T&gt;</code> (E.g. arrays and <code>List&lt;T&gt;</code>) and collections that have value-typed enumerators (E.g. collections in the <code>System.Collections.Generic</code> and <code>System.Collections.Immutable</code> namespaces). For any other collection, it also outperforms <em>LINQ</em> when multiple operations are composed.</p>
<p>This implementation favors performance and reduction of heap allocations, in detriment of assembly binary size (lots of overloads).</p>
<h2>Usage</h2>
<ol>
<li>Add the <em>NetFabric.Hyperlinq</em> <a href="https://www.nuget.org/packages/NetFabric.Hyperlinq/" rel="nofollow">NuGet package</a> to your project.</li>
<li>Optionally, also add the <em>NetFabric.Hyperlinq.Analyzer</em> <a href="https://www.nuget.org/packages/NetFabric.Hyperlinq.Analyzer/" rel="nofollow">NuGet package</a> to your project. It's a Roslyn analyzer that suggests performance improvements on your enumeration source code. No dependencies are added to your assemblies.</li>
<li>Add an <code>using NetFabric.Hyperlinq</code> directive to all source code files where you want to use <em>NetFabric.Hyperlinq</em>.</li>
<li>Use the <code>ValueEnumerable</code> static class for generation operations (E.g. <code>ValueEnumerable.Empty()</code>, <code>ValueEnumerable.Range(...)</code>, <code>ValueEnumerable.Repeat(...)</code>, <code>ValueEnumerable.Return(...)</code>, etc.)</li>
<li><em>NetFabric.Hyperlinq</em> and <em>System.Linq</em> namespaces can co-exist:
<ol>
<li><em>NetFabric.Hyperlinq</em> uses explicit collection types and higher-order interfaces on its extension methods. These take precedence over the <code>IEnumerable&lt;T&gt;</code> extension methods implemented in <em>System.Linq</em>.</li>
<li>In the cases where doesn't automatically apply, use the <code>AsValueEnumerable&lt;TSource&gt;()</code> extension method. <em>NetFabric.Hyperlinq</em> implementations will then be used for the subsequent operations. For collections that are value-types and/or return enumerators that are value-types, favor the use of the <code>AsValueEnumerable&lt;TEnumerable, TEnumerator, TSource&gt;()</code> overload to avoid boxing.</li>
<li><em>NetFabric.Hyperlinq</em> does not implement all <em>System.Linq</em> operations. In these cases, the <code>System.Linq</code> implementations will be automatically used. You'll can use <code>AsValueEnumerable()</code> on its result to apply <em>NetFabric.Hyperlinq</em> implementations from that point on.</li>
</ol>
</li>
</ol>
<div><pre><span>using</span> <span>System</span>.<span>Collections</span>.<span>Generic</span>;
<span>using</span> <span>System</span>.<span>Linq</span>;
<span>using</span> <span>NetFabric</span>.<span>Hyperlinq</span>; <span><span>//</span> add this directive</span>

<span>namespace</span> <span>ConsoleApp</span>
{
    <span>class</span> <span>Program</span>
    {
        <span>static</span> <span>void</span> <span>Main</span>()
        {
            <span>var</span> <span>list</span> <span>=</span> <span>ValueEnumerable</span>.<span>Range</span>(<span>0</span>, <span>10</span>).<span>ToList</span>(); <span><span>//</span> Hyperlinq operations are used</span>

            <span>var</span> <span>a</span> <span>=</span> <span>list</span> <span><span>//</span> Hyperlinq operations are used by default on List&lt;&gt;</span>
                .<span>Where</span>(<span>i</span> <span>=&gt;</span> <span>i</span> <span>&gt;</span> <span>0</span>) 
                .<span>Select</span>(<span>i</span> <span>=&gt;</span> <span>i</span> <span>*</span> <span>10</span>);
            
            <span>var</span> <span>b</span> <span>=</span> <span>list</span> <span><span>//</span> Hyperlinq operations are used by default on List&lt;&gt;</span>
                .<span>Where</span>(<span>i</span> <span>=&gt;</span> <span>i</span> <span>&gt;</span> <span>0</span>) 
                .<span>OrderByDescending</span>(<span>i</span> <span>=&gt;</span> <span>i</span>) <span><span>//</span> Hyperlinq does not yet support this operation so LINQ is used</span>
                .<span>AsValueEnumerable</span>() <span><span>//</span> Hyperlinq operations are used on subsequent operations</span>
                .<span>Select</span>(<span>i</span> <span>=&gt;</span> <span>i</span> <span>*</span> <span>10</span>);

            <span>var</span> <span>c</span> <span>=</span> <span>MyRange</span>(<span>0</span>, <span>10</span>) <span><span>//</span> LINQ operations are used by default on IEnumerable&lt;&gt;</span>
                .<span>AsValueEnumerable</span>() <span><span>//</span> Hyperlinq operations are used on subsequent operations</span>
                .<span>Where</span>(<span>i</span> <span>=&gt;</span> <span>i</span> <span>&gt;</span> <span>0</span>)
                .<span>Count</span>();
        }

        <span><span>//</span> 'yield' generates a reference-type enumerable with a reference-type enumerator</span>
        <span>static</span> <span>IEnumerable</span>&lt;<span>int</span>&gt; <span>MyRange</span>(<span>int</span> <span>start</span>, <span>int</span> <span>count</span>)
        {
            <span>var</span> <span>end</span> <span>=</span> <span>start</span> <span>+</span> <span>count</span>;
            <span>for</span> (<span>var</span> <span>value</span> <span>=</span> <span>start</span>; <span>value</span> <span>&lt;</span> <span>end</span>; <span>value</span><span>++</span>)
                <span>yield</span> <span>return</span> <span>value</span>;
        }
    }
}</pre></div>
<h2>Documentation</h2>
<ul>
<li><a href="https://medium.com/@antao.almada/netfabric-hyperlinq-optimizing-linq-348e02566cef" rel="nofollow">Optimizing LINQ</a></li>
<li><a href="https://medium.com/@antao.almada/netfabric-hyperlinq-generation-operations-6530826a70ca" rel="nofollow">Generation Operations</a></li>
<li><a href="https://medium.com/@antao.almada/netfabric-hyperlinq-select-operation-e4ac2bbfb187" rel="nofollow">Select Operation</a></li>
<li><a href="https://medium.com/@antao.almada/netfabric-hyperlinq-zero-allocation-fe5d0dd6b1a6" rel="nofollow">Zero Allocation</a></li>
</ul>
<h2>Supported operations</h2>
<ul>
<li>Aggregation
<ul>
<li><code>Count()</code></li>
<li><code>Count(Predicate&lt;TSource&gt;)</code></li>
<li><code>Count(PredicateAt&lt;TSource&gt;)</code></li>
<li><code>LongCount()</code></li>
<li><code>LongCount(Predicate&lt;TSource&gt;)</code></li>
</ul>
</li>
<li>Conversion
<ul>
<li><code>AsEnumerable()</code></li>
<li><code>AsValueEnumerable()</code></li>
<li><code>ToArray()</code></li>
<li><code>ToList()</code></li>
<li><code>ToDictionary(Selector&lt;TSource, TKey&gt;)</code></li>
<li><code>ToDictionary(Selector&lt;TSource, TKey&gt;, IEqualityComparer&lt;TKey&gt;)</code></li>
<li><code>ToDictionary(Selector&lt;TSource, TKey&gt;, Selector&lt;TSource, TElement&gt;)</code></li>
<li><code>ToDictionary(Selector&lt;TSource, TKey&gt;, Selector&lt;TSource, TElement&gt;, IEqualityComparer&lt;TKey&gt;)</code></li>
</ul>
</li>
<li>Element
<ul>
<li><code>TryElementAt()</code></li>
<li><code>TryElementAt(Predicate&lt;TSource&gt;)</code></li>
<li><code>TryElementAt(PredicateAt&lt;TSource&gt;)</code></li>
<li><code>ElementAt()</code></li>
<li><code>ElementAt(Predicate&lt;TSource&gt;)</code></li>
<li><code>ElementAt(PredicateAt&lt;TSource&gt;)</code></li>
<li><code>ElementAtOrDefault()</code></li>
<li><code>ElementAtOrDefault(Predicate&lt;TSource&gt;)</code></li>
<li><code>ElementAtOrDefault(PredicateAt&lt;TSource&gt;)</code></li>
<li><code>First()</code></li>
<li><code>First(Predicate&lt;TSource&gt;)</code></li>
<li><code>First(PredicateAt&lt;TSource&gt;)</code></li>
<li><code>FirstOrDefault()</code></li>
<li><code>FirstOrDefault(Predicate&lt;TSource&gt;)</code></li>
<li><code>FirstOrDefault(PredicateAt&lt;TSource&gt;)</code></li>
<li><code>Single()</code></li>
<li><code>Single(Predicate&lt;TSource&gt;)</code></li>
<li><code>Single(PredicateAt&lt;TSource&gt;)</code></li>
<li><code>SingleOrDefault()</code></li>
<li><code>SingleOrDefault(Predicate&lt;TSource&gt;)</code></li>
<li><code>SingleOrDefault(PredicateAt&lt;TSource&gt;)</code></li>
</ul>
</li>
<li>Filtering
<ul>
<li><code>Where(Predicate&lt;TSource&gt;)</code></li>
<li><code>Where(PredicateAt&lt;TSource&gt;)</code></li>
</ul>
</li>
<li>Generation
<ul>
<li><code>Create(Func&lt;TEnumerator&gt;)</code></li>
<li><code>Empty()</code></li>
<li><code>Range(int, int)</code></li>
<li><code>Repeat(TSource, int)</code></li>
<li><code>Return(TSource)</code></li>
</ul>
</li>
<li>Projection
<ul>
<li><code>Select(Selector&lt;TSource, TResult&gt;)</code></li>
<li><code>Select(SelectorAt&lt;TSource, TResult&gt;)</code></li>
<li><code>SelectMany(IValueEnumerable&lt;TSource&gt;)</code></li>
</ul>
</li>
<li>Partitioning
<ul>
<li><code>Take(int)</code></li>
<li><code>Skip(int)</code></li>
</ul>
</li>
<li>Quantifier
<ul>
<li><code>All(Predicate&lt;TSource&gt;)</code></li>
<li><code>All(PredicateAt&lt;TSource&gt;)</code></li>
<li><code>Any()</code></li>
<li><code>Any(Predicate&lt;TSource&gt;)</code></li>
<li><code>Any(PredicateAt&lt;TSource&gt;)</code></li>
<li><code>Contains(TSource)</code></li>
<li><code>Contains(TSource, IEqualityComparer&lt;TSource&gt;)</code></li>
</ul>
</li>
<li>Set
<ul>
<li><code>Distinct(TSource)</code></li>
<li><code>Distinct(TSource, IEqualityComparer&lt;TSource&gt;)</code></li>
</ul>
</li>
<li>Other
<ul>
<li><code>ForEach(Action&lt;TSource&gt;)</code></li>
<li><code>ForEach(Action&lt;TSource, int&gt;)</code></li>
</ul>
</li>
</ul>
<h2>Benchmarks</h2>
<p>The repository contains a <a href="https://github.com/NetFabric/NetFabric.Hyperlinq/tree/master/NetFabric.Hyperlinq.Benchmarks">benchmarks project</a> based on <a href="https://benchmarkdotnet.org/" rel="nofollow">BenchmarkDotNet</a> that compares <code>NetFabric.Hyperlinq</code> to <code>System.Linq</code> for many of the supported operations and its combinations.</p>
<h2>References</h2>
<ul>
<li><a href="https://blog.usejournal.com/enumeration-in-net-d5674921512e" rel="nofollow">Enumeration in .NET</a> by Antão Almada</li>
<li><a href="https://medium.com/@antao.almada/performance-of-value-type-vs-reference-type-enumerators-820ab1acc291" rel="nofollow">Performance of value-type vs reference-type enumerators</a> by Antão Almada</li>
<li><a href="https://reubenbond.github.io/posts/dotnet-perf-tuning" rel="nofollow">Performance Tuning for .NET Core</a> by Reuben Bond</li>
<li><a href="https://gist.github.com/benaadams/294cbd41ec1179638cb4b5495a15accf">ValueLinqBenchmarks</a> by Ben Adams</li>
<li><a href="http://www.levibotelho.com/development/how-method-calling-works/" rel="nofollow">C# - How method calling works</a> by Levi Botelho</li>
<li><a href="https://medium.com/@ocoanet/improving-net-disruptor-performance-part-2-5bf456cd595f" rel="nofollow">Improving .NET Disruptor performance — Part 2</a> by Olivier Coanet</li>
<li><a href="https://medium.com/@SergioPedri/optimizing-string-count-all-the-way-from-linq-to-hardware-accelerated-vectorized-instructions-186816010ad9" rel="nofollow">Optimizing string.Count all the way from LINQ to hardware accelerated vectorized instructions</a> by Sergio Pedri</li>
</ul>
<h2>Credits</h2>
<p>The following open-source projects are used to build and test this project:</p>
<ul>
<li><a href="https://github.com/dotnet">.NET</a></li>
<li><a href="https://benchmarkdotnet.org/" rel="nofollow">BenchmarkDotNet</a></li>
<li><a href="https://coveralls.io/" rel="nofollow">coveralls</a></li>
<li><a href="https://github.com/tonerdo/coverlet">coverlet</a></li>
<li><a href="https://github.com/NetFabric/NetFabric.Assertive">NetFabric.Assertive</a></li>
<li><a href="https://github.com/manuelroemer/Nullable">Nullable</a></li>
<li><a href="https://github.com/dotnet/sourcelink">Source Link</a></li>
<li><a href="https://github.com/unoplatform/Uno.SourceGeneration">Uno.SourceGeneration</a></li>
<li><a href="https://xunit.net/" rel="nofollow">xUnit.net</a></li>
</ul>
<h2>License</h2>
<p>This project is licensed under the MIT license. See the <a href="https://github.com/NetFabric/NetFabric.Hyperlinq/blob/master/LICENSE">LICENSE</a> file for more info.</p>
</article>
      </div>
  </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>