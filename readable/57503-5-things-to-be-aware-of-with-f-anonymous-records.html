<!DOCTYPE html>
<html lang="en">
<head>
    <title>
5 things to be aware of with F# anonymous records -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
            <h1>
                    <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">ðŸŽ‰</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
            </h1>
        
<div class="readable">
    <h1>5 things to be aware of with F# anonymous records</h1>
    <p><a href="https://www.compositional-it.com/news-blog/5-things-to-be-aware-of-with-f-anonymous-records/">https://www.compositional-it.com/news-blog/5-things-to-be-aware-of-with-f-anonymous-records/</a></p>
    <hr/>
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>5 things to be aware of with F# anonymous records</h1><div><div id="" class="contentArea"><p>In our <a href="https://www.compositional-it.com/news-blog/5-tips-for-working-with-f-anonymous-records/">previous post</a> on Anonymous Records, we looked at some of the <em>benefits</em> of working with them. In this post, I want to discuss five "gotchas" that you should be aware of when using anonymous records that you may not have considered.</p><h1>Limited type inference</h1><p>Unlike standard F# records, the F# compiler won't look at instances of anonymous records that have been declared, nor type aliases, when performing type inference. This normally isn't a problem when <em>returning</em> anonymous records out of e.g. a function, but when taken as an <em>input</em>, it's invariably an issue.</p><pre><code class="language-fsharp">let foo = {| Name = "Isaac" |}

// error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
let bar x =
    x.Name

bar foo</code></pre><p>You can resolve this either by explicitly entering a type annotation, or by using a type alias:</p><pre><code class="language-fsharp">// works
let bar (x:{|Name:string|}) = x.Name

// also works
type FooData = {| Name : string |}
let bar (x:FooData) = x.Name</code></pre><p>Often the latter will be preferable to improve readability, and acts as a useful "bridge" when moving towards full records.</p><h1>Unclear error messages</h1><p>Error messages with anonymous records are different to those for standard records, and in F#4.7 are not always particularly easy to reason about.</p><pre><code class="language-fsharp">type FullRecord = { Name : string; Age : int }

// error FS0764: No assignment given for field 'Age' of type 'FullRecord'
let x:FullRecord = { Name = "Isaac" }

type AnonymousRecord = {| Name : string; Age : int |}

// error FS0001: Two anonymous record types have mismatched sets of field names '["Age"; "Name"]' and '["Name"]'
let y:AnonymousRecord = {| Name = "Isaac" |}</code></pre><p>Observe how the former understands what record type is required and explains what field(s) are missing. The latter requires you to scan through all fields to identify the difference between both lists. If you have more than just a few fields, and more one difference, it can quickly become very, very difficult to identify what those differences are. Thankfully <a href="https://github.com/dotnet/fsharp/issues/8091">this issue</a> has been fixed and will be included in the next version of F#. Other issues still exist with error messages, such as <a href="https://github.com/dotnet/fsharp/issues/8127">this one</a> - I hope that such improvements are implemented in time.</p><h1>No pattern matching</h1><p>You cannot pattern match on anonymous record fields, even if you use type annotations to tell the compiler which record is being used. You can work around this to some extent by using <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns">Active Patterns</a>.</p><pre><code class="language-fsharp">let (|Name|_|) v (x:AnonymousRecord) = if x.Name = v then Some() else None
let (|Age|_|) v (x:AnonymousRecord) = if x.Age = v then Some() else None
let greet (r:AnonymousRecord) =
    match r with
    | Name "Test" &amp; Age 20 -&gt; "Hello!"
    | _ -&gt; "Goodbye"

foo {| Name = "Isaac"; Age = 21 |} // Goodbye
foo {| Name = "Test"; Age = 20 |} // Hello!</code></pre><h1>No members</h1><p>You can't put members on anonymous records. Again, there's a workaround using <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/type-extensions#extension-methods">Extension Methods</a>.</p><pre><code class="language-fsharp">open System.Runtime.CompilerServices

let y:AnonymousRecord = {| Name = "Isaac"; Age = 21 |}

[&lt;Extension; AbstractClass; Sealed&gt;]
type Extensions =
    [&lt;Extension&gt;]
    static member Description (ty: AnonymousRecord) =
        sprintf "%s is %d years old" ty.Name ty.Age

y.Description() // Isaac is 21 years old</code></pre><blockquote><p>You cannot use type extensions; only extension methods are allowed.</p></blockquote><h1>Limited composability</h1><p>Whilst anonymous records <em>appear</em> to be structural records with e.g. static duck typing and so on, they aren't - they're still nominal records that are defined statistically.</p><pre><code class="language-fsharp">let p1 = {| Name = "Fred" |}
let p2 = {| Name = "Tim" |}
let p3 = {| Name = "Frank"; Age = 34 |}
p1.GetType() = p2.GetType() // true
p1.GetType() = p3.GetType() // false</code></pre><p>So, whilst the compiler does support <em>some</em> nice features, be aware that there are limits. For starters, you can construct one anonymous record as a superset of another, but you can't compose more than one "source" record, and nor can you create "subset" records.</p><pre><code class="language-fsharp">let a = {| Fruit = "Bananas" |}
let b = {| Color = "Yellow" |}
let c = {| a with Climate = "Hot" |} // allowed
let z = {| a with b with Age = 1 |} // not allowed</code></pre><p>You also cannot do things such as this:</p><pre><code class="language-fsharp">let capitaliseFruit (x:{|Fruit: string|}) =
    x.Fruit.ToUpper()

capitaliseFruit c // not allowed - c has an extra Climate field</code></pre><h1>Conclusion</h1><p>Anonymous Records are an extremely useful tool in the arsenal of an F# developer. They provide an excellent alternative to Tuples in terms of documentation and readability, some unique features that "full" records don't have, and a smooth migration path towards full records when required.</p><p>However, there are definitely some limitations over full records - although these often have workarounds by using alternative language features. Often, type annotations and hints can get you quite far, although if you're continuously resorting to these atypical workarounds, I would advise considering moving to full records.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>