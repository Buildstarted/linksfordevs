<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Evolving Infrastructure of .NET Core | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The Evolving Infrastructure of .NET Core | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Matt MitchellFollow Matt"/>
    <meta property="og:description" content="With&#xA0;.NET Core 3.0 Preview 6&#xA0;out the door, we thought it would be useful to take a brief look at the history of our infrastructure systems and the significant improvements that have been made in the last year or so."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/the-evolving-infrastructure-of-net-core/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The Evolving Infrastructure of .NET Core | .NET Blog</title>
<div class="readable">
        <h1>The Evolving Infrastructure of .NET Core | .NET Blog</h1>
            <div>by Matt MitchellFollow Matt</div>
            <div>Reading time: 28-35 minutes</div>
        <div>Posted here: 18 Jun 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/the-evolving-infrastructure-of-net-core/">https://devblogs.microsoft.com/dotnet/the-evolving-infrastructure-of-net-core/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/5e8257344e20e0cfb30e0ea0f3160756?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Matt</p></div></div></div><p>June 18th, 2019</p><p data-line="2">With&nbsp;<a title="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0-preview-6/" href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0-preview-6/">.NET Core 3.0 Preview 6</a>&nbsp;out the door, we thought it would be useful to take a brief look at the history of our infrastructure systems and the significant improvements that have been made in the last year or so.</p><p data-line="7">This post will be interesting if you are interested in build infrastructure or want a behind-the-scenes look at how we build a product as big as .NET Core. It doesn’t describe new features or sample code that you should use in your next application. Please tell us if you like these types of posts. We have a few more like this planned, but would appreciate knowing if you find this type of information helpful.</p><h2 id="a-little-history" data-line="13">A little history<a href="#a-little-history"></a></h2><p data-line="15">Begun over 3 years ago now, the .NET Core project was a significant departure from traditional Microsoft projects.</p><ul><li data-line="17">Developed publicly on GitHub</li><li data-line="18">Composed of isolated git repositories that integrate together vs. a monolithic repository.</li><li data-line="19">Targets many platforms</li><li data-line="20">Its components may ship in more than one ‘vehicle’ (e.g. Roslyn ships as a component of Visual Studio as well as the SDK)</li></ul><p data-line="23">Our early infrastructure decisions were made around necessity and expediency. We used Jenkins for GitHub PR and CI validation because it supported cross-platform OSS development. Our official builds lived in Azure DevOps (called VSTS at the time) and TeamCity (used by&nbsp;ASP.NET&nbsp;Core), where signing and other critical shipping infrastructure exists. We integrated repositories together using a combination of manually updating package dependency versions and somewhat automated GitHub PRs. Teams independently built what tooling they needed to do packaging, layout, localization and all the rest of the usual tasks that show up in big development projects. While not ideal, on some level this worked well enough in the early days. As the project grew from .NET Core 1.0 and 1.1 into 2.0 and beyond we wanted to invest in a more integrated stack, faster shipping cadences and easier servicing. We wanted to produce a new SDK with the latest runtime multiple times per day. And we wanted all of this without reducing the development velocity of the isolated repositories.</p><p data-line="35">Many of the infrastructure challenges .NET Core faces stem from the isolated, distributed nature of the repository structure. Although it’s varied quite a bit over the years, the product is made up of anywhere from 20-30 independent git repositories (ASP.NET&nbsp;Core had many more until recently). On one hand, having many independent development silos tends to make development in those silos very efficient; a developer can iterate very quickly in the libraries without much worry about the rest of the stack. On the other hand, it makes innovation and integration of the overall project much less efficient. Some examples:</p><ul><li data-line="42">If we need to roll out new signing or packaging features, doing so across so many independent repos that use different tools is very costly.</li><li data-line="44">Moving changes across the stack is slow and costly. Fixes and features in repositories ‘low’ in the stack (e.g. corefx libraries) may not be seen in the SDK (the ‘top’ of the stack) for several days. If we make a fix in dotnet/corefx, that change must be built and the new version flowed into any up-stack components that reference it (e.g. dotnet/core-setup and&nbsp;ASP.NET&nbsp;Core), where it will be tested, committed and built. Those new components will then need to flow those new outputs further up the stack, and so on and so forth until the head is reached.</li></ul><p data-line="51">In all of these cases, there is chance for failure at many levels, further slowing down the process. As .NET Core 3.0 planning began in earnest, it became clear that we could we could not create a release of the scope that we wanted without significant changes in our infrastructure.</p><h2 id="a-three-pronged-approach" data-line="55">A three-pronged approach<a href="#a-three-pronged-approach"></a></h2><p data-line="57">We developed a three-pronged approach to ease our pain:</p><ul><li data-line="59"><strong>Shared Tooling (aka&nbsp;<a title="https://github.com/dotnet/arcade" href="https://github.com/dotnet/arcade" target="_blank">Arcade</a>)</strong>&nbsp;– Invest in shared tooling across our repositories.</li><li data-line="61"><strong>System Consolidation (Azure DevOps)</strong>&nbsp;– Move off of Jenkins and into Azure DevOps for our GitHub CI. Move our official builds from classic VSTS-era processes onto modern config-as-code.</li><li data-line="63"><strong>Automated Dependency Flow and Discovery (Maestro)</strong>&nbsp;– Explicitly track inter-repo dependencies and automatically update them on a fast cadence.</li></ul><h3 id="arcade" data-line="66">Arcade</h3><p data-line="68">Prior to .NET Core 3.0, there were 3-5 different tooling implementations scattered throughout various repositories, depending on how you counted.</p><ul><li data-line="70">The core runtime repositories (<a title="https://github.com/dotnet/coreclr" href="https://github.com/dotnet/coreclr" target="_blank">dotnet/coreclr</a>,&nbsp;<a title="https://github.com/dotnet/corefx" href="https://github.com/dotnet/corefx" target="_blank">dotnet/corefx</a>&nbsp;and&nbsp;<a title="https://github.com/dotnet/core-setup" href="https://github.com/dotnet/core-setup" target="_blank">dotnet/core-setup</a>) had&nbsp;<a title="https://github.com/dotnet/buildtools" href="https://github.com/dotnet/buildtools" target="_blank">dotnet/buildtools</a>.</li><li data-line="74">ASP.NET&nbsp;Core’s repositories had&nbsp;<a title="https://github.com/aspnet/KoreBuild" href="https://github.com/aspnet/KoreBuild" target="_blank">aspnet/KoreBuild</a></li><li data-line="75">Various repositories like&nbsp;<a title="https://github.com/dotnet/symreader" href="https://github.com/dotnet/symreader" target="_blank">dotnet/symreader</a>&nbsp;used&nbsp;<a title="https://github.com/dotnet/roslyn-tools" href="https://github.com/dotnet/roslyn-tools" target="_blank">Repo Toolset</a></li><li data-line="77">A few other isolated repositories had independent implementations.</li></ul><p data-line="79">While in this world each team gets to customize their tooling and only build exactly what they need, it does have some significant downsides:</p><ul><li data-line="81"><p data-line="81"><strong>Developers move between repositories less efficiently</strong></p><p data-line="83"><em>Example:</em>&nbsp;When a developer moves from dotnet/corefx into dotnet/core-sdk, the ‘language’ of the repository is different. What does she type to build and test? Where do the logs get placed? If she needs to add a new project to the repo, how is this done?</p></li><li data-line="86"><p data-line="86"><strong>Each required feature gets built N times</strong></p><p data-line="88"><em>Example:</em>&nbsp;.NET Core produces tons of NuGet packages. While there is some variation (e.g. shared runtime packages like Microsoft.NETCore.App produced out of dotnet/core-setup are built differently than ‘normal’ packages like Microsoft.AspNet.WebApi.Client), the steps to produce them are fairly similar. Unfortunately, as repositories diverge their layout, project structure, etc. it generates differences in how these packaging tasks need to be implemented. How does a repository define what packages should be generated, what goes in those packages, their metadata, and so on. Without shared tooling, it is often easier for a team to just implement another packaging task rather than reuse another. This is of course a strain on resources.</p></li></ul><p data-line="97">With&nbsp;<a title="https://github.com/dotnet/arcade" href="https://github.com/dotnet/arcade" target="_blank">Arcade</a>, we endeavored to bring all our repos under a common layout, repository ‘language’, and set of tasks where possible. This is not without its pitfalls. Any kind of shared tooling ends up solving a bit of a ‘Goldilocks’ problem. If the shared tooling is too prescriptive, then the kind of customization required within a project of any significant size becomes difficult, and updating that tooling becomes tough. It’s easy to break a repository with new updates. BuildTools suffered from this. The repositories that used it became so tightly coupled to it that it was not only unusable for other repositories, but making any changes in buildtools often broke consumers in unexpected ways. If shared tooling is not prescriptive enough, then repositories tend to diverge in their usage of the tooling, and rolling out updates often requires lots of work in each individual repository. At that point, why have shared tooling in the first place?</p><p data-line="109">Arcade actually tries to go with both approaches at the same time. It defines a common repository ‘language’ as set of scripts (see&nbsp;<a title="https://github.com/dotnet/arcade/tree/master/eng/common" href="https://github.com/dotnet/arcade/tree/master/eng/common" target="_blank">eng/common</a>), a common repository layout, and common set of build targets rolled out as an MSBuild SDK. Repositories that choose to fully adopt Arcade have predictable behavior, making changes easy to roll out across repositories. Repositories that do not wish to do so can pick and choose from a variety of MSBuild task packages that provide basic functionality, like signing and packaging, that tend to look the same across all repositories. As we roll out changes to these tasks, we try our best to avoid breaking changes.</p><p data-line="118">Let’s take a look at the primary features that Arcade provides and how they integrate into our larger infrastructure.</p><ul><li data-line="121"><strong>Common build task packages</strong>&nbsp;– These are a basic layer of MSBuild tasks which can either be utilized independently or as part of the Arcade SDK. They are “pay for play” (hence the name ‘Arcade’). They provide a common set of functionality that is needed in most .NET Core repositories:<ul><li data-line="125">Signing:&nbsp;<a title="https://github.com/dotnet/arcade/tree/master/src/Microsoft.DotNet.SignTool" href="https://github.com/dotnet/arcade/tree/master/src/Microsoft.DotNet.SignTool" target="_blank">Microsoft.DotNet.SignTool</a></li><li data-line="127">Output publishing (to inter-repo feeds):&nbsp;<a title="https://github.com/dotnet/arcade/tree/master/src/Microsoft.DotNet.Build.Tasks.Feed" href="https://github.com/dotnet/arcade/tree/master/src/Microsoft.DotNet.Build.Tasks.Feed" target="_blank">Microsoft.DotNet.Build.Tasks.Feed</a></li><li data-line="129">Packaging&nbsp;<a title="https://github.com/dotnet/arcade/tree/master/src/Microsoft.DotNet.Build.Tasks.Packaging" href="https://github.com/dotnet/arcade/tree/master/src/Microsoft.DotNet.Build.Tasks.Packaging" target="_blank">Microsoft.DotNet.Build.Tasks.Packaging</a></li></ul></li><li data-line="131"><strong>Common repo targets and behaviors</strong>&nbsp;– These are provided as part of an MSBuild SDK called the “Arcade SDK”. By utilizing it, repositories opt-in to the default Arcade build behaviors, project and artifact layout, etc.</li><li data-line="134"><strong>Common repository ‘language’</strong>&nbsp;– A set of common&nbsp;<a title="https://github.com/dotnet/arcade/tree/master/eng/common" href="https://github.com/dotnet/arcade/tree/master/eng/common" target="_blank">script files</a>&nbsp;that are synchronized between all the Arcade repositories using dependency flow (more on that later). These script files introduce a common ‘language’ for repositories that have adopted Arcade. Moving between these repositories becomes more seamless for developers. Moreover, because these scripts are synced between repositories, rolling out new changes to the original copies located in the Arcade repo can quickly introduce new features or behavior into repositories that have fully adopted the shared tooling.</li><li data-line="142"><strong>Shared Azure DevOps job and step templates</strong>&nbsp;– While the scripts that define the common repository ‘language’ are primarily targeted towards interfacing with humans, Arcade also has a set of Azure DevOps&nbsp;<a title="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops" target="_blank">job and step templates</a>&nbsp;that allow for Arcade repositories to interface with the Azure DevOps CI systems. Like the common build task packages, the step templates form a base layer that can be utilized by almost every repository (e.g. to send build telemetry). The job templates form more complete units, allowing repositories to worry less about the details of their CI process.</li></ul><h3 id="moving-to-azure-devops" data-line="151">Moving to Azure DevOps</h3><p data-line="153">As noted above, the larger team used a combination of CI systems through the 2.2 release:</p><ul><li data-line="154">AppVeyor and Travis for&nbsp;ASP.NET&nbsp;Core’s GitHub PRs</li><li data-line="155">TeamCity for&nbsp;ASP.NET’s official builds</li><li data-line="156">Jenkins for the rest of .NET Core’s GitHub PRs and rolling validation.</li><li data-line="157">Classic (non-YAML) Azure DevOps workflows for all&nbsp;non-ASP.NET&nbsp;Core official builds.</li></ul><p data-line="159">A lot of differentiation was simply from necessity. Azure DevOps did not support public GitHub PR/CI validation, so&nbsp;ASP.NET&nbsp;Core turned to AppVeyor and Travis to fill the gap while .NET Core invested in Jenkins. Classic Azure DevOps did not have a lot of support for build orchestration, so the&nbsp;ASP.NET&nbsp;Core team turned to TeamCity while the .NET Core team built a tool called PipeBuild on top of Azure DevOps to help out. All of this divergence was very expensive, even in some non-obvious ways:</p><ul><li data-line="165">While Jenkins is flexible, maintaining a large (~6000-8000 jobs), stable installation is a serious undertaking.</li><li data-line="167">Building our own orchestration on top of classic Azure DevOps required a lot of compromises. The checked in pipeline job descriptions were not really human-readable (they were just exported json descriptions of manually created build definitions), secrets management was ugly, and they quickly became over-parameterized as we attempted to deal with the wide variance in build requirements.</li><li data-line="172">When official build vs. nightly validation vs. PR validation processes are defined in different systems, sharing logic becomes difficult. Developers must take additional care when making process changes because and breaks are common. We defined Jenkins PR jobs in a special script file, TeamCity had lots of manually configured jobs, AppVeyor and Travis used their own yaml formats, and Azure DevOps had the obscure custom system we built on top of it. It was easy to make a change to build logic in a PR and break the official CI build. To mitigate this, we did work to keep as much logic in scripting common to official CI and PR builds, but invariably differences creep in over time. Some variance, like in build environments, is basically impossible to entirely remove.</li><li data-line="181">Practices for making changes to workflows varied wildly and were often difficult to understand. What a developer learned about Jenkins’s netci.groovy files for updating PR logic did not translate over to the PipeBuild json files for official CI builds. As a result, knowledge of the systems was typically isolated to a few team members, which is less than ideal in large organizations.</li></ul><p data-line="187">When Azure DevOps began to roll out YAML based build pipelines and support for public GitHub projects as .NET Core 3.0 began to get underway, we recognized we had a unique opportunity. With this new support, we could move all our existing workflows out of the separate systems and into modern Azure DevOps and also make some changes to how we deal with official CI vs. PR workflows. We started with the following rough outline of the effort:</p><ul><li data-line="192">Keep all our logic in code, in GitHub. Use the YAML pipelines everywhere.</li><li data-line="193">Have a public and private project.<ul><li data-line="194">The public project will run all the public CI via GitHub repos and PRs as we always have</li><li data-line="195">The private project will run official CI be the home of any private changes we need to make, in repositories matching the public GitHub repositories</li><li data-line="197">Only the private project will have access to restricted resources.</li></ul></li><li data-line="198">Share the same YAML between official CI and PR builds. Use&nbsp;<a title="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops#template-expressions" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops#template-expressions" target="_blank">template expressions</a>&nbsp;to differentiate between the public and private project where behavior must diverge, or resources only available in the private project would be accessed. While this often makes the overall YAML definition a little messier, it means that:<ul><li data-line="203">The likelihood of a build break when making a process change is lower.</li><li data-line="204">A developer only really needs to change one set of places to change official CI and PR process.</li></ul></li><li data-line="206">Build up Azure DevOps templates for common tasks to keep duplication of boilerplate YAML to a minimum, and enable rollout of updates (e.g. telemetry) easy using dependency flow.</li></ul><p data-line="209">As of now, all of the primary .NET Core 3.0 repositories are on Azure DevOps for their public PRs and official CI. A good example pipeline is the official build/PR pipeline for <a title="https://github.com/dotnet/arcade/blob/master/azure-pipelines.yml" href="https://github.com/dotnet/arcade/blob/master/azure-pipelines.yml" target="_blank">dotnet/arcade</a>&nbsp;itself.</p><h3 id="maestro-and-dependency-flow" data-line="213">Maestro and Dependency Flow</h3><p data-line="215">The final piece of the .NET Core 3.0 infrastructure puzzle is what we call dependency flow. This is not a unique concept to .NET Core. Unless they are entirely self-contained, most software projects contain some kind of versioned reference to other software. In .NET Core, these are commonly represented as NuGet packages. When we want new features or fixes that libraries have shipped, we pull those new updates by updating the referenced version numbers in our projects. Of course, these packages may also have versioned references to other packages, those other packages may have more references, so on and so forth. This creates a graph. Changes flow through the graph as each repository pulls new versions of their input dependencies.</p><h4 id="a-complex-graph" data-line="224">A Complex Graph</h4><p data-line="226">The primary development life-cycle (what developers regularly work on) of most software projects typically involves a small number of inter-related repositories. Input dependencies are typically stable and updates are sparse. When they do need to change, it’s usually a manual operation. A developer evaluates the available versions of the input package, chooses an appropriate one, and commits the update. This is not the case in .NET Core. The need for components to be independent, ship on different cadences and have efficient inner-loops development experiences has led to a fairly large number of repositories with a large amount of inter-dependency. The inter-dependencies also form a fairly deep graph:</p><figure id="attachment_23617" aria-describedby="caption-attachment-23617"><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-RepoGraph-1024x504.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-RepoGraph-1024x504.png" alt="" width="640" height="315" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-RepoGraph-1024x504.png 1024w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-RepoGraph-300x148.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-RepoGraph-768x378.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-RepoGraph.png 2048w" sizes="(max-width: 640px) 100vw, 640px"> </a><figcaption id="caption-attachment-23617"> The dotnet/core-sdk repository serves as the aggregation point for all sub-components. We ship a specific build of dotnet/core-sdk, which describes all other referenced components.</figcaption></figure><p data-line="239">We also expect that new outputs will flow quickly through this graph so that the end product can be validated as often as possible. For instance, we expect the latest bits of&nbsp;ASP.NET&nbsp;Core or the .NET Core Runtime to express themselves in the SDK as often as possible. This essentially means updating dependencies in each repository on a regular, fast cadence. In a graph of sufficient size, like .NET Core has, this quickly becomes an impossible task to do manually. A software project of this size might go about solving this is a number of ways:</p><ul><li data-line="245"><strong>Auto-floating input versions</strong>&nbsp;– In this model, dotnet/core-sdk might reference the Microsoft.NETCore.App produced out of dotnet/core-setup by allowing NuGet to float to the latest prerelease version. While this works, it suffers from major drawbacks. Builds become non-deterministic. Checking out an older git SHA and building will not necessarily use the same inputs or produce the same outputs. Reproducing bugs becomes difficult. A bad commit in dotnet/core-setup can break any repository pulling in its outputs, outside of PR and CI checks. Orchestration of builds becomes a major undertaking, because separate machines in a build may restore packages at different times, yielding different inputs. All of these problems are ‘solvable’, but require huge investment and unnecessary complication of the infrastructure.</li><li data-line="254"><strong>‘Composed’ build</strong>&nbsp;– In this model, the entire graph is built all at once in isolation, in dependency order, using the latest git SHAs from each of the input repositories. The outputs from each stage of the build are fed into the next stage. A repository effectively has its input dependency version numbers overwritten by its input stages. At the end of a successful build, the outputs are published and all the repositories update their input dependencies to match what was just built. This is a bit of an improvement over auto-floating version numbers in that individual repository builds aren’t automatically broken by bad check-ins in other repos, but it still has major drawbacks. Breaking changes are almost impossible to flow efficiently between repositories, and reproducing failures is still problematic because the source in a repository often doesn’t match what was actually built (since input versions were overwritten outside of source control).</li><li data-line="264"><strong>Automated dependency flow</strong>&nbsp;– In this model, external infrastructure is used to automatically update dependencies in a deterministic, validated fashion between repositories. Repositories explicitly declare their input dependencies and associated versions in source, and ‘subscribe’ to updates from other repositories. When new builds are produced, the system finds matching subscriptions, updates any of the declared input dependencies, and opens a PR with the changes. This method improves reproducibility, the ability to flow breaking changes, and allows a repository owner to have control over how updates are done. On the downside, it can be significantly slower than either of the other two methods. A change can only flow from the bottom of the stack to the top as fast as the total sum of the PR and Official CI times in each repository along the flow path.</li></ul><p data-line="275">.NET Core has tried all 3 methods. We floated versions early on in the 1.x cycle, had some level of automated dependency flow in 2.0 and went to a composed build for 2.1 and 2.2. With 3.0 we decided to invest heavily in automated dependency flow and abandon the other methods. We wanted to improve over our former 2.0 infrastructure in some significant ways:</p><ul><li data-line="279"><strong>Ease traceability of what is actually in the product</strong>&nbsp;– At any given repository, it’s generally possible to determine what versions of what components are being used as inputs, but almost always hard to find out where those components were built, what git SHAs they came from, what their input dependencies were, etc.</li><li data-line="283"><strong>Reduce required human interaction</strong>&nbsp;– Most dependency updates are mundane. Auto-merge the update PRs as they pass validation to speed up flow.</li><li data-line="285"><strong>Keep dependency flow information separate from repository state</strong>&nbsp;– Repositories should only contain information about the current state of their node in the dependency graph. They should not contain information regarding transformation, like when updates should be taken, what sources they pull from, etc.</li><li data-line="289"><strong>Flow dependencies based on ‘intent’, not branch</strong>&nbsp;– Because .NET Core is made up of quite a few semi-autonomous teams with different branching philosophies, different component ship cadences, etc. do not use branch as a proxy for intent. Teams should define what new dependencies they pull into their repositories based on the purpose of those inputs, not where they came from. Furthermore, the purpose of those inputs should be declared by those teams producing those inputs.</li><li data-line="295"><strong>‘Intent’ should be deferred from the time of build</strong>&nbsp;– To improve flexibility, avoid assigning the intent of a build until after the build is done, allowing for multiple intentions to be declared. At the time of build, the outputs are just a bucket of bits built at some git SHA. Just like running a release pipeline on the outputs of an Azure DevOps build essentially assigns a purpose for the outputs, assigning an intent to a build in the dependency flow system begins the process of flowing dependencies based on intent.</li></ul><p data-line="302">With these goals in mind, we created a service called Maestro++ and a tool called ‘darc’ to handle our dependency flow. Maestro++ handles the data and automated movement of dependencies, while darc provides a human interface for Maestro++ as well as a window into the overall product dependency state. Dependency flow is based around 4 primary concepts: dependency information, builds, channels and subscriptions.</p><h4 id="builds-channels-and-subscriptions" data-line="308">Builds, Channels, and Subscriptions</h4><ul><li data-line="310"><strong>Dependency information</strong>&nbsp;– In each repository, there is a declaration of the input dependencies of the repository along with source information about those input dependencies in the&nbsp;<a title="https://github.com/dotnet/core-sdk/blob/master/eng/Version.Details.xml" href="https://github.com/dotnet/core-sdk/blob/master/eng/Version.Details.xml" target="_blank">eng/Version.Details</a>. Reading this file, then transitively following the repository+sha combinations for each input dependency yields the product dependency graph.</li><li data-line="315"><strong>Builds</strong>&nbsp;– A build is just the Maestro++ view on an Azure DevOps build. A build identifies the repository+sha, overall version number and the full set of assets and their locations that were produced from the build (e.g. NuGet packages, zip files, installers, etc.).</li><li data-line="318"><strong>Channels</strong>&nbsp;– A channel represents intent. It may be useful to think of a channel as a cross repository branch. Builds can be assigned to one or more channels to assign intent to the outputs. Channels can be associated with one or more release pipelines. Assignment of a build to a channel activates the release pipeline and causes publishing to happen. The asset locations of the build are updated based on release publishing activities.</li><li data-line="323"><strong>Subscriptions</strong>&nbsp;– A subscription represents transform. It maps the outputs of a build placed on a specific channel onto another repository’s branch, with additional information about when those transforms should take place.</li></ul><p data-line="327">These concepts are designed so that repository owners do not need global knowledge of the stack or other teams’ processes in order to participate in dependency flow. They basically just need to know three things:</p><ul><li data-line="330">The intent (if any) of the builds that they do, so that channels may be assigned.</li><li data-line="331">Their input dependencies and what repositories they are produced from.</li><li data-line="332">What channels they wish to update those dependencies from.</li></ul><p data-line="334">As an example, let’s say I own the dotnet/core-setup repository. I know that my master branch produces bits for day to day .NET Core 3.0 development. I want to assign new builds to the pre-declared ‘.NET Core 3.0 Dev’ channel. I also know that I have several dotnet/coreclr and dotnet/corefx package inputs. I don’t need to know how they were produced, or from what branch. All I need to know is that I want the newest dotnet/coreclr inputs from the ‘.NET Core 3.0 Dev’ channel on a daily basis, and the newest dotnet/corefx inputs from the ‘.NET Core 3.0 Dev’ channel every time they appear.</p><p data-line="342">First, I onboard by adding an&nbsp;<a title="https://github.com/dotnet/core-setup/blob/master/eng/Version.Details.xml" href="https://github.com/dotnet/core-setup/blob/master/eng/Version.Details.xml" target="_blank">eng/Version.Details</a>&nbsp;file. I then use the ‘darc’ tool to ensure that every new build of my repository on the master branch is assigned by default to the ‘.NET Core 3.0 Dev’ channel. Next, I set up subscriptions to pull inputs from .NET Core 3.0 Dev for builds of dotnet/corefx, dotnet/coreclr, dotnet/standard, etc. These subscriptions have a cadence and auto-merge policy (e.g. weekly or every build).</p><p data-line="349">As the trigger for each subscription is activated, Maestro++ updates files (eng/Version.Details.xml, eng/Versions.props, and a few others) in the core-setup repo based on the declared dependencies intersected with the newly produced outputs. It opens a PR, and once the configured checks are satisfied, will automatically merge the PR.</p><p data-line="346"><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-UpdatePR.jpg" data-featherlight="image"></a><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-UpdatePR-1024x783.jpg" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-UpdatePR-1024x783.jpg" alt="" width="640" height="489" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-UpdatePR-1024x783.jpg 1024w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-UpdatePR-300x230.jpg 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-UpdatePR-768x588.jpg 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlog-UpdatePR.jpg 1588w" sizes="(max-width: 640px) 100vw, 640px"> </a></p><p data-line="348">This in turn generates a new build of core-setup on the master branch. Upon completion, automatic assignment of the build to the ‘.NET Core 3.0 Dev’ channel is started. The ‘.NET Core 3.0 Dev’ channel has an associated release pipeline which pushes the build’s output artifacts (e.g. packages and symbol files) to a set of target locations. Since this channel is intended for day to day public dev builds, packages and symbols are pushed to various public locations. Upon release pipeline completion, channel assignment is finalized and any subscriptions that activate on this event are fired. As more components are added, we build up a full flow graph representing all of the automatic flow between repositories.</p><figure id="attachment_23616" aria-describedby="caption-attachment-23616"><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlob-FlowGraph-1024x502.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlob-FlowGraph-1024x502.png" alt="" width="640" height="314" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlob-FlowGraph-1024x502.png 1024w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlob-FlowGraph-300x147.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlob-FlowGraph-768x377.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/06/NetCoreInfraBlob-FlowGraph.png 2048w" sizes="(max-width: 640px) 100vw, 640px"> </a><figcaption id="caption-attachment-23616"> Flow graph for the .NET Core 3 Dev channel, including other channels that (e.g. Arcade’s ‘.NET Tools Latest’) that contribute to the .NET Core 3 Dev flow.</figcaption></figure><h4 id="coherency-and-incoherency" data-line="369">Coherency and Incoherency</h4><p data-line="371">The increased visibility into the state of .NET Core’s dependency graph highlighted an existing question:&nbsp;<strong>What happens when multiple versions of the same component are referenced at various nodes in the graph?</strong>&nbsp;Each node in .NET Core’s dependency graph may flow dependencies to more than one other node. For instance, the Microsoft.NETCore.App dependency, produced out of dotnet/core-setup, flows to dotnet/toolset, dotnet/core-sdk, aspnet/extensions and a number of other places. Updates of this dependency will be committed at different rates in each of those places, due to variations in pull request validation time, need for reaction to breaking changes, and desired subscription update frequencies. As those repositories then flow elsewhere and eventually coalesce under dotnet/core-sdk, there may be a number of different versions of Microsoft.NETCore.App that have been transitively referenced throughout the graph. This is called&nbsp;<strong>incoherency</strong>. When only a single version of each product dependency is referenced throughout the dependency graph, the graph is&nbsp;<strong>coherent</strong>. We always strive to ship a coherent product if possible.</p><p data-line="385"><em><strong>What kinds of problems of does incoherency cause?</strong></em>&nbsp;Incoherency represents a&nbsp;<em>possible</em>&nbsp;error state. For an example let’s take a look at Microsoft.NETCore.App. This package represents a specific API surface area. While multiple versions of Microsoft.NETCore.App may be referenced in the repository dependency graph, the SDK ships with just one. This runtime must satisfy all of the demands of the transitively referenced components (e.g. WinForms and WPF) that may execute on that runtime. If the runtime does not satisfy those demands (e.g. breaking API change), failures may occur. In an incoherent graph, because all repositories have not ingested the same version of Microsoft.NETCore.App, there is a possibility that a breaking change has been missed.</p><p data-line="394"><em><strong>Does this mean that incoherency is always an error state?</strong></em>&nbsp;No. For example, let’s say that the the incoherency of Microsoft.NETCore.App in the graph only represents a single change in coreclr, a single non-breaking JIT bug fix. There would technically be no need to ingest the new Microsoft.NETCore.App at each point in the graph. Simply shipping the same components against the new runtime will suffice.</p><p data-line="400"><em><strong>If incoherency only matters occasionally, why do we strive to ship a coherent product?</strong></em>&nbsp;Because determining when incoherency does not matter is hard. It is easier to simply ship with coherency as the desired state than attempt to understand any semantic effects differences between incoherent components will have on the completed product. It can be done, but on a build to build basis it is time intensive and prone to error. Enforcing coherency as the default state is safer.</p><h4 id="dependency-flow-goodies" data-line="406">Dependency Flow Goodies</h4><p data-line="408">All this automation and tracking has a ton of advantages that become apparent as the repository graph gets bigger. It opens up a lot of possibility to solve real problems we have on a day to day basis. While we have just begun to explore this area, the system can begin to answer interesting questions and handling scenarios like:</p><ul><li data-line="412">What ‘real’ changes happened between git SHA A and SHA B of dotnet/core-sdk? – By building up a full dependency graph by walking the Version.Details.xml files, I can identify the non-dependency changes change happened in the graph.</li><li data-line="415">How long will it take for a fix to appear in the product? – By combining the repository flow graph and per-repository telemetry, we can estimate how long it will take to move a fix from repo A to repo B in the graph. This is especially valuable late in a release, as it helps us make a more accurate cost/benefit estimation when looking at whether to take specific changes. For example: Do we have enough time to flow this fix and complete our scenario testing?</li><li data-line="420">What are the locations of all assets produced by a build of core-sdk and all of its input builds?</li><li data-line="421">In servicing releases, we want to take specific fixes but hold off on others. Channels could be placed into modes where a specific fix is allowed to flow automatically through the graph, but others are blocked or require approval.</li></ul><h2 id="whats-next" data-line="425">What’s next?<a href="#whats-next"></a></h2><p data-line="427">As .NET Core 3.0 winds down, we’re looking for new areas to improve. While planning is still in the (very) early stages, we expect investments in a some key areas:</p><ul><li data-line="429">Reduce the time to turn a fix into a shippable, coherent product – The number of hops in our dependency graph is significant. This allows repositories a lot of autonomy in their processes, but increases our end to end ‘build’ time as each hop requires a commit and official build. We’d like to significantly reduce that end-to-end time.</li><li data-line="433">Improving our infrastructure telemetry – If we can better track where we fail, what our resource usage looks like, what our dependency state looks like, etc. we can better determine where our investments need to be to ship a better product. In .NET Core 3.0 we took some steps in this direction but we have a ways to go.</li></ul><p data-line="438">We’ve evolved our infrastructure quite a bit over the years. From Jenkins to Azure DevOps, from manual dependency flow to Maestro++, and from many tooling implementations to one, the changes we’ve made to ship .NET Core 3.0 are a huge step forward. We’ve set ourselves up to develop and ship a more exciting product more reliably than ever before.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>