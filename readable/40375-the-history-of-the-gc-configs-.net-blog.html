<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The history of the GC configs | .NET Blog -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>The history of the GC configs | .NET Blog</h1>
    <div class="entry-content col-12 sharepostcontent"><div class="row justify-content-center"><div class="col-md-4"><div><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/twitter-profile-150x150.jpg" width="58" alt="maoni" class="avatar avatar-58 wp-user-avatar wp-user-avatar-58 alignnone photo"><p>Maoni</p></div></div></div><p>Recently, Nick from Stack Overflow <a href="https://twitter.com/Nick_Craver/status/1189685719897460739">tweeted</a> about his experience of using the .NET Core GC configs &#x2013; he seemed quite happy with them (minus the fact they are not documented well which is something I&#x2019;m talking to our doc folks about). I thought it&#x2019;d be fun to tell you about the history of the GC configs &#x2018;cause it&#x2019;s almost the weekend and I want to contribute to your fun weekend reading.</p><p>I started working on the GC toward the end of .NET 2.0. At that time we had really, really few public GC configs. &#x201C;Public&#x201D; in this context means &#x201C;officially supported&#x201D;. I&#x2019;m talking just <a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element">gcServer</a> and <a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/gcconcurrent-element">gcConcurrent</a>, which you could specify as application configs and I think the retain VM one which was exposed as a startup flag <a href="https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/hosting/startup-flags-enumeration">STARTUP_HOARD_GC_VM</a>, not an app config. Those of you who only worked with .NET Core may not have come across &#x201C;application configs&#x201D; &#x2013; that&#x2019;s a concept that only exists on .NET, not .NET Core. If you have an .exe called a.exe, and you have a file called a.exe.config in the same directory, then .NET will look at things you specify in this file under the runtime element for things like gcServer or some other non GC configs.</p><p>At that time the official ways to configure the CLR were:</p><ul><li>App configs, under the runtime element</li></ul><ul><li>Startup flags when you load the CLR via Hosting API, strictly speaking, you could use some of the hosting APIs to customize other aspects of GC like providing memory for the GC instead of having GC acquire memory via the OS VirtualAlloc/VirtualFree APIs but I will not get into those &#x2013; the only customer of those was SQLCLR AFAIK.</li></ul><p>(There were actually also other ways like the machine config but I will also not get into those as they have the same idea as the app configs)</p><p>Of course there have always been the (now (fairly) famous) COMPlus environment variables. We used them only for internal testing &#x2013; it&#x2019;s easy to specify env vars and our testing framework read them, set them and unset them as needed. There were actually not many of those either &#x2013; one example was GCSegmentSize that was heavily used in testing (to test the expand heap scenario) but not officially supported so we never documented them as app configs.</p><p>I was told that env vars were not a good customer facing way to config things because people tend to set them and forget to unset them and then later they wonder why they were seeing some unexpected behavior. And I did see that happen with some internal teams so this seemed like a reasonable reason.</p><p>Startup flags are just a hosting API thing and hosting API was something few people heard of and way fewer used. You could say things like you want to start the runtime with Server GC and domain neutral. It&#x2019;s a native API and most of our customers refused to use it when they were recommended to try. Today I&#x2019;m aware of only one team who&#x2019;s actively using it &#x2013; not surprisingly many people on that team used to work on SQLCLR &#x1F61B;</p><p>For things you could specify as app configs you could also specify them with env vars or even registry values because on .NET our internal API to read these configs always check all 3 places. While we had a different kind of attitude toward configs you could specific via app config, which were considered officially supported, implementation wise this was great because devs didn&#x2019;t need to worry about which place the config would be read from &#x2013; they knew if they added a new config in clrconfigvalues.h it could be specified via any of the 3 ways automatically.</p><p>During the .NET 4.x timeframe We needed to add public configs for things like CPU group (we started seeing machines with &gt; 64 procs) or creating objects of &gt;2gb due to customer requests. Very few customers used these configs. So they could be thought of as special case configs, in other words, the majority of the scenarios were run with no configs aside from the gcServer/gcConcurrent ones.</p><p>I was pretty wary of adding new public configs. Adding internal ones was one thing but actually telling folks about them means we&#x2019;d basically be saying we are supporting them forever &#x2013; in the older versions of .NET the compatibility bar was ultra high. And tooling was of course not as advanced then so perf analysis was harder to do (most of the GC configs were for perf).</p><p>For a long time folks used the 2 major flavors of the GC, Server and Workstation, mostly according to the way they were designed. But you know how the rest of this story goes &#x2013; folks didn&#x2019;t exactly use them &#x201C;as designed originally&#x201D; anymore. And as the GC diagnostic space also advanced customers were able to debug and understand GC perf better and also used .NET on larger, more stressful and more diverse scenarios. So there was more and more desire from them to do more configuration on their own.</p><p>Good thing was Microsoft internally had plenty of customers who had very stressful workloads that called for configuration so I was able to test on these stressful real world scenarios. Around the time of .NET 4.6 I started adding configs more aggressively. One of our 1st party customers was running a scenario with many managed processes. They had configed some to use Server GC and others to use Workstation. But there was nothing inbetween. This was when configs like GCHeapCount/GCNoAffinitize/GCHeapAffinitizeMask were added.</p><p>Around that time we also open sourced coreclr. The distinction of &#x201C;officially supported configs&#x201D; vs internal only configs was still there &#x2013; in theory that line had become a little blurry because our customers could see what internal configs we had &#x1F642; but it also took time for Core adoption so I wasn&#x2019;t aware of really anyone who was using internal only configs. Also we changed the way config values were read &#x2013; we no longer had the &#x201C;one API reads them all&#x201D; so today on Core where the &#x201C;official configs&#x201D; are specified via the runtimeconfig.json, you&#x2019;d need to use a different API and specify the name in the json and the name for the env var if you want to read from both.</p><p>My development was still on CLR mostly, just because we had very few workloads on CoreCLR at that time and being able to try things on large/stressful workloads was a very valuable thing. Around this time I added a few more configs for various scenarios &#x2013; notable ones are GCLOHTheshold and GCHighMemPercent. A team had their product running in a process coexisting with a much large process on the same machine which had a lot of memory. So the default memory load that GC considered as &#x201C;high memory load situation&#x201D;, which was 90%, worked well for the much larger process but not for them. When there&#x2019;s 10% physical memory left that was still a huge amount for their process so I added this for them to specify a higher value (they specified 97 or 98) which meant their process didn&#x2019;t need to do full compacting GCs nearly as often.</p><p>Core 3.0 was when I unified the source between .NET and .NET Core so all the configs (&#x201C;internal&#x201D; or not) from .NET were made available on Core as well. The json way is obviously the official way to specify a config but it appeared specifying configs via env vars was becoming more common, especially with folks who work on scenarios with high perf requirements. I know quite a few internal and external customers use them (and have yet to hear any incidents that involved setting an env var in an undesirable fashion). A few more GC configs were added during Core 3.0 &#x2013; GCHeapHardLimit, GCLargePages, GCHeapAffinitizeRanges and etc.</p><p>One thing that took folks (who used env vars) by surprise was the number you specific for a config in an env var format is interpreted as a hex number, not decimal. As far as why it was this way, it completely predates my time on the runtime team&#x2026; since everyone remembered this for sure after they used it wrong the first time &#x1F61B; and it was an internal only thing, no one bothered to change it.</p><p>I am still of the opinion that the officially supported configs should not require you to have internal GC knowledge. Of course internal is up for interpretation &#x2013; some people might view anything beyond gcServer as internal knowledge. I&#x2019;m interpreting &#x201C;not having internal GC knowledge&#x201D; in this context as &#x201C;only having general perf knowledge to influence the GC&#x201D;. For example, GCHeapHardLimit tells the GC how much memory it&#x2019;s allowed to use; GCHeapCount tells the GC how many cores it&#x2019;s allowed to use. Memory/CPU usage are general perf knowledge that one already needs to have if they work on perf. GCLOHThreshold is actually violating this policy somewhat so it&#x2019;s something we&#x2019;d like to dynamically tune in GC instead of having users specify a number. But that&#x2019;s work we haven&#x2019;t done yet.</p><p>I don&#x2019;t want to have configs that would need users to config things like &#x201C;if this generation&#x2019;s free list ratio or survival rate is &gt; some threshold I would choose this particular GC to handle collections on that generation; but use this other GC to collect other generations&#x201D;. That to me is definitely &#x201C;requiring GC internal knowledge&#x201D;.</p><p>So there you have it &#x2013; the history of the GC configs in .NET/.NET Core.</p></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>