<!DOCTYPE html>
<html lang="en">
<head>
    <title>
NVIDIA Turing Vulkan/OpenGL extensions - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="NVIDIA Turing Vulkan/OpenGL extensions - linksfor.dev(s)"/>
    <meta property="og:description" content="NVIDIA just launched the TU102/TU104 (GeForce RTX 2080ti/2080), first GPUs based on the Turing  architecture. This new architecture brings ..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.icare3d.org/2018/09/nvidia-turing-vulkanopengl-extensions.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - NVIDIA Turing Vulkan/OpenGL extensions</title>
<div class="readable">
        <h1>NVIDIA Turing Vulkan/OpenGL extensions</h1>
            <div>Reading time: 10-13 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://blog.icare3d.org/2018/09/nvidia-turing-vulkanopengl-extensions.html">https://blog.icare3d.org/2018/09/nvidia-turing-vulkanopengl-extensions.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
<p><a href="https://1.bp.blogspot.com/-t2Zo32FEvJo/W3rtXYSS4CI/AAAAAAAAGbU/lRYQjHeoJhE8MuhFSgZs5-thfqOuJBs2ACPcBGAYYCw/s1600/QuadroTuring01.jpg" imageanchor="1"><img data-original-height="1443" data-original-width="1600" height="180" src="https://1.bp.blogspot.com/-t2Zo32FEvJo/W3rtXYSS4CI/AAAAAAAAGbU/lRYQjHeoJhE8MuhFSgZs5-thfqOuJBs2ACPcBGAYYCw/s200/QuadroTuring01.jpg" width="200"></a>NVIDIA just launched the TU102/TU104 (GeForce RTX 2080ti/2080), first GPUs based on the <b>Turing</b> architecture. This new architecture brings hardware ray-tracing acceleration, as well as many other new and really cool graphics features. A good high-level overview of the architecture and new graphics features can be found in the <a href="https://www.nvidia.com/content/dam/en-zz/Solutions/design-visualization/technologies/turing-architecture/NVIDIA-Turing-Architecture-Whitepaper.pdf" target="_blank">Turing Architecture whitepaper</a> as well as this <a href="https://devblogs.nvidia.com/nvidia-turing-architecture-in-depth/" target="_blank">blog post</a>. Most of these features are exposed through both <b>Vulkan</b> and <b>OpenGL</b> extensions, and I will quickly go through each of them in this post. A big thanks to the many people at NVIDIA who worked hard to provide us with these extensions !</p>
<p>
Most features split into a Vulkan or OpenGL -specific extension (<span>GL_*/VK_*</span>), and a GLSL or SPIR-V shader extension (<span>GLSL_*/SPV_*</span>).</p><ul></ul>
<h2>
Ray-Tracing Acceleration</h2>
<ul>
<li><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NVX_raytracing" target="_blank"><span>VK_NVX_raytracing</span></a> (<span><a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/nvx/GLSL_NVX_raytracing.txt" target="_blank">GLSL_NVX_raytracing</a> / <a href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/NV/SPV_NVX_raytracing.html" target="_blank">SPV_NVX_raytracing</a></span>)</li>
</ul>
<div>
<p><a href="https://devblogs.nvidia.com/wp-content/uploads/2018/03/raytrace_01-625x630.png" imageanchor="1"><img data-original-height="630" data-original-width="625" height="200" src="https://devblogs.nvidia.com/wp-content/uploads/2018/03/raytrace_01-625x630.png" width="198"></a>Turing brings hardware acceleration for ray-tracing through dedicated units called RT cores. The RT cores provide BVH traversal as well as ray-triangle intersection. This acceleration is exposed in Vulkan through a new ray-tracing pipeline, associated with a series of new shader stages. This programming model maps the DXR (DirectX Ray-Tracing) model, which is quickly described in <a href="https://devblogs.nvidia.com/introduction-nvidia-rtx-directx-ray-tracing/">this blog post</a>, and <a href="https://devblogs.nvidia.com/vulkan-raytracing/">this blog post</a> details the Vulkan implementation.</p>
<br></div>
<br>
<h2>
Mesh Shading </h2>
<p><a href="https://1.bp.blogspot.com/-7pMw7IdUqz8/W6FqR8lJhaI/AAAAAAAAGcI/w735CUIXhhcToVsC4ic6NpvuomvsygY1QCLcBGAs/s1600/Meshlets2.png" imageanchor="1"><img data-original-height="471" data-original-width="1600" height="188" src="https://1.bp.blogspot.com/-7pMw7IdUqz8/W6FqR8lJhaI/AAAAAAAAGcI/w735CUIXhhcToVsC4ic6NpvuomvsygY1QCLcBGAs/s640/Meshlets2.png" width="640"></a></p>
<br>
<ul>
<li><span><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_mesh_shader" target="_blank">VK_NV_mesh_shader</a> / <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_mesh_shader.txt" target="_blank">GL_NV_mesh_shader</a></span> <span>(<span><a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/nv/GLSL_NV_mesh_shader.txt" target="_blank">GLSL_NV_mesh_shader</a> / <a href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/NV/SPV_NV_mesh_shader.html" target="_blank">SPV_NV_mesh_shader</a></span>)</span></li>
</ul>
<ul>
</ul>
<div>
<p>
This is a new programmable geometry pipeline which replaces the traditional VS/HS/DS/GS pipeline with basically a Compute-based programming model. This new pipeline is based on two shader stages, a Task Shader and a Mesh Shader (separated by an expansion stage), which are used to ultimately generate a compact mesh description called a Meshlet. A Meshlet is a mini indexed geometry representation which is maintained on chip and is directly fed to the rasterizer for consumption. This exposes a very flexible and very efficient model with Compute Shader features and generic cooperative thread groups (workgroups, shared memory, barrier synchronizations...). Applications are endless, and this can for instance be used to implement efficient culling or LOD schemes, or perform procedural geometry generation.</p></div>

<div><p>
As well as in his Siggraph 2018 presentation: <a href="http://on-demand.gputechconf.com/siggraph/2018/video/sig1811-3-christoph-kubisch-mesh-shaders.html">http://on-demand.gputechconf.com/siggraph/2018/video/sig1811-3-christoph-kubisch-mesh-shaders.html</a></p><p>

A full OpenGL sample code which implements a <a href="http://onrendering.com/data/papers/isubd/isubd.pdf">compute-based adaptive tessellation technique</a> can also be found there: <a href="https://github.com/jdupuy/opengl-framework/tree/master/demo-isubd-terrain">https://github.com/jdupuy/opengl-framework/tree/master/demo-isubd-terrain</a></p><h2>
Variable Rate Shading</h2>
<ul>
<li><span><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_shading_rate_image" target="_blank">VK_NV_shading_rate_image</a> / <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_shading_rate_image.txt" target="_blank">GL_NV_shading_rate_image</a></span> (<span><a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/nv/GLSL_NV_shading_rate_image.txt" target="_blank">GLSL_NV_shading_rate_image</a> / <a href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/NV/SPV_NV_shading_rate.html" target="_blank">SPV_NV_shading_rate</a></span>)</li>
</ul>
<p><a href="https://2.bp.blogspot.com/-S4vpWzXylpE/W6FlDNxLP0I/AAAAAAAAGb8/_tqn3az7XCEbtznd5V-3PKEPU20NLHaSACLcBGAs/s1600/VRS2.png" imageanchor="1"><img data-original-height="420" data-original-width="605" height="220" src="https://2.bp.blogspot.com/-S4vpWzXylpE/W6FlDNxLP0I/AAAAAAAAGb8/_tqn3az7XCEbtznd5V-3PKEPU20NLHaSACLcBGAs/s320/VRS2.png" width="320"></a>This is a very powerful hardware feature which allows the application to dynamically control the number of fragment shader invocations (independently of the visibility rate) and vary this <i>shading rate</i> across the framebuffer. The <i>shading rate</i> is controlled using a texture image ("Shading Rate Image", 8b/texel) where each texel specifies an independent shading rate for blocks of 16x16 pixels. The rate is actually specified indirectly 
using 8b indices into a palette which is specified per-viewport and stores the actual 
shading rate flags.</p>

<p>
Not only the feature allows to vary the MSAA shading rate per-pixel (allowing 1x,4x,8x, and now even 16x SSAA, but with a maximum of 8x depth test and color storage), but it also allows to drop the shading rate below one invocation per-pixel, down to one invocation per block of 4x4 pixels (through one per 1x2, 2x1, 2x2, 2x4 and 4x2 pixels) and even zero invocation.&nbsp;</p>
<div>
<p>
The GLSL extensions also exposes intrinsics allowing fragment shaders to read the effective fragment size in pixels (<span>gl_FragmentSizeNV</span>) as well as the number of fragment shader invocation for a fully covered pixel (<span>gl_InvocationsPerPixelNV</span>). This opens the road to many new algorithms and more efficient implementations of optimized shading rate techniques, like Foveated Rendering, Lens Adaptation (for VR), Content or Motion Adaptive Shading.</p></div><p>
More info on Variable Rate Shading in this blog post:<a href="https://devblogs.nvidia.com/turing-variable-rate-shading-vrworks/"> https://devblogs.nvidia.com/turing-variable-rate-shading-vrworks/</a></p><h2>
Exclusive Scissor Test</h2>
<ul>
<li><span><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_scissor_exclusive" target="_blank">VK_NV_scissor_exclusive</a> / <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_scissor_exclusive.txt" target="_blank">GL_NV_scissor_exclusive</a></span></li>
</ul>
<p>
This adds a second per-viewport scissor test, which culls fragments *inside* (exclusive) the specified rectangle, unlike the standard scissor test which culls *outside* (inclusive). This can be used for instance to implement more efficient multi-resolution foveated-rendering techniques (in conjunction with Variable Rate Shading), where raster passes fill concentric strips of pixels by enabling both inclusive and exclusive scissor tests.</p>
<br>
<h2>
Texture Access Footprint</h2>
<ul>
<li><span><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_shader_image_footprint" target="_blank">VK_NV_shader_image_footprint</a> / <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_shader_texture_footprint.txt" target="_blank">GL_NV_shader_texture_footprint</a></span> (<span><a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/nv/GLSL_NV_shader_texture_footprint.txt" target="_blank">GLSL_NV_shader_texture_footprint</a> / <a href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/NV/SPV_NV_shader_image_footprint.html" target="_blank">SVP_NV_shader_image_footprint</a></span>)</li>
</ul>
<p><a href="https://2.bp.blogspot.com/-jH7o7EDyt5U/W6GlGTMn6dI/AAAAAAAAGcg/tvpeEBgFM3cmffWU6mvanhPQJ9yJMWT2gCLcBGAs/s1600/TexFootprint2.png" imageanchor="1"><img data-original-height="304" data-original-width="308" height="197" src="https://2.bp.blogspot.com/-jH7o7EDyt5U/W6GlGTMn6dI/AAAAAAAAGcg/tvpeEBgFM3cmffWU6mvanhPQJ9yJMWT2gCLcBGAs/s200/TexFootprint2.png" width="200"></a></p>
<p>
These extensions expose a set of GLSL (and SPIR-V) query functions which report the texture-space footprints of texture lookups, ie. some data identifying the set of all texels that may be accessed in order to return a filtered result for the corresponding texture accesses (which can use anisotropic-filtering and potentially cover large footprints). Footprints are returned and represented as an LOD value, an anchor point and a 64-bit bitfield where each bit represents coverage for a group of neighboring texel (in 2D, group granularity can range from 2x2 to 256x256 texels). </p>

<p>
This is actually an important component for implementing multi-pass decoupled and texture-space shading pipelines, where a restricted set of actually visible pixels must be determined in order to efficiently perform shading in a subsequent pass.</p>
<br>
<h2>
Derivatives in Compute Shader </h2>
<ul>
<li><span><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_compute_shader_derivatives" target="_blank">VK_NV_compute_shader_derivatives</a> / <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_compute_shader_derivatives.txt" target="_blank">GL_NV_compute_shader_derivatives</a></span> (<span><a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/nv/GLSL_NV_compute_shader_derivatives.txt" target="_blank">GLSL_NV_compute_shader_derivatives</a> / <a href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/NV/SPV_NV_compute_shader_derivatives.html" target="_blank">SPV_NV_compute_shader_derivatives</a></span>)</li>
</ul>
<p><a href="https://3.bp.blogspot.com/-WKNJkZyNAso/W6GCay7NmBI/AAAAAAAAGcU/FuAsFez1WBEPjo-9_OJWNY-5AZqz6iILACLcBGAs/s1600/ComputeQuad.png" imageanchor="1"><img data-original-height="329" data-original-width="329" height="150" src="https://3.bp.blogspot.com/-WKNJkZyNAso/W6GCay7NmBI/AAAAAAAAGcU/FuAsFez1WBEPjo-9_OJWNY-5AZqz6iILACLcBGAs/s200/ComputeQuad.png" width="150"></a></p>
<p>
These extensions bring Compute even closer to Graphics by adding support for Quad-based derivatives in Compute Shaders, using the x and y coordinates of the local workgroup invocation ID. This allows Compute Shaders to use both built-in derivative functions like dFdx(), as well as texture lookup functions using automatic LOD computation, and the texture level of detail query function (<span>textureQueryLod()</span>). <br>
Two layout qualifiers are provided allowing to specify Quad arrangements based on a linear index or 2D indices.</p>
<h2>
Shader Subgroup Operations</h2>
<ul>
<li><span><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_shader_subgroup_partitioned" target="_blank">VK_NV_shader_subgroup_partitioned</a> / <a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/nv/GL_NV_shader_subgroup_partitioned.txt" target="_blank">GL_NV_shader_subgroup_partitioned</a></span> (<span><a href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/NV/SPV_NV_shader_subgroup_partitioned.html" target="_blank">SPV_NV_shader_subgroup_partitioned</a></span>)</li>
</ul>

<p>
These shader extensions provide a series of&nbsp; ballot-based partitioning and scan/reduce operations which operate on "subgroups" of shader invocations. This can be used for instance to implement clustering and de-duplication operations on sets of values distributed among different shader invocations.</p>
<br>
<h2>
Barycentric Coordinates and manual attributes interpolation</h2>
<ul>
<li><span><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_fragment_shader_barycentric" target="_blank">VK_NV_fragment_shader_barycentric</a> / <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_fragment_shader_barycentric.txt" target="_blank">GL_NV_fragment_shader_barycentric</a></span> (<span><a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/nv/GLSL_NV_fragment_shader_barycentric.txt" target="_blank">GLSL_NV_fragment_shader_barycentric</a> / <a href="http://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/master/extensions/NV/SPV_NV_fragment_shader_barycentric.html" target="_blank">SPV_NV_fragment_shader_barycentric</a></span>)</li>
</ul>


<p>
This feature exposes barycentric coordinates as Fragment Shader input in GLSL (and SPIR-V), and provides the ability for a Fragment Shader to directly fetch raw per-vertex values in order to perform manual barycentric interpolation.&nbsp;</p>
<p>
A three-component vector built-in input <span>gl_BaryCoordNV</span> provides 
perspective-corrected barycentric coordinates (<span>gl_BaryCoordNoPerspNV</span> for non- perspective-correct). Per-vertex inputs use the same brackets array syntax as for Tesselation and Geometry Shader inputs, and a <span>pervertexNV</span> qualifier is added to identify input blocs and variables which read raw per-vertex values from the vertices of the original primitive.</p>

<p>
This feature potentially allows more efficient data passing to the Fragment Shader using compact or compressed data formats for instance. It could also allow interpolation from vertex values fetched directly from memory, user defined interpolations, or various reconstructions and computations using raw attributes accessed from the three vertices.</p>
<br>
<h2>
Ptex Hardware Acceleration</h2>
<ul>
<li><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_corner_sampled_image" target="_blank"><span>VK_NV_corner_sampled_image</span></a></li>
</ul>
<p><a href="https://4.bp.blogspot.com/-6i9APiSKKJA/W6FPf0k25eI/AAAAAAAAGbo/eWGHk7n8aqwqUZVPsgLM_5A6nE1dIWdawCLcBGAs/s1600/ptex.png" imageanchor="1"><img data-original-height="893" data-original-width="966" height="184" src="https://4.bp.blogspot.com/-6i9APiSKKJA/W6FPf0k25eI/AAAAAAAAGbo/eWGHk7n8aqwqUZVPsgLM_5A6nE1dIWdawCLcBGAs/s200/ptex.png" width="200"></a></p>
<p>
An corner-sampled image has texels centered on integer coordinates instead of being halfway, which allows edge sampling coordinates to filter to the exact texels on the edge of the texture. This facilitates implementing Ptex (Per-face Texture [<a href="http://ptex.us/ptexpaper.html" target="_blank">Burley and Lacewell 2008</a>], cf. <a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/Borderless%20Ptex.pdf">https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/Borderless%20Ptex.pdf</a>) texturing in real-time applications by providing proper filtering and interpolation. Ptex uses separate textures for each face of a subdivision surface or polygon mesh, and sample locations are placed at pixel corners, maintaining continuity between adjacent patches by duplicating values along shared edges.</p>
</div>
<h2>
Representative Fragment Test</h2>
<ul>
<li><span><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_NV_representative_fragment_test" target="_blank">VK_NV_representative_fragment_test</a></span> / <a href="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_representative_fragment_test.txt" target="_blank"><span>GL_NV_representative_fragment_test</span></a></li>
</ul>
<div>
<p>
This extension has been designed to allow optimizing occlusion queries techniques which rely on per-fragment recording of visible primitives. It allows the hardware to stop generating fragments and stop emitting fragment shader invocations for a given primitive as long as a single fragment has passed early depth and stencil tests. This reduced subset of fragment shader invocation can then be used to record visible primitives in a more performant way. This is only a performance optimization, and no guarantee is given on the number of discarded fragments and consequently the number of fragment shader invocations that will actually be executed.</p></div><p>
A typical use case for this feature can be found in this occlusion culling sample code: <a href="https://github.com/nvpro-samples/gl_occlusion_culling">https://github.com/nvpro-samples/gl_occlusion_culling</a></p><h2>
Multi-View Rendering</h2>
<ul>
<li><span><a href="https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VK_KHR_multiview" target="_blank">VK_KHR_multiview</a> / <a href="https://www.khronos.org/registry/OpenGL/extensions/OVR/OVR_multiview.txt" target="_blank">GL_OVR_multiview</a></span></li>
</ul>
<p><a href="https://blogs.nvidia.com/wp-content/uploads/2018/08/20-vr-realism.png" imageanchor="1"><img data-original-height="450" data-original-width="800" height="112" src="https://blogs.nvidia.com/wp-content/uploads/2018/08/20-vr-realism.png" width="200"></a></p>
<p>
Pascal Simultaneous Multi-Projection (SMP) and stereo view features allowed broadcasting the same geometric data for rasterization to multiple views (up to 2) and viewports (up to 16) with very limited possibilities of per-view (and viewport) variations (an horizontal position offset per-view and xyz swizzle per-viewport + viewport attributes). Turing generalizes and improves over this feature by allowing to specify fully independent per-view attribute values (including vertex positions) and exposes up to 4 views. No new extension is provided, but the feature is exposed transparently as an optimization to the existing standardized Vulkan VK_KHR_multiview and OpenGL GL_OVR_multiview extensions.<br>
More info on Multi-View Rendering in this bog post: <a href="https://devblogs.nvidia.com/turing-multi-view-rendering-vrworks/">https://devblogs.nvidia.com/turing-multi-view-rendering-vrworks/</a> </p>
<br>


</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>