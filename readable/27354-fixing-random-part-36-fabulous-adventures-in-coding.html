<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Fixing Random, part 36 | Fabulous adventures in coding -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Fixing Random, part 36 | Fabulous adventures in coding</h1><div><div class="entry-content"><p>One more time! Suppose we have our nominal distribution <code>p</code> that possibly has “black swans” and our helper distribution <code>q</code>&nbsp;which has the same support, but no black swans.</p><p>We wish to compute the expected value of <code>f</code>&nbsp;when applied to samples from <code>p</code>, and we’ve seen that we can estimate it by computing the expected value of <code>g</code>:</p><p><code>x =&gt; f(x) * p.Weight(x) / q.Weight(x)</code></p><p>applied to samples of <code>q</code>.</p><p>Unfortunately, the last two times on FAIC we saw that&nbsp;<strong>the result will be wrong by a constant factor</strong>; the constant factor is the quotient of the normalization constants of <code>q</code>&nbsp;and <code>p</code>.</p><p>It seems like we’re stuck; it can be expensive or difficult to determine the normalization factor for an arbitrary distribution. We’ve created infrastructure for building weighted distributions and computing posteriors and all sorts of fun stuff, and none of it assumes that weights are normalized so that the area under the PDF is 1.0.</p><p>But… <strong>we don’t need to know the normalization factors</strong>. We never did, and every time I said we did, I lied to you. Because I am devious.</p><p>What do we really need to know?&nbsp;<strong>We need to know the quotient of two normalization constants.</strong>&nbsp;That is less information than knowing two normalization constants, and maybe there is a cheap way to compute that fraction.</p><p>Well, let’s play around with computing fractions of weights; our intuition is: <strong>maybe the quotient of the normalization constants is the average of the quotients of the weights.</strong> So let’s make a function and call it <code>h</code>:</p><p><code>x =&gt; p.Weight(x) / q.Weight(x)</code></p><p><em>What is the expected value of <code>h</code>&nbsp;when applied to samples drawn from <code>q</code>?</em></p><p>Well, we know that it could be computed by:</p><p><code>Area(x =&gt; h(x) * q.Weight(x)) / Area(q.Weight)</code></p><p>But do the algebra: that’s equal to</p><p><code>Area(p.Weight) / Area(q.Weight)</code></p><p>Which is the <em>inverse</em> of the quantity that we need, so we can just divide by it instead of multiplying!</p><p>Here’s our logic:</p><ul><li>We can estimate the expected value of <code>g</code>&nbsp;on samples of&nbsp;&nbsp;<code>q</code> by sampling.</li><li>We can estimate the expected value of <code>h</code>&nbsp;on samples of&nbsp;<code>q</code>&nbsp;by sampling.</li><li>The quotient of these two estimates is an estimate of the expected value of <code>f</code>&nbsp;on samples of&nbsp;<code>p</code>, <em>which is what we’ve been after this whole time.</em></li></ul><p>Whew!</p><hr><p><strong>Aside:</strong> I would be remiss if I did not point out that there is one additional restriction that we’ve got to put on helper distribution&nbsp;<code>q</code>&nbsp;: there must be no likely values of <code>x</code>&nbsp;in the support of <code>q</code>&nbsp;such that <code>q.Weight(x)</code>&nbsp;is tiny but <code>p.Weight(x)</code>&nbsp;is extremely large, because their quotient is then going to blow up huge if we happen to sample that value, and that’s going to wreck the average.</p><hr><p>We can now actually implement some code that computes expected values using importance sampling and no quadrature. Let’s put the whole thing together, finally: (All the code can be found <a href="https://github.com/ericlippert/probability/tree/episode36">here</a>.)</p><p><span><span>public</span><span>&nbsp;</span><span>static</span><span>&nbsp;</span><span>double</span><span>&nbsp;</span><span>ExpectedValueBySampling</span><span>&lt;</span><span>T</span><span>&gt;(</span><br><span>&nbsp; &nbsp;&nbsp;</span><span>this</span><span>&nbsp;</span><span>IDistribution</span><span>&lt;</span><span>T</span><span>&gt;</span><span>&nbsp;</span><span>d</span><span>,</span><br><span>&nbsp; &nbsp;&nbsp;</span><span>Func</span><span>&lt;</span><span>T</span><span>,</span><span>&nbsp;</span><span>double</span><span>&gt;</span><span>&nbsp;</span><span>f</span><span>,</span><br><span>&nbsp; &nbsp;&nbsp;</span><span>int</span><span>&nbsp;</span><span>samples</span><span>&nbsp;</span><span>=</span><span>&nbsp;</span><span>1000</span><span>)</span><span>&nbsp;</span><span>=&gt;</span><br><span>&nbsp;&nbsp;</span><span>d</span><span>.</span><span>Samples</span><span>()</span><span>.</span><span>Take</span><span>(</span><span>samples</span><span>)</span><span>.</span><span>Select</span><span>(</span><span>f</span><span>)</span><span>.</span><span>Average</span><span>();</span><br></span><span><span><br>public</span><span>&nbsp;</span><span>static</span><span>&nbsp;</span><span>double</span><span>&nbsp;</span><span>ExpectedValueByImportance</span><span>(</span><br><span>&nbsp; &nbsp;&nbsp;</span><span>this</span><span>&nbsp;</span><span>IWeightedDistribution</span><span>&lt;</span><span>double</span><span>&gt;</span><span>&nbsp;</span><span>p</span><span>,</span><br><span>&nbsp; &nbsp;&nbsp;</span><span>Func</span><span>&lt;</span><span>double</span><span>,</span><span>&nbsp;</span><span>double</span><span>&gt;</span><span>&nbsp;</span><span>f</span><span>,</span><br><span>&nbsp; &nbsp;&nbsp;</span><span>double</span><span>&nbsp;</span><span>qOverP</span><span>,</span><br><span>&nbsp; &nbsp;&nbsp;</span><span>IWeightedDistribution</span><span>&lt;</span><span>double</span><span>&gt;</span><span>&nbsp;</span><span>q</span><span>,</span><br><span>&nbsp; &nbsp;&nbsp;</span><span>int</span><span>&nbsp;</span><span>n</span><span>&nbsp;</span><span>=</span><span>&nbsp;</span><span>1000</span><span>)</span><span>&nbsp;</span><span>=&gt;</span><br><span>&nbsp; </span><span>qOverP</span><span>&nbsp;</span><span>*</span><span>&nbsp;</span><span>q</span><span>.</span><span>ExpectedValueBySampling</span><span>(<br></span><span>&nbsp; &nbsp; x</span><span>&nbsp;</span><span>=&gt;</span><span>&nbsp;</span><span>f</span><span>(</span><span>x</span><span>)</span><span>&nbsp;</span><span>*</span><span>&nbsp;</span><span>p</span><span>.</span><span>Weight</span><span>(</span><span>x</span><span>)</span><span>&nbsp;</span><span>/</span><span>&nbsp;</span><span>q</span><span>.</span><span>Weight</span><span>(</span><span>x</span><span>),</span><span>&nbsp;</span><span>n</span><span>);</span></span></p><p><span><span>public</span><span>&nbsp;</span><span>static</span><span>&nbsp;</span><span>double</span><span>&nbsp;</span><span>ExpectedValueByImportance</span><span>(</span><br><span>&nbsp; </span><span>this</span><span>&nbsp;</span><span>IWeightedDistribution</span><span>&lt;</span><span>double</span><span>&gt;</span><span>&nbsp;</span><span>p</span><span>,</span><br><span>&nbsp;&nbsp;</span><span>Func</span><span>&lt;</span><span>double</span><span>,</span><span>&nbsp;</span><span>double</span><span>&gt;</span><span>&nbsp;</span><span>f</span><span>,</span><br><span>&nbsp;&nbsp;</span><span>IWeightedDistribution</span><span>&lt;</span><span>double</span><span>&gt;</span><span>&nbsp;</span><span>q</span><span>,</span><br><span>&nbsp;&nbsp;</span><span>int</span><span>&nbsp;</span><span>n</span><span>&nbsp;</span><span>=</span><span>&nbsp;</span><span>1000</span><span>)</span><br><span>{</span><br><span>&nbsp; </span><span>var</span><span>&nbsp;</span><span>pOverQ</span><span>&nbsp;</span><span>=</span><span>&nbsp;</span><span>q</span><span>.</span><span>ExpectedValueBySampling</span><span>(<br></span><span>&nbsp; &nbsp; x</span><span>&nbsp;</span><span>=&gt;</span><span>&nbsp;</span><span>p</span><span>.</span><span>Weight</span><span>(</span><span>x</span><span>)</span><span>&nbsp;</span><span>/</span><span>&nbsp;</span><span>q</span><span>.</span><span>Weight</span><span>(</span><span>x</span><span>),</span><span>&nbsp;</span><span>n</span><span>);</span><br><span>&nbsp;&nbsp;</span><span>return</span><span>&nbsp;</span><span>p</span><span>.</span><span>ExpectedValueByImportance</span><span>(</span><span>f</span><span>,</span><span>&nbsp;</span><span>1.0</span><span>&nbsp;</span><span>/</span><span>&nbsp;</span><span>pOverQ</span><span>,</span><span>&nbsp;</span><span>q</span><span>,</span><span>&nbsp;</span><span>n</span><span>);</span><br><span>}</span></span></p><p>Look at that; the <em>signatures</em> of the methods are longer than the method bodies! Basically there’s only four lines of code here. Obviously I’m omitting error handling and parameter checking and all that stuff that would be necessary in a robust implementation, but the point is: even though it took me six math-heavy episodes to justify <em>why</em> this is the correct code to write, actually writing the code to solve this problem is very straightforward.</p><p>Once we have that code, we can use importance sampling and never have to do any quadrature, even if we do not give the ratio of the two normalization constants:</p><p><span><span>var</span><span>&nbsp;</span><span>p</span><span>&nbsp;</span><span>=</span><span>&nbsp;</span><span>Normal</span><span>.</span><span>Distribution</span><span>(</span><span>0.75</span><span>,</span><span>&nbsp;</span><span>0.09</span><span>);</span><br><span>double</span><span>&nbsp;</span><span>f</span><span>(</span><span>double</span><span>&nbsp;</span><span>x</span><span>)</span><span>&nbsp;</span><span>=&gt;</span><span>&nbsp;</span><span>Atan</span><span>(</span><span>1000</span><span>&nbsp;</span><span>*</span><span>&nbsp;</span><span>(</span><span>x</span><span>&nbsp;</span><span>–</span><span>&nbsp;</span><span>.45</span><span>))</span><span>&nbsp;</span><span>*</span><span>&nbsp;</span><span>20</span><span>&nbsp;</span><span>–</span><span>&nbsp;</span><span>31.2</span><span>;</span><br><span>var</span><span>&nbsp;</span><span>u</span><span>&nbsp;</span><span>=</span><span>&nbsp;</span><span>StandardContinuousUniform</span><span>.</span><span>Distribution</span><span>;</span><br><span><span>var</span>&nbsp;expected = p</span><span>.</span><span>ExpectedValueByImportance</span><span>(</span><span>f</span><span>,</span><span>&nbsp;</span><span>u</span><span>);</span></span></p><p><strong>Summing up:</strong></p><ul><li>If we have two distributions <code>p</code>&nbsp;and <code>q</code>&nbsp;with the same support…</li><li>and a function <code>f</code>&nbsp;that we would like to evaluate on samples of <code>p</code>…</li><li>and we want to estimate the average value of <code>f</code>&nbsp;…</li><li>but <code>p</code>&nbsp;has “black swans” and <code>q</code>&nbsp;does not, then:</li><li>we can still efficiently get an estimate by sampling <code>q</code></li><li>bonus: we can compute an estimate of the ratios of the normalization constants of <code>p</code>&nbsp;and <code>q</code></li><li>extra bonus: if we already know one of the normalization constants, we can compute an estimate of the other from the ratio.</li></ul><p>Super; are we done?</p><p>In the last two episodes we pointed out that there are two problems: we don’t know the correction factor, and we don’t know how to pick a good <code>q</code>. We’ve only solved the first of those problems.</p><hr><p><strong>Next time on FAIC:</strong>&nbsp;We’ll dig into the problem of finding a good helper distribution <code>q</code>.</p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><h3 class="jp-relatedposts-headline"><em>Related</em></h3></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>