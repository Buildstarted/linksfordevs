<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Mechanized Proofs for PL: Past, Present, and Future - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Mechanized Proofs for PL: Past, Present, and Future - linksfor.dev(s)"/>
    <meta property="article:author" content="Talia Ringer on Jan 29, 2020"/>
    <meta property="og:description" content="The history of machine-checked proofs about programming languages offers valuable lessons for the future of programming languages research."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Mechanized Proofs for PL: Past, Present, and Future</title>
<div class="readable">
        <h1>Mechanized Proofs for PL: Past, Present, and Future</h1>
            <div>by Talia Ringer on Jan 29, 2020</div>
            <div>Reading time: 10-13 minutes</div>
        <div>Posted here: 21 Feb 2020</div>
        <p><a href="https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future/">https://blog.sigplan.org/2020/01/29/mechanized-proofs-for-pl-past-present-and-future/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
					<p>Last week, I had the pleasure of organizing the <a href="https://popl20.sigplan.org/track/POPL-2020-poplmark-15-year-retrospective-panel">POPLmark 15 Year Retrospective Panel</a>, which looked back on the <a href="https://www.seas.upenn.edu/~plclub/poplmark/">POPLmark Challenge</a> 15 years later. The POPLmark Challenge was a problem set and benchmark suite that rallied researchers to understand and push the limits of the technologies that made it possible to write mechanized (machine-checked) proofs about programming languages. The hope was to make it feasible for the programming languages (PL) community to shelve tedious and error-prone handwritten proofs about programming languages in favor of those mechanized proofs.</p>
<p>I was not involved in the original challenge, but I grew interested in it while writing a <a href="https://proofengineering.org/">survey paper</a> about mechanized proofs. The challenge had garnered <a href="https://scholar.google.com/scholar?um=1&amp;ie=UTF-8&amp;lr&amp;cites=14838110329858203726">hundreds of citations</a>—so clearly it was influential—but after talking to those involved, I still couldn’t answer what I’d thought was a simple question:</p>
<blockquote><p><b>Was the POPLmark Challenge successful?</b></p></blockquote>
<p>Today I’d say yes: The POPLmark Challenge helped stir lasting excitement about mechanized proofs within the PL community. Beyond that, it intentionally brought the PL community together with those developing technologies for writing mechanized proofs.</p>
<p>Despite the advances and successes, there is a lot more to do. We still don’t really understand the limits of these technologies, and we still have much to learn about how to use them best. And we have focused somewhat excessively on certain challenges and technologies, sometimes to the exclusion of others.</p>
<p>In this post, I reflect on the state of affairs of mechanized proof in PL, organized around the topics and discussions that arose in the panel.</p>

<p>To benefit from the POPLmark challenge, we need to take a step back and look at exactly what happened. Then we need to take what we learn from that and apply it to address the problems that matter today. The purpose of the panel was to amplify this process.</p>
<p>The panel featured a mix of POPLmark authors and participants, as well as experts in the problems in mechanized proofs about programming languages that resonate today. About 90 people showed up to watch and ask questions. Check it out here:</p>
<div><p><iframe title="POPLmark 15 Year Retrospective Panel" src="https://www.youtube.com/embed/2M2ZWNzpzkE?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" id="fitvid0"></iframe></p></div>
<p>Moving forward, here is just a sample of what we can learn (with links to the relevant spots in the panel video).</p>
<h2>POPLmark sparked excitement about mechanized proofs and helped bring two communities together.</h2>
<p>In his <a href="https://youtu.be/2M2ZWNzpzkE?t=57">opening talk</a>, Benjamin Pierce sketched out the world in 2004: Two islands, one with PL and systems people, and one with formal verification people. There were many people standing on each island, but only a few people swimming between them:</p>
<p><img src="https://blog.sigplan.org/wp-content/uploads/2020/01/Screenshot_2020-01-24-POPLmark-15-Year-Retrospective-Panel-YouTube-300x169.png" alt="" width="300" height="169"></p>
<p>This came as a surprise to many of us junior researchers in the audience, since we had only ever known a world with boats and bridges between those islands:</p>
<p><img src="https://blog.sigplan.org/wp-content/uploads/2020/01/unnamed-300x169.png" alt="" width="300" height="169"></p>
<p>The numbers we have for POPL tell some of this story: The proportion of papers accepted to <a href="https://popl20.sigplan.org/">POPL</a> that we found with partial or complete mechanizations was 16 out of 66 (24%) in 2018, 19 out of 76 (25%) in 2019, and 17 / 68 (25%) in 2020. These proportions are up a bit from <a href="https://www.cl.cam.ac.uk/~pes20/popl2014-pc-chair-report.pdf">7 out of 36 (19%) in 2009, and 10 out of 51 (20%) in 2014</a>. Conferences for mechanized proofs like <a href="https://popl20.sigplan.org/home/CPP-2020">CPP</a> (colocated with POPL) have also <a href="https://www.youtube.com/watch?v=IfhHdZef9T0&amp;feature=youtu.be">grown</a>, and it’s not unusual to see mechanized proofs in systems and security conferences, too. Almost everyone who attended the panel had used a proof assistant (a tool for writing and checking mechanized proofs) at some point.</p>
<p>Sparking excitement about mechanized proofs and bringing these two communities closer were some of the stated goals of POPLmark, and they have largely come to fruition. Of course, it’s hard to know how much of this was thanks to POPLmark: some of those people already swimming between the two communities undoubtedly helped! For example, well before POPLmark in 1987, Bob Harper, Furio Honsell, and Gordon Plotkin introduced <a href="http://homepages.inf.ed.ac.uk/gdp/publications/Framework_Def_Log.pdf">LF</a>, a framework for defining logical systems. LF played a <a href="https://www.nowpublishers.com/article/Details/PGL-045">central role</a> in the history of mechanized proofs for PL. The LF implementation <a href="https://www.cs.cmu.edu/~fp/papers/cade99.pdf">Twelf</a> by Frank Pfenning and Carsten Schürmann made it possible to express the kinds of PL proofs that were common at the time. Using Twelf, Michael Ashley-Rollman, Karl Crary, and Bob Harper submitted the first <a href="https://www.seas.upenn.edu/~plclub/poplmark/cmu-twelf.tar.gz">solution</a> to the POPLmark challenge. Karl Crary and Bob Harper later used Twelf to write <a href="https://github.com/SMLFamily/The-Mechanization-of-Standard-ML">a full mechanized proof</a> of the type safety of the language Standard ML.</p>
<p>Beyond LF, large proof engineering efforts like panelist Xavier Leroy’s work on <a href="http://compcert.inria.fr/">CompCert</a> <a href="https://www.sigplan.org/Awards/POPL/">helped convince the community</a> that mechanized proofs at scale were possible. Many more of these large proof developments followed, including panelist Scott Owens’ and others’ work on <a href="https://cakeml.org/publications.html">CakeML</a>.</p>
<p>But anecdotes from the panelists do suggest that POPLmark played a role. For example, even though CompCert was underway before POPLmark, <a href="https://youtu.be/2M2ZWNzpzkE?t=1113">Xavier Leroy found POPLmark&nbsp; inspiring</a>. Benjamin Pierce noted that the interest around and results of POPLmark were central motivations for writing <a href="https://softwarefoundations.cis.upenn.edu/">Software Foundations</a>, his widely used series of books on programming languages with mechanized proofs in Coq.</p>
<p>It’s <a href="https://youtu.be/2M2ZWNzpzkE?t=4261">not unusual</a> for benchmarks to have this effect. So, if there are other communities we’d like to bring together (<a href="https://youtu.be/2M2ZWNzpzkE?t=4747">mechanized proofs and testing</a>, perhaps), or technologies we’d like to see more excitement about, a challenge and benchmark suite may be a good way to accomplish this. Important things to consider are choosing a problem of the <a href="https://youtu.be/2M2ZWNzpzkE?t=1005">appropriate size and difficulty</a>, and carefully considering the <a href="https://youtu.be/2M2ZWNzpzkE?t=2141">timing</a> of the challenge and benchmark suite.</p>
<h2>The excitement POPLmark spurred was perhaps too narrow.</h2>
<p>POPLmark deliberately carved out a challenge that was timely and small enough not to deter participation. The PL community in turn responded with 15 years of work that was <a href="https://youtu.be/2M2ZWNzpzkE?t=822">disproportionately</a> focused on one important challenge of mechanized proofs about programming languages, perhaps to the exclusion of other important challenges. For example, even though POPLmark called for the community to connect their proofs to language implementations, there was <a href="https://youtu.be/2M2ZWNzpzkE?t=1039">little emphasis on this from most of the community</a>.&nbsp;The community also mostly flocked to a particular tool for writing these proofs: <a href="https://coq.inria.fr/">Coq</a>. Perhaps this came <a href="https://youtu.be/2M2ZWNzpzkE?t=1088">at the expense</a> of other excellent tools like <a href="https://isabelle.in.tum.de/">Isabelle</a>, <a href="https://hol-theorem-prover.org/">HOL</a>, and <a href="http://twelf.org/wiki/Main_Page">Twelf</a>.</p>
<p>When we design benchmark suites and challenges, we should consider and try to prevent overly narrow focus (of course, this may come at the cost of choosing a problem of the appropriate size). For example, we should make sure that there is adequate representation of different technologies among those who design and evaluate benchmark suites and challenges about those technologies. And as researchers and as educators, we should broaden our focus. Focusing more on connecting our proofs to real languages could mean not just more confidence in our languages, but also more <a href="https://youtu.be/2M2ZWNzpzkE?t=1301">confidence in our papers</a>, and <a href="https://youtu.be/2M2ZWNzpzkE?t=1994">better communication of our ideas</a>. Broadening our dialogue to capture different tools could mean more productive use of the diverse tools that are available to us that have <a href="https://youtu.be/2M2ZWNzpzkE?t=2353">continued to evolve independently of POPLmark</a>.</p>
<h2>It’s time to address the problems that matter today.</h2>
<p>Connecting our proofs to real languages is just one problem we still need to think about. When it comes to reasoning about programming languages, we could use more progress on dealing with <a href="https://youtu.be/2M2ZWNzpzkE?t=1556">state and concurrency</a>. When it comes to mechanized proofs more broadly, we could always use more work on <a href="https://youtu.be/2M2ZWNzpzkE?t=2625">proof reuse</a>, <a href="https://youtu.be/2M2ZWNzpzkE?t=3136">interoperability</a>, and the <a href="https://youtu.be/2M2ZWNzpzkE?t=1715">challenges of scale</a>.</p>
<p>There are many people who are <a href="https://www.nowpublishers.com/article/Details/PGL-045">currently working on these challenges</a>. It’s fantastic that the community is focused on many of the challenges that matter today. They are especially important when it comes to writing mechanized proofs of large and complex systems. Both industrial and academic users are under time and financial constraints that make reuse and productivity particularly salient. For large and complex systems, it may make sense to have strong guarantees about only some parts of those systems, making mixed methods with good interoperability a tempting choice. We should continue down these paths.</p>
<p>And if we want to continue down these paths, <a href="https://youtu.be/2M2ZWNzpzkE?t=4141">maybe</a> <a href="https://youtu.be/2M2ZWNzpzkE?t=4195">now is the right time</a> for a benchmark suite or challenge in one of those areas—as long as we take the design considerations of scope, size, difficulty, timing, and community response that we’ve learned from POPLmark into account.</p>
<h2>There’s a lot we still don’t know about how to evaluate success.</h2>
<p>Of course, designing a good benchmark suite or challenge means evaluating success, and that’s difficult. The job of POPLmark was, in a sense, <a href="https://youtu.be/2M2ZWNzpzkE?t=2148">a bit easier than the job that’s ahead of us</a>: it showed that mechanized proofs about programming languages were possible and gave us examples of how to use different techniques, but it did little to measure the relative success of those techniques. Measuring success is <a href="https://youtu.be/2M2ZWNzpzkE?t=1790">especially difficult</a> when it comes to technologies that address the challenges of proofs about large-scale systems. It’s not clear how we can replicate the challenges of scale in a controlled and confined environment, though perhaps we can design a challenge around, for example, <a href="https://youtu.be/2M2ZWNzpzkE?t=1920">proofs that are robust in the face of change</a>.</p>
<p>In some ways, this is symptomatic of the fact that we <a href="https://youtu.be/2M2ZWNzpzkE?t=2795">still have a lot to learn</a> about evaluating programming languages and the tools and techniques around them more generally. Considering POPLmark in the broader scope of PL research, perhaps the biggest takeaway from my end is that it’s time to tackle this problem.</p>
<p><strong>Bio:</strong><em> <a href="https://tlringer.github.io/">Talia Ringer</a> is Ph.D. student in the Paul G. Allen School of Computer Science &amp; Engineering at the University of Washington in the <a href="http://uwplse.org/">PLSE lab</a>, specializing in <a href="https://proofengineering.org/">proof engineering</a>. She is an NSF GRFP fellow and a contributor to the Coq interactive theorem prover, and is active in advising, mentorship, service, and outreach.&nbsp;</em></p>
<p><strong>Acknowledgments: </strong><em>Thanks to Tej Chajed for the numbers about 2020 POPL artifacts. Thanks to the moderator Mike Hicks and the panelists Benjamin Pierce, Peter Sewell, Xavier Leroy, Robby Findler, Brigitte Pientka, and Scott Owens for the wonderful comments throughout the panel. Thanks to the other organizers Benjamin Pierce, Peter Sewell, Dan Grossman, and Stephanie Weirich and the moderator Mike Hicks for all of the help along the way and for feedback on this post. Thanks to the audience for all of the wonderful questions. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author and do not necessarily reflect the views of the National Science Foundation.</em></p>
<p><em><strong>Edit</strong>: Thanks to Robert Harper for pointing out that the CMU team proved the type safety, not the correctness, of Standard ML.</em></p>
<p><strong>Disclaimer:</strong> <em>These posts are written by individual contributors to share their thoughts on the SIGPLAN blog for the benefit of the community. Any views or opinions represented in this blog are personal, belong solely to the blog author and do not represent those of ACM SIGPLAN or its parent organization, ACM.</em></p>
					</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>