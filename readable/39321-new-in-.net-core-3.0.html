<!DOCTYPE html>
<html lang="en">
<head>
    <title>
New in .NET Core 3.0 -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>New in .NET Core 3.0</h1>
    <div class="post-content">
<p>In this post I explore the new local tools feature introduced in .NET Core 3.0. I show how to install and run local tools using the dotnet-tools manifest, describe how to work with multiple manifests, and describe how the tools are installed.</p> <p>.NET Core 2.1 introduced the concept of <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools">global tools</a> that are CLI tools (console apps really) that you can install using the .NET Core SDK. These tools are available globally on your machine, so can be used for a wide variety of things. </p>
<p>I&apos;ve <a href="https://andrewlock.net/how-to-build-with-cake-on-linux-using-cake-coreclr-or-the-cake-global-tool/">recently migrated to using the Cake global tool</a> for new builds, by installing the global tool into the project folder using the <code>tools-path</code> option, and running the tools from there. Installing into the project folder in this way means you can use a different version of the global tool for each project, rather than being forced to update all your tools at once. </p>
<p>However this &quot;local&quot; use of <em>global</em> tools always felt a bit clumsy, and in .NET Core 3.0 we now have explicit support for &quot;project-specific&quot; <em>local</em> tools. <a href="https://twitter.com/stuartblang">Stuart Lang</a> wrote a <a href="https://stu.dev/dotnet-core-3-local-tools/">nice introductory post on the feature here</a>. This post is very similar, but with a couple of extra details.&#x1F642;</p> <p>In .NET Core 3.0 you can now specify global tools that are required for a specific project by creating a <em>dotnet-tools manifest</em>. This is a JSON file which lives in your repository and is checked-in to source control. You can create a new tool-manifest by running the following in the root of your repository:</p>
<pre class="language-bash"><code class="language-bash">dotnet new tool-manifest
</code></pre>
<p>By default, this creates the following manifest JSON file <em>dotnet-tools.json</em> inside the <em>.config</em> folder of your repository:</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span> <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token property">&quot;isRoot&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token property">&quot;tools&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The initial manifest doesn&apos;t include any tools, but you can install new ones by running <code>dotnet tool install</code> (i.e. without the <code>-g</code> or <code>--tool-path</code> flag required in .NET Core 2.x). So you can require the Cake global tool for your project by running: </p>
<pre class="language-bash"><code class="language-bash"><span class="token operator">&gt;</span> dotnet tool <span class="token function">install</span> Cake.Tool You can invoke the tool from this directory using the following commands: <span class="token string">&apos;dotnet tool run dotnet-cake&apos;</span> or <span class="token string">&apos;dotnet dotnet-cake&apos;</span><span class="token keyword">.</span>
Tool <span class="token string">&apos;cake.tool&apos;</span> <span class="token punctuation">(</span>version <span class="token string">&apos;0.35.0&apos;</span><span class="token punctuation">)</span> was successfully installed. Entry is added to the manifest <span class="token function">file</span> C:\repos\test\.config\dotnet-tools.json.
</code></pre>
<p>This updates the manifest by adding the <code>cake.tool</code> reference to the <code>tools</code> section, including the version required (the current latest version - you can update the version manually as required), and the command you need to run to execute the tool (<code>dotnet-cake</code>):</p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span> <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token property">&quot;isRoot&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token property">&quot;tools&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">&quot;cake.tool&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;0.35.0&quot;</span><span class="token punctuation">,</span> <span class="token property">&quot;commands&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;dotnet-cake&quot;</span> <span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>When a colleague clones the repository and wants to run the Cake tool, they can run the following commands to first restore the tool, and then run it: </p>
<pre class="language-bash"><code class="language-bash">
dotnet tool restore

dotnet tool run dotnet-cake --version

dotnet dotnet-cake --version

dotnet cake --version
</code></pre>
<p>For build tools like Cake, where you might want or need to have different versions installed for different projects, the .NET Core 3 local tools are great. The &quot;global tools with local tool-path&quot; approach I showed <a href="/how-to-build-with-cake-on-linux-using-cake-coreclr-or-the-cake-global-tool/#building-on-linux-with-the-cake-global-tool">in my earlier post </a> was OK, but you had to do some manual work to ensure the correct version was installed. That all gets simpler with .NET Core 3, as I&apos;ll show in a later post.</p> <p>In this section, I&apos;ll dig into a couple of questions I had after giving local tools a try. Namely, where are local tools installed, what are the other properties in the manifest file, and can I put the manifest file somewhere else?</p>
<blockquote>
<p>At the time of writing, there&apos;s no official documentation for .NET Core local tools, so most of the information below is from <a href="https://github.com/dotnet/cli/issues/10288">this issue</a>, plus my experimentation!</p>
</blockquote> <p>When you create a new manifest using <code>dotnet new tool-manifest</code> you get a JSON file like the following: </p>
<pre class="language-json"><code class="language-json"><span class="token punctuation">{</span> <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token property">&quot;isRoot&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token property">&quot;tools&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>The <code>version</code> property is specifying the version of the <em>dotnet-tools</em> schema. It&apos;s not the <em>file</em> version, it&apos;s the <em>schema</em> version, so you&apos;ll need to leave that it set to <code>1</code>. Later versions of the .NET Core SDK may update the schema to add extra/different functionality, and the version number can be used to determine which version of the schema to use.</p>
<p>The <code>isRoot</code> property is related to how the <code>dotnet tool</code> command searches for manifests. I&apos;ll get to the details of that shortly, but in summary, <code>isRoot</code> means &quot;stop searching, I&apos;m what you&apos;re looking for&quot;. It is the &quot;root&quot; manifest, i.e. the top-level manifest.</p> <p>The <code>dotnet tool</code> command checks in a number of locations when looking for a <em>dotnet-tools.json</em> manifest:</p>
<ol>
<li>The <em>.config</em> folder in the current directory (<code>./.config/dotnet-tools.json</code>)</li>
<li>In the current directory (<code>./dotnet-tools.json</code>)</li>
<li>In the parent directory (<code>../dotnet-tools.json</code>)</li>
<li>In each parent directory until you reach the root</li>
</ol>
<p>As soon as it finds a <em>dotnet-tools.json</em> manifest for which <code>isRoot</code> is <code>true</code>, it stops searching. The local tools available are all those listed in the root manifest, plus all those listed in manifests found while searching for the root. </p>
<p>You can view the local tools available in a given folder by running <code>dotnet tool list</code>. </p>
<p>For example, imagine you have a non-root manifest in the <em>.config</em> folder that requires the Cake global tool. You also have a non-root manifest in the current directory that installs the <code>dotnetsay</code> global tool, and a root manifest in the parent directory that installs the <code>dotnet-tinify</code> tool. Running <code>dotnet tool list</code> shows that all three of these tools are available:</p>
<pre class="language-bash"><code class="language-bash">Package Id         Version      Commands           Manifest
-----------------------------------------------------------------------------------------------------
cake.tool          0.35.0       dotnet-cake        C:\repos\test\.config\dotnet-tools.json
dotnetsay          2.1.4        dotnetsay          C:\repos\test\dotnet-tools.json
dotnet-tinify      0.2.0        dotnet-tinify      C:\repos\dotnet-tools.json
</code></pre>
<p>Precedence is obviously important here for knowing when to stop searching (due to <code>isRoot</code>), but it also handles the case where different versions of a tool are defined in more than one manifest. In that case, the first manifest found wins. So if version <code>1.0.0</code> of the <code>dotnetsay</code> tools was in the <em>.config</em> folder manifest, then <code>dotnet tool list</code> would output the following:</p>
<pre class="language-bash"><code class="language-bash">Package Id         Version      Commands           Manifest
-----------------------------------------------------------------------------------------------------
cake.tool          0.35.0       dotnet-cake        C:\repos\test\.config\dotnet-tools.json
dotnetsay          1.0.0        dotnetsay          C:\repos\test\.config\dotnet-tools.json
dotnet-tinify      0.2.0        dotnet-tinify      C:\repos\dotnet-tools.json
</code></pre>
<p>Note the <code>Version</code> and the <code>Manifest</code> for the <code>dotnetsay</code> command compared to the previous table.</p>
<p>Of course, you shouldn&apos;t really ever have to care about these details. The whole point of local tools is that they&apos;re <em>local</em>, checked in with your source control, and don&apos;t rely on things already existing (e.g. manifests in parent folders). I strongly suggest using only a single manifest, ensuring <code>isRoot</code> is <code>true</code>, and placing it either in the <em>.config</em> folder or the root of your project.</p> <p>The <a href="https://github.com/dotnet/cli/issues/10288#issuecomment-483449922">short answer</a> is they&apos;re installed in the <a href="https://docs.microsoft.com/en-us/nuget/consume-packages/managing-the-global-packages-and-cache-folders">global NuGet package folder</a>. .NET Core global/local tools are just console apps distributed as special NuGet packages. So they&apos;re downloaded to the global folder and unpacked as though they&apos;re normal NuGet packages. If you install the same version of a tool in multiple manifests, only a single copy of the NuGet package is installed.</p>
<p>When you run a global tool, it runs the app from the NuGet package. So if you install the <a href="https://github.com/natemcmaster/dotnet-serve">dotnet-serve</a> global tool for example:</p>
<pre class="language-bash"><code class="language-bash">dotnet tool <span class="token function">install</span> dotnet-serve
</code></pre>
<p>and then run it:</p>
<pre class="language-bash"><code class="language-bash">dotnet tool run dotnet-serve

dotnet dotnet-serve

dotnet serve
</code></pre>
<p>then looking in process explorer you can see the tool is being run directly from the <em>~/.nuget/packages</em> folder for the installed version of the tool (1.4.1 in this case)</p>
<p><img src="/content/images/2019/dotnet_local_tool.png" alt="The Windows process explorer when running &apos;dotnet tool run dotnet-serve&apos;"></p>
<p>Given the tools run from the shared NuGet cache, uninstalling a tool from a manifest (using <code>dotnet tool uninstall &lt;toolname&gt;</code> simply removes the entry from the <em>dotnet-tools.json</em> manifest. The NuGet package remains cached, and so can still be used by other apps. If you completely want to remove the tool from your system, you&apos;ll need to <a href="https://docs.microsoft.com/en-us/nuget/consume-packages/managing-the-global-packages-and-cache-folders">clear your NuGet cache</a>.</p> <p>In this post I described the new local tools feature introduced in .NET Core 3.0. This feature allows you to include a <em>manifest</em> in your project that lists the .NET Core CLI tools it requires. This allows you to have different tools (and different <em>versions</em> of tools) for different projects. I showed how to install and run local tools, explained the format of the manifest file, and how multiple manifest files can be used if necessary. Finally I described how local tools work, by running the tools from the global NuGet package cache.</p>
</div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>