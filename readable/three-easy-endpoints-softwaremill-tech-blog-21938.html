<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Three easy endpoints - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Three easy endpoints - linksfor.dev(s)"/>
    <meta property="article:author" content="Adam Warski"/>
    <meta property="og:description" content="tapir is a library for describing HTTP endpoints. It combines Scala&#x2019;s typesafety, with the declarative style and introspection&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.softwaremill.com/three-easy-endpoints-a6cbd52b0a6e"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Three easy endpoints</title>
<div class="readable">
        <h1>Three easy endpoints</h1>
            <div>by Adam Warski</div>
            <div>Reading time: 15-19 minutes</div>
        <div>Posted here: 10 May 2019</div>
        <p><a href="https://blog.softwaremill.com/three-easy-endpoints-a6cbd52b0a6e">https://blog.softwaremill.com/three-easy-endpoints-a6cbd52b0a6e</a></p>
        <hr/>
<div id="readability-page-1" class="page"><section><div><div><div><div><div><div><p><a href="https://blog.softwaremill.com/@adamwarski?source=post_page-----a6cbd52b0a6e----------------------" rel="noopener"><img alt="Adam Warski" src="https://miro.medium.com/fit/c/96/96/1*ibvO_EVklp97exBsutE5yQ.jpeg" width="48" height="48"></a></p></div></div></div></div><p id="c79c" data-selectable-paragraph=""><a href="https://github.com/softwaremill/tapir" target="_blank" rel="noopener">tapir</a> is a library for describing HTTP endpoints. It combines Scala’s <strong>typesafety</strong>, with the <strong>declarative</strong> style and <strong>introspection</strong> capabilities known from Java annotation-based frameworks, such as <a href="https://spring.io/" target="_blank" rel="noopener">Spring</a> or <a href="https://jersey.github.io/" target="_blank" rel="noopener">JAX-RS</a>.</p><p id="9ac5" data-selectable-paragraph="">By leveraging Scala’s flexibility and functional programming features, tapir relies only on Scala (no code generation or external DSLs) and is based on <strong>simple, immutable</strong> data structures. This is, in contrast to annotations, which are an <a target="_blank" rel="noopener" href="https://blog.softwaremill.com/the-case-against-annotations-4b2fb170ed67">interpreted, not-typesafe, non-composable mini-language</a> embedded into Java.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*l7hpNfeNroHXwiJ_N6A_8g.png?q=20" width="2224" height="1668" role="presentation"></p><p><img width="2224" height="1668" role="presentation" src="https://miro.medium.com/max/2224/1*l7hpNfeNroHXwiJ_N6A_8g.png"></p></div></div></div></div><figcaption data-selectable-paragraph="">tapir sticker by <a href="https://twitter.com/ImpurePics" target="_blank" rel="noopener">ImpurePics</a></figcaption></figure><p id="38c9" data-selectable-paragraph="">At the same time, being a Scala library, the main goal of tapir is to be <strong>programmer friendly</strong>:</p><ul><li id="8cfc" data-selectable-paragraph="">result in code <strong>readable</strong> also by people not familiar with the library</li><li id="229e" data-selectable-paragraph="">provide <strong>discoverable</strong> API through standard auto-complete</li><li id="6bc0" data-selectable-paragraph="">use <strong>human-comprehensible</strong> types, which you are not afraid to write down</li><li id="ba44" data-selectable-paragraph=""><strong>separate</strong> “business logic” from endpoint definition &amp; documentation</li><li id="5fef" data-selectable-paragraph="">be reasonably <strong>type safe</strong></li></ul><p id="41fe" data-selectable-paragraph="">A tapir endpoint — which is only a <strong>description</strong> — can be interpreted as a server, client or documentation. tapir doesn’t include its own HTTP server or client. Instead, it leverages one of the existing implementations:</p><ul><li id="6256" data-selectable-paragraph=""><a href="https://doc.akka.io/docs/akka-http/current/index.html" target="_blank" rel="noopener">Akka HTTP</a> or <a href="https://http4s.org/" target="_blank" rel="noopener">http4s</a> for server</li><li id="e166" data-selectable-paragraph="">Akka HTTP, async-http-client or OkHttp for client (through <a href="https://github.com/softwaremill/sttp" target="_blank" rel="noopener">sttp</a>)</li><li id="9d28" data-selectable-paragraph=""><a href="https://swagger.io/specification/" target="_blank" rel="noopener">OpenAPI</a> (Swagger) for documentation.</li></ul><p id="7e89" data-selectable-paragraph="">But, how do endpoint definitions look in practice? Let’s find out, exploring <strong>three endpoints</strong>:</p><ol><li id="76c6" data-selectable-paragraph=""><em>getting a list of entities as json</em></li><li id="95e1" data-selectable-paragraph=""><em>streaming data</em></li><li id="2147" data-selectable-paragraph=""><em>submitting multipart forms with text and binary parts</em></li></ol><p id="576b" data-selectable-paragraph="">Making a deep dive, below you’ll find the endpoints described using tapir’s API, as plain Scala values. Without knowing the library (yet!):</p><ul><li id="5c9b" data-selectable-paragraph="">do you suspect how the endpoints are <strong>intended</strong> to be used?</li><li id="31cf" data-selectable-paragraph="">do the types give a hint on what kind of information each endpoint <strong>consumes and produces</strong>?</li><li id="36d7" data-selectable-paragraph="">is the code <strong>readable</strong>, are the intentions of the writer of the code clearly communicated?</li><li id="3998" data-selectable-paragraph="">how does it compare to the meta-data that is expressible via Java <strong>annotations</strong>?</li></ul><figure><div></div></figure><p id="ca75" data-selectable-paragraph="">In the subsequent sections, we’ll go through the code of each endpoint. Together with the first one, we’ll make a crash-course of tapir’s API. If you’d rather prefer to see how to interpret the endpoint as a server or documentation, you can safely skim most of the next section.</p><p id="7157" data-selectable-paragraph="">If you’d like to read and explore code at the same time, all of the code covered is <a href="https://github.com/adamw/tapir-three" target="_blank" rel="noopener">available on GitHub</a>.</p><p id="29c9" data-selectable-paragraph="">Our running example will revolve around books. Each book will have an id, a title, author, year in which it was published and an optional cover image. The first endpoint will allow retrieving a list of books in the system, optionally filtered by publishing year, and optionally limited to a given number of results.</p><p id="8cec" data-selectable-paragraph="">Here’s the model which we’ll be using:</p><figure><div></div></figure><p id="6d5d" data-selectable-paragraph="">The endpoint that we’d like to describe is:</p><pre><span id="e6c8" data-selectable-paragraph="">GET /api/v1.0/books?year=...&amp;limit=...</span></pre><p id="faaf" data-selectable-paragraph="">where <code>year</code> and <code>limit</code> are optional parameters, the first one being mapped to the <code>Year</code> value class, the second represented as an integer. The result should be a JSON representation of a <code>List[Book]</code>. Additionally, our API should signal any errors as JSON as well (e.g. when the given limit is negative), corresponding to the <code>ErrorInfo</code> case class.</p><p id="a3f7" data-selectable-paragraph="">How to describe such an endpoint? Remember that at this point we only want to <strong>capture the structure</strong>. We’ll start with an empty endpoint, and gradually refine our description. After each step, we’ll obtain a <strong>new, immutable description</strong> of a (partial) endpoint.</p><p id="6d0a" data-selectable-paragraph="">We’ll start by adding support for a non-standard type that we’ll want to map to in the query: <code>Year</code>. In tapir, custom types are supported by creating a <code>Codec</code>, which defines a bi-directional mapping between a raw type and the custom type:</p><figure><div></div></figure><p id="746f" data-selectable-paragraph="">Next, we’ll define the endpoint itself:</p><figure><div></div></figure><p id="591b" data-selectable-paragraph="">Each endpoint consists of inputs, error-outputs and outputs. The distinction between error and normal outputs is due to the fact that usually an API has different responses in both cases — and that’s supported as a first-class construct.</p><p id="5b66" data-selectable-paragraph="">The first input (defined using the <code>.in</code> method) specifies the path of the endpoint: <code>.in("api" / "v1.0" / "books")</code>. This path is constant, and doesn’t map to any values in the HTTP request. The second and third inputs map to query parameter values in the URL: <code>query[Option[Year]]("year")</code> and <code>query[Option[Int]]("limit")</code>. Note that optional values are simply expressed using Scala’s <code>Option</code>s.</p><p id="27d1" data-selectable-paragraph="">When there’s an error, the body will be a JSON mapping to the <code>ErrorInfo</code> class. By default, error-responses map to the <code>400 Bad Request</code> status code, and successful responses map to the <code>200 OK</code> status code. However, depending on the exact error being returned, we’d like to use varying status codes. Hence, we additionally use the <code>statusCode</code> output, which maps to an <code>Int</code> in the response; we do that only for errors, the success case will continue using the default status code.</p><p id="88dc" data-selectable-paragraph="">Finally, using the <code>.out</code> method, we specify that upon success, the body should be a json, mapping to a <code>List[Book]</code>.</p><blockquote><p id="d6a1" data-selectable-paragraph="">Inputs can be specified in any order, as well as interleaved with outputs. It is just for reading convenience that they are grouped here.</p></blockquote><h2 id="864c" data-selectable-paragraph="">Inputs/outputs</h2><p id="3fd5" data-selectable-paragraph="">All of the methods used in the example above — <code>query</code>, <code>/</code>, <code>statusCode</code> and <code>jsonBody</code> are defined in the <code>tapir</code> package, and are in scope thanks to the import statement. If you’d like to explore what kind of inputs/outputs are available, just type <code>tapir.</code> and let your IDE’s auto-complete guide you.</p><p id="e922" data-selectable-paragraph="">Each of these methods yields a <strong>value</strong>, which is an <strong>immutable description</strong> of an input/output.</p><p id="ce8b" data-selectable-paragraph="">For example, <code>jsonBody[List[Book]]</code> is a description of a body input or output, which will have the json content type and will be serialised or de-serialised to a list of books.</p><blockquote><p id="c0c3" data-selectable-paragraph="">An important note here: to be able to use the json body, we’ll need to integrate with an existing json library. Here, we use <a href="https://circe.github.io/circe/" target="_blank" rel="noopener">Circe</a>, with automatic generic derivation (<code>import io.circe.generic.auto._</code>), as well as import tapir-Circe integration: <code>Codec</code>s which use Circe’s <code>Encoder</code>s/<code>Decoder</code>s, using <code>import tapir.json.circe._</code>.</p></blockquote><h2 id="f56e" data-selectable-paragraph="">The type</h2><p id="86ac" data-selectable-paragraph="">The type of the endpoint description captures what is needed for the endpoint to be interpreted as a server or a client. We need information on all the inputs and outputs which map to values in the request/response. The <code>Endpoint</code> class has four type parameters: one specifying the <strong>input type</strong>, the <strong>error output</strong> type, the <strong>output</strong> type and <strong>streaming requirements</strong> (which we’ll cover later). In our case, the type is:</p><figure><div></div></figure><p id="4180" data-selectable-paragraph="">The path input contributes no values to the input (as the path is constant), so it doesn’t influence the input type. However, the query inputs both contribute a single value: the year and the limit. Combined, we get a 2-tuple <code>(Option[Year], Option[Int])</code>. The same for the outputs.</p><h2 id="6b37" data-selectable-paragraph="">Refactoring the endpoint</h2><p id="8d7e" data-selectable-paragraph="">Leveraging the fact that both the endpoint, the inputs and the outputs are immutable values, we can do some refactoring, which will make writing subsequent endpoints easier. First, we’ll note that all of the endpoints that we’ll define in our system will have the <code>/api/v1.0</code> path prefix, and upon an error will return an <code>ErrorInfo</code> JSON (with a varying status code). To avoid duplication, we can create a custom base endpoint.</p><p id="044f" data-selectable-paragraph="">With tapir, we can use a very convenient and well-known technique of avoiding code duplication, which is called “<strong>extract value</strong>” or “<strong>extract method</strong>”. The same mechanism we use for “normal” code (because <strong>tapir code is normal code</strong>)!</p><figure><div></div></figure><p id="7fa4" data-selectable-paragraph="">Our base endpoint maps to no values from the HTTP request (hence the <code>Unit</code> as the first type parameter), but specifies the type of the error output. Note that this type isn’t final, and can also be extended by other endpoints.</p><p id="b415" data-selectable-paragraph="">As a second step of our refactoring, we’ll note that the books filter: by-year and limit, will be probably reused by other endpoints (such as searching for books by title, by author etc.). Moreover, we could use a more descriptive representation than a <code>(Option[Year], Option[Int])</code> tuple. Hence, we’ll create a case class representing the filter:</p><figure><div></div></figure><p id="57c4" data-selectable-paragraph="">and extract a value which will describe a books query input:</p><figure><div></div></figure><p id="92cd" data-selectable-paragraph="">Note that we can combine multiple inputs not only by calling <code>.in</code> or <code>.out</code> on the endpoint description multiple times, but also by using <code>.and</code> (and the alias for paths: <code>/</code>) on inputs themselves.</p><p id="bc86" data-selectable-paragraph="">Moreover, tapir provides a convenience <code>.mapTo</code> method to map a tuple to a matching case class representation. In effect, we get a value of type <code>EndpointInput[BooksQuery]</code>, which describes a (composite) input mapping to a <code>BooksQuery</code> instance.</p><h2 id="69e1" data-selectable-paragraph="">Final result</h2><p id="ba99" data-selectable-paragraph="">After the refactoring, here’s the first of the three inputs that we are going to define:</p><figure><div></div></figure><p id="20e7" data-selectable-paragraph="">Some of the key features of this representation:</p><ul><li id="112c" data-selectable-paragraph="">the endpoint is described as an <strong>immutable Scala value</strong> (a case class instance)</li><li id="eb42" data-selectable-paragraph="">re-usable parts of the endpoint description are <strong>extracted as values</strong>, which can be navigated to using the IDE</li><li id="ebc9" data-selectable-paragraph=""><strong>reading the definition</strong> (in english) gives a good idea of what the endpoint is</li><li id="43b1" data-selectable-paragraph=""><strong>the type</strong> of the endpoint gives <strong>precise</strong> (and readable) <strong>information</strong> on how the endpoint maps to HTTP requests and responses</li></ul><p id="ce93" data-selectable-paragraph="">The second example will describe an endpoint for streaming book cover images. We’ll be using the same <code>baseEndpoint</code> we’ve defined before:</p><figure><div></div></figure><p id="602f" data-selectable-paragraph="">Unlike in the first endpoint, here we capture one segment of the path, which maps to the id of the book, for which to get the cover image. This is done using the <code>path[UUID]("bookId")</code> method.</p><p id="b9ae" data-selectable-paragraph="">Moreover, we specify that the output body will be an Akka Stream: <code>Source[ByteString, Any]</code>. That’s a special kind of input, as it not only influences the input/output type, but also the 4th type parameter of <code>Endpoint</code>: the streaming requirements. While other inputs/outputs can be interpreted by any client/server interpreter, streams are interpreter-specific.</p><p id="8d22" data-selectable-paragraph="">Endpoints using Akka Streams streaming bodies can only be used when using the Akka HTTP server interpreter, or the Akka HTTP sttp client interpreter. Similarly, an endpoint using <a href="https://fs2.io/" target="_blank" rel="noopener">FS2</a> streams as the body can only be used with an http4s server interpreter, or a compatible sttp client interpreter.</p><p id="5bc3" data-selectable-paragraph="">Finally, we’ll describe an endpoint for adding a book. To add a book, besides the book details such as author and title, we’ll also give the user a possibility to submit a cover image. This is possible using multipart form submissions.</p><p id="c0d8" data-selectable-paragraph="">To handle multipart forms, we’ll first define a case class containing all the information that users will submit via the form:</p><figure><div></div></figure><p id="05a6" data-selectable-paragraph="">We’ll also secure our endpoint via a bearer token, which will be a string, but for readability we’ll use a type alias:</p><figure><div></div></figure><p id="c0eb" data-selectable-paragraph="">Finally, here’s the endpoint itself:</p><figure><div></div></figure><p id="0c30" data-selectable-paragraph="">Again, we’re using the <code>baseEndpoint</code>. Here however, we’re using the <code>.post</code> method, as this endpoint corresponds to <code>POST /api/v1.0/books</code>. Another important feature is the <code>auth.bearer</code> input, which describes an <code>Authorization</code> header input, additionally marking it as a means of authentication (which is important when generating documentation).</p><p id="f0ef" data-selectable-paragraph="">But the nicest part is specifying that the input body of the endpoint should be a multipart form. We use the <code>multipartBody[NewBook]</code> method, which yields a description of an input (as always, an immutable value! — a case class instance), mapping <code>title</code>, <code>year</code>, <code>authorName</code> and <code>authorCountry</code> <strong>text parts</strong> to the appropriate case class values, and storing the optional <code>cover</code> <strong>binary part</strong> as a temporary file (represented as Java’s <code>Path</code>).</p><p id="6cb1" data-selectable-paragraph=""><strong>And that’s it!</strong> Describing multipart forms is as easy as creating a case class with the appropriate fields.</p><p id="52b5" data-selectable-paragraph="">Describing endpoints is nice, but the descriptions are just values: they don’t do anything. Let’s change this and interpret our endpoints as a server, and later as documentation. Endpoints can also be <a href="https://tapir-scala.readthedocs.io/en/latest/sttp.html" target="_blank" rel="noopener">interpreted as clients</a>, which however isn’t covered in this article.</p><p id="ada6" data-selectable-paragraph="">Before interpreting as a server, we need to first pick an underlying stack. Here, we’ll be using Akka HTTP and <code>Future</code>s to represent asynchronous and side-effecting computations. If you’d rather work with <code>Task</code>s, <code>IO</code>s etc., you should use the http4s interpreter.</p><p id="d316" data-selectable-paragraph="">We’ll be using a thread-unsafe, var-based “database” with a couple of books already in place:</p><figure><div></div></figure><p id="bf0b" data-selectable-paragraph="">To interpret an endpoint as a server, we’ll need to provide the business logic for each endpoint that we’ve defined. To do this, we’ll import an extension method to the <code>Endpoint</code> class, <code>toRoute</code>, from the <code>tapir.server.akkahttp</code> package. This methods accepts the business logic as a parameter, and returns an Akka HTTP <code>Route</code> as a result:</p><figure><div></div></figure><p id="58b5" data-selectable-paragraph="">As we are in Akka-land, the business logic should return a <code>Future</code>. Moreover, we need to signal that either the error-output, or that the normal-output should be used. We do this using an <code>Either</code>: by convention, if the result is a <code>Left</code>, that signals an error. If the result is wrapped in a <code>Right</code>, this signals success.</p><p id="196e" data-selectable-paragraph="">Hence, for the <code>getBooks</code> endpoint, which has type:</p><pre><span id="6518" data-selectable-paragraph="">Endpoint[BooksQuery, (StatusCode, ErrorInfo), List[Book], Nothing]</span></pre><p id="8bbb" data-selectable-paragraph="">the corresponding type of the business logic that we need to provide is:</p><pre><span id="bb70" data-selectable-paragraph="">BooksQuery =&gt; Future[Either[(StatusCode, ErrorInfo), List[Book]]</span></pre><p id="a313" data-selectable-paragraph="">Note, that everything is type-safe! The business logic accepts as parameters data which is extracted and parsed according to the description in the endpoint; moreover, it is required to return data of the specified type as well. The response is then serialised using the captured json Circe codecs.</p><p id="09d4" data-selectable-paragraph="">We implement the business logic of the remaining two endpoints in a similar way:</p><figure><div></div></figure><p id="073c" data-selectable-paragraph="">We now have three completely regular Akka HTTP <code>Route</code>s. We can surround them with other directives, e.g. for logging or metrics, or manipulate in any other way just as we would with a route created using Akka HTTP’s API. Here, we’ll simply start a server with these routes on the 8080 port:</p><figure><div></div></figure><p id="f13c" data-selectable-paragraph="">Thanks to the fact that our endpoint descriptions capture the whole structure of the endpoint, we can also automatically generate API documentation.</p><p id="79ba" data-selectable-paragraph="">Moreover, we can enrich the endpoint descriptions with meta-data, such as textual clarifications on the functionality of the API or data examples. For instance, we might provide an example of a book instance that is returned by the get books endpoint (note the <code>.example</code> method invocation):</p><figure><div></div></figure><p id="4721" data-selectable-paragraph="">tapir contains an OpenAPI interpreter, which translates a list of <code>Endpoint</code>s to an instance of the <code>OpenAPI</code> class. <code>OpenAPI</code> is the root of a family of case classes, which directly model the OpenAPI specification.</p><p id="ead3" data-selectable-paragraph="">Thanks to that approach, if there’s some feature of the specification that is not covered by tapir, and cannot be automatically generated, you can always add it to the generated documentation, by manipulating the returned instance. When modifying a deeply nested case class structure, projects such as <a href="https://github.com/adamw/quicklens" target="_blank" rel="noopener">quicklens</a> might be very helpful!</p><p id="ce0a" data-selectable-paragraph="">We can later serialise the <code>OpenAPI</code> instance as yaml or json:</p><figure><div></div></figure><p id="9645" data-selectable-paragraph="">The generated yml can be exposed using Swagger’s UI by adding a couple of Akka HTTP routes to serve the static content (images, css, html) and the documentation itself. See the <code>SwaggerUI</code> class in the <a href="https://github.com/adamw/tapir-three" target="_blank" rel="noopener">sources</a> for details.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*1OWEhL3TtEdSHxiuiB7XwA.png?q=20" width="1600" height="1308" role="presentation"></p><p><img width="1600" height="1308" role="presentation"></p></div></div></div></div></figure><p id="49e5" data-selectable-paragraph="">We’ve covered a lot of ground! Let’s summarise what we’ve seen so far.</p><p id="e30b" data-selectable-paragraph="">Java frameworks use annotations to define the mapping between business logic methods and HTTP endpoints. This has three main benefits:</p><ol><li id="9f27" data-selectable-paragraph="">the HTTP meta-data is <strong>separated</strong> from the business logic</li><li id="15de" data-selectable-paragraph="">annotations can be <strong>processed</strong> to generate documentation or a client</li><li id="fee1" data-selectable-paragraph="">the <strong>intention</strong> of the code is clearly communicated, that is, the code is not only easy to write, but also easy to read</li></ol><p id="a6ad" data-selectable-paragraph="">On the other hand, we have Scala, which has a much more <strong>advanced type system</strong>, as well as a number of features allowing flexibility in defining <strong>abstractions</strong>.</p><p id="bc9d" data-selectable-paragraph="">tapir <strong>combines the best of those worlds</strong>. Instead of using a separate language for defining the meta-data (the language of annotations), we use the same language to express the meta-data and the business logic. After all, why should we use a different one? Specifying HTTP mappings isn’t such a special task, that it should require a separate language! This allows us to use the same abstraction mechanisms as we use for all other code — for example, extracting common functionality as values or methods.</p><p id="bc90" data-selectable-paragraph="">Hence, we manage to maintain the <strong>declarativeness</strong>, <strong>separation of concerns</strong> and <strong>readability</strong> of Java’s annotations; at the same time, significantly improving the <strong>type-safety</strong>, <strong>composability</strong> and <strong>abstraction</strong> capabilities.</p><p id="4918" data-selectable-paragraph="">Remember that the descriptions are plain Scala values — instances of case classes. You can construct these case classes by hand, or pattern-match them to create your own interpreters. Describing HTTP endpoints isn’t a complex thing, and it shouldn’t require complex code. Let’s use <a target="_blank" rel="noopener" href="https://blog.softwaremill.com/simple-scala-stack-70fc786132b5">simple code for simple problems</a>!</p><p id="62a2" data-selectable-paragraph="">Give <a href="https://github.com/softwaremill/tapir" target="_blank" rel="noopener">tapir</a> a try, <a href="https://github.com/adamw/tapir-three" target="_blank" rel="noopener">run the example</a> developed above, in case of questions <a href="https://tapir-scala.readthedocs.io/" target="_blank" rel="noopener">consult the docs</a>, head over to the <a href="http://gitter.im/softwaremill/tapir" target="_blank" rel="noopener">gitter room</a> or simply create an issue!</p></div></div></section><section></section></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>