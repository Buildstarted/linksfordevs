<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Against Railway-Oriented Programming -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Against Railway-Oriented Programming</h1>
    <div class="col-md-9"> <div class="page-header"> <p class="subtitle">(when used thoughtlessly)</p> <p class="postdate">20 Dec 2019</p> </div> <blockquote> <p>This post is part of the <a href="https://sergeytihon.com/2019/11/05/f-advent-calendar-in-english-2019/">2019 F# Advent Calendar</a>.
Check out all the other great posts there! And special thanks to Sergey Tihon for organizing this.</p>
</blockquote> <p>Six and half years ago, I wrote a post and did a talk on what I called <a href="https://fsharpforfunandprofit.com/rop/">&#x201C;Railway Oriented Programming&#x201D;</a>. It was a way for me to explain to myself and others how to use <code class="highlighter-rouge">Result</code>/<code class="highlighter-rouge">Either</code> to for chaining together error-generating functions.</p> <p>To my surprise, this silly railway analogy really took off, and now there are railway-oriented programming libraries and posts for all sorts of languages, including <a href="https://www.morozov.is/2018/05/27/do-notation-ruby.html">Ruby</a>, <a href="https://github.com/StefanMacke/ao-railway">Java</a>, <a href="https://dorp.io/posts/railway-oriented-programming/">JavaScript</a>, <a href="https://proandroiddev.com/railway-oriented-programming-in-kotlin-f1bceed399e5?gi=ce6e3bd2f69">Kotlin</a>,
<a href="https://github.com/rob-earwaker/rail">Python</a> and more.</p> <p>I still think it&#x2019;s a good analogy, but I do think it is <a href="https://twitter.com/scottwlaschin/status/997009818329198592">often used thoughtlessly</a>, especially if it&#x2019;s a shiny new technique that you&#x2019;ve just added to your toolbox.</p> <p>So, in this post, I&#x2019;m going to lay out reasons why you <em>shouldn&#x2019;t</em> use Railway-Oriented Programming! Or to be more precise, why you shouldn&#x2019;t use the <code class="highlighter-rouge">Result</code> type everywhere (because ROP is just the plumbing that is used to connect <code class="highlighter-rouge">Result</code>-returning functions). The <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/conventions#error-management">Microsoft page on error management</a> also has good advice, as does <a href="https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/">this blog post</a>.</p> <h2 id="1--dont-use-result-if-you-need-diagnostics">#1 &#x2013; Don&#x2019;t use Result if you need diagnostics</h2> <p>If you care about the location of an error, having a stack trace, or other diagnostics, don&#x2019;t use <code class="highlighter-rouge">Result</code>. In particular, don&#x2019;t use <code class="highlighter-rouge">Result</code> as a substitute for exceptions but then store a stack trace or a whole exception inside a <code class="highlighter-rouge">Result</code>. What&#x2019;s the point?</p> <p>Instead, think of <code class="highlighter-rouge">Result</code> as a glorified boolean with extra information. It&#x2019;s only for <em>expected</em> control-flow, not for unexpected situations.</p> <h2 id="2--dont-use-result-to-reinvent-exceptions">#2 &#x2013; Don&#x2019;t use Result to reinvent exceptions</h2> <p>I&#x2019;ve see people use <code class="highlighter-rouge">Result</code> indiscriminately for all kinds of error handling, including things that would be better handled with exceptions. Don&#x2019;t reinvent &#x201C;try-catch&#x201D;!</p> <p>I&#x2019;ve also seen people trying to hide exceptions altogether. This is fruitless. No matter how many exceptions you convert into <code class="highlighter-rouge">Result</code>s, some will always leak out. You will always need to handle exceptions appropriately in the highest parts of the system.</p> <h2 id="3--dont-use-result-if-you-need-to-fail-fast">#3 &#x2013; Don&#x2019;t use Result if you need to fail fast</h2> <p>If something does go wrong, and you can&#x2019;t continue, don&#x2019;t return a <code class="highlighter-rouge">Result</code> and keep going. Fail fast instead with an exception or even just <a href="https://docs.microsoft.com/en-us/dotnet/api/system.environment.failfast">exit the app immediately</a>.</p> <h2 id="4--dont-use-result-if-no-one-will-see-it">#4 &#x2013; Don&#x2019;t use Result if no one will see it</h2> <p>If you are doing some complex control flow but the logic is hidden from the outside world, don&#x2019;t use <code class="highlighter-rouge">Result</code> just for the sake of it. Often, using an exception locally will be cleaner.</p> <p>For example, let&#x2019;s say you are collecting information by traversing a tree, and you need to exit early when something goes wrong.</p> <p>In the ROP approach, you&#x2019;d have the node processing function return a <code class="highlighter-rouge">Result</code>, which then has to be passed to the next node processing function using <code class="highlighter-rouge">bind</code>, and so on. For complex navigation, you can spend a lot of time working out the logic so that the code will compile (<a href="https://hackage.haskell.org/package/recursion-schemes">Haskell programmers excepted, of course</a>)</p> <p>On the other hand, you could define a private local exception (e.g. in the style of Python&#x2019;s <code class="highlighter-rouge">StopIteration</code>), write the iteration imperatively, throw the exception when you need to return early, and then catch the exception at the top level. As long as the code is not too long, and the exception is defined locally, this approach can often make the code clearer. And if no consumers ever see the internals, then no harm, no foul.</p> <p>Another example might be when defining microservices. If the entire code is only a few hundred lines long, and is opaque to the callers, then using exceptions rather than <code class="highlighter-rouge">Result</code> is perfectly OK as long as they don&#x2019;t escape the service boundary.</p> <h2 id="5--dont-use-result-if-no-one-cares-about-the-error-cases">#5 &#x2013; Don&#x2019;t use Result if no one cares about the error cases</h2> <p>Typically, <code class="highlighter-rouge">Result</code> is defined with the error case being a discriminated union of all the things that can go wrong.</p> <p>For example, lets say you want to read the text from a file, so you define a function like this:</p> <div class="highlighter-rouge"><pre class="highlight"><code>type ReadTextFromFile = FileInfo -&gt; Result&lt;string, FileError&gt;
</code></pre>
</div> <p>where <code class="highlighter-rouge">FileError</code> is defined like this:</p> <div class="highlighter-rouge"><pre class="highlight"><code>type FileError =
  | FileNotFound
  | DirectoryNotFound
  | FileNotAccessible
  | PathTooLong
  | OtherIOError of string
</code></pre>
</div> <p>But do the consumers of this function really care about every possible thing that can go wrong reading a file?
Perhaps they just want the text, and they don&#x2019;t care why it didn&#x2019;t work. In which case, it might be simpler to return an <code class="highlighter-rouge">option</code> instead, like this:</p> <div class="highlighter-rouge"><pre class="highlight"><code>type ReadTextFromFile = FileInfo -&gt; string option
</code></pre>
</div> <p><code class="highlighter-rouge">Result</code> is a tool for domain modeling, so if the domain model doesn&#x2019;t need it, don&#x2019;t use it.</p> <p>A similar example can be found when implementing event sourcing, in the <a href="https://medium.com/@dzoukr/event-sourcing-step-by-step-in-f-be808aa0ca18">command processing function</a> which has the standard signature</p> <div class="highlighter-rouge"><pre class="highlight"><code>&apos;state -&gt; &apos;command -&gt; &apos;event list
</code></pre>
</div> <p>If something goes wrong in executing the command, how does that affect the return value (the list of events created by the command) in practice? Of course you need to handle errors and log them, but do you actually need to return a <code class="highlighter-rouge">Result</code> from the function itself? It will make the code more complicated for not much benefit.</p> <h2 id="6--be-careful-when-using-result-for-io-errors">#6 &#x2013; Be careful when using Result for I/O errors</h2> <p>If you try to open a file, but you get an error, should you wrap that in a <code class="highlighter-rouge">Result</code>? It depends on your domain.
If you&#x2019;re writing a word processor, not being able to open a file is expected and should be handled gracefully. On the other hand, if you can&#x2019;t open a config file that your app depends on, you shouldn&#x2019;t return a <code class="highlighter-rouge">Result</code>, you should just fail fast.</p> <p>Anywhere that there is I/O there will many, many things that can go wrong. It is tempting to try to model all possibilities with a <code class="highlighter-rouge">Result</code>, but I strongly advise against this. Instead, only model the bare minimum that you need for your domain, and let all the other errors become exceptions.</p> <p>Of course, if you follow best practices and separate your I/O from your pure business logic, then you should rarely need to work with exceptions in your core code anyway.</p> <h2 id="7--dont-use-result-if-you-care-about-performance">#7 &#x2013; Don&#x2019;t use Result if you care about performance</h2> <p>This is more of a &#x201C;be careful&#x201D; than an absolute prohibition. If you know up front that you have a section of performance-sensitive code, then be wary of using <code class="highlighter-rouge">Result</code> there. In fact, you probably want to be wary of other built-in types too (e.g. <code class="highlighter-rouge">List</code>). But as always, measure to find the hotspots rather than guessing in advance so that you don&#x2019;t over-optimize the wrong thing.</p> <h2 id="8--dont-use-result-if-you-care-about-interop">#8 &#x2013; Don&#x2019;t use Result if you care about interop</h2> <p>Most OO languages do not understand <code class="highlighter-rouge">Result</code> or other discriminated unions. If you need to return a possible failure from an API, consider using an approach that is more idiomatic for the caller. Even &#x2013; shock horror &#x2013; using null on occasion. Don&#x2019;t force the caller to become an expert in functional idioms just so they can call your API.</p> <ul> <li><strong>Diagnostics</strong>: If you care about stack traces or the location of an error, don&#x2019;t use <code class="highlighter-rouge">Result</code>.</li> <li><strong>Reinventing try/catch</strong>: Why not use the language tools that are already built-in?</li> <li><strong>Fail fast</strong>: If the end of your workflow will throw an exception anyway, don&#x2019;t use <code class="highlighter-rouge">Result</code> inside the workflow.</li> <li><strong>Local exceptions for control flow are OK</strong>: If the control flow is complicated and private, it&#x2019;s OK to use exceptions for control flow.</li> <li><strong>Apathy</strong>: Don&#x2019;t return a <code class="highlighter-rouge">Result</code> if no one cares about the errors.</li> <li><strong>I/O</strong>: Don&#x2019;t try and model every possible I/O error with a Result.</li> <li><strong>Performance</strong>: If you care about performance, be wary of using <code class="highlighter-rouge">Result</code>.</li> <li><strong>Interop</strong>: If you care about interop, don&#x2019;t force callers to understand what <code class="highlighter-rouge">Result</code> is and how it works.</li>
</ul> <h2 id="when-should-you-use-result">When should you use Result?</h2> <p>So after all that negativity, what situations <em>should</em> you use <code class="highlighter-rouge">Result</code> for?</p> <p>As I said in my book <a href="/books/"><em>Domain Modeling Made Functional</em></a>, I like to classify errors into three classes:</p> <ul> <li><strong>Domain Errors</strong>. These are errors that are to be expected as part of the business process, and therefore must be included in the design of the domain. For example, an order that is rejected by billing, or an order than contains an invalid product code. The business will already have procedures in place to deal with this kind of thing, and so the code will need to reflect these processes. Domain errors are part of the domain, like anything else, and so should be incorporated into our domain modeling, discussed with domain experts, and
documented in the type system if possible. Note that diagnostics are not needed &#x2013; we are using <code class="highlighter-rouge">Result</code> as a glorified <code class="highlighter-rouge">bool</code>.</li> <li><strong>Panics</strong>. These are errors that leave the system in an unknown state, such as unhandleable system errors (e.g. &#x201C;out of memory&#x201D;) or errors caused by programmer oversight (e.g. &#x201C;divide by zero,&#x201D; &#x201C;null reference&#x201D;). Panics are best handled by abandoning the workflow and raising an exception which is then caught and logged at the highest appropriate level (e.g. the main function of the application or equivalent).</li> <li><strong>Infrastructure Errors</strong>. These are errors that are to be expected as part of the architecture, but are not part of any business process and are not included in the domain. For example, a network timeout, or an authentication failure. Sometimes handling these should be modeled as part of the domain, and sometimes they can be treated as panics. If in doubt, ask a domain expert!</li>
</ul> <p>So using the definitions above:</p> <ul> <li><code class="highlighter-rouge">Result</code> should only be used as part of the domain modeling process, to document expected return values. And then to ensure at compile-time that you handle all the possible <em>expected</em> error cases.</li> <li>Micro-domains, such as libraries, could also use <code class="highlighter-rouge">Result</code> if appropriate.</li>
</ul> <p>So to sum up, I think the <code class="highlighter-rouge">Result</code> type and railway-oriented programming are extremely useful when used appropriately, but the use-cases are more limited than you might think, and they shouldn&#x2019;t be used everywhere just because it&#x2019;s cool and interesting.</p> <p>Thanks for reading! If you&#x2019;re interested in more F# posts, check out the rest of the <a href="https://sergeytihon.com/2019/11/05/f-advent-calendar-in-english-2019/">2019 F# Advent Calendar</a>.</p> <table>
<tr>
<td width="150">
<a href="/books"><img src="/books/domain-modeling-made-functional-150.jpg"></a>
</td>
<td>
And if you are interested in the functional approach to domain modeling and design, here&apos;s <a href="/books">my &quot;Domain Modeling Made Functional&quot; book!</a>
It&apos;s a beginner-friendly introduction that covers Domain Driven Design, modeling with types, and functional programming.
</td>
</tr>
</table> <h4>Comments</h4> <a href="//disqus.com" class="dsq-brlink">blog comments powered by </a> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>