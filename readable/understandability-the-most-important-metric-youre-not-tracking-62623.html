<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Understandability: The Most Important Metric You&#x2019;re Not Tracking  - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Understandability: The Most Important Metric You&#x2019;re Not Tracking  - linksfor.dev(s)"/>
    <meta property="article:author" content="Liran Haimovitch&#xA;                &#xA;            &#xA;        Follow"/>
    <meta property="og:description" content="Understandability is the concept that a system should be presented so that an engineer can easily comprehend it. The more understandable a system is, the easier it will be for engineers to change it in a predictable and safe manner. A system is understandable if it meets the following criteria: complete, concise, clear, and organized."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.infoq.com/articles/understandability-metric-not-tracking/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Understandability: The Most Important Metric You&#x2019;re Not Tracking </title>
<div class="readable">
        <h1>Understandability: The Most Important Metric You&#x2019;re Not Tracking </h1>
            <div>by Liran Haimovitch&#xA;                &#xA;            &#xA;        Follow</div>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 09 Jun 2020</div>
        <p><a href="https://www.infoq.com/articles/understandability-metric-not-tracking/">https://www.infoq.com/articles/understandability-metric-not-tracking/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
							
								<div>
									<h3>Key Takeaways</h3>
									<ul>
	<li>Change is the only constant in life. Nowhere is this more apparent than in software engineering, where a developer’s daily job is to modify, adapt, tweak, or even remake the systems they are responsible for.&nbsp;</li>
	<li>As applications grow and teams scale, it becomes more challenging to maintain a clear understanding of the software itself. Complexity hurts engineers’ ability to understand and effectively change the software as needed.&nbsp;</li>
	<li>Understandability is the concept that a system should be presented so that an engineer can easily comprehend it.&nbsp;The more understandable a system is, the easier it will be for engineers to change it in a predictable and safe manner.</li>
	<li>A system is understandable if it meets the following criteria: complete, concise, clear, and organized.</li>
	<li>Understandability and observability are complementary, but the later focuses more on two things: the ability to alert when the system misbehaves and help to identify the causes so that normal service can be restored; and the ability to help identify performance bottlenecks so that additional resources can be allocated or that the relevant teams be informed.<br>
	&nbsp;</li>
</ul>

									
								</div>
							
							
								
								<p>2,500 years ago Heraclitus said that “change is the only constant in life.” Nowhere is this more apparent than in software engineering, where a developer’s daily job is to modify, adapt, tweak, or even remake the systems they are responsible for. Another such aspect that makes software engineering relatively unique among human disciplines is the vast freedom we have to mold our works, within the man-made boundaries defined by the mechanics of computer science.</p>

<p>Our ability to effectively exercise that great power often falls short on a very surprising limitation —our ability to know our own creations. As applications grow and teams scale, it becomes even harder to maintain a clear understanding of the software itself, causing projects to crumble like the biblical Tower of Babel.</p>

<h2>Case in point</h2>

<p>Most commercial software engineering tasks out there do not start out with a clean slate. There is an existing application, written using a certain computer language(s), relying on a set of frameworks and libraries, and running on top of some operating system(s).</p>


								
								
									








								
								<p>We take it upon ourselves (or our teams) to change that existing application so that it meets some requirement(s), such as developing a new feature, fixing an existing bug, etc. Simultaneously we are required to continue meeting all the existing (un)documented requirements, and maintain the existing behavior as much as possible.</p>

<p>And, as every junior software engineer finds out on their first day on the job, writing a piece of code to solve a simple computer science problem (or copying the answer from StackOverflow) is nowhere near the level of complexity of solving that same problem within a large and intricate system.</p>

<h2>What is Understandability?</h2>

<p>Borrowing from the <a href="https://www.accountingtools.com/articles/what-is-understandability.html">financial industry</a>, let’s define Understandability: “Understandability is the concept that a system should be presented so that an engineer can easily comprehend it.” The more understandable a system is, the easier it will be for engineers to change it in a predictable and safe manner.</p>


								
								
									
								
								<p>Drawing further on that analogy, we can say that a system is understandable if it meets the following criteria:</p>

<ul>
	<li>Complete. The system must be presented using a predefined set of sources (source code, documentation, etc.) to cover all key information. No critical pieces of information may be left to the engineer’s imagination.</li>
	<li>Concise. The system source code should not bury the user with an excessive amount of detail. This is where <a href="https://deviq.com/separation-of-concerns/">s</a><a href="https://deviq.com/separation-of-concerns/">eparation of concerns</a> and <a href="https://www.techopedia.com/definition/3736/abstraction">a</a><a href="https://www.techopedia.com/definition/3736/abstraction">bstraction</a> come into play, allowing the engineer to focus on the task at hand.</li>
	<li>Clear. Use a presentation methodology that is easy for the reader to scan. This is where <a href="https://medium.com/@jonfinerty/consistency-in-software-42626ac4219f">c</a><a href="https://medium.com/@jonfinerty/consistency-in-software-42626ac4219f">onsistency</a>, coding conventions, source-code formatting, code comments, and syntax highlighting make a huge difference.</li>
	<li>Organized. The engineer should be able to easily locate cross-referenced information within the system. This is where <a href="https://modularmanagement.com/software-modularity/">m</a><a href="https://modularmanagement.com/software-modularity/">odularity</a>, software documentation, source-code navigation controls, and source code management tools allow engineers to find their way around the system.</li>
</ul>

<h2>Runtime Understandability</h2>

<p>With the rise of <a href="https://searchcloudcomputing.techtarget.com/definition/Software-as-a-Service">Software as a Service</a> (SaaS) and other new <a href="https://thenewstack.io/convergence-new-software-paradigm/">s</a><a href="https://thenewstack.io/convergence-new-software-paradigm/">oftware delivery paradigms</a>, many organizations are practicing <a href="https://netflixtechblog.com/full-cycle-developers-at-netflix-a08c31f83249">total ownership</a> of software, empowering engineers to take responsibility for the application throughout its lifecycle.</p>

<p>In such organizations, Understandability takes on an even more powerful form, determining how well engineers can understand how the software operates and how it is being utilized by the application’s customers.</p>

<p>And so, highly valuable information such as usage patterns, real-world inputs and outputs, and actual performance and availability statistics can become accessible to teams determined to have them.</p>

<h2>Observability is not Understandability</h2>

<p>Reading this you might be thinking, that’s exactly what <a href="https://docs.honeycomb.io/learning-about-observability/intro-to-observability/">o</a><a href="https://docs.honeycomb.io/learning-about-observability/intro-to-observability/">bservability</a> and monitoring tools are for. Unfortunately, that’s not the case. Those tools are there to support more traditional IT problems, focusing on:</p>

<ol>
	<li>Alerting when the system misbehaves and helping to identify the root so that normal service can be restored.</li>
	<li>Identifying performance bottlenecks so that additional resources can be allocated or that the relevant teams be informed.</li>
	<li>Keeping detailed event logs for operations, security, and support purposes.</li>
</ol>

<p>Those are all great use-cases IT has been dealing with since time immemorial, and as the ROI for them is quite clear, a large number of vendors are offering great tools to solve those problems. However, those are not the use cases software engineering teams are tasked with, and those tools were never meant to help them.</p>

<p>What all of those IT use cases have in common is that someone, with a basic working knowledge of the system, needs to know exactly how the system behaved in a specific instance so that they can respond to it appropriately. This means we collect data about a predefined set of events, which tends to be about how the system is interacting with the world around it.</p>

<p>Software engineering teams, on the other hand, have an in-depth knowledge of the inner workings of the system and are looking to understand more about how it works. The data they need to collect changes on a daily (if not hourly) basis, based on the specific change they are making to the system.</p>

<h2>Winning over complexity</h2>

<p>As software scales and mutates, it becomes ever more complex. A big part of that complexity is inherent, due to the simple fact that the number of business requirements is ever-growing. The rest of that complexity is unwanted, caused by the way the application has been repurposed over time as well as poor design choices and is commonly referred to as <a href="https://jaxenter.com/haimovitch-interview-technical-debt-157301.html">tech debt</a>.</p>

<p>Regardless of its source, complexity hurts engineers’ ability to understand and effectively change the software as needed. This problem is usually aggravated by the knowledge loss caused by personnel turnover.</p>

<p>Of course, in the software industry, it is common knowledge that software complexity has to be minimized. The more complex the software, the more expensive it will be to develop new features and the overall quality of the system will be lower. Much has been written on how to build application software that keeps complexity to a minimum and allows systems and teams to scale better.</p>

<h2>Understandability in new software</h2>

<p>If you are developing new software, you will likely neglect Understandability in favor of one of its proxies: complexity. By focusing on avoiding and reducing complexity you will naturally maintain understandability. Lucky for you, complexity in software is at the focus of countless software development tools and techniques.</p>

<p>First and foremost, start with a high-quality workforce. Talented engineers draw on their experience to express complex business problems in simple and elegant ways in both the software’s source code and architecture, creating an easier to understand software.</p>

<p>Next, try to make the system as small as possible, since smaller systems by nature are less complex and easier to understand. Systems can be reduced from the “top” by focusing on the business requirements that truly matter, while leaving out, at least temporarily, requirements that are not mandatory. Systems can often be reduced from the “bottom” as well, by using higher-level abstractions, such as new programming languages, advanced frameworks, and modern databases.</p>

<p>Last but not least, make sure to have the scaffolding in place to deal with complexity when it arises. Write automated tests in the form of both unit-tests and system-tests to ensure that your engineering team can safely refactor that complexity away. Put in high-quality observability tools to help you gain a high-level understanding of the system. Automate your integration and deployment pipelines to enable you to improve and iterate fast.</p>



<p>When it comes to existing software, on the other hand, we tend to accept our engineering team’s failure to understand the code as a god-wrought catastrophe. Charging at complexity head-on is no longer a viable approach to improving Understandability.</p>

<p>More often than not, you are faced with a legacy system that was written using lower-level instruments than what is currently available, by people who have long ago left and none of the scaffolding is there. Complaining about the technical debt you have to cope with and the “unreadable code” your engineers cannot understand is not going to get you very far. Nor will dreaming about long-term refactorings and migrations which will rarely ever come to pass.</p>

<p>That’s where production debugging platforms shine. By allowing your engineers the in-depth view of the code in motion they are striving for, they can begin to understand it. And by following the cookie crumbs across environments and use cases, they can unravel that complexity step-by-step.</p>

<h2>Parting words</h2>

<p>We now have a better perspective on the importance of Understandability in software development. On the one hand, we always knew that keeping code easy to read and maintain was important and that much of software engineering was focused on that feat. And yet, we now have a greater appreciation for how much of a difference it can make in allowing software to grow and evolve over time.</p>

<p>On the other hand, we have also challenged the assumption that Understandability can always be improved by tackling complexity and designing and writing better, simpler software. More often than not, we find ourselves boarding the train midway through, with little or no control over how it got there. And so, we must start tracking and managing Understandability as its own key metric, maximizing engineering velocity and quality, even under less than optimal conditions.</p>

<h2>About the Author</h2>

<p><strong><img alt="" _href="img://1Liran-Haimovitch-1591279293579.jpg" data-src="articles/understandability-metric-not-tracking/en/resources/1Liran-Haimovitch-1591279293579.jpg" src="https://res.infoq.com/articles/understandability-metric-not-tracking/en/resources/1Liran-Haimovitch-1591279293579.jpg" rel="share">Liran Haimovitch</strong> is the Co-Founder and CTO of Rookout. He’s an advocate of modern software methodologies like agile, lean, and devops. Liran’s passion is to understand how software actually works. When he’s not thinking of code, he’s usually diving or hiking.</p>

							
							
						</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>