<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Implementing Sign In with Apple in ASP.NET Core -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Implementing Sign In with Apple in ASP.NET Core</h1><div><div class="col-lg-10" itemprop="articleBody"><p>
Apple have improved their OpenID Connect implementation, which thankfully means that some of the workarounds in this article are no longer necessary.
I’ll update the article soon.
</p><img src="/img/logos/apple.svg" alt=".NET Core" class="float-left mr-2" height="130"><p>
Sign in with Apple was recently released as part of Apple’s WWDC 2019 conference.
They’ve essentially weighed into the identity provider space with the username and password being handled by Apple ID and 2FA handled by your registered Apple devices.
</p><p>
Sign In with Apple gives us a new alternative to other social login providers such as Google and Facebook.
However, unlike those services, it seems to be more aimed at identity and authentication, rather than access to services such as Google calendar.
</p><p>
The major value add is the ability to create a “private relay email”.
So instead of giving the website your actual email address, you instead give them an Apple one, created specifically for that website.
This way we get to keep our email private, whilst still having the ability to receive mail from that website.
</p><p>
In this article, I’m going to take a brief look at how Sign In with Apple is hooked together, and then show a proof of concept integration using ASP.NET Core.
</p><p><a href="#aspnetcore">Skip to the code.</a></p><h2>
Sign In with Apple: How It Works
</h2><p>
The good news is, Sign In with Apple is OpenID Connect in everything but name.
It has an authorization endpoint, a token endpoint, we send it a client ID, redirect URI, state, and we get an identity token in return.
However, it does have a few caveats.
</p><h3>Authorization Request</h3><p>
The authorization URL is the same for every application, and the client specific configuration is registered in Apple’s developer portal as a Service ID.
</p><h4>Example Sign In with Apple Authorization Request</h4><pre><code class="language-custom">https://appleid.apple.com/auth/authorize
  ?client_id=com.scottbrady91.authdemo.service
  &amp;redirect_uri=https://www.scottbrady91.com/signin-apple
  &amp;state=123
  &amp;response_type=code
  &amp;response_mode=form_post</code></pre><p>
If you supply a <code>nonce</code>, it will unfortunately not be included in any returned identity tokens.
<code>s_hash</code>, <code>c_hash</code> when using the hybrid flow, and PKCE support do not seem to be present either.
As a result, <strong>I’m struggling to see any protection from code injection attacks in Apple’s implementation</strong>.
</p><p>
You can define requested scopes in your authorization request (e.g. openid or email. profile is not supported), however, during testing if I included this parameter it caused Apple’s consent page on <em>https://appleid.apple.com/appleauth/auth/oauth/consent</em> to fail with an HTTP 500 error.
</p><p>
There does not seem to be a discovery endpoint either, so endpoints will have to be defined manually.
Thankfully, they do have a JWKS endpoint for public keys.
</p><h3>Token Request</h3><p>
Apple does not support simple shared secrets for client authorization.
Instead, they use a custom implementation, similar to <a href="/OAuth/Removing-Shared-Secrets-for-OAuth-Client-Authentication" title="Removing Shared Secrets for OAuth Client Authentication" target="_blank">JWT Bearer Token for Client Authentication</a> found in <a title="RFC 7523 - JWT Profile for OAuth 2.0 Client Authentication and Authorization Grants" href="https://tools.ietf.org/html/rfc7523" target="_blank">RFC 7523</a>.
Apple supply you with a private key with which to sign the token and require you to use the ES256 signing algorithm.
</p><p>
This JWT must also have:
</p><ul><li>An issuer (<code>iss</code>) value set to your Apple Team ID (found in the membership area of the Apple developer portal)</li><li>An expiry (<code>exp</code>) of under 6 months (allowing for long-lived or short-lived credentials)</li><li>An audience (<code>aud</code>) value of <em>https://appleid.apple.com</em></li><li>A subject (<code>sub</code>) value equal to your <code>client_id</code> (Service ID)</li></ul><p>
You can find more details on the client secret type in <a title="Apple Docs - Creating the Client Secret" href="https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens#3262048" target="_blank">Apple’s documentation</a>.
</p><h4>Example JWT Secret</h4><h5>Encoded</h5><pre><code class="language-custom nooverflow">eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJjb20uc2NvdHRicmFkeTkxLmF1dGhkZW1vLnNlcnZpY2UiLCJuYmYiOjE1NTk5ODE5NDAsImV4cCI6MTU1OTk4MjI0MCwiaWF0IjoxNTU5OTgxOTQwLCJpc3MiOiI2MlFNMjk1NzhOIiwiYXVkIjoiaHR0cHM6Ly9hcHBsZWlkLmFwcGxlLmNvbSJ9.ZxYzYTJUcjGq46NKrqHhi53yOWp6mmvq5WECg2qMq6Xg-5qeOpJXmi0Qf1YZsA2OG4RJwlFHObWbhF5ebdUZfA</code></pre><h5>Decoded</h5><pre><code class="language-json">{
  "alg": "ES256",
  "typ": "JWT"
}
{
  "sub": "com.scottbrady91.authdemo.service",
  "nbf": 1559981940,
  "exp": 1559982240,
  "iat": 1559981940,
  "iss": "62QM29578N",
  "aud": "https://appleid.apple.com"
}</code></pre><h4>Example Sign in with Apple Token Request</h4><pre><code class="language-custom">POST https://appleid.apple.com/auth/token HTTP/1.1
User-Agent: Microsoft ASP.NET Core OpenIdConnect handler
Content-Type: application/x-www-form-urlencoded

client_id=com.scottbrady91.authdemo.service
    &amp;code=c17591c6ce9a942b19729925667457fa4.0.nvrr.nVvlSbFTgMm9mpg-uKvlYg
    &amp;grant_type=authorization_code
    &amp;redirect_uri=http%3A%2F%2Flocal.test%3A5000%2Fsignin-apple
    &amp;client_secret=eyJhbGciOiJFU[...]A2OG4RJwlFHObWbhF5ebdUZfA</code></pre><p>
Note that Apple’s token endpoint <strong>requires a User-Agent header</strong> to succeed validation.
</p><h4>Example Sign In with Apple Token Response</h4><pre><code class="language-json">{
    "access_token": "aa4c538c4896649b89d39b7e355f5b4fb.0.nvrr.pJR4425acx26Gu4LxXUwAw",
    "token_type": "Bearer",
    "expires_in": 3600,
    "refresh_token": "r3dc7e086e35e4db99583cf2a61d27785.0.nvrr.JcsmhqE0ZzNGj-h3BDN5rg",
    "id_token": "eyJraWQiOiJBSURPUEsxIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL2FwcGxlaWQuYXBwbGUuY29tIiwiYXVkIjoiY29tLnNjb3R0YnJhZHk5MS5hdXRoZGVtby5zZXJ2aWNlIiwiZXhwIjoxNTU5OTgyNTQyLCJpYXQiOjE1NTk5ODE5NDIsInN1YiI6IjAwMDUxMS4xMDViODM3OGZhYmM0MTBjYjI4NTc2ZTA4YzI0NDgzZS4wNjU5IiwiYXRfaGFzaCI6IlAxeGFqX2VEaFZLLWhxd1RNWmZfckEifQ.DCVaN3QngqtBQuoXzwTrr9MywmwZy6tZF6ljLsNBH7cJMaIn3pnYPAs9rD_YAmF2ihZS0DJtKlpinZ1LmmMVvBqebD1N7Bl7iDWxuAyFLkU1xQQZYIWP_JhoHXhHFGTls_e7YZZDlgEKPPSZdimGs8byr1c9uaagIY8cSjwAk8t8egazMgYQstuu7SRb7JJs2rm2lDFWXR61AmeRbej8khSYEhn-28uJY2DHQWwamKj0ABcFTmq4Cn3kKiIPm3r5fYxFHOUOl01av_uRGtG9bPORv5nb9CPHSZM6qZu2rxWcybfnLJlExbM12Q0yLQHxk5_gtC6OJOM8dfFfWwB0Vg"
}</code></pre><h2 id="aspnetcore">ASP.NET Core Authentication using Sign In with Apple</h2><p>
Let’s see how to integrate this in ASP.NET Core.
First, we’ll need to do some setup within Apple’s developer portal, access to which will unfortunately put you back at least £79 if you don’t already have an account.
</p><h3>Apple Developer Portal Setup</h3><p>
Apple have some good <a title="Configure Sign In with Apple for the web" href="https://help.apple.com/developer-account/#/dev1c0e25352" target="_blank">step-by-step instructions</a> for creating a client application in their developer portal, however, the requirements boil down to:
</p><ol><li>Create an App ID that is configured for “Sign In with Apple”</li><li>Create a Service ID that is configured for “Sign In with Apple” (including a verified domain and redirect URIs)</li><li>Create a key that can be used by your created Service ID</li></ol><p>
Unfortunately, you can’t use localhost redirect URIs, but you can use dev domains such as <code>.test</code>.
In my example, I set my verified domain as <em>www.scottbrady91.com</em> and had my redirect URL as <em>http://local.test:5000/signin-apple</em> (with an associated host record on my machine).
</p><h3>ASP.NET Core Integration</h3><p>
We’ll start by adding cookie and OpenID Connect authentication handlers to our application, that will start by looking something like the following:
</p><pre><code class="language-csharp">services.AddAuthentication(options =&gt;
    {
        options.DefaultAuthenticateScheme = "cookie";
        options.DefaultChallengeScheme = "apple";
    })
    .AddCookie("cookie")
    .AddOpenIdConnect("apple", async options =&gt;
    {
        options.ResponseType = "code";
        options.SignInScheme = "cookie";
        options.Scope.Clear(); // otherwise I had consent request issues

        // TODO
    });</code></pre><p>
Not forgetting the call to <code>UseAuthentication</code> in your <code>Configure</code> method, and a route somewhere with an <code>AuthorizeAttribute</code> or a call to challenge.
</p><p>
We’re going to be using the authorization code flow, due to the lack of <code>c_hash</code> or PKCE support.
Becuase there is no <code>c_hash</code>, the existing ASP.NET Core OpenID Connect validation will not support the use of the hybrid flow, as it <a title="Microsoft.IdentityModel.Protocols.OpenIdConnect" href="https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Protocols.OpenIdConnect/OpenIdConnectProtocolValidator.cs#L516" target="_blank">requires this security check</a> when a <code>code</code> and <code>id_token</code> are received at the same time.
</p><p>
I’ve also cleared scopes for this example, due to an odd HTTP 500 error I would receive from Apple’s consent endpoint.
</p><p>
Since Apple doesn’t seem to have an OpenID Connect discovery document, we must configure some of the URLs ourselves by using properties in <code>OpenIdConnectConfiguration</code>:
</p><pre><code class="language-csharp">options.Configuration = new OpenIdConnectConfiguration
{
    AuthorizationEndpoint = "https://appleid.apple.com/auth/authorize",
    TokenEndpoint = "https://appleid.apple.com/auth/token",
};</code></pre><p>
The <code>client_id</code> will be the Service ID that was created for Sign In with Apple.
Our callback path must match a redirect URI configured in that Service.
</p><pre><code class="language-csharp">options.ClientId = "com.scottbrady91.authdemo.service"; // Service ID
options.CallbackPath = "/signin-apple"; // corresponding to your redirect URI</code></pre><p>
Now for our secret generation.
When we generate a key within the Apple developer portal, it is given to us as a <code>.p8</code> file.
Luckily, this is something we can read with relative ease, using the <code>CngKey</code> class.
</p><pre><code class="language-csharp">public static class TokenGenerator
{
    public static string CreateNewToken()
    {
        const string iss = "62QM29578N"; // your account's team ID found in the dev portal
        const string aud = "https://appleid.apple.com";
        const string sub = "com.scottbrady91.authdemo.service"; // same as client_id
        const string privateKey = "MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgnbfHJQO9feC7yKOenScNctvHUP+Hp3AdOKnjUC3Ee9GgCgYIKoZIzj0DAQehRANCAATMgckuqQ1MhKALhLT/CA9lZrLA+VqTW/iIJ9GKimtC2GP02hCc5Vac8WuN6YjynF3JPWKTYjg2zqex5Sdn9Wj+"; // contents of .p8 file
        
        var cngKey = CngKey.Import(
          Convert.FromBase64String(privateKey), 
          CngKeyBlobFormat.Pkcs8PrivateBlob);
        
        var handler = new JwtSecurityTokenHandler();
        var token = handler.CreateJwtSecurityToken(
            issuer: iss,
            audience: aud,
            subject: new ClaimsIdentity(new List&lt;Claim&gt; {new Claim("sub", sub)}),
            expires: DateTime.UtcNow.AddMinutes(5), // expiry can be a maximum of 6 months
            issuedAt: DateTime.UtcNow,
            notBefore: DateTime.UtcNow,
            signingCredentials: new SigningCredentials(
              new ECDsaSecurityKey(new ECDsaCng(cngKey)), SecurityAlgorithms.EcdsaSha256));

        return handler.WriteToken(token);
    }
}</code></pre><p>
Using this helper method, we can generate a new client secret per request via the <code>OnAuthorizationCodeReceived</code> event:
</p><pre><code class="language-csharp">options.Events.OnAuthorizationCodeReceived = context =&gt;
{
    context.TokenEndpointRequest.ClientSecret = TokenGenerator.CreateNewToken();
    return Task.CompletedTask;
};</code></pre><p>
Now that we have everything set up to get tokens, we need to be able to validate incoming identity tokens.
</p><p>
We can let the defaults handle things such as expiration validation and audience (client ID), but we’ll need to specify the issuer as <em>https://appleid.apple.com</em>.
</p><pre><code class="language-csharp">// Expected identity token iss value
options.TokenValidationParameters.ValidIssuer = "https://appleid.apple.com";</code></pre><p>
Next, we’ll need the public key that will be used to validate the signature of the token.
Thankfully, Apple does have a JWKS endpoint, found on <em>https://appleid.apple.com/auth/keys</em>.
Incoming identity tokens will be signed using RS256.
</p><pre><code class="language-csharp">// Expected identity token signing key
var jwks = await new HttpClient().GetStringAsync("https://appleid.apple.com/auth/keys");
options.TokenValidationParameters.IssuerSigningKey = new JsonWebKeySet(jwks).Keys.FirstOrDefault();</code></pre><p>
And finally, we need to disable nonce validation, as this is something that Apple does not support.
</p><pre><code class="language-csharp">// Disable nonce validation (not supported by Apple)
options.ProtocolValidator.RequireNonce = false;</code></pre><p>
You should now be able to login using Sign In with Apple.
</p><h2>Source Code <i class="fab fa-github"></i></h2><p>
You can find a working sample of this code <a title="GitHub: AspNetCore-SignInWithApple-Example" href="https://github.com/scottbrady91/AspNetCore-SignInWithApple-Example" target="_blank">on GitHub</a>. You’ll just need to provide your own Service ID, redirect URI, and signing key.
</p><h2>Further Reading</h2></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>