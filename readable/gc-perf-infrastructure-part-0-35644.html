<!DOCTYPE html>
<html lang="en">
<head>
    <title>
GC Perf Infrastructure &#x2013; Part 0 | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="GC Perf Infrastructure &#x2013; Part 0 | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Maoni StephensFollow Maoni"/>
    <meta property="og:description" content="In this blog entry and some future ones I will be showing off functionalities that our new GC perf infrastructure provides. Andy and I have been working on it (he did all the work; I merely played the consultant role). We will be open sourcing it soon and I wanted to give you some examples of using it and you can add these to your repertoire of perf analysis techniques when it&#x2019;s available."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/gc-perf-infrastructure-part-0/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - GC Perf Infrastructure &#x2013; Part 0 | .NET Blog</title>
<div class="readable">
        <h1>GC Perf Infrastructure &#x2013; Part 0 | .NET Blog</h1>
            <div>by Maoni StephensFollow Maoni</div>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 10 Sep 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/gc-perf-infrastructure-part-0/">https://devblogs.microsoft.com/dotnet/gc-perf-infrastructure-part-0/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/twitter-profile-150x150.jpg" width="58" height="58" alt="maoni"></p><p>Maoni</p></div></div></div><p>September 9th, 2019</p><p>In this blog entry and some future ones I will be showing off functionalities that our new GC perf infrastructure provides. <a href="https://github.com/andy-ms" target="_blank">Andy</a> and I have been working on it (he did all the work; I merely played the consultant role). We will be open sourcing it soon and I wanted to give you some examples of using it and you can add these to your repertoire of perf analysis techniques when it‚Äôs available.</p><p>The general GC perf analysis flow on a customer scenario usually goes like this ‚Äì</p><p>1) get a perf trace (ETW trace on Windows and event trace on Linux);</p><p>2A) if the customer has no complains and just wanted to see if they can improve things, we first get a general idea of things and see if/how they can be improved or</p><p>2B) if the customer does have specific complains (eg, long GC pauses, or too much memory used) we look for things that could cause them.</p><p>Of course, as any experienced perf person would know, perf analysis can vary greatly from one case to the next. You look at some data to get some clues to identify the suspicious areas and focus on those areas and get more clues‚Ä¶and usually make incremental progress before you get to the root cause.</p><p>To give some context, for data we get from trace, we have a library named <a href="https://github.com/microsoft/perfview/tree/master/src/TraceEvent" target="_blank">TraceEvent</a> that parses it into <a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L1723" target="_blank">TraceGC</a> objects. Since GC is per process, each process (that observed at least one GC) will get its list of these TraceGC objects. And the TraceGC type includes information on this GC such as</p><ul><li>Basic things which are read directly from some GC event‚Äôs fields like Number (index of this GC), Generation (which generation this GC collected), <a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L2354" target="_blank">PerHeapHistories</a> (which includes a lot of info such as what condemned reasons this heap incurred, the generation data for each generation for this heap)</li><li>Processed info like <a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L1787" target="_blank">PauseDurationMSec</a> (for ephemeral GCs this is the difference between the timestamp of the <a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L511" target="_blank">SuspendEEStart</a> event and the <a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L594" target="_blank">RestartEEStop</a> event);</li><li>Info that gets light up when you have the additional events, eg, <a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L1803" target="_blank">GCCpuMSec</a> if you have CPU samples collected in the trace;</li></ul><p>So given a basic GC trace there‚Äôs already a ton of info you can get. We do some processing in TraceEvent and a perf analysis means looking at info these TraceGC objects give you in really any number of ways.</p><p>If we have a big trace, the time that it took to parse the trace to get these TraceGC objects can be very long. And if I change my analysis code I‚Äôd have to start my analysis process again which means I‚Äôd have to parse the trace again. This seemed very inefficient. I started searching for options that could persist the TraceGC objects and I can just modify my code to consume them without having to reprocess the trace. And I found <a href="https://jupyter.org/" target="_blank">Jupyter Notebook</a> which allows you to edit python code in individual cells but the results from them persist in memory and can be used by any other cells. And I found <a href="https://github.com/pythonnet/pythonnet" target="_blank">pythonnet</a> which allows you to interop with a c# lib from python. This means I could persist the TraceGC objects in memory and edit the code that I want to look at any of these objects in any way I desire and don‚Äôt need to reprocess the trace at all. This along with the nice charting capability from python gave me exactly what I needed. So what I would do is to have one cell that just did the trace processing with all the resulting TraceGC objects, and other cells for various ways to look at info in these objects and edit them whenever I needed.</p><p>This was several years ago and I‚Äôve been using it since. When Andy joined the team and started working on a new GC perf infra I asked him to adapt this as part of our infra. And today I looked at a trace with him and below is what we did.</p><p>In this case I just got the trace from a customer to see if we can find anything can be improved by something the customer can do or we did but in a release the customer hasn‚Äôt upgraded to, or we are doing/planning to do. To start with, we looked at 3 metrics ‚Äì individual GC pause times (PauseDurationMSec), GC speed PromotedMBPerSec(ie, # of MB GC promoted / (PauseDurationMSec / 1000)) and&nbsp; heap size in MB after each GC (HeapSizeAfterMB), just to get a general idea. We used the histogram charts for these:</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/all-gcs-1.jpg" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/all-gcs-1.jpg" alt="" width="1037" height="657" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/all-gcs-1.jpg 1037w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/all-gcs-1-300x190.jpg 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/all-gcs-1-768x487.jpg 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/all-gcs-1-1024x649.jpg 1024w" sizes="(max-width: 1037px) 100vw, 1037px"> </a></p><p>*NGC means NonConcurrent GC, I didn‚Äôt want to call it BGC (Blocking GC) because we already have BGC mean Background GC.</p><p>If you look at the PauseDurationMSec charts for gen0 GCs (NGC0), gen1 GCs (NGC1) and BGCs (there were no full blocking GCs in this trace), most of them were in the range of a few to 20ms. But there are definitely some longer ones, eg some that are between 75 and 100ms in the NGC0 chart. And right off the bat we see some outliers for BGC ‚Äì most of them are &lt; 40ms but then there are some &gt; 100ms! And it‚Äôs hard to see on the charts but there are actually some thin blue lines in the &gt; 100ms range in both the NGC0 and NGC1 charts.</p><p>Since we are using Jupyter, we just changed the code in the cell for this and only showed GCs with the PauseDurationMSec &gt; 50ms and redrew the charts ‚Äì now it‚Äôs very clear there are some ephemeral GCs &gt; 100ms pauses and we can see the 1 long BGC pause is 114.2ms.</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/over50ms.jpg" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/over50ms.jpg" alt="" width="1037" height="656" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/over50ms.jpg 1037w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/over50ms-300x190.jpg 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/over50ms-768x486.jpg 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/over50ms-1024x648.jpg 1024w" sizes="(max-width: 1037px) 100vw, 1037px"> </a></p><p>And we can see the GC speed (the PromotedMBPerSec charts) for many of these are low. In the NGC0 chart most of the GCs are on the left hand side with the lowest speed.</p><p>If the long GCs‚Äôs PromotedMBPerSec was not so low it would mean they simply had a lot more memory to promote which would indicate a GC tuning problem ‚Äì one very likely reason would be we are not setting the allocation budgets correctly.</p><p>But since that‚Äôs not the case we wanted to see why these GC‚Äôs speed was so low ‚Äì we spent a long time paused but GC was not able to do work at its normal speed.</p><p>Let‚Äôs concentrate on the gen0 GCs (NGC0) first as a starting point. We know the way PauseDurationMSec is calculated so it consists of suspending EE (<a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L1791" target="_blank">SuspendDurationMSec</a>)+ actual GC work + resuming EE. Resuming the EE generally takes very little time so I‚Äôll not look at it first. I wanted to see if suspension was too long. So we looked at NGC0‚Äôs pause and suspension with our table printing function. Since it‚Äôs so easy we‚Äôll throw in the total promoted mb and the GC speed and let‚Äôs sort by PauseDurationMSec (highest first):</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart0.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart0.png" alt="" width="539" height="242" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart0.png 539w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart0-300x135.png 300w" sizes="(max-width: 539px) 100vw, 539px"> </a></p><p>‚Äúpause msec‚Äù is PauseDurationMSec.</p><p>‚Äúsuspend msec‚Äù is SuspendDurationMSec.</p><p>‚Äúpromoted mb‚Äù is PromotedMB for this GC.</p><p>(I‚Äôm only showing the top few for brevity)</p><p>Right away we see some long suspension times ‚Äì the GCs that took 156ms and 101ms, spent 95.4ms and 49.4ms in suspension respectively. So that definitely shows a suspension issue which means the suspension in EE had trouble suspending the managed threads. But the other GCs, like the longest one that took 187ms spent very little time in suspension.</p><p>We do have another field in the TraceGC class called <a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L1783" target="_blank">DurationMSec</a> which is the difference between the timestamp for the <a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L686" target="_blank">GCStart</a> event and the <a href="https://github.com/microsoft/perfview/blob/master/src/TraceEvent/Computers/TraceManagedProcess.cs#L1035" target="_blank">GCStop</a> event. From the first glance this should just be PauseDurationMSec ‚Äì suspending EE ‚Äì resuming EE. Almost ‚Äì there‚Äôs a bit of work we have to do between SuspendEEStop and GCStart, and between GCStop and RestartEEStart. So if things work as expected, (PauseDurationMSec ‚Äì DurationMSec) should be almost the same as (suspending EE + resuming EE). We changed the code again to add a DurationMSec column (‚Äúduration msec‚Äù) and we sort by that column</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart1.jpg" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart1.jpg" alt="" width="782" height="493" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart1.jpg 782w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart1-300x189.jpg 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart1-768x484.jpg 768w" sizes="(max-width: 782px) 100vw, 782px"> </a></p><p>The longest GC (187ms) has only 8.73ms DurationMSec! And Suspend only took 0.0544ms. So there‚Äôs a huge difference between PauseDurationMSec and DurationMSec, not accounted by the suspension cost.</p><p>We modified the code again to add a few more columns, mainly the ‚Äúpause to start‚Äù column which is the difference between the timestamp of SuspendEEStart and GCStart so it includes the suspension time. We also calculate a ‚Äúpause %‚Äù column which is (‚Äúsuspend msec‚Äù / ‚Äúpause to start‚Äù * 100) and a ‚Äúsuspend %‚Äù column which is (‚Äúsuspend msec‚Äù / ‚Äúpause msec‚Äù * 100). Also we changed the ‚Äúpromoted mb/sec‚Äù column to use DurationMSec instead of PauseDurationMSec. Now some rows in the table change very drastically. The table is sorted by the ‚Äúpause %‚Äù column.</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart2.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart2.png" alt="" width="1037" height="325" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart2.png 1037w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart2-300x94.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart2-768x241.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/chart2-1024x321.png 1024w" sizes="(max-width: 1037px) 100vw, 1037px"> </a></p><p>The GC that took 187ms spent 178ms from SuspendEEStart to GCStart!!! And of course the GC speed (promoted mb/sec) is now a lot higher.</p><p>This is enough evidence to tell us that the GC threads are getting severely interfered (suspension is not the only part that was affected), could be from other processes or other threads in this process. We‚Äôd need to collect more events to diagnose further.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>