<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Spying on&#xA0;.NET Garbage Collector with&#xA0;.NET Core EventPipes - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Spying on&#xA0;.NET Garbage Collector with&#xA0;.NET Core EventPipes - linksfor.dev(s)"/>
    <meta property="article:author" content="Christophe Nasarre"/>
    <meta property="og:description" content="This post shows how to use&#xA0;.NET Core EventPipes to build Garbage Collector logs. The emitted raw CLR events are described in details."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@chnasarre/spying-on-net-garbage-collector-with-net-core-eventpipes-9f2a986d5705"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Spying on&#xA0;.NET Garbage Collector with&#xA0;.NET Core EventPipes</title>
<div class="readable">
        <h1>Spying on&#xA0;.NET Garbage Collector with&#xA0;.NET Core EventPipes</h1>
            <div>by Christophe Nasarre</div>
            <div>Reading time: 8-11 minutes</div>
        <div>Posted here: 28 May 2019</div>
        <p><a href="https://medium.com/@chnasarre/spying-on-net-garbage-collector-with-net-core-eventpipes-9f2a986d5705">https://medium.com/@chnasarre/spying-on-net-garbage-collector-with-net-core-eventpipes-9f2a986d5705</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@chnasarre?source=post_page-----9f2a986d5705----------------------"><img alt="Christophe Nasarre" src="https://miro.medium.com/fit/c/96/96/0*p_afBNMUbL9S3Ojv" width="48" height="48"></a></p></div></div></div></div><p id="e5ad" data-selectable-paragraph="">This post of the series shows how to generate GC logs in .NET Core with the new event pipes architecture and details the events emitted by the CLR during a collection.</p><p id="67ff" data-selectable-paragraph="">Part 1: <a href="http://labs.criteo.com/2018/06/replace-net-performance-counters-by-clr-event-tracing" target="_blank" rel="noopener nofollow">Replace .NET performance counters by CLR event tracing</a>.</p><p id="959f" data-selectable-paragraph="">Part 2: <a href="http://labs.criteo.com/2018/07/grab-etw-session-providers-and-events/" target="_blank" rel="noopener nofollow">Grab ETW Session, Providers and Events</a>.</p><p id="86db" data-selectable-paragraph="">Part 3: CLR Threading events with TraceEvent.</p><p id="ef71" data-selectable-paragraph="">Part 4: <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/spying-on-net-garbage-collector-with-traceevent-f49dc3117de">Spying on .NET Garbage Collector with TraceEvent</a>.</p><p id="f4ab" data-selectable-paragraph="">Part 5: <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/c-building-your-own-java-like-gc-logs-in-net-992205fd8d4f">Building your own Java GC logs in .NET</a></p><p id="ba16" data-selectable-paragraph="">The previous episode of the series introduced the notion of “GC log”, well known in the Java world and how to implement it in .NET thanks to ETW and TraceEvent on Windows. This solution is easy but requires to create an ETW session (and to remember to close it)… and is also not supported on Linux. However, <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/c-in-process-clr-event-listeners-with-net-core-2-2-ef4075c14e87">.NET Core 2.2 introduced</a> the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventlistener?view=netcore-2.2" target="_blank" rel="noopener nofollow">EventListener class</a> as the best way to receive CLR events both on Windows and Linux but only from inside the process itself. As of today, TraceEvent is not supporting live session with EventPipe/EventListener, only <a href="https://github.com/Microsoft/perfview/blob/master/src/TraceEvent/EventPipe/EventPipeEventSource.cs#L28" target="_blank" rel="noopener nofollow">a file-based constructor is available</a>. This is unfortunate because it means that you can’t rely on the huge work done by TraceEvent to parse the CLR events; especially those related to garbage collections. The rest of the post will explain how to decipher raw events.</p><p id="ef00" data-selectable-paragraph="">In addition, there is a bigger problem: the current .NET Core 2.2 implementation is <a href="https://github.com/dotnet/coreclr/issues/21380" target="_blank" rel="noopener nofollow">not working for all CLR events</a>. Long story short, the <code>EventPipe</code> class relies on specific Thread Local Storage slot that is not set by GC background worker threads: the events are not emitted in that case. In addition, there is no per event timestamp information in 2.2. The implementation presented in this post relies on tests done with ETW traces and on the <a href="https://github.com/dotnet/coreclr/pull/21817" target="_blank" rel="noopener nofollow">Pull Request</a> that fixes the issue for .NET Core 3.0, available in Preview 5.</p><p id="175b" data-selectable-paragraph="">The previous posts of the series were based on C# events raised by the TraceEvent parser with names different from the original CLR events and the <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events" target="_blank" rel="noopener nofollow">corresponding Microsoft Docs</a>. When you implement your EventListener-derived class, each event is received as an <code>EventWrittenEventArgs</code> object in the <code>OnEventWritten</code> override. The <code>EventId</code> and <code>EventName</code> properties allow you to figure out which event is received. If you have worked with TraceEvent before, you might be using the <code>Opcode</code> property but even if a property with the same name exists in <code>EventWrittenEventArgs</code>, the value is completely different and should not be used.</p><p id="67a9" data-selectable-paragraph="">The CLR is versioning the emitted events to be able to add information over time. For example, the <code>EventId</code> of the “GCStart” event is 1 but the <code>EventName</code> could be <em>GCStart</em>, <em>GCStart_V1</em> or <em>GCStart_V2</em> even though the Microsoft Docs seems to be <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events#gcstart_v1_event" target="_blank" rel="noopener nofollow">stuck on version 1</a>. The following table lists the interesting GC events for .NET Core 2.2/3.0:</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*NFTfqDwPckWMA7Pjv9oX5A.png?q=20" width="1026" height="602" role="presentation"></p><p><img width="1026" height="602" role="presentation"></p></div></div></div></div></figure><p id="a30b" data-selectable-paragraph="">Look at <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events" target="_blank" rel="noopener nofollow">https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events</a> for the documentation related to each event.</p><p id="8e80" data-selectable-paragraph="">If you go back to <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/c-building-your-own-java-like-gc-logs-in-net-992205fd8d4f">this previous article</a> of the series, you notice that all details provided by the <code>TraceGC</code> argument are available except for the objects size before and after the collection. These values are embedded in the workload of the <em>GCPerHeapHistory</em> event by the GC code. Unfortunately, these details are not marshalled by the current <code>EventPipe</code> implementation to your <code>OnEventWritten</code> override (read <a href="https://github.com/dotnet/coreclr/issues/24506" target="_blank" rel="noopener nofollow">https://github.com/dotnet/coreclr/issues/24506</a> for more details and when it will be fixed).</p><p id="279b" data-selectable-paragraph="">There is no strongly typed <code>EventArgs</code> per event and you need to know the name of the field you are interested in to get its index. From this index, you get its corresponding value from the <code>Payload</code> property of the received <code>EventWrittenArgs</code>. The following helper method is doing the heavy lifting for you:</p><figure><div></div></figure><p id="98c2" data-selectable-paragraph="">Now that all interesting events are known, it is time to figure out what is the sequence of events emitted during a garbage collection: a new line with the details should be added to the GC log file when the last event is received.</p><p id="36d4" data-selectable-paragraph="">So let’s go back to the main phases of a garbage collection with the related CLR events as shown in the following figure (with <a href="https://twitter.com/konradkokosa" target="_blank" rel="noopener nofollow">Konrad Kokosa</a> courtesy from <a href="https://www.amazon.com/Pro-NET-Memory-Management-Performance/dp/148424026X" target="_blank" rel="noopener nofollow">his book</a>)</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*pNJJ5L4IlEaOsH6aHzQ4tQ.png?q=20" width="937" height="865" role="presentation"></p><p><img width="937" height="865" role="presentation"></p></div></div></div></div></figure><p id="0bd1" data-selectable-paragraph="">This is the expected events for the most complicated case: a background collection with possible foreground ephemeral (gen0 and gen1) collections while the GC threads are concurrently sweeping. However, it is not possible to rely on this specific order of events because the order changes, depending on workstation/background mode and generation 2/ephemeral. Each type of collection triggers events in different order as shown below:</p><figure><div><div><div><p><img src="https://miro.medium.com/max/56/1*wxICgleCgQgNQKQ7eBd8Zg.png?q=20" width="254" height="273" role="presentation"></p><p><img width="254" height="273" role="presentation"></p></div></div></div></figure><figure><div><div><div><p><img src="https://miro.medium.com/max/44/1*mV2osuRu1bwXSgppAvmhvQ.png?q=20" width="396" height="545" role="presentation"></p><p><img width="396" height="545" role="presentation"></p></div></div></div></figure><p id="3b30" data-selectable-paragraph="">Here is a more visual view of what could happen (dark blue is gen 2 and light blue are ephemeral gen0/1):</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/60/1*CJb-0oh4Z1vntA2JQpZsog.png?q=20" width="1433" height="682" role="presentation"></p><p><img width="1433" height="682" role="presentation"></p></div></div></div></div></figure><p id="c33c" data-selectable-paragraph="">The <strong>GCTriggered</strong> event notifies that a new collection will start except in the case of foreground ephemeral gen0/gen1 collections triggered during a background gen2. In that case, you could rely on the <strong>GCStart</strong> event and check if a background gen2 is running. This <strong>GCStart</strong> event provides the condemned generation in its <code>Depth</code> property. So I keep track of both the current background GC (if any) and the foreground GC (if any) in a <code>GCInfo</code> object:</p><figure><div></div></figure><p id="7b65" data-selectable-paragraph="">The <code>GCDetails</code> class keeps tracks of all the details gathered during a garbage collection:</p><figure><div></div></figure><p id="f6b4" data-selectable-paragraph="">The <code>HeapDetails</code> stores the size of each generation after a collection:</p><figure><div></div></figure><p id="ee53" data-selectable-paragraph="">The <code>GCDetails</code> instance is created when the <strong>GCStart</strong> event is received:</p><figure><div></div></figure><p id="9a3b" data-selectable-paragraph="">This is where it is important to remember if either a background or foreground GC is starting. In the former case, the <code>CurrentBGC</code> field is set and the <code>GCInProgress</code> field is set otherwise with a new <code>GCDetails</code> instance.</p><p id="be4a" data-selectable-paragraph="">That way, when either of <strong>GCGlobalHistory</strong> or <strong>GCHeapStarts</strong> is received, it is easy to know what is the GC in progress; i.e. if a foreground GC is in progress, an event happens in its context (until the last one <strong>GCHeapStats </strong>that will clean the <code>GCInProcess</code> field):</p><figure><div></div></figure><p id="a165" data-selectable-paragraph="">The suspension and pause time are not that complicated to compute. The garbage collector code is relying on the <code>SuspendEE</code> and <code>RestartEE</code> methods provided by the .NET Execution Engine to suspend and restart the application threads respectively. Each of these methods emits a pair of <strong>GCxxxBegin</strong> and <strong>GCxxxEnd</strong> events. After <strong>GCSuspendEEBegin</strong> is emitted, the Execution Engine waits for the application threads to suspend their execution. When all threads are suspended, <strong>GCSuspendEEEnd</strong> gets emitted.</p><p id="a7a5" data-selectable-paragraph="">The <strong>GCRestartEEBegin</strong> event is emitted when the applications threads begin to resume their execution. When all application threads are resumed, <strong>GCRestartEEEnd</strong> gets emitted. The elapsed time between the <strong>GCSuspendEEEnd</strong> and <strong>GCRestartEEBegin</strong> events is counted as <em>suspension time</em>. However, for simplicity sake, my current implementation sums both the time spent by the Execution Engine to suspend the threads and the pause time due to the GC work.</p><p id="67d7" data-selectable-paragraph="">The suspension start time is kept in <strong>GCInfo</strong>:</p><figure><div></div></figure><p id="e92c" data-selectable-paragraph="">It will be set when the <strong>GCSuspendEEBegin</strong> event is received:</p><figure><div></div></figure><p id="4a43" data-selectable-paragraph="">This implementation decision does not provide the same level of suspension details (no fine grain suspension time for inner foreground collections) as the one provided by the TraceEvent parsing.</p><p id="d753" data-selectable-paragraph="">The sibling <strong>GCRestartEEEnd</strong> event is used to (1) compute the total pause time and (2) detect when gen0/gen1/non concurrent gen2 collections end:</p><figure><div></div></figure><p id="82b0" data-selectable-paragraph="">As shown in the events workflow figure, the <strong>GCRestartEEBegin</strong>/<strong>GCRestartEEEnd</strong> duo of events are used to detect the end of non-concurrent gen0/1/2 collections. It is more complicated to detect the end of a gen2 background or inner ephemeral gen0/1 collections: <strong>GCGlobalHeapHistory</strong> for the former and <strong>GCHeapStats</strong> for the latter. However, these two events payload does not contain the piece of information to know if we are in a middle of a background gen 2 or not. With this details in mind, the code of the different event handlers is quite straightforward.</p><p id="8f34" data-selectable-paragraph="">The generations size are retrieved from the <strong>GCHeapStat</strong> event:</p><figure><div></div></figure><p id="6eb6" data-selectable-paragraph="">Remember this is the last event received for a gen0/gen1/foreground gen2 collection so I’m using it to clear the <code>GCInProgress</code> field: the next event will be for the current background gen2 if any (<code>CurrentBGC</code> field is not null) or a new collection.</p><p id="1d58" data-selectable-paragraph="">As of today with Preview 5, the before/after generation sizes are not marshalled through event pipes (see the <a href="https://github.com/dotnet/coreclr/issues/24506" target="_blank" rel="noopener nofollow">corresponding bug</a> for more details) so the <strong>GCPerHeapHistory </strong>event does not bring any value.</p><p id="10e2" data-selectable-paragraph="">The last <strong>GCGlobalHeapHistory</strong> event of background gen 2 collection is also used to detect compaction:</p><figure><div></div></figure><p id="a89b" data-selectable-paragraph="">In case of a background gen 2, this is the last event so there should not be any collection in progress:</p><figure><div></div></figure><p id="60a8" data-selectable-paragraph="">The next received event will start a new garbage collection cycle of events.</p><p id="e788" data-selectable-paragraph="">This post concludes the series about CLR events and how to use them to better understand how the runtime is behaving under the workloads of your applications. The code available on <a href="https://github.com/chrisnas/ClrEvents" target="_blank" rel="noopener nofollow">Github</a> has been updated to provide the <code>EventListenerGcLog</code> class that uses the code demonstrated in this post to generate GC logs with event pipes.</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>