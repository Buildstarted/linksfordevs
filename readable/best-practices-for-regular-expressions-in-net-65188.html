<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Best Practices for Regular Expressions in .NET - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Best Practices for Regular Expressions in .NET - linksfor.dev(s)"/>
    <meta property="article:author" content="adegeo"/>
    <meta property="og:description" content="Learn how to create efficient, effective regular expressions in .NET."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://docs.microsoft.com/en-us/dotnet/standard/base-types/best-practices"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Best Practices for Regular Expressions in .NET</title>
<div class="readable">
        <h1>Best Practices for Regular Expressions in .NET</h1>
            <div>by adegeo</div>
            <div>Reading time: 55-69 minutes</div>
        <div>Posted here: 04 Aug 2020</div>
        <p><a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/best-practices">https://docs.microsoft.com/en-us/dotnet/standard/base-types/best-practices</a></p>
        <hr/>
<div id="readability-page-1" class="page">


	<div data-bi-name="body">

		<div>

			

			<section>
				<div>


				<div id="main-column">

					<main id="main" role="main" data-bi-name="content" lang="en-us" dir="ltr">



						

						<ul data-bi-name="page info" lang="en-us" dir="ltr">
							<li>
								<time data-article-date="" aria-label="Article review date" datetime="2020-06-30T00:00:00.000Z" data-article-date-source="ms.date">06/30/2020</time>
							</li>
								<li>39 minutes to read</li>
								<li>
									<a href="https://github.com/dotnet/docs/blob/master/docs/standard/base-types/best-practices.md" title="15 Contributors" aria-label="15 Contributors">
										
									</a>
								</li>
						</ul>

						<nav id="center-doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">
							<h3>In this article</h3>
						<ol><li><a href="#consider-the-input-source">Consider the input source</a></li><li><a href="#handle-object-instantiation-appropriately">Handle object instantiation appropriately</a></li><li><a href="#take-charge-of-backtracking">Take charge of backtracking</a></li><li><a href="#use-time-out-values">Use time-out values</a></li><li><a href="#capture-only-when-necessary">Capture only when necessary</a></li><li><a href="#related-topics">Related topics</a></li></ol></nav>

						<!-- <content> -->
							<p>The regular expression engine in .NET is a powerful, full-featured tool that processes text based on pattern matches rather than on comparing and matching literal text. In most cases, it performs pattern matching rapidly and efficiently. However, in some cases, the regular expression engine can appear to be very slow. In extreme cases, it can even appear to stop responding as it processes a relatively small input over the course of hours or even days.</p>
<p>This topic outlines some of the best practices that developers can adopt to ensure that their regular expressions achieve optimal performance.</p>

<h2 id="consider-the-input-source"><a href="#consider-the-input-source" aria-labelledby="consider-the-input-source"></a>Consider the input source</h2>
<p>In general, regular expressions can accept two types of input: constrained or unconstrained. Constrained input is text that originates from a known or reliable source and follows a predefined format. Unconstrained input is text that originates from an unreliable source, such as a web user, and may not follow a predefined or expected format.</p>
<p>Regular expression patterns are typically written to match valid input. That is, developers examine the text that they want to match and then write a regular expression pattern that matches it. Developers then determine whether this pattern requires correction or further elaboration by testing it with multiple valid input items. When the pattern matches all presumed valid inputs, it is declared to be production-ready and can be included in a released application. This makes a regular expression pattern suitable for matching constrained input. However, it does not make it suitable for matching unconstrained input.</p>
<p>To match unconstrained input, a regular expression must be able to efficiently handle three kinds of text:</p>
<ul>
<li><p>Text that matches the regular expression pattern.</p>
</li>
<li><p>Text that does not match the regular expression pattern.</p>
</li>
<li><p>Text that nearly matches the regular expression pattern.</p>
</li>
</ul>
<p>The last text type is especially problematic for a regular expression that has been written to handle constrained input. If that regular expression also relies on extensive <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/backtracking-in-regular-expressions" data-linktype="relative-path">backtracking</a>, the regular expression engine can spend an inordinate amount of time (in some cases, many hours or days) processing seemingly innocuous text.</p>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>The following example uses a regular expression that is prone to excessive backtracking and that is likely to reject valid email addresses. You should not use it in an email validation routine. If you would like a regular expression that validates email addresses, see <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format" data-linktype="relative-path">How to: Verify that Strings Are in Valid Email Format</a>.</p>
</div>
<p>For example, consider a very commonly used but extremely problematic regular expression for validating the alias of an email address. The regular expression <code>^[0-9A-Z]([-.\w]*[0-9A-Z])*$</code> is written to process what is considered to be a valid email address, which consists of an alphanumeric character, followed by zero or more characters that can be alphanumeric, periods, or hyphens. The regular expression must end with an alphanumeric character. However, as the following example shows, although this regular expression handles valid input easily, its performance is very inefficient when it is processing nearly valid input.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#1" data-author-content="using System;
using System.Diagnostics;
using System.Text.RegularExpressions;

public class Example
{
   public static void Main()
   {
      Stopwatch sw;
      string[] addresses = { &quot;AAAAAAAAAAA@contoso.com&quot;,
                             &quot;AAAAAAAAAAaaaaaaaaaa!@contoso.com&quot; };
      // The following regular expression should not actually be used to
      // validate an email address.
      string pattern = @&quot;^[0-9A-Z]([-.\w]*[0-9A-Z])*$&quot;;
      string input;

      foreach (var address in addresses) {
         string mailBox = address.Substring(0, address.IndexOf(&quot;@&quot;));
         int index = 0;
         for (int ctr = mailBox.Length - 1; ctr >= 0; ctr--) {
            index++;

            input = mailBox.Substring(ctr, index);
            sw = Stopwatch.StartNew();
            Match m = Regex.Match(input, pattern, RegexOptions.IgnoreCase);
            sw.Stop();
            if (m.Success)
               Console.WriteLine(&quot;{0,2}. Matched '{1,25}' in {2}&quot;,
                                 index, m.Value, sw.Elapsed);
            else
               Console.WriteLine(&quot;{0,2}. Failed  '{1,25}' in {2}&quot;,
                                 index, input, sw.Elapsed);
         }
         Console.WriteLine();
      }
   }
}

// The example displays output similar to the following:
//     1. Matched '                        A' in 00:00:00.0007122
//     2. Matched '                       AA' in 00:00:00.0000282
//     3. Matched '                      AAA' in 00:00:00.0000042
//     4. Matched '                     AAAA' in 00:00:00.0000038
//     5. Matched '                    AAAAA' in 00:00:00.0000042
//     6. Matched '                   AAAAAA' in 00:00:00.0000042
//     7. Matched '                  AAAAAAA' in 00:00:00.0000042
//     8. Matched '                 AAAAAAAA' in 00:00:00.0000087
//     9. Matched '                AAAAAAAAA' in 00:00:00.0000045
//    10. Matched '               AAAAAAAAAA' in 00:00:00.0000045
//    11. Matched '              AAAAAAAAAAA' in 00:00:00.0000045
//
//     1. Failed  '                        !' in 00:00:00.0000447
//     2. Failed  '                       a!' in 00:00:00.0000071
//     3. Failed  '                      aa!' in 00:00:00.0000071
//     4. Failed  '                     aaa!' in 00:00:00.0000061
//     5. Failed  '                    aaaa!' in 00:00:00.0000081
//     6. Failed  '                   aaaaa!' in 00:00:00.0000126
//     7. Failed  '                  aaaaaa!' in 00:00:00.0000359
//     8. Failed  '                 aaaaaaa!' in 00:00:00.0000414
//     9. Failed  '                aaaaaaaa!' in 00:00:00.0000758
//    10. Failed  '               aaaaaaaaa!' in 00:00:00.0001462
//    11. Failed  '              aaaaaaaaaa!' in 00:00:00.0002885
//    12. Failed  '             Aaaaaaaaaaa!' in 00:00:00.0005780
//    13. Failed  '            AAaaaaaaaaaa!' in 00:00:00.0011628
//    14. Failed  '           AAAaaaaaaaaaa!' in 00:00:00.0022851
//    15. Failed  '          AAAAaaaaaaaaaa!' in 00:00:00.0045864
//    16. Failed  '         AAAAAaaaaaaaaaa!' in 00:00:00.0093168
//    17. Failed  '        AAAAAAaaaaaaaaaa!' in 00:00:00.0185993
//    18. Failed  '       AAAAAAAaaaaaaaaaa!' in 00:00:00.0366723
//    19. Failed  '      AAAAAAAAaaaaaaaaaa!' in 00:00:00.1370108
//    20. Failed  '     AAAAAAAAAaaaaaaaaaa!' in 00:00:00.1553966
//    21. Failed  '    AAAAAAAAAAaaaaaaaaaa!' in 00:00:00.3223372
"><span><span>using</span> System;
<span>using</span> System.Diagnostics;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>Example</span>
{
   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span></span>)</span>
   {
      Stopwatch sw;
      <span>string</span>[] addresses = { <span>"AAAAAAAAAAA@contoso.com"</span>,
                             <span>"AAAAAAAAAAaaaaaaaaaa!@contoso.com"</span> };
      <span>// The following regular expression should not actually be used to</span>
      <span>// validate an email address.</span>
      <span>string</span> pattern = <span>@"^[0-9A-Z]([-.\w]*[0-9A-Z])*$"</span>;
      <span>string</span> input;

      <span>foreach</span> (<span>var</span> address <span>in</span> addresses) {
         <span>string</span> mailBox = address.Substring(<span>0</span>, address.IndexOf(<span>"@"</span>));
         <span>int</span> index = <span>0</span>;
         <span>for</span> (<span>int</span> ctr = mailBox.Length - <span>1</span>; ctr &gt;= <span>0</span>; ctr--) {
            index++;

            input = mailBox.Substring(ctr, index);
            sw = Stopwatch.StartNew();
            Match m = Regex.Match(input, pattern, RegexOptions.IgnoreCase);
            sw.Stop();
            <span>if</span> (m.Success)
               Console.WriteLine(<span>"{0,2}. Matched '{1,25}' in {2}"</span>,
                                 index, m.Value, sw.Elapsed);
            <span>else</span>
               Console.WriteLine(<span>"{0,2}. Failed  '{1,25}' in {2}"</span>,
                                 index, input, sw.Elapsed);
         }
         Console.WriteLine();
      }
   }
}

<span>// The example displays output similar to the following:</span>
<span>//     1. Matched '                        A' in 00:00:00.0007122</span>
<span>//     2. Matched '                       AA' in 00:00:00.0000282</span>
<span>//     3. Matched '                      AAA' in 00:00:00.0000042</span>
<span>//     4. Matched '                     AAAA' in 00:00:00.0000038</span>
<span>//     5. Matched '                    AAAAA' in 00:00:00.0000042</span>
<span>//     6. Matched '                   AAAAAA' in 00:00:00.0000042</span>
<span>//     7. Matched '                  AAAAAAA' in 00:00:00.0000042</span>
<span>//     8. Matched '                 AAAAAAAA' in 00:00:00.0000087</span>
<span>//     9. Matched '                AAAAAAAAA' in 00:00:00.0000045</span>
<span>//    10. Matched '               AAAAAAAAAA' in 00:00:00.0000045</span>
<span>//    11. Matched '              AAAAAAAAAAA' in 00:00:00.0000045</span>
<span>//</span>
<span>//     1. Failed  '                        !' in 00:00:00.0000447</span>
<span>//     2. Failed  '                       a!' in 00:00:00.0000071</span>
<span>//     3. Failed  '                      aa!' in 00:00:00.0000071</span>
<span>//     4. Failed  '                     aaa!' in 00:00:00.0000061</span>
<span>//     5. Failed  '                    aaaa!' in 00:00:00.0000081</span>
<span>//     6. Failed  '                   aaaaa!' in 00:00:00.0000126</span>
<span>//     7. Failed  '                  aaaaaa!' in 00:00:00.0000359</span>
<span>//     8. Failed  '                 aaaaaaa!' in 00:00:00.0000414</span>
<span>//     9. Failed  '                aaaaaaaa!' in 00:00:00.0000758</span>
<span>//    10. Failed  '               aaaaaaaaa!' in 00:00:00.0001462</span>
<span>//    11. Failed  '              aaaaaaaaaa!' in 00:00:00.0002885</span>
<span>//    12. Failed  '             Aaaaaaaaaaa!' in 00:00:00.0005780</span>
<span>//    13. Failed  '            AAaaaaaaaaaa!' in 00:00:00.0011628</span>
<span>//    14. Failed  '           AAAaaaaaaaaaa!' in 00:00:00.0022851</span>
<span>//    15. Failed  '          AAAAaaaaaaaaaa!' in 00:00:00.0045864</span>
<span>//    16. Failed  '         AAAAAaaaaaaaaaa!' in 00:00:00.0093168</span>
<span>//    17. Failed  '        AAAAAAaaaaaaaaaa!' in 00:00:00.0185993</span>
<span>//    18. Failed  '       AAAAAAAaaaaaaaaaa!' in 00:00:00.0366723</span>
<span>//    19. Failed  '      AAAAAAAAaaaaaaaaaa!' in 00:00:00.1370108</span>
<span>//    20. Failed  '     AAAAAAAAAaaaaaaaaaa!' in 00:00:00.1553966</span>
<span>//    21. Failed  '    AAAAAAAAAAaaaaaaaaaa!' in 00:00:00.3223372</span>
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#1" data-author-content="Imports System.Diagnostics
Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim sw As Stopwatch
        Dim addresses() As String = {&quot;AAAAAAAAAAA@contoso.com&quot;,
                                   &quot;AAAAAAAAAAaaaaaaaaaa!@contoso.com&quot;}
        ' The following regular expression should not actually be used to 
        ' validate an email address.
        Dim pattern As String = &quot;^[0-9A-Z]([-.\w]*[0-9A-Z])*$&quot;
        Dim input As String

        For Each address In addresses
            Dim mailBox As String = address.Substring(0, address.IndexOf(&quot;@&quot;))
            Dim index As Integer = 0
            For ctr As Integer = mailBox.Length - 1 To 0 Step -1
                index += 1
                input = mailBox.Substring(ctr, index)
                sw = Stopwatch.StartNew()
                Dim m As Match = Regex.Match(input, pattern, RegexOptions.IgnoreCase)
                sw.Stop()
                if m.Success Then
                    Console.WriteLine(&quot;{0,2}. Matched '{1,25}' in {2}&quot;,
                                      index, m.Value, sw.Elapsed)
                Else
                    Console.WriteLine(&quot;{0,2}. Failed  '{1,25}' in {2}&quot;,
                                      index, input, sw.Elapsed)
                End If
            Next
            Console.WriteLine()
        Next
    End Sub
End Module
' The example displays output similar to the following:
'     1. Matched '                        A' in 00:00:00.0007122
'     2. Matched '                       AA' in 00:00:00.0000282
'     3. Matched '                      AAA' in 00:00:00.0000042
'     4. Matched '                     AAAA' in 00:00:00.0000038
'     5. Matched '                    AAAAA' in 00:00:00.0000042
'     6. Matched '                   AAAAAA' in 00:00:00.0000042
'     7. Matched '                  AAAAAAA' in 00:00:00.0000042
'     8. Matched '                 AAAAAAAA' in 00:00:00.0000087
'     9. Matched '                AAAAAAAAA' in 00:00:00.0000045
'    10. Matched '               AAAAAAAAAA' in 00:00:00.0000045
'    11. Matched '              AAAAAAAAAAA' in 00:00:00.0000045
'    
'     1. Failed  '                        !' in 00:00:00.0000447
'     2. Failed  '                       a!' in 00:00:00.0000071
'     3. Failed  '                      aa!' in 00:00:00.0000071
'     4. Failed  '                     aaa!' in 00:00:00.0000061
'     5. Failed  '                    aaaa!' in 00:00:00.0000081
'     6. Failed  '                   aaaaa!' in 00:00:00.0000126
'     7. Failed  '                  aaaaaa!' in 00:00:00.0000359
'     8. Failed  '                 aaaaaaa!' in 00:00:00.0000414
'     9. Failed  '                aaaaaaaa!' in 00:00:00.0000758
'    10. Failed  '               aaaaaaaaa!' in 00:00:00.0001462
'    11. Failed  '              aaaaaaaaaa!' in 00:00:00.0002885
'    12. Failed  '             Aaaaaaaaaaa!' in 00:00:00.0005780
'    13. Failed  '            AAaaaaaaaaaa!' in 00:00:00.0011628
'    14. Failed  '           AAAaaaaaaaaaa!' in 00:00:00.0022851
'    15. Failed  '          AAAAaaaaaaaaaa!' in 00:00:00.0045864
'    16. Failed  '         AAAAAaaaaaaaaaa!' in 00:00:00.0093168
'    17. Failed  '        AAAAAAaaaaaaaaaa!' in 00:00:00.0185993
'    18. Failed  '       AAAAAAAaaaaaaaaaa!' in 00:00:00.0366723
'    19. Failed  '      AAAAAAAAaaaaaaaaaa!' in 00:00:00.1370108
'    20. Failed  '     AAAAAAAAAaaaaaaaaaa!' in 00:00:00.1553966
'    21. Failed  '    AAAAAAAAAAaaaaaaaaaa!' in 00:00:00.3223372
">Imports System.Diagnostics
Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim sw As Stopwatch
        Dim addresses() As String = {"AAAAAAAAAAA@contoso.com",
                                   "AAAAAAAAAAaaaaaaaaaa!@contoso.com"}
        ' The following regular expression should not actually be used to 
        ' validate an email address.
        Dim pattern As String = "^[0-9A-Z]([-.\w]*[0-9A-Z])*$"
        Dim input As String

        For Each address In addresses
            Dim mailBox As String = address.Substring(0, address.IndexOf("@"))
            Dim index As Integer = 0
            For ctr As Integer = mailBox.Length - 1 To 0 Step -1
                index += 1
                input = mailBox.Substring(ctr, index)
                sw = Stopwatch.StartNew()
                Dim m As Match = Regex.Match(input, pattern, RegexOptions.IgnoreCase)
                sw.Stop()
                if m.Success Then
                    Console.WriteLine("{0,2}. Matched '{1,25}' in {2}",
                                      index, m.Value, sw.Elapsed)
                Else
                    Console.WriteLine("{0,2}. Failed  '{1,25}' in {2}",
                                      index, input, sw.Elapsed)
                End If
            Next
            Console.WriteLine()
        Next
    End Sub
End Module
' The example displays output similar to the following:
'     1. Matched '                        A' in 00:00:00.0007122
'     2. Matched '                       AA' in 00:00:00.0000282
'     3. Matched '                      AAA' in 00:00:00.0000042
'     4. Matched '                     AAAA' in 00:00:00.0000038
'     5. Matched '                    AAAAA' in 00:00:00.0000042
'     6. Matched '                   AAAAAA' in 00:00:00.0000042
'     7. Matched '                  AAAAAAA' in 00:00:00.0000042
'     8. Matched '                 AAAAAAAA' in 00:00:00.0000087
'     9. Matched '                AAAAAAAAA' in 00:00:00.0000045
'    10. Matched '               AAAAAAAAAA' in 00:00:00.0000045
'    11. Matched '              AAAAAAAAAAA' in 00:00:00.0000045
'    
'     1. Failed  '                        !' in 00:00:00.0000447
'     2. Failed  '                       a!' in 00:00:00.0000071
'     3. Failed  '                      aa!' in 00:00:00.0000071
'     4. Failed  '                     aaa!' in 00:00:00.0000061
'     5. Failed  '                    aaaa!' in 00:00:00.0000081
'     6. Failed  '                   aaaaa!' in 00:00:00.0000126
'     7. Failed  '                  aaaaaa!' in 00:00:00.0000359
'     8. Failed  '                 aaaaaaa!' in 00:00:00.0000414
'     9. Failed  '                aaaaaaaa!' in 00:00:00.0000758
'    10. Failed  '               aaaaaaaaa!' in 00:00:00.0001462
'    11. Failed  '              aaaaaaaaaa!' in 00:00:00.0002885
'    12. Failed  '             Aaaaaaaaaaa!' in 00:00:00.0005780
'    13. Failed  '            AAaaaaaaaaaa!' in 00:00:00.0011628
'    14. Failed  '           AAAaaaaaaaaaa!' in 00:00:00.0022851
'    15. Failed  '          AAAAaaaaaaaaaa!' in 00:00:00.0045864
'    16. Failed  '         AAAAAaaaaaaaaaa!' in 00:00:00.0093168
'    17. Failed  '        AAAAAAaaaaaaaaaa!' in 00:00:00.0185993
'    18. Failed  '       AAAAAAAaaaaaaaaaa!' in 00:00:00.0366723
'    19. Failed  '      AAAAAAAAaaaaaaaaaa!' in 00:00:00.1370108
'    20. Failed  '     AAAAAAAAAaaaaaaaaaa!' in 00:00:00.1553966
'    21. Failed  '    AAAAAAAAAAaaaaaaaaaa!' in 00:00:00.3223372
</code></pre>
<p>As the output from the example shows, the regular expression engine processes the valid email alias in about the same time interval regardless of its length. On the other hand, when the nearly valid email address has more than five characters, processing time approximately doubles for each additional character in the string. This means that a nearly valid 28-character string would take over an hour to process, and a nearly valid 33-character string would take nearly a day to process.</p>
<p>Because this regular expression was developed solely by considering the format of input to be matched, it fails to take account of input that does not match the pattern. This, in turn, can allow unconstrained input that nearly matches the regular expression pattern to significantly degrade performance.</p>
<p>To solve this problem, you can do the following:</p>
<ul>
<li><p>When developing a pattern, you should consider how backtracking might affect the performance of the regular expression engine, particularly if your regular expression is designed to process unconstrained input. For more information, see the <a href="#take-charge-of-backtracking" data-linktype="self-bookmark">Take Charge of Backtracking</a> section.</p>
</li>
<li><p>Thoroughly test your regular expression using invalid and near-valid input as well as valid input. To generate input for a particular regular expression randomly, you can use <a href="https://www.microsoft.com/research/project/rex-regular-expression-exploration/" data-linktype="external">Rex</a>, which is a regular expression exploration tool from Microsoft Research.</p>
</li>
</ul>
<h2 id="handle-object-instantiation-appropriately"><a href="#handle-object-instantiation-appropriately" aria-labelledby="handle-object-instantiation-appropriately"></a>Handle object instantiation appropriately</h2>
<p>At the heart of .NETâ€™s regular expression object model is the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">System.Text.RegularExpressions.Regex</a> class, which represents the regular expression engine. Often, the single greatest factor that affects regular expression performance is the way in which the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> engine is used. Defining a regular expression involves tightly coupling the regular expression engine with a regular expression pattern. That coupling process, whether it involves instantiating a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object by passing its constructor a regular expression pattern or calling a static method by passing it the regular expression pattern along with the string to be analyzed, is by necessity an expensive one.</p>

<p>You can couple the regular expression engine with a particular regular expression pattern and then use the engine to match text in several ways:</p>
<ul>
<li><p>You can call a static pattern-matching method, such as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.match#System_Text_RegularExpressions_Regex_Match_System_String_System_String_" data-linktype="absolute-path">Regex.Match(String, String)</a>. This does not require instantiation of a regular expression object.</p>
</li>
<li><p>You can instantiate a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object and call an instance pattern-matching method of an interpreted regular expression. This is the default method for binding the regular expression engine to a regular expression pattern. It results when a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object is instantiated without an <code>options</code> argument that includes the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions#System_Text_RegularExpressions_RegexOptions_Compiled" data-linktype="absolute-path">Compiled</a> flag.</p>
</li>
<li><p>You can instantiate a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object and call an instance pattern-matching method of a compiled regular expression. Regular expression objects represent compiled patterns when a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object is instantiated with an <code>options</code> argument that includes the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions#System_Text_RegularExpressions_RegexOptions_Compiled" data-linktype="absolute-path">Compiled</a> flag.</p>
</li>
<li><p>You can create a special-purpose <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object that is tightly coupled with a particular regular expression pattern, compile it, and save it to a standalone assembly. You do this by calling the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.compiletoassembly" data-linktype="absolute-path">Regex.CompileToAssembly</a> method.</p>
</li>
</ul>
<p>The particular way in which you call regular expression matching methods can have a significant impact on your application. The following sections discuss when to use static method calls, interpreted regular expressions, and compiled regular expressions to improve your application's performance.</p>
<div>
<p><span aria-hidden="true"></span> Important</p>
<p>The form of the method call (static, interpreted, compiled) affects performance if the same regular expression is used repeatedly in method calls, or if an application makes extensive use of regular expression objects.</p>
</div>
<h3 id="static-regular-expressions"><a href="#static-regular-expressions" aria-labelledby="static-regular-expressions"></a>Static regular expressions</h3>
<p>Static regular expression methods are recommended as an alternative to repeatedly instantiating a regular expression object with the same regular expression. Unlike regular expression patterns used by regular expression objects, either the operation codes or the compiled Microsoft intermediate language (MSIL) from patterns used in static method calls is cached internally by the regular expression engine.</p>
<p>For example, an event handler frequently calls another method to validate user input. This is reflected in the following code, in which a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.button" data-linktype="absolute-path">Button</a> control's <a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.forms.control.click" data-linktype="absolute-path">Click</a> event is used to call a method named <code>IsValidCurrency</code>, which checks whether the user has entered a currency symbol followed by at least one decimal digit.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#2" data-author-content="public void OKButton_Click(object sender, EventArgs e)
{
   if (! String.IsNullOrEmpty(sourceCurrency.Text))
      if (RegexLib.IsValidCurrency(sourceCurrency.Text))
         PerformConversion();
      else
         status.Text = &quot;The source currency value is invalid.&quot;;
}
"><span><span><span>public</span> <span>void</span> <span>OKButton_Click</span>(<span><span>object</span> sender, EventArgs e</span>)</span>
{
   <span>if</span> (! String.IsNullOrEmpty(sourceCurrency.Text))
      <span>if</span> (RegexLib.IsValidCurrency(sourceCurrency.Text))
         PerformConversion();
      <span>else</span>
         status.Text = <span>"The source currency value is invalid."</span>;
}
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#2" data-author-content="Public Sub OKButton_Click(sender As Object, e As EventArgs) _
           Handles OKButton.Click

    If Not String.IsNullOrEmpty(sourceCurrency.Text) Then
        If RegexLib.IsValidCurrency(sourceCurrency.Text) Then
            PerformConversion()
        Else
            status.Text = &quot;The source currency value is invalid.&quot;
        End If
    End If
End Sub
">Public Sub OKButton_Click(sender As Object, e As EventArgs) _
           Handles OKButton.Click

    If Not String.IsNullOrEmpty(sourceCurrency.Text) Then
        If RegexLib.IsValidCurrency(sourceCurrency.Text) Then
            PerformConversion()
        Else
            status.Text = "The source currency value is invalid."
        End If
    End If
End Sub
</code></pre>
<p>A very inefficient implementation of the <code>IsValidCurrency</code> method is shown in the following example. Note that each method call reinstantiates a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object with the same pattern. This, in turn, means that the regular expression pattern must be recompiled each time the method is called.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#3" data-author-content="using System;
using System.Text.RegularExpressions;

public class RegexLib
{
   public static bool IsValidCurrency(string currencyValue)
   {
      string pattern = @&quot;\p{Sc}+\s*\d+&quot;;
      Regex currencyRegex = new Regex(pattern);
      return currencyRegex.IsMatch(currencyValue);
   }
}
"><span><span>using</span> System;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>RegexLib</span>
{
   <span><span>public</span> <span>static</span> <span>bool</span> <span>IsValidCurrency</span>(<span><span>string</span> currencyValue</span>)</span>
   {
      <span>string</span> pattern = <span>@"\p{Sc}+\s*\d+"</span>;
      Regex currencyRegex = <span>new</span> Regex(pattern);
      <span>return</span> currencyRegex.IsMatch(currencyValue);
   }
}
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#3" data-author-content="Imports System.Text.RegularExpressions

Public Module RegexLib
    Public Function IsValidCurrency(currencyValue As String) As Boolean
        Dim pattern As String = &quot;\p{Sc}+\s*\d+&quot;
        Dim currencyRegex As New Regex(pattern)
        Return currencyRegex.IsMatch(currencyValue)
    End Function
End Module
">Imports System.Text.RegularExpressions

Public Module RegexLib
    Public Function IsValidCurrency(currencyValue As String) As Boolean
        Dim pattern As String = "\p{Sc}+\s*\d+"
        Dim currencyRegex As New Regex(pattern)
        Return currencyRegex.IsMatch(currencyValue)
    End Function
End Module
</code></pre>
<p>You should replace this inefficient code with a call to the static <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.ismatch#System_Text_RegularExpressions_Regex_IsMatch_System_String_System_String_" data-linktype="absolute-path">Regex.IsMatch(String, String)</a> method. This eliminates the need to instantiate a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object each time you want to call a pattern-matching method, and enables the regular expression engine to retrieve a compiled version of the regular expression from its cache.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#4" data-author-content="using System;
using System.Text.RegularExpressions;

public class RegexLib
{
   public static bool IsValidCurrency(string currencyValue)
   {
      string pattern = @&quot;\p{Sc}+\s*\d+&quot;;
      return Regex.IsMatch(currencyValue, pattern);
   }
}
"><span><span>using</span> System;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>RegexLib</span>
{
   <span><span>public</span> <span>static</span> <span>bool</span> <span>IsValidCurrency</span>(<span><span>string</span> currencyValue</span>)</span>
   {
      <span>string</span> pattern = <span>@"\p{Sc}+\s*\d+"</span>;
      <span>return</span> Regex.IsMatch(currencyValue, pattern);
   }
}
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#4" data-author-content="Imports System.Text.RegularExpressions

Public Module RegexLib
    Public Function IsValidCurrency(currencyValue As String) As Boolean
        Dim pattern As String = &quot;\p{Sc}+\s*\d+&quot;
        Return Regex.IsMatch(currencyValue, pattern)
    End Function
End Module
">Imports System.Text.RegularExpressions

Public Module RegexLib
    Public Function IsValidCurrency(currencyValue As String) As Boolean
        Dim pattern As String = "\p{Sc}+\s*\d+"
        Return Regex.IsMatch(currencyValue, pattern)
    End Function
End Module
</code></pre>
<p>By default, the last 15 most recently used static regular expression patterns are cached. For applications that require a larger number of cached static regular expressions, the size of the cache can be adjusted by setting the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.cachesize" data-linktype="absolute-path">Regex.CacheSize</a> property.</p>
<p>The regular expression <code>\p{Sc}+\s*\d+</code> that is used in this example verifies that the input string consists of a currency symbol and at least one decimal digit. The pattern is defined as shown in the following table.</p>

<h3 id="interpreted-vs-compiled-regular-expressions"><a href="#interpreted-vs-compiled-regular-expressions" aria-labelledby="interpreted-vs-compiled-regular-expressions"></a>Interpreted vs. compiled regular expressions</h3>
<p>Regular expression patterns that are not bound to the regular expression engine through the specification of the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions#System_Text_RegularExpressions_RegexOptions_Compiled" data-linktype="absolute-path">Compiled</a> option are interpreted. When a regular expression object is instantiated, the regular expression engine converts the regular expression to a set of operation codes. When an instance method is called, the operation codes are converted to MSIL and executed by the JIT compiler. Similarly, when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to a set of operation codes and stores them in the cache. It then converts these operation codes to MSIL so that the JIT compiler can execute them. Interpreted regular expressions reduce startup time at the cost of slower execution time. Because of this, they are best used when the regular expression is used in a small number of method calls, or if the exact number of calls to regular expression methods is unknown but is expected to be small. As the number of method calls increases, the performance gain from reduced startup time is outstripped by the slower execution speed.</p>
<p>Regular expression patterns that are bound to the regular expression engine through the specification of the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions#System_Text_RegularExpressions_RegexOptions_Compiled" data-linktype="absolute-path">Compiled</a> option are compiled. This means that, when a regular expression object is instantiated, or when a static regular expression method is called and the regular expression cannot be found in the cache, the regular expression engine converts the regular expression to an intermediary set of operation codes, which it then converts to MSIL. When a method is called, the JIT compiler executes the MSIL. In contrast to interpreted regular expressions, compiled regular expressions increase startup time but execute individual pattern-matching methods faster. As a result, the performance benefit that results from compiling the regular expression increases in proportion to the number of regular expression methods called.</p>
<p>To summarize, we recommend that you use interpreted regular expressions when you call regular expression methods with a specific regular expression relatively infrequently. You should use compiled regular expressions when you call regular expression methods with a specific regular expression relatively frequently. The exact threshold at which the slower execution speeds of interpreted regular expressions outweigh gains from their reduced startup time, or the threshold at which the slower startup times of compiled regular expressions outweigh gains from their faster execution speeds, is difficult to determine. It depends on a variety of factors, including the complexity of the regular expression and the specific data that it processes. To determine whether interpreted or compiled regular expressions offer the best performance for your particular application scenario, you can use the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.stopwatch" data-linktype="absolute-path">Stopwatch</a> class to compare their execution times.</p>
<p>The following example compares the performance of compiled and interpreted regular expressions when reading the first ten sentences and when reading all the sentences in the text of Theodore Dreiser's <em>The Financier</em>. As the output from the example shows, when only ten calls are made to regular expression matching methods, an interpreted regular expression offers better performance than a compiled regular expression. However, a compiled regular expression offers better performance when a large number of calls (in this case, over 13,000) are made.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#5" data-author-content="using System;
using System.Diagnostics;
using System.IO;
using System.Text.RegularExpressions;

public class Example
{
   public static void Main()
   {
      string pattern = @&quot;\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]&quot;;
      Stopwatch sw;
      Match match;
      int ctr;

      StreamReader inFile = new StreamReader(@&quot;.\Dreiser_TheFinancier.txt&quot;);
      string input = inFile.ReadToEnd();
      inFile.Close();

      // Read first ten sentences with interpreted regex.
      Console.WriteLine(&quot;10 Sentences with Interpreted Regex:&quot;);
      sw = Stopwatch.StartNew();
      Regex int10 = new Regex(pattern, RegexOptions.Singleline);
      match = int10.Match(input);
      for (ctr = 0; ctr <= 9; ctr++) {
         if (match.Success)
            // Do nothing with the match except get the next match.
            match = match.NextMatch();
         else
            break;
      }
      sw.Stop();
      Console.WriteLine(&quot;   {0} matches in {1}&quot;, ctr, sw.Elapsed);

      // Read first ten sentences with compiled regex.
      Console.WriteLine(&quot;10 Sentences with Compiled Regex:&quot;);
      sw = Stopwatch.StartNew();
      Regex comp10 = new Regex(pattern,
                   RegexOptions.Singleline | RegexOptions.Compiled);
      match = comp10.Match(input);
      for (ctr = 0; ctr <= 9; ctr++) {
         if (match.Success)
            // Do nothing with the match except get the next match.
            match = match.NextMatch();
         else
            break;
      }
      sw.Stop();
      Console.WriteLine(&quot;   {0} matches in {1}&quot;, ctr, sw.Elapsed);

      // Read all sentences with interpreted regex.
      Console.WriteLine(&quot;All Sentences with Interpreted Regex:&quot;);
      sw = Stopwatch.StartNew();
      Regex intAll = new Regex(pattern, RegexOptions.Singleline);
      match = intAll.Match(input);
      int matches = 0;
      while (match.Success) {
         matches++;
         // Do nothing with the match except get the next match.
         match = match.NextMatch();
      }
      sw.Stop();
      Console.WriteLine(&quot;   {0:N0} matches in {1}&quot;, matches, sw.Elapsed);

      // Read all sentences with compiled regex.
      Console.WriteLine(&quot;All Sentences with Compiled Regex:&quot;);
      sw = Stopwatch.StartNew();
      Regex compAll = new Regex(pattern,
                      RegexOptions.Singleline | RegexOptions.Compiled);
      match = compAll.Match(input);
      matches = 0;
      while (match.Success) {
         matches++;
         // Do nothing with the match except get the next match.
         match = match.NextMatch();
      }
      sw.Stop();
      Console.WriteLine(&quot;   {0:N0} matches in {1}&quot;, matches, sw.Elapsed);
   }
}
// The example displays the following output:
//       10 Sentences with Interpreted Regex:
//          10 matches in 00:00:00.0047491
//       10 Sentences with Compiled Regex:
//          10 matches in 00:00:00.0141872
//       All Sentences with Interpreted Regex:
//          13,443 matches in 00:00:01.1929928
//       All Sentences with Compiled Regex:
//          13,443 matches in 00:00:00.7635869
//
//       >compare1
//       10 Sentences with Interpreted Regex:
//          10 matches in 00:00:00.0046914
//       10 Sentences with Compiled Regex:
//          10 matches in 00:00:00.0143727
//       All Sentences with Interpreted Regex:
//          13,443 matches in 00:00:01.1514100
//       All Sentences with Compiled Regex:
//          13,443 matches in 00:00:00.7432921
"><span><span>using</span> System;
<span>using</span> System.Diagnostics;
<span>using</span> System.IO;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>Example</span>
{
   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span></span>)</span>
   {
      <span>string</span> pattern = <span>@"\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]"</span>;
      Stopwatch sw;
      Match match;
      <span>int</span> ctr;

      StreamReader inFile = <span>new</span> StreamReader(<span>@".\Dreiser_TheFinancier.txt"</span>);
      <span>string</span> input = inFile.ReadToEnd();
      inFile.Close();

      <span>// Read first ten sentences with interpreted regex.</span>
      Console.WriteLine(<span>"10 Sentences with Interpreted Regex:"</span>);
      sw = Stopwatch.StartNew();
      Regex int10 = <span>new</span> Regex(pattern, RegexOptions.Singleline);
      match = int10.Match(input);
      <span>for</span> (ctr = <span>0</span>; ctr &lt;= <span>9</span>; ctr++) {
         <span>if</span> (match.Success)
            <span>// Do nothing with the match except get the next match.</span>
            match = match.NextMatch();
         <span>else</span>
            <span>break</span>;
      }
      sw.Stop();
      Console.WriteLine(<span>"   {0} matches in {1}"</span>, ctr, sw.Elapsed);

      <span>// Read first ten sentences with compiled regex.</span>
      Console.WriteLine(<span>"10 Sentences with Compiled Regex:"</span>);
      sw = Stopwatch.StartNew();
      Regex comp10 = <span>new</span> Regex(pattern,
                   RegexOptions.Singleline | RegexOptions.Compiled);
      match = comp10.Match(input);
      <span>for</span> (ctr = <span>0</span>; ctr &lt;= <span>9</span>; ctr++) {
         <span>if</span> (match.Success)
            <span>// Do nothing with the match except get the next match.</span>
            match = match.NextMatch();
         <span>else</span>
            <span>break</span>;
      }
      sw.Stop();
      Console.WriteLine(<span>"   {0} matches in {1}"</span>, ctr, sw.Elapsed);

      <span>// Read all sentences with interpreted regex.</span>
      Console.WriteLine(<span>"All Sentences with Interpreted Regex:"</span>);
      sw = Stopwatch.StartNew();
      Regex intAll = <span>new</span> Regex(pattern, RegexOptions.Singleline);
      match = intAll.Match(input);
      <span>int</span> matches = <span>0</span>;
      <span>while</span> (match.Success) {
         matches++;
         <span>// Do nothing with the match except get the next match.</span>
         match = match.NextMatch();
      }
      sw.Stop();
      Console.WriteLine(<span>"   {0:N0} matches in {1}"</span>, matches, sw.Elapsed);

      <span>// Read all sentences with compiled regex.</span>
      Console.WriteLine(<span>"All Sentences with Compiled Regex:"</span>);
      sw = Stopwatch.StartNew();
      Regex compAll = <span>new</span> Regex(pattern,
                      RegexOptions.Singleline | RegexOptions.Compiled);
      match = compAll.Match(input);
      matches = <span>0</span>;
      <span>while</span> (match.Success) {
         matches++;
         <span>// Do nothing with the match except get the next match.</span>
         match = match.NextMatch();
      }
      sw.Stop();
      Console.WriteLine(<span>"   {0:N0} matches in {1}"</span>, matches, sw.Elapsed);
   }
}
<span>// The example displays the following output:</span>
<span>//       10 Sentences with Interpreted Regex:</span>
<span>//          10 matches in 00:00:00.0047491</span>
<span>//       10 Sentences with Compiled Regex:</span>
<span>//          10 matches in 00:00:00.0141872</span>
<span>//       All Sentences with Interpreted Regex:</span>
<span>//          13,443 matches in 00:00:01.1929928</span>
<span>//       All Sentences with Compiled Regex:</span>
<span>//          13,443 matches in 00:00:00.7635869</span>
<span>//</span>
<span>//       &gt;compare1</span>
<span>//       10 Sentences with Interpreted Regex:</span>
<span>//          10 matches in 00:00:00.0046914</span>
<span>//       10 Sentences with Compiled Regex:</span>
<span>//          10 matches in 00:00:00.0143727</span>
<span>//       All Sentences with Interpreted Regex:</span>
<span>//          13,443 matches in 00:00:01.1514100</span>
<span>//       All Sentences with Compiled Regex:</span>
<span>//          13,443 matches in 00:00:00.7432921</span>
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#5" data-author-content="Imports System.Diagnostics
Imports System.IO
Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim pattern As String = &quot;\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]&quot;
        Dim sw As Stopwatch
        Dim match As Match
        Dim ctr As Integer

        Dim inFile As New StreamReader(&quot;.\Dreiser_TheFinancier.txt&quot;)
        Dim input As String = inFile.ReadToEnd()
        inFile.Close()

        ' Read first ten sentences with interpreted regex.
        Console.WriteLine(&quot;10 Sentences with Interpreted Regex:&quot;)
        sw = Stopwatch.StartNew()
        Dim int10 As New Regex(pattern, RegexOptions.SingleLine)
        match = int10.Match(input)
        For ctr = 0 To 9
            If match.Success Then
                ' Do nothing with the match except get the next match.
                match = match.NextMatch()
            Else
                Exit For
            End If
        Next
        sw.Stop()
        Console.WriteLine(&quot;   {0} matches in {1}&quot;, ctr, sw.Elapsed)

        ' Read first ten sentences with compiled regex.
        Console.WriteLine(&quot;10 Sentences with Compiled Regex:&quot;)
        sw = Stopwatch.StartNew()
        Dim comp10 As New Regex(pattern,
                     RegexOptions.SingleLine Or RegexOptions.Compiled)
        match = comp10.Match(input)
        For ctr = 0 To 9
            If match.Success Then
                ' Do nothing with the match except get the next match.
                match = match.NextMatch()
            Else
                Exit For
            End If
        Next
        sw.Stop()
        Console.WriteLine(&quot;   {0} matches in {1}&quot;, ctr, sw.Elapsed)

        ' Read all sentences with interpreted regex.
        Console.WriteLine(&quot;All Sentences with Interpreted Regex:&quot;)
        sw = Stopwatch.StartNew()
        Dim intAll As New Regex(pattern, RegexOptions.SingleLine)
        match = intAll.Match(input)
        Dim matches As Integer = 0
        Do While match.Success
            matches += 1
            ' Do nothing with the match except get the next match.
            match = match.NextMatch()
        Loop
        sw.Stop()
        Console.WriteLine(&quot;   {0:N0} matches in {1}&quot;, matches, sw.Elapsed)

        ' Read all sentences with compiled regex.
        Console.WriteLine(&quot;All Sentences with Compiled Regex:&quot;)
        sw = Stopwatch.StartNew()
        Dim compAll As New Regex(pattern,
                       RegexOptions.SingleLine Or RegexOptions.Compiled)
        match = compAll.Match(input)
        matches = 0
        Do While match.Success
            matches += 1
            ' Do nothing with the match except get the next match.
            match = match.NextMatch()
        Loop
        sw.Stop()
        Console.WriteLine(&quot;   {0:N0} matches in {1}&quot;, matches, sw.Elapsed)
    End Sub
End Module
' The example displays output like the following:
'       10 Sentences with Interpreted Regex:
'          10 matches in 00:00:00.0047491
'       10 Sentences with Compiled Regex:
'          10 matches in 00:00:00.0141872
'       All Sentences with Interpreted Regex:
'          13,443 matches in 00:00:01.1929928
'       All Sentences with Compiled Regex:
'          13,443 matches in 00:00:00.7635869
'       
'       >compare1
'       10 Sentences with Interpreted Regex:
'          10 matches in 00:00:00.0046914
'       10 Sentences with Compiled Regex:
'          10 matches in 00:00:00.0143727
'       All Sentences with Interpreted Regex:
'          13,443 matches in 00:00:01.1514100
'       All Sentences with Compiled Regex:
'          13,443 matches in 00:00:00.7432921
">Imports System.Diagnostics
Imports System.IO
Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim pattern As String = "\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]"
        Dim sw As Stopwatch
        Dim match As Match
        Dim ctr As Integer

        Dim inFile As New StreamReader(".\Dreiser_TheFinancier.txt")
        Dim input As String = inFile.ReadToEnd()
        inFile.Close()

        ' Read first ten sentences with interpreted regex.
        Console.WriteLine("10 Sentences with Interpreted Regex:")
        sw = Stopwatch.StartNew()
        Dim int10 As New Regex(pattern, RegexOptions.SingleLine)
        match = int10.Match(input)
        For ctr = 0 To 9
            If match.Success Then
                ' Do nothing with the match except get the next match.
                match = match.NextMatch()
            Else
                Exit For
            End If
        Next
        sw.Stop()
        Console.WriteLine("   {0} matches in {1}", ctr, sw.Elapsed)

        ' Read first ten sentences with compiled regex.
        Console.WriteLine("10 Sentences with Compiled Regex:")
        sw = Stopwatch.StartNew()
        Dim comp10 As New Regex(pattern,
                     RegexOptions.SingleLine Or RegexOptions.Compiled)
        match = comp10.Match(input)
        For ctr = 0 To 9
            If match.Success Then
                ' Do nothing with the match except get the next match.
                match = match.NextMatch()
            Else
                Exit For
            End If
        Next
        sw.Stop()
        Console.WriteLine("   {0} matches in {1}", ctr, sw.Elapsed)

        ' Read all sentences with interpreted regex.
        Console.WriteLine("All Sentences with Interpreted Regex:")
        sw = Stopwatch.StartNew()
        Dim intAll As New Regex(pattern, RegexOptions.SingleLine)
        match = intAll.Match(input)
        Dim matches As Integer = 0
        Do While match.Success
            matches += 1
            ' Do nothing with the match except get the next match.
            match = match.NextMatch()
        Loop
        sw.Stop()
        Console.WriteLine("   {0:N0} matches in {1}", matches, sw.Elapsed)

        ' Read all sentences with compiled regex.
        Console.WriteLine("All Sentences with Compiled Regex:")
        sw = Stopwatch.StartNew()
        Dim compAll As New Regex(pattern,
                       RegexOptions.SingleLine Or RegexOptions.Compiled)
        match = compAll.Match(input)
        matches = 0
        Do While match.Success
            matches += 1
            ' Do nothing with the match except get the next match.
            match = match.NextMatch()
        Loop
        sw.Stop()
        Console.WriteLine("   {0:N0} matches in {1}", matches, sw.Elapsed)
    End Sub
End Module
' The example displays output like the following:
'       10 Sentences with Interpreted Regex:
'          10 matches in 00:00:00.0047491
'       10 Sentences with Compiled Regex:
'          10 matches in 00:00:00.0141872
'       All Sentences with Interpreted Regex:
'          13,443 matches in 00:00:01.1929928
'       All Sentences with Compiled Regex:
'          13,443 matches in 00:00:00.7635869
'       
'       &gt;compare1
'       10 Sentences with Interpreted Regex:
'          10 matches in 00:00:00.0046914
'       10 Sentences with Compiled Regex:
'          10 matches in 00:00:00.0143727
'       All Sentences with Interpreted Regex:
'          13,443 matches in 00:00:01.1514100
'       All Sentences with Compiled Regex:
'          13,443 matches in 00:00:00.7432921
</code></pre>
<p>The regular expression pattern used in the example, <code>\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]</code>, is defined as shown in the following table.</p>

<h3 id="regular-expressions-compiled-to-an-assembly"><a href="#regular-expressions-compiled-to-an-assembly" aria-labelledby="regular-expressions-compiled-to-an-assembly"></a>Regular expressions: Compiled to an assembly</h3>
<p>.NET also enables you to create an assembly that contains compiled regular expressions. This moves the performance hit of regular expression compilation from run time to design time. However, it also involves some additional work: You must define the regular expressions in advance and compile them to an assembly. The compiler can then reference this assembly when compiling source code that uses the assemblyâ€™s regular expressions. Each compiled regular expression in the assembly is represented by a class that derives from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a>.</p>
<p>To compile regular expressions to an assembly, you call the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.compiletoassembly#System_Text_RegularExpressions_Regex_CompileToAssembly_System_Text_RegularExpressions_RegexCompilationInfo___System_Reflection_AssemblyName_" data-linktype="absolute-path">Regex.CompileToAssembly(RegexCompilationInfo[], AssemblyName)</a> method and pass it an array of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexcompilationinfo" data-linktype="absolute-path">RegexCompilationInfo</a> objects that represent the regular expressions to be compiled, and an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assemblyname" data-linktype="absolute-path">AssemblyName</a> object that contains information about the assembly to be created.</p>
<p>We recommend that you compile regular expressions to an assembly in the following situations:</p>
<ul>
<li><p>If you are a component developer who wants to create a library of reusable regular expressions.</p>
</li>
<li><p>If you expect your regular expression's pattern-matching methods to be called an indeterminate number of times -- anywhere from once or twice to thousands or tens of thousands of times. Unlike compiled or interpreted regular expressions, regular expressions that are compiled to separate assemblies offer performance that is consistent regardless of the number of method calls.</p>
</li>
</ul>
<p>If you are using compiled regular expressions to optimize performance, you should not use reflection to create the assembly, load the regular expression engine, and execute its pattern-matching methods. This requires that you avoid building regular expression patterns dynamically, and that you specify any pattern-matching options (such as case-insensitive pattern matching) at the time the assembly is created. It also requires that you separate the code that creates the assembly from the code that uses the regular expression.</p>
<p>The following example shows how to create an assembly that contains a compiled regular expression. It creates an assembly named <code>RegexLib.dll</code> with a single regular expression class, <code>SentencePattern</code>, that contains the sentence-matching regular expression pattern used in the <a href="#interpreted-vs-compiled-regular-expressions" data-linktype="self-bookmark">Interpreted vs. Compiled Regular Expressions</a> section.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#6" data-author-content="using System;
using System.Reflection;
using System.Text.RegularExpressions;

public class Example
{
   public static void Main()
   {
      RegexCompilationInfo SentencePattern =
                           new RegexCompilationInfo(@&quot;\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]&quot;,
                                                    RegexOptions.Multiline,
                                                    &quot;SentencePattern&quot;,
                                                    &quot;Utilities.RegularExpressions&quot;,
                                                    true);
      RegexCompilationInfo[] regexes = { SentencePattern };
      AssemblyName assemName = new AssemblyName(&quot;RegexLib, Version=1.0.0.1001, Culture=neutral, PublicKeyToken=null&quot;);
      Regex.CompileToAssembly(regexes, assemName);
   }
}
"><span><span>using</span> System;
<span>using</span> System.Reflection;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>Example</span>
{
   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span></span>)</span>
   {
      RegexCompilationInfo SentencePattern =
                           <span>new</span> RegexCompilationInfo(<span>@"\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]"</span>,
                                                    RegexOptions.Multiline,
                                                    <span>"SentencePattern"</span>,
                                                    <span>"Utilities.RegularExpressions"</span>,
                                                    <span>true</span>);
      RegexCompilationInfo[] regexes = { SentencePattern };
      AssemblyName assemName = <span>new</span> AssemblyName(<span>"RegexLib, Version=1.0.0.1001, Culture=neutral, PublicKeyToken=null"</span>);
      Regex.CompileToAssembly(regexes, assemName);
   }
}
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#6" data-author-content="Imports System.Reflection
Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim SentencePattern As New RegexCompilationInfo(&quot;\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]&quot;,
                                                        RegexOptions.Multiline,
                                                        &quot;SentencePattern&quot;,
                                                        &quot;Utilities.RegularExpressions&quot;,
                                                        True)
        Dim regexes() As RegexCompilationInfo = {SentencePattern}
        Dim assemName As New AssemblyName(&quot;RegexLib, Version=1.0.0.1001, Culture=neutral, PublicKeyToken=null&quot;)
        Regex.CompileToAssembly(regexes, assemName)
    End Sub
End Module
">Imports System.Reflection
Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim SentencePattern As New RegexCompilationInfo("\b(\w+((\r?\n)|,?\s))*\w+[.?:;!]",
                                                        RegexOptions.Multiline,
                                                        "SentencePattern",
                                                        "Utilities.RegularExpressions",
                                                        True)
        Dim regexes() As RegexCompilationInfo = {SentencePattern}
        Dim assemName As New AssemblyName("RegexLib, Version=1.0.0.1001, Culture=neutral, PublicKeyToken=null")
        Regex.CompileToAssembly(regexes, assemName)
    End Sub
End Module
</code></pre>
<p>When the example is compiled to an executable and run, it creates an assembly named <code>RegexLib.dll</code>. The regular expression is represented by a class named <code>Utilities.RegularExpressions.SentencePattern</code> that is derived from <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a>. The following example then uses the compiled regular expression to extract the sentences from the text of Theodore Dreiser's <em>The Financier</em>.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#7" data-author-content="using System;
using System.IO;
using System.Text.RegularExpressions;
using Utilities.RegularExpressions;

public class Example
{
   public static void Main()
   {
      SentencePattern pattern = new SentencePattern();
      StreamReader inFile = new StreamReader(@&quot;.\Dreiser_TheFinancier.txt&quot;);
      string input = inFile.ReadToEnd();
      inFile.Close();

      MatchCollection matches = pattern.Matches(input);
      Console.WriteLine(&quot;Found {0:N0} sentences.&quot;, matches.Count);
   }
}
// The example displays the following output:
//      Found 13,443 sentences.
"><span><span>using</span> System;
<span>using</span> System.IO;
<span>using</span> System.Text.RegularExpressions;
<span>using</span> Utilities.RegularExpressions;

<span>public</span> <span>class</span> <span>Example</span>
{
   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span></span>)</span>
   {
      SentencePattern pattern = <span>new</span> SentencePattern();
      StreamReader inFile = <span>new</span> StreamReader(<span>@".\Dreiser_TheFinancier.txt"</span>);
      <span>string</span> input = inFile.ReadToEnd();
      inFile.Close();

      MatchCollection matches = pattern.Matches(input);
      Console.WriteLine(<span>"Found {0:N0} sentences."</span>, matches.Count);
   }
}
<span>// The example displays the following output:</span>
<span>//      Found 13,443 sentences.</span>
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#7" data-author-content="Imports System.IO
Imports System.Text.RegularExpressions
Imports Utilities.RegularExpressions

Module Example
    Public Sub Main()
        Dim pattern As New SentencePattern()
        Dim inFile As New StreamReader(&quot;.\Dreiser_TheFinancier.txt&quot;)
        Dim input As String = inFile.ReadToEnd()
        inFile.Close()

        Dim matches As MatchCollection = pattern.Matches(input)
        Console.WriteLine(&quot;Found {0:N0} sentences.&quot;, matches.Count)
    End Sub
End Module
' The example displays the following output:
'      Found 13,443 sentences.
">Imports System.IO
Imports System.Text.RegularExpressions
Imports Utilities.RegularExpressions

Module Example
    Public Sub Main()
        Dim pattern As New SentencePattern()
        Dim inFile As New StreamReader(".\Dreiser_TheFinancier.txt")
        Dim input As String = inFile.ReadToEnd()
        inFile.Close()

        Dim matches As MatchCollection = pattern.Matches(input)
        Console.WriteLine("Found {0:N0} sentences.", matches.Count)
    End Sub
End Module
' The example displays the following output:
'      Found 13,443 sentences.
</code></pre><h2 id="take-charge-of-backtracking"><a href="#take-charge-of-backtracking" aria-labelledby="take-charge-of-backtracking"></a>Take charge of backtracking</h2>
<p>Ordinarily, the regular expression engine uses linear progression to move through an input string and compare it to a regular expression pattern. However, when indeterminate quantifiers such as <code>*</code>, <code>+</code>, and <code>?</code> are used in a regular expression pattern, the regular expression engine may give up a portion of successful partial matches and return to a previously saved state in order to search for a successful match for the entire pattern. This process is known as backtracking.</p>

<p>Support for backtracking gives regular expressions power and flexibility. It also places the responsibility for controlling the operation of the regular expression engine in the hands of regular expression developers. Because developers are often not aware of this responsibility, their misuse of backtracking or reliance on excessive backtracking often plays the most significant role in degrading regular expression performance. In a worst-case scenario, execution time can double for each additional character in the input string. In fact, by using backtracking excessively, it is easy to create the programmatic equivalent of an endless loop if input nearly matches the regular expression pattern; the regular expression engine may take hours or even days to process a relatively short input string.</p>
<p>Often, applications pay a performance penalty for using backtracking despite the fact that backtracking is not essential for a match. For example, the regular expression <code>\b\p{Lu}\w*\b</code> matches all words that begin with an uppercase character, as the following table shows.</p>

<p>Because a word boundary is not the same as, or a subset of, a word character, there is no possibility that the regular expression engine will cross a word boundary when matching word characters. This means that for this regular expression, backtracking can never contribute to the overall success of any match -- it can only degrade performance, because the regular expression engine is forced to save its state for each successful preliminary match of a word character.</p>
<p>If you determine that backtracking is not necessary, you can disable it by using the <code>(?&gt;subexpression)</code> language element, known as an atomic group. The following example parses an input string by using two regular expressions. The first, <code>\b\p{Lu}\w*\b</code>, relies on backtracking. The second, <code>\b\p{Lu}(?&gt;\w*)\b</code>, disables backtracking. As the output from the example shows, they both produce the same result.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#10" data-author-content="using System;
using System.Text.RegularExpressions;

public class Example
{
   public static void Main()
   {
      string input = &quot;This this word Sentence name Capital&quot;;
      string pattern = @&quot;\b\p{Lu}\w*\b&quot;;
      foreach (Match match in Regex.Matches(input, pattern))
         Console.WriteLine(match.Value);

      Console.WriteLine();

      pattern = @&quot;\b\p{Lu}(?>\w*)\b&quot;;
      foreach (Match match in Regex.Matches(input, pattern))
         Console.WriteLine(match.Value);
   }
}
// The example displays the following output:
//       This
//       Sentence
//       Capital
//
//       This
//       Sentence
//       Capital
"><span><span>using</span> System;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>Example</span>
{
   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span></span>)</span>
   {
      <span>string</span> input = <span>"This this word Sentence name Capital"</span>;
      <span>string</span> pattern = <span>@"\b\p{Lu}\w*\b"</span>;
      <span>foreach</span> (Match match <span>in</span> Regex.Matches(input, pattern))
         Console.WriteLine(match.Value);

      Console.WriteLine();

      pattern = <span>@"\b\p{Lu}(?&gt;\w*)\b"</span>;
      <span>foreach</span> (Match match <span>in</span> Regex.Matches(input, pattern))
         Console.WriteLine(match.Value);
   }
}
<span>// The example displays the following output:</span>
<span>//       This</span>
<span>//       Sentence</span>
<span>//       Capital</span>
<span>//</span>
<span>//       This</span>
<span>//       Sentence</span>
<span>//       Capital</span>
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#10" data-author-content="Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim input As String = &quot;This this word Sentence name Capital&quot;
        Dim pattern As String = &quot;\b\p{Lu}\w*\b&quot;
        For Each match As Match In Regex.Matches(input, pattern)
            Console.WriteLine(match.Value)
        Next
        Console.WriteLine()

        pattern = &quot;\b\p{Lu}(?>\w*)\b&quot;
        For Each match As Match In Regex.Matches(input, pattern)
            Console.WriteLine(match.Value)
        Next
    End Sub
End Module
' The example displays the following output:
'       This
'       Sentence
'       Capital
'       
'       This
'       Sentence
'       Capital
">Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim input As String = "This this word Sentence name Capital"
        Dim pattern As String = "\b\p{Lu}\w*\b"
        For Each match As Match In Regex.Matches(input, pattern)
            Console.WriteLine(match.Value)
        Next
        Console.WriteLine()

        pattern = "\b\p{Lu}(?&gt;\w*)\b"
        For Each match As Match In Regex.Matches(input, pattern)
            Console.WriteLine(match.Value)
        Next
    End Sub
End Module
' The example displays the following output:
'       This
'       Sentence
'       Capital
'       
'       This
'       Sentence
'       Capital
</code></pre>
<p>In many cases, backtracking is essential for matching a regular expression pattern to input text. However, excessive backtracking can severely degrade performance and create the impression that an application has stopped responding. In particular, this happens when quantifiers are nested and the text that matches the outer subexpression is a subset of the text that matches the inner subexpression.</p>
<div>
<p><span aria-hidden="true"></span> Warning</p>
<p>In addition to avoiding excessive backtracking, you should use the timeout feature to ensure that excessive backtracking does not severely degrade regular expression performance. For more information, see the <a href="#use-time-out-values" data-linktype="self-bookmark">Use Time-out Values</a> section.</p>
</div>
<p>For example, the regular expression pattern <code>^[0-9A-Z]([-.\w]*[0-9A-Z])*\$$</code> is intended to match a part number that consists of at least one alphanumeric character. Any additional characters can consist of an alphanumeric character, a hyphen, an underscore, or a period, though the last character must be alphanumeric. A dollar sign terminates the part number. In some cases, this regular expression pattern can exhibit extremely poor performance because quantifiers are nested, and because the subexpression <code>[0-9A-Z]</code> is a subset of the subexpression <code>[-.\w]*</code>.</p>
<p>In these cases, you can optimize regular expression performance by removing the nested quantifiers and replacing the outer subexpression with a zero-width lookahead or lookbehind assertion. Lookahead and lookbehind assertions are anchors; they do not move the pointer in the input string, but instead look ahead or behind to check whether a specified condition is met. For example, the part number regular expression can be rewritten as <code>^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$</code>. This regular expression pattern is defined as shown in the following table.</p>

<p>The following example illustrates the use of this regular expression to match an array containing possible part numbers.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#11" data-author-content="using System;
using System.Text.RegularExpressions;

public class Example
{
   public static void Main()
   {
      string pattern = @&quot;^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$&quot;;
      string[] partNos = { &quot;A1C$&quot;, &quot;A4&quot;, &quot;A4$&quot;, &quot;A1603D$&quot;, &quot;A1603D#&quot; };

      foreach (var input in partNos) {
         Match match = Regex.Match(input, pattern);
         if (match.Success)
            Console.WriteLine(match.Value);
         else
            Console.WriteLine(&quot;Match not found.&quot;);
      }
   }
}
// The example displays the following output:
//       A1C$
//       Match not found.
//       A4$
//       A1603D$
//       Match not found.
"><span><span>using</span> System;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>Example</span>
{
   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span></span>)</span>
   {
      <span>string</span> pattern = <span>@"^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$"</span>;
      <span>string</span>[] partNos = { <span>"A1C$"</span>, <span>"A4"</span>, <span>"A4$"</span>, <span>"A1603D$"</span>, <span>"A1603D#"</span> };

      <span>foreach</span> (<span>var</span> input <span>in</span> partNos) {
         Match match = Regex.Match(input, pattern);
         <span>if</span> (match.Success)
            Console.WriteLine(match.Value);
         <span>else</span>
            Console.WriteLine(<span>"Match not found."</span>);
      }
   }
}
<span>// The example displays the following output:</span>
<span>//       A1C$</span>
<span>//       Match not found.</span>
<span>//       A4$</span>
<span>//       A1603D$</span>
<span>//       Match not found.</span>
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#11" data-author-content="Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim pattern As String = &quot;^[0-9A-Z][-.\w]*(?<=[0-9A-Z])\$$&quot;
        Dim partNos() As String = {&quot;A1C$&quot;, &quot;A4&quot;, &quot;A4$&quot;, &quot;A1603D$&quot;,
                                    &quot;A1603D#&quot;}

        For Each input As String In partNos
            Dim match As Match = Regex.Match(input, pattern)
            If match.Success Then
                Console.WriteLine(match.Value)
            Else
                Console.WriteLine(&quot;Match not found.&quot;)
            End If
        Next
    End Sub
End Module
' The example displays the following output:
'       A1C$
'       Match not found.
'       A4$
'       A1603D$
'       Match not found.
">Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim pattern As String = "^[0-9A-Z][-.\w]*(?&lt;=[0-9A-Z])\$$"
        Dim partNos() As String = {"A1C$", "A4", "A4$", "A1603D$",
                                    "A1603D#"}

        For Each input As String In partNos
            Dim match As Match = Regex.Match(input, pattern)
            If match.Success Then
                Console.WriteLine(match.Value)
            Else
                Console.WriteLine("Match not found.")
            End If
        Next
    End Sub
End Module
' The example displays the following output:
'       A1C$
'       Match not found.
'       A4$
'       A1603D$
'       Match not found.
</code></pre>
<p>The regular expression language in .NET includes the following language elements that you can use to eliminate nested quantifiers. For more information, see <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/grouping-constructs-in-regular-expressions" data-linktype="relative-path">Grouping Constructs</a>.</p>

<h2 id="use-time-out-values"><a href="#use-time-out-values" aria-labelledby="use-time-out-values"></a>Use time-out values</h2>
<p>If your regular expressions processes input that nearly matches the regular expression pattern, it can often rely on excessive backtracking, which impacts its performance significantly. In addition to carefully considering your use of backtracking and testing the regular expression against near-matching input, you should always set a time-out value to ensure that the impact of excessive backtracking, if it occurs, is minimized.</p>
<p>The regular expression time-out interval defines the period of time that the regular expression engine will look for a single match before it times out. The default time-out interval is <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.infinitematchtimeout" data-linktype="absolute-path">Regex.InfiniteMatchTimeout</a>, which means that the regular expression will not time out. You can override this value and define a time-out interval as follows:</p>
<ul>
<li><p>By providing a time-out value when you instantiate a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object by calling the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.-ctor#System_Text_RegularExpressions_Regex__ctor_System_String_System_Text_RegularExpressions_RegexOptions_System_TimeSpan_" data-linktype="absolute-path">Regex(String, RegexOptions, TimeSpan)</a> constructor.</p>
</li>
<li><p>By calling a static pattern matching method, such as <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.match#System_Text_RegularExpressions_Regex_Match_System_String_System_String_System_Text_RegularExpressions_RegexOptions_System_TimeSpan_" data-linktype="absolute-path">Regex.Match(String, String, RegexOptions, TimeSpan)</a> or <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.replace#System_Text_RegularExpressions_Regex_Replace_System_String_System_String_System_String_System_Text_RegularExpressions_RegexOptions_System_TimeSpan_" data-linktype="absolute-path">Regex.Replace(String, String, String, RegexOptions, TimeSpan)</a>, that includes a <code>matchTimeout</code> parameter.</p>
</li>
<li><p>For compiled regular expressions that are created by calling the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.compiletoassembly" data-linktype="absolute-path">Regex.CompileToAssembly</a> method, by calling the constructor that has a parameter of type <a href="https://docs.microsoft.com/en-us/dotnet/api/system.timespan" data-linktype="absolute-path">TimeSpan</a>.</p>
</li>
</ul>
<p>If you have defined a time-out interval and a match is not found at the end of that interval, the regular expression method throws a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexmatchtimeoutexception" data-linktype="absolute-path">RegexMatchTimeoutException</a> exception. In your exception handler, you can choose to retry the match with a longer time-out interval, abandon the match attempt and assume that there is no match, or abandon the match attempt and log the exception information for future analysis.</p>
<p>The following example defines a <code>GetWordData</code> method that instantiates a regular expression with a time-out interval of 350 milliseconds to calculate the number of words and average number of characters in a word in a text document. If the matching operation times out, the time-out interval is increased by 350 milliseconds and the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> object is re-instantiated. If the new time-out interval exceeds 1 second, the method re-throws the exception to the caller.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#12" data-author-content="using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

public class Example
{
   public static void Main()
   {
      RegexUtilities util = new RegexUtilities();
      string title = &quot;Doyle - The Hound of the Baskervilles.txt&quot;;
      try {
         var info = util.GetWordData(title);
         Console.WriteLine(&quot;Words:               {0:N0}&quot;, info.Item1);
         Console.WriteLine(&quot;Average Word Length: {0:N2} characters&quot;, info.Item2);
      }
      catch (IOException e) {
         Console.WriteLine(&quot;IOException reading file '{0}'&quot;, title);
         Console.WriteLine(e.Message);
      }
      catch (RegexMatchTimeoutException e) {
         Console.WriteLine(&quot;The operation timed out after {0:N0} milliseconds&quot;,
                           e.MatchTimeout.TotalMilliseconds);
      }
   }
}

public class RegexUtilities
{
   public Tuple<int, double> GetWordData(string filename)
   {
      const int MAX_TIMEOUT = 1000;   // Maximum timeout interval in milliseconds.
      const int INCREMENT = 350;      // Milliseconds increment of timeout.

      List<string> exclusions = new List<string>( new string[] { &quot;a&quot;, &quot;an&quot;, &quot;the&quot; });
      int[] wordLengths = new int[29];        // Allocate an array of more than ample size.
      string input = null;
      StreamReader sr = null;
      try {
         sr = new StreamReader(filename);
         input = sr.ReadToEnd();
      }
      catch (FileNotFoundException e) {
         string msg = String.Format(&quot;Unable to find the file '{0}'&quot;, filename);
         throw new IOException(msg, e);
      }
      catch (IOException e) {
         throw new IOException(e.Message, e);
      }
      finally {
         if (sr != null) sr.Close();
      }

      int timeoutInterval = INCREMENT;
      bool init = false;
      Regex rgx = null;
      Match m = null;
      int indexPos = 0;
      do {
         try {
            if (! init) {
               rgx = new Regex(@&quot;\b\w+\b&quot;, RegexOptions.None,
                               TimeSpan.FromMilliseconds(timeoutInterval));
               m = rgx.Match(input, indexPos);
               init = true;
            }
            else {
               m = m.NextMatch();
            }
            if (m.Success) {
               if ( !exclusions.Contains(m.Value.ToLower()))
                  wordLengths[m.Value.Length]++;

               indexPos += m.Length + 1;
            }
         }
         catch (RegexMatchTimeoutException e) {
            if (e.MatchTimeout.TotalMilliseconds < MAX_TIMEOUT) {
               timeoutInterval += INCREMENT;
               init = false;
            }
            else {
               // Rethrow the exception.
               throw;
            }
         }
      } while (m.Success);

      // If regex completed successfully, calculate number of words and average length.
      int nWords = 0;
      long totalLength = 0;

      for (int ctr = wordLengths.GetLowerBound(0); ctr <= wordLengths.GetUpperBound(0); ctr++) {
         nWords += wordLengths[ctr];
         totalLength += ctr * wordLengths[ctr];
      }
      return new Tuple<int, double>(nWords, totalLength/nWords);
   }
}
"><span><span>using</span> System;
<span>using</span> System.Collections.Generic;
<span>using</span> System.IO;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>Example</span>
{
   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span></span>)</span>
   {
      RegexUtilities util = <span>new</span> RegexUtilities();
      <span>string</span> title = <span>"Doyle - The Hound of the Baskervilles.txt"</span>;
      <span>try</span> {
         <span>var</span> info = util.GetWordData(title);
         Console.WriteLine(<span>"Words:               {0:N0}"</span>, info.Item1);
         Console.WriteLine(<span>"Average Word Length: {0:N2} characters"</span>, info.Item2);
      }
      <span>catch</span> (IOException e) {
         Console.WriteLine(<span>"IOException reading file '{0}'"</span>, title);
         Console.WriteLine(e.Message);
      }
      <span>catch</span> (RegexMatchTimeoutException e) {
         Console.WriteLine(<span>"The operation timed out after {0:N0} milliseconds"</span>,
                           e.MatchTimeout.TotalMilliseconds);
      }
   }
}

<span>public</span> <span>class</span> <span>RegexUtilities</span>
{
   <span><span>public</span> Tuple&lt;<span>int</span>, <span>double</span>&gt; <span>GetWordData</span>(<span><span>string</span> filename</span>)</span>
   {
      <span>const</span> <span>int</span> MAX_TIMEOUT = <span>1000</span>;   <span>// Maximum timeout interval in milliseconds.</span>
      <span>const</span> <span>int</span> INCREMENT = <span>350</span>;      <span>// Milliseconds increment of timeout.</span>

      List&lt;<span>string</span>&gt; exclusions = <span>new</span> List&lt;<span>string</span>&gt;( <span>new</span> <span>string</span>[] { <span>"a"</span>, <span>"an"</span>, <span>"the"</span> });
      <span>int</span>[] wordLengths = <span>new</span> <span>int</span>[<span>29</span>];        <span>// Allocate an array of more than ample size.</span>
      <span>string</span> input = <span>null</span>;
      StreamReader sr = <span>null</span>;
      <span>try</span> {
         sr = <span>new</span> StreamReader(filename);
         input = sr.ReadToEnd();
      }
      <span>catch</span> (FileNotFoundException e) {
         <span>string</span> msg = String.Format(<span>"Unable to find the file '{0}'"</span>, filename);
         <span>throw</span> <span>new</span> IOException(msg, e);
      }
      <span>catch</span> (IOException e) {
         <span>throw</span> <span>new</span> IOException(e.Message, e);
      }
      <span>finally</span> {
         <span>if</span> (sr != <span>null</span>) sr.Close();
      }

      <span>int</span> timeoutInterval = INCREMENT;
      <span>bool</span> init = <span>false</span>;
      Regex rgx = <span>null</span>;
      Match m = <span>null</span>;
      <span>int</span> indexPos = <span>0</span>;
      <span>do</span> {
         <span>try</span> {
            <span>if</span> (! init) {
               rgx = <span>new</span> Regex(<span>@"\b\w+\b"</span>, RegexOptions.None,
                               TimeSpan.FromMilliseconds(timeoutInterval));
               m = rgx.Match(input, indexPos);
               init = <span>true</span>;
            }
            <span>else</span> {
               m = m.NextMatch();
            }
            <span>if</span> (m.Success) {
               <span>if</span> ( !exclusions.Contains(m.Value.ToLower()))
                  wordLengths[m.Value.Length]++;

               indexPos += m.Length + <span>1</span>;
            }
         }
         <span>catch</span> (RegexMatchTimeoutException e) {
            <span>if</span> (e.MatchTimeout.TotalMilliseconds &lt; MAX_TIMEOUT) {
               timeoutInterval += INCREMENT;
               init = <span>false</span>;
            }
            <span>else</span> {
               <span>// Rethrow the exception.</span>
               <span>throw</span>;
            }
         }
      } <span>while</span> (m.Success);

      <span>// If regex completed successfully, calculate number of words and average length.</span>
      <span>int</span> nWords = <span>0</span>;
      <span>long</span> totalLength = <span>0</span>;

      <span>for</span> (<span>int</span> ctr = wordLengths.GetLowerBound(<span>0</span>); ctr &lt;= wordLengths.GetUpperBound(<span>0</span>); ctr++) {
         nWords += wordLengths[ctr];
         totalLength += ctr * wordLengths[ctr];
      }
      <span>return</span> <span>new</span> Tuple&lt;<span>int</span>, <span>double</span>&gt;(nWords, totalLength/nWords);
   }
}
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#12" data-author-content="Imports System.Collections.Generic
Imports System.IO
Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim util As New RegexUtilities()
        Dim title As String = &quot;Doyle - The Hound of the Baskervilles.txt&quot;
        Try
            Dim info = util.GetWordData(title)
            Console.WriteLine(&quot;Words:               {0:N0}&quot;, info.Item1)
            Console.WriteLine(&quot;Average Word Length: {0:N2} characters&quot;, info.Item2)
        Catch e As IOException
            Console.WriteLine(&quot;IOException reading file '{0}'&quot;, title)
            Console.WriteLine(e.Message)
        Catch e As RegexMatchTimeoutException
            Console.WriteLine(&quot;The operation timed out after {0:N0} milliseconds&quot;,
                              e.MatchTimeout.TotalMilliseconds)
        End Try
    End Sub
End Module

Public Class RegexUtilities
    Public Function GetWordData(filename As String) As Tuple(Of Integer, Double)
        Const MAX_TIMEOUT As Integer = 1000  ' Maximum timeout interval in milliseconds.
        Const INCREMENT As Integer = 350     ' Milliseconds increment of timeout.

        Dim exclusions As New List(Of String)({&quot;a&quot;, &quot;an&quot;, &quot;the&quot;})
        Dim wordLengths(30) As Integer        ' Allocate an array of more than ample size.
        Dim input As String = Nothing
        Dim sr As StreamReader = Nothing
        Try
            sr = New StreamReader(filename)
            input = sr.ReadToEnd()
        Catch e As FileNotFoundException
            Dim msg As String = String.Format(&quot;Unable to find the file '{0}'&quot;, filename)
            Throw New IOException(msg, e)
        Catch e As IOException
            Throw New IOException(e.Message, e)
        Finally
            If sr IsNot Nothing Then sr.Close()
        End Try

        Dim timeoutInterval As Integer = INCREMENT
        Dim init As Boolean = False
        Dim rgx As Regex = Nothing
        Dim m As Match = Nothing
        Dim indexPos As Integer = 0
        Do
            Try
                If Not init Then
                    rgx = New Regex(&quot;\b\w+\b&quot;, RegexOptions.None,
                                    TimeSpan.FromMilliseconds(timeoutInterval))
                    m = rgx.Match(input, indexPos)
                    init = True
                Else
                    m = m.NextMatch()
                End If
                If m.Success Then
                    If Not exclusions.Contains(m.Value.ToLower()) Then
                        wordLengths(m.Value.Length) += 1
                    End If
                    indexPos += m.Length + 1
                End If
            Catch e As RegexMatchTimeoutException
                If e.MatchTimeout.TotalMilliseconds < MAX_TIMEOUT Then
                    timeoutInterval += INCREMENT
                    init = False
                Else
                    ' Rethrow the exception.
                    Throw
                End If
            End Try
        Loop While m.Success

        ' If regex completed successfully, calculate number of words and average length.
        Dim nWords As Integer
        Dim totalLength As Long

        For ctr As Integer = wordLengths.GetLowerBound(0) To wordLengths.GetUpperBound(0)
            nWords += wordLengths(ctr)
            totalLength += ctr * wordLengths(ctr)
        Next
        Return New Tuple(Of Integer, Double)(nWords, totalLength / nWords)
    End Function
End Class
">Imports System.Collections.Generic
Imports System.IO
Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim util As New RegexUtilities()
        Dim title As String = "Doyle - The Hound of the Baskervilles.txt"
        Try
            Dim info = util.GetWordData(title)
            Console.WriteLine("Words:               {0:N0}", info.Item1)
            Console.WriteLine("Average Word Length: {0:N2} characters", info.Item2)
        Catch e As IOException
            Console.WriteLine("IOException reading file '{0}'", title)
            Console.WriteLine(e.Message)
        Catch e As RegexMatchTimeoutException
            Console.WriteLine("The operation timed out after {0:N0} milliseconds",
                              e.MatchTimeout.TotalMilliseconds)
        End Try
    End Sub
End Module

Public Class RegexUtilities
    Public Function GetWordData(filename As String) As Tuple(Of Integer, Double)
        Const MAX_TIMEOUT As Integer = 1000  ' Maximum timeout interval in milliseconds.
        Const INCREMENT As Integer = 350     ' Milliseconds increment of timeout.

        Dim exclusions As New List(Of String)({"a", "an", "the"})
        Dim wordLengths(30) As Integer        ' Allocate an array of more than ample size.
        Dim input As String = Nothing
        Dim sr As StreamReader = Nothing
        Try
            sr = New StreamReader(filename)
            input = sr.ReadToEnd()
        Catch e As FileNotFoundException
            Dim msg As String = String.Format("Unable to find the file '{0}'", filename)
            Throw New IOException(msg, e)
        Catch e As IOException
            Throw New IOException(e.Message, e)
        Finally
            If sr IsNot Nothing Then sr.Close()
        End Try

        Dim timeoutInterval As Integer = INCREMENT
        Dim init As Boolean = False
        Dim rgx As Regex = Nothing
        Dim m As Match = Nothing
        Dim indexPos As Integer = 0
        Do
            Try
                If Not init Then
                    rgx = New Regex("\b\w+\b", RegexOptions.None,
                                    TimeSpan.FromMilliseconds(timeoutInterval))
                    m = rgx.Match(input, indexPos)
                    init = True
                Else
                    m = m.NextMatch()
                End If
                If m.Success Then
                    If Not exclusions.Contains(m.Value.ToLower()) Then
                        wordLengths(m.Value.Length) += 1
                    End If
                    indexPos += m.Length + 1
                End If
            Catch e As RegexMatchTimeoutException
                If e.MatchTimeout.TotalMilliseconds &lt; MAX_TIMEOUT Then
                    timeoutInterval += INCREMENT
                    init = False
                Else
                    ' Rethrow the exception.
                    Throw
                End If
            End Try
        Loop While m.Success

        ' If regex completed successfully, calculate number of words and average length.
        Dim nWords As Integer
        Dim totalLength As Long

        For ctr As Integer = wordLengths.GetLowerBound(0) To wordLengths.GetUpperBound(0)
            nWords += wordLengths(ctr)
            totalLength += ctr * wordLengths(ctr)
        Next
        Return New Tuple(Of Integer, Double)(nWords, totalLength / nWords)
    End Function
End Class
</code></pre><h2 id="capture-only-when-necessary"><a href="#capture-only-when-necessary" aria-labelledby="capture-only-when-necessary"></a>Capture only when necessary</h2>
<p>Regular expressions in .NET support a number of grouping constructs, which let you group a regular expression pattern into one or more subexpressions. The most commonly used grouping constructs in .NET regular expression language are <code>(</code><em>subexpression</em><code>)</code>, which defines a numbered capturing group, and <code>(?&lt;</code><em>name</em><code>&gt;</code><em>subexpression</em><code>)</code>, which defines a named capturing group. Grouping constructs are essential for creating backreferences and for defining a subexpression to which a quantifier is applied.</p>
<p>However, the use of these language elements has a cost. They cause the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.groupcollection" data-linktype="absolute-path">GroupCollection</a> object returned by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.match.groups" data-linktype="absolute-path">Match.Groups</a> property to be populated with the most recent unnamed or named captures, and if a single grouping construct has captured multiple substrings in the input string, they also populate the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.capturecollection" data-linktype="absolute-path">CaptureCollection</a> object returned by the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.group.captures" data-linktype="absolute-path">Group.Captures</a> property of a particular capturing group with multiple <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.capture" data-linktype="absolute-path">Capture</a> objects.</p>
<p>Often, grouping constructs are used in a regular expression only so that quantifiers can be applied to them, and the groups captured by these subexpressions are not subsequently used. For example, the regular expression <code>\b(\w+[;,]?\s?)+[.?!]</code> is designed to capture an entire sentence. The following table describes the language elements in this regular expression pattern and their effect on the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.match" data-linktype="absolute-path">Match</a> object's <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.match.groups" data-linktype="absolute-path">Match.Groups</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.group.captures" data-linktype="absolute-path">Group.Captures</a> collections.</p>

<p>As the following example shows, when a match is found, both the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.groupcollection" data-linktype="absolute-path">GroupCollection</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.capturecollection" data-linktype="absolute-path">CaptureCollection</a> objects are populated with captures from the match. In this case, the capturing group <code>(\w+[;,]?\s?)</code> exists so that the <code>+</code> quantifier can be applied to it, which enables the regular expression pattern to match each word in a sentence. Otherwise, it would match the last word in a sentence.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#8" data-author-content="using System;
using System.Text.RegularExpressions;

public class Example
{
   public static void Main()
   {
      string input = &quot;This is one sentence. This is another.&quot;;
      string pattern = @&quot;\b(\w+[;,]?\s?)+[.?!]&quot;;

      foreach (Match match in Regex.Matches(input, pattern)) {
         Console.WriteLine(&quot;Match: '{0}' at index {1}.&quot;,
                           match.Value, match.Index);
         int grpCtr = 0;
         foreach (Group grp in match.Groups) {
            Console.WriteLine(&quot;   Group {0}: '{1}' at index {2}.&quot;,
                              grpCtr, grp.Value, grp.Index);
            int capCtr = 0;
            foreach (Capture cap in grp.Captures) {
               Console.WriteLine(&quot;      Capture {0}: '{1}' at {2}.&quot;,
                                 capCtr, cap.Value, cap.Index);
               capCtr++;
            }
            grpCtr++;
         }
         Console.WriteLine();
      }
   }
}
// The example displays the following output:
//       Match: 'This is one sentence.' at index 0.
//          Group 0: 'This is one sentence.' at index 0.
//             Capture 0: 'This is one sentence.' at 0.
//          Group 1: 'sentence' at index 12.
//             Capture 0: 'This ' at 0.
//             Capture 1: 'is ' at 5.
//             Capture 2: 'one ' at 8.
//             Capture 3: 'sentence' at 12.
//
//       Match: 'This is another.' at index 22.
//          Group 0: 'This is another.' at index 22.
//             Capture 0: 'This is another.' at 22.
//          Group 1: 'another' at index 30.
//             Capture 0: 'This ' at 22.
//             Capture 1: 'is ' at 27.
//             Capture 2: 'another' at 30.
"><span><span>using</span> System;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>Example</span>
{
   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span></span>)</span>
   {
      <span>string</span> input = <span>"This is one sentence. This is another."</span>;
      <span>string</span> pattern = <span>@"\b(\w+[;,]?\s?)+[.?!]"</span>;

      <span>foreach</span> (Match match <span>in</span> Regex.Matches(input, pattern)) {
         Console.WriteLine(<span>"Match: '{0}' at index {1}."</span>,
                           match.Value, match.Index);
         <span>int</span> grpCtr = <span>0</span>;
         <span>foreach</span> (Group grp <span>in</span> match.Groups) {
            Console.WriteLine(<span>"   Group {0}: '{1}' at index {2}."</span>,
                              grpCtr, grp.Value, grp.Index);
            <span>int</span> capCtr = <span>0</span>;
            <span>foreach</span> (Capture cap <span>in</span> grp.Captures) {
               Console.WriteLine(<span>"      Capture {0}: '{1}' at {2}."</span>,
                                 capCtr, cap.Value, cap.Index);
               capCtr++;
            }
            grpCtr++;
         }
         Console.WriteLine();
      }
   }
}
<span>// The example displays the following output:</span>
<span>//       Match: 'This is one sentence.' at index 0.</span>
<span>//          Group 0: 'This is one sentence.' at index 0.</span>
<span>//             Capture 0: 'This is one sentence.' at 0.</span>
<span>//          Group 1: 'sentence' at index 12.</span>
<span>//             Capture 0: 'This ' at 0.</span>
<span>//             Capture 1: 'is ' at 5.</span>
<span>//             Capture 2: 'one ' at 8.</span>
<span>//             Capture 3: 'sentence' at 12.</span>
<span>//</span>
<span>//       Match: 'This is another.' at index 22.</span>
<span>//          Group 0: 'This is another.' at index 22.</span>
<span>//             Capture 0: 'This is another.' at 22.</span>
<span>//          Group 1: 'another' at index 30.</span>
<span>//             Capture 0: 'This ' at 22.</span>
<span>//             Capture 1: 'is ' at 27.</span>
<span>//             Capture 2: 'another' at 30.</span>
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#8" data-author-content="Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim input As String = &quot;This is one sentence. This is another.&quot;
        Dim pattern As String = &quot;\b(\w+[;,]?\s?)+[.?!]&quot;

        For Each match As Match In Regex.Matches(input, pattern)
            Console.WriteLine(&quot;Match: '{0}' at index {1}.&quot;,
                              match.Value, match.Index)
            Dim grpCtr As Integer = 0
            For Each grp As Group In match.Groups
                Console.WriteLine(&quot;   Group {0}: '{1}' at index {2}.&quot;,
                                  grpCtr, grp.Value, grp.Index)
                Dim capCtr As Integer = 0
                For Each cap As Capture In grp.Captures
                    Console.WriteLine(&quot;      Capture {0}: '{1}' at {2}.&quot;,
                                      capCtr, cap.Value, cap.Index)
                    capCtr += 1
                Next
                grpCtr += 1
            Next
            Console.WriteLine()
        Next
    End Sub
End Module
' The example displays the following output:
'       Match: 'This is one sentence.' at index 0.
'          Group 0: 'This is one sentence.' at index 0.
'             Capture 0: 'This is one sentence.' at 0.
'          Group 1: 'sentence' at index 12.
'             Capture 0: 'This ' at 0.
'             Capture 1: 'is ' at 5.
'             Capture 2: 'one ' at 8.
'             Capture 3: 'sentence' at 12.
'       
'       Match: 'This is another.' at index 22.
'          Group 0: 'This is another.' at index 22.
'             Capture 0: 'This is another.' at 22.
'          Group 1: 'another' at index 30.
'             Capture 0: 'This ' at 22.
'             Capture 1: 'is ' at 27.
'             Capture 2: 'another' at 30.
">Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim input As String = "This is one sentence. This is another."
        Dim pattern As String = "\b(\w+[;,]?\s?)+[.?!]"

        For Each match As Match In Regex.Matches(input, pattern)
            Console.WriteLine("Match: '{0}' at index {1}.",
                              match.Value, match.Index)
            Dim grpCtr As Integer = 0
            For Each grp As Group In match.Groups
                Console.WriteLine("   Group {0}: '{1}' at index {2}.",
                                  grpCtr, grp.Value, grp.Index)
                Dim capCtr As Integer = 0
                For Each cap As Capture In grp.Captures
                    Console.WriteLine("      Capture {0}: '{1}' at {2}.",
                                      capCtr, cap.Value, cap.Index)
                    capCtr += 1
                Next
                grpCtr += 1
            Next
            Console.WriteLine()
        Next
    End Sub
End Module
' The example displays the following output:
'       Match: 'This is one sentence.' at index 0.
'          Group 0: 'This is one sentence.' at index 0.
'             Capture 0: 'This is one sentence.' at 0.
'          Group 1: 'sentence' at index 12.
'             Capture 0: 'This ' at 0.
'             Capture 1: 'is ' at 5.
'             Capture 2: 'one ' at 8.
'             Capture 3: 'sentence' at 12.
'       
'       Match: 'This is another.' at index 22.
'          Group 0: 'This is another.' at index 22.
'             Capture 0: 'This is another.' at 22.
'          Group 1: 'another' at index 30.
'             Capture 0: 'This ' at 22.
'             Capture 1: 'is ' at 27.
'             Capture 2: 'another' at 30.
</code></pre>
<p>When you use subexpressions only to apply quantifiers to them, and you are not interested in the captured text, you should disable group captures. For example, the <code>(?:subexpression)</code> language element prevents the group to which it applies from capturing matched substrings. In the following example, the regular expression pattern from the previous example is changed to <code>\b(?:\w+[;,]?\s?)+[.?!]</code>. As the output shows, it prevents the regular expression engine from populating the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.groupcollection" data-linktype="absolute-path">GroupCollection</a> and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.capturecollection" data-linktype="absolute-path">CaptureCollection</a> collections.</p>
<pre tabindex="0"><code name="Conceptual.RegularExpressions.BestPractices#9" data-author-content="using System;
using System.Text.RegularExpressions;

public class Example
{
   public static void Main()
   {
      string input = &quot;This is one sentence. This is another.&quot;;
      string pattern = @&quot;\b(?:\w+[;,]?\s?)+[.?!]&quot;;

      foreach (Match match in Regex.Matches(input, pattern)) {
         Console.WriteLine(&quot;Match: '{0}' at index {1}.&quot;,
                           match.Value, match.Index);
         int grpCtr = 0;
         foreach (Group grp in match.Groups) {
            Console.WriteLine(&quot;   Group {0}: '{1}' at index {2}.&quot;,
                              grpCtr, grp.Value, grp.Index);
            int capCtr = 0;
            foreach (Capture cap in grp.Captures) {
               Console.WriteLine(&quot;      Capture {0}: '{1}' at {2}.&quot;,
                                 capCtr, cap.Value, cap.Index);
               capCtr++;
            }
            grpCtr++;
         }
         Console.WriteLine();
      }
   }
}
// The example displays the following output:
//       Match: 'This is one sentence.' at index 0.
//          Group 0: 'This is one sentence.' at index 0.
//             Capture 0: 'This is one sentence.' at 0.
//
//       Match: 'This is another.' at index 22.
//          Group 0: 'This is another.' at index 22.
//             Capture 0: 'This is another.' at 22.
"><span><span>using</span> System;
<span>using</span> System.Text.RegularExpressions;

<span>public</span> <span>class</span> <span>Example</span>
{
   <span><span>public</span> <span>static</span> <span>void</span> <span>Main</span>(<span></span>)</span>
   {
      <span>string</span> input = <span>"This is one sentence. This is another."</span>;
      <span>string</span> pattern = <span>@"\b(?:\w+[;,]?\s?)+[.?!]"</span>;

      <span>foreach</span> (Match match <span>in</span> Regex.Matches(input, pattern)) {
         Console.WriteLine(<span>"Match: '{0}' at index {1}."</span>,
                           match.Value, match.Index);
         <span>int</span> grpCtr = <span>0</span>;
         <span>foreach</span> (Group grp <span>in</span> match.Groups) {
            Console.WriteLine(<span>"   Group {0}: '{1}' at index {2}."</span>,
                              grpCtr, grp.Value, grp.Index);
            <span>int</span> capCtr = <span>0</span>;
            <span>foreach</span> (Capture cap <span>in</span> grp.Captures) {
               Console.WriteLine(<span>"      Capture {0}: '{1}' at {2}."</span>,
                                 capCtr, cap.Value, cap.Index);
               capCtr++;
            }
            grpCtr++;
         }
         Console.WriteLine();
      }
   }
}
<span>// The example displays the following output:</span>
<span>//       Match: 'This is one sentence.' at index 0.</span>
<span>//          Group 0: 'This is one sentence.' at index 0.</span>
<span>//             Capture 0: 'This is one sentence.' at 0.</span>
<span>//</span>
<span>//       Match: 'This is another.' at index 22.</span>
<span>//          Group 0: 'This is another.' at index 22.</span>
<span>//             Capture 0: 'This is another.' at 22.</span>
</span></code></pre><pre tabindex="0" hidden=""><code name="Conceptual.RegularExpressions.BestPractices#9" data-author-content="Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim input As String = &quot;This is one sentence. This is another.&quot;
        Dim pattern As String = &quot;\b(?:\w+[;,]?\s?)+[.?!]&quot;

        For Each match As Match In Regex.Matches(input, pattern)
            Console.WriteLine(&quot;Match: '{0}' at index {1}.&quot;,
                              match.Value, match.Index)
            Dim grpCtr As Integer = 0
            For Each grp As Group In match.Groups
                Console.WriteLine(&quot;   Group {0}: '{1}' at index {2}.&quot;,
                                  grpCtr, grp.Value, grp.Index)
                Dim capCtr As Integer = 0
                For Each cap As Capture In grp.Captures
                    Console.WriteLine(&quot;      Capture {0}: '{1}' at {2}.&quot;,
                                      capCtr, cap.Value, cap.Index)
                    capCtr += 1
                Next
                grpCtr += 1
            Next
            Console.WriteLine()
        Next
    End Sub
End Module
' The example displays the following output:
'       Match: 'This is one sentence.' at index 0.
'          Group 0: 'This is one sentence.' at index 0.
'             Capture 0: 'This is one sentence.' at 0.
'       
'       Match: 'This is another.' at index 22.
'          Group 0: 'This is another.' at index 22.
'             Capture 0: 'This is another.' at 22.
">Imports System.Text.RegularExpressions

Module Example
    Public Sub Main()
        Dim input As String = "This is one sentence. This is another."
        Dim pattern As String = "\b(?:\w+[;,]?\s?)+[.?!]"

        For Each match As Match In Regex.Matches(input, pattern)
            Console.WriteLine("Match: '{0}' at index {1}.",
                              match.Value, match.Index)
            Dim grpCtr As Integer = 0
            For Each grp As Group In match.Groups
                Console.WriteLine("   Group {0}: '{1}' at index {2}.",
                                  grpCtr, grp.Value, grp.Index)
                Dim capCtr As Integer = 0
                For Each cap As Capture In grp.Captures
                    Console.WriteLine("      Capture {0}: '{1}' at {2}.",
                                      capCtr, cap.Value, cap.Index)
                    capCtr += 1
                Next
                grpCtr += 1
            Next
            Console.WriteLine()
        Next
    End Sub
End Module
' The example displays the following output:
'       Match: 'This is one sentence.' at index 0.
'          Group 0: 'This is one sentence.' at index 0.
'             Capture 0: 'This is one sentence.' at 0.
'       
'       Match: 'This is another.' at index 22.
'          Group 0: 'This is another.' at index 22.
'             Capture 0: 'This is another.' at 22.
</code></pre>
<p>You can disable captures in one of the following ways:</p>
<ul>
<li><p>Use the <code>(?:subexpression)</code> language element. This element prevents the capture of matched substrings in the group to which it applies. It does not disable substring captures in any nested groups.</p>
</li>
<li><p>Use the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions#System_Text_RegularExpressions_RegexOptions_ExplicitCapture" data-linktype="absolute-path">ExplicitCapture</a> option. It disables all unnamed or implicit captures in the regular expression pattern. When you use this option, only substrings that match named groups defined with the <code>(?&lt;name&gt;subexpression)</code> language element can be captured. The <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regexoptions#System_Text_RegularExpressions_RegexOptions_ExplicitCapture" data-linktype="absolute-path">ExplicitCapture</a> flag can be passed to the <code>options</code> parameter of a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> class constructor or to the <code>options</code> parameter of a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex" data-linktype="absolute-path">Regex</a> static matching method.</p>
</li>
<li><p>Use the <code>n</code> option in the <code>(?imnsx)</code> language element. This option disables all unnamed or implicit captures from the point in the regular expression pattern at which the element appears. Captures are disabled either until the end of the pattern or until the <code>(-n)</code> option enables unnamed or implicit captures. For more information, see <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/miscellaneous-constructs-in-regular-expressions" data-linktype="relative-path">Miscellaneous Constructs</a>.</p>
</li>
<li><p>Use the <code>n</code> option in the <code>(?imnsx:subexpression)</code> language element. This option disables all unnamed or implicit captures in <code>subexpression</code>. Captures by any unnamed or implicit nested capturing groups are disabled as well.</p>
</li>
</ul>



						<!-- </content> -->

						</main>

						<!-- recommended content page section -->

							<nav data-bi-name="recommendation-bottom" hidden="" id="recommended-content-center" aria-labelledby="recommended-content-center-title">
								<h3 id="recommended-content-center-title">Related Articles</h3>
							</nav>

						<!-- end recommended content page section -->

						<!-- page rating section -->
								
						<!-- end page rating section -->


						<!-- feedback section -->
<section data-bi-name="feedback-section">

    <h2 id="feedback">Feedback</h2>

    <div>
        <p aria-hidden="true" id="send-feedback-about">Submit and view feedback for</p>

        
    </div>

    
</section>

						<!-- end feedback section -->

						<!-- feedback report section -->
						<!-- end feedback report section -->

						
					</div>

					

					<!--end of div.columns -->
				</div>

			<!--end of .primary-holder -->
			</section>

			
		</div>

		<!--end of .mainContainer -->
	</div>

	

	

		
		
	
	<span id="adobe-target-experiment-container" hidden=""></span>


</div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>