<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Announcing .NET Core 3.0 | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Announcing .NET Core 3.0 | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard"/>
    <meta property="og:description" content="Announcing .NET Core 3.0&#xA;We&#x2019;re excited to announce the release of .NET Core 3.0. It includes many improvements, including adding Windows Forms and WPF, adding new JSON APIs, support for ARM64 and improving performance across the board. C# 8 is also part of this release,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Announcing .NET Core 3.0 | .NET Blog</title>
<div class="readable">
        <h1>Announcing .NET Core 3.0 | .NET Blog</h1>
            <div>by Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard</div>
            <div>Reading time: 52-66 minutes</div>
        <div>Posted here: 23 Sep 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/">https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/37f91ebe219df737566a4dc7cdd53b68?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Richard</p></div></div></div><p>September 23rd, 2019</p><p>We’re excited to announce the release of .NET Core 3.0. It includes many improvements, including adding Windows Forms and WPF, adding new JSON APIs, support for ARM64 and improving performance across the board. C# 8 is also part of this release, which includes nullable, async streams, and more patterns. F# 4.7 is included, and focused on relaxing syntax and targeting .NET Standard 2.0. You can start updating existing projects to target .NET Core 3.0 today. The release is compatible with previous versions, making updating easy.</p><p>Watch the team and the community talk about <a href="https://www.dotnetconf.net/" target="_blank">.NET at .NET Conf, live NOW!</a></p><p>You can <a href="https://dotnet.microsoft.com/download/dotnet-core/3.0" target="_blank">download .NET Core 3.0</a>, for Windows, macOS, and Linux:</p><ul><li><a href="https://dotnet.microsoft.com/download/dotnet-core/3.0" target="_blank">.NET Core 3.0 SDK and Runtime</a></li><li><a href="https://snapcraft.io/dotnet-sdk" target="_blank">Snap installer</a></li><li><a href="https://hub.docker.com/_/microsoft-dotnet-core" target="_blank">Docker images</a></li></ul><p><a href="https://devblogs.microsoft.com/aspnet/asp-net-core-and-blazor-updates-in-net-core-3-0/">ASP.NET Core 3.0</a> and <a href="https://devblogs.microsoft.com/dotnet/announcing-ef-core-3-0-and-ef-6-3-general-availability/">EF Core 3.0</a> are also releasing today.</p><p><a href="https://devblogs.microsoft.com/visualstudio/dot-net-core-support-in-visual-studio-2019-version-16-3/">Visual Studio 2019 16.3</a> and <a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2019-for-mac-version-8-3/">Visual Studio for Mac 8.3</a> were also released today and are required update to use .NET Core 3.0 with Visual Studio. .NET Core 3.0 is part of Visual Studio 2019 16.3. You can just get .NET Core by simply upgrading Visual Studio 2019 16.3.</p><p>Thank you to everyone that contributed to .NET Core 3.0! Hundreds of people were involved in making this release happen, including major contributions from the community.</p><p>Release notes:</p><ul><li><a href="https://github.com/dotnet/core/tree/master/release-notes/3.0" target="_blank">.NET Core 3.0 release notes</a></li><li><a href="https://github.com/dotnet/core/blob/master/release-notes/3.0/api-diff/3.0.0.md" target="_blank">.NET Core 2.2 -&gt; 3.0 API diff</a></li><li><a href="https://github.com/dotnet/core/blob/master/release-notes/3.0/3.0.0/3.0.0-contrib.md" target="_blank">.NET Core 3.0 contributor list</a></li><li><a href="https://github.com/dotnet/core/releases/tag/v3.0.0" target="_blank">GitHub release</a></li><li><a href="https://github.com/dotnet/core/issues/3430" target="_blank">GitHub issue for .NET Core 3.0 issues</a></li></ul><p>Note: There are some contributors missing from the contributor list. We’re working on fixing that. Send mail to dotnet@microsoft.com if you are missing.</p><h2>What you should know about 3.0</h2><p>There are some key improvements and guidance that are important to draw attention to before we go into a deep dive on all the new features in .NET Core 3.0. Here’s the quick punch list.</p><ul><li><strong>.NET Core 3.0 is already battle-tested</strong> by being hosted for months at <a href="https://dotnet.microsoft.com/" target="_blank">dot.net</a> and on <a href="https://bing.com/" target="_blank">Bing.com</a>. Many other Microsoft teams will soon be deploying large workloads on .NET Core 3.0 in production.</li><li><strong>Performance is greatly improved</strong> across many components and is described in detail at <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/">Performance Improvements in .NET Core 3.0</a>.</li><li><strong>C# 8</strong> add async streams, range/index, more patterns, and nullable reference types. Nullable enables you to directly target the flaws in code that lead to <code>NullReferenceException</code>. The lowest layer of the framework libraries has been annotated, so that you know when to expect <code>null</code>.</li><li><strong>F# 4.7</strong> focuses on making some thing easier with implicit <code>yield</code> expressions and some syntax relaxations. It also includes support for <code>LangVersion</code>, and ships with <code>nameof</code> and opening of static classes in preview. The F# Core Library now also targets .NET Standard 2.0. You can read more at <a href="https://devblogs.microsoft.com/dotnet/announcing-f-4-7/">Announcing F# 4.7</a>.</li><li><strong>.NET Standard 2.1</strong> increases the set of types you can use in code that can be used with both .NET Core and Xamarin. <a href="https://devblogs.microsoft.com/dotnet/announcing-net-standard-2-1/">.NET Standard 2.1</a> includes types since .NET Core 2.1.</li><li><strong>Windows Desktop</strong> apps are now supported with .NET Core, for both <a href="https://github.com/dotnet/winforms" target="_blank">Windows Forms</a> and <a href="https://github.com/dotnet/wpf" target="_blank">WPF</a> (and open source). The WPF designer is part of Visual Studio 2019 16.3. The Windows Forms designer is still in preview and available as a <a href="https://aka.ms/winforms-designer" target="_blank">VSIX download</a>.</li><li><strong>.NET Core apps now have executables</strong> by default. In past releases, apps needed to be launched via the <code>dotnet</code> command, like <code>dotnet myapp.dll</code>. Apps can now be launched with an app-specific executable, like <code>myapp</code> or <code>./myapp</code>, depending on the operating system.</li><li><strong>High performance JSON APIs</strong> have been added, for reader/writer, object model and serialization scenarios. These APIs were built from scratch on top of <code>Span&lt;T&gt;</code> and use UTF-8 under the covers instead of UTF-16 (like <code>string</code>). These APIs minimize allocations, resulting in faster performance, and much less work for the garbage collector. See <a href="https://github.com/dotnet/corefx/issues/33115" target="_blank">The future of JSON in .NET Core 3.0</a>.</li><li><strong>The garbage collector uses less memory</strong> by default, often a lot less. This improvement is very beneficial for scenarios where many applications are hosted on the same server. The garbage collector has also been updated to make better use of large numbers of cores, on machines with &gt;64 cores.</li><li><strong>.NET Core has been hardened for Docker</strong> to enable .NET applications to work predictably and efficiently in containers. The garbage collector and thread pool have been updated to work much better when a container has been configured for limited memory or CPU. .NET Core docker images are smaller, particularly the SDK image.</li><li><strong>Raspberry Pi and ARM chips</strong> are now supported to enable IoT development, including with the remote Visual Studio debugger. You can deploy apps that listen to sensors, and print messages or images on a display, all using the new GPIO APIs. ASP.NET can be used to expose data as an API or as a site that enables configuring an IoT device.</li><li><strong>.NET Core 3.0 is a ‘current’ release</strong> and will be superseded by <strong>.NET Core 3.1</strong>, targeted for November 2019. .NET Core 3.1 will be a <a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core" target="_blank">long-term supported (LTS) release</a> (supported for at least 3 years). We recommend that you adopt .NET Core 3.0 and then adopt 3.1. It’ll be very easy to upgrade.</li><li><strong>.NET Core 2.2 will go EOL on 12/23</strong> as it is now the previous ‘current’ release. See <a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core" target="_blank">.NET Core support policy</a>.</li><li><strong>.NET Core 3.0 will be available with RHEL 8</strong> in the Red Hat Application Streams, after several years of collaboration with Red Hat.</li><li><strong>Visual Studio 2019 16.3</strong> is a required update for Visual Studio users on Windows that want to use .NET Core 3.0.</li><li><strong>Visual Studio for Mac 8.3</strong> is a required update for Visual Studio for Mac users that want to use .NET Core 3.0.</li><li><strong>Visual Studio Code</strong> users should just always use the latest version of the C# extension to ensure that the newest scenarios work, including targeting .NET Core 3.0.</li><li><strong>Azure App Service</strong> deployment of .NET Core 3.0 is currently ongoing. See our <a href="https://aspnetcoreon.azurewebsites.net/" target="_blank">tracking site</a> to track when .NET Core 3.0 is available in your region.</li><li><strong>Azure DevOps</strong> deployment of .NET Core 3.0 is coming soon. Will update when it is available.</li></ul><h2>Platform support</h2><p>.NET Core 3.0 is supported on the following operating systems:</p><ul><li>Alpine: 3.9+</li><li>Debian: 9+</li><li>openSUSE: 42.3+</li><li>Fedora: 26+</li><li>Ubuntu: 16.04+</li><li>RHEL: 6+</li><li>SLES: 12+</li><li>macOS: 10.13+</li><li>Windows Client: 7, 8.1, 10 (1607+)</li><li>Windows Server: 2012 R2 SP1+</li></ul><p>Note: Windows Forms and WPF apps only work on Windows.</p><p>Chip support follows:</p><ul><li>x64 on Windows, macOS, and Linux</li><li>x86 on Windows</li><li>ARM32 on Windows and Linux</li><li>ARM64 on Linux (kernel 4.14+)</li></ul><p>Note: Please ensure that .NET Core 3.0 ARM64 deployments use Linux kernel 4.14 version or later. For example, Ubuntu 18.04 satisfies this requirement, but 16.04 does not.</p><h2>WPF and Windows Forms</h2><p>You can build WPF and Windows Forms apps with .NET Core 3, on Windows. We’ve had a strong compatibility goal from the start of the project, to make it easy to migrate desktop applications from .NET Framework to .NET Core. We’ve heard feedback from many developers that have already successfully ported their app to .NET Core 3.0 that the process is straightforward. To a large degree, we took WPF and Windows Forms as-is, and got them working on .NET Core. The engineering project was very different than that, but that’s a good way to think about the project.</p><p>The following image shows a .NET Core Windows Forms app:</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/windows-forms-app.png" alt="" width="426" height="427" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/windows-forms-app.png 426w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/windows-forms-app-150x150.png 150w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/windows-forms-app-300x300.png 300w" sizes="(max-width: 426px) 100vw, 426px"></p><p>Visual Studio 2019 16.3 has support for creating WPF apps that target .NET Core. This includes new templates and an updated XAML designer and XAML Hot Reload. The designer is similar to the existing XAML designer (that targets .NET Framework), however, you may notice some differences in experience. The big technical difference is that the designer for .NET Core uses a new surface process (wpfsurface.exe) to solely run the runtime code targeting the .NET Core version. Previously, the .NET Framework WPF designer process (xdesproc.exe) was a itself a WPF .NET Framework process hosting the designer, and due to runtime incompatibility we can’t have a WPF .NET Framework process (in this case, Visual Studio) loading two versions of .NET (.NET Framework and .NET Core) into the same process. This means that some aspects of the designer, like designer extensions, can’t work in the same way. If you are writing designer extensions, we recommend reading <a href="https://docs.microsoft.com/visualstudio/extensibility/xaml-designer-extensibility-migration?view=vs-2019" target="_blank">XAML designer extensibility migration</a>.</p><p>The following image shows a WPF app being displayed in the new designer:</p><p><img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/wpf-designer.png" alt="" width="2097" height="1346" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/wpf-designer.png 2048w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/wpf-designer-300x193.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/wpf-designer-768x493.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/09/wpf-designer-1024x657.png 1024w" sizes="(max-width: 2097px) 100vw, 2097px"></p><p>The Windows Forms designer is still in preview, and available as a <a href="https://aka.ms/winforms-designer" target="_blank">separate download</a>. It will be added to Visual Studio as part of a later release. The designer currently includes support for the most commonly used controls and low-level functionality. We’ll keep improving the designer with monthly updates. We don’t recommend porting your Windows Forms applications to .NET Core just yet, particularly if you rely on the designer. Please do experiment with the designer preview, and give us feedback.</p><p>You can also create and build desktop applications from the command line using the .NET CLI.</p><p>For example, you can quickly create a new Windows Forms app:</p><pre><code><span>dotnet </span><span>new</span><span> winforms </span><span>-</span><span>o myapp
cd myapp
dotnet run</span></code></pre><p>You can try WPF using the same flow:</p><pre><code><span>dotnet </span><span>new</span><span> wpf </span><span>-</span><span>o mywpfapp
cd mywpfapp
dotnet run</span></code></pre><p>We made <a href="https://github.com/dotnet/winforms" target="_blank">Windows Forms</a> and <a href="https://github.com/dotnet/wpf" target="_blank">WPF</a> open source, back in December 2018. It’s been great to see the community and the Windows Forms and WPF teams working together to improve those UI frameworks. In the case of WPF, we started out with a very small amount of code in the GitHub repo. At this point, almost all of WPF has been published to GitHub, and a few more components will straggle in over time. Like other .NET Core projects, these new repos are part of the .NET Foundation and licensed with the MIT license.</p><p>The <a href="https://www.nuget.org/packages/System.Windows.Forms.DataVisualization/" target="_blank">System.Windows.Forms.DataVisualization</a> package (which includes the chart control) is also available for .NET Core. You can now include this control in your .NET Core WinForms applications. The source for the chart control is available at <a href="https://github.com/dotnet/winforms-datavisualization" target="_blank">dotnet/winforms-datavisualization</a>, on GitHub. The control was migrated to ease porting to .NET Core 3, but isn’t a component we expect to update significantly.</p><h2>Windows Native Interop</h2><p>Windows offers a rich native API, in the form of flat C APIs, COM and WinRT. We’ve had support for P/Invoke since .NET Core 1.0, and have been adding the ability to CoCreate COM APIs, activate WinRT APIs, and exposed managed code as COM components as part of the .NET Core 3.0 release. We have had many requests for these capabilities, so we know that they will get a lot of use.</p><p>Late last year, we announced that we had managed to <a href="https://twitter.com/runfaster2000/status/1053704090671185920" target="_blank">automate Excel from .NET Core</a>. That was a fun moment. Under the covers, this demo is using COM interop features like NOPIA, object equivalence and custom marshallers. You can now try this and other demos yourself at <a href="https://github.com/dotnet/samples/tree/master/core/extensions" target="_blank">extension samples</a>.</p><p>Managed C++ and WinRT interop have partial support with .NET Core 3.0 and will be included with .NET Core 3.1.</p><h3>Nullable reference types</h3><p>C# 8.0 introduces <em>nullable reference types</em> and <em>non-nullable reference types</em> that enable you to make important statements about the properties for reference type variables:</p><ul><li><strong>A reference is not supposed to be null</strong>. When variables aren’t supposed to be null, the compiler enforces rules that ensure it is safe to dereference these variables without first checking that it isn’t null.</li><li><strong>A reference may be null</strong>. When variables may be null, the compiler enforces different rules to ensure that you’ve correctly checked for a null reference.</li></ul><p>This new feature provides significant benefits over the handling of reference variables in earlier versions of C# where the design intent couldn’t be determined from the variable declaration. With the addition of nullable reference types, you can declare your intent more clearly, and the compiler both helps you do that correctly and discover bugs in your code.</p><p>See <a href="https://channel9.msdn.com/Shows/On-NET/This-is-how-you-get-rid-of-null-reference-exceptions-forever" target="_blank">This is how you get rid of null reference exceptions forever</a>, <a href="https://devblogs.microsoft.com/dotnet/try-out-nullable-reference-types/">Try out Nullable Reference Types</a> and <a href="https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references" target="_blank">Nullable reference types</a> to learn more.</p><h2>Default implementations of interface members</h2><p>Today, once you publish an interface, it’s game over for changing it: you can’t add members to it without breaking all the existing implementers of it.</p><p>With C# 8.0, you can provide a body for an interface member. As a result, if a class that implements the interface doesn’t implement that member (perhaps because it wasn’t there yet when they wrote the code), then the calling code will just get the default implementation instead.</p><pre><code><span>interface</span><span> </span><span>ILogger</span><span>
</span><span>{</span><span>
    </span><span>void</span><span> </span><span>Log</span><span>(</span><span>LogLevel</span><span> level</span><span>,</span><span> </span><span>string</span><span> message</span><span>);</span><span>
    </span><span>void</span><span> </span><span>Log</span><span>(</span><span>Exception</span><span> ex</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>Log</span><span>(</span><span>LogLevel</span><span>.</span><span>Error</span><span>,</span><span> ex</span><span>.</span><span>ToString</span><span>());</span><span> </span><span>// New overload</span><span>
</span><span>}</span><span>
</span><span>class</span><span> </span><span>ConsoleLogger</span><span> </span><span>:</span><span> </span><span>ILogger</span><span>
</span><span>{</span><span>
    </span><span>public</span><span> </span><span>void</span><span> </span><span>Log</span><span>(</span><span>LogLevel</span><span> level</span><span>,</span><span> </span><span>string</span><span> message</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>
    </span><span>// Log(Exception) gets default implementation</span><span>
</span><span>}</span></code></pre><p>In this example, the <code>ConsoleLogger</code> class doesn’t have to implement the <code>Log(Exception)</code> overload of ILogger, because it is declared with a default implementation. Now you can add new members to existing public interfaces as long as you provide a default implementation for existing implementors to use.</p><h2>Async streams</h2><p>You can now <code>foreach</code> over an async stream of data using <code>IAsyncEnumerable&lt;T&gt;</code>. This new interface is exactly what you’d expect; an asynchronous version of <code>IEnumerable&lt;T&gt;</code>. The language lets you <code>await foreach</code> over tasks to consume their elements. On the production side, you <code>yield return</code> items to produce an async stream. It might sound a bit complicated, but it is incredibly easy in practice.</p><p>The following example demonstrates both production and consumption of async streams. The foreach statement is async and itself uses yield return to produce an async stream for callers. This pattern – using <code>yield return</code> — is the recommended model for producing async streams.</p><pre><code><span>async </span><span>IAsyncEnumerable</span><span>&lt;int&gt;</span><span> </span><span>GetBigResultsAsync</span><span>()</span><span>
</span><span>{</span><span>
    await </span><span>foreach</span><span> </span><span>(</span><span>var</span><span> result </span><span>in</span><span> </span><span>GetResultsAsync</span><span>())</span><span>
    </span><span>{</span><span>
        </span><span>if</span><span> </span><span>(</span><span>result </span><span>&gt;</span><span> </span><span>20</span><span>)</span><span> </span><span>yield</span><span> </span><span>return</span><span> result</span><span>;</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>In addition to being able to <code>await foreach</code>, you can also create async iterators, e.g. an iterator that returns an <code>IAsyncEnumerable</code>/<code>IAsyncEnumerator</code> that you can both <code>await</code> and <code>yield return</code> in. For objects that need to be disposed, you can use <code>IAsyncDisposable</code>, which various framework types implement, such as <code>Stream</code> and <code>Timer</code>.</p><h2>Index and Range</h2><p>We’ve created new syntax and types that you can use to describe indexers, for array element access or for any other type that exposes direct data access. This includes support for both a single value — the usual definition of an index — or two values, which describing a range.</p><p><code>Index</code> is a new type that describes an array index. You can create an <code>Index</code> from an int that counts from the beginning, or with a prefix <code>^</code> operator that counts from the end. You can see both cases in the following example:</p><pre><code><span>Index</span><span> i1 </span><span>=</span><span> </span><span>3</span><span>;</span><span>  </span><span>// number 3 from beginning</span><span>
</span><span>Index</span><span> i2 </span><span>=</span><span> </span><span>^</span><span>4</span><span>;</span><span> </span><span>// number 4 from end</span><span>
</span><span>int</span><span>[]</span><span> a </span><span>=</span><span> </span><span>{</span><span> </span><span>0</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>6</span><span>,</span><span> </span><span>7</span><span>,</span><span> </span><span>8</span><span>,</span><span> </span><span>9</span><span> </span><span>};</span><span>
</span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>$</span><span>"{a[i1]}, {a[i2]}"</span><span>);</span><span> </span><span>// "3, 6"</span></code></pre><p><code>Range</code> is similar, consisting of two <code>Index</code> values, one for the start and one for the end, and can be written with a x..y range expression. You can then index with a <code>Range</code> in order to produce a slice of the underlying data, as demonstrated in the following example:</p><pre><code><span>var</span><span> slice </span><span>=</span><span> a</span><span>[</span><span>i1</span><span>..</span><span>i2</span><span>];</span><span> </span><span>// { 3, 4, 5 }</span></code></pre><h2>Using Declarations</h2><p>Are you tired of using statements that require indenting your code? No more! You can now write the following code, which attaches a using declaration to the scope of the current statement block and then disposes the object at the end of it.</p><pre><code><span>using</span><span> </span><span>System</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Linq</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Collections</span><span>.</span><span>Generic</span><span>;</span><span>
</span><span>using</span><span> </span><span>static</span><span> </span><span>System</span><span>.</span><span>Console</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>IO</span><span>;</span><span>

</span><span>namespace</span><span> usingapp
</span><span>{</span><span>
    </span><span>class</span><span> </span><span>Program</span><span>
    </span><span>{</span><span>
        </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>()</span><span>
        </span><span>{</span><span>
            </span><span>var</span><span> filename </span><span>=</span><span> </span><span>"Program.cs"</span><span>;</span><span>
            </span><span>var</span><span> line </span><span>=</span><span> </span><span>string</span><span>.</span><span>Empty</span><span>;</span><span>
            </span><span>var</span><span> magicString </span><span>=</span><span> </span><span>"magicString"</span><span>;</span><span>

            </span><span>var</span><span> file </span><span>=</span><span> </span><span>new</span><span> </span><span>FileInfo</span><span>(</span><span>filename</span><span>);</span><span>
            </span><span>using</span><span> </span><span>var</span><span> reader </span><span>=</span><span> file</span><span>.</span><span>OpenText</span><span>();</span><span>
            </span><span>while</span><span> </span><span>((</span><span>line </span><span>=</span><span> reader</span><span>.</span><span>ReadLine</span><span>())!=</span><span> </span><span>null</span><span>)</span><span>
            </span><span>{</span><span>
                </span><span>if</span><span> </span><span>(</span><span>line</span><span>.</span><span>Contains</span><span>(</span><span>magicString</span><span>))</span><span>  
                </span><span>{</span><span> 
                    </span><span>WriteLine</span><span>(</span><span>"Found string"</span><span>);</span><span> 
                    </span><span>return</span><span>;</span><span>
                </span><span>}</span><span>
            </span><span>}</span><span>

            </span><span>WriteLine</span><span>(</span><span>"String not found"</span><span>);</span><span>
        </span><span>}</span><span> </span><span>// reader disposed here</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><h2>Switch Expressions</h2><p>Anyone who uses C# probably loves the idea of a switch statement, but not the syntax. C# 8 introduces switch expressions, which enable the following:</p><ul><li>terser syntax</li><li>returns a value since it is an expression</li><li>fully integrated with pattern matching</li></ul><p>The switch keyword is “infix”, meaning the keyword sits between the tested value (that’s <code>o</code> in the first example) and the list of cases, much like expression lambdas.</p><p>The first examples uses the lambda syntax for methods, which integrates well with the switch expressions but isn’t required.</p><pre><code><span>static</span><span> </span><span>string</span><span> </span><span>Display</span><span>(</span><span>object</span><span> o</span><span>)</span><span> </span><span>=&gt;</span><span> o </span><span>switch</span><span>
</span><span>{</span><span>
    </span><span>Point</span><span> </span><span>{</span><span> X</span><span>:</span><span> </span><span>0</span><span>,</span><span> Y</span><span>:</span><span> </span><span>0</span><span> </span><span>}</span><span>         </span><span>=&gt;</span><span> </span><span>"origin"</span><span>,</span><span>
    </span><span>Point</span><span> </span><span>{</span><span> X</span><span>:</span><span> </span><span>var</span><span> x</span><span>,</span><span> Y</span><span>:</span><span> </span><span>var</span><span> y </span><span>}</span><span> </span><span>=&gt;</span><span> $</span><span>"({x}, {y})"</span><span>,</span><span>
    _                            </span><span>=&gt;</span><span> </span><span>"unknown"</span><span>
</span><span>};</span></code></pre><p>There are two patterns at play in this example. o first matches with the Point type pattern and then with the property pattern inside the {curly braces}. The _ describes the discard pattern, which is the same as default for switch statements.</p><p>You can go one step further, and rely on tuple deconstruction and parameter position, as you can see in the following example:</p><pre><code><span>static</span><span> </span><span>State</span><span> </span><span>ChangeState</span><span>(</span><span>State</span><span> current</span><span>,</span><span> </span><span>Transition</span><span> transition</span><span>,</span><span> </span><span>bool</span><span> hasKey</span><span>)</span><span> </span><span>=&gt;</span><span>
    </span><span>(</span><span>current</span><span>,</span><span> transition</span><span>)</span><span> </span><span>switch</span><span>
    </span><span>{</span><span>
        </span><span>(</span><span>Opened</span><span>,</span><span> </span><span>Close</span><span>)</span><span>              </span><span>=&gt;</span><span> </span><span>Closed</span><span>,</span><span>
        </span><span>(</span><span>Closed</span><span>,</span><span> </span><span>Open</span><span>)</span><span>               </span><span>=&gt;</span><span> </span><span>Opened</span><span>,</span><span>
        </span><span>(</span><span>Closed</span><span>,</span><span> </span><span>Lock</span><span>)</span><span>   </span><span>when</span><span> hasKey </span><span>=&gt;</span><span> </span><span>Locked</span><span>,</span><span>
        </span><span>(</span><span>Locked</span><span>,</span><span> </span><span>Unlock</span><span>)</span><span> </span><span>when</span><span> hasKey </span><span>=&gt;</span><span> </span><span>Closed</span><span>,</span><span>
        _ </span><span>=&gt;</span><span> </span><span>throw</span><span> </span><span>new</span><span> </span><span>InvalidOperationException</span><span>(</span><span>$</span><span>"Invalid transition"</span><span>)</span><span>
    </span><span>};</span></code></pre><p>In this example, you can see you do not need to define a variable or explicit type for each of the cases. Instead, the compiler can match the tuple being testing with the tuples defined for each of the cases.</p><p>All of these patterns enable you to write declarative code that captures your intent instead of procedural code that implements tests for it. The compiler becomes responsible for implementing that boring procedural code and is guaranteed to always do it correctly.</p><p>There will still be cases where switch statements will be a better choice than switch expressions and patterns can be used with both syntax styles.</p><h2>Introducing a fast JSON API</h2><p>.NET Core 3.0 includes a new family of JSON APIs that enable reader/writer scenarios, random access with a document object model (DOM) and a serializer. You are likely familiar with using <a href="https://www.newtonsoft.com/json" target="_blank">Newtonsoft.Json</a>. The new APIs are intended to satisfy many of the same scenarios, but with less memory and faster execution.</p><p>You can see the initial motivation and description of the plan in <a href="https://github.com/dotnet/corefx/issues/33115" target="_blank">The future of JSON in .NET Core 3.0</a>. This includes <a href="https://github.com/jamesnk" target="_blank">James Newton-King</a>, the author of Newtonsoft.Json, explaining why a new API was created, as opposed to extending Newtonsoft.Json. In short, we wanted to build a new JSON API that took advantage of all the new performance capabilities in .NET Core, and delivered performance inline with that. It wasn’t possible to do that in an existing codebase like Newtonsoft.Json while maintaining compatibility.</p><p>Let’s take a quick look at the new API, layer by layer.</p><h3>Utf8JsonReader</h3><p><code>System.Text.Json.Utf8JsonReader</code> is a high-performance, low allocation, forward-only reader for UTF-8 encoded JSON text, read from a <code>ReadOnlySpan&lt;byte&gt;</code>. The <code>Utf8JsonReader</code> is a foundational, low-level type, that can be leveraged to build custom parsers and deserializers. Reading through a JSON payload using the new Utf8JsonReader is 2x faster than using the reader from Newtonsoft.Json. It does not allocate until you need to actualize JSON tokens as (UTF-16) strings.</p><h3>Utf8JsonWriter</h3><p><code>System.Text.Json.Utf8JsonWriter</code> provides a high-performance, non-cached, forward-only way to write UTF-8 encoded JSON text from common .NET types like <code>String</code>, <code>Int32</code>, and <code>DateTime</code>. Like the reader, the writer is a foundational, low-level type, that can be leveraged to build custom serializers. Writing a JSON payload using the new <code>Utf8JsonWriter</code> is 30-80% faster than using the writer from <code>Newtonsoft.Json</code> and does not allocate.</p><h3>JsonDocument</h3><p><code>System.Text.Json.JsonDocument</code> provides the ability to parse JSON data and build a read-only Document Object Model (DOM) that can be queried to support random access and enumeration. It is built on top of the <code>Utf8JsonReader</code>. The JSON elements that compose the data can be accessed via the <code>JsonElement</code> type which is exposed by the <code>JsonDocument</code> as a property called <code>RootElement</code>. The <code>JsonElement</code> contains the JSON array and object enumerators along with APIs to convert JSON text to common .NET types. Parsing a typical JSON payload and accessing all its members using the <code>JsonDocument</code> is 2-3x faster than <code>Newtonsoft.Json</code> with very little allocations for data that is reasonably sized (i.e. &lt; 1 MB).</p><h3>JSON Serializer</h3><p><code>System.Text.Json.JsonSerializer</code> layers on top of the high-performance <code>Utf8JsonReader</code> and <code>Utf8JsonWriter</code>. It deserializes objects from JSON and serializes objects to JSON. Memory allocations are kept minimal and includes support for reading and writing JSON with <code>Stream</code> asynchronously.</p><p>See the <a href="https://docs.microsoft.com/dotnet/standard/serialization/system-text-json-overview" target="_blank">documentation</a> for information and samples.</p><h2>Introducing the new SqlClient</h2><p>SqlClient is the data provider you use to access Microsoft SQL Server and Azure SQL Database, either through one of the popular .NET O/RMs, like EF Core or Dapper, or directly using the ADO.NET APIs. It will now be released and updated as the <a href="https://www.nuget.org/packages/Microsoft.Data.SqlClient/" target="_blank">Microsoft.Data.SqlClient</a> NuGet package, and supported for both .NET Framework and .NET Core applications. By using NuGet, it will be easier for the SQL team to provide updates to both .NET Framework and .NET Core users.</p><h2>ARM and IoT Support</h2><p>We added support for Linux ARM64 this release, after having added support for ARM32 for Linux and Windows in the .NET Core 2.1 and 2.2, respectively. While some IoT workloads take advantage of our existing x64 capabilities, many users had been asking for ARM support. That is now in place, and we are working with customers who are planning large deployments.</p><p>Many IoT deployments using .NET are edge devices, and entirely network-oriented. Other scenarios require direct access to hardware. In this release, we added the capability to use serial ports on Linux and take advantage of digital pins on devices like the Raspberry Pi. The pins use a variety of protocols. We added support for GPIO, PWM, I2C, and SPI, to enable reading sensor data, interacting with radios and writing text and images to displays, and many other scenarios.</p><p>This functionality is available as part of the following packages:</p><ul><li><a href="https://www.nuget.org/packages/System.Device.Gpio" target="_blank">System.Device.Gpio</a></li><li><a href="https://www.nuget.org/packages/Iot.Device.Bindings" target="_blank">Iot.Device.Bindings</a></li></ul><p>As part of providing support for GPIO (and friends), we took a look at what was already available. We found APIs for C# and also Python. In both cases, the APIs were wrappers over native libraries, which were often licensed as GPL. We didn’t see a path forward with that approach. Instead, we built a 100% C# solution to implement these protocols. This means that our APIs will work anywhere .NET Core is supported, can be debugged with a C# debugger (via sourcelink), and supports multiple underlying Linux drivers (sysfs, libgpiod, and board-specific). All of the code is licensed as MIT. We see this approach as a major improvement for .NET developers compared to what has existed.</p><p>See <a href="https://github.com/dotnet/iot" target="_blank">dotnet/iot</a> to learn more. The best places to start are <a href="https://github.com/dotnet/iot/blob/master/samples/README.md" target="_blank">samples</a> or <a href="https://github.com/dotnet/iot/blob/master/src/devices/README.md" target="_blank">devices</a>. We have built a few experiments while adding support for GPIO. One of them was validating that we could <a href="https://www.youtube.com/watch?v=TW4K64hfa5U" target="_blank">control an Arduino from a Pi</a> through a serial port connection. That was suprisingly easy. We also spent a lot of time playing with <a href="https://learn.adafruit.com/32x16-32x32-rgb-led-matrix/" target="_blank">LED matrices</a>, as you can see in this <a href="https://github.com/dotnet/iot/blob/master/src/devices/RGBLedMatrix/README.md" target="_blank">RGB LED Matrix sample</a>. We expect to share more of these experiments over time.</p><h2>.NET Core runtime roll-forward policy update</h2><p>The .NET Core runtime, actually the runtime binder, now enables major-version roll-forward as an opt-in policy. The runtime binder already enables roll-forward on patch and minor versions as a default policy. We decided to expose a broader set of policies, which we expected would be important for various scenarios, but did not change the default roll-forward behavior.</p><p>There is a new property called <code>RollForward</code>, which accepts the following values:</p><ul><li><code>LatestPatch</code> — Rolls forward to the highest patch version. This disables the <code>Minor</code> policy.</li><li><code>Minor</code> — Rolls forward to the lowest higher minor version, if the requested minor version is missing. If the requested minor version is present, then the <code>LatestPatch</code> policy is used. This is the default policy.</li><li><code>Major</code> — Rolls forward to lowest higher major version, and lowest minor version, if the requested major version is missing. If the requested major version is present, then the <code>Minor</code> policy is used.</li><li><code>LatestMinor</code> — Rolls forward to highest minor version, even if the requested minor version is present.</li><li><code>LatestMajor</code> — Rolls forward to highest major and highest minor version, even if requested major is present.</li><li><code>Disable</code> — Do not roll forward. Only bind to specified version. This policy is not recommended for general use since it disable the ability to roll-forward to the latest patches. It is only recommended for testing.</li></ul><p>See <a href="https://github.com/dotnet/designs/blob/master/accepted/runtime-binding.md" target="_blank">Runtime Binding Behavior</a> and <a href="https://github.com/dotnet/core-setup/pull/5691" target="_blank">dotnet/core-setup #5691</a> for more information.</p><h2>Docker and cgroup Limits</h2><p>Many developers are <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/">packaging and running their application with containers</a>. A key scenario is <a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank">limiting a container’s resources</a> such as CPU or memory. We implemented <a href="https://github.com/dotnet/coreclr/pull/10064" target="_blank">support for memory limits</a> back in 2017. Unfortunately, we found that the implementation wasn’t aggressive enough to reliably stay under the configured limits and applications were still being OOM killed when memory limits are set (particular &lt;500MB). We have fixed that in .NET Core 3.0. We strongly recommend that .NET Core Docker users upgrade to .NET Core 3.0 due to this improvement.</p><p>The Docker resource limits feature is built on top of <a href="https://en.wikipedia.org/wiki/Cgroups" target="_blank">cgroups</a>, which a Linux kernel feature. From a runtime perspective, we need to target cgroup primitives.</p><p>You can limit the available memory for a container with the <code>docker run -m</code> argument, as shown in the following example that creates an Alpine-based container with a 4MB memory limit (and then <a href="https://stackoverflow.com/questions/42187085/check-mem-limit-within-a-docker-container" target="_blank">prints the memory limit</a>):</p><pre><code><span>C</span><span>:</span><span>\&gt;docker run </span><span>-</span><span>m </span><span>4mb</span><span> </span><span>--</span><span>rm alpine cat </span><span>/</span><span>sys</span><span>/</span><span>fs</span><span>/</span><span>cgroup</span><span>/</span><span>memory</span><span>/</span><span>memory</span><span>.</span><span>limit_in_bytes
</span><span>4194304</span></code></pre><p>We also added made changes to <a href="https://github.com/dotnet/coreclr/commit/aea3b1a80d6c114e3e67bc9521bf39a8a17371d1" target="_blank">better support CPU limits</a> (<code>--cpus</code>). This includes changing the way that the runtime rounds up or down for decimal CPU values. In the case where <code>--cpus</code> is set to a value close (enough) to a smaller integer (for example, 1.499999999), the runtime would previously round that value down (in this case, to 1). As a result, the runtime would take advantage of less CPUs than requested, leading to CPU underutilization. By rounding up the value, the runtime augments the pressure on the OS threads scheduler, but even in the worst case scenario (<code>--cpus=1.000000001</code> — previously rounded down to 1, now rounded to 2), we have not observed any overutilization of the CPU leading to performance degradation.</p><p>The next step was ensuring that the thread pool honors CPU limits. Part of the algorithm of the thread pool is computing CPU busy time, which is, in part, a function of available CPUs. By taking CPU limits into account when computing CPU busy time, we avoid various heuristics of the threadpool competing with each other: one trying to allocate more threads to increase the CPU busy time, and the other one trying to allocate less threads because adding more threads doesn’t improve the throughput.</p><h2>Making GC Heap Sizes Smaller by default</h2><p>While working on <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-3/">improving support for docker memory limits</a>, we were inspired to make more general GC policy updates to improve memory usage for a broader set of applications (even when not running in a container). The changes better align the generation 0 allocation budget with modern processor cache sizes and cache hierarchy.</p><p><a href="https://twitter.com/DamianEdwards" target="_blank">Damian Edwards</a> on our team noticed that the <a href="https://twitter.com/DamianEdwards/status/1093981272362254336" target="_blank">memory usage of the ASP.NET benchmarks were cut in half</a> with no negative effect on other performance metrics. That’s a staggering improvement! As he says, these are the new defaults, with no change required to his (or your) code (other than adopting .NET Core 3.0).</p><p>The memory savings that we saw with the ASP.NET benchmarks may or may not be representative of what you’ll see with your application. We’d like to hear how these changes reduce memory usage for your application.</p><h2>Better support for many proc machines</h2><p>Based on .NET’s Windows heritage, the GC needed to implement the <a href="https://docs.microsoft.com/en-us/windows/desktop/ProcThread/processor-groups" target="_blank">Windows concept of processor groups</a> to support machines with 64+ processors. This implementation was made in .NET Framework, 5-10 years ago. With .NET Core, we made the choice initially for the Linux PAL to emulate that same concept, even though it doesn’t exist in Linux. We have since abandoned this concept in the GC and transitioned it exclusively to the Windows PAL.</p><p>The GC now exposes a configuration switch, GCHeapAffinitizeRanges, to specify affinity masks on machines with 64+ processors. <a href="https://twitter.com/maoni0" target="_blank">Maoni Stephens</a> wrote about this change in <a href="https://devblogs.microsoft.com/dotnet/making-cpu-configuration-better-for-gc-on-machines-with-64-cpus/">Making CPU configuration better for GC on machines with &gt; 64 CPUs</a>.</p><h2>GC Large page support</h2><p><a href="https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support" target="_blank">Large Pages</a> or <a href="https://wiki.debian.org/Hugepages" target="_blank">Huge Pages</a> is a feature where the operating system is able to establish memory regions larger than the native page size (often 4K) to improve performance of the application requesting these large pages.</p><p>When a virtual-to-physical address translation occurs, a cache called the <a href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank">Translation lookaside buffer (TLB)</a> is first consulted (often in parallel) to check if a physical translation for the virtual address being accessed is available, to avoid doing a potentially expensive page-table walk. Each large-page translation uses a single translation buffer inside the CPU. The size of this buffer is typically three orders of magnitude larger than the native page size; this increases the efficiency of the translation buffer, which can increase performance for frequently accessed memory. This win can be even more significant in a virtual machine, which has a two-layer TLB.</p><p>The GC can now be configured with the <a href="https://github.com/dotnet/coreclr/blob/master/src/inc/clrconfigvalues.h#L326" target="_blank">GCLargePages</a> opt-in feature to choose to <a href="https://github.com/dotnet/coreclr/pull/23251" target="_blank">allocate large pages on Windows</a>. Using large pages reduces TLB misses therefore can potentially increase application perf in general, however, the feature has its own set of <a href="https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support" target="_blank">limitations</a> that should be considered. Bing has experimented with this feature and seen performance improvements.</p><h2>.NET Core Version APIs</h2><p>We have <a href="https://github.com/dotnet/coreclr/issues/22844" target="_blank">improved the .NET Core version APIs</a> in .NET Core 3.0. They now return the version information you would expect. These changes while they are objectively better are technically breaking and may break applications that rely on existing version APIs for various information.</p><p>You can now <a href="https://github.com/richlander/testapps/blob/master/versioninfo/Program.cs" target="_blank">get access to the following version information</a>:</p><pre><code><span>C</span><span>:</span><span>\git\testapps\versioninfo</span><span>&gt;</span><span>dotnet run
</span><span>**.</span><span>NET </span><span>Core</span><span> info</span><span>**</span><span>
</span><span>Environment</span><span>.</span><span>Version</span><span>:</span><span> </span><span>3.0</span><span>.</span><span>0</span><span>
</span><span>RuntimeInformation</span><span>.</span><span>FrameworkDescription</span><span>:</span><span> </span><span>.</span><span>NET </span><span>Core</span><span> </span><span>3.0</span><span>.</span><span>0</span><span>
</span><span>CoreCLR</span><span> </span><span>Build</span><span>:</span><span> </span><span>3.0</span><span>.</span><span>0</span><span>
</span><span>CoreCLR</span><span> </span><span>Hash</span><span>:</span><span> ac25be694a5385a6a1496db40de932df0689b742
</span><span>CoreFX</span><span> </span><span>Build</span><span>:</span><span> </span><span>3.0</span><span>.</span><span>0</span><span>
</span><span>CoreFX</span><span> </span><span>Hash</span><span>:</span><span> </span><span>1bb52e6a3db7f3673a3825f3677b9f27b9af99aa</span><span>

</span><span>**</span><span>Environment</span><span> info</span><span>**</span><span>
</span><span>Environment</span><span>.</span><span>OSVersion</span><span>:</span><span> </span><span>Microsoft</span><span> </span><span>Windows</span><span> NT </span><span>6.2</span><span>.</span><span>9200.0</span><span>
</span><span>RuntimeInformation</span><span>.</span><span>OSDescription</span><span>:</span><span> </span><span>Microsoft</span><span> </span><span>Windows</span><span> </span><span>10.0</span><span>.</span><span>18970</span><span>
</span><span>RuntimeInformation</span><span>.</span><span>OSArchitecture</span><span>:</span><span> X64
</span><span>Environment</span><span>.</span><span>ProcessorCount</span><span>:</span><span> </span><span>8</span></code></pre><h2>Event Pipe improvements</h2><p>Event Pipe now supports multiple sessions. This means that you can consume events with EventListener in-proc and simultaneously have out-of-process event pipe clients.</p><p>New Perf Counters added:</p><ul><li>% Time in GC</li><li>Gen 0 Heap Size</li><li>Gen 1 Heap Size</li><li>Gen 2 Heap Size</li><li>LOH Heap Size</li><li>Allocation Rate</li><li>Number of assemblies loaded</li><li>Number of ThreadPool Threads</li><li>Monitor Lock Contention Rate</li><li>ThreadPool Work Items Queue</li><li>ThreadPool Completed Work Items Rate</li></ul><p>Profiler attach is now implemented using the same Event Pipe infrastructure.</p><p>See <a href="https://twitter.com/davidfowl/status/1135355693634949121" target="_blank">Playing with counters</a> from David Fowler to get an idea of what you can do with event pipe to perform your own performance investigations or just monitor application status.</p><p>See <a href="https://github.com/dotnet/diagnostics/blob/master/documentation/dotnet-counters-instructions.md" target="_blank">dotnet-counters</a> to install the dotnet-counters tool.</p><h2>HTTP/2 Support</h2><p>We now have support for <a href="https://en.wikipedia.org/wiki/HTTP/2" target="_blank">HTTP/2</a> in HttpClient. The new protocol is a requirement for some APIs, like <a href="https://github.com/grpc/" target="_blank">gRPC</a> and <a href="https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1" target="_blank">Apple Push Notification Service</a>. We expect more services to require HTTP/2 in the future. ASP.NET also has support for HTTP/2.</p><p>Note: the preferred HTTP protocol version will be negotiated via TLS/ALPN and HTTP/2 will only be used if the server selects to use it.</p><h2>Tiered Compilation</h2><p><a href="https://blogs.msdn.microsoft.com/dotnet/2018/08/02/tiered-compilation-preview-in-net-core-2-1/" target="_blank">Tiered compilation</a> was added as an opt-in feature in .NET Core 2.1. It’s a feature that enables the runtime to more adaptively use the Just-In-Time (JIT) compiler to get better performance, both at startup and to maximize throughput. It is enabled by default with .NET Core 3.0. We made a lot of improvements to the feature over the last year, including testing it with a variety of workloads, including websites, PowerShell Core and Windows desktop apps. The performance is a lot better, which is what enabled us to enable it by default.</p><h2>IEEE Floating-point improvements</h2><p>Floating point APIs have been updated to comply with <a href="https://en.wikipedia.org/wiki/IEEE_754-2008_revision" target="_blank">IEEE 754-2008 revision</a>. The goal of the <a href="https://github.com/dotnet/corefx/issues/31901" target="_blank">.NET Core floating point project</a> is to expose all “required” operations and ensure that they are behaviorally compliant with the IEEE spec.</p><p>Parsing and formatting fixes:</p><ul><li>Correctly parse and round inputs of any length.</li><li>Correctly parse and format negative zero.</li><li>Correctly parse Infinity and NaN by performing a case-insensitive check and allowing an optional preceding <code>+</code> where applicable.</li></ul><p>New <a href="https://github.com/dotnet/corefx/issues/31903" target="_blank">Math APIs</a>:</p><ul><li><code>BitIncrement/BitDecrement</code> — corresponds to the <code>nextUp</code> and <code>nextDown</code> IEEE operations. They return the smallest floating-point number that compares greater or lesser than the input (respectively). For example, <code>Math.BitIncrement(0.0)</code> would return <code>double.Epsilon</code>.</li><li><code>MaxMagnitude/MinMagnitude</code> — corresponds to the <code>maxNumMag</code> and <code>minNumMag</code> IEEE operations, they return the value that is greater or lesser in magnitude of the two inputs (respectively). For example, <code>Math.MaxMagnitude(2.0, -3.0)</code> would return <code>-3.0</code>.</li><li><code>ILogB</code> — corresponds to the <code>logB</code> IEEE operation which returns an integral value, it returns the integral base-2 log of the input parameter. This is effectively the same as <code>floor(log2(x))</code>, but done with minimal rounding error.</li><li><code>ScaleB</code> — corresponds to the <code>scaleB</code> IEEE operation which takes an integral value, it returns effectively <code>x * pow(2, n)</code>, but is done with minimal rounding error.</li><li><code>Log2</code> — corresponds to the <code>log2</code> IEEE operation, it returns the base-2 logarithm. It minimizes rounding error.</li><li><code>FusedMultiplyAdd</code> — corresponds to the <code>fma</code> IEEE operation, it performs a fused multiply add. That is, it does <code>(x * y) + z</code> as a single operation, there-by minimizing the rounding error. An example would be <code>FusedMultiplyAdd(1e308, 2.0, -1e308)</code> which returns <code>1e308</code>. The regular <code>(1e308 * 2.0) - 1e308</code> returns <code>double.PositiveInfinity</code>.</li><li><code>CopySign</code> — corresponds to the <code>copySign</code> IEEE operation, it returns the value of <code>x</code>, but with the sign of <code>y</code>.</li></ul><h2>.NET Platform Dependent Intrinsics</h2><p>We’ve added <a href="https://devblogs.microsoft.com/dotnet/hardware-intrinsics-in-net-core/">APIs that allow access to certain performance-oriented CPU instructions</a>, such as the SIMD or Bit Manipulation instruction sets. These instructions can help achieve big performance improvements in certain scenarios, such as processing data efficiently in parallel. In addition to exposing the APIs for your programs to use, we have begun using these instructions to accelerate the .NET libraries too.</p><p>The following CoreCLR PRs demonstrate a few of the intrinsics, either via implementation or use:</p><ul><li><a href="https://github.com/dotnet/coreclr/pull/15585" target="_blank">Implement simple SSE2 hardware intrinsics</a></li><li><a href="https://github.com/dotnet/coreclr/pull/15538" target="_blank">Implement the SSE hardware intrinsics</a></li><li><a href="https://github.com/dotnet/coreclr/pull/16822" target="_blank">Arm64 Base HW Intrinsics</a></li><li><a href="https://github.com/dotnet/coreclr/pull/21073" target="_blank">Use TZCNT and LZCNT for Locate{First|Last}Found{Byte|Char}</a></li></ul><p>For more information, take a look at <a href="https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md" target="_blank">.NET Platform Dependent Intrinsics</a>, which defines an approach for defining this hardware infrastructure, allowing Microsoft, chip vendors or any other company or individual to define hardware/chip APIs that should be exposed to .NET code.</p><h2>Supporting TLS 1.3 and OpenSSL 1.1.1 now Supported on Linux</h2><p>NET Core can now take advantage of <a href="https://www.openssl.org/blog/blog/2018/09/11/release111/" target="_blank">TLS 1.3 support in OpenSSL 1.1.1</a>. There are multiple benefits of TLS 1.3, per the OpenSSL team:</p><ul><li>Improved connection times due to a reduction in the number of round trips required between the client and server</li><li>Improved security due to the removal of various obsolete and insecure cryptographic algorithms and encryption of more of the connection handshake</li></ul><p>.NET Core 3.0 is capable of utilizing OpenSSL 1.1.1, OpenSSL 1.1.0, or OpenSSL 1.0.2 (whatever the best version found is, on a Linux system). When OpenSSL 1.1.1 is available, the SslStream and HttpClient types will use TLS 1.3 when using SslProtocols.None (system default protocols), assuming both the client and server support TLS 1.3.</p><p>.NET Core will support TLS 1.3 on Windows and macOS — we expect automatically — when support becomes available.</p><h2>Cryptography</h2><p>We added support for <code>AES-GCM</code> and <code>AES-CCM</code> ciphers, implemented via <code>System.Security.Cryptography.AesGcm</code> and <code>System.Security.Cryptography.AesCcm</code>. These algorithms are both Authenticated Encryption with Association Data (AEAD) algorithms, and the first Authenticated Encryption (AE) algorithms added to .NET Core.</p><p>NET Core 3.0 now supports the import and export of asymmetric public and private keys from standard formats, without needing to use an X.509 certificate.</p><p>All key types (RSA, DSA, ECDsa, ECDiffieHellman) support the X.509 SubjectPublicKeyInfo format for public keys, and the PKCS#8 PrivateKeyInfo and PKCS#8 EncryptedPrivateKeyInfo formats for private keys. RSA additionally supports PKCS#1 RSAPublicKey and PKCS#1 RSAPrivateKey. The export methods all produce DER-encoded binary data, and the import methods expect the same; if a key is stored in the text-friendly PEM format the caller will need to base64-decode the content before calling an import method.</p><p>PKCS#8 files can be inspected with the <code>System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo</code> class.</p><p>PFX/PKCS#12 files can be inspected and manipulated with <code>System.Security.Cryptography.Pkcs.Pkcs12Info</code> and <code>System.Security.Cryptography.Pkcs.Pkcs12Builder</code>, respectively.</p><h2>New Japanese Era (Reiwa)</h2><p>On May 1st, 2019, Japan started a new era called <a href="https://en.wikipedia.org/wiki/Reiwa" target="_blank">Reiwa</a>. Software that has support for Japanese calendars, like .NET Core, must be updated to accommodate Reiwa. .NET Core and .NET Framework have been updated and correctly handle Japanese date formatting and parsing with the new era.</p><p>.NET relies on operating system or other updates to correctly process Reiwa dates. If you or your customers are using Windows, download the latest updates for your Windows version. If running macOS or Linux, download and install <a href="http://site.icu-project.org/download/64" target="_blank">ICU version 64.2</a>, which has support the new Japanese era.</p><p><a href="https://devblogs.microsoft.com/dotnet/handling-a-new-era-in-the-japanese-calendar-in-net/">Handling a new era in the Japanese calendar in .NET blog</a> has more information about .NET support for the new Japanese era.</p><h2>Assembly Load Context Improvements</h2><p>Enhancements to AssemblyLoadContext:</p><ul><li>Enable naming contexts</li><li>Added the ability to enumerate ALCs</li><li>Added the ability to enumerate assemblies within an ALC</li><li>Made the type concrete – so instantiation is easier (no requirement for custom types for simple scenarios)</li></ul><p>See <a href="https://github.com/dotnet/corefx/issues/34791" target="_blank">dotnet/corefx #34791</a> for more details. The <a href="https://github.com/richlander/testapps/blob/master/appwithalc/appwithalc/Program.cs" target="_blank">appwithalc</a> sample demonstrates these new capabilities.</p><p>By using <code>AssemblyDependencyResolver</code> along with a custom <code>AssemblyLoadContext</code>, an application can load plugins so that each plugin’s dependencies are loaded from the correct location, and one plugin’s dependencies will not conflict with another. The <a href="https://github.com/dotnet/samples/tree/master/core/extensions/AppWithPlugin" target="_blank">AppWithPlugin sample</a> includes plugins that have conflicting dependencies and plugins that rely on satellite assemblies or native libraries.</p><h2>Assembly Unloadability</h2><p>Assembly unloadability is a new capability of AssemblyLoadContext. This new feature is largely transparent from an API perspective, exposed with just a few new APIs. It enables a loader context to be unloaded, releasing all memory for instantiated types, static fields and for the assembly itself. An application should be able to load and unload assemblies via this mechanism forever without experiencing a memory leak.</p><p>We expect this new capability to be used for the following scenarios:</p><ul><li>Plugin scenarios where dynamic plugin loading and unloading is required.</li><li>Dynamically compiling, running and then flushing code. Useful for web sites, scripting engines, etc.</li><li>Loading assemblies for introspection (like ReflectionOnlyLoad), although MetadataLoadContext will be a better choice in many cases.</li></ul><h2>Assembly Metadata Reading with MetadataLoadContext</h2><p>We added <code>MetadataLoadContext</code>, which enables reading assembly metadata without affecting the caller’s application domain. Assemblies are read as data, including assemblies built for different architectures and platforms than the current runtime environment. MetadataLoadContext overlaps with the ReflectionOnlyLoad type, which is only available in the .NET Framework.</p><p><code>MetdataLoadContext</code> is available in the <a href="https://www.nuget.org/packages/System.Reflection.MetadataLoadContext" target="_blank">System.Reflection.MetadataLoadContext</a> package. It is a .NET Standard 2.0 package.</p><p>Scenarios for MetadataLoadContext include design-time features, build-time tooling, and runtime light-up features that need to inspect a set of assemblies as data and have all file locks and memory freed after inspection is performed.</p><h2>Native Hosting sample</h2><p>The team posted a <a href="https://github.com/dotnet/samples/tree/master/core/hosting/HostWithHostFxr" target="_blank">Native Hosting sample</a>. It demonstrates a best practice approach for hosting .NET Core in a native application.</p><p>As part of .NET Core 3.0, we now expose general functionality to .NET Core native hosts that was previously only available to .NET Core managed applications through the officially provided .NET Core hosts. The functionality is primarily related to assembly loading. This functionality should make it easier to produce native hosts that can take advantage of the full feature set of .NET Core.</p><h2>Other API Improvements</h2><p>We optimized <code>Span&lt;T&gt;</code>, <code>Memory&lt;T&gt;</code> and related types that were introduced in .NET Core 2.1. Common operations such as span construction, slicing, parsing, and formatting now perform better. Additionally, types like String have seen under-the-cover improvements to make them more efficient when used as keys with <code>Dictionary&lt;TKey, TValue&gt;</code> and other collections. No code changes are required to enjoy these improvements.</p><p>The following improvements are also new:</p><ul><li>Brotli support built-in to HttpClient</li><li>ThreadPool.UnsafeQueueWorkItem(IThreadPoolWorkItem)</li><li>Unsafe.Unbox</li><li>CancellationToken.Unregister</li><li>Complex arithmetic operators</li><li>Socket APIs for TCP keep alive</li><li>StringBuilder.GetChunks</li><li>IPEndPoint parsing</li><li>RandomNumberGenerator.GetInt32</li><li>System.Buffers.SequenceReader</li></ul><h2>Applications now have native executables by default</h2><p>.NET Core applications are now built with native executables. This is new for <a href="https://docs.microsoft.com/dotnet/core/deploying/" target="_blank">framework-dependent application</a>. Until now, only <a href="https://docs.microsoft.com/dotnet/core/deploying/" target="_blank">self-contained applications</a> had executables.</p><p>You can expect the same things with these executables as you would other native executables, such as:</p><ul><li>You can double click on the executable to start the application.</li><li>You can launch the application from a command prompt, using <code>myapp.exe</code>, on Windows, and <code>./myapp</code>, on Linux and macOS.</li></ul><p>The executable that is generated as part of the build will match your operating system and CPU. For example, if you are on a Linux x64 machine, the executable will only work on that kind of machine, not on a Windows machine and not on a Linux ARM machine. That’s because the executables are native code (just like C++). If you want to target another machine type, you need to publish with a <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-publish" target="_blank">runtime argument</a>. You can continue to launch applications with the <code>dotnet</code> command, and not use native executables, if you prefer.</p><h2>Optimize your .NET Core apps with ReadyToRun images</h2><p>You can improve the startup time of your .NET Core application by compiling your application assemblies as ReadyToRun (R2R) format. R2R is a form of ahead-of-time (AOT) compilation. It is a publish-time, opt-in feature in .NET Core 3.0.</p><p>R2R binaries improve startup performance by reducing the amount of work the JIT needs to do as your application is loading. The binaries contain similar native code as what the JIT would produce, giving the JIT a bit of a vacation when performance matters most (at startup). R2R binaries are larger because they contain both intermediate language (IL) code, which is still needed for some scenarios, and the native version of the same code, to improve startup.</p><p>To enable the ReadyToRun compilation:</p><ul><li>Set the <code>PublishReadyToRun</code> property to <code>true</code>.</li><li>Publish using an explicit <code>RuntimeIdentifier</code>.</li></ul><p>Note: When the application assemblies get compiled, the native code produced is platform and architecture specific (which is why you have to specify a valid RuntimeIdentifier when publishing).</p><p>Here’s an example:</p><pre><code><span>&lt;Project</span><span> </span><span>Sdk</span><span>=</span><span>"Microsoft.NET.Sdk"</span><span>&gt;</span><span>
  </span><span>&lt;PropertyGroup&gt;</span><span>
    </span><span>&lt;OutputType&gt;</span><span>Exe</span><span>&lt;/OutputType&gt;</span><span>
    </span><span>&lt;TargetFramework&gt;</span><span>netcoreapp3.0</span><span>&lt;/TargetFramework&gt;</span><span>
    </span><span>&lt;PublishReadyToRun&gt;</span><span>true</span><span>&lt;/PublishReadyToRun&gt;</span><span>
  </span><span>&lt;/PropertyGroup&gt;</span><span>
</span><span>&lt;/Project&gt;</span></code></pre><p>And publish using the following command:</p><pre><code><span>dotnet publish </span><span>-</span><span>r win</span><span>-</span><span>x64 </span><span>-</span><span>c </span><span>Release</span></code></pre><p>Note: The <code>RuntimeIdentifier</code> can be set to another operating system or chip. It can also be set in the project file.</p><h2>Assembly linking</h2><p>The .NET core 3.0 SDK comes with a tool that can reduce the size of apps by analyzing IL and trimming unused assemblies. It is another publish-time opt-in feature in .NET Core 3.0.</p><p>With .NET Core, it has always been possible to publish self-contained apps that include everything needed to run your code, without requiring .NET to be installed on the deployment target. In some cases, the app only requires a small subset of the framework to function and could potentially be made much smaller by including only the used libraries.</p><p>We use the <a href="https://github.com/mono/linker" target="_blank">IL linker</a> to scan the IL of your application to detect which code is actually required, and then trim unused framework libraries. This can significantly reduce the size of some apps. Typically, small tool-like console apps benefit the most as they tend to use fairly small subsets of the framework and are usually more amenable to trimming.</p><p>To use the linker:</p><ul><li>Set the <code>PublishTrimmed</code> property to <code>true</code>.</li><li>Publish using an explicit <code>RuntimeIdentifier</code>.</li></ul><p>Here’s an example:</p><pre><code><span>&lt;Project</span><span> </span><span>Sdk</span><span>=</span><span>"Microsoft.NET.Sdk"</span><span>&gt;</span><span>
  </span><span>&lt;PropertyGroup&gt;</span><span>
    </span><span>&lt;OutputType&gt;</span><span>Exe</span><span>&lt;/OutputType&gt;</span><span>
    </span><span>&lt;TargetFramework&gt;</span><span>netcoreapp3.0</span><span>&lt;/TargetFramework&gt;</span><span>
    </span><span>&lt;PublishTrimmed&gt;</span><span>true</span><span>&lt;/PublishTrimmed&gt;</span><span>
  </span><span>&lt;/PropertyGroup&gt;</span><span>
</span><span>&lt;/Project&gt;</span></code></pre><p>And publish using the following command:</p><pre><code><span>dotnet publish </span><span>-</span><span>r win</span><span>-</span><span>x64 </span><span>-</span><span>c </span><span>Release</span></code></pre><p>Note: The <code>RuntimeIdentifier</code> can be set to another operating system or chip. It can also be set in the project file.</p><p>The publish output will include a subset of the framework libraries, depending on what the application code calls. For a helloworld app, the linker reduces the size from ~68MB to ~28MB.</p><p>Applications or frameworks (including ASP.NET Core and WPF) that use reflection or related dynamic features will often break when trimmed, because the linker doesn’t know about this dynamic behavior and usually can’t determine which framework types will be required for reflection at run time. To trim such apps, you need to tell the linker about any types needed by reflection in your code, and in any packages or frameworks that you depend on. Be sure to test your apps after trimming. We are working on improving this experience for .NET 5.</p><p>For more information about the IL Linker, see the <a href="https://aka.ms/dotnet-illink" target="_blank">documentation</a>, or visit the <a href="https://github.com/mono/linker" target="_blank">mono/linker</a> repo.</p><p>Note: In previous versions of .NET Core, <a href="https://dotnet.myget.org/feed/dotnet-core/package/nuget/Illink.Tasks" target="_blank">ILLink.Tasks</a> was shipped as an external NuGet package and provided much of the same functionality. It is no longer supported – please update to the .NET Core 3.0 SDK and try the new experience!</p><p>The linker and ReadyToRun compiler can be used for the same application. In general, the linker makes your application smaller, and then the ready-to-run compiler will make it a bit larger again, but with a significant performance win. It is worth testing in various configurations to understand the impact of each option.</p><h2>Publishing single-file executables</h2><p>You can now publish a single-file executable with <code>dotnet publish</code>. This form of single EXE is effectively a self-extracting executable. It contains all dependencies, including native dependencies, as resources. At startup, it copies all dependencies to a temp directory, and loads them for there. It only needs to unpack dependencies once. After that, startup is fast, without any penalty.</p><p>You can enable this publishing option by adding the <code>PublishSingleFile</code> property to your project file or by adding a new switch on the commandline.</p><p>To produce a self-contained single EXE application, in this case for 64-bit Windows:</p><pre><code><span>dotnet publish </span><span>-</span><span>r win10</span><span>-</span><span>x64 </span><span>/</span><span>p</span><span>:</span><span>PublishSingleFile</span><span>=</span><span>true</span></code></pre><p>Note: The <code>RuntimeIdentifier</code> can be set to another operating system or chip. It can also be set in the project file.</p><p>See <a href="https://github.com/dotnet/core-setup/pull/5286" target="_blank">Single file bundler</a> for more information.</p><p>Assembly trimmer, ahead-of-time compilation (via crossgen) and single file bundling are all new features in .NET Core 3.0 that can be used together or separately.</p><p>We expect that some of you will prefer single exe provided by an ahead-of-time compiler, as opposed to the self-extracting-executable approach that we are providing in .NET Core 3.0. The ahead-of-time compiler approach will be provided as part of the .NET 5 release.</p><h2>dotnet build now copies dependencies</h2><p>dotnet build now copies NuGet dependencies for your application from the NuGet cache to your build output folder during the build operation. Until this release,those dependencies were only copied as part of dotnet publish. This change allows you to xcopy your build output to different machines.</p><p>There are some operations, like linking and razor page publishing that require publishing.</p><h2>.NET Core Tools — local installation</h2><p>.NET Core tools has been updated to allow local installation. They have advantages over <a href="https://blogs.msdn.microsoft.com/dotnet/2018/05/30/announcing-net-core-2-1/" target="_blank">global tools</a>, which were added in .NET Core 2.1.</p><p>Local installation enables the following:</p><ul><li>Limit the scope by which a tool can be used.</li><li>Always use a specific version of the tool, which might differ from a globally-installed tool or another local installation. This is based on the version in the local tools manifest file.</li><li>Launched with <code>dotnet</code>, like in <code>dotnet mytool</code>.</li></ul><p>Note: See <a href="https://github.com/dotnet/cli/issues/10288" target="_blank">Local Tools Early Preview Documentation</a> for more information.</p><h2>.NET Core SDK installers will now Upgrade in Place</h2><p>The .NET Core SDK MSI installers for Windows will start upgrading patch versions in place. This will reduce the number of SDKs that are installed on both developer and production machines.</p><p>The upgrade policy will specifically target .NET Core SDK feature bands. Feature bands are defined in hundreds groups in the patch section of the version number. For example, <code>3.0.101</code> and <code>3.0.201</code> are versions in two different feature bands while <code>3.0.101</code> and <code>3.0.199</code> are in the same feature band.</p><p>This means when .NET Core SDK 3.0.101 becomes available and is installed, .NET Core SDK 3.0.100 will be removed from the machine if it exists. When .NET Core SDK 3.0.200 becomes available and is installed on the same machine, .NET Core SDK 3.0.101 will not be removed. In that situation, .NET Core SDK 3.0.200 will still be used by default, but .NET Core SDK 3.0.101 (or higher .1xx versions) will still be usable if it is configured for use via <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-json" target="_blank">global.json</a>.</p><p>This approach aligns with the behavior of <code>global.json</code>, which allows roll forward across patch versions, but not feature bands of the SDK. Thus, upgrading via the SDK installer will not result in errors due to a missing SDK. Feature bands also align with side by side Visual Studio installations for those users that install SDKs for Visual Studio use.</p><p>For more information, please check out:</p><ul><li><a href="https://docs.microsoft.com/dotnet/core/versions/#versioning-details" target="_blank">.NET Core versioning</a></li><li><a href="https://docs.microsoft.com/dotnet/core/versions/remove-runtime-sdk-versions" target="_blank">Remove .NET Core SDK versions</a></li></ul><h2>.NET Core SDK Size Improvements</h2><p>The .NET Core SDK is significantly smaller with .NET Core 3.0. The primary reason is that we changed the way we construct the SDK, by moving to purpose-built “packs” of various kinds (reference assemblies, frameworks, templates). In previous versions (including .NET Core 2.2), we constructed the SDK from NuGet packages, which included many artifacts that were not required and wasted a lot of space.</p><p>.NET Core 3.0 SDK Size (size change in brackets)</p><table><thead><tr><th>Operating System</th><th>Installer Size (change)</th><th>On-disk Size (change)</th></tr></thead><tbody><tr><td>Windows</td><td>164MB (-440KB; 0%)</td><td>441MB (-968MB; -68.7%)</td></tr><tr><td>Linux</td><td>115MB (-55MB; -32%)</td><td>332MB (-1068MB; -76.2%)</td></tr><tr><td>macOS</td><td>118MB (-51MB; -30%)</td><td>337MB (-1063MB; -75.9%)</td></tr></tbody></table><p>The size improvements for Linux and macOS are dramatic. The improvement for Windows is smaller because we have added WPF and Windows Forms as part of .NET Core 3.0. It’s amazing that we added WPF and Windows Forms in 3.0 and the installer is still (a little bit) smaller.</p><p>You can see the same benefit with <a href="https://hub.docker.com/_/microsoft-dotnet-core-sdk" target="_blank">.NET Core SDK Docker images</a> (here, limited to x64 Debian and Alpine).</p><table><thead><tr><th>Distro</th><th>2.2 Size</th><th>3.0 Size</th></tr></thead><tbody><tr><td>Debian</td><td>1.74GB</td><td>706MB</td></tr><tr><td>Alpine</td><td>1.48GB</td><td>422MB</td></tr></tbody></table><p>You can see how we calculated these file sizes in <a href="https://gist.github.com/richlander/9dbb7cf0a9a53bfd161903ba4f20a1f6" target="_blank">.NET Core 3.0 SDK Size Improvements</a>. Detailed instructions are provided so that you can run the same tests in your own environment.</p><h2>Docker Publishing Update</h2><p>Microsoft teams are now publishing container images to the <a href="https://azure.microsoft.com/en-us/blog/microsoft-syndicates-container-catalog/" target="_blank">Microsoft Container Registry (MCR)</a>. There are two primary reasons for this change:</p><ul><li>Syndicate Microsoft-provided container images to multiple registries, like Docker Hub and Red Hat.</li><li>Use Microsoft Azure as a global CDN for delivering Microsoft-provided container images.</li></ul><p>On the .NET team, we are now publishing all <a href="https://hub.docker.com/_/microsoft-dotnet-core" target="_blank">.NET Core images</a> to MCR. As you can see from the links (if you click on it), we continue to have “home pages” on Docker Hub. We intend for that to continue indefinitely. MCR does not offer such pages, but relies of public registries, like Docker Hub, to provide users with image-related information.</p><p>The links to our old repos, such as <a href="https://hub.docker.com/r/microsoft/dotnet" target="_blank">microsoft/dotnet</a> and <a href="https://hub.docker.com/r/microsoft/dotnet-nightly" target="_blank">microsoft/dotnet-nightly</a> now forward to the new locations. The images that existed at those locations still exists and will not be deleted.</p><p>We will continue servicing the floating tags in the old repos for the supported life of the various .NET Core versions. For example, <code>2.1-sdk</code>, <code>2.2-runtime</code>, and <code>latest</code> are examples of floating tags that will be serviced. A three-part version tag like <code>2.1.2-sdk</code> will not be serviced, which was already the case. We will only be supporting .NET Core 3.0 images in MCR.</p><p>For example, the correct tag string to pull the 3.0 SDK image now looks like the following:</p><pre><code><span>mcr</span><span>.</span><span>microsoft</span><span>.</span><span>com</span><span>/</span><span>dotnet</span><span>/</span><span>core</span><span>/</span><span>sdk</span><span>:</span><span>3.0</span></code></pre><p>The new MCR string will be used with both <code>docker pull</code> and in Dockerfile <code>FROM</code> statements.</p><p>See <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/">.NET Core Images now available via Microsoft Container Registry</a> for more information.</p><h2>SDK Docker Images Contain PowerShell Core</h2><p><a href="https://github.com/powershell/powershell" target="_blank">PowerShell Core</a> has been added to the .NET Core SDK Docker container images, per <a href="https://github.com/dotnet/dotnet-docker/issues/360" target="_blank">requests from the community</a>. PowerShell Core is a cross-platform (Windows, Linux, and macOS) automation and configuration tool/framework that works well with your existing tools and is optimized for dealing with structured data (e.g. JSON, CSV, XML, etc.), REST APIs, and object models. It includes a command-line shell, an associated scripting language and a framework for processing cmdlets.</p><p>You can try out PowerShell Core, as part of the .NET Core SDK container image, by running the following Docker command:</p><pre><code><span>docker run </span><span>--</span><span>rm mcr</span><span>.</span><span>microsoft</span><span>.</span><span>com</span><span>/</span><span>dotnet</span><span>/</span><span>core</span><span>/</span><span>sdk</span><span>:</span><span>3.0</span><span> pwsh </span><span>-</span><span>c </span><span>Write</span><span>-</span><span>Host</span><span> </span><span>"Hello Powershell"</span></code></pre><p>There are two main scenarios that having PowerShell inside the .NET Core SDK container image enables, which were not otherwise possible:</p><ul><li>Write .NET Core application <a href="https://github.com/dotnet/dotnet-docker/blob/master/3.0/sdk/nanoserver-1809/amd64/Dockerfile" target="_blank">Dockerfiles with PowerShell syntax</a> for any OS.</li><li>Write .NET Core application/library build logic that can be easily containerized.</li></ul><p>Example syntax for launching PowerShell for a (volume-mounted) containerized build:</p><ul><li><code>docker run -it -v c:\myrepo:/myrepo -w /myrepo mcr.microsoft.com/dotnet/core/sdk:3.0 pwsh build.ps1</code></li><li><code>docker run -it -v c:\myrepo:/myrepo -w /myrepo mcr.microsoft.com/dotnet/core/sdk:3.0 ./build.ps1</code></li></ul><p>For the second example to work, on Linux, the <code>.ps1</code> file needs to have the following pattern, and needs to be formatted with Unix (LF) not Windows (CRLF) line endings:</p><pre><code><span>#!/usr/bin/env pwsh</span><span>
</span><span>Write</span><span>-</span><span>Host</span><span> </span><span>"test"</span></code></pre><p>If you are new to PowerShell and would like to learn more, we recommend reviewing the <a href="https://github.com/PowerShell/PowerShell/tree/master/docs/learning-powershell" target="_blank">getting started</a> documentation.</p><p>Note: PowerShell Core is now available as part of <a href="https://hub.docker.com/_/microsoft-dotnet-core-sdk/" target="_blank">.NET Core 3.0 SDK container images</a>. It is not part of the <a href="https://dotnet.microsoft.com/download/dotnet-core/3.0" target="_blank">.NET Core 3.0 SDK</a>.</p><h3>Red Hat Support</h3><p>In April 2015, we announced that .NET Core would be coming to Red Hat Enterprise Linux. Through an excellent engineering partnership with Red Hat, .NET Core 1.0 appeared as a component available in the Red Hat Software Collections, June 2016. Working with Red Hat engineers, we have learned (and continue to learn!) much about the releasing software to the Linux community.</p><p>Over the last four years, Red Hat has shipped many .NET Core updates and significant releases, such as 2.1 and 2.2, on the same day as the Microsoft. With .NET Core 2.2, Red Hat expanded their .NET Core offerings to include OpenShift platforms. With the release of RHEL 8, we are excited to have .NET Core 2.1 and soon, 3.0, available in the Red Hat Application Streams.</p><h2>Closing</h2><p>.NET Core 3.0 is a major new release of .NET Core, and includes a vast set of improvements. We recommend that you start adopting .NET Core 3.0 as soon as you can. It greatly improves .NET Core in many ways, like the massive reduction in size of the SDK, and by greatly improving support for key scenarios like containers and Windows desktop applications. There are also many small improvements that were not included in this post, that you are sure to benefit from over time.</p><p>Please share your feedback with us, either in the coming days, weeks or months. We hope you enjoy it. We had a lot of fun making it for you.</p><p>If you still want to read more, the following recent posts are recommended reading:</p><ul><li><a href="https://devblogs.microsoft.com/dotnet/the-evolving-infrastructure-of-net-core/">The Evolving Infrastructure of .NET Core</a></li><li><a href="https://devblogs.microsoft.com/dotnet/how-the-net-team-uses-azure-pipelines-to-produce-docker-images/">How the .NET Team uses Azure Pipelines to produce Docker Images</a></li><li><a href="https://devblogs.microsoft.com/aspnet/net-core-workers-as-windows-services/">.NET Core Workers as Windows Services</a></li><li><a href="https://devblogs.microsoft.com/dotnet/net-core-and-systemd/">.NET Core and systemd</a></li><li><a href="https://devblogs.microsoft.com/dotnet/messaging-practices/">Messaging Practices</a></li><li><a href="https://devblogs.microsoft.com/dotnet/visual-studio-tips-and-tricks-increasing-your-productivity-for-net/">Visual Studio Tips and Tricks: Increasing your Productivity for .NET</a></li></ul></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>