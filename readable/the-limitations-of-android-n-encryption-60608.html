<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The limitations of Android N Encryption - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The limitations of Android N Encryption - linksfor.dev(s)"/>
    <meta property="article:author" content="Matthew Green"/>
    <meta property="og:description" content="Over the past few years we&#x2019;ve heard more about smartphone encryption than, quite frankly, most of us expected to hear in a lifetime. We learned that proper encryption can slow down even sophi&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://blog.cryptographyengineering.com/2016/11/24/android-n-encryption/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The limitations of Android N Encryption</title>
<div class="readable">
        <h1>The limitations of Android N Encryption</h1>
            <div>by Matthew Green</div>
            <div>Reading time: 13-16 minutes</div>
        <div>Posted here: 12 Apr 2020</div>
        <p><a href="https://blog.cryptographyengineering.com/2016/11/24/android-n-encryption/">https://blog.cryptographyengineering.com/2016/11/24/android-n-encryption/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
		<p>Over the past few years <img data-attachment-id="2273" data-permalink="https://blog.cryptographyengineering.com/2016/11/24/android-n-encryption/pixelphone/" data-orig-file="https://matthewdgreen.files.wordpress.com/2016/11/pixelphone.png" data-orig-size="877,1209" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pixelphone" data-image-description="" data-medium-file="https://matthewdgreen.files.wordpress.com/2016/11/pixelphone.png?w=218" data-large-file="https://matthewdgreen.files.wordpress.com/2016/11/pixelphone.png?w=700" src="https://matthewdgreen.files.wordpress.com/2016/11/pixelphone.png?w=218&amp;h=300" alt="pixelphone" width="218" height="300" srcset="https://matthewdgreen.files.wordpress.com/2016/11/pixelphone.png?w=218&amp;h=300 218w, https://matthewdgreen.files.wordpress.com/2016/11/pixelphone.png?w=436&amp;h=600 436w, https://matthewdgreen.files.wordpress.com/2016/11/pixelphone.png?w=109&amp;h=150 109w" sizes="(max-width: 218px) 100vw, 218px">we’ve <a href="http://www.nytimes.com/interactive/2016/03/03/technology/apple-iphone-fbi-fight-explained.html">heard more about smartphone encryption </a>than, quite frankly, most of us expected to hear in a lifetime. We learned that proper encryption can slow down even <a href="http://www.apple.com/customer-letter/">sophisticated decryption attempts</a>&nbsp;if done correctly. We’ve also learned that incorrect implementations can <a href="http://www.vox.com/2016/3/29/11325134/apple-iphone-fbi-san-bernardino-case-ends">undo most of that security</a>.</p>
<p>In other words, phone encryption&nbsp;is an area where details matter. For&nbsp;the past few weeks I’ve been looking a bit at Android Nougat’s new file-based encryption to see how well they’ve addressed some of those details in their latest release. The answer, unfortunately, is that there’s still lots of work to do. In this post I’m going to talk about a bit of that.</p>
<p>(As an aside:&nbsp;the inspiration&nbsp;for this post comes&nbsp;from&nbsp;<a href="https://twitter.com/thegrugq">Grugq</a>, who has been loudly and angrily trying to work through these&nbsp;kinks to&nbsp;develop a <a href="http://ironsides.tech/">secure Android phone</a>. So credit where credit is due.)</p>
<p><strong>Background: file and disk&nbsp;encryption&nbsp;</strong></p>
<p>Disk&nbsp;encryption is <em>much</em> older than smartphones. Indeed, early encrypting filesystems date back&nbsp;<a href="http://www.crypto.com/papers/cfs.ps">at least to the early 1990s</a>&nbsp;and proprietary implementations may go back before that. Even in the relatively new area of PCs&nbsp;operating systems,&nbsp;disk encryption has been a <a href="https://en.wikipedia.org/wiki/BitLocker">built-in</a>&nbsp;<a href="https://en.wikipedia.org/wiki/FileVault">feature</a>&nbsp;since the early 2000s.</p>
<p>The typical&nbsp;PC disk encryption system&nbsp;operates as follows. At boot time you enter a password. This&nbsp;is&nbsp;fed&nbsp;through a <a href="https://en.wikipedia.org/wiki/Key_derivation_function">key derivation function</a>&nbsp;to derive a cryptographic key. If a hardware co-processor is available (e.g., a <a href="https://en.wikipedia.org/wiki/Trusted_Platform_Module">TPM</a>), your key is further strengthened by “tangling” it with some secrets stored in the hardware. This helps to lock encryption to a particular device.</p>
<p>The actual encryption can be done in one of two different ways:</p>
<ol>
<li><strong>Full&nbsp;Disk Encryption (FDE)</strong> systems (like&nbsp;<a href="https://en.wikipedia.org/wiki/TrueCrypt">Truecrypt</a>,&nbsp;<a href="https://en.wikipedia.org/wiki/BitLocker">BitLocker</a>&nbsp;and <a href="https://en.wikipedia.org/wiki/FileVault">FileVault</a>) encrypt disks at&nbsp;the level of&nbsp;<a href="https://en.wikipedia.org/wiki/Disk_sector">disk sectors</a>. This is an all-or-nothing approach, since the encryption drivers won’t&nbsp;necessarily have any idea what files those&nbsp;sectors represent. At the same time, FDE&nbsp;is popular — mainly because it’s extremely&nbsp;easy to implement.</li>
<li><strong>File-based Encryption (FBE)</strong>&nbsp;systems (like <a href="https://en.wikipedia.org/wiki/EncFS">EncFS</a>&nbsp;and <a href="https://en.wikipedia.org/wiki/ECryptfs">eCryptFS</a>) encrypt <em>individual files</em>.&nbsp;This approach requires changes to the filesystem itself, but&nbsp;has the benefit of allowing fine grained access controls where individual files are encrypted using different keys.</li>
</ol>
<p>Most commercial PC disk encryption software has historically opted to use&nbsp;the&nbsp;full-disk encryption (FDE) approach. Mostly this is just&nbsp;a matter of expediency: FDE is just significantly&nbsp;easier to implement. But philosophically, <em>it also reflects&nbsp;a particular view of what disk encryption was&nbsp;meant to accomplish</em>.</p>
<p>In this view, encryption is&nbsp;an all-or-nothing proposition. Your machine is&nbsp;either on or off; accessible or inaccessible. As long as you make&nbsp;sure to have your laptop&nbsp;stolen&nbsp;only when it’s off, disk encryption will&nbsp;keep you perfectly safe.</p>
<h4><strong>So what&nbsp;does this have to do with Android?</strong></h4>
<p>Android’s early attempts at adding encryption to their phones followed the standard PC&nbsp;full-disk encryption paradigm. Beginning in&nbsp;Android 4.4 (Kitkat) through Android 6.0 (Marshmallow), Android systems shipped with&nbsp;a kernel device mapper called&nbsp;<a href="https://en.wikipedia.org/wiki/Dm-crypt">dm-crypt</a>&nbsp;designed to encrypt disks at the sector level.&nbsp;This represented&nbsp;a quick and dirty way to bring encryption to Android phones, and it made sense —&nbsp;<em>if you believe&nbsp;that&nbsp;phones&nbsp;are&nbsp;just&nbsp;very&nbsp;tiny PCs.</em></p>
<p>The problem is that&nbsp;smartphones are <em>not</em>&nbsp;PCs.</p>
<p>The major difference is that smartphone&nbsp;users are never&nbsp;encouraged to shut down their device. In practice this means that — after you enter&nbsp;a passcode once after&nbsp;boot — normal&nbsp;users spend&nbsp;their whole day&nbsp;walking around with all their cryptographic keys in RAM. Since&nbsp;phone batteries live for a day or more&nbsp;(a long time&nbsp;compared to laptops) encryption doesn’t really offer much to protect you against an attacker who gets their hands on&nbsp;your phone during this time.</p>
<p>Of course, users do&nbsp;<em>lock</em>&nbsp;their smartphones. In principle, a clever&nbsp;implementation could&nbsp;evict sensitive cryptographic keys from RAM when the device locks,&nbsp;then re-derive&nbsp;them the next time&nbsp;the user logs in. Unfortunately, &nbsp;Android&nbsp;doesn’t do this&nbsp;— for the very simple reason that<em>&nbsp;Android users&nbsp;want their phones to actually work</em>. Without cryptographic keys&nbsp;in RAM, an FDE system loses access to everything on the storage drive. In practice this&nbsp;turns it into a brick.</p>
<p>For&nbsp;this very excellent reason, once you boot an Android FDE phone it will never evict&nbsp;its&nbsp;cryptographic&nbsp;keys from&nbsp;RAM.&nbsp;<em>And this is not good.</em></p>
<h4><strong>So what’s the alternative?</strong></h4>
<p>Android is not the only game in town when it comes to phone encryption. Apple, for its part, also gave this&nbsp;problem&nbsp;a lot of thought and came to a subtly&nbsp;different solution.</p>
<p>Starting with iOS 4, Apple included&nbsp;a “data protection” feature to&nbsp;encrypt all data&nbsp;stored a device. But unlike&nbsp;Android, Apple doesn’t&nbsp;use the&nbsp;full-disk encryption paradigm. Instead, they employ&nbsp;a file-based encryption approach that&nbsp;individually encrypts each file on the device.</p>
<p>In the Apple system, the contents of each&nbsp;file is encrypted under a unique per-file key (metadata&nbsp;is encrypted separately). The file&nbsp;key is in turn encrypted with one of several “class keys” that are&nbsp;derived from the user passcode&nbsp;and some hardware secrets embedded in the processor.</p>
<figure data-shortcode="caption" id="attachment_1619" aria-describedby="caption-attachment-1619"><img data-attachment-id="1619" data-permalink="https://blog.cryptographyengineering.com/2016/11/24/android-n-encryption/apple/" data-orig-file="https://matthewdgreen.files.wordpress.com/2016/11/apple.png" data-orig-size="868,326" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="apple" data-image-description="" data-medium-file="https://matthewdgreen.files.wordpress.com/2016/11/apple.png?w=300" data-large-file="https://matthewdgreen.files.wordpress.com/2016/11/apple.png?w=700" src="https://matthewdgreen.files.wordpress.com/2016/11/apple.png?w=300&amp;h=113" alt="apple" width="300" height="113" srcset="https://matthewdgreen.files.wordpress.com/2016/11/apple.png?w=300&amp;h=113 300w, https://matthewdgreen.files.wordpress.com/2016/11/apple.png?w=600&amp;h=226 600w, https://matthewdgreen.files.wordpress.com/2016/11/apple.png?w=150&amp;h=56 150w" sizes="(max-width: 300px) 100vw, 300px"><figcaption id="caption-attachment-1619">iOS data encryption. Source: iOS Security Guide.</figcaption></figure>
<p>The main advantage&nbsp;of the Apple approach&nbsp;is that instead of a single FDE key to rule them all, Apple can implement&nbsp;<a href="https://www.apple.com/business/docs/iOS_Security_Guide.pdf">fine-grained access control</a>&nbsp;for individual files. To enable this, iOS provides&nbsp;an&nbsp;API developers can&nbsp;use to&nbsp;<em>specify</em>&nbsp;which class key to use in encrypting any given&nbsp;file. The available&nbsp;“protection classes” include:</p>
<ul>
<li><strong>Complete protection.</strong>&nbsp;Files encrypted with <a href="https://developer.apple.com/reference/foundation/nsfileprotectioncomplete">this class key</a>&nbsp;can&nbsp;only be accessed when the device is powered up <em>and</em> unlocked. To ensure&nbsp;this, the class key is evicted from RAM a few seconds after&nbsp;the&nbsp;device locks.</li>
<li><strong>Protected Until First User Authentication.&nbsp;</strong>Files encrypted with <a href="https://developer.apple.com/reference/foundation/nsfileprotectioncompleteunlessopen">this class key</a> are protected until the user first logs in (after a reboot), and the key remains in memory.</li>
<li><strong>No protection.</strong>&nbsp;These files are <a href="https://developer.apple.com/reference/foundation/nsfileprotectionnone">accessible</a> even when the device has been rebooted, and&nbsp;the user has not yet logged in.</li>
</ul>
<p>By giving developers the option to individually protect different files, Apple made it possible to build applications that can work&nbsp;while the device is locked, while providing strong protection for files containing&nbsp;sensitive data.</p>
<p>Apple even created a <a href="https://developer.apple.com/reference/foundation/nsfileprotectioncompleteunlessopen">fourth&nbsp;option</a> for&nbsp;apps that simply need to&nbsp;<em>create new encrypted&nbsp;files</em>&nbsp;when the class key has been evicted from RAM. This class uses&nbsp;<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">public key encryption</a> to write&nbsp;new files. This is why you can safely take pictures even when your device is locked.</p>
<p>Apple’s approach&nbsp;isn’t perfect. What it is, however, is&nbsp;the obvious&nbsp;result of a long and&nbsp;careful thought process. All of which raises&nbsp;the following question…</p>
<h4><strong>Why&nbsp;the hell didn’t&nbsp;Android do this as well?</strong></h4>
<p>The short answer is Android is <em>trying to.</em> Sort of. Let me explain.</p>
<p>As of Android 7.0 (Nougat), Google has moved away from&nbsp;full-disk encryption as the primary&nbsp;mechanism for protecting data at rest. If you set a passcode on your device, Android N&nbsp;systems can be configured to support a <a href="https://source.android.com/security/encryption/file-based.html">more Apple-like approach that uses&nbsp;file encryption</a>. So far so good.</p>
<p>The new system&nbsp;is called Direct Boot, so named because it addresses what Google obviously saw as&nbsp;fatal problem with Android FDE — namely, that FDE-protected phones are&nbsp;<a href="http://www.howtogeek.com/269422/how-to-enable-android-nougats-direct-boot-for-less-annoying-encryption/">useless bricks following a reboot</a>. The main advantage of&nbsp;the&nbsp;new model is that it allows phones to access&nbsp;<em>some</em> data even before you enter the passcode. This is enabled by providing developers with two separate “encryption&nbsp;contexts”:</p>
<ul>
<li><strong>Credential encrypted storage.</strong> Files in this area are encrypted under the user’s passcode, and won’t be available&nbsp;until the user enters their passcode (once).</li>
<li><strong>Device encrypted storage.</strong> These files are <em>not</em> encrypted under the user’s passcode (though they may be encrypted using hardware secrets). Thus they are available after boot, even before the user enters a passcode.</li>
</ul>
<p>Direct Boot even&nbsp;provides separate encryption contexts&nbsp;for <em>different users&nbsp;on the phone</em>&nbsp;—&nbsp;something I’m not quite sure what to do with. But sure, why not?</p>
<h4><strong>If Android&nbsp;is making all these changes, what’s the problem?</strong></h4>
<p>One thing you might have noticed&nbsp;is that where Apple had <em>four</em> categories of protection, Android N only has <em>two</em>. And it’s the&nbsp;two missing categories that cause the problems. These are&nbsp;the “complete protection” categories&nbsp;that allow the user to&nbsp;<em>lock</em> their device following first user authentication — and evict&nbsp;the keys from memory.</p>
<p>Of course, you might argue that Android could provide this by forcing application developers to switch back to “device encrypted storage” following a device lock. The problem with this idea is twofold. First, Android documentation&nbsp;and sample code is&nbsp;explicit that this <em>isn’t</em> how things work:</p>
<p><img data-attachment-id="2233" data-permalink="https://blog.cryptographyengineering.com/2016/11/24/android-n-encryption/credentialenc/" data-orig-file="https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png" data-orig-size="1400,218" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="credentialenc" data-image-description="" data-medium-file="https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png?w=300" data-large-file="https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png?w=700" src="https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png?w=700" alt="credentialenc" srcset="https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png?w=700 700w, https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png 1400w, https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png?w=150 150w, https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png?w=300 300w, https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png?w=768 768w, https://matthewdgreen.files.wordpress.com/2016/11/credentialenc.png?w=1024 1024w" sizes="(max-width: 700px) 100vw, 700px"></p>
<p>Moreover, a quick read of the documentation shows that even if you wanted to,<em>&nbsp;there is no unambiguous way&nbsp;for Android to tell&nbsp;applications when the system has been re-locked</em>.&nbsp;If keys are evicted when the device is locked, applications will unexpectedly find their file accesses returning errors. Even system applications tend to do badly when this happens.</p>
<p>And of course,&nbsp;this assumes that Android N will&nbsp;even&nbsp;<em>try</em>&nbsp;to evict keys when you lock the device. Here’s how the&nbsp;current <a href="https://android.googlesource.com/platform/system/vold/+/master/Ext4Crypt.cpp">filesystem encryption code</a>&nbsp;handles locks:</p>
<p><img data-attachment-id="1999" data-permalink="https://blog.cryptographyengineering.com/2016/11/24/android-n-encryption/lockuserkey-2/" data-orig-file="https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png" data-orig-size="1482,726" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="lockuserkey" data-image-description="" data-medium-file="https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png?w=300" data-large-file="https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png?w=700" src="https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png?w=700" alt="lockuserkey" srcset="https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png?w=700 700w, https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png?w=1400 1400w, https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png?w=150 150w, https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png?w=300 300w, https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png?w=768 768w, https://matthewdgreen.files.wordpress.com/2016/11/lockuserkey1.png?w=1024 1024w" sizes="(max-width: 700px) 100vw, 700px"></p>
<p>While the above is bad, it’s important to stress that<em>&nbsp;the&nbsp;real problem here is not really in the&nbsp;cryptography</em>. The problem is that&nbsp;since Google is not giving developers proper guidance, the company&nbsp;may be locking Android&nbsp;into years of insecurity. Without (even a half-baked) solution to define a “complete” protection class, Android app developers can’t build their apps correctly to support the idea that devices can lock. Even&nbsp;if&nbsp;Android O gets around to implementing&nbsp;key eviction, the existing legacy app base&nbsp;won’t be able to handle&nbsp;it&nbsp;— since this&nbsp;will break a million apps that have implemented their security according to&nbsp;Android’s current recommendations.</p>
<p>In short: this is a thing you&nbsp;get right from the start, or you don’t do at all. It looks like — for the moment — Android isn’t getting it&nbsp;right.</p>
<h4><strong>Are keys that easy to steal?</strong></h4>
<p>Of course it’s reasonable to ask&nbsp;whether it’s having&nbsp;keys in RAM is that big of concern in the first place. Can&nbsp;these keys actually be accessed?</p>
<p>The answer to that question is a bit complicated. First, if you’re up against&nbsp;somebody with a hardware lab and&nbsp;forensic expertise, the answer is almost certainly&nbsp;“yes”. Once you’ve entered your passcode and derived the keys, they aren’t stored in some magically&nbsp;secure part&nbsp;of the phone. People with the ability&nbsp;to access RAM or the bus lines of the device can potentially nick them.</p>
<p>But that’s a lot of work. From a software perspective, it’s even worse.&nbsp;A software attack would require a way to get past the phone’s&nbsp;lockscreen in order to get running code on the device. In older (pre-N) versions of Android the attacker&nbsp;might need to then escalate privileges to get access to Kernel memory. Remarkably, Android N doesn’t even store its disk keys in the Kernel&nbsp;— instead they’re&nbsp;held by&nbsp;the <a href="https://android.googlesource.com/platform/system/vold/+/master">“vold” daemon</a>, which runs as user “root” in userspace.&nbsp;This doesn’t make exploits trivial, but it certainly isn’t the best way to handle things.</p>
<p>Of&nbsp;course, all of this&nbsp;is mostly irrelevant. The main point is that if&nbsp;the keys are loaded&nbsp;you <em>don’t need to steal them</em>. If you have a way to&nbsp;get past the&nbsp;lockscreen, you can just access files on the&nbsp;disk.</p>
<h4><strong>What about hardware?</strong></h4>
<p>Although a bit of a tangent, it’s worth noting that many high-end Android phones use some sort of trusted hardware to enable encryption. The most common approach is to use a trusted execution environment (TEE) running with&nbsp;ARM TrustZone.</p>
<p>This definitely solves a problem. Unfortunately it’s not quite the same problem as discussed above. ARM TrustZone — when it works correctly, <a href="http://bits-please.blogspot.com/2016/06/extracting-qualcomms-keymaster-keys.html">which is not guaranteed</a>&nbsp;— forces attackers to&nbsp;<em>derive</em>&nbsp;their encryption keys on the device itself, which should&nbsp;make offline dictionary attacks on the password much harder. In some cases, this hardware can be used&nbsp;to&nbsp;cache the keys and reveal them only when you input&nbsp;a biometric such as a fingerprint.</p>
<p>The problem here is that in Android N, this only helps you <em>at the time&nbsp;the keys are being initially derived.&nbsp;</em>Once that&nbsp;happens (i.e., following your first&nbsp;login),&nbsp;the hardware doesn’t appear to do much. The resulting derived keys seem to live&nbsp;forever in normal userspace RAM. While it’s possible that specific phones (e.g., Google’s Pixel, or Samsung devices) implement additional countermeasures, on stock Android N phones hardware doesn’t save you.</p>
<p><strong>So what does it all mean?</strong></p>
<p>How you feel about this depends on whether you’re a “glass half full” or “glass half empty” kind of person.</p>
<p>If you’re an optimistic type, you’ll point out that Android is clearly moving in the right direction. And while there’s a lot of work still to be done, even a half-baked implementation of&nbsp;file-based implementation&nbsp;is better than the last generation of dumb&nbsp;FDE Android encryption. Also: you probably also think clowns are nice.</p>
<p>On the other hand, you might notice that&nbsp;<em>this is a pretty goddamn&nbsp;low standard.&nbsp;</em>In other words, in 2016 Android is still struggling to deploy encryption that achieves (lock screen) security that Apple&nbsp;figured out six years ago.&nbsp;<em>And they’re not even getting it right.</em> That doesn’t bode well for the long term security of Android users.</p>
<p>And that’s a shame, because as many have pointed out, the users who rely on Android phones are&nbsp;<a href="http://appleinsider.com/articles/15/11/04/aclu-google-is-embarrassed-by-android-not-protecting-vulnerable-users-like-apples-ios">disproportionately poorer and more at-risk</a>. By treating encryption as a relatively low priority, Google is basically telling these people that they shouldn’t get the same protections as other users. This may keep the FBI off Google’s backs, but in&nbsp;the long term it’s bad judgement on Google’s part.</p>
	</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>