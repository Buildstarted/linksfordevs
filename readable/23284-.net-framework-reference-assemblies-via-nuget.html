<!DOCTYPE html>
<html lang="en">
<head>
    <title>
.NET Framework Reference Assemblies via NuGet -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>.NET Framework Reference Assemblies via NuGet</h1><div><div class="post-content"><p>In <a href="https://stu.dev/how-to-target-net4x-on-macos/">a previous post</a> I showed how to build for <code>net4x</code> on macOS, and it turns out you have everything you need to do it with the .NET Core SDK, except for the Reference Assemblies, and in that post I showed some workarounds.</p><p>This problem doesn't just exist on macOS however, it's also applicable when you are building on Linux, in Docker, or even on Windows without having the right targeting pack installed.</p><p>Now the dotnet team have made a more seamless way of doing this, with a new NuGet metapackage;</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://www.nuget.org/packages/Microsoft.NETFramework.ReferenceAssemblies/"><div class="kg-bookmark-content"><p class="kg-bookmark-title">Microsoft.NETFramework.ReferenceAssemblies 1.0.0</p><p class="kg-bookmark-description">Microsoft .NET Framework Reference Assemblies</p></div></a></figure><h2 id="how-do-i-use-it">How do I use it?</h2><p>Just add this to your project file:</p><p><span>&lt;</span><span>PackageReference</span><span></span><span>Include</span><span>=</span><span>"Microsoft.NETFramework.ReferenceAssemblies"</span><span></span><span>Version</span><span>=</span><span>"1.0.0"</span><span></span><span>PrivateAssets</span><span>=</span><span>"All"</span><span></span><span>/&gt;</span></p><p>The team are talking about adding this to the SDK imports, so in future it may just already be imported and "just work".</p><p>The <code>PrivateAssets</code> part is to make sure it doesn't appear as a dependency of your project.</p><p>It's a package that contains no payload, just depends on a number of other packages, as a convenient way to add a group of packages. You can read <a href="https://docs.microsoft.com/en-us/dotnet/core/packages#metapackages">more here</a>.</p><p>Here is what the metapackage dependencies look like:</p><figure class="kg-card kg-image-card"><img src="https://stu.dev/content/images/2019/05/image-2.png" class="kg-image"></figure><p>... and so on.</p><h2 id="i-don-t-want-to-download-all-tfms">I don't want to download all TFMs</h2><p>As you can see from the screenshot above, the metapackage references all the .NET Framework TFMs (Target Framework Moniker), you wouldn't want to download all of these at build time when you only need one.</p><p>Well there's no need to worry, when you do a NuGet restore, dependencies are resolved per framework. So let's say we had this in our project file:</p><p><span>&lt;</span><span>TargetFrameworks</span><span>&gt;</span><span>netstandard2.0;net461</span><span>&lt;/</span><span>TargetFrameworks</span><span>&gt;</span></p><p>If we do a NuGet restore, we can look at the contents of <code>/obj/project.asset.json</code> and we will see:</p><div class="vscode"><p><span>"Microsoft.NETFramework.ReferenceAssemblies/1.0.0"</span><span>: {</span></p><p><span></span><span>"type"</span><span>: </span><span>"package"</span><span>,</span></p><p><span></span><span>"dependencies"</span><span>: {</span></p><p><span></span><span>"Microsoft.NETFramework.ReferenceAssemblies.net461"</span><span>: </span><span>"1.0.0"</span></p><p><span>  }</span></p><p><span>}</span></p></div><p>Notice how it's only resolved <code>Microsoft.NETFramework.ReferenceAssemblies.net461</code> as a dependency, and not all of the others.</p><h2 id="how-does-it-work">How does it work?</h2><p>If we unzip the <code>net461</code> package and open it up, it looks like this:</p><figure class="kg-card kg-image-card"><img src="https://stu.dev/content/images/2019/05/image-1.png" class="kg-image"></figure><p>The <code>build/.NETFramework/v4.6.1</code> folder contains the reference assemblies, and the <code>Microsoft.NETFramework.ReferenceAssemblies.net461.targets</code> file looks like this:</p><div class="vscode"><p><span>&lt;</span><span>Project</span><span>&gt;</span></p><p><span></span><span>&lt;</span><span>PropertyGroup</span><span></span><span>Condition</span><span>=</span><span>" ('$(TargetFrameworkIdentifier)' == '.NETFramework') And ('$(TargetFrameworkVersion)' == 'v4.6.1') "</span><span>&gt;</span></p><p><span></span><span>&lt;</span><span>TargetFrameworkRootPath</span><span>&gt;</span><span>$(MSBuildThisFileDirectory)</span><span>&lt;/</span><span>TargetFrameworkRootPath</span><span>&gt;</span></p><p><span></span><span>&lt;!-- FrameworkPathOverride is typically not set to the correct value, and the common targets include mscorlib from FrameworkPathOverride.</span></p><p><span>         So disable FrameworkPathOverride, set NoStdLib to true, and explicitly reference mscorlib here. --&gt;</span></p><p><span></span><span>&lt;</span><span>EnableFrameworkPathOverride</span><span>&gt;</span><span>false</span><span>&lt;/</span><span>EnableFrameworkPathOverride</span><span>&gt;</span></p><p><span></span><span>&lt;</span><span>NoStdLib</span><span>&gt;</span><span>true</span><span>&lt;/</span><span>NoStdLib</span><span>&gt;</span></p><p><span></span><span>&lt;/</span><span>PropertyGroup</span><span>&gt;</span></p><p><span></span><span>&lt;</span><span>ItemGroup</span><span></span><span>Condition</span><span>=</span><span>" ('$(TargetFrameworkIdentifier)' == '.NETFramework') And ('$(TargetFrameworkVersion)' == 'v4.6.1') "</span><span>&gt;</span></p><p><span></span><span>&lt;</span><span>Reference</span><span></span><span>Include</span><span>=</span><span>"mscorlib"</span><span></span><span>Pack</span><span>=</span><span>"false"</span><span></span><span>/&gt;</span></p><p><span></span><span>&lt;/</span><span>ItemGroup</span><span>&gt;</span></p><p><span>&lt;/</span><span>Project</span><span>&gt;</span></p><br></div><p>Notice that the top level condition means that this package will do nothing when you are not building for <code>net461</code> (this is evaluated per-tfm for multi-targeting).</p><p><code>EnableFrameworkPathOverride</code> is set to <code>false</code>, so the <code>FrameworkPathOverride</code> we used in the <a href="https://stu.dev/how-to-target-net4x-on-macos/">previous post</a> can be removed as it will be ignored anyway, and instead it sets the <code>TargetFrameworkRootPath</code>, which is how it will find the assemblies shipped in the package.</p><h2 id="summary">Summary</h2><p>This package works great and you can take out those old workarounds and custom NuGet feed. This is excellent work from the dotnet team!</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>