<!DOCTYPE html>
<html lang="en">
<head>
    <title>
An In-depth Look at Routing in Blazor -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>An In-depth Look at Routing in Blazor</h1><div><div class="post-content"><p>In this post, I want to build on my last post, <a href="https://chrissainty.com/introduction-to-routing-in-blazor/">Introduction to Routing in Blazor</a>, and take a deep dive into the nuts and bolts of routing in Blazor.</p><p>We're going to look at each part of Blazor's routing model in detail, starting in the JavaScript world where navigation events are picked up. And following the code over the divide to the C# world, to the point of rendering either the correct page or the not found template.</p><h2 id="intercepting-navigation-events-with-navigationmanager-javascript-">Intercepting navigation events with NavigationManager (JavaScript)</h2><p>We're going to start off looking at the <code>NavigationManager</code> service. But this isn't the <code>NavigationManager</code> we're used to interacting with in our C# code, this is the JavaScript version. </p><h3 id="intercepting-link-clicks">Intercepting link clicks</h3><p>Blazor uses something called an <code>EventDelegator</code> to manage the various events produced by DOM elements. This service exposes a function called <code>notifyAfterClick</code>, which the <code>NavigationManager</code> hooks into in order to intercept navigation link click events. When a navigation link click event occurs the following code is run.</p><pre><code class="language-typescript">if (!hasEnabledNavigationInterception) {
  return;
}

if (event.button !== 0 || eventHasSpecialKey(event)) {
  return;
}

if (event.defaultPrevented) {
  return;
}

const anchorTarget = findClosestAncestor(event.target as Element | null, 'A') as HTMLAnchorElement | null;
const hrefAttributeName = 'href';
if (anchorTarget &amp;&amp; anchorTarget.hasAttribute(hrefAttributeName)) {
  const targetAttributeValue = anchorTarget.getAttribute('target');
  const opensInSameFrame = !targetAttributeValue || targetAttributeValue === '_self';
  if (!opensInSameFrame) {
    return;
  }

  const href = anchorTarget.getAttribute(hrefAttributeName)!;
  const absoluteHref = toAbsoluteUri(href);

  if (isWithinBaseUriSpace(absoluteHref)) {
    event.preventDefault();
    performInternalNavigation(absoluteHref, true);
  }
}
</code></pre><p>We're going to break this code down a piece at a time so we can understand it.</p><p>First there are some checks being made before anything more invasive is done.</p><pre><code class="language-typescript">if (!hasEnabledNavigationInterception) {
  return;
}

if (event.button !== 0 || eventHasSpecialKey(event)) {
  // Don't stop ctrl/meta-click (etc) from opening links in new tabs/windows
  return;
}

if (event.defaultPrevented) {
  return;
}
</code></pre><p>The first check is to see if navigation interception has been enabled - this gets enabled by Blazor's router component during it's <code>OnAfterRender</code> life-cycle method. </p><p>Then there's a check to see if the link was clicked with a modifier key being held - for example, holding <code>ctrl</code> when clicking a link will open the link in a new tab. If a modifier was being held, then the event is allowed to continue normally and open in a new tab. Finally, a check is made to see if the event has had its default behaviour prevented already.</p><h3 id="determining-internal-navigation">Determining internal navigation</h3><pre><code class="language-javascript">const anchorTarget = findClosestAncestor(event.target as Element | null, 'A') as HTMLAnchorElement | null;
const hrefAttributeName = 'href';

if (anchorTarget &amp;&amp; anchorTarget.hasAttribute(hrefAttributeName)) {
  const targetAttributeValue = anchorTarget.getAttribute('target');
  const opensInSameFrame = !targetAttributeValue || targetAttributeValue === '_self';
  
  if (!opensInSameFrame) {
    return;
  }

  const href = anchorTarget.getAttribute(hrefAttributeName)!;
  const absoluteHref = toAbsoluteUri(href);

  if (isWithinBaseUriSpace(absoluteHref)) {
    event.preventDefault();
    performInternalNavigation(absoluteHref, true);
  }
}
</code></pre><p>The next section of code checks if the target of the click was an <code>&lt;a&gt;</code> tag, and if it was, that it has an <code>href</code> attribute. If either of these checks fail then the event will be allowed to continue as normal. </p><p>Next, a check happens to decide if the link should be opened in the same frame (tab) or not. If not, then again, the event is allowed to continue as normal.</p><p>Finally, the value of the <code>href</code> attribute is converted to an absolute URI - if it isn't one already. &nbsp;It's then checked to see if it falls within the scope of the base URI. This is set in the <code>&lt;head&gt;</code> tag of either the <code>index.html</code> (Blazor WebAssembly) or <code>_Hosts.cshtml</code> (Blazor Server) using the <code>&lt;base&gt;</code> element. </p><p>If the link falls within the scope of the <code>base</code> element, then it's considered internal navigation. The <code>performInternalNavigation</code> function is called, passing the absolute URI and a boolean value to indicate it was intercepted.</p><h3 id="simulating-browser-navigation">Simulating browser navigation</h3><pre><code class="language-typescript">function performInternalNavigation(absoluteInternalHref: string, interceptedLink: boolean) {
  resetScrollAfterNextBatch();

  history.pushState(null, /* ignored title */ '', absoluteInternalHref);
  notifyLocationChanged(interceptedLink);
}
</code></pre><p>The first call, <code>resetScrollAfterNextBatch</code> isn't of much interest to us. It stops unwanted flickering when resetting the scroll position during navigation. But the next part is more interesting.</p><p>The new location is pushed into the browsers history. This is what allows the forward and back buttons to function as they would in a traditional web app. By adding the new location to the browsers history it's simulating traditional app navigation. Another important function this action performs is updating the URL in the browsers address bar. </p><p>At the end, the <code>notifyLocationChanged</code> function is called.</p><h3 id="the-gateway-to-c-">The gateway to C#</h3><pre><code class="language-typescript">async function notifyLocationChanged(interceptedLink: boolean) {
  if (notifyLocationChangedCallback) {
    await notifyLocationChangedCallback(location.href, interceptedLink);
  }
}
</code></pre><p>The final step before we head into the C# world is the <code>notifyLocationChanged</code> function above. This function checks if there is a <code>notifyLocationChangedCallback</code> and then invokes it, passing the location and whether the link was intercepted.</p><p>But where does the <code>notifyLocationChangedCallback</code> come from? Well, that depends.</p><p>If we're running on WebAssembly then the callback is registered during the application startup in <code>Boot.WebAssembly.ts</code>.</p><pre><code class="language-tyepscript">// Configure navigation via JS Interop
window['Blazor']._internal.navigationManager.listenForNavigationEvents(async (uri: string, intercepted: boolean): Promise&lt;void&gt; =&gt; {
    await DotNet.invokeMethodAsync(
      'Microsoft.AspNetCore.Blazor',
      'NotifyLocationChanged',
      uri,
      intercepted
    );
});
</code></pre><p>If we're running on .NET Core (Blazor Server) then the callback is registered in <code>Boot.Server.ts</code>.</p><pre><code class="language-typescript">// Configure navigation via SignalR
window['Blazor']._internal.navigationManager.listenForNavigationEvents((uri: string, intercepted: boolean): Promise&lt;void&gt; =&gt; {
    return connection.send('OnLocationChanged', uri, intercepted);
});
</code></pre><h2 id="navigation-manager-c-">Navigation Manager (C#)</h2><p>This leads us into the C# side of things and what responds to the location changed event. </p><p>The C# version of <code>NavigationManager</code> listens for the location changed event. But the <code>NavigationManager</code> class is abstract. There are actually two implementations, one for Blazor Server called <code>RemoteNavigationManager</code>. And one for Blazor WebAssembly called <code>WebAssemblyNavigationManager</code>. </p><p>The <code>NavigationManager</code> class performs lots of useful operations, but right now, we're only interested in the <code>LocationChanged</code> event. This event gets invoked from different places depending on if we're in a Blazor WebAssembly or Blazor Server application. </p><h3 id="blazor-webassembly">Blazor WebAssembly</h3><p>When the <code>NotifyLocationChanged</code> event is invoked from the JS world it enters the C# world via a class called <code>JSInteropMethods</code>.</p><pre><code class="language-csharp">public static class JSInteropMethods
{
    /// &lt;summary&gt;
    /// For framework use only.
    /// &lt;/summary&gt;
    [JSInvokable(nameof(NotifyLocationChanged))]
    public static void NotifyLocationChanged(string uri, bool isInterceptedLink)
    {
        WebAssemblyNavigationManager.Instance.SetLocation(uri, isInterceptedLink);
    }
}
</code></pre><p>The <code>NotifyLocationChanged</code> method calls the <code>SetLocation</code> method on the <code>WebAssemblyNavigationManager</code> which looks like this.</p><pre><code class="language-csharp">public void SetLocation(string uri, bool isInterceptedLink)
{
    Uri = uri;
    NotifyLocationChanged(isInterceptedLink);
}
</code></pre><p>This method records the new URI and calls the <code>NotifyLocationChanged</code> method on the base <code>NavigationManager</code> - this method invokes an event called <code>LocationChanged</code>.</p><h3 id="blazor-server">Blazor Server</h3><p>In this version the <code>NotifyLocationChanged</code> event enters the C# world via the <code>ComponentHub</code>'s <code>OnLocationChanged</code> method.</p><pre><code class="language-csharp">public async ValueTask OnLocationChanged(string uri, bool intercepted)
{
    var circuitHost = await GetActiveCircuitAsync();
    if (circuitHost == null)
    {
        return;
    }

    _ = circuitHost.OnLocationChangedAsync(uri, intercepted);
}
</code></pre><p>This method calls the <code>CircuitHost</code>'s <code>OnLocationChangedAsync</code> method.</p><pre><code class="language-csharp">public async Task OnLocationChangedAsync(string uri, bool intercepted)
{
    AssertInitialized();
    AssertNotDisposed();

    try
    {
        await Renderer.Dispatcher.InvokeAsync(() =&gt;
        {
            Log.LocationChange(_logger, uri, CircuitId);
            var navigationManager = (RemoteNavigationManager)Services.GetRequiredService&lt;NavigationManager&gt;();
            navigationManager.NotifyLocationChanged(uri, intercepted);
            Log.LocationChangeSucceeded(_logger, uri, CircuitId);
        });
    }
    
    // Remaining code omitted for brevity
}
</code></pre><p>The interesting part for us is in the <code>try</code> block. Essentially, an instance of the <code>RemoteNavigationManager</code> is being retrieved from the DI container and then it's <code>NotifyLocationChanged</code> method is called.</p><pre><code class="language-csharp">public void NotifyLocationChanged(string uri, bool intercepted)
{
    Log.ReceivedLocationChangedNotification(_logger, uri, intercepted);

    Uri = uri;
    NotifyLocationChanged(intercepted);
}
</code></pre><p>In much the same way as the <code>WebAssemblyNavigationManager</code>, the new URI is recorded and the <code>NotifyLocationChanged</code> method on the base <code>NavigationManager</code> is called.</p><p>But what's listening? </p><p>Technically, it could be a few things. The <code>NavigationManager</code>'s <code>LocationChanged</code> event is public for anyone to handle after all. But what we're interested in is Blazor's <code>Router</code> component.</p><h2 id="the-router-component">The Router Component</h2><p>When the router is initialised it registers a handler for the <code>LocationChanged</code> event. Which looks like this.</p><pre><code class="language-csharp">private void OnLocationChanged(object sender, LocationChangedEventArgs args)
{
    _locationAbsolute = args.Location;
    if (_renderHandle.IsInitialized &amp;&amp; Routes != null)
    {
        Refresh(args.IsNavigationIntercepted);
    }
}
</code></pre><p>But in order for the router to function it needs to know what components to load for a particular URI, or route. How does it do this? </p><h3 id="finding-page-components">Finding Page Components</h3><p>We looked at the parameters the router accepts <a href="https://chrissainty.com/introduction-to-routing-in-blazor/">in the last post</a>. The router accepts a parameter called <code>AppAssembly</code>, which is required. It also accepts another optional parameter, <code>AdditionalAssemblies</code>. The router passes these assemblies to a class called <code>RouteTableFactory</code> via it's <code>Create</code> method.</p><pre><code class="language-csharp">public static RouteTable Create(IEnumerable&lt;Assembly&gt; assemblies)
{
    var key = new Key(assemblies.OrderBy(a =&gt; a.FullName).ToArray());
    if (Cache.TryGetValue(key, out var resolvedComponents))
    {
        return resolvedComponents;
    }

    var componentTypes = key.Assemblies.SelectMany(a =&gt; a.ExportedTypes.Where(t =&gt; typeof(IComponent).IsAssignableFrom(t)));
    var routeTable = Create(componentTypes);
    Cache.TryAdd(key, routeTable);
    return routeTable;
}
</code></pre><p>This method loops over each assembly and pulls out any types which implement <code>IComponent</code>. It then passes them to an internal version of <code>Create</code> for further processing.</p><pre><code class="language-csharp">internal static RouteTable Create(IEnumerable&lt;Type&gt; componentTypes)
{
    var templatesByHandler = new Dictionary&lt;Type, string[]&gt;();
    foreach (var componentType in componentTypes)
    {
        var routeAttributes = componentType.GetCustomAttributes&lt;RouteAttribute&gt;(inherit: false);

        var templates = routeAttributes.Select(t =&gt; t.Template).ToArray();
        templatesByHandler.Add(componentType, templates);
    }
    return Create(templatesByHandler);
}
</code></pre><p>This next method loops over each component and extracts any <code>RouteAttributes</code>. It then selects the template for each route. A template being what's in the quotes when using a <code>@page</code> directive, <code>@page "<strong>/my/route/template</strong>"</code> for example.</p><p>It then adds the component type and it's templates (there can be more than one <code>@page</code> directive on a component) to a dictionary which is passed to the final overload of <code>Create</code>. </p><pre><code class="language-csharp">internal static RouteTable Create(Dictionary&lt;Type, string[]&gt; templatesByHandler)
{
    var routes = new List&lt;RouteEntry&gt;();
    foreach (var keyValuePair in templatesByHandler)
    {
        var parsedTemplates = keyValuePair.Value.Select(v =&gt; TemplateParser.ParseTemplate(v)).ToArray();
        var allRouteParameterNames = parsedTemplates
            .SelectMany(GetParameterNames)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToArray();

        foreach (var parsedTemplate in parsedTemplates)
        {
            var unusedRouteParameterNames = allRouteParameterNames
                .Except(GetParameterNames(parsedTemplate), StringComparer.OrdinalIgnoreCase)
                .ToArray();
            var entry = new RouteEntry(parsedTemplate, keyValuePair.Key, unusedRouteParameterNames);
            routes.Add(entry);
        }
    }

    return new RouteTable(routes.OrderBy(id =&gt; id, RoutePrecedence).ToArray());
}
</code></pre><p>In this last method, a <code>RouteTable</code> is constructed, which is what will be used later by the <code>Router</code> to know which components to load for a given URI. </p><p>Essentially, this method does some house keeping to remove any duplication, checks that templates are valid, etc... Before constructing a <code>RouteEntry</code>, which holds the route template, component type and any unused route parameters. Finally, a new <code>RouteTable</code> is returned.</p><p>The router then stores the returned <code>RouteTable</code> so it can use it for route lookups during <code>NavigationChanged</code> events.</p><h3 id="loading-page-components">Loading Page Components</h3><p>We now understand how the <code>Router</code> knows where to find the correct components for a given route. So let's get back to the <code>OnLocationChanged</code> method.</p><pre><code class="language-csharp">private void OnLocationChanged(object sender, LocationChangedEventArgs args)
{
    _locationAbsolute = args.Location;
    if (_renderHandle.IsInitialized &amp;&amp; Routes != null)
    {
        Refresh(args.IsNavigationIntercepted);
    }
}
</code></pre><p>In the code above the router stores the new URI and then performs some checks. One of which is checking that it has a <code>RouteTable</code>. If everything is present and correct the <code>Refresh</code> method is called.</p><pre><code class="language-csharp">private void Refresh(bool isNavigationIntercepted)
{
    var locationPath = NavigationManager.ToBaseRelativePath(_locationAbsolute);
    locationPath = StringUntilAny(locationPath, _queryOrHashStartChar);
    var context = new RouteContext(locationPath);
    Routes.Route(context);

    if (context.Handler != null)
    {
        if (!typeof(IComponent).IsAssignableFrom(context.Handler))
        {
            throw new InvalidOperationException($"The type {context.Handler.FullName} " +
                $"does not implement {typeof(IComponent).FullName}.");
        }

        Log.NavigatingToComponent(_logger, context.Handler, locationPath, _baseUri);

        var routeData = new RouteData(
            context.Handler,
            context.Parameters ?? _emptyParametersDictionary);
        _renderHandle.Render(Found(routeData));
    }
    else
    {
        if (!isNavigationIntercepted)
        {
            Log.DisplayingNotFound(_logger, locationPath, _baseUri);
            _renderHandle.Render(NotFound);
        }
        else
        {
            Log.NavigatingToExternalUri(_logger, _locationAbsolute, locationPath, _baseUri);
            NavigationManager.NavigateTo(_locationAbsolute, forceLoad: true);
        }
    }
}
</code></pre><p>We'll work through the code a piece at a time to understand what's going on.</p><pre><code class="language-csharp">var locationPath = NavigationManager.ToBaseRelativePath(_locationAbsolute);
locationPath = StringUntilAny(locationPath, _queryOrHashStartChar);
var context = new RouteContext(locationPath);
Routes.Route(context);
</code></pre><p>The code above is converting the current URL to a relative URL, then stripping off any querystrings (<em>?name=chris</em>) or hash strings (<em>#my-div</em>). Then a new <code>RouteContext</code> is created using the remaining path. &nbsp;</p><p>A <code>RouteContext</code> takes the string provided and splits it on each <code>/</code> into segments. Finally, the <code>Route</code> method is called on the routing table.</p><p>Inside the <code>Route</code> method, each route in the routing table is checked to see if it matches the route in the <code>RouteContext</code> being passed in. This is done by calling the <code>Match</code> method on each <code>RouteEntry</code>. </p><pre><code class="language-csharp">internal void Match(RouteContext context)
{
    if (Template.Segments.Length != context.Segments.Length)
    {
        return;
    }

    // Parameters will be lazily initialized.
    IDictionary&lt;string, object&gt; parameters = null;
    for (int i = 0; i &lt; Template.Segments.Length; i++)
    {
        var segment = Template.Segments[i];
        var pathSegment = context.Segments[i];
        if (!segment.Match(pathSegment, out var matchedParameterValue))
        {
            return;
        }
        else
        {
            if (segment.IsParameter)
            {
                GetParameters()[segment.Value] = matchedParameterValue;
            }
        }
    }

    context.Parameters = parameters;
    context.Handler = Handler;

    IDictionary&lt;string, object&gt; GetParameters()
    {
        if (parameters == null)
        {
            parameters = new Dictionary&lt;string, object&gt;();
        }

        return parameters;
    }
}
</code></pre><p>The <code>Match</code> method first checks to see if the number of segments in the routes are the same. If that succeeds, then each route segment is checked individually to ensure a match. </p><p>If the segment on the <code>RouteEntry</code> is marked as a parameter, then the value for that segment on the <code>RouteContext</code> is added to a parameters collection. Once each segment has been checked, any parameters are added to the <code>RouteContext</code> along with the <code>Handler</code> for that route, which is the component type.</p><h3 id="a-match-was-found-load-the-page-">A match was found - load the page!</h3><pre><code class="language-csharp">if (context.Handler != null)
{
    if (!typeof(IComponent).IsAssignableFrom(context.Handler))
    {
        throw new InvalidOperationException($"The type {context.Handler.FullName} " +
            $"does not implement {typeof(IComponent).FullName}.");
    }

    Log.NavigatingToComponent(_logger, context.Handler, locationPath, _baseUri);

    var routeData = new RouteData(
        context.Handler,
        context.Parameters ?? _emptyParametersDictionary);
    _renderHandle.Render(Found(routeData));
}
</code></pre><p>This executes if a handler was assigned i.e. a match was found for the route. A final check is made to make sure the handler component is definitely implementing <code>IComponent</code>. If that passes then the a <code>RouteData</code> object is constructed with the handler and any parameters which need to be passed to the handler. </p><p>A render is then queued which will use the <code>Found</code> template with the route data. This will then render the correct page component and supply it with any necessary parameters.</p><h3 id="no-match-found-load-not-found-template">No match found - Load not found template</h3><pre><code class="language-csharp">else
{
    if (!isNavigationIntercepted)
    {
        Log.DisplayingNotFound(_logger, locationPath, _baseUri);
        _renderHandle.Render(NotFound);
    }
    else
    {
        Log.NavigatingToExternalUri(_logger, _locationAbsolute, locationPath, _baseUri);
        NavigationManager.NavigateTo(_locationAbsolute, forceLoad: true);
    }
}
</code></pre><p>First a check is made to see if the navigation was intercepted. If it wasn't intercepted, this can only occur programmatically, so the <code>NotFound</code> template is queued to be rendered.</p><p>If it was intercepted then a browser reload is forced to the new location, the main scenario for this would be linking to another page on the same domain which isn't a Blazor component, for example, a standard HTML page or a Razor Page or MVC view.</p><h2 id="summary">Summary</h2><p>That's it! We've reached the end of the journey. We've followed the flow of navigation events from the source, starting in the JavaScript world all the way to the point of rendering either the correct page component or the not found template.</p><p>I hope you've found this post interesting, I've certainly learned a lot about how the mechanics of client-side routers work writing this post. Next time, we'll have a go at writing our own router and replacing the default implementation.</p><hr><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>