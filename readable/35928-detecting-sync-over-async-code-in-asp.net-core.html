<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Detecting Sync over Async Code in ASP.NET Core -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Detecting Sync over Async Code in ASP.NET Core</h1><div><div class="entry-content"><p>It’s pretty easy to write some bad async code, especially when you first start using async/await.  Async/await is pretty viral in .NET, which means it generally goes all the way through the stack.  This can be challenging if you are trying to add async/await to an existing app and you usually end up adding sync over async code.</p><p>If you don’t use async/await correctly, and end up writing sync-over-async code, you’ll ultimately end up causing ThreadPool starvation.  </p><figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><h2>Sync over Async</h2><p>The term refers to making an async call but not awaiting it.  Often time this is caused by calling <strong>.Wait()</strong> or <strong>.Result</strong> on the returned <strong>Task</strong>.</p><figure class="wp-block-embed"><h2>Ben.BlockingDetector</h2><p>Ben Adams wrote a Blocking Detector for ASP.NET Core.</p><p>Start by adding the NuGet package <strong><a href="https://www.nuget.org/packages/Ben.BlockingDetector/" target="_blank" rel="noreferrer noopener" aria-label="Ben.BlockingDetector (opens in a new tab)">Ben.BlockingDetector</a></strong> to your csproj.</p><figure class="wp-block-embed"><p>At the very beginning (or the higher the better) of your <strong>Configure()</strong> method in your Startup, add the <strong>UseBlockingDetection()</strong> extension method to the <strong>IApplicationBuilder</strong>.</p><figure class="wp-block-embed"><p>That’s it.  Really.  Now when we run our application and hit the /sync-over-async route from the example above, a warning is logged in the console (or however you have logging configured).</p><figure class="wp-block-image"><a href="https://codeopinion.com/wp-content/uploads/2019/09/benblocking.png" target="_blank" rel="noreferrer noopener"><img src="https://codeopinion.com/wp-content/uploads/2019/09/benblocking-1024x670.png" alt="" class="wp-image-6564" srcset="https://codeopinion.com/wp-content/uploads/2019/09/benblocking-1024x670.png 1024w, https://codeopinion.com/wp-content/uploads/2019/09/benblocking-300x196.png 300w, https://codeopinion.com/wp-content/uploads/2019/09/benblocking-768x503.png 768w" sizes="(max-width: 1024px) 100vw, 1024px"></a><figcaption>I’ve added the red arrow to point out our sync-over-async method in the call stack.</figcaption></figure><h2>Microsoft.VisualStudio.Threading.Analyzers</h2><p>Another great tool is the <a rel="noreferrer noopener" aria-label=" (opens in a new tab)" href="https://www.nuget.org/packages/Microsoft.VisualStudio.Threading.Analyzers/" target="_blank">Microsoft.VisualStudio.Threading.Analyzers</a> NuGet Package.</p><blockquote class="wp-block-quote"><p>Static code analyzer to detect common mistakes or potential issues regarding threading and async coding. </p></blockquote><p>Simply add it the PackageReference to your csproj and by default, you will immediately be getting warnings about sync over async calls.  Here’s a screenshot in JetBrains Rider (which also can use Roslyn analyzers) that is notifying us of the issue.</p><figure class="wp-block-image"><a href="https://codeopinion.com/wp-content/uploads/2019/09/analyzer.png" target="_blank" rel="noreferrer noopener"><img src="https://codeopinion.com/wp-content/uploads/2019/09/analyzer-1024x450.png" alt="" class="wp-image-6565" srcset="https://codeopinion.com/wp-content/uploads/2019/09/analyzer-1024x450.png 1024w, https://codeopinion.com/wp-content/uploads/2019/09/analyzer-300x132.png 300w, https://codeopinion.com/wp-content/uploads/2019/09/analyzer-768x337.png 768w, https://codeopinion.com/wp-content/uploads/2019/09/analyzer.png 1223w" sizes="(max-width: 1024px) 100vw, 1024px"></a></figure><p>Are you using any other analyzers or packages to detect blocking or problematic async code?  Let me know in the comments or on Twitter.</p><p>Related Posts: I’ve also written a post on <a rel="noreferrer noopener" aria-label="Lazy Async (opens in a new tab)" href="https://codeopinion.com/lazy-async/" target="_blank">Lazy Async</a> which try’s to solve the issue of deferring doing IO until it’s first needed.</p><a href="https://twitter.com/codeopinion?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-size="large" data-show-count="false">Follow @codeopinion</a></figure></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>