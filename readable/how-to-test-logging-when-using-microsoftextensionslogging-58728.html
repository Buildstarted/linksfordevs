<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How to test logging when using Microsoft.Extensions.Logging - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="How to test logging when using Microsoft.Extensions.Logging - linksfor.dev(s)"/>
    <meta property="og:description" content="A tutorial to easily write effective tests of the logs generated by your libraries of applications. Introducing MELT, a Testing library for Microsoft.Extensions.Logging."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://alessio.franceschelli.me/posts/dotnet/how-to-test-logging-when-using-microsoft-extensions-logging/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - How to test logging when using Microsoft.Extensions.Logging</title>
<div class="readable">
        <h1>How to test logging when using Microsoft.Extensions.Logging</h1>
            <div>Reading time: 19-24 minutes</div>
        <div>Posted here: 21 Feb 2020</div>
        <p><a href="https://alessio.franceschelli.me/posts/dotnet/how-to-test-logging-when-using-microsoft-extensions-logging/">https://alessio.franceschelli.me/posts/dotnet/how-to-test-logging-when-using-microsoft-extensions-logging/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div role="main"><article><header><p><a href="https://alessio.franceschelli.me/categories/dotnet/">.NET</a> and
<a href="https://alessio.franceschelli.me/categories/dotnet-core/">.NET Core</a></p><span><time datetime="2020-01-27T00:00:00Z">January 27, 2020</time>
<span>- 15 minutes read</span>
<span>- 3050 words</span><br><span>Updated on
<time datetime="2020-02-18T23:22:13Z">February 18, 2020</time></span></span></header><section><p>Logs are a key element for diagnosing, monitoring or auditing the application's behaviour, so if you are either a library author or you are developing an application, it is important to ensure that the right logs are generated.</p><p>Would it be nice if there was an easy solution to write tests for it?
Let's start a journey through the best approaches to tests logs when using <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging/">Microsoft.Extensions.Logging</a>.</p><blockquote><p>If you don't want to follow along and you are just looking for a ready to use solution, please skip to the <a href="#introducing-melt-a-testing-library-for-microsoftextensionslogging">Introducing MELT, a Testing library for Microsoft.Extensions.Logging</a> section.</p></blockquote><blockquote><p><a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging/">Microsoft.Extensions.Logging</a> is the defacto standard abstraction in .NET (not only on .NET Core) to generate logs from either libraries or applicaitons, since its introdution alongside the first version of <a href="https://docs.microsoft.com/en-us/aspnet/core/">ASP.NET Core</a>.</p></blockquote><p>Usually, with it, you inject an <code>ILogger&lt;T&gt;</code> and then leverage the simplified extension methods to log, like:</p><div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>Sample</span>
<span>{</span>
  <span>private</span> <span>readonly</span> <span>ILogger</span><span>&lt;</span><span>Sample</span><span>&gt;</span> <span>_logger</span><span>;</span>

  <span>public</span> <span>Sample</span><span>(</span><span>ILogger</span><span>&lt;</span><span>Sample</span><span>&gt;</span> <span>logger</span><span>)</span>
  <span>{</span>
    <span>_logger</span> <span>=</span> <span>logger</span><span>;</span>
  <span>}</span>

  <span>public</span> <span>void</span> <span>DoSomething</span><span>(</span><span>)</span>
  <span>{</span>
    <span>_logger</span><span>.</span><span>LogInformation</span><span>(</span><span>"The answer is {number}"</span><span>,</span> <span>4</span><span>2</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div><p>This leverage the extension method:</p><div><pre><code data-lang="csharp"><span>public</span> <span>static</span> <span>void</span> <span>LogInformation</span><span>(</span><span>this</span> <span>ILogger</span> <span>logger</span><span>,</span> <span>string</span> <span>message</span><span>,</span> <span>params</span> <span>object</span><span>[</span><span>]</span> <span>args</span><span>)</span>
</code></pre></div><p>The extension methods are much cleaner to use, as you can simply provide a message template with a list of arguments, similar to a <code>string.Format()</code>, compared to the <code>Log</code> method provided by the <code>ILogger&lt;T&gt;</code> interface, which even requires to provide in each call a <code>formatter</code> to format the <code>state</code> (which in this example would be our message template and its list of arguments).</p><div><pre><code data-lang="csharp"><span>public</span> <span>interface</span> <span>ILogger</span>
<span>{</span>
    <span>void</span> <span>Log</span><span>&lt;</span><span>TState</span><span>&gt;</span><span>(</span><span>LogLevel</span> <span>logLevel</span><span>,</span> <span>EventId</span> <span>eventId</span><span>,</span> <span>TState</span> <span>state</span><span>,</span> <span>Exception</span> <span>exception</span><span>,</span> <span>Func</span><span>&lt;</span><span>TState</span><span>,</span> <span>Exception</span><span>,</span> <span>string</span><span>&gt;</span> <span>formatter</span><span>)</span><span>;</span>

    <span>// ...
</span><span></span><span>}</span>
</code></pre></div><blockquote><p>If you want to learn the best practices for logging, I would recommend reading <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/">Logging in .NET Core and ASP.NET Core</a>.</p></blockquote><h2 id="what-are-the-implications-of-this-design-of-the-library-for-testing-the-emitted-logs">What are the implications of this design of the library for testing the emitted logs?</h2><p>It is tempting to mock an <code>ILogger&lt;T&gt;</code> using a mocking framework that keeps track of the invocations to assert in our tests that we have correctly emitted the required logs.
However, as we would have to verify the calls to the <code>Log&lt;TState&gt;</code> method, but in our code we are probably leveraging on the extensions method, we would first need to understand the implementation of these extension methods to figure out which arguments are passed in the <code>Log&lt;TState&gt;()</code> invocation. In doing so, we would be tying our tests to the implementation of the extensions method, which is an internal implementation detail of the logging library.
In fact, those extension methods could change what to use as <code>state</code>, and updating the <code>formatter</code> accordingly, without affecting the generated logs, but breaking our tests if we were leveraging on this internal detail.</p><p>Let's take a step back:
<strong>what we really want to test are the generated logs, not the method's invocations of the <code>ILogger&lt;T&gt;</code></strong>!</p><p>So, probably, mocking an <code>Ilogger&lt;T&gt;</code> is not the best approach. Furthermore, <a href="https://www.nuget.org/packages/Microsoft.Extensions.Logging/">Microsoft.Extensions.Logging</a> has a concept of <code>Scope</code> to decorate the logs, allowing to push and pop scopes on a stack that will be used to decorate the logs, based on which scopes are present at any given point. If we limit ourself to assert the invocations of the methods after the execution, we would not be able to keep track of the scopes. We could create a more complex fake logger so that we could maintain a state, however, this will increase the complexity while still not testing at the right level.</p><p>So far we have also looked at the very simple case of writing a unit test. Once we move to integration tests, we would not have a single <code>ILogger&lt;T&gt;</code> anymore, but multiple ones created by an <code>ILoggerFactory</code>, all sharing the same stack of scopes! <strong>As you can imagine, the complexity will quickly skyrocket.</strong> 🚀</p><h2 id="a-better-approach">A better approach</h2><p>If we want to focus on testing the outcome of the logging of our application, which means testing the generated logs without worrying about all the layers of extension methods and the implementation details of <code>Microsoft.Extensions.Logging</code>, we need to first understand the structure of this library so that we can find the best place to hook into.</p><p>Without getting into too many details, the <code>Microsoft.Extensions.Logging</code> library (MEL for friends), is made of:</p><ul><li><p>loggers (<code>ILogger</code>/<code>ILogger&lt;T&gt;</code>)</p><p>The logger used to send the logs to, usually one per class instance.</p></li><li><p>a logger factory (<code>ILoggerFactory</code>)</p><p>The factory is responsible to create the loggers</p></li><li><p>logger providers (<code>ILoggerProvider</code>)</p><p>A provider defines a target for the logs and you can register multiple providers to the factory so that multiple targets can receive the logs.</p></li></ul><p>When a logger is requested from the factory, the factory will request a logger from each provider, then creating a logger that wrap these multiple loggers, so to send everything to all of them.</p><p>What we need to do for our testing, is to create an <code>ILogger</code> that sends the data to an in-memory data structure we can then assert against. It needs to be shared across multiple loggers preserving the orders the entries are received. Furthermore, this should be not only limited to store the log entries, but also the scopes, which needs to be stored on a <em>stack</em>.</p><p>In fact, when <code>BeginScope</code> is invoked we need to enqueue the new state and return an instance that, when <em>disposed</em>, will <em>pop</em> that particular scope.</p><div><pre><code data-lang="csharp"><span>public</span> <span>interface</span> <span>ILogger</span>
<span>{</span>
    <span>IDisposable</span> <span>BeginScope</span><span>&lt;</span><span>TState</span><span>&gt;</span><span>(</span><span>TState</span> <span>state</span><span>)</span><span>;</span>

    <span>// ...
</span><span></span><span>}</span>
</code></pre></div><blockquote><p>Please note that when using <code>Microsoft.Extensions.Logging</code>, it is important to remove the scopes in the opposite order they have been added, as <em>popping</em> out of order is not supported and can lead to unexpected consequences. The best approach is to rely on using statements to reduce the risk of mistakes.</p></blockquote><p>We would also need to capture the current scope when we log an <em>entry</em>, so we can later check if that entry was produced inside the proper scope.</p><p>Once we have implemented our logger, we need to implement a provider that would instantiate it when requested from the factory, and the default factory will take care of the rests.</p><p>This is a great approach for our integration tests!</p><p>In unit tests, we can avoid implementing a provider and instead create a simple factory that would just return a logger, to reduce complexity. Obviously, it would be preferable to leave the logging library completely out of the picture but, for the reason described in the previous paragraphs, it would be more pain than gain. <strong>If we can isolate the implementation of the new provider and all the logic to create a factory, with or without registering the provider based on the context, then create the logger to pass to our fixture to test, we could keep our tests clean and have a ready to use solution so not to worry again about it.</strong></p><h2 id="introducing-melt-a-testing-library-for-microsoftextensionslogging">Introducing MELT, a Testing library for Microsoft.Extensions.Logging</h2><p>As you can guess… you are not the only software developer that wants to test logging! 😄
In fact, while developing the logging library and consuming it, the ASP.NET Core team has created <a href="https://github.com/aspnet/Extensions/tree/master/src/Logging/Logging.Testing">Microsoft.Extensions.Logging.Testing</a>, a library used internally in <a href="https://github.com/aspnet/AspNetCore">ASP.NET Core</a> for testing the logging.</p><p>All good? Not really!</p><p>Unfortunately <a href="https://github.com/aspnet/Extensions/issues/672#issuecomment-532850535">there is currently no plan to offer an official package for it</a>.
For this reason, I decided to create <strong><a href="https://github.com/alefranz/MELT">MELT</a>, a repackaging with a <em>sweetened</em> API and some omissions of <code>Microsoft.Extensions.Logging.Testing</code></strong>, so you can just add the <a href="https://www.nuget.org/packages/MELT/">MELT</a> NuGet package to your test projects and carry on with your life. 😏</p><blockquote><p><a href="https://github.com/alefranz/MELT">MELT</a> is a free, open-source, testing library for the .NET Standard <em>Microsoft Extensions Logging</em> library.
It is licensed under <a href="https://github.com/alefranz/MELT/blob/master/LICENSE">Apache License 2.0</a>.
Most of the code is copyrighted by the .NET Foundation as mentioned in the files headers.</p></blockquote><p>The original plan was to simply re-package the existing library to make it easily available on <a href="https://www.nuget.org/">NuGet.org</a>.
However, once I started to write some usage examples, I realized that it was a bit too powerful: having access to internal aspects of the logging gives great flexibility on testing, but makes tests a little too verbose as well as giving me the impression of not being straightforward to use without a basic understanding of the architecture of the logging library. This made perfect sense in the context where this library has been created and used, but in my opinion, it would have prevented an easy adoption out of that small circle (and I guess this is part of the reason why Microsoft deemed too costly to publish it directly).</p><p>As I didn't want to alter the nature of the library, I started to add some extensions methods to simplify the usage in the really simples scenario, while not modifying the original library.
This approach was however increasing the code complexity and, most of all, not allowing me to offer a good discovery and autocompletion experience, as the <code>IntelliSense</code> was overcrowded with duplicated functionalities.
In version <code>0.3</code> I finally gave up 🙄 and decided to refactor the library to my liking, in the hope of providing a simpler API while keeping the flexibility to get access to all the internal state if needed. <strong>Please be aware as is not an exact replica of the Microsoft library, I could have introduced bugs in the process!</strong></p><p>I am reasonably happy with the current shape, so I don't plan to do more breaking changes and I aim to soon release a <code>1.0</code> version, once I have improved the documentation shown in <code>IntelliSense</code>. <strong>If you want to help to get to the first stable version or you have any suggestions for improvements, this is a good time!</strong></p><h2 id="how-to-write-unit-tests-with-melt">How to write unit tests with MELT?</h2><ul><li><p>Install the NuGet package <a href="https://www.nuget.org/packages/MELT/">MELT</a></p><div><pre><code data-lang="xml"><span>&lt;PackageReference</span> <span>Include=</span><span>"MELT"</span> <span>Version=</span><span>"0.4.0"</span> <span>/&gt;</span>
</code></pre></div></li><li><p>Get a test logger factory</p><div><pre><code data-lang="csharp"><span>var</span> <span>loggerFactory</span> <span>=</span> <span>MELTBuilder</span><span>.</span><span>CreateLoggerFactory</span><span>(</span><span>)</span><span>;</span>
</code></pre></div></li><li><p>Get a logger from the factory, as usual, to pass to your fixture.</p><div><pre><code data-lang="csharp"><span>var</span> <span>logger</span> <span>=</span> <span>loggerFactory</span><span>.</span><span>CreateLogger</span><span>&lt;</span><span>Sample</span><span>&gt;</span><span>(</span><span>)</span><span>;</span>
</code></pre></div></li></ul><h3 id="assert-log-entries">Assert log entries</h3><p>The logger factory exposes a property <code>LogEntries</code> that enumerates all the logs captured.
Each entry exposes all the relevant property for a log.</p><p>For example, to test with <code>xUnit</code> that a single log has been emitted and it had a specific message:</p><div><pre><code data-lang="csharp"><span>var</span> <span>log</span> <span>=</span> <span>Assert</span><span>.</span><span>Single</span><span>(</span><span>loggerFactory</span><span>.</span><span>LogEntries</span><span>)</span><span>;</span>
<span>Assert</span><span>.</span><span>Equal</span><span>(</span><span>"The answer is 42"</span><span>,</span> <span>log</span><span>.</span><span>Message</span><span>)</span><span>;</span>
</code></pre></div><h3 id="assert-scopes">Assert scopes</h3><p>The logger factory exposes a property <code>Scopes</code> that enumerates all the scopes captured.</p><p>For example, to test with <code>xUnit</code> that a single scope has been emitted and it had a specific message:</p><div><pre><code data-lang="csharp"><span>var</span> <span>scope</span> <span>=</span> <span>Assert</span><span>.</span><span>Single</span><span>(</span><span>loggerFactory</span><span>.</span><span>Scopes</span><span>)</span><span>;</span>
<span>Assert</span><span>.</span><span>Equal</span><span>(</span><span>"I'm in the GET scope"</span><span>,</span> <span>scope</span><span>.</span><span>Message</span><span>)</span><span>;</span>
</code></pre></div><p>There is also a property <code>Scope</code> in each log entry to have the scope captured with that entry.</p><h3 id="assert-message-format">Assert message format</h3><div><pre><code data-lang="csharp"><span>var</span> <span>log</span> <span>=</span> <span>Assert</span><span>.</span><span>Single</span><span>(</span><span>loggerFactory</span><span>.</span><span>LogEntries</span><span>)</span><span>;</span>
<span>Assert</span><span>.</span><span>Equal</span><span>(</span><span>"The answer is {number}"</span><span>,</span> <span>log</span><span>.</span><span>Format</span><span>)</span><span>;</span>
</code></pre></div><h3 id="easily-test-log-or-scope-properties-with-xunit">Easily test log or scope properties with xUnit</h3><ul><li><p>Install the NuGet package <a href="https://www.nuget.org/packages/MELT.Xunit/">MELT.Xunit</a></p><div><pre><code data-lang="xml"><span>&lt;PackageReference</span> <span>Include=</span><span>"MELT.Xunit"</span> <span>Version=</span><span>"0.4.0"</span> <span>/&gt;</span>
</code></pre></div></li><li><p>Use the <code>LogValuesAssert.Contains(...)</code> helpers.
For example, to test that a single log has been emitted and it had a property <code>number</code> with value <code>42</code>:</p><div><pre><code data-lang="csharp"><span>var</span> <span>log</span> <span>=</span> <span>Assert</span><span>.</span><span>Single</span><span>(</span><span>loggerFactory</span><span>.</span><span>LogEntries</span><span>)</span><span>;</span>
<span>LogValuesAssert</span><span>.</span><span>Contains</span><span>(</span><span>"number"</span><span>,</span> <span>4</span><span>2</span><span>,</span> <span>log</span><span>.</span><span>Properties</span><span>)</span><span>;</span>
</code></pre></div></li></ul><h3 id="and-much-more">And much more</h3><p>You can assert against all the characteristic of a log entry: <code>EventId</code>, <code>Exception</code>, <code>LoggerName</code>, <code>LogLevel</code>, <code>Message</code>, <code>Format</code>, <code>Properties</code> and <code>Scope</code>.</p><h3 id="limitations">Limitations</h3><p>For simplicity, when log entries are generated, only the innermost scope is captured and assigned to that log entry. So, although all scopes are tracked and can be tested, in the context of a log entry only one scope can be verified, as usual scopes are not deeply nested in a single unit. If this is not enough for you, please leave a comment below or <a href="https://github.com/alefranz/MELT/issues/new">file an issue</a> on GitHub, ideally with a use case.</p><h2 id="but-you-mentioned-the-complexity-is-in-writing-integration-tests-how-will-it-help-me">But you mentioned the complexity is in writing integration tests, how will it help me?</h2><p>For the integration tests you need some setup, but it is pretty straightforward and support all the different scenarios to write integration tests for ASP.NET Core.</p><ul><li><p>Install the NuGet package <a href="https://www.nuget.org/packages/MELT.AspNetCore/">MELT.AspNetCore</a></p><div><pre><code data-lang="xml"><span>&lt;PackageReference</span> <span>Include=</span><span>"MELT.AspNetCore"</span> <span>Version=</span><span>"0.4.0"</span> <span>/&gt;</span>
</code></pre></div></li><li><p>Create a test sink using <code>MELTBuilder.CreateTestSink(...)</code>, where you can also customize the behaviour.</p><p>For example to filter all log entries and scopes not generated by loggers consumed in the <code>SampleWebApplication.*</code> namespace (this filters the logger name so it assumes you are using <code>ILogger&lt;T&gt;</code> or following the default naming convention for your loggers.)</p><div><pre><code data-lang="csharp"><span>ITestSink</span> <span>_sink</span> <span>=</span> <span>MELTBuilder</span><span>.</span><span>CreateTestSink</span><span>(</span><span>options</span> <span>=</span><span>&gt;</span> <span>options</span><span>.</span><span>FilterByNamespace</span><span>(</span><span>nameof</span><span>(</span><span>SampleWebApplication</span><span>)</span><span>)</span><span>)</span><span>;</span>
</code></pre></div><p>You can also filter by logger name using <code>FilterByTypeName&lt;T&gt;()</code> or <code>FilterByLoggerName(string name)</code>.</p></li><li><p>Use the <code>AddTestLogger(...)</code> extension method to add the test logger provider to the logging builder. This can be done where you are already configuring the web host builder.</p><p>Configure the logger using <code>WithWebHostBuilder</code> on the factory.</p><div><pre><code data-lang="csharp"><span>using</span> <span>Microsoft.AspNetCore.Hosting</span><span>;</span>
<span>using</span> <span>Microsoft.AspNetCore.Mvc.Testing</span><span>;</span>
<span>// ...
</span><span></span><span>var</span> <span>factory</span> <span>=</span> <span>factory</span><span>.</span><span>WithWebHostBuilder</span><span>(</span><span>builder</span> <span>=</span><span>&gt;</span> <span>builder</span><span>.</span><span>UseTestLogging</span><span>(</span><span>_sink</span><span>)</span><span>)</span><span>;</span>
</code></pre></div><p>Alternatively, you can configure the logger builder in the <code>ConfigureWebHost</code> implementation of your custom <code>WebApplicationFactory&lt;T&gt;</code>.
If you chose so, the same sink will be used by all tests using the same factory.
You can clear the sink in the test constructor with <code>Clear()</code> if you like to have a clean state before each test, as xUnit will not run tests consuming the same fixture in parallel.</p><p>The logger will be automatically injected with Dependency Injection.</p></li><li><p>Alternatively, you can set it up in your custom <code>WebApplicationFactory&lt;TStartup&gt;</code>.</p><div><pre><code data-lang="csharp"><span>using</span> <span>Microsoft.AspNetCore.Hosting</span><span>;</span>
<span>using</span> <span>Microsoft.AspNetCore.Mvc.Testing</span><span>;</span>

<span>public</span> <span>class</span> <span>CustomWebApplicationFactory</span><span>&lt;</span><span>TStartup</span><span>&gt;</span> <span>:</span> <span>WebApplicationFactory</span><span>&lt;</span><span>TStartup</span><span>&gt;</span>
    <span>where</span> <span>TStartup</span> <span>:</span> <span>class</span>
<span>{</span>
    <span>protected</span> <span>override</span> <span>void</span> <span>ConfigureWebHost</span><span>(</span><span>IWebHostBuilder</span> <span>builder</span><span>)</span>
    <span>{</span>
        <span>builder</span><span>.</span><span>UseTestLogging</span><span>(</span><span>options</span> <span>=</span><span>&gt;</span> <span>options</span><span>.</span><span>FilterByNamespace</span><span>(</span><span>nameof</span><span>(</span><span>SampleWebApplication</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>// ...
</span><span></span>    <span>}</span>
<span>}</span>
</code></pre></div><p>You can then retrieve the sink to assert against using the extension method <code>GetTestSink()</code> on the factory.</p><p>Please note that in this case, all tests sharing the same factory will get the same sink.
You can reset it between tests with <code>Clear()</code> in the constructor of your <code>xUnit</code> tests. For example:</p><div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>LoggingTestWithInjectedFactory</span> <span>:</span> <span>IClassFixture</span><span>&lt;</span><span>CustomWebApplicationFactory</span><span>&lt;</span><span>Startup</span><span>&gt;</span><span>&gt;</span>
<span>{</span>
    <span>private</span> <span>readonly</span> <span>CustomWebApplicationFactory</span><span>&lt;</span><span>Startup</span><span>&gt;</span> <span>_factory</span><span>;</span>

    <span>public</span> <span>LoggingTestWithInjectedFactory</span><span>(</span><span>CustomWebApplicationFactory</span><span>&lt;</span><span>Startup</span><span>&gt;</span> <span>factory</span><span>)</span>
    <span>{</span>
        <span>_factory</span> <span>=</span> <span>factory</span><span>;</span>
        <span>// In this case the factory will be resused for all tests, so the sink will be shared as well.
</span><span></span>        <span>// We can clear the sink before each test execution, as xUnit will not run this tests in parallel.
</span><span></span>        <span>_factory</span><span>.</span><span>GetTestSink</span><span>(</span><span>)</span><span>.</span><span>Clear</span><span>(</span><span>)</span><span>;</span>
        <span>// When running on 2.x, the server is not initialized until it is explicitly started or the first client is created.
</span><span></span>        <span>// So we need to use:
</span><span></span>        <span>// if (_factory.TryGetTestSink(out var testSink)) testSink.Clear();
</span><span></span>    <span>}</span>
<span>}</span>
</code></pre></div></li></ul><p>Once you have set it up, the logger will be automatically injected when requested, or you can manually retrieve it from the factory when needed.
You can then retrieve the log holder, called <em>sink</em>, from the <code>WebApplicationFactory</code> with <code>GetTestSink()</code> if you don't have it as a field, depending on which route you followed.
Form the <em>sink</em> you can then get the <code>LogEntries</code> and <code>Scopes</code>, and do the assertion as in the unit tests.</p><h2 id="but-i-only-need-to-write-a-simple-test-i-dont-want-to-use-a-library-not-even-a-mocking-one">But I only need to write a simple test, I don't want to use a library, not even a mocking one!</h2><p>I hear you! If you are only after a simple unit test, yes you can create a really simple fake implementation of the logger, without having to worry about factories or providers. For example, you can simply capture all the log calls and store the log level and message on a list to be asserted later, relying on the fact that the logging library implements a sane default <code>ToString()</code> on the data structure passed to the <code>Log()</code> method.</p><p>You can write something like:</p><div><pre><code data-lang="csharp"><span>private</span> <span>class</span> <span>FakeLogger</span> <span>:</span> <span>ILogger</span><span>&lt;</span><span>Sample</span><span>&gt;</span>
<span>{</span>
    <span>public</span> <span>List</span><span>&lt;</span><span>(</span><span>LogLevel</span> <span>Level</span><span>,</span> <span>string</span> <span>Message</span><span>)</span><span>&gt;</span> <span>Entries</span> <span>{</span> <span>get</span><span>;</span> <span>}</span> <span>=</span> <span>new</span> <span>List</span><span>&lt;</span><span>(</span><span>LogLevel</span><span>,</span> <span>string</span><span>)</span><span>&gt;</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>IDisposable</span> <span>BeginScope</span><span>&lt;</span><span>TState</span><span>&gt;</span><span>(</span><span>TState</span> <span>state</span><span>)</span> <span>=</span><span>&gt;</span> <span>throw</span> <span>new</span> <span>NotImplementedException</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>bool</span> <span>IsEnabled</span><span>(</span><span>LogLevel</span> <span>logLevel</span><span>)</span> <span>=</span><span>&gt;</span> <span>throw</span> <span>new</span> <span>NotImplementedException</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>Log</span><span>&lt;</span><span>TState</span><span>&gt;</span><span>(</span><span>LogLevel</span> <span>logLevel</span><span>,</span> <span>EventId</span> <span>eventId</span><span>,</span> <span>TState</span> <span>state</span><span>,</span> <span>Exception</span> <span>exception</span><span>,</span> <span>Func</span><span>&lt;</span><span>TState</span><span>,</span> <span>Exception</span><span>,</span> <span>string</span><span>&gt;</span> <span>formatter</span><span>)</span>
    <span>{</span>
        <span>// This is relying on an internal implementation detail, it will break!
</span><span></span>        <span>string</span> <span>message</span> <span>=</span> <span>state</span><span>.</span><span>ToString</span><span>(</span><span>)</span><span>;</span>

        <span>Entries</span><span>.</span><span>Add</span><span>(</span><span>(</span><span>logLevel</span><span>,</span> <span>message</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>However, this means relying on a source (either a blog post like this one or the actual source code) or some experimentation to know that you can use <code>ToString()</code> on the state to get the message. If it works in your scenario, that's good! It's doesn't really matter if it will not work in every possible scenario. But will it stop working at some point if you update the logging library or get a newer version through a dependency? Probably! And if you have used this technique are you then going to update it everywhere? 😏</p><p>Oh, wait! What about exceptions? Ah, you also rely on structured logging? so you should probably assert that the template and parameters are what you expect (which could be quite important to avoid regressions if you are relying on those parameters on a dashboard).</p><p>Ok, so let's include a bit more in our fake implementation for testing!
Once we realize that the state is a list of <code>KeyValuePair&lt;string, object&gt;</code>, it's pretty trivial.</p><div><pre><code data-lang="csharp"><span>private</span> <span>class</span> <span>FakeLogger</span> <span>:</span> <span>ILogger</span><span>&lt;</span><span>Sample</span><span>&gt;</span>
<span>{</span>
    <span>public</span> <span>List</span><span>&lt;</span><span>(</span><span>LogLevel</span> <span>Level</span><span>,</span> <span>string</span> <span>Message</span><span>,</span> <span>IReadOnlyList</span><span>&lt;</span><span>KeyValuePair</span><span>&lt;</span><span>string</span><span>,</span> <span>object</span><span>&gt;</span><span>&gt;</span> <span>Properties</span><span>,</span> <span>Exception</span> <span>Exception</span><span>)</span><span>&gt;</span> <span>Entries</span> <span>{</span> <span>get</span><span>;</span> <span>}</span> <span>=</span>
        <span>new</span> <span>List</span><span>&lt;</span><span>(</span><span>LogLevel</span><span>,</span> <span>string</span><span>,</span> <span>IReadOnlyList</span><span>&lt;</span><span>KeyValuePair</span><span>&lt;</span><span>string</span><span>,</span> <span>object</span><span>&gt;</span><span>&gt;</span><span>,</span> <span>Exception</span><span>)</span><span>&gt;</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>IDisposable</span> <span>BeginScope</span><span>&lt;</span><span>TState</span><span>&gt;</span><span>(</span><span>TState</span> <span>state</span><span>)</span> <span>=</span><span>&gt;</span> <span>throw</span> <span>new</span> <span>NotImplementedException</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>bool</span> <span>IsEnabled</span><span>(</span><span>LogLevel</span> <span>logLevel</span><span>)</span> <span>=</span><span>&gt;</span> <span>throw</span> <span>new</span> <span>NotImplementedException</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>void</span> <span>Log</span><span>&lt;</span><span>TState</span><span>&gt;</span><span>(</span><span>LogLevel</span> <span>logLevel</span><span>,</span> <span>EventId</span> <span>eventId</span><span>,</span> <span>TState</span> <span>state</span><span>,</span> <span>Exception</span> <span>exception</span><span>,</span> <span>Func</span><span>&lt;</span><span>TState</span><span>,</span> <span>Exception</span><span>,</span> <span>string</span><span>&gt;</span> <span>formatter</span><span>)</span>
    <span>{</span>
        <span>// These are relying on an internal implementation detail, they will break!
</span><span></span>        <span>var</span> <span>message</span> <span>=</span> <span>state</span><span>.</span><span>ToString</span><span>(</span><span>)</span><span>;</span>
        <span>var</span> <span>properties</span> <span>=</span> <span>state</span> <span>as</span> <span>IReadOnlyList</span><span>&lt;</span><span>KeyValuePair</span><span>&lt;</span><span>string</span><span>,</span> <span>object</span><span>&gt;</span><span>&gt;</span><span>;</span>

        <span>Entries</span><span>.</span><span>Add</span><span>(</span><span>(</span><span>logLevel</span><span>,</span> <span>message</span><span>,</span> <span>properties</span><span>,</span> <span>exception</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>Assertions are not hard either…. if we don't need anything too fancy:</p><div><pre><code data-lang="csharp"><span>// Assert
</span><span></span><span>var</span> <span>log</span> <span>=</span> <span>Assert</span><span>.</span><span>Single</span><span>(</span><span>logger</span><span>.</span><span>Entries</span><span>)</span><span>;</span>

<span>// Assert the message rendered by a default formatter
</span><span></span><span>Assert</span><span>.</span><span>Equal</span><span>(</span><span>"The answer is 42"</span><span>,</span> <span>log</span><span>.</span><span>Message</span><span>)</span><span>;</span>

<span>// Assert structured logs
</span><span></span><span>var</span> <span>element</span> <span>=</span> <span>Assert</span><span>.</span><span>Single</span><span>(</span><span>log</span><span>.</span><span>Properties</span><span>,</span> <span>x</span> <span>=</span><span>&gt;</span> <span>x</span><span>.</span><span>Key</span> <span>=</span><span>=</span> <span>"number"</span><span>)</span><span>;</span>
<span>Assert</span><span>.</span><span>Equal</span><span>(</span><span>4</span><span>2</span><span>,</span> <span>element</span><span>.</span><span>Value</span><span>)</span><span>;</span>
<span>// or
</span><span></span><span>Assert</span><span>.</span><span>Contains</span><span>(</span><span>new</span> <span>KeyValuePair</span><span>&lt;</span><span>string</span><span>,</span> <span>object</span><span>&gt;</span><span>(</span><span>"number"</span><span>,</span> <span>4</span><span>2</span><span>)</span><span>,</span> <span>log</span><span>.</span><span>Properties</span><span>)</span><span>;</span>

<span>// Assert Exception
</span><span></span><span>var</span> <span>exception</span> <span>=</span> <span>Assert</span><span>.</span><span>IsType</span><span>&lt;</span><span>ArgumentNullException</span><span>&gt;</span><span>(</span><span>log</span><span>.</span><span>Exception</span><span>)</span><span>;</span>
<span>Assert</span><span>.</span><span>Equal</span><span>(</span><span>"foo"</span><span>,</span> <span>exception</span><span>.</span><span>ParamName</span><span>)</span><span>;</span>
</code></pre></div><p>We can also get the template that was used in the log entry, if we know that is stored in the state with key <code>{OriginalFormat}</code> (yes, with the curly braces):</p><div><pre><code data-lang="csharp"><span>var</span> <span>template</span> <span>=</span> <span>Assert</span><span>.</span><span>Single</span><span>(</span><span>log</span><span>.</span><span>Properties</span><span>,</span> <span>x</span> <span>=</span><span>&gt;</span> <span>x</span><span>.</span><span>Key</span> <span>=</span><span>=</span> <span>"{OriginalFormat}"</span><span>)</span><span>;</span>
<span>Assert</span><span>.</span><span>Equal</span><span>(</span><span>"The answer is {number}"</span><span>,</span> <span>template</span><span>.</span><span>Value</span><span>)</span><span>;</span>
</code></pre></div><p>Ah but you also use scopes, so I need to keep track of the scopes. Actually, it than requiring to keep track of which scopes were present when the log entry was added! 🤯</p><p><strong>As you can see, the complexity will quickly skyrocket!</strong> 🚀 And we haven't considered integration tests yet!</p><p>All in all, using a library that takes care of the different aspect of testing the logging and works for both libraries and applications doesn't sound like a bad idea.</p><p>Add the <a href="https://www.nuget.org/packages/MELT/">MELT</a> NuGet package to your test projects, or check out <a href="https://github.com/alefranz/MELT">MELT</a> on GitHub. Asserts your logs and file an issue or get in touch (I'm <a href="https://twitter.com/AleFranz">@AleFranz</a> on Twitter) if you have any idea for improvements!</p><p><strong>Happy logging! And happy testing!</strong></p><ul></ul><div><div><div><p><a href="https://alessio.franceschelli.me/about/"><img src="https://d33wubrfki0l68.cloudfront.net/53c2807cafa056507c247cc654f1bb200df2ab7a/03634/alefranz.jpg" alt="Alessio Franceschelli aka AleFranz"></a></p><div><p>My name is Alessio Franceschelli. I'm a software developer based in London, UK. I work as Principal Engineer for Trainline but these blog's opinions are my own.</p></div></div></div></div></section></article></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>