<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Next Release of PowerShell - PowerShell 7 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>The Next Release of PowerShell - PowerShell 7</h1><div><div class="markdown-body"><p>Recently, the PowerShell Team shipped the Generally Available (GA) release of <a href="https://devblogs.microsoft.com/powershell/general-availability-of-powershell-core-6-2/" rel="nofollow">PowerShell Core 6.2</a>. Since that release, we’ve already begun work on the next iteration!</p><p>We’re calling the next release <code>PowerShell 7</code>, the reasons for which will be explained in this blog post.</p><h2><a id="user-content-why-7-and-not-63" class="anchor" href="#why-7-and-not-63" aria-hidden="true"></a>Why 7 and not 6.3?</h2><p>PowerShell Core usage has grown significantly in the last two years. In particular, the bulk of our growth has come from Linux usage, an encouraging statistic given our investment in making PowerShell viable cross-platform.&nbsp; This chart represents the number of times pwsh.exe (or just pwsh on Linux/macOS) was started (unless telemetry was disabled).</p><p><a href="https://user-images.githubusercontent.com/1255187/55589621-87f52400-56e5-11e9-8672-34fa72fcf621.png" target="_blank" rel="nofollow noopener"></a><a href="https://user-images.githubusercontent.com/1255187/55589621-87f52400-56e5-11e9-8672-34fa72fcf621.png"><img src="https://user-images.githubusercontent.com/1255187/55589621-87f52400-56e5-11e9-8672-34fa72fcf621.png" alt="image"></a></p><p>However, we also can clearly see that our Windows usage has not been growing as significantly, surprising given that PowerShell was popularized on the Windows platform. We believe that this could be occurring because existing Windows PowerShell users have existing automation that is incompatible with PowerShell Core because of unsupported modules, assemblies, and APIs. These folks are unable to take advantage of PowerShell Core’s new features, increased performance, and bug fixes. To address this, we are renewing our efforts towards a full replacement of Windows PowerShell 5.1 with our next release.</p><p>This means that Windows PowerShell and PowerShell Core users will be able to use the same version of PowerShell to automate across Windows, Linux, and macOS and on Windows, and PowerShell 7 users will have a very high level of compatibility with Windows PowerShell modules they rely on today.</p><p>We’re also going to take the opportunity to simplify our references to PowerShell in documentation and product pages, dropping the “Core” in “PowerShell 7”. The <code>PSEdition</code> will still reflect <code>Core</code>, but this will only be a technical distinction in APIs and documentation where appropriate.</p><p>Note that the major version does not imply that we will be making significant breaking changes. While we took the opportunity to make some breaking changes in 6.0, many of those were compromises to ensure our compatibility on non-Windows platforms. Prior to that, Windows PowerShell historically updated its major version based on new versions of Windows rather than <a href="https://semver.org/" rel="nofollow">Semantic Versioning</a></p><h2><a id="user-content-net-core-30" class="anchor" href="#net-core-30" aria-hidden="true"></a>.NET Core 3.0</h2><p><a href="https://devblogs.microsoft.com/powershell/announcing-powershell-core-6-1/" rel="nofollow">PowerShell Core 6.1</a> brought compatibility with many built-in Windows PowerShell modules, and our estimation is that PowerShell 7 can attain compatibility with 90+% of the inbox Windows PowerShell modules by leveraging changes in <a href="https://dotnet.microsoft.com/download/dotnet-core/3.0" rel="nofollow">.NET Core 3.0</a>&nbsp;that bring back many APIs required by modules built on .NET Framework so that&nbsp;they work with .NET Core runtime. For example, we expect <code>Out-GridView</code> to come back (for Windows only, though)!</p><p>A significant effort for PowerShell 7 is porting the PowerShell Core 6&nbsp;code base to .NET Core 3.0 and also working with Windows partner teams to validate their modules against PowerShell 7.</p><h2><a id="user-content-support-lifecycle-changes" class="anchor" href="#support-lifecycle-changes" aria-hidden="true"></a>Support Lifecycle Changes</h2><p>Currently, <a href="https://aka.ms/pslifecycle" rel="nofollow">PowerShell Core is under the Microsoft Modern Lifecycle Policy</a>. This means that PowerShell Core 6 is fix-forward: we produce servicing releases for security fixes and critical bug fixes,<br>and you must install the latest stable version within 6 months of a new minor version release.</p><p>In PowerShell 7, we will align more closely with the&nbsp;<a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-core" rel="nofollow">.NET Core support lifecycle</a>,&nbsp;enabling PowerShell 7 to have both LTS (Long Term Servicing) and non-LTS releases.</p><p>We will still have monthly Preview releases to get feedback early.</p><h2><a id="user-content-when-do-i-get-powershell-7" class="anchor" href="#when-do-i-get-powershell-7" aria-hidden="true"></a>When do I get PowerShell 7?</h2><p>The first Preview release of PowerShell 7 will likely be in May. Be aware, however, that this depends on completing integration and validation of PowerShell with .NET Core 3.0.</p><p>Since PowerShell 7 is aligned with the .NET Core timeline, we expect the generally available (GA) release to be some time after the GA of .NET Core 3.0.</p><h2><a id="user-content-what-about-shipping-in-windows" class="anchor" href="#what-about-shipping-in-windows" aria-hidden="true"></a>What about shipping in Windows?</h2><p>We are planning on eventually shipping PowerShell 7 in Windows as a side-by-side feature with Windows PowerShell 5.1, but we still need to work out some of the details on how you will manage this inbox version of PowerShell 7.</p><p>And since the .NET Core timeline doesn’t align with the Windows timeline, we can’t say right now when it will show up in a future version of Windows 10 or Windows Server.</p><h2><a id="user-content-what-other-features-will-be-in-powershell-7" class="anchor" href="#what-other-features-will-be-in-powershell-7" aria-hidden="true"></a>What other features will be in PowerShell 7?</h2><p>We haven’t closed on our feature planning yet, but expect another blog post relatively soon with a roadmap of our current feature level plans for PowerShell 7.</p><p>Steve Lee<br><a href="https://twitter.com/Steve_MSFT">https://twitter.com/Steve_MSFT</a><br>Principal Engineering Manager<br>PowerShell Team</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>