<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Runtime analysis and leak detection for Autofac -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Runtime analysis and leak detection for Autofac</h1><div><div class="post-content" itemprop="articleBody"><p>IoC containers like <a href="https://autofac.org">Autofac</a> are magic when they quietly do their job; but, when they don’t behave as intended, they can be maddeningly opaque.</p><p><em>Autofac.Analysis</em> is the latest incarnation of a project I’ve had in the works for a long, long time. Its primary purpose is to <em>reliably</em> detect Autofac usage problems <em>at runtime</em>: notably, it can spot the dreaded <code class="language-plaintext highlighter-rouge">IDisposable</code> component “memory leak” bug that still trips up people who are new to how Autofac works.</p><p>Along with that, <em>Autofac.Analysis</em> offers a glimpse into the hidden life of the IoC container running at the core of your app. What’s that thing actually doing in there? Find out:</p><h3 id="1-install-the-autofacanalysis-module">1. Install the <em>Autofac.Analysis</em> module</h3><p>On the application side, you need to hook <em>Autofac.Analysis</em> into your <code class="language-plaintext highlighter-rouge">ContainerBuilder</code>, and give it somewhere to send events. The analyzer doesn’t have a UI, but instead writes events through a <a href="https://serilog.net">Serilog</a> logger.</p><p>We’ll start by installing a package or two:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet add package Autofac.Analysis
dotnet add package Serilog.Sinks.Seq
</code></pre></div></div><p>Even if you’re using Serilog in the rest of your application, you might want to set up a separate logging pipeline for this, because a little bit of nonstandard configuration is needed:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// using Serilog;
var logger = new LoggerConfiguration()
    .Destructure.ToMaximumDepth(100)
    .WriteTo.Seq("http://localhost:5341")
    .CreateLogger();
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">Destructure.ToMaximumDepth(100)</code> lets us log some deeper object graphs than might normally be sensible :-)</p><p>Slicing and dicing the events is made easier by a structure log server like <a href="https://datalust.co/seq">Seq</a> - you can just as easily log them to a JSON file or some other log server if you like.</p><p>If you don’t have Seq running locally, it’s:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --rm -it -e ACCEPT_EULA=Y -p 5341:80 datalust/seq
</code></pre></div></div><p>… and open a web browser on http://localhost:5341.</p><p>Next, register the module with the <code class="language-plaintext highlighter-rouge">ContainerBuilder</code> you use to configure Autofac:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// using Autofac;
// using Autofac.Analysis;
var builder = new ContainerBuilder();

#if DEBUG
builder.RegisterModule(new AnalysisModule(logger));
#endif

// Other registrations...
</code></pre></div></div><p>I’ve added some <code class="language-plaintext highlighter-rouge">#if DEBUG</code> conditional compilation directives just to remind you that you probably <em>don’t</em> want to run this day-to-day in production: it’s very likely it will have a detrimental effect on application performance.</p><h3 id="2-run-your-application">2. Run your application!</h3><p>Here’s the fun part! Start up your app, click around, test things out. The goal is to exercise as much code as you can, since this will trigger <code class="language-plaintext highlighter-rouge">Resolve()</code> calls and feed events to the analyzer.</p><p><a href="https://github.com/nblumhardt/autofac-analysis/tree/dev/sample/MvcApplication">The sample app</a> is just an ASP.NET Core MVC <em>File &gt; New Project</em> web app with some dummy components thrown in. <code class="language-plaintext highlighter-rouge">HomeController.Index()</code> secretly sneaks a hundred tubes of toothpaste into the visitor’s shopping cart:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="k">class</span><span class="nc">HomeController</span><span class="p">:</span><span class="n">Controller</span><span class="p">{</span><span class="k">readonly</span><span class="n">ShoppingCartService</span><span class="n">_shoppingCartService</span><span class="p">;</span><span class="k">public</span><span class="nf">HomeController</span><span class="p">(</span><span class="n">ShoppingCartService</span><span class="n">shoppingCartService</span><span class="p">)</span><span class="p">{</span><span class="n">_shoppingCartService</span><span class="p">=</span><span class="n">shoppingCartService</span><span class="p">;</span><span class="p">}</span><span class="k">public</span><span class="n">IActionResult</span><span class="nf">Index</span><span class="p">()</span><span class="p">{</span><span class="n">_shoppingCartService</span><span class="p">.</span><span class="nf">AddItem</span><span class="p">(</span><span class="s">"toothpaste"</span><span class="p">,</span><span class="m">100</span><span class="p">);</span><span class="k">return</span><span class="nf">View</span><span class="p">();</span><span class="p">}</span></code></pre></div></div><p>It otherwise looks like the default ASP.NET Core app template.</p><p><img src="https://nblumhardt.com/img/2019-03-autofac-analysis/ExampleApp.png" alt="Example Application" class="nshadow"></p><h3 id="3-dig-through-the-analysis">3. Dig through the analysis</h3><p>Here’s the … slightly less-fun part. If you refresh the Seq UI in your browser you should now see a pile of events:</p><p><img src="https://nblumhardt.com/img/2019-03-autofac-analysis/AnalysisView.png" alt="Analysis Log" class="nshadow"></p><p>If you want to find information about a specific component, you can search for it by type name, but otherwise, select the <em>Warnings</em> and <em>Errors</em> signals in the right-hand bar to see whether the analyzer has picked up anything interesting.</p><p><img src="https://nblumhardt.com/img/2019-03-autofac-analysis/WarningEvents.png" alt="Warning Events" class="nshadow"></p><p>The analysis is fairly loose, and there are sure to be some false-positives. The most important event to look out for is <code class="language-plaintext highlighter-rouge">A004</code>, which I’ve expanded in the screenshot. This indicates a potential leak. If you find one, you can switch back to your application and run through the same sequence of actions, again. Does another, similar message, appear in the analysis log? If so - you’re probably onto something.</p><p>From the warning event, clicking the green checkmark next to the <code class="language-plaintext highlighter-rouge">ComponentId</code> property and selecting <em>Find</em> will give you more information about the component, and <code class="language-plaintext highlighter-rouge">ResolveOperationId</code> will give you more information about the graph being resolved, including where the <code class="language-plaintext highlighter-rouge">Resolve()</code> call originated and what components contributed to it. <strong>Don’t forget</strong> to de-select the <em>Warnings</em> and <em>Errors</em> signals, so that you can see information-level events.</p><p><img src="https://nblumhardt.com/img/2019-03-autofac-analysis/ResolveOperation.png" alt="Resolve Operation" class="nshadow"></p><p>Here I’ve filtered on the <code class="language-plaintext highlighter-rouge">ResolveOperationId</code> to see where in the codebase it started. Here’s the <code class="language-plaintext highlighter-rouge">ShoppingCartService.AddItem()</code> method:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="k">class</span><span class="nc">ShoppingCartService</span><span class="p">{</span><span class="k">readonly</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">DBContext</span><span class="p">&gt;</span><span class="n">_createDBContext</span><span class="p">;</span><span class="k">public</span><span class="nf">ShoppingCartService</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">DBContext</span><span class="p">&gt;</span><span class="n">createDBContext</span><span class="p">)</span><span class="p">{</span><span class="n">_createDBContext</span><span class="p">=</span><span class="n">createDBContext</span><span class="p">;</span><span class="p">}</span><span class="k">public</span><span class="k">void</span><span class="nf">AddItem</span><span class="p">(</span><span class="kt">string</span><span class="n">itemId</span><span class="p">,</span><span class="kt">int</span><span class="n">quantity</span><span class="p">)</span><span class="p">{</span><span class="n">Log</span><span class="p">.</span><span class="n">ForContext</span><span class="p">&lt;</span><span class="n">ShoppingCartService</span><span class="p">&gt;().</span><span class="nf">Information</span><span class="p">(</span><span class="s">"Adding {ItemId} x {Quantity} to cart"</span><span class="p">,</span><span class="n">itemId</span><span class="p">,</span><span class="n">quantity</span><span class="p">);</span><span class="c1">// Oops, this will leak, we really needed Func&lt;Owned&lt;DBContext&gt;&gt; here.</span><span class="k">using</span><span class="p">(</span><span class="kt">var</span><span class="n">db</span><span class="p">=</span><span class="nf">_createDBContext</span><span class="p">())</span><span class="p">{</span><span class="c1">// Find and update the current shopping cart :-)</span><span class="p">}</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>Classic mistake - using <code class="language-plaintext highlighter-rouge">Func&lt;T&gt;</code> where <code class="language-plaintext highlighter-rouge">Func&lt;Owned&lt;T&gt;&gt;</code> is required.</p><h3 id="4-getting-help">4. Getting help</h3><p>It might be a few years old, now, but if you have problems with memory usage in Autofac, <a href="https://nblumhardt.com/2011/01/an-autofac-lifetime-primer/">the primer</a> is the place to start.</p><p><em>Autofac.Analysis</em> is a bit of an experiment. While issue reports and PRs for the analysis engine are welcome, I can’t help with debugging any Autofac usage issues that it identifies, sorry. Don’t despair, though! You should be able to collect enough information from the analysis log to write a really detailed Stack Overflow post, and <a href="https://stackoverflow.com/questions/tagged/autofac">tagging it with <code class="language-plaintext highlighter-rouge">autofac</code></a> is usually sufficient to get the right eyes on it.</p><p>Hope this helps!</p><p><strong>Aside… why is the code so badly overengineered?</strong> If you poke your head into the <a href="https://github.com/nblumhardt/autofac-analysis"><code class="language-plaintext highlighter-rouge">nblumhardt/autofac-analysis</code></a> GitHub repository, you’ll find it’s a complex beast. The analyzer was originally <a href="https://github.com/nblumhardt/whitebox">a fully-out-of-process application</a>, complete with a WPF user interface, that connected to the profiled app via named pipes (I’d hoped to package it as a Visual Studio plug-in at some point). The effort involved in building and maintaining it ended up too great, so the code was cut down to what we have today. There’s still a full “client side” object model that replicates what’s going on in the container, and a “transport” that connects the model asynchronously to container events. It’s true that I’d never go this far, starting from scratch with more modest goals, but there are some nice properties of this architecture, including resilience to accidental deadlocks, that makes it worth keeping around as a foundation for more complex analysis someday.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>