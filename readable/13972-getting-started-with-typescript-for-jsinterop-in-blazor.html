<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Getting Started with TypeScript for JSInterop in Blazor -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Getting Started with TypeScript for JSInterop in Blazor</h1><div><div class="post-content"><p>One of the most exciting prospects of Blazor is the potential to remove the need for JavaScript. However, we are not there yet. In an <a href="https://chrissainty.com/using-javascript-interop-in-razor-components-and-blazor/">earlier post</a>, I pointed out that WebAssembly isn't currently able to interact with the DOM or call browser APIs. I'm not even sure how server-side Blazor is going to move away from JavaScript or if it can.</p><p>So if we're going to have to write JavaScript, then it would be great to get as close to our development experience with C# as we can. This is where we can leverage <a href="https://www.typescriptlang.org/">TypeScript</a>.</p><p>TypeScript is a first class citizen in Visual Studio, one of the benefits of this is that any TypeScript you write in your Blazor project will be transpiled to JS for you automatically. </p><p>But what about TypeScript in a Razor Class Library project? Unfortunately, this doesn't get compiled automatically. It turns out though that it's not too difficult to get this working.</p><h2 id="what-is-typescript">What is TypeScript</h2><p>Just before we continue, for those who aren't familiar, TypeScript is a typed superset of JavaScript, which compiles to plain JavaScript. It gives us the ability to use static typing, classes and interfaces. But the biggest benefit is that because it's compiled, we can get compile time checks on our code as apposed to writing plain JS where errors may only show up at runtime.</p><h2 id="the-example">The Example</h2><p>For this post we're going to use the standard Razor Class Library template. You can create this via the dotnet CLI using the following command.</p><pre><code class="language-bash">dotnet new razorclasslib
</code></pre><p>If you don't have this template available you can install it using this command.</p><pre><code class="language-bash">dotnet new -i Microsoft.AspNetCore.Blazor.Templates
</code></pre><p><strong>NOTE</strong>: You may have to adjust the version at the end, depending on when you read this.</p><p>Inside this project there is a content folder with a file called <code>exampleJsInterop.js</code>, with the following contents.</p><pre><code class="language-javascript">// This file is to show how a library package may provide JavaScript interop features
// wrapped in a .NET API

window.exampleJsFunctions = {
  showPrompt: function (message) {
    return prompt(message, 'Type anything here');
  }
};
</code></pre><p>We're going to convert this file to TypeScript and then make a few changes to the project to make it compile when the project builds.</p><h2 id="converting-to-typescript">Converting to TypeScript</h2><p>As I mentioned earlier, TypeScript is a superset of JavaScript what this means is that any valid JavaScript is valid TypeScript. So we could just give the <code>exampleJsInterop</code> file a <code>.ts</code> extension and we would be done. But that kind of defeats the point of using TypeScript. </p><p>So we're going to rewrite the code to take advantage of some of the features TypeScript gives us.</p><pre><code class="language-javascript">// This file is to show how a library package may provide JavaScript interop features
// wrapped in a .NET API

namespace JSInteropWithTypeScript {

    class ExampleJsFunctions {
        public showPrompt(message: string): string {
            return prompt(message, 'Type anything here');
        }
    }

    export function Load(): void {
        window['exampleJsFunctions'] = new ExampleJsFunctions();
    }
}

JSInteropWithTypeScript.Load();
</code></pre><p>This is how things look once converted to TypeScript. Hopefully, this should look a lot more familiar to C# developers. We now have a namespace, a class and types. I'll admit that types don't really give us much as this code is going to be called by C#. But if the <code>showPrompt</code> method was going to be called by another TypeScript method we would now benefit from compile time checks.</p><h2 id="configuring-the-build">Configuring the build</h2><p>We now have our TypeScript file so how can we get it to build with our project. The first thing we need to do is to install the <code><a href="https://www.nuget.org/packages/Microsoft.TypeScript.MSBuild">Microsoft.TypeScript.MSBuild</a></code> package from NuGet. You can do this either via the NuGet package manger.</p><pre><code class="language-powershell">Install-Package Microsoft.TypeScript.MSBuild
</code></pre><p>Or via the dotnet CLI.</p><pre><code class="language-bash">dotnet add package Microsoft.TypeScript.MSBuild
</code></pre><p>Once installed, we need to edit the <code>.csproj</code> file. We're going to add in a <code>TypeScriptToolsVersion</code> tag in the <code>PropertyGroup</code> node.</p><pre><code class="language-xml">  &lt;PropertyGroup&gt;
     &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
    &lt;RazorLangVersion&gt;3.0&lt;/RazorLangVersion&gt;
    &lt;RootNamespace&gt;BlazorTypeScriptExample&lt;/RootNamespace&gt;
    &lt;TypeScriptToolsVersion&gt;3.2&lt;/TypeScriptToolsVersion&gt;
  &lt;/PropertyGroup&gt;
</code></pre><p>This tells MSBuild which version of TypeScript to use when compiling the project. If this is not set then the build will use the latest version installed on the system.</p><p>We need to tell MSBuild what files it should build. In order to do this we're going to use the <code>TypeScriptCompile</code> item type. </p><pre><code class="language-xml">&lt;ItemGroup&gt;
  &lt;TypeScriptCompile Include="content/exampleJsInterop.ts" /&gt;
&lt;/ItemGroup&gt;
</code></pre><h2 id="checking-the-build">Checking the build</h2><p>That should be all we need to be able to compile our TypeScript. We can now do a build and if everything has gone to plan then you should see a <code>exampleJsInterop.js</code> file and a <code>exampleJsInterop.js.map</code> file. </p><p>The <code>.map</code> file has been generated for us by the TypeScript compiler. Map files provide a mapping between the original TypeScript source file and the compiled JavaScript. This means we can debug the TypeScript version of our code in the browser instead of the compiled JavaScript version.</p><h2 id="summary">Summary</h2><p>In this post, we've taken a first look at how we can use TypeScript with our Blazor libraries. As well as how we can configure our projects to compile our TypeScript files during a build. </p><p>There is a lot more that can be done with TypeScript in terms of configuration but I wanted to provide a quick start guide which should work for most interop cases in Blazor. Have you written much interop code so far? Let me know in the comments.</p><hr><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>