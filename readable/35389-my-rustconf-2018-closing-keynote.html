<!DOCTYPE html>
<html lang="en">
<head>
    <title>
My RustConf 2018 Closing Keynote -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>My RustConf 2018 Closing Keynote</h1><div><div class="post-content" itemprop="articleBody"><p>I promised two things when I did the closing keynote at RustConf 2018:</p><ol><li><p>I will put the slides for the talk online</p></li><li><p>I will post the long-form version of the talk on a my blog</p><p>2.a. I will actually make a blog for this purpose</p></li></ol><p>…and I have taken my damn sweet time doing so.  Finally, I have done what I
promised I would do!</p><p>If you haven’t seen it and would like to, you can see the live talk that I did
<a href="https://www.youtube.com/watch?v=aKLntZcp27M">here</a>.</p><p>The slides for the talk (with a small errata) are now hosted
<a href="/rustconf_2018_slides/index.html">here</a>.</p><p>So, I said in my talk that I would post a potentially more interesting long-form
version of the talk that includes things that I couldn’t fit into the 30-ish
minute time slot.  What I’ve included below is my original long-form version of
this talk, but my original intention was not to post this as-is.  Originally I
wanted to clean this up a bit more and make this into something that wasn’t so
much a giant wall of text, but after I started doing this I realized that I was
just rewriting it entirely, and at that rate I would never get around to
releasing it, which I <em>promised</em> I would do in a timely manner.</p><p>I’m not super happy with this, and in retrospect I think many of the things I
cut for the 30-ish minute talk were probably wise to cut.  I think the parts
about console development are wildly speculative and not that helpful, and the
part at the end about language boundaries being particularly difficult is,
while true, kind of beside the point.  However, people seemed very interested
and are (very rightly) reminding me that I haven’t posted this yet, so rather
than delay any further I’m going to give you the very lightly edited text
version of the talk that I made.  Keep in mind this was before I realized I
would NEVER fit this into 30 minutes :).  This is written in a very informal,
conversational style because this was intended as the source material for my
talk.</p><p>Without further ado…</p><hr><p>This is a very rough outline of the things I’d like to talk about in my RustConf
2018 keynote.</p><p>This talk assumes that you know a bit of C++ in addition to a bit of Rust, and
there are quite a lot of C++ code samples, but I hope they’re obvious enough not
to be distracting to the people who might not be used to C++.</p><h2 id="basic-thesis-of-the-talk">Basic thesis of the talk:</h2><p>Rust, by design, makes certain programming patterns more painful than others.
This is a GOOD thing!  It turns out that, for game development, the patterns
that end up being the easiest to deal with in Rust closely mirror the patterns
that are easiest for game development in <em>any</em> language.</p><p>I unfortunately had to learn this the HARD way!</p><p>Rust highly rewards data-oriented design with simple, understandable ownership
semantics, and this is great news because this is a really good fit for game
development.  I suspect this is also true generally, not just for game
development! (but what do I know?)</p><h2 id="why-should-you-listen-to-me-who-am-i">Why should you listen to me, who am I?</h2><p>I was the lead programmer for Starbound, I’ve I was one of the first members of
Chucklefish back when we were all working over IRC.  I was the technical lead at
Chucklefish when we first decided that we should probably have somebody be
called the “technical lead”.  I still work with Chucklefish peripherally, but
I’ve since moved back to the US and I work on things more independently now.</p><p>But, honestly not sure you SHOULD listen to me!  I’ve helped release ONE (1)
whole commercial game, and some of this talk is a cautionary tale about what NOT
to do based on the ONE (1) commercial game I’ve helped make.</p><p>I definitely feel like you shouldn’t make any… real <em>grown up</em> business
decisions based on my advice.  I can’t say for sure that Rust is a good fit for
you, or whether you should or shouldn’t make your game in Rust, certainly there
are probably larger concerns depending on, if you’re an indie, what your
personal skill level and tolerances and preferences are, and if you’re a company
what tooling you need and what engines, middleware, etc you already use.</p><p>What I can say is that personally I will be using Rust for game development (and
other things!) for the foreseeable future, and if you’d like to hear why, or if
you’ve already decided that you’d like to use Rust and would like to know what
you’re in for, then this talk may be useful.</p><p>This talk is going to be more… vague than I’d prefer.  I’m generally more
comfortable giving people specific very technical advice where I can prove my
point almost from first principles, but things like architecture advice or
general advice are probably never going to be so clear cut.  I definitely think
it’s still <em>useful</em>, which is why I’m doing it (and people seem interested), but
remember: this is all just like, my opinion, man.</p><h2 id="how-do-you-even-make-a-game-in-rust">How do you EVEN make a game in Rust?</h2><p>I’ve gotten a lot of questions over the past year or so that more or less ask:</p><blockquote><p>How do you make a game from scratch in Rust?  No, seriously… HOW.  I mean, I
can see how you can do it <em>in theory</em>, but for some reason when I try to apply
patterns that I’m used to from other languages I just hit lots of problems?
I’ve heard that this is called “fighting the borrow checker”, but… that
doesn’t really seem to <em>help</em> me much.  What am I doing wrong?</p></blockquote><p>Or, maybe it’s something like:</p><blockquote><p>I can see how rust is great if you like very strict control, I can see it
being used for small utilities or things where security is paramount, but it
seems very restrictive!  I don’t really see how you could make something large
like a game without running into these limitations.  How do you structure
something like a game without needing Rc&lt;RefCell<t>&gt; and Arc&lt;Mutex<t>&gt;
everywhere?</t></t></p></blockquote><p>These (straw man) questions are of course about games, but they also mirror
sentiments I’ve seen about Rust in general.  In case it’s not obvious, I
disagree with this sentiment (I am at RustConf after all), and I think the best
way for me to talk about WHY I disagree with it is to talk about what I know,
so I’m going to come at this from the perspective of games.</p><p>The talk could just be me coming up to a podium and saying “Jeez, it’s not that
difficult!  Data oriented design!  If you’re making a game, use an ECS! …
Thank you.” and then walking off stage, and from a certain perspective I do
feel that it <em>can</em> be that simple, but I think there’s a more important
fundamental point here and that’s what this talk is about.  The very very short
answer to this question is: if you forget OO design and instead just
concentrate on the data representation of your game state (or whatever you’re
making), and you try hard not to make anything more complicated than it really
has to be, things can actually be pretty simple!  This talk will be working up
slowly to a simple ECS implementation in Rust and trying to give justifications
for each step, but not <em>all</em> the steps are necessary.  I don’t even think using
some specific design pattern like an ECS is essential, I think the more
important larger point is to let go of some habits that, at least <em>I</em> had that
make things more difficult than they need to be, and in Rust more so.</p><p>For some people the things that I say in this talk might be <em>blindingly
obvious</em>.  If this is all obvious to you, that’s wonderful, but this hasn’t
always been obvious to me.  In fact, part of the reason that I’m such a fan of
Rust is that I didn’t actually learn these lessons from trying to build a game
in Rust, I mostly learned them before I ever even tried Rust for the first time,
from mistakes that I made early in Starbound.  I need somebody to pick on to
demonstrate what NOT to do, so it’s really convenient that I have such a great
example in my past self.</p><p>I’m definitely going to repeat some advice that other people have given.  In
fact, some of these things are definitely widely known and have almost become
kind of truisms: Inheritance is bad, OO is mostly bad, ECS design is good, etc.
Hopefully to the extent that those <em>are</em> true I provide more evidence for them
and describe why these are especially important in the presence of the borrow
checker, but hopefully I can also add some nuance to these and this will be
helpful to other people who want to use Rust for game development.</p><h2 id="how-do-you-even-make-a-game-at-all">How do you EVEN make a game <em>at all</em></h2><p>Certainly a lot of these questions only appear when you’re trying to come up
with a game architecture from scratch, and certainly many people aren’t going to
actually do this.  In fact, generally the advice for indie developers is
that you should NEVER make your own engine, and if you use something like Unity
or Unreal to make your game, a lot of these decisions are going to be made for
you.</p><p>I definitely did NOT follow this advice.  In fact, I think Starbound ran
directly against every piece of advice you commonly give a new indie dev:</p><ul><li><p>Don’t make your own engine
(Starbound is written basically in bare C++ on top of SDL / libogg /
libvorbis / libfreetype etc)</p></li><li><p>Always make a prototype and plan to throw it away
(The code that I used to demo two weeks in is the same lineage as the 1.0
release)</p></li><li><p>Seriously, don’t make your own engine, just use Unity / Unreal / Godot etc
(We didn’t even use boost!  In fact, at some point we added our own versions
of c++17 classes like std::optional and std::variant inside starbound,
because at the time it was easier than starting to depend on boost.  We also
came up with our own system for doing 2d texture atlasing because we
couldn’t find a good way to do offline texture atlasing with so many small
textures that can’t be easily grouped)</p></li><li><p>Your first game should be simple, you should make something simple that you
can release in a short time.
(In starbound, you can have an item that the player holds that runs its own
Lua script which affects player physics, which can cooperate with other
items and abilities that the player has that have their own scripts that
also can affect the player’s physics (at the same time), while also giving
the player scripted status effects which can add their own custom stats to a
generic stat database that most entities have, which can have stacks of
generic stat modifiers also controllable from scripts.  There is also an
entire crappy sort of DSL for drawing material blocks that visually connect
in arbitrarily complicated ways.)</p></li></ul><p>I’m definitely not trying to tell anybody to make ANYTHING like what I made as
my first commercial game, don’t follow in my footsteps, I don’t think I would
recommend that for anybody.  However, there are actually quite a lot of indie
devs who don’t use Unreal / Unity style game engines and instead of using these
“framework” style game engines instead go for more “library” style where they
simply use individual libraries for specific features, or use small
“frameworks” that provide mostly rendering, audio, and input, and create the
basic structure of the games they make themselves.  (I once had a porting house
call this “old school” development style, MUCH to my dismay)</p><ul><li>Any game made with XNA or MonoGame.  XNA / MonoGame definitely provide a lot
in a single package (rendering, sound, input) but they don’t dictate the
architecture of the game itself.  This includes Terraria and Stardew Valley,
just to name two.</li><li>Any game made by Jonathan Blow (Braid, The Witness)</li><li>Any game made by Zach Barth (Zachtronics).  He has stated that when he
starts developing a game, he starts with a bare event loop (input / update /
render) and goes from there. (NOTE: I couldn’t find a source for this, so I
hope I’m not misrepresenting him, I think he said it in an interview that I
now can’t find)</li><li>Any game made Supergiant (Bastion, Transistor, Pyre)</li><li>Chucklefish games that are made 100% in house: Starbound obviously, also
Wargroove (made with the generic C++ engine halley, but the main dev for the
engine is the main dev of Wargroove).</li><li>LOTS more that I’m not listing, many many many 2d games are made this way,
some 3d games as well.  There are <em>dozens</em> of us, I tell you.</li></ul><p>Obviously the advice I give is not as applicable if you decide to use something
like Unity or Unreal, which if you do and that’s great and you’re happy, then
I’m not trying to convince you to leave that.  Obviously if you use one of
those, Rust is probably out of the question except for very very peripheral
things, but honestly I still think eventually Rust WILL find its way into these
sorts commercial mainstream game engine products, it’s just a matter of time.
For the moment though, the most likely people to use Rust and find this talk
useful are other start-from-scratch indie types, and maybe a few AAA studios
that make a lot of their own technology in house (Ready at Dawn!, EA SEED!).
Also, I’m convinced there’s going to be a Unity or UE competitor that uses Rust
sooner or later!</p><p>So okay, suppose you’ve decided that you’re going to make a game, you’re NOT
going to be using one of the opinionated game engines that decide much of the
game structure for you like Unreal or Unity, and you’ve decided to use Rust,
what would such a thing look like?</p><h2 id="how-games-were-made-in-the-past">How games were made in the past</h2><p>So, in the past, games were mostly engineered in a “data-oriented” way out of
sheer necessity.  There is not much room for abstraction when your target
console has 128KB of RAM (SNES).  I’m going to call this the “Action Replay” era
of video game development.  If you aren’t aware, these are cheating devices kind
of like “Game Genies” or “Game Sharks” if you know those, where you can patch a
game’s RAM state every frame.  The “Game Genie” and similar devices allowed you
to patch the ROM of the game cartridge, but the “Action Replay” devices actually
let you insert hooks into say, the VBlank handler, that overwrote actual memory
values at constant locations every frame to say give you infinite lives etc.</p><p>The reason this worked is because obviously with 128KB of RAM, you’re not
exactly going to have an implementation of malloc!.  Every byte of storage is
precious, so mostly games from this era are designed with very predictable
manually managed layouts for their entire game state in memory.  In the NES /
SNES era, there was so little memory that generally the graphical representation
of your game (tiles, sprites) and the logical representation of your game are
the same, and if you kind of squint you see “entity” structures, but generally
the maximum number of “things” that the game can keep track of are so few that
there’s not enough room for any generality.  This is sometimes also known as the
“healing power of off-screen” era of game development, because the moment you go
off screen, everything about that part of the game level is often forgotten (and
enemies are magically healed).</p><p>Imagine if you were to try to write a game for the NES in Rust (probably REALLY
hard, but not impossible?  No harder than C at least, which is equally really
hard.  I’m pretty sure basically all games from the SNES era are written
directly in assembler.), you might define a single static data structure
something like this completely made up example:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">type</span><span class="n">ProjectileType</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">type</span><span class="n">EnemyType</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">type</span><span class="n">EnemyBehavior</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">type</span><span class="n">Tile</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">PlayerProjectile</span><span class="p">{</span><span class="k">pub</span><span class="n">pos</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">i16</span><span class="o">&gt;</span><span class="p">,</span><span class="k">pub</span><span class="n">proj_type</span><span class="p">:</span><span class="n">ProjectileType</span><span class="p">,</span><span class="c">// etc...</span><span class="p">}</span><span class="k">pub</span><span class="k">struct</span><span class="n">Enemy</span><span class="p">{</span><span class="k">pub</span><span class="n">pos</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">i16</span><span class="o">&gt;</span><span class="p">,</span><span class="k">pub</span><span class="n">enemy_type</span><span class="p">:</span><span class="n">EnemyType</span><span class="p">,</span><span class="k">pub</span><span class="n">behavior</span><span class="p">:</span><span class="n">EnemyBehavior</span><span class="p">,</span><span class="c">// etc...</span><span class="p">}</span><span class="k">pub</span><span class="k">struct</span><span class="n">GameState</span><span class="p">{</span><span class="k">pub</span><span class="n">player_pos</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">i16</span><span class="o">&gt;</span><span class="p">,</span><span class="k">pub</span><span class="n">player_vel</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">i8</span><span class="o">&gt;</span><span class="p">,</span><span class="k">pub</span><span class="n">player_health</span><span class="p">:</span><span class="nb">i8</span><span class="p">,</span><span class="c">// You want more than 4 projectiles on screen?  Nope, if the player fires</span><span class="c">// more, clear the oldest ones to make room, or wait until they hit</span><span class="c">// something or move off screen (like megaman).</span><span class="k">pub</span><span class="n">player_projectiles</span><span class="p">:</span><span class="p">[</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">PlayerProjectile</span><span class="o">&gt;</span><span class="p">;</span><span class="mi">4</span><span class="p">],</span><span class="c">// All level data is stored in this constant block of memory.</span><span class="k">pub</span><span class="n">level_tiles</span><span class="p">:</span><span class="p">[[</span><span class="n">Tile</span><span class="p">;</span><span class="mi">64</span><span class="p">];</span><span class="mi">64</span><span class="p">],</span><span class="c">// 8 enemies on screen, after this, you have to wait for enemies to</span><span class="c">// disappear before spawning more (kirby's adventure, this is highly abused</span><span class="c">// in tool-assisted speed runs)</span><span class="k">pub</span><span class="n">enemies</span><span class="p">:</span><span class="p">[</span><span class="n">Enemy</span><span class="p">;</span><span class="mi">8</span><span class="p">],</span><span class="c">// etc...</span><span class="p">}</span></code></pre></div></div><p>You can learn an enormous amount about how software works just by looking at its
data structures in this way, even if this is a pretend example.</p><p>One thing to note here is that since every SNES game was overwhelmingly likely
to be made in assembler, there almost certainly was no such thing as “data
hiding”, the entire state of the game is available at any point to the update
loop.</p><p>This era where every memory location was precious and objects were carefully
laid out in it actually lasted a huge amount of time, at least up to the N64.
Let’s look at another example which I’m moderately familiar with, and is still
solidly in this era, but whose design is imo much closer to modern game engines.
One of my all-time favorite games in the world: Mario 64.  Mario 64 is
interesting because it’s 3D, and except for the low-poly simple graphics, is it
really THAT much different from a modern 3D platformer?  Yet, it’s still solidly
in the “Action Replay” era of gaming, when you get into a “game world” (you can
run and jump around as Mario) you can reliably tell (more or less) where all the
level data is going to live in the N64’s expansive, luxurious 4 entire MB of
ram.  There’s a predictable block of memory for the level geometry, for lots of
various level flags, etc, but most of the dynamic content of the game is in the
form of generic “entities” (or “objects”), much like modern game engines.  In
Mario 64, the entity structures are all exactly 608 bytes long, and there is a
hard limit to 240 of them (sometimes this is a bit less, like in Bowser in the
Fire Sea, there is a limit of 232 objects).</p><p>We don’t actually know what language Mario 64 was programmed in, but it was
<em>likely</em> C, so this is probably in the era where, if you had a time machine and
a burning desire for a better systems language from the future, you could just
as easily have used Rust to make a commercial Nintendo 64 game.  Let’s take a
lot of artistic liberty and imagine what the structure of such a game would look
like translated as directly as possible to Rust:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">struct</span><span class="n">EntityAnimation</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">EntityBehavior</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">Entity</span><span class="p">{</span><span class="c">// Is this entity initialized and active or is it dead and can be</span><span class="c">// overwritten.</span><span class="k">pub</span><span class="n">initialized</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span><span class="c">// Okay, this is really interesting.  In Mario 64, all entities are divided</span><span class="c">// into "important" and "unimportant" entities.  Important entities are</span><span class="c">// things like mario himself, coins, enemies etc.  Unimportant entities are</span><span class="c">// things like wind effects or the stars that come out of mario's butt</span><span class="c">// stomp.  When the game runs out of entity slots, it will remove</span><span class="c">// unimportant entities to make room for important entities.  If the game</span><span class="c">// tries to create more than 240 important entities (or 232 in BitFS), it</span><span class="c">// will hang.</span><span class="k">pub</span><span class="n">important</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span><span class="k">pub</span><span class="n">position</span><span class="p">:</span><span class="n">Vector3</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="k">pub</span><span class="n">rotation</span><span class="p">:</span><span class="n">Vector3</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="c">// I think most things like this are pointers in real Mario 64, but they</span><span class="c">// could just as easily be indexes.  This turns out to be kind of important.</span><span class="k">pub</span><span class="n">animation</span><span class="p">:</span><span class="n">EntityAnimation</span><span class="p">,</span><span class="k">pub</span><span class="n">behavior</span><span class="p">:</span><span class="n">EntityBehavior</span><span class="p">,</span><span class="k">pub</span><span class="n">visible</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span><span class="k">pub</span><span class="n">damage_mario_on_touch</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span><span class="k">pub</span><span class="n">home_in_on_mario</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span><span class="c">// Generic timer, used for lots of animation and gameplay purposes</span><span class="k">pub</span><span class="n">timer</span><span class="p">:</span><span class="nb">u16</span><span class="p">,</span><span class="c">// Generic action, used differently for different entity types</span><span class="k">pub</span><span class="n">action</span><span class="p">:</span><span class="nb">u8</span><span class="p">,</span><span class="c">// Lots more stuff...</span><span class="p">}</span><span class="k">pub</span><span class="k">type</span><span class="n">EntityIndex</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">WorldRenderGeometry</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">WorldCollisions</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">GameState</span><span class="p">{</span><span class="k">pub</span><span class="n">world_render_geometry</span><span class="p">:</span><span class="n">WorldRenderGeometry</span><span class="p">,</span><span class="k">pub</span><span class="n">world_collisions</span><span class="p">:</span><span class="n">WorldCollisions</span><span class="p">,</span><span class="c">// Seriously, not ever more than 240</span><span class="k">pub</span><span class="n">entities</span><span class="p">:</span><span class="p">[</span><span class="n">Entity</span><span class="p">;</span><span class="mi">240</span><span class="p">],</span><span class="c">// Instead of a pointer, we store an index into the entities array.</span><span class="k">pub</span><span class="n">mario_entity</span><span class="p">:</span><span class="n">EntityIndex</span><span class="p">,</span><span class="c">// Lots more stuff...</span><span class="p">}</span></code></pre></div></div><p>So, the specific details of these representations aren’t really super important,
the important takeaways here are that:</p><ul><li>The representation of the game state (though it’s dramatically
over-simplified here) is still very <em>simple</em> even in the real game.  It’s
very predictable and amenable to RAM value poking, and there isn’t really
much in the way of “abstraction” here, everything is quite literal and built
for purpose.</li><li>We can’t know for sure about the languages used for all the games in the N64
era, but we know at least for some titles that it was definitely C (Shadows
of the Empire), and probably it was C in the vast majority of cases.  The
game structures all tended to be simple and predictable like Mario 64, you
can imagine the game state being represented mostly as global C structs or
arrays of structs.</li><li>I’m speculating here, but <em>probably</em> there was not much “data hiding”, you
can imagine the structure of these games more or less as a giant static
global struct containing “all of the game state”, visible to all of the
game’s code.</li><li>There are occasional pointers to functions, but there doesn’t seem to be a
whole lot of OO going on.  There don’t seem to be vtables, or even many
things <em>like</em> vtables, or anything like that.  This is potentially wild
speculation and is definitely just a non-expert opinion, but from my
“extensive” research into the memory layout and design of SNES - N64 era
titles, it usually feels like you can kind of imagine the very basic,
boring, made-for-purpose C code that the engine is made of just from looking
at the data format.</li></ul><p>Okay, so imagine you were to write Mario 64 very similarly to how it appears to
originally be designed, but in Rust.  You would effectively be writing a giant,
procedural, single purpose game engine in a much much nicer C, but still at its
heart, pretty much like C.  Effectively your game engine is something like
(DRAMATIC OVERSIMPLIFICATION INCOMING):</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">struct</span><span class="n">EntityAnimation</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">EntityBehavior</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">Entity</span><span class="p">{</span><span class="c">// ... see above</span><span class="p">}</span><span class="k">pub</span><span class="k">type</span><span class="n">EntityIndex</span><span class="o">=</span><span class="nb">u8</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">WorldRenderGeometry</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">WorldCollisions</span><span class="p">;</span><span class="k">pub</span><span class="k">struct</span><span class="n">GameState</span><span class="p">{</span><span class="c">// ... see above</span><span class="p">}</span><span class="k">fn</span><span class="nf">main</span><span class="p">()</span><span class="p">{</span><span class="c">// ALL of the game state, morally a global.</span><span class="k">let</span><span class="k">mut</span><span class="n">game_state</span><span class="o">=</span><span class="n">GameState</span><span class="p">{</span><span class="o">...</span><span class="p">};</span><span class="k">loop</span><span class="p">{</span><span class="c">// Every time around this loop is 1 frame, which is 16ms for a 60fps game.</span><span class="c">// We capture the entire input in one go, once a frame.  There is not</span><span class="c">// really even a need for anything complex like input events, because in</span><span class="c">// something like Mario 64, all that's really happening to read the state</span><span class="c">// of controllers is reading a specific memory region for the controller</span><span class="c">// state.  Here, we're just doing this at the beginning of the frame, in</span><span class="c">// real Mario 64 I believe happens once per frame for different systems</span><span class="c">// but distributed over several places.</span><span class="k">let</span><span class="n">input_state</span><span class="o">=</span><span class="nf">capture_input_state</span><span class="p">();</span><span class="c">// Let's have a series of functions change the state of the game_state</span><span class="c">// based on the previous game state and the input.  We'll be very very</span><span class="c">// fancy, and we'll give this very SIMPLE pattern an overly fancy name,</span><span class="c">// and we'll call each of these functions a "system".</span><span class="c">// Set state flags inside mario to start jumping, or maybe set a state</span><span class="c">// flag for whether you're paused.</span><span class="nf">input_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">,</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">);</span><span class="c">// pos += vel * dt;  Apply gravity.  Do collision detection and response</span><span class="c">// for all entities.</span><span class="nf">physics_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">);</span><span class="c">// Run entity logic for every entity, this might farm out into</span><span class="c">// update_mario, update_baddies, update_platforms, etc.</span><span class="nf">entity_logic_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">);</span><span class="c">// ... lots more systems</span><span class="c">// Render the current game state.  In the N64 era this was in some ways</span><span class="c">// vastly simpler than now, but even then it was probably still pretty</span><span class="c">// messy and stateful, so maybe our game state includes the state of</span><span class="c">// loaded graphics resources as well.</span><span class="nf">render_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game</span><span class="p">);</span><span class="c">// Read state flags of entities and trigger new audio, this is messy</span><span class="c">// and stateful just like rendering.</span><span class="nf">audio_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game</span><span class="p">);</span><span class="c">// Wait on VBlank</span><span class="nf">wait_vblank</span><span class="p">();</span><span class="c">// repeat.</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>So I’m NOT recommending that you make games this way!  However, even if you
think this is 100% a ridiculous over-simplification, or you think that even if
you could make a large complex game this way, it would turn into a procedural
ball of mud, let’s look at this for a while and see if there are any advantages
before we totally write this off.  Clearly there is a huge, gaping, obvious
disadvantage in that the entire game state is visible and mutable to all systems
and if something changes unexpectedly, you might have no idea where to look to
find what is changing the game state improperly.  Nobody is <em>really</em> suggesting
in the modern era that you write software with all state as effectively global.
HOWEVER there is one advantage here, which is that with a little bit of care,
you could write a game this way in 100% safe rust and almost definitely not run
into issues with the borrow checker.  You might not be able to use <em>pointers</em>
safely since <em>certainly</em> if you used pointers your entire game state would have
internal pointers to itself, so the one modification from Mario 64 style that we
need to make is that everywhere where there would have been a pointer, instead
store an index into some array.  The canonical example of this is the
“mario_entity” field on our GameState.  This may seem overly limiting, but with
a bit of thought it becomes clear especially if you had constant limits on
things (you don’t even have malloc, remember!), you can always add something
like <code class="highlighter-rouge">all_the_textures: [TextureDescriptor; 256]</code>, and use integer indexes into
this static array to describe textures instead of things like pointers.  The
other reason this is helpful w.r.t. the borrow checker is that Rust is rather
good at letting you split borrows for different fields of a public struct, so
since everything in our pretend-engine is just a giant nested tree of entirely
public structs, you should always be able to read the state of the game and
change exactly as much of the game as necessary in each system.  Remember, most
of the games in the “Action Replay” era are written like this, there is not
usually any malloc-ing, there is at most something very limited like
“allocating” only from a fixed array, and most everything is more or less
carefully laid out in a static struct somewhere.</p><p>One more criticism of this style is that you might say that using indexes
instead of pointers is “safe” in the strict sense, but possibly only
technically, you’re trading UB and potential crashes with pointers for “random
but unspecified” behavior if you access the wrong or outdated index, and
potentially panics.  You’d be right, btw!  We’ll visit this some more later, but
just accept for now that it’s possible and safe and this design doesn’t run
directly against the borrow checker.</p><p>Okay, so now I’ve hopefully described an admittedly over-simplified way that you
COULD write a game in Rust that morally sort of closely mirrors the oldest game
architectures.  I’m not advocating this for your next game or anything, but
there ARE games written now that are little more than this, written in direct,
single purpose, procedural style.  I’m not going to call out specific games, but
I’ve seen a bunch of games written in a style that is little more than this,
often wrapped in a paper thin veneer of OO.  I’ve seen game source code that has
a single <strong>12k</strong> line world generation function.  This is not an insult to such
games, even marginally, the people who do this are often absolute geniuses who
are just very good at knowing what to care about and what not to care about.
There is real wisdom here!</p><p>But still, I’m genuinely not advocating this.  Let’s refer to this as the
“UR-game-architecture”, and we’ll come back to it.  This is approaching the
“data-driven! use an ECS!” answer from the bottom up, let’s digress and approach
this now from the top down.</p><h2 id="wayyyyyyy-too-much-object-orientation">Wayyyyyyy too much object orientation</h2><p>Now that we’ve covered sort of the simplest possible messy procedural C-ish game
engine design, let’s try to apply the principles of OO design and see if this is
an improvement.  I’m going to use Starbound or some simplification of Starbound
as an example here, because I’m lucky enough to know a lot about it and have its
source on hand, so I’m not going to be lying <em>too</em> much when I describe it.</p><p>What are the principles of OO?  Not everybody entirely agrees with what OO is,
but I’m including some basic hopefully non-controversial points:</p><ul><li>Single responsibility principle - Objects should have a single logical set
of responsibilities, and methods should perform one operation inside that
set of responsibilities.</li><li>Encapsulation - You should bind data together with the functions that
operate on it, keeping both safe from outside interference and misuse.  This
allows for refactoring by changing the internal representation of a class
without changing its behavior.</li><li>Abstraction, or “Liskov Substitution Principle”, or similar - You should be
able to substitute one derived class for another, as long as they share the
same base and are used through that base class (or interface, or whatever).</li><li>Interface segregation, or principle of least coupling, etc - The dependency
on one class to another should use the smallest possible interface.</li></ul><p>On a practical level, OO languages generally have a few important features to
support OO design, namely object methods, private object data, inheritance,
virtual methods, etc.  I’m mostly going to be talking about C++ because it has a
lot of OO footguns, it’s what I know, and it’s a super popular language for the
“I’m gonna make my own engine” gamedev crowd.</p><p>We’re going to try these principles out and see how they can be misused for game
development, and then talk about how even though they often fail for gamedev
(and this is now a “well known” state of affairs), they fail <em>way more
spectacularly</em> with Rust.  It <em>is</em> possible to make a game with at least some of
these principles, though, and they’re not <em>all</em> actually universally terrible
ideas.  I’m not really a proponent of OO <em>at all</em>, but there are at least a few
good ideas that are sort of related to OO or kind of came out of OO (all of
which Rust has and can perform admirably).</p><ul><li>The dot operator or “postfix functions”.  If you’re a haskeller this is
“type directed name resolution” as opposed to the normal state of affairs
which is “name directed type resolution”.  A “powerful” way to avoid having
to scope 100 different functions with very short common names, or have C
style prefixes for everything.  Great for IDEs too!</li><li>Interfaces with laws (contracts) - Rust traits!  No inheritance in sight,
and they’re best when they’re small and come with meaningful rules around
them, but if you squint they’re kind of C++ pure virtual classes.  They’re
<em>awesome</em> in the same way Haskell typeclasses are awesome.</li><li>Data hiding - Being able to hide data to maintain invariants is invaluable,
making a safe interface to unsafe code would not be possible without it.
Very useful in the small, and with “library” code.</li></ul><p>So just for the record I’m not trying to pick on the above good parts, these are
fine, great even.  With that out of the way, lets look at ways the rest of OO
design can fail in gamedev.</p><p>So, superficially games seem well suited to OO because when trying to come up
with OO designs, there are obvious “objects” that jump out at you.  Using
starbound as our example, things like “Player”, “NPC”, “Monster” are pretty
easily understood concepts and obvious candidates for objects in our game, so
lets start with these.  We’ll also include a “World” class which, like the Mario
64 example, is the basic structure of some live play arena (we’re purposefully
skipping things like interfaces, menus, etc and focusing on the core part of a
game engine).  I’ll also have to switch to C++ because some of this is going to
be difficult to express in Rust.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span><span class="kt">uint32_t</span><span class="n">EntityId</span><span class="p">;</span><span class="k">enum</span><span class="k">class</span><span class="nc">HumanoidAnimationState</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">class</span><span class="nc">HumanoidItem</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">Player</span><span class="p">{</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">velocity</span><span class="p">;</span><span class="kt">float</span><span class="n">mass</span><span class="p">;</span><span class="n">HumanoidAnimationState</span><span class="n">animation_state</span><span class="p">;</span><span class="n">HumanoidItem</span><span class="n">left_hand_item</span><span class="p">;</span><span class="n">HumanoidItem</span><span class="n">right_hand_item</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">aim_position</span><span class="p">;</span><span class="kt">float</span><span class="n">health</span><span class="p">;</span><span class="n">EntityId</span><span class="n">focused_entity</span><span class="p">;</span><span class="kt">float</span><span class="n">food_level</span><span class="p">;</span><span class="kt">bool</span><span class="n">admin</span><span class="p">;</span><span class="c1">// So, so much more...
</span><span class="p">};</span><span class="k">enum</span><span class="k">class</span><span class="nc">MonsterAnimationState</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">DamageRegion</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">Monster</span><span class="p">{</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">velocity</span><span class="p">;</span><span class="kt">float</span><span class="n">mass</span><span class="p">;</span><span class="n">MonsterAnimationState</span><span class="n">animation_state</span><span class="p">;</span><span class="kt">float</span><span class="n">health</span><span class="p">;</span><span class="n">EntityId</span><span class="n">current_target</span><span class="p">;</span><span class="n">DamageRegion</span><span class="n">damage_region</span><span class="p">;</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">Npc</span><span class="p">{</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">velocity</span><span class="p">;</span><span class="kt">float</span><span class="n">mass</span><span class="p">;</span><span class="n">HumanoidAnimationState</span><span class="n">animation_state</span><span class="p">;</span><span class="n">HumanoidItem</span><span class="n">left_hand_item</span><span class="p">;</span><span class="n">HumanoidItem</span><span class="n">right_hand_item</span><span class="p">;</span><span class="kt">float</span><span class="n">health</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">aim_position</span><span class="p">;</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">WorldTile</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">World</span><span class="p">{</span><span class="n">List</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="o">&gt;</span><span class="n">player_ids</span><span class="p">;</span><span class="c1">// Hmm, we're probably going to need an interface and downcasting here?
</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="p">,</span><span class="kt">void</span><span class="o">*&gt;</span><span class="n">entities</span><span class="p">;</span><span class="n">MultiArray2D</span><span class="o">&lt;</span><span class="n">WorldTile</span><span class="o">&gt;</span><span class="n">tiles</span><span class="p">;</span><span class="c1">// So, so much more...
</span><span class="p">};</span></code></pre></div></div><p>Right away, we see repeated structure in our data types, and probably these
should be sub-objects with their own methods, so let’s sketch that out a bit:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span><span class="kt">uint32_t</span><span class="n">EntityId</span><span class="p">;</span><span class="k">enum</span><span class="k">class</span><span class="nc">HumanoidAnimationState</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">class</span><span class="nc">HumanoidItem</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">Physics</span><span class="p">{</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">velocity</span><span class="p">;</span><span class="kt">float</span><span class="n">mass</span><span class="p">;</span><span class="p">};</span><span class="k">struct</span><span class="n">HumanoidState</span><span class="p">{</span><span class="n">HumanoidAnimationState</span><span class="n">animation_state</span><span class="p">;</span><span class="n">HumanoidItem</span><span class="n">left_hand_item</span><span class="p">;</span><span class="n">HumanoidItem</span><span class="n">right_hand_item</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">aim_position</span><span class="p">;</span><span class="p">};</span><span class="k">struct</span><span class="n">Player</span><span class="p">{</span><span class="n">Physics</span><span class="n">physics</span><span class="p">;</span><span class="n">HumanoidState</span><span class="n">humanoid</span><span class="p">;</span><span class="kt">float</span><span class="n">health</span><span class="p">;</span><span class="n">EntityId</span><span class="n">focused_entity</span><span class="p">;</span><span class="kt">float</span><span class="n">food_level</span><span class="p">;</span><span class="kt">bool</span><span class="n">admin</span><span class="p">;</span><span class="p">...</span><span class="p">};</span><span class="k">enum</span><span class="k">class</span><span class="nc">MonsterAnimationState</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">DamageRegion</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">Monster</span><span class="p">{</span><span class="n">Physics</span><span class="n">physics</span><span class="p">;</span><span class="n">MonsterAnimationState</span><span class="n">animation_state</span><span class="p">;</span><span class="kt">float</span><span class="n">health</span><span class="p">;</span><span class="n">EntityId</span><span class="n">current_target</span><span class="p">;</span><span class="n">DamageRegion</span><span class="n">damage_region</span><span class="p">;</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">Npc</span><span class="p">{</span><span class="n">Physics</span><span class="n">physics</span><span class="p">;</span><span class="n">HumanoidState</span><span class="n">humanoid</span><span class="p">;</span><span class="kt">float</span><span class="n">health</span><span class="p">;</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">WorldTile</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">World</span><span class="p">{</span><span class="n">List</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="o">&gt;</span><span class="n">player_ids</span><span class="p">;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="p">,</span><span class="kt">void</span><span class="o">*&gt;</span><span class="n">entities</span><span class="p">;</span><span class="n">MultiArray2D</span><span class="o">&lt;</span><span class="n">WorldTile</span><span class="o">&gt;</span><span class="n">tiles</span><span class="p">;</span><span class="p">...</span><span class="p">};</span></code></pre></div></div><p>So far this isn’t going too bad, but this is still just describing the data
structures in our game.  Remember, one of the OO principles we talked about is
encapsulation, you want to expose a minimal interface to each of these structs
(we really should call them classes!) and methods that only expose what is
necessary.  Also, there’s that void pointer in entities inside world, we
probably shouldn’t have that, we’re going to need to keep our entities stored
somehow so let’s make an Entity interface while we’re at it for things that are
common to all entities.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span><span class="kt">uint32_t</span><span class="n">EntityId</span><span class="p">;</span><span class="c1">// Forward declare World to pass it to Entity
</span><span class="k">struct</span><span class="n">World</span><span class="p">;</span><span class="k">struct</span><span class="n">InputState</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">RenderState</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="c1">// Pure virtual interface!
</span><span class="k">class</span><span class="nc">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="c1">// Okay, *definitely* all entities will have a position, and it's probably
</span><span class="c1">// fine for this to be const.
</span><span class="k">virtual</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">// Do all entities have a velocity?  Probably not actually, there are
</span><span class="c1">// probably going to be stationary entities, so let's skip velocity.  Any
</span><span class="c1">// other common fields?  Honestly probably there are a few that deserve to
</span><span class="c1">// go here, but there can't be *too* many without immediately thinking of
</span><span class="c1">// cases where an entity doesn't have them.  Maybe they all return Maybe or
</span><span class="c1">// something, but that doesn't sound very useful as an interface?  We'll
</span><span class="c1">// just make more interfaces for those and stick to OO design!
</span><span class="c1">// So, we're going to need to update each entity somehow and probably render
</span><span class="c1">// it, so let's define a few methods for this.
</span><span class="c1">// Well, we definitely have to pass the entity's world to its update method,
</span><span class="c1">// because for example a Player has to be able to do things like spawn
</span><span class="c1">// projectile entities, and so do monsters and NPCs probably.  Also,
</span><span class="c1">// monsters have to know where the player is to attack them!
</span><span class="kt">void</span><span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">*</span><span class="n">world</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="c1">// Let's assume that these aren't toooo stateful and messy and each entity
</span><span class="c1">// can just "render themselves" in some reasonable way.
</span><span class="kt">void</span><span class="n">input</span><span class="p">(</span><span class="n">InputState</span><span class="k">const</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="kt">void</span><span class="n">render</span><span class="p">(</span><span class="n">RenderState</span><span class="o">&amp;</span><span class="n">render_state</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="k">private</span><span class="o">:</span><span class="c1">// No private data!  We definitely know that we should favor composition
</span><span class="c1">// over inheritance because we've been told this before, so only pure
</span><span class="c1">// virtual interfaces for us!  This is one facet of OO design that's
</span><span class="c1">// *probably* basically dead now?  I don't actually know for sure, but I
</span><span class="c1">// know this has been talked about to death so we don't have to beat THIS
</span><span class="c1">// dead of a horse.
</span><span class="p">};</span><span class="k">class</span><span class="nc">Player</span><span class="o">:</span><span class="n">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">input</span><span class="p">(</span><span class="n">InputState</span><span class="k">const</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">*</span><span class="n">world</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">render</span><span class="p">(</span><span class="n">RenderState</span><span class="o">&amp;</span><span class="n">render_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="k">private</span><span class="o">:</span><span class="n">Physics</span><span class="n">m_physics</span><span class="p">;</span><span class="n">HumanoidState</span><span class="n">m_humanoid</span><span class="p">;</span><span class="p">...</span><span class="p">};</span><span class="k">class</span><span class="nc">Monster</span><span class="o">:</span><span class="n">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">input</span><span class="p">(</span><span class="n">InputState</span><span class="k">const</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">*</span><span class="n">world</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">render</span><span class="p">(</span><span class="n">RenderState</span><span class="o">&amp;</span><span class="n">render_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="k">private</span><span class="o">:</span><span class="n">Physics</span><span class="n">m_physics</span><span class="p">;</span><span class="p">...</span><span class="p">};</span><span class="k">class</span><span class="nc">NPC</span><span class="o">:</span><span class="n">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">input</span><span class="p">(</span><span class="n">InputState</span><span class="k">const</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">*</span><span class="n">world</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">render</span><span class="p">(</span><span class="n">RenderState</span><span class="o">&amp;</span><span class="n">render_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="k">private</span><span class="o">:</span><span class="n">Physics</span><span class="n">m_physics</span><span class="p">;</span><span class="n">HumanoidState</span><span class="n">m_humanoid</span><span class="p">;</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">WorldTile</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="k">struct</span><span class="n">World</span><span class="p">{</span><span class="n">List</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="o">&gt;</span><span class="n">player_ids</span><span class="p">;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="p">,</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;&gt;</span><span class="n">entities</span><span class="p">;</span><span class="n">MultiArray2D</span><span class="o">&lt;</span><span class="n">WorldTile</span><span class="o">&gt;</span><span class="n">tiles</span><span class="p">;</span><span class="p">...</span><span class="p">};</span></code></pre></div></div><p>So one point before we go on, why am I bothering with this <code class="highlighter-rouge">EntityId</code> stuff
here?  This is C++, why can’t we use pointers?  Well, it turns out that doing
this is <em>very</em> unsafe, so the pattern that all game engines I’ve ever (in
languages without a fancy garbage collector) seen adopt is actually to have
some kind of map from some form of “entity id” to an actual entity pointer and
keep that in a single location.  The reason for this is that, say in C++, let’s
say every entity keeps a shared_ptr<entity> or some kind of downcasted
shared_ptr.  The problem then becomes that World is now a giant ball of
reference-cycles and entities may never be destructed, and this is a huge
problem.  On the other side of this, if they kept raw pointers, they would be
continually invalidated and this tends to lead to hard to solve ephemeral bugs
and so more or less nobody does this (least, nobody keeps raw pointers /
references around for "very long").  You *could* use for example weak_ptr, and
this is sometimes used, but there tend to be other reasons to use ids because
they're useful for networking and can more easily be saved and loaded from
disk.  This is interesting, because this is the major change that we had to
make in our "UR-game-architecture" to make it compatible with Rust, but it's
very *very* common in game engines in general!</entity></p><p>(In game engines, EntityId is usually something like an int that counts up,
possibly a uint64_t that doesn’t round or a uint32_t that does round, and this
is done so that an EntityId is never or very rarely re-used.  This way, if an
entity goes away, generally anything monitoring it will notice it gone rather
than some other entity immediately taking its place.  There’s another pattern
here called “generational indexes” which is important and I’ll talk about later)</p><p>Okay so this seems like it… could actually work to make a complex game with?
I can sort of imagine a <em>very</em> simple game you could make with these classes and
interfaces as they are right now, but let’s flesh it out a bit to see what sort
of problems we’ll run into.</p><p>Let’s think about what a monster needs to track a player.  They might go through
all the entities in the world, filter by only the players, sort by distance
(you’d use some kind of spatial hash / kd-tree in reality), and then track the
closest one.  That actually seems basically possible with this as it is!  Okay,
new requirement: monsters should track players with the lowest health first.
Uh-oh, okay player health is private, so we better make a public accessor for
this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span><span class="nc">Player</span><span class="o">:</span><span class="n">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">input</span><span class="p">(</span><span class="n">InputState</span><span class="k">const</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">*</span><span class="n">world</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">render</span><span class="p">(</span><span class="n">RenderState</span><span class="o">&amp;</span><span class="n">render_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">float</span><span class="n">health</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="k">private</span><span class="o">:</span><span class="p">...</span><span class="p">};</span></code></pre></div></div><p>We <em>could</em> have just made the health public, but OO design!  What if there’s an
invariant being held, where if the health drops below some value, some animation
state is triggered?  What about damage?  Certainly the single responsibility
principle states that a <em>monster</em> shouldn’t be in charge of setting a <em>player’s</em>
health.</p><p>Okay, new requirement: Monsters should not go after players marked as “admin”.
Alright, add an accessor!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span><span class="nc">Player</span><span class="o">:</span><span class="n">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">input</span><span class="p">(</span><span class="n">InputState</span><span class="k">const</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">*</span><span class="n">world</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">render</span><span class="p">(</span><span class="n">RenderState</span><span class="o">&amp;</span><span class="n">render_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">float</span><span class="n">health</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">is_admin</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="k">private</span><span class="o">:</span><span class="p">...</span><span class="p">};</span></code></pre></div></div><p>Okay, we’ve made a little prototype game but no damage is happening yet, so
let’s go ahead and get damage set up.  Hmm, where should the damage system for
players go?  Probably a player should reduce their health since it’s <em>their</em>
health… or maybe monsters could do it since it’s <em>their</em> damage region?  I
dunno, I’ll say it’s the player’s job.  I guess that means we need accessors on
the monsters for their damage region:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span><span class="nc">Monster</span><span class="o">:</span><span class="n">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">input</span><span class="p">(</span><span class="n">InputState</span><span class="k">const</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">*</span><span class="n">world</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">render</span><span class="p">(</span><span class="n">RenderState</span><span class="o">&amp;</span><span class="n">render_state</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="n">DamageRegion</span><span class="k">const</span><span class="o">&amp;</span><span class="n">damage_region</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="k">private</span><span class="o">:</span><span class="p">...</span><span class="p">};</span></code></pre></div></div><p>This is turning into a lot of accessors.  We <em>could</em> just start making lots of
things public, but what do OO principles state?  That we should expose as little
and finite an interface as possible so that we can change our implementation
without refactoring.  Maybe this won’t get <em>so</em> bad.</p><p>Okay, new requirements: A certain monster will only aggro the player when the
player touches the ground near them.  Okay, this is going to require yet more
accessors, except because we’ve been following good OO principles about code
re-use, we have that internal member m_physics of type <code class="highlighter-rouge">Physics</code>, and it is the
only thing that can know whether an entity is touching the ground.  So, I guess
Physics needs an accessor to <em>its</em> internal state <code class="highlighter-rouge">Physics::onGround</code> And then
the <em>Player</em> needs an accessor <code class="highlighter-rouge">Player::onGround</code> which in turn will use
<code class="highlighter-rouge">Physics::onGround</code>.  Okay, this is turning into LOTS of accessors.</p><p>It feels like every time a new requirement comes in, you have to take what may
have once been sane interfaces and “poke more holes through them”.  8 months
later, most of a semi-game has been built this way and there are LOTS of these
holes poked through.  Lots of code has no clear place to be because it concerns
multiple entities at once, and a lot of logically similar functionality is split
across several files.  “The problem with OO is that everything happens somewhere
else”.</p><p>A new requirement comes in: I have an idea for a special kind of item that when
the player holds it and its near a specific kind of enemy, it will glow.  The
enemies that trigger this should be scared of the item and back away, but have a
special animation where they’re mesmerized by the glowing item.  This should
only work for players that have achieved some specific quest goal.</p><p>You throw up your hands in frustration, this would require 4 separate modules to
know about all of the other’s internals (Player, Items, Monsters, Animation).
You add a lot more accessors and special interfaces.  Things are a mess.</p><p>So, these are made up examples, but they are not much different than the real
things that I went through a <em>lot</em>.  This is why it is now considered common
knowledge now that for games, OO <em>mostly</em> just gets in the way.  Data hiding has
very limited utility for a game outside of just maintaining invariants at the
edges of the code, where things are smaller and more contained.  A lot, possibly
even the vast majority of the interesting behavior in your game ends up spanning
many data types, and does not naturally “belong” to any specific entity.  Lots
of entity types are 80% or 60% similar to others and its hard to re-use code,
and the more modules we add inside our entities to help reuse code, the more
layers are added.  What have we gained vs our UR-architecture?  That not
everything is visible to all our functions, even though we keep adding more and
more and more accessors so it sort of is?  Maybe some marginally better code
organization, but also sometimes <em>worse</em> code organization?</p><p>Okay, so obviously this has a lot of downsides even in C++, and obviously you
know where we’re eventually going to end up because I told you at the beginning
of the talk (Just use ECS!).  You CAN make a game this way, but you’ll have a
lot of problems and poke a LOT of holes and probably end up with some
mega-objects.  Just for a nice visceral reaction, let’s look at the actual,
<em>for-real</em> Player class inside Starbound as of the current version:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span><span class="nc">Player</span><span class="o">:</span><span class="k">public</span><span class="k">virtual</span><span class="n">ToolUserEntity</span><span class="p">,</span><span class="k">public</span><span class="k">virtual</span><span class="n">LoungingEntity</span><span class="p">,</span><span class="k">public</span><span class="k">virtual</span><span class="n">ChattyEntity</span><span class="p">,</span><span class="k">public</span><span class="k">virtual</span><span class="n">DamageBarEntity</span><span class="p">,</span><span class="k">public</span><span class="k">virtual</span><span class="n">PortraitEntity</span><span class="p">,</span><span class="k">public</span><span class="k">virtual</span><span class="n">NametagEntity</span><span class="p">,</span><span class="k">public</span><span class="k">virtual</span><span class="n">PhysicsEntity</span><span class="p">,</span><span class="k">public</span><span class="k">virtual</span><span class="n">EmoteEntity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="n">Player</span><span class="p">(</span><span class="n">PlayerConfigPtr</span><span class="n">config</span><span class="p">,</span><span class="n">Uuid</span><span class="n">uuid</span><span class="o">=</span><span class="n">Uuid</span><span class="p">());</span><span class="n">Player</span><span class="p">(</span><span class="n">PlayerConfigPtr</span><span class="n">config</span><span class="p">,</span><span class="n">Json</span><span class="k">const</span><span class="o">&amp;</span><span class="n">diskStore</span><span class="p">);</span><span class="n">Player</span><span class="p">(</span><span class="n">PlayerConfigPtr</span><span class="n">config</span><span class="p">,</span><span class="n">ByteArray</span><span class="k">const</span><span class="o">&amp;</span><span class="n">netStore</span><span class="p">);</span><span class="n">ClientContextPtr</span><span class="n">clientContext</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">setClientContext</span><span class="p">(</span><span class="n">ClientContextPtr</span><span class="n">clientContext</span><span class="p">);</span><span class="n">StatisticsPtr</span><span class="n">statistics</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">setStatistics</span><span class="p">(</span><span class="n">StatisticsPtr</span><span class="n">statistics</span><span class="p">);</span><span class="n">QuestManagerPtr</span><span class="n">questManager</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">Json</span><span class="n">diskStore</span><span class="p">();</span><span class="n">ByteArray</span><span class="n">netStore</span><span class="p">();</span><span class="n">EntityType</span><span class="n">entityType</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">init</span><span class="p">(</span><span class="n">World</span><span class="o">*</span><span class="n">world</span><span class="p">,</span><span class="n">EntityId</span><span class="n">entityId</span><span class="p">,</span><span class="n">EntityMode</span><span class="n">mode</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">uninit</span><span class="p">()</span><span class="k">override</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">velocity</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">mouthPosition</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">mouthOffset</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">feetOffset</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">headArmorOffset</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">chestArmorOffset</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">legsArmorOffset</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">backArmorOffset</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="c1">// relative to current position
</span><span class="n">RectF</span><span class="n">metaBoundBox</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="c1">// relative to current position
</span><span class="n">RectF</span><span class="n">collisionArea</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">ByteArray</span><span class="p">,</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="n">writeNetState</span><span class="p">(</span><span class="kt">uint64_t</span><span class="n">fromStep</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">readNetState</span><span class="p">(</span><span class="n">ByteArray</span><span class="n">data</span><span class="p">,</span><span class="kt">float</span><span class="n">interpolationStep</span><span class="o">=</span><span class="mf">0.0</span><span class="n">f</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">enableInterpolation</span><span class="p">(</span><span class="kt">float</span><span class="n">extrapolationHint</span><span class="o">=</span><span class="mf">0.0</span><span class="n">f</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">disableInterpolation</span><span class="p">()</span><span class="k">override</span><span class="p">;</span><span class="k">virtual</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">HitType</span><span class="o">&gt;</span><span class="n">queryHit</span><span class="p">(</span><span class="n">DamageSource</span><span class="k">const</span><span class="o">&amp;</span><span class="n">source</span><span class="p">)</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">PolyF</span><span class="o">&gt;</span><span class="n">hitPoly</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">DamageNotification</span><span class="o">&gt;</span><span class="n">applyDamage</span><span class="p">(</span><span class="n">DamageRequest</span><span class="k">const</span><span class="o">&amp;</span><span class="n">damage</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">DamageNotification</span><span class="o">&gt;</span><span class="n">selfDamageNotifications</span><span class="p">()</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">hitOther</span><span class="p">(</span><span class="n">EntityId</span><span class="n">targetEntityId</span><span class="p">,</span><span class="n">DamageRequest</span><span class="k">const</span><span class="o">&amp;</span><span class="n">damageRequest</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">damagedOther</span><span class="p">(</span><span class="n">DamageNotification</span><span class="k">const</span><span class="o">&amp;</span><span class="n">damage</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">DamageSource</span><span class="o">&gt;</span><span class="n">damageSources</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">shouldDestroy</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">destroy</span><span class="p">(</span><span class="n">RenderCallback</span><span class="o">*</span><span class="n">renderCallback</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">EntityAnchorState</span><span class="o">&gt;</span><span class="n">loungingIn</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">lounge</span><span class="p">(</span><span class="n">EntityId</span><span class="n">loungeableEntityId</span><span class="p">,</span><span class="kt">size_t</span><span class="n">anchorIndex</span><span class="p">);</span><span class="kt">void</span><span class="n">stopLounging</span><span class="p">();</span><span class="kt">void</span><span class="n">revive</span><span class="p">(</span><span class="n">Vec2F</span><span class="k">const</span><span class="o">&amp;</span><span class="n">footPosition</span><span class="p">);</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Drawable</span><span class="o">&gt;</span><span class="n">portrait</span><span class="p">(</span><span class="n">PortraitMode</span><span class="n">mode</span><span class="p">)</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">underwater</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">setShifting</span><span class="p">(</span><span class="kt">bool</span><span class="n">shifting</span><span class="p">);</span><span class="kt">void</span><span class="n">special</span><span class="p">(</span><span class="kt">int</span><span class="n">specialKey</span><span class="p">);</span><span class="kt">void</span><span class="n">moveLeft</span><span class="p">();</span><span class="kt">void</span><span class="n">moveRight</span><span class="p">();</span><span class="kt">void</span><span class="n">moveUp</span><span class="p">();</span><span class="kt">void</span><span class="n">moveDown</span><span class="p">();</span><span class="kt">void</span><span class="n">jump</span><span class="p">();</span><span class="kt">void</span><span class="n">dropItem</span><span class="p">();</span><span class="kt">float</span><span class="n">toolRadius</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">float</span><span class="n">interactRadius</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">InteractAction</span><span class="o">&gt;</span><span class="n">pullInteractActions</span><span class="p">();</span><span class="kt">uint64_t</span><span class="n">currency</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">currencyType</span><span class="p">)</span><span class="k">const</span><span class="p">;</span><span class="kt">float</span><span class="n">health</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">float</span><span class="n">maxHealth</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">DamageBarType</span><span class="n">damageBar</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">float</span><span class="n">healthPercentage</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">float</span><span class="n">energy</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">float</span><span class="n">maxEnergy</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">float</span><span class="n">energyPercentage</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">float</span><span class="n">energyRegenBlockPercent</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">energyLocked</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">fullEnergy</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">consumeEnergy</span><span class="p">(</span><span class="kt">float</span><span class="n">energy</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">float</span><span class="n">foodPercentage</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">float</span><span class="n">breath</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">float</span><span class="n">maxBreath</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">float</span><span class="n">protection</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">forceNude</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">String</span><span class="n">description</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">LightSource</span><span class="o">&gt;</span><span class="n">lightSources</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Direction</span><span class="n">walkingDirection</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Direction</span><span class="n">facingDirection</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="n">receiveMessage</span><span class="p">(</span><span class="n">ConnectionId</span><span class="n">sendingConnection</span><span class="p">,</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">message</span><span class="p">,</span><span class="n">JsonArray</span><span class="k">const</span><span class="o">&amp;</span><span class="n">args</span><span class="o">=</span><span class="p">{})</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">update</span><span class="p">(</span><span class="kt">uint64_t</span><span class="n">currentStep</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">render</span><span class="p">(</span><span class="n">RenderCallback</span><span class="o">*</span><span class="n">renderCallback</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="n">PlayerInventoryPtr</span><span class="n">inventory</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="c1">// Returns the number of items from this stack that could be
</span><span class="c1">// picked up from the world, using inventory tab filtering
</span><span class="kt">size_t</span><span class="n">itemsCanHold</span><span class="p">(</span><span class="n">ItemPtr</span><span class="k">const</span><span class="o">&amp;</span><span class="n">items</span><span class="p">)</span><span class="k">const</span><span class="p">;</span><span class="c1">// Adds items to the inventory, returning the overflow.
</span><span class="c1">// The items parameter is invalid after use.
</span><span class="n">ItemPtr</span><span class="n">pickupItems</span><span class="p">(</span><span class="n">ItemPtr</span><span class="k">const</span><span class="o">&amp;</span><span class="n">items</span><span class="p">);</span><span class="c1">// Pick up all of the given items as possible, dropping the overflow.
</span><span class="c1">// The item parameter is invalid after use.
</span><span class="kt">void</span><span class="n">giveItem</span><span class="p">(</span><span class="n">ItemPtr</span><span class="k">const</span><span class="o">&amp;</span><span class="n">item</span><span class="p">);</span><span class="kt">void</span><span class="n">triggerPickupEvents</span><span class="p">(</span><span class="n">ItemPtr</span><span class="k">const</span><span class="o">&amp;</span><span class="n">item</span><span class="p">);</span><span class="kt">bool</span><span class="n">hasItem</span><span class="p">(</span><span class="n">ItemDescriptor</span><span class="k">const</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">,</span><span class="kt">bool</span><span class="n">exactMatch</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span><span class="k">const</span><span class="p">;</span><span class="kt">size_t</span><span class="n">hasCountOfItem</span><span class="p">(</span><span class="n">ItemDescriptor</span><span class="k">const</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">,</span><span class="kt">bool</span><span class="n">exactMatch</span><span class="o">=</span><span class="nb">false</span><span class="p">)</span><span class="k">const</span><span class="p">;</span><span class="c1">// altough multiple entries may match, they might have different
</span><span class="c1">// serializations
</span><span class="n">ItemDescriptor</span><span class="n">takeItem</span><span class="p">(</span><span class="n">ItemDescriptor</span><span class="k">const</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">,</span><span class="kt">bool</span><span class="n">consumePartial</span><span class="o">=</span><span class="nb">false</span><span class="p">,</span><span class="kt">bool</span><span class="n">exactMatch</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span><span class="kt">void</span><span class="n">giveItem</span><span class="p">(</span><span class="n">ItemDescriptor</span><span class="k">const</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">);</span><span class="c1">// Clear the item swap slot.
</span><span class="kt">void</span><span class="n">clearSwap</span><span class="p">();</span><span class="c1">// Refresh worn equipment from the inventory
</span><span class="kt">void</span><span class="n">refreshEquipment</span><span class="p">();</span><span class="n">PlayerBlueprintsPtr</span><span class="n">blueprints</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">addBlueprint</span><span class="p">(</span><span class="n">ItemDescriptor</span><span class="k">const</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">,</span><span class="kt">bool</span><span class="n">showFailure</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span><span class="kt">bool</span><span class="n">blueprintKnown</span><span class="p">(</span><span class="n">ItemDescriptor</span><span class="k">const</span><span class="o">&amp;</span><span class="n">descriptor</span><span class="p">)</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">addCollectable</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">collectionName</span><span class="p">,</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">collectableName</span><span class="p">);</span><span class="n">PlayerUniverseMapPtr</span><span class="n">universeMap</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">PlayerCodexesPtr</span><span class="n">codexes</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">PlayerTechPtr</span><span class="n">techs</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">overrideTech</span><span class="p">(</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">StringList</span><span class="o">&gt;</span><span class="k">const</span><span class="o">&amp;</span><span class="n">techModules</span><span class="p">);</span><span class="kt">bool</span><span class="n">techOverridden</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">PlayerCompanionsPtr</span><span class="n">companions</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">PlayerLogPtr</span><span class="n">log</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">InteractiveEntityPtr</span><span class="n">bestInteractionEntity</span><span class="p">(</span><span class="kt">bool</span><span class="n">includeNearby</span><span class="p">);</span><span class="kt">void</span><span class="n">interactWithEntity</span><span class="p">(</span><span class="n">InteractiveEntityPtr</span><span class="n">entity</span><span class="p">);</span><span class="c1">// Aim this player's target at the given world position.
</span><span class="kt">void</span><span class="n">aim</span><span class="p">(</span><span class="n">Vec2F</span><span class="k">const</span><span class="o">&amp;</span><span class="n">position</span><span class="p">);</span><span class="n">Vec2F</span><span class="n">aimPosition</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">armPosition</span><span class="p">(</span><span class="n">ToolHand</span><span class="n">hand</span><span class="p">,</span><span class="n">Direction</span><span class="n">facingDirection</span><span class="p">,</span><span class="kt">float</span><span class="n">armAngle</span><span class="p">,</span><span class="n">Vec2F</span><span class="n">offset</span><span class="o">=</span><span class="p">{})</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">handOffset</span><span class="p">(</span><span class="n">ToolHand</span><span class="n">hand</span><span class="p">,</span><span class="n">Direction</span><span class="n">facingDirection</span><span class="p">)</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">handPosition</span><span class="p">(</span><span class="n">ToolHand</span><span class="n">hand</span><span class="p">,</span><span class="n">Vec2F</span><span class="k">const</span><span class="o">&amp;</span><span class="n">handOffset</span><span class="o">=</span><span class="p">{})</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">ItemPtr</span><span class="n">handItem</span><span class="p">(</span><span class="n">ToolHand</span><span class="n">hand</span><span class="p">)</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">armAdjustment</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">setCameraFocusEntity</span><span class="p">(</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="o">&gt;</span><span class="k">const</span><span class="o">&amp;</span><span class="n">cameraFocusEntity</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">playEmote</span><span class="p">(</span><span class="n">HumanoidEmote</span><span class="n">emote</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">canUseTool</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="c1">// "Fires" whatever is in the primary (left) item slot, or the primary fire
</span><span class="c1">// of the 2H item, at whatever the current aim position is.  Will auto-repeat
</span><span class="c1">// depending on the item auto repeat setting.
</span><span class="kt">void</span><span class="n">beginPrimaryFire</span><span class="p">();</span><span class="c1">// "Fires" whatever is in the alternate (right) item slot, or the alt fire of
</span><span class="c1">// the 2H item, at whatever the current aim position is.  Will auto-repeat
</span><span class="c1">// depending on the item auto repeat setting.
</span><span class="kt">void</span><span class="n">beginAltFire</span><span class="p">();</span><span class="kt">void</span><span class="n">endPrimaryFire</span><span class="p">();</span><span class="kt">void</span><span class="n">endAltFire</span><span class="p">();</span><span class="c1">// Triggered whenever the use key is pressed
</span><span class="kt">void</span><span class="n">beginTrigger</span><span class="p">();</span><span class="kt">void</span><span class="n">endTrigger</span><span class="p">();</span><span class="n">ItemPtr</span><span class="n">primaryHandItem</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">ItemPtr</span><span class="n">altHandItem</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">Uuid</span><span class="n">uuid</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">PlayerMode</span><span class="n">modeType</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">setModeType</span><span class="p">(</span><span class="n">PlayerMode</span><span class="n">mode</span><span class="p">);</span><span class="n">PlayerModeConfig</span><span class="n">modeConfig</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">ShipUpgrades</span><span class="n">shipUpgrades</span><span class="p">();</span><span class="kt">void</span><span class="n">setShipUpgrades</span><span class="p">(</span><span class="n">ShipUpgrades</span><span class="n">shipUpgrades</span><span class="p">);</span><span class="n">String</span><span class="n">name</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">setName</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">statusText</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">displayNametag</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">Vec3B</span><span class="n">nametagColor</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">setBodyDirectives</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">directives</span><span class="p">);</span><span class="kt">void</span><span class="n">setHairType</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">group</span><span class="p">,</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span><span class="kt">void</span><span class="n">setHairDirectives</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">directives</span><span class="p">);</span><span class="kt">void</span><span class="n">setEmoteDirectives</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">directives</span><span class="p">);</span><span class="kt">void</span><span class="n">setFacialHair</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">group</span><span class="p">,</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">directives</span><span class="p">);</span><span class="kt">void</span><span class="n">setFacialMask</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">group</span><span class="p">,</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">directives</span><span class="p">);</span><span class="n">String</span><span class="n">species</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">setSpecies</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">species</span><span class="p">);</span><span class="n">Gender</span><span class="n">gender</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">setGender</span><span class="p">(</span><span class="n">Gender</span><span class="k">const</span><span class="o">&amp;</span><span class="n">gender</span><span class="p">);</span><span class="kt">void</span><span class="n">setPersonality</span><span class="p">(</span><span class="n">Personality</span><span class="k">const</span><span class="o">&amp;</span><span class="n">personality</span><span class="p">);</span><span class="kt">void</span><span class="n">setAdmin</span><span class="p">(</span><span class="kt">bool</span><span class="n">isAdmin</span><span class="p">);</span><span class="kt">bool</span><span class="n">isAdmin</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">inToolRange</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">inToolRange</span><span class="p">(</span><span class="n">Vec2F</span><span class="k">const</span><span class="o">&amp;</span><span class="n">aimPos</span><span class="p">)</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">inInteractionRange</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">inInteractionRange</span><span class="p">(</span><span class="n">Vec2F</span><span class="n">aimPos</span><span class="p">)</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">addParticles</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Particle</span><span class="o">&gt;</span><span class="k">const</span><span class="o">&amp;</span><span class="n">particles</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">addSound</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">sound</span><span class="p">,</span><span class="kt">float</span><span class="n">volume</span><span class="o">=</span><span class="mf">1.0</span><span class="n">f</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">wireToolInUse</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">setWireConnector</span><span class="p">(</span><span class="n">WireConnector</span><span class="o">*</span><span class="n">wireConnector</span><span class="p">)</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">addEphemeralStatusEffects</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">EphemeralStatusEffect</span><span class="o">&gt;</span><span class="k">const</span><span class="o">&amp;</span><span class="n">statusEffects</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="n">ActiveUniqueStatusEffectSummary</span><span class="n">activeUniqueStatusEffectSummary</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">float</span><span class="n">powerMultiplier</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">isDead</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">kill</span><span class="p">();</span><span class="kt">void</span><span class="n">setFavoriteColor</span><span class="p">(</span><span class="n">Vec4B</span><span class="n">color</span><span class="p">);</span><span class="n">Vec4B</span><span class="n">favoriteColor</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="c1">// Starts the teleport animation sequence, locking player movement and
</span><span class="c1">// preventing some update code
</span><span class="kt">void</span><span class="n">teleportOut</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">animationType</span><span class="o">=</span><span class="s">"default"</span><span class="p">,</span><span class="kt">bool</span><span class="n">deploy</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span><span class="kt">void</span><span class="n">teleportIn</span><span class="p">();</span><span class="kt">void</span><span class="n">teleportAbort</span><span class="p">();</span><span class="kt">bool</span><span class="n">isTeleporting</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">isTeleportingOut</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">canDeploy</span><span class="p">();</span><span class="kt">void</span><span class="n">deployAbort</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">animationType</span><span class="o">=</span><span class="s">"default"</span><span class="p">);</span><span class="kt">bool</span><span class="n">isDeploying</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">isDeployed</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">setBusyState</span><span class="p">(</span><span class="n">PlayerBusyState</span><span class="n">busyState</span><span class="p">);</span><span class="c1">// A hard move to a specified location
</span><span class="kt">void</span><span class="n">moveTo</span><span class="p">(</span><span class="n">Vec2F</span><span class="k">const</span><span class="o">&amp;</span><span class="n">footPosition</span><span class="p">);</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="n">pullQueuedMessages</span><span class="p">();</span><span class="n">List</span><span class="o">&lt;</span><span class="n">ItemPtr</span><span class="o">&gt;</span><span class="n">pullQueuedItemDrops</span><span class="p">();</span><span class="kt">void</span><span class="n">queueUIMessage</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">message</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">queueItemPickupMessage</span><span class="p">(</span><span class="n">ItemPtr</span><span class="k">const</span><span class="o">&amp;</span><span class="n">item</span><span class="p">);</span><span class="kt">void</span><span class="n">addChatMessage</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">message</span><span class="p">);</span><span class="kt">void</span><span class="n">addEmote</span><span class="p">(</span><span class="n">HumanoidEmote</span><span class="k">const</span><span class="o">&amp;</span><span class="n">emote</span><span class="p">);</span><span class="n">List</span><span class="o">&lt;</span><span class="n">ChatAction</span><span class="o">&gt;</span><span class="n">pullPendingChatActions</span><span class="p">()</span><span class="k">override</span><span class="p">;</span><span class="kt">float</span><span class="n">beamGunRadius</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="kt">bool</span><span class="n">instrumentPlaying</span><span class="p">()</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">instrumentEquipped</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">instrumentKind</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">interact</span><span class="p">(</span><span class="n">InteractAction</span><span class="k">const</span><span class="o">&amp;</span><span class="n">action</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">addEffectEmitters</span><span class="p">(</span><span class="n">StringSet</span><span class="k">const</span><span class="o">&amp;</span><span class="n">emitters</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="kt">void</span><span class="n">requestEmote</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">emote</span><span class="p">)</span><span class="k">override</span><span class="p">;</span><span class="n">ActorMovementController</span><span class="o">*</span><span class="n">movementController</span><span class="p">()</span><span class="k">override</span><span class="p">;</span><span class="n">StatusController</span><span class="o">*</span><span class="n">statusController</span><span class="p">()</span><span class="k">override</span><span class="p">;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">PhysicsForceRegion</span><span class="o">&gt;</span><span class="n">forceRegions</span><span class="p">()</span><span class="k">const</span><span class="k">override</span><span class="p">;</span><span class="n">SongbookPtr</span><span class="n">songbook</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">finalizeCreation</span><span class="p">();</span><span class="kt">float</span><span class="n">timeSinceLastGaveDamage</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">EntityId</span><span class="n">lastDamagedTarget</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">invisible</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">void</span><span class="n">animatePortrait</span><span class="p">();</span><span class="kt">bool</span><span class="n">isOutside</span><span class="p">();</span><span class="kt">void</span><span class="n">dropSelectedItems</span><span class="p">(</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">ItemPtr</span><span class="p">)</span><span class="o">&gt;</span><span class="n">filter</span><span class="p">);</span><span class="kt">void</span><span class="n">dropEverything</span><span class="p">();</span><span class="kt">bool</span><span class="n">isPermaDead</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="kt">bool</span><span class="n">interruptRadioMessage</span><span class="p">();</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">RadioMessage</span><span class="o">&gt;</span><span class="n">pullPendingRadioMessage</span><span class="p">();</span><span class="kt">void</span><span class="n">queueRadioMessage</span><span class="p">(</span><span class="n">Json</span><span class="k">const</span><span class="o">&amp;</span><span class="n">messageConfig</span><span class="p">,</span><span class="kt">float</span><span class="n">delay</span><span class="o">=</span><span class="mi">0</span><span class="p">);</span><span class="kt">void</span><span class="n">queueRadioMessage</span><span class="p">(</span><span class="n">RadioMessage</span><span class="n">message</span><span class="p">);</span><span class="c1">// If a cinematic should play, returns it and clears it.  May stop cinematics
</span><span class="c1">// by returning a null Json.
</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="n">pullPendingCinematic</span><span class="p">();</span><span class="kt">void</span><span class="n">setPendingCinematic</span><span class="p">(</span><span class="n">Json</span><span class="k">const</span><span class="o">&amp;</span><span class="n">cinematic</span><span class="p">,</span><span class="kt">bool</span><span class="n">unique</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span><span class="kt">void</span><span class="n">setInCinematic</span><span class="p">(</span><span class="kt">bool</span><span class="n">inCinematic</span><span class="p">);</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">StringList</span><span class="o">&gt;</span><span class="p">,</span><span class="kt">float</span><span class="o">&gt;&gt;</span><span class="n">pullPendingAltMusic</span><span class="p">();</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">PlayerWarpRequest</span><span class="o">&gt;</span><span class="n">pullPendingWarp</span><span class="p">();</span><span class="kt">void</span><span class="n">setPendingWarp</span><span class="p">(</span><span class="n">String</span><span class="k">const</span><span class="o">&amp;</span><span class="n">action</span><span class="p">,</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="k">const</span><span class="o">&amp;</span><span class="n">animation</span><span class="o">=</span><span class="p">{},</span><span class="kt">bool</span><span class="n">deploy</span><span class="o">=</span><span class="nb">false</span><span class="p">);</span><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Json</span><span class="p">,</span><span class="n">RpcPromiseKeeper</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;&gt;&gt;</span><span class="n">pullPendingConfirmation</span><span class="p">();</span><span class="kt">void</span><span class="n">queueConfirmation</span><span class="p">(</span><span class="n">Json</span><span class="k">const</span><span class="o">&amp;</span><span class="n">dialogConfig</span><span class="p">,</span><span class="n">RpcPromiseKeeper</span><span class="o">&lt;</span><span class="n">Json</span><span class="o">&gt;</span><span class="k">const</span><span class="o">&amp;</span><span class="n">resultPromise</span><span class="p">);</span><span class="n">AiState</span><span class="k">const</span><span class="o">&amp;</span><span class="n">aiState</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="n">AiState</span><span class="o">&amp;</span><span class="n">aiState</span><span class="p">();</span><span class="c1">// In inspection mode, scannable, scanned, and interesting objects will be
</span><span class="c1">// rendered with special highlighting.
</span><span class="kt">bool</span><span class="n">inspecting</span><span class="p">()</span><span class="k">const</span><span class="p">;</span><span class="c1">// Will return the highlight effect to give an inspectable entity when inspecting
</span><span class="n">EntityHighlightEffect</span><span class="n">inspectionHighlight</span><span class="p">(</span><span class="n">InspectableEntityPtr</span><span class="k">const</span><span class="o">&amp;</span><span class="n">inspectableEntity</span><span class="p">)</span><span class="k">const</span><span class="p">;</span><span class="n">Vec2F</span><span class="n">cameraPosition</span><span class="p">();</span><span class="k">using</span><span class="n">Entity</span><span class="o">::</span><span class="n">setTeam</span><span class="p">;</span><span class="k">private</span><span class="o">:</span><span class="c1">// ...
</span><span class="p">};</span></code></pre></div></div><p>Interesting fact, there are many more methods than there are fields in Player,
somehow.  If you handed me a game and asked me to add a feature to the engine,
and asked me whether it would be easier to add in the “too much OO architecture”
vs “UR-architecture”, I’d say it’s easier in the “UR-architecture” almost
<em>every</em> time.  BUT it IS doable with effort obviously, because lots of Starbound
is like this :(.</p><p>So, this has downsides in C++, but not every game has as many crazy one-off
features as Starbound.  Maybe this is just an extreme example, and usually this
is not quite as bad of a problem?  Let’s see what happens if you try this in
Rust!  <em>Right off the bat</em>, things start to become <em>hard</em>.  Let’s go back to the
simplest OO version in C++:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// typedefs...
</span><span class="k">class</span><span class="nc">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="k">virtual</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="kt">void</span><span class="n">input</span><span class="p">(</span><span class="n">InputState</span><span class="k">const</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="kt">void</span><span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">*</span><span class="n">world</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="kt">void</span><span class="n">render</span><span class="p">(</span><span class="n">RenderState</span><span class="o">&amp;</span><span class="n">render_state</span><span class="p">)</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="p">};</span><span class="c1">// entity definitions...
</span><span class="k">struct</span><span class="n">World</span><span class="p">{</span><span class="n">List</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="o">&gt;</span><span class="n">player_ids</span><span class="p">;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="p">,</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;&gt;</span><span class="n">entities</span><span class="p">;</span><span class="p">...</span><span class="p">};</span></code></pre></div></div><p>Partially translating into Rust:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">trait</span><span class="n">Entity</span><span class="p">{</span><span class="k">fn</span><span class="nf">position</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="n">Vec2F</span><span class="p">;</span><span class="k">fn</span><span class="nf">input</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">,</span><span class="n">input_state</span><span class="p">:</span><span class="o">&amp;</span><span class="n">InputState</span><span class="p">);</span><span class="k">fn</span><span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">,</span><span class="n">world</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">World</span><span class="p">);</span><span class="k">fn</span><span class="nf">render</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">,</span><span class="n">render_state</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">RenderState</span><span class="p">);</span><span class="p">}</span><span class="k">pub</span><span class="k">struct</span><span class="n">World</span><span class="p">{</span><span class="n">player_ids</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="o">&gt;</span><span class="p">,</span><span class="n">entities</span><span class="p">:</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="p">,</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span></code></pre></div></div><p>Even in this tiny example you can already see this is going to be a huge pain.
First of all, World owns each Entity, but each Entity has a set of mutable
methods, one of which must take a mutable reference to World.  That won’t work,
because you will mutably borrow an Entity, and then have to mutably borrow it
<em>again</em> to pass in a World reference (which would presumably contain the self
Entity).  In order to do this, probably <em>every</em> Entity implementation would need
internal mutation because otherwise they would have no way to take a World
reference, and also World would probably need internal mutation because it too
would need to be passed by immutable reference.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">trait</span><span class="n">Entity</span><span class="p">{</span><span class="k">fn</span><span class="nf">position</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="n">Vec2F</span><span class="p">;</span><span class="k">fn</span><span class="nf">input</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span><span class="n">input_state</span><span class="p">:</span><span class="o">&amp;</span><span class="n">InputState</span><span class="p">);</span><span class="k">fn</span><span class="nf">update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span><span class="n">world</span><span class="p">:</span><span class="o">&amp;</span><span class="n">World</span><span class="p">);</span><span class="k">fn</span><span class="nf">render</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span><span class="n">render_state</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">RenderState</span><span class="p">);</span><span class="p">}</span><span class="k">pub</span><span class="k">struct</span><span class="n">World</span><span class="p">{</span><span class="n">player_ids</span><span class="p">:</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">entities</span><span class="p">:</span><span class="n">RefCell</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="p">,</span><span class="nb">Rc</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span></code></pre></div></div><p>Okay, now we won’t have borrow errors during entity updates, but now everything
has to be inside a RefCell?  Maybe we can place our entire state inside a
RefCell and it’s not so hard?  We’ve discussed the tendency for complex
behaviors to be very cross-cutting, so what if we have the following situation:</p><p>A monster damages a player, this triggers the player to play an audio as a hurt
sound effect, but for gameplay reasons this <em>also</em> triggers a logical sound that
other creatures can react to.  Maybe there is a swarming behavior for some
particular monster type?  So, hurting a player triggers an external mutation
(audio), internal mutation (health), which then maybe signals monsters which
have their own internal mutations (target entity).  Maybe this all was started
from a Monster, so the control flow goes from Monster to Player and <em>back into</em>
Monster.  If you’re debugging Monster, you now have triggered <em>spooky action at
a distance</em> by indirectly triggering mutation inside your own struct method.
Except, rust doesn’t allow this, (and this wouldn’t even type check probably
without RefCell), so in rust the version of this is that you simply get a
RefCell panic.</p><p>Let’s keep going, say entities have some kind of tag or dynamic set of tags, and
let’s add that to our C++ Entity interface:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span><span class="nc">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="k">virtual</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="k">virtual</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Tag</span><span class="o">&gt;</span><span class="n">tags</span><span class="p">()</span><span class="k">const</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="p">};</span></code></pre></div></div><p>Say you profile your game and simply returning a copy of <code class="highlighter-rouge">List&lt;Tag&gt;</code> is eating
up huge CPU time, so you change the interface to this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span><span class="nc">Entity</span><span class="p">{</span><span class="k">public</span><span class="o">:</span><span class="k">virtual</span><span class="n">Vec2F</span><span class="n">position</span><span class="p">()</span><span class="k">const</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="k">virtual</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Tag</span><span class="o">&gt;</span><span class="k">const</span><span class="o">&amp;</span><span class="n">tags</span><span class="p">()</span><span class="k">const</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="p">};</span></code></pre></div></div><p>This is assuming such a change is possible and not a use after free bug waiting
to happen, which it often is.  Well, Rust is supposed to save us from use after
free, so what happens if you translate this to the Rust version:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">trait</span><span class="n">Entity</span><span class="p">{</span><span class="k">fn</span><span class="nf">position</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="n">Vec2F</span><span class="p">;</span><span class="k">fn</span><span class="n">tags</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="o">&amp;</span><span class="nv">'a</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Tag</span><span class="o">&gt;</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>I’ve made the lifetimes un-elided to make it obvious, but what this says is that
this method returns a single Vec reference that borrows <em>the entire entity</em>.
That’s.. helpful but also not at all helpful if you want to later call any other
method that might mutate.  If this has internal mutation and is inside a
RefCell, this is also impossible and would have to instead return
<code class="highlighter-rouge">std::cell::Ref</code>.  Everything is hard, much harder than it is in C++.  You go
onto IRC to ask for help, you get the well meaning but potentially unhelpful
answer: “You’re just still in the phase where you’re fighting the borrow
checker.”</p><p>It can get even worse. Entity is pretty sparse, even the real <code class="highlighter-rouge">Entity</code> inside
Starbound, but say you apply these same principles to <code class="highlighter-rouge">World</code>:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">struct</span><span class="n">World</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">impl</span><span class="n">World</span><span class="p">{</span><span class="k">fn</span><span class="n">tile</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span><span class="k">self</span><span class="p">,</span><span class="n">index</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="k">-&gt;</span><span class="o">&amp;</span><span class="nv">'a</span><span class="n">WorldTile</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="c">// HUGE number of additional members...</span><span class="p">}</span></code></pre></div></div><p>If you have a big enough <code class="highlighter-rouge">World</code> structure, even in the absence of things like
pure virtual interfaces (or in Rust, traits), you can still run into problems.
Should accessing one tile borrow the <em>entire world</em>?  Things would be much
easier if you could somehow borrow only <em>part</em> of the world and thus allow you
to mutate some other part, and that’s exactly what you could do were all the
fields of World simply public.  Rust is quite good at splitting borrows of a
struct, but by design, it cannot do that for such an opaque method.  This would
be vastly easier if simply World was a struct with plain public members.  This
becomes MORE important the larger the structure is, and data hiding becomes less
important the more into the “application” level you are.  With games this
becomes worse and worse, because your games become more and more complicated
over time as you add features.  We’re not trying to write an engine, we’re just
trying to write a simple game directly in Rust, all of that data has to go
somewhere!</p><p>If you’re writing a method like this, it’s more obvious that you can make fields
of a large compound structure public and split borrows will help, but imagine
that you didn’t design things this way.  Imagine instead that you have <em>two</em>
kinds of Worlds, one for the Server and one for the Client.  This is precisely
how Starbound works, and there is a large complex interface for a “world” that
is common between the client and server.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">trait</span><span class="n">World</span><span class="p">{</span><span class="k">fn</span><span class="n">tile</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span><span class="k">self</span><span class="p">,</span><span class="n">index</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="k">-&gt;</span><span class="o">&amp;</span><span class="nv">'a</span><span class="n">WorldTile</span><span class="p">;</span><span class="c">// HUGE number of additional trait methods...</span><span class="p">}</span></code></pre></div></div><p>Now it’s <em>impossible</em> to “just allow the fields to be public” regardless of “OO”
principles or not, just like Entity.  More “fighting the borrow checker”.  OO
principles guide you to having the loosest coupling you can, and a very common
strategy for this is to, rather than having objects depend on each other
directly, that they would depend on each other through a pure interface.
Starbound is <em>chock full</em> of these, Entity and World are only two.  They
<em>amplify</em> borrowing problems by <em>amplifying</em> the amount you are forced to
borrow!</p><p>I don’t think I can <em>completely</em> fully justify everything I’m saying inside a 30
minute talk, this is really only scratching the surface, but hopefully I’ve
given you at least an <em>idea</em> of where I’m coming from.  I know that for some of
you this is going to sound VERY subjective and possibly only sound like useful
advice for a specific type of software (games).  Also, for a lot of you, this is
maybe boring and you already knew all this, but it’s still hopefully helpful to
see this as it pertains to an industry which not everyone is part of.</p><p>But, that being said, here are some of my takeaways:</p><ul><li>For games, OO doesn’t really help, at all.  The parts of OO that are useful
which I listed above are fine, but at the point where you’re not writing
“library” code and are actually writing a game, data hiding is NOT generally
useful, and just wastes a lot of effort and time.  The more data your game
has, the more it changes because you’re constantly experimenting, the worse
this gets.  This might be old news to you!</li><li>Thinking about “objects” vs data types in a game sounds superficially
appealing, but it’s actually actively harmful.  Most behavior doesn’t
“attach” to any data, and if you start thinking about things that way it can
be hard to stop.  Stop conflating the data representation of your game with
the systems that operate on it!</li><li>Sometimes I think I would rather deal with a single 12k line mega-procedure
than a tangled ball of objects.</li><li>Carmack quote: “Sometimes, the elegant implementation is just a function.
Not a method.  Not a class.  Not a framework.  Just a function.”</li><li>Sometimes if you have to write a lot of messy procedural state changes, just
being honest about it with long (maybe not 12k lines) procedures is the best
strategy.  Just be honest about the messiness of what’s happening, hiding it
in other functions or methods doesn’t help, it only makes it more confusing
when it goes wrong.  If you can pull things out that are simple and pure
functions, do it, but leave the messy procedural truth as it is!
<a href="http://number-none.com/blow/john_carmack_on_inlined_code.html">Another Carmack thing</a></li><li><p>I find it really easy and enlightening to think about the types of
structures that determine the state of a game.  You can often learn almost
everything you need to know from taking a code base and just looking at all
the type definitions.  If you’re looking at C++, if you just look at the
struct members and their relationships and ignore all the code, this will
often tell you more than looking at say, the names of functions.  I spent a
lot of time reading Haskell code and they had this pattern that’s often
mimicked in Rust where they would have a module called “Types” that just
had… all the types that were required in some library.  I kind of like
that, and I think Rust is really great at this kind of programming.</p><p>I’m being a bit cheeky here, but what tells you more, this interface:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span><span class="nc">World</span><span class="p">{</span><span class="n">List</span><span class="o">&lt;</span><span class="n">EntityPtr</span><span class="o">&gt;</span><span class="n">entityQuery</span><span class="p">(</span><span class="n">RectF</span><span class="k">const</span><span class="o">&amp;</span><span class="n">boundBox</span><span class="p">)</span><span class="k">const</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="p">...</span><span class="p">}</span></code></pre></div></div><p>or this struct definition:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="n">World</span><span class="p">{</span><span class="n">SpatialHash2D</span><span class="o">&lt;</span><span class="n">EntityId</span><span class="p">,</span><span class="kt">float</span><span class="p">,</span><span class="n">EntityPtr</span><span class="o">&gt;</span><span class="n">entitySpatialMap</span><span class="p">;</span><span class="p">...</span><span class="p">};</span></code></pre></div></div><p>Obviously a lot of the information here comes from the <em>names</em> of the types,
and clearly <code class="highlighter-rouge">SpatialHash2D</code> is some struct of its own with its own
sub-types, but if you name your types well the point still stands, you see
an obvious trail of bread crumbs to follow to understand what an interface
may hide from you (That your spatial entity queries are probably going to be
fast and you shouldn’t expect a query to take linear time in the number of
entities).</p></li></ul><p>I asked if we could use OO to improve our UR-architecture, and surprisingly we
largely <em>can’t</em>.  Useful things like the dot operator and data hiding to
maintain invariants in library-ish code aside, the large scale structure of our
game is not really helped by OO.  We need some way to deal with the downsides of
a single giant mutable public nested struct without making an OO mess.  We’re
now approaching the ECS answer from the top down.</p><h2 id="back-to-the-beginning">Back to the beginning.</h2><p>Our “OO-architecture” was a complete bust in Rust, so let’s start over with
something we know will work, our “UR-architecture” and try to improve it.  This
is a pretty standard ECS transformation, and you may have seen this before.
I’ve read a bunch of ECS explanations before and I know of one fairly good one,
and <em>lots</em> of really confusing bad ones, and hopefully I can explain this in a
nice way that focuses on the <em>data</em> representation, and is useful to Rust
specifically.</p><p>Let’s start from the beginning with our simplistic “Starbound”, writing down
what the state representation of our game is again, but this time in Rust.  No
methods, no functions, only the data types.  This will be very similar to the
Mario 64 example “UR-architecture” above, with a few small additions:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="n">EntityIndex</span><span class="o">=</span><span class="nb">usize</span><span class="p">;</span><span class="k">struct</span><span class="n">Physics</span><span class="p">{</span><span class="n">position</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="n">velocity</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="n">mass</span><span class="p">:</span><span class="nb">f32</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidAnimationState</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidItem</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidState</span><span class="p">{</span><span class="n">animation_state</span><span class="p">:</span><span class="n">HumanoidAnimationState</span><span class="p">,</span><span class="n">left_hand_item</span><span class="p">:</span><span class="n">HumanoidItem</span><span class="p">,</span><span class="n">right_hand_item</span><span class="p">:</span><span class="n">HumanoidItem</span><span class="p">,</span><span class="n">aim_position</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">Player</span><span class="p">{</span><span class="n">physics</span><span class="p">:</span><span class="n">Physics</span><span class="p">,</span><span class="n">humanoid</span><span class="p">:</span><span class="n">HumanoidState</span><span class="p">,</span><span class="n">health</span><span class="p">:</span><span class="nb">f32</span><span class="p">,</span><span class="n">focused_entity</span><span class="p">:</span><span class="n">EntityIndex</span><span class="p">,</span><span class="n">food_level</span><span class="p">:</span><span class="nb">f32</span><span class="p">,</span><span class="n">admin</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span><span class="o">...</span><span class="p">}</span><span class="k">enum</span><span class="n">MonsterAnimationState</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">DamageRegion</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">Monster</span><span class="p">{</span><span class="n">physics</span><span class="p">:</span><span class="n">Physics</span><span class="p">,</span><span class="n">animation_state</span><span class="p">:</span><span class="n">MonsterAnimationState</span><span class="p">,</span><span class="n">health</span><span class="p">:</span><span class="nb">f32</span><span class="p">,</span><span class="n">current_target</span><span class="p">:</span><span class="n">EntityIndex</span><span class="p">,</span><span class="n">damage_region</span><span class="p">:</span><span class="n">DamageRegion</span><span class="p">,</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">NpcBehavior</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">Npc</span><span class="p">{</span><span class="n">physics</span><span class="p">:</span><span class="n">Physics</span><span class="p">,</span><span class="n">humanoid</span><span class="p">:</span><span class="n">HumanoidState</span><span class="p">,</span><span class="n">health</span><span class="p">:</span><span class="nb">f32</span><span class="p">,</span><span class="n">behavior</span><span class="p">:</span><span class="n">NpcBehavior</span><span class="p">,</span><span class="o">...</span><span class="p">}</span><span class="k">enum</span><span class="n">Entity</span><span class="p">{</span><span class="nf">Player</span><span class="p">(</span><span class="n">Player</span><span class="p">),</span><span class="nf">Monster</span><span class="p">(</span><span class="n">Monster</span><span class="p">),</span><span class="nf">Npc</span><span class="p">(</span><span class="n">Npc</span><span class="p">),</span><span class="p">}</span><span class="k">struct</span><span class="n">Assets</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">GameState</span><span class="p">{</span><span class="n">assets</span><span class="p">:</span><span class="n">Assets</span><span class="p">,</span><span class="n">entities</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">players</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">EntityIndex</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span><span class="k">fn</span><span class="nf">main</span><span class="p">()</span><span class="p">{</span><span class="k">let</span><span class="k">mut</span><span class="n">game_state</span><span class="o">=</span><span class="nf">initial_game_state</span><span class="p">();</span><span class="k">loop</span><span class="p">{</span><span class="k">let</span><span class="n">input_state</span><span class="o">=</span><span class="nf">capture_input_state</span><span class="p">();</span><span class="nf">player_control_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">,</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">);</span><span class="nf">npc_behavior_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">);</span><span class="nf">monster_behavior_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">);</span><span class="nf">physics_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">);</span><span class="c">// ... lots more systems</span><span class="nf">render_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game</span><span class="p">);</span><span class="nf">audio_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game</span><span class="p">);</span><span class="nf">wait_vsync</span><span class="p">();</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>There are a few changes from the Mario 64 example.  For one, we’re trying to use
Rust features like enums and data types like Option, rather than trying so hard
to mirror C.  The great thing about this, is suddenly the structure of our game
state has less possible invalid states!  For example, here if we had tried to
use a unified “Entity” with a type code, like Mario 64, there would be
invariants that had to be kept manually stating that certain fields were in
sensible states depending on the type of the entity.  Now, many of these
invariants just fall naturally out because sum types are so great.  This is
interesting, because it makes encapsulation less important, even with everything
public, there are certain invariants that cannot be broken.  There ARE
invariants that aren’t expressible in this way though, an example being that the
array of player ids probably need to point to Player type entities only!</p><p>The <code class="highlighter-rouge">entities: Vec&lt;Option&lt;Entity&gt;&gt;</code> is interesting as well.  Since some of our
entities keep indexes to this array as “pointers” to other entities, it makes
sense that we should never move an entity in the array.  If we allocate a bunch
of entities then remove the first entity we allocated, instead of moving every
entity, we need to set it to None instead so that the rest of the array stays in
place.  When allocating, we probably would go through the array looking for the
first None empty slot, and if none are found, push a new entity onto the end.
This is interesting, because this is very similar to how the “Mario 64” example
worked with a static array.</p><p>Other than these changes, this is not really a huge departure.  All of the game
state is still morally global, and each system is still potentially large and
procedural.  Here’s the thing though… I actually don’t think this is very bad
at all?  In all honesty, if I were doing a game jam game, this might be how I
would write my game!</p><p>I wouldn’t write low level graphics or audio code, but if I were doing a simple
2D game or very simple 3D game, this would work for me.  My game state might be
a pretty complex struct full of other structs, and I might have many “systems”
(which remember here are just regular functions) in different files, and this
would be fine.  I would choose a very simple graphics API with as little state
as possible, to reduce as much as possible the headache of “loading” and
“unloading” graphics data and the same with the audio API, and this would be the
structure of my game.  If I had to use a very messy and stateful graphics or
audio system, I would pre-load everything when creating the game state
initially, stick all of it inside some Assets structure, and that would be it.
There are plenty of high level level graphics and sound APIs for Rust that
actually make this really easy.</p><p>But, this pattern is obviously not perfect, even other than everything being
globally public.  For one, there’s a lot of repeated data in each of our entity
types, e.g. with <code class="highlighter-rouge">Physics</code> being repeated across Player, Monster, and Npc.  In
our <code class="highlighter-rouge">physics_system</code> function, probably there is some commonality in this system
which is broken down further into another function, but the <code class="highlighter-rouge">physics_system</code>
definitely <em>for sure</em> has to understand that there are 3 separate entity types
that all have physics.  Whenever we add an entity type, probably this system has
to change its implementation, and honestly probably <em>very many</em> systems have to
change when you add entity types.</p><p>Also, as we add more entities, we’ll probably start to find out that a large
part of them will be repeated over and over.  Maybe “Monster” is too specific,
and you split this up between “FlyingMonster” and “GroundMonster”, but they
share 80% of the same fields, and in turn both of those share 50% of their
fields with Player.</p><p>This is in some ways better than having all entities be one unified type, but in
some ways actually it’s kind of worse?  It’s not terrible, but let’s see if we
can do better.  Let’s go back to having a unified Entity type like the Mario 64
example:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="n">EntityIndex</span><span class="o">=</span><span class="nb">usize</span><span class="p">;</span><span class="c">// All the different types of fields that an Entity can have, grouped somewhat</span><span class="c">// logically...</span><span class="k">struct</span><span class="n">Physics</span><span class="p">{</span><span class="n">position</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="n">velocity</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="n">mass</span><span class="p">:</span><span class="nb">f32</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidAnimationState</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidItem</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">enum</span><span class="n">MonsterAnimationState</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">DamageRegion</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">NpcBehavior</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidState</span><span class="p">{</span><span class="n">animation_state</span><span class="p">:</span><span class="n">HumanoidAnimationState</span><span class="p">,</span><span class="n">left_hand_item</span><span class="p">:</span><span class="n">HumanoidItem</span><span class="p">,</span><span class="n">right_hand_item</span><span class="p">:</span><span class="n">HumanoidItem</span><span class="p">,</span><span class="n">aim_position</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">PlayerState</span><span class="p">{</span><span class="n">focused_entity</span><span class="p">:</span><span class="n">EntityIndex</span><span class="p">,</span><span class="n">food_level</span><span class="p">:</span><span class="nb">f32</span><span class="p">,</span><span class="n">admin</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">MonsterState</span><span class="p">{</span><span class="n">current_target</span><span class="p">:</span><span class="n">EntityIndex</span><span class="p">,</span><span class="n">animation_state</span><span class="p">:</span><span class="n">MonsterAnimationState</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">NpcState</span><span class="p">{</span><span class="n">behavior</span><span class="p">:</span><span class="n">NpcBehavior</span><span class="p">,</span><span class="p">}</span><span class="c">// An entity is a collection of all the possible entity fields, we let every one</span><span class="c">// of them be optional.  In this case, we have lost some type safety, because</span><span class="c">// this can express more invalid states than our previous example, some of these</span><span class="c">// combinations probably don't make sense.  Also, maybe right now it doesn't</span><span class="c">// make sense for an entity to be missing a position, so all entities have to</span><span class="c">// have physics even though it's optional here.</span><span class="k">struct</span><span class="n">Entity</span><span class="p">{</span><span class="n">physics</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Physics</span><span class="o">&gt;</span><span class="p">,</span><span class="n">health</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="n">humanoid</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">HumanoidState</span><span class="o">&gt;</span><span class="p">,</span><span class="n">player</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">PlayerState</span><span class="o">&gt;</span><span class="p">,</span><span class="n">monster</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">MonsterState</span><span class="o">&gt;</span><span class="p">,</span><span class="n">npc</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">NpcState</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">Assets</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">GameState</span><span class="p">{</span><span class="n">assets</span><span class="p">:</span><span class="n">Assets</span><span class="p">,</span><span class="n">entities</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">players</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">EntityIndex</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span><span class="k">fn</span><span class="nf">main</span><span class="p">()</span><span class="p">{</span><span class="k">let</span><span class="k">mut</span><span class="n">game_state</span><span class="o">=</span><span class="nf">initial_game_state</span><span class="p">();</span><span class="k">loop</span><span class="p">{</span><span class="k">let</span><span class="n">input_state</span><span class="o">=</span><span class="nf">capture_input_state</span><span class="p">();</span><span class="nf">player_control_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">,</span><span class="o">&amp;</span><span class="n">input_state</span><span class="p">);</span><span class="nf">npc_behavior_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">);</span><span class="nf">monster_behavior_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">);</span><span class="nf">physics_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game_state</span><span class="p">);</span><span class="c">// ... lots more systems</span><span class="nf">render_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game</span><span class="p">);</span><span class="nf">audio_system</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">game</span><span class="p">);</span><span class="nf">wait_vsync</span><span class="p">();</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>Okay, so this is interesting.  It’s clear that we lose some invariants here in
that more potentially invalid entities could be created, but there are some big
advantages here.  One that stands out is that our implementation of
<code class="highlighter-rouge">physics_system</code> is probably vastly simplified, just loop over all the entities
and mutate the <code class="highlighter-rouge">physics</code> field if they have one.  This is much simpler than
looping over the entities and having to match on the entity type.</p><p>There are still structures that are only valid for each of our “logical” entity
types though, and clearly it probably wouldn’t make sense for something to be
both an NPC <em>and</em> a Monster at the same time, so this is I guess another
invariant to keep.  It’s interesting though, because the amount of per-“type”
data got smaller.  Let’s change this a bit more and separate out more fields:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="n">Physics</span><span class="p">{</span><span class="n">position</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="n">velocity</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="n">mass</span><span class="p">:</span><span class="nb">f32</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidAnimation</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidItems</span><span class="p">{</span><span class="n">left_hand_item</span><span class="p">:</span><span class="n">HumanoidItem</span><span class="p">,</span><span class="n">right_hand_item</span><span class="p">:</span><span class="n">HumanoidItem</span><span class="p">,</span><span class="n">aim_position</span><span class="p">:</span><span class="n">Vector2</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">MonsterAnimation</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">NpcBehavior</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">Aggression</span><span class="p">{</span><span class="n">current_target</span><span class="p">:</span><span class="n">EntityIndex</span><span class="p">,</span><span class="p">}</span><span class="c">// Just for symmetry, let's let Health be a struct type</span><span class="k">struct</span><span class="nf">Health</span><span class="p">(</span><span class="nb">f32</span><span class="p">);</span><span class="k">struct</span><span class="n">Hunger</span><span class="p">{</span><span class="n">food_level</span><span class="p">:</span><span class="nb">f32</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">PlayerState</span><span class="p">{</span><span class="n">focused_entity</span><span class="p">:</span><span class="n">EntityIndex</span><span class="p">,</span><span class="n">admin</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span><span class="p">}</span><span class="k">struct</span><span class="n">Entity</span><span class="p">{</span><span class="n">physics</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Physics</span><span class="o">&gt;</span><span class="p">,</span><span class="n">huamnoid_animation</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">HumanoidAnimation</span><span class="o">&gt;</span><span class="p">,</span><span class="n">humanoid_items</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">HumanoidItems</span><span class="o">&gt;</span><span class="p">,</span><span class="n">monster_animation</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">MonsterAnimation</span><span class="o">&gt;</span><span class="p">,</span><span class="n">npc_behavior</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">NpcBehavior</span><span class="o">&gt;</span><span class="p">,</span><span class="n">health</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Health</span><span class="o">&gt;</span><span class="p">,</span><span class="n">hunger</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Hunger</span><span class="o">&gt;</span><span class="p">,</span><span class="n">player</span><span class="p">:</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">PlayerState</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span></code></pre></div></div><p>So there are lots and lots of ways to express the fields that may go into each
entity, and they all have their advantages and disadvantages.  In this case,
after transforming our field types this way, a couple of things become
expressible that weren’t before!  For example, since we’ve broken out the
<code class="highlighter-rouge">food_level</code> field from Player and called it <code class="highlighter-rouge">Hunger</code>, we can now express entity
types that aren’t Players that are hungry, so now we can describe NPCs with
hunger.  Also, after breaking out <code class="highlighter-rouge">Aggression</code>, we can express hostile NPCs!
However, maybe we can express something with monster-type animation that also
can carry humanoid items, and maybe this is actually logically invalid, so there
is a give and take here.  Still, this is interesting, and solves the problem
where there is much commonality between our entity types that requires repeated
code to express or extract from monolithic enums.</p><p>Now, it may be very clear where I’m going with this already, but this pattern,
where entities are composed of one or more of a set of named parts, and they are
specified a la carte, is very common.  In fact, these parts are normally called
“components”!  We now have all of Entities, Components, and Systems, so if you
squint this is everything needed to be an “ECS” system, but this is actually
very simple!  By focusing on the data representation of our state, it is really
not very many steps in between this and what we started with.</p><p>Let’s make one more actually sort of inconsequential change, but this will help
us in a second.  Also, we’ll start calling all of these pieces we’ve been
defining “components” just to drive the point home:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="n">PhysicsComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidAnimationComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidItemsComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">MonsterAnimationComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">NpcBehaviorComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">AggressionComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HealthComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HungerComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">PlayerComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">type</span><span class="n">EntityIndex</span><span class="o">=</span><span class="nb">usize</span><span class="p">;</span><span class="k">struct</span><span class="n">Assets</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">GameState</span><span class="p">{</span><span class="n">assets</span><span class="p">:</span><span class="n">Assets</span><span class="p">,</span><span class="c">// All of these component vecs must be the same length, which is the current</span><span class="c">// number of entities.</span><span class="n">physics_components</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">PhysicsComponent</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">humanoid_animation_components</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">HumanoidAnimationComponent</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">humanoid_items_components</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">HumanoidItemsComponent</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">monster_animation_components</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">MonsterAnimationComponent</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">npc_behavior_components</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">NpcBehaviorComponent</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">aggression_components</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">AggressionComponent</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">health_components</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">HealthComponent</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">hunger_components</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">HungerComponents</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">player_components</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">PlayerComponents</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">players</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">EntityIndex</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span></code></pre></div></div><p>This is the classic “array of structs” to “struct of arrays” transform.  It
should be clear that (nearly) exactly the same information is expressible
between this and the previous representation.  There are a few new invariants to
maintain, namely that each component Vec is the same length, but there’s not
really new information.  When you just write out types like this, these kinds of
changes actually look pretty simple, instead of in our OO architecture where
something like this might be considered an impossible refactor.  Obviously we’d
have to change the systems a lot here too potentially every time we made these
changes, but there’s value in being able to think about the data independently.</p><p>The transformation to “structs of arrays” is generally the thing that ECS
introductions really focus on, and then they start talking about performance
concerns and cache behavior and it can be a little confusing and overwhelming.
They’re not wrong, but I really don’t think this is the important part.  This is
why I’ve introduced ECS this way, because I think a lot of explanations miss
this point, that from a certain perspective, these changes are actually pretty
boring and normal.  You might have this structure or you might have the previous
structure, maybe one is better performing than the other, but you have not
radically changed programming paradigms by choosing one vs the other.  From a
data-oriented perspective, these things are not earth shattering, they’re just
performance optimizations.  There are lots MORE potential optimizations you can
do here as well, but I think we’ve reached the point where we have a
bare-minimum that somebody might call an “ECS system”.</p><p>There are some takeaways here for Rust users in general, not just game
developers:</p><ul><li>Thinking about JUST the structure of state is really powerful, often times
“methods” and “objects” get in the way.  Nobody really thinks that having
methods on your structs is “too much OO”, but it DOES couple your procedures
to your data, even if only organizationally.  Both data structure design and
simple module organization are important, but don’t conflate them!  I’m
convinced that “ECS design” in games is so great because it forces you to
think about your data rather than be stuck in OO mode, not because of the
magic of “structs of arrays”.  This is a lesson that can be applied to Rust
in general.</li><li>You can do a LOT with indexes into Vecs.  This is way easier than self
borrowing or Rc&lt;RefCell<t>&gt;.</t></li></ul><p>Okay, let’s stop for a second and talk about <code class="highlighter-rouge">EntityIndex</code>.  I genuinely think
that most of the time when you find yourself running into self borrowing with
Rust, plain Vecs and indexes should first tool you reach for.  There are OTHER
tools, like various arena crates, rental etc, but I think that generally you
should try Vec first.  Generally these problems happen when trying to represent
some kind of graph structure (and an ECS is just a really flat graph… kind
of), and <em>even in C++</em> this is the advice generally given!  (See Andrei
Alexandrescu’s performance talks, his favorite data structure in the world is
std::vector, “just use vector!”)  Things like Arena allocators are great and
actually quite performant, and there are versions that work with multiple types,
but they can’t be ‘static without the addition of self-borrowing.  Self
borrowing solutions like rental are tools of <em>last resort</em>.  It is not worth it,
move on with your life, and just use Vecs and indexes.</p><p>THAT BEING SAID, they have do have some problems.  In our entity examples, we’ve
been glossing over the question of how to find “free” EntityIndexes, and how
“deletion” works, because it’s not actually terribly great.  The cost of
allocating an “entity” is not constant because we have to scan through a Vec
looking for free entries.  Deleting an entity is cheaper, but it has bad
properties.  We can delete an entity which frees up a slot in a Vec, but then
it’s possible that the very next allocated entity will use the same index.  This
is fine if we make sure that there are no outstanding “index references” to this
entity before deletion, but what if we mess that up?  We’ll get a “random other
entity” in its place without being able to tell that it was in fact removed out
from under us!.  Also, both of these situations are now much worse after the
“struct of arrays” transform, because we now have multiple arrays instead of one
and how we manage “entity indexes” is kind of up in the air now.  We’re going to
solve both of these problems at once.</p><h2 id="generational-indexes-are-awesome">Generational indexes are awesome.</h2><p>So this is one of my favorite patterns that I’m not sure is widely known in the
Rust community but I believe is widely known in the gamedev one.</p><p>We’ve been using <code class="highlighter-rouge">EntityIndex</code> to identify and look up entities stored inside a
Vec.  This is very similar to the pattern I used in the C++ mini-Starbound, I
used an <code class="highlighter-rouge">EntityId</code> which was an increasing integer id to store entities like
this:</p><p><code class="highlighter-rouge">HashMap&lt;EntityId, shared_ptr&lt;Entity&gt;&gt; entities;</code></p><p>Both are abstract mappings from integers to some value.  In the Vec case, it is
basically the fastest POSSIBLE data structure, indexing into an array, and in
the case of <code class="highlighter-rouge">HashMap</code> it is much slower, but the <code class="highlighter-rouge">HashMap</code> is much more
flexible!  For one thing, there is only an upper bound really on the total
number of entries, not on, say the largest size of the index.  <code class="highlighter-rouge">HashMap</code> works
just as well if you start the keys at value 1,000,000,000 or 1, certainly a
billion entry Vec is different than a 1 sized one.  This matters for the
deletion problem above.  If we indexed using a HashMap and a key type of <code class="highlighter-rouge">u32</code>
or even <code class="highlighter-rouge">u64</code>, we could just have new indexes always increment (with eventual
wrap-around).  In this way, you could more or less guarantee that no index would
ever be re-used, or at the VERY least it would be a “very long time” before an
index would be reused.  In the <code class="highlighter-rouge">u64</code> case, if you ever re-used an index, your
game technology probably has “cloud” in the name, so you might have bigger
problems anyway :).  BUT HashMap is much slower than Vec :(</p><p>Is there a way to get this property with integer indexes into a Vec?  There is,
and it’s called “generational indexes”!</p><p>Instead of using just an integer index, we make a “generational index” type like
this:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// You can use other types that usize / u64 if these are too large</span><span class="nd">#[derive(Eq,</span><span class="nd">PartialEq,</span><span class="nd">etc</span><span class="err">...</span><span class="nd">)]</span><span class="k">pub</span><span class="k">struct</span><span class="n">GenerationalIndex</span><span class="p">{</span><span class="n">index</span><span class="p">:</span><span class="nb">usize</span><span class="p">,</span><span class="n">generation</span><span class="p">:</span><span class="nb">u64</span><span class="p">,</span><span class="p">}</span><span class="k">impl</span><span class="n">GenerationalIndex</span><span class="p">{</span><span class="k">pub</span><span class="nf">index</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">usize</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>Then, we make something called an “GenerationalIndexAllocator”:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="n">AllocatorEntry</span><span class="p">{</span><span class="n">is_live</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span><span class="n">generation</span><span class="p">:</span><span class="nb">u64</span><span class="p">,</span><span class="p">}</span><span class="k">pub</span><span class="k">struct</span><span class="n">GenerationalIndexAllocator</span><span class="p">{</span><span class="n">entries</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">AllocatorEntry</span><span class="o">&gt;</span><span class="p">,</span><span class="n">free</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="p">}</span><span class="k">impl</span><span class="n">GenerationalIndexAllocator</span><span class="p">{</span><span class="k">pub</span><span class="k">fn</span><span class="nf">allocate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="n">GenerationalIndex</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="c">// Returns true if the index was allocated before and is now deallocated</span><span class="k">pub</span><span class="k">fn</span><span class="nf">deallocate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">,</span><span class="n">index</span><span class="p">:</span><span class="n">GenerationalIndex</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">bool</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">pub</span><span class="k">fn</span><span class="nf">is_live</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span><span class="n">index</span><span class="p">:</span><span class="n">GenerationalIndex</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">bool</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>(There are faster ways to implement this, but this one is actually pretty much
fine.  Also note that this is an obviously GOOD use of data hiding).</p><p>The basic idea is that you can “allocate” indexes for a vector just like if you
had <code class="highlighter-rouge">Vec&lt;Option&lt;Entry&gt;&gt;</code>, but you will instead never re-use indexes.  It works
like this, you allocate an index and get back a <code class="highlighter-rouge">GenerationalIndex</code> with real
index 0, it will also have “generation” 0.  If you delete that index, it will go
into a pool of free indexes, so next time you allocate an index you might get
back another generational index with real index 0, but crucially the generation
will now be 1.  Generational indexes are never re-used because the generation
will always increment, yet the “real indexes” will always be “small”, on the
order of the largest total number of entries ever allocated.  This way, you can
use fast indexing into a Vec without many of the bad “pointer-like” properties
of simple indexes!</p><p>I said this pattern is not widely known inside the Rust community, but that’s at
least a bit of a lie because there is a recently released crate built on this
idea called “slotmap” and it’s great!  However, it’s missing a CRUCIAL feature
for our example, which is that in “slotmap” you can only allocate indexes for a
specific SlotMap, you can’t allocate indexes and re-use them for different
SlotMaps.  Useful, but it would be vastly MORE useful if these concepts were
separate, which is what we’ve sketched out here.  Indexes into a Vec are already
a great pattern when encountering “self borrowing”, and generational indexes
make it much much better.  “slotmap” beat me to releasing a crate for it :(, so
consider this a feature request :)</p><p>We’ll go ahead and make a type that’s a bit easier to use than <code class="highlighter-rouge">Vec&lt;Option&lt;T&gt;&gt;</code>
to store our actual data as well:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="n">ArrayEntry</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="n">value</span><span class="p">:</span><span class="n">T</span><span class="p">,</span><span class="n">generation</span><span class="p">:</span><span class="nb">u64</span><span class="p">,</span><span class="p">}</span><span class="c">// An associative array from GenerationalIndex to some Value T.</span><span class="k">pub</span><span class="k">struct</span><span class="n">GenerationalIndexArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">ArrayEntry</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">);</span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="n">GenerationalIndexArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="c">// Set the value for some generational index.  May overwrite past generation</span><span class="c">// values.</span><span class="k">pub</span><span class="k">fn</span><span class="nf">set</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">,</span><span class="n">index</span><span class="p">:</span><span class="n">GenerationalIndex</span><span class="p">,</span><span class="n">value</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="c">// Gets the value for some generational index, the generation must match.</span><span class="k">pub</span><span class="k">fn</span><span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span><span class="n">index</span><span class="p">:</span><span class="n">GenerationalIndex</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">pub</span><span class="k">fn</span><span class="nf">get_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">,</span><span class="n">index</span><span class="p">:</span><span class="n">GenerationalIndex</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>So with this new abstraction, let’s change our engine some more:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="n">PhysicsComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidAnimationComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidItemsComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">MonsterAnimationComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">NpcBehaviorComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">AggressionComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HealthComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HungerComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">PlayerComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="c">// We're dropping the index or id suffix, because there is no other "Entity"</span><span class="c">// type to get confused with.  Don't forget though, this doesn't "contain"</span><span class="c">// anything, it's just a sort of index or id or handle or whatever you want to</span><span class="c">// call it.</span><span class="k">type</span><span class="n">Entity</span><span class="o">=</span><span class="n">GenerationalIndex</span><span class="p">;</span><span class="c">// Map of Entity to some type T</span><span class="k">type</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">=</span><span class="n">GenerationalIndexArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="k">struct</span><span class="n">GameState</span><span class="p">{</span><span class="n">assets</span><span class="p">:</span><span class="n">Assets</span><span class="p">,</span><span class="n">entity_allocator</span><span class="p">:</span><span class="n">GenerationalIndexAllocator</span><span class="p">,</span><span class="n">physics_components</span><span class="p">:</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">PhysicsComponent</span><span class="o">&gt;</span><span class="p">,</span><span class="n">humanoid_animation_components</span><span class="p">:</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">HumanoidAnimationComponent</span><span class="o">&gt;</span><span class="p">,</span><span class="n">humanoid_items_components</span><span class="p">:</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">HumanoidItemsComponent</span><span class="o">&gt;</span><span class="p">,</span><span class="n">monster_animation_components</span><span class="p">:</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">MonsterAnimationComponent</span><span class="o">&gt;</span><span class="p">,</span><span class="n">npc_behavior_components</span><span class="p">:</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">NpcBehaviorComponent</span><span class="o">&gt;</span><span class="p">,</span><span class="n">aggression_components</span><span class="p">:</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">AggressionComponent</span><span class="o">&gt;</span><span class="p">,</span><span class="n">health_components</span><span class="p">:</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">HealthComponent</span><span class="o">&gt;</span><span class="p">,</span><span class="n">hunger_components</span><span class="p">:</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">HungerComponents</span><span class="o">&gt;</span><span class="p">,</span><span class="n">player_components</span><span class="p">:</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">PlayerComponents</span><span class="o">&gt;</span><span class="p">,</span><span class="n">players</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span></code></pre></div></div><p>Neat!  We’re in the home stretch now, this is almost a full blown ECS system.</p><p>Take away for users of Rust in general: obviously generational indexes are
awesome but for some reason they’re more popular only in C++, but they’re
potentially even MORE useful for Rust!  To the author of “slotmap”, please
expose the allocator separately, it’s hugely useful!  If that doesn’t seem in
scope or the kind of API you want to provide, I can release a similar crate with
the version I have that does do this.</p><h2 id="dynamic-typing-is-actually-kind-of-nice-in-very-controlled-quantities">Dynamic typing is actually kind of nice in VERY controlled quantities.</h2><p>Okay, we’re really close now, this is very close to how a “real” ECS system
(like specs!) might work.  The biggest problem we haven’t addressed from earlier
is still that everything is kind of global still.  More so, every “system” (for
us, this is still just a fancy name for plain functions) depends on <em>all</em> of the
types that go into our game state, which may be quite large.  Most of a game is
going to live inside one crate and the dependency graph between modules such as
this is really hardly anything to fret over, but still changing anything inside
“GameState” potentially would affect every system at least <em>theoretically</em>.
Let’s see what we can do about this?</p><p>I want to emphasize before we go on that this, like many steps before, is
<em>optional</em>.  You may balk at this as unnecessary complication, and you may be
right!  This IS something that is in most ECS implementations though, so it’s
worth covering if only to understand them, and it’s more or less unavoidable
when trying to build a library to do this sort of thing.</p><p>For this we’re going to need the <code class="highlighter-rouge">anymap</code> crate, but also the <code class="highlighter-rouge">mopa</code> crate would
do as well.  What we need is a container that can store exactly one of every
type that we put into it:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">struct</span><span class="n">AnyMap</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">impl</span><span class="n">AnyMap</span><span class="p">{</span><span class="k">pub</span><span class="k">fn</span><span class="n">insert</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">,</span><span class="n">t</span><span class="p">:</span><span class="n">T</span><span class="p">)</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">pub</span><span class="k">fn</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">pub</span><span class="k">fn</span><span class="n">get_mut</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>How might we use this to store our components?</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="n">PhysicsComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidAnimationComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HumanoidItemsComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">MonsterAnimationComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">NpcBehaviorComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">AggressionComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HealthComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">HungerComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">struct</span><span class="n">PlayerComponent</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">type</span><span class="n">Entity</span><span class="o">=</span><span class="n">GenerationalIndex</span><span class="p">;</span><span class="k">type</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">=</span><span class="n">GenerationalIndexArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="k">struct</span><span class="n">GameState</span><span class="p">{</span><span class="n">assets</span><span class="p">:</span><span class="n">Assets</span><span class="p">,</span><span class="n">entity_allocator</span><span class="p">:</span><span class="n">GenerationalIndexAllocator</span><span class="p">,</span><span class="c">// We're assuming that this will contain only types of the pattern</span><span class="c">// `EntityMap&lt;T&gt;`.  This is dynamic, so the type system stops being helpful</span><span class="c">// here, you could use `mopa` crate to make this somewhat better.</span><span class="n">entity_components</span><span class="p">:</span><span class="n">AnyMap</span><span class="p">,</span><span class="n">players</span><span class="p">:</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Entity</span><span class="o">&gt;</span><span class="p">,</span><span class="o">...</span><span class="p">}</span></code></pre></div></div><p>Now instead of storing game-specific data, let’s just keep going with dynamic
typing!  We’ll say that our game state is a dynamic collection of entities with
components, and <em>also</em> a dynamic collection of other types, one of each type.
We’ll call these “resources”.  Also we’ll change the name from <code class="highlighter-rouge">GameState</code> to
something more accurate.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="n">Entity</span><span class="o">=</span><span class="n">GenerationalIndex</span><span class="p">;</span><span class="k">type</span><span class="n">EntityMap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">=</span><span class="n">GenerationalIndexArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span><span class="k">struct</span><span class="n">ECS</span><span class="p">{</span><span class="n">entity_allocator</span><span class="p">:</span><span class="n">GenerationalIndexAllocator</span><span class="p">,</span><span class="c">// Full of types like `EntityMap&lt;T&gt;`.</span><span class="n">entity_components</span><span class="p">:</span><span class="n">AnyMap</span><span class="p">,</span><span class="n">resources</span><span class="p">:</span><span class="n">AnyMap</span><span class="p">,</span><span class="p">}</span></code></pre></div></div><p>And here we have arrived at what an actual ECS data structure might look like.
I’ve added a “resources” AnyMap because this is also a very common pattern, and
it means that more or less your entire game state can be expressed inside this
“ECS” structure.  We’re calling it an “ECS”, but importantly, really there
aren’t any mentions of “systems” in sight.  I don’t actually like describing
ECSes in terms of systems, because I think while it can be important, it’s
really incidental.  If our “systems” are pure functions in a loop or they’re
something much fancier, BOTH of these capture the important part of ECS design.</p><p>So, you may be balking now at the egregious and sudden introduction of dynamic
typing.  Let’s stop and think though what this buys us.  Say you get a new
feature request for your game, say you need a new crazy special monster that has
some kind of counter inside it.  Every time you kill the monster, it copies itself
into two and decrements the counter, duplicating like the heads on a hydra.
This means you might need a new component type, say <code class="highlighter-rouge">EnemyDuplicationLevel</code> or
something.  With dynamic typing, you can add this component without “disturbing”
your other systems, because without importing the new module, they can’t
possibly “see” that the ECS has such a component anyway.  The same is true for
resources, you can add new data types to your model without “disturbing”
existing systems.</p><p>The justification for this may seem pretty weak, and it kind of is.  In order to
get the full picture we need to go a bit further.  I’m going to speed up a bit
so we can get to the end and I can show a full-ish picture, something which I
consider a “modern” game engine design that you might use for a medium or large
project.  It’s actually not much further along than this, but the last few
features are all related and are not as useful alone.</p><h2 id="the-registry-pattern">The “registry” pattern</h2><p>Now that we’ve introduced dynamic typing, there’s a design pattern that I like
in Rust that I haven’t really seen in practice yet (I’m sure it exists and I
have just not seen it).  I’m going to call it the “registry pattern”.</p><p>In ECS implementations like specs, there’s a step where you “register” a type
with your ECS, which inserts an entry into some AnyMap or equivalent to an
AnyMap.  Using a component type that is unregistered is usually an error.  Let’s
take this a bit further, and not tie “registering” to the ECS per se, let’s make
our own “registry”.</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">struct</span><span class="n">ComponentRegistry</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">impl</span><span class="n">ComponentRegistry</span><span class="p">{</span><span class="c">// Registers a component, components must implement a special trait to allow</span><span class="c">// e.g. loading from a JSON config.</span><span class="k">pub</span><span class="k">fn</span><span class="n">register_component</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span><span class="n">Component</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">)</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="c">// Sets up entries for all registered components to the given ECS</span><span class="k">pub</span><span class="k">fn</span><span class="nf">setup_ecs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span><span class="n">ecs</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">ECS</span><span class="p">)</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="c">// Loads a given entity into the given ECS, loading all the components from</span><span class="c">// the given config</span><span class="k">pub</span><span class="k">fn</span><span class="nf">load_entity</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span><span class="n">config</span><span class="p">:</span><span class="n">Json</span><span class="p">,</span><span class="n">ecs</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">ECS</span><span class="p">)</span><span class="k">-&gt;</span><span class="n">Entity</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>We’ll also make one for “resources”</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span><span class="k">struct</span><span class="n">ResourceRegistry</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">impl</span><span class="n">ResourceRegistry</span><span class="p">{</span><span class="c">// The Resource trait provides loading from JSON and other things.</span><span class="k">pub</span><span class="k">fn</span><span class="n">register_resource</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="k">self</span><span class="p">)</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="c">// Sets up entries for all registered resources to the given ECS</span><span class="k">pub</span><span class="k">fn</span><span class="nf">setup_ecs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span><span class="n">ecs</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">ECS</span><span class="p">)</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="c">// Adds a resource to the given ECS by loading from the given config.</span><span class="k">pub</span><span class="k">fn</span><span class="nf">load_resource</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span><span class="n">config</span><span class="p">:</span><span class="n">Json</span><span class="p">,</span><span class="n">ecs</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">ECS</span><span class="p">)</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>Then, we’ll tie them together in one big global constant with lazy_static!</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// When we add a component to our project, there are two steps.  First, add the</span><span class="c">// component somewhere as a Rust module, THEN add it to this list here.  For</span><span class="c">// added convenience, this function could go in the lib.rs which contains the</span><span class="c">// component modules themselves.  If you were very fancy, you could have some</span><span class="c">// kind of "plugin architecture" for this as well, grouping related components /</span><span class="c">// resources together into "plugins".</span><span class="k">fn</span><span class="nf">load_component_registry</span><span class="p">()</span><span class="k">-&gt;</span><span class="n">ComponentRegistry</span><span class="p">{</span><span class="k">let</span><span class="k">mut</span><span class="n">component_registry</span><span class="o">=</span><span class="nn">ComponentRegistry</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span><span class="n">component_registry</span><span class="py">.register</span><span class="p">::</span><span class="o">&lt;</span><span class="n">PhysicsComponent</span><span class="o">&gt;</span><span class="p">();</span><span class="n">component_registry</span><span class="py">.register</span><span class="p">::</span><span class="o">&lt;</span><span class="n">PlayerComponent</span><span class="o">&gt;</span><span class="p">();</span><span class="o">...</span><span class="p">}</span><span class="c">// Ditto </span><span class="k">fn</span><span class="nf">load_resource_registry</span><span class="p">()</span><span class="k">-&gt;</span><span class="n">ResourceRegistry</span><span class="p">{</span><span class="o">...</span><span class="p">}</span><span class="k">pub</span><span class="k">struct</span><span class="n">Registry</span><span class="p">{</span><span class="k">pub</span><span class="n">components</span><span class="p">:</span><span class="n">ComponentRegistry</span><span class="p">,</span><span class="k">pub</span><span class="n">resources</span><span class="p">:</span><span class="n">ResourceRegistry</span><span class="p">,</span><span class="p">}</span><span class="nd">lazy_static!</span><span class="p">{</span><span class="k">pub</span><span class="k">static</span><span class="k">ref</span><span class="n">REGISTRY</span><span class="p">:</span><span class="n">Registry</span><span class="o">=</span><span class="n">Registry</span><span class="p">{</span><span class="n">components</span><span class="p">:</span><span class="nf">load_component_registry</span><span class="p">(),</span><span class="n">resources</span><span class="p">:</span><span class="nf">load_resource_registry</span><span class="p">(),</span><span class="p">};</span><span class="p">}</span></code></pre></div></div><p>I like this pattern, because this is, if you squint, almost like a sort of
global type registry like you might find in Java.  It feels a bit
“enterprisey”, but it’s quite useful!  It is <em>also</em> similar (again, if you
squint) to very full-featured all encompassing engines with built-in editors,
where you might say add a component type through some menu or GUI and it ends
up being stored in some project config file.  In this case, instead of a
project config file it’s simply a bit of auxiliary rust code.</p><p>This pattern ends up being very useful!  Imagine you have some game state that
can be loaded from a JSON config file.  Each resource and component can be
loaded from JSON, so you can just add a component or resource type and then add
the entry to the data format, load the game and see it (except you need a new
system that understands the new types, we’ll get there in a sec).</p><p>So at this point, this is a sketch of something that is unmistakably turning
into a “real” ECS game engine.  I like this, because so far, except for some
brief required library-ish functionality, I have barely talked about functions
or systems!  The reason for this is, I don’t like introducing this concept by
talking about behavior, I really think that thinking just about how we describe
our state is a much more useful way to approach this.</p><p>With that out of the way, it’s pretty easy to see how you could also just as
easily add a <code class="highlighter-rouge">SystemRegistry</code> to go along with this.  Our systems are just
functions, so all this would do is allow you to add functions to your main loop
in a slightly more complicated way.  One possible addition here is to allow
systems to have some kind of config, so that maybe you can configure tunable
parameters for them or even use the same function multiple times with different
parameters.  It’s generally advised though that you try very hard not to give
your systems <em>state</em>, so you can limit your game state to just components and
resources.  If your game state is just components and resources, you can often
do cool things like clone them (save state like in an emulator!) or easily
serialize it, and this is harder with something like system closures.</p><p>Takeaways for regular Rust: The registry pattern is actually quite nice.  In
Starbound there is a “Root” object which is sort of like this, where every type
is registered, but it’s more stateful than what I’ve described here.  It’s read
only, but it’s constructed by reading assets.  I actually like the idea of a
“type registry”, and something like this is necessary as soon as you want to use
this sort of dynamic typing with AnyMap, and the two patterns go together well
to limit the problem of “everything depending on everything else”.</p><h2 id="ecs-is-sql-for-games">ECS is SQL for games</h2><p>Let me pull the curtain back a bit.  What have we described so far: A way of
declaring a special kind of key (Entity), and a series of records that go with
those keys (components), and also for good measure a way to define records that
don’t pair with any of those keys (resources).  We’ve added dynamic typing into
the mix, and shown a pattern so that you can define all the record types you
have in one place (kind of like a schema?).  In the real ECS I have built, I
even have ways of performing primitive “queries” on components, saying “give me
all entities with a position, optionally a velocity, but NOT a mass”.</p><p>This probably sounds achingly familiar, and if it does there’s a good reason for
it.  ECS is just SQL for games.  A very, very, very limited form of SQL, but
spiritually very similar.  Define the schema for your data, load it, run queries
on it, and update it.  Very limited SQL where every query might have to run in
no more than a few microseconds.</p><p>I said earlier that I’ve read a lot of bad introductions to ECS and one good
one.  I’m not the first to mention this parallel between ECS and SQL, all the
way back in 2009, there was an
<a href="http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/">article</a>
about this very point with a focus on MMOs.</p><p>So, if this is true, why can’t we just use something like sqlite to store our
game state?  The funny thing is, you might actually be able to do this, but it’s
tough to run queries fast enough in 16ms.  Let’s think about what kind of
benefits this would bring, though!  Oh man, I need to make a save format for the
game.. nope it’s SQL I’m already done.  Oh, I need to update the format of
everyone’s save file.. write some external SQL update scripts and you’re done!
Oh, I’d like to give the ability to save the game’s state at any arbitrary
point?  Done.  I noticed a bug and I want to roll back the game state to 30
seconds ago and step through it frame by frame, running queries to see when a
bad state was produced?  done. All this careful introduction of the generational
indexes concept, SQL has this already, they’re keys with auto increment (more
like <code class="highlighter-rouge">HashMap&lt;EntityId, T&gt;</code> really).</p><p>At that point, each of your systems would basically be a series of queries to
get data out of SQL, some updates, and then writing it back out to SQL.  We’ve
turned sexy game development into boring old web development! (web development
can be sexy and game development can be boring, just for the record)</p><p>The only issue is that I’m <em>pretty</em> sure it’s about two orders of magnitude too
slow to work, but still it’s a neat idea, and it’s useful to draw parallels!</p><p>I think this is important, because I see a lot of debate about “what makes
something a pure ECS” that I think is ultimately pretty silly.</p><ul><li>Is it an ECS if entities can have multiples of a component?  Well, the
differences between multiples of a component and a component that contains
just a Vec are very very few, but yes it’s still ECS.  Is it still SQL if you
have two tables that are 1 to N instead of 1 to 1?  Yes, of course it is.</li><li>Is it still an ECS if my components have methods?  Yes, adding a component
method is not the end of the world, especially if there is a small local
invariant to maintain.  SQL is all about data, but it also has stored
procedures to maintain invariants.</li><li>Is it still an ECS if I need two different ECS sets, or I put lots of data
into resources?  Should I be using “singleton entities” or resources?  Is it
still SQL if I have two different databases, or split a top level table apart?
Yes, of course!</li></ul><p>… and so on</p><p>The analogy is not perfect, but I think this is really kind of illuminating.
There is research currently about how to make more capable ECS systems that have
things like component graphs with child relationships between components and
entities and all kinds of crazy stuff, and the thing is that’s of course fine.
SQL has all of this already, it’s an entire language and set of software for
expressing <em>all kinds</em> of data relationships, it’s just that games have
generally simpler needs, will basically always be in-memory only, and have
timing requirements on the order of nanoseconds or microseconds, so we
compromise and make new tools.</p><p>This is the other reason I’m doing this talk, to help further de-mystify “ECS”
and show how we ended up here, and to give perspective.</p><h2 id="the-one-place-where-it-all-goes-wrong">The one place where it all goes wrong</h2><p>(NOTE: I don’t know if I need this section at all, I’m just hawking the OTHER
talk I wanted to do.  Maybe this is unimportant?  This talk is already
potentially very very long)</p><p>I claimed at the beginning that the attitude I see of being overly skeptical of
the borrow checker, of considering it too restrictive, is bunk.  I still
absolutely believe this, but I want to talk quickly about the one place where I
kept running into issues, really the <em>only</em> place where I really had trouble,
where I constantly felt limited.  Certainly as a project grows in size,
<em>something</em> must go wrong right?  Well, I have one example of this, though this
problem isn’t really limited to Rust at all, it’s just more <em>immediately</em>
painful (noticing a pattern?).</p><p>Language boundaries are hard.</p><p>So, the issues here are all… pretty hard to explain succinctly.  I’m not sure
I can come up with small limited examples like before without getting way into
the weeds and doubling the length of this already lengthy talk.  I wrote an
entire crate (rlua) just to try and solve this problem, and after a ridiculous
amount of work I can confidently say that I’ve <em>sort of</em> half-solved it.</p><p>I have a representation of components where you choose to read or write each
component (they’re stored in RwLocks for system concurrency).  I want Lua to be
able to read a set of systems, so I have a lua script perform a “query” on the
ECS store.  All I need to do is to be able to hand Lua the “RwLockReadGuard”
(really a structure containing this) that the query returns, except…
RwLockReadGuard is not static.  Oh I guess I’ll just have the Lua query lock
inside the query API rather than once at the beginning… well that would be
very slow and also not thread safe, a query should lock for the whole time.  I
guess I could use the rental crate.. oh god the rental crate is HARD and this is
TERRIBLE.  (I was later able to solve this problem with rlua’s “scope” system,
but it’s still bad).</p><p>It’s best if you don’t have your systems be stateful, right?  Generally systems
should store data either in the components they operate on if they’re logically
related, or maybe in a custom resource, or simply store some cache-like values
but be prepared if the system is reloaded and the cache is reset.  Don’t rely on
data that can’t be saved / restored / serialized etc.  This is great until you
write a Lua system, because exfiltrating values outside of Lua is actually
really hard.  You can’t store a Lua state inside a resource because it’s not
Sync, and you can’t store Lua data separate from the state because the Lua
internal state and external handles are REALLY not Sync.  You can sort of solve
this with magic Lua registry keys, but then if each system has its own Lua
instance, you’ve made a footgun if you ever try to use Lua values in the wrong
context, and they’re not serializable anyway.</p><p>You can make a data type which is limited to just data and not an internal Lua
type, but then you must write marshalling between it and the non-lua
representation, so every time your script system reads or writes this storage
it’s <em>dog slow</em>.  Some of the slowness is from copying data, but most of it is
from the intrinsically slow Lua API.</p><p>Everything is hard, it works if you really try but you feel like it should be
simpler than this.  It’s harder even than the equivalent in C++, but the
equivalent in C++ is actually just as bad, you just notice way faster in Rust.
At least there are not constant crashes and shared_ptr cycles now?</p><p>Seems a bit similar to our situation before, where we were trying the wrong
approach with OO.  Unfortunately, in the case of rlua, there are pretty hard
limitations based on how the internal Lua C API works, and it might be close to
the best I can offer.</p><p>Language boundaries are hard, especially between languages that have very
different sets of limitations like Rust and Lua (or C++ and Lua).  Especially in
the presence of a garbage collector in the contained language, if the garbage
collector in the contained language ever makes contact with one in the host
language, nothing will work, nothing will get collected. (In C++ / Rust this is
shared_ptr / Arc, yes these are a sort of garbage collector).</p><p>I mention this because I think Lua is very popular for games, and I get
questions a lot about how to combine rlua with things like specs, and I think
it’s just really hard, and goes against the larger point I’m making with this
talk.  I think this is probably <em>uniquely</em> hard due to language boundaries being
so tricky, and the situation is not vastly worse or better than the one in C++,
it’s slightly more difficult and vastly safer, just slightly more difficult is
not a great answer when in C++ it’s still very difficult.</p><p>I also mention this because I might have an answer for this soon!  The OTHER
talk I thought about doing was describing what I believe is a novel way of
implementing language runtimes safely in rust that have garbage collection that
is zero cost, and comes with the ability to have a fast, mostly pain-free (or as
much as possible) bindings experience.</p><p>In the meantime, think really really hard before you add a scripting layer to
your game engine.  The problem is, I LOVE scripting layers in game engines (for
modability and many other reasons), so I do this anyway, but it is not a
decision to be taken lightly and it can eat up a lot of time and effort.  I want
to make this more painless though, and make a safe, fast Lua that feels at home
in Rust in the same way that PUC-Rio’s Lua feels at home in C.  I will talk
about this in the future!</p><h2 id="summary">Summary</h2><p>I had multiple purposes with this talk:</p><ul><li>To walk through the design of a medium-scale rust project for those with only
experience in small-scale ones.</li><li>To show some examples of traps people might fall in that cause them to “fight
the borrow checker”, and to help make more concrete how to move past this
phase, at least in part.</li><li>To show how awesome data-oriented programming is and how well of a fit it is
for games and for Rust</li><li>To show how patterns in game dev that appeared long before Rust, when applied
to Rust, still seem to be a good fit.</li></ul><p>I talked a lot about patterns that in some cases were hard fought in other
languages, only appearing after laboriously exploring the space of solutions
that DIDN’T ultimately work.  Interestingly, those solutions that ultimately
don’t work very well often times are painful more quickly in Rust, they’re
louder, MORE annoying.  I think this is a good thing, and I like having tools
that make bad patterns feel as bad as they are.  Rust is <em>great</em> at this.</p><p>But could you take most of the lessons here and apply them just as easily in
C++?  In C?  Yes, absolutely.  Even if you’re the sort of person that doesn’t
make these mistakes even when there isn’t this sort of language pressure to
avoid them (you’re way better than me), there are tons of other great benefits.
I didn’t really get a chance to talk about all the benefits of Rust or talk
about my experiences with Rust in general, because I only have 30 minutes and
this is probably way longer than 30 minutes at this point.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>