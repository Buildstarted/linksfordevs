<!DOCTYPE html>
<html lang="en">
<head>
    <title>
An Experimental Floating-Point Scalar Evolution :: Duskborn &#x2014; Duskborn Labs is where Neil &#x2018;@sheredom&#x2018; Henning writes up things of interest. -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>An Experimental Floating-Point Scalar Evolution :: Duskborn &#x2014; Duskborn Labs is where Neil &#x2018;@sheredom&#x2018; Henning writes up things of interest.</h1>
    <div class="post-content"> <p>The TL;DR - after a conversation at EuroLLVM with <a href="https://twitter.com/stephentyrone">Steve Canon</a> about how LLVM is missing scalar evolution analysis for floating-point, I&#x2019;ve spent some spare time hacking on a new LLVM analysis pass - fpscev (Floating-Point SCalar EVolution) - available <a href="https://github.com/sheredom/fpscev">here at github</a>. The pass will analyze floating-point operations in a function and work out if there are any constraints on the range of these values, information which can be used to better optimize code.</p> <h2 id="what-is-scalar-evolution">What is Scalar Evolution?</h2> <p>Scalar evolution lets a compiler understand the scope of a value throughout a
program. The classic place that scalar evolution is used in compiler
optimizations is with respect to loop index variables to let a compiler infer
the number of loop iterations that a loop will perform.</p> <p>Scalar evolution can also be used to fold branches away. Imagine you have code
like:</p> <pre><code class="language-c">if (i &lt; 4) {
  // Do a million lines of awful code that will bloat you executable!
}
</code></pre> <p>And lets say that via scalar evolution we know that <code>i</code> could <em>never</em> be less
than 4. That allows the compiler to remove the entire if branch as it will never
be hit!</p> <h2 id="why-floating-point-scalar-evolution">Why Floating-Point Scalar Evolution?</h2> <p>Many floating-point algorithms can be vastly improved if we know the scope of
the inputs to math functions are. Lots of high performance code that game
developers throw through compiler stacks will use many operations that could
benefit from knowing a little more about the value of the float.</p> <p>A great use of this would be something like the following:</p> <pre><code class="language-c">float f = ...; // definitely not NaN or Infinity
f = sin(f); // because f wasn&apos;t NaN or Infinity f is now in the range [-1..1]

if (!isfinite(f)) {
  // Do a million lines of awful code that will bloat you executable!
}

</code></pre> <p>In the example above that if check should always return false - but the compiler
doesn&#x2019;t have enough information to know that.</p> <p>If we look at the latest (as of the time of writing) version of LLVM from trunk
SVN (9.0.0svn) and how it handles the above:</p> <pre><code class="language-c">define float @func(float %0) {
1:
  %2 = tail call nnan ninf float @llvm.sin.f32(float %0)
  %3 = tail call float @llvm.fabs.f32(float %2)
  %4 = fcmp ueq float %3, 0x7FF0000000000000
  br i1 %4, label %5, label %7

5:
  %6 = ... ; do something complicated
  br label %7

7:
  %8 = phi float [ %2, %1 ], [ %6, %5 ]
  ret float %8
}

</code></pre> <p>Even with the additional <em>fast-math</em> flags &#x2018;nnan&#x2019; (no NaNs) and &#x2018;ninf&#x2019; (no
Infinity) on the call stored into <code>%2</code> - the compiler cannot deduce that the
branch in <code>%4</code> is redundant.</p> <p>This is all because LLVM&#x2019;s scalar evolution only cares about <em>integers</em>. This
generally makes sense - scalar evolution came about because of loops, and loops
have integer indices (for the most part&#x2026;). What if we extended some similar
techniques as found in scalar evolution to floating-point - what optimization
opportunites we could open up?</p> <h2 id="the-approach">The Approach</h2> <p>The overall approach that I&#x2019;ve taken is to classify all operations that produce a floating-point result as having a result within a given range. We will keep track of the minimum (down to -NaN), the maximum (up to +NaN) and whether the value is an integer (whole number hiding in a floating-point) or not.</p> <p>The analysis runs as a function pass that iterates on the basic blocks of that function in a reverse post-order traversal - which ensures that for graphs of basic blocks that are <em>not</em> loops, we will always have classified an input float before it is used.</p> <p>To keep things simple - no attempt has been made to classify floating-point values that are persistant around a loop - any phi node can attempt to classify a float which has not been identified yet, and thus will have to make a default worst-case assumption on the float.</p> <p>Lets now run through the list of instructions that we will analyze, and I&#x2019;ll explain what the analysis pass does for each.</p> <h2 id="signed-integer-to-floating-point">Signed Integer to Floating-Point</h2> <pre><code class="language-c">  %f = sitofp i8 %i to float
</code></pre> <p>The <code>sitofp</code> instruction converts a signed integer to a floating-point value. Given that integers have a constrained range with respect to their integer size, we can make some assumptions on all integers as to what their maximum and minimum values are. To get an even better insight into their value, I use the existing scalar evolution analysis (which only works for integers) to query the range of the input integer and propagate this to the float. The smallest integer value is rounded towards negative when converting and the largest integer value is rounded towards positive, to ensure that even for the integer numbers that are not fully representable in their floating-point equivalents - we account for the worst-case behaviour of any rounding mode the system supports.</p> <p>In the above example, because <code>%i</code> has a signed range of <code>[-128..127]</code> we can infer that <code>%f</code> also has this range, and we record that <code>%f</code> is an integer (hiding in a float).</p> <pre><code class="language-c">min: -128
max: 127
isInteger: 1
</code></pre> <h2 id="unsigned-integer-to-floating-point">Unsigned Integer to Floating-Point</h2> <pre><code class="language-c">  %f = uitofp i3 %i to float
</code></pre> <p>Much like for the signed equivalent above, we know that <code>%i</code> has an unsigned range of <code>[0..7]</code> and so <code>%f</code> also has this range and is an integer.</p> <pre><code class="language-c">min: 0
max: 7
isInteger: 1
</code></pre> <h2 id="floating-point-truncation">Floating-Point Truncation</h2> <pre><code class="language-c">  %f = fptrunc double %d to float
</code></pre> <p>For floating-point truncation - the range of the truncated value is the same as the range of the larger value we are truncating from. The only exceptions will be if the larger number is not fully representable in the smaller data type.</p> <p>If we assume that <code>%d</code> above came from an already constrained number, we can see that the constraints have passed from <code>%d</code> to <code>%f</code>.</p> <pre><code class="language-c">min: -128
max: 127
isInteger: 1
</code></pre> <h2 id="floating-point-extension">Floating-Point Extension</h2> <pre><code class="language-c">  %f = fpext half %h to float
</code></pre> <p>For floating-point extension - the approach mirrors that of truncation. We simply pass the original constrained range onto the larger type.</p> <pre><code class="language-c">min: 4.5
max: 42.42
isInteger: 0
</code></pre> <h2 id="selects">Selects</h2> <pre><code class="language-c">%d = select i1 %b, double 0.0, double %in
</code></pre> <p>Selecting between two values yields a range that is the intersection of the two original ranges.</p> <p>In the above example <code>%in</code> is a value that when classifying we could deduce no information about. Think of values sourced from loads or passed in as function parameters. So the range of <code>%in</code> is:</p> <pre><code class="language-c">min: -NaN
max: NaN
isInteger: 0
</code></pre> <p>This means that the result of the selection is the same range - EG. the range of the 0.0 is merged with the range of <code>%in</code> which just so happens to already contain 0.0.</p> <h2 id="phis">PHIs</h2> <pre><code class="language-c">%f = phi float [%a, %true], [%b, %false]
</code></pre> <p>PHIs merge their ranges together in a similar fashion to selects. So for the above phi the range of <code>%f</code> is the intersection of the ranges of <code>%a</code> and <code>%b</code>. To keep the algorithm simple though, I&#x2019;ve purposefully not handled any arguments to a PHI that we haven&#x2019;t seen before. Since we iterate through the basic blocks in a reverse post order traversal, the only time we will see a value to a PHI that we haven&#x2019;t seen before is in loops where the PHI value has yet to be parsed:</p> <pre><code class="language-c">loop:
  %f = phi float [0.0, %entry], [%f2, %loop]
  %f2 = fadd float %f, 1.0
  %c = fcmp oge float %f2, 42.0
  br i1 %c, label %loop, label %merge
</code></pre> <p>In the example above <code>%f2</code> has not been encountered when we are classifying the PHI node in <code>%f</code>, and thus we have to assume the worst case for <code>%f</code> that <code>%f2</code> could be any floating-point number.</p> <pre><code class="language-c">min: -NaN
max: NaN
isInteger: 0
</code></pre> <h2 id="floating-point-negate">Floating-Point Negate</h2> <pre><code class="language-c">  %f2 = fneg float %f
</code></pre> <p>Negate is a fun one - because in any cases where we know that the input is all positive or all negative we know for sure that the output is exactly the opposite range.</p> <p>Lets assume that <code>%f</code> is in the range <code>[0..4000.12]</code>, and thus <code>%f2</code> is the negative of this range:</p> <pre><code class="language-c">min: -4000.12
max: -0
isInteger: 0
</code></pre> <h2 id="floating-point-addition">Floating-Point Addition</h2> <pre><code class="language-c">  %f3 = fadd float %f, %f2
</code></pre> <p>The addition of two numbers has a linear result across the range. So to evaluate the full range of the addition we need to perform eight adds - we need to add the min/max from the first operand to the min/max of the second operand. We need to be careful of the worst case behaviour with respect to rounding also, so we need to perform all these additions under both round to negative and round to positive rounding modes (thus the eight adds).</p> <p>LLVM&#x2019;s APFloat class supports all this for us, we just leverage it.</p> <pre><code class="language-c">min: 0
max: 638.1
isInteger: 0
</code></pre> <pre><code class="language-c">%f3 = fsub float %f, %f2
</code></pre> <p>Subtraction follows the same idea as addition - eight subtractions with the min/max of both operands.</p> <pre><code class="language-c">min: -127
max: 511
isInteger: 1
</code></pre> <h2 id="floating-point-multiplication">Floating-Point Multiplication</h2> <pre><code class="language-c">%f3 = fmul float %f, %f2
</code></pre> <p>Multiplication is the same as addition and subtraction - use LLVM&#x2019;s APFloat to multiply the min/max of both operands.</p> <pre><code class="language-c">min: 0
max: 64897
isInteger: 1
</code></pre> <h2 id="floating-point-division">Floating-Point Division</h2> <pre><code class="language-c">%f3 = fdiv float %f, %f2
</code></pre> <p>Division is an interesting one because there are three domains of interest outwith any NaNs:</p> <ol>
<li>Could the denominator be zero? This can produce infinities.</li>
<li>Could the denominator be between minus one and one? This <em>grows</em> the range of the output.</li>
<li>Could the denominator be exclusively outwith the range minus one and one? This <em>shrinks</em> the range.</li>
</ol> <p>For my evaluation I care most about 1. and 3. - if the denominator could be zero I need my range to encompass all finite and infinite numbers, and if the denominator will always cause the range to <em>shrink</em> I calculate the division on the bounds and use that as the new constrained range.</p> <p>Let us assume that <code>%f</code> in the above example is in the range <code>[0..511.0]</code>, and that <code>%f2</code> is a single value <code>400000000.0</code>. The resulting range for <code>%f3</code> is:</p> <pre><code class="language-c">FPSCEV: 0x7fe02e006698:
min: 0
max: 1.27750002E-6
isInteger: 0
</code></pre> <p>Another interesting point with division is the fast-math flag allow reciprocal (arcp). This flags lets a division operation to be replaced with x * (1 / y) - EG. you take the reciprocal of y (with intermediate rounding) and multiply that by x. Lots of hardware has efficient reciprocals, and so this optimization can be very powerful for performance. The problem with this optimization for us is that the intermediate rounding of x presents an issue with the range of the output. To combat this - if arcp is being used we have to perform four division operations for the reciprocal with each value from the range of y being calculate with each of the most biased rounding modes, and then these reciprocals are combined with the range of x using a further sixteen multiplies. We need sixteen multiplies because we need to multiply all four of the reciprocal calculations with the two ranges of x for each of the two most biased rounding modes - resulting in the sixteen operations. At the end of this we just calculate the min and max of all these values to get our final range.</p> <p>If we apply arcp to the division operation above, our new resulting range for <code>%f3</code> is:</p> <pre><code class="language-c">min: 0
max: 1.27750013E-6
isInteger: 0
</code></pre> <p>Which as you can see is slightly larger in the maximum resulting value because of the intermediate rounding.</p> <h2 id="floating-point-remainder">Floating-Point Remainder</h2> <p>Floating-point remainder is an operation that I&#x2019;ve avoided - simply because LLVM&#x2019;s APFloat does not contain a method for calculating the remainder with a provided rounding mode.</p> <p>The only optimizations I propagate through remainder are the fast-math flags.</p> <h2 id="arbitrary-calls">Arbitrary Calls</h2> <p>LLVM lets you place fast-math flags on arbitrary calls.</p> <pre><code class="language-c">%f = call nnan float @some_called_func()
%f2 = call nnan ninf float @some_called_func()
</code></pre> <p>For the above two calls, the range of <code>%f</code> will not contain NaNs, and the range of <code>%f2</code> is strictly finite - EG. no NaNs or infinities.</p> <h2 id="square-root">Square Root</h2> <pre><code class="language-c">%f2 = call float @llvm.sqrt.f32(float %f)
</code></pre> <p>LLVM&#x2019;s APFloat does not contain a sqrt operation. So all I could do with sqrt was to check if the range was entirely negative and thus a NaN would be produced. If the range contains positives and negatives, then the largest output range could be NaN, and the smallest output range could always be zero for a sufficiently small input. Otherwise if the range is entirely finite and positive, the best I could do for now was to say that the output range is at least as small as the input range, and I wipe all knowledge of whether the input was an integer because the likelyhood of an integer input being a perfect square is small enough that I didn&#x2019;t currently care.</p> <p>If <code>%f</code> in the above example is an integer in the range <code>[0.0..511.0]</code>, then the range for <code>%f2</code> is:</p> <pre><code class="language-c">min: 0
max: 511
isInteger: 0
</code></pre> <p>Or - if the range is entirely negative the result is:</p> <pre><code class="language-c">min: NaN
max: NaN
isInteger: 0
</code></pre> <h2 id="x-to-the-power-of-integer-y">X To the Power of Integer Y</h2> <pre><code class="language-c">%f2 = call float @llvm.powi.f32(float %f, i32 %i)
</code></pre> <p>For x to the power of an integer y, we again don&#x2019;t have anything in LLVM&#x2019;s APFloat to help us here. But we can make some assumptions on the output if either <code>%f</code> or <code>%i</code> all have the same sign. Firstly - I only optimize if x is entirely a positive number. This is because negative x will cause the sign of the result to oscillate depending on whether the input integer y is odd or even. Next if y is always negative and x is greater than or equal to one, we know that the output range will at most be as large as the input range. And lastly if y is always positive then if x is less than one the output is between zero and one, otherwise if x is one or greater then the result will be between the minimum of one and the original range of x (because x^0 == 1.0), and the maximum will be infinity.</p> <p>For instance, lets say that <code>%i</code> above is in the range <code>[0..255]</code> and <code>%f</code> is in the range <code>[0..65535]</code>, the range of <code>%f2</code> is:</p> <pre><code class="language-c">min: 0
max: +Inf
isInteger: 0
</code></pre> <p>We could greatly reduce this range if we had an equivalent of pow for an APFloat in LLVM!</p> <h2 id="cosine-and-sine">Cosine and Sine</h2> <pre><code class="language-c">%f2 = call float @llvm.cos.f32(float %f)
%f3 = call float @llvm.sin.f32(float %f)
</code></pre> <p>The two trignometric functions cos and sin are great candidates for analysis. Both functions will return a result in the range <code>[-1..1]</code> if the input value is finite.</p> <h2 id="exponentials">Exponentials</h2> <pre><code class="language-c">%f2 = call float @llvm.exp.f32(float %f)
%f3 = call float @llvm.exp2.f32(float %f)
</code></pre> <p>The two exponential functions LLVM provides are hard to provide a maximum bound to because we don&#x2019;t have functions in APFloat to perform the calculation. But we do know that exponential always provides a positive result, so we set the minimum to zero for the output range, and the maximum to the largest the fast-math flags let us support (so worst case NaN, otherwise infinity or the largest positive number).</p> <h2 id="logarithms">Logarithms</h2> <pre><code class="language-c">%f2 = call float @llvm.log.f32(float %f)
%f3 = call float @llvm.log10.f32(float %f)
%f4 = call float @llvm.log2.f32(float %f)
</code></pre> <p>A similar problem with logarithm is that we don&#x2019;t have functions in APFloat that can help us here. But there are some properties of logs that we can check:</p> <ol>
<li>I check if the input is entirely negative, which always produces a NaN.</li>
<li>If the input is always positive but could be zero, then the minimum value could be a negative infinity.</li>
<li>If the input is less than one but not zero, then the minimum value could go as low as the largest negative representable number.</li>
<li>Otherwise if the input is greater than or equal to one, the minimum value is zero.</li>
</ol> <p>Since I don&#x2019;t have a way to calculate the log of the input, the maximum range is poorly chosen as the same as the input - which will nearly always be hugely bigger than the actual maximum could be if we had a way to calculate it!</p> <p>If we assume that <code>%f</code> is definitely not negative, then the output range is:</p> <pre><code class="language-c">min: -Inf
max: 511
isInteger: 0
</code></pre> <h2 id="fused-multiply-and-add">Fused Multiply and Add</h2> <pre><code class="language-c">%f3 = call float @llvm.fma.f32(float %f, float %f2, float 4.0)
</code></pre> <p>Fused multiply and add does not intermediately round the multiplied values before combining the additive. Luckily APFloat has a function for calculating this that takes a rounding mode, so we can use a similar approach to our addition above, except that we need sixteen operations for min and max we calculate - we need to perform four multiplications with two additions for the two most biased rounding modes.</p> <p>If we assume that <code>%f</code> above has a range of <code>[0..511]</code> and <code>%f2</code> has a range of <code>[-511..0]</code>, then the resulting range of the fma is:</p> <pre><code class="language-c">min: -261117
max: 4
isInteger: 0
</code></pre> <h2 id="floating-point-absolute-value">Floating-Point Absolute Value</h2> <pre><code class="language-c">%f2 = call float @llvm.fabs.f32(float %f)
</code></pre> <p>The absolute value of a number is just the range of the input with its sign reversed. This one took me an embarassingly long time to get right, as I&#x2019;ll illustrate with a fun little range. Let&#x2019;s say that <code>%f</code> is in the range <code>[-4..1.5]</code>, what I did originally was to wipe the sign from the range and then recalculate which of the new values was min/max. The resulting range was <em>incredibly wrong</em>:</p> <pre><code class="language-c">min: 1.5
max: 4
isInteger: 0
</code></pre> <p>The fix was trivial though - if the original range contained positive and negative numbers it thus passed through zero, and the minimum result would be zero also. After applying this fix the range correctly was:</p> <pre><code class="language-c">min: 0
max: 4
isInteger: 0
</code></pre> <h2 id="minimums-and-maximums">Minimums and Maximums</h2> <pre><code class="language-c">%f3 = call float @llvm.minnum.f32(float %f, float %f2)
%f4 = call float @llvm.maxnum.f32(float %f, float %f2)
%f5 = call float @llvm.minimum.f32(float %f, float %f2)
%f6 = call float @llvm.maximum.f32(float %f, float %f2)
</code></pre> <p>LLVM provides two variants of minimum/maximum calculations - they only really differ in how they handle NaNs. Minnum and maxnum match libm&#x2019;s fmin/fmax, whereas minimum and maximum match IEEE 754-2018.</p> <p>Lets assume that <code>%f</code> is in the range <code>[0..511]</code> and <code>%f2</code> is in the range <code>[-256..255]</code>.</p> <p>Minnum&#x2019;s range is:</p> <pre><code class="language-c">min: -256
max: 255
isInteger: 1
</code></pre> <p>Maxnum&#x2019;s range is:</p> <pre><code class="language-c">min: 0
max: 511
isInteger: 1
</code></pre> <p>Minimum&#x2019;s range is:</p> <pre><code class="language-c">min: -256
max: 255
isInteger: 1
</code></pre> <p>Maximum&#x2019;s range is:</p> <pre><code class="language-c">min: -256
max: 255
isInteger: 1
</code></pre> <pre><code class="language-c">%f3 = call float @llvm.copysign.f32(float %f, float %f2)
</code></pre> <p>Copy sign just copies the sign of <code>%f2</code> to <code>%f</code>. The interesting ranges are:</p> <ol>
<li>If <code>%f2</code> contains positive and negative numbers, I wipe the sign the minimum and maximum ranges of <code>%f</code>, find the largest of these for the new maximum, and flip the sign for the new minimum.</li>
<li>If <code>%f</code> contains positive and negative numbers, I do the same a 1.</li>
<li>If <code>%f2</code> is all negative then the result is always negative.</li>
<li>if <code>%f2</code> is all positive then the result is always positive.</li>
</ol> <p>Let us assume that <code>%f</code> is in the range <code>[0..511]</code> and <code>%f2</code> is in the range <code>[-256..255]</code>. This would mean our output range would be:</p> <pre><code class="language-c">min: -511
max: 511
isInteger: 0
</code></pre> <h2 id="rounding">Rounding</h2> <pre><code class="language-c">%f2 = call float @llvm.floor.f32(float %f)
%f3 = call float @llvm.ceil.f32(float %f)
%f4 = call float @llvm.trunc.f32(float %f)
%f5 = call float @llvm.rint.f32(float %f)
%f6 = call float @llvm.nearbyint.f32(float %f)
%f7 = call float @llvm.round.f32(float %f)
</code></pre> <p>LLVM has various functions that essentially boil down to <em>&#x201C;Round this floating-point to an integer with various rounding modes&#x201D;</em>. For each of these functions I use the APFloat&#x2019;s <code>roundToIntegral</code> to handle them.</p> <p>Let us assume that <code>%f</code> is in the range <code>[-32768.5039..32768.5039]</code>.</p> <p>For floor the output range is:</p> <pre><code class="language-c">min: -32769
max: 32768
isInteger: 1
</code></pre> <p>For ceil the output range is:</p> <pre><code class="language-c">min: -32768
max: 32769
isInteger: 1
</code></pre> <p>For trunc the output range is:</p> <pre><code class="language-c">min: -32768
max: 32768
isInteger: 1
</code></pre> <p>For rint the output range is:</p> <pre><code class="language-c">min: -32769
max: 32769
isInteger: 1
</code></pre> <p>For nearbyint the output range is:</p> <pre><code class="language-c">min: -32769
max: 32769
isInteger: 1
</code></pre> <p>For round the output range is:</p> <pre><code class="language-c">min: -32769
max: 32769
isInteger: 1
</code></pre> <p>Note that all of the results are always integer too.</p> <h2 id="fast-math-flags">Fast-Math Flags</h2> <p>LLVM supports <a href="https://llvm.org/docs/LangRef.html#id1027">fast-math flags</a> that allows the compiler to assume some properties about the input floating-point. For each of the functions above, the fast-math flags no-NaNs, no-infinities, and no signed zeros are propagated onto the inputs before the calculations of their range, and also propagated onto the output to constrain the range further.</p> <h2 id="all-the-missing-parts">All The Missing Parts</h2> <p>Even though I&#x2019;ve done a quite extensive analysis on the input, there are lots of missing parts. These can be categorized into a few main areas:</p> <ol>
<li>Any function that is missing from APFloat (like exponentials) means I make a really poor guess at the range&#x2019;s constraint. If these functions could be added this analysis would get better.</li>
<li>I make no attempt to handle the fast-math flag <em>approximate function</em> (afn). In actual fact given there are no range constraints on what an operation with afn is tagged with, I really should modify the optimization to set the range to NaN if afn is used in any function. This would suck because afn is meant to be used to allow more optimizations of the function, so to make it that our range analysis gets <em>much worse</em> when it is present seems backwards. I think the only way to solve this would be to provide some limitations on the range - like we could still require that afn on trig functions would definitely return a result in the range <code>[-1..1]</code>.</li>
<li>I almost wonder whether I would have been better tracking the NaN/infinity separately from the range itself - some functions like sin/cos can return NaN or something in the range <code>[-1..1]</code> - and if this was fed into an operation with no-NaNs specified then we could assume a much tighter range for that function.</li>
<li>Potentially track disjoint ranges to let us have a better guess - means a lot more data per FPSCEV though.</li>
<li>Integrate with the integer SCEV itself? I didn&#x2019;t do this because SCEV is huge and scary and anything that changes it this drastically would probably break all of LLVM. But if you convert a floating-point to an integer and you have FPSCEV information, I could translate that back into some better SCEV information on the integer too.</li>
</ol> <h2 id="conclusions">Conclusions</h2> <p>So doing this analysis wasn&#x2019;t trivial - but the results are pretty cool! We can now perform lots more analysis on floating-point values in LLVM.</p> <p>In my next blog I&#x2019;ll use this analysis to start actually optimizing some fun little programs, and see what is now possible with this extra information.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>