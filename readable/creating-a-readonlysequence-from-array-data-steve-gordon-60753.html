<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating a ReadOnlySequence from Array Data - Steve Gordon - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Creating a ReadOnlySequence from Array Data - Steve Gordon - linksfor.dev(s)"/>
    <meta property="article:author" content="Steve Gordon"/>
    <meta property="og:description" content="In this .NET focused post, I demonstrate how to create a ReadOnlySequence from some existing data held in multiple arrays."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.stevejgordon.co.uk/creating-a-readonlysequence-from-array-data-in-dotnet"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Creating a ReadOnlySequence from Array Data - Steve Gordon</title>
<div class="readable">
        <h1>Creating a ReadOnlySequence from Array Data - Steve Gordon</h1>
            <div>by Steve Gordon</div>
            <div>Reading time: 20-25 minutes</div>
        <div>Posted here: 16 Apr 2020</div>
        <p><a href="https://www.stevejgordon.co.uk/creating-a-readonlysequence-from-array-data-in-dotnet">https://www.stevejgordon.co.uk/creating-a-readonlysequence-from-array-data-in-dotnet</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="pryc-wp-acctp-original-content">
<div><p><em><span><strong>WARNING: This blog post is informational and relevant to those with an inquisitive mind but should be considered experimental. The code presented here is not suited to most real-world situations, not thoroughly tested and is just for fun!</strong></span></em></p><p>In this post, I will demonstrate how to create a ReadOnlySequence from some existing data held in multiple arrays. The idea for this post came from a comment on my post, “<a href="https://www.stevejgordon.co.uk/an-introduction-to-sequencereader">An Introduction to SequenceReader</a>“. To understand the types and terms used in this post, you may want to read that blog post first.</p></div>
<p>The question posed to me was:</p>
<blockquote>
<p>“How do I create a ReadOnlySequence from two arrays?”</p>
</blockquote>
<p>My original answer was:</p>
<blockquote>
<div><p>“It’s not something I’ve looked into as I’ve been a consumer only for now. There’s a constructor which takes a single array or ReadOnlyMemory&lt;t&gt; (ROM), but for multiple arrays of data, I suspect you’ll need to manually create a linked list of ReadOnlySequenceSegment&lt;t&gt; first, to pass into the final ReadOnlySequence. You’ve piqued my interest so I’ll have a look at some point.</p><p>What are you doing with the two arrays? My gut is that parsing each in turn would be more efficient anyway as it’s just two you are dealing with. Is performance critical in your case?”</p></div>
</blockquote>
<p>I stand by the points in my reply. For two arrays, manually parsing through them should be fairly simple, without having to resort to creating a ReadOnlySequence. I’d love to know more about the reader’s particular case. Perhaps there is a plausible scenario I’m not thinking of where this might be reasonable.</p>
<p>As an experimental learning exercise, let’s see if and how we can achieve the above requirement. Remember, this is for fun and not likely to be a valid option for real-world scenarios. You can find the code samples used in this blog post in my <a href="https://github.com/stevejgordon/ReadOnlySequencePlayground" target="_blank" rel="noopener noreferrer">ReadOnlySequencePlayground repository on GitHub</a>.</p>
<h2>Creating a ReadOnlySequence</h2>
<p>For this example, let’s start with three arrays containing sequences of integers.</p>



<div id="gist102390682">
    <div>
      <div>
        <div>
  <div id="file-program-cs">
    

  <div itemprop="text">
      
<table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-program-cs-L1" data-line-number="1"></td>
        <td id="file-program-cs-LC1"><span>var</span> <span>arrayOne</span> <span>=</span> <span>new</span>[] { <span>0</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span> };</td>
      </tr>
      <tr>
        <td id="file-program-cs-L2" data-line-number="2"></td>
        <td id="file-program-cs-LC2"><span>var</span> <span>arrayTwo</span> <span>=</span> <span>new</span>[] { <span>5</span>, <span>6</span>, <span>7</span>, <span>8</span>, <span>9</span> };</td>
      </tr>
      <tr>
        <td id="file-program-cs-L3" data-line-number="3"></td>
        <td id="file-program-cs-LC3"><span>var</span> <span>arrayThree</span> <span>=</span> <span>new</span>[] { <span>10</span>, <span>11</span>, <span>12</span>, <span>13</span>, <span>14</span> };</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>




<p>We’ll need to begin by creating a ReadOnlySequence that “wraps” these arrays into a single contiguous representation.</p>
<p>The ReadOnlySequence struct has four constructor overloads&nbsp;which can be used to create an instance.</p>



<div id="gist102390645">
    <div>
      <div>
        <div>
  <div id="file-readonlysequence-cs">
    

  <div itemprop="text">
      
<table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-readonlysequence-cs-L1" data-line-number="1"></td>
        <td id="file-readonlysequence-cs-LC1"><span>public</span> <span>ReadOnlySequence</span>(<span>ReadOnlySequenceSegment</span>&lt;<span>T</span>&gt; <span>startSegment</span>, <span>int</span> <span>startIndex</span>, <span>ReadOnlySequenceSegment</span>&lt;<span>T</span>&gt; <span>endSegment</span>, <span>int</span> <span>endIndex</span>)</td>
      </tr>
      <tr>
        <td id="file-readonlysequence-cs-L2" data-line-number="2"></td>
        <td id="file-readonlysequence-cs-LC2"><span>public</span> <span>ReadOnlySequence</span>(<span>ReadOnlyMemory</span>&lt;<span>T</span>&gt; <span>memory</span>)</td>
      </tr>
      <tr>
        <td id="file-readonlysequence-cs-L3" data-line-number="3"></td>
        <td id="file-readonlysequence-cs-LC3"><span>public</span> <span>ReadOnlySequence</span>(<span>T</span>[] <span>array</span>)</td>
      </tr>
      <tr>
        <td id="file-readonlysequence-cs-L4" data-line-number="4"></td>
        <td id="file-readonlysequence-cs-LC4"><span>public</span> <span>ReadOnlySequence</span>(<span>T</span>[] <span>array</span>, <span>int</span> <span>start</span>, <span>int</span> <span>length</span>)</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>




<p>The last three of these deal with creating a ReadOnlySequence wrapping a single contiguous block of memory, either an array or a ReadOnlyMemory&lt;T&gt;. None of these meet our requirement here. That leaves us with the constructor accepting some ReadOnlySequenceSegment&lt;T&gt; parameters.</p>



<div id="gist102394324">
    <div>
      <div>
        <div>
  <div id="file-readonlysequence-cs">
    

  <div itemprop="text">
      
<table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-readonlysequence-cs-L1" data-line-number="1"></td>
        <td id="file-readonlysequence-cs-LC1"><span>public</span> <span>ReadOnlySequence</span>(<span>ReadOnlySequenceSegment</span>&lt;<span>T</span>&gt; <span>startSegment</span>, <span>int</span> <span>startIndex</span>, <span>ReadOnlySequenceSegment</span>&lt;<span>T</span>&gt; <span>endSegment</span>, <span>int</span> <span>endIndex</span>)</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>




<p>So it appears we need two ReadOnlySequenceSegment&lt;T&gt; instances. Let’s take a look at that type. You can view the source in the <a href="https://github.com/dotnet/runtime/blob/master/src/libraries/System.Memory/src/System/Buffers/ReadOnlySequenceSegment.cs" target="_blank" rel="noopener noreferrer">.NET Runtime repository</a>, and I’ll include it here in its current form.</p>



<div id="gist102390854">
    <div>
      <div>
        <div>
  <div id="file-readonlysequencesegment-cs">
    

  <div itemprop="text">
      
<table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-readonlysequencesegment-cs-L1" data-line-number="1"></td>
        <td id="file-readonlysequencesegment-cs-LC1"><span>namespace</span> <span>System</span>.<span>Buffers</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L2" data-line-number="2"></td>
        <td id="file-readonlysequencesegment-cs-LC2">{</td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L3" data-line-number="3"></td>
        <td id="file-readonlysequencesegment-cs-LC3">    <span><span>///</span> &lt;<span><span>summary</span></span>&gt;</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L4" data-line-number="4"></td>
        <td id="file-readonlysequencesegment-cs-LC4">    <span><span>///</span> Represents a linked list of &lt;<span><span>see</span></span> <span><span>cref</span></span>=<span><span>"</span>ReadOnlyMemory{T}<span>"</span></span>/&gt; nodes.</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L5" data-line-number="5"></td>
        <td id="file-readonlysequencesegment-cs-LC5">    <span><span>///</span> &lt;/<span><span>summary</span></span>&gt;</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L6" data-line-number="6"></td>
        <td id="file-readonlysequencesegment-cs-LC6">    <span>public</span> <span>abstract</span> <span>class</span> <span>ReadOnlySequenceSegment</span>&lt;<span>T</span>&gt;</td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L7" data-line-number="7"></td>
        <td id="file-readonlysequencesegment-cs-LC7">    {</td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L8" data-line-number="8"></td>
        <td id="file-readonlysequencesegment-cs-LC8">        <span><span>///</span> &lt;<span><span>summary</span></span>&gt;</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L9" data-line-number="9"></td>
        <td id="file-readonlysequencesegment-cs-LC9">        <span><span>///</span> The &lt;<span><span>see</span></span> <span><span>cref</span></span>=<span><span>"</span>ReadOnlyMemory{T}<span>"</span></span>/&gt; value for current node.</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L10" data-line-number="10"></td>
        <td id="file-readonlysequencesegment-cs-LC10">        <span><span>///</span> &lt;/<span><span>summary</span></span>&gt;</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L11" data-line-number="11"></td>
        <td id="file-readonlysequencesegment-cs-LC11">        <span>public</span> <span>ReadOnlyMemory</span>&lt;<span>T</span>&gt; <span>Memory</span> { <span>get</span>; <span>protected</span> <span>set</span>; }</td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L12" data-line-number="12"></td>
        <td id="file-readonlysequencesegment-cs-LC12">
</td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L13" data-line-number="13"></td>
        <td id="file-readonlysequencesegment-cs-LC13">        <span><span>///</span> &lt;<span><span>summary</span></span>&gt;</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L14" data-line-number="14"></td>
        <td id="file-readonlysequencesegment-cs-LC14">        <span><span>///</span> The next node.</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L15" data-line-number="15"></td>
        <td id="file-readonlysequencesegment-cs-LC15">        <span><span>///</span> &lt;/<span><span>summary</span></span>&gt;</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L16" data-line-number="16"></td>
        <td id="file-readonlysequencesegment-cs-LC16">        <span>public</span> <span>ReadOnlySequenceSegment</span>&lt;<span>T</span>&gt;? <span>Next</span> { <span>get</span>; <span>protected</span> <span>set</span>; }</td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L17" data-line-number="17"></td>
        <td id="file-readonlysequencesegment-cs-LC17">
</td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L18" data-line-number="18"></td>
        <td id="file-readonlysequencesegment-cs-LC18">        <span><span>///</span> &lt;<span><span>summary</span></span>&gt;</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L19" data-line-number="19"></td>
        <td id="file-readonlysequencesegment-cs-LC19">        <span><span>///</span> The sum of node length before current.</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L20" data-line-number="20"></td>
        <td id="file-readonlysequencesegment-cs-LC20">        <span><span>///</span> &lt;/<span><span>summary</span></span>&gt;</span></td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L21" data-line-number="21"></td>
        <td id="file-readonlysequencesegment-cs-LC21">        <span>public</span> <span>long</span> <span>RunningIndex</span> { <span>get</span>; <span>protected</span> <span>set</span>; }</td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L22" data-line-number="22"></td>
        <td id="file-readonlysequencesegment-cs-LC22">    }</td>
      </tr>
      <tr>
        <td id="file-readonlysequencesegment-cs-L23" data-line-number="23"></td>
        <td id="file-readonlysequencesegment-cs-LC23">}</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>




<p>The first thing to note is that this is an abstract class, so we need to find a concrete implementation we can use. After hunting around in the runtime repository for a while, I found a derived class named BufferSegment&nbsp;within System.IO.Pipelines. Unfortunately, this type has the internal access modifier so we can’t use it here.</p>
<p>It turns out, there are no publicly derived types for ReadOnlySequenceSegment&lt;T&gt;, so we must create our own.</p>



<div id="gist102390970">
    <div>
      <div>
        <div>
  <div id="file-memorysegment-cs">
    

  <div itemprop="text">
      
<table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-memorysegment-cs-L1" data-line-number="1"></td>
        <td id="file-memorysegment-cs-LC1"><span>internal</span> <span>class</span> <span>MemorySegment</span>&lt;<span>T</span>&gt; : <span>ReadOnlySequenceSegment</span>&lt;<span>T</span>&gt;</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L2" data-line-number="2"></td>
        <td id="file-memorysegment-cs-LC2">{</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L3" data-line-number="3"></td>
        <td id="file-memorysegment-cs-LC3">    <span>public</span> <span>MemorySegment</span>(<span>ReadOnlyMemory</span>&lt;<span>T</span>&gt; <span>memory</span>)</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L4" data-line-number="4"></td>
        <td id="file-memorysegment-cs-LC4">    {</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L5" data-line-number="5"></td>
        <td id="file-memorysegment-cs-LC5">        <span>Memory</span> <span>=</span> <span>memory</span>;</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L6" data-line-number="6"></td>
        <td id="file-memorysegment-cs-LC6">    }</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L7" data-line-number="7"></td>
        <td id="file-memorysegment-cs-LC7">
</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L8" data-line-number="8"></td>
        <td id="file-memorysegment-cs-LC8">    <span>public</span> <span>MemorySegment</span>&lt;<span>T</span>&gt; <span>Append</span>(<span>ReadOnlyMemory</span>&lt;<span>T</span>&gt; <span>memory</span>)</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L9" data-line-number="9"></td>
        <td id="file-memorysegment-cs-LC9">    {</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L10" data-line-number="10"></td>
        <td id="file-memorysegment-cs-LC10">        <span>var</span> <span>segment</span> <span>=</span> <span>new</span> <span>MemorySegment</span>&lt;<span>T</span>&gt;(<span>memory</span>)</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L11" data-line-number="11"></td>
        <td id="file-memorysegment-cs-LC11">        {</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L12" data-line-number="12"></td>
        <td id="file-memorysegment-cs-LC12">            <span>RunningIndex</span> <span>=</span> <span>RunningIndex</span> <span>+</span> <span>Memory</span>.<span>Length</span></td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L13" data-line-number="13"></td>
        <td id="file-memorysegment-cs-LC13">        };</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L14" data-line-number="14"></td>
        <td id="file-memorysegment-cs-LC14">
</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L15" data-line-number="15"></td>
        <td id="file-memorysegment-cs-LC15">        <span>Next</span> <span>=</span> <span>segment</span>;</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L16" data-line-number="16"></td>
        <td id="file-memorysegment-cs-LC16">
</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L17" data-line-number="17"></td>
        <td id="file-memorysegment-cs-LC17">        <span>return</span> <span>segment</span>;</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L18" data-line-number="18"></td>
        <td id="file-memorysegment-cs-LC18">    }</td>
      </tr>
      <tr>
        <td id="file-memorysegment-cs-L19" data-line-number="19"></td>
        <td id="file-memorysegment-cs-LC19">}</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>




<p>The preceding code is a basic derived implementation of the abstract class. We can create an initial segment using the constructor, passing any type that can be represented as a ReadOnlyMemory&lt;T&gt;. That parameter is used to set the Memory property on the base class.</p>
<p>We also have an Append method which also takes a ReadOnlyMemory&lt;T&gt;. The segments are used to form a linked list structure. Each segment may hold a reference to the next segment in the chain. In this example, our Append method first creates a new MemorySegment&lt;T&gt;. It calculates and sets a value for the RunningIndex property on the new segment. The RunningIndex represents the sum of node lengths before the current node.</p>
<p>Append then sets the Next property on the current segment, with the reference to the new (next) segment we are appending. Finally, it returns the new segment.</p>
<p>This flow may be quite hard to visualise. Hopefully, it will become clearer once we begin to use our MemorySegment&lt;T&gt;.</p>



<div id="gist102391140">
    <div>
      <div>
        <div>
  <div id="file-program-cs">
    

  <div itemprop="text">
      
<table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-program-cs-L1" data-line-number="1"></td>
        <td id="file-program-cs-LC1"><span>var</span> <span>arrayOne</span> <span>=</span> <span>new</span>[] { <span>0</span>, <span>1</span>, <span>2</span>, <span>3</span>, <span>4</span> };</td>
      </tr>
      <tr>
        <td id="file-program-cs-L2" data-line-number="2"></td>
        <td id="file-program-cs-LC2"><span>var</span> <span>arrayTwo</span> <span>=</span> <span>new</span>[] { <span>5</span>, <span>6</span>, <span>7</span>, <span>8</span>, <span>9</span> };</td>
      </tr>
      <tr>
        <td id="file-program-cs-L3" data-line-number="3"></td>
        <td id="file-program-cs-LC3"><span>var</span> <span>arrayThree</span> <span>=</span> <span>new</span>[] { <span>10</span>, <span>11</span>, <span>12</span>, <span>13</span>, <span>14</span> };</td>
      </tr>
      <tr>
        <td id="file-program-cs-L4" data-line-number="4"></td>
        <td id="file-program-cs-LC4">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L5" data-line-number="5"></td>
        <td id="file-program-cs-LC5"><span>var</span> <span>first</span> <span>=</span> <span>new</span> <span>MemorySegment</span>&lt;<span>int</span>&gt;(<span>arrayOne</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L6" data-line-number="6"></td>
        <td id="file-program-cs-LC6"><span>var</span> <span>last</span> <span>=</span> <span>first</span>.<span>Append</span>(<span>arrayTwo</span>).<span>Append</span>(<span>arrayThree</span>);</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>




<p>We begin on line 5 in the sample code above. We create our first segment, passing in the first array. Because an array represents a contiguous region of memory, it confirms to the ReadOnlyMemory&lt;T&gt; argument. We hold onto this first segment in a local variable.</p>
<p>We then call append on the first segment, passing in the second array. This method returns a reference to that second segment. We can immediately chain on the third array using another Append call. This appends the last array as a third and final segment, linked to the second one.</p>



<div><figure><img src="https://www.stevejgordon.co.uk/wp-content/uploads/2020/04/ReadOnlySequence-Segments-Diagram-1024x456.png" alt="" srcset="https://www.stevejgordon.co.uk/wp-content/uploads/2020/04/ReadOnlySequence-Segments-Diagram-1024x456.png 1024w, https://www.stevejgordon.co.uk/wp-content/uploads/2020/04/ReadOnlySequence-Segments-Diagram-300x134.png 300w, https://www.stevejgordon.co.uk/wp-content/uploads/2020/04/ReadOnlySequence-Segments-Diagram-768x342.png 768w, https://www.stevejgordon.co.uk/wp-content/uploads/2020/04/ReadOnlySequence-Segments-Diagram.png 1167w" sizes="(max-width: 1024px) 100vw, 1024px"></figure></div>



<p>We must hold a reference to the first and the last segments in the chain as we’ve done here. We need those to create the ReadOnlySequence.</p>



<div id="gist102391973">
    <div>
      <div>
        <div>
  <div id="file-program-cs">
    

  <div itemprop="text">
      
<table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-program-cs-L1" data-line-number="1"></td>
        <td id="file-program-cs-LC1"><span>var</span> <span>first</span> <span>=</span> <span>new</span> <span>MemorySegment</span>&lt;<span>int</span>&gt;(<span>arrayOne</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L2" data-line-number="2"></td>
        <td id="file-program-cs-LC2"><span>var</span> <span>last</span> <span>=</span> <span>first</span>.<span>Append</span>(<span>arrayTwo</span>).<span>Append</span>(<span>arrayThree</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L3" data-line-number="3"></td>
        <td id="file-program-cs-LC3">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L4" data-line-number="4"></td>
        <td id="file-program-cs-LC4"><span>var</span> <span>ros</span> <span>=</span> <span>new</span> <span>ReadOnlySequence</span>&lt;<span>int</span>&gt;(<span>first</span>, <span>0</span>, <span>last</span>, <span>last</span>.<span>Memory</span>.<span>Length</span>);</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>




<p>On line 4 above, we are now ready to create a ReadOnlySequence&lt;int&gt; using our segments. We pass a reference to the first segment and the start index for the sequence. We want to begin at the start of the first segment, so the index in the second argument is zero.</p>
<p>We then pass the reference to the last segment, followed by the end index. The end index can be used to limit the sequence to a particular index within that final segment. In our case, we want the whole array, so we use the length of the memory referenced by the last segment.</p>
<p>We now have a ReadOnlySequence!</p>
<h2>Parsing the ReadOnlySequence</h2>
<p>Now that we have a ReadOnlySequence, we can look at how to consume the data from it. I won’t go into quite as much detail for these steps. Our imaginary scenario here will be that we want to access all values from the sequence. However, we want to start from the values after (and including) a value of 6. We need to store those values for future use somewhere in our application code. For this contrived example, we’ll just print the values out to the console once we have them.</p>
<p>We’ll start with a basic implementation and then simplify that slightly. A reminder once again that this is demo code, sufficient to illustrate a point and not necessarily “perfect” code to copy/paste into your production codebase!</p>



<div id="gist102392065">
    <div>
      <div>
        <div>
  <div id="file-program-cs">
    

  <div itemprop="text">
      
<table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-program-cs-L1" data-line-number="1"></td>
        <td id="file-program-cs-LC1"><span>private</span> <span>static</span> <span>void</span> <span>ParseExampleOne</span>(<span>ReadOnlySequence</span>&lt;<span>int</span>&gt; <span>ros</span>)</td>
      </tr>
      <tr>
        <td id="file-program-cs-L2" data-line-number="2"></td>
        <td id="file-program-cs-LC2">{</td>
      </tr>
      <tr>
        <td id="file-program-cs-L3" data-line-number="3"></td>
        <td id="file-program-cs-LC3">    <span>const</span> <span>int</span> <span>maxStackLength</span> <span>=</span> <span>32</span>; <span><span>//</span> 32 integers at 4 bytes each = 128 bytes</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L4" data-line-number="4"></td>
        <td id="file-program-cs-LC4">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L5" data-line-number="5"></td>
        <td id="file-program-cs-LC5">    <span>var</span> <span>sequenceReader</span> <span>=</span> <span>new</span> <span>SequenceReader</span>&lt;<span>int</span>&gt;(<span>ros</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L6" data-line-number="6"></td>
        <td id="file-program-cs-LC6">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L7" data-line-number="7"></td>
        <td id="file-program-cs-LC7">    <span>var</span> <span>sequenceLength</span> <span>=</span> <span>Convert</span>.<span>ToInt32</span>(<span>sequenceReader</span>.<span>Length</span>); <span><span>//</span> may throw for large sequences</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L8" data-line-number="8"></td>
        <td id="file-program-cs-LC8">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L9" data-line-number="9"></td>
        <td id="file-program-cs-LC9">    <span>Span</span>&lt;<span>int</span>&gt; <span>output</span> <span>=</span> <span>sequenceLength</span> <span>&lt;</span> <span>maxStackLength</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L10" data-line-number="10"></td>
        <td id="file-program-cs-LC10">        <span>?</span> <span>stackalloc</span> <span>int</span>[<span>sequenceLength</span>] <span><span>//</span> For small amounts of data we optimise to the stack for the output</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L11" data-line-number="11"></td>
        <td id="file-program-cs-LC11">        <span>:</span> <span>new</span> <span>int</span>[<span>sequenceLength</span>]; <span><span>//</span> This allocates and could be improved using ArrayPool&lt;T&gt;</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L12" data-line-number="12"></td>
        <td id="file-program-cs-LC12">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L13" data-line-number="13"></td>
        <td id="file-program-cs-LC13">    <span>var</span> <span>position</span> <span>=</span> <span>0</span>;</td>
      </tr>
      <tr>
        <td id="file-program-cs-L14" data-line-number="14"></td>
        <td id="file-program-cs-LC14">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L15" data-line-number="15"></td>
        <td id="file-program-cs-LC15">    <span><span>//</span> Same effect as above, but more verbose</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L16" data-line-number="16"></td>
        <td id="file-program-cs-LC16">    <span>if</span> (<span>sequenceReader</span>.<span>TryAdvanceTo</span>(<span>6</span>, <span>advancePastDelimiter</span>: <span>false</span>))</td>
      </tr>
      <tr>
        <td id="file-program-cs-L17" data-line-number="17"></td>
        <td id="file-program-cs-LC17">    {</td>
      </tr>
      <tr>
        <td id="file-program-cs-L18" data-line-number="18"></td>
        <td id="file-program-cs-LC18">        <span>while</span> (<span>!</span><span>sequenceReader</span>.<span>End</span>)</td>
      </tr>
      <tr>
        <td id="file-program-cs-L19" data-line-number="19"></td>
        <td id="file-program-cs-LC19">        {</td>
      </tr>
      <tr>
        <td id="file-program-cs-L20" data-line-number="20"></td>
        <td id="file-program-cs-LC20">            <span>if</span> (<span>sequenceReader</span>.<span>TryRead</span>(<span>out</span> <span>var</span> <span>value</span>))</td>
      </tr>
      <tr>
        <td id="file-program-cs-L21" data-line-number="21"></td>
        <td id="file-program-cs-LC21">            {</td>
      </tr>
      <tr>
        <td id="file-program-cs-L22" data-line-number="22"></td>
        <td id="file-program-cs-LC22">                <span>output</span>[<span>position</span><span>++</span>] <span>=</span> <span>value</span>; <span><span>//</span> copy data to the output buffer</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L23" data-line-number="23"></td>
        <td id="file-program-cs-LC23">            }</td>
      </tr>
      <tr>
        <td id="file-program-cs-L24" data-line-number="24"></td>
        <td id="file-program-cs-LC24">        }</td>
      </tr>
      <tr>
        <td id="file-program-cs-L25" data-line-number="25"></td>
        <td id="file-program-cs-LC25">    }</td>
      </tr>
      <tr>
        <td id="file-program-cs-L26" data-line-number="26"></td>
        <td id="file-program-cs-LC26">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L27" data-line-number="27"></td>
        <td id="file-program-cs-LC27">    <span>var</span> <span>finalData</span> <span>=</span> <span>output</span>.<span>Slice</span>(<span>0</span>, <span>position</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L28" data-line-number="28"></td>
        <td id="file-program-cs-LC28">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L29" data-line-number="29"></td>
        <td id="file-program-cs-LC29">    <span>foreach</span> (<span>var</span> <span>value</span> <span>in</span> <span>finalData</span>)</td>
      </tr>
      <tr>
        <td id="file-program-cs-L30" data-line-number="30"></td>
        <td id="file-program-cs-LC30">    {</td>
      </tr>
      <tr>
        <td id="file-program-cs-L31" data-line-number="31"></td>
        <td id="file-program-cs-LC31">        <span>Console</span>.<span>WriteLine</span>(<span>value</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L32" data-line-number="32"></td>
        <td id="file-program-cs-LC32">    }</td>
      </tr>
      <tr>
        <td id="file-program-cs-L33" data-line-number="33"></td>
        <td id="file-program-cs-LC33">}</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>




<p>We’ll use a SequenceReader here to make working with the ReadOnlySequence a little easier.</p>
<p>First, we need to create somewhere to store the final output of the data that we want. This will be the collection of integer values which appear after (and including) the value 6 in our ReadOnlySequence. Since we’re likely in a high-performance scenario if we find ourselves with a ReadOnlySequence, let’s try and be as efficient as we can.</p>
<p>We need somewhere to store our output values. On line 9, we can use Span&lt;T&gt; since it allows us to apply a handy optimisation. Since we know the maximum possible length of the data, assuming we may read the entire sequence, we can see if it’s safe to store our memory on the stack, rather than heap allocating an array. For this example, I’ve decided that 128 bytes is a reasonable maximum to allow on the stack here. That gives us headroom for 32 integers of 4 bytes each.</p>
<p>Span&lt;T&gt; allows us to represent contiguous memory on either the stack or heap, so we can set the variable of type Span&lt;int&gt; either with memory we allocate on the stack or an array on the heap.</p>
<p>One downside so far is that we determine the space we need based on the total number of values in the original sequence. We are expecting to have a reduced set of values when we parse the sequence, so our output memory is probably oversized. This may push us to allocate an array when the output data could perhaps meet our condition to be stored on the stack. We’ll ignore that for this example.</p>
<p>We can now use the sequence reader on line 16 to position ourselves at the first element in the sequence with a value of 6. From there, we will loop over each value until we reach the end of the sequence. Adding each value to the output memory. We update our position on each loop iteration so we can store the value into the appropriate index.</p>
<p>Once this is completed, we have our output memory populated with data. But, we expect that it’s likely we have not filled the entire memory region with data. So on line 27, we slice the Span&lt;int&gt; from the start until the position of the last element we added.</p>
<p>We now have a new Span&lt;int&gt; representing the memory, and therefore values, that we care about from the original sequence. In a real situation, we’d likely want to do some further processing, but for this sample, we’ll just print out each value to the console.</p>
<h2>Parsing the ReadOnlySequence (Take Two)</h2>
<p>Thanks for <a href="https://twitter.com/davidfowl" target="_blank" rel="noopener noreferrer">David Fowler</a> for a quick chat we had about my demo code. He pointed out that I could simplify the example, which then led me to this refactored code that I’m about to share with you.</p>



<div id="gist102392534">
    <div>
      <div>
        <div>
  <div id="file-program-cs">
    

  <div itemprop="text">
      
<table data-tab-size="8" data-paste-markdown-skip="">
      <tbody><tr>
        <td id="file-program-cs-L1" data-line-number="1"></td>
        <td id="file-program-cs-LC1"><span>private</span> <span>static</span> <span>void</span> <span>ParseExampleTwo</span>(<span>ReadOnlySequence</span>&lt;<span>int</span>&gt; <span>ros</span>)</td>
      </tr>
      <tr>
        <td id="file-program-cs-L2" data-line-number="2"></td>
        <td id="file-program-cs-LC2">{</td>
      </tr>
      <tr>
        <td id="file-program-cs-L3" data-line-number="3"></td>
        <td id="file-program-cs-LC3">    <span>const</span> <span>int</span> <span>maxStackLength</span> <span>=</span> <span>32</span>; <span><span>//</span> 128 bytes</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L4" data-line-number="4"></td>
        <td id="file-program-cs-LC4">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L5" data-line-number="5"></td>
        <td id="file-program-cs-LC5">    <span>var</span> <span>sequenceReader</span> <span>=</span> <span>new</span> <span>SequenceReader</span>&lt;<span>int</span>&gt;(<span>ros</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L6" data-line-number="6"></td>
        <td id="file-program-cs-LC6">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L7" data-line-number="7"></td>
        <td id="file-program-cs-LC7">    <span><span>//</span>Try to find and start reading from '6' onward</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L8" data-line-number="8"></td>
        <td id="file-program-cs-LC8">    <span>if</span> (<span>!</span><span>sequenceReader</span>.<span>TryAdvanceTo</span>(<span>6</span>, <span>advancePastDelimiter</span>: <span>false</span>)) <span>return</span>;</td>
      </tr>
      <tr>
        <td id="file-program-cs-L9" data-line-number="9"></td>
        <td id="file-program-cs-LC9">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L10" data-line-number="10"></td>
        <td id="file-program-cs-LC10">    <span>var</span> <span>remaining</span> <span>=</span> <span>sequenceReader</span>.<span>Sequence</span>.<span>Slice</span>(<span>sequenceReader</span>.<span>Position</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L11" data-line-number="11"></td>
        <td id="file-program-cs-LC11">    <span>var</span> <span>length</span> <span>=</span> <span>Convert</span>.<span>ToInt32</span>(<span>remaining</span>.<span>Length</span>); <span><span>//</span> may throw for large sequences</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L12" data-line-number="12"></td>
        <td id="file-program-cs-LC12">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L13" data-line-number="13"></td>
        <td id="file-program-cs-LC13">    <span>Span</span>&lt;<span>int</span>&gt; <span>output</span> <span>=</span> <span>length</span> <span>&lt;</span> <span>maxStackLength</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L14" data-line-number="14"></td>
        <td id="file-program-cs-LC14">        <span>?</span> <span>stackalloc</span> <span>int</span>[<span>length</span>] <span><span>//</span> For small amounts of data we optimise to the stack for the output</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L15" data-line-number="15"></td>
        <td id="file-program-cs-LC15">        <span>:</span> <span>new</span> <span>int</span>[<span>length</span>]; <span><span>//</span> This allocates and could be improved using ArrayPool&lt;T&gt;</span></td>
      </tr>
      <tr>
        <td id="file-program-cs-L16" data-line-number="16"></td>
        <td id="file-program-cs-LC16">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L17" data-line-number="17"></td>
        <td id="file-program-cs-LC17">    <span>remaining</span>.<span>CopyTo</span>(<span>output</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L18" data-line-number="18"></td>
        <td id="file-program-cs-LC18">
</td>
      </tr>
      <tr>
        <td id="file-program-cs-L19" data-line-number="19"></td>
        <td id="file-program-cs-LC19">    <span>foreach</span> (<span>var</span> <span>value</span> <span>in</span> <span>output</span>)</td>
      </tr>
      <tr>
        <td id="file-program-cs-L20" data-line-number="20"></td>
        <td id="file-program-cs-LC20">    {</td>
      </tr>
      <tr>
        <td id="file-program-cs-L21" data-line-number="21"></td>
        <td id="file-program-cs-LC21">        <span>Console</span>.<span>WriteLine</span>(<span>value</span>);</td>
      </tr>
      <tr>
        <td id="file-program-cs-L22" data-line-number="22"></td>
        <td id="file-program-cs-LC22">    }</td>
      </tr>
      <tr>
        <td id="file-program-cs-L23" data-line-number="23"></td>
        <td id="file-program-cs-LC23">}</td>
      </tr>
</tbody></table>


  </div>

  </div>
</div>

      </div>
      
    </div>
</div>




<p>This time, we first check if we have the value of 6 anywhere in our sequence. If we don’t, then we exit from the method immediately.</p>
<p>If we find an element with the value of 6, we can simply slice the entire sequence from that position. We do that on line 10 in the above code. At this point, we have another ReadOnlySequence representing the data we care about. In this example, that sequence is still backed by the last two segments we created since that’s where the data resides.</p>
<p>Since we now know the exact length of the final data, we can use the same approach as applied earlier to create a Span&lt;int&gt; backed by some memory large enough to hold the output data. Again we try to use the stack if there are 32 or fewer integers in the final data. This time, we are sure of the final length of the data that we want to output so we avoid oversizing the memory we need. This makes it more likely we’ll be able to stack allocate for small amounts of output data.</p>
<p>We then loop over the data and print the values to the console.</p>
<h2>Downsides of These Approaches</h2>
<p>We’ve now answered and implemented the question from the original comment.</p>
<blockquote>
<p>“How do I create a ReadOnlySequence from two arrays?”</p>
</blockquote>
<p>But just because you can do something in code, doesn’t mean you should. There are some things I’m not happy about in this sample.</p>
<h3>Code Verbosity</h3>
<p>First and foremost, it’s pretty verbose and required a moderate amount of code to first create a ReadOnlySequence and then parse through it. Given that the original question mentioned two arrays, I’m reasonably sure we could parse each of those, in turn, using a Span&lt;T&gt; based approach. Depending on the actual scenario, even that may be overkill, and a more straightforward technique of iterating over each array in turn, would probably suffice. Without knowing the exact scenario, the size of the arrays or the performance constraints, it’s impossible to say for sure which technique is best.</p>
<h3>Memory Allocations</h3>
<p>The second issue with this code concerns optimisation. While I’ve made reasonable efforts to parse the ReadOnlySequence with zero allocations, there remains an issue around creating the ReadOnlySequence in the first place.</p>
<p>Because we had multiple source data inputs, we were forced into using the constructor taking two ReadOnlySequenceSegment&lt;T&gt; parameters. Before we can create the ReadOnlySequence, we need a “linked list” of the memory segments. To achieve that, I created a class, MemorySegment&lt;T&gt;, which provided a fundamental implementation of the abstract ReadOnlySequenceSegment&lt;T&gt; class.</p>
<p>We then had to create three segments for each of the arrays, linking them together through our Append method. MemorySegment here is a class, which will result in a heap allocation for each instance. I measured that overhead, and it comes to 48 bytes per segment, a total of 144 bytes for my three segments. For a limited number segments, this might be reasonable, but where I would see this being applied more realistically, you’ll likely have many more segments. This allocation overhead, just to achieve the creation of a ReadOnlySequence may not be reasonable.</p>
<p>Imaging for a moment that we do have perhaps 200 arrays that we’d like to link into a ReadOnlySequence, a better approach would be to use a Pipe from System.IO.Pipelines. The Pipe concept would support this scenario quite reasonably. Firstly, you can read and write to a pipe independently in a thread-safe way. Therefore you could start two concurrent Tasks, one writing into the pipe from each array in turn, and another, reading through the sequence as data was flushed through.</p>
<p>A second advantage is that the pipe is heavily optimised on our behalf and pools the buffers and the link list nodes (segments) required to operate on the data efficiently. If the desired outcome were to access a ReadOnlySequence from a starting point of many independent arrays, I would indeed start with a Pipe. This would be easier than managing the creation and linking of each segment in my own code.</p>
<h2>Summary</h2>
<p>In this post, we took on a theoretical exercise and learned a little more about the ReadOnlySequence&lt;T&gt; type. I stand my original answer to the comment on my “<a href="https://www.stevejgordon.co.uk/an-introduction-to-sequencereader" target="_blank" rel="noopener noreferrer">An Introduction to SequenceReader</a>”&nbsp;blog post. I don’t think the code I’ve shown is a sensible choice for the actual problem being presented.</p>
<p>However, I love questions like this since it made me realise, I hadn’t actually considered how a ReadOnlySequence is created. By investigating this with a small sample, I learned more about how this type behaves, which I consider as time well invested. I hope you found reading this post equally useful or at least interesting!</p>
<p>I’ll end with one final reminder, please don’t put this code blindly into production. <strong>There are sure to be dragons!</strong></p>
<!-- PRyC WP: Add custom content to bottom of post/page: Standard Content START --></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>