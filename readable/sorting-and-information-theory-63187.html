<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Sorting and information theory - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Sorting and information theory - linksfor.dev(s)"/>
    <meta property="og:description" content="Category: math"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://guille.site/sorting-bounds.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Sorting and information theory</title>
<div class="readable">
        <h1>Sorting and information theory</h1>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 20 Jun 2020</div>
        <p><a href="https://guille.site/sorting-bounds.html">https://guille.site/sorting-bounds.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
<div>
    <div>
        <h2><a href="https://guille.site/">← Home</a></h2>
        
        <p>Category: <a href="https://guille.site/category/math.html">math</a></p>
        <p><label>Posted <strong>June 19, 2020</strong></label></p>
        <p>In this post, we'll talk a bit about the usual proofs about the
worst-case query complexity of sorting (at least, in the deterministic case) and then
use a beautiful (and surprisingly simple!) tool from information lower bounds to give a very general argument about why sorting requires at least <span><span><span id="MJXp-Span-1"><span id="MJXp-Span-2">Ω</span><span id="MJXp-Span-3">(</span><span id="MJXp-Span-4">n</span><span id="MJXp-Span-5">log</span><span id="MJXp-Span-6"></span><span id="MJXp-Span-7">n</span><span id="MJXp-Span-8">)</span></span></span><span id="MathJax-Element-1-Frame" tabindex="0"><nobr><span id="MathJax-Span-1"><span><span><span id="MathJax-Span-2"><span id="MathJax-Span-3">Ω</span><span id="MathJax-Span-4">(</span><span id="MathJax-Span-5">n</span><span id="MathJax-Span-6">log</span><span id="MathJax-Span-7"></span><span id="MathJax-Span-8">n</span><span id="MathJax-Span-9">)</span></span></span></span></span></nobr></span></span> queries to work.</p>
<h2>The usual approach</h2>
<p>There are many notes and posts talking about the fact that sorting will, in the worst case, always take <span><span><span id="MJXp-Span-9"><span id="MJXp-Span-10">Ω</span><span id="MJXp-Span-11">(</span><span id="MJXp-Span-12">n</span><span id="MJXp-Span-13">log</span><span id="MJXp-Span-14"></span><span id="MJXp-Span-15">n</span><span id="MJXp-Span-16">)</span></span></span><span id="MathJax-Element-2-Frame" tabindex="0"><nobr><span id="MathJax-Span-10"><span><span><span id="MathJax-Span-11"><span id="MathJax-Span-12">Ω</span><span id="MathJax-Span-13">(</span><span id="MathJax-Span-14">n</span><span id="MathJax-Span-15">log</span><span id="MathJax-Span-16"></span><span id="MathJax-Span-17">n</span><span id="MathJax-Span-18">)</span></span></span></span></span></nobr></span></span> comparisons; equivalently,
in the worst case, the number of comparisons is about a constant factor
away from <span><span><span id="MJXp-Span-17"><span id="MJXp-Span-18">n</span><span id="MJXp-Span-19">log</span><span id="MJXp-Span-20"></span><span id="MJXp-Span-21">n</span></span></span><span id="MathJax-Element-3-Frame" tabindex="0"><nobr><span id="MathJax-Span-19"><span><span><span id="MathJax-Span-20"><span id="MathJax-Span-21">n</span><span id="MathJax-Span-22">log</span><span id="MathJax-Span-23"></span><span id="MathJax-Span-24">n</span></span></span></span></span></nobr></span></span> when <span><span><span id="MJXp-Span-22"><span id="MJXp-Span-23">n</span></span></span><span id="MathJax-Element-4-Frame" tabindex="0"><nobr><span id="MathJax-Span-25"><span><span><span id="MathJax-Span-26"><span id="MathJax-Span-27">n</span></span></span></span></span></nobr></span></span> is large. In many cases, the proof
presented depends on the fact that the sorting algorithm is deterministic and goes a little like this (see <a href="https://www.bowdoin.edu/~ltoma/teaching/cs231/fall07/Lectures/sortLB.pdf">here</a> for a common case):</p>
<h3>Preliminaries</h3>
<p>Let <span><span><span id="MJXp-Span-24"><span id="MJXp-Span-25"><span id="MJXp-Span-26">C</span><span id="MJXp-Span-27">k</span></span></span></span><span id="MathJax-Element-5-Frame" tabindex="0"><nobr><span id="MathJax-Span-28"><span><span><span id="MathJax-Span-29"><span id="MathJax-Span-30"><span><span><span id="MathJax-Span-31">C<span></span></span><span></span></span><span><span id="MathJax-Span-32">k</span><span></span></span></span></span></span></span></span></span></nobr></span></span> be the <span><span><span id="MJXp-Span-28"><span id="MJXp-Span-29">k</span></span></span><span id="MathJax-Element-6-Frame" tabindex="0"><nobr><span id="MathJax-Span-33"><span><span><span id="MathJax-Span-34"><span id="MathJax-Span-35">k</span></span></span></span></span></nobr></span></span>th step of a deterministic sorting algorithm
(this can be represented, for example, as a tuple containing what the next comparison should be) with input <span><span><span id="MJXp-Span-30"><span id="MJXp-Span-31">L</span><span id="MJXp-Span-32">∈</span><span id="MJXp-Span-33"><span id="MJXp-Span-34">K</span><span id="MJXp-Span-35">n</span></span></span></span><span id="MathJax-Element-7-Frame" tabindex="0"><nobr><span id="MathJax-Span-36"><span><span><span id="MathJax-Span-37"><span id="MathJax-Span-38">L</span><span id="MathJax-Span-39">∈</span><span id="MathJax-Span-40"><span><span><span id="MathJax-Span-41">K<span></span></span><span></span></span><span><span id="MathJax-Span-42">n</span><span></span></span></span></span></span></span></span></span></nobr></span></span> where <span><span><span id="MJXp-Span-36"><span id="MJXp-Span-37">L</span></span></span><span id="MathJax-Element-8-Frame" tabindex="0"><nobr><span id="MathJax-Span-43"><span><span><span id="MathJax-Span-44"><span id="MathJax-Span-45">L</span></span></span></span></span></nobr></span></span> is a list of
<span><span><span id="MJXp-Span-38"><span id="MJXp-Span-39">n</span></span></span><span id="MathJax-Element-9-Frame" tabindex="0"><nobr><span id="MathJax-Span-46"><span><span><span id="MathJax-Span-47"><span id="MathJax-Span-48">n</span></span></span></span></span></nobr></span></span> comparable elements. (For example, <span><span><span id="MJXp-Span-40"><span id="MJXp-Span-41">L</span></span></span><span id="MathJax-Element-10-Frame" tabindex="0"><nobr><span id="MathJax-Span-49"><span><span><span id="MathJax-Span-50"><span id="MathJax-Span-51">L</span></span></span></span></span></nobr></span></span> can be a list of real numbers,
in which case <span><span><span id="MJXp-Span-42"><span id="MJXp-Span-43">K</span><span id="MJXp-Span-44">=</span><span id="MJXp-Span-45"><span id="MJXp-Span-46">R</span></span></span></span><span id="MathJax-Element-11-Frame" tabindex="0"></span></span>.)</p>
<p>By the definition of a deterministic algorithm, <span><span><span id="MJXp-Span-47"><span id="MJXp-Span-48"><span id="MJXp-Span-49">C</span><span id="MJXp-Span-50">k</span></span></span></span><span id="MathJax-Element-12-Frame" tabindex="0"></span></span> depends only on the past <span><span><span id="MJXp-Span-51"><span id="MJXp-Span-52">k</span><span id="MJXp-Span-53">−</span><span id="MJXp-Span-54">1</span></span></span><span id="MathJax-Element-13-Frame" tabindex="0"></span></span> comparisons; <em>i.e.</em>, <span><span><span id="MJXp-Span-55"><span id="MJXp-Span-56"><span id="MJXp-Span-57">C</span><span id="MJXp-Span-58">k</span></span><span id="MJXp-Span-59">(</span><span id="MJXp-Span-60"><span id="MJXp-Span-61">C</span><span id="MJXp-Span-62"><span id="MJXp-Span-63">k</span><span id="MJXp-Span-64">−</span><span id="MJXp-Span-65">1</span></span></span><span id="MJXp-Span-66">,</span><span id="MJXp-Span-67"><span id="MJXp-Span-68">C</span><span id="MJXp-Span-69"><span id="MJXp-Span-70">k</span><span id="MJXp-Span-71">−</span><span id="MJXp-Span-72">2</span></span></span><span id="MJXp-Span-73">,</span><span id="MJXp-Span-74">…</span><span id="MJXp-Span-75">,</span><span id="MJXp-Span-76"><span id="MJXp-Span-77">C</span><span id="MJXp-Span-78">1</span></span><span id="MJXp-Span-79">)</span></span></span><span id="MathJax-Element-14-Frame" tabindex="0"></span></span>. (I am slightly overloading
notation here, of course, but the meaning should be clear.) This means that we can view the
behavior of the algorithm as a tree, where <span><span><span id="MJXp-Span-80"><span id="MJXp-Span-81"><span id="MJXp-Span-82">C</span><span id="MJXp-Span-83">k</span></span></span></span><span id="MathJax-Element-15-Frame" tabindex="0"></span></span> is a child node of <span><span><span id="MJXp-Span-84"><span id="MJXp-Span-85"><span id="MJXp-Span-86">C</span><span id="MJXp-Span-87"><span id="MJXp-Span-88">k</span><span id="MJXp-Span-89">−</span><span id="MJXp-Span-90">1</span></span></span></span></span><span id="MathJax-Element-16-Frame" tabindex="0"></span></span> which itself is a child node of <span><span><span id="MJXp-Span-91"><span id="MJXp-Span-92"><span id="MJXp-Span-93">C</span><span id="MJXp-Span-94"><span id="MJXp-Span-95">k</span><span id="MJXp-Span-96">−</span><span id="MJXp-Span-97">2</span></span></span></span></span><span id="MathJax-Element-17-Frame" tabindex="0"></span></span>, etc. Additionally, the tree is
<em>binary</em> since the output of a comparison is only one of two possibilities (if <span><span><span id="MJXp-Span-98"><span id="MJXp-Span-99"><span id="MJXp-Span-100">C</span><span id="MJXp-Span-101">k</span></span><span id="MJXp-Span-102">=</span><span id="MJXp-Span-103">(</span><span id="MJXp-Span-104">a</span><span id="MJXp-Span-105">,</span><span id="MJXp-Span-106">b</span><span id="MJXp-Span-107">)</span></span></span><span id="MathJax-Element-18-Frame" tabindex="0"></span></span>, then either <span><span><span id="MJXp-Span-108"><span id="MJXp-Span-109">a</span><span id="MJXp-Span-110">≤</span><span id="MJXp-Span-111">b</span></span></span><span id="MathJax-Element-19-Frame" tabindex="0"></span></span> or <span><span><span id="MJXp-Span-112"><span id="MJXp-Span-113">b</span><span id="MJXp-Span-114">≤</span><span id="MJXp-Span-115">a</span></span></span><span id="MathJax-Element-20-Frame" tabindex="0"></span></span>).</p>
<p><img src="https://guille.site/images/sorting-bounds/comparison_tree.png"></p>
<p>Finally, let the leaf nodes of this tree be the list of indices (say, <span><span><span id="MJXp-Span-116"><span id="MJXp-Span-117">p</span></span></span><span id="MathJax-Element-21-Frame" tabindex="0"></span></span>, where each entry is an index, <span><span><span id="MJXp-Span-118"><span id="MJXp-Span-119"><span id="MJXp-Span-120">p</span><span id="MJXp-Span-121">i</span></span><span id="MJXp-Span-122">∈</span><span id="MJXp-Span-123">{</span><span id="MJXp-Span-124">1</span><span id="MJXp-Span-125">,</span><span id="MJXp-Span-126">…</span><span id="MJXp-Span-127">,</span><span id="MJXp-Span-128">n</span><span id="MJXp-Span-129">}</span></span></span><span id="MathJax-Element-22-Frame" tabindex="0"></span></span> for <span><span><span id="MJXp-Span-130"><span id="MJXp-Span-131">i</span><span id="MJXp-Span-132">=</span><span id="MJXp-Span-133">1</span><span id="MJXp-Span-134">,</span><span id="MJXp-Span-135">…</span><span id="MJXp-Span-136">,</span><span id="MJXp-Span-137">n</span></span></span><span id="MathJax-Element-23-Frame" tabindex="0"></span></span>) such that the list permuted
at these indices is sorted, <span><span><span id="MJXp-Span-138"><span id="MJXp-Span-139"><span id="MJXp-Span-140">L</span><span id="MJXp-Span-141"><span id="MJXp-Span-142"><span id="MJXp-Span-143">p</span><span id="MJXp-Span-144">1</span></span></span></span><span id="MJXp-Span-145">≤</span><span id="MJXp-Span-146"><span id="MJXp-Span-147">L</span><span id="MJXp-Span-148"><span id="MJXp-Span-149"><span id="MJXp-Span-150">p</span><span id="MJXp-Span-151">2</span></span></span></span><span id="MJXp-Span-152">≤</span><span id="MJXp-Span-153">…</span><span id="MJXp-Span-154">,</span><span id="MJXp-Span-155">≤</span><span id="MJXp-Span-156"><span id="MJXp-Span-157">L</span><span id="MJXp-Span-158"><span id="MJXp-Span-159"><span id="MJXp-Span-160">p</span><span id="MJXp-Span-161">n</span></span></span></span></span></span><span id="MathJax-Element-24-Frame" tabindex="0"></span></span>. Note that the number of nodes needed to get from the root node to a given
leaf node (or permutation) is exactly the number of comparisons that the algorithm makes before it returns a specific permutation. If we
can show that the height (the length of the longest path from root to leaf) of the tree is always larger than about <span><span><span id="MJXp-Span-162"><span id="MJXp-Span-163">n</span><span id="MJXp-Span-164">log</span><span id="MJXp-Span-165"></span><span id="MJXp-Span-166">n</span></span></span><span id="MathJax-Element-25-Frame" tabindex="0"></span></span>, then we've shown that this algorithm must take at least <span><span><span id="MJXp-Span-167"><span id="MJXp-Span-168">n</span><span id="MJXp-Span-169">log</span><span id="MJXp-Span-170"></span><span id="MJXp-Span-171">n</span></span></span><span id="MathJax-Element-26-Frame" tabindex="0"></span></span> steps.</p>
<h3>Bound on the height</h3>
<p>The idea for the bound is pretty simple: since this algorithm is a sorting
algorithm and it can receive <em>any</em> unsorted list, then each of the <span><span><span id="MJXp-Span-172"><span id="MJXp-Span-173">n</span><span id="MJXp-Span-174">!</span></span></span><span id="MathJax-Element-27-Frame" tabindex="0"></span></span> possible permutations must be a leaf node of the tree. (Why?) Additionally,
the maximum number of leaves for a binary tree of height <span><span><span id="MJXp-Span-175"><span id="MJXp-Span-176">h</span></span></span><span id="MathJax-Element-28-Frame" tabindex="0"></span></span> is <span><span><span id="MJXp-Span-177"><span id="MJXp-Span-178"><span id="MJXp-Span-179">2</span><span id="MJXp-Span-180">h</span></span></span></span><span id="MathJax-Element-29-Frame" tabindex="0"></span></span>, which, in turn, implies that we must have <span><span><span id="MJXp-Span-181"><span id="MJXp-Span-182"><span id="MJXp-Span-183">2</span><span id="MJXp-Span-184">h</span></span><span id="MJXp-Span-185">≥</span><span id="MJXp-Span-186">n</span><span id="MJXp-Span-187">!</span></span></span><span id="MathJax-Element-30-Frame" tabindex="0"></span></span>. Taking the log of both sides shows that:
</p>
<div><p><span><span id="MJXp-Span-188"><span id="MJXp-Span-189">h</span><span id="MJXp-Span-190">=</span><span id="MJXp-Span-191">log</span><span id="MJXp-Span-192"></span><span id="MJXp-Span-193">(</span><span id="MJXp-Span-194"><span id="MJXp-Span-195">2</span><span id="MJXp-Span-196">h</span></span><span id="MJXp-Span-197">)</span><span id="MJXp-Span-198">≥</span><span id="MJXp-Span-199">log</span><span id="MJXp-Span-200"></span><span id="MJXp-Span-201">(</span><span id="MJXp-Span-202">n</span><span id="MJXp-Span-203">!</span><span id="MJXp-Span-204">)</span><span id="MJXp-Span-205">=</span><span id="MJXp-Span-206">Ω</span><span id="MJXp-Span-207">(</span><span id="MJXp-Span-208">n</span><span id="MJXp-Span-209">log</span><span id="MJXp-Span-210"></span><span id="MJXp-Span-211">n</span><span id="MJXp-Span-212">)</span><span id="MJXp-Span-213">,</span></span></span></p></div>
<p>
which is exactly what we wanted to show. (The second equality is shown, for example, in the <a href="https://www.bowdoin.edu/~ltoma/teaching/cs231/fall07/Lectures/sortLB.pdf">original reference for this proof</a>; see page 2.)</p>
<h3>Some takeaways from this proof</h3>
<p>To prove this statement we only really used a few things: (a) the algorithm
has to decide between <span><span><span id="MJXp-Span-214"><span id="MJXp-Span-215">n</span><span id="MJXp-Span-216">!</span></span></span><span id="MathJax-Element-32-Frame" tabindex="0"></span></span> things, and (b) at each query, it only receives a "yes" or a "no" (as we will soon make rigorous, it only gains 1 bit of information from each query). The rest of the proof simply sets up scaffolding for the remaining parts, most of which is really somewhat orthogonal to our intuition. The point is: look, we have <span><span><span id="MJXp-Span-217"><span id="MJXp-Span-218">n</span><span id="MJXp-Span-219">!</span></span></span><span id="MathJax-Element-33-Frame" tabindex="0"></span></span> things we have to decide on and every time we ask a question, we cut down our list of possible true answers by about half. How many times do we need to cut down our list to be able to have exactly one possible answer? (Of course, as we showed before, this should be <span><span><span id="MJXp-Span-220"><span id="MJXp-Span-221"><span id="MJXp-Span-222">log</span><span id="MJXp-Span-223">2</span></span><span id="MJXp-Span-224"></span><span id="MJXp-Span-225">(</span><span id="MJXp-Span-226">n</span><span id="MJXp-Span-227">!</span><span id="MJXp-Span-228">)</span></span></span><span id="MathJax-Element-34-Frame" tabindex="0"></span></span>.)</p>
<p>Now, a good number of writings (and some textbooks) I've seen simply end here by saying "the algorithm gains at most 1 bit for every query and we need at least <span><span><span id="MJXp-Span-229"><span id="MJXp-Span-230">log</span><span id="MJXp-Span-231"></span><span id="MJXp-Span-232">(</span><span id="MJXp-Span-233">n</span><span id="MJXp-Span-234">!</span><span id="MJXp-Span-235">)</span><span id="MJXp-Span-236">∼</span><span id="MJXp-Span-237">n</span><span id="MJXp-Span-238">log</span><span id="MJXp-Span-239"></span><span id="MJXp-Span-240">n</span></span></span><span id="MathJax-Element-35-Frame" tabindex="0"></span></span> bits" and then give some vague citation to Shannon's theorem about communication without explicitly writing out any argument. (While there is some connection, it's unclear what it is or how to even make it rigorous in a general sense.) It's a bit of a shame since (as we will see) it doesn't really take much math to fully justify this intuitive statement.</p>
<h2>An information-theoretic approach</h2>
<p>The idea behind a (simple) information theoretic approach is to view the algorithm as attempting to 'uncover' the true, sorted permutation by querying an oracle that knows whether two elements are in sorted order or not. Here, the oracle gets to choose some 'true' permutation uniformly at random and then the sorting algorithm queries the oracle in a restricted sense: it can only ask yes or no questions about the list.</p>
<p>More formally, we will let <span><span><span id="MJXp-Span-241"><span id="MJXp-Span-242"><span id="MJXp-Span-243">X</span></span></span></span><span id="MathJax-Element-36-Frame" tabindex="0"></span></span> be the set of all <span><span><span id="MJXp-Span-244"><span id="MJXp-Span-245">n</span><span id="MJXp-Span-246">!</span></span></span><span id="MathJax-Element-37-Frame" tabindex="0"></span></span> possible permutations of <span><span><span id="MJXp-Span-247"><span id="MJXp-Span-248">1</span></span></span><span id="MathJax-Element-38-Frame" tabindex="0"></span></span> through <span><span><span id="MJXp-Span-249"><span id="MJXp-Span-250">n</span></span></span><span id="MathJax-Element-39-Frame" tabindex="0"></span></span> and let <span><span><span id="MJXp-Span-251"><span id="MJXp-Span-252">X</span></span></span><span id="MathJax-Element-40-Frame" tabindex="0"></span></span> the oracle's permutation such that <span><span><span id="MJXp-Span-253"><span id="MJXp-Span-254">X</span><span id="MJXp-Span-255">∼</span><span id="MJXp-Span-256"><span id="MJXp-Span-257">X</span></span></span></span><span id="MathJax-Element-41-Frame" tabindex="0"></span></span> is uniformly randomly sampled from <span><span><span id="MJXp-Span-258"><span id="MJXp-Span-259"><span id="MJXp-Span-260">X</span></span></span></span><span id="MathJax-Element-42-Frame" tabindex="0"></span></span>. Then, the algorithm gets to ask a sequence of yes/no queries <span><span><span id="MJXp-Span-261"><span id="MJXp-Span-262"><span id="MJXp-Span-263">Y</span><span id="MJXp-Span-264">i</span></span><span id="MJXp-Span-265">∈</span><span id="MJXp-Span-266">{</span><span id="MJXp-Span-267">0</span><span id="MJXp-Span-268">,</span><span id="MJXp-Span-269">1</span><span id="MJXp-Span-270">}</span></span></span><span id="MathJax-Element-43-Frame" tabindex="0"></span></span> for <span><span><span id="MJXp-Span-271"><span id="MJXp-Span-272">i</span><span id="MJXp-Span-273">=</span><span id="MJXp-Span-274">1</span><span id="MJXp-Span-275">,</span><span id="MJXp-Span-276">…</span><span id="MJXp-Span-277">,</span><span id="MJXp-Span-278">k</span></span></span><span id="MathJax-Element-44-Frame" tabindex="0"></span></span> which are dependent on the permutation <span><span><span id="MJXp-Span-279"><span id="MJXp-Span-280">X</span></span></span><span id="MathJax-Element-45-Frame" tabindex="0"></span></span>, and, at the end of <span><span><span id="MJXp-Span-281"><span id="MJXp-Span-282">k</span></span></span><span id="MathJax-Element-46-Frame" tabindex="0"></span></span> queries, must respond with some 'guess' for the true permutation <span><span><span id="MJXp-Span-283"><span id="MJXp-Span-284"><span id="MJXp-Span-285"><span><span><span><span id="MJXp-Span-287">ˆ</span></span><span><span id="MJXp-Span-286">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-47-Frame" tabindex="0"></span></span>, which is a random variable that depends only on <span><span><span id="MJXp-Span-288"><span id="MJXp-Span-289">Y</span></span></span><span id="MathJax-Element-48-Frame" tabindex="0"></span></span>. </p>
<p>The idea here is that, by picking a permutation uniformly at random and feeding it into the sorting algorithm, the sorting algorithm will, on average, always require at least <span><span><span id="MJXp-Span-290"><span id="MJXp-Span-291">n</span><span id="MJXp-Span-292">log</span><span id="MJXp-Span-293"></span><span id="MJXp-Span-294">n</span></span></span><span id="MathJax-Element-49-Frame" tabindex="0"></span></span> queries with high probability. In other words, the uniform distribution is a "hard" distribution for the problem.</p>
<p>We can represent the current set up as a Markov chain <span><span><span id="MJXp-Span-295"><span id="MJXp-Span-296">X</span><span id="MJXp-Span-297">→</span><span id="MJXp-Span-298">Y</span><span id="MJXp-Span-299">→</span><span id="MJXp-Span-300"><span id="MJXp-Span-301"><span><span><span><span id="MJXp-Span-303">ˆ</span></span><span><span id="MJXp-Span-302">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-50-Frame" tabindex="0"></span></span>, since <span><span><span id="MJXp-Span-304"><span id="MJXp-Span-305"><span id="MJXp-Span-306"><span><span><span><span id="MJXp-Span-308">ˆ</span></span><span><span id="MJXp-Span-307">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-51-Frame" tabindex="0"></span></span> is conditionally independent of <span><span><span id="MJXp-Span-309"><span id="MJXp-Span-310">X</span></span></span><span id="MathJax-Element-52-Frame" tabindex="0"></span></span> given <span><span><span id="MJXp-Span-311"><span id="MJXp-Span-312">Y</span></span></span><span id="MathJax-Element-53-Frame" tabindex="0"></span></span> (<em>i.e.</em>, the algorithm can only use information given by <span><span><span id="MJXp-Span-313"><span id="MJXp-Span-314">Y</span></span></span><span id="MathJax-Element-54-Frame" tabindex="0"></span></span>) while the random variable <span><span><span id="MJXp-Span-315"><span id="MJXp-Span-316">Y</span></span></span><span id="MathJax-Element-55-Frame" tabindex="0"></span></span> depends only on <span><span><span id="MJXp-Span-317"><span id="MJXp-Span-318">X</span></span></span><span id="MathJax-Element-56-Frame" tabindex="0"></span></span>. The idea then is to give a bound on the number of queries <span><span><span id="MJXp-Span-319"><span id="MJXp-Span-320">k</span></span></span><span id="MathJax-Element-57-Frame" tabindex="0"></span></span> required for an algorithm to succeed with probability 1.</p>
<p>To give a lower bound on this quantity, we'll use a tool from information theory called Fano's inequality, which, surprisingly, I don't often see taught in information theory courses. (Perhaps I haven't been taking the right ones!)</p>
<h3>Fano's inequality</h3>
<p>I learned about this lovely inequality in John Duchi's class, EE377: <em>Information Theory and Statistics</em> (the lectures notes for the class are <a href="http://web.stanford.edu/class/stats311/lecture-notes.pdf">here</a>). Its proof really makes it clear why entropy, as defined by Shannon, is pretty much the exact right quantity to look at. We'll explore a weaker version of it here that is simpler to prove and requires fewer definitions but which will suffice for our purposes.</p>
<p>We will use <span><span><span id="MJXp-Span-321"><span id="MJXp-Span-322">X</span><span id="MJXp-Span-323">,</span><span id="MJXp-Span-324">Y</span></span></span><span id="MathJax-Element-58-Frame" tabindex="0"></span></span> as random variables and set <span><span><span id="MJXp-Span-325"><span id="MJXp-Span-326">H</span></span></span><span id="MathJax-Element-59-Frame" tabindex="0"></span></span> as the entropy, defined:
</p>

<p>
where <span><span><span id="MJXp-Span-352"><span id="MJXp-Span-353"><span id="MJXp-Span-354">X</span></span></span></span><span id="MathJax-Element-61-Frame" tabindex="0"></span></span> is the space of values that <span><span><span id="MJXp-Span-355"><span id="MJXp-Span-356">X</span></span></span><span id="MathJax-Element-62-Frame" tabindex="0"></span></span> can take on. The conditional entropy of <span><span><span id="MJXp-Span-357"><span id="MJXp-Span-358">X</span></span></span><span id="MathJax-Element-63-Frame" tabindex="0"></span></span> given <span><span><span id="MJXp-Span-359"><span id="MJXp-Span-360">Y</span></span></span><span id="MathJax-Element-64-Frame" tabindex="0"></span></span> is defined as
</p>
<div><p><span><span id="MJXp-Span-361"><span id="MJXp-Span-362">H</span><span id="MJXp-Span-363">(</span><span id="MJXp-Span-364">X</span><span id="MJXp-Span-365"><span id="MJXp-Span-366">|</span></span><span id="MJXp-Span-367">Y</span><span id="MJXp-Span-368">)</span><span id="MJXp-Span-369">=</span><span id="MJXp-Span-370">−</span><span id="MJXp-Span-371"><span><span id="MJXp-Span-372"><span>∑</span></span></span><span><span id="MJXp-Span-373"><span id="MJXp-Span-374">Y</span><span id="MJXp-Span-375">∈</span><span id="MJXp-Span-376"><span id="MJXp-Span-377">Y</span></span></span></span></span><span id="MJXp-Span-378">P</span><span id="MJXp-Span-379">(</span><span id="MJXp-Span-380">Y</span><span id="MJXp-Span-381">)</span><span id="MJXp-Span-382"><span><span id="MJXp-Span-383"><span>∑</span></span></span><span><span id="MJXp-Span-384"><span id="MJXp-Span-385">X</span><span id="MJXp-Span-386">∈</span><span id="MJXp-Span-387"><span id="MJXp-Span-388">X</span></span></span></span></span><span id="MJXp-Span-389">P</span><span id="MJXp-Span-390">(</span><span id="MJXp-Span-391">X</span><span id="MJXp-Span-392">∣</span><span id="MJXp-Span-393">Y</span><span id="MJXp-Span-394">)</span><span id="MJXp-Span-395">log</span><span id="MJXp-Span-396"></span><span id="MJXp-Span-397">P</span><span id="MJXp-Span-398">(</span><span id="MJXp-Span-399">X</span><span id="MJXp-Span-400">∣</span><span id="MJXp-Span-401">Y</span><span id="MJXp-Span-402">)</span><span id="MJXp-Span-403">=</span><span id="MJXp-Span-404">H</span><span id="MJXp-Span-405">(</span><span id="MJXp-Span-406">X</span><span id="MJXp-Span-407">,</span><span id="MJXp-Span-408">Y</span><span id="MJXp-Span-409">)</span><span id="MJXp-Span-410">−</span><span id="MJXp-Span-411">H</span><span id="MJXp-Span-412">(</span><span id="MJXp-Span-413">Y</span><span id="MJXp-Span-414">)</span><span id="MJXp-Span-415">.</span></span></span></p></div>
<p>
As usual, the entropy <span><span><span id="MJXp-Span-416"><span id="MJXp-Span-417">H</span></span></span><span id="MathJax-Element-66-Frame" tabindex="0"></span></span> is a measure of the 'uncertainty' in the variable <span><span><span id="MJXp-Span-418"><span id="MJXp-Span-419">X</span></span></span><span id="MathJax-Element-67-Frame" tabindex="0"></span></span>, with the maximally uncertain distribution being the uniform one.<sup id="fnref:entropy"><a href="#fn:entropy">1</a></sup> Additionally, note that <span><span><span id="MJXp-Span-420"><span id="MJXp-Span-421">H</span><span id="MJXp-Span-422">(</span><span id="MJXp-Span-423">X</span><span id="MJXp-Span-424">,</span><span id="MJXp-Span-425">Y</span><span id="MJXp-Span-426">)</span></span></span><span id="MathJax-Element-68-Frame" tabindex="0"></span></span> is the entropy taken with respect to the joint distribution of <span><span><span id="MJXp-Span-427"><span id="MJXp-Span-428">X</span></span></span><span id="MathJax-Element-69-Frame" tabindex="0"></span></span> and <span><span><span id="MJXp-Span-429"><span id="MJXp-Span-430">Y</span></span></span><span id="MathJax-Element-70-Frame" tabindex="0"></span></span>. Finally, if <span><span><span id="MJXp-Span-431"><span id="MJXp-Span-432">X</span></span></span><span id="MathJax-Element-71-Frame" tabindex="0"></span></span> is a deterministic function of <span><span><span id="MJXp-Span-433"><span id="MJXp-Span-434">Y</span></span></span><span id="MathJax-Element-72-Frame" tabindex="0"></span></span>, then <span><span><span id="MJXp-Span-435"><span id="MJXp-Span-436">H</span><span id="MJXp-Span-437">(</span><span id="MJXp-Span-438">X</span><span id="MJXp-Span-439">∣</span><span id="MJXp-Span-440">Y</span><span id="MJXp-Span-441">)</span><span id="MJXp-Span-442">=</span><span id="MJXp-Span-443">0</span></span></span><span id="MathJax-Element-73-Frame" tabindex="0"></span></span> which follows from the definition.</p>
<p>For this post, we will only make use of the following three properties of the entropy (I will not prove them here, as there are many available proofs of them, including the notes above and Cover's famous <em>Elements of Information Theory</em>):</p>
<ol>
<li>The entropy can only decrease when removing variables, <span><span><span id="MJXp-Span-444"><span id="MJXp-Span-445">H</span><span id="MJXp-Span-446">(</span><span id="MJXp-Span-447">X</span><span id="MJXp-Span-448">,</span><span id="MJXp-Span-449">Y</span><span id="MJXp-Span-450">)</span><span id="MJXp-Span-451">≥</span><span id="MJXp-Span-452">H</span><span id="MJXp-Span-453">(</span><span id="MJXp-Span-454">X</span><span id="MJXp-Span-455">)</span></span></span><span id="MathJax-Element-74-Frame" tabindex="0"></span></span>.</li>
<li>The entropy is smaller than the log of the size of the sample space <span><span><span id="MJXp-Span-456"><span id="MJXp-Span-457">H</span><span id="MJXp-Span-458">(</span><span id="MJXp-Span-459">X</span><span id="MJXp-Span-460">∣</span><span id="MJXp-Span-461">Y</span><span id="MJXp-Span-462">)</span><span id="MJXp-Span-463">≤</span><span id="MJXp-Span-464">H</span><span id="MJXp-Span-465">(</span><span id="MJXp-Span-466">X</span><span id="MJXp-Span-467">)</span><span id="MJXp-Span-468">≤</span><span id="MJXp-Span-469">log</span><span id="MJXp-Span-470"></span><span id="MJXp-Span-471"><span id="MJXp-Span-472">|</span></span><span id="MJXp-Span-473"><span id="MJXp-Span-474">X</span></span><span id="MJXp-Span-475"><span id="MJXp-Span-476">|</span></span></span></span><span id="MathJax-Element-75-Frame" tabindex="0"></span></span>. (Equivalently, conditioning reduces entropy, and the uniform distribution on <span><span><span id="MJXp-Span-477"><span id="MJXp-Span-478"><span id="MJXp-Span-479">X</span></span></span></span><span id="MathJax-Element-76-Frame" tabindex="0"></span></span> has the highest possible entropy, <span><span><span id="MJXp-Span-480"><span id="MJXp-Span-481">log</span><span id="MJXp-Span-482"></span><span id="MJXp-Span-483"><span id="MJXp-Span-484">|</span></span><span id="MJXp-Span-485"><span id="MJXp-Span-486">X</span></span><span id="MJXp-Span-487"><span id="MJXp-Span-488">|</span></span></span></span><span id="MathJax-Element-77-Frame" tabindex="0"></span></span>.)</li>
<li>If a random variable <span><span><span id="MJXp-Span-489"><span id="MJXp-Span-490"><span id="MJXp-Span-491"><span><span><span><span id="MJXp-Span-493">ˆ</span></span><span><span id="MJXp-Span-492">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-78-Frame" tabindex="0"></span></span> is conditionally independent of <span><span><span id="MJXp-Span-494"><span id="MJXp-Span-495">X</span></span></span><span id="MathJax-Element-79-Frame" tabindex="0"></span></span> given <span><span><span id="MJXp-Span-496"><span id="MJXp-Span-497">Y</span></span></span><span id="MathJax-Element-80-Frame" tabindex="0"></span></span> (<em>i.e.</em>, if <span><span><span id="MJXp-Span-498"><span id="MJXp-Span-499">X</span><span id="MJXp-Span-500">→</span><span id="MJXp-Span-501">Y</span><span id="MJXp-Span-502">→</span><span id="MJXp-Span-503"><span id="MJXp-Span-504"><span><span><span><span id="MJXp-Span-506">ˆ</span></span><span><span id="MJXp-Span-505">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-81-Frame" tabindex="0"></span></span> is a Markov chain), then <span><span><span id="MJXp-Span-507"><span id="MJXp-Span-508">H</span><span id="MJXp-Span-509">(</span><span id="MJXp-Span-510">X</span><span id="MJXp-Span-511">∣</span><span id="MJXp-Span-512"><span id="MJXp-Span-513"><span><span><span><span id="MJXp-Span-515">ˆ</span></span><span><span id="MJXp-Span-514">X</span></span></span></span></span></span><span id="MJXp-Span-516">)</span><span id="MJXp-Span-517">≥</span><span id="MJXp-Span-518">H</span><span id="MJXp-Span-519">(</span><span id="MJXp-Span-520">X</span><span id="MJXp-Span-521">∣</span><span id="MJXp-Span-522">Y</span><span id="MJXp-Span-523">)</span></span></span><span id="MathJax-Element-82-Frame" tabindex="0"></span></span>. This is often called a <a href="https://en.wikipedia.org/wiki/Data_processing_inequality">data processing inequality</a>, which simply says that <span><span><span id="MJXp-Span-524"><span id="MJXp-Span-525">X</span></span></span><span id="MathJax-Element-83-Frame" tabindex="0"></span></span> has smaller entropy knowing <span><span><span id="MJXp-Span-526"><span id="MJXp-Span-527">Y</span></span></span><span id="MathJax-Element-84-Frame" tabindex="0"></span></span> than knowing a variable, <span><span><span id="MJXp-Span-528"><span id="MJXp-Span-529"><span id="MJXp-Span-530"><span><span><span><span id="MJXp-Span-532">ˆ</span></span><span><span id="MJXp-Span-531">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-85-Frame" tabindex="0"></span></span>, that has undergone further processing. In other words, you cannot gain more information about <span><span><span id="MJXp-Span-533"><span id="MJXp-Span-534">X</span></span></span><span id="MathJax-Element-86-Frame" tabindex="0"></span></span> from a variable <span><span><span id="MJXp-Span-535"><span id="MJXp-Span-536">Y</span></span></span><span id="MathJax-Element-87-Frame" tabindex="0"></span></span> by further processing <span><span><span id="MJXp-Span-537"><span id="MJXp-Span-538">Y</span></span></span><span id="MathJax-Element-88-Frame" tabindex="0"></span></span>.</li>
</ol>
<p>This is all we need to prove the following inequality. Let <span><span><span id="MJXp-Span-539"><span id="MJXp-Span-540">X</span><span id="MJXp-Span-541">→</span><span id="MJXp-Span-542">Y</span><span id="MJXp-Span-543">→</span><span id="MJXp-Span-544"><span id="MJXp-Span-545"><span><span><span><span id="MJXp-Span-547">ˆ</span></span><span><span id="MJXp-Span-546">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-89-Frame" tabindex="0"></span></span> be a Markov chain such that <span><span><span id="MJXp-Span-548"><span id="MJXp-Span-549"><span id="MJXp-Span-550"><span><span><span><span id="MJXp-Span-552">ˆ</span></span><span><span id="MJXp-Span-551">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-90-Frame" tabindex="0"></span></span> is conditionally independent of <span><span><span id="MJXp-Span-553"><span id="MJXp-Span-554">X</span></span></span><span id="MathJax-Element-91-Frame" tabindex="0"></span></span> given <span><span><span id="MJXp-Span-555"><span id="MJXp-Span-556">Y</span></span></span><span id="MathJax-Element-92-Frame" tabindex="0"></span></span> and <span><span><span id="MJXp-Span-557"><span id="MJXp-Span-558">X</span></span></span><span id="MathJax-Element-93-Frame" tabindex="0"></span></span> is uniformly drawn from <span><span><span id="MJXp-Span-559"><span id="MJXp-Span-560"><span id="MJXp-Span-561">X</span></span></span></span><span id="MathJax-Element-94-Frame" tabindex="0"></span></span>, then the probability that <span><span><span id="MJXp-Span-562"><span id="MJXp-Span-563">X</span><span id="MJXp-Span-564">≠</span><span id="MJXp-Span-565"><span id="MJXp-Span-566"><span><span><span><span id="MJXp-Span-568">ˆ</span></span><span><span id="MJXp-Span-567">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-95-Frame" tabindex="0"></span></span> is given by <span><span><span id="MJXp-Span-569"><span id="MJXp-Span-570"><span id="MJXp-Span-571">P</span><span id="MJXp-Span-572">e</span></span></span></span><span id="MathJax-Element-96-Frame" tabindex="0"></span></span> and <span><span><span id="MJXp-Span-573"><span id="MJXp-Span-574"><span id="MJXp-Span-575">P</span><span id="MJXp-Span-576">e</span></span></span></span><span id="MathJax-Element-97-Frame" tabindex="0"></span></span> satisfies
</p>

<p>
where <span><span><span id="MJXp-Span-597"><span id="MJXp-Span-598">k</span></span></span><span id="MathJax-Element-99-Frame" tabindex="0"></span></span> is the number of binary queries made and <span><span><span id="MJXp-Span-599"><span id="MJXp-Span-600"><span id="MJXp-Span-601">|</span></span><span id="MJXp-Span-602"><span id="MJXp-Span-603">X</span></span><span id="MJXp-Span-604"><span id="MJXp-Span-605">|</span></span></span></span><span id="MathJax-Element-100-Frame" tabindex="0"></span></span> is the number of elements in <span><span><span id="MJXp-Span-606"><span id="MJXp-Span-607"><span id="MJXp-Span-608">X</span></span></span></span><span id="MathJax-Element-101-Frame" tabindex="0"></span></span>.</p>
<h3>A quick aside</h3>
<p>Proving this inequality is enough to show the claim. Note that, we want the probability of error to be 0 (since we want our algorithm to work!) so
</p>
<div><p><span><span id="MJXp-Span-609"><span id="MJXp-Span-610">1</span><span id="MJXp-Span-611">−</span><span id="MJXp-Span-612"><span><span id="MJXp-Span-613">k</span><span id="MJXp-Span-614">+</span><span id="MJXp-Span-615">1</span></span><span><span><span><span></span></span><span><span><span id="MJXp-Span-616">log</span><span id="MJXp-Span-617"></span><span id="MJXp-Span-618"><span id="MJXp-Span-619">|</span></span><span id="MJXp-Span-620"><span id="MJXp-Span-621">X</span></span><span id="MJXp-Span-622"><span id="MJXp-Span-623">|</span></span></span></span></span></span></span><span id="MJXp-Span-624">≤</span><span id="MJXp-Span-625">0</span><span id="MJXp-Span-626"></span><span id="MJXp-Span-627">implies</span><span id="MJXp-Span-628"></span><span id="MJXp-Span-629">k</span><span id="MJXp-Span-630">+</span><span id="MJXp-Span-631">1</span><span id="MJXp-Span-632">≥</span><span id="MJXp-Span-633">log</span><span id="MJXp-Span-634"></span><span id="MJXp-Span-635"><span id="MJXp-Span-636">|</span></span><span id="MJXp-Span-637"><span id="MJXp-Span-638">X</span></span><span id="MJXp-Span-639"><span id="MJXp-Span-640">|</span></span><span id="MJXp-Span-641">,</span></span></span></p></div>
<p>
and, since <span><span><span id="MJXp-Span-642"><span id="MJXp-Span-643"><span id="MJXp-Span-644">|</span></span><span id="MJXp-Span-645"><span id="MJXp-Span-646">X</span></span><span id="MJXp-Span-647"><span id="MJXp-Span-648">|</span></span></span></span><span id="MathJax-Element-103-Frame" tabindex="0"></span></span> is the space of possible permutations of size <span><span><span id="MJXp-Span-649"><span id="MJXp-Span-650">n</span></span></span><span id="MathJax-Element-104-Frame" tabindex="0"></span></span>, (of which there are <span><span><span id="MJXp-Span-651"><span id="MJXp-Span-652">n</span><span id="MJXp-Span-653">!</span></span></span><span id="MathJax-Element-105-Frame" tabindex="0"></span></span> of) then <span><span><span id="MJXp-Span-654"><span id="MJXp-Span-655"><span id="MJXp-Span-656">|</span></span><span id="MJXp-Span-657"><span id="MJXp-Span-658">X</span></span><span id="MJXp-Span-659"><span id="MJXp-Span-660">|</span></span><span id="MJXp-Span-661">=</span><span id="MJXp-Span-662">n</span><span id="MJXp-Span-663">!</span></span></span><span id="MathJax-Element-106-Frame" tabindex="0"></span></span> and <span><span><span id="MJXp-Span-664"><span id="MJXp-Span-665">log</span><span id="MJXp-Span-666"></span><span id="MJXp-Span-667">n</span><span id="MJXp-Span-668">!</span><span id="MJXp-Span-669">∼</span><span id="MJXp-Span-670">Ω</span><span id="MJXp-Span-671">(</span><span id="MJXp-Span-672">n</span><span id="MJXp-Span-673">log</span><span id="MJXp-Span-674"></span><span id="MJXp-Span-675">n</span><span id="MJXp-Span-676">)</span></span></span><span id="MathJax-Element-107-Frame" tabindex="0"></span></span> then <span><span><span id="MJXp-Span-677"><span id="MJXp-Span-678">k</span></span></span><span id="MathJax-Element-108-Frame" tabindex="0"></span></span> must satisfy
</p>

<p>
In other words, the number of queries (or comparisons, or whatever) <span><span><span id="MJXp-Span-690"><span id="MJXp-Span-691">k</span></span></span><span id="MathJax-Element-110-Frame" tabindex="0"></span></span> must be approximately at least as large as <span><span><span id="MJXp-Span-692"><span id="MJXp-Span-693">n</span><span id="MJXp-Span-694">log</span><span id="MJXp-Span-695"></span><span id="MJXp-Span-696">n</span></span></span><span id="MathJax-Element-111-Frame" tabindex="0"></span></span>, asymptotically (up to constant multiples). In fact, this proves a slightly <em>stronger</em> statement that no probabilistic algorithm can succeed with nonvanishing probability if the number of queries is not on the order of <span><span><span id="MJXp-Span-697"><span id="MJXp-Span-698">n</span><span id="MJXp-Span-699">log</span><span id="MJXp-Span-700"></span><span id="MJXp-Span-701">n</span></span></span><span id="MathJax-Element-112-Frame" tabindex="0"></span></span>, which our original proof above does not cover!</p>
<p>Now, the last missing piece is showing that the probability of error is bounded from below.</p>
<h3>A proof of Fano's inequality</h3>
<p>This is a slightly simplified version of the proof presented in <a href="http://web.stanford.edu/class/stats311/lecture-notes.pdf">Duchi's notes</a> (see section 2.3.2) for the specific case we care about, which requires less additional definitions and supporting statements. Let <span><span><span id="MJXp-Span-702"><span id="MJXp-Span-703">E</span></span></span><span id="MathJax-Element-113-Frame" tabindex="0"></span></span> be the 'error' random variable that is <span><span><span id="MJXp-Span-704"><span id="MJXp-Span-705">1</span></span></span><span id="MathJax-Element-114-Frame" tabindex="0"></span></span> if <span><span><span id="MJXp-Span-706"><span id="MJXp-Span-707">X</span><span id="MJXp-Span-708">≠</span><span id="MJXp-Span-709"><span id="MJXp-Span-710"><span><span><span><span id="MJXp-Span-712">ˆ</span></span><span><span id="MJXp-Span-711">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-115-Frame" tabindex="0"></span></span> and 0 otherwise, then let's look at the quantity <span><span><span id="MJXp-Span-713"><span id="MJXp-Span-714">H</span><span id="MJXp-Span-715">(</span><span id="MJXp-Span-716">E</span><span id="MJXp-Span-717">,</span><span id="MJXp-Span-718">X</span><span id="MJXp-Span-719">∣</span><span id="MJXp-Span-720"><span id="MJXp-Span-721"><span><span><span><span id="MJXp-Span-723">ˆ</span></span><span><span id="MJXp-Span-722">X</span></span></span></span></span></span><span id="MJXp-Span-724">)</span></span></span><span id="MathJax-Element-116-Frame" tabindex="0"></span></span>:
</p>
<div><p><span><span id="MJXp-Span-725"><span id="MJXp-Span-726">H</span><span id="MJXp-Span-727">(</span><span id="MJXp-Span-728">E</span><span id="MJXp-Span-729">,</span><span id="MJXp-Span-730">X</span><span id="MJXp-Span-731">∣</span><span id="MJXp-Span-732"><span id="MJXp-Span-733"><span><span><span><span id="MJXp-Span-735">ˆ</span></span><span><span id="MJXp-Span-734">X</span></span></span></span></span></span><span id="MJXp-Span-736">)</span><span id="MJXp-Span-737">=</span><span id="MJXp-Span-738">H</span><span id="MJXp-Span-739">(</span><span id="MJXp-Span-740">X</span><span id="MJXp-Span-741">∣</span><span id="MJXp-Span-742"><span id="MJXp-Span-743"><span><span><span><span id="MJXp-Span-745">ˆ</span></span><span><span id="MJXp-Span-744">X</span></span></span></span></span></span><span id="MJXp-Span-746">,</span><span id="MJXp-Span-747">E</span><span id="MJXp-Span-748">)</span><span id="MJXp-Span-749">+</span><span id="MJXp-Span-750">H</span><span id="MJXp-Span-751">(</span><span id="MJXp-Span-752">E</span><span id="MJXp-Span-753">∣</span><span id="MJXp-Span-754"><span id="MJXp-Span-755"><span><span><span><span id="MJXp-Span-757">ˆ</span></span><span><span id="MJXp-Span-756">X</span></span></span></span></span></span><span id="MJXp-Span-758">)</span><span id="MJXp-Span-759">,</span></span></span></p></div>
<p>
by our definition of conditional entropy, and
</p>
<div><p><span><span id="MJXp-Span-760"><span id="MJXp-Span-761">H</span><span id="MJXp-Span-762">(</span><span id="MJXp-Span-763">X</span><span id="MJXp-Span-764">∣</span><span id="MJXp-Span-765"><span id="MJXp-Span-766"><span><span><span><span id="MJXp-Span-768">ˆ</span></span><span><span id="MJXp-Span-767">X</span></span></span></span></span></span><span id="MJXp-Span-769">,</span><span id="MJXp-Span-770">E</span><span id="MJXp-Span-771">)</span><span id="MJXp-Span-772">=</span><span id="MJXp-Span-773"><span id="MJXp-Span-774">P</span><span id="MJXp-Span-775">e</span></span><span id="MJXp-Span-776">H</span><span id="MJXp-Span-777">(</span><span id="MJXp-Span-778">X</span><span id="MJXp-Span-779">∣</span><span id="MJXp-Span-780"><span id="MJXp-Span-781"><span><span><span><span id="MJXp-Span-783">ˆ</span></span><span><span id="MJXp-Span-782">X</span></span></span></span></span></span><span id="MJXp-Span-784">,</span><span id="MJXp-Span-785">E</span><span id="MJXp-Span-786">=</span><span id="MJXp-Span-787">1</span><span id="MJXp-Span-788">)</span><span id="MJXp-Span-789">+</span><span id="MJXp-Span-790">(</span><span id="MJXp-Span-791">1</span><span id="MJXp-Span-792">−</span><span id="MJXp-Span-793"><span id="MJXp-Span-794">P</span><span id="MJXp-Span-795">e</span></span><span id="MJXp-Span-796">)</span><span id="MJXp-Span-797">H</span><span id="MJXp-Span-798">(</span><span id="MJXp-Span-799">X</span><span id="MJXp-Span-800">∣</span><span id="MJXp-Span-801"><span id="MJXp-Span-802"><span><span><span><span id="MJXp-Span-804">ˆ</span></span><span><span id="MJXp-Span-803">X</span></span></span></span></span></span><span id="MJXp-Span-805">,</span><span id="MJXp-Span-806">E</span><span id="MJXp-Span-807">=</span><span id="MJXp-Span-808">0</span><span id="MJXp-Span-809">)</span><span id="MJXp-Span-810">,</span></span></span></p></div>
<p>
again by the same definition. Since <span><span><span id="MJXp-Span-811"><span id="MJXp-Span-812">X</span><span id="MJXp-Span-813">=</span><span id="MJXp-Span-814"><span id="MJXp-Span-815"><span><span><span><span id="MJXp-Span-817">ˆ</span></span><span><span id="MJXp-Span-816">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-119-Frame" tabindex="0"></span></span> whenever there is no error, <span><span><span id="MJXp-Span-818"><span id="MJXp-Span-819">E</span><span id="MJXp-Span-820">=</span><span id="MJXp-Span-821">0</span></span></span><span id="MathJax-Element-120-Frame" tabindex="0"></span></span>, then <span><span><span id="MJXp-Span-822"><span id="MJXp-Span-823">H</span><span id="MJXp-Span-824">(</span><span id="MJXp-Span-825">X</span><span id="MJXp-Span-826">∣</span><span id="MJXp-Span-827"><span id="MJXp-Span-828"><span><span><span><span id="MJXp-Span-830">ˆ</span></span><span><span id="MJXp-Span-829">X</span></span></span></span></span></span><span id="MJXp-Span-831">,</span><span id="MJXp-Span-832">E</span><span id="MJXp-Span-833">=</span><span id="MJXp-Span-834">0</span><span id="MJXp-Span-835">)</span><span id="MJXp-Span-836">=</span><span id="MJXp-Span-837">0</span></span></span><span id="MathJax-Element-121-Frame" tabindex="0"></span></span> since <span><span><span id="MJXp-Span-838"><span id="MJXp-Span-839">X</span></span></span><span id="MathJax-Element-122-Frame" tabindex="0"></span></span> is known, so, we really have
</p>
<div><p><span><span id="MJXp-Span-840"><span id="MJXp-Span-841">H</span><span id="MJXp-Span-842">(</span><span id="MJXp-Span-843">E</span><span id="MJXp-Span-844">,</span><span id="MJXp-Span-845">X</span><span id="MJXp-Span-846">∣</span><span id="MJXp-Span-847"><span id="MJXp-Span-848"><span><span><span><span id="MJXp-Span-850">ˆ</span></span><span><span id="MJXp-Span-849">X</span></span></span></span></span></span><span id="MJXp-Span-851">)</span><span id="MJXp-Span-852">=</span><span id="MJXp-Span-853"><span id="MJXp-Span-854">P</span><span id="MJXp-Span-855">e</span></span><span id="MJXp-Span-856">H</span><span id="MJXp-Span-857">(</span><span id="MJXp-Span-858">X</span><span id="MJXp-Span-859">∣</span><span id="MJXp-Span-860"><span id="MJXp-Span-861"><span><span><span><span id="MJXp-Span-863">ˆ</span></span><span><span id="MJXp-Span-862">X</span></span></span></span></span></span><span id="MJXp-Span-864">,</span><span id="MJXp-Span-865">E</span><span id="MJXp-Span-866">=</span><span id="MJXp-Span-867">1</span><span id="MJXp-Span-868">)</span><span id="MJXp-Span-869">+</span><span id="MJXp-Span-870">H</span><span id="MJXp-Span-871">(</span><span id="MJXp-Span-872">E</span><span id="MJXp-Span-873">∣</span><span id="MJXp-Span-874"><span id="MJXp-Span-875"><span><span><span><span id="MJXp-Span-877">ˆ</span></span><span><span id="MJXp-Span-876">X</span></span></span></span></span></span><span id="MJXp-Span-878">)</span><span id="MJXp-Span-879">.</span></span></span></p></div>
<p>
Since <span><span><span id="MJXp-Span-880"><span id="MJXp-Span-881">E</span></span></span><span id="MathJax-Element-124-Frame" tabindex="0"></span></span> can only take on two values, we have that <span><span><span id="MJXp-Span-882"><span id="MJXp-Span-883">H</span><span id="MJXp-Span-884">(</span><span id="MJXp-Span-885">E</span><span id="MJXp-Span-886">∣</span><span id="MJXp-Span-887"><span id="MJXp-Span-888"><span><span><span><span id="MJXp-Span-890">ˆ</span></span><span><span id="MJXp-Span-889">X</span></span></span></span></span></span><span id="MJXp-Span-891">)</span><span id="MJXp-Span-892">≤</span><span id="MJXp-Span-893">log</span><span id="MJXp-Span-894"></span><span id="MJXp-Span-895">(</span><span id="MJXp-Span-896">2</span><span id="MJXp-Span-897">)</span><span id="MJXp-Span-898">=</span><span id="MJXp-Span-899">1</span></span></span><span id="MathJax-Element-125-Frame" tabindex="0"></span></span> and we also have that <span><span><span id="MJXp-Span-900"><span id="MJXp-Span-901">H</span><span id="MJXp-Span-902">(</span><span id="MJXp-Span-903">X</span><span id="MJXp-Span-904">∣</span><span id="MJXp-Span-905"><span id="MJXp-Span-906"><span><span><span><span id="MJXp-Span-908">ˆ</span></span><span><span id="MJXp-Span-907">X</span></span></span></span></span></span><span id="MJXp-Span-909">,</span><span id="MJXp-Span-910">E</span><span id="MJXp-Span-911">=</span><span id="MJXp-Span-912">1</span><span id="MJXp-Span-913">)</span><span id="MJXp-Span-914">≤</span><span id="MJXp-Span-915">log</span><span id="MJXp-Span-916"></span><span id="MJXp-Span-917"><span id="MJXp-Span-918">|</span></span><span id="MJXp-Span-919"><span id="MJXp-Span-920">X</span></span><span id="MJXp-Span-921"><span id="MJXp-Span-922">|</span></span></span></span><span id="MathJax-Element-126-Frame" tabindex="0"></span></span>, which gives
</p>

<p>
Now, we have that
</p>
<div><p><span><span id="MJXp-Span-949"><span id="MJXp-Span-950">H</span><span id="MJXp-Span-951">(</span><span id="MJXp-Span-952">E</span><span id="MJXp-Span-953">,</span><span id="MJXp-Span-954">X</span><span id="MJXp-Span-955">∣</span><span id="MJXp-Span-956"><span id="MJXp-Span-957"><span><span><span><span id="MJXp-Span-959">ˆ</span></span><span><span id="MJXp-Span-958">X</span></span></span></span></span></span><span id="MJXp-Span-960">)</span><span id="MJXp-Span-961">≥</span><span id="MJXp-Span-962">H</span><span id="MJXp-Span-963">(</span><span id="MJXp-Span-964">X</span><span id="MJXp-Span-965">∣</span><span id="MJXp-Span-966"><span id="MJXp-Span-967"><span><span><span><span id="MJXp-Span-969">ˆ</span></span><span><span id="MJXp-Span-968">X</span></span></span></span></span></span><span id="MJXp-Span-970">)</span><span id="MJXp-Span-971">≥</span><span id="MJXp-Span-972">H</span><span id="MJXp-Span-973">(</span><span id="MJXp-Span-974">X</span><span id="MJXp-Span-975">∣</span><span id="MJXp-Span-976">Y</span><span id="MJXp-Span-977">)</span><span id="MJXp-Span-978">.</span></span></span></p></div>
<p>
The first inequality follows from the fact that we're removing a variable and the second follows from statement 3 in the previous section (as <span><span><span id="MJXp-Span-979"><span id="MJXp-Span-980">X</span><span id="MJXp-Span-981">→</span><span id="MJXp-Span-982">Y</span><span id="MJXp-Span-983">→</span><span id="MJXp-Span-984"><span id="MJXp-Span-985"><span><span><span><span id="MJXp-Span-987">ˆ</span></span><span><span id="MJXp-Span-986">X</span></span></span></span></span></span></span></span><span id="MathJax-Element-129-Frame" tabindex="0"></span></span>). Using the definition of <span><span><span id="MJXp-Span-988"><span id="MJXp-Span-989">H</span><span id="MJXp-Span-990">(</span><span id="MJXp-Span-991">X</span><span id="MJXp-Span-992">∣</span><span id="MJXp-Span-993">Y</span><span id="MJXp-Span-994">)</span></span></span><span id="MathJax-Element-130-Frame" tabindex="0"></span></span>, then we have
</p>
<div><p><span><span id="MJXp-Span-995"><span id="MJXp-Span-996">H</span><span id="MJXp-Span-997">(</span><span id="MJXp-Span-998">X</span><span id="MJXp-Span-999">,</span><span id="MJXp-Span-1000">Y</span><span id="MJXp-Span-1001">)</span><span id="MJXp-Span-1002">−</span><span id="MJXp-Span-1003">H</span><span id="MJXp-Span-1004">(</span><span id="MJXp-Span-1005">Y</span><span id="MJXp-Span-1006">)</span><span id="MJXp-Span-1007">≥</span><span id="MJXp-Span-1008">H</span><span id="MJXp-Span-1009">(</span><span id="MJXp-Span-1010">X</span><span id="MJXp-Span-1011">)</span><span id="MJXp-Span-1012">−</span><span id="MJXp-Span-1013">H</span><span id="MJXp-Span-1014">(</span><span id="MJXp-Span-1015">Y</span><span id="MJXp-Span-1016">)</span><span id="MJXp-Span-1017">=</span><span id="MJXp-Span-1018">log</span><span id="MJXp-Span-1019"></span><span id="MJXp-Span-1020"><span id="MJXp-Span-1021">|</span></span><span id="MJXp-Span-1022"><span id="MJXp-Span-1023">X</span></span><span id="MJXp-Span-1024"><span id="MJXp-Span-1025">|</span></span><span id="MJXp-Span-1026">−</span><span id="MJXp-Span-1027">H</span><span id="MJXp-Span-1028">(</span><span id="MJXp-Span-1029">Y</span><span id="MJXp-Span-1030">)</span><span id="MJXp-Span-1031">≥</span><span id="MJXp-Span-1032">log</span><span id="MJXp-Span-1033"></span><span id="MJXp-Span-1034"><span id="MJXp-Span-1035">|</span></span><span id="MJXp-Span-1036"><span id="MJXp-Span-1037">X</span></span><span id="MJXp-Span-1038"><span id="MJXp-Span-1039">|</span></span><span id="MJXp-Span-1040">−</span><span id="MJXp-Span-1041">log</span><span id="MJXp-Span-1042"></span><span id="MJXp-Span-1043"><span id="MJXp-Span-1044">|</span></span><span id="MJXp-Span-1045"><span id="MJXp-Span-1046">Y</span></span><span id="MJXp-Span-1047"><span id="MJXp-Span-1048">|</span></span><span id="MJXp-Span-1049">.</span></span></span></p></div>
<p>
The first inequality here follows since we're (again!) removing a variable and the equality follows from the fact that <span><span><span id="MJXp-Span-1050"><span id="MJXp-Span-1051">X</span></span></span><span id="MathJax-Element-132-Frame" tabindex="0"></span></span> is uniformly randomly drawn from <span><span><span id="MJXp-Span-1052"><span id="MJXp-Span-1053"><span id="MJXp-Span-1054">X</span></span></span></span><span id="MathJax-Element-133-Frame" tabindex="0"></span></span> and the last inequality follows from the fact that the entropy of <span><span><span id="MJXp-Span-1055"><span id="MJXp-Span-1056">Y</span></span></span><span id="MathJax-Element-134-Frame" tabindex="0"></span></span> is always smaller than that of the uniform distribution on <span><span><span id="MJXp-Span-1057"><span id="MJXp-Span-1058"><span id="MJXp-Span-1059">Y</span></span></span></span><span id="MathJax-Element-135-Frame" tabindex="0"></span></span>. Finally, note that, if we have <span><span><span id="MJXp-Span-1060"><span id="MJXp-Span-1061">k</span></span></span><span id="MathJax-Element-136-Frame" tabindex="0"></span></span> queries, then <span><span><span id="MJXp-Span-1062"><span id="MJXp-Span-1063"><span id="MJXp-Span-1064">|</span></span><span id="MJXp-Span-1065"><span id="MJXp-Span-1066">Y</span></span><span id="MJXp-Span-1067"><span id="MJXp-Span-1068">|</span></span><span id="MJXp-Span-1069">=</span><span id="MJXp-Span-1070"><span id="MJXp-Span-1071">2</span><span id="MJXp-Span-1072">k</span></span></span></span><span id="MathJax-Element-137-Frame" tabindex="0"></span></span> (this is the number of possible values a sequence of <span><span><span id="MJXp-Span-1073"><span id="MJXp-Span-1074">k</span></span></span><span id="MathJax-Element-138-Frame" tabindex="0"></span></span> binary queries can take on). So, <span><span><span id="MJXp-Span-1075"><span id="MJXp-Span-1076">log</span><span id="MJXp-Span-1077"></span><span id="MJXp-Span-1078"><span id="MJXp-Span-1079">|</span></span><span id="MJXp-Span-1080"><span id="MJXp-Span-1081">Y</span></span><span id="MJXp-Span-1082"><span id="MJXp-Span-1083">|</span></span><span id="MJXp-Span-1084">=</span><span id="MJXp-Span-1085">k</span></span></span><span id="MathJax-Element-139-Frame" tabindex="0"></span></span> (in other words, the maximum amount of information we can get with <span><span><span id="MJXp-Span-1086"><span id="MJXp-Span-1087">k</span></span></span><span id="MathJax-Element-140-Frame" tabindex="0"></span></span> binary queries is <span><span><span id="MJXp-Span-1088"><span id="MJXp-Span-1089">k</span></span></span><span id="MathJax-Element-141-Frame" tabindex="0"></span></span> bits) so we find
</p>

<p>
or, after some slight rewriting:
</p>

<p>
as required!</p>
<h3>Some discussion</h3>
<p>I think overall that Fano's inequality is a relatively straightforward way of justifying a ton of the statements one can make about information theory without needing to invoke a large number of more complicated notions. Additionally, the proof is relatively straightforward (in the sense that it only requires very few definitions and properties of the entropy) while also matching our intuition about these problems pretty much exactly.</p>
<p>In particular, we see that sorting is hard not because somehow ordering elements is difficult, but because we have to decide between a bunch of different items (in fact, <span><span><span id="MJXp-Span-1136"><span id="MJXp-Span-1137">n</span><span id="MJXp-Span-1138">!</span></span></span><span id="MathJax-Element-144-Frame" tabindex="0"></span></span> of them) while only receiving a few bits of information at any point in time! In fact, this bound applies to <em>any</em> yes/no query that one can make of the sorted data, not just comparisons, which is interesting.</p>
<p>There are some even more powerful generalizations of Fano's inequality which can also be extended to machine learning applications: you can use them to show that, given only some small amount of data, you cannot decide between a parameter that correctly describe the data and one that does not.</p>
<p>This is all to say that, even though entropy is a magical quantity, that doesn't mean we can't say very rigorous things about it (and make our intuitions about lower bounds even more rigorous, to boot!).</p>


        <hr>
        
    </div>
</div>
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>