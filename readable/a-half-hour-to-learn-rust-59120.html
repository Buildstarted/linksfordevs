<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A half-hour to learn Rust - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A half-hour to learn Rust - linksfor.dev(s)"/>
    <meta property="og:description" content="In order to increase fluency in a programming language, one has to read a lot of it. But how can you read a lot of it if you don&#x27;t know what it means?&#xA;In this article, instead of focusing on one or two concepts, I&#x27;ll try to go through as many Rust snippets as I can, and explain what the keywords and symbols they contain mean.&#xA;Ready? Go!&#xA;let introduces a variable binding:"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A half-hour to learn Rust</title>
<div class="readable">
        <h1>A half-hour to learn Rust</h1>
            <div>Reading time: 28-35 minutes</div>
        <div>Posted here: 29 Feb 2020</div>
        <p><a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
          


          
    <p>In order to increase fluency in a programming language, one has to read a lot of it.
But how can you read a lot of it if you don't know what it means?</p>
<p>In this article, instead of focusing on one or two concepts, I'll try to go
through as many Rust snippets as I can, and explain what the keywords and symbols
they contain mean.</p>
<p>Ready? Go!</p>
<p><code>let</code> introduces a variable binding:</p>
<pre><code><span>let</span> x; 
x = <span>42</span>; 
</code></pre>
<p>This can also be written as a single line:</p>
<pre><code><span>let</span> x = <span>42</span>;
</code></pre>
<p>You can specify the variable's type explicitly with <code>:</code>, that's a type annotation:</p>
<pre><code><span>let</span> x: <span>i32</span>; 
x = <span>42</span>;



</code></pre>
<p>This can also be written as a single line:</p>
<pre><code><span>let</span> x: <span>i32</span> = <span>42</span>;
</code></pre>
<p>If you declare a name and initialize it later, the compiler will prevent you
from using it before it's initialized.</p>
<pre><code><span>let</span> x;
foobar(x); 
x = <span>42</span>;
</code></pre>
<p>However, doing this is completely fine:</p>
<pre><code><span>let</span> x;
x = <span>42</span>;
foobar(x); 
</code></pre>
<p>The underscore <code>_</code> is a special name - or rather, a ‚Äúlack of name‚Äù. It
basically means to throw away something:</p>
<pre><code>
<span>let</span> _ = <span>42</span>;


<span>let</span> _ = get_thing();
</code></pre>
<p>Names that <em>start</em> with an underscore are regular names, it's just that
the compiler won't warn about them being unused:</p>
<pre><code>

<span>let</span> _x = <span>42</span>;
</code></pre>
<p>Separate bindings with the same name can be introduced - you can <em>shadow</em>
a variable binding:</p>
<pre><code><span>let</span> x = <span>13</span>;
<span>let</span> x = x + <span>3</span>;


</code></pre>
<p>Rust has tuples, which you can think of as ‚Äúfixed-length collections
of values of different types‚Äù.</p>
<pre><code><span>let</span> pair = (<span>'a'</span>, <span>17</span>);
pair.<span>0</span>; 
pair.<span>1</span>; 
</code></pre>
<p>If we we really we wanted to annotate the type of <code>pair</code>, we would write:</p>
<pre><code><span>let</span> pair: (<span>char</span>, <span>i32</span>) = (<span>'a'</span>, <span>17</span>);
</code></pre>
<p>Tuples can be <em>destructured</em> when doing an assignment, which means
they're broken down into their individual fields:</p>
<pre><code><span>let</span> (some_char, some_int) = (<span>'a'</span>, <span>17</span>);

</code></pre>
<p>This is especially useful when a function returns a tuple:</p>
<pre><code><span>let</span> (left, right) = slice.split_at(middle);
</code></pre>
<p>Of course, when destructuring a tuple, <code>_</code> can be used to throw away part of it:</p>
<pre><code><span>let</span> (_, right) = slice.split_at(middle);
</code></pre>
<p>The semi-colon marks the end of a statement:</p>
<pre><code><span>let</span> x = <span>3</span>;
<span>let</span> y = <span>5</span>;
<span>let</span> z = y + x;
</code></pre>
<p>Which means statements can span multiple lines:</p>
<pre><code><span>let</span> x = <span>vec!</span>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>, <span>6</span>, <span>7</span>, <span>8</span>]
    .iter()
    .map(|x| x + <span>3</span>)
    .fold(<span>0</span>, |x, y| x + y);
</code></pre>
<p>(We'll go over what those actually mean later).</p>
<p><code>fn</code> declares a function.</p>
<p>Here's a void function:</p>
<pre><code><span><span>fn</span> <span>greet</span></span>() {
    <span>println!</span>(<span>"Hi there!"</span>);
}
</code></pre>
<p>And here's a function that returns a 32-bit signed integer. The
arrow indicates its return type:</p>
<pre><code><span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>4</span>
}
</code></pre>
<p>A pair of brackets declares a block, which has its own scope:</p>
<pre><code>
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x = <span>"out"</span>;
    {
        
        <span>let</span> x = <span>"in"</span>;
        <span>println!</span>(x);
    }
    <span>println!</span>(x);
}
</code></pre>
<p>Blocks are also expressions, which mean they evaluate to.. a value.</p>
<pre><code>
<span>let</span> x = <span>42</span>;


<span>let</span> x = { <span>42</span> };
</code></pre>
<p>Inside a block, there can be multiple statements:</p>
<pre><code><span>let</span> x = {
    <span>let</span> y = <span>1</span>; 
    <span>let</span> z = <span>2</span>; 
    y + z 
};
</code></pre>
<p>And that's why ‚Äúomitting the semicolon at the end of a function‚Äù is the same
as returning, ie. these are equivalent:</p>
<pre><code><span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>return</span> <span>4</span>;
}

<span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>4</span>
}
</code></pre>
<p><code>if</code> conditionals are also expressions:</p>
<pre><code><span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>if</span> feeling_lucky {
        <span>6</span>
    } <span>else</span> {
        <span>4</span>
    }
}
</code></pre>
<p>A <code>match</code> is also an expression:</p>
<pre><code><span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>match</span> feeling_lucky {
        <span>true</span> =&gt; <span>6</span>,
        <span>false</span> =&gt; <span>4</span>,
    }
}
</code></pre>
<p>Dots are typically used to access fields of a value:</p>
<pre><code><span>let</span> a = (<span>10</span>, <span>20</span>);
a.<span>0</span>; 

<span>let</span> amos = get_some_struct();
amos.nickname; 
</code></pre>
<p>Or call a method on a value:</p>
<pre><code><span>let</span> nick = <span>"fasterthanlime"</span>;
nick.len(); 
</code></pre>
<p>The double-colon, <code>::</code>, is similar but it operates on namespaces.</p>
<p>In this example, <code>std</code> is a <em>crate</em> (~ a library), <code>cmp</code> is a <em>module</em>
(~ a source file), and <code>min</code> is a <em>function</em>:</p>
<pre><code><span>let</span> least = std::cmp::min(<span>3</span>, <span>8</span>); 
</code></pre>
<p><code>use</code> directives can be used to ‚Äúbring in scope‚Äù names from other
namespace:</p>
<pre><code><span>use</span> std::cmp::min;

<span>let</span> least = min(<span>7</span>, <span>1</span>); 
</code></pre>
<p>Within <code>use</code> directives, curly brackets have another meaning: they're
‚Äúglobs‚Äù. If we want to import both <code>min</code> and <code>max</code>, we can do any
of these:</p>
<pre><code>
<span>use</span> std::cmp::min;
<span>use</span> std::cmp::max;


<span>use</span> std::cmp::{min, max};


<span>use</span> std::{cmp::min, cmp::max};
</code></pre>
<p>A wildcard (<code>*</code>) lets you import every symbol from a namespace:</p>
<pre><code>
<span>use</span> std::cmp::*;
</code></pre>
<p>Types are namespaces too, and methods can be called as regular functions:</p>
<pre><code><span>let</span> x = <span>"amos"</span>.len(); 
<span>let</span> x = <span>str</span>::len(<span>"amos"</span>); 
</code></pre>
<p><code>str</code> is a primitive type, but many non-primitive types are also in scope
by default.</p>
<pre><code>
<span>let</span> v = <span>Vec</span>::new();


<span>let</span> v = std::vec::<span>Vec</span>::new();
</code></pre>
<p>This works because Rust inserts this at the beginning of every module:</p>
<pre><code><span>use</span> std::prelude::v1::*;
</code></pre>
<p>(Which in turns re-exports a lot of symbols, like <code>Vec</code>, <code>String</code>, <code>Option</code> and <code>Result</code>).</p>
<p>Structs are declared with the <code>struct</code> keyword:</p>
<pre><code><span><span>struct</span> <span>Vec2</span></span> {
    x: <span>f64</span>, 
    y: <span>f64</span>,
}
</code></pre>
<p>They can be initialized using <em>struct literals</em>:</p>
<pre><code><span>let</span> v1 = Vec2 { x: <span>1.0</span>, y: <span>3.0</span> };
<span>let</span> v2 = Vec2 { y: <span>2.0</span>, x: <span>4.0</span> };

</code></pre>
<p>There is a shortcut for initializing the <em>rest of the fields</em> from
another struct:</p>
<pre><code><span>let</span> v3 = Vec2 {
    x: <span>14.0</span>,
    ..v2
};
</code></pre>
<p>This is called ‚Äústruct update syntax‚Äù, can only happen in last position,
and cannot be followed by a comma.</p>
<p>Note that <em>the rest of the fields</em> can mean <em>all the fields</em>:</p>
<pre><code><span>let</span> v4 = Vec2 { ..v3 };
</code></pre>
<p>Structs, like tuples, can be destructured.</p>
<p>Just like this is a valid <code>let</code> pattern:</p>
<pre><code><span>let</span> (left, right) = slice.split_at(middle);
</code></pre>
<p>So is this:</p>
<pre><code><span>let</span> v = Vec2 { x: <span>3.0</span>, y: <span>6.0</span> };
<span>let</span> Vec2 { x, y } = v;

</code></pre>
<p>And this:</p>
<pre><code><span>let</span> Vec2 { x, .. } = v;

</code></pre>
<p><code>let</code> patterns can be used as conditions in <code>if</code>:</p>
<pre><code><span><span>struct</span> <span>Number</span></span> {
    odd: <span>bool</span>,
    value: <span>i32</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> one = Number { odd: <span>true</span>, value: <span>1</span> };
    <span>let</span> two = Number { odd: <span>false</span>, value: <span>2</span> };
    print_number(one);
    print_number(two);
}

<span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>if</span> <span>let</span> Number { odd: <span>true</span>, value } = n {
        <span>println!</span>(<span>"Odd number: {}"</span>, value);
    } <span>else</span> <span>if</span> <span>let</span> Number { odd: <span>false</span>, value } = n {
        <span>println!</span>(<span>"Even number: {}"</span>, value);
    }
}




</code></pre>
<p><code>match</code> arms are also patterns, just like <code>if let</code>:</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>match</span> n {
        Number { odd: <span>true</span>, value } =&gt; <span>println!</span>(<span>"Odd number: {}"</span>, value),
        Number { odd: <span>false</span>, value } =&gt; <span>println!</span>(<span>"Even number: {}"</span>, value),
    }
}


</code></pre>
<p>A <code>match</code> has to be exhaustive: at least one arm needs to match.</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>match</span> n {
        Number { value: <span>1</span>, .. } =&gt; <span>println!</span>(<span>"One"</span>),
        Number { value: <span>2</span>, .. } =&gt; <span>println!</span>(<span>"Two"</span>),
        Number { value, .. } =&gt; <span>println!</span>(<span>"{}"</span>, value),
        
    }
}
</code></pre>
<p>If that's hard, <code>_</code> can be used as a ‚Äúcatch-all‚Äù pattern:</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>match</span> n.value {
        <span>1</span> =&gt; <span>println!</span>(<span>"One"</span>),
        <span>2</span> =&gt; <span>println!</span>(<span>"Two"</span>),
        _ =&gt; <span>println!</span>(<span>"{}"</span>, n.value),
    }
}
</code></pre>
<p>You can declare methods on your own types:</p>
<pre><code><span><span>struct</span> <span>Number</span></span> {
    odd: <span>bool</span>,
    value: <span>i32</span>,
}

<span>impl</span> Number {
    <span><span>fn</span> <span>is_strictly_positive</span></span>(<span>self</span>) -&gt; <span>bool</span> {
        <span>self</span>.value &gt; <span>0</span>
    }
}
</code></pre>
<p>And use them like usual:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> minus_two = Number {
        odd: <span>false</span>,
        value: -<span>2</span>,
    };
    <span>println!</span>(<span>"positive? {}"</span>, minus_two.is_strictly_positive());
    
}
</code></pre>
<p>Variable bindings are immutable by default:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number {
        odd: <span>true</span>,
        value: <span>17</span>,
    };
    n.odd = <span>false</span>; 
                   
}
</code></pre>
<p>An immutable variable binding cannot have its interior mutated (like
we just tried), but it also cannot be assigned to:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number {
        odd: <span>true</span>,
        value: <span>17</span>,
    };
    n = Number {
        odd: <span>false</span>,
        value: <span>22</span>,
    }; 
}
</code></pre>
<p><code>mut</code> makes a variable binding mutable:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> n = Number {
        odd: <span>true</span>,
        value: <span>17</span>,
    }
    n.value = <span>19</span>; 
}
</code></pre>
<p>Traits are something multiple types can have in common:</p>
<pre><code><span><span>trait</span> <span>Signed</span></span> {
    <span><span>fn</span> <span>is_strictly_negative</span></span>(<span>self</span>) -&gt; <span>bool</span>;
}
</code></pre>
<p>You can implement:</p>
<ul>
<li>one of your traits on anyone's type</li>
<li>anyone's trait on one of your types</li>
<li>but not a foreign trait on a foreign type</li>
</ul>
<p>These are called the ‚Äúorphan rules‚Äù.</p>
<p>Here's an implementation of our trait on our type:</p>
<pre><code><span>impl</span> Signed <span>for</span> Number {
    <span><span>fn</span> <span>is_strictly_negative</span></span>(<span>self</span>) -&gt; <span>bool</span> {
        <span>self</span>.value &lt; <span>0</span>
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>false</span>, value: -<span>44</span> };
    <span>println!</span>(<span>"{}"</span>, n.is_strictly_negative()); 
}
</code></pre>
<p>Our trait on a foreign type (a primitive type, even):</p>
<pre><code><span>impl</span> Signed <span>for</span> <span>i32</span> {
    <span><span>fn</span> <span>is_strictly_negative</span></span>(<span>self</span>) -&gt; <span>bool</span> {
        <span>self</span> &lt; <span>0</span>
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n: <span>i32</span> = -<span>44</span>;
    <span>println!</span>(<span>"{}"</span>, n.is_strictly_negative()); 
}
</code></pre>
<p>A foreign trait on our type:</p>
<pre><code>

<span>impl</span> std::ops::Neg <span>for</span> Number {
    <span><span>type</span> <span>Output</span></span> = Number;

    <span><span>fn</span> <span>neg</span></span>(<span>self</span>) -&gt; Number {
        Number {
            value: -<span>self</span>.value,
            odd: <span>self</span>.odd,
        }        
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>987</span> };
    <span>let</span> m = -n; 
    <span>println!</span>(<span>"{}"</span>, m.value); 
}
</code></pre>
<p>An <code>impl</code> block is always <em>for</em> a type, so, inside that block, <code>Self</code>
means that type:</p>
<pre><code><span>impl</span> std::ops::Neg <span>for</span> Number {
    <span><span>type</span> <span>Output</span></span> = <span>Self</span>;

    <span><span>fn</span> <span>neg</span></span>(<span>self</span>) -&gt; <span>Self</span> {
        <span>Self</span> {
            value: -<span>self</span>.value,
            odd: <span>self</span>.odd,
        }        
    }
}
</code></pre>
<p>Some traits are <em>markers</em> - they don't say that a type implements
some methods, they say that certain things can be done with a type.</p>
<p>For example, <code>i32</code> implements trait <code>Copy</code> (in short, <code>i32</code> <em>is</em> <code>Copy</code>),
so this works:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> a: <span>i32</span> = <span>15</span>;
    <span>let</span> b = a; 
    <span>let</span> c = a; 
}
</code></pre>
<p>And this also works:</p>
<pre><code><span><span>fn</span> <span>print_i32</span></span>(x: <span>i32</span>) {
    <span>println!</span>(<span>"x = {}"</span>, x);
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> a: <span>i32</span> = <span>15</span>;
    print_i32(a); 
    print_i32(a); 
}
</code></pre>
<p>But the <code>Number</code> struct is not <code>Copy</code>, so this doesn't work:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    <span>let</span> m = n; 
    <span>let</span> o = n; 
}
</code></pre>
<p>And neither does this:</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>println!</span>(<span>"{} number {}"</span>, <span>if</span> n.odd { <span>"odd"</span> } <span>else</span> { <span>"even"</span> }, n.value);
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    print_number(n); 
    print_number(n); 
}
</code></pre>
<p>But it works if <code>print_number</code> takes an immutable reference instead:</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: &amp;Number) {
    <span>println!</span>(<span>"{} number {}"</span>, <span>if</span> n.odd { <span>"odd"</span> } <span>else</span> { <span>"even"</span> }, n.value);
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    print_number(&amp;n); 
    print_number(&amp;n); 
}
</code></pre>
<p>It also works if a function takes a <em>mutable</em> reference - but only
if our variable binding is also <code>mut</code>.</p>
<pre><code><span><span>fn</span> <span>invert</span></span>(n: &amp;<span>mut</span> Number) {
    n.value = -n.value;
}

<span><span>fn</span> <span>print_number</span></span>(n: &amp;Number) {
    <span>println!</span>(<span>"{} number {}"</span>, <span>if</span> n.odd { <span>"odd"</span> } <span>else</span> { <span>"even"</span> }, n.value);
}

<span><span>fn</span> <span>main</span></span>() {
    
    <span>let</span> <span>mut</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    print_number(&amp;n);
    invert(&amp;<span>mut</span> n); 
    print_number(&amp;n);
}
</code></pre>
<p>Trait methods can also take <code>self</code> by reference or mutable reference:</p>
<pre><code><span>impl</span> std::clone::<span>Clone</span> <span>for</span> Number {
    <span><span>fn</span> <span>clone</span></span>(&amp;<span>self</span>) -&gt; <span>Self</span> {
        <span>Self</span> { ..*<span>self</span> }
    }
}
</code></pre>
<p>When invoking trait methods, the receiver is borrowed implicitly:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    <span>let</span> <span>mut</span> m = n.clone();
    m.value += <span>100</span>;
    
    print_number(&amp;n);
    print_number(&amp;m);
}
</code></pre>
<p>To highlight this: these are equivalent:</p>
<pre><code><span>let</span> m = n.clone();

<span>let</span> m = std::clone::<span>Clone</span>::clone(&amp;n);
</code></pre>
<p>Marker traits like <code>Copy</code> have no methods:</p>
<pre><code>
<span>impl</span> std::clone::<span>Clone</span> <span>for</span> Number {
    <span><span>fn</span> <span>clone</span></span>(&amp;<span>self</span>) -&gt; <span>Self</span> {
        <span>Self</span> { ..*<span>self</span> }
    }
}

<span>impl</span> std::marker::<span>Copy</span> <span>for</span> Number {}
</code></pre>
<p>Now, <code>Clone</code> can still be used:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    <span>let</span> m = n.clone();
    <span>let</span> o = n.clone();
}
</code></pre>
<p>But <code>Number</code> values will no longer be moved:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    <span>let</span> m = n; 
    <span>let</span> o = n; 
}
</code></pre>
<p>Some traits are so common, they can be implemented automatically
by using the <code>derive</code> attribute:</p>
<pre><code><span>#[derive(Clone, Copy)]</span>
<span><span>struct</span> <span>Number</span></span> {
    odd: <span>bool</span>,
    value: <span>i32</span>,
}


</code></pre>
<p>Functions can be generic:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;T&gt;(arg: T) {
    
}
</code></pre>
<p>They can have multiple <em>type parameters</em>, which can then be used in the
function's declaration and its body, instead of concrete types:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;L, R&gt;(left: L, right: R) {
    
}
</code></pre>
<p>Type parameters usually have <em>constraints</em>, so you can actually
do something with them.</p>
<p>The simplest constraints are just trait names:</p>
<pre><code><span><span>fn</span> <span>print</span></span>&lt;T: Display&gt;(value: T) {
    <span>println!</span>(<span>"value = {}"</span>, value);
}

<span><span>fn</span> <span>print</span></span>&lt;T: <span>Debug</span>&gt;(value: T) {
    <span>println!</span>(<span>"value = {:?}"</span>, value);
}
</code></pre>
<p>There's a longer syntax for type parameter constraints:</p>
<pre><code><span><span>fn</span> <span>print</span></span>&lt;T&gt;(value: T)
<span>where</span>
    T: Display,
{
    <span>println!</span>(<span>"value = {}"</span>, value);
}
</code></pre>
<p>Constraints can be more complicated: they can require a type parameter
to implement multiple traits:</p>
<pre><code><span>use</span> std::fmt::<span>Debug</span>;

<span><span>fn</span> <span>compare</span></span>&lt;T&gt;(left: T, right: T)
<span>where</span>
    T: <span>Debug</span> + <span>PartialEq</span>,
{
    <span>println!</span>(<span>"{:?} {} {:?}"</span>, left, <span>if</span> left == right { <span>"=="</span> } <span>else</span> { <span>"!="</span> }, right);
}

<span><span>fn</span> <span>main</span></span>() {
    compare(<span>"tea"</span>, <span>"coffee"</span>);
    
}
</code></pre>
<p>Generic functions can be thought of as namespaces, containing an infinity
of functions with different concrete types.</p>
<p>Same as with crates, and modules, and types, generic functions can be ‚Äúexplored‚Äù
(navigated?) using <code>::</code></p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>use</span> std::any::type_name;
    <span>println!</span>(<span>"{}"</span>, type_name::&lt;<span>i32</span>&gt;()); 
    <span>println!</span>(<span>"{}"</span>, type_name::&lt;(<span>f64</span>, <span>char</span>)&gt;()); 
}
</code></pre>
<p>This is lovingly called <a href="https://turbo.fish/">turbofish syntax</a>, because
<code>::&lt;&gt;</code> looks like a fish.</p>
<p>Structs can be generic too:</p>
<pre><code><span><span>struct</span> <span>Pair</span></span>&lt;T&gt; {
    a: T,
    b: T,
}

<span><span>fn</span> <span>print_type_name</span></span>&lt;T&gt;(_val: &amp;T) {
    <span>println!</span>(<span>"{}"</span>, std::any::type_name::&lt;T&gt;());
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p1 = Pair { a: <span>3</span>, b: <span>9</span> };
    <span>let</span> p2 = Pair { a: <span>true</span>, b: <span>false</span> };
    print_type_name(&amp;p1); 
    print_type_name(&amp;p2); 
}
</code></pre>
<p>The standard library type <code>Vec</code> (~ a heap-allocated array), is generic:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> v1 = <span>Vec</span>::new();
    v1.push(<span>1</span>);
    <span>let</span> <span>mut</span> v2 = <span>Vec</span>::new();
    v2.push(<span>false</span>);
    print_type_name(&amp;v1); 
    print_type_name(&amp;v2); 
}
</code></pre>
<p>Speaking of <code>Vec</code>, it comes with a macro that gives more or less ‚Äúvec literals‚Äù:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> v1 = <span>vec!</span>[<span>1</span>, <span>2</span>, <span>3</span>];
    <span>let</span> v2 = <span>vec!</span>[<span>true</span>, <span>false</span>, <span>true</span>];
    print_type_name(&amp;v1); 
    print_type_name(&amp;v2); 
}
</code></pre>
<p>All of <code>name!()</code>, <code>name![]</code> or <code>name!{}</code> invoke a macro. Macros just expand to
regular code.</p>
<p>In fact, <code>println</code> is a macro:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>println!</span>(<span>"{}"</span>, <span>"Hello there!"</span>);
}
</code></pre>
<p>This expands to something that has the same effect as:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>use</span> std::io::{<span>self</span>, Write};
    io::stdout().lock().write_all(<span>b"Hello there!
"</span>).unwrap();
}
</code></pre>
<p><code>panic</code> is also a macro. It violently stops execution with an error
message, and the file name / line number of the error, if enabled:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>panic!</span>(<span>"This panics"</span>);
}

</code></pre>
<p>Some methods also panic. For example, the <code>Option</code> type can contain something,
or it can contain nothing. If <code>.unwrap()</code> is called on it, and it contains
nothing, it panics:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> o1: <span>Option</span>&lt;<span>i32</span>&gt; = <span>Some</span>(<span>128</span>);
    o1.unwrap(); 

    <span>let</span> o2: <span>Option</span>&lt;<span>i32</span>&gt; = <span>None</span>;
    o2.unwrap(); 
}


</code></pre>
<p><code>Option</code> is not a struct - it's an <code>enum</code>, with two variants.</p>
<pre><code><span><span>enum</span> <span>Option</span></span>&lt;T&gt; {
    <span>None</span>,
    <span>Some</span>(T),
}

<span>impl</span>&lt;T&gt; <span>Option</span>&lt;T&gt; {
    <span><span>fn</span> <span>unwrap</span></span>(<span>self</span>) -&gt; T {
        
        <span>match</span> <span>self</span> {
            Self::<span>Some</span>(t) =&gt; t,
            Self::<span>None</span> =&gt; <span>panic!</span>(<span>".unwrap() called on a None option"</span>),
        }
    }
}

<span>use</span> self::<span>Option</span>::{<span>None</span>, <span>Some</span>};

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> o1: <span>Option</span>&lt;<span>i32</span>&gt; = <span>Some</span>(<span>128</span>);
    o1.unwrap(); 

    <span>let</span> o2: <span>Option</span>&lt;<span>i32</span>&gt; = <span>None</span>;
    o2.unwrap(); 
}


</code></pre>
<p><code>Result</code> is also an enum, it can either contain something, or an error:</p>
<pre><code><span><span>enum</span> <span>Result</span></span>&lt;T, E&gt; {
    <span>Ok</span>(T),
    <span>Err</span>(E),
}
</code></pre>
<p>It also panics when unwrapped and containing an error.</p>
<p>Variables bindings have a ‚Äúlifetime‚Äù:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    
    {
        <span>let</span> x = <span>42</span>; 
        <span>println!</span>(<span>"x = {}"</span>, x);
        
    }
    
}
</code></pre>
<p>Similarly, references have a lifetime:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    
    {
        <span>let</span> x = <span>42</span>; 
        <span>let</span> x_ref = &amp;x; 
        <span>println!</span>(<span>"x_ref = {}"</span>, x_ref);
        
        
    }
    
}
</code></pre>
<p>The lifetime of a reference cannot exceed the lifetime of the variable
binding it borrows:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x_ref = {
        <span>let</span> x = <span>42</span>;
        &amp;x
    };
    <span>println!</span>(<span>"x_ref = {}"</span>, x_ref);
    
}
</code></pre>
<p>A variable binding can be immutably borrowed multiple times:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x = <span>42</span>;
    <span>let</span> x_ref1 = &amp;x;
    <span>let</span> x_ref2 = &amp;x;
    <span>let</span> x_ref3 = &amp;x;
    <span>println!</span>(<span>"{} {} {}"</span>, x_ref1, x_ref2, x_ref3);
}
</code></pre>
<p>While borrowed, a variable binding cannot be mutated:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> x = <span>42</span>;
    <span>let</span> x_ref = &amp;x;
    x = <span>13</span>;
    <span>println!</span>(<span>"x_ref = {}"</span>, x_ref);
    
}
</code></pre>
<p>While immutably borrowed, a variable cannot be <em>mutably borrowed</em>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> x = <span>42</span>;
    <span>let</span> x_ref1 = &amp;x;
    <span>let</span> x_ref2 = &amp;<span>mut</span> x;
    
    <span>println!</span>(<span>"x_ref1 = {}"</span>, x_ref1);
}
</code></pre>
<p>References in function arguments also have lifetimes:</p>
<pre><code><span><span>fn</span> <span>print</span></span>(x: &amp;<span>i32</span>) {
    
    
}
</code></pre>
<p>Functions with reference arguments can be called with borrows
that have different lifetimes, so:</p>
<ul>
<li>All functions that take references are generic</li>
<li>Lifetimes are generic parameters</li>
</ul>
<p>Lifetimes‚Äô names start with a single quote, <code>'</code>:</p>
<pre><code>
<span><span>fn</span> <span>print</span></span>(x: &amp;<span>i32</span>) {}


<span><span>fn</span> <span>print</span></span>&lt;<span>'a</span>&gt;(x: &amp;<span>'a</span> <span>i32</span>) {}
</code></pre>
<p>This allows returning references whose lifetime depend on the
lifetime of the arguments:</p>
<pre><code><span><span>struct</span> <span>Number</span></span> {
    value: <span>i32</span>,
}

<span><span>fn</span> <span>number_value</span></span>&lt;<span>'a</span>&gt;(num: &amp;<span>'a</span> Number) -&gt; &amp;<span>'a</span> <span>i32</span> {
    &amp;num.value
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { value: <span>47</span> };
    <span>let</span> v = number_value(&amp;n);
    
    
}
</code></pre>
<p>When there is a <em>single</em> input lifetime, it doesn't need to be named,
and everything has the same lifetime, so the two functions below are
equivalent:</p>
<pre><code><span><span>fn</span> <span>number_value</span></span>&lt;<span>'a</span>&gt;(num: &amp;<span>'a</span> Number) -&gt; &amp;<span>'a</span> <span>i32</span> {
    &amp;num.value
}

<span><span>fn</span> <span>number_value</span></span>(num: &amp;Number) -&gt; &amp;<span>i32</span> {
    &amp;num.value
}
</code></pre>
<p>Structs can also be <em>generic over lifetimes</em>, which allows them to
hold references:</p>
<pre><code><span><span>struct</span> <span>NumRef</span></span>&lt;<span>'a</span>&gt; {
    x: &amp;<span>'a</span> <span>i32</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x: <span>i32</span> = <span>99</span>;
    <span>let</span> x_ref = NumRef { x: &amp;x };
    
}
</code></pre>
<p>The same code, but with an additional function:</p>
<pre><code><span><span>struct</span> <span>NumRef</span></span>&lt;<span>'a</span>&gt; {
    x: &amp;<span>'a</span> <span>i32</span>,
}

<span><span>fn</span> <span>as_num_ref</span></span>&lt;<span>'a</span>&gt;(x: &amp;<span>'a</span> <span>i32</span>) -&gt; NumRef&lt;<span>'a</span>&gt; {
    NumRef { x: &amp;x }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x: <span>i32</span> = <span>99</span>;
    <span>let</span> x_ref = as_num_ref(&amp;x);
    
}
</code></pre>
<p>The same code, but with ‚Äúelided‚Äù lifetimes:</p>
<pre><code><span><span>struct</span> <span>NumRef</span></span>&lt;<span>'a</span>&gt; {
    x: &amp;<span>'a</span> <span>i32</span>,
}

<span><span>fn</span> <span>as_num_ref</span></span>(x: &amp;<span>i32</span>) -&gt; NumRef&lt;<span>'_</span>&gt; {
    NumRef { x: &amp;x }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x: <span>i32</span> = <span>99</span>;
    <span>let</span> x_ref = as_num_ref(&amp;x);
    
}
</code></pre>
<p><code>impl</code> blocks can be generic over lifetimes too:</p>
<pre><code><span>impl</span>&lt;<span>'a</span>&gt; NumRef&lt;<span>'a</span>&gt; {
    <span><span>fn</span> <span>as_i32_ref</span></span>(&amp;<span>'a</span> <span>self</span>) -&gt; &amp;<span>'a</span> <span>i32</span> {
        <span>self</span>.x
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x: <span>i32</span> = <span>99</span>;
    <span>let</span> x_num_ref = NumRef { x: &amp;x };
    <span>let</span> x_i32_ref = x_num_ref.as_i32_ref();
    
}
</code></pre>
<p>But you can do elision (‚Äúto elide‚Äù) there too:</p>
<pre><code><span>impl</span>&lt;<span>'a</span>&gt; NumRef&lt;<span>'a</span>&gt; {
    <span><span>fn</span> <span>as_i32_ref</span></span>(&amp;<span>self</span>) -&gt; &amp;<span>i32</span> {
        <span>self</span>.x
    }
}
</code></pre>
<p>You can elide even harder, if you never need the name:</p>
<pre><code><span>impl</span> NumRef&lt;<span>'_</span>&gt; {
    <span><span>fn</span> <span>as_i32_ref</span></span>(&amp;<span>self</span>) -&gt; &amp;<span>i32</span> {
        <span>self</span>.x
    }
}
</code></pre>
<p>There is a special lifetime, named <code>'static</code>, which is valid for the
entire program's lifetime.</p>
<p>String literals are <code>'static'</code>:</p>
<pre><code><span><span>struct</span> <span>Person</span></span> {
    name: &amp;<span>'static</span> <span>str</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p = Person {
        name: <span>"fasterthanlime"</span>,
    };
}
</code></pre>
<p>But <em>owned strings</em> are not static:</p>
<pre><code><span><span>struct</span> <span>Person</span></span> {
    name: &amp;<span>'static</span> <span>str</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> name = <span>format!</span>(<span>"fasterthan{}"</span>, <span>"lime"</span>);
    <span>let</span> p = Person { name: &amp;name };
    
}
</code></pre>
<p>In that last example, the local <code>name</code> is not a <code>&amp;'static str</code>, it's a
<code>String</code>. It's been allocated dynamically, and it will be freed. Its lifetime
is <em>less</em> than the whole program (even though it happens to be in <code>main</code>).</p>
<p>To store a non-<code>'static</code> string in <code>Person</code>, it needs to either:</p>
<p>A) Be generic over a lifetime:</p>
<pre><code><span><span>struct</span> <span>Person</span></span>&lt;<span>'a</span>&gt; {
    name: &amp;<span>'a</span> <span>str</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> name = <span>format!</span>(<span>"fasterthan{}"</span>, <span>"lime"</span>);
    <span>let</span> p = Person { name: &amp;name };
    
}
</code></pre>
<p>or</p>
<p>B) Take ownership of the string</p>
<pre><code><span><span>struct</span> <span>Person</span></span> {
    name: <span>String</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> name = <span>format!</span>(<span>"fasterthan{}"</span>, <span>"lime"</span>);
    <span>let</span> p = Person { name: name };
    
}
</code></pre>
<p>Speaking of: in a struct literal, when a field is set to a variable binding of the
same name:</p>
<pre><code>    <span>let</span> p = Person { name: name };
</code></pre>
<p>It can be shortened like this:</p>
<pre><code>    <span>let</span> p = Person { name };
</code></pre>
<p>For many types in Rust, there are owned and non-owned variants:</p>
<ul>
<li>Strings: <code>String</code> is owned, <code>&amp;str</code> is a reference</li>
<li>Paths: <code>PathBuf</code> is owned, <code>&amp;Path</code> is a reference</li>
<li>Collections: <code>Vec&lt;T&gt;</code> is owned, <code>&amp;[T]</code> is a reference</li>
</ul>
<p>Rust has slices - they're a reference to multiple contiguous elements.</p>
<p>You can borrow a slice of a vector, for example:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> v = <span>vec!</span>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>];
    <span>let</span> v2 = &amp;v[<span>2</span>..<span>4</span>];
    <span>println!</span>(<span>"v2 = {:?}"</span>, v2);
}



</code></pre>
<p>The above is not magical. The indexing operator (<code>foo[index]</code>) is
overloaded with the <code>Index</code> and <code>IndexMut</code> traits.</p>
<p>The <code>..</code> syntax is just range literals. Ranges are just a few
structs defined in the standard library.</p>
<p>They can be open-ended, and their rightmost bound can be inclusive,
if it's preceded by <code>=</code>.</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    
    <span>println!</span>(<span>"{:?}"</span>, (<span>0</span>..).contains(&amp;<span>100</span>)); 
    
    <span>println!</span>(<span>"{:?}"</span>, (..<span>20</span>).contains(&amp;<span>20</span>)); 
    
    <span>println!</span>(<span>"{:?}"</span>, (..=<span>20</span>).contains(&amp;<span>20</span>)); 
    
    <span>println!</span>(<span>"{:?}"</span>, (<span>3</span>..<span>6</span>).contains(&amp;<span>4</span>)); 
}
</code></pre>
<p>Borrowing rules apply to slices.</p>
<pre><code><span><span>fn</span> <span>tail</span></span>(s: &amp;[<span>u8</span>]) -&gt; &amp;[<span>u8</span>] {
  &amp;s[<span>1</span>..] 
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x = &amp;[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>];
    <span>let</span> y = tail(x);
    <span>println!</span>(<span>"y = {:?}"</span>, y);
}
</code></pre>
<p>This is the same as:</p>
<pre><code><span><span>fn</span> <span>tail</span></span>&lt;<span>'a</span>&gt;(s: &amp;<span>'a</span> [<span>u8</span>]) -&gt; &amp;<span>'a</span> [<span>u8</span>] {
  &amp;s[<span>1</span>..] 
}
</code></pre>
<p>This is legal:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> y = {
        <span>let</span> x = &amp;[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>];
        tail(x)
    };
    <span>println!</span>(<span>"y = {:?}"</span>, y);
}
</code></pre>
<p>‚Ä¶but only because <code>[1, 2, 3, 4, 5]</code> is a <code>'static</code> array.</p>
<p>So, this is illegal:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> y = {
        <span>let</span> v = <span>vec!</span>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>];
        tail(&amp;v)
        
    };
    <span>println!</span>(<span>"y = {:?}"</span>, y);
}
</code></pre>
<p>‚Ä¶because a vector is heap-allocated, and it has a non-<code>'static</code> lifetime.</p>
<p><code>&amp;str</code> values are really slices.</p>
<pre><code><span><span>fn</span> <span>file_ext</span></span>(name: &amp;<span>str</span>) -&gt; <span>Option</span>&lt;&amp;<span>str</span>&gt; {
    
    
    name.split(<span>"."</span>).last()
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> name = <span>"Read me. Or don't.txt"</span>;
    <span>if</span> <span>let</span> <span>Some</span>(ext) = file_ext(name) {
        <span>println!</span>(<span>"file extension: {}"</span>, ext);
    } <span>else</span> {
        <span>println!</span>(<span>"no file extension"</span>);
    }
}
</code></pre>
<p>‚Ä¶so the borrow rules apply here too:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> ext = {
        <span>let</span> name = <span>String</span>::from(<span>"Read me. Or don't.txt"</span>);
        file_ext(&amp;name).unwrap_or(<span>""</span>)
        
    };
    <span>println!</span>(<span>"extension: {:?}"</span>, ext);
}
</code></pre>
<p>Functions that can fail typically return a <code>Result</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]);
    <span>println!</span>(<span>"{:?}"</span>, s);
    

    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>195</span>, <span>40</span>]);
    <span>println!</span>(<span>"{:?}"</span>, s);
    
}
</code></pre>
<p>If you want to panic in case of failure, you can <code>.unwrap()</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]).unwrap();
    <span>println!</span>(<span>"{:?}"</span>, s);
    

    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>195</span>, <span>40</span>]).unwrap();
    
    
    
}
</code></pre>
<p>Or <code>.expect()</code>, for a custom message:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>195</span>, <span>40</span>]).expect(<span>"valid utf-8"</span>);
    
    
}
</code></pre>
<p>Or, you can <code>match</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>match</span> std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]) {
        <span>Ok</span>(s) =&gt; <span>println!</span>(<span>"{}"</span>, s),
        <span>Err</span>(e) =&gt; <span>panic!</span>(e),
    }
    
}
</code></pre>
<p>Or you can <code>if let</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>if</span> <span>let</span> <span>Ok</span>(s) = std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]) {
        <span>println!</span>(<span>"{}"</span>, s);
    }
    
}
</code></pre>
<p>Or you can bubble up the error:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() -&gt; <span>Result</span>&lt;(), std::<span>str</span>::Utf8Error&gt; {
    <span>match</span> std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]) {
        <span>Ok</span>(s) =&gt; <span>println!</span>(<span>"{}"</span>, s),
        <span>Err</span>(e) =&gt; <span>return</span> <span>Err</span>(e),
    }
    <span>Ok</span>(())
}
</code></pre>
<p>Or you can use <code>?</code> to do it the concise way:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() -&gt; <span>Result</span>&lt;(), std::<span>str</span>::Utf8Error&gt; {
    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>])?;
    <span>println!</span>(<span>"{}"</span>, s);
    <span>Ok</span>(())
}
</code></pre>
<p>The <code>*</code> operator can be used to <em>dereference</em>, but you don't need to do
that to access fields or call methods:</p>
<pre><code><span><span>struct</span> <span>Point</span></span> {
    x: <span>f64</span>,
    y: <span>f64</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p = Point { x: <span>1.0</span>, y: <span>3.0</span> };
    <span>let</span> p_ref = &amp;p;
    <span>println!</span>(<span>"({}, {})"</span>, p_ref.x, p_ref.y);
}


</code></pre>
<p>And you can only do it if the type is <code>Copy</code>:</p>
<pre><code><span><span>struct</span> <span>Point</span></span> {
    x: <span>f64</span>,
    y: <span>f64</span>,
}

<span><span>fn</span> <span>negate</span></span>(p: Point) -&gt; Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p = Point { x: <span>1.0</span>, y: <span>3.0</span> };
    <span>let</span> p_ref = &amp;p;
    negate(*p_ref);
    
}
</code></pre>
<pre><code>
<span>#[derive(Clone, Copy)]</span>
<span><span>struct</span> <span>Point</span></span> {
    x: <span>f64</span>,
    y: <span>f64</span>,
}

<span><span>fn</span> <span>negate</span></span>(p: Point) -&gt; Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p = Point { x: <span>1.0</span>, y: <span>3.0</span> };
    <span>let</span> p_ref = &amp;p;
    negate(*p_ref); 
}
</code></pre>
<p>Closures are just functions of type <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> with some captured context.</p>
<p>Their parameters are a comma-separated list of names within a pair of pipes
(<code>|</code>). They don't <em>need</em> curly braces, unless you want to have multiple statement.</p>
<pre><code><span><span>fn</span> <span>for_each_planet</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(&amp;<span>'static</span> <span>str</span>)
{
    f(<span>"Earth"</span>);
    f(<span>"Mars"</span>);
    f(<span>"Jupiter"</span>);
}
 
<span><span>fn</span> <span>main</span></span>() {
    for_each_planet(|planet| <span>println!</span>(<span>"Hello, {}"</span>, planet));
}





</code></pre>
<p>The borrow rules apply to them too:</p>
<pre><code><span><span>fn</span> <span>for_each_planet</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(&amp;<span>'static</span> <span>str</span>)
{
    f(<span>"Earth"</span>);
    f(<span>"Mars"</span>);
    f(<span>"Jupiter"</span>);
}
 
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> greeting = <span>String</span>::from(<span>"Good to see you"</span>);
    for_each_planet(|planet| <span>println!</span>(<span>"{}, {}"</span>, greeting, planet));
    
}
</code></pre>
<p>For example, this would not work:</p>
<pre><code><span><span>fn</span> <span>for_each_planet</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(&amp;<span>'static</span> <span>str</span>) + <span>'static</span> 
{
    f(<span>"Earth"</span>);
    f(<span>"Mars"</span>);
    f(<span>"Jupiter"</span>);
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> greeting = <span>String</span>::from(<span>"Good to see you"</span>);
    for_each_planet(|planet| <span>println!</span>(<span>"{}, {}"</span>, greeting, planet));
    
    
}
</code></pre>
<p>But this would:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> greeting = <span>String</span>::from(<span>"You're doing great"</span>);
    for_each_planet(<span>move</span> |planet| <span>println!</span>(<span>"{}, {}"</span>, greeting, planet));
    
    
}
</code></pre>
<p>An <code>FnMut</code> needs to be mutably borrowed to be called, so it can
only be called once at a time.</p>
<p>This is legal:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>println!</span>(<span>"{}"</span>, f(f(<span>2</span>))); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    foobar(|x| x * <span>2</span>);
}


</code></pre>
<p>This isn't:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(<span>mut</span> f: F)
    <span>where</span> F: <span>FnMut</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>println!</span>(<span>"{}"</span>, f(f(<span>2</span>))); 
    
}
 
<span><span>fn</span> <span>main</span></span>() {
    foobar(|x| x * <span>2</span>);
}
</code></pre>
<p>This is legal again:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(<span>mut</span> f: F)
    <span>where</span> F: <span>FnMut</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>let</span> tmp = f(<span>2</span>);
    <span>println!</span>(<span>"{}"</span>, f(tmp)); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    foobar(|x| x * <span>2</span>);
}


</code></pre>
<p><code>FnMut</code> exists because some closures <em>mutably borrow</em> local variables:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(<span>mut</span> f: F)
    <span>where</span> F: <span>FnMut</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>let</span> tmp = f(<span>2</span>);
    <span>println!</span>(<span>"{}"</span>, f(tmp)); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> acc = <span>2</span>;
    foobar(|x| {
        acc += <span>1</span>;
        x * acc
    });
}


</code></pre>
<p>Those closures cannot be passed to functions expecting <code>Fn</code>:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>println!</span>(<span>"{}"</span>, f(f(<span>2</span>))); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> acc = <span>2</span>;
    foobar(|x| {
        acc += <span>1</span>;
        
        
        
        
        x * acc
    });
}
</code></pre>
<p><code>FnOnce</code> closures can only be called once. They exist because some closure
move out variables that have been moved when captured:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>FnOnce</span>() -&gt; <span>String</span>
{
    <span>println!</span>(<span>"{}"</span>, f()); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = <span>String</span>::from(<span>"alright"</span>);
    foobar(<span>move</span> || s);
    
    
    
}
</code></pre>
<p>This is enforced naturally, as <code>FnOnce</code> closures need to be <em>moved</em>
in order to be called.</p>
<p>So, for example, this is illegal:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>FnOnce</span>() -&gt; <span>String</span>
{
    <span>println!</span>(<span>"{}"</span>, f()); 
    <span>println!</span>(<span>"{}"</span>, f()); 
    
}
</code></pre>
<p>And, if you need convincing that our closure <em>does</em> move <code>s</code>,
this is illegal too:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = <span>String</span>::from(<span>"alright"</span>);
    foobar(<span>move</span> || s);
    foobar(<span>move</span> || s);
    
}
</code></pre>
<p>But this is fine:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = <span>String</span>::from(<span>"alright"</span>);
    foobar(|| s.clone());
    foobar(|| s.clone());
}
</code></pre>
<p>Here's a closure with two arguments:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(x: <span>i32</span>, y: <span>i32</span>, is_greater: F)
    <span>where</span> F: <span>Fn</span>(<span>i32</span>, <span>i32</span>) -&gt; <span>bool</span>
{
    <span>let</span> (greater, smaller) = <span>if</span> is_greater(x, y) {
        (x, y)
    } <span>else</span> {
        (y, x)
    };
    <span>println!</span>(<span>"{} is greater than {}"</span>, greater, smaller);
}
 
<span><span>fn</span> <span>main</span></span>() {
    foobar(<span>32</span>, <span>64</span>, |x, y| x &gt; y);
}
</code></pre>
<p>Here's a closure ignoring both its arguments:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    foobar(<span>32</span>, <span>64</span>, |_, _| <span>panic!</span>(<span>"Comparing is futile!"</span>));
}
</code></pre>
<p>Here's a slightly worrying closure:</p>
<pre><code><span><span>fn</span> <span>countdown</span></span>&lt;F&gt;(count: <span>usize</span>, tick: F)
    <span>where</span> F: <span>Fn</span>(<span>usize</span>)
{
    <span>for</span> i <span>in</span> (<span>1</span>..=count).rev() {
        tick(i);
    }
}
 
<span><span>fn</span> <span>main</span></span>() {
    countdown(<span>3</span>, |i| <span>println!</span>(<span>"tick {}..."</span>, i));
}





</code></pre>
<p>And here's a toilet closure:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    countdown(<span>3</span>, |_| ());
}
</code></pre>
<p>Called thusly because <code>|_| ()</code> looks like a toilet.</p>
<p>Anything that is iterable can be used in a <code>for in</code> loop.</p>
<p>We've just seen a range being used, but it also works with a <code>Vec</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>for</span> i <span>in</span> <span>vec!</span>[<span>52</span>, <span>49</span>, <span>21</span>] {
        <span>println!</span>(<span>"I like the number {}"</span>, i);
    }
}
</code></pre>
<p>Or a slice:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>for</span> i <span>in</span> &amp;[<span>52</span>, <span>49</span>, <span>21</span>] {
        <span>println!</span>(<span>"I like the number {}"</span>, i);
    }
}





</code></pre>
<p>Or an actual iterator:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    
    
    <span>for</span> c <span>in</span> <span>"rust"</span>.chars() {
        <span>println!</span>(<span>"Give me a {}"</span>, c);
    }
}






</code></pre>
<p>Even if the iterator items are filtered and mapped and flattened:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>for</span> c <span>in</span> <span>"sHE'S brOKen"</span>
        .chars()
        .filter(|c| c.is_uppercase() || !c.is_ascii_alphabetic())
        .flat_map(|c| c.to_lowercase())
    {
        <span>print!</span>(<span>"{}"</span>, c);
    }
    <span>println!</span>();
}


</code></pre>
<p>You can return a closure from a function:</p>
<pre><code><span><span>fn</span> <span>make_tester</span></span>(answer: <span>String</span>) -&gt; <span>impl</span> <span>Fn</span>(&amp;<span>str</span>) -&gt; <span>bool</span> {
    <span>move</span> |challenge| {
        challenge == answer
    }
}

<span><span>fn</span> <span>main</span></span>() {
    
    
    <span>let</span> test = make_tester(<span>"hunter2"</span>.into());
    <span>println!</span>(<span>"{}"</span>, test(<span>"******"</span>));
    <span>println!</span>(<span>"{}"</span>, test(<span>"hunter2"</span>));
}
</code></pre>
<p>You can even move a reference to some of a function's arguments,
into a closure it returns:</p>
<pre><code><span><span>fn</span> <span>make_tester</span></span>&lt;<span>'a</span>&gt;(answer: &amp;<span>'a</span> <span>str</span>) -&gt; <span>impl</span> <span>Fn</span>(&amp;<span>str</span>) -&gt; <span>bool</span> + <span>'a</span> {
    <span>move</span> |challenge| {
        challenge == answer
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> test = make_tester(<span>"hunter2"</span>);
    <span>println!</span>(<span>"{}"</span>, test(<span>"*******"</span>));
    <span>println!</span>(<span>"{}"</span>, test(<span>"hunter2"</span>));
}




</code></pre>
<p>Or, with elided lifetimes:</p>
<pre><code><span><span>fn</span> <span>make_tester</span></span>(answer: &amp;<span>str</span>) -&gt; <span>impl</span> <span>Fn</span>(&amp;<span>str</span>) -&gt; <span>bool</span> + <span>'_</span> {
    <span>move</span> |challenge| {
        challenge == answer
    }
}
</code></pre>
<p>And with that, we hit the 30-minute estimated reading time mark, and you
should be able to read <em>most</em> of the Rust code you find online.</p>
<p>Writing Rust is a very different experience from reading Rust. On one hand,
you're not reading the <em>solution</em> to a problem, you're actually solving it.
On the other hand, the Rust compiler helps out a <em>lot</em>.</p>
<p>For all of the intentional mistakes made above (‚Äúthis code is illegal‚Äù, etc.),
rustc always has very good error messages <em>and</em> insightful suggestions.</p>
<p>And when there's a hint missing, the compiler team is <a href="https://mobile.twitter.com/fasterthanlime/status/1219601989404954624">not afraid to add it</a>.</p>
<p>For more Rust material, you may want to check out:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust By Example</a></li>
<li><a href="https://readrust.net/">Read Rust</a></li>
<li><a href="https://this-week-in-rust.org/">This Week In Rust</a></li>
</ul>
<p>I also <a href="https://fasterthanli.me/tags/rust/">blog about Rust</a> and <a href="https://twitter.com/fasterthanlime">tweet about
Rust</a> a lot, so if you liked this
article, you know what to do.</p>
<p>Have fun!</p>


          



          
          
<p>This article was made possible thanks to my patrons: Aurora, Chad Morrow, Fernando, Geert Depuydt, Geoff Cant, Geoffroy Couprie,
Ignacio Vergara, Jane Lusby, Jes√∫s Higueras, J√©r√©my Gtld, Makoto Nakashima,
Michael Alyn Miller, Nicolas Goy, o0Ignition0o, Pascal, Raphael Gaschignard,
Romain Ruetschi, Ryszard Sommefeldt, Sebastian Zimmer, Someone, Stefano
Probst, Ted Mielczarek, Xananax, Zaki, and –¢–∏–º –ú–∞—Ä–∏–Ω–∏–Ω.</p>
          
        </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>