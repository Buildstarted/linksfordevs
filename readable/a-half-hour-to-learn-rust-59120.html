<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A half-hour to learn Rust - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A half-hour to learn Rust - linksfor.dev(s)"/>
    <meta property="og:description" content="In order to increase fluency in a programming language, one has to read a lot of it. But how can you read a lot of it if you don&#x27;t know what it means?&#xA;In this article, instead of focusing on one or two concepts, I&#x27;ll try to go through as many Rust snippets as I can, and explain what the keywords and symbols they contain mean.&#xA;Ready? Go!&#xA;let introduces a variable binding:"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A half-hour to learn Rust</title>
<div class="readable">
        <h1>A half-hour to learn Rust</h1>
            <div>Reading time: 28-35 minutes</div>
        <div>Posted here: 29 Feb 2020</div>
        <p><a href="https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/">https://fasterthanli.me/blog/2020/a-half-hour-to-learn-rust/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
          


          
    <p>In order to increase fluency in a programming language, one has to read a lot of it.
But how can you read a lot of it if you don't know what it means?</p>
<p>In this article, instead of focusing on one or two concepts, I'll try to go
through as many Rust snippets as I can, and explain what the keywords and symbols
they contain mean.</p>
<p>Ready? Go!</p>
<p><code>let</code> introduces a variable binding:</p>
<pre><code><span>let</span> x; 
x = <span>42</span>; 
</code></pre>
<p>This can also be written as a single line:</p>
<pre><code><span>let</span> x = <span>42</span>;
</code></pre>
<p>You can specify the variable's type explicitly with <code>:</code>, that's a type annotation:</p>
<pre><code><span>let</span> x: <span>i32</span>; 
x = <span>42</span>;



</code></pre>
<p>This can also be written as a single line:</p>
<pre><code><span>let</span> x: <span>i32</span> = <span>42</span>;
</code></pre>
<p>If you declare a name and initialize it later, the compiler will prevent you
from using it before it's initialized.</p>
<pre><code><span>let</span> x;
foobar(x); 
x = <span>42</span>;
</code></pre>
<p>However, doing this is completely fine:</p>
<pre><code><span>let</span> x;
x = <span>42</span>;
foobar(x); 
</code></pre>
<p>The underscore <code>_</code> is a special name - or rather, a “lack of name”. It
basically means to throw away something:</p>
<pre><code>
<span>let</span> _ = <span>42</span>;


<span>let</span> _ = get_thing();
</code></pre>
<p>Names that <em>start</em> with an underscore are regular names, it's just that
the compiler won't warn about them being unused:</p>
<pre><code>

<span>let</span> _x = <span>42</span>;
</code></pre>
<p>Separate bindings with the same name can be introduced - you can <em>shadow</em>
a variable binding:</p>
<pre><code><span>let</span> x = <span>13</span>;
<span>let</span> x = x + <span>3</span>;


</code></pre>
<p>Rust has tuples, which you can think of as “fixed-length collections
of values of different types”.</p>
<pre><code><span>let</span> pair = (<span>'a'</span>, <span>17</span>);
pair.<span>0</span>; 
pair.<span>1</span>; 
</code></pre>
<p>If we we really we wanted to annotate the type of <code>pair</code>, we would write:</p>
<pre><code><span>let</span> pair: (<span>char</span>, <span>i32</span>) = (<span>'a'</span>, <span>17</span>);
</code></pre>
<p>Tuples can be <em>destructured</em> when doing an assignment, which means
they're broken down into their individual fields:</p>
<pre><code><span>let</span> (some_char, some_int) = (<span>'a'</span>, <span>17</span>);

</code></pre>
<p>This is especially useful when a function returns a tuple:</p>
<pre><code><span>let</span> (left, right) = slice.split_at(middle);
</code></pre>
<p>Of course, when destructuring a tuple, <code>_</code> can be used to throw away part of it:</p>
<pre><code><span>let</span> (_, right) = slice.split_at(middle);
</code></pre>
<p>The semi-colon marks the end of a statement:</p>
<pre><code><span>let</span> x = <span>3</span>;
<span>let</span> y = <span>5</span>;
<span>let</span> z = y + x;
</code></pre>
<p>Which means statements can span multiple lines:</p>
<pre><code><span>let</span> x = <span>vec!</span>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>, <span>6</span>, <span>7</span>, <span>8</span>]
    .iter()
    .map(|x| x + <span>3</span>)
    .fold(<span>0</span>, |x, y| x + y);
</code></pre>
<p>(We'll go over what those actually mean later).</p>
<p><code>fn</code> declares a function.</p>
<p>Here's a void function:</p>
<pre><code><span><span>fn</span> <span>greet</span></span>() {
    <span>println!</span>(<span>"Hi there!"</span>);
}
</code></pre>
<p>And here's a function that returns a 32-bit signed integer. The
arrow indicates its return type:</p>
<pre><code><span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>4</span>
}
</code></pre>
<p>A pair of brackets declares a block, which has its own scope:</p>
<pre><code>
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x = <span>"out"</span>;
    {
        
        <span>let</span> x = <span>"in"</span>;
        <span>println!</span>(x);
    }
    <span>println!</span>(x);
}
</code></pre>
<p>Blocks are also expressions, which mean they evaluate to.. a value.</p>
<pre><code>
<span>let</span> x = <span>42</span>;


<span>let</span> x = { <span>42</span> };
</code></pre>
<p>Inside a block, there can be multiple statements:</p>
<pre><code><span>let</span> x = {
    <span>let</span> y = <span>1</span>; 
    <span>let</span> z = <span>2</span>; 
    y + z 
};
</code></pre>
<p>And that's why “omitting the semicolon at the end of a function” is the same
as returning, ie. these are equivalent:</p>
<pre><code><span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>return</span> <span>4</span>;
}

<span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>4</span>
}
</code></pre>
<p><code>if</code> conditionals are also expressions:</p>
<pre><code><span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>if</span> feeling_lucky {
        <span>6</span>
    } <span>else</span> {
        <span>4</span>
    }
}
</code></pre>
<p>A <code>match</code> is also an expression:</p>
<pre><code><span><span>fn</span> <span>fair_dice_roll</span></span>() -&gt; <span>i32</span> {
    <span>match</span> feeling_lucky {
        <span>true</span> =&gt; <span>6</span>,
        <span>false</span> =&gt; <span>4</span>,
    }
}
</code></pre>
<p>Dots are typically used to access fields of a value:</p>
<pre><code><span>let</span> a = (<span>10</span>, <span>20</span>);
a.<span>0</span>; 

<span>let</span> amos = get_some_struct();
amos.nickname; 
</code></pre>
<p>Or call a method on a value:</p>
<pre><code><span>let</span> nick = <span>"fasterthanlime"</span>;
nick.len(); 
</code></pre>
<p>The double-colon, <code>::</code>, is similar but it operates on namespaces.</p>
<p>In this example, <code>std</code> is a <em>crate</em> (~ a library), <code>cmp</code> is a <em>module</em>
(~ a source file), and <code>min</code> is a <em>function</em>:</p>
<pre><code><span>let</span> least = std::cmp::min(<span>3</span>, <span>8</span>); 
</code></pre>
<p><code>use</code> directives can be used to “bring in scope” names from other
namespace:</p>
<pre><code><span>use</span> std::cmp::min;

<span>let</span> least = min(<span>7</span>, <span>1</span>); 
</code></pre>
<p>Within <code>use</code> directives, curly brackets have another meaning: they're
“globs”. If we want to import both <code>min</code> and <code>max</code>, we can do any
of these:</p>
<pre><code>
<span>use</span> std::cmp::min;
<span>use</span> std::cmp::max;


<span>use</span> std::cmp::{min, max};


<span>use</span> std::{cmp::min, cmp::max};
</code></pre>
<p>A wildcard (<code>*</code>) lets you import every symbol from a namespace:</p>
<pre><code>
<span>use</span> std::cmp::*;
</code></pre>
<p>Types are namespaces too, and methods can be called as regular functions:</p>
<pre><code><span>let</span> x = <span>"amos"</span>.len(); 
<span>let</span> x = <span>str</span>::len(<span>"amos"</span>); 
</code></pre>
<p><code>str</code> is a primitive type, but many non-primitive types are also in scope
by default.</p>
<pre><code>
<span>let</span> v = <span>Vec</span>::new();


<span>let</span> v = std::vec::<span>Vec</span>::new();
</code></pre>
<p>This works because Rust inserts this at the beginning of every module:</p>
<pre><code><span>use</span> std::prelude::v1::*;
</code></pre>
<p>(Which in turns re-exports a lot of symbols, like <code>Vec</code>, <code>String</code>, <code>Option</code> and <code>Result</code>).</p>
<p>Structs are declared with the <code>struct</code> keyword:</p>
<pre><code><span><span>struct</span> <span>Vec2</span></span> {
    x: <span>f64</span>, 
    y: <span>f64</span>,
}
</code></pre>
<p>They can be initialized using <em>struct literals</em>:</p>
<pre><code><span>let</span> v1 = Vec2 { x: <span>1.0</span>, y: <span>3.0</span> };
<span>let</span> v2 = Vec2 { y: <span>2.0</span>, x: <span>4.0</span> };

</code></pre>
<p>There is a shortcut for initializing the <em>rest of the fields</em> from
another struct:</p>
<pre><code><span>let</span> v3 = Vec2 {
    x: <span>14.0</span>,
    ..v2
};
</code></pre>
<p>This is called “struct update syntax”, can only happen in last position,
and cannot be followed by a comma.</p>
<p>Note that <em>the rest of the fields</em> can mean <em>all the fields</em>:</p>
<pre><code><span>let</span> v4 = Vec2 { ..v3 };
</code></pre>
<p>Structs, like tuples, can be destructured.</p>
<p>Just like this is a valid <code>let</code> pattern:</p>
<pre><code><span>let</span> (left, right) = slice.split_at(middle);
</code></pre>
<p>So is this:</p>
<pre><code><span>let</span> v = Vec2 { x: <span>3.0</span>, y: <span>6.0</span> };
<span>let</span> Vec2 { x, y } = v;

</code></pre>
<p>And this:</p>
<pre><code><span>let</span> Vec2 { x, .. } = v;

</code></pre>
<p><code>let</code> patterns can be used as conditions in <code>if</code>:</p>
<pre><code><span><span>struct</span> <span>Number</span></span> {
    odd: <span>bool</span>,
    value: <span>i32</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> one = Number { odd: <span>true</span>, value: <span>1</span> };
    <span>let</span> two = Number { odd: <span>false</span>, value: <span>2</span> };
    print_number(one);
    print_number(two);
}

<span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>if</span> <span>let</span> Number { odd: <span>true</span>, value } = n {
        <span>println!</span>(<span>"Odd number: {}"</span>, value);
    } <span>else</span> <span>if</span> <span>let</span> Number { odd: <span>false</span>, value } = n {
        <span>println!</span>(<span>"Even number: {}"</span>, value);
    }
}




</code></pre>
<p><code>match</code> arms are also patterns, just like <code>if let</code>:</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>match</span> n {
        Number { odd: <span>true</span>, value } =&gt; <span>println!</span>(<span>"Odd number: {}"</span>, value),
        Number { odd: <span>false</span>, value } =&gt; <span>println!</span>(<span>"Even number: {}"</span>, value),
    }
}


</code></pre>
<p>A <code>match</code> has to be exhaustive: at least one arm needs to match.</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>match</span> n {
        Number { value: <span>1</span>, .. } =&gt; <span>println!</span>(<span>"One"</span>),
        Number { value: <span>2</span>, .. } =&gt; <span>println!</span>(<span>"Two"</span>),
        Number { value, .. } =&gt; <span>println!</span>(<span>"{}"</span>, value),
        
    }
}
</code></pre>
<p>If that's hard, <code>_</code> can be used as a “catch-all” pattern:</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>match</span> n.value {
        <span>1</span> =&gt; <span>println!</span>(<span>"One"</span>),
        <span>2</span> =&gt; <span>println!</span>(<span>"Two"</span>),
        _ =&gt; <span>println!</span>(<span>"{}"</span>, n.value),
    }
}
</code></pre>
<p>You can declare methods on your own types:</p>
<pre><code><span><span>struct</span> <span>Number</span></span> {
    odd: <span>bool</span>,
    value: <span>i32</span>,
}

<span>impl</span> Number {
    <span><span>fn</span> <span>is_strictly_positive</span></span>(<span>self</span>) -&gt; <span>bool</span> {
        <span>self</span>.value &gt; <span>0</span>
    }
}
</code></pre>
<p>And use them like usual:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> minus_two = Number {
        odd: <span>false</span>,
        value: -<span>2</span>,
    };
    <span>println!</span>(<span>"positive? {}"</span>, minus_two.is_strictly_positive());
    
}
</code></pre>
<p>Variable bindings are immutable by default:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number {
        odd: <span>true</span>,
        value: <span>17</span>,
    };
    n.odd = <span>false</span>; 
                   
}
</code></pre>
<p>An immutable variable binding cannot have its interior mutated (like
we just tried), but it also cannot be assigned to:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number {
        odd: <span>true</span>,
        value: <span>17</span>,
    };
    n = Number {
        odd: <span>false</span>,
        value: <span>22</span>,
    }; 
}
</code></pre>
<p><code>mut</code> makes a variable binding mutable:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> n = Number {
        odd: <span>true</span>,
        value: <span>17</span>,
    }
    n.value = <span>19</span>; 
}
</code></pre>
<p>Traits are something multiple types can have in common:</p>
<pre><code><span><span>trait</span> <span>Signed</span></span> {
    <span><span>fn</span> <span>is_strictly_negative</span></span>(<span>self</span>) -&gt; <span>bool</span>;
}
</code></pre>
<p>You can implement:</p>
<ul>
<li>one of your traits on anyone's type</li>
<li>anyone's trait on one of your types</li>
<li>but not a foreign trait on a foreign type</li>
</ul>
<p>These are called the “orphan rules”.</p>
<p>Here's an implementation of our trait on our type:</p>
<pre><code><span>impl</span> Signed <span>for</span> Number {
    <span><span>fn</span> <span>is_strictly_negative</span></span>(<span>self</span>) -&gt; <span>bool</span> {
        <span>self</span>.value &lt; <span>0</span>
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>false</span>, value: -<span>44</span> };
    <span>println!</span>(<span>"{}"</span>, n.is_strictly_negative()); 
}
</code></pre>
<p>Our trait on a foreign type (a primitive type, even):</p>
<pre><code><span>impl</span> Signed <span>for</span> <span>i32</span> {
    <span><span>fn</span> <span>is_strictly_negative</span></span>(<span>self</span>) -&gt; <span>bool</span> {
        <span>self</span> &lt; <span>0</span>
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n: <span>i32</span> = -<span>44</span>;
    <span>println!</span>(<span>"{}"</span>, n.is_strictly_negative()); 
}
</code></pre>
<p>A foreign trait on our type:</p>
<pre><code>

<span>impl</span> std::ops::Neg <span>for</span> Number {
    <span><span>type</span> <span>Output</span></span> = Number;

    <span><span>fn</span> <span>neg</span></span>(<span>self</span>) -&gt; Number {
        Number {
            value: -<span>self</span>.value,
            odd: <span>self</span>.odd,
        }        
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>987</span> };
    <span>let</span> m = -n; 
    <span>println!</span>(<span>"{}"</span>, m.value); 
}
</code></pre>
<p>An <code>impl</code> block is always <em>for</em> a type, so, inside that block, <code>Self</code>
means that type:</p>
<pre><code><span>impl</span> std::ops::Neg <span>for</span> Number {
    <span><span>type</span> <span>Output</span></span> = <span>Self</span>;

    <span><span>fn</span> <span>neg</span></span>(<span>self</span>) -&gt; <span>Self</span> {
        <span>Self</span> {
            value: -<span>self</span>.value,
            odd: <span>self</span>.odd,
        }        
    }
}
</code></pre>
<p>Some traits are <em>markers</em> - they don't say that a type implements
some methods, they say that certain things can be done with a type.</p>
<p>For example, <code>i32</code> implements trait <code>Copy</code> (in short, <code>i32</code> <em>is</em> <code>Copy</code>),
so this works:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> a: <span>i32</span> = <span>15</span>;
    <span>let</span> b = a; 
    <span>let</span> c = a; 
}
</code></pre>
<p>And this also works:</p>
<pre><code><span><span>fn</span> <span>print_i32</span></span>(x: <span>i32</span>) {
    <span>println!</span>(<span>"x = {}"</span>, x);
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> a: <span>i32</span> = <span>15</span>;
    print_i32(a); 
    print_i32(a); 
}
</code></pre>
<p>But the <code>Number</code> struct is not <code>Copy</code>, so this doesn't work:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    <span>let</span> m = n; 
    <span>let</span> o = n; 
}
</code></pre>
<p>And neither does this:</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: Number) {
    <span>println!</span>(<span>"{} number {}"</span>, <span>if</span> n.odd { <span>"odd"</span> } <span>else</span> { <span>"even"</span> }, n.value);
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    print_number(n); 
    print_number(n); 
}
</code></pre>
<p>But it works if <code>print_number</code> takes an immutable reference instead:</p>
<pre><code><span><span>fn</span> <span>print_number</span></span>(n: &amp;Number) {
    <span>println!</span>(<span>"{} number {}"</span>, <span>if</span> n.odd { <span>"odd"</span> } <span>else</span> { <span>"even"</span> }, n.value);
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    print_number(&amp;n); 
    print_number(&amp;n); 
}
</code></pre>
<p>It also works if a function takes a <em>mutable</em> reference - but only
if our variable binding is also <code>mut</code>.</p>
<pre><code><span><span>fn</span> <span>invert</span></span>(n: &amp;<span>mut</span> Number) {
    n.value = -n.value;
}

<span><span>fn</span> <span>print_number</span></span>(n: &amp;Number) {
    <span>println!</span>(<span>"{} number {}"</span>, <span>if</span> n.odd { <span>"odd"</span> } <span>else</span> { <span>"even"</span> }, n.value);
}

<span><span>fn</span> <span>main</span></span>() {
    
    <span>let</span> <span>mut</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    print_number(&amp;n);
    invert(&amp;<span>mut</span> n); 
    print_number(&amp;n);
}
</code></pre>
<p>Trait methods can also take <code>self</code> by reference or mutable reference:</p>
<pre><code><span>impl</span> std::clone::<span>Clone</span> <span>for</span> Number {
    <span><span>fn</span> <span>clone</span></span>(&amp;<span>self</span>) -&gt; <span>Self</span> {
        <span>Self</span> { ..*<span>self</span> }
    }
}
</code></pre>
<p>When invoking trait methods, the receiver is borrowed implicitly:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    <span>let</span> <span>mut</span> m = n.clone();
    m.value += <span>100</span>;
    
    print_number(&amp;n);
    print_number(&amp;m);
}
</code></pre>
<p>To highlight this: these are equivalent:</p>
<pre><code><span>let</span> m = n.clone();

<span>let</span> m = std::clone::<span>Clone</span>::clone(&amp;n);
</code></pre>
<p>Marker traits like <code>Copy</code> have no methods:</p>
<pre><code>
<span>impl</span> std::clone::<span>Clone</span> <span>for</span> Number {
    <span><span>fn</span> <span>clone</span></span>(&amp;<span>self</span>) -&gt; <span>Self</span> {
        <span>Self</span> { ..*<span>self</span> }
    }
}

<span>impl</span> std::marker::<span>Copy</span> <span>for</span> Number {}
</code></pre>
<p>Now, <code>Clone</code> can still be used:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    <span>let</span> m = n.clone();
    <span>let</span> o = n.clone();
}
</code></pre>
<p>But <code>Number</code> values will no longer be moved:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { odd: <span>true</span>, value: <span>51</span> };
    <span>let</span> m = n; 
    <span>let</span> o = n; 
}
</code></pre>
<p>Some traits are so common, they can be implemented automatically
by using the <code>derive</code> attribute:</p>
<pre><code><span>#[derive(Clone, Copy)]</span>
<span><span>struct</span> <span>Number</span></span> {
    odd: <span>bool</span>,
    value: <span>i32</span>,
}


</code></pre>
<p>Functions can be generic:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;T&gt;(arg: T) {
    
}
</code></pre>
<p>They can have multiple <em>type parameters</em>, which can then be used in the
function's declaration and its body, instead of concrete types:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;L, R&gt;(left: L, right: R) {
    
}
</code></pre>
<p>Type parameters usually have <em>constraints</em>, so you can actually
do something with them.</p>
<p>The simplest constraints are just trait names:</p>
<pre><code><span><span>fn</span> <span>print</span></span>&lt;T: Display&gt;(value: T) {
    <span>println!</span>(<span>"value = {}"</span>, value);
}

<span><span>fn</span> <span>print</span></span>&lt;T: <span>Debug</span>&gt;(value: T) {
    <span>println!</span>(<span>"value = {:?}"</span>, value);
}
</code></pre>
<p>There's a longer syntax for type parameter constraints:</p>
<pre><code><span><span>fn</span> <span>print</span></span>&lt;T&gt;(value: T)
<span>where</span>
    T: Display,
{
    <span>println!</span>(<span>"value = {}"</span>, value);
}
</code></pre>
<p>Constraints can be more complicated: they can require a type parameter
to implement multiple traits:</p>
<pre><code><span>use</span> std::fmt::<span>Debug</span>;

<span><span>fn</span> <span>compare</span></span>&lt;T&gt;(left: T, right: T)
<span>where</span>
    T: <span>Debug</span> + <span>PartialEq</span>,
{
    <span>println!</span>(<span>"{:?} {} {:?}"</span>, left, <span>if</span> left == right { <span>"=="</span> } <span>else</span> { <span>"!="</span> }, right);
}

<span><span>fn</span> <span>main</span></span>() {
    compare(<span>"tea"</span>, <span>"coffee"</span>);
    
}
</code></pre>
<p>Generic functions can be thought of as namespaces, containing an infinity
of functions with different concrete types.</p>
<p>Same as with crates, and modules, and types, generic functions can be “explored”
(navigated?) using <code>::</code></p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>use</span> std::any::type_name;
    <span>println!</span>(<span>"{}"</span>, type_name::&lt;<span>i32</span>&gt;()); 
    <span>println!</span>(<span>"{}"</span>, type_name::&lt;(<span>f64</span>, <span>char</span>)&gt;()); 
}
</code></pre>
<p>This is lovingly called <a href="https://turbo.fish/">turbofish syntax</a>, because
<code>::&lt;&gt;</code> looks like a fish.</p>
<p>Structs can be generic too:</p>
<pre><code><span><span>struct</span> <span>Pair</span></span>&lt;T&gt; {
    a: T,
    b: T,
}

<span><span>fn</span> <span>print_type_name</span></span>&lt;T&gt;(_val: &amp;T) {
    <span>println!</span>(<span>"{}"</span>, std::any::type_name::&lt;T&gt;());
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p1 = Pair { a: <span>3</span>, b: <span>9</span> };
    <span>let</span> p2 = Pair { a: <span>true</span>, b: <span>false</span> };
    print_type_name(&amp;p1); 
    print_type_name(&amp;p2); 
}
</code></pre>
<p>The standard library type <code>Vec</code> (~ a heap-allocated array), is generic:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> v1 = <span>Vec</span>::new();
    v1.push(<span>1</span>);
    <span>let</span> <span>mut</span> v2 = <span>Vec</span>::new();
    v2.push(<span>false</span>);
    print_type_name(&amp;v1); 
    print_type_name(&amp;v2); 
}
</code></pre>
<p>Speaking of <code>Vec</code>, it comes with a macro that gives more or less “vec literals”:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> v1 = <span>vec!</span>[<span>1</span>, <span>2</span>, <span>3</span>];
    <span>let</span> v2 = <span>vec!</span>[<span>true</span>, <span>false</span>, <span>true</span>];
    print_type_name(&amp;v1); 
    print_type_name(&amp;v2); 
}
</code></pre>
<p>All of <code>name!()</code>, <code>name![]</code> or <code>name!{}</code> invoke a macro. Macros just expand to
regular code.</p>
<p>In fact, <code>println</code> is a macro:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>println!</span>(<span>"{}"</span>, <span>"Hello there!"</span>);
}
</code></pre>
<p>This expands to something that has the same effect as:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>use</span> std::io::{<span>self</span>, Write};
    io::stdout().lock().write_all(<span>b"Hello there!
"</span>).unwrap();
}
</code></pre>
<p><code>panic</code> is also a macro. It violently stops execution with an error
message, and the file name / line number of the error, if enabled:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>panic!</span>(<span>"This panics"</span>);
}

</code></pre>
<p>Some methods also panic. For example, the <code>Option</code> type can contain something,
or it can contain nothing. If <code>.unwrap()</code> is called on it, and it contains
nothing, it panics:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> o1: <span>Option</span>&lt;<span>i32</span>&gt; = <span>Some</span>(<span>128</span>);
    o1.unwrap(); 

    <span>let</span> o2: <span>Option</span>&lt;<span>i32</span>&gt; = <span>None</span>;
    o2.unwrap(); 
}


</code></pre>
<p><code>Option</code> is not a struct - it's an <code>enum</code>, with two variants.</p>
<pre><code><span><span>enum</span> <span>Option</span></span>&lt;T&gt; {
    <span>None</span>,
    <span>Some</span>(T),
}

<span>impl</span>&lt;T&gt; <span>Option</span>&lt;T&gt; {
    <span><span>fn</span> <span>unwrap</span></span>(<span>self</span>) -&gt; T {
        
        <span>match</span> <span>self</span> {
            Self::<span>Some</span>(t) =&gt; t,
            Self::<span>None</span> =&gt; <span>panic!</span>(<span>".unwrap() called on a None option"</span>),
        }
    }
}

<span>use</span> self::<span>Option</span>::{<span>None</span>, <span>Some</span>};

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> o1: <span>Option</span>&lt;<span>i32</span>&gt; = <span>Some</span>(<span>128</span>);
    o1.unwrap(); 

    <span>let</span> o2: <span>Option</span>&lt;<span>i32</span>&gt; = <span>None</span>;
    o2.unwrap(); 
}


</code></pre>
<p><code>Result</code> is also an enum, it can either contain something, or an error:</p>
<pre><code><span><span>enum</span> <span>Result</span></span>&lt;T, E&gt; {
    <span>Ok</span>(T),
    <span>Err</span>(E),
}
</code></pre>
<p>It also panics when unwrapped and containing an error.</p>
<p>Variables bindings have a “lifetime”:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    
    {
        <span>let</span> x = <span>42</span>; 
        <span>println!</span>(<span>"x = {}"</span>, x);
        
    }
    
}
</code></pre>
<p>Similarly, references have a lifetime:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    
    {
        <span>let</span> x = <span>42</span>; 
        <span>let</span> x_ref = &amp;x; 
        <span>println!</span>(<span>"x_ref = {}"</span>, x_ref);
        
        
    }
    
}
</code></pre>
<p>The lifetime of a reference cannot exceed the lifetime of the variable
binding it borrows:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x_ref = {
        <span>let</span> x = <span>42</span>;
        &amp;x
    };
    <span>println!</span>(<span>"x_ref = {}"</span>, x_ref);
    
}
</code></pre>
<p>A variable binding can be immutably borrowed multiple times:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x = <span>42</span>;
    <span>let</span> x_ref1 = &amp;x;
    <span>let</span> x_ref2 = &amp;x;
    <span>let</span> x_ref3 = &amp;x;
    <span>println!</span>(<span>"{} {} {}"</span>, x_ref1, x_ref2, x_ref3);
}
</code></pre>
<p>While borrowed, a variable binding cannot be mutated:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> x = <span>42</span>;
    <span>let</span> x_ref = &amp;x;
    x = <span>13</span>;
    <span>println!</span>(<span>"x_ref = {}"</span>, x_ref);
    
}
</code></pre>
<p>While immutably borrowed, a variable cannot be <em>mutably borrowed</em>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> x = <span>42</span>;
    <span>let</span> x_ref1 = &amp;x;
    <span>let</span> x_ref2 = &amp;<span>mut</span> x;
    
    <span>println!</span>(<span>"x_ref1 = {}"</span>, x_ref1);
}
</code></pre>
<p>References in function arguments also have lifetimes:</p>
<pre><code><span><span>fn</span> <span>print</span></span>(x: &amp;<span>i32</span>) {
    
    
}
</code></pre>
<p>Functions with reference arguments can be called with borrows
that have different lifetimes, so:</p>
<ul>
<li>All functions that take references are generic</li>
<li>Lifetimes are generic parameters</li>
</ul>
<p>Lifetimes’ names start with a single quote, <code>'</code>:</p>
<pre><code>
<span><span>fn</span> <span>print</span></span>(x: &amp;<span>i32</span>) {}


<span><span>fn</span> <span>print</span></span>&lt;<span>'a</span>&gt;(x: &amp;<span>'a</span> <span>i32</span>) {}
</code></pre>
<p>This allows returning references whose lifetime depend on the
lifetime of the arguments:</p>
<pre><code><span><span>struct</span> <span>Number</span></span> {
    value: <span>i32</span>,
}

<span><span>fn</span> <span>number_value</span></span>&lt;<span>'a</span>&gt;(num: &amp;<span>'a</span> Number) -&gt; &amp;<span>'a</span> <span>i32</span> {
    &amp;num.value
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> n = Number { value: <span>47</span> };
    <span>let</span> v = number_value(&amp;n);
    
    
}
</code></pre>
<p>When there is a <em>single</em> input lifetime, it doesn't need to be named,
and everything has the same lifetime, so the two functions below are
equivalent:</p>
<pre><code><span><span>fn</span> <span>number_value</span></span>&lt;<span>'a</span>&gt;(num: &amp;<span>'a</span> Number) -&gt; &amp;<span>'a</span> <span>i32</span> {
    &amp;num.value
}

<span><span>fn</span> <span>number_value</span></span>(num: &amp;Number) -&gt; &amp;<span>i32</span> {
    &amp;num.value
}
</code></pre>
<p>Structs can also be <em>generic over lifetimes</em>, which allows them to
hold references:</p>
<pre><code><span><span>struct</span> <span>NumRef</span></span>&lt;<span>'a</span>&gt; {
    x: &amp;<span>'a</span> <span>i32</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x: <span>i32</span> = <span>99</span>;
    <span>let</span> x_ref = NumRef { x: &amp;x };
    
}
</code></pre>
<p>The same code, but with an additional function:</p>
<pre><code><span><span>struct</span> <span>NumRef</span></span>&lt;<span>'a</span>&gt; {
    x: &amp;<span>'a</span> <span>i32</span>,
}

<span><span>fn</span> <span>as_num_ref</span></span>&lt;<span>'a</span>&gt;(x: &amp;<span>'a</span> <span>i32</span>) -&gt; NumRef&lt;<span>'a</span>&gt; {
    NumRef { x: &amp;x }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x: <span>i32</span> = <span>99</span>;
    <span>let</span> x_ref = as_num_ref(&amp;x);
    
}
</code></pre>
<p>The same code, but with “elided” lifetimes:</p>
<pre><code><span><span>struct</span> <span>NumRef</span></span>&lt;<span>'a</span>&gt; {
    x: &amp;<span>'a</span> <span>i32</span>,
}

<span><span>fn</span> <span>as_num_ref</span></span>(x: &amp;<span>i32</span>) -&gt; NumRef&lt;<span>'_</span>&gt; {
    NumRef { x: &amp;x }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x: <span>i32</span> = <span>99</span>;
    <span>let</span> x_ref = as_num_ref(&amp;x);
    
}
</code></pre>
<p><code>impl</code> blocks can be generic over lifetimes too:</p>
<pre><code><span>impl</span>&lt;<span>'a</span>&gt; NumRef&lt;<span>'a</span>&gt; {
    <span><span>fn</span> <span>as_i32_ref</span></span>(&amp;<span>'a</span> <span>self</span>) -&gt; &amp;<span>'a</span> <span>i32</span> {
        <span>self</span>.x
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x: <span>i32</span> = <span>99</span>;
    <span>let</span> x_num_ref = NumRef { x: &amp;x };
    <span>let</span> x_i32_ref = x_num_ref.as_i32_ref();
    
}
</code></pre>
<p>But you can do elision (“to elide”) there too:</p>
<pre><code><span>impl</span>&lt;<span>'a</span>&gt; NumRef&lt;<span>'a</span>&gt; {
    <span><span>fn</span> <span>as_i32_ref</span></span>(&amp;<span>self</span>) -&gt; &amp;<span>i32</span> {
        <span>self</span>.x
    }
}
</code></pre>
<p>You can elide even harder, if you never need the name:</p>
<pre><code><span>impl</span> NumRef&lt;<span>'_</span>&gt; {
    <span><span>fn</span> <span>as_i32_ref</span></span>(&amp;<span>self</span>) -&gt; &amp;<span>i32</span> {
        <span>self</span>.x
    }
}
</code></pre>
<p>There is a special lifetime, named <code>'static</code>, which is valid for the
entire program's lifetime.</p>
<p>String literals are <code>'static'</code>:</p>
<pre><code><span><span>struct</span> <span>Person</span></span> {
    name: &amp;<span>'static</span> <span>str</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p = Person {
        name: <span>"fasterthanlime"</span>,
    };
}
</code></pre>
<p>But <em>owned strings</em> are not static:</p>
<pre><code><span><span>struct</span> <span>Person</span></span> {
    name: &amp;<span>'static</span> <span>str</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> name = <span>format!</span>(<span>"fasterthan{}"</span>, <span>"lime"</span>);
    <span>let</span> p = Person { name: &amp;name };
    
}
</code></pre>
<p>In that last example, the local <code>name</code> is not a <code>&amp;'static str</code>, it's a
<code>String</code>. It's been allocated dynamically, and it will be freed. Its lifetime
is <em>less</em> than the whole program (even though it happens to be in <code>main</code>).</p>
<p>To store a non-<code>'static</code> string in <code>Person</code>, it needs to either:</p>
<p>A) Be generic over a lifetime:</p>
<pre><code><span><span>struct</span> <span>Person</span></span>&lt;<span>'a</span>&gt; {
    name: &amp;<span>'a</span> <span>str</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> name = <span>format!</span>(<span>"fasterthan{}"</span>, <span>"lime"</span>);
    <span>let</span> p = Person { name: &amp;name };
    
}
</code></pre>
<p>or</p>
<p>B) Take ownership of the string</p>
<pre><code><span><span>struct</span> <span>Person</span></span> {
    name: <span>String</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> name = <span>format!</span>(<span>"fasterthan{}"</span>, <span>"lime"</span>);
    <span>let</span> p = Person { name: name };
    
}
</code></pre>
<p>Speaking of: in a struct literal, when a field is set to a variable binding of the
same name:</p>
<pre><code>    <span>let</span> p = Person { name: name };
</code></pre>
<p>It can be shortened like this:</p>
<pre><code>    <span>let</span> p = Person { name };
</code></pre>
<p>For many types in Rust, there are owned and non-owned variants:</p>
<ul>
<li>Strings: <code>String</code> is owned, <code>&amp;str</code> is a reference</li>
<li>Paths: <code>PathBuf</code> is owned, <code>&amp;Path</code> is a reference</li>
<li>Collections: <code>Vec&lt;T&gt;</code> is owned, <code>&amp;[T]</code> is a reference</li>
</ul>
<p>Rust has slices - they're a reference to multiple contiguous elements.</p>
<p>You can borrow a slice of a vector, for example:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> v = <span>vec!</span>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>];
    <span>let</span> v2 = &amp;v[<span>2</span>..<span>4</span>];
    <span>println!</span>(<span>"v2 = {:?}"</span>, v2);
}



</code></pre>
<p>The above is not magical. The indexing operator (<code>foo[index]</code>) is
overloaded with the <code>Index</code> and <code>IndexMut</code> traits.</p>
<p>The <code>..</code> syntax is just range literals. Ranges are just a few
structs defined in the standard library.</p>
<p>They can be open-ended, and their rightmost bound can be inclusive,
if it's preceded by <code>=</code>.</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    
    <span>println!</span>(<span>"{:?}"</span>, (<span>0</span>..).contains(&amp;<span>100</span>)); 
    
    <span>println!</span>(<span>"{:?}"</span>, (..<span>20</span>).contains(&amp;<span>20</span>)); 
    
    <span>println!</span>(<span>"{:?}"</span>, (..=<span>20</span>).contains(&amp;<span>20</span>)); 
    
    <span>println!</span>(<span>"{:?}"</span>, (<span>3</span>..<span>6</span>).contains(&amp;<span>4</span>)); 
}
</code></pre>
<p>Borrowing rules apply to slices.</p>
<pre><code><span><span>fn</span> <span>tail</span></span>(s: &amp;[<span>u8</span>]) -&gt; &amp;[<span>u8</span>] {
  &amp;s[<span>1</span>..] 
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> x = &amp;[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>];
    <span>let</span> y = tail(x);
    <span>println!</span>(<span>"y = {:?}"</span>, y);
}
</code></pre>
<p>This is the same as:</p>
<pre><code><span><span>fn</span> <span>tail</span></span>&lt;<span>'a</span>&gt;(s: &amp;<span>'a</span> [<span>u8</span>]) -&gt; &amp;<span>'a</span> [<span>u8</span>] {
  &amp;s[<span>1</span>..] 
}
</code></pre>
<p>This is legal:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> y = {
        <span>let</span> x = &amp;[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>];
        tail(x)
    };
    <span>println!</span>(<span>"y = {:?}"</span>, y);
}
</code></pre>
<p>…but only because <code>[1, 2, 3, 4, 5]</code> is a <code>'static</code> array.</p>
<p>So, this is illegal:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> y = {
        <span>let</span> v = <span>vec!</span>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>];
        tail(&amp;v)
        
    };
    <span>println!</span>(<span>"y = {:?}"</span>, y);
}
</code></pre>
<p>…because a vector is heap-allocated, and it has a non-<code>'static</code> lifetime.</p>
<p><code>&amp;str</code> values are really slices.</p>
<pre><code><span><span>fn</span> <span>file_ext</span></span>(name: &amp;<span>str</span>) -&gt; <span>Option</span>&lt;&amp;<span>str</span>&gt; {
    
    
    name.split(<span>"."</span>).last()
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> name = <span>"Read me. Or don't.txt"</span>;
    <span>if</span> <span>let</span> <span>Some</span>(ext) = file_ext(name) {
        <span>println!</span>(<span>"file extension: {}"</span>, ext);
    } <span>else</span> {
        <span>println!</span>(<span>"no file extension"</span>);
    }
}
</code></pre>
<p>…so the borrow rules apply here too:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> ext = {
        <span>let</span> name = <span>String</span>::from(<span>"Read me. Or don't.txt"</span>);
        file_ext(&amp;name).unwrap_or(<span>""</span>)
        
    };
    <span>println!</span>(<span>"extension: {:?}"</span>, ext);
}
</code></pre>
<p>Functions that can fail typically return a <code>Result</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]);
    <span>println!</span>(<span>"{:?}"</span>, s);
    

    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>195</span>, <span>40</span>]);
    <span>println!</span>(<span>"{:?}"</span>, s);
    
}
</code></pre>
<p>If you want to panic in case of failure, you can <code>.unwrap()</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]).unwrap();
    <span>println!</span>(<span>"{:?}"</span>, s);
    

    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>195</span>, <span>40</span>]).unwrap();
    
    
    
}
</code></pre>
<p>Or <code>.expect()</code>, for a custom message:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>195</span>, <span>40</span>]).expect(<span>"valid utf-8"</span>);
    
    
}
</code></pre>
<p>Or, you can <code>match</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>match</span> std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]) {
        <span>Ok</span>(s) =&gt; <span>println!</span>(<span>"{}"</span>, s),
        <span>Err</span>(e) =&gt; <span>panic!</span>(e),
    }
    
}
</code></pre>
<p>Or you can <code>if let</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>if</span> <span>let</span> <span>Ok</span>(s) = std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]) {
        <span>println!</span>(<span>"{}"</span>, s);
    }
    
}
</code></pre>
<p>Or you can bubble up the error:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() -&gt; <span>Result</span>&lt;(), std::<span>str</span>::Utf8Error&gt; {
    <span>match</span> std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>]) {
        <span>Ok</span>(s) =&gt; <span>println!</span>(<span>"{}"</span>, s),
        <span>Err</span>(e) =&gt; <span>return</span> <span>Err</span>(e),
    }
    <span>Ok</span>(())
}
</code></pre>
<p>Or you can use <code>?</code> to do it the concise way:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() -&gt; <span>Result</span>&lt;(), std::<span>str</span>::Utf8Error&gt; {
    <span>let</span> s = std::<span>str</span>::from_utf8(&amp;[<span>240</span>, <span>159</span>, <span>141</span>, <span>137</span>])?;
    <span>println!</span>(<span>"{}"</span>, s);
    <span>Ok</span>(())
}
</code></pre>
<p>The <code>*</code> operator can be used to <em>dereference</em>, but you don't need to do
that to access fields or call methods:</p>
<pre><code><span><span>struct</span> <span>Point</span></span> {
    x: <span>f64</span>,
    y: <span>f64</span>,
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p = Point { x: <span>1.0</span>, y: <span>3.0</span> };
    <span>let</span> p_ref = &amp;p;
    <span>println!</span>(<span>"({}, {})"</span>, p_ref.x, p_ref.y);
}


</code></pre>
<p>And you can only do it if the type is <code>Copy</code>:</p>
<pre><code><span><span>struct</span> <span>Point</span></span> {
    x: <span>f64</span>,
    y: <span>f64</span>,
}

<span><span>fn</span> <span>negate</span></span>(p: Point) -&gt; Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p = Point { x: <span>1.0</span>, y: <span>3.0</span> };
    <span>let</span> p_ref = &amp;p;
    negate(*p_ref);
    
}
</code></pre>
<pre><code>
<span>#[derive(Clone, Copy)]</span>
<span><span>struct</span> <span>Point</span></span> {
    x: <span>f64</span>,
    y: <span>f64</span>,
}

<span><span>fn</span> <span>negate</span></span>(p: Point) -&gt; Point {
    Point {
        x: -p.x,
        y: -p.y,
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> p = Point { x: <span>1.0</span>, y: <span>3.0</span> };
    <span>let</span> p_ref = &amp;p;
    negate(*p_ref); 
}
</code></pre>
<p>Closures are just functions of type <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> with some captured context.</p>
<p>Their parameters are a comma-separated list of names within a pair of pipes
(<code>|</code>). They don't <em>need</em> curly braces, unless you want to have multiple statement.</p>
<pre><code><span><span>fn</span> <span>for_each_planet</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(&amp;<span>'static</span> <span>str</span>)
{
    f(<span>"Earth"</span>);
    f(<span>"Mars"</span>);
    f(<span>"Jupiter"</span>);
}
 
<span><span>fn</span> <span>main</span></span>() {
    for_each_planet(|planet| <span>println!</span>(<span>"Hello, {}"</span>, planet));
}





</code></pre>
<p>The borrow rules apply to them too:</p>
<pre><code><span><span>fn</span> <span>for_each_planet</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(&amp;<span>'static</span> <span>str</span>)
{
    f(<span>"Earth"</span>);
    f(<span>"Mars"</span>);
    f(<span>"Jupiter"</span>);
}
 
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> greeting = <span>String</span>::from(<span>"Good to see you"</span>);
    for_each_planet(|planet| <span>println!</span>(<span>"{}, {}"</span>, greeting, planet));
    
}
</code></pre>
<p>For example, this would not work:</p>
<pre><code><span><span>fn</span> <span>for_each_planet</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(&amp;<span>'static</span> <span>str</span>) + <span>'static</span> 
{
    f(<span>"Earth"</span>);
    f(<span>"Mars"</span>);
    f(<span>"Jupiter"</span>);
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> greeting = <span>String</span>::from(<span>"Good to see you"</span>);
    for_each_planet(|planet| <span>println!</span>(<span>"{}, {}"</span>, greeting, planet));
    
    
}
</code></pre>
<p>But this would:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> greeting = <span>String</span>::from(<span>"You're doing great"</span>);
    for_each_planet(<span>move</span> |planet| <span>println!</span>(<span>"{}, {}"</span>, greeting, planet));
    
    
}
</code></pre>
<p>An <code>FnMut</code> needs to be mutably borrowed to be called, so it can
only be called once at a time.</p>
<p>This is legal:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>println!</span>(<span>"{}"</span>, f(f(<span>2</span>))); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    foobar(|x| x * <span>2</span>);
}


</code></pre>
<p>This isn't:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(<span>mut</span> f: F)
    <span>where</span> F: <span>FnMut</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>println!</span>(<span>"{}"</span>, f(f(<span>2</span>))); 
    
}
 
<span><span>fn</span> <span>main</span></span>() {
    foobar(|x| x * <span>2</span>);
}
</code></pre>
<p>This is legal again:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(<span>mut</span> f: F)
    <span>where</span> F: <span>FnMut</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>let</span> tmp = f(<span>2</span>);
    <span>println!</span>(<span>"{}"</span>, f(tmp)); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    foobar(|x| x * <span>2</span>);
}


</code></pre>
<p><code>FnMut</code> exists because some closures <em>mutably borrow</em> local variables:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(<span>mut</span> f: F)
    <span>where</span> F: <span>FnMut</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>let</span> tmp = f(<span>2</span>);
    <span>println!</span>(<span>"{}"</span>, f(tmp)); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> acc = <span>2</span>;
    foobar(|x| {
        acc += <span>1</span>;
        x * acc
    });
}


</code></pre>
<p>Those closures cannot be passed to functions expecting <code>Fn</code>:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>Fn</span>(<span>i32</span>) -&gt; <span>i32</span>
{
    <span>println!</span>(<span>"{}"</span>, f(f(<span>2</span>))); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> <span>mut</span> acc = <span>2</span>;
    foobar(|x| {
        acc += <span>1</span>;
        
        
        
        
        x * acc
    });
}
</code></pre>
<p><code>FnOnce</code> closures can only be called once. They exist because some closure
move out variables that have been moved when captured:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>FnOnce</span>() -&gt; <span>String</span>
{
    <span>println!</span>(<span>"{}"</span>, f()); 
}
 
<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = <span>String</span>::from(<span>"alright"</span>);
    foobar(<span>move</span> || s);
    
    
    
}
</code></pre>
<p>This is enforced naturally, as <code>FnOnce</code> closures need to be <em>moved</em>
in order to be called.</p>
<p>So, for example, this is illegal:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(f: F)
    <span>where</span> F: <span>FnOnce</span>() -&gt; <span>String</span>
{
    <span>println!</span>(<span>"{}"</span>, f()); 
    <span>println!</span>(<span>"{}"</span>, f()); 
    
}
</code></pre>
<p>And, if you need convincing that our closure <em>does</em> move <code>s</code>,
this is illegal too:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = <span>String</span>::from(<span>"alright"</span>);
    foobar(<span>move</span> || s);
    foobar(<span>move</span> || s);
    
}
</code></pre>
<p>But this is fine:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>let</span> s = <span>String</span>::from(<span>"alright"</span>);
    foobar(|| s.clone());
    foobar(|| s.clone());
}
</code></pre>
<p>Here's a closure with two arguments:</p>
<pre><code><span><span>fn</span> <span>foobar</span></span>&lt;F&gt;(x: <span>i32</span>, y: <span>i32</span>, is_greater: F)
    <span>where</span> F: <span>Fn</span>(<span>i32</span>, <span>i32</span>) -&gt; <span>bool</span>
{
    <span>let</span> (greater, smaller) = <span>if</span> is_greater(x, y) {
        (x, y)
    } <span>else</span> {
        (y, x)
    };
    <span>println!</span>(<span>"{} is greater than {}"</span>, greater, smaller);
}
 
<span><span>fn</span> <span>main</span></span>() {
    foobar(<span>32</span>, <span>64</span>, |x, y| x &gt; y);
}
</code></pre>
<p>Here's a closure ignoring both its arguments:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    foobar(<span>32</span>, <span>64</span>, |_, _| <span>panic!</span>(<span>"Comparing is futile!"</span>));
}
</code></pre>
<p>Here's a slightly worrying closure:</p>
<pre><code><span><span>fn</span> <span>countdown</span></span>&lt;F&gt;(count: <span>usize</span>, tick: F)
    <span>where</span> F: <span>Fn</span>(<span>usize</span>)
{
    <span>for</span> i <span>in</span> (<span>1</span>..=count).rev() {
        tick(i);
    }
}
 
<span><span>fn</span> <span>main</span></span>() {
    countdown(<span>3</span>, |i| <span>println!</span>(<span>"tick {}..."</span>, i));
}





</code></pre>
<p>And here's a toilet closure:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    countdown(<span>3</span>, |_| ());
}
</code></pre>
<p>Called thusly because <code>|_| ()</code> looks like a toilet.</p>
<p>Anything that is iterable can be used in a <code>for in</code> loop.</p>
<p>We've just seen a range being used, but it also works with a <code>Vec</code>:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>for</span> i <span>in</span> <span>vec!</span>[<span>52</span>, <span>49</span>, <span>21</span>] {
        <span>println!</span>(<span>"I like the number {}"</span>, i);
    }
}
</code></pre>
<p>Or a slice:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>for</span> i <span>in</span> &amp;[<span>52</span>, <span>49</span>, <span>21</span>] {
        <span>println!</span>(<span>"I like the number {}"</span>, i);
    }
}





</code></pre>
<p>Or an actual iterator:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    
    
    <span>for</span> c <span>in</span> <span>"rust"</span>.chars() {
        <span>println!</span>(<span>"Give me a {}"</span>, c);
    }
}






</code></pre>
<p>Even if the iterator items are filtered and mapped and flattened:</p>
<pre><code><span><span>fn</span> <span>main</span></span>() {
    <span>for</span> c <span>in</span> <span>"sHE'S brOKen"</span>
        .chars()
        .filter(|c| c.is_uppercase() || !c.is_ascii_alphabetic())
        .flat_map(|c| c.to_lowercase())
    {
        <span>print!</span>(<span>"{}"</span>, c);
    }
    <span>println!</span>();
}


</code></pre>
<p>You can return a closure from a function:</p>
<pre><code><span><span>fn</span> <span>make_tester</span></span>(answer: <span>String</span>) -&gt; <span>impl</span> <span>Fn</span>(&amp;<span>str</span>) -&gt; <span>bool</span> {
    <span>move</span> |challenge| {
        challenge == answer
    }
}

<span><span>fn</span> <span>main</span></span>() {
    
    
    <span>let</span> test = make_tester(<span>"hunter2"</span>.into());
    <span>println!</span>(<span>"{}"</span>, test(<span>"******"</span>));
    <span>println!</span>(<span>"{}"</span>, test(<span>"hunter2"</span>));
}
</code></pre>
<p>You can even move a reference to some of a function's arguments,
into a closure it returns:</p>
<pre><code><span><span>fn</span> <span>make_tester</span></span>&lt;<span>'a</span>&gt;(answer: &amp;<span>'a</span> <span>str</span>) -&gt; <span>impl</span> <span>Fn</span>(&amp;<span>str</span>) -&gt; <span>bool</span> + <span>'a</span> {
    <span>move</span> |challenge| {
        challenge == answer
    }
}

<span><span>fn</span> <span>main</span></span>() {
    <span>let</span> test = make_tester(<span>"hunter2"</span>);
    <span>println!</span>(<span>"{}"</span>, test(<span>"*******"</span>));
    <span>println!</span>(<span>"{}"</span>, test(<span>"hunter2"</span>));
}




</code></pre>
<p>Or, with elided lifetimes:</p>
<pre><code><span><span>fn</span> <span>make_tester</span></span>(answer: &amp;<span>str</span>) -&gt; <span>impl</span> <span>Fn</span>(&amp;<span>str</span>) -&gt; <span>bool</span> + <span>'_</span> {
    <span>move</span> |challenge| {
        challenge == answer
    }
}
</code></pre>
<p>And with that, we hit the 30-minute estimated reading time mark, and you
should be able to read <em>most</em> of the Rust code you find online.</p>
<p>Writing Rust is a very different experience from reading Rust. On one hand,
you're not reading the <em>solution</em> to a problem, you're actually solving it.
On the other hand, the Rust compiler helps out a <em>lot</em>.</p>
<p>For all of the intentional mistakes made above (“this code is illegal”, etc.),
rustc always has very good error messages <em>and</em> insightful suggestions.</p>
<p>And when there's a hint missing, the compiler team is <a href="https://mobile.twitter.com/fasterthanlime/status/1219601989404954624">not afraid to add it</a>.</p>
<p>For more Rust material, you may want to check out:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust By Example</a></li>
<li><a href="https://readrust.net/">Read Rust</a></li>
<li><a href="https://this-week-in-rust.org/">This Week In Rust</a></li>
</ul>
<p>I also <a href="https://fasterthanli.me/tags/rust/">blog about Rust</a> and <a href="https://twitter.com/fasterthanlime">tweet about
Rust</a> a lot, so if you liked this
article, you know what to do.</p>
<p>Have fun!</p>


          



          
          
<p>This article was made possible thanks to my patrons: Aurora, Chad Morrow, Fernando, Geert Depuydt, Geoff Cant, Geoffroy Couprie,
Ignacio Vergara, Jane Lusby, Jesús Higueras, Jérémy Gtld, Makoto Nakashima,
Michael Alyn Miller, Nicolas Goy, o0Ignition0o, Pascal, Raphael Gaschignard,
Romain Ruetschi, Ryszard Sommefeldt, Sebastian Zimmer, Someone, Stefano
Probst, Ted Mielczarek, Xananax, Zaki, and Тим Маринин.</p>
          
        </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>