<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Jepsen: MongoDB 4.2.6 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Jepsen: MongoDB 4.2.6 - linksfor.dev(s)"/>
    <meta property="article:author" content="Kyle Kingsbury"/>
    <meta property="og:description" content="MongoDB is a distributed document database which claims to offer &#x201C;among the strongest data consistency, correctness, and safety guarantees of any database available today&#x201D;, with &#x201C;full ACID transactions&#x201D;. Jepsen evaluated MongoDB version 4.2.6, and found that even at the strongest levels of read and write concern, it failed to preserve snapshot isolation. Instead, Jepsen observed read skew, cyclic information flow, duplicate writes, and internal consistency violations. Weak defaults meant that transactions could lose writes and allow dirty reads, even downgrading requested safety levels at the database and collection level. Moreover, the snapshot read concern did not guarantee snapshot unless paired with write concern majority&#x2014;even for read-only transactions. These design choices complicate the safe use of MongoDB transactions. This work was performed independently, without compensation, and conducted in accordance with the Jepsen ethics policy. MongoDB, Fauna, and YugaByte, all mentioned in this report, have previously engaged Jepsen for paid analyses."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://jepsen.io/analyses/mongodb-4.2.6"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Jepsen: MongoDB 4.2.6</title>
<div class="readable">
        <h1>Jepsen: MongoDB 4.2.6</h1>
            <div>by Kyle Kingsbury</div>
            <div>Reading time: 27-34 minutes</div>
        <div>Posted here: 16 May 2020</div>
        <p><a href="http://jepsen.io/analyses/mongodb-4.2.6">http://jepsen.io/analyses/mongodb-4.2.6</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>
    MongoDB is a distributed document database which claims to offer “among the strongest data consistency, correctness, and safety guarantees of any database available today”, with “full ACID transactions”. Jepsen evaluated MongoDB version 4.2.6, and found that even at the strongest levels of read and write concern, it failed to preserve snapshot isolation. Instead, Jepsen observed read skew, cyclic information flow, duplicate writes, and internal consistency violations. Weak defaults meant that transactions could lose writes and allow dirty reads, even downgrading requested safety levels at the database and collection level. Moreover, the <code>snapshot</code> read concern did not guarantee snapshot unless paired with write concern <code>majority</code>—even for read-only transactions. These design choices complicate the safe use of MongoDB transactions. This work was performed independently, without compensation, and conducted in accordance with the <a href="https://jepsen.io/ethics.html">Jepsen ethics policy</a>. MongoDB, Fauna, and YugaByte, all mentioned in this report, have previously engaged Jepsen for paid analyses.
  </p><article>
  <div>

<p>MongoDB is a popular distributed document database. It offers <a href="https://docs.mongodb.com/manual/replication/">replication</a> via a <a href="https://jepsen.io/analyses/mongodb-3-4-0-rc3#protocol-version-1">homegrown consensus protocol</a> which draws inspiration from <a href="https://raft.github.io/">Raft</a>, and can distribute data across shards via <a href="https://docs.mongodb.com/manual/sharding/">mongos</a>. We previously evaluated MongoDB at versions <a href="https://aphyr.com/posts/284-call-me-maybe-mongodb">2.4.3</a>, <a href="https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads">2.6.7</a>, <a href="https://jepsen.io/analyses/mongodb-3-4-0-rc3">3.4.0-rc3</a>, and <a href="https://jepsen.io/analyses/mongodb-3-6-4">3.6.4</a>.</p>
<p>Our most recent report on <a href="https://jepsen.io/analyses/mongodb-3-6-4">MongoDB 3.6.4</a> focused on causal consistency and linearizability in sharded collections. We found that sharded clusters appeared to offer linearizable reads, writes, and compare-and-set operations against single documents, so long as users ran with <a href="https://docs.mongodb.com/manual/reference/read-concern/">read concern</a> <code>linearizable</code> and <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> <code>majority</code>. However, any weaker level of write concern resulted in the loss of committed writes. MongoDB’s default level of write concern was (and remains) acknowledgement by a single node, which means MongoDB may lose data by default. Although the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern documentation</a> does not make this clear, the <a href="https://docs.mongodb.com/manual/core/replica-set-rollbacks/">rollback documentation</a> states:</p>
<blockquote>
<p>With the default write concern, data may be rolled back if the primary steps down before the write operations have replicated to any of the secondaries.</p>
</blockquote>
<p>Similarly, MongoDB’s default level of read concern allows aborted reads: readers can observe state that is not fully committed, and could be discarded in the future. As the <a href="https://docs.mongodb.com/manual/core/read-isolation-consistency-recency/">read isolation consistency docs</a> note, “Read uncommitted is the default isolation level”.</p>
<p>We found that due to these weak defaults, MongoDB’s causal sessions <a href="https://jepsen.io/analyses/mongodb-3-6-4#discussion">did not preserve causal consistency</a> by default: users needed to specify both write and read concern <code>majority</code> (or higher) to actually get causal consistency. MongoDB <a href="https://jira.mongodb.org/browse/SERVER-35316?focusedCommentId=2008354&amp;page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#comment-2008354">closed the issue</a>, saying it was working as designed, and updated their <a href="https://docs.mongodb.com/manual/core/read-isolation-consistency-recency/#causal-consistency">isolation documentation</a> to note that even though MongoDB offers “causal consistency in client sessions”, that guarantee does not hold unless users take care to use both read and write concern <code>majority</code>. A <a href="https://docs.mongodb.com/manual/core/causal-consistency-read-write-concerns/">detailed table</a> now shows the properties offered by weaker read and write concerns.</p>
<p>Curiously, MongoDB omitted any mention of these findings in their <a href="https://web.archive.org/web/20200508173236/https://www.mongodb.com/jepsen">MongoDB and Jepsen</a> page. Instead, that page discusses only passing results, makes no mention of read or write concern, buries the actual report in a footnote, and goes on to claim:</p>
<blockquote>
<p>MongoDB offers among the strongest data consistency, correctness, and safety guarantees of any database available today.</p>
</blockquote>
<p>We encourage MongoDB to report Jepsen findings in context: while MongoDB <em>did</em> appear to offer per-document linearizability and causal consistency with the strongest settings, it also <em>failed</em> to offer those properties in most configurations. We think users might want to be aware that their database could lose data by default, but MongoDB’s summary of our work omits any mention of this behavior.</p>
<h2 id="transactional-consistency"> Transactional Consistency</h2>
<p>So, does MongoDB offer “among the strongest data consistency, correctness, and safety guarantees”? Past work suggests that for individual document operations, the answer is, “yes; MongoDB offers per-document linearizability with the strongest settings, but not by default”. However in 2018, MongoDB introduced <em>multi-document transactions</em>—limited to within a shard—and in 2019, extended those transactions across shards. What safety properties do these transactions provide?</p>
<p>The <a href="https://www.mongodb.com/">MongoDB home page</a> proudly advertises “full ACID transactions”. The <a href="https://www.mongodb.com/transactions">transactions page</a> states that MongoDB is “the only database that fully combines the power of the document model and a distributed systems architecture with ACID guarantees,” a combination also claimed by <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/database-transactions-optimistic-concurrency">CosmosDB</a>, <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transaction-apis.html#transaction-isolation">DynamoDB</a>, <a href="https://docs.fauna.com/fauna/current/concepts/isolation_levels.html">FaunaDB</a>, <a href="https://www.oracle.com/database/nosql-cloud.html">Oracle NoSQL</a>, <a href="https://orientdb.com/docs/last/Transactions.html">OrientDB</a>, <a href="https://ravendb.net/why-ravendb/acid-transactions">RavenDB</a>, <a href="https://help.sap.com/viewer/3e48dd3ad36e41efbdf534a89fdf278f/2.0.04/en-US/b4518419653e44daad99c285039b29c5.html">SAP HANA</a>, <a href="https://docs.yugabyte.com/latest/architecture/transactions/isolation-levels/">YugaByte DB</a>, et al.</p>
<p>The <a href="https://www.mongodb.com/collateral/mongodb-architecture-guide">MongoDB architecture guide</a> promises ACID transactions “maintain the same data integrity guarantees you are used to in traditional databases…”, and that MongoDB offers “strong consistency by design”, but offers no more specific claims. The <a href="https://www.mongodb.com/collateral/mongodb-multi-document-acid-transactions">ACID whitepaper</a> clarifies that MongoDB transactions offer <a href="https://jepsen.io/consistency/models/snapshot-isolation">snapshot isolation</a>: a reasonably strong model which constitutes the baseline level of consistency for systems like <a href="https://www.postgresql.org/">PostgreSQL</a>. The whitepaper states:</p>
<blockquote>
<p>… snapshot read isolation ensures queries and aggregations executed within a read-only transaction will operate against a globally consistent snapshot of the database across each primary replica of a sharded cluster.</p>
</blockquote>
<p><a href="https://www.mongodb.com/blog/post/mongodb-multi-document-acid-transactions-general-availability">MongoDB</a> <a href="https://www.mongodb.com/blog/post/multi-document-transactions-in-mongodb">repeatedly</a> <a href="https://www.mongodb.com/collateral/mongodb-multi-document-acid-transactions">summarizes</a> snapshot isolation as “transactions provide a consistent view of data, and enforce all-or-nothing execution to maintain data integrity”. This is a concise and intuitive summary of snapshot isolation, but we should note that a “consistent view” under snapshot isolation may still be surprising: as Fekete, O’Neil, and O’Neil <a href="https://www.cs.umb.edu/~poneil/ROAnom.pdf">wrote in 2004</a>, read-only transactions can observe nonserializable behavior under snapshot isolation. Nor does snapshot isolation necessarily maintain data integrity: in their <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">1995 paper defining snapshot isolation</a>, Berenson, Bernstein, et al.&nbsp;provided examples of applications whose integrity constraints could be violated under snapshot isolation—for instance, due to write skew.</p>

<p>We designed a <a href="https://github.com/jepsen-io/mongodb/tree/83548bb8e054170ecc4b8fda70390e40fcca5e30">test suite</a> using the <a href="https://github.com/jepsen-io/jepsen">Jepsen</a> distributed systems testing library, and used it to evaluate transactional safety in MongoDB 4.2.6. Our tests installed MongoDB’s official Debian packages on clusters of nine Debian 9 nodes. We tested both in LXC and EC2; both exhibited similar behavior. As per the <a href="https://docs.mongodb.com/manual/tutorial/deploy-shard-cluster/">deployment guidelines</a>, we built <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/db.clj#L281-L295">two-shard clusters</a>, with both shards and the <code>configsvr</code> metadata system running as three-node <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/db.clj#L93-L223">replica sets</a>. All nine nodes ran <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/db.clj#L361-L380">an instance of <code>mongos</code></a>, which serves as the frontend to sharded MongoDB clusters.</p>
<p>Our <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/list_append.clj#L74-L136">test workload</a> involved transactions over a rotating pool of documents in a single MongoDB collection, each document containing a single array of integers. Each transaction <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/list_append.clj#L52-L72">performed one to four operations</a> over those documents: either reading a single document by primary key <code>_id</code>, or appending (using <code>$push</code>) a unique integer to a single document’s <code>value</code> array, again by <code>_id</code>. We <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/list_append.clj#L84-L98">sharded</a> the collection by <code>_id</code>.</p>
<p>Using <a href="https://github.com/jepsen-io/elle">Elle</a>, a new transaction analysis tool developed in collaboration with UC Santa Cruz’s <a href="https://people.ucsc.edu/~palvaro/">Peter Alvaro</a>, Jepsen automatically inferred dependencies between these transactions, and searched for cycles in that graph to identify isolation anomalies. Additional techniques checked for aborted and intermediate reads, as well as other non-cyclic anomalies.</p>
<p>During some of these tests, we introduced <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/nemesis.clj">network partitions</a>, targeted to isolate MongoDB primary nodes.</p>

<h2 id="sometimes-programs-that-use-transactions-are-worse"> Sometimes, Programs That Use Transactions… Are Worse</h2>
<p>We began by running our tests without transactions to get a baseline: each Jepsen “transaction” performed only a single read or append operation without using the session or transaction APIs. Since we know MongoDB loses updates with any setting less than <code>majority</code>, and exhibits stale reads without read concern <code>linearizable</code>, we set write concern <code>majority</code> and read concern <code>linearizable</code> <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/client.clj#L265-L277">on the client’s <code>database</code> handle</a>. The resulting histories appeared consistent with snapshot isolation.</p>
<p>We then wrapped those single operations in transactions, and a surprising behavior appeared: with network partitions, transactions appeared to lose acknowledged writes. For instance, consider <a href="http://jepsen.io.s3.amazonaws.com/analyses/mongodb-4.2.6/20200509T083112.000-0400.zip">this history</a>, where in 30 seconds, updates to eight documents were successfully acknowledged, then disappeared. Here is the history of reads for document 555:</p>

<p>Clients observed a monotonically growing list of elements until <code>[1 2 3 4 5 6 7]</code>, at which point the list reset to <code>[]</code>, and started afresh with <code>[8]</code>. This could be an example of MongoDB <a href="https://docs.mongodb.com/manual/core/replica-set-rollbacks/">rollbacks</a>, which is a fancy way of saying “data loss”.</p>
<p>This is bad, but a more subtle question arises: <em>why were we able to read these values at all</em>? After all, read concern <code>linearizable</code> <a href="https://docs.mongodb.com/manual/reference/read-concern-linearizable/">is supposed to show only majority-acknowledged</a> (i.e.&nbsp;durable) writes. The answer is a surprising—<a href="https://docs.mongodb.com/manual/core/transactions/">but documented</a>—MongoDB design choice:</p>
<blockquote>
<p>Operations in a transaction use the transaction-level read concern. That is, any read concern set at the collection and database level is ignored inside the transaction.</p>
</blockquote>
<p>The received wisdom in the database community is that MongoDB has historically resisted raising the default level of read and write safety because doing so would impact production users who have become accustomed to faster, occasionally unsafe defaults, and because data loss might not be significant enough to warrant the increased latency, throughput, and capital expenditure entailed by stronger safety settings. MongoDB’s researchers <a href="http://www.vldb.org/pvldb/vol12/p2071-schultz.pdf">reported in VLDB</a> that:</p>
<blockquote>
<p>… users would prefer, of course, to use readConcern level “majority” and writeConcern w:“majority”, since everyone wants safety. However, when users find stronger consistency levels to be too slow, they will switch to using weaker consistency levels. These decisions are often based on business requirements and SLAs rather than granular developer needs. As we argue throughout this paper, the decision to use weaker consistency levels often works in practice because failovers are infrequent and data loss from failovers is usually small.</p>
</blockquote>
<p>However, transactions are an entirely new feature, and users presumably <em>expect</em> to trade off some speed in exchange for improved safety guarantees. A reasonable user might expect that the default safety levels for transactions provide, as promised, snapshot isolation—or, at the very least, the same level of read concern that the user has already requested from the databases or collections involved. Instead, transactions without an explicit read concern <a href="https://docs.mongodb.com/master/core/transactions/#transactions-and-read-concern">downgrade any requested read concern</a> at the database or collection level to a default level of <code>local</code>, <a href="https://docs.mongodb.com/master/reference/read-concern-local/#readconcern.%22local%22">which offers</a> “no guarantee that the data has been written to a majority of replicas (i.e. may be rolled back).”</p>
<p>So: users should be careful to use the <code>snapshot</code> level of read concern with every transaction which requires snapshot isolation. The <a href="https://docs.mongodb.com/master/core/transactions/#transactions-and-read-concern">documentation confirms</a>: “Read concern ‘snapshot’ returns data from a snapshot of majority committed data…” which makes sense, and then continues: “<strong>if</strong> the transaction commits with write concern ‘majority’”, which does not. Specifically:</p>
<blockquote>
<p>If the transaction does not use write concern “majority” for the commit, the “snapshot” read concern provides no guarantee that read operations used a snapshot of majority-committed data.</p>
</blockquote>
<p>“What is the point,” an astute reader might ask, “of having a <code>snapshot</code> read concern which does not provide snapshot isolated reads?” An even more astute reader, having observed a pattern, might inquire about the <em>default</em> level of write concern.</p>
<blockquote>
<p>If the transaction-level write concern and the session-level write concern are unset, transaction-level write concern defaults to the client-level write concern. By default, client-level write concern is w: 1.</p>
</blockquote>
<p>In order to obtain snapshot isolation, users must be careful not only to set the read concern to <code>snapshot</code> for each transaction, but <em>also</em> to set write concern for each transaction to <code>majority</code>.</p>
<p>Astonishingly, this applies even to <em>read-only</em> transactions. In <a href="http://jepsen.io.s3.amazonaws.com/analyses/mongodb-4.2.6/20200509T093640.000-0400.zip">this test run</a>, we set read concern <code>snapshot</code> and write concern <code>majority</code> on single-operation write transactions, and for single-operation read transactions, set only read concern <code>snapshot</code>. When a network partition occurred, reads observed divergent timelines:</p>

<p>These updates weren’t <em>lost</em> exactly—the transactions which wrote 1, 5, and 6 timed out, but their effects being both visible and not visible to reads implies that at least one of these timelines was an instance of aborted read.</p>
<p>This behavior might be surprising, but to MongoDB’s credit, most of this behavior is <a href="https://docs.mongodb.com/manual/core/transactions/#read-concern-write-concern-read-preference">clearly laid out in the transactions documentation</a>. The question is whether users are closely reading that documentation, versus relying on marketing claims, or assumptions like “using read concern <code>snapshot</code> means reading a committed snapshot”. We might also ask whether users can be expected to remember to apply these settings to every transaction which requires them. After all, MongoDB offers database and collection-level safety settings precisely so users can <em>assume</em> all operations interacting with those databases or collections use those settings; ignoring read and write concern settings when users perform (presumably) safety-critical operations is surprising!</p>
<h2 id="how-acid-is-snapshot-isolation-anyway"> How ACID is Snapshot Isolation, Anyway</h2>
<p>In subsequent tests, we used read concern <code>linearizable</code> and write concern <code>majority</code> for all single-operation reads and writes, and read concern <code>snapshot</code> and write concern <code>majority</code> for multi-operation transactions. In healthy clusters (e.g.&nbsp;without faults), cursory testing appeared consistent with snapshot isolation.</p>
<p>However, we note that while MongoDB’s home page prominently <a href="https://www.mongodb.com/">claims to offer</a> “full ACID transactions”, which one might assume means that transactions are fully atomic, isolated, consistent, and durable. This is not exactly the case: transactions under snapshot isolation are not, as <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">previously noted</a>, fully isolated.</p>
<p>For example, consider <a href="http://jepsen.io.s3.amazonaws.com/analyses/mongodb-4.2.6/20200508T195637.000-0400.zip">this test run</a>, which used read concern <code>snapshot</code>, write concern <code>majority</code>, and did not involve network partitions or other exogenous faults. The resulting history does not appear to violate snapshot isolation, but nonetheless exhibits cyclic transaction dependencies, like the following:</p>

<p>One transaction appends 1 to document 1047, and reads document 1045, finding it empty. The other appends 1 to document 1045, and reads 1047, finding it empty. Lines marked <code>rw</code> denote these read-write <em>anti-dependencies</em>. These transactions cannot possibly be isolated: if the top transaction executed first, in isolation, its write to 1047 would have been visible to the second—and vice-versa. Since these transactions didn’t write to the same documents, they are allowed (under snapshot isolation) to execute concurrently.</p>

<p>Other cycles are more complex. Here, for instance, is a cluster of twelve transactions, again executed under MongoDB’s strongest possible safety settings. Each of these transactions depends (in various ways) on every other. Arrows labeled <code>ww</code> show a write-write dependency, wherein one transaction overwrote another’s write. Those with <code>wr</code> show a write-read dependency: one transaction read another’s write.</p>
<p>Or consider this <a href="http://jepsen.io.s3.amazonaws.com/analyses/mongodb-4.2.6/g2-large.svg">cluster of 123 transactions</a>, all of which appeared to execute before—but also after!—every other. Is this cluster “full ACID”? Perhaps, but if so, we must accept that the “I” in ACID means only <em>partial</em> isolation, or “full” means somewhat less than full.</p>
<p><img src="http://jepsen.io/analyses/mongodb-4.2.6/g2-huge.png"><br>
</p>
<p>These anomalies are not rare. <a href="http://jepsen.io.s3.amazonaws.com/analyses/mongodb-4.2.6/20200508T195637.000-0400.zip">This history</a>, for example, contains roughly 100 transactions per second, and we identified 1461 transactions (out of 13914 total) with cyclic dependencies. Roughly 10% of transactions exhibited anomalies during normal operation, without faults.</p>
<p>It’s important to remember that just because we <em>can</em> detect anomalies in this simple workload doesn’t mean those anomalies <em>matter</em> to users. Concurrency could be low enough that concurrency control is largely unnecessary. Some sets of transactions can be proven to execute serializably under snapshot isolation—e.g., when their write sets intersect. Others exhibit nonserializable anomalies, but don’t violate application-level consistency constraints. Still others <em>do</em> violate constraints, but not frequently enough for users to notice or care. For these purposes, snapshot isolation is good enough!</p>
<h2 id="indeterminate-errors"> Indeterminate Errors</h2>
<p>When we introduced network failures into our tests, we encountered (as one would expect) <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/client.clj#L189-L263">a variety of client errors</a>. The MongoDB <a href="https://docs.mongodb.com/manual/core/transactions/">transaction documentation</a> says:</p>
<blockquote>
<p>When a transaction aborts, all data changes made in the transaction are discarded without ever becoming visible. For example, if any operation in the transaction fails, the transaction aborts and all data changes made in the transaction are discarded without ever becoming visible.<a href="#fn1" id="fnref1"><sup>1</sup></a></p>
</blockquote>
<p>However, the converse is not necessarily true: <a href="https://github.com/jepsen-io/mongodb/blob/83548bb8e054170ecc4b8fda70390e40fcca5e30/src/jepsen/mongodb/client.clj#L227-L239">some transaction error messages</a> seem to indicate a transaction has aborted, but do not. For example, a <code>TransactionCoordinatorSteppingDown</code> exception may actually mean the transaction has committed. Likewise, <code>Command failed with error 6 (HostUnreachable): 'unable to initialize targeter for write op for collection jepsendb.jepsencoll :: caused by :: Connection refused'</code> also appears to denote an indeterminate failure. We repeatedly encountered these errors in our tests, only to find that their writes were visible to later reads.</p>
<p>This is not necessarily a <em>bug</em>—there will always be a class of errors in any distributed system which could indicate either success or failure. However, it <em>is</em> helpful when those errors are clearly marked, or offer textual guidance. Error 6, like most of the errors we encountered, is <a href="https://jira.mongodb.org/browse/DOCS-10757">undocumented</a>; only a few codes <a href="https://docs.mongodb.com/manual/reference/exit-codes/">remain in the official docs</a>, and Google has <a href="https://www.google.com/search?&amp;q=mongodb+%22error+6%22">little to say</a>. Complete error documentation, perhaps with a table of which codes indicate determinate vs indeterminate failures, could offer a pragmatic alternative to error message haruspicy.</p>
<h2 id="duplicate-effects"> Duplicate Effects</h2>
<p>With errors interpreted correctly, we found that network partitions could cause MongoDB to duplicate the effects of transactions. Despite never appending the same value to an array twice, we repeatedly observed arrays with multiple copies of the same element. For example, take <a href="http://jepsen.io.s3.amazonaws.com/analyses/mongodb-4.2.6/20200508T222527.000Z.zip">this test run</a>, which contained the following transaction:</p>

<p>Here, element 6 appeared twice in a read of document 436. This duplication raises the possibility that the transaction which wrote 6 to key 436 occurred both before <em>and</em> after other transactions; depending on which (if any) interpretation one chooses, the resulting history also exhibits G-single and G2 anti-dependency cycles. This anomaly occurred even with read concern <code>snapshot</code> and write concern <code>majority</code>, which suggests that even at the strongest settings, MongoDB transactions do not provide snapshot isolation.</p>
<p>This behavior could point to an improper transaction retry mechanism—MongoDB advertises <a href="https://docs.mongodb.com/manual/core/retryable-writes/">automatic retries</a> as a feature. To identify whether the retry mechanism might be at fault, we attempted to disable it—only to discover that MongoDB transactions <em>ignore</em> the <code>retryWrites</code> setting, and <a href="https://docs.mongodb.com/manual/core/retryable-writes/#retryable-writes-and-multi-document-transactions">retry regardless</a>. We are unsure if users can work around this behavior.</p>
<h2 id="read-skew"> Read Skew</h2>
<p>In <a href="http://jepsen.io.s3.amazonaws.com/analyses/mongodb-4.2.6/20200508T211458.000Z.zip">this case</a>, a test running with read concern <code>snapshot</code> and write concern <code>majority</code> executed a trio of transactions with the following dependency graph:</p>

<p>The topmost transaction appended 2 to document 79, which was followed by the middle transaction’s append of 5. We can infer these writes took place in this order because another transaction (not part of this cycle) observed:</p>

<p>Following these writes, the bottom transaction appended 5 to document 77, which was <em>not</em> observed by the middle transaction’s read of 77. However, that append of 5 <em>was</em> visible to the topmost transaction!</p>
<p>Because this cycle contains exactly one anti-dependency (rw) edge, it’s likely<a href="#fn2" id="fnref2"><sup>2</sup></a> an example of <a href="http://pmg.csail.mit.edu/papers/icde00.pdf">Adya’s G-single anomaly</a>, also known as <em>read skew</em>. In essence, the middle transaction observed some, but not all, effects of logically prior transactions. Read skew is prohibited by snapshot isolation.</p>
<p>Curiously, this anomaly appeared in a history without (observed) duplicate writes. This suggests there could be multiple problems in the MongoDB transaction protocol, but it’s difficult to say for sure.</p>
<h2 id="cyclic-information-flow"> Cyclic Information Flow</h2>
<p>Worse yet, transactions running with the strongest isolation levels can exhibit <a href="http://pmg.csail.mit.edu/papers/adya-phd.pdf">G1c: cyclic information flow</a>. Take <a href="http://jepsen.io.s3.amazonaws.com/analyses/mongodb-4.2.6/20200508T151522.000-0400.zip">this example</a>, in which two transactions (both running at read concern <code>snapshot</code> and write concern <code>majority</code>) observe one another’s effects:</p>

<p>The top transaction appended 3 to document 68, and the bottom transaction’s read of 68 observed that write. However, the bottom transaction also appended 5 to document 95, and the top transaction read that write! These anomalies appear relatively infrequently, but we have collected a dozen-odd examples in a day’s worth of testing.</p>
<h2 id="read-your-future-writes"> Read Your (Future) Writes</h2>
<p>It’s even possible for a single transaction to observe its own future effects. In <a href="http://jepsen.io.s3.amazonaws.com/analyses/mongodb-4.2.6/20200508T215706.000Z.zip">this test run</a>, four transactions, all executed at read concern <code>snapshot</code> and write concern <code>majority</code>, append 1, 2, 3, and 4 to key 586—but the transaction which wrote 1 observed [1 2 3 4] <em>before</em> it appended 1.</p>

<p>This is, of course, impossible: our test submits each transaction’s operations in strict order, and unless MongoDB has built a time machine, it cannot return values which it doesn’t yet know will be written. This suggests that the retrocausal transaction actually ran <em>twice</em>, and on its second run, observed an effect of its own prior execution. This could be another consequence of an inappropriate retry mechanism.</p>

<p>MongoDB 4.2.6 <a href="https://web.archive.org/web/20200510151604/https://www.mongodb.com/">claims to offer</a> “full ACID transactions” via snapshot isolation. However, the use of these transactions is complicated by weak defaults, confusing APIs, and undocumented error codes. Snapshot isolation is questionably compatible with the marketing phrase “full ACID”. Even at the highest levels of read and write concern, MongoDB’s transaction mechanism exhibited various anomalies which violate snapshot isolation.</p>
<p>MongoDB’s default read and write concern for single-document operations remains <code>local</code>, which can observe uncommitted data, and <code>w: 1</code>, which can lose committed writes. Even when users select safer settings in their clients at the database or collection level, transactions ignore these settings and default again to <code>local</code> and <code>w: 1</code>. The <code>snapshot</code> read concern does not actually guarantee snapshot isolation, and must always be used in conjunction with write concern <code>majority</code>. This holds even for transactions which perform no writes.</p>
<p>Default behavior has significant impact: <a href="http://www.vldb.org/pvldb/vol12/p2071-schultz.pdf">MongoDB’s user research suggests</a> roughly 80% of users of their hosted MongoDB service use the default write concern, and 99.6% of users use the default read concern. While it might be the case that many of these users <em>intend</em> to occasionally lose data or observe uncommitted state, it might also be the case that users are simply unaware of this behavior.</p>
<p>Nor can users rely on examples to demonstrate snapshot isolated behavior. MongoDB’s <a href="https://docs.mongodb.com/manual/core/transactions/">transaction documentation</a> and <a href="https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions">tutorial blog posts</a> show only write-only transactions, using read concern <code>local</code> rather than <code>snapshot</code>. Other examples from MongoDB <a href="https://www.mongodb.com/blog/post/java-and-mongodb-40-support-for-multidocument-acid-transactions">don’t specify a read concern</a> or <a href="https://developer.mongodb.com/quickstart/python-acid-transactions">run entirely with defaults</a>. <a href="http://learnmongodbthehardway.com/article/transactions/">Learn MongoDB The Hard Way</a> uses read concern <code>snapshot</code> but write concern <code>local</code>, despite performing writes. Tutorials from <a href="https://dzone.com/articles/mongodb-transactions-your-very-first-transaction-w">DZone</a>, <a href="https://severalnines.com/database-blog/overview-multi-document-acid-transactions-mongodb-and-how-use-them">Several Nines</a>, <a href="https://www.percona.com/blog/2018/06/25/mongodb-transactions-your-very-first-transaction-with-mongodb-4-0/">Percona</a>, <a href="https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html">The Code Barbarian</a>, and <a href="https://spring.io/blog/2018/06/28/hands-on-mongodb-4-0-transactions-with-spring-data">Spring.io</a> all claim that transactions are either ACID or offer snapshot isolation, but none set <em>either</em> read or write concern. There are some examples of MongoDB transactions which <em>are</em> snapshot isolated—for instance, from <a href="https://www.bmc.com/blogs/mongodb-transactions/">BMC</a>, <a href="https://www.plusnconsulting.com/post/Transactions-with-MongoDB-4-0/">+N Consulting</a>, and <a href="https://zgadzaj.com/development/mongodb/mongodb-multi-document-transactions-in-symfony-4-with-doctrine-and-mongodb-odm-bundle">Maciej Zgadzaj</a>, but most uses of MongoDB transactions we found ran—either intentionally or inadvertently—with settings that would (in general) allow write loss and aborted reads.</p>
<p>Snapshot isolation is a reasonably strong consistency model, but claiming that snapshot isolation is “full ACID” is questionable. We routinely observed histories which appeared compatible with snapshot isolation, but also included hundreds of G2 (anti-dependency cycle) anomalies, wherein transactions failed to observe one another’s effects. This is normal and allowed under snapshot isolation, but whether these transactions are fully isolated—in the sense of ACID I—seems debatable.</p>
<p>Finally, even with the strongest levels of read and write concern for both single-document and transactional operations, we observed cases of G-single (read skew), G1c (cyclic information flow), duplicated writes, and a sort of retrocausal internal consistency anomaly: within a single transaction, reads could observe that transaction’s own writes from the future. MongoDB appears to allow transactions to both observe and not observe prior transactions, and to observe one another’s writes. A single write could be applied multiple times, suggesting an error in MongoDB’s automatic retry mechanism. All of these behaviors are incompatible with MongoDB’s claims of snapshot isolation.</p>
<h2 id="recommendations"> Recommendations</h2>
<p>We continue to recommend that users of MongoDB consider their read and write concerns carefully, both for single-document and transactional operations. Settings applied at the database and collection level do not transfer to transactional contexts, even when those database or collection handles are used within the transaction. Instead, users must be careful to set read and write concern on each transaction directly. Moreover, the <code>snapshot</code> read concern does not guarantee snapshot isolation—even for read-only transactions; users must take care to use write concern <code>majority</code> whenever snapshot isolated reads are required. We recommend users perform careful review of safety-critical codepaths to look for potential mistakes.</p>
<p>Given this behavior, and the relative scarcity of users who actually set their read and write concern, we continue to recommend that MongoDB select safer defaults for all operations—but especially for transactions: a feature specifically intended to provide stronger safety guarantees! We also question why it’s even <em>possible</em> for read concern <code>snapshot</code> to return non-snapshot-isolated reads, especially for read-only queries. While these behaviors <em>are</em> clearly documented, we think MongoDB would be better off with more conservative behavior, at least where transactions are concerned.</p>
<p>MongoDB’s claim of “full ACID transactions” which “maintain the same data integrity guarantees you are used to in traditional databases” could be misleading. We recommend that users who are accustomed to serializable behavior evaluate critical transactions carefully, to identify whether running at snapshot isolation could violate application-level constraints. MongoDB may wish to revise their marketing language to use “snapshot isolated” instead of “ACID”.</p>
<p>In theory, transactions running on a snapshot isolated system like MongoDB could be lifted, via static analysis, into transactions which execute serializably <a href="https://www.cse.iitb.ac.in/infolab/Data/Courses/CS632/2009/Papers/p492-fekete.pdf">by materializing selected read conflicts as writes</a>. Some database users perform a similar technique by hand, introducing no-op writes into selected transactions. However, MongoDB <a href="https://www.mongodb.com/blog/post/mongodb-multi-document-acid-transactions-general-availability">may optimize those writes away</a>. MongoDB recommends incrementing a counter to force conflicts where desired.</p>
<p>Our research suggests that users of MongoDB 4.2.6 may experience transactional anomalies during network partitions. We suspect MongoDB may investigate and resolve these issues in future versions, and encourage users to upgrade when appropriate.</p>
<h2 id="future-work"> Future Work</h2>
<p>This report represents a brief investigation relative to most Jepsen reports; we have not investigated pauses, crashes, or clock skew in depth; nor have we introduced membership changes or shard reallocation. Disk and filesystem-related issues could also prove fruitful.</p>
<p>Going forward, we would like to investigate collection-level transactional behavior with respect to predicates, as well as apply Elle to MongoDB’s causal sessions. In addition, we would like to generalize the present tests to those with reads or writes via secondary indices or scans, as well as changing shard keys.</p>
<p><em>This work was performed independently, without compensation, and conducted in accordance with the <a href="https://jepsen.io/ethics.html">Jepsen ethics policy</a>. MongoDB, Fauna, and YugaByte have previously engaged Jepsen for paid analyses. Jepsen wishes to thank C. Scott Andreas, Peter Alvaro, Silvia Botros, Nicole Forsgren, Camille Fournier, Coda Hale, Marc Hedlund, Ben Linsay, Dan McKinley, Kit Patella, Marco Rogers, and James Turnbull for their invaluable feedback. We also wish to thank MongoDB’s Maxime Beugnet for <a href="https://twitter.com/MBeugnet/status/1253622755049734150">inspiration</a>.</em></p>
<section>
<hr>
<ol>
<li id="fn1"><p>This is, of course, only true for read and write concern <code>majority</code> or higher.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>It could also be the case that some or all of these transactions observed garbage data, or values from aborted transactions. Since these anomalies are in a sense “worse” than G-single, we choose the more charitable interpretation here.<a href="#fnref2">↩</a></p></li>
</ol>
</section>
  </div>
</article></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>