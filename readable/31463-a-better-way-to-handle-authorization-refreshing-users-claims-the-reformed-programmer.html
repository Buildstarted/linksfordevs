<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A better way to handle authorization &#x2013; refreshing user&#x2019;s claims &#x2013; The Reformed Programmer -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>A better way to handle authorization – refreshing user’s claims – The Reformed Programmer</h1><div><div><div id="page" class="hfeed site"><a class="skip-link screen-reader-text" href="#content">Skip to content</a><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main" role="main"><article id="post-1771" class="post-1771 post type-post status-publish format-standard has-post-thumbnail hentry category-net-core category-asp-net-core"><div class="entry-content"><p class="entry-top-meta"><span class="entry-top-meta-datetime">Last Updated: August 22, 2019 | Created: July 29, 2019</span></p><p>This article focuses on the ability to update a logged in user’s authorization as soon as any of the authorization classes in the database are changed – I refer to this as “refresh claims” (see “Setting the Scene” !!! for a longer explanation). This article was inspired by a number of people asking for this feature in my alternative feature/data authorization approach originally described in the<a></a><a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-authorization-in-asp-net-core/">first article</a> in this series.</p><p>The <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-authorization-in-asp-net-core/">original article</a> is very popular, with lots of questions and
comments. I therefore came back about six months after the first article to
answer some of the more complex question by creating a new <a href="https://github.com/JonPSmith/PermissionAccessControl2">PermissionAccessControl2</a> example web application and the following three
extra articles: </p><p><strong>UPDATE: See my </strong><a href="https://www.youtube.com/watch?v=q9Ztb1y4Hxw"><strong>NDC
Oslo 2019</strong></a><strong> talk which covers these three articles.</strong></p><p>You can find the original
articles at:</p><p><strong><em>NOTE: You can see the “refresh
claims” feature in action by cloning the </em></strong><a href="https://github.com/JonPSmith/PermissionAccessControl2"><strong><em>PermissionAccessControl2</em></strong></a><strong><em> example web application and then running
the PermissionAccessControl2 project. By default, it is set up to use in-memory
databases seeded with demo data and the “refresh claims” feature. See the
“refresh Claims” menu item.</em></strong></p><h2 id="tldr-summary">TL;DR; – summary <a class="anchorlink dashicons-before" href="#tldr-summary"></a></h2><ul><li>Typically, when you log in to an ASP.NET Core
web app the things you can do, known as <em>authorization</em>,
is “frozen”, i.e. it is fixed for however long you stay logged in.</li><li>An alternative is to update a logged-in user’s
authorization whenever the internal, database versions of the authorization is
updated. I call this “refreshing claims” because authorization data is stored
in a user’s Claims.</li><li>This article describes how I have added this
“refresh claims” feature to my alternative feature/data authorization approach
described in this series.</li><li>While the “refresh claims” code I show applies
to my alternative feature/data authorization code the same approach can be applied
to any standard ASP.NET Core Role or Claim authorization system.</li><li>There are some (small?) downside to adding this
feature around complexity and performance, which I cover near the end of this
article.</li><li>The code in this article can be found in the
open-source <a href="https://github.com/JonPSmith/PermissionAccessControl2">PermissionAccessControl2</a>
GitHub repo, which also includes a runnable example web application.</li></ul><h2 id="setting-the-scene-why-refresh-the-users-claims">Setting the scene – why refresh the user’s claims?<a class="anchorlink dashicons-before" href="#setting-the-scene-why-refresh-the-users-claims"></a></h2><p>If you are using the built-in ASP.NET Core’s Identity
system, then when you log in you get a set of Role and Claims which defined
what you can do – known as <em>authorisation</em>
in ASP.NET. By default, once you are logged in your authorisation is fixed for
however long you stay logged in. This means that any changed the internal authorisation
setting, then you need to log out and log back in again before you inherit
these new settings. Most systems work this way because it’s simple and covers
most of the authentication/authorization requirements of standard web apps.</p><p>But there are situations where you need any change to authorization
to be immediately applied to the user – what I call “refreshing claims”. For
instance, in a high-security system like a bank you might want to be able
revoke certain authentication features immediately from a logged-in user/users.
Another use case would be where users can trial a paid-for feature, but once
the trial period you want the feature to turn off immediately.</p><p>So, if you need refresh feature then how can you implement it?
One approach would be to recalculate the user’s authorisation settings every
time they access the system – that would work but would add a performance hit
due to all the extra database accesses and recalculations required on every
HTTP request. Another approach would be to revoke/time-out the authentication
token or cookie and have the system recalculate the authentication token or
cookie again.</p><p>In the next section I describe how I added the “refresh
claims” to my feature authentication approach. </p><h2 id="the-architecture-of-my-refresh-claims-feature">The architecture of my “refresh claims” feature<a class="anchorlink dashicons-before" href="#the-architecture-of-my-refresh-claims-feature"></a></h2><p>In the earlier articles I described a replacement
authorization system which had the advantage over the ASP.NET Core’s
Roles-based authorisation in that the Admin user can change all aspects of the
user’s authorisation (with ASP.NET Core’s Roles-based authorisation you need to
edit/redeploy the code to alter what controller methods a Role can access).</p><p>The figure below shows an abbreviated version of how the
feature part of authorisation process which is run on login (see <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/">the
Part3 article</a> for a more in-depth explanation).</p><figure class="wp-block-image"><img src="https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/SplitAuthenticationFromAuthorization-1024x349.png" alt="" class="wp-image-1773" srcset="https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/SplitAuthenticationFromAuthorization-1024x349.png 1024w, https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/SplitAuthenticationFromAuthorization-300x102.png 300w, https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/SplitAuthenticationFromAuthorization-768x261.png 768w, https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/SplitAuthenticationFromAuthorization.png 1087w" sizes="(max-width: 1024px) 100vw, 1024px"></figure><p>But to implement the “refresh claims” feature I need a way
to alter the permissions while the user is logged in. My solution is to use an
authorization cookie event that happens every HTTP request. This allows me to
change the user’s authorisations at any time.</p><p>To make this work I set a “LastUpdated” time when any of the
database classes that manages authorization are changed. This is then compared
with the “LastUpdated” claim in the user’s Claims – see the diagram below which
shows this process. Parts in <strong>blue bold text</strong> show what changes over time.</p><figure class="wp-block-image"><img src="https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/RefreashUsersClaimsOverview-1024x416.png" alt="" class="wp-image-1791" srcset="https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/RefreashUsersClaimsOverview-1024x416.png 1024w, https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/RefreashUsersClaimsOverview-300x122.png 300w, https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/RefreashUsersClaimsOverview-768x312.png 768w, https://www.thereformedprogrammer.net/wp-content/uploads/2019/07/RefreashUsersClaimsOverview.png 1093w" sizes="(max-width: 1024px) 100vw, 1024px"></figure><p>I’m going to describe the stages involved in this in the
following order</p><ol><li>How to detect that the Roles/Permissions have changed.</li><li>How to store the last time the Roles/Permissions changed.</li><li>Linking the authorization code to the database cache.</li><li>How to detect/update the user’s permissions Claim.</li><li>How to tell your front-end that the Permissions have changed.</li></ol><h3 id="1-how-to-detect-that-the-roles-permissions-have-changed">1. How to detect that the Roles/Permissions have changed.<a class="anchorlink dashicons-before" href="#1-how-to-detect-that-the-roles-permissions-have-changed"></a></h3><p>A user’s Permissions could be out of date whenever the User
Roles, the Role’s Permissions, or the User Modules are changed. To do this I
add some detection code to the SaveChanges/ SaveChangesAsync methods in
DbContext that manages those database classes, called ExtraAuthorizeDbContext. </p><p><strong><em>NOTE: Putting the detection code inside the SaveChanges and
SaveChangesAsync methods provides a robust solution because it doesn’t rely on
the developer to adding code to all the services that changes the authorization
database classes. </em></strong></p><p>Here is the code in the SaveChanges method</p><pre class="brush: csharp; title: ; notranslate" title="">// I only have to override these two versions of SaveChanges,
// as the other two SaveChanges versions call these 
public override int SaveChanges(bool acceptAllChangesOnSuccess)
{ 

    if (ChangeTracker.Entries().Any(x =&gt; 
        (x.Entity is IChangeEffectsUser &amp;&amp; x.State == EntityState.Modified) || 
              (x.Entity is IAddRemoveEffectsUser &amp;&amp; 
                    (x.State == EntityState.Added || 
                     x.State == EntityState.Deleted)))
    {
        _authChange.AddOrUpdate(this);
    }
    return base.SaveChanges(acceptAllChangesOnSuccess);
}
</pre><p>The things to note are:</p><ul><li>Lines 6 to 9 This is looking for changes that
could affect an existing user. </li><li>Line 11: If a change is found it calls the AddOrUpdate
method in the IAuthChange instance that is injected into the ExtraAuthorizeDbContext.
I describe the AuthChange class in section 3.</li></ul><h3 id="2-how-to-store-the-last-time-the-roles-permissions-changed">2. How to store the last time the Roles/Permissions changed.<a class="anchorlink dashicons-before" href="#2-how-to-store-the-last-time-the-roles-permissions-changed"></a></h3><p>Once the SaveChanges have detected a change we need to store
the time that change happens. This is done via a class called TimeStore which
is shown below. </p><pre class="brush: csharp; title: ; notranslate" title="">public class TimeStore
{
    [Key]
    [Required]
    [MaxLength(AuthChangesConsts.CacheKeyMaxSize)]
    public string Key { get; set; }

    public long LastUpdatedTicks { get; set; }
}
</pre><p>This is a Key/Value cache, where the Value is a long (Int64)
containing the time as ticks when the item was changes. I did this way because
I would use this same store to contain changes in any my hierarchical DataKeys
(see <a href="https://www.thereformedprogrammer.net/part-4-building-a-robust-and-secure-data-authorization-with-ef-core/">Part4
article</a>), which I don’t cover in this article. </p><p><strong><em>NOTE: In the <a href="https://www.thereformedprogrammer.net/part-4-building-a-robust-and-secure-data-authorization-with-ef-core/">Part4
article</a> I describe a multi-tenant system which is hierarchical. In that
case if I move a SubGroup (e.g. West Coast division) to a different parent,
then the DataKey would change, along with all its “child” data. In this case
you MUST refresh any logged-in user’s DataKey otherwise a logged-in user would
have access to the wrong data. That is why I used a generalized TimeStore so
that I could add a per-company “LastUpdated” value.</em></strong></p><p>I also add a the ITimeStore interface
ExtraAuthorizationDbContext which the AuthChanges class (see next section) can
use. The ITimeStore defines two methods:</p><ol><li>GetValueFromStore, which reads a value from the
TimeStore</li><li>AddUpdateValue, which adds or update the
TimeStore</li></ol><p>You will see these being used in the next section.</p><h3 id="3-linking-the-authorization-code-to-the-database-cache">3. Linking the authorization code to the database cache.<a class="anchorlink dashicons-before" href="#3-linking-the-authorization-code-to-the-database-cache"></a></h3><p>I created a small project called CommonCache which lives at
the bottom of the solution structure, i.e. it doesn’t reference to any other
project. This contains AuthChange class, which links between the database and
the code handling the authorization. </p><p>This AuthChange class provides a method that the
authorization code can call to check if the user’s authorization Claims are out
of date. And at the database end it creates the correct cache key/value when
the database detects a change in the authorization database classes.</p><p>Here is the AuthChange class code.</p><pre class="brush: csharp; title: ; notranslate" title="">public class AuthChanges : IAuthChanges
{
    public bool IsOutOfDateOrMissing(string cacheKey, 
        string ticksToCompareString, ITimeStore timeStore)
    {
        if (ticksToCompareString == null)
            //if there is no time claim then you do need to reset the claims
            return true;

        var ticksToCompare = long.Parse(ticksToCompareString);
        return IsOutOfDate(cacheKey, ticksToCompare, timeStore);
    }

    private bool IsOutOfDate(string cacheKey, 
        long ticksToCompare, ITimeStore timeStore)
    {
        var cachedTicks = timeStore.GetValueFromStore(cacheKey);
        if (cachedTicks == null)
            throw new ApplicationException(
                $"You must seed the database with a cache value for the key {cacheKey}.");

        return ticksToCompare &lt; cachedTicks;
    }

    public void AddOrUpdate(ITimeStore timeStore)
    {
        timeStore.AddUpdateValue(AuthChangesConsts.FeatureCacheKey, 
             DateTime.UtcNow.Ticks);
    }
}
</pre><p>The things to note are:</p><ul><li>Lines 3 to 12: The IsOutOfDateOrMissing method
is called by the ValidateAsync method (described in the next section) uses to
find out if the User’s claims need recalculating, i.e. it returns true if the
User’s claims “LastUpdated” is missing, or it is earlier then the database “LastUpdated”
time. You can see the cache read in line 17 inside the private method that does
the time compare.</li><li>Lines 25 to 29: The AddOrUpdate method makes
sure the ITimeStore has an entry under the key defined by FeatureCacheKey which
has the current time in ticks. This is referred to as the database “LastUpdated”
value.</li></ul><h3 id="3-how-to-detect-update-the-users-permissions-claim">3. How to detect/update the user’s permissions Claim<a class="anchorlink dashicons-before" href="#3-how-to-detect-update-the-users-permissions-claim"></a></h3><p>In the <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-authorization-in-asp-net-core/#how-do-i-turn-the-roles-into-a-permissions-claim">Part1
article I showed how you can add claims to the user</a> at login time via the
Authentication Cookie’s OnValidatePrincipal event, but these claims are “frozen”.
However, this event is perfect for our “refresh claims” feature because the
event happens on every HTTP request. So, in the new version 2 <a href="https://github.com/JonPSmith/PermissionAccessControl2">PermissionAccessControl2</a>
code I have altered the code to add the “refresh claims” feature. Below is the
new version of the ValidateAsync method, with comments on the key parts of the code
at the bottom.</p><pre class="brush: csharp; title: ; notranslate" title="">public async Task ValidateAsync(CookieValidatePrincipalContext context)
{
    var extraContext = new ExtraAuthorizeDbContext(
        _extraAuthContextOptions, _authChanges);
    //now we set up the lazy values - I used Lazy for performance reasons
    var rtoPLazy = new Lazy&lt;CalcAllowedPermissions&gt;(() =&gt; 
        new CalcAllowedPermissions(extraContext));
    var dataKeyLazy = new Lazy&lt;CalcDataKey&gt;(() =&gt; 
        new CalcDataKey(extraContext));

    var newClaims = new List&lt;Claim&gt;();
    var originalClaims = context.Principal.Claims.ToList();
    if (originalClaims.All(x =&gt; 
        x.Type != PermissionConstants.PackedPermissionClaimType) ||
        _authChanges.IsOutOfDateOrMissing(AuthChangesConsts.FeatureCacheKey, 
            originalClaims.SingleOrDefault(x =&gt; 
                 x.Type == PermissionConstants.LastPermissionsUpdatedClaimType)?.Value,
            extraContext))
    {
        var userId = originalClaims.SingleOrDefault(x =&gt; 
             x.Type == ClaimTypes.NameIdentifier)?.Value;
        newClaims.AddRange(await BuildFeatureClaimsAsync(userId, rtoPLazy.Value));
    }

    //… removed DataKey code as not relevant to this article

    if (newClaims.Any())
    {
        newClaims.AddRange(RemoveUpdatedClaimsFromOriginalClaims(
              originalClaims, newClaims));
        var identity = new ClaimsIdentity(newClaims, "Cookie");
        var newPrincipal = new ClaimsPrincipal(identity);
        context.ReplacePrincipal(newPrincipal);
        context.ShouldRenew = true;             
    }
    extraContext.Dispose(); //be tidy and dispose the context.
}

private IEnumerable&lt;Claim&gt; RemoveUpdatedClaimsFromOriginalClaims(
    List&lt;Claim&gt; originalClaims, List&lt;Claim&gt; newClaims)
{
    var newClaimTypes = newClaims.Select(x =&gt; x.Type);
    return originalClaims.Where(x =&gt; !newClaimTypes.Contains(x.Type));
}

private async Task&lt;List&lt;Claim&gt;&gt; BuildFeatureClaimsAsync(
    string userId, CalcAllowedPermissions rtoP)
{
    var claims = new List&lt;Claim&gt;
    {
        new Claim(PermissionConstants.PackedPermissionClaimType, 
             await rtoP.CalcPermissionsForUserAsync(userId)),
        new Claim(PermissionConstants.LastPermissionsUpdatedClaimType,
             DateTime.UtcNow.Ticks.ToString())
    };
    return claims;
}
</pre><p>The things to note are:</p><ul><li>Lines 13 to 18: This checks if the
PackedPermissionClaimType Claim is missing, or that the LastPermissionsUpdatedClaimType
Claim’s value is either out of date or missing. If either of these are true
then it has to recalculate the user’s Permissions, which you can see in lines 19
to 23.</li><li>Lines 46 to 57: This adds the two claims needed:
the PackedPermissionClaimType Claim with the user’s recalculated Permissions,
and the LastPermissionsUpdatedClaimType Claim which is given the current time.</li></ul><h3 id="5-how-to-tell-your-front-end-that-the-permissions-have-changed">5. How to tell your front-end that the Permissions have changed<a class="anchorlink dashicons-before" href="#5-how-to-tell-your-front-end-that-the-permissions-have-changed"></a></h3><p>If you are using some form of front-end framework, like
React.js, Angular.js, Vue.js etc. then you will use the Permissions in the front-end
to select what buttons, links etc to show. In the Part3 article I showed a <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/#2-working-with-a-javascript-front-end-framework">very
simple API to get the Permissions names</a>, but now we need to know when to
update the local Permissions in your front end. </p><p>My solution is to add a header to every HTTP return that
gives you the “LastUpdated” time when the current user’s Permissions where updated.
By saving this value in the JavaScript <a href="https://www.w3schools.com/jsref/prop_win_sessionstorage.asp">SessionStorage</a>
you can compare the time provided in the header with the last value you had – if
they are different then you need to re-read the permissions for the current
user.</p><p>Its pretty easy to add a header, and here is the code inside
the Configure method inside the Startup class in your ASP.NET Core project.
Here is the code (with thanks to SO answer <a href="https://stackoverflow.com/a/48610119/1434764">https://stackoverflow.com/a/48610119/1434764</a>).</p><pre class="brush: csharp; title: ; notranslate" title="">//This should come AFTER the app.UseAuthentication() call
if (Configuration["DemoSetup:UpdateCookieOnChange"] == "True")
{
    app.Use((context, next) =&gt;
    {
        var lastTimeUserPermissionsSet = context.User.Claims
            .SingleOrDefault(x =&gt; 
                 x.Type == PermissionConstants.LastPermissionsUpdatedClaimType)
            ?.Value;
        if (lastTimeUserPermissionsSet != null)
            context.Response.Headers["Last-Time-Users-Permissions-Updated"] 
                 = lastTimeUserPermissionsSet;
        return next.Invoke();
    });
}
</pre><p>While the “refresh claims” feature is useful it does have
some downsides. Firstly it is a lot more complex than using the <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/#a-simpler-way-to-add-to-the-users-claims">UserClaimsPrincipalFactory
approach explained in the Part3 article</a>. Complexity makes the application
harder to understand and can be harder to refactor.</p><p>Also, I only got the “refresh claims” feature to work for
Cookie authentication, while the “frozen” implementation I showed in the Part3
article works with both Cookie or Token authentication. If you need a token
solution then a good starting point is the <a href="https://www.blinkingcaret.com/">https://www.blinkingcaret.com/</a> blog (you
might find this article useful “<a href="https://www.blinkingcaret.com/2018/05/30/refresh-tokens-in-asp-net-core-web-api/">Refresh
Tokens in ASP.NET Core Web Api”</a>).</p><p>The other issue is performance. For every HTTP request a
read of the TimeStore is required. Now that request is very small and only take
about 750ns on my I7, 4GHz Windows development PC, but with lots of
simultaneous users you would be loading up the database. But the good news is
that using a database means it automatically works with multiple instances of a
web application (known as <a href="https://azure.microsoft.com/en-gb/resources/videos/scale-a-web-app-using-azure-scale-out/">scale-out</a>).</p><p><strong><em>NOTE: I did try adding an <a href="https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed?view=aspnetcore-2.2#distributed-memory-cache">ASP.NET
Core Distributed Memory Cache</a> to improve local performance, but because the
OnValidatePrincipal event lives outside the dependency injection you end up
with difference instances of the memory cache (took me a while to work that
out!). You could add a cache like Redis because it relies on configuration
rather than the same instance, but it does add another level of complexity.</em></strong></p><p>The other performance issue is it has to refresh EVERY
logged in user, as it doesn’t have enough information to target the specific
users that need an update. If you have thousands of concurrent users that will
bring a higher-than-normal load on the application and the database. Overall
recalculating the Permissions aren’t that onerous, but it may be worth changing
any roles and permissions outside the site’s peak usage times.</p><p>Overall, I would suggest you think hard as to whether you
need the “refresh claims” feature. Most authentication systems don’t have “refresh
claims” feature as standard, so remember the <a href="https://www.martinfowler.com/bliki/Yagni.html">Yagni</a> (“You
Aren’t Gonna Need It”) rule.</p><h2 id="conclusion">Conclusion<a class="anchorlink dashicons-before" href="#conclusion"></a></h2><p>This article has focused on one specific feature that
readers of my first article felt was needed. I believe my solution to the “refresh
claims” feature is robust, but there are some (small?) downsides which I have
listed. You can find all the code in this article, and a runnable example
application, in the GitHub repo <a href="https://github.com/JonPSmith/PermissionAccessControl2">PermissionAccessControl2</a>.</p><p>When I first developed the whole feature/data authorization
approach for one of my clients we discussed whether we needed the “refresh
claims” feature. They decided it wasn’t worth the effort and I think that was
right decision for their application. </p><p>But if your application/users need the refresh claims
feature then you now have a fully worked out approach which will still work
even on web apps that scale out, i.e. run multiple instances of the web app to
give better scalability.</p><p>Happy coding!</p><p>PS. Have a look at Andrew Lock’s excellent series “<a href="https://andrewlock.net/series/adding-feature-flags-to-an-asp-net-core-app/">Adding
feature flags to an ASP.NET Core app</a>” for another useful feature to add to
your web app.</p><p><strong>If you have a
ASP.NET Core or Entity Framework Core problem that you want help on then I am
available as a freelance contractor. Please send me a contact request via my </strong><a href="https://www.thereformedprogrammer.net/contact/"><strong>Contact</strong></a><strong> page and we can talk some more on
Skype.</strong></p></div></article></main></div></div></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>