<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Empty try with finally | tabs &#x21B9; over &#x2423; &#x2423; &#x2423; spaces by Ji&#x159;&#xED; {x2} &#x10C;in&#x10D;ura -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Empty try with finally | tabs ↹ over ␣ ␣ ␣ spaces by Jiří {x2} Činčura</h1><div><div id="" class=""><h3>Empty try with finally <a href="/id/233786" rel="bookmark nofollow" title="Permalink"><span class="fa fa-link" aria-label="Permalink"></span></a></h3><p class="meta"><span class="fa fa-calendar" aria-label="Published"></span> 10 Jun 2019
	<span class="divider"></span><span class="fa fa-tags" aria-label="Tags"></span> .NET, .NET Core, C#
</p><p>The <code>finally</code> block has a little unknown feature, that frankly isn’t even remotely needed for regular day-to-day development, but you already know content on this blog is usually little geeky.</p><p>The <code>finally</code> block is guaranteed to run completely. In other words, it cannot be interrupted using regular outside code (you can still interrupt it yourself). This is important, because there’s a little nasty exception named <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.threadabortexception?view=netcore-3.0"><code>ThreadAbortException</code></a>. This can erupt basically anywhere anytime. But for some very reliable pieces of code, like synchronization primitives, this isn’t what you want to hear.</p><p>Related to this are also <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/constrained-execution-regions"><em>constrained execution regions</em></a> or <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.constrainedexecution.criticalfinalizerobject?view=netcore-3.0"><code>CriticalFinalizerObject</code></a>. Moreover, .NET Core doesn’t support <code>Thread.Abort</code> anymore (and JIT is smart <a href="https://github.com/dotnet/coreclr/pull/8949">about it</a>).</p><p>Putting these two together, this is solvable. And it’s nicely visible in i.e. CoreCLR or CoreFX. To find these instances I wrote a small tool using Roslyn. It’s basically going through all the files and checking for empty <code>try</code> block with non-empty <code>finally</code> block. Here’s the skeleton of the code.</p><pre><code class="language-csharp">var unit = SyntaxFactory.ParseCompilationUnit(File.ReadAllText(file), options: parseOptions);
foreach (var node in unit.DescendantNodes().Where(n =&gt; n.IsKind(SyntaxKind.FinallyClause)))
{
	var finallySyntax = node as FinallyClauseSyntax;
	var trySyntax = finallySyntax.Parent as TryStatementSyntax;
	if (!trySyntax.Block.Statements.Any() &amp;&amp; finallySyntax.Block.Statements.Any())
	{
		// bingo
	}
}
</code></pre><h4>CoreCLR</h4><p>So, what we can find? In CoreCLR (tests excluded) there’s only few instances in <code>System.Private.CoreLib</code>.</p><p>In <a href="https://github.com/dotnet/coreclr/blob/ac70d9bb/src/System.Private.CoreLib/shared/System/Threading/Tasks/ProducerConsumerQueues.cs#L185"><code>ProducerConsumerQueues.cs</code></a> and <a href="https://github.com/dotnet/coreclr/blob/ac70d9bb/src/System.Private.CoreLib/shared/System/Threading/SemaphoreSlim.cs#L351"><code>SemaphoreSlim.cs</code></a> it’s “regular” stuff to ensure the data structures are not corrupted. In <a href="https://github.com/dotnet/coreclr/blob/ac70d9bb/src/System.Private.CoreLib/shared/System/Threading/ThreadLocal.cs#L128"><code>ThreadLocal.cs</code></a>, it’s not about data structures per se, but just about making sure the IDs are not leaking aka lost. Finally, the <a href="https://github.com/dotnet/coreclr/blob/ac70d9bb/src/System.Private.CoreLib/src/System/Exception.CoreCLR.cs#L313"><code>Exception.CoreCLR.cs</code></a>, which I think is most interesting. The comment explains it all.</p><blockquote><p>Take a lock to ensure only one thread can restore the details
at a time against this exception object that could have
multiple ExceptionDispatchInfo instances associated with it.</p><p>We do this inside a finally clause to ensure ThreadAbort cannot
be injected while we have taken the lock. This is to prevent
unrelated exception restorations from getting blocked due to TAE.</p></blockquote><h4>CoreFX</h4><p>In CoreFX I decided to skip <code>System.Data.OleDb</code>, <code>System.Data.Odbc</code>, <code>System.Data.SqlClient</code> and tests, because I’m interested more in low-level pieces. And as you’d expect there’s bit more occurrences. Here’s the complete list and I’ll just focus on few interesting below it.</p><p>First (ab)use of <code>finally</code> that caught my eye is in <a href="https://github.com/dotnet/corefx/blob/a1940826/src/System.Diagnostics.PerformanceCounter/src/System/Diagnostics/SharedPerformanceCounter.cs#L535"><code>SharedPerformanceCounter.cs</code></a>, because I don’t usually think about shared state across processes. Another interesting is in <a href="https://github.com/dotnet/corefx/blob/a1940826/src/System.IO.FileSystem.Watcher/src/System/IO/FileSystemWatcher.Linux.cs#L40"><code>FileSystemWatcher.Linux.cs</code></a>, talking about the tradeoffs done to make the <code>FileSystemWatcher</code> on Linux	 work.</p><p>Not exactly usage of <code>finally</code> block, but interesting nonetheless is object I found while looking at <a href="https://github.com/dotnet/corefx/blob/a1940826/src/System.Reflection.Metadata/src/System/Reflection/Internal/Utilities/PinnedObject.cs"><code>PinnedObject.cs</code></a> named <a href="https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/src/System/Reflection/Internal/Utilities/CriticalDisposableObject.cs"><code>CriticalDisposableObject.cs</code></a> (it’s not public). It derives from well known (public) <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.constrainedexecution.criticalfinalizerobject?view=netcore-3.0"><code>CriticalFinalizerObject</code></a> and provides a simple template. The <code>Release</code> method reminds me all of the different ways that were used decade or more ago for “disposing” – <code>Release</code>, <code>Dispose</code>, <code>Close</code>, <code>Free</code>, etc. methods, some of them still in place today (yes, I’m looking at you <code>Stream</code> class).</p><h4>Closing</h4><p>It’s always nice to read other – preferably smarter – people’s code. And that’s what this was all about, with a small focus on specific shape of code to maybe discover something thought-provoking.</p></div><div id="" class=""><p class="bio"><a href="/about"><img src="/assets/bio_image.png" alt="Profile Picture"></a>
		Jiří Činčura is an independent developer focusing on data and business layers, language constructs, parallelism and databases. Specifically Entity Framework, asynchronous and parallel programming, cloud and Azure. He's Microsoft Most Valuable Professional and you can read his articles, guides, tips and tricks at www.tabsoverspaces.com.
	</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>