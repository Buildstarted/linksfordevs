<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How to register a service with multiple interfaces in ASP.NET Core DI -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>How to register a service with multiple interfaces in ASP.NET Core DI</h1><div><div class="post-content"><p>In this post I describe how to register a concrete class with multiple public interfaces in the <em>Microsoft.Extensions.DependencyInjection</em> container used in ASP.NET Core. With this approach you'll be able to retrieve the concrete class using any of the interfaces it implements. For example, if you have the following class:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">MyTestClass</span><span class="token punctuation">:</span><span class="token class-name">ISomeInterface</span><span class="token punctuation">,</span> ISomethingElse <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>then you'll be able to inject either <code>ISomeInterface</code> or <code>ISomethingElse</code> and you will receive the same <code>MyTestClass</code> instance. </p><p>Its important that you register the <code>MyTestClass</code> in a specific way to avoid unexpected lifetime issues, such as having two instances of a singleton!</p><p>In this post I give a brief overview of the DI container in ASP.NET Core and some of its limitations compared to third party containers. I'll then describe the concept of "forwarding" requests for multiple interfaces to a concrete type, and how you can achieve this with the ASP.NET Core DI container.</p><blockquote><p><strong>TL;DR</strong> The ASP.NET Core DI container doesn't natively support registering an implementation as multiple services (sometimes called "forwarding"). Instead, you have to manually delegate resolution of the service to a factory function, e.g <code>services.AddSingleton&lt;IFoo&gt;(x=&gt; x.GetRequiredService&lt;Foo&gt;())</code></p></blockquote><h2 id="dependency-injection-in-asp-net-core" class="heading-with-anchor">Dependency Injection in ASP.NET Core<a href="#dependency-injection-in-asp-net-core"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>One of the key features of ASP.NET Core is its use of dependency injection (DI). The framework is designed around a "conforming container" abstraction that allows the framework itself to use a simple container, while also allowing you to plug in more feature-rich third-party containers. </p><blockquote><p>The "conforming container" idea is not without controversy - I suggest reading <a href="http://blog.ploeh.dk/2014/05/19/conforming-container/">this post by Mark Seemann</a> about conforming containers as an anti pattern, or <a href="https://simpleinjector.org/blog/2016/06/whats-wrong-with-the-asp-net-core-di-abstraction/">this from the the SimpleInjector team</a> about the ASP.NET Core DI container specifically.</p></blockquote><p>To make the conforming container as simple as possible for third-party containers to implement, it exposes a very limited number of APIs. For a given service (e.g. <code>IFoo</code>), you can define the concrete class that implements it (e.g. <code>Foo</code>), and the lifetime it should have (e.g. <code>Singleton</code>). There are variations on this where you can directly provide an instance of the service, or you can provide a factory method, but that's about as complex as you can get.</p><p>In contrast, third-party DI containers in .NET often provide more advanced registration APIs. For example, many DI containers <a href="https://autofaccn.readthedocs.io/en/latest/register/scanning.html">expose a "scan" API</a> for configuration, in which you can search through all types in an assembly, and add them to your DI container. The following is an Autofac example:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">var</span> dataAccess <span class="token operator">=</span> Assembly<span class="token punctuation">.</span><span class="token function">GetExecutingAssembly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

builder<span class="token punctuation">.</span><span class="token function">RegisterAssemblyTypes</span><span class="token punctuation">(</span>dataAccess<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>t <span class="token operator">=</span><span class="token operator">&gt;</span> t<span class="token punctuation">.</span>Name<span class="token punctuation">.</span><span class="token function">EndsWith</span><span class="token punctuation">(</span><span class="token string">"Repository"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AsImplementedInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SingleInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>In this example, Autofac will find all concrete classes in the assembly who's name ends with <code>"Repository"</code>, and register them in the container against any public interfaces they implement. So for example, given the following classes and interfaces:</p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">interface</span><span class="token class-name">IStubRepository</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">interface</span><span class="token class-name">ICachingRepository</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">StubRepository</span><span class="token punctuation">:</span><span class="token class-name">IStubRepository</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">MyRepository</span><span class="token punctuation">:</span><span class="token class-name">ICachingRepository</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>The previous Autofac code is equivalent to manually registering both classes with their respective interfaces in the ASP.NET Core container in <code>Startup.ConfigureServices</code>:</p><pre class="language-csharp"><code class="language-csharp">services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token punctuation">&lt;</span><span class="token class-name">IStubRepository</span><span class="token punctuation">,</span><span class="token class-name">StubRepository</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token punctuation">&lt;</span><span class="token class-name">ICachingRepository</span><span class="token punctuation">,</span><span class="token class-name">MyRepository</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>But what happens if a class implements <em>multiple</em> interfaces?</p><h2 id="registering-a-single-implementation-as-multiple-services" class="heading-with-anchor">Registering a single implementation as multiple services<a href="#registering-a-single-implementation-as-multiple-services"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>It's pretty common to see classes that implement multiple interfaces, for example: </p><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">public</span><span class="token keyword">interface</span><span class="token class-name">IBar</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">interface</span><span class="token class-name">IFoo</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span><span class="token keyword">class</span><span class="token class-name">Foo</span><span class="token punctuation">:</span><span class="token class-name">IFoo</span><span class="token punctuation">,</span> IBar <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>Lets write a quick test to see what happens if we register the class against both interfaces using the ASP.NET Core DI container: </p><pre class="language-csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token class-name">Fact</span><span class="token punctuation">]</span><span class="token keyword">public</span><span class="token keyword">void</span><span class="token function">WhenRegisteredAsSeparateSingleton_InstancesAreNotTheSame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> services <span class="token operator">=</span><span class="token keyword">new</span><span class="token class-name">ServiceCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token punctuation">&lt;</span><span class="token class-name">IFoo</span><span class="token punctuation">,</span><span class="token class-name">Foo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token punctuation">&lt;</span><span class="token class-name">IBar</span><span class="token punctuation">,</span><span class="token class-name">Foo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> provider <span class="token operator">=</span> services<span class="token punctuation">.</span><span class="token function">BuildServiceProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo1 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetService</span><span class="token punctuation">&lt;</span><span class="token class-name">IFoo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo2 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetService</span><span class="token punctuation">&lt;</span><span class="token class-name">IBar</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Assert<span class="token punctuation">.</span><span class="token function">Same</span><span class="token punctuation">(</span>foo1<span class="token punctuation">,</span> foo2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>We registered <code>Foo</code> as a singleton for both <code>IFoo</code> and <code>IBar</code>, but the result might not be what you expect. We actually have <em>two</em> instances of our <code>Foo</code> "Singleton", one for each service it was registered as. </p><h2 id="forwarding-requests-for-a-service" class="heading-with-anchor">Forwarding requests for a service<a href="#forwarding-requests-for-a-service"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>The general pattern of having an implementation registered against multiple services is a common one. Most third-party DI containers have this concept built in. For example: </p><ul><li><a href="https://autofac.org/">Autofac</a> uses this behaviour by default - the previous test would have passed</li><li><a href="http://www.castleproject.org/projects/windsor/">Windsor</a> has the concept of "forwarded types" which allows you to "forward" multiple services to a single implementation</li><li><a href="https://structuremap.github.io/">StructureMap</a> (<a href="https://jeremydmiller.com/2018/01/29/sunsetting-structuremap/">now sunsetted</a>) had a similar concept of "forwarded" types. As far as I can tell, it's successor, <a href="https://jasperfx.github.io/lamar/">Lamar</a>, doesn't yet, but I could be wrong on that one.</li></ul><p>Given this requirement is quite common, it might seem odd that it's not possible with the ASP.NET Core DI container. The <a href="https://github.com/aspnet/DependencyInjection/issues/360">issue was raised (by David Fowler)</a> over 2 years ago, but it was closed. Luckily there's a couple of conceptually simple, if somewhat inelegant, solutions.</p><h3 id="1-provide-an-instance-of-the-service-singleton-only-" class="heading-with-anchor">1. Provide an instance of the service (Singleton only)<a href="#1-provide-an-instance-of-the-service-singleton-only-"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h3><p>The simplest approach is to provide an instance of <code>Foo</code> when you're registering your services. Each registered service will return the exact instance you provided when requested, ensuring there is only ever a single instance.</p><pre class="language-csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token class-name">Fact</span><span class="token punctuation">]</span><span class="token keyword">public</span><span class="token keyword">void</span><span class="token function">WhenRegisteredAsInstance_InstancesAreTheSame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> foo <span class="token operator">=</span><span class="token keyword">new</span><span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> services <span class="token operator">=</span><span class="token keyword">new</span><span class="token class-name">ServiceCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token punctuation">&lt;</span><span class="token class-name">IFoo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token punctuation">&lt;</span><span class="token class-name">IBar</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> provider <span class="token operator">=</span> services<span class="token punctuation">.</span><span class="token function">BuildServiceProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo1 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetService</span><span class="token punctuation">&lt;</span><span class="token class-name">IFoo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo2 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetService</span><span class="token punctuation">&lt;</span><span class="token class-name">IBar</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Assert<span class="token punctuation">.</span><span class="token function">Same</span><span class="token punctuation">(</span>foo1<span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Assert<span class="token punctuation">.</span><span class="token function">Same</span><span class="token punctuation">(</span>foo2<span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>There's one big caveat with this - you have to be able to instantiate <code>Foo</code> at configuration time, and you have to know and provide all of it's dependencies. This may work for you in some cases, but it's not very flexible.</p><p>Additionally, you can only use this approach for registering Singletons. If you want <code>Foo</code> to be a single instance per-request-scope (Scoped), then you're out of luck. Instead, you'll need to use the following technique.</p><h3 id="2-implement-forwarding-using-factory-methods" class="heading-with-anchor">2. Implement forwarding using factory methods<a href="#2-implement-forwarding-using-factory-methods"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h3><p>If we break down our requirements, then an alternative solution pops out: </p><ul><li>We want our registered service (<code>Foo</code>) to have a specific lifetime (e.g. Singleton or Scoped)</li><li>When <code>IFoo</code> is requested, return the instance of <code>Foo</code></li><li>When <code>IBar</code> is requested, also return the instance of <code>Foo</code></li></ul><p>From those three rules, we can write another test:</p><pre class="language-csharp"><code class="language-csharp"><span class="token punctuation">[</span><span class="token class-name">Fact</span><span class="token punctuation">]</span><span class="token keyword">public</span><span class="token keyword">void</span><span class="token function">WhenRegisteredAsForwardedSingleton_InstancesAreTheSame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> services <span class="token operator">=</span><span class="token keyword">new</span><span class="token class-name">ServiceCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token punctuation">&lt;</span><span class="token class-name">Foo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token punctuation">&lt;</span><span class="token class-name">IFoo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">&gt;</span> x<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetRequiredService</span><span class="token punctuation">&lt;</span><span class="token class-name">Foo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    services<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">AddSingleton</span><span class="token punctuation">&lt;</span><span class="token class-name">IBar</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">&gt;</span> x<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetRequiredService</span><span class="token punctuation">&lt;</span><span class="token class-name">Foo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> provider <span class="token operator">=</span> services<span class="token punctuation">.</span><span class="token function">BuildServiceProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo1 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetService</span><span class="token punctuation">&lt;</span><span class="token class-name">Foo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo2 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetService</span><span class="token punctuation">&lt;</span><span class="token class-name">IFoo</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo3 <span class="token operator">=</span> provider<span class="token punctuation">.</span><span class="token generic-method"><span class="token function">GetService</span><span class="token punctuation">&lt;</span><span class="token class-name">IBar</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Assert<span class="token punctuation">.</span><span class="token function">Same</span><span class="token punctuation">(</span>foo1<span class="token punctuation">,</span> foo2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Assert<span class="token punctuation">.</span><span class="token function">Same</span><span class="token punctuation">(</span>foo1<span class="token punctuation">,</span> foo3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>In order to "forward" requests for an interface to the concrete type you must do two things: </p><ul><li>Explicitly register the concrete type using <code>services.AddSingleton&lt;Foo&gt;()</code></li><li>Delegate requests for the interfaces to the concrete type by providing a factory function: <code>services.AddSingleton&lt;IFoo&gt;(x =&gt; x.GetRequiredService&lt;Foo&gt;())</code></li></ul><p>With this approach, you will have a true singleton instance of <code>Foo</code>, no matter which implemented service you request. </p><blockquote><p>This approach to providing "forwarded" types was noted <a href="https://github.com/aspnet/DependencyInjection/issues/360">in the original issue</a>, along with a caveat - it's not very efficient. The "service-locator style" <code>GetService()</code> invocation is generally best avoided where possible. However, I feel it's definitely the preferable course of action in this case.</p></blockquote><h2 id="summary" class="heading-with-anchor">Summary<a href="#summary"><img aria-hidden="true" src="/assets/img/icons-link.svg"></a></h2><p>In this post I described what happens if you register a concrete type as multiple services with the ASP.NET Core DI service. In particular, I showed how you could end up with multiple copies of <code>Singleton</code> objects, which could lead to subtle bugs. To get around this, you can either provide an instance of the service at registration time, or you can use factory methods to delegate resolution of the service. Using factory methods is not very efficient, but is generally the best approach.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>