<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Introducing .NET 5 | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Introducing .NET 5 | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard"/>
    <meta property="og:description" content="Today, we&#x2019;re announcing that the next release after .NET Core 3.0 will be .NET 5. This will be the next big release in the .NET family.&#xA;There will be just one .NET going forward, and you will be able to use it to target Windows,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/introducing-net-5/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Introducing .NET 5 | .NET Blog</title>
<div class="readable">
        <h1>Introducing .NET 5 | .NET Blog</h1>
            <div>by Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard</div>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 06 May 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/introducing-net-5/">https://devblogs.microsoft.com/dotnet/introducing-net-5/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/37f91ebe219df737566a4dc7cdd53b68?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Richard</p></div></div></div><p>May 6th, 2019</p><p>Today, we’re announcing that the next release after <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0-preview-5/">.NET Core 3.0</a> will be .NET 5. This will be the next big release in the .NET family.</p><p>There will be just one .NET going forward, and you will be able to use it to target Windows, Linux, macOS, iOS, Android, tvOS, watchOS and WebAssembly and more.</p><p>We will introduce new .NET APIs, runtime capabilities and language features as part of .NET 5.</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet5_platform.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet5_platform.png" alt="" width="1837" height="979" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet5_platform.png 1837w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet5_platform-300x160.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet5_platform-768x409.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet5_platform-1024x546.png 1024w" sizes="(max-width: 1837px) 100vw, 1837px"> </a></p><p>From the inception of the .NET Core project, we’ve added around fifty thousand .NET Framework APIs to the platform. .NET Core 3.0 closes much of the remaining capability gap with .NET Framework 4.8, enabling Windows Forms, WPF and Entity Framework 6. .NET 5 builds on this work, taking <a href="https://docs.microsoft.com/en-us/dotnet/core/" rel="nofollow" target="_blank">.NET Core</a> and the best of <a href="https://www.mono-project.com/" rel="nofollow" target="_blank">Mono</a> to create a single platform that you can use for all your modern .NET code.</p><p>We intend to release .NET 5 in November 2020, with the first preview available in the first half of 2020. It will be supported with future updates to Visual Studio 2019, Visual Studio for Mac and Visual Studio Code.</p><p>Check out <a href="https://devblogs.microsoft.com/dotnet/net-core-is-the-future-of-net/">.NET Core is the Future of .NET</a> to understand how .NET 5 relates to .NET Framework.</p><h2>.NET 5 = .NET Core vNext</h2><p>.NET 5 is the next step forward with .NET Core. The project aims to improve .NET in a few key ways:</p><ul><li>Produce a single .NET runtime and framework that can be used everywhere and that has uniform runtime behaviors and developer experiences.</li><li>Expand the capabilities of .NET by taking the best of .NET Core, .NET Framework, Xamarin and Mono.</li><li>Build that product out of a single code-base that developers (Microsoft and the community) can work on and expand together and that improves all scenarios.</li></ul><p>This new project and direction are a game-changer for .NET. With .NET 5, your code and project files will look and feel the same no matter which type of app you’re building. You’ll have access to the same runtime, API and language capabilities with each app. This includes new <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-2-1/" rel="nofollow">performance improvements</a> that get committed to corefx, practically daily.</p><p>Everything you love about .NET Core will continue to exist:</p><ul><li>Open source and community-oriented on GitHub.</li><li>Cross-platform implementation.</li><li>Support for leveraging platform-specific capabilities, such as Windows Forms and WPF on Windows and the native bindings to each native platform from Xamarin.</li><li>High performance.</li><li>Side-by-side installation.</li><li>Small project files (SDK-style).</li><li>Capable command-line interface (CLI).</li><li>Visual Studio, Visual Studio for Mac, and Visual Studio Code integration.</li></ul><p>Here’s what will be new:</p><ul><li>You will have more choice on runtime experiences (more on that below).</li><li>Java interoperability will be available on all platforms.</li><li>Objective-C and Swift interoperability will be supported on multiple operating systems.</li><li>CoreFX will be extended to support static compilation of .NET (ahead-of-time – AOT), smaller footprints and support for more operating systems.</li></ul><p>We will ship .NET Core 3.0 this September, .NET 5 in November 2020, and then we intend to ship a major version of .NET once a year, every November:</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet_schedule.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet_schedule.png" alt="" width="1837" height="1015" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet_schedule.png 1837w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet_schedule-300x166.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet_schedule-768x424.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/05/dotnet_schedule-1024x566.png 1024w" sizes="(max-width: 1837px) 100vw, 1837px"> </a></p><p>We’re skipping the version 4 because it would confuse users that are familiar with the .NET Framework, which has been using the 4.x series for a long time. Additionally, we wanted to clearly communicate that .NET 5 is the future for the .NET platform.</p><p>We are also taking the opportunity to simplify naming. We thought that if there is only one .NET going forward, we don’t need a clarifying term like “Core”. The shorter name is a simplification and also communicates that .NET 5 has uniform capabilities and behaviors. Feel free to continue to use the “.NET Core” name if you prefer it.</p><h2>Runtime experiences</h2><p><a href="https://github.com/mono/mono" target="_blank">Mono</a> is the original cross-platform implementation of .NET. It started out as an open-source alternative to .NET Framework and transitioned to targeting mobile devices as iOS and Android devices became popular. Mono is the runtime used as part of Xamarin.</p><p><a href="https://github.com/dotnet/coreclr" target="_blank">CoreCLR</a> is the runtime used as part of .NET Core. It has been primarily targeted at supporting cloud applications, including the largest services at Microsoft, and now is also being used for Windows desktop, IoT and machine learning applications.</p><p>Taken together, the .NET Core and Mono runtimes have a lot of similarities (they are both .NET runtimes after all) but also valuable unique capabilities. It makes sense to make it possible to pick the runtime experience you want. We’re in the process of making CoreCLR and Mono drop-in replacements for one another. We will make it as simple as a build switch to choose between the different runtime options.</p><p>The following sections describe the primary pivots we are planning for .NET 5. They provide a clear view on how we plan to evolve the two runtimes individually, and also together.</p><h3>High throughput and high productivity</h3><p>From the very beginning, .NET has relied on a <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" rel="nofollow" target="_blank">just-in-time compiler (JIT)</a> to translate <a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language" rel="nofollow" target="_blank">Intermediate Language (IL) code</a> to optimized machine code. Since that time, we’ve built an industry-leading JIT-based managed runtime that is capable of very high throughput and also enabled developer experiences that make programming fast and easy.</p><p>JITs are well suited for long-running cloud and client scenarios. They are able to generate code that targets a specific machine configuration, including specific CPU instructions. A JIT can also <a href="https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/" rel="nofollow">re-generate methods at runtime</a>, a technique used to JIT quickly while still having the option to produce a highly-tuned version of the code if this becomes a frequently used method.</p><p>Our efforts to make ASP.NET Core run faster on the <a href="https://www.techempower.com/benchmarks/" rel="nofollow" target="_blank">TechEmpower benchmarks</a> is a good example of the power of JIT and our investments in CoreCLR. Our efforts to <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2019-update/" rel="nofollow">harden .NET Core for containers</a> also demonstrates the runtime’s ability to dynamically adapt to constrained environments.</p><p>Developer tools are another good example where JIT shines, such as with the <code>dotnet watch</code> tool or edit and continue. Tools often require compiling and loading code multiple times in a single process without restarting and need to do it very quickly.</p><p>Developers using .NET Core or .NET Framework have primarily relied on JIT. As a result, this experience should seem familiar.</p><p>The default experience for most .NET 5 workloads will be using the JIT-based CoreCLR runtime. The two notable exceptions are iOS and client-side Blazor (web assembly) since both require ahead-of-time (AOT) native compilation.</p><h3>Fast startup, low footprint, and lower memory usage</h3><p>The Mono Project has spent much of its effort focused on mobile and gaming consoles. A key capability and outcome of that project is an AOT compiler for .NET, based on the industry-leading <a href="http://llvm.org/" rel="nofollow" target="_blank">LLVM compiler project</a>. The Mono AOT compiler enables .NET code to be built into a single native code executable that can run on a machine, much like C++ code. AOT-compiled apps can run efficiently in small places, and trades throughput for startup if needed.</p><p>The <a href="https://blazor.net/" rel="nofollow" target="_blank">Blazor project</a> is already using the Mono AOT. It will be one of the first projects to transition to .NET 5. We are using it as one of the scenarios to prove out this plan.</p><p>There are two types of AOT solutions:</p><ul><li>solutions that require 100% AOT compilation.</li><li>solutions where most code is AOT-compiled but where a JIT or interpreter is available and used for code patterns that are not friendly to AOT (like generics).</li></ul><p>The Mono AOT supports both cases. The first type of AOT is required by Apple for iOS and some game consoles, typically for security reasons. The second is the preferred choice since it offers the benefits of AOT without any of its drawbacks.</p><p>.NET Native is the AOT compiler we use for Windows UWP applications and is an example of the first type of AOT listed above. With that particular implementation, we limited the .NET APIs and capabilities that you can use. We learned from that experience that AOT solutions need to cover the full spectrum of .NET APIs and patterns.</p><p>AOT compilation will remain required for iOS, web assembly and some game consoles. We will make AOT compilation an option for applications that are more appliance-like, that require fast startup and/or low footprint.</p><h3>Fundamentals and overlapping experiences</h3><p>It is critical that we continue to move forward as an overall platform with startup, throughput, memory use, reliability, and diagnostics. At the same time, it also makes sense to focus our efforts. We’ll invest more in throughput and reliability in CoreCLR while we invest more in startup and size reduction with the Mono AOT compiler. We think that these are good pairings. Throughput and reliability go together as do startup and size reduction.</p><p>While there are some characteristics where it makes sense to make different investments, there are others that do not.</p><p>Diagnostics capabilities need to be the same across .NET 5, for both functional and performance diagnostics. It is also important to support the same chips and operating systems (with the exception of iOS and web assembly).</p><p>We will continue to optimize .NET 5 for each workload and scenario, for whatever makes sense. There will be even greater emphasis on optimizations, particular where multiple workloads have overlapping needs.</p><p>All .NET 5 applications will use the <a href="https://github.com/dotnet/corefx" target="_blank">CoreFX framework</a>. We will ensure that CoreFX works well in the places it is not used today, which is primarily the Xamarin and client-side Blazor workloads.<br> All .NET 5 applications will be buildable with the <a href="https://github.com/dotnet/cli" target="_blank">.NET CLI</a>, ensuring that you have common command-line tooling across projects.</p><p>C# will move forward in lock-step with .NET 5. Developers writing .NET 5 apps will have access to the latest C# version and features.</p><h2>The birth of the project</h2><p>We met as a technical team in December 2018 in Boston to kick off this project. Design leaders from .NET teams (Mono/Xamarin and .NET Core) and also from <a href="https://unity.com/" rel="nofollow" target="_blank">Unity</a> presented on various technical capabilities and architectural direction.</p><p>We are now moving forward on this project as a single team with one set of deliverables. Since December, we have made a lot of progress on a few projects:</p><ul><li>Defined a minimal layer that defines the runtime &lt;-&gt; managed code layer, with the goal making &gt;99% of CoreFX common code.</li><li>MonoVM can now use CoreFX and its class libraries.</li><li>Run all CoreFX tests on MonoVM using the CoreFX implementation.</li><li>Run ASP.NET Core 3.0 apps with MonoVM.</li><li>Run MonoDevelop and then Visual Studio for Mac on CoreCLR.</li></ul><p>Moving to a single .NET implementation raises important questions. What will the target framework be? Will NuGet package compatibility rules be the same? Which workloads should be supported out-of-the-box by the .NET 5 SDK? How does writing code for a specific architecture work? Do we still need .NET Standard? We are working through these issues now and will soon be sharing design docs for you to read and give feedback on.</p><h2>Closing</h2><p>The .NET 5 project is an important and exciting new direction for .NET. You will see .NET become simpler but also have broader and more expansive capability and utility. All new development and feature capabilities will be part of .NET 5, including new C# versions.</p><p>We see a bright future ahead in which you can use the same .NET APIs and languages to target a broad range of application types, operating systems, and chip architectures. It will be easy to make changes to your build configuration to build your applications differently, in Visual Studio, Visual Studio for Mac, Visual Studio Code, Azure DevOps or at the command line.</p><p>See: <a href="https://news.ycombinator.com/item?id=19840763" target="_blank">.NET 5 on Hacker News</a></p></div></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>