<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Icare3D Blog: NVIDIA Turing Vulkan/OpenGL extensions -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>Icare3D Blog: NVIDIA Turing Vulkan/OpenGL extensions</h1><div><p class="readability-styled" style="display: inline;">).</p><p xmlns="http://www.w3.org/1999/xhtml"><br>This is a new programmable geometry pipeline which replaces the traditional VS/HS/DS/GS pipeline with basically a Compute-based programming model. This new pipeline is based on two shader stages, a Task Shader and a Mesh Shader (separated by an expansion stage), which are used to ultimately generate a compact mesh description called a Meshlet. A Meshlet is a mini indexed geometry representation which is maintained on chip and is directly fed to the rasterizer for consumption. This exposes a very flexible and very efficient model with Compute Shader features and generic cooperative thread groups (workgroups, shared memory, barrier synchronizations...). Applications are endless, and this can for instance be used to implement efficient culling or LOD schemes, or perform procedural geometry generation.</p><div xmlns="http://www.w3.org/1999/xhtml"><p class="readability-styled" style="display: inline;" xmlns="">
As well as in his Siggraph 2018 presentation: </p><a href="http://on-demand.gputechconf.com/siggraph/2018/video/sig1811-3-christoph-kubisch-mesh-shaders.html">http://on-demand.gputechconf.com/siggraph/2018/video/sig1811-3-christoph-kubisch-mesh-shaders.html</a><p>A full OpenGL sample code which implements a <a href="http://onrendering.com/data/papers/isubd/isubd.pdf">compute-based adaptive tessellation technique</a> can also be found there: <a href="https://github.com/jdupuy/opengl-framework/tree/master/demo-isubd-terrain">https://github.com/jdupuy/opengl-framework/tree/master/demo-isubd-terrain</a><br></p><h2>
Variable Rate Shading</h2><div><a href="https://2.bp.blogspot.com/-S4vpWzXylpE/W6FlDNxLP0I/AAAAAAAAGb8/_tqn3az7XCEbtznd5V-3PKEPU20NLHaSACLcBGAs/s1600/VRS2.png" imageanchor="1"><img border="0" data-original-height="420" data-original-width="605" height="220" src="https://2.bp.blogspot.com/-S4vpWzXylpE/W6FlDNxLP0I/AAAAAAAAGb8/_tqn3az7XCEbtznd5V-3PKEPU20NLHaSACLcBGAs/s320/VRS2.png" width="320"></a><p class="readability-styled" style="display: inline;" xmlns="">This is a very powerful hardware feature which allows the application to dynamically control the number of fragment shader invocations (independently of the visibility rate) and vary this </p><i>shading rate</i><p class="readability-styled" style="display: inline;" xmlns=""> across the framebuffer. The </p><i>shading rate</i><p class="readability-styled" style="display: inline;" xmlns=""> is controlled using a texture image ("Shading Rate Image", 8b/texel) where each texel specifies an independent shading rate for blocks of 16x16 pixels. The rate is actually specified indirectly 
using 8b indices into a palette which is specified per-viewport and stores the actual 
shading rate flags.</p></div><p>
Not only the feature allows to vary the MSAA shading rate per-pixel (allowing 1x,4x,8x, and now even 16x SSAA, but with a maximum of 8x depth test and color storage), but it also allows to drop the shading rate below one invocation per-pixel, down to one invocation per block of 4x4 pixels (through one per 1x2, 2x1, 2x2, 2x4 and 4x2 pixels) and even zero invocation.&nbsp;</p><p><br>The GLSL extensions also exposes intrinsics allowing fragment shaders to read the effective fragment size in pixels (<span>gl_FragmentSizeNV</span>) as well as the number of fragment shader invocation for a fully covered pixel (<span>gl_InvocationsPerPixelNV</span>). This opens the road to many new algorithms and more efficient implementations of optimized shading rate techniques, like Foveated Rendering, Lens Adaptation (for VR), Content or Motion Adaptive Shading.</p><p class="readability-styled" style="display: inline;" xmlns="">
More info on Variable Rate Shading in this blog post:</p><a href="https://devblogs.nvidia.com/turing-variable-rate-shading-vrworks/"> https://devblogs.nvidia.com/turing-variable-rate-shading-vrworks/</a><br><h2>
Exclusive Scissor Test</h2><p>
This adds a second per-viewport scissor test, which culls fragments *inside* (exclusive) the specified rectangle, unlike the standard scissor test which culls *outside* (inclusive). This can be used for instance to implement more efficient multi-resolution foveated-rendering techniques (in conjunction with Variable Rate Shading), where raster passes fill concentric strips of pixels by enabling both inclusive and exclusive scissor tests.</p><br><h2>
Texture Access Footprint</h2><p>
These extensions expose a set of GLSL (and SPIR-V) query functions which report the texture-space footprints of texture lookups, ie. some data identifying the set of all texels that may be accessed in order to return a filtered result for the corresponding texture accesses (which can use anisotropic-filtering and potentially cover large footprints). Footprints are returned and represented as an LOD value, an anchor point and a 64-bit bitfield where each bit represents coverage for a group of neighboring texel (in 2D, group granularity can range from 2x2 to 256x256 texels). </p><p>
This is actually an important component for implementing multi-pass decoupled and texture-space shading pipelines, where a restricted set of actually visible pixels must be determined in order to efficiently perform shading in a subsequent pass.</p><br><h2>
Derivatives in Compute Shader </h2><p>
These extensions bring Compute even closer to Graphics by adding support for Quad-based derivatives in Compute Shaders, using the x and y coordinates of the local workgroup invocation ID. This allows Compute Shaders to use both built-in derivative functions like dFdx(), as well as texture lookup functions using automatic LOD computation, and the texture level of detail query function (<span>textureQueryLod()</span>). <br>Two layout qualifiers are provided allowing to specify Quad arrangements based on a linear index or 2D indices.</p><h2>
Shader Subgroup Operations</h2><p>
These shader extensions provide a series of&nbsp; ballot-based partitioning and scan/reduce operations which operate on "subgroups" of shader invocations. This can be used for instance to implement clustering and de-duplication operations on sets of values distributed among different shader invocations.</p><br><h2>
Barycentric Coordinates and manual attributes interpolation</h2><p>
This feature exposes barycentric coordinates as Fragment Shader input in GLSL (and SPIR-V), and provides the ability for a Fragment Shader to directly fetch raw per-vertex values in order to perform manual barycentric interpolation.&nbsp;</p><p>
A three-component vector built-in input <span>gl_BaryCoordNV</span> provides 
perspective-corrected barycentric coordinates (<span>gl_BaryCoordNoPerspNV</span> for non- perspective-correct). Per-vertex inputs use the same brackets array syntax as for Tesselation and Geometry Shader inputs, and a <span>pervertexNV</span> qualifier is added to identify input blocs and variables which read raw per-vertex values from the vertices of the original primitive.</p><p>
This feature potentially allows more efficient data passing to the Fragment Shader using compact or compressed data formats for instance. It could also allow interpolation from vertex values fetched directly from memory, user defined interpolations, or various reconstructions and computations using raw attributes accessed from the three vertices.</p><br><h2>
Ptex Hardware Acceleration</h2><div><p class="readability-styled" style="display: inline;" xmlns="">
An corner-sampled image has texels centered on integer coordinates instead of being halfway, which allows edge sampling coordinates to filter to the exact texels on the edge of the texture. This facilitates implementing Ptex (Per-face Texture [</p><a href="http://ptex.us/ptexpaper.html" target="_blank">Burley and Lacewell 2008</a><p class="readability-styled" style="display: inline;" xmlns="">], cf. </p><a href="https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/Borderless%20Ptex.pdf">https://developer.nvidia.com/sites/default/files/akamai/gamedev/docs/Borderless%20Ptex.pdf</a><p class="readability-styled" style="display: inline;" xmlns="">) texturing in real-time applications by providing proper filtering and interpolation. Ptex uses separate textures for each face of a subdivision surface or polygon mesh, and sample locations are placed at pixel corners, maintaining continuity between adjacent patches by duplicating values along shared edges.</p></div></div><p xmlns="http://www.w3.org/1999/xhtml"><br>This extension has been designed to allow optimizing occlusion queries techniques which rely on per-fragment recording of visible primitives. It allows the hardware to stop generating fragments and stop emitting fragment shader invocations for a given primitive as long as a single fragment has passed early depth and stencil tests. This reduced subset of fragment shader invocation can then be used to record visible primitives in a more performant way. This is only a performance optimization, and no guarantee is given on the number of discarded fragments and consequently the number of fragment shader invocations that will actually be executed.</p><p class="readability-styled" style="display: inline;">
A typical use case for this feature can be found in this occlusion culling sample code: </p></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>