<!DOCTYPE html>
<html lang="en">
<head>
    <title>
gRPC Bi-directional streaming with Razor Pages and a Hosted Service gRPC client -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>gRPC Bi-directional streaming with Razor Pages and a Hosted Service gRPC client</h1><div><div class="entry-content"><p>This article shows how a Bi-directional streaming <a href="https://grpc.io/">gRPC </a>service could be implemented using an .NET Core Hosted Service as a gRPC client, and a Razor Page to send Bi-directional streaming messages to the servers connected clients.</p><p><strong>Code:</strong><a href="https://github.com/damienbod/Secure_gRpc" rel="nofollow">https://github.com/damienbod/Secure_gRpc</a></p><p><strong>Posts in this series</strong></p><p><strong>History</strong></p><p><strong>2019-12-17:</strong> Updated Nuget packages, .NET Core 3.1, updated grpc implementations<br><strong>2019-09-06:</strong> Updated Nuget packages, .NET Core 3 preview 9<br><strong>2019-08-13:</strong> Updated Nuget packages, .NET Core 3 preview 8<br><strong>2019-07-28:</strong> Updated Nuget packages, .NET Core 3 preview 7<br><strong>2019-04-20:</strong> Updated Nuget packages, .NET Core 3 preview 4 changes<br><strong>2019-03-26</strong> Added Code improvements from feedback</p><p><strong>Setting up the Bi-directional streaming gRPC Server </strong></p><p>The gRPC client and server code is defined using a proto3 file. This has a single method, SendData which takes a MyMessage stream.</p><pre class="brush: csharp; title: ; notranslate" title="">syntax = "proto3";

package Duplex;

service Messaging {

  rpc SendData (stream MyMessage) returns (stream MyMessage) {}
}

message MyMessage {
  string name = 1;
  string message = 2;
}
</pre><p>The DuplexService class implements the gRPC service. This class implements the SendData method, which was defined using the proto3 definitions. The service uses a ServerGrpcSubscribers singleton service, which implements the broadcast. If a gRPC client sends a request, the client is added to the list of subscribers and then the message is broadcasted to all the other clients.</p><p>If the gRPC client closes gracefully, the client will be removed here as well. The service requires that the client send a valid bearer token by using the Authorize attribute.</p><pre class="brush: csharp; title: ; notranslate" title="">using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Duplex;
using Grpc.Core;
using Microsoft.AspNetCore.Authorization;
using Microsoft.Extensions.Logging;

namespace SecureGrpc.Server
{
    [Authorize(Policy = "protectedScope")]
    public class DuplexService : Messaging.MessagingBase, IDisposable
    {
        private readonly ILogger _logger;
        private readonly ServerGrpcSubscribers _serverGrpcSubscribers;

        public DuplexService(ILoggerFactory loggerFactory, ServerGrpcSubscribers serverGrpcSubscribers)
        {
            _logger = loggerFactory.CreateLogger&lt;DuplexService&gt;();
            _serverGrpcSubscribers = serverGrpcSubscribers;
        }

        public override async Task SendData(IAsyncStreamReader&lt;MyMessage&gt; requestStream, IServerStreamWriter&lt;MyMessage&gt; responseStream, ServerCallContext context)
        {
            var httpContext = context.GetHttpContext();
            _logger.LogInformation($"Connection id: {httpContext.Connection.Id}");

            if (!await requestStream.MoveNext())
            {
                return;
            }

            var user = requestStream.Current.Name;
            _logger.LogInformation($"{user} connected");
            var subscriber = new SubscribersModel
            {
                Subscriber = responseStream,
                Name = user
            };

            _serverGrpcSubscribers.AddSubscriber(subscriber);

            do
            {
                await _serverGrpcSubscribers.BroadcastMessageAsync(requestStream.Current);
            } while (await requestStream.MoveNext());

            _serverGrpcSubscribers.RemoveSubscriber(subscriber);
            _logger.LogInformation($"{user} disconnected");
        }

        public void Dispose()
        {
            _logger.LogInformation("Cleaning up");
        }
    }
}

</pre><p>The ServerGrpcSubscribers class implements the BroadcastMessageAsync method and the ConcurrentDictionary of clients are managed here. This service can be used to send server messages to the connected clients.</p><p>If when sending a message to a client fails, for example, the client application is killed, the broadcast will catch an exception, and remove this subscription.</p><pre class="brush: csharp; title: ; notranslate" title="">using Duplex;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

namespace SecureGrpc.Server
{
    public class ServerGrpcSubscribers
    {
        private readonly ILogger _logger;
        private readonly ConcurrentDictionary&lt;string, SubscribersModel&gt; Subscribers = new ConcurrentDictionary&lt;string,SubscribersModel&gt;();
        
        public ServerGrpcSubscribers(ILoggerFactory loggerFactory)
        {
            _logger = loggerFactory.CreateLogger&lt;ServerGrpcSubscribers&gt;();
        }

        public async Task BroadcastMessageAsync(MyMessage message)
        {
            await BroadcastMessages(message);
        }


        public void AddSubscriber(SubscribersModel subscriber)
        {
            bool added = Subscribers.TryAdd(subscriber.Name, subscriber);
            _logger.LogInformation($"New subscriber added: {subscriber.Name}");
            if (!added)
            {
                _logger.LogInformation($"could not add subscriber: {subscriber.Name}");
            }
        }

        public void RemoveSubscriber(SubscribersModel subscriber)
        {
            try
            {
                Subscribers.TryRemove(subscriber.Name, out SubscribersModel item);
                _logger.LogInformation($"Force Remove: {item.Name} - no longer works");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Could not remove {subscriber.Name}");
            }
        }

        private async Task BroadcastMessages(MyMessage message)
        {
            foreach (var subscriber in Subscribers.Values)
            {
                var item = await SendMessageToSubscriber(subscriber, message);
                if (item != null)
                {
                    RemoveSubscriber(item);
                };
            }
        }

        private async Task&lt;SubscribersModel&gt; SendMessageToSubscriber(SubscribersModel subscriber, MyMessage message)
        {
            try
            {
                _logger.LogInformation($"Broadcasting: {message.Name} - {message.Message}");
                await subscriber.Subscriber.WriteAsync(message);
                return null;
            }
            catch(Exception ex)
            {
                _logger.LogError(ex, "Could not send");
                return subscriber;
            }
        }

    }
}

</pre><p>The SubscribersModel class is used for the clients which are connected to the service. The RequireAuthorization method is used to define the authorization in the routing configuration.</p><pre class="brush: csharp; title: ; notranslate" title="">public class SubscribersModel
{
	public IServerStreamWriter&lt;MyMessage&gt; Subscriber { get; set; }

	public string Name { get; set; }
}
</pre><p>The server startup configures the gRPC service. </p><pre class="brush: csharp; title: ; notranslate" title="">using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using IdentityServer4.AccessTokenValidation;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using System.Security.Claims;

namespace SecureGrpc.Server
{
    public class Startup
    {
        private string stsServer = "https://localhost:44352";

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddHttpContextAccessor();

            services.AddSingleton&lt;ServerGrpcSubscribers&gt;();

            services.AddAuthorization(options =&gt;
            {
                options.AddPolicy("protectedScope", policy =&gt;
                {
                    policy.RequireClaim("scope", "grpc_protected_scope");
                });
            });

            services.AddAuthorizationPolicyEvaluator();

            services.AddAuthentication(IdentityServerAuthenticationDefaults.AuthenticationScheme)
                .AddIdentityServerAuthentication(options =&gt;
                {
                    options.Authority = stsServer;
                    options.ApiName = "ProtectedGrpc";
                    options.ApiSecret = "grpc_protected_secret";
                    options.RequireHttpsMetadata = false;
                });

            services.AddGrpc(options =&gt;
            {
                options.EnableDetailedErrors = true;
            });

            services.AddMvc()
               .AddNewtonsoftJson();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            app.UseStaticFiles();
            app.UseHttpsRedirection();

            app.UseRouting();

            app.UseAuthentication();
            app.UseAuthorization();
            app.UseCors();

            app.UseEndpoints(endpoints =&gt;
            {
                endpoints.MapGrpcService&lt;GreeterService&gt;().RequireAuthorization("protectedScope");
                endpoints.MapGrpcService&lt;DuplexService&gt;().RequireAuthorization("protectedScope");
                endpoints.MapRazorPages();
            });
        }
    }
}

</pre><p>The csproj requires the GrpcServices and the proto configuration to create the stubs.</p><pre class="brush: xml; title: ; notranslate" title="">&lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netcoreapp3.1&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;Protobuf Include="..\Protos\*.proto" GrpcServices="Server" /&gt;
    &lt;Content Include="@(Protobuf)" LinkBase="" /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.AspNetCore.Authentication.Certificate" Version="3.1.0" /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Grpc.AspNetCore.Server" Version="2.25.0" /&gt;
    &lt;PackageReference Include="Google.Protobuf" Version="3.11.2" /&gt;

    &lt;PackageReference Include="Grpc.Tools" Version="2.25.0" PrivateAssets="All" /&gt;

    &lt;PackageReference Include="Microsoft.AspNetCore.Mvc.NewtonsoftJson" Version="3.1.0" /&gt;
    &lt;PackageReference Include="IdentityServer4.AccessTokenValidation" Version="3.0.1" /&gt;
    &lt;PackageReference Include="Serilog" Version="2.9.0" /&gt;
    &lt;PackageReference Include="Serilog.AspNetCore" Version="3.2.0" /&gt;
    &lt;PackageReference Include="Serilog.Settings.Configuration" Version="3.1.1-dev-00209" /&gt;
    &lt;PackageReference Include="Serilog.Sinks.Console" Version="3.1.2-dev-00824" /&gt;
    &lt;PackageReference Include="Serilog.Sinks.File" Version="4.1.0" /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;None Update="Certs\client1.pfx"&gt;
      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
    &lt;None Update="Certs\server1.pfx"&gt;
      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
    &lt;None Update="Certs\server2.pfx"&gt;
      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
    &lt;None Update="server.pfx"&gt;
      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;

</pre><p><strong>Hosted Worker service gRPC client </strong></p><p>The gRPC client is implemented in a worker class run in a Hosted Service. The csproj file also requires the gRPC configurations and the proto settings, otherwise the stub will not be built from the proto file.</p><pre class="brush: csharp; title: ; notranslate" title="">using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace BiDirectionalStreamingWorker
{
    public class Program
    {
        public static void Main(string[] args)
        {
            CreateHostBuilder(args).Build().Run();
        }

        public static IHostBuilder CreateHostBuilder(string[] args) =&gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureServices(services =&gt;
                {
                    services.AddHostedService&lt;Worker&gt;();
                    services.AddSingleton&lt;ApiService&gt;();
                });
    }
}

</pre><p>The worker service implements the gRPC client. This is based on the example from the C# gRPC github repo. </p><p>The application gets a bearer token from the Secure token service, and uses the Metadata to add this as a header to the stream.</p><p>The data is then sent, received from the server. If the application is closed properly, it will close it’s connection. If the application is killed, the server gRPC server needs to handle this.</p><pre class="brush: csharp; title: ; notranslate" title="">using System;
using System.Threading;
using System.Threading.Tasks;
using Grpc.Core;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.IO;
using System.Security.Cryptography.X509Certificates;
using Grpc.Net.Client;

namespace BiDirectionalStreamingWorker
{
    public class Worker : BackgroundService
    {
        private readonly ILogger&lt;Worker&gt; _logger;

        public Worker(ILogger&lt;Worker&gt; logger)
        {
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            ///
            /// Token init
            /// 
            HttpClient httpClient = new HttpClient();
            ApiService apiService = new ApiService(httpClient);
            var token = await apiService.GetAccessTokenAsync();
            //var token = "This is invalid, I hope it fails";

            var tokenValue = "Bearer " + token;
            var metadata = new Metadata
            {
                { "Authorization", tokenValue }
            };

            var channel = GrpcChannel.ForAddress("https://localhost:50051", new GrpcChannelOptions
            {
                HttpClient = CreateHttpClient()
            });

            var name = "worker_client";
            while (!stoppingToken.IsCancellationRequested)
            {
                _logger.LogInformation($"Worker running at: {DateTime.Now}");

                var client = new Duplex.Messaging.MessagingClient(channel);

                using (var sendData = client.SendData(metadata))
                {
                    Console.WriteLine($"Connected as {name}. Send empty message to quit.");

                    var responseTask = Task.Run(async () =&gt;
                    {
                        while (await sendData.ResponseStream.MoveNext(stoppingToken))
                        {
                            Console.WriteLine($"{sendData.ResponseStream.Current.Name}: {sendData.ResponseStream.Current.Message}");
                        }
                    });

                    var line = Console.ReadLine();
                    while (!string.IsNullOrEmpty(line))
                    {
                        await sendData.RequestStream.WriteAsync(new Duplex.MyMessage { Name = name, Message = line });
                        line = Console.ReadLine();
                    }
                    await sendData.RequestStream.CompleteAsync();
                }

                await Task.Delay(1000, stoppingToken);
            }
        }

        private static HttpClient CreateHttpClient()
        {
            var handler = new HttpClientHandler();
            var cert = new X509Certificate2(Path.Combine("Certs/client2.pfx"), "1111");
            handler.ClientCertificates.Add(cert);

            // Create client
            return new HttpClient(handler);
        }
    }
}

</pre><p><strong>Sending server messages from the Server Razor Pages</strong></p><p>On the gRPC server a Razor page can be used to send server messages to all the connected clients. For Razor pages and gRPC to work on the same kestrel server, HTTP and HTTP2 need to be allowed.</p><p>A Razor page implements a form to send a broadcast to all the connected gRPC clients, using the ServerGrpcSubscribers defined above.</p><pre class="brush: csharp; title: ; notranslate" title="">using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace SecureGrpc.Server.Pages
{
    public class IndexModel : PageModel
    {
        private readonly ServerGrpcSubscribers _serverGrpcSubscribers;

        public IndexModel(ServerGrpcSubscribers serverGrpcSubscribers)
        {
            _serverGrpcSubscribers = serverGrpcSubscribers;
        }

        public void OnGet()
        {
        }

        public async Task OnPostAsync(string message)
        {
            await _serverGrpcSubscribers.BroadcastMessageAsync(
              new Duplex.MyMessage { Message = message, Name = "Server" });
        }
    }
}

</pre><p><strong>Running the code</strong></p><p>In Visual studio, build and run all the projects, multiple project start. The clients will get an access token from the Secure token service, and then send a message to the gRPC server from the clients using the console.</p><p><img data-attachment-id="12173" data-permalink="https://damienbod.com/2019/03/25/grpc-bi-directional-streaming-with-razor-pages-and-a-hosted-service-grpc-client/grpc_streaming_duplex_01/" data-orig-file="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png" data-orig-size="1272,818" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gRPC_streaming_duplex_01" data-image-description="" data-medium-file="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png?w=600" data-large-file="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png?w=640" src="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png?w=640&amp;h=412" alt="" width="640" height="412" class="alignnone size-full wp-image-12173" srcset="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png?w=640&amp;h=412 640w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png?w=150&amp;h=96 150w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png?w=600&amp;h=386 600w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png?w=768&amp;h=494 768w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png?w=1024&amp;h=659 1024w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_01.png 1272w" sizes="(max-width: 640px) 100vw, 640px"></p><p>Using a browser at <a href="https://localhost:50051" rel="nofollow">https://localhost:50051</a>, a razor page can be opened to send a server message to the connected clients.</p><p><img data-attachment-id="12174" data-permalink="https://damienbod.com/2019/03/25/grpc-bi-directional-streaming-with-razor-pages-and-a-hosted-service-grpc-client/grpc_streaming_duplex_02/" data-orig-file="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png" data-orig-size="1140,873" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gRPC_streaming_duplex_02" data-image-description="" data-medium-file="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png?w=600" data-large-file="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png?w=640" src="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png?w=640&amp;h=490" alt="" width="640" height="490" class="alignnone size-full wp-image-12174" srcset="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png?w=640&amp;h=490 640w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png?w=150&amp;h=115 150w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png?w=600&amp;h=459 600w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png?w=768&amp;h=588 768w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png?w=1024&amp;h=784 1024w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_02.png 1140w" sizes="(max-width: 640px) 100vw, 640px"></p><p>If a connected client is killed, a message is sent, the server throws an exception, and removes the client without crashing.</p><p><img data-attachment-id="12175" data-permalink="https://damienbod.com/2019/03/25/grpc-bi-directional-streaming-with-razor-pages-and-a-hosted-service-grpc-client/grpc_streaming_duplex_03/" data-orig-file="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png" data-orig-size="1289,976" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="gRPC_streaming_duplex_03" data-image-description="" data-medium-file="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png?w=600" data-large-file="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png?w=640" src="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png?w=640&amp;h=485" alt="" width="640" height="485" class="alignnone size-full wp-image-12175" srcset="https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png?w=640&amp;h=485 640w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png?w=1280&amp;h=970 1280w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png?w=150&amp;h=114 150w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png?w=600&amp;h=454 600w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png?w=768&amp;h=582 768w, https://damienbod.files.wordpress.com/2019/03/grpc_streaming_duplex_03.png?w=1024&amp;h=775 1024w" sizes="(max-width: 640px) 100vw, 640px"></p><p>When the client connects again, the server can send messages to the same client.</p><p><strong>Links:</strong></p><p><a href="https://github.com/grpc/grpc-dotnet/" rel="nofollow">https://github.com/grpc/grpc-dotnet/</a></p><p><a href="https://grpc.io/" rel="nofollow">https://grpc.io/</a></p><blockquote class="wp-embedded-content" data-secret="mvYCNwJdCK"><p><a href="https://www.stevejgordon.co.uk/early-look-at-grpc-using-aspnet-core-3">An Early Look at gRPC and ASP.NET Core 3.0</a></p></blockquote><p><a href="https://www.zoeys.blog/first-impressions-of-grpc-integration-in-asp-net-core-3-preview/" rel="nofollow">https://www.zoeys.blog/first-impressions-of-grpc-integration-in-asp-net-core-3-preview/</a></p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><h3 class="jp-relatedposts-headline"><em>Related</em></h3></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>