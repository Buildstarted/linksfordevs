<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Dynamically setting Content Type in ASP.NET Core with FileExtensionContentTypeProvider &#x2013; Scott Sauber -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Dynamically setting Content Type in ASP.NET Core with FileExtensionContentTypeProvider – Scott Sauber</h1><div><div class="entry-content"><h2><span>tldr;</span></h2><p>If you have a scenario where you have multiple file types (.pdf, .docx, etc.) stored somewhere (in a database, file system, etc.), that need to be downloaded, you can automatically figure out the Content Type by newing up a <code>FileExtensionContentTypeProvider</code> and call <code>TryGetContentType</code> to get the Content Type and pass that to the <code>File</code>result helper.&nbsp; See lines 8-16 below</p><h2><span>What is a Content Type?</span></h2><p>A Content Type is how the server tells the browser what type of file the resource being served is.&nbsp; That way the browser knows how to render whether it’s HTML, CSS, JSON, PDF, etc.&nbsp; The way the server does this is by passing a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type" target="_blank" rel="noopener noreferrer">Content-Type HTTP Header</a>.&nbsp; This value of the header will look like “text/html” for HTML, “text/css” for CSS, “application/json” for JSON, “application/pdf” for PDF’s, and so on.&nbsp; A complete list can be found on the <a href="http://www.iana.org/assignments/media-types/media-types.xhtml">IANA official docs</a>.</p><blockquote><p>Note: A Content Type can also be called a MIME type, but because the header is called Content-Type, and ASP.NET Core calls it the Content Type in the code I’m going to be showing, I’m going to call it Content Type for consistency throughout this post.</p></blockquote><h2><span>How do I set the Content Type in ASP.NET Core?</span></h2><p>The good news is, for a vast majority of the static files you’re going to serve, the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/static-files">Static Files Middleware</a> will set the Content Type for you.&nbsp; For scenarios where you need to set the Content Type yourself, you can use the <code>FileContentResult</code>&nbsp;in your <code>Controllers</code>&nbsp;or <code>PageModels</code>&nbsp;via the <code>File</code> helper method used on line 11 below.</p><h2><span>What happens if I set the wrong Content Type?</span></h2><p>If you set the wrong Content Type, then you may cause issues for your application.&nbsp; For example, the PDF rendered in the code above will render a PDF in the browser like this:</p><p><img data-attachment-id="2772" data-permalink="https://scottsauber.com/2019/02/25/dynamically-setting-content-type-in-asp-net-core-with-fileextensioncontenttypeprovider/pdf-returned/" data-orig-file="https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png" data-orig-size="3815,1912" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="pdf returned" data-image-description="" data-medium-file="https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png?w=300" data-large-file="https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png?w=809" class="alignnone size-full wp-image-2772" src="https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png?w=809" alt="pdf returned" srcset="https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png?w=809 809w, https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png?w=1616 1616w, https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png?w=150 150w, https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png?w=300 300w, https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png?w=768 768w, https://scottsauber.files.wordpress.com/2019/02/pdf-returned.png?w=1024 1024w" sizes="(max-width: 809px) 100vw, 809px"></p><p>But what happens if I replace that “application/pdf” string with “application/json” to try to tell the browser the PDF is really JSON?&nbsp; Well… let’s find out:</p><p><img data-attachment-id="2773" data-permalink="https://scottsauber.com/2019/02/25/dynamically-setting-content-type-in-asp-net-core-with-fileextensioncontenttypeprovider/returned-json/" data-orig-file="https://scottsauber.files.wordpress.com/2019/02/returned-json.png" data-orig-size="3831,1912" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="returned json" data-image-description="" data-medium-file="https://scottsauber.files.wordpress.com/2019/02/returned-json.png?w=300" data-large-file="https://scottsauber.files.wordpress.com/2019/02/returned-json.png?w=809" class="alignnone size-full wp-image-2773" src="https://scottsauber.files.wordpress.com/2019/02/returned-json.png?w=809" alt="returned json" srcset="https://scottsauber.files.wordpress.com/2019/02/returned-json.png?w=809 809w, https://scottsauber.files.wordpress.com/2019/02/returned-json.png?w=1618 1618w, https://scottsauber.files.wordpress.com/2019/02/returned-json.png?w=150 150w, https://scottsauber.files.wordpress.com/2019/02/returned-json.png?w=300 300w, https://scottsauber.files.wordpress.com/2019/02/returned-json.png?w=768 768w, https://scottsauber.files.wordpress.com/2019/02/returned-json.png?w=1024 1024w" sizes="(max-width: 809px) 100vw, 809px"></p><p>Well that’s not good.&nbsp; So, setting the correct Content Type is pretty important.&nbsp; (Also, yes I know I need to update Chrome…. don’t judge me.&nbsp; I have a bunch of tabs open in another window that I’m totally going to look at some day, ok?)</p><h2><span>Scenario</span></h2><p>Let’s say you have a scenario where you allow admin users to upload files that allows some customer users to download those files.&nbsp; Those admin users can uploads all sorts of file extensions such as a pdf, pptx, docx, xlsx, etc. that customers can then download themselves.&nbsp; This means that you can’t assume and be sure what the Content Type should be, so you need to inspect the file extension to figure it out.&nbsp; No big deal, there are a few ways to solve this, but the simplest is to just write a trusty ol’ switch statement like lines 11-25 below to handle every file type we allow.</p><p>The problem with that is trying to maintain a list of all those mappings yourself is annoying, and likely leads you to adding “just one more” when your users want to support another file type you didn’t previously have.&nbsp; It’s also prone to typo’s, because some of these content types are ridiculously convoluted.</p><h2><span>Solution</span></h2><p>Luckily, ASP.NET Core already has maintained this list for us via the <a href="https://github.com/aspnet/AspNetCore/blob/dffe9abf6b6b009e183e808459e65770c9210a52/src/Middleware/StaticFiles/src/FileExtensionContentTypeProvider.cs#L21">FileExtensionContentTypeProvider</a>.&nbsp; So all you have to do is new it up, and call TryGetContentType which acts like a lot of the TryX-out pattern you see sprinkled throughout .NET.&nbsp; It returns a bool and an out variable with the content type.&nbsp; Usage looks like lines 8-16 below:</p><p>So there you have it, now you don’t have to maintain some crazy list of Content Type mappings, you can just lean on ASP.NET Core which maintains those mappings for you.</p><p>Hope this helps.</p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>