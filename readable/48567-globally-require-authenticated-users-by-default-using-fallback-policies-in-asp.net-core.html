<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Globally Require Authenticated Users By Default Using Fallback Policies in ASP.NET&#xA0;Core -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Globally Require Authenticated Users By Default Using Fallback Policies in ASP.NET&#xA0;Core</h1>
    <article id="post-3007" class="post-3007 post type-post status-publish format-standard hentry category-uncategorized"> <div class="entry-content"> <p>You can use Fallback Policies in ASP.NET Core 3.0+ to require an Authenticated User by default. Conceptually, you can think of this as adding an <code>[Authorize]</code> attribute by default to every single Controller and Razor Page ONLY WHEN no other attribute is specified on a Controller or Razor Page (like <code>[AllowAnonymous]</code> or <code>[Authorize(PolicyName=&quot;PolicyName&quot;)]</code>).&#xA0; See lines 9-11 below.</p> <h2></h2> <h2><span>A Quick Lap Around the [Authorize] and [AllowAnonymous] Attributes</span></h2>
<p>In ASP.NET Core (and even previously in ASP.NET), we&#x2019;ve had the ability to add a <code>[Authorize]</code> attribute to a resource (such as a Controller or Razor Page) in order to tell ASP.NET Core not to let a user access that resource unless they are authenticated.</p> <p>The <code>[Authorize]</code> attribute can also take a PolicyName parameter that tells it what <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies">Authorization Policy</a> to execute.&#xA0; The Policy below says only Admins can access this page.</p> <p>You can follow <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies">this link</a> to learn more how to set up policies in ASP.NET Core and how to enforce your own custom rules (such as what defines an Admin).</p>
<p>By default, if you do not add an <code>[Authorize]</code> attribute, then the resource will <span><strong>not</strong></span> be secured and will be accessible to unauthenticated users.&#xA0; A resource can also be accessible to unauthenticated users by explicitly adding a <code>[AllowAnonymous]</code> attribute.</p>
<blockquote><p><strong>Word of Caution:</strong> Adding the <code>[AllowAnonymous]</code>attribute bypasses all Authorization, and short-circuits out of the Authorization pipeline, even if Authorization is set further up the stack.</p></blockquote> <h2><span>The Problem &#x2013; Having to remember to add [Authorize] attributes everywhere</span></h2>
<p>When you create a new Controller or Razor Page in ASP.NET Core, by default the resource will be accessible to anyone, because there is no <code>[Authorize]</code> attribute.&#xA0; This is a problem if you&#x2019;re creating a site where a majority of the site is protected by some sort of authentication.&#xA0; It is really easy to forget to add an <code>[Authorize]</code> attribute which could open up your application to a security vulnerability, and leave you with a potential&#x2026; let&#x2019;s call it a &#x201C;resume updating event.&#x201D; &#x1F642;</p> <h2><span>What are Fallback Policies?</span></h2>
<p>ASP.NET Core 3.0 turned on <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1#endpoint-routing">Endpoint Routing</a> by default, which was a way to get Routing information out of being tightly coupled to MVC and make Routing more global to the entire stack (such as Middleware).&#xA0; The 3.0 release introduced the concept of Fallback Policies with Endpoint Routing.</p>
<p><strong>A Fallback Policy means that if no other policy or attribute is specified on a Controller or Razor Page, the Authorization middleware will use the Fallback Policy.</strong>&#xA0; Therefore, if you do not add any other attribute (such as <code>[AllowAnonymous]</code> or <code>[Authorize(PolicyName=&quot;PolicyName&quot;)]</code>, then ASP.NET Core will use the Fallback Policy.</p> <h2><span>The Solution &#x2013; Using a Fallback Policy to require authentication by default</span></h2>
<p>So by leveraging a Fallback Policy, we can specify that a user must always be authenticated for every Controller or Razor Page in our application.&#xA0; You can wire this up under <code>ConfigureServices</code> via the <code>AuthorizationOptions</code> in <code>services.AddAuthorization</code>.&#xA0; &#xA0;See lines 9-11 below:</p> <p>Conceptually, you can think of this as adding an <code>[Authorize]</code> attribute by default to every single Controller and Razor Page ONLY WHEN no other attribute is specified on a Controller or Razor Page (like <code>[AllowAnonymous]</code> or <code>[Authorize(PolicyName=&quot;PolicyName&quot;)]</code>).</p>
<p>Of course, you could also take this one step further, by having your Fallback Policy be a policy that requires certain claims instead of just being authenticated.&#xA0; The choice is up to you!</p> <h2><span>What do we gain by doing this?</span></h2>
<ol>
<li><strong>A</strong> <strong>more secure default.&#xA0;</strong> A developer doesn&#x2019;t have to remember to add an <code>[Authorize]</code> attribute to every Controller or Razor Page.</li>
<li><strong>Less boilerplate.&#xA0;</strong> Every Controller and Razor Page requiring authentication has one less line of boilerplate code to worry about.</li>
<li><strong>You don&#x2019;t give up any flexibility.</strong>
<ol>
<li>If a Controller or Razor Page is supposed to be public to unauthenticated users (such as a Login page or Forgot Password page), then you can still add a <code>[AllowAnonymous]</code> attribute and the Fallback Policy is bypassed.</li>
<li>If a Controller or Razor Page needs a specific policy, you can still add an Authorize attribute with a custom policy name.&#xA0; That will take precedence over the Fallback Policy such as <code>[Authorize(PolicyName=&quot;PolicyName&quot;)]</code>.</li>
</ol>
</li>
</ol> <h2><span>Default Policy vs. Fallback Policy</span></h2>
<p>You might get confused when seeing that there&#x2019;s also a &#x201C;Default Policy&#x201D; in addition to Fallback Policies (or at least I did).&#xA0; In my head I thought &#x201C;oh the Fallback Policy is kind of like the default policy that runs&#x2026; but wait&#x2026; what&#x2019;s a Default Policy then?&#x201D;</p>
<p>The Default Policy is the policy that gets evaluated when authorization is required, but no explicit policy is specified.&#xA0; In other words, it&#x2019;s the policy that evaluates when you add an <code>[Authorize]</code> attribute without any PolicyName.&#xA0; Out of the box, the Default Policy is set to requiring Authenticated Users.</p>
<p>A Fallback Policy, on the other hand, is the policy that gets evaluated if no other policy is specified (such as when no <code>[AllowAnonymous]</code> or <code>[Authorize]</code> attribute exists on a Controller or Razor Page)</p> <h2><span>The Old Solution in ASP.NET Core 2.x</span></h2>
<h2><span>A common solution to this problem in ASP.NET Core 2.x was to add a Global Filter to MVC such as lines 10-13 below:</span></h2> <h2><span>Conclusion</span></h2>
<p>In my opinion, the new way using a Fallback Policy makes a lot more sense. It keeps everything inside the Authorization configuration and doesn&#x2019;t sprinkle Authorization logic into MVC Filters.&#xA0; The only thing that&#x2019;s a little goofy is the naming between a Default Policy and Fallback Policy, but once you learn that nuance, the naming makes sense.</p> <p>In a future post, I&#x2019;ll go over other tips and tricks for leveraging the ASP.NET Core authorization system.&#xA0; Stay tuned.</p> </div> </article>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>