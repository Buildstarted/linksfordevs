<!DOCTYPE html>
<html lang="en">
<head>
    <title>
How to make a racist AI without really trying -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>How to make a racist AI without really trying</h1><div><div class="text_cell_render border-box-sizing rendered_html"><h3 id="Step-1:-Word-embeddings">Step 1: Word embeddings<a class="anchor-link" href="#Step-1:-Word-embeddings">¶</a><a class="headerlink" href="#Step-1:-Word-embeddings" title="Permalink to this heading">¶</a></h3><p>Word embeddings are frequently used to represent words as inputs to machine learning. The words become vectors in a multi-dimensional space, where nearby vectors represent similar meanings. With word embeddings, you can compare words by (roughly) what they mean, not just exact string&nbsp;matches.</p><p>Successfully training word vectors requires starting from hundreds of gigabytes of input text. Fortunately, various machine-learning groups have already done this and provided pre-trained word embeddings that we can&nbsp;download.</p><p>Two very well-known datasets of pre-trained English word embeddings are <strong>word2vec</strong>, pretrained on Google News data, and <strong>GloVe</strong>, pretrained on the Common Crawl of web pages. We would get similar results for either one, but here we’ll use GloVe because its source of data is more&nbsp;transparent.</p><p>GloVe comes in three sizes: 6B, 42B, and 840B. The 840B size is powerful, but requires significant post-processing to use it in a way that’s an improvement over 42B. The 42B version is pretty good and is also neatly trimmed to a vocabulary of 1 million words. Because we’re following the path of least resistance, we’ll just use the 42B&nbsp;version.</p><blockquote><p><strong>Why does it matter that the word embeddings are&nbsp;“well-known”?</strong></p><p>I’m glad you asked, hypothetical questioner! We’re trying to do something extremely typical at each step, and for some reason, comparison-shopping for better word embeddings isn’t typical yet. Read on, and I hope you’ll come out of this tutorial with the desire to use <a href="https://github.com/commonsense/conceptnet-numberbatch">modern, high-quality word embeddings</a>, especially those that are aware of algorithmic bias and try to mitigate it. But that’s getting ahead of&nbsp;things.</p></blockquote><p>We download glove.42B.300d.zip from <a href="https://nlp.stanford.edu/projects/glove/">the GloVe web page</a>, and extract it into <code>data/glove.42B.300d.txt</code>. Next we define a function to read the simple format of its word&nbsp;vectors.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>