<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Using Certificate Authentication with IHttpClientFactory and HttpClient -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Using Certificate Authentication with IHttpClientFactory and HttpClient</h1><div><div class="entry-content"><p>This article shows how an HttpClient instance could be setup to send a certificate to an API to use for <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth">certificate authentication</a>. In an ASP.NET Core application, the <em>IHttpClientFactory </em>can be used to get an instance of the <em>HttpClient</em>. </p><p><strong>Code</strong><a href="https://github.com/damienbod/Secure_gRpc/tree/master/SecureGrpc.ManagedClient" rel="nofollow">https://github.com/damienbod/Secure_gRpc/tree/master/SecureGrpc.ManagedClient</a></p><p>Posts in this series</p><p><strong>Using a named HttpClient</strong></p><p>In the following example, a client certificate is added to a <em>HttpClientHandler </em>using the <em>ClientCertificates</em> property from the handler. This handler can then be used in a named instance of a HttpClient using the <em>ConfigurePrimaryHttpMessageHandler </em>method. This is setup in the Startup class in the<br>ConfigureServices method.</p><pre class="brush: csharp; title: ; notranslate" title="">var clientCertificate = 
    new X509Certificate2(
      Path.Combine(_environment.ContentRootPath, "sts_dev_cert.pfx"), "1234");

var handler = new HttpClientHandler();
handler.ClientCertificates.Add(clientCertificate);

services.AddHttpClient("namedClient", c =&gt;
{
}).ConfigurePrimaryHttpMessageHandler(() =&gt; handler);
</pre><p>The IHttpClientFactory can then be used to get the named instance with the handler and the certificate. The CreateClient method with the name of the client defined in the Startup class is used to get the instance. The HTTP request can be sent using the client as required.</p><pre class="brush: csharp; title: ; notranslate" title="">private readonly IHttpClientFactory _clientFactory;

public ApiService(IHttpClientFactory clientFactory)
{
	_clientFactory = clientFactory;
}

private async Task&lt;JsonDocument&gt; GetApiDataWithNamedClient()
{
	var client = _clientFactory.CreateClient("namedClient");

	var request = new HttpRequestMessage()
	{
		RequestUri = new Uri("https://localhost:44379/api/values"),
		Method = HttpMethod.Get,
	};
	var response = await client.SendAsync(request);
	if (response.IsSuccessStatusCode)
	{
		var responseContent = await response.Content.ReadAsStringAsync();
		var data = JsonDocument.Parse(responseContent);
		return data;
	}

	throw new ApplicationException($"Status code: {response.StatusCode}, Error: {response.ReasonPhrase}");
}
</pre><p><strong>Using a HttpClientHandler directly</strong></p><p>The HttpClientHandler could be added directly in the constructor of the HttpClient class. Care should be taken when creating instances of the HttpClient. The HttpClient will then send the certificate with each request.</p><pre class="brush: csharp; title: ; notranslate" title="">private async Task&lt;JsonDocument&gt; GetApiDataUsingHttpClientHandler()
{
	var cert = new X509Certificate2(Path.Combine(_environment.ContentRootPath, "sts_dev_cert.pfx"), "1234");
	var handler = new HttpClientHandler();
	handler.ClientCertificates.Add(cert);
	var client = new HttpClient(handler);
	
	var request = new HttpRequestMessage()
	{
		RequestUri = new Uri("https://localhost:44379/api/values"),
		Method = HttpMethod.Get,
	};
	var response = await client.SendAsync(request);
	if (response.IsSuccessStatusCode)
	{
		var responseContent = await response.Content.ReadAsStringAsync();
		var data = JsonDocument.Parse(responseContent);
		return data;
	}

	throw new ApplicationException($"Status code: {response.StatusCode}, Error: {response.ReasonPhrase}");
}
</pre><p><strong>Sending the certificate in the X-ARR-ClientCert request header</strong></p><p>The HttpClient could also send the certificate using the <em>X-ARR-ClientCert</em> request header. If sending the client as a HTTP request header, the server needs to handle this correctly. This can be implemented using the <em>AddCertificateForwarding</em> extension method.</p><pre class="brush: csharp; title: ; notranslate" title="">private async Task&lt;JsonDocument&gt; GetApiDataUsingXARRClientCertHeader()
{
	var client = _clientFactory.CreateClient();

	var request = new HttpRequestMessage()
	{
		RequestUri = new Uri("https://localhost:44379/api/values"),
		Method = HttpMethod.Get,
	};

	request.Headers.Add("X-ARR-ClientCert", cert.GetRawCertDataString());
	var response = await client.SendAsync(request);
	if (response.IsSuccessStatusCode)
	{
		var responseContent = await response.Content.ReadAsStringAsync();
		var data = JsonDocument.Parse(responseContent);
		return data;
	}

	throw new ApplicationException($"Status code: {response.StatusCode}, Error: {response.ReasonPhrase}");
}
</pre><p><strong>GRPC named HttpClient with access token</strong></p><p>A GRPC service could also send a certificate and an access token for authentication. The certificate is added as in the handler like before, and the access token is sent using the Authorization request header.</p><pre class="brush: csharp; title: ; notranslate" title="">public async Task&lt;string&gt; GetGrpcApiDataAsync()
{
	var client = _clientFactory.CreateClient("grpc");

	var access_token = await _apiTokenInMemoryClient.GetApiToken(
		"ProtectedGrpc",
		"grpc_protected_scope",
		"grpc_protected_secret"
	);

	var tokenValue = "Bearer " + access_token;
	var metadata = new Metadata
	{
		{ "Authorization", tokenValue }
	};

	CallOptions callOptions = new CallOptions(metadata);

	var channel = GrpcChannel.ForAddress(_authConfigurations.Value.ProtectedApiUrl);
	var clientGrpc = new Greeter.GreeterClient(channel);

	var response = await clientGrpc.SayHelloAsync(
	 new HelloRequest { Name = "GreeterClient managed" }, callOptions);

	return response.Message;
}
</pre><p>The following ApiTokenInMemoryClient can be used to get an access token from a secure token server.</p><pre class="brush: csharp; title: ; notranslate" title="">using IdentityModel.Client;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net.Http;
using System.Threading.Tasks;

namespace SecureGrpc.ManagedClient
{
    public class ApiTokenInMemoryClient
    {
        private readonly ILogger&lt;ApiTokenInMemoryClient&gt; _logger;
        private readonly HttpClient _httpClient;
        private readonly IOptions&lt;AuthConfigurations&gt; _authConfigurations;

        private class AccessTokenItem
        {
            public string AccessToken { get; set; } = string.Empty;
            public DateTime ExpiresIn { get; set; }
        }

        private ConcurrentDictionary&lt;string, AccessTokenItem&gt; _accessTokens = new ConcurrentDictionary&lt;string, AccessTokenItem&gt;();

        public ApiTokenInMemoryClient(
            IOptions&lt;AuthConfigurations&gt; authConfigurations,
            IHttpClientFactory httpClientFactory,
            ILoggerFactory loggerFactory)
        {
            _authConfigurations = authConfigurations;
            _httpClient = httpClientFactory.CreateClient();
            _logger = loggerFactory.CreateLogger&lt;ApiTokenInMemoryClient&gt;();
        }

        public async Task&lt;string&gt; GetApiToken(string api_name, string api_scope, string secret)
        {
            if (_accessTokens.ContainsKey(api_name))
            {
                var accessToken = _accessTokens.GetValueOrDefault(api_name);
                if (accessToken.ExpiresIn &gt; DateTime.UtcNow)
                {
                    return accessToken.AccessToken;
                }
                else
                {
                    // remove
                    _accessTokens.TryRemove(api_name, out AccessTokenItem accessTokenItem);
                }
            }

            _logger.LogDebug($"GetApiToken new from STS for {api_name}");

            // add
            var newAccessToken = await getApiToken( api_name,  api_scope,  secret);
            _accessTokens.TryAdd(api_name, newAccessToken);

            return newAccessToken.AccessToken;
        }

        private async Task&lt;AccessTokenItem&gt; getApiToken(string api_name, string api_scope, string secret)
        {
            try
            {
                var disco = await HttpClientDiscoveryExtensions.GetDiscoveryDocumentAsync(
                    _httpClient, 
                    _authConfigurations.Value.StsServer);

                if (disco.IsError)
                {
                    _logger.LogError($"disco error Status code: {disco.IsError}, Error: {disco.Error}");
                    throw new ApplicationException($"Status code: {disco.IsError}, Error: {disco.Error}");
                }

                var tokenResponse = await HttpClientTokenRequestExtensions.RequestClientCredentialsTokenAsync(_httpClient, new ClientCredentialsTokenRequest
                {
                    Scope = api_scope,
                    ClientSecret = secret,
                    Address = disco.TokenEndpoint,
                    ClientId = api_name
                });

                if (tokenResponse.IsError)
                {
                    _logger.LogError($"tokenResponse.IsError Status code: {tokenResponse.IsError}, Error: {tokenResponse.Error}");
                    throw new ApplicationException($"Status code: {tokenResponse.IsError}, Error: {tokenResponse.Error}");
                }

                return new AccessTokenItem
                {
                    ExpiresIn = DateTime.UtcNow.AddSeconds(tokenResponse.ExpiresIn),
                    AccessToken = tokenResponse.AccessToken
                };
                
            }
            catch (Exception e)
            {
                _logger.LogError($"Exception {e}");
                throw new ApplicationException($"Exception {e}");
            }
        }
    }
}

</pre><p><strong>Links</strong></p><p><a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth</a></p><p><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests</a></p><div id="jp-post-flair" class="sharedaddy sd-like-enabled sd-sharing-enabled"><h3 class="jp-relatedposts-headline"><em>Related</em></h3></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>