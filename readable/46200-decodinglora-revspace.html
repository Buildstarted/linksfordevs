<!DOCTYPE html>
<html lang="en">
<head>
    <title>
DecodingLora - RevSpace -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>DecodingLora - RevSpace</h1><div><div class="mw-parser-output"><p>This page is about understanding the LoRa RF modulation format.
</p><p>LoRa is an abbreviation of Long Range, meaning it is an radio modulation format that gives longer range than straight FSK modulation. This is achieved by a combination of methods: it uses a spread spectrum technique called Chirp Spread Spectrum (CSS) and it uses forward error coding (in combination with whitening and interleaving).
</p><p>To transmit or receive LoRa signals, you need to buy hardware that supports this modulation format.
</p><p>The goal of this project is to collect more detailed information on the LoRa modulation and packet format.
A concrete result could be that someone writes software which makes it possible to receive and decode LoRa signals with a cheap software defined radio, like rtlsdr.
</p><h2><span class="mw-headline" id="Status">Status</span></h2><ul><li>2016-05-08: can no longer get either sdrangel nor rtl-sdranglelove to compile: sdrangel needs a newer cmake than my distro provides (and building cmake from source is very cumbersome), rtl-sdrangelove needs some qt5 multimedia package that I forgot how to install</li><li>2016-02-19: ran into this patent <a rel="nofollow" class="external text" href="https://www.google.com/patents/EP2763321A1?cl=en">EP2763321</a>, it explains a lot of the details investigated here, like the symbol encoding, interleaving method</li><li>2016-02-16: can no longer get a decode to work with rtl-sdrangelove (something changed), sdrangel still works</li><li>2016-01-17: decoded a transmission from an RFM95 module in software using sdrangelove lora plugin (just use the right settings ...)</li></ul><p>Work done on decoding LoRa by other people:
</p><h2><span class="mw-headline" id="Modulation_basics">Modulation basics</span></h2><p>The LoRa modulation appears to be defined by the following basic parameters:
</p><ul><li>the bandwidth BW, meaning the difference in minimum and maximum frequency</li><li>the spreading factor SF, this is a measure for the number of bits encoded per symbol</li><li>the coding rate CR, this is a measure for the amount of forward error correction</li></ul><p>Additionally the following settings can be changed:
</p><ul><li>preamble length and SyncWord value</li><li>whether an explicit header is sent with the message, this header contains information about the parameter of the rest of the message (payload length, the CR parameter, CRC presence)</li><li>presence of a 16-bit CRC</li><li>the LowDataRateOptimization bit (DE)</li></ul><p>On the air I have seen the following waveforms:
</p><ul><li>a series of up-chirps at the start of a message (preamble), the number of up-chirps corresponds to the PreambleLength registers</li><li>two up-chirps with a chirp-phase corresponding to the contents of the SyncWord register</li><li>two down-chirps at the end of the preamble (sync-pattern)</li><li>data-chirps, these consist only of up-chirps (like the preamble), but with a jump in the "phase"/timing of the chirp. The frequency shift of this jump likely encodes one symbol representing several data bits (SF bits per symbol).</li></ul><p>One symbol has a length in time of (2^SF)/BW.
Chirps seem to have a constant chirp rate for a specific modulation setting, both when going up and down.
When the frequency of a chirp reaches the end of the band, it "wraps around" to the other side.
One chirp nominally covers the entire bandwidth BW once during one symbol time.
</p><h2><span class="mw-headline" id="Investigation">Investigation</span></h2><p>The image on the right shows the LoRa spectrogram for a short message as recorded by gqrx, when sending a 1-byte payload (with settings SF=12,BW=8,CR=4/8, implicit header).
At the bottom of the spectrogram you can see the preamble consisting of 10 up-chirps and 2 down-chirps.
At the top of the spectrogram you see the data portion of the signal, consisting solely of up-chirps.
</p><p>Since the LoRa signal is basically a single carrier being swept over a certain bandwidth in a specific way, it is possible to recover the frequency by FM demodulation of the signal generated by a Semtech chip. This allows for a more compact representation of the signal for analysis.
</p><p>The approach used on this page is to receive the LoRa signal with an inexpensive rtlsdr receiver, FM-demodulate it in SDR-application qgrx and record the resulting output in the audio application Audacity.
</p><p>Some thoughts on analysis:
</p><ul><li>For simplicity, the output length of the forward error coding parameter CR can be chosen to be equal to the symbol size SF. This way each 4-bit input nibble should result in exactly one output symbol. For example use CR=4/6 with SF=6, CR=4/7 with SF=7, CR=4/8 with SF=8,</li><li>make the payload equal to the PRNG sequence, such that the whitening effect of the PRNG is cancelled out, possibly making analysis easier.</li><li>vary the payload with a walking-bit sequence, so the shuffling order of the interleaver can be analysed.</li></ul><h3><span class="mw-headline" id="payload_contents">payload contents</span></h3><p>The image on the right shows the audio captured in audacity from an FM-demodulated LoRa-signal (with settings BW=8kHz, CR=4/8, SF=8, implicit mode, 1-byte payload), with the single-byte changed from 0x00 (top) to 0xFF (bottom).
In the highlighted area, some differences can be seen between the FM-waveforms.
</p><h3><span class="mw-headline" id="preamble_length">preamble length</span></h3><p>Some experimentation shows that when the preamble length n is set to 0 through the register interface, we still see 2 up-chirps and 2 down-chirps (plus 1/4th of a up-chirp) in the preamble on-air.
This is consistent with the preamble timing formula in the datasheet, which states that the preamble is (n + 4.25) symbols long.
</p><p>Actually the final two up-chirps in the preamble encode for the 'SyncWord'.
</p><h3><span class="mw-headline" id="sync_word">sync word</span></h3><p>Something that is not mentioned in the RFM95 datasheet, but is mentioned in the SX1276 datasheet, is the SyncWord setting in register 0x39. The datasheet mentions a default setting of 0x12 and a LoRaWAN setting of 0x34.
</p><p>Modifying this setting results in the following changes to the FM waveform just before the reverse chirps. From top to bottom: 0x00, 0x12, 0x34, 0xFF.
It seems the setting influences the "starting value" of the two chirps just before the reverse chirps.
The starting value appears to be closely related to the low nibble of the sync word (with 0xF corresponding to half the symbol time).
</p><p>This setting only has influence on the preamble/sync, there is no influence on the rest of the packet.
</p><h3><span class="mw-headline" id="CRC">CRC</span></h3><p>The datasheet suggests that CRC can be turned off and on through bit RxPayloadCrcOn (mistake in datasheet: Rx should be TX?) in register RegModemConfig2 (0x1E).
The image on the right shows the effect of turning it off (top) and on (bottom).
</p><p>Oddly enough, this doesn't seem to influence the length of the transmission.
</p><p>Settings: BW=8,CR=4/8,SF=8, 1 byte payload (0x00).
</p><h3><p>A header can be specified. This header tells the receiving end about the length of the payload, presence of CRC and coding rate of the rest of the message. The header itself is encoded with a coding rate CR=4/8.
</p><p>The image on the right shows the effect of turning it on (top) and off (bottom).
</p><p>The difference in length is about 8.4 symbols.
</p><p>Settings: BW=8,CR=4/8,SF=8, 1 byte payload (0x00).
</p></h3><h3><span class="mw-headline" id="Payload_size">Payload size</span></h3><p>The image on the right shows the FM-demodulated signal with varying payload. A payload size of 1 (0x00) on top and a payload size of 2 (0x00 0x00) on the bottom.
</p><p>Curiously, the size of the transmission is exactly the same.
</p><h3><span class="mw-headline" id="LowDataRateOptimize_bit">LowDataRateOptimize bit</span></h3><p>Register 0x26, bit 3 contains a LowDataRateOptimize setting, which should have some influence on the number of payload symbols transmitted according to the datasheets.
</p><p>The image on the right shows the effect of turning it off (top) and on (bottom)
Settings: BW=8,CR=4/8,SF=8, 1 byte payload (0x00), implicit mode, no CRC.
</p><p>The image below it shows the effect of turning it off (top) and on (bottom) with the same settings, except now a payload of 4 bytes 0x00.
</p><p>So, I see no difference in over-the-air length with payloads of 1 and 4 bytes when this bit is modified.
</p><h2><span class="mw-headline" id="The_timing_formula">The timing formula</span></h2><p>In paragraph 4.1.1.7 of the SX1276 datasheet, the time on air for a LoRa packet is discussed.
This is derived from the symbol time (2^SF / BW), the number of preamble symbols and number of payload symbols.
</p><p>A lot of information on the packet structure and the effect of certain parameters can be obtained from the formula that gives the number of payload symbols:
</p><p>Parameters:
</p><ul><li>PL: number of payload bytes</li><li>SF: spreading factor</li><li>CRC: presence of a CRC (0 if absent, 1 if present, I assume)</li><li>IH: whether the header is enabled (0 if enabled, 1 if disabled)</li><li>DE: whether low data rate optimization is on (0 if disabled, 1 if enabled)</li><li>CR: the coding rate (1 meaning 4/5 rate, 4 meaning 4/8 rate)</li></ul><p>What we can derive from this formula:
</p><ul><li>there are always at least 8 payload symbols in a packet, and these are completely independent of parameters like PL, SF, CR, etc.</li><li>the upper part of the fraction under the ceil() function expresses a number of *bits* (because PL, number of payload bytes, is multiplied by 8)</li><li>the CRC is 16 bits long</li><li>the difference in length between implicit and explicit header mode is 20 bits</li><li>the number calculated under the ceil() expresses a number of *nibbles*, since it divides by SF (number of bits/symbol) and the factor 4 (4 bits/nibble).</li><li>when low data rate optimization DE is turned on, the number of bits encoded in each symbol (nominally SF) is reduced by 2.</li></ul><h2><span class="mw-headline" id="Recordings">Recordings</span></h2><p>See <a rel="nofollow" class="external text" href="http://bertrik.sikken.nl/sdr/">here</a> for some IQ recordings of the LoRa signal.
</p><p>The filenames contain a code for the LoRa modulation setting which was used for each recording.
This should mostly be obvious. For example, a postfix of BW21CR48SF6PL64x00 means the following:
</p><ul><li>BW21: Bandwidth is approximately 21 kHz (20.8 actually)</li><li>CR48: Code rate is 4/8</li><li>SF6: Spreading factor is 6</li><li>PL64x00: Payload is 64 bytes of 0x00</li></ul><p>The files were recorded on ms windows using sdr# v1.0.0.1111 at a sample rate of 1024 kHz.
</p><h2><span class="mw-headline" id="Decoding_in_software">Decoding in software</span></h2><p>There exists a LoRa plug-in for the SDR application sdrangelove.
This plug-in is able to decode (with varying success) the payload from a LoRa message with the following settings:
</p><ul><li>BW = 8, SF = 8, CR = 4/6, DE = 1 (LowDataRateOptimization=on)</li></ul><p>The code for the SDR application sdrangelove with the LoRa plugin can be found
<a rel="nofollow" class="external text" href="https://github.com/hexameron/rtl-sdrangelove">here</a>
To build it:
</p><ul><li>get the code from github with git clone</li><li>cmake .</li><li>make</li></ul><p>Code for driving a HopeRF RFM95 module from a 3.3V 8MHz Arduino mini pro can be found
<a rel="nofollow" class="external text" href="https://github.com/bertrik/loratest">here (in loratest.ino)</a>
This code is configured with the settings mentioned earlier.
This code uses my <a rel="nofollow" class="external text" href="https://github.com/bertrik/RadioHead">clone of the RadioHead library</a> to control the RFM95.
</p><h3><span class="mw-headline" id="Algorithmic_steps">Algorithmic steps</span></h3><p>The LoRa plugin appears to perform the following steps (in this order):
</p><ul><li>decode the chirp phase</li><li>undo the whitening sequence by XORing again with the PRNG</li><li>undo the interleaving</li><li>undo the forward error coding</li></ul><h2><span class="mw-headline" id="External_links">External links</span></h2><ul><li>Datasheets:
</li><li>Background:
<ul><li>A nice explanation of the preamble and data modulation at <a rel="nofollow" class="external text" href="http://www.link-labs.com/what-is-lora/">link-labs</a></li><li>The <a rel="nofollow" class="external text" href="https://www.google.com/patents/US7791415">US7791415</a> patent, which describes mostly the structure of the transmitter side.</li><li>The <a rel="nofollow" class="external text" href="https://www.google.com/patents/EP2763321A1">EP2763321</a> patent, which describes both the general frame structure and modulation method</li><li><a rel="nofollow" class="external text" href="http://leobodnar.com/balloons/files/LoRa/LoRa-2.gif">Annotated analysis of the LoRa signal</a> by Leo Bodnar, clearly showing the preamble, preamble-end-marker and the data bits</li></ul></li><li>Tools:
<ul><li>Semtech <a rel="nofollow" class="external text" href="http://www.semtech.com/apps/filedown/down.php?file=SX1272LoRaCalculatorSetup1%271.zip">LoRa Calculator</a>, allows you to play with modulation parameters and see the impact on symbol time, sensitivity etc.</li></ul></li><li>Code:
</li></ul></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>