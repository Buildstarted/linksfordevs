<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A better way to handle authorization in ASP.NET Core &#x2013; The Reformed Programmer -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>A better way to handle authorization in ASP.NET Core – The Reformed Programmer</h1><div><div><div id="page" class="hfeed site"><a class="skip-link screen-reader-text" href="#content">Skip to content</a><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main" role="main"><article id="post-1546" class="post-1546 post type-post status-publish format-standard has-post-thumbnail hentry category-net-core category-asp-net-core"><div class="entry-content"><p class="entry-top-meta"><span class="entry-top-meta-datetime">Last Updated: September 30, 2019 | Created: December 14, 2018</span></p><p>I was asked by one of my clients to help build a fairly
large web application, and their <em>authentication</em>
(i.e. checking who is logging in) and <a><em>authorization</em></a>(i.e. what
pages/feature the logged in user can access) is very complex. From my experience
a knew that using ASP.NET’s Role-based approach wouldn’t cut it, and I found
the new ASP.NET Core policy-based approach really clever but it needed me to
write lots of (boring) policies. </p><p>In the end I created a solution for my client and this article describes the authorization part – I call it Roles-to-Permissions (the name will make more sense as you read the article). I have also build <a href="https://github.com/JonPSmith/PermissionAccessControl">an example ASP.NET Core application</a>, with all new code to support this article. This example application is quite different from my client’s system as I tap into ASP.NET Core built-in Identity system (the client’s system needed OAuth2). The example application contains about 60 lines that I copied (with my client’s permission) from the original implementation to create an open-source version (MIT licence) you can use.</p><p>This
article is part of a series on authorization in ASP.NET Core</p><h3 class="update-text" id="updatenew-articles-added-to-this-series"><strong>UPDATE:
New articles added to this series</strong><a class="anchorlink dashicons-before" href="#updatenew-articles-added-to-this-series"></a></h3><p class="update-text">There was a lot of interest in this article so I have written some follow-on articles that answer some of the comments/questions from the first two articles. <strong>If you want to add the features described in this article use the new  new, improved example application in the repo </strong><a href="https://github.com/JonPSmith/PermissionAccessControl2"><strong>PermissionAccessControl2</strong></a><strong> and look at the </strong><a href="https://www.thereformedprogrammer.net/part-7-adding-the-better-asp-net-core-authorization-code-into-your-app/"><strong>Part 7 article</strong></a><strong>.</strong></p><blockquote class="wp-block-quote"><p><em>NOTE: you can Clone the </em><a href="https://github.com/JonPSmith/PermissionAccessControl"><em>GitHub repo</em></a><em> and run locally – it uses in-memory databases so it will run anywhere. The application was written using ASP.NET Core 2.1.</em></p></blockquote><p>This is a long article, so here links to the major parts:</p><h2 id="tldr-summary">TL;DR; – summary<a class="anchorlink dashicons-before" href="#tldr-summary"></a></h2><ul><li>ASP.NET Role-based authorization system works
for systems with simple authorization rules, but it has limitations, like the
fact that you have to republish your code if you change the authorization rules.</li><li><em>Roles</em>,
with names like “Manager” or “ExternalBuyer” makes sense for users (human or external
services) as they define a “Use Case” of what the user should be able to do.</li><li>But Roles don’t work well when applied to
ASP.NET Core actions or Razor Pages. Here you need a much more fine-grained
solution, with names like “CanRequestHoliday”, “CanApproveHoliday” – I call these
<em>Permissions</em>.</li><li>The solution is to map the user’s Roles to a
group of Permissions and store these in the User’s Claims.</li><li>Then I use ASP.NET Core’s new policy-based
authorization system to check that the User’s Permissions Claims contains the
Permission placed on the action/page they want to access.</li><li>There is <a href="https://github.com/JonPSmith/PermissionAccessControl">an open-source
example ASP.NET Core application</a> to go with this article.</li></ul><h2 id="setting-the-scene-a-look-at-different-application-security-needs">Setting the Scene – a look at different application security needs<a class="anchorlink dashicons-before" href="#setting-the-scene-a-look-at-different-application-security-needs"></a></h2><p><em>If you understand ASP.NET’s
authorization and authentication features then you can skip this section.</em></p><p>There are billions of web applications and the control of
what you can do ranges for “anyone can do anything”, e.g. Google search, up to
some military systems where access needs keys, biometrics etc. When you need to
prove you are a valid user of the system, say by logging in, that is referred
to as <em>authentication</em>. Once you are
logged in then what you can do is controlled by what is called <em>authorization</em>.</p><p>Authorization breaks down into two parts: </p><ol><li>What data can I access? For instance, you can
see your personal information, but not other people’s personal information.</li><li>What features you can use? For instance, are you
allowed to change the title of a book that you can see?</li></ol><blockquote class="wp-block-quote"><p><strong><em>NOTE: This article describes a way to manage the second part, what features can you use. </em></strong></p></blockquote><p>ASP.NET MVC and now ASP.NET Core have various systems to
help with authorization and authentication. Some systems only need a simple authorization
– I could imagine a very simple e-commerce system could get away with: a) No
logged in – browsing, b) Logged in – buying, and c) Admin – Add/Remove items
for sale. This could be done using ASP.NET Role-based authentication.</p><p>But many business-to-business (B-to-B) systems have more
complex authorization needs. For instance, think of a human resources (HR)
system where people can request holiday leave and their manager has to approve
those requests – there is lot going on inside to ensure only the correct users
can use these features.</p><p>Systems like my example HR system often end up with lots of complex
authorization rules. My experience is that the ASP.NET Role-based
authentication starts to have problems implementing this type of system, which
is why I created the Roles-to-Permissions code. </p><p>Another type of application that could benefit from the
Roles-to-Permissions approach are subscription systems, where the features a
user can access depend on what subscription they paid for. The
Roles-to-Permissions approach can control the features that as user can access
based on the subscription they bought.</p><h2 id="role-authorization-what-is-it-and-what-are-its-limitations">Role authorization: what is it and what are its limitations?<a class="anchorlink dashicons-before" href="#role-authorization-what-is-it-and-what-are-its-limitations"></a></h2><p>Roles authorization has been around for years in the ASP.NET MVC application, and I have used it in a number of applications. Here is an example of a ASP.NET Core controller that can only be accessed by logged in users with either the “Staff” Role or the “Manger” role.</p><pre class="brush: csharp; title: ; notranslate" title="">[Authorize(Roles = "Staff,Manager")]
public ActionResult Index()
{
    return View(MyData);
}
</pre><p>This works for applications that have fairly simple and
well-defined Roles, like User/Admin or Staff/Manager/Admin, then Roles is a
good choice. But here are some of the problems I have found:</p><ol><li>If you have lots of roles you can end up with
long Authorize attributes, e.g.&nbsp; [Authorize(Roles
= “Staff,HrManager,BizManager,DevManage,Admin,SuperAdmin”)].</li><li>Because Authorize is an attribute then the
string has to be a constant, e.g. you can’t have $”{RoleConstants.StaffRole}”.
This means if things change you are editing strings, and you could misspell
something really easily.</li><li>The big one for me is your authorization rules
are hard-coded into your code. So, if you want to change who can access a
certain action you have to edit the appropriate Authorize attributes and
redeploy your application. </li></ol><p>My experience from previous applications using Roles-based
authorization is me constantly having to go back and edit the authorize Roles
part as I develop or refine the application. I have been looking for a better
way for some time, and my client’s requirements spurred me on to find something
better than Roles authorization.</p><h3 id="1-introducing-roles-permissions-and-modules">1. Introducing Roles, Permissions and Modules<a class="anchorlink dashicons-before" href="#1-introducing-roles-permissions-and-modules"></a></h3><p>It turns out that there is nothing wrong with the idea of a
user having Roles. A user (human or an external service) can typically can be
described by their function or department, like “Developer” or “HR”, maybe with
side Roles like “HolidayAdmin”. Think of Roles as “<a href="http://www.gatherspace.com/static/use_case_example.html">Use Cases</a>
for users. </p><p><strong><em>NOTE: In the example application I have Roles of “Staff”, “Manager”, and “Admin.</em></strong></p><p>But the problem is that Roles aren’t a good fit for the
actions in the Controllers. Each Controller action has a little part to play in
a Role, or to turn it around, a Role is made up of a series of Controller
actions that the Role allows you to access.&nbsp;
I decided I would call the authorization feature on each action a
“Permission”, and I used an Enum to define them. A permission Enum member might
be called “CanReadHoliday”, “CanRequestHoliday”, “CanApproveHoliday”, etc. </p><p><strong><em>NOTE: In the example application I have Permissions on my ColorController of “ColorRead”, “ColorCreate”, “ColorUpdate”, and “ColorDelete”.</em></strong></p><p>Now that we have permissions we can provide another feature
that of controls access to optional features, e.g. features that a user only
has based on their subscription to the service. There are many ways of handling
features but by combining optional features into the permissions makes it
simpler to setup and control. </p><p><strong><em>NOTE:&nbsp; In the example application I have Permissions called “Feature1” and “Feature2” which are mapped to Modules with the same name.</em></strong></p><h3 id="2-how-this-is-implemented">2. How this is implemented <a class="anchorlink dashicons-before" href="#2-how-this-is-implemented"></a></h3><p>Having defined my terms, I’m going to give you an overview
of the process. It consists of two parts: the login stage and the normal
accesses to the web site. The login stage is the most complex with lots of
magic goes on in the background. Its basic job is to convert the user’s Roles
into Permissions and add it to the User’s information.</p><p>I have set up my example application to store the user’s
claims in a cookie which is read in with every HTTP request and turned into a
ClaimsPrincipal, which can be accessed in ASP.NET Core by the HttpContext
property called “User”. </p><p>Here is a diagram of that login stage. It might not make a lot of sense yet, but I describe each part in the rest of the article. This diagram is to give you an overview.</p><figure class="wp-block-image"><img src="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart1.png" alt="" class="wp-image-1548" srcset="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart1.png 935w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart1-300x169.png 300w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart1-768x433.png 768w" sizes="(max-width: 935px) 100vw, 935px"></figure><p class="update-text"><strong><em>UPDATE: In article “</em></strong><a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/"><strong><em>Part 3: A better way to handle ASP.NET Core authorization – six months on</em></strong></a><strong><em>” I show a way to handle Roles via the Roles-to-Permissions database. That makes the approach more useful with other authentication approaches such a social media, AzureAd etc.</em></strong></p><p>The second part is simpler and covers what happens every time the logged-in user accesses a protected Controller action. Basically, I have a policy-based authorization with dynamic rules that checks the current User has the permission needed to execute the ASP.NET action/razor page.</p><figure class="wp-block-image"><img src="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart2.png" alt="" class="wp-image-1549" srcset="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart2.png 935w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart2-300x126.png 300w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/RolesAndPermissionsPart2-768x322.png 768w" sizes="(max-width: 935px) 100vw, 935px"></figure><blockquote class="wp-block-quote"><p><strong><em>NOTE: Don’t forget there is </em></strong><a href="https://github.com/JonPSmith/PermissionAccessControl"><strong><em>example application</em></strong></a><strong><em> if you want to look at the actual code.</em></strong></p></blockquote><p>Now I’m going to build up the Roles-to-Permissions in stages
and explain what each part does.</p><h2 id="why-i-used-enums-for-the-permissions">Why I used Enums for the Permissions<a class="anchorlink dashicons-before" href="#why-i-used-enums-for-the-permissions"></a></h2><p>One of the down-sides of using Roles is it used strings, and
I’m a little bit dyslexic. That means I can type/spell things incorrectly and
not notice. Therefore, I wanted something where intellisence would prompt me
and if I still typed it incorrectly it would be a compile error. But it turns
out there are a couple of other reasons that make using an Enum for the
permissions a good idea. Let me explain.</p><p>In a big application there could be hundreds of Permissions.
This lead to two problems:</p><ol><li>If I use Cookie Authorization there is a maximum
size of 4096 bytes for the Cookie. If I had hundreds of long strings I might
start to fill up the Cookie, and I want some room for other things like my data
authorization. If I can store the Enums permissions as a series of integers
it’s going to be much smaller than a series of strings.</li><li>Secondly, I want to help the Admin person who
needs to build the mapping from Roles to permissions. If they need to scroll
through hundreds of permission names it could be hard to work out which ones
are needed. It turns out Enum members can have attributes, so I can add extra
information to help the Admin person.</li></ol><p>So, here is part of my Permissions Enum code</p><pre class="brush: csharp; title: ; notranslate" title="">public enum Permissions
{
    //Here is an example of very detailed control over something
    [Display(GroupName = "Color", Name = "Read", Description = "Can read colors")]
    ColorRead = 0x10,
    [Display(GroupName = "Color", Name = "Create", Description = "Can create a color entry")]
    ColorCreate = 0x11,
    [Display(GroupName = "Color", Name = "Update", Description = "Can update a color entry")]
    ColorUpdate = 0x12,
    [Display(GroupName = "Color", Name = "Delete", Description = "Can delete a color entry")]
    ColorDelete = 0x13,

    [Display(GroupName = "UserAdmin", Name = "Read users", Description = "Can list User")]
    UserRead = 0x20,
    //This is an example of grouping multiple actions under one permission
    [Display(GroupName = "UserAdmin", Name = "Alter user", Description = "Can do anything to the User")]
    UserChange = 0x21,

    [Obsolete]
    [Display(GroupName = "Old", Name = "Not used", Description = "example of old permission"
    OldPermissionNotUsed = 0x40,
//... other code left out
</pre><p>The things to note are:</p><ul><li>I show two types of permissions.<ul><li>First four (lines 4 to 11) are fine-grained permissions, almost one per action.</li></ul><ul><li>Next two (lines 13 to 17) are more generic, e.g. I have a specific “UserRead”, but then one permission called “UserChange” which allows create, update, delete, lock, change password etc.</li></ul></li><li>Line 5, 7, etc. Notice that I give each enum a specific number. If you are operating a 24/7 application with a new version seamlessly replacing the old version, then the Permission numbed mustn’t change otherwise user’s Claims be wrong. That is why I give each enum a specific number. </li><li>Line 19. I also support the Obsolete attribute, which stops the Permission appearing in the listing. There are plenty of scary stories about reusing a number with unintended consequences. (Also, it you try to use something marked as Obsolete you get a warning).</li><li>Line 4 etc. I add a Display Attribute to each Permission Enum. This has useful information that I can show lots of useful information to help the person who is building a Role.</li><li>Line 4, 6, 8, 10. I “Group” permissions that are used in the same place. This makes it easier for the Admin person to find the things they want. I also number in Hex, which gives me 16 possible permissions in a Group (I tried 10 and you could go over that, so 16 is better).</li></ul><p>Here is a list of some of the Permissions in my example application listed via the Users-&gt;List Permissions nav dropdown.   </p><figure class="wp-block-image"><img src="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/ListOfEnumPermissions.png" alt="" class="wp-image-1551" srcset="https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/ListOfEnumPermissions.png 1002w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/ListOfEnumPermissions-300x187.png 300w, https://www.thereformedprogrammer.net/wp-content/uploads/2018/12/ListOfEnumPermissions-768x478.png 768w" sizes="(max-width: 1002px) 100vw, 1002px"></figure><p>And the code that produced that output (link to <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/PermissionParts/PermissionDisplay.cs">PermissionDisplay
class</a> for the whole thing)</p><pre class="brush: csharp; title: ; notranslate" title="">public static List&lt;PermissionDisplay&gt; GetPermissionsToDisplay(Type enumType) 
{
    var result = new List&lt;PermissionDisplay&gt;();
    foreach (var permissionName in Enum.GetNames(enumType))
    {
        var member = enumType.GetMember(permissionName);
        //This allows you to obsolete a permission and it won't be shown as a
        //possible option, but is still there so you won't reuse the number
        var obsoleteAttribute = member[0].GetCustomAttribute&lt;ObsoleteAttribute&gt;();
        if (obsoleteAttribute != null)
            continue;
        //If there is no DisplayAttribute then the Enum is not used
        var displayAttribute = member[0].GetCustomAttribute&lt;DisplayAttribute&gt;();
        if (displayAttribute == null)
            continue;

        //Gets the optional PaidForModule that a permission can be linked to
        var moduleAttribute = member[0].GetCustomAttribute&lt;PermissionLinkedToModuleAttribute&gt;();

        var permission = (Permissions)Enum.Parse(enumType, permissionName, false);

        result.Add(new PermissionDisplay(displayAttribute.GroupName, displayAttribute.Name, 
                displayAttribute.Description, permission, moduleAttribute?.PaidForModule.ToString()));
    }

    return result;
}
</pre><h2 id="how-to-handle-optional-paid-forfeatures">How to handle optional/paid-for
features?<a class="anchorlink dashicons-before" href="#how-to-handle-optional-paid-forfeatures"></a></h2><p>My client provides a Business-to-Business application and
plans to add new features that customers can subscribe to. One way to handle
this would be create different Roles, like “Manager”, “ManagerWithFeature1”,
“ManagerWithFeature2” or add separate Feature Roles that you have to manually
apply to a user. That works but is pretty horrible to manage, and human error
could cause problems. My preferred system is mark Permissions linked to a
paid-for feature filter them based on the User’s subscriptions. </p><p>Marking Permissions as linked to a module is easy to do with
the Enums – I just add another attribute. Here an example of Permissions linked
to a Module (see line 5).</p><pre class="brush: csharp; title: ; notranslate" title="">public enum Permissions
{
    //… other Permissions removed for clarity

    [LinkedToModule(PaidForModules.Feature1)]
    [Display(GroupName = "Features", Name = "Feature1", Description = "Can access feature1")]
    Feature1Access = 0x30,
    [LinkedToModule(PaidForModules.Feature2)]
    [Display(GroupName = "Features", Name = "Feature2", Description = "Can access feature2")]
    Feature2Access = 0x31
}
</pre><p>The paid-for modules are again represented by an Enum, but
one marked the [Flags] attribute because a user can have multiple modules that
they have subscribed to. Here is my PaidForModules Enum code</p><pre class="brush: csharp; title: ; notranslate" title="">[Flags]
public enum PaidForModules : long
{
    None = 0,
    Feature1 = 1,
    Feature2 = 2,
    Feature3 = 4
} 
</pre><p>NOTE I add “: long” to the Enum which gives me up to 64
different modules in my system.</p><p>What happens is that Permissions linked to a Module that the
user hasn’t subscribe to are filtered out when working out what permissions the
user should have – I show how later. This makes the setting up the Roles much simpler,
as you build each Role with all the Permissions that make sense for that role,
including features mapped to a paid-for module. Then, at login time, the system
will remove any Permissions the current user doesn’t have access to. That is
simpler for the Admin person and more secure for the application.</p><h2 id="how-do-i-turn-the-roles-into-a-permissions-claim">How do I turn the Roles into a Permissions Claim?<a class="anchorlink dashicons-before" href="#how-do-i-turn-the-roles-into-a-permissions-claim"></a></h2><p>I my client’s system we uses <a href="https://www.jerriepelser.com/blog/authenticate-oauth-aspnet-core-2/">0Auth2 authentication</a>, but for this example I used ASP.NET Core IdentityRole to hold the Roles that a user has. That means I can use all of the ASP.NET Core built-in Identity code to set up the Users and Roles. But how do I convert the User’s Roles to a Permissions Claim?</p><h3 class="update-text" id="update-two-improvements-added-in-later-articles"><strong>UPDATE: Two improvements added in later articles:</strong><a class="anchorlink dashicons-before" href="#update-two-improvements-added-in-later-articles"></a></h3><ol class="update-text"><li>In article called “<a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/">Part 3: A better way to handle ASP.NET Core authorization – six months on</a>” I show an easier way to turn Roles into permission claims using the UserClaimsPrincipalFactory- see <a href="https://www.thereformedprogrammer.net/a-better-way-to-handle-asp-net-core-authorization-six-months-on/#a-simpler-way-to-add-to-the-users-claims">this section</a>.</li><li>In the second version of the code in the <a href="https://github.com/JonPSmith/PermissionAccessControl2">PermissionAccessControl2 </a>repo I improved/simplified the code called by ‘OnValidatePrincipal’ and provided versions for various extra features I added. See the folder “<a href="https://github.com/JonPSmith/PermissionAccessControl2/tree/master/AuthorizeSetup">AuthorizeSetup</a>” for the code.  </li></ol><p>Again there are few ways to do it, but in the end I tapped
into an event in the Authorization Cookie called ‘OnValidatePrincipal’ (here is
a <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/TestWebApp/Startup.cs#L59-L68">link
to the lines in the example application startup class</a>). This calls the code
below, but be warned it’s pretty complex so here is a summary of the steps it goes
through:</p><ol><li>If the Claims already have the Permissions claim type then nothing to do so return quickly.</li><li>Then we get the Roles the user has from the Role Claim</li><li>I need to access my part of the database. I can’t use dependency injection, so I use the extraAuthDbContextOptions, which is a singleton that I can provide at startup.</li><li>Then I get all the permissions for all of the roles, with a Distinct to remove unnecessary duplicates.</li><li>Then I filter out any permissions that are linked to a Module that the user doesn’t have access to.</li><li>Then I add a permissions Claim containing all the Permissions the user is allowed, but packed as hex numbers in a single string so that it doesn’t take up so much room (I used Hex format as it made debugging easier).</li><li>Finally I have to create a new ClaimsPrincipal and tell ASP.NET Core to replace the current ClaimsPrincipal, plus set the all-important context.ShouldRenew&nbsp; to true, which updates the Cookie, otherwise this complex (slow) method on every HTTP request!</li></ol><pre class="brush: csharp; title: ; notranslate" title="">public async Task ValidateAsync(CookieValidatePrincipalContext context)
{
    if (context.Principal.Claims.Any(x =&gt; 
        x.Type == PermissionConstants.PackedPermissionClaimType))
        return;

    //No permissions in the claims so we need to add it
    //This is only happens once after the user has logged in
    var claims = new List&lt;Claim&gt;();
    foreach (var claim in context.Principal.Claims)
    {
        claims.Add(claim);
    }

    var usersRoles = context.Principal.Claims
        .Where(x =&gt; x.Type == ClaimTypes.Role)
        .Select(x =&gt; x.Value)
        .ToList();
    //I can't inject the DbContext here because that is dynamic, 
    //but I can pass in the database options because that is a 
    //From that I can create a valid dbContext to access the database
    using (var dbContext = new ExtraAuthorizeDbContext(_extraAuthDbContextOptions))
    {
        //This gets all the permissions, with a distinct to remove duplicates
        var permissionsForUser = await dbContext.RolesToPermissions
            .Where(x =&gt; usersRoles.Contains(x.RoleName))
            .SelectMany(x =&gt; x.PermissionsInRole)
            .Distinct()
            .ToListAsync();

        //we get the modules this user is allows to see
        var userModules =
            dbContext.ModulesForUsers
                .Find(context.Principal.Claims
                     .SingleOrDefault(x =&gt; x.Type == ClaimTypes.Name).Value)
                ?.AllowedPaidForModules ?? PaidForModules.None;
        //Now we remove permissions that are linked to modules that the user has no access to
        var filteredPermissions =
            from permission in permissionsForUser
            let moduleAttr = typeof(Permissions).GetMember(permission.ToString())[0]
                .GetCustomAttribute&lt;LinkedToModuleAttribute&gt;()
            where moduleAttr == null || userModules.HasFlag(moduleAttr.PaidForModule)
            select permission;

          //Now add it to the claim
          claims.Add(new Claim(PermissionConstants.PackedPermissionClaimType,
              filteredPermissions.PackPermissionsIntoString()));    }

    var identity = new ClaimsIdentity(claims, "Cookie");
    var newPrincipal = new ClaimsPrincipal(identity);

    context.ReplacePrincipal(newPrincipal);
    context.ShouldRenew = true;
}
</pre><h2 id="how-do-i-convert-my-permissionsinto-policy-based-authorization">How do I convert my Permissions
into Policy-based authorization?<a class="anchorlink dashicons-before" href="#how-do-i-convert-my-permissionsinto-policy-based-authorization"></a></h2><p>OK, I now have access to the Permissions via the User’
Claims, but how do I get this turned into something that ASP.NET Core can use
for authorization. This is where a .NET developer and friend, <a href="https://www.jerriepelser.com/">Jerrie Pelser</a> helped me. </p><p>When I started this project, I emailed Jerrie Pelser, who
runs the <a href="https://www.getrevue.co/profile/aspnetweekly">ASP.NET Weekly
newsletter</a> (great newsletter! Do sign up) as I know Jerrie is an expert in
authentication &amp; authorization.&nbsp; He
pointed me at a few architectural things and I also found his own article “<a href="https://www.jerriepelser.com/blog/creating-dynamic-authorization-policies-aspnet-core/">Creating
Authorization Policies dynamically with ASP.NET Core</a>” really helpful.&nbsp; Jerris’s article showed me how to build
policies dynamically, which is exactly what I need. </p><p>I’m not going to repeat Jerrie article here (use the link
above), but I will show you my PermissionHandler
that is used inside the policy to check that the current User’s Permissions
claim exists and contains the Permission on the action/Razor Page. It uses an
extension method called <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/PermissionParts/PermissionChecker.cs">ThisPermissionIsAllowed</a>
which does the check.</p><pre class="brush: csharp; title: ; notranslate" title="">public class PermissionHandler : 
    AuthorizationHandler&lt;PermissionRequirement&gt;
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context, 
        PermissionRequirement requirement)
    {
        var permissionsClaim = context.User.Claims
            .SingleOrDefault(c =&gt; 
                 c.Type == PermissionConstants.PackedPermissionClaimType);
        // If user does not have the scope claim, get out of here
        if (permissionsClaim == null)
            return Task.CompletedTask;

        if (permissionsClaim.Value
            .ThisPermissionIsAllowed(requirement.PermissionName))
            context.Succeed(requirement);

        return Task.CompletedTask;
    }
}
</pre><p>There are two other classes that are involved in making
dynamic policy-based authorisation work. Here are the links to them:</p><p>Policies are defined by strings, but as I said I hate
strings as I can make a mistake. I therefore created this very simple
HasPermission attribute which allows me to apply an Authorize attribute, but
using a Permissions Enum</p><pre class="brush: csharp; title: ; notranslate" title="">[AttributeUsage(AttributeTargets.Method 
    | AttributeTargets.Class, Inherited = false)]
public class HasPermissionAttribute : AuthorizeAttribute
{
    public HasPermissionAttribute(Permissions permission) 
       : base(permission.ToString()) { }
}
</pre><p>That’s pretty simple, but it means I get intellisence when I
am adding the Permission.</p><h2 id="putting-it-all-together">Putting it all together<a class="anchorlink dashicons-before" href="#putting-it-all-together"></a></h2><p>So, we have the Permissions in the code and we can apply
them using our HasPermissionAttribute to each action we want to protect via
authorization. Here is one action taken from the ColorController in my example
application.</p><pre class="brush: csharp; title: ; notranslate" title="">[HasPermission(Permissions.ColorRead)]
public ActionResult Index()
{
    return View(MyData);
}
</pre><p>We also need to add two tables to whatever database your
application uses. The two EF Core entity classes are:</p><p>Once the application is up and running an Admin-type user
has to:</p><ol><li>Create some roles, e.g. “Staff”, “Manager”, etc.
using ASP.NET Core Identity code.</li><li>Create matching RoleToPermissions for each of
the roles, specifying what Permissions map to each Role.</li></ol><p>Then, for every new user an Admin person (or some automatic
subscription code) has to:</p><ul><li>Create the user (if an invite-only type
application)</li><li>Add the correct Roles and ModulesForUser for
that new user.</li></ul><p>Once that is done all the code I have shown you takes over.
The user logs in, gets the Permissions and what they can access is managed by ASP.NET
Core’s policy-based authentication. </p><h2 id="things-i-didnt-cover-elsewhere">Things I didn’t cover elsewhere<a class="anchorlink dashicons-before" href="#things-i-didnt-cover-elsewhere"></a></h2><p>There are a few things I didn’t cover in detail, but here
are links to the items:</p><ul><li>Startup. The important parts about registering
things are shown in <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/TestWebApp/Startup.cs#L60-L73">highlighted
lines in this link to the Startup class</a>.&nbsp;
(NOTE: I built the application with ASP.NET Core 2.1, but I know the
Identity parts are changing in 2.2, so you might have to update the code I put
in the Startup class for newer versions of ASP.NET Core).</li><li>You don’t need to use ASP.NET Core Identity
system at all – I said the client’s version uses an external authentication
system. You just have to create a Roles-to-User table so you can assign Roles
to each user.</li><li>I didn’t cover how I Packed/Unpacked the
Permissions. You can find the Extension methods for doing that in <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/PermissionParts/PermissionPackers.cs">PermissionPackers</a>.</li><li>You might want to check for a permission in your
razor pages to show/hide links. I created a simple method in the <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/TestWebApp/RolesToPermissions/PermissionExtensions.cs">PermissionsExtension</a>
class, and used it in the <a href="https://github.com/JonPSmith/PermissionAccessControl/blob/master/TestWebApp/Views/Shared/_Layout.cshtml#L49-L52">_Layout.cshtml</a>
Razor page.</li></ul><h2 id="conclusion">Conclusion<a class="anchorlink dashicons-before" href="#conclusion"></a></h2><p>Well that is a long article so well done by getting to the
end. I have described an authentication I have built that handles complex authentication
rules while being (relatively) easy to understand and manage via the Admin
staff. Sure, if you have hundreds of Permissions it’s not to be hard setting up
the initial RolesToPermissions, but the Admin has a lot of information to help
them.</p><p>For me the Roles-to-Permissions approach solves a lot of problems I had in older systems I built using ASP.NET MVC Roles. I have to write some more code, but it makes it a) easier to change the authorization rules and b) helps the Admin person manage applications with lots of Roles/Permissions. I hope it helps you and makes you think of better ways of building better authentication systems for your projects.</p><p class="update-text"><strong>The new code and articles add more features, and more especially make the code easier to copy into your own application. See article called “Adding the “</strong><a href="https://www.thereformedprogrammer.net/part-7-adding-the-better-asp-net-core-authorization-code-into-your-app/"><strong>better ASP.NET Core authorization” code into your app</strong></a><strong>” which gives you a step by step tutorial on how to add the features in this and later articles into your own code.</strong></p><h2 id="further-reading">Further reading<a class="anchorlink dashicons-before" href="#further-reading"></a></h2><p><strong><em>Happy coding. PS. Don’t forget to sign up to Jerrie Pelser’s, </em></strong><a href="https://www.getrevue.co/profile/aspnetweekly"><strong><em>ASP.NET Weekly newsletter</em></strong></a><strong><em> if you are interested in ASP.NET or Entity Framework. It is the most important newsletter I get </em></strong></p></div></article></main></div></div></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>