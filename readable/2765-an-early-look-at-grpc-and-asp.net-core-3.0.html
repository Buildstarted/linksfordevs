<!DOCTYPE html>
<html lang="en">
<head>
    <title>
An Early Look at gRPC and ASP.NET Core 3.0 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>An Early Look at gRPC and ASP.NET Core 3.0</h1><div><div id="pryc-wp-acctp-original-content"><p>In this post, I want to introduce my very early experience (after a few hours of experimentation) of gRPC and ASP.NET Core 3.0. I’ve conducted some experiments as part of our quarterly Madgex hack day. This will be an introductory post so I don’t expect to show everything in fine detail. This is intended to give an overview of how the main pieces fit together and I’ll hopefully then dive into the details in future posts.</p><p>If you want to explore the sample code for this post you can find it on my <a href="https://github.com/stevejgordon/gRPCBasicSample" target="_blank" rel="noopener">GitHub account</a>.&nbsp;</p><h2>What is gRPC?</h2><p>gRPC is a schema-first framework initially created by Google. It supports service to service communication over HTTP/2 connections. It uses the Protobuf wire transfer serialisation for lightweight, fast messaging between the services. As more and more of us build interconnected microservices it can sometimes be a pain using REST as our protocol over HTTP for such purposes. REST was designed for human-readable data transfer and often results in a fair amount of boiler-plate code on both the client and server services to implement.</p><p>gRPC allows us to define our message schema and “contract” up front using Protocol Buffers. This file is then used to automatically generate much of the client and server code on our behalf. It is an interesting technology and looks well placed to become a popular choice when working with microservices. For my hack day project, I wanted to take it for a quick spin and see if I could get a client and server working over gRPC.</p><blockquote><p><em><strong>NOTE: The information in this post is therefore based on early code and has the potential to change during the remaining previews and after release. If you’re reading this in the distant future you may want to look for updated blog posts from me!</strong></em></p></blockquote><h2>Getting Started</h2><p>Microsoft is actively contributing to the “<a href="https://github.com/grpc/grpc-dotnet" target="_blank" rel="noopener">gRPC for .NET</a>” repository to support gRPC in the ASP.NET Core 3.0 timeframe. Currently, this is a work in progress, there is no formal NuGet package available and it depends on some features not yet available in the current ASP.NET Core 3.0 preview 2 release.</p><p>To support working with the newest bits, I found that I first needed to download the latest “preview 3&nbsp;“daily build using the links provided on <a href="https://github.com/dotnet/core-sdk/blob/master/README.md#installers-and-binaries" target="_blank" rel="noopener">GitHub</a>.</p><del>With the SDK installed, I created a solution in the Visual Studio 2019 preview to begin hacking around. After cloning the <a href="https://github.com/grpc/grpc-dotnet">grpc-dotnet repo</a> I copied the code from the <a href="https://github.com/grpc/grpc-dotnet/tree/master/src/Grpc.AspNetCore.Server" target="_blank" rel="noopener">Grpc.AspNetCore.Server</a> folder into a .NET Core 3.0 library project. As there’s no NuGet package that I have found so far this was the quickest way to get up and running.</del><p><em><strong>Update: There is actually a <a href="https://www.nuget.org/packages/Grpc.AspNetCore.Server/0.1.19-pre1" target="_blank" rel="noopener">NuGet package</a> available which we can reference to avoid the step of manually adding the Grpc.AspNetCore.Server code. I’ll update the sample csproj files to reflect this below.</strong></em></p><p>My hack day project was then heavily based off of the <a href="https://github.com/grpc/grpc-dotnet/tree/master/examples" target="_blank" rel="noopener">gRPC samples</a> in the repository.</p><p>The sample “domain” for my hack was to develop a basic client data API which would be exposed as a gRPC server.</p><h2>Creating the Protobuf Service Descriptor</h2><p>gRPC uses a .proto (Protobuf) file to define the shape of your service contract. This contains the “schema” for the messages that will be sent between the exposed services.</p><p>My initial proto file looks like this:</p><p>For now, I’ve defined a single RPC service interface called GetProperty. This accepts a PropertyRequest and returns a PropertyReply which are defined underneath the service.</p><p>Messages are defined using scalar types by providing the type, a name and then a unique number for the field. These uniquely identify the fields as they’ll appear in the binary message format and should not change once defined.</p><p>For example, my PropertyRequest message has a single string value called “propertyId” and I’ve assigned it a value of 1.</p><h2>Creating the Server</h2><p>The next step is to create an ASP.NET Core 3.0 server which will use code&nbsp;automatically generated from the proto file to reduce the amount of code we need to add. We can stub out the functionality over the generated code, which handles the serialisation and communication.</p><p>I created a standard ASP.NET Core 3.0 API project and then updated the csproj file in line with the available example in the grpc-dotnet repo.</p><p>Without diving too deep this references the .proto file and the Grpc.Tools library in order to support the code generation work.</p><p>The next step is create a class derived from the generate code base class which once completed looks like this:</p><p>You can see the using statement in line 4 which matches the name of the package as defined in the proto file.</p><p>A static class ClientProperty has been generated which includes a sub-class called ClientPropertyBase which is what we derive from.</p><p>I can then override the base GetProperty method, which is so named because the proto file defines a service which includes that interface. It accepts a PropertyRequest type and returns a Task&lt;PropertyReply&gt;. Both of these have been code generated for me based on the proto file.</p><p>The only code I need to add here is the logic for fulfilling the request. In this sample, I have an&nbsp;in-memory store of some basic test data which I query using MediatR. It’s not too important how those bits work and you can code this however you need.</p><p>The program.cs for this API looks like this:</p><p>This using the new ASP.NET Core 3.0 generic host flow to register a web host which uses Kestrel. Kestrel is set up to listen on HTTP2 on port 50051.</p><p>The final bit I’ll show is the Startup class which looks like this:</p><p>This calls the AddGrpc extension on the IServiceCollection, available for now due to the Grpc.AspNetCore.Server code I copied in. Later this will be built in a NuGet library.</p><p>It then uses the new ASP.NET Core 3.0 routing middleware to map a GrpcService route to the PropertyService. This will allow the server to handle the gRPC requests.</p><h2>Creating the Client</h2><p>To send request to the server I created a basic .NET Core console app client. The csproj file for this also had a reference to the proto file so that the client code could be generated.</p><p>The only code needed lives in the Main method in this sample:</p><p>First we establish a gRPC channel to the server. For this sample I’m using insecure communication. I’ll show how SSL can be applied in a future post.</p><p>I then create a ClientPropertyClient which is a class created by the code gen process based on the proto file.</p><p>I can then call methods on the client which map to the methods as defined in the proto file. I simply create a PropertyRequest object (again, the class is from generated code) and send it via the client.</p><p>Here I write out the values from the PropertyResponse object to the console. Good enough for now!</p><p>I also handle a <strong>RpcException</strong> which is thrown if the server sends a NotFound status for example. I’ve not explored this too deeply so there may be better approaches to achieve this.</p><p>And that’s basically it. I can fire up the server and then fire the client up which will send a request over HTTP2 and gRPC. Awesome!</p><h2>Summary</h2><p>This has been a high-level overview of gRPC, after I’ve only spent a few hours learning how it works. I hope it serves to show one of the big benefits of the gRPC proto file which is the fact that we have to write very little boiler-plate code. There are no Controllers to define and even the models can be easily generated for both the client and server. On the client side, I don’t need to construct HTTP requests and fire them. I can simply make a call to a code generated client method, passing a simple request message.</p><p>As part of my&nbsp;hack I’ve also spent some time trying out the streaming capabilities of gRPC and working with a basic Node.js client. I’ll explore these in more detail in future posts.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>