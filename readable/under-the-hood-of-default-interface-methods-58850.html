<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Under the hood of &#x201C;Default Interface Methods&#x201D; - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Under the hood of &#x201C;Default Interface Methods&#x201D; - linksfor.dev(s)"/>
    <meta property="article:author" content="Matt Warren"/>
    <meta property="og:description" content="&#x27;Default Implementations in Interfaces&#x27;, sometimes referred to as just &#x27;Default Interface Methods&#x27; (DIM) appeared in C# 8. In case you&#x27;ve never heard of the feature, here&#x27;s some links to get you started:"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://mattwarren.org/2020/02/19/Under-the-hood-of-Default-Interface-Methods/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Under the hood of &#x201C;Default Interface Methods&#x201D;</title>
<div class="readable">
        <h1>Under the hood of &#x201C;Default Interface Methods&#x201D;</h1>
            <div>by Matt Warren</div>
            <div>Reading time: 20-26 minutes</div>
        <div>Posted here: 23 Feb 2020</div>
        <p><a href="https://mattwarren.org/2020/02/19/Under-the-hood-of-Default-Interface-Methods/">https://mattwarren.org/2020/02/19/Under-the-hood-of-Default-Interface-Methods/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
  
  <p><span>19 Feb 2020 - 3380 words</span></p><h2 id="background">Background</h2>

<p>‘Default Implementations in Interfaces’, sometimes referred to as just ‘Default Interface Methods’ (DIM) appeared in C# 8. In case you’ve never heard of the feature, here’s some links to get you started:</p>

<ul>
  <li><a href="https://devblogs.microsoft.com/dotnet/default-implementations-in-interfaces/">Default implementations in interfaces</a> (official <em>announcement</em>)</li>
  <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods">Default Interface Methods</a> (C# Language Proposal), here’s some notable sections:
    <ul>
      <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods#diamond-inheritance-and-classes-closed">Diamond inheritance and classes</a></li>
      <li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods#interface-methods-vs-structs-closed">Interface methods vs structs</a></li>
      <li><a href="https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-19.md#structs-and-default-implementations">Structs and default implementations</a></li>
    </ul>
  </li>
  <li><a href="https://github.com/dotnet/csharplang/issues/52">Champion “default interface methods”</a> (including links for ‘Language Design Meeting’ notes)</li>
  <li><a href="https://docs.microsoft.com/en-gb/dotnet/csharp/tutorials/default-interface-methods-versions">Tutorial: Update interfaces with default interface methods in C# 8.0</a></li>
</ul>

<p>Also, there are quite a few other blogs posts discussing this feature, but as you can see opinion is split on whether it’s useful or not:</p>

<ul>
  <li><a href="https://www.infoq.com/articles/default-interface-methods-cs8/">Default Interface Methods in C# 8</a></li>
  <li><a href="https://www.codejourney.net/2019/02/csharp-8-default-interface-methods/">C# 8: Default Interface Methods Implementation</a></li>
  <li><a href="https://daveaglick.com/posts/default-interface-members-what-are-they-good-for">Default Interface Members, What Are They Good For?</a></li>
  <li><a href="https://gunnarpeipman.com/csharp-interface-default-implementations/">C# 8: Default implementations in interfaces</a></li>
  <li><a href="https://www.talkingdotnet.com/default-implementations-in-interfaces-in-c-sharp-8/">Interfaces in C# 8.0 gets a makeover</a></li>
  <li><a href="https://stu.dev/csharp8-doing-unsupported-things/#default-interface-members">C# 8.0 and .NET Standard 2.0 - Doing Unsupported Things</a></li>
  <li><a href="https://jeremybytes.blogspot.com/2019/09/interfaces-in-c-8-are-bit-of-mess.html">Interfaces in C# 8 are a Bit of a Mess</a></li>
  <li><a href="https://www.reddit.com/r/dotnet/comments/asq3jl/the_most_controversial_c_80_feature_default/">The most controversial C# 8.0 feature: Default Interface Methods Implementation (Reddit discussion)</a></li>
</ul>

<hr>

<p>But this post isn’t about what they are, how you can use them or if they’re useful or not. Instead we will be exploring how ‘Default Interface Methods’ work <em>under-the-hood</em>, looking at what the .NET Core Runtime has to do to make them work and how the feature was developed.</p>

<hr>

<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#background">Background</a></li>
  <li><a href="#development-timeline-and-prs">Development Timeline and PRs</a>
    <ul>
      <li><a href="#initial-work-prototype-and-timeline">Initial work, Prototype and Timeline</a></li>
      <li><a href="#interesting-prs-done-after-the-prototype-newest---oldest">Interesting PR’s done after the prototype (newest -&gt; oldest)</a></li>
      <li><a href="#bug-fixes-done-since-the-prototype-newest---oldest">Bug fixes done since the Prototype (newest -&gt; oldest)</a></li>
      <li><a href="#possible-future-work"><em>Possible</em> future work</a></li>
    </ul>
  </li>
  <li><a href="#default-interface-methods-in-action">Default Interface Methods ‘in action’</a></li>
  <li><a href="#enabling-methods-on-an-interface">Enabling Methods on an Interface</a></li>
  <li><a href="#resolving-the-method-dispatch">Resolving the Method Dispatch</a></li>
  <li><a href="#analysis-of-finddefaultinterfaceimplementation">Analysis of <code>FindDefaultInterfaceImplementation(..)</code></a></li>
  <li><a href="#diamond-inheritance-problem">Diamond Inheritance Problem</a></li>
  <li><a href="#summary">Summary</a></li>
</ul>

<hr>

<h2 id="development-timeline-and-prs">Development Timeline and PRs</h2>

<p>First of all, there are a few places you can go to get a ‘high-level’ understanding of what was done:</p>

<ul>
  <li><a href="https://github.com/dotnet/coreclr/projects/6">GitHub Project for Default Interface Methods</a></li>
  <li>List of <a href="https://github.com/dotnet/coreclr/pulls?q=is%3Aclosed+is%3Apr+project%3Adotnet%2Fcoreclr%2F6+sort%3Acreated-asc">all the PRs done during the Project</a></li>
  <li>To see which parts of the runtime are affected, you can <a href="https://github.com/dotnet/runtime/search?q=FEATURE_DEFAULT_INTERFACES">search for ‘FEATURE_DEFAULT_INTERFACES’</a> in the .NET (Core) Runtime source code as the entire feature is behind a #define.</li>
  <li>In addition, you can see the corresponding work being done in Mono, <a href="https://github.com/mono/mono/issues/6961">Epic: Default Interface Implementation #6961</a> and <a href="https://github.com/mono/mono/issues/11267">Update default interfaces support #11267</a></li>
</ul>

<h3 id="initial-work-prototype-and-timeline">Initial work, Prototype and Timeline</h3>

<ul>
  <li>The entire prototype is split across several PRs, running from <strong>March - July 2017</strong>:
    <ul>
      <li><a href="https://github.com/dotnet/coreclr/pull/10505">Default Interface Method Prototype #10505</a></li>
      <li><a href="https://github.com/dotnet/coreclr/pull/10818">More update for default interface methods #10818</a></li>
      <li><a href="https://github.com/dotnet/coreclr/pull/11693">More update in /dev/defaultintf #11693</a></li>
      <li><a href="https://github.com/dotnet/coreclr/pull/11940">Add RuntimeFeature detection for default interface method #11940</a></li>
      <li><a href="https://github.com/dotnet/coreclr/pull/12753">Finalize override lookup algorithm #12753</a></li>
    </ul>
  </li>
  <li>All the initial work was merged into master in <strong>December 2017</strong> in <a href="https://github.com/dotnet/coreclr/pull/15370">Merge dev/defaultintf to master #15370</a></li>
  <li>The entire feature was turned on by default in <strong>March 2019</strong> in <a href="https://github.com/dotnet/coreclr/pull/23225">Enable FeatureDefaultInterfaces unconditionally #23225</a></li>
  <li>It was then <a href="https://devblogs.microsoft.com/dotnet/default-implementations-in-interfaces/">announced/released</a> in <strong>May 2019</strong>.</li>
</ul>

<h3 id="interesting-prs-done-after-the-prototype-newest---oldest">Interesting PR’s done after the prototype (newest -&gt; oldest)</h3>

<p>Once the prototype was merged in, there was additional <em>feature</em> work done to ensure that DIM’s worked across different scenarios:</p>

<ul>
  <li><a href="https://github.com/dotnet/coreclr/pull/25770">Use native code slot for default interface methods #25770</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/23313">Allow reabstraction of default interface methods #23313</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/22295">Throw the right exception when interface dispatch is ambiguous #22295</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/21355">Implement two pass algorithm for variant interface dispatch #21355</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/16257">Make it possible to Reflection.Emit default interface methods #16257</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/16034">Fix reflection to work with default interface methods #16034</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/15925">Stop treating all calls to instance interface methods as callvirt #15925</a></li>
  <li><a href="https://github.com/dotnet/runtime/issues/9601">[Default Interfaces] Edit and Continue #9601</a></li>
</ul>

<h3 id="bug-fixes-done-since-the-prototype-newest---oldest">Bug fixes done since the Prototype (newest -&gt; oldest)</h3>

<p>In addition, there were various bugs fixes done to ensure that existing parts of the CLR played nicely with DIMs:</p>

<ul>
  <li><a href="https://github.com/dotnet/coreclr/pull/23970">Block usage of default interfaces feature in COM scenarios #23970</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/23032">Remove legacy behavior around non-virtual interface calls #23032</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/22464">Fix constrained call corner cases #22464</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/22427">Fix delegate creation for default interface methods on structs #22427</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/21525">Fix stack walking and reporting of default interface methods #21525</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/20458">Allow supressing exceptions in diamond inheritance cases #20458</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/20404">Handle generics in methodimpls for default interface methods #20404</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/15979">Do not devirtualize shared default interface methods #15979</a></li>
  <li><a href="https://github.com/dotnet/coreclr/pull/15978">Catch ambiguous interface method resolution exceptions #15978</a></li>
</ul>

<h3 id="possible-future-work"><em>Possible</em> future work</h3>

<p>Finally, there’s no guarantee if or when this will be done, but here are the remaining issues associated with the project:</p>

<ul>
  <li><a href="https://github.com/dotnet/runtime/issues/9588">Support for default interface method devirtualization #9588</a></li>
  <li><a href="https://github.com/dotnet/runtime/issues/9556">Debugger support #9556</a></li>
  <li><a href="https://github.com/dotnet/runtime/issues/9552">Interfaces implemented by arrays #9552</a></li>
  <li><a href="https://github.com/dotnet/runtime/issues/9490">Support constrained interface calls on value types #9490</a></li>
  <li><a href="https://github.com/dotnet/runtime/issues/9479">Add support for default interfaces in type generator #9479</a></li>
</ul>

<hr>

<h2 id="default-interface-methods-in-action">Default Interface Methods ‘in action’</h2>

<p>Now that we’ve seen what was done, let’s look at what that all means, starting with this code that simply demonstrates ‘Default Interface Methods’ in action:</p>

<div><div><pre><code><span>interface</span> <span>INormal</span> <span>{</span>
    <span>void</span> <span>Normal</span><span>();</span>
<span>}</span>

<span>interface</span> <span>IDefaultMethod</span> <span>{</span>
    <span>void</span> <span>Default</span><span>()</span> <span>=&gt;</span> <span>WriteLine</span><span>(</span><span>"IDefaultMethod.Default"</span><span>);</span>
<span>}</span>

<span>class</span> <span>CNormal</span> <span>:</span> <span>INormal</span> <span>{</span>
    <span>public</span> <span>void</span> <span>Normal</span><span>()</span> <span>=&gt;</span> <span>WriteLine</span><span>(</span><span>"CNormal.Normal"</span><span>);</span>
<span>}</span>

<span>class</span> <span>CDefault</span> <span>:</span> <span>IDefaultMethod</span> <span>{</span>
    <span>// Nothing to do here!</span>
<span>}</span>

<span>class</span> <span>CDefaultOwnImpl</span> <span>:</span> <span>IDefaultMethod</span> <span>{</span>
    <span>void</span> <span>IDefaultMethod</span><span>.</span><span>Default</span><span>()</span> <span>=&gt;</span> <span>WriteLine</span><span>(</span><span>"CDefaultOwnImpl.IDefaultMethod.Default"</span><span>);</span>
<span>}</span>

<span>// Test out the Normal/DefaultMethod Interfaces</span>
<span>INormal</span> <span>iNormal</span> <span>=</span> <span>new</span> <span>CNormal</span><span>();</span>
<span>iNormal</span><span>.</span><span>Normal</span><span>();</span> <span>// prints "CNormal.Normal"</span>

<span>IDefaultMethod</span> <span>iDefault</span> <span>=</span> <span>new</span> <span>CDefault</span><span>();</span>
<span>iDefault</span><span>.</span><span>Default</span><span>();</span> <span>// prints "IDefaultMethod.Default"</span>

<span>IDefaultMethod</span> <span>iDefaultOwnImpl</span> <span>=</span> <span>new</span> <span>CDefaultOwnImpl</span><span>();</span>
<span>iDefaultOwnImpl</span><span>.</span><span>Default</span><span>();</span> <span>// prints "CDefaultOwnImpl.IDefaultMethod.Default"</span>
</code></pre></div></div>

<p>The first way we can understand how they are implemented is by using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.type.getinterfacemap?view=netframework-4.8#examples"><code>Type.GetInterfaceMap(Type)</code></a> (which actually <a href="https://github.com/dotnet/coreclr/issues/15645">had to be fixed to work with DIMs</a>), this can be done with code like this:</p>

<div><div><pre><code><span>private</span> <span>static</span> <span>void</span> <span>ShowInterfaceMapping</span><span>(</span><span>Type</span> <span>@implemetation</span><span>,</span> <span>Type</span> <span>@interface</span><span>)</span> <span>{</span>
    <span>InterfaceMapping</span> <span>map</span> <span>=</span> <span>@implemetation</span><span>.</span><span>GetInterfaceMap</span><span>(</span><span>@interface</span><span>);</span>
    <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>$"</span><span>{</span><span>map</span><span>.</span><span>TargetType</span><span>}</span><span>: GetInterfaceMap(</span><span>{</span><span>map</span><span>.</span><span>InterfaceType</span><span>}</span><span>)"</span><span>);</span>
    <span>for</span> <span>(</span><span>int</span> <span>counter</span> <span>=</span> <span>0</span><span>;</span> <span>counter</span> <span>&lt;</span> <span>map</span><span>.</span><span>InterfaceMethods</span><span>.</span><span>Length</span><span>;</span> <span>counter</span><span>++)</span> <span>{</span>
        <span>MethodInfo</span> <span>im</span> <span>=</span> <span>map</span><span>.</span><span>InterfaceMethods</span><span>[</span><span>counter</span><span>];</span>
        <span>MethodInfo</span> <span>tm</span> <span>=</span> <span>map</span><span>.</span><span>TargetMethods</span><span>[</span><span>counter</span><span>];</span>
        <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>$"   </span><span>{</span><span>im</span><span>.</span><span>DeclaringType</span><span>}</span><span>::</span><span>{</span><span>im</span><span>.</span><span>Name</span><span>}</span><span> --&gt; </span><span>{</span><span>tm</span><span>.</span><span>DeclaringType</span><span>}</span><span>::</span><span>{</span><span>tm</span><span>.</span><span>Name</span><span>}</span><span> (</span><span>{(</span><span>im</span> <span>==</span> <span>tm</span> <span>?</span> <span>"same"</span> <span>:</span> <span>"different"</span><span>)}</span><span>)"</span><span>);</span>
        <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"       MethodHandle 0x{0:X} --&gt; MethodHandle 0x{1:X}"</span><span>,</span>
            <span>im</span><span>.</span><span>MethodHandle</span><span>.</span><span>Value</span><span>.</span><span>ToInt64</span><span>(),</span> <span>tm</span><span>.</span><span>MethodHandle</span><span>.</span><span>Value</span><span>.</span><span>ToInt64</span><span>());</span>
        <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"       FunctionPtr  0x{0:X} --&gt; FunctionPtr  0x{1:X}"</span><span>,</span>
            <span>im</span><span>.</span><span>MethodHandle</span><span>.</span><span>GetFunctionPointer</span><span>().</span><span>ToInt64</span><span>(),</span> <span>tm</span><span>.</span><span>MethodHandle</span><span>.</span><span>GetFunctionPointer</span><span>().</span><span>ToInt64</span><span>());</span>
    <span>}</span>
    <span>Console</span><span>.</span><span>WriteLine</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>Which gives the following output:</p>

<pre><code>//ShowInterfaceMapping(typeof(CNormal), @interface: typeof(INormal));
//ShowInterfaceMapping(typeof(CDefault), @interface: typeof(IDefaultMethod));
//ShowInterfaceMapping(typeof(CDefaultOwnImpl), @interface: typeof(IDefaultMethod));

TestApp.CNormal: GetInterfaceMap(TestApp.INormal)
   TestApp.INormal::Normal --&gt; TestApp.CNormal::Normal (different)
       MethodHandle 0x7FF993916A80 --&gt; MethodHandle 0x7FF993916B10
       FunctionPtr  0x7FF99385FC50 --&gt; FunctionPtr  0x7FF993861880

TestApp.CDefault: GetInterfaceMap(TestApp.IDefaultMethod)
   TestApp.IDefaultMethod::Default --&gt; TestApp.IDefaultMethod::Default (same)
       MethodHandle 0x7FF993916BD8 --&gt; MethodHandle 0x7FF993916BD8
       FunctionPtr  0x7FF99385FC78 --&gt; FunctionPtr  0x7FF99385FC78

TestApp.CDefaultOwnImpl: GetInterfaceMap(TestApp.IDefaultMethod)
   TestApp.IDefaultMethod::Default --&gt; TestApp.CDefaultOwnImpl::TestApp.IDefaultMethod.Default (different)
       MethodHandle 0x7FF993916BD8 --&gt; MethodHandle 0x7FF993916D10
       FunctionPtr  0x7FF99385FC78 --&gt; FunctionPtr  0x7FF9938663A0
</code></pre>

<p>So here we can see that in the case of <code>IDefaultMethod</code> interface on the <code>CDefault</code> class the interface and method implementations are the <em>same</em>. As you can see, in the other scenarios the interface method maps to a <em>different</em> method implementation.</p>

<p>But lets look at bit lower, making use of WinDBG and the <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/sos-dll-sos-debugging-extension">SOS extension</a> to get a peek into the internal ‘data structures’ that the runtime uses.</p>

<p>First, lets take a look at the <code>MethodTable</code> (<code>dumpmt</code>) for the <code>INormal</code> interface:</p>

<div><div><pre><code>&gt; dumpmt -md 00007ff8bcc31dd8
EEClass:         00007FF8BCC2C420
Module:          00007FF8BCC0F788
Name:            TestApp.INormal
mdToken:         0000000002000002
File:            C:\DefaultInterfaceMethods\TestApp\bin\Debug\netcoreapp3.0\TestApp.dll
BaseSize:        0x0
ComponentSize:   0x0
Slots in VTable: 1
Number of IFaces in IFaceMap: 0
--------------------------------------
MethodDesc Table
           Entry       MethodDesc    JIT Name
00007FF8BCB70580 00007FF8BCC31DC8   NONE TestApp.INormal.Normal()
</code></pre></div></div>

<p>So we can see that the interface has an entry for the <code>Normal()</code> method, as expected, but lets look in more detail at the <code>MethodDesc</code> (<code>dumpmd</code>):</p>

<div><div><pre><code>&gt; dumpmd 00007FF8BCC31DC8                                    
Method Name:          TestApp.INormal.Normal()               
Class:                00007ff8bcc2c420                       
MethodTable:          00007ff8bcc31dd8                       
mdToken:              0000000006000001                       
Module:               00007ff8bcc0f788                       
IsJitted:             no                                     
Current CodeAddr:     ffffffffffffffff                       
Version History:                                             
  ILCodeVersion:      0000000000000000                       
  ReJIT ID:           0                                      
  IL Addr:            0000000000000000                       
     CodeAddr:           0000000000000000  (MinOptJitted)    
     NativeCodeVersion:  0000000000000000 
</code></pre></div></div>

<p>So whilst the method exists in the interface definition, it’s clear that the method has not been jitted (<code>IsJitted: no</code>) and in fact it never will, as it can never be executed.</p>

<p>Now lets compare that output with the one for the <code>IDefaultMethod</code> interface, again the <code>MethodTable</code> (<code>dumpmt</code>) and the  <code>MethodDesc</code> (<code>dumpmd</code>):</p>

<div><div><pre><code>&gt; dumpmt -md 00007ff8bcc31e68
EEClass:         00007FF8BCC2C498
Module:          00007FF8BCC0F788
Name:            TestApp.IDefaultMethod
mdToken:         0000000002000003
File:            C:\DefaultInterfaceMethods\TestApp\bin\Debug\netcoreapp3.0\TestApp.dll
BaseSize:        0x0
ComponentSize:   0x0
Slots in VTable: 1
Number of IFaces in IFaceMap: 0
--------------------------------------
MethodDesc Table
           Entry       MethodDesc    JIT Name
00007FF8BCB70590 00007FF8BCC31E58    JIT TestApp.IDefaultMethod.Default()

&gt; dumpmd 00007FF8BCC31E58
Method Name:          TestApp.IDefaultMethod.Default()
Class:                00007ff8bcc2c498
MethodTable:          00007ff8bcc31e68
mdToken:              0000000006000002
Module:               00007ff8bcc0f788
IsJitted:             yes
Current CodeAddr:     00007ff8bcb765c0
Version History:
  ILCodeVersion:      0000000000000000
  ReJIT ID:           0
  IL Addr:            0000000000000000
     CodeAddr:           00007ff8bcb765c0  (MinOptJitted)
     NativeCodeVersion:  0000000000000000
</code></pre></div></div>

<p>Here we see something very different, the <code>MethodDesc</code> entry in the <code>MethodTable</code> actually has jitted, executable code associated with it.</p>

<hr>

<h2 id="enabling-methods-on-an-interface">Enabling Methods on an Interface</h2>

<p>So we’ve seen that ‘default interface methods’ are wired up by the runtime, but how does that happen?</p>

<p>Firstly, it’s very illuminating to look at the initial prototype of the feature in <a href="https://github.com/dotnet/coreclr/pull/10505/">CoreCLR PR #10505</a>, because we can understand at the lowest level what the feature is actually enabling, from <a href="https://github.com/dotnet/coreclr/pull/10505/files#diff-711c484c34d9ba3361552c3f2e1a4246">/src/vm/classcompat.cpp</a>:</p>

<p><a href="https://mattwarren.org/images/2020/02/Default%20Interface%20Methods%20-%20Relaxing%20class%20constraints.png"><img src="https://mattwarren.org/images/2020/02/Default%20Interface%20Methods%20-%20Relaxing%20class%20constraints.png" alt="Default Interface Methods - Relaxing class constraints"></a></p>

<p>Here we see why DIM didn’t require any changes to the .NET <a href="https://en.wikipedia.org/wiki/Common_Intermediate_Language">‘Intermediate Language’ (IL)</a> op-codes, instead <strong>they are enabled by relaxing a previous restriction</strong>. Before this change, you weren’t able to add ‘<em>virtual, non-abstract</em>’ or ‘<em>non-virtual</em>’ methods to an interface:</p>

<ul>
  <li>“Virtual Non-Abstract Interface Method.” (<code>BFA_VIRTUAL_NONAB_INT_METHOD</code>)</li>
  <li>“Nonvirtual Instance Interface Method.” (<code>BFA_NONVIRT_INST_INT_METHOD</code>)</li>
</ul>

<p>This ties in with the <em>proposed</em> changes to the <a href="https://www.ecma-international.org/publications/standards/Ecma-335.htm">ECMA-335 specification</a>, from the <a href="https://github.com/dotnet/coreclr/blob/release/3.1/Documentation/design-docs/default-interface-methods.md">‘Default interface methods’ design doc</a>:</p>

<blockquote>
  <p>The major changes are:</p>

  <ul>
    <li><strong>Interfaces are now allowed to have instance methods (both virtual and non-virtual). Previously we only allowed abstract virtual methods.</strong>
      <ul>
        <li>Interfaces obviously still can’t have instance fields.</li>
      </ul>
    </li>
    <li>Interface methods are allowed to MethodImpl other interface methods the interface requires (but we require the MethodImpls to be final to keep things simple) - i.e. an interface is allowed to provide (or override) an implementation of another interface’s method</li>
  </ul>
</blockquote>

<p>However, just allowing ‘<em>virtual, non-abstract</em>’ or ‘<em>non-virtual</em>’ methods to exist on an interface is only the start, the runtime then needs to allow code to call those methods and that is far harder!</p>

<hr>

<h2 id="resolving-the-method-dispatch">Resolving the Method Dispatch</h2>

<p>In .NET, since version 2.0, all interface methods calls have taken place via a mechanism known as <a href="https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/virtual-stub-dispatch.md">Virtual Stub Dispatch</a>:</p>

<blockquote>
  <p>Virtual stub dispatching (VSD) is the technique of using <strong>stubs for virtual method invocations instead of the traditional virtual method table</strong>. In the past, interface dispatch required that interfaces had process-unique identifiers, and that every loaded interface was added to a global interface virtual table map. This requirement meant that all interfaces and all classes that implemented interfaces had to be restored at runtime in NGEN scenarios, causing significant startup working set increases. <strong>The motivation for stub dispatching was to eliminate much of the related working set, as well as distribute the remaining work throughout the lifetime of the process.</strong></p>

  <p>Although it is possible for VSD to dispatch both virtual instance and interface method calls, <strong>it is currently used only for interface dispatch.</strong></p>
</blockquote>

<p>For more information I recommend reading the section on <a href="https://lukasatkinson.de/2018/interface-dispatch/#slotmaps">C#’s slotmaps</a> in the excellent article on ‘Interface Dispatch’ by <a href="https://twitter.com/latkde">Lukas Atkinson</a>.</p>

<p>So, to make DIM work, the runtime has to wire up any ‘default methods’, so that they integrate with the ‘virtual stub dispatch’ mechanism. We can see this in action by looking at the call stack from the hand-crafted assembly stub (<code>ResolveWorkerAsmStub</code>) all the way down to <code>FindDefaultInterfaceImplementation(..)</code> which finds the correct method, given an interface (<code>pInterfaceMD</code>) and the default method to call (<code>pInterfaceMT</code>):</p>

<div><div><pre><code>- coreclr.dll!MethodTable::FindDefaultInterfaceImplementation(MethodDesc *pInterfaceMD, MethodTable *pInterfaceMT, MethodDesc **ppDefaultMethod, int allowVariance, int throwOnConflict) Line 6985	C++
- coreclr.dll!MethodTable::FindDispatchImpl(unsigned int typeID, unsigned int slotNumber, DispatchSlot *pImplSlot, int throwOnConflict) Line 6851	C++
- coreclr.dll!MethodTable::FindDispatchSlot(unsigned int typeID, unsigned int slotNumber, int throwOnConflict) Line 7251	C++
- coreclr.dll!VirtualCallStubManager::Resolver(MethodTable *pMT, DispatchToken token, OBJECTREF *protectedObj, unsigned __int64 *ppTarget, int throwOnConflict) Line 2208	C++
- coreclr.dll!VirtualCallStubManager::ResolveWorker(StubCallSite *pCallSite, OBJECTREF *protectedObj, DispatchToken token, VirtualCallStubManager::StubKind stubKind) Line 1874	C++
- coreclr.dll!VSD_ResolveWorker(TransitionBlock *pTransitionBlock, unsigned __int64 siteAddrForRegisterIndirect, unsigned __int64 token, unsigned __int64 flags) Line 1683	C++
- coreclr.dll!ResolveWorkerAsmStub() Line 42	Unknown
</code></pre></div></div>

<p>If you want to explore the call-stack in more detail, you can follow the links below:</p>

<ul>
  <li><code>ResolveWorkerAsmStub</code> <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/amd64/VirtualCallStubAMD64.asm#L40">here</a>
    <ul>
      <li>This is the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/virtual-stub-dispatch.md#generic-resolver">‘Generic Resolver’</a> phase of ‘Virtual Stub Dispatch’.</li>
    </ul>
  </li>
  <li><code>VSD_ResolveWorker(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/virtualcallstub.cpp#L1683">here</a></li>
  <li><code>VirtualCallStubManager::ResolveWorker(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/virtualcallstub.cpp#L1874">here</a></li>
  <li><code>VirtualCallStubManager::Resolver(..)</code><a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/virtualcallstub.cpp#L2204">here</a></li>
  <li><code>MethodTable::FindDispatchSlot(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7459">here</a>
<code>[MethodTable::FindDispatchImpl(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7065">here</a> or <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7075">here</a></li>
  <li>Finally ending up in <code>MethodTable::FindDefaultInterfaceImplementation(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7173-L7444">here</a></li>
</ul>

<hr>

<h2 id="analysis-of-finddefaultinterfaceimplementation">Analysis of <code>FindDefaultInterfaceImplementation(..)</code></h2>

<p>So the code in <code>FindDefaultInterfaceImplementation(..)</code> is at the heart of the feature, but what does it need to do and how does it do it? This list from <a href="https://github.com/dotnet/coreclr/pull/12753">Finalize override lookup algorithm #12753</a> gives us some idea of the complexity:</p>

<blockquote>
  <ul>
    <li>properly detect diamond shape positive case (where I4 overrides both I2/I3 which both overrides I1) by keep tracking of a current list of best candidates. I went for the simplest algorithm and didn’t build any complex graph / DFS since the majority case the list of interfaces would be small, and interface dispatch cache would ensure majority of cases we don’t need to redo the (slow) dispatch. If needed we can revisit this to make it a proper topological sort.</li>
    <li>VerifyVirtualMethodsImplemented now properly validates default interface scenarios - it is happy if there is at least one implementation and early returns. It doesn’t worry about conflicting overrides, for performance reasons.</li>
    <li>NotSupportedException thrown in conflicting override scenario now has a proper error message</li>
    <li>properly supports GVM when detecting method impl overrides</li>
    <li>Revisited code that adds method impl for interfaces. added proper methodimpl validation and ensure methodimpl are virtual and final (and throw exception if it is not final)</li>
    <li>Added test scenario with method that has multiple method impl. found and fixed a bug where the slot array is not big enough when building method impls for interfaces.</li>
  </ul>
</blockquote>

<p>In addition, the ‘two-pass’ algorithm was implemented in <a href="https://github.com/dotnet/coreclr/pull/21355">Implement two pass algorithm for variant interface dispatch #21355</a>, which contains an interesting discussion of the <a href="https://github.com/dotnet/coreclr/pull/21355#discussion_r238893252">edge-cases that need to be handled</a>.</p>

<p>So onto the code, this is the high-level view of the algorithm:</p>

<ul>
  <li>Which actually starts in <code>MethodTable::FindDispatchImpl(..)</code> <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7057-L7112">here</a>, where <code>FindDefaultInterfaceImplementation</code> can be called twice:
    <ol>
      <li>First time to try and find an ‘exact match’ (<code>allowVariance</code>=false)</li>
      <li>Then if that fails, it’s called again to try and find a ‘variant match’ (<code>allowVariance</code>=true)</li>
    </ol>
  </li>
  <li>The entire <code>FindDefaultInterfaceImplementation</code> method <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7173-L7444">is here</a>, it’s fairly straight-forward and relatively easy to understand, plus there’s only ~270 LOC and they’re all very well commented. The high-level algorithm is the following:
    <ol>
      <li>Walk interface from <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7202-L7402">derived class to parent class here</a>, this is a straight-forward implementation that may me revisited <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7204-L7206">if it doesn’t scale well</a></li>
      <li>Then <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7220-L7398">scan through each class</a> looking for a match:
        <ol>
          <li>an <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7227-L7234">‘exact match’</a></li>
          <li>a <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7237-L7244">‘generic variance match’</a>, i.e. the interfaces match via ‘casting’, but ultimately have the same <code>TypeDef</code></li>
          <li>a <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7276-L7303">‘more specific interface’</a> that matches, this match is made more complicated by the fact that <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7278-L7282">‘generic instantiations’ are involved</a></li>
          <li>a <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7304-L7308">‘more specific interface’</a> matches, but without generics involved, so much simpler to calculate</li>
        </ol>
      </li>
      <li>If the previous step produced a match, double-check that it is the <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7314-L7395"><em>most</em> specific interface match seen so far</a>, by keeping a <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7198-L7200">‘candidates list’</a> and classifying each scenario as:
        <ol>
          <li>a <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7354-L7357">‘tie’ which is ignored</a>, i.e. a ‘variant match’ on the same type</li>
          <li>a <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7358-L7374">‘more specific’ match</a>, which is used to update the ‘candidates list’</li>
          <li>a <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7375-L7381">‘less-specific’ match</a>, so no need to carry on with this candidate</li>
        </ol>
      </li>
      <li>Finally, a scan is done to see if there are any conflicts <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7404-L7438">here</a>, which is acceptable when <code>allowVariance=true</code>, but otherwise <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7427">throws an exception</a></li>
      <li>That’s it, the <a href="https://github.com/dotnet/coreclr/blob/release/3.1/src/vm/methodtable.cpp#L7434-L7438">‘best-candidate’ is then returned to the caller</a> (assuming there is one)</li>
    </ol>
  </li>
</ul>

<h2 id="diamond-inheritance-problem">Diamond Inheritance Problem</h2>

<p>Finally, the ‘diamond inheritance problem’ was mentioned in a few of the PRs/Issues related to the feature, but what is it?</p>

<p>A good place to starts is one of the test cases, <a href="https://github.com/dotnet/coreclr/blob/release/3.1/tests/src/Loader/classloader/DefaultInterfaceMethods/diamondshape/diamondshape.cs">diamondshape.cs</a>. However there’s a more concise example in the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods#diamond-inheritance-and-classes-closed">C#8 Language Proposal</a>:</p>

<div><div><pre><code><span>interface</span> <span>IA</span>
<span>{</span>
    <span>void</span> <span>M</span><span>();</span>
<span>}</span>
<span>interface</span> <span>IB</span> <span>:</span> <span>IA</span>
<span>{</span>
    <span>override</span> <span>void</span> <span>M</span><span>()</span> <span>{</span> <span>WriteLine</span><span>(</span><span>"IB"</span><span>);</span> <span>}</span>
<span>}</span>
<span>class</span> <span>Base</span> <span>:</span> <span>IA</span>
<span>{</span>
    <span>void</span> <span>IA</span><span>.</span><span>M</span><span>()</span> <span>{</span> <span>WriteLine</span><span>(</span><span>"Base"</span><span>);</span> <span>}</span>
<span>}</span>
<span>class</span> <span>Derived</span> <span>:</span> <span>Base</span><span>,</span> <span>IB</span> <span>// allowed?</span>
<span>{</span>
    <span>static</span> <span>void</span> <span>Main</span><span>()</span>
    <span>{</span>
        <span>Ia</span> <span>a</span> <span>=</span> <span>new</span> <span>Derived</span><span>();</span>
        <span>a</span><span>.</span><span>M</span><span>();</span>           <span>// what does it do?</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>So the issue is which of the matching interface methods should be used, in this case <code>IB.M()</code> or <code>Base.IA.M()</code>? The resolution, as outlined in the <a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/default-interface-methods.md#diamond-inheritance-and-classes-closed">C#8 language proposal</a> was to use the <em>most specific override</em>:</p>

<blockquote>
  <p><strong><em>Closed Issue:</em></strong> Confirm the draft spec, above, for <em>most specific override</em> as it applies to mixed classes and interfaces (a class takes priority over an interface). See <a href="https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-19.md#diamonds-with-classes">https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-19.md#diamonds-with-classes</a>.</p>
</blockquote>

<p>Which ties in with the ‘more-specific’ and ‘less-specific’ steps we saw in the outline of <code>FindDefaultInterfaceImplementation</code> above.</p>

<hr>

<h2 id="summary">Summary</h2>

<p>So there you have it, an entire feature delivered end-to-end, yay for .NET (Core) being open source! Thanks to the runtime engineers for making their Issues and PRs easy to follow and for adding such great comments to their code! Also kudos to the language designers for making their proposals and meeting notes available for all to see (e.g. <a href="https://github.com/dotnet/csharplang/blob/master/meetings/2017/LDM-2017-04-19.md#diamonds-with-classes">LDM-2017-04-19</a>).</p>

<p>Whether you think they are useful or not, it’s hard to argue that ‘Default Interface Methods’ aren’t well designed and well implemented.</p>

<p>But what makes it even more unique feature is that it required the <em>compiler</em> and <em>runtime</em> teams working together to make it possible!</p>

</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>