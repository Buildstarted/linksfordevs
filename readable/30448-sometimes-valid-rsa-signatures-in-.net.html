<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Sometimes valid RSA signatures in .NET -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Sometimes valid RSA signatures in .NET</h1><div><div class="post-content" itemprop="articleBody"><p>One of the nice things about .NET Core being open source is following along with
some of the issues that people report. I tend to keep an eye on System.Security
tagged issues, since those tend to be at the intersection of things that
interest me and things I can maybe help with.</p><p>A user <a href="https://github.com/dotnet/corefx/issues/34202">filed an issue</a> where .NET Framework considered a CMS valid, and .NET
Core did not. This didn’t entirely surprise me. In the .NET Framework, the
<code class="highlighter-rouge">SignedCms</code> class is heavily backed by Windows’ handling of CMS/PKCS#7. In .NET
Core, the implementation is managed (sans the cryptography). The managed
implementation adheres somewhat strictly to the CMS specification. As other issues
have noticed, Windows’, thus .NET Framework’s, implementation was a little more
relaxed in some ways.</p><p>This turned out not to be one of those cases. The CMS part was actually working
just fine. What was failing was RSA itself. The core of the issue was that
different implementations of RSA disagreed on the RSA signature’s validity.</p><p>That seems pretty strange!</p><p>When I talk about different implementations on Windows, I am usually referring
to CAPI vs CNG, or <code class="highlighter-rouge">RSACryptoServiceProvider</code> and <code class="highlighter-rouge">RSACng</code>, respectively. For
now, I’m keeping this post to the .NET Framework. We’ll bring .NET Core in to
the discussion later.</p><p>There are two implementations because, well, Windows has two of them. CNG, or
“Cryptography API: Next Generation” is the newer of the two and is intended to
be future of cryptographic primitives on Windows. It shipped in Windows Vista,
and offers functionality that CAPI cannot do. An example of that is PSS RSA
signatures.</p><p>.NET Framework exposes these implementations as <code class="highlighter-rouge">RSACryptoServiceProvider</code> and
<code class="highlighter-rouge">RSACng</code>. They <em>should</em> be interchangable, and CNG implementations should be
used going forward. However, there is one corner case where the old, CAPI
implementation considers a signature valid while the CNG one does not.</p><p>The issue can be demonstrated like so:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">byte</span><span class="p">[]</span><span class="n">n</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="kt">byte</span><span class="p">[]</span><span class="n">e</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="kt">byte</span><span class="p">[]</span><span class="n">signature</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="p">...</span><span class="p">};</span><span class="kt">var</span><span class="n">digest</span><span class="p">=</span><span class="k">new</span><span class="kt">byte</span><span class="p">[]</span><span class="p">{</span><span class="m">0x68</span><span class="p">,</span><span class="m">0xB4</span><span class="p">,</span><span class="m">0xF9</span><span class="p">,</span><span class="m">0x26</span><span class="p">,</span><span class="m">0x34</span><span class="p">,</span><span class="m">0x31</span><span class="p">,</span><span class="m">0x25</span><span class="p">,</span><span class="m">0xDD</span><span class="p">,</span><span class="m">0x26</span><span class="p">,</span><span class="m">0x50</span><span class="p">,</span><span class="m">0x13</span><span class="p">,</span><span class="m">0x68</span><span class="p">,</span><span class="m">0xC1</span><span class="p">,</span><span class="m">0x99</span><span class="p">,</span><span class="m">0x26</span><span class="p">,</span><span class="m">0x71</span><span class="p">,</span><span class="m">0x19</span><span class="p">,</span><span class="m">0xA2</span><span class="p">,</span><span class="m">0xDE</span><span class="p">,</span><span class="m">0x81</span><span class="p">,</span><span class="p">};</span><span class="k">using</span><span class="p">(</span><span class="kt">var</span><span class="n">rsa</span><span class="p">=</span><span class="k">new</span><span class="nf">RSACng</span><span class="p">())</span><span class="p">{</span><span class="n">rsa</span><span class="p">.</span><span class="nf">ImportParameters</span><span class="p">(</span><span class="k">new</span><span class="n">RSAParameters</span><span class="p">{</span><span class="n">Modulus</span><span class="p">=</span><span class="n">n</span><span class="p">,</span><span class="n">Exponent</span><span class="p">=</span><span class="n">e</span><span class="p">});</span><span class="kt">var</span><span class="n">valid</span><span class="p">=</span><span class="n">rsa</span><span class="p">.</span><span class="nf">VerifyHash</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span><span class="n">signature</span><span class="p">,</span><span class="n">HashAlgorithmName</span><span class="p">.</span><span class="n">SHA1</span><span class="p">,</span><span class="n">RSASignaturePadding</span><span class="p">.</span><span class="n">Pkcs1</span><span class="p">);</span><span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">valid</span><span class="p">);</span><span class="p">}</span><span class="k">using</span><span class="p">(</span><span class="kt">var</span><span class="n">rsa</span><span class="p">=</span><span class="k">new</span><span class="nf">RSACryptoServiceProvider</span><span class="p">())</span><span class="p">{</span><span class="n">rsa</span><span class="p">.</span><span class="nf">ImportParameters</span><span class="p">(</span><span class="k">new</span><span class="n">RSAParameters</span><span class="p">{</span><span class="n">Modulus</span><span class="p">=</span><span class="n">n</span><span class="p">,</span><span class="n">Exponent</span><span class="p">=</span><span class="n">e</span><span class="p">});</span><span class="kt">var</span><span class="n">valid</span><span class="p">=</span><span class="n">rsa</span><span class="p">.</span><span class="nf">VerifyHash</span><span class="p">(</span><span class="n">digest</span><span class="p">,</span><span class="n">signature</span><span class="p">,</span><span class="n">HashAlgorithmName</span><span class="p">.</span><span class="n">SHA1</span><span class="p">,</span><span class="n">RSASignaturePadding</span><span class="p">.</span><span class="n">Pkcs1</span><span class="p">);</span><span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">valid</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><aside><p>Note: to avoid bloating this blog post with large signatures and RSA
keys, I omitted them. However the full example with public keys is available
<a href="https://gist.github.com/vcsjones/ab4c2327b53ed018eada76b75ef4fd99">
on GitHub here</a>.
</p></aside><p>When used with one of the curious signatures that exhibits this behavior, such
as the one in the GitHub link, the first result will be false, and the second
will be true.</p><p>Nothing jumped out at me as being problematic. The signature padding is PKCS,
the public exponent is the very typical 67,537, and the RSA key is sensible in
size.</p><p>To make it stranger, this signature came off the timestamp of Firefox’s own
signed installer. So why are the results different?</p><p>Jeremy Barton from Microsoft on .NET Core made the observation that the padding
in the RSA signature itself is incorrect, but in a way that CAPI tollerates and
CNG does not, at least by default. Let’s look at the raw signature. To do that,
we need the public key and signature on disk, and we can poke at them with OpenSSL.</p><p>Using the command:</p><div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssl rsautl <span class="nt">-verify</span><span class="nt">-in</span> sig.bin <span class="nt">-inkey</span> key.der <span class="se">\</span><span class="nt">-pubin</span><span class="nt">-hexdump</span><span class="nt">-raw</span><span class="nt">-keyform</span> der
</code></pre></div></div><p>We get the following output:</p><pre>0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00e0 - ff ff ff ff ff ff ff ff-ff ff ff 00 68 b4 f9 26
00f0 - 34 31 25 dd 26 50 13 68-c1 99 26 71 19 a2 de 81
</pre><p>This is a PKCS#1 v1.5 padded signature, as indicated by by starting with 00 01.
The digest at the end can be seen, <code class="highlighter-rouge">68 b4 f9 26 ... 19 a2 de 81</code> which matches
the digest above, so we know that the signature is for the right digest.</p><p>What is not correct in this signature is how the digest is encoded. The signature
contains the bare digest. It <em>should</em> be encoded as an ASN.1 sequence along
with the AlgorithmIdentifer of the digest:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DigestInfo ::= SEQUENCE {
	digestAlgorithm AlgorithmIdentifier,
	digest OCTET STRING
}
</code></pre></div></div><p>This goes back all the way to <a href="ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-1.asc">a document</a> (warning: link is to an ftp:// site)
written in 1993 by RSA labratories explaining how PKCS#1 v1.5 works,and was
standardized in to <a href="https://tools.ietf.org/html/rfc2313">an RFC</a> in 1998.</p><p>The RSA signature we have only contains the raw digest. It is not part of a
<code class="highlighter-rouge">DigestInfo</code>. If the digest were properly encoded, it would look something like
this:</p><pre>0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0050 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0060 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0070 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0080 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
0090 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00a0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00b0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00c0 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff
00d0 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 21 30
00e0 - 09 06 05 2b 0e 03 02 1a-05 00 04 14 68 b4 f9 26
00f0 - 34 31 25 dd 26 50 13 68-c1 99 26 71 19 a2 de 81
</pre><p>The signature now includes <code class="highlighter-rouge">DigestInfo</code> along with the OID 1.3.14.3.2.26 to
indicate that the digest is SHA1.</p><p>At this point we know what the difference is, and the original specification in
part 10.1.2 makes it fairly clear that the “data” should be a digest and should
be encoded as DigestInfo, not a bare digest.</p><p>The source of this signature is from Verisign's timestamp authority at
http://timestamp.verisign.com/​scripts/​timstamp.dll. After checking with
someone at DigiCert (now running this TSA), it was launched in May 1995.</p><p>I suspect that the TSA is old enough that the implementation was made before the
specification was complete or simply got the specification wrong and no one
noticed. Bringing this back to CNG and CAPI, CNG can validate this signatures, but you
must explicitly tell CNG that the signature does not have an object identifier.
<a href="https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-_bcrypt_pkcs1_padding_info"><code class="highlighter-rouge">BCRYPT_PKCS1_PADDING_INFO</code>’s</a> documentation has the detail there, but gist
of it is</p><blockquote><p>If there is no OID in the signature, then verification fails unless this
member is NULL.</p></blockquote><p>This would be used with <code class="highlighter-rouge">{B,N}CryptVerifySignature</code>. To bring this back around
to the .NET Framework, how do we use <code class="highlighter-rouge">RSACng</code> and give <code class="highlighter-rouge">null</code> in for the
padding algorithm? The short answer is: you cannot. If you try, you will get
an explicit <code class="highlighter-rouge">ArgumentException</code> saying that the hash algorithm name cannot be
null.</p><p>For .NET Framework, this solution “keep using <code class="highlighter-rouge">RSACryptoServiceProvider</code>”. If
you need to validate these signatures, chances are you do not need to use CNG’s
newer capabilities like PSS since these malformed signatures appear to be coming
from old systems. Higher level things like <code class="highlighter-rouge">SignedCms</code> and <code class="highlighter-rouge">SignedXml</code> use
<code class="highlighter-rouge">RSACryptoServiceProvider</code> by default, so they will continue to work.</p><p>To bring in .NET Core, the situation is a little more difficult. If you are
using <code class="highlighter-rouge">SignedCms</code> like so:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">signedCms</span><span class="p">=</span><span class="k">new</span><span class="nf">SignedCms</span><span class="p">();</span><span class="n">signedCms</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="n">File</span><span class="p">.</span><span class="nf">ReadAllBytes</span><span class="p">(</span><span class="s">"cms-with-sig.bin"</span><span class="p">));</span><span class="n">signedCms</span><span class="p">.</span><span class="nf">CheckSignature</span><span class="p">(</span><span class="k">true</span><span class="p">);</span></code></pre></div></div><p>This will start throwing when you migrate to .NET Core. .NET Core will use CNG
when run on Windows to validate RSA signatures for <code class="highlighter-rouge">SignedCms</code> and <code class="highlighter-rouge">SignedXml</code>.
This is currently not configurable, either. When used with <code class="highlighter-rouge">SignedCms</code>, it
ultimately calls the <code class="highlighter-rouge">X509Certificate2.GetRSAPublicKey()</code> extension method,
and that will <a href="https://github.com/dotnet/corefx/blob/b26339b6f6c7537875c70b5f3c8af376d0bbded5/src/System.Security.Cryptography.X509Certificates/src/Internal/Cryptography/Pal.Windows/X509Pal.PublicKey.cs#L43">always</a> return an implementation based on CNG.</p><p>If you are using <code class="highlighter-rouge">SignedCms</code> on .NET Core and need to validate a CMS that is
signed with these problematic signatures, you are currently out of luck using
in-the-box components. As far as other platforms go, both macOS and Linux
environments for .NET Core will agree with CNG - that the signature is invalid.</p><p>The good news is, these signatures are not easy to come by. So far, only the
old Verisign timestamp authority is known to have produced signatures like this.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>