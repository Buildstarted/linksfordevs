<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Lies, darn lies and sampling bias -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>Lies, darn lies and sampling bias</h1><div><div class="post-body entry-content" id="post-body-5225907021731649223" itemprop="description articleBody" xmlns="http://www.w3.org/1999/xhtml"><p>
    Sampling profiling is very powerful technique widely used across various platforms for identifying hot code (execution bottlenecks). 
</p><p>
    In Java world sampling profiling (thread stack sampling to be precise) is supported by every serious profiler.
</p><p>
    While being powerful and very handy in practice, sampling has well known weakness – sampling bias. It is real and well-known problem, though its practical impact is often being <a href="https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html">over exaggerated</a>.
</p><p>
    A picture is worth a thousand of words, so let me jump start with example.
</p><h4>Case 1</h4><p>
    Below is a simple snippet of code. This snippet is doing cryptographic hash calculation over a bunch of random strings.
</p><pre class="brush: java">import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.TimeUnit;

public class CryptoBench {

 private static final boolean trackTime = Boolean.getBoolean("trackTime");
 
 public static void main(String[] args) {
  CryptoBench test = new CryptoBench();
  while(true) {
   test.execute();
  }  
 }
 
 public void execute() {
        long N = 5 * 1000 * 1000;
        RandomStringUtils randomStringUtils = new RandomStringUtils();
        long ts = 0,tf = 0;
        long timer1 = 0;
        long timer2 = 0;
        long bs = System.nanoTime();
        for (long i = 0; i &lt; N; i++) {
         ts = trackTime ? System.nanoTime() : 0;
            String text = randomStringUtils.generate();
            tf = trackTime ? System.nanoTime() : 0;
            timer1 += tf - ts;
            ts = tf;
   crypt(text);
   tf = trackTime ? System.nanoTime() : 0;
   timer2 += tf - ts;
   ts = tf;
        }
        long bt = System.nanoTime() - bs;
        System.out.print(String.format("Hash rate: %.2f Mm/s", 0.01 * (N * TimeUnit.SECONDS.toNanos(1) / bt / 10000)));
        if (trackTime) {
         System.out.print(String.format(" | Generation: %.1f %%",  0.1 * (1000 * timer1 / (timer1 + timer2))));
         System.out.print(String.format(" | Hashing: %.1f %%", 0.1 * (1000 * timer2 / (timer1 + timer2))));
        }
        System.out.println();
 }

    public String crypt(String str) {
        if (str == null || str.length() == 0) {
            throw new IllegalArgumentException("String to encrypt cannot be null or zero length");
        }
        StringBuilder hexString = new StringBuilder();
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            md.update(str.getBytes());
            byte[] hash = md.digest();
            for (byte aHash : hash) {
                if ((0xff &amp; aHash) &lt; 0x10) {
                    hexString.append("0" + Integer.toHexString((0xFF &amp; aHash)));
                } else {
                    hexString.append(Integer.toHexString(0xFF &amp; aHash));
                }
            }
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return hexString.toString();
    }
}
</pre><a class="github" href="https://github.com/aragozin/proflab/blob/bench/cryptoprof/master/src/main/java/CryptoBench.java">code is available on github</a><p>
    Now let’s use a Visual VM (a profiler bundled with Java 8) and look how much time is actually spent in <code>CryptoBench.crypt()</code> method.
</p><a href="https://1.bp.blogspot.com/-n8Ah6x3pmSA/XIGquaemhGI/AAAAAAAAORo/MIbU2_jRSaoRc8b5csFNkstgPPzXM5baACPcBGAYYCw/s1600/image1.png" imageanchor="1"><img border="0" data-original-height="444" data-original-width="618" src="https://1.bp.blogspot.com/-n8Ah6x3pmSA/XIGquaemhGI/AAAAAAAAORo/MIbU2_jRSaoRc8b5csFNkstgPPzXM5baACPcBGAYYCw/s1600/image1.png" width="95%"></a><p>
    Something in definitely off in screenshot above!
</p><p class="b_red"><code>CryptoBench.crypt()</code>, method doing actual cryptography, is attributed only to <b>33%</b> of execution time.<br>At same time, <code>CryptoBench.execute()</code> has <b>67%</b> of self time, and that methods is doing nothing besides calling other methods.    
</p><p class="sarcasm">
   Probably I just need a cooler profiler here. /s
</p><p>
    Let’s use Java Flight Recorder for the very same case.<br>Below is screen shot from Mission Control.
</p><a href="https://3.bp.blogspot.com/-JwneD_EHsnY/XIGqucn8tDI/AAAAAAAAOR8/0MI1Q3oUM5sWTUOKYMnx51AdVZd0AtsfgCPcBGAYYCw/s1600/image2.png" imageanchor="1"><img border="0" data-original-height="504" data-original-width="608" src="https://3.bp.blogspot.com/-JwneD_EHsnY/XIGqucn8tDI/AAAAAAAAOR8/0MI1Q3oUM5sWTUOKYMnx51AdVZd0AtsfgCPcBGAYYCw/s1600/image2.png" width="95%"></a><p>
    That looks much better!
</p><p class="b_red"><code>CryptoBench.crypt()</code> is now <b>86%</b> of time our budget. Rest of time code spends in random string generation.<br>These numbers are looking more belivable to me.
</p><p>Wait, wait, wait!</p><p><code>Integer.toHexString()</code> is taking as much time as actual MD5 calculation. I cannot belive that.
</p><p>    
    Numbers are better than ones produced by VisualVM but they are still fishy enough.
</p><p class="sarcasm">
    Flight recorder is not cool enough for that task! We need really cool profiler! /s
</p><p>
    Ok, let me bring some sense into this discrepancy between tools.
</p><p>
    We were using thread stack sampling in both tools (Visual VM and Flight Recorder). Though, these tools capture stack traces differently.
</p><p>
    Visual VM is actually sampling thread dumps (via thread dump support in JVM). Thread dumps include stack traces for every application thread in JVM, regardless of whatever thread's state is (blocked, sleeping or actually executing code) and this dump is taken atomically. It reflects instant execution state of whole JVM (which is important for deadlock/contention analysis). In practice, that implies short Stop the World pause for each dump. Stop the World pause means <a href="/2012/10/safepoints-in-hotspot-jvm.html">safepoint</a> in hotspot JVM. And safepoints brings some nuances.
</p><p>
    When Visual VM requests thread dump, JVM notifies threads to suspend execution, but a thread executing Java code wouldn’t stop immediately (unless it is interpreted). The thread would continue to run until next safepoint check where it can suspend itself. Checks cost CPU cycles so they are sparse in JIT generated code.
</p><p>
    Checks are placed inside of loops and after method returns. Though, checks are omitted for loops considered “fast” by JIT compiler (typically integer indexed loops). Small methods are aggressively inlined too, hence omiting safepoint check at return. As a consequence, a hot and calculation intensive code may be optimized by JIT into single chunk of machine code which is mostly free of safepoint checks.
</p><p>
    If you are lucky, thread dump would show you a line invoking the method containing hot code. With less luck result would be even more misleading.
</p><p class="b_red">
    So in Visual VM call tree we see method <code>CryptoBench.execute()</code> at top of the stack for <b>66%</b> of samples. If we would be able to see call tree at line number granularity is would be a line calling <code>CryptoBench.crypt()</code> method.
</p><p class="sarcasm">
    Bad, ugly safepoint bias I’ve caught you red handed! /s
</p><p>
    So, how Flight Recorder does sample stacks and why numbers are different?
</p><p>
    Flight Recorder sampling doesn’t involve full thread dumps. Instead it freezes threads one by one using OS provided facilities. Once thread is frozen; we can get address of next instruction to be executed out of stack memory area. Address of instruction is converted into line number of java source code via byte code to machine code symbol map. The map is generated during JIT compilation. This is how stack trace is reconstructed.
</p><p>
    In case of Flight Recorder safepoint bias does not apply. Though results are still looking inaccurate. Why?
</p><p>
    Below is another session with Flight Recorder for the very same code.
</p><a href="https://1.bp.blogspot.com/-1eW28Lng2ik/XIGqua7lUSI/AAAAAAAAOR4/oIE9IYKAwsgcTD_6P7-2hAF9UBX6LEP4gCPcBGAYYCw/s1600/image3.png" imageanchor="1"><img border="0" data-original-height="649" data-original-width="611" src="https://1.bp.blogspot.com/-1eW28Lng2ik/XIGqua7lUSI/AAAAAAAAOR4/oIE9IYKAwsgcTD_6P7-2hAF9UBX6LEP4gCPcBGAYYCw/s1600/image3.png" width="95%"></a><p>
    Picture is different now.
</p><p class="b_red"><code>Integer.toHexString()</code> is just <b>2.25%</b> of out execution budget which is more trustworthy in my eyes.
</p><p>
    Flight Recoder has to resolve memory addresses back to reference of bytecode instruction (which is further transalted into Java source line). Mapping generated by JIT compiler is used for that purpose.
</p><p>
    Though compiler is aware that we can see thread stack trace only at safepoints. By default, only safepoint checks are mapped into bytecode instruction indexes. Flight Recorder takes execution address from stack, then it finds next address mapped to Java code in symbol table. In case of aggressive inlining, Flight Recorder can map address to whole wrong point in code.
</p><p>
    Though sampling itself is not biased by safepoints, symbol map generated by JIT compiler is.
</p><p>
    In second example, I’ve used two JVM options to force more detailed symbol maps to be generated by JIT compler. Options are below.
</p><pre class="args">-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints
</pre><p>
    More accurate, free of bias, symbol map allows Flight Recorder to produce more accurate stack traces.
</p><p>
    In our mental model, code is being executed line by line (bytecode instruction by instruction). But complier lumps bunch of methods together and generates single blob of machine code, aggressively reordering operations in the middle of process to make code faster.<br>Our mental model of line by line execution is totally broken by compiler optimization. 
</p><p>
    Though, in practice artifacts of operation reordering are not that striking as safepoint bias.
</p><p class="sarcasm">
    So Java Flight Recorder is cool, Visual VM is not. Should I make this conclusion?
</p><p>
Let me present a counter example.
</p><h4>Case 2</h4><p>
    Below is profiling reports from a differnt case.
</p><p>
    Now I’m using flame graph generated from data captured by Visual VM and Flight Recorder (with <code class="args">–XX:+DebugNonSafepoints</code>).
</p><p>
    Visual VM report
    <a href="https://2.bp.blogspot.com/-fNi4wAgvGII/XIGqvgu9w-I/AAAAAAAAOSE/L2BMlC3_dRwVbjbZLH7oqhCGX1FkRDf3ACPcBGAYYCw/s1600/sjk_flame.png" imageanchor="1"><img border="0" data-original-height="296" data-original-width="1200" src="https://2.bp.blogspot.com/-fNi4wAgvGII/XIGqvgu9w-I/AAAAAAAAOSE/L2BMlC3_dRwVbjbZLH7oqhCGX1FkRDf3ACPcBGAYYCw/s1600/sjk_flame.png" width="95%"></a></p><p>
    Flight Recorder report
    <a href="https://3.bp.blogspot.com/-fN5fdxvof9A/XIGqvaewrAI/AAAAAAAAOSA/VtYuemJZejE1hz08KN1b5H0sB3B_UyB1gCPcBGAYYCw/s1600/jfr_flame.png" imageanchor="1"><img border="0" data-original-height="232" data-original-width="1200" src="https://3.bp.blogspot.com/-fN5fdxvof9A/XIGqvaewrAI/AAAAAAAAOSA/VtYuemJZejE1hz08KN1b5H0sB3B_UyB1gCPcBGAYYCw/s1600/jfr_flame.png" width="95%"></a></p><p class="b_red">
    Both graphs are showing <code>InflaterInputStream</code> to be a bottleneck. Though Visual VM assesses time spent as <b>98%</b>, but in Flight Recorder it is just <b>47%</b>.   
</p><p>Who is right?</p><p class="b_red">
    Correct answer is <b>92%</b> (which is approximated using differential analysis).
</p><p class="sarcasm">
    My heart is broken! Flight Recorder is not a silver bullet. /s
</p><p>
    What have gone wrong?
</p><p>
    In this example, hot spot was related to JNI overhead involved with calling native code in zlib. It seems like Flight Recorder were unable reconstruct stack trace for certain samples outside of Java code and dropped these samples. Sample population was biased by native code execution. That bias has played against Flight Recorder in this case.
</p><h4>Conclusion</h4><p>
    Both profilers are doing that they intended to do. Some sort of bias is natural for almost any kind of sampling.    
</p><p>
    Each sampling profiler could be categorized by three aspects.
</p><ul><li><b>Blind spots bias</b> – which samples are excluded from data set collected by profiler.
    </li><li><b>Attractor bias</b> – how samples be attracted to specific discrete points (e.g. safe point).
    </li><li><b>Resolution</b> – unit of code which profiling data is being aggregated to (e.g. method, line number etc).
    </li></ul><p>Below is summary table for sampling methods mentioned in this article.</p><table><tbody><tr><td></td><th>Blind spot</th><th>Attractor</th><th>Resolution</th></tr><tr><th>JVM Thread Dump Sampling</th><td>non-java threads</td><td>safepoint bias</td><td>java frames only</td></tr><tr><th>Java Flight Recorder</th><td>non-java code execution</td><td>CPU pipeline bias <br>+ code to source mapping skew</td><td>java frames only</td></tr><tr><th>Java Flight Recorder <br>+ <code>DebugNonSafepoint</code></th><td>non-java code execution</td><td>CPU pipeline bias <br>+ code to source mapping skew</td><td>java frames only</td></tr></tbody></table></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>