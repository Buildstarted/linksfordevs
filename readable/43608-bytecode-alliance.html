<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Bytecode Alliance -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Bytecode Alliance</h1><div><div class="post-content e-content" itemprop="articleBody"><p><a href="https://github.com/bytecodealliance/wasmtime/">Wasmtime</a>, the WebAssembly runtime from the <a href="https://bytecodealliance.org/articles/announcing-the-bytecode-alliance">Bytecode Alliance</a>, recently added an early preview of an API for <a href="https://docs.microsoft.com/en-us/dotnet/core">.NET Core</a>, Microsoft’s free, open-source, and cross-platform application runtime. This API enables developers to programmatically load and execute WebAssembly code directly from their .NET programs.</p><p>.NET Core is already a cross-platform runtime, so why should .NET developers pay any attention to WebAssembly?</p><p>There are several reasons to be excited about WebAssembly if you’re a .NET developer, such as sharing the same executable code across platforms, being able to securely isolate untrusted code, and having a seamless interop experience with the upcoming WebAssembly interface types proposal.</p><h3 id="share-more-code-across-platforms">Share more code across platforms</h3><p>.NET assemblies can already be built for cross-platform use, but using a <em>native library</em> (for example, a library written in C or Rust) can be difficult because it requires native interop and distributing a platform-specific build of the library for each supported platform.</p><p>However, if the native library were compiled to WebAssembly, the same WebAssembly module could be used across many different platforms and programming environments, including .NET; this would simplify the distribution of the library and the applications that depend on it.</p><h3 id="securely-isolate-untrusted-code">Securely isolate untrusted code</h3><p>The .NET Framework attempted to sandbox untrusted code with technologies such as <em>Code Access Security</em> and <em>Application Domains</em>, but ultimately these failed to properly isolate untrusted code. As a result, Microsoft deprecated their use for sandboxing and ultimately removed them from .NET Core.</p><p>Have you ever wanted to load untrusted plugins in your application but couldn’t figure out a way to prevent the plugin from invoking arbitrary system calls or from directly reading your process’ memory? You can do this with WebAssembly because it was designed for the web, an environment where untrusted code executes every time you visit a website.</p><p>A WebAssembly module can only call the external functions it explicitly imports from a host environment, and may only access a region of memory given to it by the host. We can leverage this design to sandbox code in a .NET program too!</p><h3 id="improved-interoperability-with-interface-types">Improved interoperability with interface types</h3><p>The <a href="https://hacks.mozilla.org/2019/08/webassembly-interface-types/">WebAssembly interface types proposal</a> introduces a way for WebAssembly to better integrate with programming languages by reducing the amount of glue code that is necessary to pass more complex types back and forth between the hosting application and a WebAssembly module.</p><p>When support for interface types is eventually implemented by the Wasmtime for .NET API, it will enable a seamless experience for exchanging complex types between WebAssembly and .NET.</p><h2 id="diving-into-using-webassembly-from-net">Diving into using WebAssembly from .NET</h2><p>In this article we’ll dive into using a Rust library compiled to WebAssembly from .NET with the Wasmtime for .NET API, so it will help to be a little familiar with the C# programming language to follow along.</p><p>The API described here is fairly low-level. That means that there is quite a bit of glue code required for conceptually simple operations, such as passing or receiving a string value.</p><p>In the future we’ll also provide a higher-level API based on <a href="https://hacks.mozilla.org/2019/08/webassembly-interface-types/">WebAssembly interface types</a> which will significantly reduce the code required for the same operations. Using that API will enable interacting with a WebAssembly module from .NET as easily as you would a .NET assembly.</p><p>Note also that the API is still under active development and will change in backwards-incompatible ways. We’re aiming to stabilize it as we stabilize Wasmtime itself.</p><p>If you’re reading this and you aren’t a .NET developer, that’s okay! Check out the <a href="https://github.com/bytecodealliance/wasmtime-demos">Wasmtime Demos</a> repository for corresponding implementations for Python, Node.js, and Rust too!</p><h2 id="creating-the-webassembly-module">Creating the WebAssembly module</h2><p>We’ll start by building a Rust library that can be used to render <a href="https://commonmark.org/">Markdown</a> to HTML. However, instead of compiling the Rust library for your processor architecture, we’ll be compiling it to WebAssembly so we can use it from .NET.</p><p>You don’t need to be familiar with the <a href="https://www.rust-lang.org/">Rust programming language</a> to follow along, but it will help to have a Rust toolchain installed if you want to build the WebAssembly module. See the homepage for <a href="https://rustup.rs/">Rustup</a> for an easy way to install a Rust toolchain.</p><p>Additionally, we’re going to use <a href="https://github.com/bytecodealliance/cargo-wasi">cargo-wasi</a>, a command that bootstraps everything we need for Rust to target WebAssembly:</p><p>Next, clone the Wasmtime Demos repository:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/bytecodealliance/wasmtime-demos.git
cd wasmtime-demos
</code></pre></div></div><p>This repository includes the <code class="language-plaintext highlighter-rouge">markdown</code> directory that contains a Rust library. The library wraps a well-known Rust crate that can render Markdown as HTML. (<em>Note for .NET developers: a crate is like a NuGet package, in a way</em>).</p><p>Let’s build the <code class="language-plaintext highlighter-rouge">markdown</code> WebAssembly module using <code class="language-plaintext highlighter-rouge">cargo-wasi</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd markdown
cargo wasi build --release
</code></pre></div></div><p>There should now be a <code class="language-plaintext highlighter-rouge">markdown.wasm</code> file in the <code class="language-plaintext highlighter-rouge">target/wasm32-wasi/release</code> directory.</p><p>If you’re curious about the Rust implementation, open <code class="language-plaintext highlighter-rouge">src/lib.rs</code>; it contains the following:</p><div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span><span class="nn">pulldown_cmark</span><span class="p">::{</span><span class="n">html</span><span class="p">,</span><span class="n">Parser</span><span class="p">};</span><span class="k">use</span><span class="nn">wasm_bindgen</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span><span class="nd">#[wasm_bindgen]</span><span class="k">pub</span><span class="k">fn</span><span class="nf">render</span><span class="p">(</span><span class="n">input</span><span class="p">:</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span><span class="k">-&gt;</span><span class="nb">String</span><span class="p">{</span><span class="k">let</span><span class="n">parser</span><span class="o">=</span><span class="nn">Parser</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">input</span><span class="p">);</span><span class="k">let</span><span class="k">mut</span><span class="n">html_output</span><span class="o">=</span><span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span><span class="nn">html</span><span class="p">::</span><span class="nf">push_html</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="n">html_output</span><span class="p">,</span><span class="n">parser</span><span class="p">);</span><span class="k">return</span><span class="n">html_output</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>The Rust library is exporting only a single function, <code class="language-plaintext highlighter-rouge">render</code>, that takes a string (the Markdown) as input and returns a string (the rendered HTML). All of the code required to parse Markdown and translate it to HTML is provided by the <a href="https://github.com/raphlinus/pulldown-cmark">pulldown-cmark</a> crate.</p><p>Let’s step back and simply appreciate what is about to happen here. We’re taking a popular Rust crate, wrapping it with a few lines of code that exposes the functionality as a WebAssembly function, and then compiling it to a WebAssembly module that we can load from .NET regardless of the platform we’re running on. How cool is that?!</p><h3 id="peeking-under-the-hood-of-a-webassembly-module">Peeking under the hood of a WebAssembly module</h3><p>Now that we have the WebAssembly module we’re going to use, what does it need from a host to function and what functionality does it offer the host?</p><p>To figure that out, let’s disassemble the module to a textual representation using the <code class="language-plaintext highlighter-rouge">wasm2wat</code> tool from the <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a> to a file called <code class="language-plaintext highlighter-rouge">markdown.wat</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wasm2wat markdown.wasm --enable-multi-value &gt; markdown.wat
</code></pre></div></div><p><em>Note: the <code class="language-plaintext highlighter-rouge">--enable-multi-value</code> option enables support for functions that return multiple values and is required to disassemble the <code class="language-plaintext highlighter-rouge">markdown</code> module.</em></p><h4 id="what-the-module-needs-from-a-host">What the module needs from a host</h4><p>The module’s imports define what the host should provide for the module to work.</p><p>Here are the imports for the <code class="language-plaintext highlighter-rouge">markdown</code> module:</p><pre><code class="language-wasm">(import "wasi_unstable" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32)))
(import "wasi_unstable" "random_get" (func $random_get (param i32 i32) (result i32)))
</code></pre><p>This tells us that the module will need two functions from the host: <code class="language-plaintext highlighter-rouge">fd_write</code> and <code class="language-plaintext highlighter-rouge">random_get</code>. These are actually <a href="https://github.com/WebAssembly/WASI">WebAssembly System Interface</a> (WASI) functions that have well-defined behavior: <code class="language-plaintext highlighter-rouge">fd_write</code> is used to write data to a file descriptor and <code class="language-plaintext highlighter-rouge">random_get</code> will fill a buffer with random data.</p><p>Shortly we’ll implement these functions for a .NET host, but it is important to understand that <strong>this module can <em>only</em> call these functions from the host</strong>; the host gets to decide how, and even if, the functions are implemented.</p><h4 id="what-the-module-offers-a-host">What the module offers a host</h4><p>The module’s exports define what functionality it offers the host.</p><p>Here are the exports for the <code class="language-plaintext highlighter-rouge">markdown</code> module:</p><pre><code class="language-wasm">(export "memory" (memory 0))
(export "render" (func $render_multivalue_shim))
(export "__wbindgen_malloc" (func $__wbindgen_malloc))
(export "__wbindgen_realloc" (func $__wbindgen_realloc))
(export "__wbindgen_free" (func $__wbindgen_free))

...

(func $render_multivalue_shim (param i32 i32) (result i32 i32) ...)
(func $__wbindgen_malloc (param i32) (result i32) ...)
(func $__wbindgen_realloc (param i32 i32 i32) (result i32) ...)
(func $__wbindgen_free (param i32 i32) ...)
</code></pre><p>First, the module is exporting a <em>memory</em>. A WebAssembly memory is the linear address space accessible to the module; <strong>it will be the only region of memory the module can read from or write to</strong>. As the module cannot access any other region of the host’s address space directly, the exported memory is where the host will exchange data with the WebAssembly module.</p><p>Second, the module exports the <code class="language-plaintext highlighter-rouge">render</code> function we implemented in Rust. But wait a second, why does it have two parameters and return two values when the Rust implementation only has one parameter and one return value?</p><p>In Rust, both a string slice (<code class="language-plaintext highlighter-rouge">&amp;str</code>) and an owned string (<code class="language-plaintext highlighter-rouge">String</code>) are represented as an address and length (in bytes) pair when compiled to WebAssembly. Thus, the WebAssembly version of the Rust function takes an address-length pair for the markdown input string and returns an address-length pair for the rendered HTML string. Here, addresses are represented as integer offsets into the exported memory.</p><p>Note that since the Rust code returns a <code class="language-plaintext highlighter-rouge">String</code>, which is an <em>owned</em> type, the caller of <code class="language-plaintext highlighter-rouge">render</code> will be responsible for freeing the returned memory containing the rendered string.</p><p>During the implementation of the .NET host we’ll discuss the rest of the exports.</p><h2 id="creating-the-net-project">Creating the .NET project</h2><p>We will need a <a href="https://dotnet.microsoft.com/download">.NET Core SDK</a> to create a .NET Core project, so make sure you have a <strong>3.0 or later</strong> SDK installed.</p><p>Start by creating a directory for the project:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir WasmtimeDemo
cd WasmtimeDemo
</code></pre></div></div><p>Next, create a new .NET Core console project:</p><p>Finally, add a reference to the <a href="https://www.nuget.org/packages/Wasmtime">Wasmtime NuGet package</a>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dotnet add package wasmtime --version 0.8.0-preview2
</code></pre></div></div><p>That’s it! Now we’re ready to use the Wasmtime for .NET API to load and execute the <code class="language-plaintext highlighter-rouge">markdown</code> WebAssembly module.</p><h2 id="importing-net-code-from-webassembly">Importing .NET code from WebAssembly</h2><p>Importing .NET functions from WebAssembly is as simple as implementing the <a href="https://peterhuene.github.io/wasmtime.net/api/Wasmtime.IHost.html"><code class="language-plaintext highlighter-rouge">IHost</code></a> interface in .NET. This only requires a public <a href="https://peterhuene.github.io/wasmtime.net/api/Wasmtime.Instance.html"><code class="language-plaintext highlighter-rouge">Instance</code></a> property that will represent the WebAssembly module instance the host is bound to.</p><p>The <a href="https://peterhuene.github.io/wasmtime.net/api/Wasmtime.ImportAttribute.html"><code class="language-plaintext highlighter-rouge">Import</code></a> attribute is then used to mark functions and fields as imports to a WebAssembly module.</p><p>As we discussed earlier, the module requires two imports from the host: <code class="language-plaintext highlighter-rouge">fd_write</code> and <code class="language-plaintext highlighter-rouge">random_get</code>, so let’s create implementations for those functions.</p><p>Create a file named <code class="language-plaintext highlighter-rouge">Host.cs</code> in the project directory and add the following content:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span><span class="nn">System.Security.Cryptography</span><span class="p">;</span><span class="k">using</span><span class="nn">Wasmtime</span><span class="p">;</span><span class="k">namespace</span><span class="nn">WasmtimeDemo</span><span class="p">{</span><span class="k">class</span><span class="nc">Host</span><span class="p">:</span><span class="n">IHost</span><span class="p">{</span><span class="c1">// These are from the current WASI proposal.</span><span class="k">const</span><span class="kt">int</span><span class="n">WASI_ERRNO_NOTSUP</span><span class="p">=</span><span class="m">58</span><span class="p">;</span><span class="k">const</span><span class="kt">int</span><span class="n">WASI_ERRNO_SUCCESS</span><span class="p">=</span><span class="m">0</span><span class="p">;</span><span class="k">public</span><span class="n">Instance</span><span class="n">Instance</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="k">set</span><span class="p">;</span><span class="p">}</span><span class="p">[</span><span class="nf">Import</span><span class="p">(</span><span class="s">"fd_write"</span><span class="p">,</span><span class="n">Module</span><span class="p">=</span><span class="s">"wasi_unstable"</span><span class="p">)]</span><span class="k">public</span><span class="kt">int</span><span class="nf">WriteFile</span><span class="p">(</span><span class="kt">int</span><span class="n">fd</span><span class="p">,</span><span class="kt">int</span><span class="n">iovs</span><span class="p">,</span><span class="kt">int</span><span class="n">iovs_len</span><span class="p">,</span><span class="kt">int</span><span class="n">nwritten</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="n">WASI_ERRNO_NOTSUP</span><span class="p">;</span><span class="p">}</span><span class="p">[</span><span class="nf">Import</span><span class="p">(</span><span class="s">"random_get"</span><span class="p">,</span><span class="n">Module</span><span class="p">=</span><span class="s">"wasi_unstable"</span><span class="p">)]</span><span class="k">public</span><span class="kt">int</span><span class="nf">GetRandomBytes</span><span class="p">(</span><span class="kt">int</span><span class="n">buf</span><span class="p">,</span><span class="kt">int</span><span class="n">buf_len</span><span class="p">)</span><span class="p">{</span><span class="n">_random</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">Instance</span><span class="p">.</span><span class="n">Externs</span><span class="p">.</span><span class="n">Memories</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Span</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">buf_len</span><span class="p">));</span><span class="k">return</span><span class="n">WASI_ERRNO_SUCCESS</span><span class="p">;</span><span class="p">}</span><span class="k">private</span><span class="n">RNGCryptoServiceProvider</span><span class="n">_random</span><span class="p">=</span><span class="k">new</span><span class="nf">RNGCryptoServiceProvider</span><span class="p">();</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>The <code class="language-plaintext highlighter-rouge">fd_write</code> implementation simply returns an error indicating the operation isn’t supported. It is used by the module for writing errors to <code>stderr</code>, which will not happen for this example.</p><p>The <code class="language-plaintext highlighter-rouge">random_get</code> implementation fills the requested buffer with random bytes. It slices the <a href="https://peterhuene.github.io/wasmtime.net/api/Wasmtime.Memory.html#Wasmtime_Memory_Span"><code class="language-plaintext highlighter-rouge">Span</code></a> representing the entire exported memory of the module so that the .NET implementation can write <em>directly</em> to the requested buffer without having to perform any intermediate copies. The <code class="language-plaintext highlighter-rouge">random_get</code> function is being called by the implementation of <code class="language-plaintext highlighter-rouge">HashMap</code> from Rust’s standard library.</p><p>That’s all it takes to expose .NET functions to the WebAssembly module with the Wasmtime for .NET API.</p><p>However, before we can load the WebAssembly module and use it from .NET, we need to discuss how a string gets passed from the .NET host as a parameter to the <code class="language-plaintext highlighter-rouge">render</code> function.</p><h2 id="being-a-good-host">Being a good host</h2><p>Based on the exports of the module, we know it exports a <em>memory</em>. From the host’s perspective, think of a WebAssembly module’s exported memory as being granted access to the address space of a foreign process, even though the module <em>shares</em> the same process of the host itself.</p><p>If you randomly write data to a foreign address space, Bad Things Happen™ because it’s quite easy to corrupt the state of the other program and cause undefined behavior, such as a crash or the total protonic reversal of the universe. So how can a host pass data to the WebAssembly module in a safe manner?</p><p>Internally the Rust program uses a <em>memory allocator</em> to manage its memory. So, for .NET to be a good host to the WebAssembly module, it must also use the <em>same</em> memory allocator when allocating and freeing memory accessible to the WebAssembly module.</p><p>Thankfully, <a href="https://rustwasm.github.io/docs/wasm-bindgen">wasm-bindgen</a>, used by the Rust program to export itself as WebAssembly, also exported two functions for that purpose: <code class="language-plaintext highlighter-rouge">__wbindgen_malloc</code> and <code class="language-plaintext highlighter-rouge">__wbindgen_free</code>. These two functions are essentially <code class="language-plaintext highlighter-rouge">malloc</code> and <code class="language-plaintext highlighter-rouge">free</code> from C, except <code class="language-plaintext highlighter-rouge">__wbindgen_free</code> needs the size of the previous allocation in addition to the memory address.</p><p>With this in mind, let us write a simple wrapper for these exported functions in C# so we can easily allocate and free memory accessible to the WebAssembly module.</p><p>Create a file named <code class="language-plaintext highlighter-rouge">Allocator.cs</code> in the project directory and add the following content:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span><span class="nn">System</span><span class="p">;</span><span class="k">using</span><span class="nn">System.Collections.Generic</span><span class="p">;</span><span class="k">using</span><span class="nn">System.Linq</span><span class="p">;</span><span class="k">using</span><span class="nn">System.Text</span><span class="p">;</span><span class="k">using</span><span class="nn">Wasmtime.Externs</span><span class="p">;</span><span class="k">namespace</span><span class="nn">WasmtimeDemo</span><span class="p">{</span><span class="k">class</span><span class="nc">Allocator</span><span class="p">{</span><span class="k">public</span><span class="nf">Allocator</span><span class="p">(</span><span class="n">ExternMemory</span><span class="n">memory</span><span class="p">,</span><span class="n">IReadOnlyList</span><span class="p">&lt;</span><span class="n">ExternFunction</span><span class="p">&gt;</span><span class="n">functions</span><span class="p">)</span><span class="p">{</span><span class="n">_memory</span><span class="p">=</span><span class="n">memory</span><span class="p">??</span><span class="k">throw</span><span class="k">new</span><span class="nf">ArgumentNullException</span><span class="p">(</span><span class="k">nameof</span><span class="p">(</span><span class="n">memory</span><span class="p">));</span><span class="n">_malloc</span><span class="p">=</span><span class="n">functions</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">f</span><span class="p">=&gt;</span><span class="n">f</span><span class="p">.</span><span class="n">Name</span><span class="p">==</span><span class="s">"__wbindgen_malloc"</span><span class="p">)</span><span class="p">.</span><span class="nf">SingleOrDefault</span><span class="p">()</span><span class="p">??</span><span class="k">throw</span><span class="k">new</span><span class="nf">ArgumentException</span><span class="p">(</span><span class="s">"Unable to resolve malloc function."</span><span class="p">);</span><span class="n">_free</span><span class="p">=</span><span class="n">functions</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">f</span><span class="p">=&gt;</span><span class="n">f</span><span class="p">.</span><span class="n">Name</span><span class="p">==</span><span class="s">"__wbindgen_free"</span><span class="p">)</span><span class="p">.</span><span class="nf">SingleOrDefault</span><span class="p">()</span><span class="p">??</span><span class="k">throw</span><span class="k">new</span><span class="nf">ArgumentException</span><span class="p">(</span><span class="s">"Unable to resolve free function."</span><span class="p">);</span><span class="p">}</span><span class="k">public</span><span class="kt">int</span><span class="nf">Allocate</span><span class="p">(</span><span class="kt">int</span><span class="n">length</span><span class="p">)</span><span class="p">{</span><span class="k">return</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">_malloc</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="n">length</span><span class="p">);</span><span class="p">}</span><span class="k">public</span><span class="p">(</span><span class="kt">int</span><span class="n">Address</span><span class="p">,</span><span class="kt">int</span><span class="n">Length</span><span class="p">)</span><span class="nf">AllocateString</span><span class="p">(</span><span class="kt">string</span><span class="n">str</span><span class="p">)</span><span class="p">{</span><span class="kt">var</span><span class="n">length</span><span class="p">=</span><span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetByteCount</span><span class="p">(</span><span class="n">str</span><span class="p">);</span><span class="kt">int</span><span class="n">addr</span><span class="p">=</span><span class="nf">Allocate</span><span class="p">(</span><span class="n">length</span><span class="p">);</span><span class="n">_memory</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="n">str</span><span class="p">);</span><span class="k">return</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="n">length</span><span class="p">);</span><span class="p">}</span><span class="k">public</span><span class="k">void</span><span class="nf">Free</span><span class="p">(</span><span class="kt">int</span><span class="n">address</span><span class="p">,</span><span class="kt">int</span><span class="n">length</span><span class="p">)</span><span class="p">{</span><span class="n">_free</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span><span class="n">address</span><span class="p">,</span><span class="n">length</span><span class="p">);</span><span class="p">}</span><span class="k">private</span><span class="n">ExternMemory</span><span class="n">_memory</span><span class="p">;</span><span class="k">private</span><span class="n">ExternFunction</span><span class="n">_malloc</span><span class="p">;</span><span class="k">private</span><span class="n">ExternFunction</span><span class="n">_free</span><span class="p">;</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>This code looks complicated, but all it is doing is finding the needed exported functions by name from the module and wrapping them with an easier to use interface.</p><p>We’ll use this helper <code class="language-plaintext highlighter-rouge">Allocator</code> class to allocate the input string to the exported <code class="language-plaintext highlighter-rouge">render</code> function.</p><p>Now we’re ready to render some Markdown.</p><h2 id="rendering-the-markdown">Rendering the Markdown</h2><p>Open <code class="language-plaintext highlighter-rouge">Program.cs</code> in the project directory and replace it with the following content:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span><span class="nn">System</span><span class="p">;</span><span class="k">using</span><span class="nn">System.Linq</span><span class="p">;</span><span class="k">using</span><span class="nn">Wasmtime</span><span class="p">;</span><span class="k">namespace</span><span class="nn">WasmtimeDemo</span><span class="p">{</span><span class="k">class</span><span class="nc">Program</span><span class="p">{</span><span class="k">const</span><span class="kt">string</span><span class="n">MarkdownSource</span><span class="p">=</span><span class="s">"# Hello, `.NET`! Welcome to **WebAssembly** with [Wasmtime](https://wasmtime.dev)!"</span><span class="p">;</span><span class="k">static</span><span class="k">void</span><span class="nf">Main</span><span class="p">()</span><span class="p">{</span><span class="k">using</span><span class="nn">var</span><span class="n">engine</span><span class="p">=</span><span class="k">new</span><span class="nf">Engine</span><span class="p">();</span><span class="k">using</span><span class="nn">var</span><span class="n">store</span><span class="p">=</span><span class="n">engine</span><span class="p">.</span><span class="nf">CreateStore</span><span class="p">();</span><span class="k">using</span><span class="nn">var</span><span class="n">module</span><span class="p">=</span><span class="n">store</span><span class="p">.</span><span class="nf">CreateModule</span><span class="p">(</span><span class="s">"markdown.wasm"</span><span class="p">);</span><span class="k">using</span><span class="nn">var</span><span class="n">instance</span><span class="p">=</span><span class="n">module</span><span class="p">.</span><span class="nf">Instantiate</span><span class="p">(</span><span class="k">new</span><span class="nf">Host</span><span class="p">());</span><span class="kt">var</span><span class="n">memory</span><span class="p">=</span><span class="n">instance</span><span class="p">.</span><span class="n">Externs</span><span class="p">.</span><span class="n">Memories</span><span class="p">.</span><span class="nf">SingleOrDefault</span><span class="p">()</span><span class="p">??</span><span class="k">throw</span><span class="k">new</span><span class="nf">InvalidOperationException</span><span class="p">(</span><span class="s">"Module must export a memory."</span><span class="p">);</span><span class="kt">var</span><span class="n">allocator</span><span class="p">=</span><span class="k">new</span><span class="nf">Allocator</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span><span class="n">instance</span><span class="p">.</span><span class="n">Externs</span><span class="p">.</span><span class="n">Functions</span><span class="p">);</span><span class="p">(</span><span class="kt">var</span><span class="n">inputAddress</span><span class="p">,</span><span class="kt">var</span><span class="n">inputLength</span><span class="p">)</span><span class="p">=</span><span class="n">allocator</span><span class="p">.</span><span class="nf">AllocateString</span><span class="p">(</span><span class="n">MarkdownSource</span><span class="p">);</span><span class="k">try</span><span class="p">{</span><span class="kt">object</span><span class="p">[]</span><span class="n">results</span><span class="p">=</span><span class="p">(</span><span class="n">instance</span><span class="k">as</span><span class="kt">dynamic</span><span class="p">).</span><span class="nf">render</span><span class="p">(</span><span class="n">inputAddress</span><span class="p">,</span><span class="n">inputLength</span><span class="p">);</span><span class="kt">var</span><span class="n">outputAddress</span><span class="p">=</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">results</span><span class="p">[</span><span class="m">0</span><span class="p">];</span><span class="kt">var</span><span class="n">outputLength</span><span class="p">=</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">results</span><span class="p">[</span><span class="m">1</span><span class="p">];</span><span class="k">try</span><span class="p">{</span><span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">memory</span><span class="p">.</span><span class="nf">ReadString</span><span class="p">(</span><span class="n">outputAddress</span><span class="p">,</span><span class="n">outputLength</span><span class="p">));</span><span class="p">}</span><span class="k">finally</span><span class="p">{</span><span class="n">allocator</span><span class="p">.</span><span class="nf">Free</span><span class="p">(</span><span class="n">outputAddress</span><span class="p">,</span><span class="n">outputLength</span><span class="p">);</span><span class="p">}</span><span class="p">}</span><span class="k">finally</span><span class="p">{</span><span class="n">allocator</span><span class="p">.</span><span class="nf">Free</span><span class="p">(</span><span class="n">inputAddress</span><span class="p">,</span><span class="n">inputLength</span><span class="p">);</span><span class="p">}</span><span class="p">}</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>Let’s walk through what the code doing. Step-by-step, it:</p><ol><li>Creates an <a href="https://peterhuene.github.io/wasmtime.net/api/Wasmtime.Engine.html"><code class="language-plaintext highlighter-rouge">Engine</code></a>. The engine represents the Wasmtime runtime itself. The runtime is what enables loading and executing WebAssembly modules from .NET.</li><li>Then it creates a <a href="https://peterhuene.github.io/wasmtime.net/api/Wasmtime.Store.html"><code class="language-plaintext highlighter-rouge">Store</code></a>. A store is where all WebAssembly objects, such as modules and their instantiations, are kept. There can be multiple stores in an engine, but their associated objects cannot interact with one another.</li><li>Next it creates a <a href="https://peterhuene.github.io/wasmtime.net/api/Wasmtime.Module.html"><code class="language-plaintext highlighter-rouge">Module</code></a> from the <code class="language-plaintext highlighter-rouge">markdown.wasm</code> file on disk. A <code class="language-plaintext highlighter-rouge">Module</code> represents the data of the WebAssembly module itself, such as what it imports and exports. A module can have one or more <em>instantiations</em>. An instantiation is the <em>runtime</em> representation of a WebAssembly module. It compiles the module’s <em>WebAssembly</em> instructions to instructions of the <em>current CPU architecture</em>, allocates the memory accessible to the module, and binds imports from the host.</li><li>It instantiates the module using an instance of the <code class="language-plaintext highlighter-rouge">Host</code> class we implemented earlier, binding the .NET functions as imports.</li><li>Finds the memory exported by the module.</li><li>Creates an allocator and then allocates a string for the Markdown source we want to render.</li><li>Invokes the <code class="language-plaintext highlighter-rouge">render</code> function with the input string by casting the instance to <code class="language-plaintext highlighter-rouge">dynamic</code>. This is a C# feature that enables dynamic binding of functions at runtime; think of it simply as a shortcut to searching for the exported <code class="language-plaintext highlighter-rouge">render</code> function and invoking it.</li><li>Outputs the rendered HTML by reading the returned string from the exported memory of the WebAssembly module.</li><li>Finally, it frees both the input string it allocated and the returned string that the Rust program gave us to own.</li></ol><p>That’s it for the implementation; onwards to actually running the code!</p><h2 id="running-the-net-program">Running the .NET program</h2><p>Before we can run the program, we need to copy <code class="language-plaintext highlighter-rouge">markdown.wasm</code> to the project directory, as this is where we’ll run the program from. You can find the <code class="language-plaintext highlighter-rouge">markdown.wasm</code> file in the <code class="language-plaintext highlighter-rouge">target/wasm32-wasi/release</code> directory from where you built it.</p><p>From the <code class="language-plaintext highlighter-rouge">Program.cs</code> source above, we see that the program hard-coded some Markdown to render:</p><div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># Hello, `.NET`! Welcome to **WebAssembly** with [Wasmtime](https://wasmtime.dev)!</span></code></pre></div></div><p>Run the program to render it as HTML:</p><p>If everything went according to plan, this should be the result:</p><div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>Hello, <span class="nt">&lt;code&gt;</span>.NET<span class="nt">&lt;/code&gt;</span>! Welcome to <span class="nt">&lt;strong&gt;</span>WebAssembly<span class="nt">&lt;/strong&gt;</span> with <span class="nt">&lt;a</span><span class="na">href=</span><span class="s">"https://wasmtime.dev"</span><span class="nt">&gt;</span>Wasmtime<span class="nt">&lt;/a&gt;</span>!<span class="nt">&lt;/h1&gt;</span></code></pre></div></div><h2 id="whats-next-for-wasmtime-for-net">What’s next for Wasmtime for .NET?</h2><p>That was a surprisingly large amount of C# code that was necessary to implement this demo, wasn’t it?</p><p>There are two major features we have planned that will help simplify this:</p><ul><li><p><strong>Exposing Wasmtime’s WASI implementation to .NET (and other languages)</strong></p><p>In our implementation of <code class="language-plaintext highlighter-rouge">Host</code> above, we had to manually implement <code class="language-plaintext highlighter-rouge">fd_write</code> and <code class="language-plaintext highlighter-rouge">random_get</code>, which are WASI functions.</p><p>Wasmtime itself has a WASI implementation, but currently it isn’t accessible to the .NET API.</p><p>Once the .NET API can access and configure the WASI implementation of Wasmtime, there will no longer be a need for .NET hosts to provide their own implementation of WASI functions.</p></li><li><p><strong>Implementing interface types for .NET</strong></p><p>As discussed earlier, WebAssembly interface types enable a more idiomatic integration of WebAssembly with a hosting programming language.</p><p>Once the .NET API implements the interface types proposal, there shouldn’t be a need to create an <code class="language-plaintext highlighter-rouge">Allocator</code> class like the one we implemented.</p><p>Instead, functions that use types like <code class="language-plaintext highlighter-rouge">string</code> should simply work without having to write any glue code in .NET.</p></li></ul><p>The hope, then, is that this is what it might look like in the future to implement this demo from .NET:</p><div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span><span class="nn">System</span><span class="p">;</span><span class="k">using</span><span class="nn">Wasmtime</span><span class="p">;</span><span class="k">namespace</span><span class="nn">WasmtimeDemo</span><span class="p">{</span><span class="k">interface</span><span class="nc">Markdown</span><span class="p">{</span><span class="kt">string</span><span class="nf">Render</span><span class="p">(</span><span class="kt">string</span><span class="n">input</span><span class="p">);</span><span class="p">}</span><span class="k">class</span><span class="nc">Program</span><span class="p">{</span><span class="k">const</span><span class="kt">string</span><span class="n">MarkdownSource</span><span class="p">=</span><span class="s">"# Hello, `.NET`! Welcome to **WebAssembly** with [Wasmtime](https://wasmtime.dev)!"</span><span class="p">;</span><span class="k">static</span><span class="k">void</span><span class="nf">Main</span><span class="p">()</span><span class="p">{</span><span class="k">using</span><span class="nn">var</span><span class="n">markdown</span><span class="p">=</span><span class="n">Module</span><span class="p">.</span><span class="n">Load</span><span class="p">&lt;</span><span class="n">Markdown</span><span class="p">&gt;(</span><span class="s">"markdown.wasm"</span><span class="p">);</span><span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">markdown</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="n">MarkdownSource</span><span class="p">));</span><span class="p">}</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>I think we can all agree that looks so much better!</p><h2 id="thats-a-wrap">That’s a wrap!</h2><p>This is the exciting beginning of using WebAssembly outside of the web browser from many different programming environments, including Microsoft’s .NET platform.</p><p>If you’re a .NET developer, we hope you’ll join us on this journey!</p><p><em>The .NET demo code from this article can be found in the <a href="https://github.com/bytecodealliance/wasmtime-demos/tree/master/dotnet">Wasmtime Demos repository</a>.</em></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>