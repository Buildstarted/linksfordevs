<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Announcing .NET Core 3 Preview 3 | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Announcing .NET Core 3 Preview 3 | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard"/>
    <meta property="og:description" content="Today, we are announcing .NET Core 3.0 Preview 3. We would like to update you on the .NET Core 3.0 schedule and introduce you to improvements in .NET Core SDK installers, Docker containers, Range, and Index. We also have updates on the Windows Desktop and Entity Framework projects."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-3/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Announcing .NET Core 3 Preview 3 | .NET Blog</title>
<div class="readable">
        <h1>Announcing .NET Core 3 Preview 3 | .NET Blog</h1>
            <div>by Richard LanderProgram Manager,&#xA0;.NET TeamFollow Richard</div>
            <div>Reading time: 17-22 minutes</div>
        <div>Posted here: 06 Mar 2019</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-3/">https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-3/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/37f91ebe219df737566a4dc7cdd53b68?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p><p>Richard</p></div></div></div><p>March 6th, 2019</p><p>Today, we are announcing .NET Core 3.0 Preview 3. We would like to update you on the .NET Core 3.0 schedule and introduce you to improvements in .NET Core SDK installers, Docker containers, Range, and Index. We also have updates on the Windows Desktop and Entity Framework projects.</p><p><a href="https://aka.ms/netcore3download" rel="nofollow" target="_blank">Download and get started with .NET Core 3 Preview 3</a> right now on Windows, macOS and Linux.</p><p>You can see complete details of the release in the <a href="https://aka.ms/netcore3releasenotes" rel="nofollow" target="_blank">.NET Core 3 Preview 3 release notes</a>.</p><p>.NET Core 3.0 will be supported in Visual Studio 2019, Visual Studio for Mac and Visual Studio Code.</p><p>You need to enable <strong>Use previews of the .NET Core SDK</strong> to use .NET Core 3.0 with Visual Studio 2019, as described in&nbsp;<a href="https://devblogs.microsoft.com/dotnet/net-core-tooling-update-for-visual-studio-2017-version-15-9/">.NET Core tooling update</a>.</p><p>A new preview&nbsp;<a href="https://github.com/OmniSharp/omnisharp-vscode/releases/tag/v1.18.0-beta8" target="_blank">C# extension</a>&nbsp;update is available for VS Code that includes the latest C# compiler (aligned with .NET Core Preview 3 and Visual Studio 2019 Preview 4), which is required to use new C# 8.0 syntax. You need to <a href="https://github.com/OmniSharp/omnisharp-vscode/releases/tag/v1.18.0-beta8" target="_blank">download the extension</a> and then <a href="https://code.visualstudio.com/docs/editor/extension-gallery#_install-from-a-vsix" target="_blank">install it as a VSIX in VS Code</a> (VSIX install is in Extensions settings).</p><p>We recently published an update on <a href="https://devblogs.microsoft.com/dotnet/floating-point-parsing-and-formatting-improvements-in-net-core-3-0/">Floating-Point Parsing and Formatting improvements in .NET Core 3.0</a>. Please check out that post in you use floating APIs and associated mathematical operations.</p><h2>Schedule</h2><p>We have seen people asking questions about when .NET Core 3.0 will be released. They also want to know if .NET Core 3.0 will be included in Visual Studio 2019. <a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2019-release-candidate-rc-now-available/" rel="nofollow">Visual Studio 2019 RC</a> was recently released, which is part of the motivation for the questions.</p><p>We plan to ship .NET Core 3.0 in the second half of 2019. We will announce the ship date at the Build 2019 conference.</p><p>Visual Studio 2019 will be released on April 2nd. .NET Core 2.1 and 2.2 will be included in that release, just like they have been in the Visual Studio 2019 preview builds. At the point of the final .NET Core 3.0 release, we’ll announce support for a specific Visual Studio 2019 update, and .NET Core 3.0 will be included in Visual Studio 2019 from that point on.</p><p>We’re tracking to shipping .NET Core 3.0 preview releases every month. By coincidence,the previews now align with the months. We’re releasing Preview 3 today and we’re in the third month. We hope to continue that pattern until the final release.</p><h2>.NET Core SDK installers will now Upgrade in Place</h2><p>For Windows, the .NET Core SDK MSI installers will start upgrading patch versions in place. This will reduce the number of SDKs that are installed on both developer and production machines.</p><p>The upgrade policy will specifically target .NET Core SDK feature bands. Feature bands are defined in hundreds groups in the patch section of the version number. For example, <code>3.0.101</code> and <code>3.0.201</code> are versions in two different feature bands while <code>3.0.101</code> and <code>3.0.199</code> are in the same feature band.</p><p>This means when .NET Core SDK 3.0.101 becomes available and is installed, .NET Core SDK 3.0.100 will be removed from the machine if it exists. When .NET Core SDK 3.0.200 becomes available and is installed on the same machine, .NET Core SDK 3.0.101 will not be removed. In that situation, .NET Core SDK 3.0.200 will still be used by default, but .NET Core SDK 3.0.101 (or higher .1xx versions) will still be usable if it is configured for use via <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-json" rel="nofollow" target="_blank">global.json</a>.</p><p>This approach aligns with the behavior of <code>global.json</code>, which allows roll forward across patch versions, but not feature bands of the SDK. Thus, upgrading via the SDK installer will not result in errors due to a missing SDK. Feature bands also align with side by side Visual Studio installations for those users that install SDKs for Visual Studio use.</p><p>We would like feedback on the approach we’ve taken for upgrading the .NET Core SDK in place. We considered a few different policies and chose this one because it is the most conservative. We’d also like to hear if it is important to build similar experience on macOS. For Linux, we use package managers, which have an existing upgrade-in-place behavior.</p><p>For more information, please check out:</p><ul><li><a href="https://docs.microsoft.com/dotnet/core/versions/#versioning-details" rel="nofollow" target="_blank">.NET Core versioning</a></li><li><a href="https://docs.microsoft.com/dotnet/core/versions/remove-runtime-sdk-versions" rel="nofollow" target="_blank">Remove .NET Core SDK versions</a></li></ul><h2>Docker and cgroup memory Limits</h2><p>Many developers are <a href="https://devblogs.microsoft.com/dotnet/using-net-and-docker-together-dockercon-2018-update/" rel="nofollow">packaging and running their application with containers</a>. A key scenario is <a href="https://docs.docker.com/config/containers/resource_constraints/" rel="nofollow" target="_blank">limiting a container’s resources</a> such as CPU or memory. We implemented <a href="https://github.com/dotnet/coreclr/pull/10064" target="_blank">support for memory limits</a> back in 2017. Unfortunately, we found that the implementation isn’t aggressive enough to reliably stay under the configured limits and applications are still being OOM killed when memory limits are set (particular &lt;500MB). We are fixing that in .NET Core 3.0. Note that this scenario only applies if memory limits are set.</p><p>The Docker resource limits feature is built on top of <a href="https://en.wikipedia.org/wiki/Cgroups" rel="nofollow" target="_blank">cgroups</a>, which a Linux kernel feature. From a runtime perspective, we need to target cgroup primitives.</p><p>You can limit the available memory for a container with the <code>docker run -m</code> argument, as shown in the following example that creates an Alpine-based container with a 4MB memory limit (and then <a href="https://stackoverflow.com/questions/42187085/check-mem-limit-within-a-docker-container" rel="nofollow" target="_blank">prints the memory limit</a>):</p><div><div><pre><span>C</span><span>:</span><span>\&gt;docker run </span><span>-</span><span>m </span><span>4mb</span><span> </span><span>--</span><span>rm alpine cat </span><span>/</span><span>sys</span><span>/</span><span>fs</span><span>/</span><span>cgroup</span><span>/</span><span>memory</span><span>/</span><span>memory</span><span>.</span><span>limit_in_bytes
</span><span>4194304</span></pre><p><span>Mid-way through 2018, we started </span><a href="https://github.com/dotnet/coreclr/issues/18971" target="_blank">testing applications with memory limits set below 100MB</a><span>. The results were not great. This effort was based on enabling .NET Core to run well in containers in IoT scenarios. More recently, we published a </span><a href="https://github.com/dotnet/designs/blob/master/accepted/support-for-memory-limits.md" target="_blank">design</a><span> and </span><a href="https://github.com/dotnet/coreclr/pull/22180" target="_blank">implementation</a><span> to satisfy both server/cloud and IoT memory limits cases.</span></p></div></div><p>We concluded that the primary fix is to set a GC heap maximum significantly lower than the overall memory limit as a default behavior. In retrospect, this choice seems like an obvious requirement of our implementation. We also found that Java has taken a similar approach, introduced in Java 9 and updated in Java 10.</p><p>The following design summary describes the new .NET Core behavior (added in Preview 3) when cgroup limits are set:</p><ul><li>Default GC heap size: maximum of <code>20mb</code> or <code>75%</code> of the memory limit on the container</li><li>Explicit size can be set as an absolute number or percentage of cgroup limit</li><li>Minimum reserved segment size per GC heap is 16mb, which will reduce the number of heaps created on machines with a large number of cores and small memory limits</li></ul><p>The GC change is the most critical part of our memory limits solution. It is also important to <a href="https://github.com/dotnet/corefx/issues/35638" target="_blank">update BCL APIs to honor cgroup settings</a>. Those changes are not included in Preview 3 but will come later. We’d appreciate feedback on which BCL APIs are most important to update first (<a href="https://github.com/dotnet/corefx/issues/32748" target="_blank">another example</a>).</p><p>Our focus in Preview 3 has been about making Docker limits work well for Linux containers. We’re do the same for Windows containers in upcoming previews.</p><h2>Docker Publishing Update</h2><p>Microsoft teams are now publishing container images to the <a href="https://azure.microsoft.com/en-us/blog/microsoft-syndicates-container-catalog/" rel="nofollow" target="_blank">Microsoft Container Registry (MCR)</a>. There are two primary reasons for this change:</p><ul><li>Syndicate Microsoft-provided container images to multiple registries, like Docker Hub and Red Hat.</li><li>Use Microsoft Azure as a global CDN for delivering Microsoft-provided container images.</li></ul><p>On the .NET team, we are now publishing all .NET Core images to MCR. We switched the <a href="https://hub.docker.com/_/microsoft-dotnet-core-nightly" rel="nofollow" target="_blank">.NET Core Nightly product repo</a> to MCR 2-3 weeks ago. The <a href="https://hub.docker.com/_/microsoft-dotnet-core" rel="nofollow" target="_blank">.NET Core product repo</a> has now been moved to publishing to MCR as well, and includes .NET Core 3.0 Preview 3. As you can see from these links (if you click on them), we continue to have “home pages” on Docker Hub. We intend for that to continue indefinitely. MCR does not offer such pages, but relies of public registries, like Docker Hub, to provide users with image-related information.</p><p>The links to our old repos, such as <a href="https://hub.docker.com/r/microsoft/dotnet" rel="nofollow" target="_blank">microsoft/dotnet</a> and <a href="https://hub.docker.com/r/microsoft/dotnet-nightly" rel="nofollow" target="_blank">microsoft/dotnet-nightly</a> now forward to the new locations. The images that existed at those locations still exists and will not be deleted.</p><p>We will continue servicing the floating tags in the old repos for the supported life of the various .NET Core versions. For example, <code>2.1-sdk</code>, <code>2.2-runtime</code>, and <code>latest</code> are examples of floating tags that will be serviced. A three-part version tag like <code>2.1.2-sdk</code> will not be serviced, which was already the case.</p><p>We have deleted the <code>3.0</code> images in the old repos. We will only be supporting .NET Core 3.0 images in MCR and want to make sure that everyone realizes that MCR is the correct place to pull those images, and transitions to using MCR immediately.</p><p>For example, the correct tag string to pull the 3.0 SDK image now looks like the following:</p><pre><span>mcr</span><span>.</span><span>microsoft</span><span>.</span><span>com</span><span>/</span><span>dotnet</span><span>/</span><span>core</span><span>/</span><span>sdk</span><span>:</span><span>3.0</span></pre><p>The new MCR string will be used with both <code>docker pull</code> and in Dockerfile <code>FROM</code> statements.</p><p>This tag string previously looked like the following:</p><pre><span>microsoft</span><span>/</span><span>dotnet</span><span>:</span><span>3.0</span><span>-</span><span>sdk</span></pre><p>See <a href="https://github.com/dotnet/announcements/issues/101" target="_blank">Publishing .NET Core images to Microsoft Container Registry (MCR)</a> for more information.</p><h2>Index and Range</h2><p><code>Index</code> and <code>Range</code> types were introduced in <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/" rel="nofollow">Preview 1</a> to support the new C# 8.0 compiler index and range syntax (e.g. array[^10] and array[3..10]). We have polished these types for Preview 3 and added some more APIs to enable using <code>Index</code> and <code>Range</code> with some other types (e.g. <code>String</code>, <code>[Readonly]Span&lt;T&gt;</code>, <code>[Readonly]Memory&lt;T&gt;</code> and <code>Array</code>).</p><p>These changes enable the following syntax and scenarios:</p><pre><span>// start with int[]</span><span>
</span><span>int</span><span>[]</span><span> nums </span><span>=</span><span> </span><span>{</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>6</span><span>,</span><span> </span><span>7</span><span>,</span><span> </span><span>8</span><span>,</span><span> </span><span>9</span><span>,</span><span> </span><span>10</span><span> </span><span>};</span><span>
</span><span>int</span><span> lastNum </span><span>=</span><span> nums</span><span>[^</span><span>1</span><span>];</span><span> </span><span>// 10</span><span>
</span><span>int</span><span>[]</span><span> subsetNums </span><span>=</span><span> nums</span><span>[</span><span>2.</span><span>.</span><span>6</span><span>];</span><span> </span><span>// {3, 4, 5, 6}</span><span>

</span><span>// Create a Memory&lt;int&gt; using arrayofNums as input</span><span>
</span><span>// Create no-copy slices of the array</span><span>
</span><span>Memory</span><span>&lt;int&gt;</span><span> numbers </span><span>=</span><span> nums</span><span>;</span><span>
</span><span>Memory</span><span>&lt;int&gt;</span><span> lastTwoNums </span><span>=</span><span> numbers</span><span>.</span><span>Slice</span><span>(^</span><span>2</span><span>);</span><span> </span><span>// {9, 10}</span><span>
</span><span>Memory</span><span>&lt;int&gt;</span><span> middleNums </span><span>=</span><span> numbers</span><span>.</span><span>Slice</span><span>(</span><span>4.</span><span>.</span><span>8</span><span>);</span><span> </span><span>// {5, 6, 7, 8}</span><span>

</span><span>// Create a substring using a range</span><span>
</span><span>string</span><span> myString </span><span>=</span><span> </span><span>"0123456789ABCDEF"</span><span>;</span><span>
</span><span>string</span><span> substring </span><span>=</span><span> myString</span><span>[</span><span>0.</span><span>.</span><span>5</span><span>];</span><span> </span><span>// "01234"</span><span>

</span><span>// Create a Memory&lt;char&gt; using a range</span><span>
</span><span>ReadOnlyMemory</span><span>&lt;char&gt;</span><span> myChars </span><span>=</span><span> myString</span><span>.</span><span>AsMemory</span><span>();</span><span>
</span><span>ReadOnlyMemory</span><span>&lt;char&gt;</span><span> firstChars </span><span>=</span><span> myChars</span><span>[</span><span>0.</span><span>.</span><span>5</span><span>];</span><span> </span><span>// {'0', '1', '2', '3', '4'}</span><span>

</span><span>// Get an offset with an Index</span><span>
</span><span>Index</span><span> indexFromEnd </span><span>=</span><span> </span><span>Index</span><span>.</span><span>FromEnd</span><span>(</span><span>3</span><span>);</span><span> </span><span>// equivalent to [^3]</span><span>
</span><span>int</span><span> offsetFromLength </span><span>=</span><span> indexFromEnd</span><span>.</span><span>GetOffset</span><span>(</span><span>10</span><span>);</span><span> </span><span>// 7</span><span>
</span><span>int</span><span> value </span><span>=</span><span> nums</span><span>[</span><span>offsetFromLength</span><span>];</span><span> </span><span>// 8</span><span>

</span><span>// Get an offset with a Range</span><span>
</span><span>Range</span><span> rangeFromEnd </span><span>=</span><span> </span><span>5.</span><span>.^</span><span>0</span><span>;</span><span>
</span><span>(</span><span>int</span><span> offset</span><span>,</span><span> </span><span>int</span><span> length</span><span>)</span><span> </span><span>=</span><span> rangeFromEnd</span><span>.</span><span>GetOffsetAndLength</span><span>(</span><span>10</span><span>);</span><span> </span><span>// offset = 5, length = 5</span><span>
</span><span>Memory</span><span>&lt;int&gt;</span><span> values </span><span>=</span><span> numbers</span><span>.</span><span>Slice</span><span>(</span><span>offset</span><span>,</span><span> length</span><span>);</span><span> </span><span>// {6, 7, 8, 9, 10}</span></pre><h2>.NET Standard 2.1</h2><p>This is the first preview that has support for authoring .NET Standard 2.1 libraries. By default, <code>dotnet new classlib</code> continues to create .NET Standard 2.0 libraries as we believe it gives you a better compromise between platform support and feature set. For example, <a href="https://devblogs.microsoft.com/dotnet/announcing-net-standard-2-1/" rel="nofollow">.NET Standard 2.1 won’t be supported by .NET Framework</a>.</p><p>In order to target .NET Standard 2.1, you’ll have to edit your project file and change the <code>TargetFramework</code> property to <code>netstandard2.1</code>:</p><pre><span>&lt;Project</span><span> </span><span>Sdk</span><span>=</span><span>"Microsoft.NET.Sdk"</span><span>&gt;</span><span>

  </span><span>&lt;PropertyGroup&gt;</span><span>
    </span><span>&lt;TargetFramework&gt;</span><span>netstandard2.1</span><span>&lt;/TargetFramework&gt;</span><span>
  </span><span>&lt;/PropertyGroup&gt;</span><span>

</span><span>&lt;/Project&gt;</span></pre><p>If you’re using Visual Studio, you’ll need Visual Studio 2019 as .NET Standard 2.1 won’t be supported in Visual Studio 2017.</p><p><a href="https://devblogs.microsoft.com/Microsoft/dotnet-blog/blob/c2fc375e73e2ee410523fa7d0d152c82c54e2f86/2019/03-Mar/dotnet-core3-preview3/ns21-vs2019.png" target="_blank" rel="noopener noreferrer" data-featherlight="image"></a><a href="https://devblogs.microsoft.com/Microsoft/dotnet-blog/raw/c2fc375e73e2ee410523fa7d0d152c82c54e2f86/2019/03-Mar/dotnet-core3-preview3/ns21-vs2019.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/Microsoft/dotnet-blog/raw/c2fc375e73e2ee410523fa7d0d152c82c54e2f86/2019/03-Mar/dotnet-core3-preview3/ns21-vs2019.png" alt=""> </a><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/03/ns21-vs2019-1024x503.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/03/ns21-vs2019-1024x503.png" alt="" width="640" height="314" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/03/ns21-vs2019-1024x503.png 1024w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/03/ns21-vs2019-300x147.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/03/ns21-vs2019-768x377.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2019/03/ns21-vs2019.png 1186w" sizes="(max-width: 640px) 100vw, 640px"> </a></p><p>As the version number illustrates, .NET Standard 2.1 is a minor increment over what was added with .NET Standard 2.0 (we added ~3000 APIs). Here are the key additions:</p><ul><li><code>Index</code> and <code>Range</code>. This adds both, the types as well as the indexers on the core types, such as <code>String</code>, <code>ArraySegment&lt;T&gt;</code>, and <code>Span&lt;T&gt;</code>.</li><li><code>IAsyncEnumerable&lt;T&gt;</code>. This adds support for an async <code>IEnumerable&lt;T&gt;</code>. We don’t currently provide Linq-style extension methods but this gap is filled by the <a href="https://www.nuget.org/packages/System.Linq.Async" rel="nofollow" target="_blank">System.Linq.Async community project</a>.</li><li>Support for <code>Span&lt;T&gt;</code> and friends. This includes both, the span types, as well as the hundreds of helper methods across various types that accept and return spans (e.g. <code>Stream</code>).</li><li>Reflection emit &amp; capability APIs. This includes Reflection emit itself as well as two new properties on the <code>RuntimeFeature</code> class that allows you to check whether runtime code generation is supported at all (<code>IsDynamicCodeSupported</code>) and whether it’s compiled using a JIT or interpreted (<code>IsDynamicCodeCompiled</code>). This enables you to author .NET Standard libraries that can take advantage of dynamic code generation if available and fallback to other behavior when you run in environments that don’t have JIT and/or don’t have support for IL interpretation.</li><li>SIMD. .NET had support for SIMD for a while now. We’ve leveraged them to speed up basic operations in the BCL, such as string comparisons. We’ve received quite a few requests to expose these APIs in .NET Standard as the functionality requires runtime support and thus cannot be provided meaningfully as a NuGet package.</li><li><code>DbProviderFactories</code>. In .NET Standard 2.0 we added almost all of the primitives in ADO.NET to allow O/R mappers and database implementers to communicate. Unfortunately, <code>DbProviderFactories</code> didn’t make the cut for 2.0 so we’re adding it now. In a nutshell, <code>DbProviderFactories</code> allows libraries and applications to utilize a specific ADO.NET provider without knowing any of its specific types at compile time, by selecting among registered <code>DbProviderFactory</code> instances based on a name, which can be read from, for example, configuration settings.</li><li>General Goodness. Since .NET Core was open sourced, we’ve added many small features across the base class libraries such as <code>System.HashCode</code> for combining hash codes or new overloads on <code>System.String</code>. There are about 800 new members in .NET Core and virtually all of them got added in .NET Standard 2.1.</li></ul><p>For more details on all the API additions and platform support, check out <a href="https://github.com/dotnet/standard/blob/master/docs/versions.md" target="_blank">.NET Standard version table on GitHub</a>.</p><h2>F# Update</h2><p>We added the following for F# in Preview 3.</p><ul><li>F# 4.6 (Preview) (in the SDK)</li><li>dotnet fsi (Preview) command</li></ul><h3>F# 4.6</h3><ul><li>Anonymous Record support</li><li>FSharp.Core additions<ul><li>ValueOption function parity with Option</li><li>tryExactlyOne function for List, Array, and Seq</li></ul></li></ul><p>Learn more at <a href="https://devblogs.microsoft.com/dotnet/announcing-f-4-6-preview/" rel="nofollow">Announcing F# 4.6 Preview</a>.</p><h3>dotnet fsi preview</h3><p>F# interactive as a pure .NET Core application:</p><pre><span>dotnet fsi </span><span>--</span><span>readline

</span><span>Microsoft</span><span> </span><span>(</span><span>R</span><span>)</span><span> F</span><span># Interactive version 10.4.0 for F# 4.6</span><span>
</span><span>Copyright</span><span> </span><span>(</span><span>c</span><span>)</span><span> </span><span>Microsoft</span><span> </span><span>Corporation</span><span>.</span><span> </span><span>All</span><span> </span><span>Rights</span><span> </span><span>Reserved</span><span>.</span><span>

</span><span>For</span><span> help type </span><span>#help;;</span><span>

</span><span>&gt;</span><span> </span><span>let</span><span> lst </span><span>=</span><span> </span><span>[</span><span> </span><span>1</span><span>;</span><span> </span><span>2</span><span>;</span><span> </span><span>3</span><span>;</span><span> </span><span>4</span><span>;</span><span> </span><span>5</span><span>];;</span><span>
val lst </span><span>:</span><span> </span><span>int</span><span> list </span><span>=</span><span> </span><span>[</span><span>1</span><span>;</span><span> </span><span>2</span><span>;</span><span> </span><span>3</span><span>;</span><span> </span><span>4</span><span>;</span><span> </span><span>5</span><span>]</span><span>

</span><span>&gt;</span><span> </span><span>let</span><span> squares </span><span>=</span><span> lst </span><span>|&gt;</span><span> </span><span>List</span><span>.</span><span>map </span><span>(</span><span>fun x </span><span>-&gt;</span><span> x </span><span>*</span><span> x</span><span>);;</span><span>
val squares </span><span>:</span><span> </span><span>int</span><span> list </span><span>=</span><span> </span><span>[</span><span>1</span><span>;</span><span> </span><span>4</span><span>;</span><span> </span><span>9</span><span>;</span><span> </span><span>16</span><span>;</span><span> </span><span>25</span><span>]</span><span>

</span><span>&gt;</span><span> </span><span>let</span><span> sumOfSquares </span><span>=</span><span> lst </span><span>|&gt;</span><span> </span><span>List</span><span>.</span><span>sumBy </span><span>(</span><span>fun x </span><span>-&gt;</span><span> x </span><span>*</span><span> x</span><span>);;</span><span>
val sumOfSquares </span><span>:</span><span> </span><span>int</span><span> </span><span>=</span><span> </span><span>55</span></pre><p>Has basic colorization of F# types (thanks to <a href="https://github.com/saul" target="_blank">Saul Rennison</a>):</p><p><a href="https://user-images.githubusercontent.com/6309070/53784393-f322bf00-3ec9-11e9-86ba-8a9cc8783dd1.png" target="_blank" rel="noopener noreferrer" data-featherlight="image"></a><a href="https://user-images.githubusercontent.com/6309070/53784393-f322bf00-3ec9-11e9-86ba-8a9cc8783dd1.png" target="_blank" data-featherlight="image"> <img src="https://user-images.githubusercontent.com/6309070/53784393-f322bf00-3ec9-11e9-86ba-8a9cc8783dd1.png" alt="F# colorization"> </a></p><h2>AssemblyDependencyResolver</h2><p>AssemblyDependencyResolver is a key component of&nbsp;dynamically loading assemblies.&nbsp; Given .NET Core’s binder does not do simple probing like ‘next to the assembly’. We added a mechanism to read a deps or flat directory at runtime and resolve assemblies.</p><p>So in the past, doing an AssemblyLoadContext.LoadAssemblyFromPath(“…”), would fail to find dependent assemblies.&nbsp; But using the following works as expected with .NET Core 3.0:</p><pre><span>var</span><span> resolver </span><span>=</span><span> </span><span>new</span><span> </span><span>AssemblyDependencyResolver</span><span>(</span><span>pluginPath</span><span>);</span><span>
</span><span>var</span><span> assemblyPath </span><span>=</span><span> resolver</span><span>.</span><span>ResolveAssemblyToPath</span><span>(</span><span>assemblyName</span><span>);</span></pre><p>See <a href="https://github.com/dotnet/samples/tree/master/core/extensions/AppWithPlugin" target="_blank">examples of this API</a> in use.</p><h2>DLLMap and Native image resolver events</h2><p>These new capabilities enable a better experience with working with dynamically loaded native dependencies.</p><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.nativelibrary?view=netcore-3.0" target="_blank">NativeLibrary</a> provides an encapsulation for loading a native library (using the same load logic as .NET Core P/Invoke) and providing the relevant helper functions (getSymbol, etc.). See the following usage pattern:</p><pre><span>NativeLibrary</span><span>.</span><span>Load</span><span>(</span><span>mappedName</span><span>,</span><span> assembly</span><span>,</span><span> dllImportSearchPath</span><span>);</span></pre><p>We provided callbacks on P/Invoke module load to allow for replacement at runtime. This is similar to what is available with the Mono runtime. This feature an application to dynamically target Windows and Linux without having to do #if and rebuild.&nbsp;See the following usage pattern:</p><pre><span>NativeLibrary</span><span>.</span><span>SetDllImportResolver</span><span>(</span><span>assembly</span><span>,</span><span> </span><span>MapAndLoad</span><span>);</span></pre><p>We added symmetric native library resolution APIs when modules are not found.&nbsp; &nbsp;Previously this was not possible in the default load context, and required inheriting from a class and overriding a protected method.</p><pre><span>AssemblyLoadContext</span><span>.</span><span>Default</span><span>.</span><span>ResolvingUnmanagedDll</span><span> </span><span>+=</span><span> </span><span>HandlerFail</span><span>;</span></pre><p>We are in the process of adding <a href="https://github.com/dotnet/samples/pull/668/files" target="_blank">samples for these new capabilities</a>.</p><h2>.NET Core Windows Desktop Project Update</h2><p>We are continuing to make progress on the <a href="https://github.com/dotnet/wpf" target="_blank">WPF</a> and <a href="https://github.com/dotnet/winforms" target="_blank">WinForms</a> projects. We are still working on transitioning these code bases from a proprietary build system to an open source one, based on <a href="https://github.com/dotnet/arcade" target="_blank">dotnet/arcade</a>. We are coming to the tail end of this phase of the project and then expect that remaining parts of the WPF code base will be published afterwards, likely after Preview 4.</p><h2>High DPI for Windows Forms Applications</h2><p>As technology progresses, more varied display monitors are avaiable for purchase. Dots-per-inch (DPI), that used to always be 96 DPI, is no longer a constant value. With that comes a need to be able to set different <strong>DPI modes</strong> for desktop applications.</p><p>Before, the only way to set the DPI mode for your .NET Core WinForms application was via <code>P/Invoke</code>. In .NET Core Preview 3 we are adding the ability to get and set High DPI mode by adding the <code>Application.SetHighDpiMode</code> and <code>Application.HighDpiMode</code>.</p><p>The <code>SetHighDpiMode</code> method will set the corresponding High DPI mode unless the setting has been set by other means like <code>App.Manifest</code> or <code>P/Invoke</code> before <code>Application.Run</code>.</p><p>The possible HighDPIMode values, as expressed by the <code>HighDpiMode</code> enum are:</p><ul><li><code>DpiUnaware</code></li><li><code>SystemAware</code></li><li><code>PerMonitor</code></li><li><code>PerMonitorV2</code></li><li><code>DpiUnawareGdiScaled</code></li></ul><p>To learn more about High DPI modes check out <a href="https://docs.microsoft.com/en-us/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows" rel="nofollow" target="_blank">High DPI Desktop Application Development on Windows</a> article.</p><h2>Entity Framework Project Update</h2><p>In the first 3 previews, the EF team has prioritized API and behavior changes that could cause existing applications to break when upgrading from previous versions. These changes are themselves designed to improve EF Core or to unblock further improvements. But it also means that many other changes, including sought-after new features planned for EF Core 3.0, together with the porting of EF6 to .NET Core, haven’t been completed yet.</p><p>Implementing architectural changes early in the release helps us maximize the opportunities to collect customer feedback, understand any unintended impact of the changes, and react accordingly.</p><p>You can expect to see more detailed announcements in this blog, as we make progress in the delivery of new features in upcoming previews.</p><p>In the meantime, you can visit <a href="https://docs.microsoft.com/ef/core/what-is-new/ef-core-3.0/" rel="nofollow" target="_blank">What’s new in EF Core 3.0</a> in the product documentation to find more information about the new features planned for 3.0 as well as a detailed description of the breaking changes included so far.</p><h2>Closing</h2><p>Take a look at the <a href="https://blogs.msdn.microsoft.com/dotnet/2018/12/04/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/" target="_blank">.NET Core 3.0 Preview 1</a>&nbsp;and <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-preview-2/" rel="nofollow">Preview 2</a> posts if you missed those. With this post, they describe the complete set of new capabilities that have been added so far with the .NET Core 3.0 release.</p><p>Thanks for trying out .NET Core 3.0. Please continue to give us feedback, either in the comments or on GitHub. We are listening carefully and will continue to make changes based on your feedback.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>