<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Promise of Hierarchical Reinforcement Learning - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="The Promise of Hierarchical Reinforcement Learning - linksfor.dev(s)"/>
    <meta property="og:description" content="This idea of temporal abstraction, once incorporated into reinforcement learning (RL), converts it into *hierarchical* reinforcement learning (HRL)."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://thegradient.pub/the-promise-of-hierarchical-reinforcement-learning/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - The Promise of Hierarchical Reinforcement Learning</title>
<div class="readable">
        <h1>The Promise of Hierarchical Reinforcement Learning</h1>
            <div>Reading time: 41-52 minutes</div>
        <div>Posted here: 11 Mar 2019</div>
        <p><a href="https://thegradient.pub/the-promise-of-hierarchical-reinforcement-learning/">https://thegradient.pub/the-promise-of-hierarchical-reinforcement-learning/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
          <div><h5 id="updatejrgenschmidhuberkindlysuggestedsomecorrectionsconcerningtheearlyworkonintrinsicmotivationsubgoaldiscoveryandartificialcuriositysince1990whichihaveincorporatedandexpanded"><em>Update: Jürgen Schmidhuber kindly suggested some corrections concerning the early work on intrinsic motivation, subgoal discovery and artificial curiosity since 1990, which I have incorporated and expanded.</em></h5>
<p><span>S<span></span></span>uppose your friend just baked and shared  an excellent cake with you, and you would like to know its recipe. It might seem that it should be very easy for your friend to just tell you how to cook the cake — that it should be easy for him to get across the recipe. But this is a subtler task than you might think; how detailed should the instructions be? Does the friend have to explain in detail each of the tiny tasks to be followed?</p>
<p>Probably not.</p>
<p>At some point into the recipe of, let’s say, beef bourguignon, one needs to "cut 4 carrots into slices." To humans, there is no need to say: "take a knife; in case it doesn’t cut properly, sharpen it; take a wooden board and put the 4 carrots on it; hold the knife in your dominant hand; contract muscle X to cut the first slice of carrot."</p>
<p>So, there is a pertinent level of <em>granularity</em> to be adopted when sketching an action for a system to follow. This granularity can be very difficult to mathematically integrate into complex self-learning systems.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image58.png" width="800" data-action="zoom">
       <figcaption>Example of different levels of granularity in a recipe</figcaption>
</figure>
<p>In addition, there is converging evidence in developmental psychology <sup data-footnote-backlink-ref="fnref1" data-footnote-ref="#fn1"><a href="#fn1" id="fnref1">[1]</a></sup> that newborns, primates, children, and adults rely on the same cognitive systems for their basic knowledge. These cognitive systems include entities, agents, actions, space, social structures and intuitive theories. During open-ended games such as stacking up physically stable block structures, toddlers will use this knowledge to set sub-goals.</p>
<p><a href="https://giphy.com/gifs/lcyOND2tlMObGT6Fp2">via GIPHY</a> </p>
<p>To achieve these goals, toddlers seem to generate sub-goals within the space of their basic knowledge, engaging in <em>temporal abstraction</em>. If we use the recipe for beef bourguignon as an example, the cutting process of an onion is a temporally extended action and can take different numbers of steps to complete depending on the required cutting fineness. This idea of temporal abstraction, once incorporated into reinforcement learning (RL), converts it into <em>hierarchical</em> reinforcement learning (HRL).</p>
<p>The following was motivated by a modest attempt to <a href="https://distill.pub/2017/research-debt/">distill</a> research on the subject of HRL. We will start by reviewing the fundamentals of RL before elaborating on its current limitations. We will then see how HRL can be an attractive way to counter the limits of RL, including its motivations, main frameworks and own limitations. Finally, we will discuss active and future research in this area.</p>
<hr>

<p>Reinforcement learning (RL) methods have recently shown a wide range of positive results, including beating humanity's best at <a href="https://deepmind.com/research/alphago/">Go</a>, learning to play Atari games just from the raw pixels, and teaching computers to control robots in <a href="https://storage.googleapis.com/joschu-public/knocked-over-stand-up.mp4">simulations</a> or in the <a href="https://youtu.be/jwSbzNHGflM">real world</a>. These achievements are the culmination of research on trial and error learning and optimal control since the 1950s. From these two domains was born the field of RL, which has since then been constantly evolving and remains incredibly stimulating.</p>
<p>Csaba Szepesvári puts it well in his book <sup data-footnote-backlink-ref="fnref2" data-footnote-ref="#fn2"><a href="#fn2" id="fnref2">[2]</a></sup>: “reinforcement learning refers to both a learning problem and a subfield of machine learning.”</p>
<p>In short: the learning problem is concerned with software agents that learn goal-oriented behavior by trial and error in an environment that provides rewards in response to the agent’s actions towards achieving that goal.</p>
<figure>
    <center>
       <img src="https://thegradient.pub/content/images/2019/03/image57.png" width="900" data-action="zoom">
       <figcaption>RL learning problem</figcaption>
    </center>
</figure>
<p>The learning problem setup is quite simple.</p>
<p>There are two protagonists: an agent and an environment. The environment is where the agent ‘lives’ and what it interacts with. At each point of the interaction, the agent sees an observation of the state of the world, then decides on an action to be taken. The environment changes when the agent acts on it, but it can also change on its own. The agent also receives an environmental reward signal, a number (or a distribution <sup data-footnote-backlink-ref="fnref3" data-footnote-ref="#fn3"><a href="#fn3" id="fnref3">[3]</a></sup>) that tells it how good or bad the effect of the action was with respect to the agent’s goal.</p>
<p>At this point, you could ask: why do RL at all and not directly supervised learning (eg. with data samples (state, action) → reward)? Alex Graves pointed it in his NeurIPS 2018 <a href="https://www.youtube.com/watch?v=rjZCjosEFpI">talk</a> about Unsupervised Learning:</p>
<ol>
<li>With a supervised learning setup, we would need huge amounts of data that is difficult to obtain and can be complex to define</li>
<li>From what we understand from the way toddlers learn when they discover the world <sup data-footnote-backlink-ref="fnref4" data-footnote-ref="#fn4"><a href="#fn4" id="fnref4">[4]</a></sup><sup data-footnote-backlink-ref="fnref5" data-footnote-ref="#fn5"><a href="#fn5" id="fnref5">[5]</a></sup><sup data-footnote-backlink-ref="fnref6" data-footnote-ref="#fn6"><a href="#fn6" id="fnref6">[6]</a></sup>, learning without relying on a massive amount of data feels more human</li>
<li>RL could allow for better generalisation in a variety of complex real-world environments with eg. intrinsic motivation and auxiliary tasks <sup data-footnote-backlink-ref="fnref7" data-footnote-ref="#fn7"><a href="#fn7" id="fnref7">[7]</a></sup><sup data-footnote-backlink-ref="fnref8" data-footnote-ref="#fn8"><a href="#fn8" id="fnref8">[8]</a></sup><sup data-footnote-backlink-ref="fnref9" data-footnote-ref="#fn9"><a href="#fn9" id="fnref9">[9]</a></sup><sup data-footnote-backlink-ref="fnref10" data-footnote-ref="#fn10"><a href="#fn10" id="fnref10">[10]</a></sup></li>
</ol>
<p>The third argument makes even more sense when considering HRL, whose ambition is to be very effective, particularly in terms of generalisation and transfer of learning.</p>
<hr>
<details>
  <summary>Click here for a summary of Markov Decision Processes and RL</summary>
<p>Formally speaking, a Markov Decision Processes (MDP) is used to describe an environment for reinforcement learning where the environment is fully observable. Under the well-known Markov property “the future is independent of the past given the present” we define a finite MDP as a tuple <span id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;lt;</mo><mi>S</mi><mo>,</mo><mi>A</mi><mo>,</mo><mi>p</mi><mo>,</mo><mi>r</mi><mo>&amp;gt;</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&lt;</mo><mi>S</mi><mo>,</mo><mi>A</mi><mo>,</mo><mi>p</mi><mo>,</mo><mi>r</mi><mo>&gt;</mo></math></span></span> where <span id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>S</mi></math></span></span> is a finite set of states, <span id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math></span></span> is a finite set of actions, <span id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo>′</mo></msup><mrow><mo stretchy="false">|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></math></span></span> is the probability of transition from one state to another <span id="MathJax-Element-5-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>s</mi><mo>′</mo></msup></math></span></span> when action <span id="MathJax-Element-6-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math></span></span> is taken, <span id="MathJax-Element-7-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo>,</mo><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo>,</mo><msup><mi>s</mi><mo>′</mo></msup><mo stretchy="false">)</mo></math></span></span> is a distribution on the rewards obtained when action <span id="MathJax-Element-8-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math></span></span> is taken from <span id="MathJax-Element-9-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></span></span> and the following state <span id="MathJax-Element-10-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>s</mi><mo>′</mo></msup></math></span></span>. A stationary deterministic policy <span id="MathJax-Element-11-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C0;</mi><mo>:</mo><mi>S</mi><mo stretchy=&quot;false&quot;>&amp;#x2192;</mo><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>π</mi><mo>:</mo><mi>S</mi><mo stretchy="false">→</mo><mi>A</mi></math></span></span> maps states to actions.</p>
<p>In short, in a traditional RL problem, the agent aims to maximise its expected discounted return <span><span id="MathJax-Element-12-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msub><mi>R</mi><mi>t</mi></msub><mo>=</mo><munderover><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi mathvariant=&quot;normal&quot;>&amp;#x221E;</mi></munderover><msup><mi>&amp;#x03B3;</mi><mi>k</mi></msup><msub><mi>r</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>R</mi><mi>t</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi mathvariant="normal">∞</mi></munderover><msup><mi>γ</mi><mi>k</mi></msup><msub><mi>r</mi><mrow><mi>t</mi><mo>+</mo><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msub></math></span></span></span> where <span id="MathJax-Element-13-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>r</mi><mi>t</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>r</mi><mi>t</mi></msub></math></span></span> is the reward the agent receives at time <span id="MathJax-Element-14-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>t</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>t</mi></math></span></span> and <span id="MathJax-Element-15-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B3;</mi><mo>&amp;#x2208;</mo><mo stretchy=&quot;false&quot;>[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>γ</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></math></span></span> is the discount factor <sup data-footnote-backlink-ref="fnref11" data-footnote-ref="#fn11"><a href="#fn11" id="fnref11">[11]</a></sup>.</p>
<p>In a fully observable setting, the agent observes the true state of the environment <span id="MathJax-Element-16-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>s</mi><mi>t</mi></msub><mo>&amp;#x2208;</mo><mi>S</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>s</mi><mi>t</mi></msub><mo>∈</mo><mi>S</mi></math></span></span> and chooses an action <span id="MathJax-Element-17-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>a</mi><mi>t</mi></msub><mo>&amp;#x2208;</mo><mi>A</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mi>t</mi></msub><mo>∈</mo><mi>A</mi></math></span></span> according to policy <span id="MathJax-Element-18-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C0;</mi><mo stretchy=&quot;false&quot;>(</mo><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>s</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>π</mi><mo stretchy="false">(</mo><mi>a</mi><mrow><mo stretchy="false">|</mo></mrow><mi>s</mi><mo stretchy="false">)</mo></math></span></span>.</p>
<p>One way to address the RL problem is to define what is called the action-value function <span id="MathJax-Element-19-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>Q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi></math></span></span> of a policy <span id="MathJax-Element-20-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C0;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>π</mi></math></span></span> <sup data-footnote-backlink-ref="fnref12" data-footnote-ref="#fn12"><a href="#fn12" id="fnref12">[12]</a></sup>: <span><span id="MathJax-Element-21-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msub><mi>Q</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03C0;</mi></mrow></msub><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>E</mi><mo stretchy=&quot;false&quot;>[</mo><msub><mi>R</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi></mrow></msub><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><msub><mi>s</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi></mrow></msub><mo>=</mo><mi>s</mi><mo>,</mo><msub><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>t</mi></mrow></msub><mo>=</mo><mi>a</mi><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>Q</mi><mrow><mi>π</mi></mrow></msub><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">[</mo><msub><mi>R</mi><mrow><mi>t</mi></mrow></msub><mrow><mo stretchy="false">|</mo></mrow><msub><mi>s</mi><mrow><mi>t</mi></mrow></msub><mo>=</mo><mi>s</mi><mo>,</mo><msub><mi>a</mi><mrow><mi>t</mi></mrow></msub><mo>=</mo><mi>a</mi><mo stretchy="false">]</mo></math></span></span></span></p>
<p>The Bellman optimality equation <span><span id="MathJax-Element-22-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msup><mi>Q</mi><mo>&amp;#x2217;</mo></msup><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mi>&amp;#x03B3;</mi><munder><mo>&amp;#x2211;</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup><mo>&amp;#x2208;</mo><mi>S</mi></mrow></munder><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo><munder><mo movablelimits=&quot;true&quot; form=&quot;prefix&quot;>max</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msup><mi>a</mi><mo>&amp;#x2032;</mo></msup></mrow></munder><msup><mi>Q</mi><mo>&amp;#x2217;</mo></msup><mo stretchy=&quot;false&quot;>(</mo><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup><mo>,</mo><msup><mi>a</mi><mo>&amp;#x2032;</mo></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>Q</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mi>γ</mi><munder><mo>∑</mo><mrow><msup><mi>s</mi><mo>′</mo></msup><mo>∈</mo><mi>S</mi></mrow></munder><mi>P</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo>′</mo></msup><mrow><mo stretchy="false">|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><munder><mo movablelimits="true" form="prefix">max</mo><mrow><msup><mi>a</mi><mo>′</mo></msup></mrow></munder><msup><mi>Q</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><msup><mi>s</mi><mo>′</mo></msup><mo>,</mo><msup><mi>a</mi><mo>′</mo></msup><mo stretchy="false">)</mo></math></span></span></span></p>
<p>recursively represents the optimal Q-function <span><span id="MathJax-Element-23-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msup><mi>Q</mi><mo>&amp;#x2217;</mo></msup><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><munder><mo movablelimits=&quot;true&quot; form=&quot;prefix&quot;>max</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03C0;</mi></mrow></munder><msup><mi>Q</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>&amp;#x03C0;</mi></mrow></msup><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msup><mi>Q</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo movablelimits="true" form="prefix">max</mo><mrow><mi>π</mi></mrow></munder><msup><mi>Q</mi><mrow><mi>π</mi></mrow></msup><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></math></span></span></span> as a function of the expected immediate reward <span id="MathJax-Element-24-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>r</mi><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></math></span></span> and the transition function <span id="MathJax-Element-25-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo>′</mo></msup><mrow><mo stretchy="false">|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></math></span></span>, which in turn yields an optimal greedy policy <span id="MathJax-Element-26-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>&amp;#x03C0;</mi><mo>&amp;#x2217;</mo></msup><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>arg</mi><mo>&amp;#x2061;</mo><munder><mo movablelimits=&quot;true&quot; form=&quot;prefix&quot;>max</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>a</mi></mrow></munder><msup><mi>Q</mi><mo>&amp;#x2217;</mo></msup><mo stretchy=&quot;false&quot;>(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>π</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>arg</mi><mo>⁡</mo><munder><mo movablelimits="true" form="prefix">max</mo><mrow><mi>a</mi></mrow></munder><msup><mi>Q</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></math></span></span>.</p>
<p>Q-learning <sup data-footnote-backlink-ref="fnref12:1" data-footnote-ref="#fn12"><a href="#fn12" id="fnref12:1">[12:1]</a></sup> uses a sample-based approximation of the Bellman optimality equation to iteratively improve the Q-function. Q-learning has been shown to converge in the limit, with probability 1, to the optimal value function<br>
<span id="MathJax-Element-27-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mi>Q</mi><mo>&amp;#x2217;</mo></msup></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>Q</mi><mo>∗</mo></msup></math></span></span> under standard stochastic approximation assumptions. It is a RL solution for a MDP.</p>
<p>In deep Q-learning <sup data-footnote-backlink-ref="fnref13" data-footnote-ref="#fn13"><a href="#fn13" id="fnref13">[13]</a></sup>, the Q-function is represented by a neural network parameterised by <span id="MathJax-Element-28-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03B8;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>θ</mi></math></span></span>.</p>
</details>
<hr>
<p>What emerges from the above is really what the main question in RL is: <strong>How do we maximize future rewards?</strong></p>
<p>Answering this question actually requires answering to other sub-questions, including:</p>
<ul>
<li>What should we learn (models, state utilities, policies, etc.)?</li>
<li>How should we learn (TD learning, Monte Carlo, etc.)?</li>
<li>How do we represent what we have learned (deep neural networks, big tables, etc.)?</li>
<li>How to use what we have learnt: really often the first question that needs to be answered...</li>
</ul>
<hr>

<p><a href="https://giphy.com/gifs/iYnmrnrBynUyhwvG0H">via GIPHY</a></p>
<p>In this famous experiment from Warneken and Tomasello (full video <a href="https://www.youtube.com/watch?v=Z-eU5xZW7cU">here</a>), an 18-month-old child can understand what is happening and how to interact with the situation without having seen what to do before. The kid must have some common sense to be able to do that: understanding the physics, the action, the constraints, the plan. If you look to the end of the experiment, the child even takes a quick look at the man's hands to deduce how the plan will be completed.</p>
<p>We are still a long way from setting up such a capable system with current RL methods. One reason may be because RL suffers from a variety of defects that hinder learning and prevent it from being applied to more complex environments. HRL aims at alleviating precisely this learning complexity by breaking down specific parts of learning. The question is, therefore, whether this is enough. Strongly in line with Andrey Kurenkov's <a href="https://thegradient.pub/why-rl-is-flawed/">essay</a> in a previous Gradient article, the main weaknesses of RL, in comparison to the promises of HRL, can be broken down as follows.</p>
<ul>
<li>Sample efficiency: data generation is often a bottleneck and current RL methods are data inefficient. With HRL, sub-tasks and abstract actions can be used in different tasks on the same domain (transfer learning)</li>
<li>Scaling up: the application of classic RL to the problems with large action and/or state space is infeasible (curse of dimensionality). HRL aims to decompose large problems into smaller ones (efficient learning)</li>
<li>Generalization: trained agents can solve complex tasks, but if we want them to transfer their experience to new (even similar) environments, most state of the art RL algorithms will fail (brittleness due to overspecialization)</li>
<li>Abstraction: state and temporal abstractions allow to simplify the problem since resulting sub-tasks can effectively be solved by RL approaches (better knowledge representation)</li>
</ul>
<p>In addition, all the basic algorithms for reinforcement learning are so-called “flat” methods. They treat the state space as a huge, flat search space, meaning that the paths from the starting state to the target state are very long. If we look at this with the example of the recipe, <strong>it would give us a sequence of actions solely composed of a series of muscular micro-contractions</strong>. In addition, the length of these paths dictates the cost of learning, as information on future rewards must be disseminated backwards along these paths. In short, the reward signal is weak and delayed.</p>
<p>Perhaps we could step back and look at what we have learnt so far: in the 1970s, research in the field of planning showed that hierarchical methods such as hierarchical task networks <sup data-footnote-backlink-ref="fnref14" data-footnote-ref="#fn14"><a href="#fn14" id="fnref14">[14]</a></sup>, macro actions <sup data-footnote-backlink-ref="fnref15" data-footnote-ref="#fn15"><a href="#fn15" id="fnref15">[15]</a></sup> and state abstraction methods <sup data-footnote-backlink-ref="fnref16" data-footnote-ref="#fn16"><a href="#fn16" id="fnref16">[16]</a></sup> can provide exponential reductions in compute costs to find the right plans. There is also a large literature on subgoal discovery, intrinsic motivation and artificial curiosity <sup data-footnote-backlink-ref="fnref17" data-footnote-ref="#fn17"><a href="#fn17" id="fnref17">[17]</a></sup><sup data-footnote-backlink-ref="fnref18" data-footnote-ref="#fn18"><a href="#fn18" id="fnref18">[18]</a></sup><sup data-footnote-backlink-ref="fnref19" data-footnote-ref="#fn19"><a href="#fn19" id="fnref19">[19]</a></sup>. Nevertheless, we still lack a fully acceptable method for integrating hierarchies into the effective RL algorithms introduced so far.</p>
<hr>

<p>As we just saw, the reinforcement learning problem suffers from serious scaling issues. Hierarchical reinforcement learning (HRL) is a computational approach intended to address these issues by learning to operate on different levels of temporal abstraction <sup data-footnote-backlink-ref="fnref20" data-footnote-ref="#fn20"><a href="#fn20" id="fnref20">[20]</a></sup>.</p>
<p>To really understand the need for a hierarchical structure in the learning algorithm and in order to make the bridge between RL and HRL, we need to remember what we are trying to solve: MDPs. HRL methods learn  a policy made up of multiple layers, each of which is responsible for control at a different level of temporal abstraction. Indeed, the key innovation of the HRL is to extend the set of available actions so that the agent can now choose to perform not only elementary actions, but also macro-actions, i.e. sequences of lower-level actions. Hence, with actions that are extended over time, we must take into account the time  elapsed between decision-making moments. Luckily, MDP planning and learning algorithms can easily be extended to accommodate HRL.</p>
<p>In order to do that, let us welcome the <em>semi-Markov decision process</em> (SMDP). In this setup, <span id="MathJax-Element-29-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo>′</mo></msup><mrow><mo stretchy="false">|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></math></span></span> turns into <span id="MathJax-Element-30-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>s</mi><mo>&amp;#x2032;</mo></msup><mo>,</mo><mi>&amp;#x03C4;</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi><mo stretchy="false">(</mo><msup><mi>s</mi><mo>′</mo></msup><mo>,</mo><mi>τ</mi><mrow><mo stretchy="false">|</mo></mrow><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></math></span></span>.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image52.png" width="600" data-action="zoom">
       <figcaption>Hierarchical learning dynamics. <a href="https://www.princeton.edu/~yael/Publications/RibasFernandesSolwayEtAl2011.pdf">Source</a></figcaption>
</figure>
<p>The figure above clearly illustrates the paradigm: <span id="MathJax-Element-31-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math></span></span> is a primitive action, <span id="MathJax-Element-32-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C3;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>σ</mi></math></span></span> is a subroutine or macro-action, <span id="MathJax-Element-33-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>&amp;#x03C0;</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>π</mi></math></span></span> is the action policy, <span id="MathJax-Element-34-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03C0;</mi><mi>&amp;#x03C3;</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>π</mi><mi>σ</mi></msub></math></span></span> is the subroutine-specific action polcy, and <span id="MathJax-Element-35-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>V</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>V</mi></math></span></span> and <span id="MathJax-Element-36-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>V</mi><mi>a</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mi>a</mi></msub></math></span></span> are the state values.</p>
<p>The promise of HRL is to have:</p>
<ol>
<li>Long-term credit assignment: faster learning and better generalisation</li>
<li>Structured exploration: explore with sub-policies rather than primitive actions</li>
<li>Transfer learning: different levels of hierarchy can encompass different knowledge and allow for better transfer</li>
</ol>
<p>In the following and in the aforementioned setting, we outline the foundational methods that have emerged since 1993.</p>
<hr>

<h2 id="feudallearning">Feudal Learning</h2>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image48.png" width="800" data-action="zoom">
       <figcaption>Feudal hierarchy. <a href="https://shogunvseurope.weebly.com/feudal-society.html">Source</a></figcaption>
</figure>
<p>Inspired by Medieval Europe's Feudal system, this HRL method demonstrates how to create a managerial learning hierarchy in which lords (or managers) learn to assign tasks (or sub-goals) to their serfs (or sub-managers) who, in turn, learn to satisfy them. Sub-managers learn to maximize their reinforcement in the context of the command as pictured in the illustration below with the black circle.</p>
<figure>       
    <img src="https://thegradient.pub/content/images/2019/03/image44.png" width="300" data-action="zoom">
    <figcaption>Illustration of the feudal system in a standard maze task. <a href="https://papers.nips.cc/paper/714-feudal-reinforcement-learning.pdf">Source</a></figcaption>
</figure>    
<p>In practice, Feudal learning <sup data-footnote-backlink-ref="fnref21" data-footnote-ref="#fn21"><a href="#fn21" id="fnref21">[21]</a></sup> takes advantage of two notions:</p>
<ul>
<li>Information hiding: the managerial hierarchy observes the environment at different resolutions</li>
<li>Reward hiding: communication is made between managers and "workers" through goals - a reward is given for reaching them</li>
</ul>
<p>A noteworthy effect of information and reward hiding is that the managers only need to know the state of the system at the granularity of their own choices of tasks. They also don’t know what choices their workers have made to satisfy their command, since it is not needed for the system setup to learn.</p>
<p>Unfortunately, the Feudal Q-learning algorithm introduced in <sup data-footnote-backlink-ref="fnref21:1" data-footnote-ref="#fn21"><a href="#fn21" id="fnref21:1">[21:1]</a></sup> is tailored to a specific kind of problem, and does not converge to any well-defined optimal policy. But it has paved the way for many other contributions.</p>
<h2 id="optionsframework">Options Framework</h2>
<p>The most well-known formulation for HRL is probably the Options framework <sup data-footnote-backlink-ref="fnref20:1" data-footnote-ref="#fn20"><a href="#fn20" id="fnref20:1">[20:1]</a></sup><sup data-footnote-backlink-ref="fnref22" data-footnote-ref="#fn22"><a href="#fn22" id="fnref22">[22]</a></sup><sup data-footnote-backlink-ref="fnref23" data-footnote-ref="#fn23"><a href="#fn23" id="fnref23">[23]</a></sup><sup data-footnote-backlink-ref="fnref24" data-footnote-ref="#fn24"><a href="#fn24" id="fnref24">[24]</a></sup>. A <em>(Markov) option</em> is a triple <span id="MathJax-Element-37-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>o</mi><mo>=&amp;lt;</mo><msub><mi>I</mi><mi>o</mi></msub><mo>,</mo><msub><mi>&amp;#x03C0;</mi><mi>o</mi></msub><mo>,</mo><msub><mi>&amp;#x03B2;</mi><mi>o</mi></msub><mo>&amp;gt;</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>o</mi><mo>=&lt;</mo><msub><mi>I</mi><mi>o</mi></msub><mo>,</mo><msub><mi>π</mi><mi>o</mi></msub><mo>,</mo><msub><mi>β</mi><mi>o</mi></msub><mo>&gt;</mo></math></span></span> with:</p>
<ul>
<li><span id="MathJax-Element-38-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>I</mi><mi>o</mi></msub></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>I</mi><mi>o</mi></msub></math></span></span>: the initiation set</li>
<li><span id="MathJax-Element-39-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03C0;</mi><mi>o</mi></msub><mo>:</mo><mi>S</mi><mo>&amp;#x00D7;</mo><mi>A</mi><mo stretchy=&quot;false&quot;>&amp;#x2192;</mo><mo stretchy=&quot;false&quot;>[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>π</mi><mi>o</mi></msub><mo>:</mo><mi>S</mi><mo>×</mo><mi>A</mi><mo stretchy="false">→</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></math></span></span>: the option's policy</li>
<li><span id="MathJax-Element-40-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>&amp;#x03B2;</mi><mi>o</mi></msub><mo>:</mo><mi>S</mi><mo stretchy=&quot;false&quot;>&amp;#x2192;</mo><mo stretchy=&quot;false&quot;>[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy=&quot;false&quot;>]</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>β</mi><mi>o</mi></msub><mo>:</mo><mi>S</mi><mo stretchy="false">→</mo><mo stretchy="false">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false">]</mo></math></span></span>: the termination condition</li>
</ul>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image64.png" width="600" data-action="zoom">
       <figcaption>Understanding the difference between primitive actions and options. <a href="http://www-anw.cs.umass.edu/~barto/courses/cs687/Sutton-Precup-Singh-AIJ99.pdf">Source</a></figcaption>
</figure>
<p>One can grasp the idea of this framework with the self-explanatory example above where the options can be summed up as “going to hallways” and the actions as “going N, S, W, or E.” The options can be considered as individual actions at a higher level of abstraction (ie. each state can be used as a subgoal <sup data-footnote-backlink-ref="fnref25" data-footnote-ref="#fn25"><a href="#fn25" id="fnref25">[25]</a></sup><sup data-footnote-backlink-ref="fnref26" data-footnote-ref="#fn26"><a href="#fn26" id="fnref26">[26]</a></sup>) and can, as a result, be abstracted into skills.</p>
<p>Unlike Feudal learning, if the action space consists of both primitive actions and options, then an algorithm following the Options framework is proven <sup data-footnote-backlink-ref="fnref27" data-footnote-ref="#fn27"><a href="#fn27" id="fnref27">[27]</a></sup> to converge to an optimal policy. Otherwise, it will still converge, but to a hierarchically optimal policy<sup data-footnote-backlink-ref="fnref28" data-footnote-ref="#fn28"><a href="#fn28" id="fnref28">[28]</a></sup>.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image65.png" width="400" data-action="zoom">
       <figcaption>Understanding the Options in the context of a SMDP. <a href="http://www-anw.cs.umass.edu/~barto/courses/cs687/Sutton-Precup-Singh-AIJ99.pdf">Source</a></figcaption>
</figure>
<p>The resulting idea is that an Options framework is composed of two levels:</p>
<ul>
<li>The bottom level is a sub-policy:
<ul>
<li>takes environment observations</li>
<li>outputs actions</li>
<li>runs until termination</li>
</ul>
</li>
<li>The top level is a policy-over-options:
<ul>
<li>takes environment observations</li>
<li>outputs sub-policies</li>
<li>runs until termination</li>
</ul>
</li>
</ul>
<p>Options are quite easy to implement, and effective in defining high-level competencies which in turn improves convergence speed. Moreover, options themselves can be used to define option hierarchies. However, and as a natural consequence, options increase the complexity of the MDP. They also do not explicitly address the problem of task segmentation.</p>
<h2 id="hierarchicalabstractmachines">Hierarchical Abstract Machines</h2>
<p>HAMs consist of non-deterministic finite state machines whose transitions may invoke lower-level machines (the optimal action is yet to be decided or learnt). A machine is a partial policy represented by a Finite State Automaton (FSA). There are four machine states:</p>
<ul>
<li>Action states execute an action in the environment</li>
<li>Call states execute another machine as a subroutine</li>
<li>Choice states non-deterministically select a next machine state</li>
<li>Stop states halt execution of the machine and return control to the previous call state</li>
</ul>
<p>We can view policies as programs. For HAMs, the learning occurs within machines, since machines are only partially defined. The approach is to flatten all machines out and consider the state space of the problem <span id="MathJax-Element-41-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;lt;</mo><mi>s</mi><mo>,</mo><mi>m</mi><mo>&amp;gt;</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&lt;</mo><mi>s</mi><mo>,</mo><mi>m</mi><mo>&gt;</mo></math></span></span> where <span id="MathJax-Element-42-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>m</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>m</mi></math></span></span> is the machine state and <span id="MathJax-Element-43-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></span></span>is the state of the underlying MDP.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image63.png" width="500" data-action="zoom">
       <figcaption>The grid-world environment that was used throughout the paper. <a href="https://arxiv.org/abs/cs/9905014">Source</a></figcaption>
</figure>
<p>When the machine encounters a <em>Call state</em>, it executes the machine it is supposed to execute in a deterministic way. When it encounters a <em>Stop state</em>, it simply sends the command back to the parent machine. Unlike the case where learning takes place directly on the MDP where actions are learnt in each state, in the HAM framework learning only takes place in the <em>Choice states</em>. Thus, the state space on which the learning takes place may be smaller than the actual state space.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image67.png" width="500" data-action="zoom">
       <figcaption>Example of FSA for the grid-world environment</figcaption>
</figure>
<p>In the above example, each time an obstacle is encountered, the machine enters a Choice state where either it chooses the follow-wall machine (which just continuously follows the wall in a certain direction), or it chooses the back-off machine (which moves back and execution continues).</p>
<p>The learnt machine’s policy is therefore to decide which machine to call and with what probability.</p>
<p>For all the above reasons, the HAM framework offers us the ability to simplify the MDP by restricting the class of realizable policies. Similar to the Options framework, it also has theoretical guarantees of optimality <sup data-footnote-backlink-ref="fnref29" data-footnote-ref="#fn29"><a href="#fn29" id="fnref29">[29]</a></sup>. The main problems are that HAMs are complex to design and implement and that there are not many significant applications available.</p>
<h2 id="maxq">MAXQ</h2>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image50.png" width="500" data-action="zoom">
       <figcaption>Example of a MAXQ hierarchy. <a href="https://arxiv.org/pdf/cs/9905014.pdf">Source</a></figcaption>
</figure>    
<p>MAXQ is a hierarchical learning algorithm in which the hierarchy of a task is obtained by decomposing the Q value of state-action pair into the sum of two components <span id="MathJax-Element-44-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>Q</mi><mo stretchy=&quot;false&quot;>(</mo><mi>p</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mi>V</mi><mo stretchy=&quot;false&quot;>(</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo stretchy=&quot;false&quot;>)</mo><mo>+</mo><mi>C</mi><mo stretchy=&quot;false&quot;>(</mo><mi>p</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>V</mi><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo><mo>+</mo><mi>C</mi><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></math></span></span> where <span id="MathJax-Element-45-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>V</mi><mo stretchy=&quot;false&quot;>(</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>V</mi><mo stretchy="false">(</mo><mi>a</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></math></span></span> is the total expected reward received when executing the action <span id="MathJax-Element-46-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math></span></span> in state <span id="MathJax-Element-47-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>s</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>s</mi></math></span></span> (classic <span id="MathJax-Element-48-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>Q</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Q</mi></math></span></span>) and <span id="MathJax-Element-49-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mo stretchy=&quot;false&quot;>(</mo><mi>p</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mo stretchy="false">(</mo><mi>p</mi><mo>,</mo><mi>s</mi><mo>,</mo><mi>a</mi><mo stretchy="false">)</mo></math></span></span> is the total reward expected from the performance of the parent-task, noted by <span id="MathJax-Element-50-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>p</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi></math></span></span>, after taking the action <span id="MathJax-Element-51-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math></span></span>. In fact, the action <span id="MathJax-Element-52-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>a</mi></math>" role="presentation"><span role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi></math></span></span> may not only contain a primitive action, but also a sequence of actions.</p>
<p>In essence, one can understand the MAXQ framework <sup data-footnote-backlink-ref="fnref30" data-footnote-ref="#fn30"><a href="#fn30" id="fnref30">[30]</a></sup> as decomposing the value function of an MDP into combinations of value functions of smaller constituent MDPs, a finite set of sub-tasks where each sub-task is formalized as 1. a termination predicate, 2. a set of actions and 3. a pseudo reward. For this particular aspect, the MAXQ framework is related to the Feudal Q-learning.</p>
<p>Nevertheless, MAXQ’s advantage over the other frameworks is that it learns a <em>recursively optimal policy</em>, meaning that the policy for a parent task is optimal given the learnt policies of its children. Namely, the task’s policy is context-free: each subtask is optimally solved without reference to the context in which it is executed. While this does not mean it will find an optimal policy, it opens the door to state abstraction and better transfer learning, and can provide common macro actions to many other tasks.</p>
<p>State abstraction helps to reduce memory. Think about it: when you want to reach a door, no matter what colour the door is or whether it is made of wood or metal. State abstraction should help to represent similar states and reject irrelevant state variables. Moreover, with state abstraction, the necessary exploration is reduced and their reusability increased (because they do not depend on their higher parents). In fact, an abstract state is a state with fewer state variables: different states in the world correspond to the same abstract state. Therefore, if we can reduce some state variables (only a few variables are relevant to the task), then we can significantly reduce the learning time. Ultimately, we will use different abstract states for different macro-actions.</p>
<p>In short, the MAXQ framework proposes a real hierarchical decomposition of tasks (contrary to Options), it facilitates the reuse of sub-policies and allows temporal and spatial abstraction. Although one of the concerns is that MAXQ involves a very complex structure and that recursively optimal policies can be highly suboptimal policies.</p>
<hr>
<h2 id="recentworks">Recent works</h2>
<p>Inspired (or interpretable) by these founding elements (Feudal, Options, HAM, MAXQ) of HRL, interesting articles have been published more recently with rather encouraging results.</p>
<h3 id="feudalnetworksfunforhierarchicalreinforcementlearning"><a href="https://arxiv.org/abs/1703.01161">FeUdal Networks (FUN) for Hierarchical Reinforcement Learning</a></h3>
<p>FeUdal Networks <sup data-footnote-backlink-ref="fnref31" data-footnote-ref="#fn31"><a href="#fn31" id="fnref31">[31]</a></sup> present a modular architecture. Inspired by Dayan’s seminal idea of Feudal RL, the manager chooses a direction to go in a latent state space, and the worker learns to achieve that direction through actions in the environment. This means that FuN represents sub-goals as directions in latent state space which then translate into meaningful behavioural primitives. The paper introduces a method that allows better long-term credit assignment and makes memorisation more tractable.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image47.png" width="800" data-action="zoom">
       <figcaption>FuN Architecture. <a href="https://arxiv.org/abs/1703.01161">Source</a></figcaption>
</figure>    
<h3 id="theoptioncriticarchitecture"><a href="https://arxiv.org/abs/1609.05140">The option-critic architecture</a></h3>
<p>While earlier works used pre-specified option policies, there has been recent success in discovering options such as this paper <sup data-footnote-backlink-ref="fnref32" data-footnote-ref="#fn32"><a href="#fn32" id="fnref32">[32]</a></sup> which showcases an end-to-end trainable system that can scale to very large domains with sub-policies with theoretical possibility of learning options jointly with a policy-over-options by extending the policy gradient theorem to options. Contrary to FuN, here the Managers’ output is trained with gradients coming directly from the Worker and no intrinsic reward is used.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image55.png" width="400" data-action="zoom">
       <figcaption>Termination probabilities learnt by the option-critic agent with 4 options. <a href="https://arxiv.org/abs/1609.05140">Source</a></figcaption>
</figure>
<p>As you can see by the figure above, termination events are more likely to occur near the doors, intuitively this means that reaching those doors are learnt as being meaningful sub-goals.</p>
<h3 id="hirodataefficienthierarchicalreinforcementlearning"><a href="https://arxiv.org/abs/1805.08296">HIRO (Data Efficient Hierarchical Reinforcement Learning)</a></h3>
<p>The main contribution of <sup data-footnote-backlink-ref="fnref33" data-footnote-ref="#fn33"><a href="#fn33" id="fnref33">[33]</a></sup> is that the method is very sample efficient compared to previous works thanks to a novel off-policy correction<sup data-footnote-backlink-ref="fnref34" data-footnote-ref="#fn34"><a href="#fn34" id="fnref34">[34]</a></sup> and the fact that the learning algorithm directly uses the state observation as the goal. There is no goal representation, hence no goal representation training needed. This means that the higher-level policy receives a meaningful supervision signal from the task reward at the outset.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image46.png" width="800" data-action="zoom">
       <figcaption>Design and basic training of HIRO. <a href="https://arxiv.org/abs/1805.08296">Source</a></figcaption>
</figure>
<h3 id="haclearningmultilevelhierarchieswithhindsight"><a href="https://openreview.net/forum?id=ryzECoAcY7">HAC (Learning Multi-Level Hierarchies with Hindsight)</a></h3>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image56.png" width="1000" data-action="zoom">
       <figcaption>Comparison between HAC and HIRO on 3 continuous tasks. <a href="https://openreview.net/forum?id=ryzECoAcY7">Source</a></figcaption>
</figure>
<p>“We introduce a new HRL framework that can significantly accelerate learning by enabling hierarchical agents to jointly learn a hierarchy of policies. Our framework is primarily comprised of two components: (i) a particular hierarchical architecture and (ii) a method for learning the multiple levels of policies in parallel given sparse rewards. The hierarchies produced by our framework have a specific architecture consisting of a set of nested, goal-conditioned policies that use the state space as the mechanism for breaking down a task into subtasks. [...] HIRO, which was developed simultaneously and independently to our approach, uses the same hierarchical architecture, but does not use either form of hindsight and is therefore not as efficient at learning multiple levels of policies in sparse reward tasks.”</p>
<h3 id="locomotorcontrollers"><a href="https://arxiv.org/abs/1610.05182">Locomotor Controllers</a></h3>
<p>“We study a novel architecture and training procedure for locomotion tasks. A high-frequency, low-level "spinal" network with access to proprioceptive sensors learns sensorimotor primitives by training on simple tasks. This pre-trained module is fixed and connected to a low-frequency, high-level "cortical" network, with access to all sensors, which drives behavior by modulating the inputs to the spinal network. Where a monolithic end-to-end architecture fails completely, learning with a pre-trained spinal module succeeds at multiple high-level tasks, and enables the effective exploration required to learn from sparse rewards.”</p>
<p>This paper introduces a HRL method for training locomotive controllers that effectively improves sample efficiency and achieves transfer among different tasks. The idea of the authors is to obtain low-level policies that are invariable according to the tasks. Then by recycling and re-training the meta-policy that schedules over the low-level policies, different skills can be obtained with fewer samples than by training from scratch.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image53.png" width="600" data-action="zoom">
       <figcaption>Screenshot of the humanoid approaching a virtual gate in the transfer task. <a href="https://arxiv.org/abs/1610.05182">Source</a></figcaption>
</figure>
<h3 id="onreinforcementlearningforfulllengthgameofstarcraft"><a href="https://arxiv.org/abs/1809.09095">On Reinforcement Learning for Full-length Game of Starcraft</a></h3>
<p>In this paper, the authors focused on SC2LE, the StarCraft research learning environment introduced by DeepMind. They developed a method for full-length game learning where a controller chooses a sub-policy based on current observations at each relatively large time interval (8 seconds). Then, at each relatively short time interval (one second), a sub-policy chooses a macro-action that is mastered before learning from the repetitions of human expert games. StarCraft is a very challenging playground where the state and action spaces are very large. The approach takes advantage of the hierarchical structure to reduce those spaces. In addition, the size of the execution steps of strategic movements is reduced with the temporal abstraction provided by the controller. Finally, each sub-policy can have its own specific reward function which help divide the complex problem into several easier sub-problems.</p>
<figure>
       <img src="https://thegradient.pub/content/images/2019/03/image62.png" width="800" data-action="zoom">
       <figcaption>Screenshot of the StarCraft II environment. <a href="https://arxiv.org/abs/1809.09095">Source</a></figcaption>
</figure>
<h3 id="hdqn"><a href="https://arxiv.org/abs/1604.06057">h-DQN</a></h3>
<p>“We present hierarchical-DQN (h-DQN), a framework to integrate hierarchical value functions, operating at different temporal scales, with intrinsically motivated deep reinforcement learning. A top-level value function learns a policy over intrinsic goals, and a lower-level function learns a policy over atomic actions to satisfy the given goals. h-DQN allows for flexible goal specifications, such as functions over entities and relations. This provides an efficient space for exploration in complicated environments. We demonstrate the strength of our approach on two problems with very sparse, delayed feedback: (1) a complex discrete stochastic decision process, and (2) the classic ATARI game ‘Montezuma's Revenge’.”</p>
<figure>
   <img src="https://thegradient.pub/content/images/2019/03/image43.png" width="800" data-action="zoom">
   <figcaption>The meta-controller chooses the goal (illustrated in red) which the controller tries to satisfy by taking a series of low-level actions. <a href="https://arxiv.org/abs/1604.06057">Source</a></figcaption>
</figure>
<h3 id="metalearningsharedhierarchiesmlsh"><a href="https://arxiv.org/abs/1710.09767">Meta Learning Shared Hierarchies (MLSH)</a></h3>
<p>“In this work, we formulate an approach for the end-to-end meta learning of hierarchical policies. We present a model for representing shared information as a set of sub-policies. We then provide a framework for training these models over distributions of environments. Even though we do not optimize towards the true objective, we achieve significant speedups in learning. In addition, we naturally discover diverse sub-policies without the need for hand engineering.”</p>
<figure>
<img src="https://thegradient.pub/content/images/2019/03/image51.png" width="800" data-action="zoom">
<figcaption>Sub-policies learned from mazes to move down, right, and up. <a href="https://arxiv.org/abs/1710.09767">Source</a></figcaption>
</figure> 
<h3 id="modulatedpolicyhierarchiesmph"><a href="https://arxiv.org/abs/1812.00025">Modulated Policy Hierarchies (MPH)</a></h3>
<p>“We introduced Modulated Policy Hierarchies (MPHs) to address environments with sparse rewards that can be decomposed into sub-tasks. By combining rich modulation signals, temporal abstraction, and intrinsic motivation, MPH benefits from better exploration and increased stability of training. Moreover, in contrast to many state-of-the-art approaches, MPH does not require pre-training, multiple training phases or manual reward shaping. We evaluated MPH on two simulated robot manipulation tasks: pushing and block stacking. In both cases, MPH outperformed baselines and the recently proposed MLSH algorithm, suggesting that our approach may be a fertile direction for further investigation.”</p>
<figure>
<img src="https://thegradient.pub/content/images/2019/03/image61.png" width="800" data-action="zoom">
<figcaption>Modulation signals for a trained options baseline and MPH on the stacking task. <a href="https://arxiv.org/abs/1812.00025">Source</a></figcaption>
</figure> 
<h3 id="strageticattentivewriterstrawforlearningmacrowactions"><a href="https://arxiv.org/abs/1606.04695">Stragetic Attentive Writer (STRAW) for Learning Macrow Actions</a></h3>
<p>“We present a novel deep recurrent neural network architecture that learns to build implicit plans in an end-to-end manner by purely interacting with an environment in reinforcement learning setting. The network builds an internal plan, which is continuously updated upon observation of the next input from the environment. It can also partition this internal representation into contiguous sub-sequences by learning for how long the plan can be committed to - i.e. followed without re-planning. Combining these properties, the proposed model, dubbed STRategic Attentive Writer (STRAW) can learn high-level, temporally abstracted macro- actions of varying lengths that are solely learnt from data without any prior information. These macro-actions enable both structured exploration and economic computation. We experimentally demonstrate that STRAW delivers strong improvements on several ATARI games by employing temporally extended planning strategies (e.g. Ms. Pacman and Frostbite). It is at the same time a general algorithm that can be applied on any sequence data.”</p>
<figure>
<img src="https://thegradient.pub/content/images/2019/03/image57-1.png" width="800" data-action="zoom">
<figcaption>Schematic illustration of STRAW playing a maze navigation game. <a href="https://arxiv.org/abs/1606.04695">Source</a></figcaption>
</figure>
<h3 id="hdrln"><a href="https://arxiv.org/abs/1604.07255">H-DRLN</a></h3>
<p>“We propose a lifelong learning system that has the ability to reuse and transfer knowledge from one task to another while efficiently retaining the previously learned knowledge-base. Knowledge is transferred by learning reusable skills to solve tasks in Minecraft. [...] These reusable skills, which we refer to as Deep Skill Networks, are then incorporated into our novel Hierarchical Deep Reinforcement Learning Network (H-DRLN) architecture using two techniques: (1) a deep skill array and (2) skill distillation, our novel variation of policy distillation (Rusu et. al. 2015) for learning skills.”</p>
<h3 id="abstractmarkovdecisionprocessesamdp"><a href="https://aaai.org/ocs/index.php/ICAPS/ICAPS17/paper/view/15759">Abstract Markov Decision Processes (AMDP)</a></h3>
<p>“We propose Abstract Markov Decision Process (AMDP) hierarchies as a method for reasoning about a network of subgoals. [...] An AMDP is an MDP whose states are abstract representations of the states of an underlying environment (the ground MDP). The actions of the AMDP are either primitive actions from the environment MDP or subgoals to be solved. [...] A major limitation of MAXQ is that value functions over the hierarchy are found by processing the state–action space at the lowest level and backing up values to the abstract subtask nodes (bottom-up process). [...] AMDPs model each subtask’s transition and reward functions locally, resulting in faster planning, since backup across multiple levels of the hierarchy is unnecessary. This top-down planning approach decides what a good subgoal is before planning to achieve it.”</p>
<figure>
<img src="https://thegradient.pub/content/images/2019/03/image45.png" width="800" data-action="zoom">
<figcaption>Left: starting position for the turtlebot. Middle: the turtlebot gets to the block. Right: it pushes the block into the goal room. <a href="https://aaai.org/ocs/index.php/ICAPS/ICAPS17/paper/view/15759">Source</a></figcaption>
</figure>
<h3 id="iterativehierarchicaloptimizationformisspecifiedproblemsimhop"><a href="https://arxiv.org/abs/1602.03348">Iterative Hierarchical Optimization for Misspecified Problems (IMHOP)</a></h3>
<p>“For complex, high-dimensional Markov Decision Processes (MDPs), it may be necessary to represent the policy with function approximation. A problem is mis- specified whenever, the representation cannot express any policy with acceptable performance. [...] We introduce a meta-algorithm, Iterative Hierarchical Optimization for Misspecified Problems (IHOMP), that uses an RL algorithm as a “black box” to iteratively learn options that repair MPs. To force the options to specialize, IHOMP uses a partition of the state-space and trains one option for each class in the partition.”</p>
<figure>
<img src="https://thegradient.pub/content/images/2019/03/image54.png" width="400" data-action="zoom">
<figcaption>An episodic MDP with S-shaped state-space and goal region G. (i) Flat approach, vs. (ii) Hierarchical approach. <a href="https://arxiv.org/abs/1602.03348">Source</a></figcaption>
</figure>
<h3 id="hsp"><a href="https://arxiv.org/abs/1811.09083">HSP</a></h3>
<p>“Our approach uses unsupervised asymmetric self-play [15] as a pre-training phase for the low-level policy, prior to training the hierarchical model. In self-play, the agent devises tasks for itself via the goal embedding and then attempts to solve them. [...] A high-level policy can then direct the lower one by generating a sequence of continuous sub-goal vectors. [...] These can then be utilized in a hierarchical RL framework to speed exploration on complex tasks with sparse reward. Experiments on AntGather demonstrate the ability of the resulting hierarchical controller to move the Ant long distances to obtain reward, unlike non-hierarchical policy gradient methods. One limitation of our self-play approach is that the choice of D (the distance function used to decide if the self-play task has been completed successfully or not) requires some domain knowledge.”</p>
<figure>
<img src="https://thegradient.pub/content/images/2019/03/image62-1.png" width="800" data-action="zoom">
<figcaption>HSP method architecture. <a href="https://arxiv.org/abs/1811.09083">Source</a></figcaption>
</figure>
<h3 id="learningrepresentationsinmodelfreehrl"><a href="https://arxiv.org/abs/1810.10096">Learning Representations in Model-Free HRL</a></h3>
<p>“We propose and implement a novel model-free method for subgoal discovery using incremental unsupervised learning over a small memory of the most recent experiences of the agent. When combined with an intrinsic motivation learning mechanism, this method learns subgoals and skills together, based on experiences in the environment. Thus, we offer an original approach to HRL that does not require the acquisition of a model of the environment, suitable for large-scale applications. We conducted experiments using our method on large-scale RL problems, such as portions of the difficult Atari 2600 game Montezuma’s Revenge.”</p>
<figure>
<img src="https://thegradient.pub/content/images/2019/03/image49.png" width="800" data-action="zoom">
<figcaption>From left to right: A sample screen from the ATARI 2600 game Montezuma’s Revenge; The CNN architecture for the controller’s value function; The CNN architecture for the meta- controller’s value function; The results of the unsupervised subgoal discovery algorithm. <a href="https://arxiv.org/abs/1810.10096">Source</a></figcaption>
</figure>    
<hr>

<p>In the field of cognitive science, research <sup data-footnote-backlink-ref="fnref35" data-footnote-ref="#fn35"><a href="#fn35" id="fnref35">[35]</a></sup><sup data-footnote-backlink-ref="fnref36" data-footnote-ref="#fn36"><a href="#fn36" id="fnref36">[36]</a></sup> has long suggested that human and animal behaviour is based on a hierarchical structure. There certainly is a shift that real-world and complex environments will require us to adopt. This could be found in one of the main appealing aspects of HRL: the use of skills to reduce the search complexity of the problem.</p>
<blockquote>
<p><em>"Stop learning tasks, start learning skills." -Satinder Singh, NeurIPS 2018</em></p>
</blockquote>
<p>However, depending on the framework used, specifying a good hierarchy by hand requires domain-specific knowledge and careful engineering, motivating the need for learning skills automatically. Essentially, to choose an appropriate hierarchy framework one needs to look how available the domain knowledge is (a friendly combination of the three is also conceivable <sup data-footnote-backlink-ref="fnref37" data-footnote-ref="#fn37"><a href="#fn37" id="fnref37">[37]</a></sup>):</p>
<ul>
<li>If the behaviours are completely specified → Options</li>
<li>If the behaviours are partially specified → HAM</li>
<li>If less domain knowledge is available → MAXQ, Learned Options <sup data-footnote-backlink-ref="fnref24:1" data-footnote-ref="#fn24"><a href="#fn24" id="fnref24:1">[24:1]</a></sup><sup data-footnote-backlink-ref="fnref32:1" data-footnote-ref="#fn32"><a href="#fn32" id="fnref32:1">[32:1]</a></sup></li>
</ul>
<p>In the table below, the columns imply:</p>
<ul>
<li><em>Temporal abstraction</em> allows representing knowledge about courses of action that take place at different time scales. We talk about temporally extended actions</li>
<li><em>State abstraction</em> occurs when a sub-task ignores some aspects of the state of the environment, it requires that sub-tasks be specified in terms of termination predicates as opposed to using the option or partial policy methods</li>
<li><em>"Sub-tasks: fixed policy provided by the programmer"</em> means given a set of options, the system learns a policy over those options</li>
<li><em>"Sub-tasks: non-deterministic finite-state controller"</em> means given a hierarchy of partial policies the system learns a policy for the entire problem</li>
<li><em>“Sub-tasks: termination predicate and a local reward function"</em> means given a set of sub-tasks the system learns policies for entire problem</li>
<li>A <em>hierarchical optimal policy</em> is a policy that is optimal among all the policies that can be expressed given the hierarchical structure</li>
<li>A <em>recursively optimal policy</em> is a policy optimal for each SMDP corresponding to each of the sub-tasks in the decomposition</li>
</ul>
<p><img src="https://thegradient.pub/content/images/2019/03/image66.png" alt="" data-action="zoom"></p>
<p>Comparison of the foundational HRL frameworks characteristics</p>
<p>Fundamentally, the promising benefits of HRL — faster learning by mitigating scaling problem, a powerful ability to tackle problems with large state/action by reducing the curse of dimensionality, using sub-goals and abstract actions on different tasks with state abstraction, using multiple levels of temporal abstraction, truer and better generalisation with transfer of knowledge from previous tasks — seem at reach, but not quite there yet.</p>
<p>There are a lot of great ideas and algorithms, but not quite a big impact or major adoption to date, and, to be honest, there is still a legitimate scepticism on the part of the RL community. On the one hand, challenges such as the non-stationarity generated by updating the levels of a hierarchical agent require more effort in implementation and introduce additional hyperparameters. On the other hand, we are still far from achieving reasonable sample efficiency, as <sup data-footnote-backlink-ref="fnref38" data-footnote-ref="#fn38"><a href="#fn38" id="fnref38">[38]</a></sup> pointed out: in the Options framework options are atomic macro-actions independent from each other. Thus we lose the potential benefit of considering interactions between options, which could be used to significantly improve the sample efficiency. Furthermore, HRL might actually not be a necessary fix to the limitations of flat RL, as stated in the <a href="https://blog.openai.com/openai-five/">OpenAI blog-post</a>: “RL researchers (including ourselves) have generally believed that long time horizons would require fundamentally new advances, such as hierarchical reinforcement learning. Our results suggest that we haven’t been giving today’s algorithms enough credit - at least when they’re run at sufficient scale and with a reasonable way of exploring.”</p>
<p>Until HRL frameworks benefit from greater user-friendliness and better technical specifications, HRL will not become standard for RL problems.</p>
<p>That said, these defects are known issues that are precisely in line with the main active research directions in HRL, including but not bounded to:</p>
<ul>
<li>Better management of the non-stationarity of the higher-level state transition functions</li>
<li>Learn hierarchies automatically</li>
<li>More efficient exploration</li>
<li>Enrich signal with efficient decomposition in environments with sparse rewards</li>
<li>Improve stability</li>
</ul>
<p>We already have observed hierarchical structures emerging in deep networks applied to perception tasks, such as computer vision with ConvNets, but these are hierarchical in the sense of perception. If we could build hierarchical temporal and behavioural systems in RL in the same way, that would have a significant impact like ConvNets had. There is still a lot of work ahead and a strong base for optimism.</p>

<p>If you’ve come this far, that means HRL is of decent interest for you. The goal of this write-up was to outline the main framework streams that served as inspiration for the subsequent contributions in HRL, to (hopefully) forge your interest for the domain if you were not familiar with it, and to encourage further discussion on the subject.</p>
<p>As we saw, both the Options framework and MAXQ decomposition provide algorithm designers with powerful tools to break down a problem hierarchically. Should you be interested in this line of research, you can choose the method that you think is the most promising to you, or the one that you think would benefit most from improvements. You can then develop new hypotheses to benchmark test, using open-source code (e.g. <a href="https://github.com/tensorflow/models/tree/master/research/efficient-hrl">HIRO</a>, <a href="https://github.com/andrew-j-levy/Hierarchical-Actor-Critc-HAC-">HAC</a>, <a href="https://github.com/openai/mlsh">MLSH</a>, <a href="https://github.com/tesatory/hsp">HSP</a>) to build on it with new ideas, or implementing a system by yourself by drawing inspiration from the many contributions mentioned above.</p>
<p>To conclude on a more general point, these developments cannot be quantified if they cannot be measured properly, and I have the feeling that there is still a lack of tools to efficiently measure progress made in HRL, and more broadly in RL at all. Fortunately, the community is <a href="https://blog.openai.com/quantifying-generalization-in-reinforcement-learning/">actively</a> <a href="https://arxiv.org/abs/1812.09521v1">working</a> on these issues as well. Of course, it is our responsibility to be aware of the problems inherent in our field that do not exhibit short-term difficulties but slow down progress in the long term. It is our duty to participate in their resolution and to contribute to progress in a reproducible way.</p>
<hr>
<p><em>Special thanks to Andrey Kurenkov, Hugh Zhang, Eric Wang, Steven Ban and Florian Strub for their feedback, suggestions, and insights.</em><br>
<em><a href="https://unsplash.com/photos/bJhT_8nbUA0">Cover image source</a>.</em></p>
<hr>
<p><em>Yannis Flet-Berliac is a PhD student at the University of Lille in the Inria SequeL team. His research project mainly involves deep reinforcement learning with a focus on stochastic and non stationary environments. Prior to starting his PhD, he worked in France and Denmark mostly on conversational models, machine translation and photographer style recognition. Find him on <a href="https://twitter.com/yfletberliac">Twitter</a>!</em></p>
<hr>
<p><em>If you enjoyed this piece and want to hear more, <a href="https://thegradient.pub/subscribe/">subscribe</a> to the Gradient and follow us on <a href="https://twitter.com/gradientpub">Twitter</a>.</em></p>
<hr>
<section>
<ol>
<li id="fn1"><p>Spelke and Kinzler. Core knowledge. Developmental science, 2007. <a href="#fnref1">↩︎</a></p>
</li>
<li id="fn2"><p>Szepesvári. Algorithms for Reinforcement Learning. Synthesis Lectures on Artificial Intelligence and Machine Learning, 2009. <a href="#fnref2">↩︎</a></p>
</li>
<li id="fn3"><p>Bellemare, Dabney, and Munos. A distributional perspective on reinforcement learning. ICML, 2017. <a href="#fnref3">↩︎</a></p>
</li>
<li id="fn4"><p>Jackson. On the comparative study of disease of the nervous system. British Medical Journal, 1889. <a href="#fnref4">↩︎</a></p>
</li>
<li id="fn5"><p>Mussa-Ivaldi and Bizzi. Motor learning through the combination of primitives. Philosophical Transactions of the Royal Society of London B: Biological Sciences, 2000. <a href="#fnref5">↩︎</a></p>
</li>
<li id="fn6"><p>Todorov et al. From task parameters to motor synergies: A hierarchical framework for approximately optimal control of redundant manipulators. Journal of robotic systems, 2005. <a href="#fnref6">↩︎</a></p>
</li>
<li id="fn7"><p>Arulkumaran et al. Deep reinforcement learning: A brief survey. IEEE Signal Processing Magazine, 2017. <a href="#fnref7">↩︎</a></p>
</li>
<li id="fn8"><p>Mnih et al. Human-level control through deep reinforcement learning. Nature, 2015. <a href="#fnref8">↩︎</a></p>
</li>
<li id="fn9"><p>Schmidhuber. Formal theory of creativity, fun, and intrinsic motivation (1990–2010). IEEE Transactions on Autonomous Mental Development, 2(3):230–247, 2010. <a href="#fnref9">↩︎</a></p>
</li>
<li id="fn10"><p>Pathak, et al. Curiosity-driven exploration by self-supervised prediction. ICML, 2017. <a href="#fnref10">↩︎</a></p>
</li>
<li id="fn11"><p>Sutton and Barto. Reinforcement learning: An introduction, volume 1. MIT press Cambridge, 1998. <a href="#fnref11">↩︎</a></p>
</li>
<li id="fn12"><p>Watkins. Learning from delayed rewards. PhD thesis. University of Cambridge England, 1989. <a href="#fnref12">↩︎</a> <a href="#fnref12:1">↩︎</a></p>
</li>
<li id="fn13"><p>Mnih et al. Human-level control through deep reinforcement learning. Nature, 2015. <a href="#fnref13">↩︎</a></p>
</li>
<li id="fn14"><p>Currie and Tate. O-plan: the open planning architecture. Artiﬁcial Intelligence, 1991. <a href="#fnref14">↩︎</a></p>
</li>
<li id="fn15"><p>Fikes, Hart and Nilsson. Learning and Executing Generalized Robot Plans. Artificial Intelligence, 1972. <a href="#fnref15">↩︎</a></p>
</li>
<li id="fn16"><p>Knoblock. Learning Abstraction Hierarchies for Problem Solving. AAAI, 1990. <a href="#fnref16">↩︎</a></p>
</li>
<li id="fn17"><p>Schmidhuber. Learning to generate sub-goals for action sequences. Proc. ICANN'91, pages 967-972, 1991. Based on TR FKI-129-90, 1990. <a href="#fnref17">↩︎</a></p>
</li>
<li id="fn18"><p>Oudeyer and Kaplan. What is intrinsic motivation? A typology of computational approaches. Front. Neurorobotics, 2009. <a href="#fnref18">↩︎</a></p>
</li>
<li id="fn19"><p>Schmidhuber. Curious model-building control systems. In Proc. International Joint Conference on Neural Networks, Singapore, volume 2, pages 1458-1463. IEEE, 1991. <a href="#fnref19">↩︎</a></p>
</li>
<li id="fn20"><p>Sutton, Precup and Singh. Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning. Artificial Intelligence, 1999. <a href="#fnref20">↩︎</a> <a href="#fnref20:1">↩︎</a></p>
</li>
<li id="fn21"><p>Dayan and Hinton. Feudal Reinforcement Learning. NIPS, 1993. <a href="#fnref21">↩︎</a> <a href="#fnref21:1">↩︎</a></p>
</li>
<li id="fn22"><p>Bacon, Harb and Precup. The Option-Critic Architecture. AAAI, 2017. <a href="#fnref22">↩︎</a></p>
</li>
<li id="fn23"><p>Fruit and Lazaric. Exploration-Exploitation in MDPs with Options. AISTATS, 2017. <a href="#fnref23">↩︎</a></p>
</li>
<li id="fn24"><p>Stolle and Precup. Learning Options in Reinforcement Learning. Lecture Notes in Computer Science, 2002. <a href="#fnref24">↩︎</a> <a href="#fnref24:1">↩︎</a></p>
</li>
<li id="fn25"><p>Schaul et al. Universal value function approximators. ICML, 2015. <a href="#fnref25">↩︎</a></p>
</li>
<li id="fn26"><p>Wiering and Schmidhuber. HQ-Learning. Adaptive Behavior 6(2):219-246, 1997. <a href="#fnref26">↩︎</a></p>
</li>
<li id="fn27"><p>Puterman. Markov Decision Processes: Discrete Stochastic Dynamic Programming, Chapter 11. John Wiley &amp; Sons, Inc, 1994. <a href="#fnref27">↩︎</a></p>
</li>
<li id="fn28"><p>(ie. the learnt policy will be the best policy consistent with the given hierarchy: task’s policy depends not only on its children’s policies, but also on its context) <a href="#fnref28">↩︎</a></p>
</li>
<li id="fn29"><p>Parr and Russell.  Reinforcement Learning with Hierarchies of Machines. MIT Press, 1998. <a href="#fnref29">↩︎</a></p>
</li>
<li id="fn30"><p>Dietterich. Hierarchical Reinforcement Learning with the MAXQ Value Function Decomposition. Artificial Intelligence, 2000. <a href="#fnref30">↩︎</a></p>
</li>
<li id="fn31"><p>Vezhnevets et al. FeUdal Networks for Hierarchical Reinforcement Learning. ICML, 2017. <a href="#fnref31">↩︎</a></p>
</li>
<li id="fn32"><p>Bacon, Harb, and Precup. The option-critic architecture. AAAI, 2017. <a href="#fnref32">↩︎</a> <a href="#fnref32:1">↩︎</a></p>
</li>
<li id="fn33"><p>Nachum et al. Data-Efficient Hierarchical Reinforcement Learning. CoRR, 2018. <a href="#fnref33">↩︎</a></p>
</li>
<li id="fn34"><p>(an off-policy setting is helping for sample efficiency but challenging to handle because off-policy RL creates a non-stationary problem for the higher-level policy since the lower-level is constantly changing) <a href="#fnref34">↩︎</a></p>
</li>
<li id="fn35"><p>Botvinick, Niv and Barto. Hierarchically organized behavior and its neural foundations: a reinforcement learning perspective. Cognition, 2008. <a href="#fnref35">↩︎</a></p>
</li>
<li id="fn36"><p>Badre, Kayser, and D’Esposito. Frontal cortex and the discovery of abstract action rules, 2010. <a href="#fnref36">↩︎</a></p>
</li>
<li id="fn37"><p>Cai et al. A  combined hierarchical  reinforcement  learning  based  approach  for  multi-robot  cooperative  target  searching  in  complex  unknown environments. IEEE, 2013. <a href="#fnref37">↩︎</a></p>
</li>
<li id="fn38"><p>Fruit, Pirotta, Lazaric, Brunskill. Regret Minimization in MDPs with Options without Prior Knowledge. NIPS, 2017. <a href="#fnref38">↩︎</a></p>
</li>
</ol>
</section>
</div>
        </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>