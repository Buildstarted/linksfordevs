<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Candidate Features For C# 9 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Candidate Features For C# 9 - linksfor.dev(s)"/>
    <meta property="article:author" content="Bassam Alugili"/>
    <meta property="og:description" content="In this article, you will learn candidate features in C# 9."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.c-sharpcorner.com/article/candidate-features-for-c-sharp-9/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Candidate Features For C# 9</title>
<div class="readable">
        <h1>Candidate Features For C# 9</h1>
            <div>by Bassam Alugili</div>
            <div>Reading time: 13-16 minutes</div>
        <div>Posted here: 31 May 2019</div>
        <p><a href="https://www.c-sharpcorner.com/article/candidate-features-for-c-sharp-9/">https://www.c-sharpcorner.com/article/candidate-features-for-c-sharp-9/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="div2"><p>The long road to C# 9 has already begun and this is the first article in the world about the C# 9 Candidate features. Once you have completed reading this article, you will hopefully be better prepared for the new C# challenges you will meet in the future.</p>  <p>The article is based on,</p>  <h2>Records and Pattern-based With-Expression</h2>  <p>I have been waiting for a long time for this feature. Records is a lightweight immutable type. They are nominally typed, and they might have (methods, properties, operators, etc) and allow you to compare structural equality! Also, the record properties are read-only by default.</p>  <p> Records can be Value Type or Reference Type.</p>  <p><strong>Example</strong></p>  <div>  <ol start="1"> <li><span><span>public</span><span>&nbsp;</span><span>class</span><span>&nbsp;Point3D(</span><span>double</span><span>&nbsp;X,&nbsp;</span><span>double</span><span>&nbsp;Y,&nbsp;</span><span>double</span><span>&nbsp;Z);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span><span>public</span><span>&nbsp;</span><span>class</span><span>&nbsp;Demo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;<span>public</span><span>&nbsp;</span><span>void</span><span>&nbsp;CreatePoint()&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;var&nbsp;p&nbsp;=&nbsp;<span>new</span><span>&nbsp;Point3D(1.0,&nbsp;1.0,&nbsp;1.0);&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;&nbsp;}&nbsp;&nbsp;</span></li> <li><span>}&nbsp;&nbsp;</span></li> </ol> </div> <p>The code above is converted to,</p>  <div>  <ol start="1"> <li><span><span>public</span><span>&nbsp;</span><span>class</span><span>&nbsp;Point3D&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span><span>private</span><span>&nbsp;</span><span>readonly</span><span>&nbsp;</span><span>double</span><span>&nbsp;&lt;X&gt;k__BackingField;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span><span>private</span><span>&nbsp;</span><span>readonly</span><span>&nbsp;</span><span>double</span><span>&nbsp;&lt;Y&gt;k__BackingField;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span><span>private</span><span>&nbsp;</span><span>readonly</span><span>&nbsp;</span><span>double</span><span>&nbsp;&lt;Z&gt;k__BackingField;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span><span>public</span><span>&nbsp;</span><span>double</span><span>&nbsp;X&nbsp;{</span><span>get</span><span>&nbsp;{</span><span>return</span><span>&nbsp;&lt;X&gt;k__BackingField;}}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span><span>public</span><span>&nbsp;</span><span>double</span><span>&nbsp;Y{</span><span>get</span><span>{</span><span>return</span><span>&nbsp;&lt;Y&gt;k__BackingField;}}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span><span>public</span><span>&nbsp;</span><span>double</span><span>&nbsp;Z{</span><span>get</span><span>{</span><span>return</span><span>&nbsp;&lt;Z&gt;k__BackingField;}}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;Point3D(</span><span>double</span><span>&nbsp;X,&nbsp;</span><span>double</span><span>&nbsp;Y,&nbsp;</span><span>double</span><span>&nbsp;Z)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&lt;X&gt;k__BackingField&nbsp;=&nbsp;X;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&lt;Y&gt;k__BackingField&nbsp;=&nbsp;Y;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&lt;Z&gt;k__BackingField&nbsp;=&nbsp;Z;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>bool</span><span>&nbsp;Equals(Point3D&nbsp;value)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;<span>return</span><span>&nbsp;X&nbsp;==&nbsp;value.X&nbsp;&amp;&amp;&nbsp;Y&nbsp;==&nbsp;value.Y&nbsp;&amp;&amp;&nbsp;Z&nbsp;==&nbsp;value.Z;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>override</span><span>&nbsp;</span><span>bool</span><span>&nbsp;Equals(</span><span>object</span><span>&nbsp;value)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;Point3D&nbsp;value2;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;<span>return</span><span>&nbsp;(value2&nbsp;=&nbsp;(value&nbsp;</span><span>as</span><span>&nbsp;Point3D))&nbsp;!=&nbsp;</span><span>null</span><span>&nbsp;&amp;&amp;&nbsp;Equals(value2);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>override</span><span>&nbsp;</span><span>int</span><span>&nbsp;GetHashCode()&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;<span>return</span><span>&nbsp;((1717635750&nbsp;*&nbsp;-1521134295&nbsp;+&nbsp;&nbsp;EqualityComparer&lt;</span><span>double</span><span>&gt;.Default.GetHashCode(X))&nbsp;*&nbsp;-1521134295&nbsp;+&nbsp;EqualityComparer&lt;</span><span>double</span><span>&gt;.Default.GetHashCode(Y))&nbsp;*&nbsp;-1521134295&nbsp;+&nbsp;&nbsp;EqualityComparer&lt;</span><span>double</span><span>&gt;.Default.GetHashCode(Z);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>Using&nbsp;Records:&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span><span>public</span><span>&nbsp;</span><span>class</span><span>&nbsp;Demo&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>void</span><span>&nbsp;CreatePoint()&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;Point3D&nbsp;point3D&nbsp;=&nbsp;<span>new</span><span>&nbsp;Point3D(1.0,&nbsp;1.0,&nbsp;1.0);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>}&nbsp;&nbsp;</span></li> </ol> </div> <p>Records proposal is introduced with the new proposed feature "with-expression", and you can use them together like the following,</p> <div>  <ol start="1"> <li><span><span>var&nbsp;newPoint3D&nbsp;=&nbsp;point3D.With(x:&nbsp;42);&nbsp; &nbsp;</span></span></li> </ol> </div> <p>The created new point (newPoint3D) just like the existing one (point3D), but with the value of X changed to 42.</p>  <p>This future is also working very well with pattern matching. I will cover this topic in a separate article.</p>  <h2>Records in F#</h2>  <p>Copy from F# MSDN example, type Point3D = {X: float; Y: float; Z: float}</p>  <div>  <ol start="1"> <li><span><span>let&nbsp;evaluatePoint&nbsp;(point:&nbsp;Point3D)&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>match&nbsp;point&nbsp;with&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;0.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span>"Point&nbsp;is&nbsp;at&nbsp;the&nbsp;origin."</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;xVal;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span>"Point&nbsp;is&nbsp;on&nbsp;the&nbsp;x-axis.&nbsp;Value&nbsp;is&nbsp;%f."</span><span>&nbsp;xVal&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;0.0;&nbsp;Y&nbsp;=&nbsp;yVal;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span>"Point&nbsp;is&nbsp;on&nbsp;the&nbsp;y-axis.&nbsp;Value&nbsp;is&nbsp;%f."</span><span>&nbsp;yVal&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;0.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;zVal&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span>"Point&nbsp;is&nbsp;on&nbsp;the&nbsp;z-axis.&nbsp;Value&nbsp;is&nbsp;%f."</span><span>&nbsp;zVal&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>|&nbsp;{&nbsp;X&nbsp;=&nbsp;xVal;&nbsp;Y&nbsp;=&nbsp;yVal;&nbsp;Z&nbsp;=&nbsp;zVal&nbsp;}&nbsp;-&gt;&nbsp;printfn&nbsp;<span>"Point&nbsp;is&nbsp;at&nbsp;(%f,&nbsp;%f,&nbsp;%f)."</span><span>&nbsp;xVal&nbsp;yVal&nbsp;zVal&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>evaluatePoint&nbsp;{&nbsp;X&nbsp;=&nbsp;0.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>evaluatePoint&nbsp;{&nbsp;X&nbsp;=&nbsp;100.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;0.0&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>evaluatePoint&nbsp;{&nbsp;X&nbsp;=&nbsp;10.0;&nbsp;Y&nbsp;=&nbsp;0.0;&nbsp;Z&nbsp;=&nbsp;-1.0&nbsp;}&nbsp;&nbsp;&nbsp;</span></li> </ol> </div>  <p>The output of this code is as follows.</p> <div> <ul> <li>Point is at the origin.</li> <li>Point is on the x-axis. Value is 100.000000.</li> <li>Point is at (10.000000, 0.000000, -1.000000).</li> </ul> </div> <p>The first question which comes to my mind why do we need Records? Is it not better to use a struct?</p>  <p>To answer the questions, I have posted a quote from Reddit:</p>  <p>"Structs are a thing you have to have some discipline to implement. You don't have to make them immutable. You don't have to implement their value equality logic. You don't have to make them comparable. If you don't, you lose almost all of their benefits, but the compiler doesn't enforce any of these constraints.</p>  <p>Record types are implemented by the compiler, which means you have to meet all of those criteria and can't get them wrong.</p>  <p>So not only do they save a lot of boilerplate, they eliminate an entire class of potential bugs.</p>  <p>Moreover, this feature existed over a decade in F#, and other languages like (Scala, Kotlin) have a similar concept too.</p>  <p>Examples for other languages that support both constructors and records,</p>  <p><strong>F#</strong></p> <div> <div>  <ol start="1"> <li><span><span>type&nbsp;Greeter(name:&nbsp;</span><span>string</span><span>)&nbsp;=&nbsp;member&nbsp;</span><span>this</span><span>.SayHi()&nbsp;=&nbsp;printfn&nbsp;</span><span>"Hi,&nbsp;%s"</span><span>&nbsp;name&nbsp;&nbsp;</span></span></li> </ol> </div> </div> <p><strong>Scala</strong></p>  <div>  <ol start="1"> <li><span><span>class</span><span>&nbsp;Greeter(name:&nbsp;String)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;def&nbsp;SayHi()&nbsp;=&nbsp;println(<span>"Hi,&nbsp;"</span><span>&nbsp;+&nbsp;name)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp;&nbsp;</span></li> </ol> </div> <p><strong>Kotlin</strong></p>  <div>  <ol start="1"> <li><span><span>class</span><span>&nbsp;Greeter(val&nbsp;name:&nbsp;String)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;fun&nbsp;sayhi()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;println(<span>"Hi,&nbsp;${name}"</span><span>);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>}&nbsp; &nbsp;</span></li> </ol> </div> <p>Meanwhile, we are still writing in C# the long code below,</p>  <div>  <ol start="1"> <li><span><span>public</span><span>&nbsp;</span><span>class</span><span>&nbsp;Greeter</span></span></li> <li><span>{</span></li> <li><span>&nbsp;<span>private</span><span>&nbsp;</span><span>readonly</span><span>&nbsp;</span><span>string</span><span>&nbsp;_name;</span></span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;Greeter(</span><span>string</span><span>&nbsp;name)</span></span></li> <li><span>&nbsp;{</span></li> <li><span>&nbsp;_name&nbsp;=&nbsp;name;</span></li> <li><span>&nbsp;}</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>void</span><span>&nbsp;Greet()</span></span></li> <li><span>&nbsp;{</span></li> <li><span>&nbsp;&nbsp;Console.WriteLine($&nbsp;<span>"Hello,&nbsp;{_name}"</span><span>);</span></span></li> <li><span>&nbsp;}</span></li> <li><span>}</span></li> </ol> </div> <p>When this feature is done, then we can reduce the C# code to,</p>  <div>  <ol start="1"> <li><span><span>public</span><span>&nbsp;</span><span>class</span><span>&nbsp;Greeter(name:&nbsp;</span><span>string</span><span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>void</span><span>&nbsp;Greet()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;Console.WriteLine($&nbsp;<span>"Hello,&nbsp;{_name}"</span><span>);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>}&nbsp; &nbsp;&nbsp;</span></li> </ol> </div> <p>Less code! = I love it!</p>  <h2>Type Classes</h2>  <p>This feature is inspired from Haskell and it is one of my favorite features. As I said before, two years ago in my old article, C# is going to implement more functional programming concepts and this is one of those FP- concepts. In functional programming, Type Classes allow you to add a set of operations on a type, but not implement it. Since the implementation is done elsewhere, this is a form of polymorphism, but lots more flexible or ad-hoc than the classical kind in object-oriented programming languages.</p>  <p>Type classes and C# interfaces serve similar purposes, but the way they work is somewhat different, and in some cases, Type Classes are more straightforward to use because of working on fixed types rather than pieces of an inheritance hierarchy.</p>  <p>This feature was originally introduced together with “extending everything” feature, and you can combine them as shown below in Mads Torgersen example.</p>  <p>I have quoted some text from the official proposal:</p>  <p>"In general, a "shape" declaration is very much like an interface declaration, except that it,</p> <div> <ul> <li>Can define almost any kind of member (including static members)</li> <li>Can be implemented by an extension</li> <li>Can be used as a type only in certain places."</li> </ul> </div> <p>Haskell Type Class example.</p>  <div>  <ol start="1"> <li><span><span>class</span><span>&nbsp;Eq&nbsp;a&nbsp;where&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>(==)&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;a&nbsp;-&gt;&nbsp;Bool&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>(/=)&nbsp;::&nbsp;a&nbsp;-&gt;&nbsp;a&nbsp;-&gt;&nbsp;Bool&nbsp; &nbsp;</span></li> </ol> </div> <p>"Eq" is the class name, and ==, /= are the operations in the class. A type "a" is an instance of the class "Eq".</p>  <p>Haskell example as a generic C# interface,</p>  <div>  <ol start="1"> <li><span><span>interface</span><span>&nbsp;Eq&nbsp;&lt;A&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>bool</span><span>&nbsp;Equal(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>bool</span><span>&nbsp;NotEqual(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp;&nbsp;</span></li> </ol> </div> <p>Haskell example as Type Classes in C# 9(shape is a new distinctive keyword for Type classes),</p>  <div>  <ol start="1"> <li><span><span>shape&nbsp;Eq&lt;A&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>bool</span><span>&nbsp;Equal(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>bool</span><span>&nbsp;NotEqual(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp; &nbsp;</span></li> </ol> </div> <p>Example to show the syntax similarity between interfaces and type classes,</p>  <div>  <ol start="1"> <li><span><span>interface</span><span>&nbsp;Num&lt;A&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;A&nbsp;Add(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;A&nbsp;Mult(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;A&nbsp;Neg(A&nbsp;a);&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span><span>struct</span><span>&nbsp;NumInt&nbsp;:&nbsp;Num&lt;</span><span>int</span><span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>int</span><span>&nbsp;Add(</span><span>int</span><span>&nbsp;a,&nbsp;</span><span>int</span><span>&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;+&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>int</span><span>&nbsp;Mult(</span><span>int</span><span>&nbsp;a,&nbsp;</span><span>int</span><span>&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;*&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>int</span><span>&nbsp;Neg(</span><span>int</span><span>&nbsp;a)&nbsp;=&gt;&nbsp;-a;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp; &nbsp;&nbsp;</span></li> </ol> </div> <p>With C# 9 Type Classes concept C#,</p>  <div>  <ol start="1"> <li><span><span>shape&nbsp;Num&lt;A&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;A&nbsp;Add(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;A&nbsp;Mult(A&nbsp;a,&nbsp;A&nbsp;b);&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;A&nbsp;Neg(A&nbsp;a);&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>instance&nbsp;NumInt&nbsp;:&nbsp;Num&lt;<span>int</span><span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>int</span><span>&nbsp;Add(</span><span>int</span><span>&nbsp;a,&nbsp;</span><span>int</span><span>&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;+&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>int</span><span>&nbsp;Mult(</span><span>int</span><span>&nbsp;a,&nbsp;</span><span>int</span><span>&nbsp;b)&nbsp;=&gt;&nbsp;a&nbsp;*&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>int</span><span>&nbsp;Neg(</span><span>int</span><span>&nbsp;a)&nbsp;=&gt;&nbsp;-a;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp; &nbsp;&nbsp;</span></li> </ol> </div> <h2>Mads Torgersen Example</h2>  <p>Important information: a shape is not a type. Instead, the primary purpose of a shape is to be used as a generic constraint, limiting type arguments to have the right shape, while allowing the body of the generic declaration to make use of that shape,</p>    <div>  <ol start="1"> <li><span><span>public</span><span>&nbsp;shape&nbsp;SGroup&lt;T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>static</span><span>&nbsp;T&nbsp;</span><span>operator</span><span>&nbsp;+(T&nbsp;t1,&nbsp;T&nbsp;t2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>static</span><span>&nbsp;T&nbsp;Zero&nbsp;{</span><span>get</span><span>;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp;&nbsp;</span></li> </ol> </div> <p>This declaration says that a type can be an SGroup&lt;T&gt; if it implements a+ operator over T, and a Zero static property.</p>  <div>  <ol start="1"> <li><span><span>public</span><span>&nbsp;extension&nbsp;IntGroup&nbsp;of&nbsp;</span><span>int</span><span>:&nbsp;SGroup&lt;</span><span>int</span><span>&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>static</span><span>&nbsp;</span><span>int</span><span>&nbsp;Zero&nbsp;=&gt;&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp; &nbsp;</span></li> </ol> </div> <p>And the extension.</p>  <div>  <ol start="1"> <li><span><span>public</span><span>&nbsp;</span><span>static</span><span>&nbsp;AddAll&lt;T&gt;(T[]&nbsp;ts)&nbsp;where&nbsp;T:&nbsp;SGroup&lt;T&gt;&nbsp;</span><span>&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;var&nbsp;result&nbsp;=&nbsp;T.Zero;&nbsp;<span>&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>foreach</span><span>&nbsp;(var&nbsp;t&nbsp;</span><span>in</span><span>&nbsp;ts)&nbsp;{&nbsp;result&nbsp;+=&nbsp;t;&nbsp;}&nbsp;</span><span>&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>return</span><span>&nbsp;result;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp; &nbsp;</span></li> </ol> </div> <p>Let us call the AddAll method with some ints,</p>  <div>  <ol start="1"> <li><span><span>int</span><span>[]&nbsp;numbers&nbsp;=&nbsp;{&nbsp;5,&nbsp;1,&nbsp;9,&nbsp;2,&nbsp;3,&nbsp;10,&nbsp;8,&nbsp;4,&nbsp;7,&nbsp;6&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>WriteLine(AddAll(numbers));&nbsp;<span>&nbsp;&nbsp;</span></span></li> </ol> </div> <h2>Dictionary Literals</h2>  <p>Introduces a simpler syntax to create initialized Dictionary&lt;TKey,TValue&gt; objects without having to specify either the Dictionary type name or the type parameters. The type parameters for the dictionary are inferred using the existing rules used for array type inference.</p>  <div>  <ol start="1"> <li><span><span>&nbsp;&nbsp;</span></span></li> <li><span>var&nbsp;x&nbsp;=&nbsp;<span>new</span><span>&nbsp;Dictionary&nbsp;&lt;</span><span>string</span><span>,</span><span>int</span><span>&gt;&nbsp;()&nbsp;{&nbsp;{&nbsp;</span><span>"foo"</span><span>,&nbsp;4&nbsp;},&nbsp;{&nbsp;</span><span>"bar"</span><span>,&nbsp;5&nbsp;}};&nbsp;&nbsp;&nbsp;</span></span></li> <li><span><span>&nbsp;&nbsp;</span></span></li> <li><span>var&nbsp;x&nbsp;=&nbsp;[<span>"foo"</span><span>:4,&nbsp;</span><span>"bar"</span><span>:&nbsp;5];&nbsp;&nbsp;</span></span></li> </ol> </div> <p>This proposal makes the work with dictionaries in C# simpler and removing the redundant code. In addition, it is worth to mention that a similar dictionary-syntax is used in other programming languages like F# and Swift.</p>  <h2>Params Span&lt;T&gt;</h2>  <p>Allows the params syntax to use Span&lt;T&gt; this help to implement params parameter-passing without any heap allocation. This feature could make the use of params methods much more efficient.</p>  <p>The new Syntax could be like,</p> <div> <div>  <ol start="1"> <li><span><span>void</span><span>&nbsp;Foo(</span><span>params</span><span>&nbsp;Span&lt;</span><span>int</span><span>&gt;&nbsp;values);&nbsp; &nbsp;</span></span></li> </ol> </div> </div> <h2>Allow no-arg constructor and field initializers in struct declarations</h2>  <p>Until now no-arg constructor and field initializers in struct declarations are not allowed in C#. In C# 9, this limitation will be removed.</p>  <p><strong>StackOverflow example</strong></p>  <div>  <ol start="1"> <li><span><span>public</span><span>&nbsp;</span><span>struct</span><span>&nbsp;Rational&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>private</span><span>&nbsp;</span><span>long</span><span>&nbsp;numerator;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>private</span><span>&nbsp;</span><span>long</span><span>&nbsp;denominator;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;Rational(</span><span>long</span><span>&nbsp;num,&nbsp;</span><span>long</span><span>&nbsp;denom)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;{&nbsp;<span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;Rational(</span><span>long</span><span>&nbsp;num)&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;numerator&nbsp;=&nbsp;num;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;denominator&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;Rational()&nbsp;</span><span>&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;numerator&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;denominator&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>}&nbsp; &nbsp;</span></li> </ol> </div>   <p>Quoted Text from the official proposal,</p>  <p>"HaloFour commented on Nov 6, 2017</p>  <p>Proposal #99.</p>  <p>That proposal seeks to remove the language limitation which prevents declaring a default constructor. The CLR already fully supports structs with default constructors, and C# supports using them. They are entirely unrelated to constants and couldn't be related to constants given that the feature already exists at the CLR level and behaves differently."</p>  <h2>Native-Sized Number Types</h2>  <p>Introduces a new set of native types (nint, nuint, nfloat, etc) the ‘n’ for native. The design of the new data types is planned to allow a one C# source file to use 32 naturally- or 64-bit storage depending on the host platform type and the compilation settings.</p>  <p>The native type is depending on the OS,</p>  <div>  <ol start="1"> <li><span><span>nint&nbsp;nativeInt&nbsp;=&nbsp;55;&nbsp;take&nbsp;4&nbsp;bytes&nbsp;when&nbsp;I&nbsp;compile&nbsp;</span><span>in</span><span>&nbsp;32&nbsp;Bit&nbsp;host.&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>nint&nbsp;nativeInt&nbsp;=&nbsp;55;&nbsp;take&nbsp;8&nbsp;bytes&nbsp;when&nbsp;I&nbsp;compile&nbsp;<span>in</span><span>&nbsp;64&nbsp;Bit&nbsp;host&nbsp;with&nbsp;x64&nbsp;compilation&nbsp;settings.&nbsp; &nbsp;</span></span></li> </ol> </div> <p>A similar concept exists already in xamarin,</p>  <h2>Fixed Sized Buffers</h2>  <p>These provide a general-purpose and safe mechanism for declaring fixed sized buffers to the C# language.</p>  <p>“Motivation Today, users can create fixed-sized buffers in an unsafe-context. However, this requires the user to deal with pointers, manually perform bounds checks, and only supports a limited set of types (bool, byte, char, short, int, long, sbyte, ushort, uint, ulong, float, and double).”</p>  <p>This feature will make fixed-sized buffer safe as in the example below.</p>  <p>One would declare a safe fixed-sized buffer via the following,</p> <div> <div>  <ol start="1"> <li><span><span>public</span><span>&nbsp;</span><span>fixed</span><span>&nbsp;DXGI_RGB&nbsp;GammaCurve[1025];&nbsp; &nbsp;</span></span></li> </ol> </div> </div> <p>The declaration would get translated into an internal representation by the compiler that is similar to the following,</p>  <div>  <ol start="1"> <li><span><span>[FixedBuffer(</span><span>typeof</span><span>(DXGI_RGB),&nbsp;1024)]&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span><span>public</span><span>&nbsp;ConsoleApp1.&lt;Buffer&gt;e__FixedBuffer_1024&lt;DXGI_RGB&gt;&nbsp;GammaCurve;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span><span>&nbsp;&nbsp;</span></span></li> <li><span>[CompilerGenerated,&nbsp;UnsafeValueType,&nbsp;StructLayout(LayoutKind.Sequential,&nbsp;Pack&nbsp;=&nbsp;0)]&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span><span>struct</span><span>&nbsp;&lt;Buffer&gt;e__FixedBuffer_1024&lt;T&gt;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;<span>private</span><span>&nbsp;T&nbsp;_e0;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>private</span><span>&nbsp;T&nbsp;_e1;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>private</span><span>&nbsp;T&nbsp;_e1024;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>public</span><span>&nbsp;</span><span>ref</span><span>&nbsp;T&nbsp;</span><span>this</span><span>[</span><span>int</span><span>&nbsp;index]&nbsp;=&gt;&nbsp;</span><span>ref</span><span>&nbsp;(</span><span>uint</span><span>)index&nbsp;&lt;=&nbsp;1024u&nbsp;?&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>ref</span><span>&nbsp;RefAdd&lt;T&gt;(</span><span>ref</span><span>&nbsp;_e0,&nbsp;index):&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;<span>throw</span><span>&nbsp;</span><span>new</span><span>&nbsp;IndexOutOfRange();&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> </ol> </div>  <h2>Uft8 string literals</h2>  <p>It is about defining a new type of UTF8String which will be like,</p> <div> <div>  <ol start="1"> <li><span><span>System.UTF8String&nbsp;myUTF8string&nbsp;=</span><span>"Test&nbsp;String"</span><span>;&nbsp;&nbsp;&nbsp;</span></span></li> </ol> </div> </div> <p><strong>based(T)</strong></p>  <p>The problem,</p>  <div>  <ol start="1"> <li><span><span>interface</span><span>&nbsp;I1&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span>void</span><span>&nbsp;M(</span><span>int</span><span>)&nbsp;{&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span><span>interface</span><span>&nbsp;I2&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span>void</span><span>&nbsp;M(</span><span>short</span><span>)&nbsp;{&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span><span>interface</span><span>&nbsp;I3&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span>override</span><span>&nbsp;</span><span>void</span><span>&nbsp;I1.M(</span><span>int</span><span>)&nbsp;{&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span><span>interface</span><span>&nbsp;I4&nbsp;:&nbsp;I3&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;<span>void</span><span>&nbsp;M2()&nbsp;&nbsp;&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>base</span><span>(I3).M(0)&nbsp;</span><span>&nbsp;&nbsp;</span></span></li> <li><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;</span></li> <li><span>}&nbsp;&nbsp;</span></li> </ol> </div> <p>"The tricky part here is that both M(short) and M(int) are applicable to M(0), but lookup rules also say that if we find an applicable member in a more derived interface, we ignore members from the less derived interfaces. Combined with the rule that overrides are not found during lookup, when looking in I3 the first thing we find is I2.M, which is applicable, meaning that I1.M does not appear in the list of applicable members.</p>  <p>Since we concluded in the previous meeting that an implementation must exist in the target type, and I2.M is the only applicable member, the call base(I3).M(0) as written is an error, because I2.M does not have an implementation in I3."</p>  <p>More Information,</p> <div> <ul> <li><em>https://github.com/dotnet/csharplang/issues/2337</em></li> <li><em>https://github.com/dotnet/csharplang/blob/master/meetings/2019/LDM-2019-02-27.md</em></li> </ul> </div> <h2>Summary</h2>  <p>You have read the first C# 9 Candidate features. As you have seen, many new features are inspired from other programming languages or programming paradigms, and not self-innovation, but the good thing is that the most of candidate features are well accepted among the community.</p> </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>