<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Bevy - Introducing Bevy - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Bevy - Introducing Bevy - linksfor.dev(s)"/>
    <meta property="og:description" content="Bevy is a refreshingly simple data-driven game engine built in Rust. It is free and open-source forever!"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://bevyengine.org/news/introducing-bevy/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Bevy - Introducing Bevy</title>
<div class="readable">
        <h1>Bevy - Introducing Bevy</h1>
            <div>Reading time: 50-63 minutes</div>
        <div>Posted here: 12 Aug 2020</div>
        <p><a href="https://bevyengine.org/news/introducing-bevy/">https://bevyengine.org/news/introducing-bevy/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
<p>After months of work, I am ecstatic to finally announce <strong>Bevy Engine</strong>!</p>
<p>Bevy is a refreshingly simple data-driven game engine and app framework built in Rust. It is <a href="https://github.com/bevyengine/bevy">free and open-source</a> forever!</p>
<p>It has the following design goals:</p>
<ul>
<li><b>Capable</b>: Offer a complete 2D and 3D feature set</li>
<li><b>Simple</b>: Easy for newbies to pick up, but infinitely flexible for power users</li>
<li><b>Data Focused</b>: Data-oriented architecture using the Entity Component System paradigm </li>
<li><b>Modular</b>: Use only what you need. Replace what you don't like</li>
<li><b>Fast</b>: App logic should run quickly, and when possible, in parallel</li>
<li><b>Productive</b>: Changes should compile quickly ... waiting isn't fun</li>
</ul>
<p>Bevy has a number of features that I think set it apart from other engines:</p>
<ul>
<li><b>Bevy ECS</b>: A custom Entity Component System with unrivaled usability and blisteringly-fast performance</li>
<li><b>Render Graphs</b>: Easily build your own multi-threaded render pipelines using Render Graph nodes</li>
<li><b>Bevy UI</b>: A custom ECS-driven UI framework built specifically for Bevy</li>
<li><b>Productive Compile Times</b>: Expect changes to compile in ~0.8-3.0 seconds with the "fast compiles" config</li>
</ul>
<p>It also has many features most people expect from a modern, general purpose engine:</p>
<ul>
<li><b>Cross Platform</b>: Windows, MacOS, and Linux (with planned support for mobile and web)</li>
<li><b>3D</b>: Lights, meshes, textures, MSAA, and GLTF loading</li>
<li><b>Sprites</b>: Render individual images as sprites, render from sprite sheets, and dynamically generate new sprite sheets</li>
<li><b>Assets</b>: An extensible, event driven asset system that loads assets asynchronously in background threads</li>
<li><b>Scenes</b>: Save ECS Worlds to human-readable scene files and load scene files into ECS Worlds</li>
<li><b>Plugins</b>: All engine and app features are implemented as modular plugins</li>
<li><b>Sound</b>: Load audio files as assets and play them from within systems</li>
<li><b>Multiple Render Backends</b>: Vulkan, DirectX 12, and Metal (with more on the way thanks to <a href="https://github.com/gfx-rs/wgpu-rs">wgpu</a>)</li>
<li><b>Data Driven Shaders</b>: Easily bind ECS components directly to shader uniforms</li>
<li><b>Hot Asset Reloading</b>: Automatically reload changes to assets at runtime without recompiles or restarts</li>
<li><b>Events</b>: Efficiently consume and produce Events from within ECS systems</li>
<li><b>Properties</b>: Dynamically get and set component fields using a string version of their names</li>
<li><b>Hierarchical Transforms</b>: Create parent-child relationships between entities that propagate Transforms down the hierarchy </li>
</ul>
<p>That being said, Bevy is still in the very early stages. I consider it to be in the "prototyping" phase: features are missing, APIs will change, and documentation is sparse. <span>I don't yet recommend using Bevy in serious projects unless you are willing to deal with gaps and instability</span>.</p>
<p>Hopefully at this point you are either (1) jazzed about Bevy or (2) not reading anymore. If you want to dive in right now, <a href="https://bevyengine.org/learn/book/introduction/">The Bevy Book</a> is the best place to get started. You can also keep reading to find out what the current state of Bevy is and where we'd like to take it.</p>
<p><strong>Quick note to the reader</strong>: in this article you will find text formatted like this: <a href="https://docs.rs/bevy_render/latest/bevy_render/texture/struct.Texture.html"><code>Texture</code>
</a></p>
<p>This formatting indicates that the text is a Rust type that links to API documentation. I encourage you to click on anything that seems interesting to you!</p>
<h2 id="bevy-apps">Bevy Apps</h2>
<p>First, lets see what a Bevy App actually looks like. The simplest App looks like this:</p>
<pre><code><span>use </span><span>bevy</span><span>::</span><span>prelude</span><span>::*;

</span><span>fn </span><span>main</span><span>() {
    </span><span>App</span><span>::</span><span>build</span><span>().</span><span>run</span><span>();
}
</span></code></pre>
<p>Thats it! This App pulls in no features and literally does nothing. Running the program would just immediately terminate. We can make it a little more interesting by doing this:</p>
<pre><code><span>fn </span><span>main</span><span>() {
    </span><span>App</span><span>::</span><span>build</span><span>()
        .</span><span>add_default_plugins</span><span>()
        .</span><span>run</span><span>();
}
</span></code></pre>
<p><a href="https://docs.rs/bevy/latest/bevy/trait.AddDefaultPlugins.html#method.add_default_plugins"><code>add_default_plugins()</code>
</a> adds all of the features you probably expect from a game engine: a 2D / 3D renderer, asset loading, a UI system, windows, input, etc</p>
<p>You can also register the default <a href="https://docs.rs/bevy_app/latest/bevy_app/trait.Plugin.html"><code>Plugins</code>
</a> manually like this:</p>
<pre><code><span>fn </span><span>main</span><span>() {
    </span><span>App</span><span>::</span><span>build</span><span>()
        .</span><span>add_plugin</span><span>(</span><span>CorePlugin</span><span>::</span><span>default</span><span>())
        .</span><span>add_plugin</span><span>(</span><span>InputPlugin</span><span>::</span><span>default</span><span>())
        .</span><span>add_plugin</span><span>(</span><span>WindowPlugin</span><span>::</span><span>default</span><span>())
        .</span><span>add_plugin</span><span>(</span><span>RenderPlugin</span><span>::</span><span>default</span><span>())
        .</span><span>add_plugin</span><span>(</span><span>UiPlugin</span><span>::</span><span>default</span><span>())
        </span><span>/* more plugins here ... omitted for brevity */
        </span><span>.</span><span>run</span><span>();
}
</span></code></pre>
<p>And of course you can also create your own plugins. In fact, all engine and game logic is built using plugins. Hopefully now you understand what we mean by modular: you are free to add/remove plugins based on your project's unique needs. However I expect that most people will stick to <a href="https://docs.rs/bevy/latest/bevy/trait.AddDefaultPlugins.html#method.add_default_plugins"><code>add_default_plugins()</code>
</a> for simplicity, at least initially. </p>
<h2 id="bevy-ecs">Bevy ECS</h2>
<p>All Bevy engine and game logic is built on top of a custom <a href="https://en.wikipedia.org/wiki/Entity_component_system">Entity Component System</a> (or ECS for short). Entity Component Systems are a software paradigm that involves breaking data up into Components. Entities are unique ids assigned to groups of Components. For example, one entity might might have a <code>Position</code> and <code>Velocity</code> component, whereas another entity might have a <code>Position</code> and <code>UI</code> component. Systems are logic that runs on a specific set of component types. You might have a <code>movement</code> system that runs on all entities with a <code>Position</code> and <code>Velocity</code> component.</p>
<p>The ECS pattern encourages clean, decoupled designs by forcing you to break up your app data and logic into its core components.</p>
<p>Unlike other Rust ECS implementations, which require complex lifetimes, traits, builder patterns, or macros, Bevy ECS uses normal Rust datatypes for all of these concepts:</p>
<ul>
<li><b>Components</b>: normal Rust structs</li>
<li><b>Systems</b>: normal Rust functions</li>
<li><b>Entities</b>: a type containing a unique integer</li>
</ul>
<p>There are already plenty of <a href="https://www.youtube.com/watch?v=2rW7ALyHaas">great introductions</a> to the ECS paradigm, so I'll leave "getting up to speed on ECS" as an exercise for the reader and skip right to what makes Bevy's ECS so special:</p>
<h3 id="ergonomics">Ergonomics</h3>
<p>I'm going to make a wild (and unverifiable) claim here: Bevy ECS is the most ergonomic ECS <em>in existence</em>:</p>
<pre><code><span>use </span><span>bevy</span><span>::</span><span>prelude</span><span>::*;

</span><span>struct </span><span>Velocity</span><span>(</span><span>f32</span><span>);
</span><span>struct </span><span>Position</span><span>(</span><span>f32</span><span>);

</span><span>// this system spawns entities with the Position and Velocity components
</span><span>fn </span><span>setup</span><span>(</span><span>mut </span><span>commands</span><span>:</span><span> Commands</span><span>) {</span><span>
    commands
        </span><span>.</span><span>spawn</span><span>((</span><span>Position</span><span>(</span><span>0.0</span><span>),</span><span> Velocity</span><span>(</span><span>1.0</span><span>),))
        .</span><span>spawn</span><span>((</span><span>Position</span><span>(</span><span>1.0</span><span>),</span><span> Velocity</span><span>(</span><span>2.0</span><span>),));
}

</span><span>// this system runs on each entity with a Position and Velocity component
</span><span>fn </span><span>movement</span><span>(</span><span>position</span><span>: </span><span>Mut</span><span>&lt;</span><span>Position</span><span>&gt;</span><span>, </span><span>velocity</span><span>: &amp;</span><span>Velocity</span><span>) {</span><span>
    position</span><span>.</span><span>0 </span><span>+=</span><span> velocity</span><span>.</span><span>0</span><span>;
}

</span><span>// the app entry point. hopefully you recognize it from the examples above!
</span><span>fn </span><span>main</span><span>() {
    </span><span>App</span><span>::</span><span>build</span><span>()
        .</span><span>add_startup_system</span><span>(</span><span>setup</span><span>.</span><span>system</span><span>())
        .</span><span>add_system</span><span>(</span><span>movement</span><span>.</span><span>system</span><span>())
        .</span><span>run</span><span>();
}
</span></code></pre>
<p>That is a complete self-contained Bevy app with automatic parallel system scheduling and global change detection. In my opinion, you <a href="https://github.com/amethyst/specs/blob/master/examples/basic.rs">won't</a> find <a href="https://github.com/TomGillen/legion">any</a> ECS <a href="https://github.com/leudz/shipyard/blob/master/bunny_demo/src/systems.rs">with</a> better <a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples/tree/master/ECSSamples/Assets/HelloCube">clarity</a> or ergonomics. Building games (and engines) involves writing a large number of systems, so I heavily invested in making ECS code easy to write <em>and</em> easy to read.</p>
<h3 id="performance">Performance</h3>
<p>One of the reasons the ECS paradigm is so popular is that it has the potential to make game logic <em>super</em> fast, primarily for these two reasons:</p>
<ol>
<li><b>Iteration Speed</b>: Components are packed tightly together to optimize for cache-locality, which makes iterating over them blazing fast</li>
<li><b>Parallelism</b>: Systems declare read/write dependencies, which enables automatic and efficient lock-free parallel scheduling</li>
</ol>
<p>Bevy ECS does both of these things about as well as it can. According to the popular <code>ecs_bench</code> benchmark, Bevy ECS is the fastest Rust ECS by a pretty wide margin:</p>
<h4 id="system-iteration-in-nanoseconds-less-is-better">System Iteration (in nanoseconds, less is better)</h4>
<p><img src="https://bevyengine.org/news/introducing-bevy/ecs_iter.svg" alt="ecs iter performance graph"></p>
<h4 id="world-setup-in-nanoseconds-less-is-better">World Setup (in nanoseconds, less is better)</h4>
<p><img src="https://bevyengine.org/news/introducing-bevy/ecs_build.svg" alt="ecs iter performance graph"></p>
<p>Note that <code>ecs_bench</code> is a single threaded benchmark, so it doesn't illustrate the multi-threading capabilities of these framework. And as always, please be aware that <code>ecs_bench</code> is a micro benchmark and it doesn't illustrate the performance of a complex game. There is a lot of nuance in the ECS performance space and each of the ECS implementations above will perform differently under different workloads. </p>
<p>I have pushed my version of <code>ecs_bench</code> <a href="https://github.com/cart/ecs_bench">here</a> if anyone wants to double-check my methodology. For some reasonable amount of time I will post updates here if anyone reports a problem or my results are not (on average) reproducible.</p>
<h3 id="features">Features</h3>
<p>Now you might be thinking "Ok @cart, so Bevy ECS has great performance and ergonomics, but <em>surely</em> this means you had to compromise on features!"</p>
<p>... <strong>NOPE</strong> Bevy has you covered:</p>
<h4 id="for-each-systems">For Each Systems</h4>
<pre><code><span>// "for each systems" run once on each entity containing the given components
</span><span>fn </span><span>system</span><span>(</span><span>position</span><span>: </span><span>Mut</span><span>&lt;</span><span>Position</span><span>&gt;</span><span>, </span><span>velocity</span><span>: &amp;</span><span>Velocity</span><span>) {
    </span><span>// do something
</span><span>}
</span></code></pre><h4 id="query-systems">Query Systems</h4>
<pre><code><span>// this "query system" is the same as the system above, but gives you control over iteration
</span><span>fn </span><span>system</span><span>(</span><span>mut </span><span>query</span><span>: </span><span>Query</span><span>&lt;(&amp;</span><span>Position, </span><span>&amp;</span><span>mut</span><span> Velocity</span><span>)&gt;) {
    </span><span>for </span><span>(</span><span>position</span><span>, </span><span>mut</span><span> velocity</span><span>) in &amp;</span><span>mut</span><span> query</span><span>.</span><span>iter</span><span>() {
        </span><span>// do something
    </span><span>}
}
</span></code></pre><h4 id="change-detection">Change Detection</h4>
<pre><code><span>// Added&lt;T&gt; queries only run when the given component has been added
</span><span>fn </span><span>system</span><span>(</span><span>mut </span><span>query</span><span>: </span><span>Query</span><span>&lt;</span><span>Added</span><span>&lt;</span><span>Position</span><span>&gt;&gt;) {
    </span><span>for</span><span> position </span><span>in &amp;</span><span>mut</span><span> query</span><span>.</span><span>iter</span><span>() {
        </span><span>// do something
    </span><span>}
}

</span><span>// Mutated&lt;T&gt; queries only run when the given component has been mutated
</span><span>fn </span><span>system</span><span>(</span><span>mut </span><span>query</span><span>: </span><span>Query</span><span>&lt;</span><span>Mutated</span><span>&lt;</span><span>Position</span><span>&gt;&gt;) {
    </span><span>for</span><span> position </span><span>in &amp;</span><span>mut</span><span> query</span><span>.</span><span>iter</span><span>() {
        </span><span>// do something
    </span><span>}
}

</span><span>// Changed&lt;T&gt; queries only run when the given component has been added or mutated
</span><span>fn </span><span>system</span><span>(</span><span>mut </span><span>query</span><span>: </span><span>Query</span><span>&lt;</span><span>Changed</span><span>&lt;</span><span>Position</span><span>&gt;&gt;) {
    </span><span>for</span><span> position </span><span>in &amp;</span><span>mut</span><span> query</span><span>.</span><span>iter</span><span>() {
        </span><span>// do something
    </span><span>}
}

</span><span>// query.removed&lt;T&gt;() will iterate over every entity where the component T was removed this update
</span><span>fn </span><span>system</span><span>(</span><span>mut </span><span>query</span><span>: </span><span>Query</span><span>&lt;&amp;</span><span>Position</span><span>&gt;</span><span>&gt;</span><span>) {
    </span><span>for</span><span> entity </span><span>in</span><span> query</span><span>.</span><span>removed</span><span>::&lt;</span><span>Velocity</span><span>&gt;() {
        </span><span>// do something
    </span><span>}
}
</span></code></pre><h4 id="multiple-queries">Multiple Queries</h4>
<pre><code><span>fn </span><span>system</span><span>(</span><span>mut </span><span>wall_query</span><span>: </span><span>Query</span><span>&lt;&amp;</span><span>Wall</span><span>&gt;</span><span>, </span><span>mut </span><span>player_query</span><span>: </span><span>Query</span><span>&lt;&amp;</span><span>Player</span><span>&gt;) {
    </span><span>for</span><span> player </span><span>in &amp;</span><span>mut</span><span> player_query</span><span>.</span><span>iter</span><span>() {
        </span><span>for</span><span> wall </span><span>in &amp;</span><span>mut</span><span> wall_query</span><span>.</span><span>iter</span><span>() {
            </span><span>if</span><span> player</span><span>.</span><span>collides_with</span><span>(</span><span>wall</span><span>) {
                </span><span>println!</span><span>("</span><span>ouch</span><span>");
            }
        }
    }
}
</span></code></pre><h4 id="entity-queries-and-direct-component-access">Entity Queries and Direct Component Access</h4>
<pre><code><span>fn </span><span>system</span><span>(</span><span>mut </span><span>entity_query</span><span>: </span><span>Query</span><span>&lt;</span><span>Entity</span><span>&gt;</span><span>, </span><span>mut </span><span>player_query</span><span>: </span><span>Query</span><span>&lt;&amp;</span><span>Player</span><span>&gt;) {
    </span><span>for</span><span> entity </span><span>in &amp;</span><span>mut</span><span> entity_query</span><span>.</span><span>iter</span><span>() {
       </span><span>if let </span><span>Some</span><span>(</span><span>player</span><span>) =</span><span> player_query</span><span>.</span><span>get</span><span>::&lt;</span><span>Player</span><span>&gt;(</span><span>entity</span><span>) {
           </span><span>// the current entity has a player component
       </span><span>}
    }
}
</span></code></pre><h4 id="resources">Resources</h4>
<pre><code><span>// Res and ResMut access global resources 
</span><span>fn </span><span>system</span><span>(</span><span>time</span><span>: </span><span>Res</span><span>&lt;</span><span>Time</span><span>&gt;</span><span>, </span><span>score</span><span>: </span><span>ResMut</span><span>&lt;</span><span>Score</span><span>&gt;) {
    </span><span>// do something
</span><span>}

</span><span>// you can use Resources in any system type
</span><span>fn </span><span>system</span><span>(</span><span>time</span><span>: </span><span>Res</span><span>&lt;</span><span>Time</span><span>&gt;</span><span>, </span><span>mut </span><span>query</span><span>: </span><span>Query</span><span>&lt;&amp;</span><span>Position</span><span>&gt;) {
    </span><span>// do something
</span><span>}
</span><span>fn </span><span>system</span><span>(</span><span>time</span><span>: </span><span>Res</span><span>&lt;</span><span>Time</span><span>&gt;</span><span>, </span><span>&amp;</span><span>Position</span><span>) {
    </span><span>// do something
</span><span>}
</span></code></pre><h4 id="local-system-resources">"Local" System Resources</h4>
<pre><code><span>// Local&lt;T&gt; resources are unique per-system. Two instances of the same system will each have their own resource. Local resources are automatically initialized to their default value.
</span><span>fn </span><span>system</span><span>(</span><span>state</span><span>: </span><span>Local</span><span>&lt;</span><span>State</span><span>&gt;</span><span>, </span><span>&amp;</span><span>Position</span><span>) {
    </span><span>// do something
</span><span>}
</span></code></pre><h4 id="empty-systems">Empty Systems</h4>
<pre><code><span>// for the hyper-minimalists
</span><span>fn </span><span>system</span><span>() {
    </span><span>// do something
</span><span>}
</span></code></pre><h4 id="with-without-filters">With/Without Filters</h4>
<pre><code><span>// only runs on entities With or Without a given component
</span><span>fn </span><span>system</span><span>(</span><span>mut </span><span>query</span><span>: </span><span>Query</span><span>&lt;</span><span>Without</span><span>&lt;</span><span>Parent, </span><span>&amp;</span><span>Position</span><span>&gt;&gt;) {
    </span><span>for</span><span> position </span><span>in &amp;</span><span>mut</span><span> query</span><span>.</span><span>iter</span><span>() {
        </span><span>// do something
    </span><span>}
}
</span></code></pre><h4 id="thread-local-systems">Thread-Local Systems</h4>
<pre><code><span>// systems that must run on the main thread with exclusive access to World and Resources
</span><span>fn </span><span>system</span><span>(</span><span>world</span><span>: &amp;</span><span>mut</span><span> World, </span><span>resources</span><span>: &amp;</span><span>mut</span><span> Resources</span><span>) {
    </span><span>// do something
</span><span>}
</span></code></pre><h4 id="stages">Stages</h4>
<pre><code><span>// the scheduler provides Stages as a way to run sets of systems in order  
</span><span>fn </span><span>main</span><span>() {
    </span><span>App</span><span>::</span><span>build</span><span>()
        </span><span>// adds a system to the default stage: "update" 
        </span><span>.</span><span>add_system</span><span>(</span><span>movement</span><span>.</span><span>system</span><span>())
        </span><span>// creates a new stage after "update"
        </span><span>.</span><span>add_stage_after</span><span>("</span><span>update</span><span>", "</span><span>do_things</span><span>")
        .</span><span>add_system_to_stage</span><span>("</span><span>do_things</span><span>",</span><span> something</span><span>.</span><span>system</span><span>())
}
</span></code></pre><h4 id="commands">Commands</h4>
<pre><code><span>// use Commands to queue up World and Resource changes, which will be applied at the end of the current Stage
</span><span>fn </span><span>system</span><span>(</span><span>mut </span><span>commands</span><span>:</span><span> Commands</span><span>) {</span><span>
    commands</span><span>.</span><span>spawn</span><span>((</span><span>Position</span><span>(</span><span>0.0</span><span>),</span><span> Velocity</span><span>(</span><span>1.0</span><span>)));
}

</span><span>// Commands can also be used alongside other types
</span><span>fn </span><span>system</span><span>(</span><span>mut </span><span>commands</span><span>:</span><span> Commands, </span><span>time</span><span>: </span><span>Res</span><span>&lt;</span><span>Time</span><span>&gt;</span><span>, </span><span>mut </span><span>query</span><span>: </span><span>Query</span><span>&lt;&amp;</span><span>Position</span><span>&gt;) {
    </span><span>// do something
</span><span>}
</span></code></pre><h3 id="how-do-function-systems-work">How Do Function Systems Work?</h3>
<p>Being able to use Rust functions directly as systems might feel like magic, but I promise it's not! You may have noticed that we do this when registering systems in our App:</p>
<pre><code><span>fn </span><span>some_system</span><span>() { }

</span><span>fn </span><span>main</span><span>() {
    </span><span>App</span><span>::</span><span>build</span><span>()
        .</span><span>add_system</span><span>(</span><span>some_system</span><span>.</span><span>system</span><span>())
        .</span><span>run</span><span>();
}
</span></code></pre>
<p>The <code>.system()</code> call takes the <code>some_system</code> function pointer and converts it to a <code>Box&lt;dyn System&gt;</code>. This works because we implement the <a href="https://docs.rs/bevy_ecs/latest/bevy_ecs/trait.IntoQuerySystem.html"><code>IntoQuerySystem</code>
</a> trait for all functions that match a certain set of function signatures.</p>
<h3 id="good-bones">Good Bones</h3>
<p>Bevy ECS actually uses a heavily forked version of the minimalist <a href="https://github.com/Ralith/hecs">Hecs ECS</a>. Hecs is an efficient single-threaded archetypal ECS. It provides the core <a href="https://docs.rs/bevy_ecs/latest/bevy_ecs/struct.World.html"><code>World</code>
</a>, <a href="https://docs.rs/bevy_ecs/latest/bevy_ecs/struct.Archetype.html"><code>Archetype</code>
</a>, and internal <a href="https://docs.rs/bevy_ecs/latest/bevy_ecs/trait.Query.html"><code>Query</code>
</a> data structures. Bevy ECS adds the following on top:</p>
<ul>
<li><b>Function Systems</b>: Hecs actually has no concept of a "system" at all. You just run queries directly on the World. Bevy adds the ability to define portable, schedulable systems using normal Rust functions.</li>
<li><b>Resources</b>: Hecs has no concept of unique/global data. When building games, this is often needed. Bevy adds a <code>Resource</code> collection and resource queries</li>
<li><b>Parallel Scheduler</b>: Hecs is single threaded, but it was designed to allow parallel schedulers to be built on top. Bevy ECS adds a custom dependency-aware scheduler that builds on top of the "Function Systems" mentioned above.</li>
<li><b>Optimization</b>: Hecs is already plenty fast, but by modifying some of its internal data access patterns, we were able to improve performance significantly. This moved it from "fast enough" to "the fastest" (see the benchmark above to compare Bevy ECS to vanilla Hecs).</li>
<li><b>Query Wrappers</b>: The <code>Query</code> Bevy ECS exports is actually a wrapper around Hecs Queries. It provides safe, scoped access to the <code>World</code> in a multi-threaded context and improves the ergonomics of iteration.</li>
<li><b>Change Detection</b>: Automatically (and efficiently) tracks component add/remove/update operations and exposes them in the Query interface.</li>
<li><b>Stable Entity IDs</b>: Almost every ECS (including Hecs) uses unstable entity ids that cannot be used for serialization (scenes / save files) or networking. In Bevy ECS, entity ids are globally unique and stable. You can use them in any context!</li>
</ul>
<p>In the near future I will file an issue on the Hecs git repo offering to upstream whatever changes they want from Bevy ECS. I have a feeling they won't want the "high level" stuff like function systems and parallel scheduling, but I guess we'll see! </p>
<h2 id="bevy-ui">Bevy UI</h2>
<p><img src="https://bevyengine.org/news/introducing-bevy/bevy_ui.png" alt="bevy ui"></p>
<p>Bevy has a custom, but familiar UI system based on the "flex box" model. Well... semi-custom, but more on that later. In the beginning, I heavily considered using <a href="https://github.com/hecrj/iced">one</a> of the <a href="https://github.com/emilk/emigui/">many</a> great <a href="https://github.com/linebender/druid">pre-made</a> UI solutions in the Rust ecosystem. But each of these frameworks felt in some way "separate" from the data-driven ECS approach at the core of Bevy. If we took a framework like <a href="https://github.com/linebender/druid">Druid</a>, which is top-of-its class in terms of design, and then shoe-horned it into the Bevy data / event model, that would <em>compromise</em> the Druid design and Bevy+Druid would end up being less compelling than just using Druid as a standalone framework.</p>
<p>I decided that the only way Bevy could even <em>hope</em> to bring something compelling to the table was to fully embrace the Bevy way of doing things.</p>
<p>Bevy UI directly uses the existing ECS, hierarchy, transform, event, asset, and scene systems at the core of Bevy. Because of this, Bevy UI automatically gets features like hot-reloading of UI scene files, async texture loading, and change detection. A shared architecture means that improvements to any of these systems feed directly into Bevy UI. I am not yet convinced that this approach will produce the best UI framework, but I <em>am</em> convinced that it will produce the best UI framework in the context of a Bevy App.</p>
<p>We are still in the experimental stages and I expect some things to change, but the patterns we've found so far are very promising. Also keep in mind that currently the best way to compose Bevy UIs is with code, but we are in the process of designing a new file format for scenes that should make declarative, file based UI composition much nicer than it currently is.</p>
<h3 id="building-blocks">Building Blocks</h3>
<p>In Bevy, a UI element is just an ECS Entity with a <a href="https://docs.rs/bevy_ui/latest/bevy_ui/struct.Node.html"><code>Node</code>
</a> component. Nodes are rectangles with a width and height, and are positioned using the same <a href="https://docs.rs/bevy_transform/latest/bevy_transform/components/struct.Transform.html"><code>Transform</code>
</a> component used elsewhere in Bevy. The <a href="https://docs.rs/bevy_ui/latest/bevy_ui/struct.Style.html"><code>Style</code>
</a> component is used to determine how the Node is rendered, sized, and positioned.</p>
<p>The easiest way to add a new node (with all of the required components) is like this:</p>
<pre><code><span>commands</span><span>.</span><span>spawn</span><span>(</span><span>NodeComponents</span><span>::</span><span>default</span><span>())
</span></code></pre>
<p><a href="https://docs.rs/bevy_ui/latest/bevy_ui/entity/struct.NodeComponents.html"><code>NodeComponents</code>
</a> is a "component bundle", which Bevy uses to make spawning entities of various "types" easier.</p>
<h3 id="layout">Layout</h3>
<p>For layout, Bevy uses a fantastic 100% Rust flexbox implementation called <a href="https://github.com/vislyhq/stretch">Stretch</a>. Stretch provides the algorithms for positioning rectangles in 2D space according to the flexbox spec. Bevy exposes flex properties inside the <a href="https://docs.rs/bevy_ui/latest/bevy_ui/struct.Style.html"><code>Style</code>
</a> component mentioned above and renders rectangles with the positions and sizes that Stretch outputs. Bevy uses its own z-layering algorithm to "stack" elements on top of each other, but its basically the same one that HTML/CSS uses.</p>
<h3 id="relative-positioning">Relative Positioning</h3>
<p>Nodes are positioned relative to each other by default:</p>
<p><img src="https://bevyengine.org/news/introducing-bevy/relative_position.png" alt="relative positioning"></p>
<pre><code><span>commands
    </span><span>.</span><span>spawn</span><span>(</span><span>NodeComponents </span><span>{</span><span>
        style</span><span>:</span><span> Style </span><span>{</span><span>
            size</span><span>: </span><span>Size</span><span>::</span><span>new</span><span>(</span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>100.0</span><span>), </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>100.0</span><span>)),
            ..</span><span>Default</span><span>::</span><span>default</span><span>()
        },</span><span>
        material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>Color</span><span>::</span><span>rgb</span><span>(</span><span>0.08</span><span>, </span><span>0.08</span><span>, </span><span>1.0</span><span>).</span><span>into</span><span>()),
        ..</span><span>Default</span><span>::</span><span>default</span><span>()
    })
    .</span><span>spawn</span><span>(</span><span>NodeComponents </span><span>{</span><span>
        style</span><span>:</span><span> Style </span><span>{</span><span>
            size</span><span>: </span><span>Size</span><span>::</span><span>new</span><span>(</span><span>Val</span><span>::</span><span>Percent</span><span>(</span><span>40.0</span><span>), </span><span>Val</span><span>::</span><span>Percent</span><span>(</span><span>40.0</span><span>)),
            ..</span><span>Default</span><span>::</span><span>default</span><span>()
        },</span><span>
        material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>Color</span><span>::</span><span>rgb</span><span>(</span><span>1.0</span><span>, </span><span>0.08</span><span>, </span><span>0.08</span><span>).</span><span>into</span><span>()),
        ..</span><span>Default</span><span>::</span><span>default</span><span>()
    });
</span></code></pre><h3 id="absolute-positioning">Absolute Positioning</h3>
<p>You can "absolutely" position a Node relative to its parent's corners like this:</p>
<p><img src="https://bevyengine.org/news/introducing-bevy/absolute_positioning.png" alt="absolute positioning"></p>
<pre><code><span>commands
    </span><span>.</span><span>spawn</span><span>(</span><span>NodeComponents </span><span>{</span><span>
        style</span><span>:</span><span> Style </span><span>{</span><span>
            size</span><span>: </span><span>Size</span><span>::</span><span>new</span><span>(</span><span>Val</span><span>::</span><span>Percent</span><span>(</span><span>40.0</span><span>), </span><span>Val</span><span>::</span><span>Percent</span><span>(</span><span>40.0</span><span>)),</span><span>
            position_type</span><span>: </span><span>PositionType</span><span>::</span><span>Absolute</span><span>,</span><span>
            position</span><span>:</span><span> Rect </span><span>{</span><span>
                top</span><span>: </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>10.0</span><span>),</span><span>
                right</span><span>: </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>10.0</span><span>),
                ..</span><span>Default</span><span>::</span><span>default</span><span>()
            },
            ..</span><span>Default</span><span>::</span><span>default</span><span>()
        },</span><span>
        material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>Color</span><span>::</span><span>rgb</span><span>(</span><span>0.08</span><span>, </span><span>0.08</span><span>, </span><span>1.0</span><span>).</span><span>into</span><span>()),
        ..</span><span>Default</span><span>::</span><span>default</span><span>()
    });
</span></code></pre><h3 id="parenting">Parenting</h3>
<p>Just like any other Entity, Nodes can have children. Children are positioned and scaled relative to their parent. By default, children will always appear in front of their parents.</p>
<p><img src="https://bevyengine.org/news/introducing-bevy/ui_parenting.png" alt="ui_parenting"></p>
<pre><code><span>commands
    </span><span>.</span><span>spawn</span><span>(</span><span>NodeComponents </span><span>{</span><span>
        style</span><span>:</span><span> Style </span><span>{</span><span>
            size</span><span>: </span><span>Size</span><span>::</span><span>new</span><span>(</span><span>Val</span><span>::</span><span>Percent</span><span>(</span><span>60.0</span><span>), </span><span>Val</span><span>::</span><span>Percent</span><span>(</span><span>60.0</span><span>)),</span><span>
            position_type</span><span>: </span><span>PositionType</span><span>::</span><span>Absolute</span><span>,</span><span>
            position</span><span>:</span><span> Rect </span><span>{</span><span>
                top</span><span>: </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>10.0</span><span>),</span><span>
                right</span><span>: </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>10.0</span><span>),
                ..</span><span>Default</span><span>::</span><span>default</span><span>()
            },
            ..</span><span>Default</span><span>::</span><span>default</span><span>()
        },</span><span>
        material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>Color</span><span>::</span><span>rgb</span><span>(</span><span>0.08</span><span>, </span><span>0.08</span><span>, </span><span>1.0</span><span>).</span><span>into</span><span>()),
        ..</span><span>Default</span><span>::</span><span>default</span><span>()
    })
    .</span><span>with_children</span><span>(|</span><span>parent</span><span>| {</span><span>
        parent
            </span><span>.</span><span>spawn</span><span>(</span><span>NodeComponents </span><span>{</span><span>
                style</span><span>:</span><span> Style </span><span>{</span><span>
                    size</span><span>: </span><span>Size</span><span>::</span><span>new</span><span>(</span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>50.0</span><span>), </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>50.0</span><span>)),
                    ..</span><span>Default</span><span>::</span><span>default</span><span>()
                },</span><span>
                material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>Color</span><span>::</span><span>rgb</span><span>(</span><span>0.5</span><span>, </span><span>0.5</span><span>, </span><span>1.0</span><span>).</span><span>into</span><span>()),
                ..</span><span>Default</span><span>::</span><span>default</span><span>()
            });
    });
</span></code></pre><h3 id="flexbox">Flexbox</h3>
<p>I won't cover how flexbox works here, but you can use all of the same "flex" properties you would use in a web context. Here is an example of how you would center two Nodes vertically and horizontally within their parent:</p>
<p><img src="https://bevyengine.org/news/introducing-bevy/flex.png" alt="flex"></p>
<pre><code><span>commands
    </span><span>.</span><span>spawn</span><span>(</span><span>NodeComponents </span><span>{</span><span>
        style</span><span>:</span><span> Style </span><span>{</span><span>
            size</span><span>: </span><span>Size</span><span>::</span><span>new</span><span>(</span><span>Val</span><span>::</span><span>Percent</span><span>(</span><span>100.0</span><span>), </span><span>Val</span><span>::</span><span>Percent</span><span>(</span><span>100.0</span><span>)),</span><span>
            justify_content</span><span>: </span><span>JustifyContent</span><span>::</span><span>Center</span><span>,</span><span>
            align_items</span><span>: </span><span>AlignItems</span><span>::</span><span>Center</span><span>,
            ..</span><span>Default</span><span>::</span><span>default</span><span>()
        },</span><span>
        material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>Color</span><span>::</span><span>rgb</span><span>(</span><span>0.04</span><span>, </span><span>0.04</span><span>, </span><span>0.04</span><span>).</span><span>into</span><span>()),
        ..</span><span>Default</span><span>::</span><span>default</span><span>()
    })
    .</span><span>with_children</span><span>(|</span><span>parent</span><span>| {</span><span>
        parent
            </span><span>.</span><span>spawn</span><span>(</span><span>NodeComponents </span><span>{</span><span>
                style</span><span>:</span><span> Style </span><span>{</span><span>
                    size</span><span>: </span><span>Size</span><span>::</span><span>new</span><span>(</span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>80.0</span><span>), </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>80.0</span><span>)),
                    ..</span><span>Default</span><span>::</span><span>default</span><span>()
                },</span><span>
                material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>Color</span><span>::</span><span>rgb</span><span>(</span><span>0.08</span><span>, </span><span>0.08</span><span>, </span><span>1.0</span><span>).</span><span>into</span><span>()),
                ..</span><span>Default</span><span>::</span><span>default</span><span>()
            })
            .</span><span>spawn</span><span>(</span><span>NodeComponents </span><span>{</span><span>
                style</span><span>:</span><span> Style </span><span>{</span><span>
                    size</span><span>: </span><span>Size</span><span>::</span><span>new</span><span>(</span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>80.0</span><span>), </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>80.0</span><span>)),
                    ..</span><span>Default</span><span>::</span><span>default</span><span>()
                },</span><span>
                material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>Color</span><span>::</span><span>rgb</span><span>(</span><span>1.0</span><span>, </span><span>0.08</span><span>, </span><span>0.08</span><span>).</span><span>into</span><span>()),
                ..</span><span>Default</span><span>::</span><span>default</span><span>()
            });
    });
</span></code></pre><h3 id="text-and-images">Text and Images</h3>
<p>Nodes can also have Text and Image components, which affect the inferred sizes of nodes.</p>
<p><img src="https://bevyengine.org/news/introducing-bevy/text_and_image.png" alt="text and images"></p>
<pre><code><span>commands
    </span><span>.</span><span>spawn</span><span>(</span><span>TextComponents </span><span>{</span><span>
        text</span><span>:</span><span> Text </span><span>{</span><span>
            value</span><span>: "</span><span>Hello from Bevy UI!</span><span>".</span><span>to_string</span><span>(),</span><span>
            font</span><span>:</span><span> asset_server</span><span>.</span><span>load</span><span>("</span><span>FiraSans-Bold.ttf</span><span>").</span><span>unwrap</span><span>(),</span><span>
            style</span><span>:</span><span> TextStyle </span><span>{</span><span>
                font_size</span><span>: </span><span>25.0</span><span>,</span><span>
                color</span><span>: </span><span>Color</span><span>::</span><span>WHITE</span><span>,
            },
        },
        ..</span><span>Default</span><span>::</span><span>default</span><span>()
    })
    .</span><span>spawn</span><span>(</span><span>ImageComponents </span><span>{</span><span>
        style</span><span>:</span><span> Style </span><span>{</span><span>
            size</span><span>: </span><span>Size</span><span>::</span><span>new</span><span>(</span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>200.0</span><span>), </span><span>Val</span><span>::</span><span>Auto</span><span>),</span><span>
            position_type</span><span>: </span><span>PositionType</span><span>::</span><span>Absolute</span><span>,</span><span>
            position</span><span>:</span><span> Rect </span><span>{</span><span>
                top</span><span>: </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>10.0</span><span>),</span><span>
                right</span><span>: </span><span>Val</span><span>::</span><span>Px</span><span>(</span><span>10.0</span><span>),
                ..</span><span>Default</span><span>::</span><span>default</span><span>()
            },
            ..</span><span>Default</span><span>::</span><span>default</span><span>()
        },</span><span>
        material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>asset_server</span><span>.</span><span>load</span><span>("</span><span>bevy_logo.png</span><span>").</span><span>unwrap</span><span>().</span><span>into</span><span>()),
        ..</span><span>Default</span><span>::</span><span>default</span><span>()
    });
</span></code></pre><h3 id="interaction-events">Interaction Events</h3>
<p>Nodes with the <a href="https://docs.rs/bevy_ui/latest/bevy_ui/enum.Interaction.html"><code>Interaction</code>
</a> component will track interaction state. You can easily build widgets like buttons this way:</p>

<p>For example, here is a system that only runs on Buttons where the Interaction state has changed:</p>
<pre><code><span>fn </span><span>system</span><span>(</span><span>_button</span><span>: &amp;</span><span>Button, </span><span>interaction</span><span>: </span><span>Mutated</span><span>&lt;</span><span>Interaction</span><span>&gt;) {
    </span><span>match </span><span>*</span><span>interaction </span><span>{
        </span><span>Interaction</span><span>::</span><span>Clicked </span><span>=&gt; </span><span>println!</span><span>("</span><span>clicked</span><span>"),
        </span><span>Interaction</span><span>::</span><span>Hovered </span><span>=&gt; </span><span>println!</span><span>("</span><span>hovered</span><span>"),
        </span><span>Interaction</span><span>::</span><span>None </span><span>=&gt; {},
    }
}
</span></code></pre><h2 id="2d-features">2D Features</h2>
<h3 id="sprites"><a href="https://github.com/bevyengine/bevy/blob/master/examples/2d/sprite.rs">Sprites</a></h3>
<p>You can use any <a href="https://docs.rs/bevy_render/latest/bevy_render/texture/struct.Texture.html"><code>Texture</code>
</a> asset as a sprite directly:</p>
<p><img src="https://bevyengine.org/news/introducing-bevy/sprite.png" alt="sprite"></p>
<pre><code><span>let</span><span> texture </span><span>=</span><span> asset_server</span><span>.</span><span>load</span><span>("</span><span>icon.png</span><span>").</span><span>unwrap</span><span>();</span><span>
commands</span><span>.</span><span>spawn</span><span>(</span><span>SpriteComponents </span><span>{</span><span>
    material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>texture</span><span>.</span><span>into</span><span>()),
    ..</span><span>Default</span><span>::</span><span>default</span><span>()
});
</span></code></pre><h3 id="sprite-sheets"><a href="https://github.com/bevyengine/bevy/blob/master/examples/2d/sprite_sheet.rs">Sprite Sheets</a></h3>
<p>Sprite sheets (also known as texture atlases) can be used for animations, tile sets, or just for optimized sprite rendering.</p>

<pre><code><span>let</span><span> texture_atlas </span><span>= </span><span>TextureAtlas</span><span>::</span><span>from_grid</span><span>(</span><span>texture_handle</span><span>,</span><span> texture</span><span>.</span><span>size</span><span>, </span><span>7</span><span>, </span><span>1</span><span>);
</span><span>let</span><span> texture_atlas_handle </span><span>=</span><span> texture_atlases</span><span>.</span><span>add</span><span>(</span><span>texture_atlas</span><span>);</span><span>
commands
    </span><span>.</span><span>spawn</span><span>(</span><span>SpriteSheetComponents </span><span>{</span><span>
        texture_atlas</span><span>:</span><span> texture_atlas_handle</span><span>,</span><span>
        sprite</span><span>: </span><span>TextureAtlasSprite</span><span>::</span><span>new</span><span>(</span><span>0</span><span>),
        ..</span><span>Default</span><span>::</span><span>default</span><span>()
    });
</span></code></pre><h3 id="dynamic-texture-atlas-generation"><a href="https://github.com/bevyengine/bevy/blob/master/examples/2d/texture_atlas.rs">Dynamic Texture Atlas Generation</a></h3>
<p>Sprites are often produced as individual files. Bevy can combine them into a single sprite sheet dynamically!</p>
<p><img src="https://bevyengine.org/news/introducing-bevy/dynamic_texture_atlas.png" alt="dynamic texture atlas"></p>
<pre><code><span>for</span><span> sprite_handle </span><span>in</span><span> sprite_handles</span><span>.</span><span>iter</span><span>() {
    </span><span>let</span><span> texture </span><span>=</span><span> textures</span><span>.</span><span>get</span><span>(&amp;</span><span>handle</span><span>).</span><span>unwrap</span><span>();</span><span>
    texture_atlas_builder</span><span>.</span><span>add_texture</span><span>(</span><span>handle</span><span>, &amp;</span><span>texture</span><span>);
}

</span><span>let</span><span> texture_atlas </span><span>=</span><span> texture_atlas_builder</span><span>.</span><span>finish</span><span>(&amp;</span><span>mut</span><span> textures</span><span>).</span><span>unwrap</span><span>();
</span></code></pre><h2 id="3d-features">3D Features</h2>
<h3 id="gltf-model-loading"><a href="https://github.com/bevyengine/bevy/blob/master/examples/3d/load_model.rs">GLTF Model Loading</a></h3>
<p>Load GLTF files as Mesh assets </p>
<p><img src="https://bevyengine.org/news/introducing-bevy/boat.png" alt="boat render"></p>
<pre><code><span>.</span><span>spawn</span><span>(</span><span>PbrComponents </span><span>{
    </span><span>// load the model
</span><span>    mesh</span><span>:</span><span> asset_server</span><span>.</span><span>load</span><span>("</span><span>boat.gltf</span><span>").</span><span>unwrap</span><span>(),
    </span><span>// create a material for the model
</span><span>    material</span><span>:</span><span> materials</span><span>.</span><span>add</span><span>(</span><span>asset_server</span><span>.</span><span>load</span><span>("</span><span>boat.png</span><span>").</span><span>into</span><span>()),
    ..</span><span>Default</span><span>::</span><span>default</span><span>()
})
</span></code></pre>
<p>Note: in the near future we will add support for loading GLTF files as Scenes instead of meshes.</p>
<h3 id="depth-based-draw-order"><a href="https://github.com/bevyengine/bevy/blob/master/examples/3d/texture.rs">Depth Based Draw Order</a></h3>
<p>Front-to-back drawing for fast "early fragment discarding" of opaque materials, and back-to-front drawing for correct transparent materials</p>
<p><img src="https://bevyengine.org/news/introducing-bevy/alpha.png" alt="alpha"></p>
<h3 id="parenting-1"><a href="https://github.com/bevyengine/bevy/blob/master/examples/3d/parenting.rs">Parenting</a></h3>
<p>Parent transforms are propagated to their descendants</p>

<pre><code><span>.</span><span>spawn</span><span>(</span><span>PbrComponents </span><span>{</span><span>
    mesh</span><span>:</span><span> cube_handle</span><span>,
    ..</span><span>Default</span><span>::</span><span>default</span><span>()
}).</span><span>with_children</span><span>(|</span><span>parent</span><span>| {</span><span>
    parent</span><span>.</span><span>spawn</span><span>(</span><span>PbrComponents </span><span>{</span><span>
        mesh</span><span>:</span><span> cube_handle</span><span>,</span><span>
        translation</span><span>: </span><span>Translation</span><span>::</span><span>new</span><span>(</span><span>0.0</span><span>, </span><span>2.0</span><span>, </span><span>0.0</span><span>),
        ..</span><span>Default</span><span>::</span><span>default</span><span>()
    });
})
</span></code></pre><h3 id="msaa"><a href="https://github.com/bevyengine/bevy/blob/master/examples/3d/msaa.rs">MSAA</a></h3>
<p>Get nice smooth edges by using Multi-Sample Anti-Aliasing</p>
<p><img src="https://bevyengine.org/news/introducing-bevy/msaa_off.png" alt="msaa_off">
<img src="https://bevyengine.org/news/introducing-bevy/msaa_on.png" alt="msaa_on"></p>
<pre><code><span>app</span><span>.</span><span>add_resource</span><span>(</span><span>Msaa </span><span>{</span><span> samples</span><span>: </span><span>8 </span><span>})
</span></code></pre><h2 id="scenes">Scenes</h2>
<p>Scenes are a way to compose pieces of your game/app ahead of time. In Bevy, Scenes are simply a collection of entities and components. A Scene can be "spawned" into a <code>World</code> any number of times. "Spawning" copies the Scene's entities and components into the given <code>World</code>.</p>
<p>Scenes can also be saved to and loaded from "scene files". One of the primary goals of the future "Bevy Editor" will be to make it easy to compose scene files visually.</p>
<h3 id="file-format">File Format</h3>
<p>Scene files are a saved and loaded as a flat list of entities and components:</p>
<pre><code><span>[
  </span><span>(
    entity: </span><span>328997855</span><span>,
    </span><span>components: </span><span>[
      {
        "</span><span>type</span><span>": "</span><span>Position</span><span>",
        "</span><span>map</span><span>": { "</span><span>x</span><span>": </span><span>3</span><span>.</span><span>0</span><span>, "</span><span>y</span><span>": </span><span>4</span><span>.</span><span>0 </span><span>},
      },
    ],
  </span><span>)</span><span>,
  </span><span>(
    entity: </span><span>404566393</span><span>,
    </span><span>components: </span><span>[
      {
        "</span><span>type</span><span>": "</span><span>Position</span><span>",
        "</span><span>map</span><span>": { "</span><span>x</span><span>": </span><span>1</span><span>.</span><span>0</span><span>, "</span><span>y</span><span>": </span><span>2</span><span>.</span><span>0 </span><span>},
      },
      {
        "</span><span>type</span><span>": "</span><span>Name</span><span>",
        "</span><span>map</span><span>": { "</span><span>value</span><span>": "</span><span>Carter</span><span>" },
      },
    ],
  </span><span>)</span><span>,
]
</span></code></pre>
<p>The numbers assigned to the <code>entity</code> fields are entity's id, which are completely optional. If no entity id is provided, one will be randomly generated when the scene is loaded. We have <a href="https://gist.github.com/cart/3e77d6537e1a0979a69de5c6749b6bcb">plans to improve this format</a> in the future to be more ergonomic, indent entity hierarchies, and support nested scenes.</p>
<h3 id="loading-and-instancing">Loading and Instancing</h3>
<p>Scenes can be added to a <code>World</code> using the <a href="https://docs.rs/bevy_scene/latest/bevy_scene/struct.SceneSpawner.html"><code>SceneSpawner</code>
</a> resource. Spawning can be done with either <a href="https://docs.rs/bevy_scene/latest/bevy_scene/struct.SceneSpawner.html#method.load"><code>SceneSpawner::load()</code>
</a> or <a href="https://docs.rs/bevy_scene/latest/bevy_scene/struct.SceneSpawner.html#method.instance"><code>SceneSpawner::instance()</code>
</a>. "Loading" a Scene preserves the entity IDs in it. This is useful for something like a save file where you want entity ids to be constant and changes to be applied on top of entities already in the world. "Instancing" adds entities to the <code>World</code> with brand-new IDs, which allows multiple "instances" of a scene to exist in the same World.</p>
<pre><code><span>fn </span><span>load_scene_system</span><span>(</span><span>asset_server</span><span>: </span><span>Res</span><span>&lt;</span><span>AssetServer</span><span>&gt;</span><span>, </span><span>mut </span><span>scene_spawner</span><span>: </span><span>ResMut</span><span>&lt;</span><span>SceneSpawner</span><span>&gt;) {
    </span><span>// Scenes are loaded just like any other asset.
    </span><span>let</span><span> scene</span><span>: </span><span>Handle</span><span>&lt;</span><span>Scene</span><span>&gt; =</span><span> asset_server</span><span>.</span><span>load</span><span>("</span><span>my_scene.scn</span><span>").</span><span>unwrap</span><span>();
    </span><span>// Spawns the scene with entity ids preserved
</span><span>    scene_spawner</span><span>.</span><span>load</span><span>(</span><span>scene</span><span>);
    </span><span>// Spawns the scene with new entity ids
</span><span>    scene_spawner</span><span>.</span><span>instance</span><span>(</span><span>scene</span><span>);
}
</span></code></pre><h3 id="saving-ecs-worlds-to-scenes">Saving ECS Worlds To Scenes</h3>
<p>Any ECS <code>World</code> can be converted to a scene like this:</p>
<pre><code><span>let</span><span> scene </span><span>= </span><span>Scene</span><span>::</span><span>from_world</span><span>(&amp;</span><span>world</span><span>, &amp;</span><span>component_type_registry</span><span>);
</span></code></pre>
<p>You can then convert the scene to a RON formatted string like this: </p>
<pre><code><span>let</span><span> ron_string </span><span>=</span><span> scene</span><span>.</span><span>serialize_ron</span><span>(&amp;</span><span>property_type_registry</span><span>)?;
</span></code></pre><h3 id="hot-scene-reloading">Hot Scene Reloading</h3>
<p>Changes to Scene files can be automatically applied to spawned Scenes at runtime. This allows for immediate feedback without restarts or recompiles.</p>

<p>Note that the video above is not sped up. Scene changes are effectively applied instantaneously.</p>
<h3 id="how-does-this-work">How Does This Work?</h3>
<p>Scenes are built on top of Bevy's Property and Asset systems. Components can be used in scenes provided they derive the <code>Properties</code> trait. Properties are what enable scene serialization, deserialization, and patching changes at runtime. Check out the next section for more details.</p>
<h2 id="properties">Properties</h2>
<p>In a nutshell, Bevy Properties add some dynamism to Rust, which is a notoriously static language. It is often useful to get or set a struct's field using a string version of its name, or interact with a struct when you don't have a statically typed reference. Languages generally cover these cases with "reflection" features, but unfortunately Rust does not currently have this type of reflection. I built the <code>bevy_property</code> crate to provide a subset of useful "reflection-like" features in Rust. Here is a quick surface-level introduction:</p>
<pre><code><span>#[</span><span>derive</span><span>(</span><span>Properties</span><span>)]
</span><span>pub struct </span><span>Counter </span><span>{
    </span><span>count</span><span>: </span><span>u32</span><span>,
</span><span>}

</span><span>let mut</span><span> counter </span><span>=</span><span> Counter </span><span>{</span><span> count</span><span>: </span><span>1 </span><span>};

</span><span>// You can set a property value like this. The type must match exactly or this will fail.
</span><span>counter</span><span>.</span><span>set_prop_val</span><span>::&lt;</span><span>u32</span><span>&gt;("</span><span>count</span><span>", </span><span>2</span><span>);
</span><span>assert_eq!</span><span>(</span><span>counter</span><span>.</span><span>count</span><span>, </span><span>2</span><span>);
</span><span>assert_eq!</span><span>(</span><span>counter</span><span>.</span><span>prop_val</span><span>::&lt;</span><span>u32</span><span>&gt;("</span><span>count</span><span>").</span><span>unwrap</span><span>(), </span><span>2</span><span>);

</span><span>// You can also set properties dynamically. set_prop accepts any type that implements the Property trait, but the property type must match the field type or this operation will fail.
</span><span>let</span><span> new_count</span><span>: </span><span>u32 </span><span>= </span><span>3</span><span>;</span><span>
counter</span><span>.</span><span>set_prop</span><span>("</span><span>count</span><span>", &amp;</span><span>new_count</span><span>);
</span><span>assert_eq!</span><span>(</span><span>counter</span><span>.</span><span>count</span><span>, </span><span>3</span><span>);

</span><span>// DynamicProperties also implements the Properties trait, but it has no restrictions on field names or types
</span><span>let mut</span><span> patch </span><span>= </span><span>DynamicProperties</span><span>::</span><span>map</span><span>();</span><span>
patch</span><span>.</span><span>set_prop_val</span><span>::&lt;</span><span>usize</span><span>&gt;("</span><span>count</span><span>", </span><span>4</span><span>);

</span><span>// You can "apply" Properties on top of other Properties. This will only set properties with the same name and type. You can use this to "patch" your properties with new values.
</span><span>counter</span><span>.</span><span>apply</span><span>(&amp;</span><span>patch</span><span>);
</span><span>assert_eq!</span><span>(</span><span>counter</span><span>.</span><span>count</span><span>, </span><span>4</span><span>);

</span><span>// Types that implement Properties can be converted to DynamicProperties
</span><span>let</span><span> dynamic_thing</span><span>:</span><span> DynamicProperties </span><span>=</span><span> counter</span><span>.</span><span>to_dynamic</span><span>();
</span></code></pre>
<p>Properties are what make Bevy's Scene system so nice to use. I also plan to use them for features in the upcoming Bevy Editor, such as undo/redo, viewing and editing component properties at runtime, and property animation tools.</p>
<p>Types that implement Properties can be serialized using <a href="https://serde.rs/">serde</a> and <code>DynamicProperties</code> can be deserialized using serde. When combined with the <code>Properties</code> patching feature, this means any type that derives <code>Properties</code> can be round trip serialized and deserialized.</p>
<p>To derive <code>Properties</code> each field in the struct must implement the <code>Property</code> trait. This is already implemented for most core Rust and Bevy types, so you should only need to implement <code>Property</code> for custom types (and you can derive <code>Property</code> too).</p>
<p>I have a feeling that the <code>bevy_property</code> crate will be useful in non-Bevy contexts, so I'll be publishing it to crates.io in the near future.</p>
<h2 id="events">Events</h2>
<p>Bevy uses a double-buffered event system that enables efficient event production and consumption with zero-allocation event consumers. Here is a complete Bevy app that produces and consumes a custom event:</p>
<pre><code><span>fn </span><span>main</span><span>() {
    </span><span>App</span><span>::</span><span>build</span><span>()
        .</span><span>add_event</span><span>::&lt;</span><span>MyEvent</span><span>&gt;()
        .</span><span>add_system</span><span>(</span><span>event_producer</span><span>.</span><span>system</span><span>())
        .</span><span>add_system</span><span>(</span><span>event_consumer</span><span>.</span><span>system</span><span>())
        .</span><span>run</span><span>();
}

</span><span>struct </span><span>MyEvent </span><span>{
    </span><span>message</span><span>:</span><span> String,
</span><span>}

</span><span>fn </span><span>event_producer</span><span>(</span><span>mut </span><span>my_events</span><span>: </span><span>ResMut</span><span>&lt;</span><span>Events</span><span>&lt;</span><span>MyEvent</span><span>&gt;&gt;) {</span><span>
    my_events</span><span>.</span><span>send</span><span>(</span><span>MyEvent </span><span>{</span><span> message</span><span>: "</span><span>Hello</span><span>".</span><span>to_string</span><span>() });
}

#[</span><span>derive</span><span>(</span><span>Default</span><span>)]
</span><span>struct </span><span>State </span><span>{
    </span><span>reader</span><span>: </span><span>EventReader</span><span>&lt;</span><span>MyEvent</span><span>&gt;</span><span>, 
</span><span>}

</span><span>fn </span><span>event_consumer</span><span>(</span><span>mut </span><span>state</span><span>: </span><span>Local</span><span>&lt;</span><span>State</span><span>&gt;</span><span>, </span><span>my_events</span><span>: </span><span>Res</span><span>&lt;</span><span>Events</span><span>&lt;</span><span>MyEvent</span><span>&gt;&gt;) {
    </span><span>for</span><span> event </span><span>in</span><span> state</span><span>.</span><span>reader</span><span>.</span><span>iter</span><span>(&amp;</span><span>my_events</span><span>) {
        </span><span>println!</span><span>("</span><span>received message: {}</span><span>",</span><span> event</span><span>.</span><span>message</span><span>);
    }
}
</span></code></pre>
<p><code>app.add_event::&lt;MyEvent&gt;()</code> adds a new <a href="https://docs.rs/bevy_app/latest/bevy_app/struct.Events.html"><code>Events</code>
</a> resource for MyEvent and a system that swaps the <code>Events&lt;MyEvent&gt;</code> buffers every update.  <a href="https://docs.rs/bevy_app/latest/bevy_app/struct.EventReader.html"><code>EventReaders</code>
</a> are very cheap to create. They are essentially just an array index that tracks the last event that has been read.</p>
<p>Events are used in Bevy for features like window resizing, assets, and input. The tradeoff for being both allocation and cpu efficient is that each system only has one chance to receive an event, otherwise it will be lost on the next update. I believe this is the correct tradeoff for apps that run in a loop (ex: games).</p>
<h2 id="assets">Assets</h2>
<p>Bevy <a href="https://docs.rs/bevy_asset/latest/bevy_asset/struct.Assets.html"><code>Assets</code>
</a> are just typed data that can be referenced using asset <a href="https://docs.rs/bevy_asset/latest/bevy_asset/struct.Handle.html"><code>Handles</code>
</a> . For example, 3d meshes, textures, fonts, materials, scenes, and sounds are assets. <code>Assets&lt;T&gt;</code> is a generic collection of assets of type <code>T</code>. In general asset usage looks like this:</p>
<h4 id="asset-creation">Asset Creation</h4>
<pre><code><span>fn </span><span>create_texture_system</span><span>(</span><span>mut </span><span>textures</span><span>: </span><span>ResMut</span><span>&lt;</span><span>Assets</span><span>&lt;</span><span>Texture</span><span>&gt;&gt;) {
    </span><span>// creates a new Texture asset and returns a handle, which can then be used to retrieve the actual asset
    </span><span>let</span><span> texture_handle</span><span>: </span><span>Handle</span><span>&lt;</span><span>Texture</span><span>&gt; =</span><span> textures</span><span>.</span><span>add</span><span>(</span><span>Texture</span><span>::</span><span>default</span><span>());
}
</span></code></pre><h4 id="asset-access">Asset Access</h4>
<pre><code><span>fn </span><span>read_texture_system</span><span>(</span><span>textures</span><span>: </span><span>Res</span><span>&lt;</span><span>Assets</span><span>&lt;</span><span>Texture</span><span>&gt;&gt;</span><span>, </span><span>texture_handle</span><span>: &amp;</span><span>Handle</span><span>&lt;</span><span>Texture</span><span>&gt;) {
    </span><span>// retrieves a Texture using the current entity's Handle&lt;Texture&gt; component
    </span><span>let</span><span> texture</span><span>: &amp;</span><span>Texture </span><span>=</span><span> textures</span><span>.</span><span>get</span><span>(</span><span>texture_handle</span><span>).</span><span>unwrap</span><span>();
}
</span></code></pre><h4 id="asset-events">Asset Events</h4>
<p>The <code>Assets&lt;T&gt;</code> collection is basically just a map from <code>Handle&lt;T&gt;</code> to <code>T</code> that records created, modified, and removed <code>Events</code>. These events can also be consumed as a system resource, just like any other <code>Events</code>:</p>
<pre><code><span>fn </span><span>system</span><span>(</span><span>mut </span><span>state</span><span>: </span><span>Local</span><span>&lt;</span><span>State</span><span>&gt;</span><span>, </span><span>texture_events</span><span>: </span><span>Res</span><span>&lt;</span><span>Events</span><span>&lt;</span><span>AssetEvent</span><span>&gt;&gt;) {
    </span><span>for</span><span> event </span><span>in</span><span> state</span><span>.</span><span>reader</span><span>.</span><span>iter</span><span>(&amp;</span><span>texture_events</span><span>) {
        </span><span>if let </span><span>AssetEvent</span><span>::</span><span>Created </span><span>{</span><span> handle </span><span>} =</span><span> event </span><span>{
            </span><span>/* do something with created asset */
        </span><span>}
    }
}
</span></code></pre><h4 id="asset-server">Asset Server</h4>
<p>The <code>Assets&lt;T&gt;</code> collection doesn't know anything about filesystems or multi-threading. This is the responsibility of the <a href="https://docs.rs/bevy_asset/latest/bevy_asset/struct.AssetServer.html"><code>AssetServer</code>
</a> resource:</p>
<pre><code><span>fn </span><span>system</span><span>(</span><span>mut </span><span>commands</span><span>:</span><span> Commands, </span><span>asset_server</span><span>: </span><span>Res</span><span>&lt;</span><span>AssetServer</span><span>&gt;</span><span>, </span><span>mut </span><span>textures</span><span>: </span><span>ResMut</span><span>&lt;</span><span>Assets</span><span>&lt;</span><span>Texture</span><span>&gt;&gt;) {
    </span><span>// this will begin asynchronously loading "texture.png" in parallel 
    </span><span>let</span><span> texture_handle</span><span>: </span><span>Handle</span><span>&lt;</span><span>Texture</span><span>&gt; =</span><span> asset_server</span><span>.</span><span>load</span><span>("</span><span>texture.png</span><span>").</span><span>unwrap</span><span>();

    </span><span>// the texture may not be loaded yet, but you can still add the handle as a component immediately.
    // whenever possible, internal Bevy systems will wait for assets to be ready before using them:
    </span><span>let</span><span> entity </span><span>=</span><span> commands</span><span>.</span><span>spawn</span><span>((</span><span>texture_handle</span><span>,));

    </span><span>// you can also asynchronously load entire folders (recursively) by adding them as an "asset folder"
</span><span>    asset_server</span><span>.</span><span>load_asset_folder</span><span>("</span><span>assets</span><span>").</span><span>unwrap</span><span>();

    </span><span>// you can get the handle of any asset (either currently loading or loaded) like this:
    </span><span>let</span><span> music_handle</span><span>: </span><span>Handle</span><span>&lt;</span><span>AudioSource</span><span>&gt; =</span><span> asset_server</span><span>.</span><span>get_handle</span><span>("</span><span>assets/music.mp3</span><span>").</span><span>unwrap</span><span>(); 

    </span><span>// when assets have finished loading, they are automatically added to the appropriate Assets&lt;T&gt; collection
    // you can check if an asset is ready like this:
    </span><span>if let </span><span>Some</span><span>(</span><span>texture</span><span>) =</span><span> textures</span><span>.</span><span>get</span><span>(&amp;</span><span>texture_handle</span><span>) {
        </span><span>// do something with texture
    </span><span>}

    </span><span>// sometimes you want access to an asset immediately. you can block the current system until an asset has
    // finished loading and immediately update Assets&lt;T&gt; using the "load_sync" method
    </span><span>let</span><span> cool_sprite</span><span>: &amp;</span><span>Texture </span><span>=</span><span>  asset_server</span><span>.</span><span>load_sync</span><span>(&amp;</span><span>mut</span><span> textures</span><span>, "</span><span>assets/cool_sprite.png</span><span>").</span><span>unwrap</span><span>();
}
</span></code></pre><h4 id="hot-reloading">Hot Reloading</h4>
<p>You can enable asset change detection by calling:</p>
<pre><code><span>asset_server</span><span>.</span><span>watch_for_changes</span><span>().</span><span>unwrap</span><span>();
</span></code></pre>
<p>This will load new versions of assets whenever their files have changed.</p>
<h4 id="adding-new-asset-types">Adding New Asset Types</h4>
<p>To add a new asset type, implement the <a href="https://docs.rs/bevy_asset/latest/bevy_asset/trait.AssetLoader.html"><code>AssetLoader</code>
</a> trait. This tells Bevy what file formats to look for and how to translate the file bytes into the given asset type.</p>
<p>Once you have implemented <code>AssetLoader&lt;MyAsset&gt;</code> for <code>MyAssetLoader</code> you can register your new loader like this:</p>
<pre><code><span>app</span><span>.</span><span>add_asset_loader</span><span>::&lt;</span><span>MyAsset, MyAssetLoader</span><span>&gt;();
</span></code></pre>
<p>Then you can access the <code>Assets&lt;MyAsset&gt;</code> resource, listen for change events, and call <code>asset_server.load("something.my_asset")</code></p>
<h2 id="sound">Sound</h2>
<p>You can currently load and play sounds like this:</p>
<pre><code><span>fn </span><span>system</span><span>(</span><span>asset_server</span><span>: </span><span>Res</span><span>&lt;</span><span>AssetServer</span><span>&gt;</span><span>, </span><span>audio_output</span><span>: </span><span>Res</span><span>&lt;</span><span>AudioOutput</span><span>&gt;) {
    </span><span>let</span><span> music</span><span>: </span><span>Handle</span><span>&lt;</span><span>AudioSource</span><span>&gt; =</span><span> asset_server</span><span>.</span><span>load</span><span>("</span><span>music.mp3</span><span>").</span><span>unwrap</span><span>(); 

    </span><span>// this will play the music asynchronously as soon as it has loaded
</span><span>    audio_output</span><span>.</span><span>play</span><span>(</span><span>music</span><span>);

    </span><span>// if you already have an AudioSource reference you can play it immediately like this:
</span><span>    audio_output</span><span>.</span><span>play_source</span><span>(</span><span>audio_source</span><span>);
}
</span></code></pre>
<p>We plan on extending the audio system with more control and features in the future. </p>
<h2 id="render-graph">Render Graph</h2>
<p>All render logic is built on top of Bevy's <a href="https://docs.rs/bevy_render/latest/bevy_render/render_graph/struct.RenderGraph.html"><code>RenderGraph</code>
</a>. The Render Graph is a way to encode atomic units of render logic. For example, you might create graph nodes for a 2D pass, UI pass, cameras, texture copies, swap chains, etc. Connecting a node to another node indicates that there is a dependency of some kind between them. By encoding render logic this way, the Bevy renderer is able to analyze dependencies and render the graph in parallel. It also has the benefit of encouraging developers to write modular render logic.</p>
<p>Bevy includes a number of nodes by default: <code>CameraNode</code>, <code>PassNode</code>, <code>RenderResourcesNode</code>, <code>SharedBuffersNode</code>, <code>TextureCopyNode</code>, <code>WindowSwapChainNode</code>, and <code>WindowTextureNode</code>. It also provides subgraphs for 2d rendering, 3d rendering, and UI rendering. But you are welcome to create your own nodes, your own graphs, or extend the included graphs!</p>
<h3 id="data-driven-shaders"><a href="https://github.com/bevyengine/bevy/blob/master/examples/shader/shader_custom_material.rs">Data Driven Shaders</a></h3>
<p>Components and Assets can derive the <a href="https://docs.rs/bevy_render/latest/bevy_render/renderer/trait.RenderResources.html"><code>RenderResources</code>
</a> trait, which enables them to be directly copied to GPU resources and used as shader uniforms.</p>
<p>Binding uniforms to a custom shader is literally as simple as deriving <code>RenderResources</code> on your component or asset: </p>
<pre><code><span>#[</span><span>derive</span><span>(</span><span>RenderResources</span><span>,</span><span> Default</span><span>)]
</span><span>struct </span><span>MyMaterial </span><span>{
    </span><span>pub </span><span>color</span><span>:</span><span> Color,
</span><span>}
</span></code></pre>
<p>And then adding a new RenderResourceNode to the Render Graph:</p>
<pre><code><span>// create the new node
</span><span>render_graph</span><span>.</span><span>add_system_node</span><span>("</span><span>my_material</span><span>", </span><span>RenderResourcesNode</span><span>::&lt;</span><span>MyMaterial</span><span>&gt;::</span><span>new</span><span>(</span><span>true</span><span>));

</span><span>// connect the new node to the "main pass node"
</span><span>render_graph</span><span>.</span><span>add_node_edge</span><span>("</span><span>my_material</span><span>", </span><span>base</span><span>::</span><span>node</span><span>::</span><span>MAIN_PASS</span><span>).</span><span>unwrap</span><span>();
</span></code></pre>
<p>From there, MyMaterial components will be automatically copied to GPU buffers. A shader can then reference an entity's MyMaterial like this:</p>
<pre><code><span>layout</span><span>(</span><span>set </span><span>= </span><span>1</span><span>,</span><span> binding </span><span>= </span><span>1</span><span>)</span><span> uniform MyMaterial_color </span><span>{</span><span>
    vec4 color</span><span>;
};
</span></code></pre>
<p>I think the simplicity of the <a href="https://github.com/bevyengine/bevy/blob/master/examples/shader/shader_custom_material.rs">fully self-contained custom shader example</a> speaks for itself.</p>
<h3 id="shader-defs"><a href="https://github.com/bevyengine/bevy/blob/master/examples/shader/shader_defs.rs">Shader Defs</a></h3>
<p>Components and Assets can also add "shader defs" to selectively enable shader code on a per-entity basis:</p>
<pre><code><span>#[</span><span>derive</span><span>(</span><span>RenderResources</span><span>,</span><span> ShaderDefs</span><span>,</span><span> Default</span><span>)]
</span><span>struct </span><span>MyMaterial </span><span>{
    </span><span>pub </span><span>color</span><span>:</span><span> Color,
    </span><span>#[</span><span>render_resource</span><span>(</span><span>ignore</span><span>)]
    #[</span><span>shader_def</span><span>]
    </span><span>pub </span><span>always_blue</span><span>: </span><span>bool</span><span>,
</span><span>}
</span></code></pre>
<p>Then in your fragment shader you could do something like this:</p>
<pre><code><span>void </span><span>main</span><span>() {</span><span>
    o_Target </span><span>=</span><span> color</span><span>;
</span><span># ifdef</span><span> MYMATERIAL_ALWAYS_BLUE
    o_Target </span><span>= </span><span>vec4</span><span>(</span><span>0</span><span>.</span><span>0</span><span>, </span><span>0</span><span>.</span><span>0</span><span>, </span><span>1</span><span>.</span><span>0</span><span>, </span><span>1</span><span>.</span><span>0</span><span>);
</span><span># endif
</span><span>}
</span></code></pre>
<p>Any entity with a <code>MyMaterial</code> component and <code>always_blue: true</code> will be rendered blue. If <code>always_blue</code> is false, it will be rendered with <code>color</code>.</p>
<p>We currently use this feature for toggling "shadeless" rendering and optional textures, but I anticipate it being useful in a variety of contexts.</p>
<h3 id="shader-layout-reflection"><a href="https://github.com/bevyengine/bevy/blob/master/examples/shader/shader_custom_material.rs">Shader Layout Reflection</a></h3>
<p>Bevy can automatically reflect shader data layouts from SpirV shaders (and from GLSL shaders by compiling them to SpirV). This means that creating custom shaders is as simple as this:</p>
<pre><code><span>let</span><span> shader_stages </span><span>=</span><span> ShaderStages </span><span>{</span><span>
    vertex</span><span>:</span><span> shaders</span><span>.</span><span>add</span><span>(</span><span>Shader</span><span>::</span><span>from_glsl</span><span>(</span><span>ShaderStage</span><span>::</span><span>Vertex</span><span>, </span><span>VERTEX_SHADER</span><span>)),</span><span>
    fragment</span><span>: </span><span>Some</span><span>(</span><span>shaders</span><span>.</span><span>add</span><span>(</span><span>Shader</span><span>::</span><span>from_glsl</span><span>(</span><span>ShaderStage</span><span>::</span><span>Fragment</span><span>, </span><span>FRAGMENT_SHADER</span><span>))),
};
</span><span>let</span><span> pipeline_handle </span><span>=</span><span> pipelines</span><span>.</span><span>add</span><span>(</span><span>PipelineDescriptor</span><span>::</span><span>default_config</span><span>(</span><span>shader_stages</span><span>));
</span></code></pre><h2 id="productive-compile-times">Productive Compile Times</h2>
<p>One of my primary design goals for Bevy is "productivity". Game development is an extremely iterative and experimental process full of small changes. If each change takes a significant amount of time to test, then development becomes a grind. Here is my personal "acceptability scale" for iterative changes:</p>
<ul>
<li><b>0-1 seconds</b>: ideal</li>
<li><b>1-3 seconds</b>: fine</li>
<li><b>3-5 seconds</b>: annoying</li>
<li><b>5-10 seconds</b>: painful but still usable if you are committed</li>
<li><b>10+ seconds</b>: completely unusable</li>
</ul>
<p>Note that these are "iterative compile times" not "clean compile times". Clean compiles only need to happen once, whereas iterative compiles happen constantly. I care a lot less about the "clean compile" metric when it comes to productivity, although it is still important to keep clean compile times down for other reasons.</p>
<p>One of the most popular Rust engines today takes <em>over 30 seconds</em> to compile a single newline inserted into trivial examples. That is categorically unproductive and makes real game-dev practically impossible.</p>
<p>Currently, with the "fast compiles" configuration, changes to Bevy examples can be compiled in ~0.8-3 seconds, based on your computer specs, configuration, and OS choice (more on this later). There is of course always room for improvement here, but Bevy currently falls into my "usability sweet spot".</p>
<p>The "Rust compiles slow" meme exists largely because many Rust projects aren't thinking enough about the compile time performance implications of certain code patterns. Rust code generally compiles slowly for three reasons:</p>
<ul>
<li><b>Generic Monomorphization</b>: The compile step where generic code gets turned into a non-generic copy. Compile times go up as the volume of monomorphized code goes up. To keep costs low you should either avoid generics entirely or keep generic code "small" and shallow.</li>
<li><b>Link Time</b>: How long it takes to link code. Here the important thing is to keep code volume and dependency counts low.</li>
<li><b>LLVM</b>: Rust throws a large amounts of IR code at LLVM and expects it to optimize it. This takes time. Additionally LLVM is optimized for "fast code at runtime" more than "fast code generation". </li>
</ul>
<p>The LLVM bit is out of our hands (for now). Keeping generic usage low and shallow isn't a particularly hard problem, provided you employ that mindset from the beginning. Link times, on the other hand, are a constant and very real "enemy" of iterative compile times. Linking happens on every iterative compile. Adding any code to your project will increase link times. Adding any dependency to your project will increase link times.</p>
<p>The cards are stacked against us for a variety of reasons:</p>
<ul>
<li><b>The Game Engine Domain</b>
<ul>
<li>Game engines inherently touch a large number of domains (and therefore involve a large number of dependencies)</li>
<li>Game engines are "big" ... they require a lot of code</li>
</ul>
</li>
<li><b>Rust's Design Choices</b>
<ul>
<li>Dependencies are statically linked by default, which means every new dependency adds link times </li>
<li>Rust's default linker is quite slow</li>
<li>Cargo makes taking dependencies very easy. What appears to be a small, simple crate might actually have a large dependency tree</li>
</ul>
</li>
</ul>
<p>One solution to this problem is to avoid dependencies at all costs and write the smallest amount of code that you can. The <a href="https://github.com/not-fl3/macroquad">Macroquad</a> project is a great example of this. They employ a minimalist approach to code and avoid any dependency that doesn't meet their strict compile time requirements. As a result, I think its fair to say that they are the fastest compiling (while still usable) Rust game engine, both for clean and iterative compiles. However their approach comes at the cost of dependency aversion.</p>
<p>Bevy takes a slightly more pragmatic approach. First, being willing to take dependencies is good for the Rust ecosystem. I don't want to ignore all of the great work that has already been done, especially when it comes to projects like <a href="https://github.com/rust-windowing/winit">winit</a> and <a href="https://github.com/gfx-rs/wgpu-rs">wgpu</a>. But we still strive to keep our dependency tree as small as we can. And any dependency that takes Bevy out of the "ideal to fine" iterative compile time range must either be pared down or removed. When combined with the "Fast Compiles" configuration, this results in nice compile times.</p>
<h3 id="the-fast-compiles-configuration">The "Fast Compiles" Configuration</h3>
<p>The "fast compiles" configuration is how we achieve usable iterative compile times while still taking dependencies. It consists of three parts:</p>
<ul>
<li><b>LLD linker</b>: LLD is <em>much faster</em> at linking than the default Rust linker. This is the biggest win.</li>
<li><b>Nightly Rust Compiler</b>: Gives access to the latest performance improvements and "unstable" optimizations. Note that Bevy can still be compiled on stable Rust if that is a requirement for you.</li>
<li><b>Generic Sharing</b>: Allows crates to share monomorphized generic code instead of duplicating it. In some cases this allows us to "precompile" generic code so it doesn't affect iterative compiles.</li>
</ul>
<p>To enable fast compiles, install the nightly rust compiler and LLD. Then copy <a href="https://github.com/bevyengine/bevy/blob/master/.cargo/config_fast_builds">this file</a> to <code>YOUR_WORKSPACE/.cargo/config</code></p>
<h3 id="current-limitations-and-future-improvements">Current Limitations and Future Improvements</h3>
<p>While Bevy is currently "productive" by my criteria, it isn't all sunshine and rainbows yet. First, MacOS doesn't have an up-to-date version of the LLD linker and therefore iterative compiles are <em>much</em> slower on that platform. Additionally, LLD is <em>slightly</em> slower on Windows than it is on Linux. On my machine I get ~1.5-3.0 seconds on Windows vs ~0.8-3.0 seconds on Linux.</p>
<h4 id="dynamic-linking-to-the-rescue">Dynamic Linking to the Rescue</h4>
<p>An easy way to cut down on link times is to just dynamically link instead. On my 2013 MacBook Pro running MacOS (with no LLD), I was able to drop iterative Bevy compile times from ~6 seconds to ~0.6 seconds by dynamically linking app plugins. Bevy actually already has support for dynamic App plugins, but the new Bevy ECS does not currently support dynamic linking because it relies on TypeIds (which are incompatible with dynamic linking). Fortunately, I have already solved the TypeId problem in other projects, so we should be able to add this back soon. </p>
<h4 id="cranelift-rustc-backend">Cranelift Rustc Backend</h4>
<p>Cranelift is an alternative compiler backend that is optimized for fast compiles. The <a href="https://github.com/bjorn3/rustc_codegen_cranelift">rustc cranelift backend</a> is rapidly approaching a usable state. I'm hoping it will give us a nice boost eventually.</p>
<h2 id="example-game-breakout">Example Game: Breakout</h2>
<p>If you are curious about what actual Bevy game code looks like, check out the <a href="https://github.com/bevyengine/bevy/blob/master/examples/game/breakout.rs">breakout example</a>. Forgive my slightly janky collision code please :)</p>

<h2 id="why-build-bevy">Why Build Bevy?</h2>
<p>There are plenty of fantastic engines out there ... why build another one? Especially when there are already so many in the Rust ecosystem?</p>
<p>First a bit about me: I decided to build Bevy after years of contributing code to other engines (ex: Godot). I spent over four years <a href="https://www.youtube.com/c/cartdev">building a game in Godot</a> and I also have experience with Unity, Unreal, and a number of other frameworks like SDL and Three.js. I have built multiple custom engines in the past using Rust, Go, HTML5, and Java. I have also used and/or closely followed most of the current players in the Rust gamedev ecosystem. I recently quit my job as Senior Software Engineer at Microsoft and my experience there deeply affected my opinions of software and what it should be.</p>
<p>These experiences led me to want the following from a game engine:</p>
<ul>
<li><b>Free and Open Source</b>: It needs to be free and open source with <em>no strings attached</em>. Games are a huge part of our culture and humanity is investing <em>millions</em> of hours into the development of games. Why are we (as game developers / engine developers) continuing to build up the ecosystems of closed-source monopolies that take cuts of our sales and deny us visibility into the tech we use daily? As a community I believe we can do so much better. This criteria eliminates Unreal and Unity, despite their huge feature sets.</li>
<li><b>Productive</b>: It needs to have fast build/run/test loops, which translates to either scripting languages or fast compile times in native languages. But scripting languages introduce runtime overhead, cognitive load, and a barrier between me and the actual engine, so my preference here is a native language with fast compile times. Sadly compile times are a huge problem in the Rust ecosystem and many Rust engines have prohibitively long iterative compiles. Fortunately Rust game engines like Macroquad and coffee prove that productive iterative compile times are possible.</li>
<li><b>Turtles All The Way Down</b>: Ideally the engine is written in the same language that games are. Being able to run an IDE "go to definition" command on a symbol in your game and hop directly into the engine source is an extremely powerful concept. You also don't need to worry about heavy language translation layers or lossy abstractions. If an engine's community builds games in the same language as the engine, they are more likely (and able) to contribute back to the engine.</li>
<li><b>Simple</b>: It needs to be easy to use for common tasks, but it also can't hide the details from you. Many engines are either "easy to use but too high level" or "very low level but difficult to do common tasks in". Additionally, many engines in Rust are littered with lifetimes and generics. Both are powerful tools to be sure, but they also introduce cognitive load and reduce ergonomics. Generics can also have a huge impact on compile times if you aren't careful.</li>
<li><b>Editor</b>: It needs to have an (optional) graphical editor. Scene creation is a large part of game development and in many cases visual editors beat code. As a bonus, the editor should be built <em>in the engine</em>. Godot uses this approach and it is <em>so smart</em>. Doing so <a href="https://en.wikipedia.org/wiki/Eating_your_own_dog_food">dogfoods</a> the engine's UI system and creates positive feedback loops. Improvements to the editor are also often improvements to the core engine. It also makes sure your engine is flexible enough to build tooling (and not just games). I personally consider building an engine's editor in another stack to be a missed opportunity (ex: the web, QT, native widgets). </li>
<li><b>Data Driven</b>: It needs to be data-driven/data-oriented/data-first. ECS is a common way of doing this, but it definitely isn't the only way. These paradigms can make your game faster (cache friendly, easier to parallelize), but they also make common tasks like game state serialization and synchronization delightfully straightforward.</li>
</ul>
<p>None of the engines on the market <em>quite</em> line up with what I'm looking for. And the changes required to make them meet my requirements are either massive in scope, impossible (closed source), or unwelcome (the things I want aren't what the developers or customers want). On top of that, making new game engines is fun!</p>
<p>Bevy is not trying to out-compete other open-source game engines. As much as possible we should be collaborating and building common foundations. If you are an open source game engine developer and you think a Bevy component would make your engine better, one of your engine's components could make Bevy better, or both, please reach out! Bevy is already benefitting massively from the efforts of the Rust gamedev ecosystem and we would love to pay it forward in whatever way we can.</p>
<h2 id="what-s-next">What's Next?</h2>
<p>I'm proud of how far Bevy has come in a relatively short period of time, but there is still plenty of work left to do. These will be our focus areas over the coming months:</p>
<h3 id="physically-based-rendering-pbr">Physically Based Rendering (PBR)</h3>
<p>Bevy's current 3D renderer is extremely bare bones. As I primarily make 3D games, improving the 3D renderer is a priority for me. We will be adding PBR shaders, shadows, more lighting options, skeletal animation, improved GLTF import, ambient occlusion (implementation TBD), and probably a bunch of other things.</p>
<h3 id="editor">Editor</h3>
<p>Bevy was architected with a visual editor in mind. The Scene and Properties systems were specifically built to make game&lt;-&gt;editor dataflow nicer. The editor will be built as a Bevy App and will utilize the existing Bevy UI, Bevy ECS, Scene, and Properties features. I like the "build the editor in the engine" approach because improvements to the editor are often improvements to the engine, and vice-versa. Additionally, it ensures that Bevy is capable of building non-game apps and tooling.</p>
<h3 id="platform-support-android-ios-web">Platform Support: Android, iOS, Web</h3>
<p>Under the hood Bevy uses <a href="https://github.com/rust-windowing/winit">winit</a> (for multi-platform windows and input) and <a href="https://github.com/gfx-rs/wgpu-rs">wgpu</a> (for multi-platform rendering). Each of these projects has varying degrees of support for the platforms above. And in general Bevy was designed to be platform-agnostic, so supporting the platforms above should be possible with a little bit of work.</p>
<h3 id="render-batching-and-instancing">Render Batching and Instancing</h3>
<p>Right now Bevy can render plenty fast for most use cases, but when it comes to rendering huge amounts of objects (tens of thousands) it isn't quite there yet. To accomplish that, we need to implement batching / instancing. These concepts can be defined in a number of ways, but the general gist is that we will be grouping as much geometry and data into the smallest number of draw calls possible, while also reducing GPU state changes as much as possible. I'm hoping Bevy's data driven shader approach will make the instancing implementation simple and extensible.</p>
<h3 id="canvas">Canvas</h3>
<p>Right now the only way to draw UI and 2D scenes is via sprites and rectangles. Bevy needs an immediate-mode drawing api capable of drawing anti-aliased curves and shapes. This can then be used to do code-driven drawing of things like rounded corners in Bevy UI, performance graphs in the editor, etc. It's very possible that we will integrate projects like <a href="https://github.com/servo/pathfinder">pathfinder</a> or <a href="https://github.com/nical/lyon">lyon</a> for this.</p>
<h3 id="animation">Animation</h3>
<p>Animation permeates almost everything in gamedev. First, I want to add a general purpose code-first animation system. Then on top of that we will add a property-based timeline system that can be saved to a config file and visualized / edited in the Bevy Editor.</p>
<h3 id="nicer-scene-format">Nicer Scene Format</h3>
<p>The current scene format is workable, but it isn't yet ideal for manual scene composition because it is a flat list of unordered entities. I also want to add nested scenes. Eventually, I would like the scene format to <a href="https://gist.github.com/cart/3e77d6537e1a0979a69de5c6749b6bcb">look something like this</a>.</p>
<h3 id="dynamic-plugin-loading">Dynamic Plugin Loading</h3>
<p>To mitigate the cost of compiling and linking plugins and make hot-code-reloading possible, we will provide the option to dynamically load App plugins. Bevy actually already supports this feature, but there is one hangup: Rust's <code>TypeId</code>. TypeIds are unstable across binaries, which means <code>TypeId::of::&lt;T&gt;()</code> in the host binary will not match <code>TypeId::of::&lt;T&gt;()</code> in a dynamically loaded binary. Bevy ECS uses TypeIds, which means dynamically loaded ECS types won't behave correctly. In the past, Bevy used a custom fork of the Legion ECS (where we fixed the TypeId problem). But since moving to Bevy ECS the problem has resurfaced. The fix is to apply the same approach we used in Legion to Bevy ECS. </p>
<h3 id="physics">Physics</h3>
<p>Many games require collision detection and physics. I'm planning on building a plug-able physics interface with <a href="https://nphysics.org/">nphysics / ncollide</a> as the first backend.</p>
<h3 id="polish">Polish</h3>
<p>There are plenty of areas that need more design work or features. For example, I think the core Render Graph is in a pretty good state, but the mid-level and high level rendering APIs need more time and experimentation. I also want to rethink how materials are composed. If you are curious about all of the improvements on our radar, check out the <a href="https://github.com/bevyengine/bevy/issues">Bevy issue tracker on GitHub</a>.</p>
<h3 id="documentation">Documentation</h3>
<p>Bevy's APIs are still very unstable, so I haven't spent much time documenting anything yet. <a href="https://bevyengine.org/learn/book/introduction/">The Bevy Book</a> is still small and the <a href="https://docs.rs/bevy">Rust API Docs</a> have plenty of gaps. In general I subscribe to the idea of "documentation proportional to stability". As features stabilize and design patterns emerge, we will increase efforts in both of those areas.</p>
<h2 id="join-the-bevy">Join the Bevy!</h2>
<p>If any of this sounds interesting to you, I encourage you to check out <a href="https://github.com/bevyengine/bevy">Bevy on GitHub</a>, read <a href="https://bevyengine.org/learn/book/introduction/">The Bevy Book</a>, and <a href="https://bevyengine.org/community/">join the Bevy community</a>. Currently Bevy is 100% built by volunteers, so if you want to help us build the next great game engine, <a href="https://discord.com/invite/gMUk5Ph">please reach out</a>! We need all the help we can get, especially if you are a:</p>
<ul>
<li><b>Software Developer</b>: check out the <a href="https://bevyengine.org/learn/book/contributing/code">Contributing Code</a> section of The Bevy Book.</li>
<li><b>Technical Writer</b>: check out the <a href="https://bevyengine.org/learn/book/contributing/docs">Contributing Docs</a> section of The Bevy Book.</li>
</ul>
<p>I want Bevy to become a vibrant developer community ... thats actually why I chose the name! A Bevy is a group of birds, just like we are a group of game developers. Join the Bevy!</p>
<p><img src="https://bevyengine.org/assets/bevy_logo_dark.svg">
</p></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>