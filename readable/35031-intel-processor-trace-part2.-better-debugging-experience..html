<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Intel Processor Trace Part2. Better debugging experience. -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Intel Processor Trace Part2. Better debugging experience.</h1><div><div class="notebody"><p><strong>Contents:</strong></p><hr><p><strong>Subscribe to my <a href="/blog/2019/08/30/Intel-PT-part2#mc_embed_signup">mailing list</a> and support me on <a href="https://www.patreon.com/dendibakh">Patreon</a>.</strong></p><hr><p>In the <a href="https://easyperf.net/blog/2019/08/23/Intel-Processor-Trace">first part</a> of my series about Intel Processor Traces (PT) I showed the underlying mechanics of this HW feature and talked a bit about its main use cases.</p><p>Here is the list of all parts in the series of posts about Intel PT:</p><ol><li>Part1: <a href="https://easyperf.net/blog/2019/08/23/Intel-Processor-Trace">Introduction to Intel Processor Trace</a>.</li><li>Part2: Better debugging experience with Intel PT (this article).</li><li>Part3: <a href="https://easyperf.net/blog/2019/09/06/Intel-PT-part3">Analyzing performance glitches with Intel PT</a>.</li><li>Part4: <a href="https://easyperf.net/blog/2019/09/13/Intel-PT-part4">Better profiling experience with Intel PT</a>.</li></ol><p>In this article I will go into one of areas where PT can provide additional value, which is debugging.</p><h3 id="postmortem-debugging">Postmortem debugging</h3><p>Traditionally, in embedded world, issues that happen in production environment are being debugged by logging. But sometimes it’s not enough. Suppose we have a function like this with a big switch inside:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="nf">foo</span><span class="p">(</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">arg</span><span class="p">)</span><span class="p">{</span><span class="kt">int</span><span class="n">x</span><span class="o">=</span><span class="n">someComplexFunc</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span><span class="n">log</span><span class="p">(</span><span class="s">"Enter calculations"</span><span class="p">);</span><span class="k">switch</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="p">{</span><span class="k">case</span><span class="mi">7498536</span><span class="p">:</span><span class="p">{</span><span class="kt">int</span><span class="n">y</span><span class="o">=</span><span class="mi">7498536</span><span class="o">/</span><span class="n">x</span><span class="p">;</span><span class="c1">// potential div by zero</span><span class="n">x</span><span class="o">=</span><span class="n">y</span><span class="o">-</span><span class="mi">42</span><span class="p">;</span><span class="k">break</span><span class="p">;</span><span class="p">}</span><span class="c1">// &lt;lots of other cases&gt;</span><span class="nl">default:</span><span class="n">x</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span><span class="k">break</span><span class="p">;</span><span class="p">}</span><span class="n">log</span><span class="p">(</span><span class="s">"result: x = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">x</span><span class="p">);</span><span class="k">return</span><span class="n">x</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>Customer reports that once in a while they see some of their machines crash. In the logs they provided the last lines are:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Time           message
19:25:13:0124: bar: calling foo
19:25:13:0134: foo: Enter calculations
</code></pre></div></div><p>Well, that’s better than nothing, still doesn’t give any clue what exactly the problem is. If the switch is big enough it will be hard to find where exactly is the issue.</p><p>Intel PT can provide a little bit more insights. I used <a href="https://github.com/andikleen/simple-pt">simple-pt</a> to collect the traces <sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>. Please refer to <code class="language-plaintext highlighter-rouge">simple-pt</code> documentation<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> for how to build and use it.</p><p>Source code for this example is available on my <a href="https://github.com/dendibakh/dendibakh.github.io/tree/master/_posts/code/IntelPT/postmortem">github</a>. I built the program like this:</p><p>The command below collects the traces. By default <code class="language-plaintext highlighter-rouge">simple-pt</code> saves the traces into 2MB circular buffer. This means new traces overwrite the old ones. So, even for long running applications we can have a trace of what was happening just before the crash:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>sptcmd <span class="nt">-K</span><span class="nt">--cyc</span> 1 taskset <span class="nt">-c</span> 0 ./app
</code></pre></div></div><p>After we collected the traces we can decode them with: <sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup></p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>sptdecode <span class="nt">-s</span> ptout.sideband <span class="nt">--pt</span> ptout.0 <span class="nt">-i</span><span class="nt">-t</span> | xed <span class="nt">-F</span> insn: <span class="nt">-A</span><span class="nt">-64</span><span class="o">&gt;</span> dump.txt
</code></pre></div></div><p>If we now look into the <code class="language-plaintext highlighter-rouge">dump.txt</code>, right at the bottom we will see something like:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;...&gt;
560a8ef2870d 0  call  callq  0x560a8ef2866allq
560a8ef2866b 0 other  mov %rsp, %rbp
560a8ef2866e 0 other  movl  %edi, -0x14(%rbp) 
560a8ef28671 0 other  movl  $0x0, -0x8(%rbp) 
560a8ef28678 0 other  movl  -0x14(%rbp), %eax 
560a8ef2867b 0 other  cmp $0x1d4a, %eax
560a8ef28680 0 cjump  jnz 0x560a8ef28699	// arg == 7498536
560a8ef28682 0 other  mov $0x1d4a, %eax 	// entering the block
560a8ef28687 0 other  cdq			// with div by zero
</code></pre></div></div><p>I was having some issues with emitting source code lines in the dumps. In <code class="language-plaintext highlighter-rouge">sptdecode</code> there is <code class="language-plaintext highlighter-rouge">-d</code> option that is supposed to print source code intermixed with the associated assembly code. After discussing the issue with Andi Kleen it looks like the problem is somewhere on my side.<sup id="fnref:5"><a href="#fn:5" class="footnote">4</a></sup></p><p>In this example you can see how Intel PT can tell us the last instructions that were executed<sup id="fnref:4"><a href="#fn:4" class="footnote">5</a></sup>. <strong>Intel PT can be used as an almost free<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup> addition to the  logging capabilities of your applications and often can provide a big chunk of useful information for postmortem debugging</strong>.</p><p>Logs still are very useful because you can print some values in them. Until <code class="language-plaintext highlighter-rouge">PTWRITE</code> instruction came out there was no way of dumping data in processor traces. Traces were only useful for determining control flow. But in recent CPUs we have <code class="language-plaintext highlighter-rouge">PTWRITE</code> instruction that allows writing values into the PT packets<sup id="fnref:7"><a href="#fn:7" class="footnote">7</a></sup>. According to <a href="https://software.intel.com/en-us/articles/intel-sdm">Intel SD Manual</a>:</p><blockquote><p>This instruction reads data in the source operand and sends it to the Intel Processor Trace hardware to be encoded in a PTW packet.</p></blockquote><p>I haven’t used <code class="language-plaintext highlighter-rouge">PTWRITE</code> in practice, but I assume that every time you want to print something new you need to recompile the binary. Though you need to do the same when using logs.</p><p>My Intel Core i5-8259U doesn’t have <code class="language-plaintext highlighter-rouge">PTWRITE</code> support. You can check whether your CPU has <code class="language-plaintext highlighter-rouge">PTWRITE</code> support with <a href="http://halobates.de/spt-man/ptfeature.html">ptfeature</a> tool which is a part of <code class="language-plaintext highlighter-rouge">simple-pt</code>.</p><h3 id="debugging-stack-corruption-issues">Debugging stack corruption issues</h3><p>Now let me show another case where Intel PT can be useful.</p><p>Let me jump right into the example with the program where the call stack is being corrupted:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a.c</span><span class="kt">void</span><span class="nf">bar</span><span class="p">();</span><span class="c1">// implemented in assembly below</span><span class="kt">void</span><span class="nf">foo</span><span class="p">()</span><span class="p">{</span><span class="n">bar</span><span class="p">();</span><span class="p">}</span><span class="kt">int</span><span class="nf">main</span><span class="p">()</span><span class="p">{</span><span class="n">foo</span><span class="p">();</span><span class="p">}</span></code></pre></div></div><pre><code class="language-asm">// b.asm
GLOBAL bar

bar:
pop rdx       ; remove return address from the stack
xor rax, rax
ret
ud2
</code></pre><p>Source code for this example is available on my <a href="https://github.com/dendibakh/dendibakh.github.io/tree/master/_posts/code/IntelPT/stack_corruption">github</a>. Let’s build the program and make sure it’s crashing:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gcc a.c <span class="nt">-c</span><span class="nt">-g</span><span class="nv">$ </span>nasm <span class="nt">-f</span> elf64 b.asm <span class="nt">-g</span><span class="nv">$ </span>gcc a.o b.o
<span class="nv">$ </span>./a.out
Segmentation fault <span class="o">(</span>core dumped<span class="o">)</span></code></pre></div></div><p>When I run usual (pre-installed) version of gdb:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>/usr/bin/gdb ./a.out
GNU gdb <span class="o">(</span>Ubuntu 8.1-0ubuntu3<span class="o">)</span> 8.1.0.20180409-git
<span class="o">(</span>gdb<span class="o">)</span> r
Starting program: /path/to/a.out
Program received signal SIGSEGV, Segmentation fault.
0x00007fffffffe336 <span class="k">in</span> ?? <span class="o">()</span><span class="o">(</span>gdb<span class="o">)</span> bt
<span class="c">#0  0x00007fffffffe336 in ?? ()</span><span class="c">#1  0x00007fffffffe320 in ?? ()</span><span class="c">#2  0x00007fffffffe320 in ?? ()</span><span class="c">#3  0x00007fffffffe320 in ?? ()</span><span class="c">#4  0x0000555555554619 in main () at a.c:10</span>
Backtrace stopped: frame did not save the PC
</code></pre></div></div><p>Stack is corrupted, so gdb is not able to unwind it. According to my experiments, <a href="https://rr-project.org/">rr</a> tool cannot provide any additional value either.</p><p>Now let’s try to run the same example using build-from-sources gdb and record traces. You can find particular instructions in the <a href="/blog/2019/08/30/Intel-PT-part2#appendix-how-to-build-gdb-with-intel-pt-support">appendix</a> of this article.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>/usr/local/bin/gdb ./a.out
GNU gdb <span class="o">(</span>GDB<span class="o">)</span> 8.3.50.20190822-git
<span class="o">(</span>gdb<span class="o">)</span> start
Starting program: /path/to/a.out
Temporary breakpoint 1, main <span class="o">()</span> at a.c:10
10        foo<span class="o">()</span><span class="p">;</span><span class="o">(</span>gdb<span class="o">)</span> record btrace pt
<span class="o">(</span>gdb<span class="o">)</span> c
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0x00007fffffffe336 <span class="k">in</span> ?? <span class="o">()</span></code></pre></div></div><p>We have the crash, let’s now see the call history:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> record <span class="k">function</span><span class="nt">-call-history</span>
1       main
2       foo
3       bar
4       ??
</code></pre></div></div><p>We can even pull the previous executed instructions.</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> record instruction-history /m -
4          0x00005555555545fb &lt;foo+1&gt;:  mov    %rsp,%rbp
a.c:5     bar<span class="o">()</span><span class="p">;</span>
5          0x00005555555545fe &lt;foo+4&gt;:  mov    <span class="nv">$0x0</span>,%eax
6          0x0000555555554603 &lt;foo+9&gt;:  callq  0x555555554620 &lt;bar&gt;
7          0x0000555555554620 &lt;bar+0&gt;:  pop    %rdx
8          0x0000555555554621 &lt;bar+1&gt;:  xor    %rax,%rax
9          0x0000555555554624 &lt;bar+4&gt;:  retq
10         0x00007fffffffe330:  xor    %al,0x55<span class="o">(</span>%rsi<span class="o">)</span>
11         0x00007fffffffe333:  push   %rbp
12         0x00007fffffffe334:  push   %rbp
13         0x00007fffffffe335:  push   %rbp
</code></pre></div></div><p>Here <code class="language-plaintext highlighter-rouge">/m</code> switch is used for intermixing source code with assembly instructions. Because <code class="language-plaintext highlighter-rouge">bar</code> is implemented in assembly there is obviously no source line for it. But for <code class="language-plaintext highlighter-rouge">foo</code> function we see the corresponding source line (<code class="language-plaintext highlighter-rouge">a.c:5</code>).</p><p>After we know the exact place where the issue happened we can put normal breakpoint and restart debugging session as usual.</p><p><strong>As you see, Intel PT helps when debugging programs with corrupted stack</strong>.</p><h3 id="appendix-how-to-build-gdb-with-intel-pt-support">Appendix: How to build gdb with Intel PT support</h3><p>This <a href="http://sourceware-org.1504.n7.nabble.com/Could-not-use-quot-record-btrace-quot-even-if-I-have-Intel-PT-hardware-feature-td412196.html">page</a> would probably be a good starting point. GDB uses <a href="https://github.com/intel/libipt">libipt</a> for collecting PT, so we need to build it first:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/intel/libipt.git
<span class="nb">mkdir </span>build <span class="o">&amp;&amp;</span><span class="nb">cd </span>build
cmake ../libipt
make
make <span class="nb">install</span></code></pre></div></div><p>Then we build gdb from sources as shown <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1526617#c5">here</a>:</p><div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>texinfo bison flex
git clone git://sourceware.org/git/binutils-gdb.git
<span class="nb">mkdir </span>build <span class="o">&amp;&amp;</span><span class="nb">cd </span>build
../binutils-gdb/configure <span class="nt">--disable-binutils</span><span class="nt">--disable-ld</span><span class="nt">--disable-gold</span><span class="nt">--disable-gas</span><span class="nt">--disable-sim</span><span class="nt">--disable-gprof</span>
make
make <span class="nb">install</span></code></pre></div></div><hr></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>