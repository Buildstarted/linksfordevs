<!DOCTYPE html>
<html lang="en">
<head>
    <title>
PHP Bug Allows RCE on NGINX Servers -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>PHP Bug Allows RCE on NGINX Servers</h1>
    <div><div class="c-article__intro"> <p>CVE-2019-11043 is trivial to exploit &#x2014; and a proof of concept is available.</p> </div><div class="c-article__content js-reading-content"> <p>A buffer underflow bug in PHP could allow remote code-execution (RCE) on targeted NGINX servers.</p>
<p>First discovered during a hCorem Capture the Flag competition in September, the bug (CVE-2019-11043) exists in the FastCGI directive used in some PHP implementations on NGINX servers, according to researchers at Wallarm.</p>
<p>PHP powers about 30 percent of modern websites, including popular web platforms like WordPress and Drupal &#x2013; but NGINX servers are only vulnerable if they have PHP-FPM enabled (a non-default optimization feature that allows servers to execute scripts faster). The issue <a href="https://bugs.php.net/patch-display.php?bug_id=78599&amp;patch=0001-Fix-bug-78599-env_path_info-underflow-can-lead-to-RC.patch&amp;revision=latest">is patched</a> in PHP versions 7.3.11, 7.2.24 and 7.1.33, which were released last week.</p>
<p><a href="https://threatpost.com/newsletter-sign/"><img class="aligncenter wp-image-141989 size-full" src="https://media.threatpost.com/wp-content/uploads/sites/103/2019/02/19151457/subscribe2.jpg" alt width="700"></a></p>
<p>In a <a href="https://github.com/search?q=fastcgi_split_path&amp;type=Code">Monday posting</a>, Wallarm researchers said that the bug can be exploited by sending specially crafted packets to the server by using the &#x201C;fastcgi_split_path&#x201D; directive in the NGINX configuration file. That file is configured to process user data, such as a URL. If an attacker creates a special URL that includes a &#x201C;%0a&#x201D; (newline) byte, the server will send back more data than it should, which confuses the FastCGI mechanism.</p>
<p>&#x201C;In particular, [the bug can be exploited] in a fastcgi_split_path directive and a regexp trick with newlines,&#x201D; according to Wallarm security researcher Andrew Danau, who found the bug. &#x201C;Because of %0a character, NGINX will set an empty value to this variable, and fastcgi+PHP will not expect this&#x2026;.[as a result], it&#x2019;s possible to put [in] arbitrary FastCGI variables, like PHP_VALUE.&#x201D;</p>
<p>Another security researcher participating in the CTF exercise, Emil Lerner, offered more details in the <a href="https://bugs.php.net/bug.php?id=78599">PHP bug tracker</a>: &#x201C;The regexp in `fastcgi_split_path_info` directive can be broken using the newline character (in encoded form, %0a). Broken regexp leads to empty PATH_INFO, which triggers the bug,&#x201D; he said.</p>
<p>Lerner <a href="https://github.com/neex/phuip-fpizdam/">posted a zero-day proof-of-concept</a> exploit for the flaw that works in PHP 7 to allow code execution. The exploit, which is trivial, makes use of an optimization used for storing FastCGI variables, _fcgi_data_seg.</p>
<p>&#x201C;Usually, that sort of [buffer underflow] response is related to memory-corruption attacks and we expected to see an attack on the type of information disclosure,&#x201D; Wallarm researchers said. &#x201C;Information disclosure is bad enough as it can result in leaking sensitive or financial data. Even worse, from time to time, although quite rarely, such behavior can indicate a remote code execution vulnerability.&#x201D;</p>
<p>Researchers added that without patching, this issue can be a dangerous entry point into web applications given the trivial nature of mounting an exploit.</p>
<p>Admins can identify vulnerable FastCGI directives in their NGINX configurations with a bash command, &#x201C;egrep -Rin &#x2013;color &#x2018;fastcgi_split_path&#x2019; /etc/nginx/,&#x201D; according to Wallarm.</p>
<p><em><strong>What are the top mistakes leading to data breaches at modern enterprises? Find out: Join experts from SpyCloud and Threatpost senior editor Tara Seals on our upcoming free&#xA0;</strong></em><a href="https://attendee.gotowebinar.com/register/3127445778613605890?source=ART"><em><strong>Threatpost webinar</strong></em></a><em><strong>, &#x201C;Trends in Fortune 1000 Breach Exposure.&#x201D;&#xA0;</strong></em><a href="https://attendee.gotowebinar.com/register/3127445778613605890?source=ART"><em><strong>Click here to register</strong></em></a><em><strong>.</strong></em></p> <footer class="c-article__footer"> <div class="c-article__footer__container"> </div> <div class="c-article__footer__container"> <p class="c-article__footer__col"> <ul class="c-list-categories"> <li><a class="c-label c-label--secondary-transparent" href="https://threatpost.com/category/vulnerabilities/">Vulnerabilities</a></li> <li><a class="c-label c-label--secondary-transparent" href="https://threatpost.com/category/web-security/">Web Security</a></li> </ul> </p> </div> </footer> </div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>