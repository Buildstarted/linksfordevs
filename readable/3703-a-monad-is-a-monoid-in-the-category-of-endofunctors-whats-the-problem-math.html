<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A monad is a monoid in the category of endofunctors, what&#x27;s the problem? : math -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>A monad is a monoid in the category of endofunctors, what's the problem? : math</h1><div><div theme="[object Object]" class="_292iotee39Lmt0MkQZ2hPV RichTextJSON-root"><p class="_1qeIAgB0cPwnLhDF9XSiJM">This phrase appears in the hilarious <a href="http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank"><em class="_7s4syPYtk5hfUIjySXcRE">A Brief, Incomplete, and Mostly Wrong History of Programming Languages</em></a>, making fun of the obscure mathematical concepts in the functional programming language Haskell.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">I've studied some category theory and I've programmed in Haskell, and I've seen this statement many times before. But I've never actually taken the time to break it down and see why it's true. I just spent a couple of hours refreshing my rusty category theory knowledge and figuring it out. I wanted to write it down to make sure I actually understood it well. So... here goes.</p><p class="_7T4UafM1PdBGycd5na9nF">What's a category?</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">A [category](<a href="https://en.wikipedia.org/wiki/Category_(mathematics)" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank">https://en.wikipedia.org/wiki/Category_(mathematics)</a>) is simply a collection of 'objects' (or 'points') with 'morphisms' (or 'arrows') between them, satisfying two very simple rules:</p><ul class="_33MEMislY0GAlB78wL1_CR"><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">You can compose an arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">f: A -&gt; B</code> with an arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">g: B -&gt; C</code> to get a new arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">g . f: A -&gt; C</code>, and this composition is associative (i.e. <code class="_34q3PgLsx9zIU5BiSOjFoM">h . (g . f) = (h . g) . f</code>).</p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">For every object <code class="_34q3PgLsx9zIU5BiSOjFoM">A</code> there exists an <em class="_7s4syPYtk5hfUIjySXcRE">identity arrow</em><code class="_34q3PgLsx9zIU5BiSOjFoM">id_A: A -&gt; A</code>, such that for every arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">f: A -&gt; B</code> we have <code class="_34q3PgLsx9zIU5BiSOjFoM">id_B . f = f . id_A = f</code>.</p></li></ul><p class="_1qeIAgB0cPwnLhDF9XSiJM">The classical example in mathematics is the category <code class="_34q3PgLsx9zIU5BiSOjFoM">Set</code>, whose objects are sets, and whose arrows are functions between these sets. In the world of Haskell, we have the category <a href="https://wiki.haskell.org/Hask" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank"><code class="_34q3PgLsx9zIU5BiSOjFoM">Hask</code></a>, whose objects are Haskell types and whose arrows are functions between these types. So, for example, <code class="_34q3PgLsx9zIU5BiSOjFoM">Float</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">Int</code> are objects, and <code class="_34q3PgLsx9zIU5BiSOjFoM">round:: Float -&gt; Int</code> is an arrow.</p><p class="_7T4UafM1PdBGycd5na9nF">What's a functor?</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">In category theory a <a href="https://en.wikipedia.org/wiki/Functor" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank">functor</a> is a map between two categories. So if <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code> are categories, then a functor <code class="_34q3PgLsx9zIU5BiSOjFoM">F: C -&gt; D</code> will map objects in <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> to objects in <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code>, and arrows in <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> to arrows in <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code>. It does this in a 'nice' way. That is:</p><ul class="_33MEMislY0GAlB78wL1_CR"><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">The starts and ends of arrows are mapped nicely: if <code class="_34q3PgLsx9zIU5BiSOjFoM">f</code> is an arrow in <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> from object <code class="_34q3PgLsx9zIU5BiSOjFoM">A</code> to <code class="_34q3PgLsx9zIU5BiSOjFoM">B</code>, then <code class="_34q3PgLsx9zIU5BiSOjFoM">F(f)</code> is an arrow in <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code> from <code class="_34q3PgLsx9zIU5BiSOjFoM">F(A)</code> to <code class="_34q3PgLsx9zIU5BiSOjFoM">F(B)</code>.</p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Identities are preserved: <code class="_34q3PgLsx9zIU5BiSOjFoM">F(id_A) = id_F(A)</code>.</p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Composition is preserved: <code class="_34q3PgLsx9zIU5BiSOjFoM">F(g . f) = F(g) . F(f)</code>.</p></li></ul><p class="_1qeIAgB0cPwnLhDF9XSiJM">Note that this concept is a bit more general than the concept of functors in Haskell (see below).</p><p class="_1WODZhR-x-fbMu3MOL9cH1">What's an endofunctor?</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">An endofunctor is simply a functor from a category to itself. So in the above, assume that <code class="_34q3PgLsx9zIU5BiSOjFoM">C = D</code>. Note, that doesn't mean that the endofunctor <code class="_34q3PgLsx9zIU5BiSOjFoM">F</code> doesn't <em class="_7s4syPYtk5hfUIjySXcRE">do</em> anything. Just like a function from the real numbers to the real numbers might still <em class="_7s4syPYtk5hfUIjySXcRE">change</em> the numbers, the functor <code class="_34q3PgLsx9zIU5BiSOjFoM">F</code> might still change the objects and arrows that are fed through it in some way.</p><p class="_1WODZhR-x-fbMu3MOL9cH1">What's a Haskell Functor?</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">What is known as a <code class="_34q3PgLsx9zIU5BiSOjFoM">Functor</code> in Haskell is actually an endofunctor on the category <code class="_34q3PgLsx9zIU5BiSOjFoM">Hask</code>. Recall that <code class="_34q3PgLsx9zIU5BiSOjFoM">Hask</code> has types as its objects and functions between these types as its arrows. So an endofunctor on <code class="_34q3PgLsx9zIU5BiSOjFoM">Hask</code> will map a type to some other type, and will also map functions to functions in some nice way.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">This is the <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#Functor" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank">definition of <code class="_34q3PgLsx9zIU5BiSOjFoM">Functor</code> in Haskell</a>:</p><pre class="_3GnarIQX9tD_qsgXkfSDz1"><code class="_34q3PgLsx9zIU5BiSOjFoM">{- | The 'Functor' class is used for types that can be mapped over.
Instances of 'Functor' should satisfy the following laws:

&gt; fmap id  ==  id
&gt; fmap (f . g)  ==  fmap f . fmap g

The instances of 'Functor' for lists, 'Data.Maybe.Maybe' and 'System.IO.IO'
satisfy these laws.
-}

class  Functor f  where
    fmap        :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre><p class="_1qeIAgB0cPwnLhDF9XSiJM">See the symmetry with the mathematical definition of functors above? The type constructor <code class="_34q3PgLsx9zIU5BiSOjFoM">f</code> fulfills the role of the functor's action on types (objects), while <code class="_34q3PgLsx9zIU5BiSOjFoM">fmap</code> fulfills the role of the functor's action on functions (arrows).</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">The two classical examples of <code class="_34q3PgLsx9zIU5BiSOjFoM">Functor</code>s in Haskell are lists (<code class="_34q3PgLsx9zIU5BiSOjFoM">[]</code>) and <code class="_34q3PgLsx9zIU5BiSOjFoM">Maybe</code>.</p><p class="WFFrvt6_3z5B7MBcYKr8U">List is a Functor</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">List is a type constructor that, given some type <code class="_34q3PgLsx9zIU5BiSOjFoM">a</code> will give you a new type <code class="_34q3PgLsx9zIU5BiSOjFoM">[a]</code>, namely lists consisting of values of type <code class="_34q3PgLsx9zIU5BiSOjFoM">a</code>. This is the type (object) mapping part. The function mapping part is <code class="_34q3PgLsx9zIU5BiSOjFoM">fmap</code> (also known simply as <code class="_34q3PgLsx9zIU5BiSOjFoM">map</code>). Given some function <code class="_34q3PgLsx9zIU5BiSOjFoM">f:: a -&gt; b</code> it will give you a function <code class="_34q3PgLsx9zIU5BiSOjFoM">fmap f:: [a] -&gt; [b]</code>, namely the function that applies <code class="_34q3PgLsx9zIU5BiSOjFoM">f</code> to every element of a list of values of type <code class="_34q3PgLsx9zIU5BiSOjFoM">a</code>. You can see that <code class="_34q3PgLsx9zIU5BiSOjFoM">fmap id</code> is indeed the identity: doing nothing to every element of a list is the same as doing nothing to the list. The other law, <code class="_34q3PgLsx9zIU5BiSOjFoM">fmap (f . g) = fmap f . fmap g</code>, is also easy to see: doing <code class="_34q3PgLsx9zIU5BiSOjFoM">g</code> and then <code class="_34q3PgLsx9zIU5BiSOjFoM">f</code> to every element of a list, is the same as first doing <code class="_34q3PgLsx9zIU5BiSOjFoM">g</code> to every element of a list and then doing <code class="_34q3PgLsx9zIU5BiSOjFoM">f</code> to every element of the resulting list.</p><p class="WFFrvt6_3z5B7MBcYKr8U">Maybe is a Functor</p><p class="_1qeIAgB0cPwnLhDF9XSiJM"><code class="_34q3PgLsx9zIU5BiSOjFoM">Maybe</code> is a type constructor that given some type <code class="_34q3PgLsx9zIU5BiSOjFoM">a</code> will give you a new type <code class="_34q3PgLsx9zIU5BiSOjFoM">Maybe a</code>. The values of this type are <code class="_34q3PgLsx9zIU5BiSOjFoM">Just x</code> for any <code class="_34q3PgLsx9zIU5BiSOjFoM">x</code> of type <code class="_34q3PgLsx9zIU5BiSOjFoM">a</code>, and <code class="_34q3PgLsx9zIU5BiSOjFoM">Nothing</code>. The function mapping part <code class="_34q3PgLsx9zIU5BiSOjFoM">fmap</code> will take some function <code class="_34q3PgLsx9zIU5BiSOjFoM">f:: a -&gt; b</code> and give you a new function <code class="_34q3PgLsx9zIU5BiSOjFoM">fmap f:: Maybe a -&gt; Maybe b</code>. It will take <code class="_34q3PgLsx9zIU5BiSOjFoM">Just x</code> to <code class="_34q3PgLsx9zIU5BiSOjFoM">Just (f x)</code>, and <code class="_34q3PgLsx9zIU5BiSOjFoM">Nothing</code> to <code class="_34q3PgLsx9zIU5BiSOjFoM">Nothing</code>. Can you prove the laws?</p><p class="_7T4UafM1PdBGycd5na9nF">What's the category of endofunctors?</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Ok, now things are going to get a bit more tricky. First we need to talk about natural transformations, which are basically arrows between functors. Then we'll use this to build a category of endofunctors, and finally we'll look at examples in Haskell.</p><p class="_1WODZhR-x-fbMu3MOL9cH1">What are natural transformations?</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">It turns out that if you have categories <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code> and functors <code class="_34q3PgLsx9zIU5BiSOjFoM">F, G: C -&gt; D</code> between them, you can sometimes find so called '<a href="https://en.wikipedia.org/wiki/Natural_transformation" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank">natural transformations</a>' between the functors <code class="_34q3PgLsx9zIU5BiSOjFoM">F</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">G</code>. A natural transformation <code class="_34q3PgLsx9zIU5BiSOjFoM">t: F =&gt; G</code> is a family of arrows in <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code> that satisfies two requirements:</p><ul class="_33MEMislY0GAlB78wL1_CR"><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">The arrows <code class="_34q3PgLsx9zIU5BiSOjFoM">t</code> go from the results of <code class="_34q3PgLsx9zIU5BiSOjFoM">F</code> to the results of <code class="_34q3PgLsx9zIU5BiSOjFoM">G</code>. More precisly, for every object <code class="_34q3PgLsx9zIU5BiSOjFoM">A</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> we have an arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">t_A: F(A) -&gt; G(A)</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code>. This is the 'component' of <code class="_34q3PgLsx9zIU5BiSOjFoM">t</code> at <code class="_34q3PgLsx9zIU5BiSOjFoM">A</code>.</p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">For every arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">f</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code>, applying <code class="_34q3PgLsx9zIU5BiSOjFoM">F(f)</code> first and then <code class="_34q3PgLsx9zIU5BiSOjFoM">t</code> is the same as applying <code class="_34q3PgLsx9zIU5BiSOjFoM">t</code> first and then <code class="_34q3PgLsx9zIU5BiSOjFoM">G(f)</code>. This is the 'natural' part of a 'natural transformation'. More precisely, for every <code class="_34q3PgLsx9zIU5BiSOjFoM">f: X -&gt; Y</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> we have <code class="_34q3PgLsx9zIU5BiSOjFoM">t_Y . F(f) = G(f) . t_X</code>. Graphically, it means that going around <a href="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f2/Natural_transformation.svg/1267px-Natural_transformation.svg.png" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank">this diagram</a> in either direction does the same thing ('the diagram commutes').</p></li></ul><p class="_1qeIAgB0cPwnLhDF9XSiJM">Of course there's a special case where <code class="_34q3PgLsx9zIU5BiSOjFoM">F</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">G</code> are endofunctors (so <code class="_34q3PgLsx9zIU5BiSOjFoM">C = D</code>). There's also nothing stopping us from setting <code class="_34q3PgLsx9zIU5BiSOjFoM">F = G</code>, so then we're looking for natural transformations from a functor to itself. Just as with endofunctors these natural transformations may still <em class="_7s4syPYtk5hfUIjySXcRE">do something</em>.</p><p class="_1WODZhR-x-fbMu3MOL9cH1">The category of endofunctors</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Now, for some category <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> we have a bunch of endofunctors on <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> and we have natural transformations between these endofunctors. We can make this into a category! So let's introduce <code class="_34q3PgLsx9zIU5BiSOjFoM">Endo(C)</code>, the category whose objects are endofunctors on <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code>, and whose arrows are natural transformations between these endofunctors. You can check that composition of natural transformations is indeed associative, and that there is an identity natural transformation from every endofunctor to itself. But that's not super relevant here.</p><p class="_1WODZhR-x-fbMu3MOL9cH1">The category of endofunctors in Haskell</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Lost? Let's think about what this would look like in the world of Haskell: what does <code class="_34q3PgLsx9zIU5BiSOjFoM">Endo(Hask)</code> look like? Well, its objects are endofunctors on <code class="_34q3PgLsx9zIU5BiSOjFoM">Hask</code>, which are simply <code class="_34q3PgLsx9zIU5BiSOjFoM">Functor</code>s. Its arrows are 'transformations' from one <code class="_34q3PgLsx9zIU5BiSOjFoM">Functor</code> to another. So if <code class="_34q3PgLsx9zIU5BiSOjFoM">f</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">g</code> are functors, then we're looking for some set of functions <code class="_34q3PgLsx9zIU5BiSOjFoM">t</code>, such that for every type <code class="_34q3PgLsx9zIU5BiSOjFoM">a</code> we have a function <code class="_34q3PgLsx9zIU5BiSOjFoM">t:: f a -&gt; g a</code>.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Let's pick <code class="_34q3PgLsx9zIU5BiSOjFoM">f = Maybe</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">g = []</code>. So we're looking for a set of functions <code class="_34q3PgLsx9zIU5BiSOjFoM">t:: Maybe a -&gt; [a]</code>. Well here's one example:</p><pre class="_3GnarIQX9tD_qsgXkfSDz1"><code class="_34q3PgLsx9zIU5BiSOjFoM">maybeToList            :: Maybe a -&gt; [a]
maybeToList  Nothing   = []
maybeToList  (Just x)  = [x]
</code></pre><p class="_1qeIAgB0cPwnLhDF9XSiJM">Ok, so <code class="_34q3PgLsx9zIU5BiSOjFoM">maybeToList</code> is a transformation from the endofunctor <code class="_34q3PgLsx9zIU5BiSOjFoM">Maybe</code> to the endofunctor <code class="_34q3PgLsx9zIU5BiSOjFoM">[]</code>. But is it natural? Well, let's take some arbitrary function <code class="_34q3PgLsx9zIU5BiSOjFoM">f: a-&gt; b</code>. If <code class="_34q3PgLsx9zIU5BiSOjFoM">maybeToList</code> is natural, it must satisfy <code class="_34q3PgLsx9zIU5BiSOjFoM">maybeToList . fmap f = map f . maybeToList</code> (note that I've filled in <code class="_34q3PgLsx9zIU5BiSOjFoM">map</code> for the list's <code class="_34q3PgLsx9zIU5BiSOjFoM">fmap</code> to avoid confusion). Well this is pretty easy to check:</p><pre class="_3GnarIQX9tD_qsgXkfSDz1"><code class="_34q3PgLsx9zIU5BiSOjFoM">(maybeToList . fmap f) Just x = maybeToList (Just (f x)) = [f x]
(map f . maybeToList ) Just x = map f [x]                = [f x]

(maybeToList . fmap f) Nothing = maybeToList Nothing = []
(map f . maybeToList ) Nothing = map f []            = []
</code></pre><p class="_1qeIAgB0cPwnLhDF9XSiJM">So yes, they're the same! So <code class="_34q3PgLsx9zIU5BiSOjFoM">maybeToList</code> is a natural transformation from the endofunctor <code class="_34q3PgLsx9zIU5BiSOjFoM">Maybe</code> to the endofunctor <code class="_34q3PgLsx9zIU5BiSOjFoM">[]</code>.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Another interesting natural transformation is <code class="_34q3PgLsx9zIU5BiSOjFoM">concat:: [[a]] -&gt; [a]</code>. It is a natural transformation from <code class="_34q3PgLsx9zIU5BiSOjFoM">[[]]</code> (i.e. applying the endofunctor <code class="_34q3PgLsx9zIU5BiSOjFoM">[]</code> twice), to <code class="_34q3PgLsx9zIU5BiSOjFoM">[]</code>. The naturality condition is <code class="_34q3PgLsx9zIU5BiSOjFoM">concat . map (map f) = map f . concat</code>.</p><p class="_7T4UafM1PdBGycd5na9nF">What's a monoid?</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Ok, this one is gonna be tricky again. There's a few different layers to this:</p><ul class="_33MEMislY0GAlB78wL1_CR"><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">First we'll look at the classical concept of a monoid in set theory. We'll also look at an example of such a monoid in Haskell.</p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Then we'll try to generalize the concept of monoids from set theory to category theory. We'll realize that we're missing a category-theoretic ingredient. Confusingly, this ingredient is called a 'monoidal category'.</p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Armed with monoidal categories, we can understand a monoid in a category.</p></li></ul><p class="_1WODZhR-x-fbMu3MOL9cH1">Monoids in set theory</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">In classical set theory, a <a href="https://en.wikipedia.org/wiki/Monoid" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank">monoid</a> is a set <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> with some binary operation <code class="_34q3PgLsx9zIU5BiSOjFoM">•: M × M -&gt; M</code> satisfying the following properties:</p><ul class="_33MEMislY0GAlB78wL1_CR"><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Associativity: for all <code class="_34q3PgLsx9zIU5BiSOjFoM">a, b, c</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>, we have <code class="_34q3PgLsx9zIU5BiSOjFoM">(a • b) • c = a • (b • c)</code>. Informally: "it doesn't matter where you put the brackets."</p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Identity element: there is some <code class="_34q3PgLsx9zIU5BiSOjFoM">e</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> such that for every <code class="_34q3PgLsx9zIU5BiSOjFoM">a</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> we have <code class="_34q3PgLsx9zIU5BiSOjFoM">e • a = a • e = a</code>.</p></li></ul><p class="_1qeIAgB0cPwnLhDF9XSiJM">An example of a monoid is the set of all finite strings over some alphabet with string concatenation as the monoid operation. It's easy to check that associativity holds and that the empty string acts as an identity element.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">This also gives us our example in Haskell: for every type <code class="_34q3PgLsx9zIU5BiSOjFoM">a</code> the type <code class="_34q3PgLsx9zIU5BiSOjFoM">[a]</code> is a monoid with <code class="_34q3PgLsx9zIU5BiSOjFoM">++</code> (concatenation) as the monoid operation and the empty list as identity element. (Small note: technically the type <code class="_34q3PgLsx9zIU5BiSOjFoM">[a]</code> also includes infinite lists, for which concatenation isn't well defined. Because of this, lists in Haskell technically aren't monoids, nor are they monads. We will ignore this technicality in what follows.)</p><p class="_1WODZhR-x-fbMu3MOL9cH1">Monoids in category theory</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Category theorists are alergic to sets. If they see a definition of a mathematical object that includes the word 'set', they'll immediately start thinking about how they can rewrite this definition without using the word 'set'. Or, more respectfully, they'll try to generalize the definition such that it holds in categories other than <code class="_34q3PgLsx9zIU5BiSOjFoM">Set</code> too.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">It's obvious how to begin: the set <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> should be replaced by an arbitrary object <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> in some category <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code>. The binary operation <code class="_34q3PgLsx9zIU5BiSOjFoM">•</code> should be replaced by some arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">μ</code> in the category. Similarly, since we can't 'crack open' an object in a category (we'd have to say what it is, and category theorists hate that), we have to replace the identity element with some arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">η</code> going into <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">The arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">μ</code> should clearly end at <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>, but where should it start? We need some way to construct a 'product object', similar to the cartesian product for sets. Turns out there's a few different ways you can do that, but the one that's useful for monoids is the concept of a 'tensor product' in a 'monoidal category'.</p><p class="_1WODZhR-x-fbMu3MOL9cH1">Monoidal categories</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">The aim here is to define some operation <code class="_34q3PgLsx9zIU5BiSOjFoM">⊗</code> that will allow us to combine two objects <code class="_34q3PgLsx9zIU5BiSOjFoM">A, B</code> in some category <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> into a new object <code class="_34q3PgLsx9zIU5BiSOjFoM">A ⊗ B</code> in that same category. The natural way to map objects in categories is through functors. But in this case we would have to map two objects into one object. We need a functor that can take two arguments.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">The typical way of solving this is by instead introducing a product space that encodes both arguments as one. So we need to have an object <code class="_34q3PgLsx9zIU5BiSOjFoM">(A, B)</code> in some product category <code class="_34q3PgLsx9zIU5BiSOjFoM">C × C</code>. At this point you may think I'm going crazy: in order to define monoids in categories we need to define products of objects, but to do that we need to define monoidal categories, but in order to that we need to define products of whole categories?!</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">That's right. Luckily, it's really quite simple. For categories <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code> the product category <code class="_34q3PgLsx9zIU5BiSOjFoM">C × D</code> is simply the category whose objects are pairs <code class="_34q3PgLsx9zIU5BiSOjFoM">(A, B)</code> of objects <code class="_34q3PgLsx9zIU5BiSOjFoM">A</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">B</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code>, and whose arrows are pairs <code class="_34q3PgLsx9zIU5BiSOjFoM">f, g: (A, B) -&gt; (X, Y)</code> of arrows <code class="_34q3PgLsx9zIU5BiSOjFoM">f: A -&gt; X</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">g: B -&gt; Y</code> in <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">D</code>, respectively. Composition works straight-forwardly: <code class="_34q3PgLsx9zIU5BiSOjFoM">(f, g) . (k, l) = (f . k, g . l)</code>, with associativity easy to check. For any object <code class="_34q3PgLsx9zIU5BiSOjFoM">(A, B)</code> the identity arrow is simply given by <code class="_34q3PgLsx9zIU5BiSOjFoM">(id_A, id_B)</code>.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Ok, so now that we defined product categories, the machinery of functors is available to us again, and we can start thinking about a functor <code class="_34q3PgLsx9zIU5BiSOjFoM">⊗: C × C -&gt; C</code> that combines objects (and arrows). What properties would we want this functor to posses? Well, we would certainly want it to be associative in some way: we want <code class="_34q3PgLsx9zIU5BiSOjFoM">A ⊗ (B ⊗ C)</code> to be 'similar' to <code class="_34q3PgLsx9zIU5BiSOjFoM">(A ⊗ B) ⊗ C</code>. This can be made precise by saying that there is a natural transformation whose components are isomorphisms <code class="_34q3PgLsx9zIU5BiSOjFoM">α: A ⊗ (B ⊗ C) -&gt; (A ⊗ B) ⊗ C</code>. Similarly, we'd like there to be some identity element for <code class="_34q3PgLsx9zIU5BiSOjFoM">⊗</code>, let's call it <code class="_34q3PgLsx9zIU5BiSOjFoM">I</code>: we want <code class="_34q3PgLsx9zIU5BiSOjFoM">I ⊗ A</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">A ⊗ I</code> to be 'similar' to <code class="_34q3PgLsx9zIU5BiSOjFoM">A</code>. This can again be made precise by saying that there are natural transformations whose components are isomorphisms <code class="_34q3PgLsx9zIU5BiSOjFoM">λ: I ⊗ A -&gt; A</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">ρ: A ⊗ I -&gt; A</code>. There's some additional conditions about these natural transformations playing nice with each other (the 'coherence conditions'), but we'll skip over that here.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">If you compare this section to the one about monoids in set theory, you can probably spot some similarities. Instead of elements of a set, we have objects in a category; instead of a binary operation <code class="_34q3PgLsx9zIU5BiSOjFoM">•</code> we have the functor <code class="_34q3PgLsx9zIU5BiSOjFoM">⊗</code>; instead of an identity element we have a unit object; and instead of equations involving elements of a set, we have natural transformations between functors built using <code class="_34q3PgLsx9zIU5BiSOjFoM">⊗</code>. This correspondence is why the term 'monoid' is reused, and why this concept is called a <a href="https://en.wikipedia.org/wiki/Monoidal_category" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank">monoidal category</a>.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">If we want to make the monoidal structure of a category <code class="_34q3PgLsx9zIU5BiSOjFoM">C</code> explicit, we will refer to it as the monoidal category <code class="_34q3PgLsx9zIU5BiSOjFoM">(C, ⊗, I)</code></p><p class="_1WODZhR-x-fbMu3MOL9cH1">Monoids in a monoidal category</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Above we defined a concept analogous to monoids. However, it's not quite what we're looking for; a monoidal category is a category with some additional properties. What we're looking for is an <em class="_7s4syPYtk5hfUIjySXcRE">object in a category</em> satisfing certain properties. Namely, a [monoid in a monoidal category](<a href="https://en.wikipedia.org/wiki/Monoid_(category_theory)" class="_3t5uN8xUmg0TOwRCOGQEcU" rel="noopener noreferrer nofollow ugc" target="_blank">https://en.wikipedia.org/wiki/Monoid_(category_theory)</a>).</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">We start with the definition of a monoid, and then swap out set-theoretic concepts for category-theoretic ones. This is what we get:</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">A monoid in a monoidal category <code class="_34q3PgLsx9zIU5BiSOjFoM">(C, ⊗, I)</code> is an object <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> with an arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">μ: M ⊗ M -&gt; M</code> ('multiplication') and an arrow <code class="_34q3PgLsx9zIU5BiSOjFoM">η: I -&gt; M</code> ('unit') satisfying the two monoid axioms:</p><ul class="_33MEMislY0GAlB78wL1_CR"><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Associativity: if you have an object <code class="_34q3PgLsx9zIU5BiSOjFoM">M ⊗ (M ⊗ M) ≅ (M ⊗ M) ⊗</code>, it doesn't matter if you first multiply the left side or first multiply the right side. This is made exact with a commutative diagram involving <code class="_34q3PgLsx9zIU5BiSOjFoM">μ</code> and the natural isomorphism <code class="_34q3PgLsx9zIU5BiSOjFoM">α</code> (the associator).</p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Unit is an identity with multiplication: if you have an object <code class="_34q3PgLsx9zIU5BiSOjFoM">I ⊗ M ≅ M</code>, then 'forgetting' the <code class="_34q3PgLsx9zIU5BiSOjFoM">I</code> using the left unitor <code class="_34q3PgLsx9zIU5BiSOjFoM">λ</code> is the same as first mapping to <code class="_34q3PgLsx9zIU5BiSOjFoM">M ⊗ M</code> using <code class="_34q3PgLsx9zIU5BiSOjFoM">η</code> and then to <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> using <code class="_34q3PgLsx9zIU5BiSOjFoM">μ</code>. A symmetric equation must hold for <code class="_34q3PgLsx9zIU5BiSOjFoM">M ⊗ I</code> using the right unitor <code class="_34q3PgLsx9zIU5BiSOjFoM">ρ</code>.</p></li></ul><p class="_7T4UafM1PdBGycd5na9nF">So how about a monoid in the category of endofunctors?</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Ok, now that we know what a monoid in a (monoidal) category is, we can start thinking about a monoid in the category of endofunctors.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">As we found out above, we first need to find a monoidal structure in the category of endofunctors. Turns out that's pretty easy: composition of endofunctors satisfies all the properties of a tensor product! The tensor product identity <code class="_34q3PgLsx9zIU5BiSOjFoM">I</code> is simply the identity functor <code class="_34q3PgLsx9zIU5BiSOjFoM">id</code>. It takes a little bit of work to show that the natural transformations behave the right way, but we'll skip over that here.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">So then a monoid in the category of endofunctors is some endofunctor <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>, a natural transformation <code class="_34q3PgLsx9zIU5BiSOjFoM">μ: M . M -&gt; M</code> ('multiplication'), and a natural transformation <code class="_34q3PgLsx9zIU5BiSOjFoM">η: id -&gt; M</code> ('unit'), that satisfy the monoid axioms.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">How can we make sense of this definition? Well, here's one way that will carry over quite nicely to Haskell: we can think of our endofunctors as introducing some additional structure on the objects they're applied to. The action of the endofunctors on arrows is to 'lift' the arrow into the structure. The endofunctor <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> then, is simply some chosen structure. The transformation <code class="_34q3PgLsx9zIU5BiSOjFoM">μ</code> ('multiplication') can be seen as 'flattening' the duplicate structure <code class="_34q3PgLsx9zIU5BiSOjFoM">M . M</code> down to just the structure <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>. The transformation <code class="_34q3PgLsx9zIU5BiSOjFoM">η</code> can be thought of as injecting unstructured data into the structure <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">What about the monoid axioms?</p><p class="_1WODZhR-x-fbMu3MOL9cH1">Associativity</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">If you have a triplicate structure <code class="_34q3PgLsx9zIU5BiSOjFoM">M . M . M</code>, it doesn't matter if you flatten it down to <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> as <code class="_34q3PgLsx9zIU5BiSOjFoM">(M . M) . M -&gt; M . M -&gt; M</code> or as <code class="_34q3PgLsx9zIU5BiSOjFoM">M . (M . M) -&gt; M . M -&gt; M</code>. This can be symbolically stated as for every <code class="_34q3PgLsx9zIU5BiSOjFoM">X</code>, <code class="_34q3PgLsx9zIU5BiSOjFoM">μ_X . M(μ_X) = μ_X . μ_M(X)</code>. Or intuitively: there's a unique way to flatten layered structure.</p><p class="_1WODZhR-x-fbMu3MOL9cH1">Unit is identity with multiplication</p><ul class="_33MEMislY0GAlB78wL1_CR"><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">If you have strucured data (<code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>), and then use <code class="_34q3PgLsx9zIU5BiSOjFoM">η</code> to inject this into <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code> again, you obtain data in <code class="_34q3PgLsx9zIU5BiSOjFoM">M . M</code>. You can then use <code class="_34q3PgLsx9zIU5BiSOjFoM">μ</code> to flatten this back down to <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>. This is the same as doing nothing. Symbolically, for every <code class="_34q3PgLsx9zIU5BiSOjFoM">X</code>, <code class="_34q3PgLsx9zIU5BiSOjFoM">μ_X . η_M(X) = id_M(X)</code></p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">If you have structured data (<code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>), and then use <code class="_34q3PgLsx9zIU5BiSOjFoM">M(η)</code> give structure to the 'contents' of your structure, you again obtain data in <code class="_34q3PgLsx9zIU5BiSOjFoM">M . M</code>. You can again use <code class="_34q3PgLsx9zIU5BiSOjFoM">μ</code> to flatten this back down to <code class="_34q3PgLsx9zIU5BiSOjFoM">M</code>. This is, again, the same as doing nothing. Symbolically, for every <code class="_34q3PgLsx9zIU5BiSOjFoM">X</code>, <code class="_34q3PgLsx9zIU5BiSOjFoM">μ_X . M(η_X) = id_M(X)</code>.</p></li></ul><p class="_1qeIAgB0cPwnLhDF9XSiJM">Intuitively: injecting structure and flattening it cancel each other out.</p><p class="_1WODZhR-x-fbMu3MOL9cH1">A monoid in Endo(Hask)</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Let's move to the world of Haskell again. As before, we look at <code class="_34q3PgLsx9zIU5BiSOjFoM">Endo(Hask)</code>, with its familiar endofunctors of <code class="_34q3PgLsx9zIU5BiSOjFoM">[]</code> and <code class="_34q3PgLsx9zIU5BiSOjFoM">Maybe</code> and others. Let's choose <code class="_34q3PgLsx9zIU5BiSOjFoM">M = []</code>. What should we pick for <code class="_34q3PgLsx9zIU5BiSOjFoM">μ</code>? It should be a natural transformation <code class="_34q3PgLsx9zIU5BiSOjFoM">μ:: [[a]] -&gt; [a]</code>. We've seen one before: <code class="_34q3PgLsx9zIU5BiSOjFoM">concat</code> (also known as <code class="_34q3PgLsx9zIU5BiSOjFoM">join</code>)! How about <code class="_34q3PgLsx9zIU5BiSOjFoM">η</code>? It should be a natural transformation <code class="_34q3PgLsx9zIU5BiSOjFoM">η:: id(a) -&gt; [a]</code>, which is simply <code class="_34q3PgLsx9zIU5BiSOjFoM">η:: a -&gt; [a]</code>. Well it's pretty simple to come up with one:</p><pre class="_3GnarIQX9tD_qsgXkfSDz1"><code class="_34q3PgLsx9zIU5BiSOjFoM">inject   :: a -&gt; [a]
inject x = [x]
</code></pre><p class="_1qeIAgB0cPwnLhDF9XSiJM">This function is also known as <code class="_34q3PgLsx9zIU5BiSOjFoM">pure</code> or <code class="_34q3PgLsx9zIU5BiSOjFoM">return</code> in Haskell.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">What about the monoid axioms?</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">Well, for associativity we have to check that if we have some 3d list, that flattening the outer dimensions first will give the same result as flattening the inner dimensions. So: <code class="_34q3PgLsx9zIU5BiSOjFoM">concat . concat = concat . (map concat)</code>. It shouldn't be too hard to convince yourself that this is true.</p><p class="_1qeIAgB0cPwnLhDF9XSiJM">But does our choice of unit play nice with the multiplication? We need to check:</p><ul class="_33MEMislY0GAlB78wL1_CR"><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Injecting a list into a list and then concatenating is the same as doing nothing to that list: <code class="_34q3PgLsx9zIU5BiSOjFoM">concat . inject = id :: [a] -&gt; [a]</code>. That sounds pretty reasonable.</p></li><li class="_3gqTEjt4x9UIIpWiro7YXz"><p class="_1qeIAgB0cPwnLhDF9XSiJM">Injecting every element of a list into a list and then concatenating is the same as doing nothing to that list: <code class="_34q3PgLsx9zIU5BiSOjFoM">concat . map inject = id :: [a] -&gt; [a]</code>. Again, that seems clear.</p></li></ul><p class="_1qeIAgB0cPwnLhDF9XSiJM">So <code class="_34q3PgLsx9zIU5BiSOjFoM">[]</code> is a monoid in the <code class="_34q3PgLsx9zIU5BiSOjFoM">Endo(Hask)</code>. Or equivalently, <code class="_34q3PgLsx9zIU5BiSOjFoM">[]</code> is a monad in <code class="_34q3PgLsx9zIU5BiSOjFoM">Hask</code>. Hooray!</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>