<!DOCTYPE html>
<html lang="en">
<head>
    <title>
EA and Visual Studio&#x2019;s Linux Support | C&#x2B;&#x2B; Team Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="EA and Visual Studio&#x2019;s Linux Support | C&#x2B;&#x2B; Team Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Erika SweetFollow Erika"/>
    <meta property="og:description" content="EA is using Visual Studio&#x2019;s cross-platform support to cross-compile on Windows and debug on Linux. The following post is written by Ben May, a Senior Software Engineer of Engineering Workflows at EA. Thanks Ben and EA for your partnership, and for helping us make Visual Studio the best IDE for C&#x2B;&#x2B; cross-platform development."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/cppblog/ea-and-visual-studios-linux-support/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - EA and Visual Studio&#x2019;s Linux Support | C&#x2B;&#x2B; Team Blog</title>
<div class="readable">
        <h1>EA and Visual Studio&#x2019;s Linux Support | C&#x2B;&#x2B; Team Blog</h1>
            <div>by Erika SweetFollow Erika</div>
            <div>Reading time: 9-12 minutes</div>
        <div>Posted here: 25 Feb 2020</div>
        <p><a href="https://devblogs.microsoft.com/cppblog/ea-and-visual-studios-linux-support/">https://devblogs.microsoft.com/cppblog/ea-and-visual-studios-linux-support/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/04/IMG_1597-1-150x150.jpg" width="58" height="58" alt="Erika Sweet"></p><p>Erika</p></div></div></div><p>November 7th, 2019</p><p>EA is using Visual Studio’s cross-platform support to cross-compile on Windows and debug on Linux. The following post is written by Ben May, a Senior Software Engineer of Engineering Workflows at EA. Thanks Ben and EA for your partnership, and for helping us make Visual Studio the best IDE for C++ cross-platform development.</p><p><em>At EA our Frostbite Engine has a Linux component used for our dedicated servers that service many of our most popular games.&nbsp; When we saw that Microsoft was adding support for Linux in a workload in Visual Studio, this caught my interest!&nbsp; At EA our game developers are used to a Windows environment for development so we thought that forcing them to develop in a Linux environment directly would be a difficult ask, so we decided to use clang and cross-compile from Windows and target Linux.&nbsp; Initially we had wired this up ourselves using Visual Studio Makefile Projects which called make to build our source, and then used a variety of tools to copy binaries over ssh to Linux machines, then wrote tooling to startup gdbserver on the remote Linux machine to be able to debug from PC.&nbsp; After the release of the Visual Studio Linux Workload, we found that Microsoft had basically wrapped up all of the tools/processes up nicely into a Visual Studio Workload we could ask our Developers to install and be able to debug directly in Visual Studio!&nbsp; So far the integration with WSL and remote debugging the workload provides has been a success and has drastically cleaned up our tools/processes surrounding Linux debugging/development.&nbsp; Our developers have been really happy with the improved experience.</em></p><p><em>I will now explain in more detail what we actually do.</em></p><h4>Internal build setup</h4><p><em>Our internal build setup uses our own proprietary tool to take our own cross platform build format and generate many types of outputs (vcxproj/csproj/make etc.) When we decided to add Linux to our list of supported platforms, we decided that we would set up our primary workflow for our developers to be initiated from a Windows based PC with Visual Studio, since this is the environment that we use for almost all of our other platforms.&nbsp; Another requirement was for our CI (Continuous Integration/Build Farm) to be able to validate that our code compiled on Linux without needing to setup Linux host based CI VMs or needing a remote Linux system to compile the code, since that would be much more expensive and complicated to manage and support.&nbsp; These requirements basically led us to deciding to cross-compile our codebase on Windows directly using clang on PC.</em></p><p><em>For our cross-compiler we use something called a “Canadian cross” compiler setup.&nbsp; See <a href="https://crosstool-ng.github.io/docs/toolchain-types/" target="_blank">toolchain types </a></em><em>for more details on the types of cross-compile you can do, and a Wikipedia link for why its called “Canadian cross”.&nbsp; The primary reason for it being a “Canadian cross” is that we have built the LLVM and GCC toolchains on a Linux machine and moved their pieces to be used on a Windows machine combined with Windows clang.&nbsp; Based on that our cross-compiler setup on Windows has the following in it:</em></p><ol><li><em>We use <a href="http://llvm.org/" target="_blank">LLVM</a></em></li><li><em>We combine the Windows version of LLVM with the Linux one on the Windows machine.&nbsp; This is to get all of the libs/headers required for targeting Linux.</em></li><li><em>We also use the GCC toolchain with LLVM.&nbsp; In order to build the gcc tools for Windows we use <a href="http://crosstool-ng.github.io/" target="_blank">crosstool-NG</a> on a Linux host to build it.</em></li><li><em>Then when building you need to pass -target x86_64-pc-linux-gnu and -sysroot=&lt;path to gcc cross tools&gt;</em></li><li><em>You may need to initially use -Wno-nonportable-include-path warning suppression since Windows is not case-sensitive, and fixing all of the include path errors might be a bit of a lengthy task (although I recommend doing it!)</em></li></ol><p><em>After we have assembled our toolchain, we then use our proprietary generator to generate makefiles that build our code for us but referencing the above cross-compiler setup, and then a set of vcxproj files which are of type “Linux Makefile” and .sln file.&nbsp; It is at this point where we move into Visual Studio for integration of our workflows into the IDE using the Visual Studio Linux Workload.</em></p><h4>Visual Studio integration</h4><p><em>Developers need to ensure they have the ‘<a href="https://docs.microsoft.com/en-us/cpp/linux/download-install-and-setup-the-linux-development-workload?view=vs-2019" target="_blank">Linux development with C++</a>’ </em><em>Workload installed:</em></p><p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea1.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea1.png" alt="The Linux development with C++ workload in the Visual Studio installer." width="1290" height="720" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea1.png 1290w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea1-300x167.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea1-768x429.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea1-1024x572.png 1024w" sizes="(max-width: 1290px) 100vw, 1290px"> </a></p><p><em>After ensuring the correct components are installed, we use the built in features of the Linux Makefile projects for working.&nbsp; To build code we simply select Build from within Visual Studio, this executes our cross-compiler and outputs binaries.&nbsp; Built into the Visual Studio Linux Projects is the ability to deploy and debug on a Linux host.&nbsp; </em></p><h4>Debugging on WSL</h4><p><em>We can configure our generator to use 2 different deployment/debugging setups:</em></p><ol><li><em>WSL (<a href="https://docs.microsoft.com/en-us/windows/wsl/about" target="_blank">Windows Subsystem For Linux</a>)</em></li><li><em>Remote Linux Host</em></li></ol><p><em>The most convenient setup is WSL assuming you do not have to render anything to screen.&nbsp; In other words, if it’s only headless unit tests or console applications you need to develop this is the easiest and fastest way to iterate.</em></p><p><em>If the developer is using WSL, then the binaries do not actually need to be deployed since WSL can access the binaries directly from the current Windows machine, this saves time since they no longer need to be copied/deployed to a remote machine (some of our binaries can get quite large so can sometimes add several seconds to an incremental build + debug session)</em></p><p><em>Here is an example of me building <a href="https://github.com/electronicarts/EASTL" target="_blank">EASTL</a>, an open-source library of EAs,</em><em>&nbsp;using Visual Studio Linux Makefile Projects and our cross-compiler:</em></p><p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea2.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea2.png" alt="Debugging EASTL using Visual Studio Linux Makefile Projects." width="1246" height="885" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea2.png 1246w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea2-300x213.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea2-768x545.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea2-1024x727.png 1024w" sizes="(max-width: 1246px) 100vw, 1246px"> </a></p><p><em>You can see I’ve placed a breakpoint there, and I configured my environment to use WSL when running, so when I debug it will launch the test binary in WSL and connect the debugger using Visual Studio’s gdb debugger without needing to first copy the binary.&nbsp; This achieved by setting the <a href="https://docs.microsoft.com/en-us/cpp/linux/prop-pages/general-linux?view=vs-2019" target="_blank">Remote Build Root, Project and Deploy directories</a></em><em>&nbsp;with the path being the WSL path to the same folder on my Windows machine.</em></p><p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea3.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea3.png" alt="The &quot;General&quot; configuration properties for a Linux Makefile Project, where &quot;Remote Build Root Directory&quot; is a mounted WSL path." width="851" height="597" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea3.png 851w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea3-300x210.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea3-768x539.png 768w" sizes="(max-width: 851px) 100vw, 851px"> </a></p><p><em>Here is a quick example of me debugging and hitting a breakpoint, then continuing to run and finish the unit test:</em></p><p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea4.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea4.png" alt="EA debugging a unit test on the Windows Subsystem for Linux." width="1312" height="885" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea4.png 1312w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea4-300x202.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea4-768x518.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea4-1024x691.png 1024w" sizes="(max-width: 1312px) 100vw, 1312px"> </a></p><h4>Debugging on a remote Linux system</h4><p><em>For a Remote Linux machine setup where we do not use WSL, the only additional thing we need to worry about is the deployment of the built executable and its dependent dynamic libraries or content files.&nbsp; The way we do this is we setup a source file to remote mapping, and have Visual Studio’s post build event do the copying of the file.&nbsp; Inside the properties of the exe’s Project under “<a href="https://docs.microsoft.com/en-us/cpp/linux/prop-pages/makefile-linux?view=vs-2019#remote-post-build-event" target="_blank">Build Events” -&gt; “Post-Build Event” -&gt; “Additional Files To Copy</a>”</em><em>, we specify the list of files needed to be copied to the remote machine after the build completes.&nbsp; This is needed to happen so that when we click “Debug” the binaries are already there on the Remote Machine.</em></p><p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea5.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea5.png" alt="Setting up a remote post-build event with additional files to copy in Visual Studio's Property Pages." width="951" height="605" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea5.png 951w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea5-300x191.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/ea5-768x489.png 768w" sizes="(max-width: 951px) 100vw, 951px"> </a></p><p><em>You can see that the syntax is a mapping of local path to remote path, which is quite handy for mapping files between the 2 file systems.</em></p><h4>Asks for the future</h4><p><em>One downside to this is that the deployment is done during the “Build” phase, what we would ideally like is to have 3 distinct phases when working with Linux:</em></p><ol><li><em>Build</em></li><li><em>Deploy</em></li><li><em>Debug</em></li></ol><p><em>This would be so that you could build the code without needing a connection to a remote machine, this is useful in CI environments, or in environments where someone just wants to locally build and fix compile issues for Linux and submit them and let automated testing validate their fixes.&nbsp; Having Deploy and Debug distinct phases is also nice so that you could deploy from visual studio, but then potentially invoke/debug etc. directly from the Linux Machine. </em></p><p><em>It is also worth noting at this point that we are still using make “under the hood” to execute our builds for Linux, but the Visual Studio Linux Workload also supports a full MSBuild-based Linux Project.&nbsp; We have not spent much time trying that out at this point, but it would be nice if we could use that, in an effort to be using MSBuild to build Linux just like we do for most of our other platforms.</em></p><p><em>We have been working closely with the Visual Studio team on the Linux Component, and have been following the Visual Studio 2019 Preview builds very closely to test and iterate on these workflows with them, our hope is that in future releases we will be able to:</em></p><ol><li><em><a href="https://developercommunity.visualstudio.com/content/idea/810083/make-distinct-phases-for-build-deploy-and-debug-in.html" target="_blank">Fully separate Build from Deployment and Debug for local cross-compilation scenarios</a>.</em></li><li><em>Setup “<a href="https://developercommunity.visualstudio.com/content/idea/810084/setup-incremental-build-deployment-detection-in-th.html" target="_blank">incremental” build + deployment detection in the Linux Makefile Projects</a></em><em> so that we don’t need to respawn make for all projects in our Solutions (some of our large solutions have &gt; 500 projects).&nbsp; This is mainly for a faster incremental iteration times.</em></li><li><em>We have asked for <a href="https://developercommunity.visualstudio.com/content/idea/810085/add-direct-wsl-debugging-support-to-the-visual-stu.html" target="_blank">direct WSL debugging</a></em><em>&nbsp;be added to the Linux Makefile Projects, currently in our setup since the Linux Makefile Projects don’t support WSL directly we still need to debug over an ssh connection to wsl which means we have to have WSL running with sshd on it. This support is already integrated with MSBuild-based Linux Applications and CMake projects, but not yet for Makefile projects.</em></li><li><em>Try the MSBuild-based Linux Project files and work with Microsoft to get those to potentially operate with a local toolchain (our cross-compiler) but still yield the same features for Deployment and Debug.&nbsp; This would also help us solve the Makefile incremental problem mentioned above.</em></li></ol><p><em>All in all this workflow is very slick for us!&nbsp; It allows our developers to use an IDE and Operating System they are comfortable working in, but are still able to build and debug Linux applications!</em></p><p><em>-Ben May, Senior Software Engineer, Engineering Workflows at EA</em></p><p>Thanks again for your partnership, Ben! Our team looks forward to continuing to improve the product based on feedback we receive from the community. If you’re interested in building the same project on both Windows and Linux, check out our native support for CMake. You can check out a similar story written by the <a href="https://mysqlserverteam.com/compiling-mysql-in-visual-studio-on-a-remote-linux-box/" target="_blank">MySQL Server Team at Oracle</a>.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>