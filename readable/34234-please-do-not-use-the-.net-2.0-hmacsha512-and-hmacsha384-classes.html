<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Please do not use the .NET 2.0 HMACSHA512 and HMACSHA384 Classes -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Please do not use the .NET 2.0 HMACSHA512 and HMACSHA384 Classes</h1><div><div id="main" class="content "><ul class="metadata page-metadata" data-bi-name="page info" lang="en-us" dir="ltr"><li class="displayDate loading"><time role="presentation" datetime="2007-01-31T00:00:00.000Z" data-article-date-source="ms.date">01/31/2007</time></li><li class="readingTime">3 minutes to read</li></ul><p>We’ve recently discovered a bug in the HMACSHA512 and HMACSHA384 classes which shipped in the .NET Framework 2.0.&nbsp; This bug will cause&nbsp;these algorithms to produce incorrect results&nbsp;which are not consistent with other implementations of HMAC-SHA-512 and HMAC-SHA-384.&nbsp; Unfortunately, we did not discover this bug until recently, and the shipping .NET Framework 2.0 on all platforms is affected by it.&nbsp; The only two affected algorithms are the HMAC-SHA-512 and HMAC-SHA-384; other HMAC algorithms do produce correct values.</p><p>The next service pack to the .NET Framework will contain a fix for this bug, which will cause the HMACSHA384 and HMACSHA512 classes to produce correct HMAC values.&nbsp; However, this will cause their output to be inconsistent with the output of&nbsp;the unserviced .NET Framework 2.0 classes.&nbsp; In order to allow applications running on serviced framework to interact with applications running on the unserviced version, we will introduce two compatibility switches in the service pack.</p><p>First, both the HMACSHA512 and HMACSHA384 classes will have a new Boolean property, ProduceLegacyHmacValues.&nbsp; By setting this property to true, the object will produce values which match what the unserviced .NET Framework would have produced.&nbsp; You should set this property only once after you’ve created your HMAC object, and you will need to reset your key afterwards:</p><p>&nbsp;&nbsp;&nbsp; public static void Test()</p><p>&nbsp;&nbsp;&nbsp; {</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HMACSHA512 hmac = new HMACSHA512();</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; hmac.ProduceLegacyHmacValues = true;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; hmac.Key = // ... get the hmac key</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ...</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // use the hmac algorithm</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // ...</p><p>&nbsp;&nbsp;&nbsp; }</p><p>In order to help applications where it is expensive or impossible to change the code, we’ve added a new configuration switch for the application’s .exe.config file which will cause all HMAC objects created within the application to use the unserviced calculation.</p><p>&lt;configuration&gt;</p><p>&nbsp;&nbsp;&nbsp; &lt;runtime&gt;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;legacyHMACMode enabled="1" /&gt;</p><p>&nbsp;&nbsp;&nbsp; &lt;/runtime&gt;</p><p>&lt;/configuration&gt;</p><p>Finally, in order to help debug any issues that arise when upgrading to the service pack, the first time an instance of either class is created, we will log a warning message to the event log and to any attached debugger.&nbsp; The message text (which will hopefully help to point search engine results here as well) will be:</p><p>"This application is using the HMAC-SHA-384 or HMAC-SHA-512 keyed hash algorithm. The implementation of these algorithms were updated in service pack 1 of .NET Framework 2.0 and by default do not produce results consistent with the unserviced versions of the classes. For more information about the changes to the algorithms and how to disable this warning message please see the release notes for service pack 1."</p><p>This warning will only be produced the first time an instance of either object is created in a process.&nbsp; If the configuration switch to enable process-wide legacy mode is set, then we will suppress the message.&nbsp; We’ve also provided a second configuration switch which will let you manually suppress the warning message for your application.</p><p>&lt;configuration&gt;</p><p>&nbsp;&nbsp;&nbsp; &lt;runtime&gt;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;legacyHMACWarning enabled="0" /&gt;</p><p>&nbsp;&nbsp;&nbsp; &lt;/runtime&gt;</p><p>&lt;/configuration&gt;</p><p>If you need a replacement class for HMACSHA512 before the next service pack ships, then you can roll your own relatively easily.&nbsp; Some code to do this would look like this:</p><p>internal sealed class MyHmacSha512 : System.Security.Cryptography.HMAC</p><p>{</p><p>&nbsp;&nbsp;&nbsp; public MyHmacSha512(byte[] key)</p><p>&nbsp;&nbsp;&nbsp; {</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (key == null)</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw new ArgumentNullException("key");</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HashName = "SHA512";</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HashSizeValue = 512;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; BlockSizeValue = 128;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Key = key;</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p>Similarly, a substitute class can be derived for HMACSHA384:</p><p>internal sealed class MyHmacSha384 : System.Security.Cryptography.HMAC</p><p>{</p><p>&nbsp;&nbsp;&nbsp; public MyHmacSha384(byte[] key)</p><p>&nbsp;&nbsp;&nbsp; {</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if (key == null)</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; throw new ArgumentNullException("key");</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HashName = "SHA384";</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HashSizeValue = 384;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; BlockSizeValue = 128;</p><p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Key = key;</p><p>&nbsp;&nbsp;&nbsp; }</p><p>}</p><p>This change will start to appear in future CTPs.&nbsp; Again, I personally, and the CLR security team in general, are very sorry for any problems this may have caused in your applications.&nbsp; Please feel free to ask any questions in the comments for this post, and I’ll make sure that they get answered as soon as possible.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>