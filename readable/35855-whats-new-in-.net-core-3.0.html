<!DOCTYPE html>
<html lang="en">
<head>
    <title>
What&#x27;s new in .NET Core 3.0 -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>What's new in .NET Core 3.0</h1><div><div id="main" class="content "><p>This article describes what is new in .NET Core 3.0. One of the biggest enhancements is support for Windows desktop applications (Windows only). By using the .NET Core 3.0 SDK component Windows Desktop, you can port your Windows Forms and Windows Presentation Foundation (WPF) applications. To be clear, the Windows Desktop component is only supported and included on Windows. For more information, see the <a href="#windows-desktop" data-linktype="self-bookmark">Windows desktop</a> section later in this article.</p><p>.NET Core 3.0 adds support for C# 8.0. It's highly recommended that you use <a href="https://visualstudio.microsoft.com/vs/?utm_medium=microsoft&amp;utm_source=docs.microsoft.com&amp;utm_campaign=inline+link&amp;utm_content=download+vs2019" data-linktype="external">Visual Studio 2019 version 16.3</a> or newer, <a href="/en-us/visualstudio/mac/install-preview" data-linktype="absolute-path">Visual Studio for Mac 8.3</a> or newer, or <a href="https://code.visualstudio.com/" data-linktype="external">Visual Studio Code</a> with the latest <strong>C# extension</strong>.</p><p><a href="https://aka.ms/netcore3download" data-linktype="external">Download and get started with .NET Core 3.0</a> right now on Windows, macOS, or Linux.</p><p>For more information about the release, see the <a href="https://devblogs.microsoft.com/dotnet/announcing-net-core-3-0/" data-linktype="external">.NET Core 3.0 announcement</a>.</p><p>.NET Core RC1 was considered production ready by Microsoft and was fully supported. If you're using a preview release, you must move to the RTM version for continued support.</p><h2 id="language-improvements-c-80">Language improvements C# 8.0</h2><p>C# 8.0 is also part of this release, which includes the <a href="../../csharp/tutorials/nullable-reference-types" data-linktype="relative-path">nullable reference types</a> feature, <a href="../../csharp/tutorials/generate-consume-asynchronous-stream" data-linktype="relative-path">async streams</a>, and <a href="../../csharp/tutorials/pattern-matching" data-linktype="relative-path">more patterns</a>. For more information about C# 8.0 features, see <a href="../../csharp/whats-new/csharp-8" data-linktype="relative-path">What's new in C# 8.0</a>.</p><p>Language enhancements were added to support the following API features detailed below:</p><h2 id="net-standard-21">.NET Standard 2.1</h2><p>.NET Core 3.0 implements <strong>.NET Standard 2.1</strong>. However, the default <code>dotnet new classlib</code> template generates a project that still targets <strong>.NET Standard 2.0</strong>. To target <strong>.NET Standard 2.1</strong>, edit your project file and change the <code>TargetFramework</code> property to <code>netstandard2.1</code>:</p><pre><code class="lang-xml">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre><p>If you're using Visual Studio, you need <a href="https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&amp;utm_source=docs.microsoft.com&amp;utm_campaign=inline+link&amp;utm_content=download+vs2019" data-linktype="external">Visual Studio 2019</a>, as Visual Studio 2017 doesn't support <strong>.NET Standard 2.1</strong> or <strong>.NET Core 3.0</strong>.</p><h2 id="compiledeploy">Compile/Deploy</h2><h3 id="default-executables">Default executables</h3><p>.NET Core now builds <a href="../deploying/#framework-dependent-executables-fde" data-linktype="relative-path">framework-dependent executables</a> by default. This behavior is new for applications that use a globally installed version of .NET Core. Previously, only <a href="../deploying/#self-contained-deployments-scd" data-linktype="relative-path">self-contained deployments</a> would produce an executable.</p><p>During <code>dotnet build</code> or <code>dotnet publish</code>, an executable is created that matches the environment and platform of the SDK you're using. You can expect the same things with these executables as you would other native executables, such as:</p><ul><li>You can double-click on the executable.</li><li>You can launch the application from a command prompt directly, such as <code>myapp.exe</code> on Windows, and <code>./myapp</code> on Linux and macOS.</li></ul><h3 id="single-file-executables">Single-file executables</h3><p>The <code>dotnet publish</code> command supports packaging your app into a platform-specific single-file executable. The executable is self-extracting and contains all dependencies (including native) that are required to run your app. When the app is first run, the application is extracted to a directory based on the app name and build identifier. Startup is faster when the application is run again. The application doesn't need to extract itself a second time unless a new version was used.</p><p>To publish a single-file executable, set the <code>PublishSingleFile</code> in your project or on the command line with the <code>dotnet publish</code> command:</p><pre><code class="lang-xml">&lt;PropertyGroup&gt;
  &lt;RuntimeIdentifier&gt;win10-x64&lt;/RuntimeIdentifier&gt;
  &lt;PublishSingleFile&gt;true&lt;/PublishSingleFile&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>-or-</p><pre><code class="lang-dotnetcli">dotnet publish -r win10-x64 -p:PublishSingleFile=true
</code></pre><p>For more information about single-file publishing, see the <a href="https://github.com/dotnet/designs/blob/master/accepted/single-file/design.md" data-linktype="external">single-file bundler design document</a>.</p><h3 id="assembly-linking">Assembly linking</h3><p>The .NET core 3.0 SDK comes with a tool that can reduce the size of apps by analyzing IL and trimming unused assemblies.</p><p>Self-contained apps include everything needed to run your code, without requiring .NET to be installed on the host computer. However, many times the app only requires a small subset of the framework to function, and other unused libraries could be removed.</p><p>.NET Core now includes a setting that will use the <a href="https://github.com/mono/linker" data-linktype="external">IL linker</a> tool to scan the IL of your app. This tool detects what code is required, and then trims unused libraries. This tool can significantly reduce the deployment size of some apps.</p><p>To enable this tool, add the <code>&lt;PublishTrimmed&gt;</code> setting in your project and publish a self-contained app:</p><pre><code class="lang-xml">&lt;PropertyGroup&gt;
  &lt;PublishTrimmed&gt;true&lt;/PublishTrimmed&gt;
&lt;/PropertyGroup&gt;
</code></pre><pre><code class="lang-dotnetcli">dotnet publish -r &lt;rid&gt; -c Release
</code></pre><p>As an example, the basic "hello world" new console project template that is included, when published, hits about 70 MB in size. By using <code>&lt;PublishTrimmed&gt;</code>, that size is reduced to about 30 MB.</p><p>It's important to consider that applications or frameworks (including ASP.NET Core and WPF) that use reflection or related dynamic features, will often break when trimmed. This breakage occurs because the linker doesn't know about this dynamic behavior and can't determine which framework types are required for reflection. The IL Linker tool can be configured to be aware of this scenario.</p><p>Above all else, be sure to test your app after trimming.</p><p>For more information about the IL Linker tool, see the <a href="https://aka.ms/dotnet-illink" data-linktype="external">documentation</a> or visit the <a href="https://github.com/mono/linker" data-linktype="external">mono/linker</a> repo.</p><h3 id="tiered-compilation">Tiered compilation</h3><p><a href="https://github.com/dotnet/runtime/blob/master/docs/design/features/tiered-compilation-guide.md" data-linktype="external">Tiered compilation</a> (TC) is on by default with .NET Core 3.0. This feature enables the runtime to more adaptively use the just-in-time (JIT) compiler to achieve better performance.</p><p>The main benefit of tiered compilation is to provide two ways of jitting methods: in a lower-quality-but-faster tier or a higher-quality-but-slower tier. The quality refers to how well the method is optimized. TC helps to improve the performance of an application as it goes through various stages of execution, from startup through steady state. When tiered compilation is disabled, every method is compiled in a single way that's biased to steady-state performance over startup performance.</p><p>When TC is enabled, the following behavior applies for method compilation when an app starts up:</p><ul><li>If the method has ahead-of-time-compiled code, or <a href="#readytorun-images" data-linktype="self-bookmark">ReadyToRun</a>, the pregenerated code is used.</li><li>Otherwise, the method is jitted. Typically, these methods are generics over value types.
<ul><li><em>Quick JIT</em> produces lower-quality (or less optimized) code more quickly. In .NET Core 3.0, Quick JIT is enabled by default for methods that don't contain loops and is preferred during startup.</li><li>The fully optimizing JIT produces higher-quality (or more optimized) code more slowly. For methods where Quick JIT would not be used (for example, if the method is attributed with <a href="/en-us/dotnet/api/system.runtime.compilerservices.methodimploptions#System_Runtime_CompilerServices_MethodImplOptions_AggressiveOptimization" data-linktype="absolute-path">MethodImplOptions.AggressiveOptimization</a>), the fully optimizing JIT is used.</li></ul></li></ul><p>For frequently called methods, the just-in-time compiler eventually creates fully optimized code in the background. The optimized code then replaces the pre-compiled code for that method.</p><p>Code generated by Quick JIT may run slower, allocate more memory, or use more stack space. If there are issues, you can disabled Quick JIT using this MSBuild property in the project file:</p><pre><code class="lang-xml">&lt;PropertyGroup&gt;
  &lt;TieredCompilationQuickJit&gt;false&lt;/TieredCompilationQuickJit&gt;
&lt;/PropertyGroup&gt;
</code></pre><p>To disable TC completely, use this MSBuild property in your project file:</p><pre><code class="lang-xml">&lt;PropertyGroup&gt;
  &lt;TieredCompilation&gt;false&lt;/TieredCompilation&gt;
&lt;/PropertyGroup&gt;
</code></pre><div class="TIP"><p>Tip</p><p>If you change these settings in the project file, you may need to perform a clean build for the new settings to be reflected (delete the <code>obj</code> and <code>bin</code> directories and rebuild).</p></div><p>For more information about configuring compilation at run time, see <a href="../run-time-config/compilation" data-linktype="relative-path">Run-time configuration options for compilation</a>.</p><h3 id="readytorun-images">ReadyToRun images</h3><p>You can improve the startup time of your .NET Core application by compiling your application assemblies as ReadyToRun (R2R) format. R2R is a form of ahead-of-time (AOT) compilation.</p><p>R2R binaries improve startup performance by reducing the amount of work the just-in-time (JIT) compiler needs to do as your application loads. The binaries contain similar native code compared to what the JIT would produce. However, R2R binaries are larger because they contain both intermediate language (IL) code, which is still needed for some scenarios, and the native version of the same code. R2R is only available when you publish a self-contained app that targets specific runtime environments (RID) such as Linux x64 or Windows x64.</p><p>To compile your project as ReadyToRun, do the following:</p><ol><li><p>Add the <code>&lt;PublishReadyToRun&gt;</code> setting to your project:</p><pre><code class="lang-xml">&lt;PropertyGroup&gt;
  &lt;PublishReadyToRun&gt;true&lt;/PublishReadyToRun&gt;
&lt;/PropertyGroup&gt;
</code></pre></li><li><p>Publish a self-contained app. For example, this command creates a self-contained app for the 64-bit version of Windows:</p><pre><code class="lang-dotnetcli">dotnet publish -c Release -r win-x64 --self-contained
</code></pre></li></ol><h4 id="cross-platformarchitecture-restrictions">Cross platform/architecture restrictions</h4><p>The ReadyToRun compiler doesn't currently support cross-targeting. You must compile on a given target. For example, if you want R2R images for Windows x64, you need to run the publish command on that environment.</p><p>Exceptions to cross-targeting:</p><ul><li>Windows x64 can be used to compile Windows ARM32, ARM64, and x86 images.</li><li>Windows x86 can be used to compile Windows ARM32 images.</li><li>Linux x64 can be used to compile Linux ARM32 and ARM64 images.</li></ul><h2 id="runtimesdk">Runtime/SDK</h2><h3 id="major-version-runtime-roll-forward">Major-version runtime roll forward</h3><p>.NET Core 3.0 introduces an opt-in feature that allows your app to roll forward to the latest major version of .NET Core. Additionally, a new setting has been added to control how roll forward is applied to your app. This can be configured in the following ways:</p><ul><li>Project file property: <code>RollForward</code></li><li>Run-time configuration file property: <code>rollForward</code></li><li>Environment variable: <code>DOTNET_ROLL_FORWARD</code></li><li>Command-line argument: <code>--roll-forward</code></li></ul><p>One of the following values must be specified. If the setting is omitted, <strong>Minor</strong> is the default.</p><ul><li><strong>LatestPatch</strong><br>Roll forward to the highest patch version. This disables minor version roll forward.</li><li><strong>Minor</strong><br>Roll forward to the lowest higher minor version, if requested minor version is missing. If the requested minor version is present, then the <strong>LatestPatch</strong> policy is used.</li><li><strong>Major</strong><br>Roll forward to lowest higher major version, and lowest minor version, if requested major version is missing. If the requested major version is present, then the <strong>Minor</strong> policy is used.</li><li><strong>LatestMinor</strong><br>Roll forward to highest minor version, even if requested minor version is present. Intended for component hosting scenarios.</li><li><strong>LatestMajor</strong><br>Roll forward to highest major and highest minor version, even if requested major is present. Intended for component hosting scenarios.</li><li><strong>Disable</strong><br>Don't roll forward. Only bind to specified version. This policy isn't recommended for general use because it disables the ability to roll forward to the latest patches. This value is only recommended for testing.</li></ul><p>Besides the <strong>Disable</strong> setting, all settings will use the highest available patch version.</p><h3 id="build-copies-dependencies">Build copies dependencies</h3><p>The <code>dotnet build</code> command now copies NuGet dependencies for your application from the NuGet cache to the build output folder. Previously, dependencies were only copied as part of <code>dotnet publish</code>.</p><p>There are some operations, like linking and razor page publishing that will still require publishing.</p><p>.NET Core 3.0 introduces local tools. Local tools are similar to <a href="../tools/global-tools" data-linktype="relative-path">global tools</a> but are associated with a particular location on disk. Local tools aren't available globally and are distributed as NuGet packages.</p><div class="WARNING"><p>Warning</p><p>If you tried local tools in .NET Core 3.0 Preview 1, such as running <code>dotnet tool restore</code> or <code>dotnet tool install</code>, delete the local tools cache folder. Otherwise, local tools won't work on any newer release. This folder is located at:</p><p>On macOS, Linux: <code>rm -r $HOME/.dotnet/toolResolverCache</code></p><p>On Windows: <code>rmdir /s %USERPROFILE%\.dotnet\toolResolverCache</code></p></div><p>Local tools rely on a manifest file name <code>dotnet-tools.json</code> in your current directory. This manifest file defines the tools to be available at that folder and below. You can distribute the manifest file with your code to ensure that anyone who works with your code can restore and use the same tools.</p><p>For both global and local tools, a compatible version of the runtime is required. Many tools currently on NuGet.org target .NET Core Runtime 2.1. To install these tools globally or locally, you would still need to install the <a href="https://dotnet.microsoft.com/download/dotnet-core/2.1" data-linktype="external">NET Core 2.1 Runtime</a>.</p><h3 id="new-globaljson-options">New global.json options</h3><p>The <em>global.json</em> file has new options that provide more flexibility when you're trying to define which version of the .NET Core SDK is used. The new options are:</p><ul><li><code>allowPrerelease</code>: Indicates whether the SDK resolver should consider prerelease versions when selecting the SDK version to use.</li><li><code>rollForward</code>: Indicates the roll-forward policy to use when selecting an SDK version, either as a fallback when a specific SDK version is missing or as a directive to use a higher version.</li></ul><p>For more information about the changes including default values, supported values, and new matching rules, see <a href="../tools/global-json" data-linktype="relative-path">global.json overview</a>.</p><h3 id="smaller-garbage-collection-heap-sizes">Smaller Garbage Collection heap sizes</h3><p>The Garbage Collector's default heap size has been reduced resulting in .NET Core using less memory. This change better aligns with the generation 0 allocation budget with modern processor cache sizes.</p><h3 id="garbage-collection-large-page-support">Garbage Collection Large Page support</h3><p>Large Pages (also known as Huge Pages on Linux) is a feature where the operating system is able to establish memory regions larger than the native page size (often 4K) to improve performance of the application requesting these large pages.</p><p>The Garbage Collector can now be configured with the <strong>GCLargePages</strong> setting as an opt-in feature to choose to allocate large pages on Windows.</p><h2 id="windows-desktop--com">Windows Desktop &amp; COM</h2><h3 id="net-core-sdk-windows-installer">.NET Core SDK Windows Installer</h3><p>The MSI installer for Windows has changed starting with .NET Core 3.0. The SDK installers will now upgrade SDK feature-band releases in place. Feature bands are defined in the <em>hundreds</em> groups in the <em>patch</em> section of the version number. For example, <strong>3.0.<em>101</em></strong> and <strong>3.0.<em>201</em></strong> are versions in two different feature bands while <strong>3.0.<em>101</em></strong> and <strong>3.0.<em>199</em></strong> are in the same feature band. And, when .NET Core SDK <strong>3.0.<em>101</em></strong> is installed, .NET Core SDK <strong>3.0.<em>100</em></strong> will be removed from the machine if it exists. When .NET Core SDK <strong>3.0.<em>200</em></strong> is installed on the same machine, .NET Core SDK <strong>3.0.<em>101</em></strong> won't be removed.</p><p>For more information about versioning, see <a href="../versions/" data-linktype="relative-path">Overview of how .NET Core is versioned</a>.</p><h3 id="windows-desktop">Windows desktop</h3><p>.NET Core 3.0 supports Windows desktop applications using Windows Presentation Foundation (WPF) and Windows Forms. These frameworks also support using modern controls and Fluent styling from the Windows UI XAML Library (WinUI) via <a href="/en-us/windows/uwp/xaml-platform/xaml-host-controls" data-linktype="absolute-path">XAML islands</a>.</p><p>The Windows Desktop component is part of the Windows .NET Core 3.0 SDK.</p><p>You can create a new WPF or Windows Forms app with the following <code>dotnet</code> commands:</p><pre><code class="lang-dotnetcli">dotnet new wpf
dotnet new winforms
</code></pre><p>Visual Studio 2019 adds <strong>New Project</strong> templates for .NET Core 3.0 Windows Forms and WPF.</p><p>For more information about how to port an existing .NET Framework application, see <a href="../../desktop-wpf/migration/convert-project-from-net-framework" data-linktype="relative-path">Port WPF projects</a> and <a href="../porting/winforms" data-linktype="relative-path">Port Windows Forms projects</a>.</p><h4 id="winforms-high-dpi">WinForms high DPI</h4><p>.NET Core Windows Forms applications can set high DPI mode with <a href="/en-us/dotnet/api/system.windows.forms.application.sethighdpimode#System_Windows_Forms_Application_SetHighDpiMode_System_Windows_Forms_HighDpiMode_" data-linktype="absolute-path">Application.SetHighDpiMode(HighDpiMode)</a>. The <code>SetHighDpiMode</code> method sets the corresponding high DPI mode unless the setting has been set by other means like <code>App.Manifest</code> or P/Invoke before <code>Application.Run</code>.</p><p>The possible <code>highDpiMode</code> values, as expressed by the <a href="/en-us/dotnet/api/system.windows.forms.highdpimode" data-linktype="absolute-path">System.Windows.Forms.HighDpiMode</a> enum are:</p><ul><li><code>DpiUnaware</code></li><li><code>SystemAware</code></li><li><code>PerMonitor</code></li><li><code>PerMonitorV2</code></li><li><code>DpiUnawareGdiScaled</code></li></ul><p>For more information about high DPI modes, see <a href="/en-us/windows/desktop/hidpi/high-dpi-desktop-application-development-on-windows" data-linktype="absolute-path">High DPI Desktop Application Development on Windows</a>.</p><p>On Windows, you can now create COM-callable managed components. This capability is critical to use .NET Core with COM add-in models and also to provide parity with .NET Framework.</p><p>Unlike .NET Framework where the <em>mscoree.dll</em> was used as the COM server, .NET Core will add a native launcher dll to the <em>bin</em> directory when you build your COM component.</p><p>For an example of how to create a COM component and consume it, see the <a href="https://github.com/dotnet/samples/tree/master/core/extensions/COMServerDemo" data-linktype="external">COM Demo</a>.</p><h3 id="windows-native-interop">Windows Native Interop</h3><p>Windows offers a rich native API in the form of flat C APIs, COM, and WinRT. While .NET Core supports <strong>P/Invoke</strong>, .NET Core 3.0 adds the ability to <strong>CoCreate COM APIs</strong> and <strong>Activate WinRT APIs</strong>. For a code example, see the <a href="https://github.com/dotnet/samples/tree/master/core/extensions/ExcelDemo" data-linktype="external">Excel Demo</a>.</p><h3 id="msix-deployment">MSIX Deployment</h3><p><a href="https://docs.microsoft.com/windows/msix/" data-linktype="external">MSIX</a> is a new Windows application package format. It can be used to deploy .NET Core 3.0 desktop applications to Windows 10.</p><p>The <a href="https://docs.microsoft.com/windows/uwp/porting/desktop-to-uwp-packaging-dot-net" data-linktype="external">Windows Application Packaging Project</a>, available in Visual Studio 2019, allows you to create MSIX packages with <a href="../deploying/#self-contained-deployments-scd" data-linktype="relative-path">self-contained</a> .NET Core applications.</p><p>The .NET Core project file must specify the supported runtimes in the <code>&lt;RuntimeIdentifiers&gt;</code> property:</p><pre><code class="lang-xml">&lt;RuntimeIdentifiers&gt;win-x86;win-x64&lt;/RuntimeIdentifiers&gt;
</code></pre><h2 id="linux-improvements">Linux improvements</h2><h3 id="serialport-for-linux">SerialPort for Linux</h3><p>.NET Core 3.0 provides basic support for <a href="/en-us/dotnet/api/system.io.ports.serialport" data-linktype="absolute-path">System.IO.Ports.SerialPort</a> on Linux.</p><p>Previously, .NET Core only supported using <code>SerialPort</code> on Windows.</p><p>For more information about the limited support for the serial port on Linux, see <a href="https://github.com/dotnet/corefx/issues/33146" data-linktype="external">GitHub issue #33146</a>.</p><h3 id="docker-and-cgroup-memory-limits">Docker and cgroup memory Limits</h3><p>Running .NET Core 3.0 on Linux with Docker works better with cgroup memory limits. Running a Docker container with memory limits, such as with <code>docker run -m</code>, changes how .NET Core behaves.</p><ul><li>Default Garbage Collector (GC) heap size: maximum of 20 mb or 75% of the memory limit on the container.</li><li>Explicit size can be set as an absolute number or percentage of cgroup limit.</li><li>Minimum reserved segment size per GC heap is 16 mb. This size reduces the number of heaps that are created on machines.</li></ul><h3 id="gpio-support-for-raspberry-pi">GPIO Support for Raspberry Pi</h3><p>Two packages have been released to NuGet that you can use for GPIO programming:</p><p>The GPIO packages include APIs for <em>GPIO</em>, <em>SPI</em>, <em>I2C</em>, and <em>PWM</em> devices. The IoT bindings package includes device bindings. For more information, see the <a href="https://github.com/dotnet/iot/blob/master/src/devices/" data-linktype="external">devices GitHub repo</a>.</p><h3 id="arm64-linux-support">ARM64 Linux support</h3><p>.NET Core 3.0 adds support for ARM64 for Linux. The primary use case for ARM64 is currently with IoT scenarios. For more information, see <a href="https://github.com/dotnet/announcements/issues/82" data-linktype="external">.NET Core ARM64 Status</a>.</p><p><a href="https://hub.docker.com/r/microsoft/dotnet/" data-linktype="external">Docker images for .NET Core on ARM64</a> are available for Alpine, Debian, and Ubuntu.</p><div class="NOTE"><p>Note</p><p><strong>ARM64</strong> Windows support isn't yet available.</p></div><h2 id="security">Security</h2><h3 id="tls-13--openssl-111-on-linux">TLS 1.3 &amp; OpenSSL 1.1.1 on Linux</h3><p>.NET Core now takes advantage of <a href="https://www.openssl.org/blog/blog/2018/09/11/release111/" data-linktype="external">TLS 1.3 support in OpenSSL 1.1.1</a>, when it's available in a given environment. With TLS 1.3:</p><ul><li>Connection times are improved with reduced round trips required between the client and server.</li><li>Improved security because of the removal of various obsolete and insecure cryptographic algorithms.</li></ul><p>When available, .NET Core 3.0 uses <strong>OpenSSL 1.1.1</strong>, <strong>OpenSSL 1.1.0</strong>, or <strong>OpenSSL 1.0.2</strong> on a Linux system. When <strong>OpenSSL 1.1.1</strong> is available, both <a href="/en-us/dotnet/api/system.net.security.sslstream" data-linktype="absolute-path">System.Net.Security.SslStream</a> and <a href="/en-us/dotnet/api/system.net.http.httpclient" data-linktype="absolute-path">System.Net.Http.HttpClient</a> types will use <strong>TLS 1.3</strong> (assuming both the client and server support <strong>TLS 1.3</strong>).</p><div class="IMPORTANT"><p>Important</p><p>Windows and macOS do not yet support <strong>TLS 1.3</strong>. .NET Core 3.0 will support <strong>TLS 1.3</strong> on these operating systems when support becomes available.</p></div><p>The following C# 8.0 example demonstrates .NET Core 3.0 on Ubuntu 18.10 connecting to <a href="https://www.cloudflare.com" data-linktype="external">https://www.cloudflare.com</a>:</p><pre><code class="lang-csharp" name="TLSExample">using System;
using System.Net.Security;
using System.Net.Sockets;
using System.Threading.Tasks;

namespace whats_new
{
    public static class TLS
    {
        public static async Task ConnectCloudFlare()
        {
            var targetHost = "www.cloudflare.com";

            using TcpClient tcpClient = new TcpClient();

            await tcpClient.ConnectAsync(targetHost, 443);

            using SslStream sslStream = new SslStream(tcpClient.GetStream());
            
            await sslStream.AuthenticateAsClientAsync(targetHost);
            await Console.Out.WriteLineAsync($"Connected to {targetHost} with {sslStream.SslProtocol}");
        }
    }
}
</code></pre><h3 id="cryptography-ciphers">Cryptography ciphers</h3><p>.NET 3.0 adds support for <strong>AES-GCM</strong> and <strong>AES-CCM</strong> ciphers, implemented with <a href="/en-us/dotnet/api/system.security.cryptography.aesgcm" data-linktype="absolute-path">System.Security.Cryptography.AesGcm</a> and <a href="/en-us/dotnet/api/system.security.cryptography.aesccm" data-linktype="absolute-path">System.Security.Cryptography.AesCcm</a> respectively. These algorithms are both <a href="https://en.wikipedia.org/wiki/Authenticated_encryption" data-linktype="external">Authenticated Encryption with Association Data (AEAD) algorithms</a>.</p><p>The following code demonstrates using <code>AesGcm</code> cipher to encrypt and decrypt random data.</p><pre><code class="lang-csharp" name="AesGcm">using System;
using System.Linq;
using System.Security.Cryptography;

namespace whats_new
{
    public static class Cipher
    {
        public static void Run()
        {
            // key should be: pre-known, derived, or transported via another channel, such as RSA encryption
            byte[] key = new byte[16];
            RandomNumberGenerator.Fill(key);

            byte[] nonce = new byte[12];
            RandomNumberGenerator.Fill(nonce);

            // normally this would be your data
            byte[] dataToEncrypt = new byte[1234];
            byte[] associatedData = new byte[333];
            RandomNumberGenerator.Fill(dataToEncrypt);
            RandomNumberGenerator.Fill(associatedData);

            // these will be filled during the encryption
            byte[] tag = new byte[16];
            byte[] ciphertext = new byte[dataToEncrypt.Length];

            using (AesGcm aesGcm = new AesGcm(key))
            {
                aesGcm.Encrypt(nonce, dataToEncrypt, ciphertext, tag, associatedData);
            }

            // tag, nonce, ciphertext, associatedData should be sent to the other part

            byte[] decryptedData = new byte[ciphertext.Length];

            using (AesGcm aesGcm = new AesGcm(key))
            {
                aesGcm.Decrypt(nonce, ciphertext, tag, decryptedData, associatedData);
            }

            // do something with the data
            // this should always print that data is the same
            Console.WriteLine($"AES-GCM: Decrypted data is {(dataToEncrypt.SequenceEqual(decryptedData) ? "the same as" : "different than")} original data.");
        }
    }
}
</code></pre><h3 id="cryptographic-key-importexport">Cryptographic Key Import/Export</h3><p>.NET Core 3.0 supports the import and export of asymmetric public and private keys from standard formats. You don't need to use an X.509 certificate.</p><p>All key types, such as <em>RSA</em>, <em>DSA</em>, <em>ECDsa</em>, and <em>ECDiffieHellman</em>, support the following formats:</p><ul><li><p><strong>Public Key</strong></p><ul><li>X.509 SubjectPublicKeyInfo</li></ul></li><li><p><strong>Private key</strong></p><ul><li>PKCS#8 PrivateKeyInfo</li><li>PKCS#8 EncryptedPrivateKeyInfo</li></ul></li></ul><p>RSA keys also support:</p><ul><li><p><strong>Public Key</strong></p></li><li><p><strong>Private key</strong></p></li></ul><p>The export methods produce DER-encoded binary data, and the import methods expect the same. If a key is stored in the text-friendly PEM format, the caller will need to base64-decode the content before calling an import method.</p><pre><code class="lang-csharp" name="RSA">using System;
using System.Security.Cryptography;

namespace whats_new
{
    public static class RSATest
    {
        public static void Run(string keyFile)
        {
            using var rsa = RSA.Create();

            byte[] keyBytes = System.IO.File.ReadAllBytes(keyFile);
            rsa.ImportRSAPrivateKey(keyBytes, out int bytesRead);

            Console.WriteLine($"Read {bytesRead} bytes, {keyBytes.Length - bytesRead} extra byte(s) in file.");
            RSAParameters rsaParameters = rsa.ExportParameters(true);
            Console.WriteLine(BitConverter.ToString(rsaParameters.D));
        }
    }
}
</code></pre><p><strong>PKCS#8</strong> files can be inspected with <a href="/en-us/dotnet/api/system.security.cryptography.pkcs.pkcs8privatekeyinfo" data-linktype="absolute-path">System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo</a> and <strong>PFX/PKCS#12</strong> files can be inspected with <a href="/en-us/dotnet/api/system.security.cryptography.pkcs.pkcs12info" data-linktype="absolute-path">System.Security.Cryptography.Pkcs.Pkcs12Info</a>. <strong>PFX/PKCS#12</strong> files can be manipulated with <a href="/en-us/dotnet/api/system.security.cryptography.pkcs.pkcs12builder" data-linktype="absolute-path">System.Security.Cryptography.Pkcs.Pkcs12Builder</a>.</p><h2 id="net-core-30-api-changes">.NET Core 3.0 API changes</h2><h3 id="ranges-and-indices">Ranges and indices</h3><p>The new <a href="/en-us/dotnet/api/system.index" data-linktype="absolute-path">System.Index</a> type can be used for indexing. You can create one from an <code>int</code> that counts from the beginning, or with a prefix <code>^</code> operator (C#) that counts from the end:</p><pre><code class="lang-csharp">Index i1 = 3;  // number 3 from beginning
Index i2 = ^4; // number 4 from end
int[] a = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
Console.WriteLine($"{a[i1]}, {a[i2]}"); // "3, 6"
</code></pre><p>There's also the <a href="/en-us/dotnet/api/system.range" data-linktype="absolute-path">System.Range</a> type, which consists of two <code>Index</code> values, one for the start and one for the end, and can be written with a <code>x..y</code> range expression (C#). You can then index with a <code>Range</code>, which produces a slice:</p><pre><code class="lang-csharp">var slice = a[i1..i2]; // { 3, 4, 5 }
</code></pre><p>For more information, see the <a href="../../csharp/tutorials/ranges-indexes" data-linktype="relative-path">ranges and indices tutorial</a>.</p><h3 id="async-streams">Async streams</h3><p>The <a href="/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1" data-linktype="absolute-path">IAsyncEnumerable&lt;T&gt;</a> type is a new asynchronous version of <a href="/en-us/dotnet/api/system.collections.generic.ienumerable-1" data-linktype="absolute-path">IEnumerable&lt;T&gt;</a>. The language lets you <code>await foreach</code> over <code>IAsyncEnumerable&lt;T&gt;</code> to consume their elements, and use <code>yield return</code> to them to produce elements.</p><p>The following example demonstrates both production and consumption of async streams. The <code>foreach</code> statement is async and itself uses <code>yield return</code> to produce an async stream for callers. This pattern (using <code>yield return</code>) is the recommended model for producing async streams.</p><pre><code class="lang-csharp">async IAsyncEnumerable&lt;int&gt; GetBigResultsAsync()
{
    await foreach (var result in GetResultsAsync())
    {
        if (result &gt; 20) yield return result;
    }
}
</code></pre><p>In addition to being able to <code>await foreach</code>, you can also create async iterators, for example, an iterator that returns an <code>IAsyncEnumerable/IAsyncEnumerator</code> that you can both <code>await</code> and <code>yield</code> in. For objects that need to be disposed, you can use <code>IAsyncDisposable</code>, which various BCL types implement, such as <code>Stream</code> and <code>Timer</code>.</p><p>For more information, see the <a href="../../csharp/tutorials/generate-consume-asynchronous-stream" data-linktype="relative-path">async streams tutorial</a>.</p><h3 id="ieee-floating-point">IEEE Floating-point</h3><p>Floating point APIs are being updated to comply with <a href="https://en.wikipedia.org/wiki/IEEE_754-2008_revision" data-linktype="external">IEEE 754-2008 revision</a>. The goal of these changes is to expose all <strong>required</strong> operations and ensure that they're behaviorally compliant with the IEEE spec. For more information about floating-point improvements, see the <a href="https://devblogs.microsoft.com/dotnet/floating-point-parsing-and-formatting-improvements-in-net-core-3-0/" data-linktype="external">Floating-Point Parsing and Formatting improvements in .NET Core 3.0</a> blog post.</p><p>Parsing and formatting fixes include:</p><ul><li>Correctly parse and round inputs of any length.</li><li>Correctly parse and format negative zero.</li><li>Correctly parse <code>Infinity</code> and <code>NaN</code> by doing a case-insensitive check and allowing an optional preceding <code>+</code> where applicable.</li></ul><p>New <a href="/en-us/dotnet/api/system.math" data-linktype="absolute-path">System.Math</a> APIs include:</p><ul><li><p><a href="/en-us/dotnet/api/system.math.bitincrement#System_Math_BitIncrement_System_Double_" data-linktype="absolute-path">BitIncrement(Double)</a> and <a href="/en-us/dotnet/api/system.math.bitdecrement#System_Math_BitDecrement_System_Double_" data-linktype="absolute-path">BitDecrement(Double)</a><br>Corresponds to the <code>nextUp</code> and <code>nextDown</code> IEEE operations. They return the smallest floating-point number that compares greater or lesser than the input (respectively). For example, <code>Math.BitIncrement(0.0)</code> would return <code>double.Epsilon</code>.</p></li><li><p><a href="/en-us/dotnet/api/system.math.maxmagnitude#System_Math_MaxMagnitude_System_Double_System_Double_" data-linktype="absolute-path">MaxMagnitude(Double, Double)</a> and <a href="/en-us/dotnet/api/system.math.minmagnitude#System_Math_MinMagnitude_System_Double_System_Double_" data-linktype="absolute-path">MinMagnitude(Double, Double)</a><br>Corresponds to the <code>maxNumMag</code> and <code>minNumMag</code> IEEE operations, they return the value that is greater or lesser in magnitude of the two inputs (respectively). For example, <code>Math.MaxMagnitude(2.0, -3.0)</code> would return <code>-3.0</code>.</p></li><li><p><a href="/en-us/dotnet/api/system.math.ilogb#System_Math_ILogB_System_Double_" data-linktype="absolute-path">ILogB(Double)</a><br>Corresponds to the <code>logB</code> IEEE operation that returns an integral value, it returns the integral base-2 log of the input parameter. This method is effectively the same as <code>floor(log2(x))</code>, but done with minimal rounding error.</p></li><li><p><a href="/en-us/dotnet/api/system.math.scaleb#System_Math_ScaleB_System_Double_System_Int32_" data-linktype="absolute-path">ScaleB(Double, Int32)</a><br>Corresponds to the <code>scaleB</code> IEEE operation that takes an integral value, it returns effectively <code>x * pow(2, n)</code>, but is done with minimal rounding error.</p></li><li><p><a href="/en-us/dotnet/api/system.math.log2#System_Math_Log2_System_Double_" data-linktype="absolute-path">Log2(Double)</a><br>Corresponds to the <code>log2</code> IEEE operation, it returns the base-2 logarithm. It minimizes rounding error.</p></li><li><p><a href="/en-us/dotnet/api/system.math.fusedmultiplyadd#System_Math_FusedMultiplyAdd_System_Double_System_Double_System_Double_" data-linktype="absolute-path">FusedMultiplyAdd(Double, Double, Double)</a><br>Corresponds to the <code>fma</code> IEEE operation, it performs a fused multiply add. That is, it does <code>(x * y) + z</code> as a single operation, thereby minimizing the rounding error. An example is <code>FusedMultiplyAdd(1e308, 2.0, -1e308)</code>, which returns <code>1e308</code>. The regular <code>(1e308 * 2.0) - 1e308</code> returns <code>double.PositiveInfinity</code>.</p></li><li><p><a href="/en-us/dotnet/api/system.math.copysign#System_Math_CopySign_System_Double_System_Double_" data-linktype="absolute-path">CopySign(Double, Double)</a><br>Corresponds to the <code>copySign</code> IEEE operation, it returns the value of <code>x</code>, but with the sign of <code>y</code>.</p></li></ul><h3 id="net-platform-dependent-intrinsics">.NET Platform-Dependent Intrinsics</h3><p>APIs have been added that allow access to certain perf-oriented CPU instructions, such as the <strong>SIMD</strong> or <strong>Bit Manipulation instruction</strong> sets. These instructions can help achieve significant performance improvements in certain scenarios, such as processing data efficiently in parallel.</p><p>Where appropriate, the .NET libraries have begun using these instructions to improve performance.</p><p>For more information, see <a href="https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md" data-linktype="external">.NET Platform Dependent Intrinsics</a>.</p><h3 id="improved-net-core-version-apis">Improved .NET Core Version APIs</h3><p>Starting with .NET Core 3.0, the version APIs provided with .NET Core now return the information you expect. For example:</p><pre><code class="lang-csharp">System.Console.WriteLine($"Environment.Version: {System.Environment.Version}");

// Old result
//   Environment.Version: 4.0.30319.42000
//
// New result
//   Environment.Version: 3.0.0
</code></pre><pre><code class="lang-csharp">System.Console.WriteLine($"RuntimeInformation.FrameworkDescription: {System.Runtime.InteropServices.RuntimeInformation.FrameworkDescription}");

// Old result
//   RuntimeInformation.FrameworkDescription: .NET Core 4.6.27415.71
//
// New result (notice the value includes any preview release information)
//   RuntimeInformation.FrameworkDescription: .NET Core 3.0.0-preview4-27615-11
</code></pre><div class="WARNING"><p>Warning</p><p>Breaking change. This is technically a breaking change because the versioning scheme has changed.</p></div><h3 id="fast-built-in-json-support">Fast built-in JSON support</h3><p>.NET users have largely relied on <a href="https://www.newtonsoft.com/json" data-linktype="external">Newtonsoft.Json</a> and other popular JSON libraries, which continue to be good choices. <code>Newtonsoft.Json</code> uses .NET strings as its base datatype, which is UTF-16 under the hood.</p><p>The new built-in JSON support is high-performance, low allocation, and works with UTF-8 encoded JSON text. For more information about the <a href="/en-us/dotnet/api/system.text.json" data-linktype="absolute-path">System.Text.Json</a> namespace and types, see the following articles:</p><h3 id="http2-support">HTTP/2 support</h3><p>The <a href="/en-us/dotnet/api/system.net.http.httpclient" data-linktype="absolute-path">System.Net.Http.HttpClient</a> type supports the HTTP/2 protocol. If HTTP/2 is enabled, the HTTP protocol version is negotiated via TLS/ALPN, and HTTP/2 is used if the server elects to use it.</p><p>The default protocol remains HTTP/1.1, but HTTP/2 can be enabled in two different ways. First, you can set the HTTP request message to use HTTP/2:</p><pre><code class="lang-csharp" name="Http2Request">var client = new HttpClient() { BaseAddress = new Uri("https://localhost:5001") };

// HTTP/1.1 request
using (var response = await client.GetAsync("/"))
    Console.WriteLine(response.Content);

// HTTP/2 request
using (var request = new HttpRequestMessage(HttpMethod.Get, "/") { Version = new Version(2, 0) })
using (var response = await client.SendAsync(request))
    Console.WriteLine(response.Content);
</code></pre><p>Second, you can change <a href="/en-us/dotnet/api/system.net.http.httpclient" data-linktype="absolute-path">HttpClient</a> to use HTTP/2 by default:</p><pre><code class="lang-csharp" name="Http2Client">var client = new HttpClient()
{
    BaseAddress = new Uri("https://localhost:5001"),
    DefaultRequestVersion = new Version(2, 0)
};

// HTTP/2 is default
using (var response = await client.GetAsync("/"))
    Console.WriteLine(response.Content);
</code></pre><p>Many times when you're developing an application, you want to use an unencrypted connection. If you know the target endpoint will be using HTTP/2, you can turn on unencrypted connections for HTTP/2. You can turn it on by setting the <code>DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT</code> environment variable to <code>1</code> or by enabling it in the app context:</p><pre><code class="lang-csharp" name="Http2Context">AppContext.SetSwitch("System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport", true);
</code></pre><h2 id="next-steps">Next steps</h2></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>