<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Testing in Production with Feature Toggles in .NET Core - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Testing in Production with Feature Toggles in .NET Core - linksfor.dev(s)"/>
    <meta property="og:description" content="Testing with confidence without breaking your users"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://joestead.codes/posts/testing-in-production-feature-toggling-netcore/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Testing in Production with Feature Toggles in .NET Core</title>
<div class="readable">
        <h1>Testing in Production with Feature Toggles in .NET Core</h1>
            <div>Reading time: 13-16 minutes</div>
        <div>Posted here: 18 Jun 2020</div>
        <p><a href="https://joestead.codes/posts/testing-in-production-feature-toggling-netcore/">https://joestead.codes/posts/testing-in-production-feature-toggling-netcore/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>I’ve always been a big fan of testing, and often think about ways to improve the testability of our system. The most effective testing is to test what your users actually use, and that is to test in production. This can be quite a scary thought to some, shipping untested code out to our live system, with real users, and hope it doesn’t break!</p>
<p>Of course, the simple solution would be to run two “Production Environments” side by side, and use one exclusively for testing, and only once you are satisfied everything is working, push the tested changes across to the other environment. This doesn’t make much sense though.</p>
<p>There’s a few potential issues with this approach. Firstly, you’ve just double your flat production costs (excluding costs which are accrued by traffic), convincing people with the credit card that this is a good idea, can be quite a hard sell, and rightfully so. We’ve essentially created a beefed-up version of a “test environment”.</p>
<p>Maybe you’re in a position where increasing costs like this isn’t a concern, unfortunately it still doesn’t cover our requirement of “testing in production”, we’ll be testing in a “production-like” environment. We won’t have data generated by users, we won’t have live traffic continuing to use the system as we’re testing our feature. It’s just not the same.</p>
<p>To effectively test in production, it’s important you have the appropriate monitoring and logging in place, as well as a team comfortable supporting a continuously changing system. Continuously deploying to production is something that you will become more comfortable with over time. It’s important to have good observability of your system.</p>
<p>It’s also worth noting that testing in production, and continuously pushing to production isn’t for everyone, if you’re in a highly-regulated field for example, you may not be able to for legal reasons. However, feature toggling may still be of use to you, in slightly different contexts, so hopefully you will still take something away from this post.</p>
<h2 id="feature-toggling-and-testing-in-production">Feature Toggling and Testing in Production</h2>
<p>So what do we mean by “Feature Toggling”? The most simplistic answer I can provide for this is:</p>
<blockquote>
<p>If a pre-set condition is true, where the appropriate value comes from a <em>source</em>, the feature should be enabled, otherwise the feature should be disabled, and the code should not execute.</p>
</blockquote>
<p>I’ve purposefully made the description here quite open here. I haven’t specified where the “appropriate value” is actually populated. There are so many sources we could use here, but let’s explore a few:</p>
<ul>
<li>A hard-coded configuration value</li>
<li>A claim on an authorised user</li>
<li>The tenant Id of the current request</li>
</ul>
<p>In these examples, I’ve picked out some that are particularly useful for testing purposes, but you could expand it to feature toggle on IP Allow/Block lists, or try to lookup the user’s location based on request headers/specified address and only allow certain features in certain regions too, the same concepts apply!</p>
<p>You can also use the same concept to A/B test features, or slowly roll out features by only enabling 10% of all requests to use the new flow, for example.</p>
<p>To go into more detail, it makes sense to show some code samples. Although the following code samples target C# and .NET Core specifically, I hope the concepts are easily translatable to your language of choice.</p>
<h3 id="setting-up-feature-toggling-in-net-core-31">Setting up Feature Toggling in .NET Core 3.1</h3>
<p>For the following samples we’ll be utilising the <a href="https://github.com/microsoft/FeatureManagement-Dotnet/"><code>Microsoft.FeatureManagement</code> package</a>. I was first made aware of this package by the blog post series on <a href="https://andrewlock.net/tag/feature-flags/">feature flags in ASP.NET</a> by Andrew Lock. The library has evolved slightly since then, but there’s still a lot more detail on how it works for those who are interested.</p>
<p>A brief overview of the package though:</p>
<ul>
<li>It uses the <code>Microsoft.Extensions.Configuration</code> bits in to determine if the feature is enabled</li>
<li>It has some built in “Filters” which can be very handy for getting up and running</li>
<li>It is extensible enough for us to also create our own filters for more specific flagging</li>
</ul>
<h4 id="setting-up-feature-toggling-and-using-it-on-a-hard-coded-configuration-value">Setting up feature toggling and using it on a hard-coded configuration value</h4>
<p>This is the simplest way of feature flagging. There are no dynamic values. It’s on or off. True or false.</p>
<p>First off, let’s create a <code>features.json</code> file for handling our feature configuration. As we’ll be using <code>Microsoft.Extensions.Configuration</code> for this, we could equally define our feature configuration in environment variables, ini files, yaml files, Azure, AWS, wherever.  My feature config looks like this:</p>
<div><pre><code data-lang="json">{
    <span>"FeatureManagement"</span>: {
        <span>"AdvancedSearch"</span>: <span>true</span>
    }
}
</code></pre></div><p>Now in our application, we need to load up this configuration ready to be used. You can either include this in your apps wider configuration by adding to the <code>ConfigurationBuilder</code> already being used, but I like keeping my feature config separate, so here’s how I’ll set up the config:</p>
<div><pre><code data-lang="csharp"><span>var</span> featureConfig = <span>new</span> ConfigurationBuilder()
                .AddJsonFile(<span>$"features.json"</span>, optional: <span>true</span>)
                .Build()
</code></pre></div><p>Finally, as the bits in <code>Microsoft.Extensions.*</code> can be incredibly viral and end up all over your application, we need to register the feature management components to our container. If you’re using ASP.NET Core here, the following code will fit into your <code>ConfigureServices</code> method, otherwise you may need to create a <code>ServiceCollection</code> and use it elsewhere.</p>
<div><pre><code data-lang="csharp">
<span>var</span> services = <span>new</span> ServiceCollection(); <span>//omit if using ASP.NET Core
</span><span></span>services.AddFeatureManagement(featureConfig);
<span>var</span> serviceProvider = services.BuildServiceProvider(); <span>//omit if using ASP.NET Core
</span></code></pre></div><p>That’s all the setup necessary! If we’re utilising dependency injection (this is true by default in ASP.NET Core), we can just take a dependency on <code>IFeatureManager</code>, if not, we can pull the instance out of our service provider:</p>
<div><pre><code data-lang="csharp"><span>var</span> featureManager = serviceProvider.GetRequiredService&lt;IFeatureManager&gt;();
</code></pre></div><p>Once we have our <code>featureManager</code> instance available to use, we can begin to do some flagging!</p>
<div><pre><code data-lang="csharp"><span>if</span>(<span>await</span> featureManager.IsEnabledAsync(<span>"AdvancedSearch"</span>)
{
    <span>// execute the advanced search
</span><span></span>}
<span>else</span>
{
    <span>// execute the simple search instead
</span><span></span>}
</code></pre></div><p>This is the simplest way to get up and running with feature toggling, but we’re not able to effectively test in production using this. It will allow us to push code to production and disable it whilst we test elsewhere though, which s a huge step forward. Let’s explore some other ways of feature toggling which we can utilise on our production environment.</p>
<h4 id="feature-toggling-on-a-user-claim">Feature Toggling on a user claim</h4>
<p>So far, our <code>AdvancedSearch</code> will either be enabled for everyone, or not. As we’re relying on <code>UserClaims</code> here, this will only work with ASP.NET Core - we’ll show an example on how to do something similar when we come to featuring by Tenant Id.</p>
<p>Let’s make it so it’s only enabled for users who are our beta testers, or internal users identified by a claim instead. Let’s start my expanding our <code>feature.json</code></p>
<div><pre><code data-lang="json">{
  <span>"FeatureManagement"</span>: {
    <span>"AdvancedSearch"</span>: {
      <span>"EnabledFor"</span>: [
        {
          <span>"Name"</span>: <span>"Claims"</span>,
          <span>"Parameters"</span>: {
            <span>"AllowedClaims"</span>: [<span>"Employee"</span>,<span>"BetaTester"</span>]
          }
        }
      ]
    }
  }
}
</code></pre></div><p>Now, this is a little more complex than either being enabled or not, so we’ll need to create our own <code>FeatureFilter</code> to handle this. Firstly, let’s create a class which understands the shape of the underlying configuration:</p>
<div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>ClaimsFilterSettings</span>
{
    <span>public</span> <span>string</span>[] AllowedClaims { <span>get</span>; <span>set</span>; }
}
</code></pre></div><p>Secondly, we’ll need to implement the filter. The filter will take a dependency on <code>IHttpContextAccessor</code> so we can grab the current HttpContext and make a decision on whether to allow the current user access:</p>
<div><pre><code data-lang="csharp"><span>[FilterAlias("Claims")]</span>
<span>public</span> <span>class</span> <span>ClaimsFeatureFilter</span> : IFeatureFilter
{
    <span>private</span> <span>readonly</span> IHttpContextAccessor httpContextAccessor;

    <span>public</span> ClaimsFeatureFilter(IHttpContextAccessor httpContextAccessor)
    {
        <span>this</span>.httpContextAccessor = httpContextAccessor;
    }

    <span>public</span> Task&lt;<span>bool</span>&gt; EvaluateAsync(FeatureFilterEvaluationContext context)
    {
        <span>var</span> settings = context.Parameters.Get&lt;ClaimsFilterSettings&gt;();

        <span>var</span> user = <span>this</span>.httpContextAccessor.HttpContext.User;

        <span>// IFeatureFilter is async by default
</span><span></span>        <span>// and we're not doing anything async here, so we'll need to use Task.FromResult
</span><span></span>        <span>return</span> Task.FromResult(user.Claims.Any(x =&gt; settings.AllowedClaims.Contains(x.Type)));
    }
}
</code></pre></div><p>So here we take the current user on the HTTP Context, and return true if any of their claims match the ones we say are “Allowed”. This concept has described in more detail by <a href="https://andrewlock.net/creating-a-custom-feature-filter-adding-feature-flags-to-an-asp-net-core-app-part-4/">Andrew Lock</a>, I have modernised it and made it accept <em>any</em> instead of <em>all</em>.</p>
<p>Once we have our filter all configured, we need to tell the feature manager to use it. For that, we need to update the registration.</p>
<div><pre><code data-lang="csharp">services.AddFeatureManagement(<span>this</span>.configuration)
    .AddFeatureFilter&lt;ClaimsFeatureFilter&gt;();
</code></pre></div><p>Finally, we our advanced search functionality in production without breaking the existing “simple” search for our existing users!</p>
<p>What if we want to be less granular, and rely on mutli-tenancy to help us test our functionality? This actually has more underlying benefits than just testing, we can charge some “tenants” extra and enable functionality for them too, but for the purpose of this example, let’s stick to using tenants for testing purposes.</p>
<h4 id="feature-toggling-on-a-particular-tenant">Feature Toggling on a particular tenant</h4>
<p>For this example, I would like to consider 3 separate tenants, all using the same code and the same databases, the tenant separation is at an application-logic level, rathern than infrastructure level. Those tenants will be:</p>
<ul>
<li>Actual Real Live Users, or <code>ARLU</code> as an identifier</li>
<li>Manual Annoying Tests, or <code>MAT</code> as an identifier</li>
<li>Automatic Awesome Testing, or <code>AAT</code> as an identifier</li>
</ul>
<p>I’ve made the distinction between <code>MAT</code> and <code>AAT</code> because we may disable certain things for automated testing, like actually purchasing items, or transferring money etc. Whereas we may want to do that for the manual tests because a human can make sensible decisions.</p>
<p>Ok, so we have our tenants defined, now, I only want to enable our new “AdvancedSearch” feature for <code>MAT</code> and <code>AAT</code>, leaving <code>ARLU</code> to be using the old search still.</p>
<div><pre><code data-lang="json">{
  <span>"FeatureManagement"</span>: {
    <span>"AdvancedSearch"</span>: {
      <span>"EnabledFor"</span>: [
        {
          <span>"Name"</span>: <span>"Tenants"</span>,
          <span>"Parameters"</span>: {
            <span>"AllowedTenants"</span>: [<span>"MAT"</span>,<span>"AAT"</span>]
          }
        }
      ]
    }
  }
}
</code></pre></div><p>Similar to our claims testing, we’ll need some settings so that our application can understand this configuration.</p>
<div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>TenantFilterSettings</span>
{
    <span>public</span> <span>string</span>[] AllowedTenants { <span>get</span>; <span>set</span>; }
}
</code></pre></div><p>So far, so good. It’s almost identical to our <code>ClaimsFilterSettings</code>, now, we’ll also need a custom feature filter, but this time we’ll want a <code>ContextualFeatureFilter</code> which will include some additional context when making a decision. For this to work, we’ll actually need to define our context:</p>
<div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>TenantFeatureContext</span>
{
    <span>public</span> <span>string</span> TenantId { <span>get</span>; <span>set</span>; }
}
</code></pre></div><p>This class will be used to tell the feature filter what the current tenant is. Now we can implement our <code>ContextualFeatureFilter</code>:</p>
<div><pre><code data-lang="csharp"><span>[FilterAlias("Tenants")]</span>
<span>public</span> <span>class</span> <span>TenantsFeatureFilter</span> : IContextualFeatureFilter&lt;TenantFeatureContext&gt;
{
    <span>public</span> Task&lt;<span>bool</span>&gt; EvaluateAsync(FeatureFilterEvaluationContext featureFilterContext, TenantFeatureContext appContext)
    {
        <span>var</span> settings = ConfigurationBinder.Get&lt;TenantFilterSettings&gt;(featureFilterContext.Parameters);

        <span>//Again, we're not doing anything async here
</span><span></span>        <span>return</span> Task.FromResult(settings.AllowedTenants.Contains(appContext.TenantId));
    }
}
</code></pre></div><p>You’ll notice we’re now implementing a generic <code>IContextualFeatureFilter</code> interface which makes our <code>EvaluateAsync</code> method take our context as a parameter.</p>
<p>We’ll also need to let the feature manager know about or feature manager before it will be used:</p>
<div><pre><code data-lang="csharp">services.AddFeatureManagement(<span>this</span>.configuration)
    .AddFeatureFilter&lt;TenantsFeatureFilter&gt;();
</code></pre></div><p>However, unlike the <code>ClaimsFeatureFilter</code>, this won’t work out of the box. The feature manager has no way of knowing what the <code>TenantFeatureContext</code> actually is.</p>
<p>We need to explicitly pass through the context when checking if the feature is enabled.</p>
<div><pre><code data-lang="csharp"><span>var</span> tenantId = <span>"MAT"</span>; <span>//May actually be pulled from message metadata, parameters from a HTTP request, a database call, anywhere.
</span><span></span><span>var</span> context = <span>new</span> TenantFeatureContext {TenantId = tenantId};
</code></pre></div><p>Finally, we need to change how we check if the feature is enabled by including the context:</p>
<div><pre><code data-lang="csharp"><span>if</span>(<span>await</span> featureManager.IsEnabledAsync(<span>"AdvancedSearch"</span>, context)
{
    <span>// execute the advanced search
</span><span></span>}
<span>else</span>
{
    <span>// execute the simple search instead
</span><span></span>}
</code></pre></div><p>All that’s different now, is we’re using an overload of <code>IsEnabledAsync</code> and including our context.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>Now we can turn features on/off for specific users, in specific contexts, we can comfortably test in production without our users seeing a broken implementation, half-baked code, or a feature that is solely used for testing purposes. It may add a little noise to your codebase, but having this flexibility in your system is incredibly powerful and worth the extra code.</p>
<p>It’s worth keeping in mind that once a new feature is enabled for <em>everyone</em>, it may be worth going back and removing the feature toggle. If it’s always on, it’s just extra code that you have to maintain. Remember to delete it early if you can.</p>
<ul>
  
</ul>

    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>