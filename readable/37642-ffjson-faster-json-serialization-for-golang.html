<!DOCTYPE html>
<html lang="en">
<head>
    <title>
ffjson: faster JSON serialization for Golang -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>ffjson: faster JSON serialization for Golang</h1>
    <div><p><small>Published March 31st, 2014</small></p><div><p><a href="https://github.com/pquerna/ffjson">ffjson</a> is a project I have been hacking on for making JSON serialization faster in the Go programing language. <code class="language-text">ffjson</code> works by generating static code for Go&#x2019;s JSON serialization interfaces. Fast binary serialization frameworks like <a href="http://kentonv.github.io/capnproto/">Cap&#x2019;n Proto</a> or <a href="https://code.google.com/p/gogoprotobuf/">Protobufs</a> also use this approach of generating code. Because <code class="language-text">ffjson</code> is serializing to JSON, it will never be as fast as some of these other tools, but it can beat the builtin <a href="http://golang.org/pkg/encoding/json/">encoding/json</a> easily.</p>
<h2>Benchmarks</h2> <p>The first example benchmark is <a href="https://github.com/pquerna/ffjson/blob/master/tests/goser/ff/goser.go#L18">Log structure</a> that <a href="http://www.cloudflare.com/">CloudFlare</a> uses. CloudFlare open sourced these benchmarks under the <a href="https://github.com/cloudflare/goser">cloudflare/goser</a> repository, which benchmarks several different serialization frameworks.</p>
<p><img src="/assets/posts/ffjson/goser.png"></p>
<p>Under this benchmark <code class="language-text">ffjson</code> is <strong>1.91x faster</strong> than <code class="language-text">encoding/json</code>.</p>
<h2>go.stripe</h2>
<p><a href="https://github.com/drone/go.stripe">go.stripe</a> contains a complicated <a href="https://github.com/pquerna/ffjson/blob/master/tests/go.stripe/ff/customer.go#L7">structure for its Customer object</a> which contains many sub-structures.</p>
<p><img src="/assets/posts/ffjson/gostripe.png"></p>
<p>For this benchmark <code class="language-text">ffjson</code> is <strong>2.11x faster</strong> than <code class="language-text">encoding/json</code>.</p>
<h2>Try it out</h2>
<p>If you have a Go source file named <code class="language-text">myfile.go</code>, and your <code class="language-text">$GOPATH</code> environment variable is set to a reasonable value, trying out <code class="language-text">ffjson</code> is easy:</p>
<div class="gatsby-highlight"> <pre class="language-sh"><code class="language-sh">go get -u github.com/pquerna/ffjson
ffjson myfile.go</code></pre> </div>
<p><code class="language-text">ffjson</code> will generate a <code class="language-text">myfile_ffjson.go</code> file which contains implementations of <code class="language-text">MarshalJSON</code> for any structures found in <code class="language-text">myfile.go</code>.</p>
<h2>Background: Serialization @ GoSF</h2>
<p>At the last <a href="http://www.meetup.com/golangsf/">GoSF</a> meetup, <a href="https://twitter.com/fullung">Albert Strasheim</a> from CloudFlare gave a presentation on <a href="http://www.slideshare.net/albertstrasheim/serialization-in-go">Serialization in Go</a>. The presentation was great &#x2014; it showed how efficient binary serialization can be in Go. But what made me unhappy was how <strong>slow</strong> JSON was:</p>
<p><img src="/assets/posts/ffjson/goser-benchmarks.png"></p>
<h2>Why is JSON so slow in Go?</h2>
<p>All of the competing serialization tools generate static code to handle data. On the other hand, Go&#x2019;s <code class="language-text">encoding/json</code> uses <a href="http://golang.org/pkg/reflect/">runtime reflection</a> to iterate members of a <code class="language-text">struct</code> and detect their types. The binary serializers generate static code for the exact type of each field, which is much faster. In CPU profiling of <code class="language-text">encoding/json</code> it is easy to see significant time is spent in reflection.</p>
<p>The reflection based approach taken by <code class="language-text">encoding/json</code> is great for fast development iteration. However, I often find myself building programs that serializing millions of objects with the same structure type. For these kinds of cases, taking a trade off for a more brittle code generation approach is worth the 2x or more speedup. The downside is when using a code generation based serializer, if your structure changes, you need to regenerate the code.</p>
<p>Last week we had a hack day at work, and I decided to take a stab at making my own code generator for JSON serialization. I am not the first person to look into this approach for Go. <a href="https://twitter.com/benbjohnson">Ben Johnson</a> created <a href="https://github.com/benbjohnson/megajson">megajson</a> several months ago, but it has limited type support and doesn&#x2019;t implement the existing <code class="language-text">MarshalJSON</code> interface.</p>
<h2>Background: Leveraging existing interfaces</h2>
<p>Go has an interface defined by <code class="language-text">encoding/json</code>, which if a type implements, it will be used to serialize the type to JSON:</p>
<div class="gatsby-highlight"> <pre class="language-go"><code class="language-go"><span class="token keyword">type</span> Marshaler <span class="token keyword">interface</span> <span class="token punctuation">{</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">type</span> Unmarshaler <span class="token keyword">interface</span> <span class="token punctuation">{</span> <span class="token function">UnmarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span></code></pre> </div>
<p>As a goal for <code class="language-text">ffjson</code> I wanted users to get improved performance without having to change any other parts of their code. The easiest way to do this is by adding a <code class="language-text">MarshalJSON</code> method to a structure, and then <code class="language-text">encoding/json</code> would be able find it via reflection.</p>
<h2>Example</h2>
<p>The simplest example of implementing <code class="language-text">Marshaler</code> would be something like the following, given a type <code class="language-text">Foo</code> with a single member:</p>
<div class="gatsby-highlight"> <pre class="language-go"><code class="language-go"><span class="token keyword">type</span> Foo <span class="token keyword">struct</span> <span class="token punctuation">{</span> Bar <span class="token builtin">string</span>
<span class="token punctuation">}</span></code></pre> </div>
<p>You could have a <code class="language-text">MarshalJSON</code> like the following:</p>
<div class="gatsby-highlight"> <pre class="language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>Foo<span class="token punctuation">)</span> <span class="token function">MarshalJSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">`{&quot;Bar&quot;:`</span> <span class="token operator">+</span> f<span class="token punctuation">.</span>Bar <span class="token operator">+</span> <span class="token string">`}`</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span></code></pre> </div>
<p>This example has many potential bugs, like <code class="language-text">.Bar</code> not being escaped properly, but it would automatically be used by <code class="language-text">encoding/json</code>, and avoids many reflection calls.</p>
<h2>First Attempt: Using go/ast</h2>
<p>During our hack day I started by using the <a href="http://golang.org/pkg/go/ast/">go/ast</a> module as a way to extract information about structures. This allowed rapid progress, and at my demo for the hack day I had a working prototype. This version was about 25% faster than <code class="language-text">encoding/json</code>. However, I quickly found that the AST interface was too limiting. For example, a type is just represented as a simple string in the AST module. Determining if that type implements a specific interface is not easily possible. Because types are just strings to the AST module, complex types like <code class="language-text">map[string]CustomerType</code> were up to me to parse by hand.</p>
<p>The day after the hack day I was frustrated with the situation. I started thinking about alternatives. Runtime reflection has many advantages. One of the most important is how easily you can tell what a type implements, and make code generation decisions based on it. In other languages you can do code generation at runtime, and then load that code into a virtual machine. Because Go is statically compiled, this isn&#x2019;t possible. In C++ you could use templates for many of these types of problems too, but Go doesn&#x2019;t have an equivalent. I needed a way to do runtime reflection, but at compile time.</p>
<p>Then I had an idea. Inception: <strong>Generate code to generate more code.</strong></p>
<h2>Inception</h2>
<p>I wanted to keep the simple user experience of just invoking <code class="language-text">ffjson</code>, and still generate static code, but somehow use reflection to generate that code. After much rambling in IRC, I conjoured up this workflow:</p>
<p><img src="/assets/posts/ffjson/flow.png"></p>
<ol>
<li>User executes <code class="language-text">ffjson</code></li>
<li><code class="language-text">ffjson</code> parses input file using <code class="language-text">go/ast</code>. This decodes the package name and structures in the file.</li>
<li><code class="language-text">ffjson</code> generates a temporary <code class="language-text">inception.go</code> file which imports the package and structures previously parsed.</li>
<li><code class="language-text">ffjson</code> executes <code class="language-text">go run</code> with the temporary <code class="language-text">inception.go</code> file.</li>
<li><code class="language-text">inception.go</code> uses runtime reflection to decode the users structures.</li>
<li><code class="language-text">inception.go</code> generates the final static code for the structures.</li>
</ol>
<h2>It worked!</h2>
<p>The inception approach worked well. The more powerful <code class="language-text">reflect</code> module allowed deep introspection of types, and it was much easier to add support for things like Maps, Arrays and Slices.</p>
<h2>Performance Improvements</h2>
<p>After figuring out the inception approach, I spent some time looking for quick performance gains with <a href="http://blog.golang.org/profiling-go-programs">the profiler</a>.</p>
<h2>Alternative Marshal interface</h2>
<p>I observed poor performance on JSON structs that contained other structures. I found this to be because of the interface of <code class="language-text">MarshalJSON</code> returns a <code class="language-text">[]byte</code>, which the caller would generally append to their own <code class="language-text">bytes.Buffer</code>. I created a new interface that allows structures to append to a <code class="language-text">bytes.Buffer</code>, avoiding many temporary allocations:</p>
<div class="gatsby-highlight"> <pre class="language-go"><code class="language-go"><span class="token keyword">type</span> MarshalerBuf <span class="token keyword">interface</span> <span class="token punctuation">{</span> <span class="token function">MarshalJSONBuf</span><span class="token punctuation">(</span>buf <span class="token operator">*</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span></code></pre> </div>
<p>This landed in <a href="https://github.com/pquerna/ffjson/pull/3">PR#3</a>, and increased performance by 18% for the <code class="language-text">goser</code> structure. <code class="language-text">ffjson</code> will use this interface on structures if it is available, if not it can still fall back to the standard interface.</p>
<h2>FormatBits that works with bytes.Buffer</h2>
<p>When converting a integer into a string, the <code class="language-text">strconv</code> module has functions like <a href="http://golang.org/pkg/strconv/#AppendInt">AppendInt</a>. These functions require a temporary <code class="language-text">[]byte</code> or a string allocation. By creating a <code class="language-text">FormatBits</code> function that can convert integers and append them directly into a <code class="language-text">*bytes.Buffer</code>, these allocations can be reduced or removed.</p>
<p>This landed in <a href="https://github.com/pquerna/ffjson/pull/5">PR#5</a>, and gave a 21% performance improvement for the <code class="language-text">goser</code> structure.</p>
<h2>What&#x2019;s next for ffjson</h2>
<p>I welcome feedback from the community about what they would like to see in <code class="language-text">ffjson</code>. What exists now is usable, but I know there are few more key items to make <code class="language-text">ffjson</code> great:</p>
<ol>
<li><strong>Embedded Anonymous Structures:</strong> <code class="language-text">ffjson</code> doesn&#x2019;t currently handle embedded structures perfectly. I have a plan to fix it, I just need some time to implement it.</li>
<li><strong>More real world structures for benchmarks</strong>: If you have an app doing high volume JSON, I would love to include an example in <code class="language-text">ffjson</code> to highlight any performance problems with real world structures as much as possible. </li>
<li><strong>Unmarshal Support</strong>: This will require writing a custom scanner/lexer, which is a larger project.</li>
</ol>
<p>If you have any other ideas, I am happy to discuss them on the <a href="https://github.com/pquerna/ffjson">Github project page for ffjson</a></p></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>