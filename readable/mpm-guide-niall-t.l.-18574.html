<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>mpm guide - niall t.l.</h1>
        <p>
Reading time: 32-40 minutes        </p>
        <p><a href="https://nialltl.neocities.org/articles/mpm_guide.html">https://nialltl.neocities.org/articles/mpm_guide.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/mls-mpm_37k.gif" alt="a real-time MPM fluid simulation made in Unity using the techniques outlined in this page" title="a real-time MPM fluid simulation made in Unity using the techniques outlined in this page"></p>
<p><em>a real-time 40,000 particle MPM fluid simulation made in Unity using techniques outlined in this page</em></p>
<p><strong>source code for this article: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>

<hr>

<p>i‚Äôve been playing around with particle-based simulations for a while now, and found that some approaches feel a little more esoteric than others. one i had a hard time getting started with is the material point method (MPM).</p>
<p>i‚Äôm going to give a very broad outline of the family of methods MPM comes from, just to contextualise it a bit. i‚Äôll then give some bare-bones example implementations, and pointers towards where i‚Äôve found most helpful to learn more.</p>
<p>compared to a few years ago, there‚Äôs really great literature on the theory behind MPM, but i always found actual implementation references hard to come by, or webbed up in massive simulation libraries.</p>
<p>my open-source MIT licensed implementations are all single-file (almost-)self contained examples. hopefully this‚Äôll help bridge the gap a little: <strong>source code for this article: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>
<p><strong>note:</strong> deformable simulation is a huge field. my interest is mostly motivated by real-time interactive applications and my mode of understanding is more gestural than mathematically rigorous. i‚Äôm going to be very hand-wavey and essentialist. buuuut, hopefully this can act as a little nudge in a less confusing direction if you‚Äôd like to play around with these ideas.</p>

<hr>

<p>throughout this page i‚Äôll be referencing existing papers and building an implementation out of them. i won‚Äôt really delve too deeply into the theoretical "why"s of how MPM works, but more why i make certain choices. for a more solid backing in what makes MPM tick, here‚Äôs a list of papers and resources i‚Äôve found the most helpful to learn from:</p>
<ul>
<li>
<p>MPM Course (SIGGRAPH 2016 notes):</p>
<ul>
<li><a href="http://mpm.graphics/" target="_blank">http://mpm.graphics</a></li>
<li>absolute behemoth of a walkthrough. probably the best bottom-up explanation of MPM i‚Äôve found! i‚Äôll reference this throughout my examples.</li>
</ul>
</li>
<li>
<p>APIC original paper:</p>
<ul>
<li><a href="https://www.math.ucla.edu/~jteran/papers/JSSTS15.pdf" target="_blank">https://www.math.ucla.edu/~jteran/papers/JSSTS15.pdf</a></li>
<li>a useful reference for the actual implementation of grid-particle transfers that are used in MLS-MPM.</li>
</ul>
</li>
<li>
<p>Taichi MPM implementation, slides &amp; notes</p>
<ul>
<li><a href="https://github.com/yuanming-hu/taichi_mpm/" target="_blank">https://github.com/yuanming-hu/taichi_mpm/</a></li>
<li>the PDF slides and slides with notes are <em>really</em> helpful and give a great side-by-side comparison of MPM and MLS-MPM.</li>
</ul>
</li>
<li>
<p>MLS-MPM original paper:</p>
<ul>
<li><a href="https://www.yzhu.io/projects/siggraph18_mlsmpm_cpic/index.html" target="_blank">https://www.yzhu.io/projects/siggraph18_mlsmpm_cpic/index.html</a></li>
<li>this might be a bit overwhelming to launch straight into without implementing standard MPM first, but i‚Äôd recommend the section ‚Äúfrom MPM to MLS-MPM‚Äù.</li>
</ul>
</li>
<li>
<p>MLS-MPM implemented in 88 lines of c++</p>
<ul>
<li><a href="https://github.com/yuanming-hu/taichi_mpm/blob/master/mls-mpm88-explained.cpp" target="_blank">https://github.com/yuanming-hu/taichi_mpm/blob/master/mls-mpm88-explained.cpp</a></li>
<li>this is the comments-expanded version of Yuanming Hu‚Äôs original 88-line implementation.</li>
<li>similar in structure to our Part 2 implementation, but with a Disney-style constitutive model for snow. useful to see how they differ!</li>
</ul>
</li>
<li>
<p>a maintained curated list of current MPM research</p>
<ul>
<li><a href="https://www.seas.upenn.edu/~cffjiang/mpm.html" target="_blank">https://www.seas.upenn.edu/~cffjiang/mpm.html</a></li>
<li>nice to see a lineage of MPM papers, and might give you some ideas on how to extend what you see on this page.</li>
</ul>
</li>
</ul>

<p><strong>note:</strong> this page contains <a href="#appendix__simulation_methods_and_their_general_vibes_450">an appendix</a> with a guide to the acronym soup that permeates the physics-simulation world. you can consult it to get a quick overview of what various techniques are all about.</p>

<hr>

<p>MPM is a hybrid Lagrangian-Eulerian method that‚Äôs really good at simulating a wide range of physical phenomena. you might have first come across MPM through <a href="https://www.youtube.com/watch?v=9H1gRQ6S7gg" target="_blank">this viral sensation</a> from Disney Research. in it, they showcase an implementation of a material model for snow, simulated using MPM. i think it‚Äôs a good introduction to the kind of versatility MPM affords.</p>
<p>MPM was originally introduced as an extension of FLIP, to tackle problems in computational solid dynamics. it takes the simulation framework of PIC / FLIP and generalises it to basically anything you can describe with a constitutive equation. solids, liquids, gases, squishy things, you name it.</p>
<p><strong>note:</strong> <em>constitutive equations</em> describe relationships between quantities that characterise the material you want to model. they often include terms like stress, strain, pressure, density, elasticity, etc.</p>
<p>so. as of writing this, a lot of existing MPM literature builds its examples out from a simple material model, like an isotropic elastic material using something like a Neo-Hookean constitutive model.</p>
<p>if you‚Äôre anything like me, you have / had no idea what any of them were talking about. i don‚Äôt know how common a path it is to come to MPM via other simulation mentalities, but my experience beforehand was mostly other fully particle based methods and i‚Äôd never had to confront much continuum mechanics.</p>
<p>i‚Äôm going to build out an MPM simulation incrementally, with the end goal of a simple little fluid simulation, assuming some prior knowledge of particle-based methods. specifically i‚Äôm going to be implementing a variation of <em>MLS-MPM</em>, and hack around with it a little to try and get something working real-time.</p>
<hr>
<h2><a id="overview_of_the_playing_field_62"></a>overview of the playing field</h2>
<p>to simulate any sort of matter, you need to discretise it in some way. this basically just means deciding on a concrete way to describe what the matter is made up of in terms that can be worked on numerically. this could be like a point cloud (think: particles), a discrete grid of values (think: voxels), or a mesh that describes an area/volume of the surface you‚Äôre modeling (think: wireframe vaporwave album covers).</p>
<p>broadly speaking, if you‚Äôre wanting to simulate something squishy / fluid-like / deformable, there are usually 3 viewpoints that different simulation models take.</p>
<ul>
<li>


<p>on one end of the spectrum, if the underlying spatial representation of your matter deforms along with its motion, you're using a <em>Lagrangian</em> representation. examples of this would be SPH and PBF, where the spatial representation is the makeup of the particles themselves, or Lagrangian FEM, where the grid / mesh itself deforms under motion.
</p>

</li>
<li>

<p>on the other end, if you choose a completely fixed reference frame, like a regular grid, you're using an Eulerian representation. you divide the domain into fixed chunks, and evaluate continuous field quantities like velocity and density at fixed points on the grid (usually edges or faces). examples of this would be are the Marker-and-Cell method and Lattice-Boltzmann methods.</p>

</li>
<li>

<p>then there‚Äôs the ~liminal space~ betwixt. <em>Hybrid</em> methods basically pick and choose between these two ways of looking at the domain. whatever perspective a particular model takes at any given time is basically just whatever works best for the problem it‚Äôs trying to solve.</p>


</li>
</ul>

<p>you can find a more thorough exposition of the differences of these reference frames <a href="https://en.wikipedia.org/wiki/Lagrangian_and_Eulerian_specification_of_the_flow_field" target="_blank">here.</a></p>

<p>the reason Hybrid methods are even a thing is that some aspects of physical simulation are just generally more straightforward or efficient to compute from a certain reference frame.</p>

<p>for example, particles are good for mass conservation and handling advection. grids are great for forcing incompressibility for fluids using pressure projection, and it‚Äôs significantly easier to evaluate gradients on grids with interpolation methods and finite differences.</p>
<hr>

<p>with that in mind, let‚Äôs say we want to simulate a fluid. to start with, we‚Äôll use PIC, as it‚Äôs one of the first Hybrid approaches to appear on the scene.</p>
<p>PIC works out the box, but its major problem is that it‚Äôs really dissipative. in order to evaluate velocity it has to interpolate data back and forth between the particles and the underlying grid a bunch. because this is never perfect, a little bit of information is lost every time. the result is that a lot of sharp high-res detail of the simulation gets smoothed out, and everything‚Äôs very mushy. stable, but mushy:</p>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/pic.gif" alt="Particle In Cell advection showing high dissipation" title="Particle In Cell advection showing high dissipation"></p>
<p><em>Particle In Cell advection showing high dissipation</em></p>
<p>yeuch! look at all that artificial viscosity. what if we want something more turbulent, and less viscous?</p>
<p>some time later, FLIP is developed. FLIP is just an extension to PIC that uses a slightly different method of advecting particles. it basically feeds a little bit of a particle‚Äôs raw individual velocity into the advection routine. most FLIP simulations use a blending value to control how much of this velocity to feed back in, tuning it to keep things stable. here‚Äôs that same simulation above using a blending value of 0.95 ‚Äî 95% FLIP velocity, 5% PIC.</p>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/flip.gif" alt="FLIP fluid simulation showing more turbulent motion" title="FLIP fluid simulation showing more turbulent motion"></p>
<p><em>FLIP fluid simulation showing more turbulent motion</em></p>
<p><strong>sidenote:</strong> if you‚Äôre familiar with Smoothed Particle Hydrodynamics, think of this PIC-FLIP mixing as being a little like XSPH. it‚Äôs pretty much artificial viscosity made from a smooth-average / ‚Äúblur‚Äù of the velocity field. here the blurred contribution comes from PIC, and the higher resolution per-particle contribution comes from FLIP.</p>
<p>FLIP is a very straightforward extension to PIC that lets you get a much wider range of fluid motion. HOWEVER, it‚Äôs still plagued by some big issues. FLIP simulations tend to be a bit less stable than standard PIC, and prone to weird noise. as an example, look at the jittery surface of the above gif. the free surface here is particularly noisy because there‚Äôs fewer particles to scatter data to the grid. as a result, the errors are more pronounced.</p>
<p>good news: the problems with FLIP have recently been pretty much solved! see the Affine Particle In Cell method (APIC), or a high-order generalisation of it, PolyPIC. these approaches one-up FLIP‚Äôs approach of mixing more info back into the grid, by storing a little affine matrix at each particle that holds a little extra context for use in our particle-grid scattering.</p>
<p>the reason this is relevant to MPM is that one recent development, Moving Least Squares MPM (MLS-MPM) makes use of APIC-style transfers at its core. i‚Äôll be implementing MLS-MPM in my incremental simulations, because it‚Äôs both more efficient and actually <em>simpler</em> than standard MPM! wow!</p>
<p><strong>why skip straight to MLS-MPM, rather than standard MPM first?</strong></p>
<p>because it‚Äôs simpler! standard MPM requires you to calculate both grid interpolation functions and their gradients, for each particle. MLS-MPM allows you to do away with gradients completely. for me, the gradient stuff feels a bit like conceptual baggage, and is more computationally intensive. the MPM course i linked to above is a good reference for further info.</p>
<p>at this point, i‚Äôm going to pivot over to MLS-MPM from an implementation perspective. as we get further in, we‚Äôll see how all that we‚Äôve covered in this section links in.</p>

<hr>

<p>so, off we pop. our goal is to start by trying to make what i guess could be MPM‚Äôs ‚Äúhello world‚Äù, a little elastic shape.</p>
<p><strong>more specifically:</strong> i‚Äôm going to be building a 2D simulation of an elastic material, using MLS-MPM with quadratic b-spline weights under an explicit time integration scheme. i‚Äôll be building it out as single-file examples in Unity, using Unity‚Äôs data-oriented language <em>High-Performance C#</em>.</p>
<p>i think the most readable intro to the structure of MPM i know of is the SIGGRAPH 2016 MPM course. however, it doesn‚Äôt cover MLS-MPM. i find the original MLS-MPM paper a bit overwhelming to just drop into, so instead i‚Äôm going to reference the structure of the course pdf and then specify wherever i switch over to MLS-MPM.</p>
<hr>
<h2><a id="simulation_structure_121"></a>simulation structure</h2>
<p>to set the scene a little, here‚Äôs an overview of the structure of our data. we need particles and a grid. here is the minimum required for a basic MLS-MPM sim:</p>
<!-- HTML generated using hilite.me --><div><pre><span>struct</span> <span>Particle</span> <span>{</span>
    <span>float2</span> <span>x;</span> <span>// position</span>
    <span>float2</span> <span>v;</span> <span>// velocity</span>
    <span>float</span> <span>mass;</span>
<span>};</span>
</pre></div>

<p>our particles‚Äô mass will stay constant throughout the simulation. it becomes more relevant if you‚Äôre doing multi-phase simulation, but in all my examples it‚Äôll just be set to <code>1</code>.</p>
<!-- HTML generated using hilite.me --><div><pre><span>struct</span> <span>Cell</span> <span>{</span>
    <span>float2</span> <span>v;</span> <span>// velocity</span>
    <span>float</span> <span>mass;</span>
<span>}</span>
</pre></div>
<p>our grid is made up of individual cells. it‚Äôs literally just a big array of them. in the implementation below, i use a 1D grid for efficiency reasons, and remap to 2D indices when required. you can easily do this with a 2D/3D array of cells instead if you like.</p>
<p>the size of our grid determines the resolution of our simulation. if we choose a grid size of, say, 32 by 32, then our particles‚Äô coordinates will range from <code>(0, 0)</code> to <code>(31, 31)</code>. it‚Äôs common to use a power of 2 for the grid size, for performance reasons when parallelising. i‚Äôm usually using a grid size of 64 in the gifs on this page.</p>
<p><strong>conceptual clearup</strong>: the grid in MPM is cleared at the start of every frame. it‚Äôs just a scratch-pad for calculating certain quantities, and you chuck it away at the end of each simulation step. so, none of the values in our Cell struct are constant throughout the simulation.</p>
<p><strong>note:</strong> the above is the near-minimum for a getting a classical MPM simulation moving. if we want more sophisticated behaviour (we do), we‚Äôll likely need to keep track of a deformation gradient matrix at each particle, and some notion of their volume. when we move on to using MLS-MPM, we‚Äôll add a little bit more info still. namely, each particle needs to store an affine momentum matrix we talked about above for APIC.</p>
<p>in traditional MPM, you would also store a force vector at each cell. with MLS-MPM, you can get rid of explicitly it entirely, and instead fuse it together with the velocity update!</p>
<hr>
<h2><a id="simulation_loop_152"></a>simulation loop</h2>
<p>below is an outline of the MLS-MPM algorithm.</p>
<p>at each step, i‚Äôve included a brief note on what the algorithm‚Äôs trying to do, with inline references to our <a href="#references_and_useful_links_18">fave papers</a>. i find it helpful to look at the broad strokes of how MPM actually runs around the data, before diving into the specifics of how each step specifically transforms it. hopefully it‚Äôll clear up what happens where.</p>
<p>for a more detailed step-by-step walkthrough, i recommend looking at chapter 10.5, ‚ÄúMPM Scheme: Full Algorithm‚Äù in the MPM course. that outlines the procedure of standard MPM. from there, look at section 4, ‚ÄúFrom MPM to MLS-MPM‚Äù in the <a href="#references_and_useful_links_18">original MLS-MPM paper</a>.</p>

<!-- HTML generated using hilite.me --><div><pre><span>Particle[]</span> <span>particles;</span>
<span>Cell[]</span> <span>grid;</span>

<span>void</span> <span>initialise</span><span>()</span> <span>{</span>
    <span>// 1.  initialise your grid - fill your grid array with (grid_res * grid_res) cells.</span>
    
    <span>// 2. create a bunch of particles. set their positions somewhere in your simulation domain.</span>
    <span>// initialise their deformation gradients to the identity matrix, as they're in their undeformed state.</span>

    <span>// 3. optionally precompute state variables e.g. particle initial volume, if your model calls for it</span>
<span>}</span>

<span>void</span> <span>each_simulation_step</span><span>()</span> <span>{</span>
    <span>// 1. reset our scratch-pad grid completely</span>
    <span>foreach</span> <span>(</span><span>var</span> <span>cell</span> <span>in</span> <span>grid)</span> <span>{</span>
        <span>// zero out mass and velocity for this cell</span>
    <span>}</span>

    <span>// 2. particle-to-grid (P2G). </span>
    <span>// goal: transfers data from particles to our grid</span>
    <span>foreach</span> <span>(</span><span>var</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
        <span>// 2.1: calculate weights for the 3x3 neighbouring cells surrounding the particle's position </span>
        <span>// on the grid using an interpolation function</span>

        <span>// 2.2: calculate quantities like e.g. stress based on constitutive equation</span>

        <span>// 2.3:</span>
        <span>foreach</span> <span>(</span><span>var</span> <span>cell</span> <span>in</span> <span>particle_neighbourhood)</span> <span>{</span>
            <span>// scatter our particle's momentum to the grid, using the cell's interpolation weight calculated in 2.1</span>
        <span>}</span>
    <span>}</span>

    <span>// 3. calculate grid velocities</span>
    <span>foreach</span> <span>(</span><span>var</span> <span>cell</span> <span>in</span> <span>grid)</span> <span>{</span>
        <span>// 3.1: calculate grid velocity based on momentum found in the P2G stage</span>

        <span>// 3.2: enforce boundary conditions</span>
    <span>}</span>

    <span>// 4. grid-to-particle (G2P). </span>
    <span>// goal: report our grid's findings back to our particles, and integrate their position + velocity forward</span>
    <span>foreach</span> <span>(</span><span>var</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
        <span>// 4.1: update particle's deformation gradient using MLS-MPM's velocity gradient estimate</span>
        <span>// Reference: MLS-MPM paper, Eq. 17</span>

        <span>// 4.2: calculate neighbouring cell weights as in step 2.1.</span>
        <span>// note: our particle's haven't moved on the grid at all by this point, so the weights will be identical</span>

        <span>// 4.3: calculate our new particle velocities</span>
        <span>foreach</span> <span>(</span><span>var</span> <span>cell</span> <span>in</span> <span>particle_neighbourhood)</span> <span>{</span>
            <span>// 4.3.1: </span>
            <span>// get this cell's weighted contribution to our particle's new velocity</span>
        <span>}</span>

        <span>// 4.4: advect particle positions by their velocity</span>
    <span>}</span>
<span>}</span>
</pre></div>


<hr>

<p>ok, so at this point, a lot of the actual details are pretty occluded. i think the above-mentioned papers do a pretty good job of filling in the conceptual details. so let‚Äôs look at fleshing it out a little.</p>
<p>i‚Äôve annotated the source code with references to the papers that give more detail, so i think learning from a combination of these references and the source itself will be the best way to work your way through it.</p>
<p>the first version of our MPM implementation just creates some particles initialised with random velocities, and the MPM takes over the rest and moves them around a wee bit.</p>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/mpm_first_pass.gif" alt="MPM simulation with no deformation model" title="MPM simulation with no deformation model"></p>
<p><em>MPM with no deformation model, just randomised initial velocities</em></p>
<p><strong>source code: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>
<p>this is a first blush with how things generally move in MLS-MPM, using APIC-style grid transfers. it completely omits anything to do with modeling deformations, but we‚Äôll build from here.</p>
<p>i use quadratic interpolation for calculating the cell weights, which evalates the 3x3 cell-neighbourhood of each particle. it‚Äôs a good balance between performance and stability. you‚Äôll get more physically accurate and stable simulations if you use higher order interpolation over bigger stencil sizes. but quadratic interpolation strikes a nice balance of being cheap to compute and a improving significantly on linear interpolation behaviour-wise.</p>
<p>i‚Äôm using a neat trick for calculating the weights that i first came across in Yuangmin Hu‚Äôs <a href="#references_and_useful_links_18">88-line MLS-MPM example</a>. it just stores 3 float2‚Äôs and cross-multiplies them when iterating over the 9 cells surrounding a given particle. depending on how you end up arranging your cell memory accesses, you may want to lay things out differently.</p>

<hr>

<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/mpm_neohookean.gif" alt="MPM simulation with isotropic elasticity using a Neo-Hookean model" title="MPM simulation with isotropic elasticity using a Neo-Hookean model"></p>
<p><em>MPM simulation with isotropic elasticity using a Neo-Hookean model</em></p>
<p><strong>source code: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>
<p>we‚Äôre now actually making use of the deformation gradient and affine momentum matrix we‚Äôd set up for part 1. as in part 1, references to derivations are included inline in the source. just to get your bearings, here‚Äôs a stripped back focus on where the majority of the actual material modelling is implemented:</p><!-- HTML generated using hilite.me --><div><pre><span>foreach</span> <span>(Particle</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
    <span>var</span> <span>F</span> <span>=</span> <span>p.F;</span> <span>// deformation gradient</span>

    <span>// MPM course page 13, "Kinematics Theory"</span>
    <span>var</span> <span>J</span> <span>=</span> <span>math.determinant(F);</span>
    <span>var</span> <span>volume</span> <span>=</span> <span>p.volume_0</span> <span>*</span> <span>J;</span>

    <span>// required terms for Neo-Hookean model (eq. 48, MPM course)</span>
    <span>var</span> <span>F_T</span> <span>=</span> <span>math.transpose(F);</span>
    <span>var</span> <span>F_inv_T</span> <span>=</span> <span>math.inverse(F_T);</span>
    <span>var</span> <span>F_minus_F_inv_T</span> <span>=</span> <span>F</span> <span>-</span> <span>F_inv_T;</span>
    
    <span>// eq. 48, MPM course</span>
    <span>var</span> <span>P_term_0</span> <span>=</span> <span>elastic_mu</span> <span>*</span> <span>(F_minus_F_inv_T);</span>
    <span>var</span> <span>P_term_1</span> <span>=</span> <span>elastic_lambda</span> <span>*</span> <span>math.log(J)</span> <span>*</span> <span>F_inv_T;</span>
    <span>var</span> <span>P</span> <span>=</span> <span>P_term_0</span> <span>+</span> <span>P_term_1;</span>

    <span>// Cauchy stress = (1 / det(F)) * P * F_T</span>
    <span>// equation 38, MPM course</span>
    <span>stress</span> <span>=</span> <span>(</span><span>1.0f</span> <span>/</span> <span>J)</span> <span>*</span> <span>math.mul(P,</span> <span>F_T);</span>

    <span>// (M_p)^-1 = 4, see APIC paper and MPM course page 42</span>
    <span>// this term is used in MLS-MPM paper eq. 16. with quadratic weights, Mp = (1/4) * (delta_x)^2.</span>
    <span>// in this simulation, delta_x = 1, because i scale the rendering of the domain rather than the domain itself.</span>
    <span>// we multiply by dt as part of the process of fusing the momentum and force update for MLS-MPM</span>
    <span>var</span> <span>eq_16_term_0</span> <span>=</span> <span>-volume</span> <span>*</span> <span>4</span> <span>*</span> <span>dt</span> <span>*</span> <span>stress;</span>

    <span>// we calculate the rest of the force term inside the loop</span>
    <span>foreach</span> <span>(Cell</span> <span>cell</span> <span>in</span> <span>p.neighbourhood)</span> <span>{</span>
        <span>float2</span> <span>cell_dist</span> <span>=</span> <span>(cell.x</span> <span>-</span> <span>p.x)</span> <span>+</span> <span>0.5f</span><span>;</span>
        <span>float2</span> <span>Q</span> <span>=</span> <span>math.mul(p.C,</span> <span>cell_dist);</span>

        <span>// MPM course equation (172)</span>
        <span>float</span> <span>weighted_mass</span> <span>=</span> <span>weight</span> <span>*</span> <span>p.mass;</span>
        
        <span>cell.mass</span> <span>+=</span> <span>weighted_mass;</span>
        <span>cell.v</span> <span>+=</span> <span>weighted_mass</span> <span>*</span> <span>(p.v</span> <span>+</span> <span>Q);</span>
        
        <span>// fused force/momentum update from MLS-MPM</span>
        <span>// see MLS-MPM paper, equation listed after eqn. 28</span>
        <span>float2</span> <span>momentum</span> <span>=</span> <span>math.mul(eq_16_term_0,</span> <span>cell_dist)</span> <span>*</span> <span>cell.weight;</span>
        <span>cell.v</span> <span>+=</span> <span>momentum;</span>
        
        <span>// total update on cell.v is now: weight * (dt * M^-1 * p.volume * p.stress + p.mass * p.C)</span>
        <span>// this is the fused momentum + force from MLS-MPM. however, instead of our stress </span>
        <span>// being derived from the energy density, i use the weak form with cauchy stress. converted:</span>
        <span>// p.volume_0 * (dŒ®/dF)(Fp)*(Fp_transposed)</span>
        <span>// is equal to p.volume * œÉ</span>
    <span>}</span>
<span>}</span>
</pre></div>


<p>for part 2, i‚Äôve parallelised some of the steps of the MPM algorithm. this is easy to do with HPC# in Unity, and hopefully doesn‚Äôt confuse you too much. it‚Äôs mostly for performance in the demos.</p>
<p>i‚Äôve only parallelised the parts that can be done ‚Äònaively‚Äô, namely steps 1, 3 &amp; 4 of the pseudocode outline above. i just split the workload of each loop evenly into several blocks, without rearranging the structure of our data. we can do this for these steps of the algorithm as they only do concurrent reads to shared areas of memory, and there‚Äôs no risk of a data race when writing here as each thread is effectively dedicated to either 1 cell or 1 particle independently.</p>

<hr>

<p>you can get an absolutely wild range of motion just from part 2. you can even kinda approximate fluid just by changing the <a href="https://en.wikipedia.org/wiki/Lam%C3%A9_parameters" target="_blank">Lam√© parameters</a> (try e.g. <code>lambda = 100, mu = 0.1</code>). but the fact is, we‚Äôve chosen a constitutive model most suited to elastic deformation. for fluids, we want a different approach.</p>
<p><img src="https://nialltl.neocities.org/articles/img/mpm_guide/mpm_fake_fluid.gif" alt="&amp;quot;Fake&amp;quot; fluid with a non-linear isotropic elasticity model&amp;quot;" title="&quot;Fake&quot; fluid with a non-linear isotropic elasticity model">
<img src="https://nialltl.neocities.org/articles/img/mpm_guide/mpm_fluid_constitutive_model.gif" alt="MPM with a constitutive model for isotropic fluids" title="MPM with a constitutive model for isotropic fluids"></p>
<p><em>left: ‚Äúfake‚Äù fluids with Neo-Hookean elasticity  ‚Äî  right: using a constitutive model for isotropic fluids</em></p>
<p><strong>source code: </strong><a href="https://github.com/nialltl/incremental_mpm" _target="_blank">incremental_mpm on GitHub</a></p>
<p>i was first drawn to MPM by its real-time fluid simulation potential (particularly the work of <a href="https://www.grantkot.com/" target="_blank">Grant Kot</a>). i generally found that MPM out of the box isn‚Äôt actually that great for this, compared to something like Position Based Fluids. the reason being mostly that for a fluid, the deformation that happens at an individual particle can be massive relative to its initial configuration, extremely quickly, e.g. when a liquid splashes. this means you typically would need to use a prohibitively low timestep. MPM is also kind of tricky to fully parallelise (it‚Äôs do-able, but a bit of a pain).</p>
<p>to get to the real-time fluid sims you see on this page, i tweak a few things from standard MPM. credits to Grant Kot for the altered volume calculations and boundary conditions tricks.</p>
<hr>
<h2><a id="constitutive_model_switchup_318"></a>constitutive model switchup</h2>
<p>to start with, we need a constitutive model better suited to fluids. i trawled the web and found <a href="https://en.wikipedia.org/wiki/Newtonian_fluid" target="_blank">the stress-strain relationship of Newtonian fluids</a>, and from there it‚Äôs just a matter of swapping out the stress-strain model we used in part 2 for something appropriate for fluids. in code it looks roughly like this:</p>
<!-- HTML generated using hilite.me --><div><pre><span>// end goal, constitutive equation for isotropic fluid: </span>
<span>// stress = -pressure * I + viscosity * (velocity_gradient + velocity_gradient_transposed)</span>

<span>float2x2</span> <span>stress</span> <span>=</span> <span>math.float2x2(</span>
    <span>-pressure,</span> <span>0</span><span>,</span> 
    <span>0</span><span>,</span> <span>-pressure</span>
<span>);</span>

<span>// velocity gradient - MLS-MPM eq. 17, where derivative of quadratic polynomial is linear</span>
<span>float2x2</span> <span>dudv</span> <span>=</span> <span>p.C;</span>

<span>// build strain from the velocity gradient</span>
<span>float2x2</span> <span>strain</span> <span>=</span> <span>dudv;</span>
<span>strain[</span><span>0</span><span>][</span><span>1</span><span>]</span> <span>=</span> <span>strain[</span><span>1</span><span>][</span><span>0</span><span>]</span> <span>=</span> <span>trace(dudv);</span>

<span>float2x2</span> <span>viscosity_term</span> <span>=</span> <span>dynamic_viscosity</span> <span>*</span> <span>strain;</span>
<span>stress</span> <span>+=</span> <span>viscosity_term;</span>
</pre></div>

<p>the pressure term here is given by an <a href="https://en.wikipedia.org/wiki/Equation_of_state" target="_blank">equation of state</a>, which you might recognise from SPH simulations. in the attached example, i use the Tait equation of state, which is a pretty typical choice for weakly compressible fluids (look up <em>WCSPH</em> as an example of this in an SPH context).</p>
<hr>
<h2><a id="evolving_volume_346"></a>evolving volume</h2>
<p>in part 2, we used the ‚Äúclassic MPM‚Äù way of determining volume. you start with an initial value for each particle‚Äôs volume at the start of your simulation. you then update your understanding of the volume a particle occupies by looking at its deformation gradient as it undergoes change. the issue with this is that volume is susceptible to inaccuracies that snowball over time. the accuracy of your volume estimate is determined heavily by the accuracy of your numerical integration scheme and the timestep that you choose. for a fluid, where the surrounding area of an individual particle can rapidly change and is basically undergoing constant plastic deformation, it can blow up very easily.</p>
<p>a way of tackling this is to re-do that initial calculation of each particle‚Äôs volume that you did at the start of the simulation, and go through that process every simulation step. this means your volume is no longer a quantity integrated over time and thus susceptible to that kind of numerical error. the downside: it‚Äôs significantly less computationally efficient per-frame. the upside: you can get away with a significantly higher timestep! in practice, i found that this tradeoff was definitely worth it.</p>
<p>the way i calculate a particle‚Äôs volume is reminiscent of the way SPH/PBF does it: by looking at neighbourhoods to get a density estimate. first, we scatter every particle‚Äôs mass to the grid. then, we gather them back up, weighting each grid cell‚Äôs contribution by the interpolation weights (or ‚Äúshape function‚Äù, in MPM-speak). scattering mass is already a step in the P2G phase of MPM, so it comes down to injecting another subroutine to loop over particles and sum up density. skipping over the boilerplate cell/weight calculations, it‚Äôs roughly like this:</p>

<!-- HTML generated using hilite.me --><div><pre><span>foreach</span> <span>(Particle</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
    <span>float</span> <span>density</span> <span>=</span> <span>0.0f</span><span>;</span>
    <span>// sum up mass contribution of each of the 9 cells surrounding tthe particle</span>
    <span>foreach</span> <span>(Cell</span> <span>cell</span> <span>in</span> <span>p.neighbourhood)</span> <span>{</span>
            <span>density</span> <span>+=</span> <span>cell.mass</span> <span>*</span> <span>cell.weight;</span>
        <span>}</span>
    <span>}</span>
    <span>float</span> <span>volume</span> <span>=</span> <span>1.0f</span> <span>/</span> <span>density;</span>

    <span>// ...</span>
<span>}</span>
</pre></div>


<p>this is the exact same procedure i used in part 2‚Äôs initialisation phase, to determine particles‚Äô initial volumes. if you exchanged part 2‚Äôs existing volume calculation based on <code>p.volume_0</code>, it‚Äôd yield very similar results. this of course comes at the cost of significantly more scattered memory reads at each particle. but it‚Äôs worth it for those sweet soupy vortices. i promise you.</p>
<hr>
<h2><a id="softened_boundary_conditions_371"></a>softened boundary conditions</h2>
<p>i‚Äôve been using a very simple boundary condition up until now: a ‚Äòslip‚Äô condition that zeroes out the tangent component of the grid‚Äôs velocity field at the edges.</p>
<p>for improved stability in our real-time simulation, we can alter the boundary conditions a bit to operate on particles <em>directly</em>, as well as on cells. in addition to zeroing out particle velocities, we can do a bit of a predictive leap in deciding when to enforce our boundary conditions. this generally helps with particles ‚Äòtunneling‚Äô through to the boundary at high speed.</p>
<p>here‚Äôs an isolated view of where and how boundary conditions are actually enforced this way:</p>

<!-- HTML generated using hilite.me --><div><pre><span>// standard cell boundary conditions</span>
<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>num_cells;</span> <span>++i)</span> <span>{</span>
    <span>var</span> <span>cell</span> <span>=</span> <span>cells[i];</span>

    <span>// convert 1D index to 2D</span>
    <span>int</span> <span>x</span> <span>=</span> <span>i</span> <span>/</span> <span>grid_res;</span>
    <span>int</span> <span>y</span> <span>=</span> <span>i</span> <span>%</span> <span>grid_res;</span>

    <span>// zero out velocities around the perimeter</span>
    <span>if</span> <span>(x</span> <span>&lt;</span> <span>2</span> <span>||</span> <span>x</span> <span>&gt;</span> <span>grid_res</span> <span>-</span> <span>3</span><span>)</span> <span>{</span> <span>cell.v.x</span> <span>=</span> <span>0</span><span>;</span> <span>}</span>
    <span>if</span> <span>(y</span> <span>&lt;</span> <span>2</span> <span>||</span> <span>y</span> <span>&gt;</span> <span>grid_res</span> <span>-</span> <span>3</span><span>)</span> <span>{</span> <span>cell.v.y</span> <span>=</span> <span>0</span><span>;</span> <span>}</span>
<span>}</span>

<span>const</span> <span>int</span> <span>wall_min</span> <span>=</span> <span>3</span><span>;</span>
<span>const</span> <span>int</span> <span>wall_max</span> <span>=</span> <span>(grid_res</span> <span>-</span> <span>1</span><span>)</span> <span>-</span> <span>wall_min;</span>

<span>foreach</span> <span>(Particle</span> <span>p</span> <span>in</span> <span>particles)</span> <span>{</span>
    <span>// safely clamp particle positions to be inside the grid</span>
    <span>p.x</span> <span>=</span> <span>math.clamp(p.x,</span> <span>1</span><span>,</span> <span>grid_res</span> <span>-</span> <span>2</span><span>);</span>

    <span>// NEW: predictive boundary conditions that soften velocities near the domain's edges </span>
    <span>float2</span> <span>x_n</span> <span>=</span> <span>p.x</span> <span>+</span> <span>p.v;</span>
    <span>if</span> <span>(x_n.x</span> <span>&lt;</span> <span>wall_min)</span> <span>p.v.x</span> <span>+=</span> <span>wall_min</span> <span>-</span> <span>x_n.x;</span>
    <span>if</span> <span>(x_n.x</span> <span>&gt;</span> <span>wall_max)</span> <span>p.v.x</span> <span>+=</span> <span>wall_max</span> <span>-</span> <span>x_n.x;</span>
    <span>if</span> <span>(x_n.y</span> <span>&lt;</span> <span>wall_min)</span> <span>p.v.y</span> <span>+=</span> <span>wall_min</span> <span>-</span> <span>x_n.y;</span>
    <span>if</span> <span>(x_n.y</span> <span>&gt;</span> <span>wall_max)</span> <span>p.v.y</span> <span>+=</span> <span>wall_max</span> <span>-</span> <span>x_n.y;</span>
<span>}</span>
</pre></div>


<hr>
<h2><a id="conclusion_410"></a>conclusion</h2>
<p>with the above-mentioned 3 tweaks, i‚Äôve managed to get some really nice interactive and stable fluid simulations running in real-time. the main trade-off being made is that of continuously reevaluating the volume, as it does create another memread bottleneck (and MPM already has quite a few of these).</p>
<p>i don‚Äôt imagine MPM being a go-to solution for real-time simulations like this in general as it has such high computational overhead. nonetheless, i think shooting for real-time has been really nice when experimenting with new material models. and it makes for some fun squishy toys.</p>
<p><strong>a note on multi-phase simulation</strong>:</p>
<p>getting multiple phases running in your simulations is literally as easy as storing material properties with your particles rather than globally. you can then instantiate particles with the desired individual characteristics and everything will be nicely coupled together.</p>
<p><strong>a note about surface tension</strong>:</p>
<p>i haven‚Äôt actually directly implemented any solution for this. however, a combination of 1) the equation of state giving negative pressures (that i clamp a little), and 2) the quadratic kernels themselves, yield really nice filaments already.</p>
<p>if you do want to explicitly mix in more tweakable surface tension, i‚Äôd maybe start by looking at the paper <a href="https://web.archive.org/web/20190426162509/http://www.techscience.com/doi/10.3970/cmes.2012.086.199.pdf" target="_blank">‚ÄúOn the Modeling of Surface Tension and its Applications by the Generalized Interpolation Material Point Method‚Äù</a>.<br>
however, that approach requires evaluating weight gradients for determining surface curvature, which MLS-MPM manages to otherwise avoid. finding a way to integrate surface tension models into a gradient-free MLS-MPM implementation would be a cool direction for further research!</p>

<hr>

<p>hip-hip hooray, this is just the beginning!!</p>
<p>there are so many avenues left unexplored right now. i‚Äôve written up a small list below.</p>
<p>if you have any questions feel free to reach out to me. i‚Äôm easiest to reach on twitter <a href="https://twitter.com/nialltl" target="_blank">@nialltl</a>.</p>
<ul>
<li>implicit time integration
<ul>
<li>my MLS-MPM implementation uses a explicit integration. implicit approaches are way more computationally intensive per-simulation-step. but, in some cases, they make up for this by allowing you to take wayyyy bigger timesteps, and can end up faster overall as a result. this <em>isn't a guarantee</em>, though. <a href="#acknowledgements_489">Yuanming Hu</a> alerted me to the fact that since we don't have a good preconditioner for MPM, unlike e.g.  Lagrangian cloth or SPH-style incompressible fluids, an implicit solver for MPM is generally not likely to be worth its weight. might be worth exploring anyway though. </li>
<li>the reason i‚Äôve not delved into this is because it‚Äôs just harder! implicit MPM iteratively solves a system of equations to determine force updates on cells. existing implementations i could find tend to rely on big number-crunching libraries like Eigen to do the bulk of this work. if you dive into this please let me know, i‚Äôd love to see how you get on!</li>
</ul>
</li>
<li>extended boundary conditions
<ul>
<li>currently we only have a slip condition at the edges of the simulation domain. would be nice to have more extensive collision handling with static objects (and dynamic, if you‚Äôre willing to go absolutely nuts)</li>
</ul>
</li>
<li>parallelisation
<ul>
<li>huge topic that i‚Äôve lost a lot of hours in! there are a bunch of ways you can go about improving MPM‚Äôs multithreading potential. being able to perform the expensive P2G step in parallel is a huge performance win.</li>
<li>i‚Äôm hoping to write another article about this soon! i‚Äôll be sharing my GPU implementation with compute shaders in due course. i‚Äôll <a href="https://twitter.com/nialltl" target="_blank">tweet about this</a> when it happens.</li>
</ul>
</li>
<li>adaptive / asynchronous time stepping
<ul>
<li>asynchronous MPM is a cool optimisation area. basically, you don‚Äôt have to simulate all of your simulation domain at the same rate. if some of your scene is barely moving or under little pressure, there‚Äôs no need to waste cycles there. you could start with <a href="https://web.archive.org/web/20190427141455/http://squarefk.com/static/files/fang2018async.pdf" target="_blank">"A Temporally Adaptive Material Point Method with Regional Time Stepping"</a>.</li>
</ul>
</li>
<li>more complex deformation models and material behaviour
<ul>
<li>a never-ending realm of possibility. you could look at <a href="https://web.archive.org/web/20190426233329/https://www.math.ucla.edu/~jteran/papers/GHFGTT18.pdf" target="_blank">simulating thin shells for e.g. fabrics</a>, <a href="https://web.archive.org/web/20170105121042/https://www.math.ucla.edu/~jteran/papers/RGJSSTK15.pdf" target="_blank">viscoelastic foams &amp; sponges</a>, or <a href="https://www.seas.upenn.edu/~cffjiang/mpm.html" target="_blank">anything listed here</a>.</li>
</ul>
</li>
</ul>

<hr>

<p>there are heaps of techniques for simulating deformable objects. i found it easy to get overwhelmed with the amount of criss-crossing references to different approaches and histories when trying to pick up MPM. here‚Äôs a quick overview of some stuff that you might come across:</p>
<h3>Lagrangian</h3>
<ul>
<li>SPH: Smoothed Particle Hydrodynamics
<ul>
<li>particle-based fluid simulation method. computes field quantities by looking at surrounding particle neighbourhoods.</li>
<li>has a hilarious amount of variations differing mostly in acronym length (ISPH, IISPH, PCISPH, DCSPH, ‚Ä¶ generally trying to improve incompressibility).</li>
</ul>
</li>
<li>PBD: Position Based Dynamics
<ul>
<li>general simulation methodology, handles constraints geometrically using direct positional corrections.</li>
<li>not that physically motivated but generally fast and great for real-time applications. super stable.</li>
<li>often suffers from damping, but higher order PBD integrators help with this.</li>
</ul>
</li>
<li>PBD: Position Based Fluids
<ul>
<li>like SPH, but using a PBD integrator. enforces incompressibility by putting a constraint on particles‚Äô densities.</li>
</ul>
</li>
</ul>
<h3>Hybrid Lagrangian-Eulerian</h3>
<ul>
<li>PIC: Particle-In-Cell
<ul>
<li>general family of methods using a mixture of grids and particles for simulation. an absolute classic, been around a long time.</li>
<li>used for astronomical simulations and liquids / gases generally.</li>
</ul>
</li>
<li>FLIP: Fluid Implicit Particle
<ul>
<li>like PIC, but with an improved way of advecting particles.</li>
<li>typically used for fluids. common in a lot of 3D simulation packages, e.g. Blender, Houdini.</li>
</ul>
</li>
<li>MPM: Material Point Method
<ul>
<li>another PIC method, more versatile than something like FLIP.</li>
<li>good for deformable soft matter and fluids.</li>
<li>supports multiple phases (different materials interacting with each other) fairly effortlessly.</li>
<li>typically requires a very small timestep, comparatively high memory requirements.</li>
<li>easily exhibits numerical fracture (stuff splitting apart), which you might not always want.</li>
</ul>
</li>
<li>GIMP: Generalised Interpolation Material Point Method
<ul>
<li>a particular flavour of MPM that emerged early on that solved early issues with linearly weighted MPM, to stop particles oscillating erroneously at cell boundaries.</li>
</ul>
</li>
<li>APIC: Affine Particle-In-Cell
<ul>
<li>very recent significant improvement on PIC, one-upping a fix for PIC‚Äôs dissipation problems that FLIP tried to solve.</li>
</ul>
</li>
<li>PolyPIC: Polynomial Particle-In-Cell
<ul>
<li>the wider family of methods that APIC belongs to. basically a higher-order generalisation.</li>
</ul>
</li>
<li>MLS-MPM: Moving Least Squares Material Point Method
<ul>
<li>like MPM, but taking ideas from APIC and bringing them in</li>
<li>state o‚Äô the art. a straight up improvement on MPM. simplifies the whole algorithm and is more computationally efficient too.</li>
<li>this algorithm is what we just implemented! :o)</li>
</ul>
</li>
</ul>

<hr>

<ul>
<li>
<p><a href="https://benedikt-bitterli.me/" target="_blank">Benedikt Bitterli</a>'s project <a href="https://github.com/tunabrain/incremental-fluids" target="_blank">Incremental Fluids</a> inspired the format of my built-out examples. it‚Äôs a really great resource on Eulerian fluid simulation.</p>
</li>
<li>
<p><a href="https://www.grantkot.com/" target="_blank">Grant Kot</a>'s work on MPM and real-time sims in general has been really inspiring and useful! he also helped me out a bunch with MPM back in the day.</p>
</li>
<li>
<p><a href="http://taichi.graphics/me/" target="_blank">Yuanming Hu</a> very kindly looked over this page to ensure i wasn‚Äôt spreading any cursedly off-piste information about MPM, thanks Yuanming!</p>
</li>
<li>
<p><a href="https://twitter.com/sebaaltonen" target="_blank">Sebastian Aaltonen</a>'s various twitter threads on simulations and parallel architecture for real-time work have been a great reference and source of motivation.</p>
</li>
</ul>
</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>

</body>
</html>