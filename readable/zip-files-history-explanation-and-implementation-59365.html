<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Zip Files: History, Explanation and Implementation - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Zip Files: History, Explanation and Implementation - linksfor.dev(s)"/>
    <meta property="og:description" content="I have been curious about data compression and the Zip file format in particular for a long time. At some point I decided to address that by learning how it works and writing my own Zip program. The implementation turned into an exciting programming exercise; there is great pleasure to be had from creating a well oiled machine that takes data apart, jumbles its bits into a more efficient representation, and puts it all back together again. Hopefully it is interesting to read about too."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.hanshq.net/zip.html"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Zip Files: History, Explanation and Implementation</title>
<div class="readable">
        <h1>Zip Files: History, Explanation and Implementation</h1>
            <div>Reading time: 142-181 minutes</div>
        <div>Posted here: 06 Mar 2020</div>
        <p><a href="https://www.hanshq.net/zip.html">https://www.hanshq.net/zip.html</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="left">
<p>I have been curious about data compression and the Zip file format in particular for a long time. At some point I decided to address that by learning how it works and writing my own Zip program. The implementation turned into an exciting programming exercise; there is great pleasure to be had from creating a well oiled machine that takes data apart, jumbles its bits into a more efficient representation, and puts it all back together again. Hopefully it is interesting to read about too.</p>

<p>This article explains how the Zip file format and its compression scheme work in great detail: LZ77 compression, Huffman coding, Deflate and all. It tells some of the history, and provides a reasonably efficient example implementation written from scratch in C. The source code is available in <a href="https://www.hanshq.net/files/hwzip/hwzip-1.1.zip">hwzip-1.1.zip</a>.</p>




<p>I have done my best to provide a bug-free implementation. If you find any issues, please let me know.</p>

<p>I am very grateful to
<a href="https://twitter.com/angealbertini">Ange Albertini</a>,
<a href="https://gynvael.coldwind.pl/">Gynvael Coldwind</a>,
<a href="https://fgiesen.wordpress.com/">Fabian Giesen</a>,
<a href="https://www.instagram.com/dr.jonas.skeppstedt">Jonas Skeppstedt</a> (<a href="https://www.jonasskeppstedt.net/">web</a>),
<a href="https://primianotucci.com/">Primiano Tucci</a>, and
<a href="https://twitter.com/thakis">Nico Weber</a>
who provided valuable feedback on draft versions of this material.</p>

<h2>Table of Contents</h2>

<ul>
<li><a href="#history">History</a><ul>
        <li><a href="#pkzip">PKZip</a></li>
        <li><a href="#zlib">Info-ZIP and zlib</a></li>
        <li><a href="#winzip">WinZip</a></li>
</ul></li>

<li><a href="#lz">Lempel-Ziv Compression (LZ77)</a></li>

<li><a href="#huffman">Huffman Coding</a><ul>
        <li><a href="#huffalg">Huffman's Algorithm</a></li>
        <li><a href="#canhuff">Canonical Huffman Codes</a></li>
        <li><a href="#huffdec">Efficient Huffman Decoding</a></li>
</ul></li>

<li><a href="#deflate">Deflate</a><ul>
        <li><a href="#bitstreams">Bitstreams</a></li>

        <li><a href="#inflation">Decompression (Inflation)</a><ul>
                <li><a href="#noncomp">Non-Compressed Deflate Blocks</a></li>
                <li><a href="#fixed">Fixed Huffman Code Deflate Blocks</a></li>
                <li><a href="#dyn">Dynamic Huffman Code Deflate Blocks</a></li>
        </ul></li>

        <li><a href="#deflation">Compression (Deflation)</a></li>
</ul></li>

<li><a href="#zip">The Zip File Format</a><ul>
        <li><a href="#zipintro">Overview</a></li>

        <li><a href="#zipstructs">Data Structures</a><ul>
                <li><a href="#eocdr">End of Central Directory Record</a></li>
                <li><a href="#cfh">Central File Header</a></li>
                <li><a href="#lfh">Local File Header</a></li>
        </ul></li>

        <li><a href="#zipreader">Zip Reader Implementation</a></li>
        <li><a href="#zipwriter">Zip Writer Implementation</a></li>
</ul></li>

<li><a href="#hwzip">HWZip</a><ul>
        <li><a href="#build">Build Instructions</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#exercises">Exercises</a></li>
<li><a href="#reading">Further Reading</a></li>

</ul>

<h2>History</h2>

<h3>PKZip</h3>

<p>Back in the eighties and early nineties, before the Internet became widely available, home computer enthusiasts used dial-up modems to connect to Bulletin Board Systems (BBSes) over the telephone network.
A BBS is an interactive computer system that typically allows users to send messages, play games, and share files.
All that was needed to go online was a computer, a modem, and the phone number of a good BBS—something that could be found in <a href="https://archive.org/details/Boardwatch_Magazine_Vol_06_10_1992_Dec/page/n81">lists published by computer magazines</a>, and on other BBSes.</p>

<p>One important tool for making file sharing easier was the <em>archiver</em>. An archiver stores one or more files into a single file, an <em>archive</em>, allowing the files to be stored or transferred as a single unit, and ideally also compresses them to save storage space and transfer time. One such archiver that was popular with the BBS scene was <a href="https://en.wikipedia.org/wiki/ARC_(file_format)">Arc</a>, written by Thom Henderson of System Enhancement Associates (SEA), a small company he had founded with his brother-in-law.</p>

<p>In the late eighties, a programmer named Phil Katz released his own Arc program, PKArc. It was compatible with SEA's Arc, but faster due to routines written in assembly, and it had a new compression method added by Katz. The program became popular, and Katz quit his job and founded PKWare to focus on developing it. According to legend, much of the work took place at his mother Hildegard's kitchen table in Glendale, Wisconsin.</p>



<p>SEA, however, were not thrilled by Katz's initiative. They sued for trademark violation and copyright infringement. The dispute and the surrounding debate in the BBS and PC world became known as the <a href="http://catb.org/jargon/chaff.html#arc-wars">Arc wars</a>. In the end, the case was <a href="http://www.bbsdocumentary.com/library/CONTROVERSY/LAWSUITS/SEA/release.txt">settled</a> to SEA's advantage.</p>

<p>Moving on from Arc, in 1989 Katz created a new archive format which he named Zip and <a href="https://groups.google.com/d/msg/comp.sys.ibm.pc/0tun_9sqKYU/RNeLTza9fAEJ">dedicated to the public domain</a>:</p>

<blockquote>
<p>The file format of the files created by these programs, which file format is original with the first release of this software, is hereby dedicated to the public domain.  Further, the filename extension of ".ZIP", first used in connection with data compression software on the first release of this software, is also hereby dedicated to the public domain, with the fervent and sincere hope that it will not be attempted to be appropriated by anyone else for their exclusive use, but rather that it will be used to refer to data compression and librarying software in general, of a class or type which creates files having a format generally compatible with this software.</p>
</blockquote>

<p>Katz's program for creating such files was called PKZip, and it was soon adopted by the BBS and PC world.</p>

<p>One aspect that most likely contributed to the Zip format's success was that PKZip came with a document, the <a href="https://www.pkware.com/documents/APPNOTE/APPNOTE-2.0.txt">Application Note</a>, which explained exactly how the format works. This allowed others to study the format and create programs that create, extract, or otherwise interact with Zip files in a compatible way.</p>

<p>Zip is a <em>lossless</em> compression format: after decompression, the data is identical to what it was before compression. It works by finding redundancies in the source data and representing it more efficiently. This is different from <em>lossy</em> compression, used in image and sound formats such as JPEG and MP3, which work by removing features from the data which are less perceivable to the human eye or ear, etc.</p>

<p>PKZip was distributed as Shareware: it could be used and copied freely, but users were encouraged to "register" the program. For $47, one would receive a printed manual, premium support, and an enhanced version of the software.</p>

<p><img src="https://www.hanshq.net/gfx/pkzip_manual.jpg" alt="PKZip manual and floppy">
</p>

<p>The seminal version of PKZip was 2.04c, released on 28 December 1992 (followed by <a href="https://www.hanshq.net/files/pkz204g.exe">version 2.04g</a> soon after). This introduced Deflate as the default compression method, and defined how Zip file compression would work going forward. (<a href="https://archive.org/details/Boardwatch1993-03/page/n21">Boardwatch article about the release.</a>)</p>

<p><img src="https://www.hanshq.net/gfx/pkzip.png" alt="Screenshot of PKZip 2.04g">
</p>

<p>The Zip format has since been adopted by many other file formats. For example, Java Archives (.jar files) and Android Application Packages (.apk files), as well as Microsoft Office .docx files, are all using the Zip format. Other file formats and protocols re-use the compression algorithm used in Zip files, Deflate. For example, this web page was most likely transferred to your web browser as a gzip file, a format which uses Deflate compression.</p>

<p>Phil Katz passed away in 2000. PKWare still exist and maintain the Zip format, though they focus mainly on data security software.</p>
<!--Pictures from their DevFest 2019: https://pkware.com/devfest2019 -->


<h3>Info-ZIP and zlib</h3>

<p>Soon after the release of PKZip in 1989, other programs to extract Zip files started showing up, in particular a program called <em>unzip</em> that could be used to extract Zip files on Unix systems. A mailing list called Info-ZIP was set up in March 1990.</p>

<p>The <a href="http://www.info-zip.org/">Info-ZIP</a> group released the free and open-source <em>unzip</em> and <em>zip</em> programs, used to extract and create zip files. The code was ported to many systems and they are still the standard Zip programs used on Unix systems. This further helped increase the popularity of Zip files.</p>

<p>At some point, the Info-ZIP code that performed the Deflate compression and decompression was extracted into a separate software library called <a href="https://www.zlib.net/">zlib</a>, written by <a href="http://gailly.net/">Jean-loup Gailly</a> (compression) and <a href="https://madler.net/madler/">Mark Adler</a> (decompression).</p>

<div>
<p><img src="https://www.hanshq.net/gfx/gailly_adler.jpg" alt="Photo of Jean-loup Gailly and Mark Adler receiving the USENIX STUG award in 2009."></p><p>Jean-loup Gailly (left) and Mark Adler (right) receiving the <a href="https://www.usenix.org/about/stug">USENIX STUG Award</a> in 2009.</p>
</div>

<p>One reason for creating the library was that this made it convenient to use Deflate compression in other applications and file formats, such as the new <a href="https://en.wikipedia.org/wiki/Gzip">gzip</a> file compression format, and the <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a> image compression format. These new file formats had been proposed in order to replace the <a href="https://en.wikipedia.org/wiki/Compress">Compress</a> and <a href="https://en.wikipedia.org/wiki/GIF">GIF</a> file formats, which used the patent-encumbered LZW algorithm.</p>

<p>As part of developing those formats, a specification of Deflate was written by Peter Deutsch and published as <a href="https://tools.ietf.org/html/rfc1951">Internet RFC 1951</a> in May 1996. This provides an easier to follow description than the original PKZip Application Note.</p>

<p>Today, the use of zlib is truly ubiquitous. It was probably responsible for both the compression of this page on the web server, and decompression in your web browser. Compression and decompression of most Zip and Zip-like files is now done with zlib.</p>

<h3>WinZip</h3>

<p>Many people who did not use PKZip do remember using WinZip. As PC users moved from DOS to Windows, they also moved from PKZip to WinZip.</p>

<p>It started as a project by programmer Nico Mak, who was working on software for the OS/2 operating system at a company called Mansfield Software Group in Storrs-Mansfield, Connecticut. He was using Presentation Manager, the graphical user interface in OS/2, and was frustrated by how he had to switch from its File Manager to a DOS command prompt whenever he wanted to create or extract Zip files.</p>
<!--Some history: https://archive.org/details/winzipforbeginne0000howa/page/n5 -->
<!--Mansfield Software Group: http://www.edm2.com/index.php/Mansfield_Software_Group -->

<p>Mak wrote a simple graphical program to manage Zip files directly in Presentation Manager, named it <a href="http://cd.textfiles.com/sigserieswin/0WINRUN/2785/PMZIP.TXT">PMZip</a>, and released it as shareware in 1990.</p>

<p>OS/2 never really took off; instead the PC world was moving to Microsoft Windows. In 1991, Mak decided to learn how to write Windows programs, and his first project was to port his Zip program to this new operating system. <a href="https://www.hanshq.net/files/winzip1.zip">WinZip 1.00</a> was released in April 1991 as shareware with a 21-day evaluation period and $29 registration price. It looked like this:</p>

<p><img src="https://www.hanshq.net/gfx/winzip1.png" alt="Screenwhot of Winzip 1.00">
</p>

<p>The first versions of WinZip used PKZip behind the scenes, but starting with version 5.0 in 1993 it uses the code from Info-ZIP to manage Zip files directly. From its humble beginnings, the user interface evolved to different versions of the one below.</p>

<div>
<p><img src="https://www.hanshq.net/gfx/winzip.png" alt="Winzip 6.3 running under Windows 3.11 For Workgroups"></p><p>Screenshot of <a href="https://ftp.sunet.se/mirror/archive/ftp.sunet.se/pub/simtelnet/win3/compress/wz16v_63.exe">WinZip 6.3</a> running under Windows 3.11 for Workgroups.</p>
</div>

<p>WinZip was one of the most popular shareware programs during the nineties, but it eventually became less relevant as operating systems gained built-in support for Zip files. Windows manages Zip files as "Compressed Folders" since 2001 (Windows XP), using a library called <a href="http://www.innermedia.com/">DynaZip</a> under the hood.</p>
<!--It's in zipfldr.dll-->

<p>Mak's company was originally called Nico Mak Computing. In 2000 it was renamed to WinZip Computing, and Mak seems to have left around this time. In 2005 the company was <a href="https://www.businesswire.com/news/home/20050718005297/en/Vector-Capital-Buys-WinZip-Private-Equity-Firm">sold to Vector Capital</a>, and it eventually ended up owned by <a href="https://www.corel.com/">Corel</a> who still release WinZip as a product.</p>


<h2>Lempel-Ziv Compression (LZ77)</h2>

<p>There are two main ingredients in Zip compression: Lempel-Ziv compression and Huffman coding. This section describes the former.</p>

<p>One way of compressing text is to maintain a list of common words or phrases, and replace occurrences of those words in the text with references to the dictionary. For example, a long word such as "compression" in the original text might be represented more efficiently as #1234, where 1234 refers to the position in the word list. This is known as <em>dictionary-based compression</em>.</p>

<p>The dictionary method poses several problems for a general-purpose compression scheme. First, what should go in the dictionary? The original data might not be in English, and it might not even be human-readable text. And if the dictionary is not agreed upon between the compressing and decompressing parties beforehand, it needs to be stored and transmitted together with the compressed data, reducing the benefit of the compression.</p>

<p>One elegant solution to these problems is to use the original data itself as the dictionary. In their 1977 paper "<a href="https://www2.cs.duke.edu/courses/spring03/cps296.5/papers/ziv_lempel_1977_universal_algorithm.pdf">A Universal Algorithm for Sequential Data Compression</a>", Jacob Ziv and Abraham Lempel (both at Technion), propose a compression scheme where the original data is parsed into a sequence of triplets</p>

<p>(<em>pointer</em>, <em>length</em>, <em>next</em>)</p>

<p>where <em>pointer</em> and <em>length</em> form a back reference to a substring to be copied from a previous position in the original text, and <em>next</em> is the next character to output.</p>



<p>For example, consider the snippet below.</p>

<blockquote>
<p>
I<span>t was the </span>best of times,<br>
i<span>t was the </span>worst of times,<br>
</p>
</blockquote>

<p>In the second line, the "t was the w" substring can be represented as (26, 10, w), because it can be recreated by copying 10 characters from the position 26 steps back, followed by a "w". Characters which have not occurred before use zero-length back references. For example, the initial "I" would be represented as (0, 0, I).</p>

<p>This form of compression is called Lempel-Ziv or LZ77 compression. However, real-world implementations typically do not use the <em>next</em> part of the triplets. Instead, they output single characters separately and use (<em>distance</em>, <em>length</em>) pairs for the back references. (This variant is called <a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski">LZSS</a> compression.) How the literals and back reference are <em>encoded</em> is a separate problem, and we will see how it is done in <a href="#deflate">Deflate</a> later.</p>

<p>As an example, the following text</p>

<blockquote>
<p>
It was the best of times,<br>
it was the worst of times,<br>
it was the age of wisdom,<br>
it was the age of foolishness,<br>
it was the epoch of belief,<br>
it was the epoch of incredulity,<br>
it was the season of Light,<br>
it was the season of Darkness,<br>
it was the spring of hope,<br>
it was the winter of despair,<br>
we had everything before us,<br>
we had nothing before us,<br>
we were all going direct to Heaven,<br>
we were all going direct the other way
</p>
</blockquote>

<p>can be compressed into</p>

<blockquote>
<p>
It was the best of times,<br>
i(26,10)wor(27,24)age(25,4)wisdom(26,20)<br>
foolishnes(57,14)epoch(33,4)belief
(28,22)incredulity<br>
(33,13)season(34,4)Light(28,23)Dark(120,17)<br>
spring(31,4)hope(231,14)inter(27,4)despair,<br>
we had everyth(57,4)before us(29,9)no(26,20)<br>
we(12,3)all go(29,4)direct to Heaven<br>
(36,28)(139,3)(83,3)(138,3)way<br>
</p>
</blockquote>

<p>One exciting aspect of back references is that they can overlap with themselves, which happens when the length is greater than the distance. This is best illustrated by an example:

</p><blockquote>
<p>
Fa<span>-la</span>-la-la-la
</p>
</blockquote>

<p>can be compressed into</p>

<blockquote>
<p>
Fa-la(3,9)
</p>
</blockquote>

<p>This may seem strange, but it works: once the first three "-la" bytes have been copied, the copying continues using the recently output bytes.</p>

<p>This is effectively a form of <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding</a>, where a piece of data is copied repeatedly up to a certain length.</p>

<p>See Colin Morris's <a href="https://pudding.cool/2017/05/song-repetition/">Are Pop Lyrics Getting More Repetitive?</a> article for an interactive example of Lempel-Ziv compression applied to song lyrics.</p>

<p>Expressed in C, a back reference can be copied out as shown below. Note that because of the possible self-overlap, we cannot use <span>memcpy</span> or <span>memmove</span>.</p>

<div><pre><span>/* Output the (dist,len) backref at dst_pos in dst. */</span>
<span>static</span> <span>inline</span> <span>void</span> <span>lz77_output_backref</span><span>(</span><span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>size_t</span> <span>dst_pos</span><span>,</span>
                                       <span>size_t</span> <span>dist</span><span>,</span> <span>size_t</span> <span>len</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>;</span>

        <span>assert</span><span>(</span><span>dist</span> <span>&lt;=</span> <span>dst_pos</span> <span>&amp;&amp;</span> <span>"cannot reference before beginning of dst"</span><span>);</span>

        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>len</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>dst</span><span>[</span><span>dst_pos</span><span>]</span> <span>=</span> <span>dst</span><span>[</span><span>dst_pos</span> <span>-</span> <span>dist</span><span>];</span>
                <span>dst_pos</span><span>++</span><span>;
        }
}</span>
</pre></div>


<p>Literals are trivial to output but we provide a utility function for completeness:</p>

<div><pre><span>/* Output lit at dst_pos in dst. */</span>
<span>static</span> <span>inline</span> <span>void</span> <span>lz77_output_lit</span><span>(</span><span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>size_t</span> <span>dst_pos</span><span>,</span> <span>uint8_t</span> <span>lit</span><span>)
{</span>
        <span>dst</span><span>[</span><span>dst_pos</span><span>]</span> <span>=</span> <span>lit</span><span>;
}</span>
</pre></div>


<p>Note that the caller of these functions is responsible for making sure there is enough room in <span>dst</span> for the output, and that the back reference does not try to go before the start of the buffer.</p>

<p>Of course the hard part is not to output back references during decompression, but rather how to find them in the first place when compressing the original data. There are different ways of doing that, but we will follow zlib's hash table-based approach, which is also what RFC 1951 suggests.</p>

<p>The idea is to maintain a hash table with the positions of three-character prefixes that have occurred previously in the string (shorter back references are not considered profitable). For Deflate, only back references to the most recent 32,768 characters, the <em>window</em>, are allowed. This enables <em>streaming compression</em>: the input can be processed a little at a time, as long as the window with the most recent bytes are kept in memory. However, our implementation will assume that the full input is available and process it in one go, allowing us to focus on the compression instead of the bookkeeping required for streaming.</p>

<p>We will use two arrays: <span>head</span> maps the hash value of a three-letter prefix to a position in the input data, and <span>prev</span> maps a position to the previous position with the same hash value. In effect, <span>head[h]</span> is the head of a linked list of positions of prefixes with hash <span>h</span>, and <span>prev[x]</span> gets the element previous to <span>x</span> in the list.</p>

<div><pre><span>#define LZ_WND_SIZE 32768
#define LZ_MAX_LEN  258

#define HASH_SIZE 15
#define NO_POS    SIZE_MAX</span>


<span>/* Perform LZ77 compression on the len bytes in src. Returns false as soon as
   either of the callback functions returns false, otherwise returns true when
   all bytes have been processed. */</span>
<span>bool</span> <span>lz77_compress</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>len</span><span>,</span>
                   <span>bool</span> <span>(</span><span>*</span><span>lit_callback</span><span>)(</span><span>uint8_t</span> <span>lit</span><span>,</span> <span>void</span> <span>*</span><span>aux</span><span>),</span>
                   <span>bool</span> <span>(</span><span>*</span><span>backref_callback</span><span>)(</span><span>size_t</span> <span>dist</span><span>,</span> <span>size_t</span> <span>len</span><span>,</span> <span>void</span> <span>*</span><span>aux</span><span>),</span>
                   <span>void</span> <span>*</span><span>aux</span><span>)
{</span>
        <span>size_t</span> <span>head</span><span>[</span><span>1U</span> <span>&lt;&lt;</span> <span>HASH_SIZE</span><span>];</span>
        <span>size_t</span> <span>prev</span><span>[</span><span>LZ_WND_SIZE</span><span>];</span>

        <span>uint16_t</span> <span>h</span><span>;</span>
        <span>size_t</span> <span>i</span><span>,</span> <span>j</span><span>,</span> <span>dist</span><span>;</span>
        <span>size_t</span> <span>match_len</span><span>,</span> <span>match_pos</span><span>;</span>
        <span>size_t</span> <span>prev_match_len</span><span>,</span> <span>prev_match_pos</span><span>;</span>

        <span>/* Initialize the hash table. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>sizeof</span><span>(</span><span>head</span><span>)</span> <span>/</span> <span>sizeof</span><span>(</span><span>head</span><span>[</span><span>0</span><span>]);</span> <span>i</span><span>++</span><span>) {</span>
                <span>head</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>NO_POS</span><span>;
        }</span>
</pre></div>


<p>To insert a new string position in the hash table, <span>prev</span> is updated to point to the previous head, and <span>head</span> is then updated:</p>

<div><pre><span>static</span> <span>void</span> <span>insert_hash</span><span>(</span><span>uint16_t</span> <span>hash</span><span>,</span> <span>size_t</span> <span>pos</span><span>,</span> <span>size_t</span> <span>*</span><span>head</span><span>,</span> <span>size_t</span> <span>*</span><span>prev</span><span>)
{</span>
        <span>prev</span><span>[</span><span>pos</span> <span>%</span> <span>LZ_WND_SIZE</span><span>]</span> <span>=</span> <span>head</span><span>[</span><span>hash</span><span>];</span>
        <span>head</span><span>[</span><span>hash</span><span>]</span> <span>=</span> <span>pos</span><span>;
}</span>
</pre></div>


<p>Note the modulo operation when indexing into <span>prev</span>: we only care about positions that fall inside the current window.</p>

<p>Rather than computing a hash value for each three-character prefix from scratch, we use a <a href="https://en.wikipedia.org/wiki/Rolling_hash">rolling hash</a> and update it continuously in such a way that only the three most recent characters are reflected in its value:</p>

<div><pre><span>static</span> <span>uint16_t</span> <span>update_hash</span><span>(</span><span>uint16_t</span> <span>hash</span><span>,</span> <span>uint8_t</span> <span>c</span><span>)
{</span>
        <span>hash</span> <span>&lt;&lt;=</span> <span>5</span><span>;</span>                     <span>/* Shift out old bits. */</span>
        <span>hash</span> <span>^=</span> <span>c</span><span>;</span>                      <span>/* Include new bits. */</span>
        <span>hash</span> <span>&amp;=</span> <span>(</span><span>1U</span> <span>&lt;&lt;</span> <span>HASH_SIZE</span><span>)</span> <span>-</span> <span>1</span><span>;</span>  <span>/* Mask off excess bits. */</span>

        <span>return</span> <span>hash</span><span>;
}</span>
</pre></div>


<p>The hash map can then be used to search efficiently for a previous match with a substring, as shown below. Searching for matches is the most computationally expensive part of the compression, so we limit how far back the list of potential matches we search.</p>

<p>Changing parameters such as how far back the list of prefixes to search (and whether to do lazy matching, described further down) is a way of trading less compression for more speed. The settings in our code are chosen to match those of zlib's maximum compression level.</p>

<div><pre><span>/* Find the longest most recent string which matches the string starting
 * at src[pos]. The match must be strictly longer than prev_match_len and
 * shorter or equal to max_match_len. Returns the length of the match if found
 * and stores the match position in *match_pos, otherwise returns zero. */</span>
<span>static</span> <span>size_t</span> <span>find_match</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>pos</span><span>,</span> <span>uint16_t</span> <span>hash</span><span>,</span>
                         <span>size_t</span> <span>prev_match_len</span><span>,</span> <span>size_t</span> <span>max_match_len</span><span>,</span>
                         <span>const</span> <span>size_t</span> <span>*</span><span>head</span><span>,</span> <span>const</span> <span>size_t</span> <span>*</span><span>prev</span><span>,</span>
                         <span>size_t</span> <span>*</span><span>match_pos</span><span>)
{</span>
        <span>size_t</span> <span>max_match_steps</span> <span>=</span> <span>4096</span><span>;</span>
        <span>size_t</span> <span>i</span><span>,</span> <span>l</span><span>;</span>
        <span>bool</span> <span>found</span><span>;</span>

        <span>if</span> <span>(</span><span>prev_match_len</span> <span>==</span> <span>0</span><span>) {</span>
                <span>/* We want backrefs of length 3 or longer. */</span>
                <span>prev_match_len</span> <span>=</span> <span>2</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>prev_match_len</span> <span>&gt;=</span> <span>max_match_len</span><span>) {</span>
                <span>/* A longer match would be too long. */</span>
                <span>return</span> <span>0</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>prev_match_len</span> <span>&gt;=</span> <span>32</span><span>) {</span>
                <span>/* Do not try too hard if there is already a good match. */</span>
                <span>max_match_steps</span> <span>/=</span> <span>4</span><span>;
        }</span>

        <span>found</span> <span>=</span> <span>false</span><span>;</span>
        <span>i</span> <span>=</span> <span>head</span><span>[</span><span>hash</span><span>];</span>

        <span>while</span> <span>(</span><span>max_match_steps</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>if</span> <span>(</span><span>i</span> <span>==</span> <span>NO_POS</span><span>) {</span>
                        <span>/* No match. */</span>
                        <span>break</span><span>;
                }</span>

                <span>assert</span><span>(</span><span>i</span> <span>&lt;</span> <span>pos</span> <span>&amp;&amp;</span> <span>"Matches should precede pos."</span><span>);</span>
                <span>if</span> <span>(</span><span>pos</span> <span>-</span> <span>i</span> <span>&gt;</span> <span>LZ_WND_SIZE</span><span>) {</span>
                        <span>/* The match is outside the window. */</span>
                        <span>break</span><span>;
                }</span>

                <span>l</span> <span>=</span> <span>cmp</span><span>(</span><span>src</span><span>,</span> <span>i</span><span>,</span> <span>pos</span><span>,</span> <span>prev_match_len</span><span>,</span> <span>max_match_len</span><span>);</span>

                <span>if</span> <span>(</span><span>l</span> <span>!=</span> <span>0</span><span>) {</span>
                        <span>assert</span><span>(</span><span>l</span> <span>&gt;</span> <span>prev_match_len</span><span>);</span>
                        <span>assert</span><span>(</span><span>l</span> <span>&lt;=</span> <span>max_match_len</span><span>);</span>

                        <span>found</span> <span>=</span> <span>true</span><span>;</span>
                        <span>*</span><span>match_pos</span> <span>=</span> <span>i</span><span>;</span>
                        <span>prev_match_len</span> <span>=</span> <span>l</span><span>;</span>

                        <span>if</span> <span>(</span><span>l</span> <span>==</span> <span>max_match_len</span><span>) {</span>
                                <span>/* A longer match is not possible. */</span>
                                <span>return</span> <span>l</span><span>;
                        }
                }</span>

                <span>/* Look further back in the prefix list. */</span>
                <span>i</span> <span>=</span> <span>prev</span><span>[</span><span>i</span> <span>%</span> <span>LZ_WND_SIZE</span><span>];</span>
                <span>max_match_steps</span><span>--</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>!</span><span>found</span><span>) {</span>
                <span>return</span> <span>0</span><span>;
        }</span>

        <span>return</span> <span>prev_match_len</span><span>;
}</span>

<span>/* Compare the substrings starting at src[i] and src[j], and return the length
 * of the common prefix. The match must be strictly longer than prev_match_len
 * and shorter or equal to max_match_len. */</span>
<span>static</span> <span>size_t</span> <span>cmp</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>i</span><span>,</span> <span>size_t</span> <span>j</span><span>,</span>
                  <span>size_t</span> <span>prev_match_len</span><span>,</span> <span>size_t</span> <span>max_match_len</span><span>)
{</span>
        <span>size_t</span> <span>l</span><span>;</span>

        <span>assert</span><span>(</span><span>prev_match_len</span> <span>&lt;</span> <span>max_match_len</span><span>);</span>

        <span>/* Check whether the first prev_match_len + 1 characters match. Do this
         * backwards for a higher chance of finding a mismatch quickly. */</span>
        <span>for</span> <span>(</span><span>l</span> <span>=</span> <span>0</span><span>;</span> <span>l</span> <span>&lt;</span> <span>prev_match_len</span> <span>+</span> <span>1</span><span>;</span> <span>l</span><span>++</span><span>) {</span>
                <span>if</span> <span>(</span><span>src</span><span>[</span><span>i</span> <span>+</span> <span>prev_match_len</span> <span>-</span> <span>l</span><span>]</span> <span>!=</span>
                    <span>src</span><span>[</span><span>j</span> <span>+</span> <span>prev_match_len</span> <span>-</span> <span>l</span><span>]) {</span>
                        <span>return</span> <span>0</span><span>;
                }
        }</span>

        <span>assert</span><span>(</span><span>l</span> <span>==</span> <span>prev_match_len</span> <span>+</span> <span>1</span><span>);</span>

        <span>/* Now check how long the full match is. */</span>
        <span>for</span> <span>(;</span> <span>l</span> <span>&lt;</span> <span>max_match_len</span><span>;</span> <span>l</span><span>++</span><span>) {</span>
                <span>if</span> <span>(</span><span>src</span><span>[</span><span>i</span> <span>+</span> <span>l</span><span>]</span> <span>!=</span> <span>src</span><span>[</span><span>j</span> <span>+</span> <span>l</span><span>]) {</span>
                        <span>break</span><span>;
                }
        }</span>

        <span>assert</span><span>(</span><span>l</span> <span>&gt;</span> <span>prev_match_len</span><span>);</span>
        <span>assert</span><span>(</span><span>l</span> <span>&lt;=</span> <span>max_match_len</span><span>);</span>
        <span>assert</span><span>(</span><span>memcmp</span><span>(</span><span>&amp;</span><span>src</span><span>[</span><span>i</span><span>],</span> <span>&amp;</span><span>src</span><span>[</span><span>j</span><span>],</span> <span>l</span><span>)</span> <span>==</span> <span>0</span><span>);</span>

        <span>return</span> <span>l</span><span>;
}</span>
</pre></div>


<p>With the code for finding previous matches in place, we can finish the <span>lz77_compress</span> function:</p>

<div><pre>        <span>/* h is the hash of the three-byte prefix starting at position i. */</span>
        <span>h</span> <span>=</span> <span>0</span><span>;</span>
        <span>if</span> <span>(</span><span>len</span> <span>&gt;=</span> <span>2</span><span>) {</span>
                <span>h</span> <span>=</span> <span>update_hash</span><span>(</span><span>h</span><span>,</span> <span>src</span><span>[</span><span>0</span><span>]);</span>
                <span>h</span> <span>=</span> <span>update_hash</span><span>(</span><span>h</span><span>,</span> <span>src</span><span>[</span><span>1</span><span>]);
        }</span>

        <span>prev_match_len</span> <span>=</span> <span>0</span><span>;</span>
        <span>prev_match_pos</span> <span>=</span> <span>0</span><span>;</span>

        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>+</span> <span>2</span> <span>&lt;</span> <span>len</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>h</span> <span>=</span> <span>update_hash</span><span>(</span><span>h</span><span>,</span> <span>src</span><span>[</span><span>i</span> <span>+</span> <span>2</span><span>]);</span>

                <span>/* Search for a match using the hash table. */</span>
                <span>match_len</span> <span>=</span> <span>find_match</span><span>(</span><span>src</span><span>,</span> <span>i</span><span>,</span> <span>h</span><span>,</span> <span>prev_match_len</span><span>,</span>
                                       <span>min</span><span>(</span><span>LZ_MAX_LEN</span><span>,</span> <span>len</span> <span>-</span> <span>i</span><span>),</span> <span>head</span><span>,</span> <span>prev</span><span>,</span>
                                       <span>&amp;</span><span>match_pos</span><span>);</span>

                <span>/* Insert the current hash for future searches. */</span>
                <span>insert_hash</span><span>(</span><span>h</span><span>,</span> <span>i</span><span>,</span> <span>head</span><span>,</span> <span>prev</span><span>);</span>

                <span>/* If the previous match is at least as good as the current. */</span>
                <span>if</span> <span>(</span><span>prev_match_len</span> <span>!=</span> <span>0</span> <span>&amp;&amp;</span> <span>prev_match_len</span> <span>&gt;=</span> <span>match_len</span><span>) {</span>
                        <span>/* Output the previous match. */</span>
                        <span>dist</span> <span>=</span> <span>(</span><span>i</span> <span>-</span> <span>1</span><span>)</span> <span>-</span> <span>prev_match_pos</span><span>;</span>
                        <span>if</span> <span>(</span><span>!</span><span>backref_callback</span><span>(</span><span>dist</span><span>,</span> <span>prev_match_len</span><span>,</span> <span>aux</span><span>)) {</span>
                                <span>return</span> <span>false</span><span>;
                        }</span>
                        <span>/* Move past the match. */</span>
                        <span>for</span> <span>(</span><span>j</span> <span>=</span> <span>i</span> <span>+</span> <span>1</span><span>;</span> <span>j</span> <span>&lt;</span> <span>min</span><span>((</span><span>i</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>prev_match_len</span><span>,</span>
                                                <span>len</span> <span>-</span> <span>2</span><span>);</span> <span>j</span><span>++</span><span>) {</span>
                                <span>h</span> <span>=</span> <span>update_hash</span><span>(</span><span>h</span><span>,</span> <span>src</span><span>[</span><span>j</span> <span>+</span> <span>2</span><span>]);</span>
                                <span>insert_hash</span><span>(</span><span>h</span><span>,</span> <span>j</span><span>,</span> <span>head</span><span>,</span> <span>prev</span><span>);
                        }</span>
                        <span>i</span> <span>=</span> <span>(</span><span>i</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>prev_match_len</span> <span>-</span> <span>1</span><span>;</span>
                        <span>prev_match_len</span> <span>=</span> <span>0</span><span>;</span>
                        <span>continue</span><span>;
                }</span>

                <span>/* If no match (and no previous match), output literal. */</span>
                <span>if</span> <span>(</span><span>match_len</span> <span>==</span> <span>0</span><span>) {</span>
                        <span>assert</span><span>(</span><span>prev_match_len</span> <span>==</span> <span>0</span><span>);</span>
                        <span>if</span> <span>(</span><span>!</span><span>lit_callback</span><span>(</span><span>src</span><span>[</span><span>i</span><span>],</span> <span>aux</span><span>)) {</span>
                                <span>return</span> <span>false</span><span>;
                        }</span>
                        <span>continue</span><span>;
                }</span>

                <span>/* Otherwise the current match is better than the previous. */</span>

                <span>if</span> <span>(</span><span>prev_match_len</span> <span>!=</span> <span>0</span><span>) {</span>
                        <span>/* Output a literal instead of the previous match. */</span>
                        <span>if</span> <span>(</span><span>!</span><span>lit_callback</span><span>(</span><span>src</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>],</span> <span>aux</span><span>)) {</span>
                                <span>return</span> <span>false</span><span>;
                        }
                }</span>

                <span>/* Defer this match and see if the next is even better. */</span>
                <span>prev_match_len</span> <span>=</span> <span>match_len</span><span>;</span>
                <span>prev_match_pos</span> <span>=</span> <span>match_pos</span><span>;
        }</span>

        <span>/* Output any previous match. */</span>
        <span>if</span> <span>(</span><span>prev_match_len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>dist</span> <span>=</span> <span>(</span><span>i</span> <span>-</span> <span>1</span><span>)</span> <span>-</span> <span>prev_match_pos</span><span>;</span>
                <span>if</span> <span>(</span><span>!</span><span>backref_callback</span><span>(</span><span>dist</span><span>,</span> <span>prev_match_len</span><span>,</span> <span>aux</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }</span>
                <span>i</span> <span>=</span> <span>(</span><span>i</span> <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>prev_match_len</span><span>;
        }</span>

        <span>/* Output any remaining literals. */</span>
        <span>for</span> <span>(;</span> <span>i</span> <span>&lt;</span> <span>len</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>if</span> <span>(</span><span>!</span><span>lit_callback</span><span>(</span><span>src</span><span>[</span><span>i</span><span>],</span> <span>aux</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }
        }</span>

        <span>return</span> <span>true</span><span>;
}</span>
</pre></div>


<p>The code looks for the longest possible back reference that could be emitted at the current position. However, before outputting that back reference, it considers whether an even longer match could be found at the next position. zlib calls this <em>lazy match evaluation</em>. This is still a <em>greedy</em> algorithm: it chooses the longest match, even though a shorter match now might allow for a longer match later and better compression overall.</p>

<p>Lempel-Ziv compression can be both fast and slow. <a href="https://github.com/google/zopfli">Zopfli</a> spends a lot of time trying to find optimal back references to squeeze out a few extra percent of compression. This is useful for data that is compressed once and used many times, such as static content on a web server.  On the other end of the spectrum are compressors such as <a href="https://github.com/google/snappy">Snappy</a> and <a href="https://lz4.github.io/lz4/">LZ4</a>, which match only against the most recent 4-byte prefix and run very fast. Such compression can be useful in database or RPC systems, where a short moment spent compressing is paid off by time savings when sending data over the network or to and from disk.</p>

<p>The Lempel-Ziv idea of using the source data itself as the dictionary is very elegant, but using a static dictionary can still be beneficial. <a href="https://github.com/google/brotli">Brotli</a> is an LZ77-based compression algorithm, but it also uses a large <a href="https://gist.github.com/klauspost/2900d5ba6f9b65d69c8e">static dictionary</a> of strings that occur frequently on the web.</p>

<p>The LZ77 code is available in <a href="https://www.hanshq.net/files/hwzip/lz77.h"><span>lz77.h</span></a> and <a href="https://www.hanshq.net/files/hwzip/lz77.c"><span>lz77.c</span></a>.</p>

<h2>Huffman Coding</h2>

<p>The second ingredient in Zip compression is Huffman coding.</p>

<p>The term <em>code</em> in this context refers to a system for representing some data in another form. For our purposes, we are interested in codes that can be used to represent the literals and back references produced by the Lempel-Ziv compression above efficiently.</p>

<p>Computers traditionally represent English text using the <a href="https://en.wikipedia.org/wiki/ASCII">American Standard Code for Information Interchange (ASCII)</a>. That code assigns a number to each character, and computers typically store each such number in an 8-bit byte. For example, the text you are reading now is originally stored like that. Here is the ASCII code for the upper-case English alphabet:</p>

<table>
<tbody><tr>
<th>A</th> <td>01000001</td>
<th>N</th> <td>01001110</td>
</tr>

<tr>
<th>B</th> <td>01000010</td>
<th>O</th> <td>01001111</td>
</tr>

<tr>
<th>C</th> <td>01000011</td>
<th>P</th> <td>01010000</td>
</tr>

<tr>
<th>D</th> <td>01000100</td>
<th>Q</th> <td>01010001</td>
</tr>

<tr>
<th>E</th> <td>01000101</td>
<th>R</th> <td>01010010</td>
</tr>

<tr>
<th>F</th> <td>01000110</td>
<th>S</th> <td>01010011</td>
</tr>

<tr>
<th>G</th> <td>01000111</td>
<th>T</th> <td>01010100</td>
</tr>

<tr>
<th>H</th> <td>01001000</td>
<th>U</th> <td>01010101</td>
</tr>

<tr>
<th>I</th> <td>01001001</td>
<th>V</th> <td>01010110</td>
</tr>

<tr>
<th>J</th> <td>01001010</td>
<th>W</th> <td>01010111</td>
</tr>

<tr>
<th>K</th> <td>01001011</td>
<th>X</th> <td>01011000</td>
</tr>

<tr>
<th>L</th> <td>01001100</td>
<th>Y</th> <td>01011001</td>
</tr>

<tr>
<th>M</th> <td>01001101</td>
<th>Z</th> <td>01011010</td>
</tr>
</tbody></table>

<p>Using one byte per character is a convenient way of storing text. It makes it easy to access or change parts of the text, and it is obvious how many bytes are required to store <span>N</span> characters or how many characters are stored in <span>N</span> bytes. However, it is not the most space efficient way. For example, E and Z are the most and least used characters in English text, respectively. Therefore it would be more space efficient to use a shorter bit representation for E and a longer for Z, instead of using the same number of bits for each character.</p>

<p>A code that specifies different-length codewords for different source symbols is called a <em>variable-length code</em>. The most famous example is <a href="https://en.wikipedia.org/wiki/Morse_code">Morse code</a>, which encodes symbols using dots and dashes, originally transmitted as short and long electric pulses over a telegraph wire:</p>

<table>
<tbody><tr>
<th>A</th> <td>•&nbsp;−</td>
<th>N</th> <td>−&nbsp;•</td>
</tr>

<tr>
<th>B</th> <td>−&nbsp;•&nbsp;•&nbsp;•</td>
<th>O</th> <td>−&nbsp;−&nbsp;−</td>
</tr>

<tr>
<th>C</th> <td>−&nbsp;•&nbsp;−&nbsp;•</td>
<th>P</th> <td>•&nbsp;−&nbsp;−&nbsp;•</td>
</tr>

<tr>
<th>D</th> <td>−&nbsp;•&nbsp;•</td>
<th>Q</th> <td>−&nbsp;−&nbsp;•&nbsp;−</td>
</tr>

<tr>
<th>E</th> <td>•</td>
<th>R</th> <td>•&nbsp;−&nbsp;•</td>
</tr>

<tr>
<th>F</th> <td>•&nbsp;•&nbsp;−&nbsp;•</td>
<th>S</th> <td>•&nbsp;•&nbsp;•</td>
</tr>

<tr>
<th>G</th> <td>−&nbsp;−&nbsp;•</td>
<th>T</th> <td>−</td>
</tr>

<tr>
<th>H</th> <td>•&nbsp;•&nbsp;•&nbsp;•</td>
<th>U</th> <td>•&nbsp;•&nbsp;−</td>
</tr>

<tr>
<th>I</th> <td>•&nbsp;•</td>
<th>V</th> <td>•&nbsp;•&nbsp;•&nbsp;−</td>
</tr>

<tr>
<th>J</th> <td>•&nbsp;−&nbsp;−&nbsp;−</td>
<th>W</th> <td>•&nbsp;−&nbsp;−</td>
</tr>

<tr>
<th>K</th> <td>−&nbsp;•&nbsp;−</td>
<th>X</th> <td>−&nbsp;•&nbsp;•&nbsp;−</td>
</tr>

<tr>
<th>L</th> <td>•&nbsp;−&nbsp;•&nbsp;•</td>
<th>Y</th> <td>−&nbsp;•&nbsp;−&nbsp;−</td>
</tr>

<tr>
<th>M</th> <td>−&nbsp;−</td>
<th>Z</th> <td>−&nbsp;−&nbsp;•&nbsp;•</td>
</tr>
</tbody></table>

<p>One problem with Morse code is that one codeword can be the prefix of another. For example, •&nbsp;•&nbsp;−&nbsp;• is not uniquely decodable: it could mean either F or ER. This problem is solved by making pauses (the length of three dots) between letters during transmission. However, a better solution would be if no codeword was the prefix of another. Such a code is called a <em>prefix-free code</em>, or sometimes just <em>prefix code</em>. The fixed-length ASCII code above is trivially prefix-free since the codewords are all the same length, but variable-length codes can also be prefix-free. Telephone numbers are mostly prefix-free. Before the <a href="https://en.wikipedia.org/wiki/112_(emergency_telephone_number)">112</a> emergency telephone number was adopted in Sweden, all existing phone numbers starting with 112 had to be changed, and nobody in the US has a phone number starting with 911.</p>

<p>To minimize the size of an encoded message, we would like a prefix-free code where frequently occurring symbols have shorter codewords than infrequent ones. The optimum code would be one which generates the shortest possible result, that is, a code where the sum of the codeword lengths multiplied by their frequency of occurrence is as small as possible. This is called a <em>minimum-redundancy prefix-free code</em>, or these days a <em>Huffman code</em> after the man who invented an efficient algorithm for constructing them.</p>


<h3>Huffman's Algorithm</h3>

<p>While studying for his doctorate in electrical engineering at MIT, David A. Huffman took a course in information theory taught by Robert Fano. <a href="https://www.huffmancoding.com/my-uncle/scientific-american">According to legend</a>, Fano gave his students a choice between taking a final exam or writing a term paper. Huffman chose the latter, and was assigned the topic of finding minimum-redundancy prefix-free codes. Huffman was allegedly not aware that this was an open problem which Fano himself had worked on (the best known method at the time was <a href="https://en.wikipedia.org/wiki/Shannon%E2%80%93Fano_coding">Shannon-Fano coding</a>). Huffman's paper was published as <a href="https://www.ic.tu-berlin.de/fileadmin/fg121/Source-Coding_WS12/selected-readings/10_04051119.pdf">A Method for the Construction of Minimum-Redundancy Codes</a> in 1952, and the algorithm has been widely used ever since.</p>



<p>Huffman's algorithm creates a minimum-redundancy prefix-free code for a set of symbols and their frequencies of use. The algorithm works by repeatedly selecting the two symbols, say X and Y, with the lowest frequencies from the set, and replacing them with a single <em>composite symbol</em> which represents "X or Y". The frequency of the composite symbol is the sum of the frequencies of the two original symbols. The codewords for X and Y can be whatever codeword gets assigned to the composite "X or Y" symbol, followed by a 0 or 1 to differentiate between the two original symbols. When the set has been reduced to a single symbol, the algorithm is done. (See <a href="https://www.youtube.com/watch?v=ZdooBTdW5bM">this video</a> for a good explanation.)</p>


<p>Below is an example of running the algorithm on a small set of symbols:</p>

<table>
<tbody><tr><th>Symbol</th> <th>Frequency</th></tr>
<tr><td>A</td> <td>6</td></tr>
<tr><td>B</td> <td>4</td></tr>
<tr><td>C</td> <td>2</td></tr>
<tr><td>D</td> <td>3</td></tr>
</tbody></table>

<p>Initially, the set of symbols to be processed (coloured blue) is our original symbols:</p>

<p><img src="https://www.hanshq.net/gfx/tex_a8347fd0.png" alt="LaTeX"></p>

<p>The two lowest-frequency symbols, C and D, are removed from the set, and replaced by a composite symbol whose frequency is the sum of C and D's frequencies.</p>

<p><img src="https://www.hanshq.net/gfx/tex_98d681cf.png" alt="LaTeX"></p>

<p>The lowest-frequency symbols are now B and the composite symbol with frequency five. These are removed from the set, and a new composite symbol with frequency nine is inserted instead:</p>

<p><img src="https://www.hanshq.net/gfx/tex_a83ef7ed.png" alt="LaTeX"></p>

<p>Finally, A and the composite node with frequency 9 have the lowest frequencies, and so a composite node with frequency 15 is inserted.</p>

<p><img src="https://www.hanshq.net/gfx/tex_e999d62f.png" alt="LaTeX"></p>

<p>Since there is only one node left in the set, the algorithm is finished.</p>

<p>The algorithm leaves us with a structure called a <em>Huffman tree</em>. Note how it has our input symbols as leaves, and symbols with higher frequency are closer to the top. We can derive codewords for our symbols from this tree by starting at the root, walking towards a symbol, and adding a 0 or 1 to the codeword when going left or right, respectively. If we do that, we end up with:</p>

<table>
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>0</td></tr>
<tr><td>B</td> <td>10</td></tr>
<tr><td>C</td> <td>110</td></tr>
<tr><td>D</td> <td>111</td></tr>
</tbody></table>

<p>Note how none of the codewords are a prefix of another, and how the symbols with higher frequency have shorter codewords.</p>

<p>The tree can also be used for decoding: start at the root and go left or right for 0 or 1 until a symbol is reached. For example, the string 010100 decodes to ABBA.</p>

<p>Note that the length of each codeword equals the depth of the corresponding node in the tree. As we will see in the next section, we do not need the actual tree to assign codewords; knowing the lengths of the codewords is enough. Therefore, the output of our implementation of Huffman's algorithm will be those codeword lengths.</p>

<p>To store the set of symbols and efficiently find the one with lowest frequency, we use a <a href="https://en.wikipedia.org/wiki/Binary_heap">binary heap</a> data structure, specifically a <em>min-heap</em> since we want the minimum value on top.</p>

<div><pre><span>/* Swap the 32-bit values pointed to by a and b. */</span>
<span>static</span> <span>void</span> <span>swap32</span><span>(</span><span>uint32_t</span> <span>*</span><span>a</span><span>,</span> <span>uint32_t</span> <span>*</span><span>b</span><span>)
{</span>
        <span>uint32_t</span> <span>tmp</span><span>;</span>

        <span>tmp</span> <span>= *</span><span>a</span><span>;</span>
        <span>*</span><span>a</span> <span>= *</span><span>b</span><span>;</span>
        <span>*</span><span>b</span> <span>=</span> <span>tmp</span><span>;
}</span>

<span>/* Move element i in the n-element heap down to restore the minheap property. */</span>
<span>static</span> <span>void</span> <span>minheap_down</span><span>(</span><span>uint32_t</span> <span>*</span><span>heap</span><span>,</span> <span>size_t</span> <span>n</span><span>,</span> <span>size_t</span> <span>i</span><span>)
{</span>
        <span>size_t</span> <span>left</span><span>,</span> <span>right</span><span>,</span> <span>min</span><span>;</span>

        <span>assert</span><span>(</span><span>i</span> <span>&gt;=</span> <span>1</span> <span>&amp;&amp;</span> <span>i</span> <span>&lt;=</span> <span>n</span> <span>&amp;&amp;</span> <span>"i must be inside the heap"</span><span>);</span>

        <span>/* While the ith element has at least one child. */</span>
        <span>while</span> <span>(</span><span>i</span> <span>*</span> <span>2</span> <span>&lt;=</span> <span>n</span><span>) {</span>
                <span>left</span> <span>=</span> <span>i</span> <span>*</span> <span>2</span><span>;</span>
                <span>right</span> <span>=</span> <span>i</span> <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>;</span>

                <span>/* Find the child with lowest value. */</span>
                <span>min</span> <span>=</span> <span>left</span><span>;</span>
                <span>if</span> <span>(</span><span>right</span> <span>&lt;=</span> <span>n</span> <span>&amp;&amp;</span> <span>heap</span><span>[</span><span>right</span><span>]</span> <span>&lt;</span> <span>heap</span><span>[</span><span>left</span><span>]) {</span>
                        <span>min</span> <span>=</span> <span>right</span><span>;
                }</span>

                <span>/* Move i down if it is larger. */</span>
                <span>if</span> <span>(</span><span>heap</span><span>[</span><span>min</span><span>]</span> <span>&lt;</span> <span>heap</span><span>[</span><span>i</span><span>]) {</span>
                        <span>swap32</span><span>(</span><span>&amp;</span><span>heap</span><span>[</span><span>min</span><span>],</span> <span>&amp;</span><span>heap</span><span>[</span><span>i</span><span>]);</span>
                        <span>i</span> <span>=</span> <span>min</span><span>;
                }</span> <span>else</span> <span>{</span>
                        <span>break</span><span>;
                }
        }
}</span>

<span>/* Establish minheap property for heap[1..n]. */</span>
<span>static</span> <span>void</span> <span>minheap_heapify</span><span>(</span><span>uint32_t</span> <span>*</span><span>heap</span><span>,</span> <span>size_t</span> <span>n</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>;</span>

        <span>/* Floyd's algorithm. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>n</span> <span>/</span> <span>2</span><span>;</span> <span>i</span> <span>&gt;=</span> <span>1</span><span>;</span> <span>i</span><span>--</span><span>) {</span>
                <span>minheap_down</span><span>(</span><span>heap</span><span>,</span> <span>n</span><span>,</span> <span>i</span><span>);
        }
}</span>
</pre></div>


<p>To keep track of the frequency of up to <span>n</span> symbols we will use a heap of <span>n</span> elements. In addition, every time we create a composite symbol, we want to "link" the two original symbols to the new one. So each symbol will also have a "link element".</p>

<p>We will use a single array of <span>n * 2 + 1</span> elements to store the <span>n</span>-element heap and the <span>n</span> link elements. When two symbols in the heap are replaced by one, we will use the leftover array element to store the link of the new symbol. This is based on the implementation in Witten, Moffat and Bell's <a href="https://people.eng.unimelb.edu.au/ammoffat/mg/">Managing Gigabytes</a>.</p>

<p>In each heap node, we will use the upper 16 bits to store the symbol's frequency, and the lower 16 bits to store the index of the symbol's link element. By using the upper bits, the difference in frequency will determine the outcome of 32-bit comparisons between two heap elements.</p>

<p>Because of this representation, we must be sure that a symbol's frequency always fits within 16 bits. When the algorithm is finished, the final composite symbol will have the frequency of all original symbols combined, so therefore this sum must fit within 16 bits. Our Deflate implementation will make sure of this by processing at most 65,535 symbols at a time.</p>

<p>Symbols with zero frequency will receive a codeword length of zero and not take part in the construction of the code.</p>

<p>If a codeword exceeds the designated maximum length, we will "flatten" the distribution of the symbol frequencies by imposing a frequency cap and try again (yes, with a <span>goto</span>). There are more sophisticated ways of doing length-limited Huffman coding, but this is simple and effective.</p>

<div><pre><span>#define MAX_HUFFMAN_SYMBOLS 288      </span><span>/* Deflate uses max 288 symbols. */</span><span></span>

<span>/* Construct a Huffman code for n symbols with the frequencies in freq, and
 * codeword length limited to max_len. The sum of the frequencies must be &lt;=
 * UINT16_MAX. max_len must be large enough that a code is always possible,
 * i.e. 2 ** max_len &gt;= n. Symbols with zero frequency are not part of the code
 * and get length zero. Outputs the codeword lengths in lengths[0..n-1]. */</span>
<span>static</span> <span>void</span> <span>compute_huffman_lengths</span><span>(</span><span>const</span> <span>uint16_t</span> <span>*</span><span>freqs</span><span>,</span> <span>size_t</span> <span>n</span><span>,</span>
                                    <span>uint8_t</span> <span>max_len</span><span>,</span> <span>uint8_t</span> <span>*</span><span>lengths</span><span>)
{</span>
        <span>uint32_t</span> <span>nodes</span><span>[</span><span>MAX_HUFFMAN_SYMBOLS</span> <span>*</span> <span>2</span> <span>+</span> <span>1</span><span>],</span> <span>p</span><span>,</span> <span>q</span><span>;</span>
        <span>uint16_t</span> <span>freq</span><span>;</span>
        <span>size_t</span> <span>i</span><span>,</span> <span>h</span><span>,</span> <span>l</span><span>;</span>
        <span>uint16_t</span> <span>freq_cap</span> <span>=</span> <span>UINT16_MAX</span><span>;</span>

<span>#ifndef NDEBUG</span>
        <span>uint32_t</span> <span>freq_sum</span> <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>freq_sum</span> <span>+=</span> <span>freqs</span><span>[</span><span>i</span><span>];
        }</span>
        <span>assert</span><span>(</span><span>freq_sum</span> <span>&lt;=</span> <span>UINT16_MAX</span> <span>&amp;&amp;</span> <span>"Frequency sum too large!"</span><span>);</span>
<span>#endif</span>

        <span>assert</span><span>(</span><span>n</span> <span>&lt;=</span> <span>MAX_HUFFMAN_SYMBOLS</span><span>);</span>
        <span>assert</span><span>((</span><span>1U</span> <span>&lt;&lt;</span> <span>max_len</span><span>)</span> <span>&gt;=</span> <span>n</span> <span>&amp;&amp;</span> <span>"max_len must be large enough"</span><span>);</span>

<span>try_again</span><span>:</span>
        <span>/* Initialize the heap. h is the heap size. */</span>
        <span>h</span> <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>freq</span> <span>=</span> <span>freqs</span><span>[</span><span>i</span><span>];</span>

                <span>if</span> <span>(</span><span>freq</span> <span>==</span> <span>0</span><span>) {</span>
                        <span>continue</span><span>;</span> <span>/* Ignore zero-frequency symbols. */</span>
                <span>}</span>
                <span>if</span> <span>(</span><span>freq</span> <span>&gt;</span> <span>freq_cap</span><span>) {</span>
                        <span>freq</span> <span>=</span> <span>freq_cap</span><span>;</span> <span>/* Enforce the frequency cap. */</span>
                <span>}</span>

                <span>/* High 16 bits: Symbol frequency.
                   Low 16 bits:  Symbol link element index. */</span>
                <span>h</span><span>++</span><span>;</span>
                <span>nodes</span><span>[</span><span>h</span><span>]</span> <span>=</span> <span>((</span><span>uint32_t</span><span>)</span><span>freq</span> <span>&lt;&lt;</span> <span>16</span><span>)</span> <span>|</span> <span>(</span><span>uint32_t</span><span>)(</span><span>n</span> <span>+</span> <span>h</span><span>);
        }</span>
        <span>minheap_heapify</span><span>(</span><span>nodes</span><span>,</span> <span>h</span><span>);</span>

        <span>/* Special case for less than two non-zero symbols. */</span>
        <span>if</span> <span>(</span><span>h</span> <span>&lt;</span> <span>2</span><span>) {</span>
                <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                        <span>lengths</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>freqs</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>0</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>1</span><span>;
                }</span>
                <span>return</span><span>;
        }</span>

        <span>/* Build the Huffman tree. */</span>
        <span>while</span> <span>(</span><span>h</span> <span>&gt;</span> <span>1</span><span>) {</span>
                <span>/* Remove the lowest frequency node p from the heap. */</span>
                <span>p</span> <span>=</span> <span>nodes</span><span>[</span><span>1</span><span>];</span>
                <span>nodes</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>nodes</span><span>[</span><span>h</span><span>--</span><span>];</span>
                <span>minheap_down</span><span>(</span><span>nodes</span><span>,</span> <span>h</span><span>,</span> <span>1</span><span>);</span>

                <span>/* Get q, the next lowest frequency node. */</span>
                <span>q</span> <span>=</span> <span>nodes</span><span>[</span><span>1</span><span>];</span>

                <span>/* Replace q with a new symbol with the combined frequencies of
                   p and q, and with the no longer used h+1'th node as the
                   link element. */</span>
                <span>nodes</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>((</span><span>p</span> <span>&amp;</span> <span>0xffff0000</span><span>)</span> <span>+</span> <span>(</span><span>q</span> <span>&amp;</span> <span>0xffff0000</span><span>))</span>
                           <span>|</span> <span>(</span><span>uint32_t</span><span>)(</span><span>h</span> <span>+</span> <span>1</span><span>);</span>

                <span>/* Set the links of p and q to point to the link element of
                   the new node. */</span>
                <span>nodes</span><span>[</span><span>p</span> <span>&amp;</span> <span>0xffff</span><span>]</span> <span>=</span> <span>nodes</span><span>[</span><span>q</span> <span>&amp;</span> <span>0xffff</span><span>]</span> <span>=</span> <span>(</span><span>uint32_t</span><span>)(</span><span>h</span> <span>+</span> <span>1</span><span>);</span>

                <span>/* Move the new symbol down to restore heap property. */</span>
                <span>minheap_down</span><span>(</span><span>nodes</span><span>,</span> <span>h</span><span>,</span> <span>1</span><span>);
        }</span>

        <span>/* Compute the codeword length for each symbol. */</span>
        <span>h</span> <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>if</span> <span>(</span><span>freqs</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>0</span><span>) {</span>
                        <span>lengths</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
                        <span>continue</span><span>;
                }</span>
                <span>h</span><span>++</span><span>;</span>

                <span>/* Link element for the i'th symbol. */</span>
                <span>p</span> <span>=</span> <span>nodes</span><span>[</span><span>n</span> <span>+</span> <span>h</span><span>];</span>

                <span>/* Follow the links until we hit the root (link index 2). */</span>
                <span>l</span> <span>=</span> <span>1</span><span>;</span>
                <span>while</span> <span>(</span><span>p</span> <span>!=</span> <span>2</span><span>) {</span>
                        <span>l</span><span>++</span><span>;</span>
                        <span>p</span> <span>=</span> <span>nodes</span><span>[</span><span>p</span><span>];
                }</span>

                <span>if</span> <span>(</span><span>l</span> <span>&gt;</span> <span>max_len</span><span>) {</span>
                        <span>/* Lower freq_cap to flatten the distribution. */</span>
                        <span>assert</span><span>(</span><span>freq_cap</span> <span>!=</span> <span>1</span> <span>&amp;&amp;</span> <span>"Cannot lower freq_cap!"</span><span>);</span>
                        <span>freq_cap</span> <span>/=</span> <span>2</span><span>;</span>
                        <span>goto</span> <span>try_again</span><span>;
                }</span>

                <span>assert</span><span>(</span><span>l</span> <span>&lt;=</span> <span>UINT8_MAX</span><span>);</span>
                <span>lengths</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)</span><span>l</span><span>;
        }
}</span>
</pre></div>


<p>An elegant alternative to the binary heap approach is to store the symbols in two queues. The first queue contains the original symbols, sorted by frequency. When a composite symbol is created, it is added to the second queue. This way, the lowest-frequency symbol will always be found at the front of one of the queues. This was described by <a href="https://www.staff.science.uu.nl/~leeuw112/">Jan van Leeuwen</a> in <a href="https://www.staff.science.uu.nl/~leeuw112/huffman.pdf">On the Construction of Huffman Trees</a> (1976).</p>
<!-- Brotli uses this approach: https://github.com/google/brotli/blob/v1.0.7/c/enc/entropy_encode.c#L111 -->

<p>While Huffman codes are optimal as far as prefix-free codes go, there are more efficient ways to encode data beyond prefix coding, such as <a href="https://en.wikipedia.org/wiki/Arithmetic_coding">Arithmetic coding</a> and <a href="https://en.wikipedia.org/wiki/Asymmetric_numeral_systems">Asymmetric numeral systems</a>.</p>

<h3>Canonical Huffman Codes</h3>

<p>In the <a href="#earlier">earlier example</a> we ended up with the Huffman tree below.</p>

<p><img src="https://www.hanshq.net/gfx/tex_e999d62f.png" alt="LaTeX"></p>

<p>By walking down the tree from the root and using 0 for left branches and 1 for right branches, we ended up with the following code:</p>

<table>
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>0</td></tr>
<tr><td>B</td> <td>10</td></tr>
<tr><td>C</td> <td>110</td></tr>
<tr><td>D</td> <td>111</td></tr>
</tbody></table>

<p>The decision to use 0 for left 1 for right branches seems arbitrary. If we do the reverse we get:</p>

<table>
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>1</td></tr>
<tr><td>B</td> <td>01</td></tr>
<tr><td>C</td> <td>001</td></tr>
<tr><td>D</td> <td>000</td></tr>
</tbody></table>

<p>In fact, we can label the two edges from a node with 0 or 1 arbitrarily (as long as the labels are different) and still end up with an equivalent code:</p>

<p><img src="https://www.hanshq.net/gfx/tex_2403b72d.png" alt="LaTeX"></p>

<table>
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>0</td></tr>
<tr><td>B</td> <td>11</td></tr>
<tr><td>C</td> <td>100</td></tr>
<tr><td>D</td> <td>101</td></tr>
</tbody></table>


<p>This shows that while Huffman's algorithm gives the requisite codeword lengths for a minimum-redundancy prefix-free code, there are many ways of assigning the individual codewords.</p>
<p>Given codeword lengths computed by Huffman's algorithm, a <em>Canonical Huffman code</em> assigns codewords to symbols in a specific way. This is useful because it makes it sufficient to store and transmit the codeword lengths with the compressed data: the decoder can reconstruct the codewords based on the lengths. (One could of course also store and transmit the symbol frequencies and run Huffman's algorithm in the decoder, but that would require more work for the decoder and likely more storage space too.) Another very important property is that the structure of canonical codes facilitates efficient decoding.</p>

<p>The idea is to assign codewords to the symbols sequentially, one codeword length at a time. The initial codeword is 0. The next codeword of some length is the previous one plus 1. The first codeword of length N is constructed by taking the last codeword of length N-1, adding one (to get a new codeword) and shifting left one step (to increase the length).</p>

<p>Viewed in terms of a Huffman tree, codewords are assigned in sequence to the leaves in left-to-right order, one level at a time, shifting left when we move down one level.</p>
<!--See Knuth Vol 1, S 2.3.4.5, Ex. 4-->

<p>In our A, B, C, D example, Huffman's algorithm gave codeword lengths 1,2,3,3.  The first codeword is 0. That is also the last codeword of length 1. For length 2, we take the 0, add 1 to get the next code which will be the prefix of the two-bit codes: we shift it left and obtain 10. That is also the last codeword of length 2. To get to length 3, we add one and shift: 110. To get the next one of length 3, we add one: 111.</p>

<table>
<tbody><tr><th>Symbol</th> <th>codeword</th></tr>
<tr><td>A</td> <td>0</td></tr>
<tr><td>B</td> <td>10</td></tr>
<tr><td>C</td> <td>110</td></tr>
<tr><td>D</td> <td>111</td></tr>
</tbody></table>

<p>The implementation for generating the canonical codes is shown below. Note that the Deflate algorithm expects codewords to be emitted LSB-first, that is, the first bit of a codeword should be stored in the least significant bit. This means we have to reverse the bits, which can be done using a lookup table.</p>

<div><pre><span>#define MAX_HUFFMAN_BITS 15          </span><span>/* Deflate uses max 15-bit codewords. */</span><span></span>

<span>static</span> <span>void</span> <span>compute_canonical_code</span><span>(</span><span>uint16_t</span> <span>*</span><span>codewords</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>lengths</span><span>,</span>
                                   <span>size_t</span> <span>n</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>;</span>
        <span>uint16_t</span> <span>count</span><span>[</span><span>MAX_HUFFMAN_BITS</span> <span>+</span> <span>1</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
        <span>uint16_t</span> <span>code</span><span>[</span><span>MAX_HUFFMAN_BITS</span> <span>+</span> <span>1</span><span>];</span>
        <span>int</span> <span>l</span><span>;</span>

        <span>/* Count the number of codewords of each length. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>count</span><span>[</span><span>lengths</span><span>[</span><span>i</span><span>]]</span><span>++</span><span>;
        }</span>
        <span>count</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span> <span>/* Ignore zero-length codes. */

        /* Compute the first codeword for each length. */</span>
        <span>code</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>l</span> <span>=</span> <span>1</span><span>;</span> <span>l</span> <span>&lt;=</span> <span>MAX_HUFFMAN_BITS</span><span>;</span> <span>l</span><span>++</span><span>) {</span>
                <span>code</span><span>[</span><span>l</span><span>]</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)((</span><span>code</span><span>[</span><span>l</span> <span>-</span> <span>1</span><span>]</span> <span>+</span> <span>count</span><span>[</span><span>l</span> <span>-</span> <span>1</span><span>])</span> <span>&lt;&lt;</span> <span>1</span><span>);
        }</span>

        <span>/* Assign a codeword for each symbol. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>l</span> <span>=</span> <span>lengths</span><span>[</span><span>i</span><span>];</span>
                <span>if</span> <span>(</span><span>l</span> <span>==</span> <span>0</span><span>) {</span>
                        <span>continue</span><span>;
                }</span>

                <span>codewords</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>reverse16</span><span>(</span><span>code</span><span>[</span><span>l</span><span>]</span><span>++</span><span>,</span> <span>l</span><span>);</span> <span>/* Make it LSB-first. */</span>
        <span>}
}</span>

<span>/* Reverse the n least significant bits of x.
   The (16 - n) most significant bits of the result will be zero. */</span>
<span>static</span> <span>inline</span> <span>uint16_t</span> <span>reverse16</span><span>(</span><span>uint16_t</span> <span>x</span><span>,</span> <span>int</span> <span>n</span><span>)
{</span>
        <span>uint16_t</span> <span>lo</span><span>,</span> <span>hi</span><span>;</span>
        <span>uint16_t</span> <span>reversed</span><span>;</span>

        <span>assert</span><span>(</span><span>n</span> <span>&gt;</span> <span>0</span><span>);</span>
        <span>assert</span><span>(</span><span>n</span> <span>&lt;=</span> <span>16</span><span>);</span>

        <span>lo</span> <span>=</span> <span>x</span> <span>&amp;</span> <span>0xff</span><span>;</span>
        <span>hi</span> <span>=</span> <span>x</span> <span>&gt;&gt;</span> <span>8</span><span>;</span>

        <span>reversed</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)((</span><span>reverse8_tbl</span><span>[</span><span>lo</span><span>]</span> <span>&lt;&lt;</span> <span>8</span><span>)</span> <span>|</span> <span>reverse8_tbl</span><span>[</span><span>hi</span><span>]);</span>

        <span>return</span> <span>reversed</span> <span>&gt;&gt;</span> <span>(</span><span>16</span> <span>-</span> <span>n</span><span>);
}</span>
</pre></div>


<p>With all the parts now in place, we can write the code to initialize the encoder:</p>

<div><pre><span>typedef struct</span> <span>huffman_encoder_t huffman_encoder_t</span><span>;</span>
<span>struct</span> <span>huffman_encoder_t</span> <span>{</span>
        <span>uint16_t</span> <span>codewords</span><span>[</span><span>MAX_HUFFMAN_SYMBOLS</span><span>];</span> <span>/* LSB-first codewords. */</span>
        <span>uint8_t</span> <span>lengths</span><span>[</span><span>MAX_HUFFMAN_SYMBOLS</span><span>];</span>    <span>/* Codeword lengths. */</span>
<span>};</span>
</pre></div>

<div><pre><span>/* Initialize a Huffman encoder based on the n symbol frequencies. */</span>
<span>void</span> <span>huffman_encoder_init</span><span>(</span><span>huffman_encoder_t</span> <span>*</span><span>e</span><span>,</span> <span>const</span> <span>uint16_t</span> <span>*</span><span>freqs</span><span>,</span> <span>size_t</span> <span>n</span><span>,</span>
                          <span>uint8_t</span> <span>max_codeword_len</span><span>)
{</span>
        <span>assert</span><span>(</span><span>n</span> <span>&lt;=</span> <span>MAX_HUFFMAN_SYMBOLS</span><span>);</span>
        <span>assert</span><span>(</span><span>max_codeword_len</span> <span>&lt;=</span> <span>MAX_HUFFMAN_BITS</span><span>);</span>

        <span>compute_huffman_lengths</span><span>(</span><span>freqs</span><span>,</span> <span>n</span><span>,</span> <span>max_codeword_len</span><span>,</span> <span>e</span><span>-&gt;</span><span>lengths</span><span>);</span>
        <span>compute_canonical_code</span><span>(</span><span>e</span><span>-&gt;</span><span>codewords</span><span>,</span> <span>e</span><span>-&gt;</span><span>lengths</span><span>,</span> <span>n</span><span>);
}</span>
</pre></div>


<p>We also provide a function for setting up an encoder based on already computed code lengths:</p>

<div><pre><span>/* Initialize a Huffman encoder based on the n codeword lengths. */</span>
<span>void</span> <span>huffman_encoder_init2</span><span>(</span><span>huffman_encoder_t</span> <span>*</span><span>e</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>lengths</span><span>,</span>
                           <span>size_t</span> <span>n</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>;</span>

        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>e</span><span>-&gt;</span><span>lengths</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>lengths</span><span>[</span><span>i</span><span>];
        }</span>
        <span>compute_canonical_code</span><span>(</span><span>e</span><span>-&gt;</span><span>codewords</span><span>,</span> <span>e</span><span>-&gt;</span><span>lengths</span><span>,</span> <span>n</span><span>);
}</span>
</pre></div>



<h3>Efficient Huffman Decoding</h3>

<p>The most basic way of doing Huffman decoding is to walk the Huffman tree from the root, reading one bit of input at a time to decide whether to take the next left or right branch. Once a leaf node is reached, that is the decoded symbol.</p>

<p>The method above is often taught at universities and in textbooks. It is simple and elegant, but processing one bit at a time is relatively slow. A very fast way of decoding is to use a lookup table. For the code above where the max codeword length is three bits, we could use the following table:</p>

<table>
<tbody><tr><th>Bits</th> <th>Symbol</th> <th>Codeword Length</th></tr>
<tr><td><b>0</b>00</td> <td>A</td> <td>1</td></tr>
<tr><td><b>0</b>01</td> <td>A</td> <td>1</td></tr>
<tr><td><b>0</b>10</td> <td>A</td> <td>1</td></tr>
<tr><td><b>0</b>11</td> <td>A</td> <td>1</td></tr>
<tr><td><b>10</b>0</td> <td>B</td> <td>2</td></tr>
<tr><td><b>10</b>1</td> <td>B</td> <td>2</td></tr>
<tr><td><b>110</b></td> <td>C</td> <td>3</td></tr>
<tr><td><b>111</b></td> <td>D</td> <td>3</td></tr>
</tbody></table>

<p>Although there are only four symbols, the table needs to have eight entries to cover all possible three-bit inputs. Symbols with codewords shorter than three bits have multiple entries in the table. For example, the 10 codeword has been "padded" to <b>10</b>0 and <b>10</b>1 to cover all three-bit inputs starting with 10.</p>

<p>To perform decoding using this method, one would index into the table using the next three bits of input, and immediately find the corresponding symbol and its codeword length. The length is important, because even though we looked at the next three bits, we should only consume as many bits of input as the actual codeword is long.</p>

<p>The lookup table approach is very fast, but there is a downside: the table size doubles with each extra bit of codeword length. This means that building the table becomes exponentially slower, and using it may also become slower if it no longer fits in the CPU's cache.</p>

<p>Because of this, a lookup table is typically only used for codewords up to a certain length, and some other approach is used for longer codewords. As Huffman coding assigns shorter codewords to more frequent symbols, using a lookup table for short codewords is a great optimization for the common case.</p>

<p><a href="https://github.com/madler/zlib/blob/v1.2.11/doc/algorithm.txt#L58">The method used by zlib</a> is to have multiple levels of lookup tables. If a codeword is too long for the first table, the table entry will point to a secondary table, to be indexed with the remaining bits.</p>

<p>However, there is another very elegant method based on the properties of canonical Huffman codes. This is described in <a href="https://github.com/tpn/pdfs/raw/08eeeb9631252a7a8e61c160518d6f3ae98859b1/On%20the%20Implementation%20of%20Minimum%20Redundancy%20Prefix%20Codes%20(1997).pdf">On the Implementation of Minimum Redundancy Prefix Codes</a> (Moffat and Turpin 1997) and further explained in Charles Bloom's <a href="http://cbloomrants.blogspot.com/2010/08/08-12-10-lost-huffman-paper.html">The Lost Huffman Paper</a>.</p>

<p>Consider the codewords from our canonical code above: 0, 10, 110, 111. We will keep track of the first codeword of each length, and where in the sequence of assigned codewords it is, the "symbol index".</p>

<table>
<tbody><tr><th>Codeword Length</th> <th>First Codeword</th> <th>First Symbol Index</th></tr>
<tr><td>1</td> <td>0</td> <td>1 (A)</td></tr>
<tr><td>2</td> <td>10</td> <td>2 (B)</td></tr>
<tr><td>3</td> <td>110</td> <td>3 (C)</td></tr>
</tbody></table>

<p>Because the codewords are assigned sequentially, once we know how many bits of input to consider, the table above lets us find out what symbol index those bits represent. For example, for the 3-bit input 111, we see that this is at offset 1 from the first codeword of that length (110). The first symbol index of that length is 3, and the offset of 1 takes us to symbol index 4. Another table maps the symbol index to the symbol:</p>

<div><pre><span>sym_idx</span> <span>=</span> <span>d</span><span>-&gt;</span><span>first_symbol</span><span>[</span><span>len</span><span>]</span> <span>+</span> <span>(</span><span>bits</span> <span>-</span> <span>d</span><span>-&gt;</span><span>first_code</span><span>[</span><span>len</span><span>]);</span>
<span>sym</span> <span>=</span> <span>d</span><span>-&gt;</span><span>syms</span><span>[</span><span>sym_idx</span><span>];</span>
</pre></div>


<p>As a small optimization, instead of storing the first symbol index and first codeword separately, we can store the first symbol index minus the first codeword in a table:</p>

<div><pre><span>sym_idx</span> <span>=</span> <span>d</span><span>-&gt;</span><span>offset_first_sym_idx</span><span>[</span><span>len</span><span>]</span> <span>+</span> <span>bits</span><span>;</span>
<span>sym</span> <span>=</span> <span>d</span><span>-&gt;</span><span>syms</span><span>[</span><span>sym_idx</span><span>];</span>
</pre></div>


<p>To determine how many bits of input to consider, we again use the sequential property of the code. In our example code, the valid 1-bit codewords are all strictly less than 1, the 2-bit codewords are strictly less than 11, and the 3-bit codewords are strictly less than 1000 (trivially true for all 3-bit values). In other words, a valid N-bit codeword must be strictly less than the first N-bit codeword plus the number of N-bit codewords.  What is even more exciting is that we can left-shift those limits so that they are all 3 bits wide. Let us call them the <em>sentinel bits</em> for each codeword length:</p>

<table>
<tbody><tr><th>Codeword Length</th> <th>Sentinel Bits</th></tr>
<tr><td>1</td> <td>100</td>  </tr>
<tr><td>2</td> <td>110</td>  </tr>
<tr><td>3</td> <td>1000</td> </tr>
</tbody></table>

<p>(The length 3 sentinel has overflowed to 4 bits, but that just means any 3-bit input will do.)</p>

<p>This means we can look at three bits of input and compare against the sentinel bits to figure out how long our codeword is. Once that is done, we shift the input bits as to only consider the right number of them, and then find the symbol index as shown above:</p>

<div><pre><span>for</span> <span>(</span><span>len</span> <span>=</span> <span>1</span><span>;</span> <span>len</span> <span>&lt;=</span> <span>3</span><span>;</span> <span>len</span><span>++</span><span>) {</span>
        <span>if</span> <span>(</span><span>bits</span> <span>&lt;</span> <span>d</span><span>-&gt;</span><span>sentinel_bits</span><span>[</span><span>len</span><span>]) {</span>
                <span>bits</span> <span>&gt;&gt;=</span> <span>3</span> <span>-</span> <span>len</span><span>;</span>  <span>/* Get the len most significant bits. */</span>
                <span>sym_idx</span> <span>=</span> <span>d</span><span>-&gt;</span><span>offset_first_sym_idx</span><span>[</span><span>len</span><span>]</span> <span>+</span> <span>bits</span><span>;
        }
}</span>
</pre></div>


<p>The time complexity of this is linear in the number of codeword bits, but it is space efficient, requires only a load and comparison per step, and since shorter codewords are more frequent it optimizes for the common case.</p>

<p>The full decoder is shown below:</p>

<div><pre><span>#define HUFFMAN_LOOKUP_TABLE_BITS 8  </span><span>/* Seems a good trade-off. */</span><span></span>

<span>typedef struct</span> <span>huffman_decoder_t huffman_decoder_t</span><span>;</span>
<span>struct</span> <span>huffman_decoder_t</span> <span>{</span>
        <span>/* Lookup table for fast decoding of short codewords. */</span>
        <span>struct</span> <span>{</span>
                <span>uint16_t</span> <span>sym</span> <span>:</span> <span>9</span><span>;</span>  <span>/* Wide enough to fit the max symbol nbr. */</span>
                <span>uint16_t</span> <span>len</span> <span>:</span> <span>7</span><span>;</span>  <span>/* 0 means no symbol. */</span>
        <span>}</span> <span>table</span><span>[</span><span>1U</span> <span>&lt;&lt;</span> <span>HUFFMAN_LOOKUP_TABLE_BITS</span><span>];</span>

        <span>/* "Sentinel bits" value for each codeword length. */</span>
        <span>uint16_t</span> <span>sentinel_bits</span><span>[</span><span>MAX_HUFFMAN_BITS</span> <span>+</span> <span>1</span><span>];</span>

        <span>/* First symbol index minus first codeword mod 2**16 for each length. */</span>
        <span>uint16_t</span> <span>offset_first_sym_idx</span><span>[</span><span>MAX_HUFFMAN_BITS</span> <span>+</span> <span>1</span><span>];</span>

        <span>/* Map from symbol index to symbol. */</span>
        <span>uint16_t</span> <span>syms</span><span>[</span><span>MAX_HUFFMAN_SYMBOLS</span><span>];</span>
<span>#ifndef NDEBUG</span>
        <span>size_t</span> <span>num_syms</span><span>;</span>
<span>#endif</span>
<span>};</span>

<span>/* Get the n least significant bits of x. */</span>
<span>static</span> <span>inline</span> <span>uint64_t</span> <span>lsb</span><span>(</span><span>uint64_t</span> <span>x</span><span>,</span> <span>int</span> <span>n</span><span>)
{</span>
        <span>assert</span><span>(</span><span>n</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>n</span> <span>&lt;=</span> <span>63</span><span>);</span>
        <span>return</span> <span>x</span> <span>&amp;</span> <span>(((</span><span>uint64_t</span><span>)</span><span>1</span> <span>&lt;&lt;</span> <span>n</span><span>)</span> <span>-</span> <span>1</span><span>);
}</span>

<span>/* Use the decoder d to decode a symbol from the LSB-first zero-padded bits.
 * Returns the decoded symbol number or -1 if no symbol could be decoded.
 * *num_used_bits will be set to the number of bits used to decode the symbol,
 * or zero if no symbol could be decoded. */</span>
<span>static</span> <span>inline</span> <span>int</span> <span>huffman_decode</span><span>(</span><span>const</span> <span>huffman_decoder_t</span> <span>*</span><span>d</span><span>,</span> <span>uint16_t</span> <span>bits</span><span>,</span>
                                 <span>size_t</span> <span>*</span><span>num_used_bits</span><span>)
{</span>
        <span>uint64_t</span> <span>lookup_bits</span><span>;</span>
        <span>size_t</span> <span>l</span><span>;</span>
        <span>size_t</span> <span>sym_idx</span><span>;</span>

        <span>/* First try the lookup table. */</span>
        <span>lookup_bits</span> <span>=</span> <span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>HUFFMAN_LOOKUP_TABLE_BITS</span><span>);</span>
        <span>assert</span><span>(</span><span>lookup_bits</span> <span>&lt;</span> <span>sizeof</span><span>(</span><span>d</span><span>-&gt;</span><span>table</span><span>)</span> <span>/</span> <span>sizeof</span><span>(</span><span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>0</span><span>]));</span>
        <span>if</span> <span>(</span><span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>lookup_bits</span><span>].</span><span>len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>assert</span><span>(</span><span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>lookup_bits</span><span>].</span><span>len</span> <span>&lt;=</span> <span>HUFFMAN_LOOKUP_TABLE_BITS</span><span>);</span>
                <span>assert</span><span>(</span><span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>lookup_bits</span><span>].</span><span>sym</span> <span>&lt;</span> <span>d</span><span>-&gt;</span><span>num_syms</span><span>);</span>

                <span>*</span><span>num_used_bits</span> <span>=</span> <span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>lookup_bits</span><span>].</span><span>len</span><span>;</span>
                <span>return</span> <span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>lookup_bits</span><span>].</span><span>sym</span><span>;
        }</span>

        <span>/* Then do canonical decoding with the bits in MSB-first order. */</span>
        <span>bits</span> <span>=</span> <span>reverse16</span><span>(</span><span>bits</span><span>,</span> <span>MAX_HUFFMAN_BITS</span><span>);</span>
        <span>for</span> <span>(</span><span>l</span> <span>=</span> <span>HUFFMAN_LOOKUP_TABLE_BITS</span> <span>+</span> <span>1</span><span>;</span> <span>l</span> <span>&lt;=</span> <span>MAX_HUFFMAN_BITS</span><span>;</span> <span>l</span><span>++</span><span>) {</span>
                <span>if</span> <span>(</span><span>bits</span> <span>&lt;</span> <span>d</span><span>-&gt;</span><span>sentinel_bits</span><span>[</span><span>l</span><span>]) {</span>
                        <span>bits</span> <span>&gt;&gt;=</span> <span>MAX_HUFFMAN_BITS</span> <span>-</span> <span>l</span><span>;</span>

                        <span>sym_idx</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)(</span><span>d</span><span>-&gt;</span><span>offset_first_sym_idx</span><span>[</span><span>l</span><span>]</span> <span>+</span> <span>bits</span><span>);</span>
                        <span>assert</span><span>(</span><span>sym_idx</span> <span>&lt;</span> <span>d</span><span>-&gt;</span><span>num_syms</span><span>);</span>

                        <span>*</span><span>num_used_bits</span> <span>=</span> <span>l</span><span>;</span>
                        <span>return</span> <span>d</span><span>-&gt;</span><span>syms</span><span>[</span><span>sym_idx</span><span>];
                }
        }</span>

        <span>*</span><span>num_used_bits</span> <span>=</span> <span>0</span><span>;</span>
        <span>return</span> <span>-</span><span>1</span><span>;
}</span>
</pre></div>


<p>To set up the decoder, we compute the canonical code similarly to <a href="#huffman_encoder_init"><span>huffman_encoder_init</span></a> and fill in the various tables:</p>

<div><pre><span>/* Initialize huffman decoder d for a code defined by the n codeword lengths.
   Returns false if the codeword lengths do not correspond to a valid prefix
   code. */</span>
<span>bool</span> <span>huffman_decoder_init</span><span>(</span><span>huffman_decoder_t</span> <span>*</span><span>d</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>lengths</span><span>,</span>
                          <span>size_t</span> <span>n</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>;</span>
        <span>uint16_t</span> <span>count</span><span>[</span><span>MAX_HUFFMAN_BITS</span> <span>+</span> <span>1</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
        <span>uint16_t</span> <span>code</span><span>[</span><span>MAX_HUFFMAN_BITS</span> <span>+</span> <span>1</span><span>];</span>
        <span>uint32_t</span> <span>s</span><span>;</span>
        <span>uint16_t</span> <span>sym_idx</span><span>[</span><span>MAX_HUFFMAN_BITS</span> <span>+</span> <span>1</span><span>];</span>
        <span>int</span> <span>l</span><span>;</span>

<span>#ifndef NDEBUG</span>
        <span>assert</span><span>(</span><span>n</span> <span>&lt;=</span> <span>MAX_HUFFMAN_SYMBOLS</span><span>);</span>
        <span>d</span><span>-&gt;</span><span>num_syms</span> <span>=</span> <span>n</span><span>;</span>
<span>#endif</span>

        <span>/* Zero-initialize the lookup table. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>sizeof</span><span>(</span><span>d</span><span>-&gt;</span><span>table</span><span>)</span> <span>/</span> <span>sizeof</span><span>(</span><span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>0</span><span>]);</span> <span>i</span><span>++</span><span>) {</span>
                <span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>i</span><span>].</span><span>len</span> <span>=</span> <span>0</span><span>;
        }</span>

        <span>/* Count the number of codewords of each length. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>assert</span><span>(</span><span>lengths</span><span>[</span><span>i</span><span>]</span> <span>&lt;=</span> <span>MAX_HUFFMAN_BITS</span><span>);</span>
                <span>count</span><span>[</span><span>lengths</span><span>[</span><span>i</span><span>]]</span><span>++</span><span>;
        }</span>
        <span>count</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>  <span>/* Ignore zero-length codewords. */

        /* Compute sentinel_bits and offset_first_sym_idx for each length. */</span>
        <span>code</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
        <span>sym_idx</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>l</span> <span>=</span> <span>1</span><span>;</span> <span>l</span> <span>&lt;=</span> <span>MAX_HUFFMAN_BITS</span><span>;</span> <span>l</span><span>++</span><span>) {</span>
                <span>/* First canonical codeword of this length. */</span>
                <span>code</span><span>[</span><span>l</span><span>]</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)((</span><span>code</span><span>[</span><span>l</span> <span>-</span> <span>1</span><span>]</span> <span>+</span> <span>count</span><span>[</span><span>l</span> <span>-</span> <span>1</span><span>])</span> <span>&lt;&lt;</span> <span>1</span><span>);</span>

                <span>if</span> <span>(</span><span>count</span><span>[</span><span>l</span><span>]</span> <span>!=</span> <span>0</span> <span>&amp;&amp;</span> <span>code</span><span>[</span><span>l</span><span>]</span> <span>+</span> <span>count</span><span>[</span><span>l</span><span>]</span> <span>-</span> <span>1</span> <span>&gt;</span> <span>(</span><span>1U</span> <span>&lt;&lt;</span> <span>l</span><span>)</span> <span>-</span> <span>1</span><span>) {</span>
                        <span>/* The last codeword is longer than l bits. */</span>
                        <span>return</span> <span>false</span><span>;
                }</span>

                <span>s</span> <span>=</span> <span>(</span><span>uint32_t</span><span>)((</span><span>code</span><span>[</span><span>l</span><span>]</span> <span>+</span> <span>count</span><span>[</span><span>l</span><span>])</span> <span>&lt;&lt;</span> <span>(</span><span>MAX_HUFFMAN_BITS</span> <span>-</span> <span>l</span><span>));</span>
                <span>d</span><span>-&gt;</span><span>sentinel_bits</span><span>[</span><span>l</span><span>]</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)</span><span>s</span><span>;</span>
                <span>assert</span><span>(</span><span>d</span><span>-&gt;</span><span>sentinel_bits</span><span>[</span><span>l</span><span>]</span> <span>==</span> <span>s</span> <span>&amp;&amp;</span> <span>"No overflow."</span><span>);</span>

                <span>sym_idx</span><span>[</span><span>l</span><span>]</span> <span>=</span> <span>sym_idx</span><span>[</span><span>l</span> <span>-</span> <span>1</span><span>]</span> <span>+</span> <span>count</span><span>[</span><span>l</span> <span>-</span> <span>1</span><span>];</span>
                <span>d</span><span>-&gt;</span><span>offset_first_sym_idx</span><span>[</span><span>l</span><span>]</span> <span>=</span> <span>sym_idx</span><span>[</span><span>l</span><span>]</span> <span>-</span> <span>code</span><span>[</span><span>l</span><span>];
        }</span>

        <span>/* Build mapping from index to symbol and populate the lookup table. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>l</span> <span>=</span> <span>lengths</span><span>[</span><span>i</span><span>];</span>
                <span>if</span> <span>(</span><span>l</span> <span>==</span> <span>0</span><span>) {</span>
                        <span>continue</span><span>;
                }</span>

                <span>d</span><span>-&gt;</span><span>syms</span><span>[</span><span>sym_idx</span><span>[</span><span>l</span><span>]]</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)</span><span>i</span><span>;</span>
                <span>sym_idx</span><span>[</span><span>l</span><span>]</span><span>++</span><span>;</span>

                <span>if</span> <span>(</span><span>l</span> <span>&lt;=</span> <span>HUFFMAN_LOOKUP_TABLE_BITS</span><span>) {</span>
                        <span>table_insert</span><span>(</span><span>d</span><span>,</span> <span>i</span><span>,</span> <span>l</span><span>,</span> <span>code</span><span>[</span><span>l</span><span>]);</span>
                        <span>code</span><span>[</span><span>l</span><span>]</span><span>++</span><span>;
                }
        }</span>

        <span>return</span> <span>true</span><span>;
}</span>

<span>static</span> <span>void</span> <span>table_insert</span><span>(</span><span>huffman_decoder_t</span> <span>*</span><span>d</span><span>,</span> <span>size_t</span> <span>sym</span><span>,</span> <span>int</span> <span>len</span><span>,</span>
                         <span>uint16_t</span> <span>codeword</span><span>)
{</span>
        <span>int</span> <span>pad_len</span><span>;</span>
        <span>uint16_t</span> <span>padding</span><span>,</span> <span>index</span><span>;</span>

        <span>assert</span><span>(</span><span>len</span> <span>&lt;=</span> <span>HUFFMAN_LOOKUP_TABLE_BITS</span><span>);</span>

        <span>codeword</span> <span>=</span> <span>reverse16</span><span>(</span><span>codeword</span><span>,</span> <span>len</span><span>);</span> <span>/* Make it LSB-first. */</span>
        <span>pad_len</span> <span>=</span> <span>HUFFMAN_LOOKUP_TABLE_BITS</span> <span>-</span> <span>len</span><span>;</span>

        <span>/* Pad the pad_len upper bits with all bit combinations. */</span>
        <span>for</span> <span>(</span><span>padding</span> <span>=</span> <span>0</span><span>;</span> <span>padding</span> <span>&lt;</span> <span>(</span><span>1U</span> <span>&lt;&lt;</span> <span>pad_len</span><span>);</span> <span>padding</span><span>++</span><span>) {</span>
                <span>index</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)(</span><span>codeword</span> <span>|</span> <span>(</span><span>padding</span> <span>&lt;&lt;</span> <span>len</span><span>));</span>
                <span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>index</span><span>].</span><span>sym</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)</span><span>sym</span><span>;</span>
                <span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>index</span><span>].</span><span>len</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)</span><span>len</span><span>;</span>

                <span>assert</span><span>(</span><span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>index</span><span>].</span><span>sym</span> <span>==</span> <span>sym</span> <span>&amp;&amp;</span> <span>"Fits in bitfield."</span><span>);</span>
                <span>assert</span><span>(</span><span>d</span><span>-&gt;</span><span>table</span><span>[</span><span>index</span><span>].</span><span>len</span> <span>==</span> <span>len</span> <span>&amp;&amp;</span> <span>"Fits in bitfield."</span><span>);
        }
}</span>
</pre></div>


<h2>Deflate</h2>

<p>Deflate, introduced with PKZip 2.04c in 1993, is the default compression method in modern Zip files. It is also the compression method used in gzip, PNG, and many other file formats. It uses LZ77 compression and Huffman coding in a combination which will be described and implemented in this section.</p>

<p>Before Deflate, PKZip used compression methods called Shrink, Reduce, and Implode. Although those methods are rarely seen in use today, they were still in use some time after the introduction of Deflate since they required less memory. Those legacy methods are however beyond the scope of this article.</p>

<h3>Bitstreams</h3>

<p>Deflate stores Huffman codewords in a least-significant-bit-first (LSB-first) bitstream, meaning that the first bit of the stream is stored in the least significant bit of the first byte.</p>

<p>For example, consider this bit stream (read left-to-right): 1-0-0-1-1. When stored LSB-first in a byte, the byte's value becomes 0b00011001 (binary) or 0x19 (hexadecimal). This might seem backwards (in a sense it is), but one advantage is that it makes it easy to get the first N bits from a computer word: just mask off the N lowest bits.</p>

<p>The following routines are from <a href="https://www.hanshq.net/files/hwzip/bitstream.h"><span>bitstream.h</span></a>.</p>

<div><pre><span>/* Input bitstream. */</span>
<span>typedef struct</span> <span>istream_t istream_t</span><span>;</span>
<span>struct</span> <span>istream_t</span> <span>{</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>;</span>  <span>/* Source bytes. */</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>end</span><span>;</span>  <span>/* Past-the-end byte of src. */</span>
        <span>size_t</span> <span>bitpos</span><span>;</span>       <span>/* Position of the next bit to read. */</span>
        <span>size_t</span> <span>bitpos_end</span><span>;</span>   <span>/* Position of past-the-end bit. */</span>
<span>};</span>

<span>/* Initialize an input stream to present the n bytes from src as an LSB-first
 * bitstream. */</span>
<span>static</span> <span>inline</span> <span>void</span> <span>istream_init</span><span>(</span><span>istream_t</span> <span>*</span><span>is</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>n</span><span>)
{</span>
        <span>is</span><span>-&gt;</span><span>src</span> <span>=</span> <span>src</span><span>;</span>
        <span>is</span><span>-&gt;</span><span>end</span> <span>=</span> <span>src</span> <span>+</span> <span>n</span><span>;</span>
        <span>is</span><span>-&gt;</span><span>bitpos</span> <span>=</span> <span>0</span><span>;</span>
        <span>is</span><span>-&gt;</span><span>bitpos_end</span> <span>=</span> <span>n</span> <span>*</span> <span>8</span><span>;
}</span>
</pre></div>


<p>For our Huffman decoder, we want to look at the next bits in the stream (enough bits for the longest possible codeword), and then advance the stream by the number of bits used by the decoded symbol:</p>

<div><pre><span>#define ISTREAM_MIN_BITS (64 - 7)</span>

<span>/* Get the next bits from the input stream. The number of bits returned is
 * between ISTREAM_MIN_BITS and 64, depending on the position in the stream, or
 * fewer if the end of stream is reached. The upper bits are zero-padded. */</span>
<span>static</span> <span>inline</span> <span>uint64_t</span> <span>istream_bits</span><span>(</span><span>const</span> <span>istream_t</span> <span>*</span><span>is</span><span>)
{</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>next</span><span>;</span>
        <span>uint64_t</span> <span>bits</span><span>;</span>
        <span>int</span> <span>i</span><span>;</span>

        <span>next</span> <span>=</span> <span>is</span><span>-&gt;</span><span>src</span> <span>+</span> <span>(</span><span>is</span><span>-&gt;</span><span>bitpos</span> <span>/</span> <span>8</span><span>);</span>

        <span>assert</span><span>(</span><span>next</span> <span>&lt;=</span> <span>is</span><span>-&gt;</span><span>end</span> <span>&amp;&amp;</span> <span>"Cannot read past end of stream."</span><span>);</span>

        <span>if</span> <span>(</span><span>is</span><span>-&gt;</span><span>end</span> <span>-</span> <span>next</span> <span>&gt;=</span> <span>8</span><span>) {</span>
                <span>/* Common case: read 8 bytes in one go. */</span>
                <span>bits</span> <span>=</span> <span>read64le</span><span>(</span><span>next</span><span>);
        }</span> <span>else</span> <span>{</span>
                <span>/* Read the available bytes and zero-pad. */</span>
                <span>bits</span> <span>=</span> <span>0</span><span>;</span>
                <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>is</span><span>-&gt;</span><span>end</span> <span>-</span> <span>next</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                        <span>bits</span> <span>|=</span> <span>(</span><span>uint64_t</span><span>)</span><span>next</span><span>[</span><span>i</span><span>]</span> <span>&lt;&lt;</span> <span>(</span><span>i</span> <span>*</span> <span>8</span><span>);
                }
        }</span>

        <span>return</span> <span>bits</span> <span>&gt;&gt;</span> <span>(</span><span>is</span><span>-&gt;</span><span>bitpos</span> <span>%</span> <span>8</span><span>);
}</span>

<span>/* Advance n bits in the bitstream if possible. Returns false if that many bits
 * are not available in the stream. */</span>
<span>static</span> <span>inline</span> <span>bool</span> <span>istream_advance</span><span>(</span><span>istream_t</span> <span>*</span><span>is</span><span>,</span> <span>size_t</span> <span>n</span><span>) {</span>
        <span>if</span> <span>(</span><span>is</span><span>-&gt;</span><span>bitpos</span> <span>+</span> <span>n</span> <span>&gt;</span> <span>is</span><span>-&gt;</span><span>bitpos_end</span><span>) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>is</span><span>-&gt;</span><span>bitpos</span> <span>+=</span> <span>n</span><span>;</span>
        <span>return</span> <span>true</span><span>;
}</span>
</pre></div>



<p>The intention is that in the common case, <span>istream_bits</span> can execute as a single load instruction and some arithmetic on 64-bit machines, assuming the members of the <span>istream_t</span> struct are available in registers. <span>read64le</span> is implemented in <a href="https://www.hanshq.net/files/hwzip/bits.h"><span>bits.h</span></a> (modern compilers translate it to a single 64-bit load on little-endian):</p>

<div><pre><span>/* Read a 64-bit value from p in little-endian byte order. */</span>
<span>static</span> <span>inline</span> <span>uint64_t</span> <span>read64le</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>p</span><span>)
{</span>
        <span>/* The one true way, see
         * https://commandcenter.blogspot.com/2012/04/byte-order-fallacy.html */</span>
        <span>return</span> <span>((</span><span>uint64_t</span><span>)</span><span>p</span><span>[</span><span>0</span><span>]</span> <span>&lt;&lt;</span> <span>0</span><span>)</span>  <span>|</span>
               <span>((</span><span>uint64_t</span><span>)</span><span>p</span><span>[</span><span>1</span><span>]</span> <span>&lt;&lt;</span> <span>8</span><span>)</span>  <span>|</span>
               <span>((</span><span>uint64_t</span><span>)</span><span>p</span><span>[</span><span>2</span><span>]</span> <span>&lt;&lt;</span> <span>16</span><span>)</span> <span>|</span>
               <span>((</span><span>uint64_t</span><span>)</span><span>p</span><span>[</span><span>3</span><span>]</span> <span>&lt;&lt;</span> <span>24</span><span>)</span> <span>|</span>
               <span>((</span><span>uint64_t</span><span>)</span><span>p</span><span>[</span><span>4</span><span>]</span> <span>&lt;&lt;</span> <span>32</span><span>)</span> <span>|</span>
               <span>((</span><span>uint64_t</span><span>)</span><span>p</span><span>[</span><span>5</span><span>]</span> <span>&lt;&lt;</span> <span>40</span><span>)</span> <span>|</span>
               <span>((</span><span>uint64_t</span><span>)</span><span>p</span><span>[</span><span>6</span><span>]</span> <span>&lt;&lt;</span> <span>48</span><span>)</span> <span>|</span>
               <span>((</span><span>uint64_t</span><span>)</span><span>p</span><span>[</span><span>7</span><span>]</span> <span>&lt;&lt;</span> <span>56</span><span>);
}</span>
</pre></div>


<p>We also need a function to advance the bitstream to the next byte boundary:</p>

<div><pre><span>/* Round x up to the next multiple of m, which must be a power of 2. */</span>
<span>static</span> <span>inline</span> <span>size_t</span> <span>round_up</span><span>(</span><span>size_t</span> <span>x</span><span>,</span> <span>size_t</span> <span>m</span><span>)
{</span>
        <span>assert</span><span>((</span><span>m</span> <span>&amp;</span> <span>(</span><span>m</span> <span>-</span> <span>1</span><span>))</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>"m must be a power of two"</span><span>);</span>
        <span>return</span> <span>(</span><span>x</span> <span>+</span> <span>m</span> <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> <span>(</span><span>size_t</span><span>)(</span><span>-</span><span>m</span><span>);</span> <span>/* Hacker's Delight (2nd), 3-1. */</span>
<span>}</span>

<span>/* Align the input stream to the next 8-bit boundary and return a pointer to
 * that byte, which may be the past-the-end-of-stream byte. */</span>
<span>static</span> <span>inline</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>istream_byte_align</span><span>(</span><span>istream_t</span> <span>*</span><span>is</span><span>)
{</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>byte</span><span>;</span>

        <span>assert</span><span>(</span><span>is</span><span>-&gt;</span><span>bitpos</span> <span>&lt;=</span> <span>is</span><span>-&gt;</span><span>bitpos_end</span> <span>&amp;&amp;</span> <span>"Not past end of stream."</span><span>);</span>

        <span>is</span><span>-&gt;</span><span>bitpos</span> <span>=</span> <span>round_up</span><span>(</span><span>is</span><span>-&gt;</span><span>bitpos</span><span>,</span> <span>8</span><span>);</span>
        <span>byte</span> <span>=</span> <span>is</span><span>-&gt;</span><span>src</span> <span>+</span> <span>is</span><span>-&gt;</span><span>bitpos</span> <span>/</span> <span>8</span><span>;</span>
        <span>assert</span><span>(</span><span>byte</span> <span>&lt;=</span> <span>is</span><span>-&gt;</span><span>end</span><span>);</span>

        <span>return</span> <span>byte</span><span>;
}</span>
</pre></div>


<p>For the output bitstream, we write bits using a read-modify-write sequence. In the fast case, a bit write can be done by a 64-bit read, some bit operations, and a 64-bit write.</p>

<div><pre><span>/* Output bitstream. */</span>
<span>typedef struct</span> <span>ostream_t ostream_t</span><span>;</span>
<span>struct</span> <span>ostream_t</span> <span>{</span>
        <span>uint8_t</span> <span>*</span><span>dst</span><span>;</span>
        <span>uint8_t</span> <span>*</span><span>end</span><span>;</span>
        <span>size_t</span> <span>bitpos</span><span>;</span>
        <span>size_t</span> <span>bitpos_end</span><span>;
};</span>

<span>/* Initialize an output stream to write LSB-first bits into dst[0..n-1]. */</span>
<span>static</span> <span>inline</span> <span>void</span> <span>ostream_init</span><span>(</span><span>ostream_t</span> <span>*</span><span>os</span><span>,</span> <span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>size_t</span> <span>n</span><span>)
{</span>
        <span>os</span><span>-&gt;</span><span>dst</span> <span>=</span> <span>dst</span><span>;</span>
        <span>os</span><span>-&gt;</span><span>end</span> <span>=</span> <span>dst</span> <span>+</span> <span>n</span><span>;</span>
        <span>os</span><span>-&gt;</span><span>bitpos</span> <span>=</span> <span>0</span><span>;</span>
        <span>os</span><span>-&gt;</span><span>bitpos_end</span> <span>=</span> <span>n</span> <span>*</span> <span>8</span><span>;
}</span>

<span>/* Get the current bit position in the stream. */</span>
<span>static</span> <span>inline</span> <span>size_t</span> <span>ostream_bit_pos</span><span>(</span><span>const</span> <span>ostream_t</span> <span>*</span><span>os</span><span>)
{</span>
        <span>return</span> <span>os</span><span>-&gt;</span><span>bitpos</span><span>;
}</span>

<span>/* Return the number of bytes written to the output buffer. */</span>
<span>static</span> <span>inline</span> <span>size_t</span> <span>ostream_bytes_written</span><span>(</span><span>ostream_t</span> <span>*</span><span>os</span><span>)
{</span>
        <span>return</span> <span>round_up</span><span>(</span><span>os</span><span>-&gt;</span><span>bitpos</span><span>,</span> <span>8</span><span>)</span> <span>/</span> <span>8</span><span>;
}</span>

<span>/* Write n bits to the output stream. Returns false if there is not enough room
 * at the destination. */</span>
<span>static</span> <span>inline</span> <span>bool</span> <span>ostream_write</span><span>(</span><span>ostream_t</span> <span>*</span><span>os</span><span>,</span> <span>uint64_t</span> <span>bits</span><span>,</span> <span>size_t</span> <span>n</span><span>)
{</span>
        <span>uint8_t</span> <span>*</span><span>p</span><span>;</span>
        <span>uint64_t</span> <span>x</span><span>;</span>
        <span>int</span> <span>shift</span><span>,</span> <span>i</span><span>;</span>

        <span>assert</span><span>(</span><span>n</span> <span>&lt;=</span> <span>57</span><span>);</span>
        <span>assert</span><span>(</span><span>bits</span> <span>&lt;=</span> <span>((</span><span>uint64_t</span><span>)</span><span>1</span> <span>&lt;&lt;</span> <span>n</span><span>)</span> <span>-</span> <span>1</span> <span>&amp;&amp;</span> <span>"Must fit in n bits."</span><span>);</span>

        <span>if</span> <span>(</span><span>os</span><span>-&gt;</span><span>bitpos_end</span> <span>-</span> <span>os</span><span>-&gt;</span><span>bitpos</span> <span>&lt;</span> <span>n</span><span>) {</span>
                <span>/* Not enough room. */</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>p</span> <span>= &amp;</span><span>os</span><span>-&gt;</span><span>dst</span><span>[</span><span>os</span><span>-&gt;</span><span>bitpos</span> <span>/</span> <span>8</span><span>];</span>
        <span>shift</span> <span>=</span> <span>os</span><span>-&gt;</span><span>bitpos</span> <span>%</span> <span>8</span><span>;</span>

        <span>if</span> <span>(</span><span>os</span><span>-&gt;</span><span>end</span> <span>-</span> <span>p</span> <span>&gt;=</span> <span>8</span><span>) {</span>
                <span>/* Common case: read and write 8 bytes in one go. */</span>
                <span>x</span> <span>=</span> <span>read64le</span><span>(</span><span>p</span><span>);</span>
                <span>x</span> <span>=</span> <span>lsb</span><span>(</span><span>x</span><span>,</span> <span>shift</span><span>);</span>
                <span>x</span> <span>|=</span> <span>bits</span> <span>&lt;&lt;</span> <span>shift</span><span>;</span>
                <span>write64le</span><span>(</span><span>p</span><span>,</span> <span>x</span><span>);
        }</span> <span>else</span> <span>{</span>
                <span>/* Slow case: read/write as many bytes as are available. */</span>
                <span>x</span> <span>=</span> <span>0</span><span>;</span>
                <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>os</span><span>-&gt;</span><span>end</span> <span>-</span> <span>p</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                        <span>x</span> <span>|=</span> <span>(</span><span>uint64_t</span><span>)</span><span>p</span><span>[</span><span>i</span><span>]</span> <span>&lt;&lt;</span> <span>(</span><span>i</span> <span>*</span> <span>8</span><span>);
                }</span>
                <span>x</span> <span>=</span> <span>lsb</span><span>(</span><span>x</span><span>,</span> <span>shift</span><span>);</span>
                <span>x</span> <span>|=</span> <span>bits</span> <span>&lt;&lt;</span> <span>shift</span><span>;</span>
                <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>os</span><span>-&gt;</span><span>end</span> <span>-</span> <span>p</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                        <span>p</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>x</span> <span>&gt;&gt;</span> <span>(</span><span>i</span> <span>*</span> <span>8</span><span>));
                }
        }</span>

        <span>os</span><span>-&gt;</span><span>bitpos</span> <span>+=</span> <span>n</span><span>;</span>

        <span>return</span> <span>true</span><span>;
}</span>

<span>/* Write a 64-bit value x to dst in little-endian byte order. */</span>
<span>static</span> <span>inline</span> <span>void</span> <span>write64le</span><span>(</span><span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>uint64_t</span> <span>x</span><span>)
{</span>
        <span>dst</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>x</span> <span>&gt;&gt;</span> <span>0</span><span>);</span>
        <span>dst</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>x</span> <span>&gt;&gt;</span> <span>8</span><span>);</span>
        <span>dst</span><span>[</span><span>2</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>x</span> <span>&gt;&gt;</span> <span>16</span><span>);</span>
        <span>dst</span><span>[</span><span>3</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>x</span> <span>&gt;&gt;</span> <span>24</span><span>);</span>
        <span>dst</span><span>[</span><span>4</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>x</span> <span>&gt;&gt;</span> <span>32</span><span>);</span>
        <span>dst</span><span>[</span><span>5</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>x</span> <span>&gt;&gt;</span> <span>40</span><span>);</span>
        <span>dst</span><span>[</span><span>6</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>x</span> <span>&gt;&gt;</span> <span>48</span><span>);</span>
        <span>dst</span><span>[</span><span>7</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>x</span> <span>&gt;&gt;</span> <span>56</span><span>);
}</span>
</pre></div>


<p>We also want an efficient way of writing bytes to the stream. One could of course perform repeated 8-bit writes, but using <span>memcpy</span> is much faster:</p>

<div><pre><span>/* Align the bitstream to the next byte boundary, then write the n bytes from
   src to it. Returns false if there is not enough room in the stream. */</span>
<span>static</span> <span>inline</span> <span>bool</span> <span>ostream_write_bytes_aligned</span><span>(</span><span>ostream_t</span> <span>*</span><span>os</span><span>,</span>
                                               <span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span>
                                               <span>size_t</span> <span>n</span><span>)
{</span>
        <span>if</span> <span>(</span><span>os</span><span>-&gt;</span><span>bitpos_end</span> <span>-</span> <span>round_up</span><span>(</span><span>os</span><span>-&gt;</span><span>bitpos</span><span>,</span> <span>8</span><span>)</span> <span>&lt;</span> <span>n</span> <span>*</span> <span>8</span><span>) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>os</span><span>-&gt;</span><span>bitpos</span> <span>=</span> <span>round_up</span><span>(</span><span>os</span><span>-&gt;</span><span>bitpos</span><span>,</span> <span>8</span><span>);</span>
        <span>memcpy</span><span>(</span><span>&amp;</span><span>os</span><span>-&gt;</span><span>dst</span><span>[</span><span>os</span><span>-&gt;</span><span>bitpos</span> <span>/</span> <span>8</span><span>],</span> <span>src</span><span>,</span> <span>n</span><span>);</span>
        <span>os</span><span>-&gt;</span><span>bitpos</span> <span>+=</span> <span>n</span> <span>*</span> <span>8</span><span>;</span>

        <span>return</span> <span>true</span><span>;
}</span>
</pre></div>


<h3>Decompression (Inflation)</h3>

<p>Since the compression algorithm is called <i>Deflate</i>—to let the air out of something—the decompression process is sometimes referred to as <i>Inflation</i>. Studying this process first will give us an understanding of how the format works.
The code is available in the first part of
<a href="https://www.hanshq.net/files/hwzip/deflate.h"><span>deflate.h</span></a> and
<a href="https://www.hanshq.net/files/hwzip/deflate.c"><span>deflate.c</span></a>,
<a href="https://www.hanshq.net/files/hwzip/bits.h"><span>bits.h</span></a>,
<a href="https://www.hanshq.net/files/hwzip/tables.h"><span>tables.h</span></a>, and
<a href="https://www.hanshq.net/files/hwzip/tables.c"><span>tables.c</span></a>
(generated by <a href="https://www.hanshq.net/files/hwzip/generate_tables.c"><span>generate_tables.c</span></a>).
</p>

<p>Deflate-compressed data is stored as a series of <i>blocks</i>. Each block starts with a 3-bit header where the first (least significant) bit is set if this is the final block of the series, and the other two bits indicate the block type.</p>

<p><img src="https://www.hanshq.net/gfx/tex_4858bc99.png" alt="LaTeX"></p>

<p>There are three block types: uncompressed (0), compressed with fixed Huffman codes (1) and compressed with "dynamic" Huffman codes (2).</p>

<p>The following code drives the decompression, relying on helper functions for the different block types which will be implemented further below.</p>

<div><pre><span>typedef enum</span> <span>{</span>
        <span>HWINF_OK</span><span>,</span>   <span>/* Inflation was successful. */</span>
        <span>HWINF_FULL</span><span>,</span> <span>/* Not enough room in the output buffer. */</span>
        <span>HWINF_ERR</span>   <span>/* Error in the input data. */</span>
<span>}</span> <span>inf_stat_t</span><span>;</span>

<span>/* Decompress (inflate) the Deflate stream in src. The number of input bytes
   used, at most src_len, is stored in *src_used on success. Output is written
   to dst. The number of bytes written, at most dst_cap, is stored in *dst_used
   on success. src[0..src_len-1] and dst[0..dst_cap-1] must not overlap.
   Returns a status value as defined above. */</span>
<span>inf_stat_t</span> <span>hwinflate</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>src_len</span><span>,</span> <span>size_t</span> <span>*</span><span>src_used</span><span>,</span>
                     <span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>size_t</span> <span>dst_cap</span><span>,</span> <span>size_t</span> <span>*</span><span>dst_used</span><span>)
{</span>
        <span>istream_t</span> <span>is</span><span>;</span>
        <span>size_t</span> <span>dst_pos</span><span>;</span>
        <span>uint64_t</span> <span>bits</span><span>;</span>
        <span>bool</span> <span>bfinal</span><span>;</span>
        <span>inf_stat_t</span> <span>s</span><span>;</span>

        <span>istream_init</span><span>(</span><span>&amp;</span><span>is</span><span>,</span> <span>src</span><span>,</span> <span>src_len</span><span>);</span>
        <span>dst_pos</span> <span>=</span> <span>0</span><span>;</span>

        <span>do</span> <span>{</span>
                <span>/* Read the 3-bit block header. */</span>
                <span>bits</span> <span>=</span> <span>istream_bits</span><span>(</span><span>&amp;</span><span>is</span><span>);</span>
                <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>&amp;</span><span>is</span><span>,</span> <span>3</span><span>)) {</span>
                        <span>return</span> <span>HWINF_ERR</span><span>;
                }</span>
                <span>bfinal</span> <span>=</span> <span>bits</span> <span>&amp;</span> <span>1</span><span>;</span>
                <span>bits</span> <span>&gt;&gt;=</span> <span>1</span><span>;</span>

                <span>switch</span> <span>(</span><span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>2</span><span>)) {</span>
                <span>case</span> <span>0</span><span>:</span> <span>/* 00: No compression. */</span>
                        <span>s</span> <span>=</span> <span>inf_noncomp_block</span><span>(</span><span>&amp;</span><span>is</span><span>,</span> <span>dst</span><span>,</span> <span>dst_cap</span><span>,</span> <span>&amp;</span><span>dst_pos</span><span>);</span>
                        <span>break</span><span>;</span>
                <span>case</span> <span>1</span><span>:</span> <span>/* 01: Compressed with fixed Huffman codes. */</span>
                        <span>s</span> <span>=</span> <span>inf_fixed_block</span><span>(</span><span>&amp;</span><span>is</span><span>,</span> <span>dst</span><span>,</span> <span>dst_cap</span><span>,</span> <span>&amp;</span><span>dst_pos</span><span>);</span>
                        <span>break</span><span>;</span>
                <span>case</span> <span>2</span><span>:</span> <span>/* 10: Compressed with "dynamic" Huffman codes. */</span>
                        <span>s</span> <span>=</span> <span>inf_dyn_block</span><span>(</span><span>&amp;</span><span>is</span><span>,</span> <span>dst</span><span>,</span> <span>dst_cap</span><span>,</span> <span>&amp;</span><span>dst_pos</span><span>);</span>
                        <span>break</span><span>;</span>
                <span>default</span><span>:</span> <span>/* Invalid block type. */</span>
                        <span>return</span> <span>HWINF_ERR</span><span>;
                }</span>

                <span>if</span> <span>(</span><span>s</span> <span>!=</span> <span>HWINF_OK</span><span>) {</span>
                        <span>return</span> <span>s</span><span>;
                }
        }</span> <span>while</span> <span>(</span><span>!</span><span>bfinal</span><span>);</span>

        <span>*</span><span>src_used</span> <span>=</span> <span>(</span><span>size_t</span><span>)(</span><span>istream_byte_align</span><span>(</span><span>&amp;</span><span>is</span><span>)</span> <span>-</span> <span>src</span><span>);</span>

        <span>assert</span><span>(</span><span>dst_pos</span> <span>&lt;=</span> <span>dst_cap</span><span>);</span>
        <span>*</span><span>dst_used</span> <span>=</span> <span>dst_pos</span><span>;</span>

        <span>return</span> <span>HWINF_OK</span><span>;
}</span>
</pre></div>


<h4>Non-Compressed Deflate Blocks</h4>

<p>The simplest block type is the non-compressed or "stored" block. It begins at the next 8-bit boundary of the bitstream, with a 16-bit word (<span>len</span>) indicating the length of the block, followed by another 16-bit word (<span>nlen</span>) which is the ones' complement (all bits inverted) of <span>len</span>. The idea is presumably that <span>nlen</span> acts as a simple checksum of <span>len</span>: if the file is corrupted, it is likely that the values are no longer each others' complements, and the program can detect the error.</p>

<p><img src="https://www.hanshq.net/gfx/tex_a74faf22.png" alt="LaTeX"></p>


<p>After <span>len</span> and <span>nlen</span> follows the non-compressed data. Because the block length is a 16-bit value, it is limited to 65,535 bytes.</p>

<div><pre><span>static</span> <span>inf_stat_t</span> <span>inf_noncomp_block</span><span>(</span><span>istream_t</span> <span>*</span><span>is</span><span>,</span> <span>uint8_t</span> <span>*</span><span>dst</span><span>,</span>
                                    <span>size_t</span> <span>dst_cap</span><span>,</span> <span>size_t</span> <span>*</span><span>dst_pos</span><span>)
{</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>p</span><span>;</span>
        <span>uint16_t</span> <span>len</span><span>,</span> <span>nlen</span><span>;</span>

        <span>p</span> <span>=</span> <span>istream_byte_align</span><span>(</span><span>is</span><span>);</span>

        <span>/* Read len and nlen (2 x 16 bits). */</span>
        <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>32</span><span>)) {</span>
                <span>return</span> <span>HWINF_ERR</span><span>;</span> <span>/* Not enough input. */</span>
        <span>}</span>
        <span>len</span>  <span>=</span> <span>read16le</span><span>(</span><span>p</span><span>);</span>
        <span>nlen</span> <span>=</span> <span>read16le</span><span>(</span><span>p</span> <span>+</span> <span>2</span><span>);</span>
        <span>p</span> <span>+=</span> <span>4</span><span>;</span>

        <span>if</span> <span>(</span><span>nlen</span> <span>!=</span> <span>(</span><span>uint16_t</span><span>)</span><span>~</span><span>len</span><span>) {</span>
                <span>return</span> <span>HWINF_ERR</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>len</span> <span>*</span> <span>8</span><span>)) {</span>
                <span>return</span> <span>HWINF_ERR</span><span>;</span> <span>/* Not enough input. */</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>dst_cap</span> <span>- *</span><span>dst_pos</span> <span>&lt;</span> <span>len</span><span>) {</span>
                <span>return</span> <span>HWINF_FULL</span><span>;</span> <span>/* Not enough room to output. */</span>
        <span>}</span>

        <span>memcpy</span><span>(</span><span>&amp;</span><span>dst</span><span>[</span><span>*</span><span>dst_pos</span><span>],</span> <span>p</span><span>,</span> <span>len</span><span>);</span>
        <span>*</span><span>dst_pos</span> <span>+=</span> <span>len</span><span>;</span>

        <span>return</span> <span>HWINF_OK</span><span>;
}</span>
</pre></div>


<h4>Fixed Huffman Code Deflate Blocks</h4>

<p>Compressed Deflate blocks use Huffman codes to represent a sequence of LZ77 literals and back references terminated by an end-of-block marker. One Huffman code, the <em>litlen code</em>, is used for literals, back reference lengths, and the end-of-block marker. A second code, the <em>dist code</em>, is used for back reference distances.</p>

<p><img src="https://www.hanshq.net/gfx/tex_b3cfba44.png" alt="LaTeX"></p>



<p>The litlen code encodes values between 0 and 285. Values 0 through 255 represent literal bytes, 256 is the end-of-block marker, and values 257 through 285 represent back reference lengths.</p>

<p>Back references are between 3 and 258 bytes long. The litlen value determines a base length to which zero or more <em>extra bits</em> from the stream are added to get the full length according to the table below. For example, a litlen value of 269 indicates a base length of 19 and two extra bits. Adding the next two bits from the stream yields a final length between 19 and 22.</p>


<table>
<tbody><tr><th>Litlen</th> <th>Extra Bits</th> <th>Length(s)</th></tr>
<tr><td>257</td> <td>0</td> <td>3</td></tr>
<tr><td>258</td> <td>0</td> <td>4</td></tr>
<tr><td>259</td> <td>0</td> <td>5</td></tr>
<tr><td>260</td> <td>0</td> <td>6</td></tr>
<tr><td>261</td> <td>0</td> <td>7</td></tr>
<tr><td>262</td> <td>0</td> <td>8</td></tr>
<tr><td>263</td> <td>0</td> <td>9</td></tr>
<tr><td>264</td> <td>0</td> <td>10</td></tr>
<tr><td>265</td> <td>1</td> <td>11–12</td></tr>
<tr><td>266</td> <td>1</td> <td>13–14</td></tr>
<tr><td>267</td> <td>1</td> <td>15–16</td></tr>
<tr><td>268</td> <td>1</td> <td>17–18</td></tr>
<tr><td>269</td> <td>2</td> <td>19–22</td></tr>
<tr><td>270</td> <td>2</td> <td>23–26</td></tr>
<tr><td>271</td> <td>2</td> <td>27–30</td></tr>
<tr><td>272</td> <td>2</td> <td>31–34</td></tr>
<tr><td>273</td> <td>3</td> <td>35–42</td></tr>
<tr><td>274</td> <td>3</td> <td>43–50</td></tr>
<tr><td>275</td> <td>3</td> <td>51–58</td></tr>
<tr><td>276</td> <td>3</td> <td>59–66</td></tr>
<tr><td>277</td> <td>4</td> <td>67–82</td></tr>
<tr><td>278</td> <td>4</td> <td>83–98</td></tr>
<tr><td>279</td> <td>4</td> <td>99–114</td></tr>
<tr><td>280</td> <td>4</td> <td>115–130</td></tr>
<tr><td>281</td> <td>5</td> <td>131–162</td></tr>
<tr><td>282</td> <td>5</td> <td>163–194</td></tr>
<tr><td>283</td> <td>5</td> <td>195–226</td></tr>
<tr><td>284</td> <td>5</td> <td>227–257</td></tr>
<tr><td>285</td> <td>0</td> <td>258</td></tr>
</tbody></table>

<p>(Note that litlen value 284 plus five extra bits could actually represents lengths 227–258, but the specification indicates that 258, the maximum back reference length, should be represented using a separate litlen value. This is presumably to allow for a shorter encoding in cases where the maximum length is common.)</p>

<p>The decompressor uses a table that maps from litlen value (minus 257) to base length and extra bits:</p>

<div><pre><span>/* Table of litlen symbol values minus 257 with corresponding base length
   and number of extra bits. */</span>
<span>struct</span> <span>litlen_tbl_t</span> <span>{</span>
        <span>uint16_t</span> <span>base_len</span> <span>:</span> <span>9</span><span>;</span>
        <span>uint16_t</span> <span>ebits</span> <span>:</span> <span>7</span><span>;
};</span>
<span>const struct</span> <span>litlen_tbl_t</span> <span>litlen_tbl</span><span>[</span><span>29</span><span>]</span> <span>=</span> <span>{</span>
<span>/* 257 */</span> <span>{</span> <span>3</span><span>,</span> <span>0</span> <span>},</span>
<span>/* 258 */</span> <span>{</span> <span>4</span><span>,</span> <span>0</span> <span>},

...</span>

<span>/* 284 */</span> <span>{</span> <span>227</span><span>,</span> <span>5</span> <span>},</span>
<span>/* 285 */</span> <span>{</span> <span>258</span><span>,</span> <span>0</span> <span>}
};</span>
</pre></div>


<p>The fixed litlen Huffman code is a canonical code using the following codeword lengths (286–287 are not valid litlen values, but they participate in the code construction):</p>

<table>
<tbody><tr><th>Litlen values</th> <th>Codeword length</th></tr>
<tr><td>0–143</td>   <td>8</td></tr>
<tr><td>144–255</td> <td>9</td></tr>
<tr><td>256–279</td> <td>7</td></tr>
<tr><td>280–287</td> <td>8</td></tr>
</tbody></table>

<p>The decompressor keeps those lengths in a table suitable for passing to <span>huffman_decoder_init</span>:</p>

<div><pre><span>const</span> <span>uint8_t</span> <span>fixed_litlen_lengths</span><span>[</span><span>288</span><span>]</span> <span>=</span> <span>{</span>
<span>/*   0 */</span> <span>8</span><span>,</span>
<span>/*   1 */</span> <span>8</span><span>,

...</span>

<span>/* 287 */</span> <span>8</span><span>,
};</span>
</pre></div>


<p>Back reference distances, ranging from 1 to 32,768, are encoded using a scheme similar to the one for lengths. The dist Huffman code encodes values between 0 and 29, each corresponding to a base length to which a number of extra bits are added to get the final distance:</p>

<table>
<tbody><tr><th>Dist</th> <th>Extra Bits</th> <th>Distance(s)</th></tr>
<tr><td>0</td>  <td>0</td>  <td>1</td></tr>
<tr><td>1</td>  <td>0</td>  <td>2</td></tr>
<tr><td>2</td>  <td>0</td>  <td>3</td></tr>
<tr><td>3</td>  <td>0</td>  <td>4</td></tr>
<tr><td>4</td>  <td>1</td>  <td>5–6</td></tr>
<tr><td>5</td>  <td>1</td>  <td>7–8</td></tr>
<tr><td>6</td>  <td>2</td>  <td>9–12</td></tr>
<tr><td>7</td>  <td>2</td>  <td>13–16</td></tr>
<tr><td>8</td>  <td>3</td>  <td>17–24</td></tr>
<tr><td>9</td>  <td>3</td>  <td>25–32</td></tr>
<tr><td>10</td> <td>4</td>  <td>33–48</td></tr>
<tr><td>11</td> <td>4</td>  <td>49–64</td></tr>
<tr><td>12</td> <td>5</td>  <td>65–96</td></tr>
<tr><td>13</td> <td>5</td>  <td>97–128</td></tr>
<tr><td>14</td> <td>6</td>  <td>129–192</td></tr>
<tr><td>15</td> <td>6</td>  <td>193–256</td></tr>
<tr><td>16</td> <td>7</td>  <td>257–384</td></tr>
<tr><td>17</td> <td>7</td>  <td>385–512</td></tr>
<tr><td>18</td> <td>8</td>  <td>513–768</td></tr>
<tr><td>19</td> <td>8</td>  <td>769–1024</td></tr>
<tr><td>20</td> <td>9</td>  <td>1025–1536</td></tr>
<tr><td>21</td> <td>9</td>  <td>1537–2048</td></tr>
<tr><td>22</td> <td>10</td> <td>2049–3072</td></tr>
<tr><td>23</td> <td>10</td> <td>3073–4096</td></tr>
<tr><td>24</td> <td>11</td> <td>4097–6144</td></tr>
<tr><td>25</td> <td>11</td> <td>6145–8192</td></tr>
<tr><td>26</td> <td>12</td> <td>8193–12288</td></tr>
<tr><td>27</td> <td>12</td> <td>12289–16384</td></tr>
<tr><td>28</td> <td>13</td> <td>16385–24576</td></tr>
<tr><td>29</td> <td>13</td> <td>24577–32768</td></tr>
</tbody></table>

<p>The fixed dist code is a canonical Huffman code where all codewords are 5 bits long. Although trivial, the decompressor keeps it in a table so that it can be used with <span>huffman_decoder_init</span> (dist values 30–31 are not valid, but are specified as participating in the Huffman code construction, though they do not have any effect):</p>

<div><pre><span>const</span> <span>uint8_t</span> <span>fixed_dist_lengths</span><span>[</span><span>32</span><span>]</span> <span>=</span> <span>{</span>
<span>/*  0 */</span> <span>5</span><span>,</span>
<span>/*  1 */</span> <span>5</span><span>,

...</span>

<span>/* 31 */</span> <span>5</span><span>,
};</span>
</pre></div>


<p>The code for decompressing, or inflating, a fixed Huffman code deflate block is shown below.</p>

<div><pre><span>static</span> <span>inf_stat_t</span> <span>inf_fixed_block</span><span>(</span><span>istream_t</span> <span>*</span><span>is</span><span>,</span> <span>uint8_t</span> <span>*</span><span>dst</span><span>,</span>
                                  <span>size_t</span> <span>dst_cap</span><span>,</span> <span>size_t</span> <span>*</span><span>dst_pos</span><span>)
{</span>
        <span>huffman_decoder_t</span> <span>litlen_dec</span><span>,</span> <span>dist_dec</span><span>;</span>

        <span>huffman_decoder_init</span><span>(</span><span>&amp;</span><span>litlen_dec</span><span>,</span> <span>fixed_litlen_lengths</span><span>,</span>
                             <span>sizeof</span><span>(</span><span>fixed_litlen_lengths</span><span>)</span> <span>/</span>
                             <span>sizeof</span><span>(</span><span>fixed_litlen_lengths</span><span>[</span><span>0</span><span>]));</span>
        <span>huffman_decoder_init</span><span>(</span><span>&amp;</span><span>dist_dec</span><span>,</span> <span>fixed_dist_lengths</span><span>,</span>
                             <span>sizeof</span><span>(</span><span>fixed_dist_lengths</span><span>)</span> <span>/</span>
                             <span>sizeof</span><span>(</span><span>fixed_dist_lengths</span><span>[</span><span>0</span><span>]));</span>

        <span>return</span> <span>inf_block</span><span>(</span><span>is</span><span>,</span> <span>dst</span><span>,</span> <span>dst_cap</span><span>,</span> <span>dst_pos</span><span>,</span> <span>&amp;</span><span>litlen_dec</span><span>,</span> <span>&amp;</span><span>dist_dec</span><span>);
}</span>

<span>#define LITLEN_EOB 256
#define LITLEN_MAX 285
#define LITLEN_TBL_OFFSET 257
#define MIN_LEN 3
#define MAX_LEN 258

#define DISTSYM_MAX 29
#define MIN_DISTANCE 1
#define MAX_DISTANCE 32768</span>

<span>static</span> <span>inf_stat_t</span> <span>inf_block</span><span>(</span><span>istream_t</span> <span>*</span><span>is</span><span>,</span> <span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>size_t</span> <span>dst_cap</span><span>,</span>
                            <span>size_t</span> <span>*</span><span>dst_pos</span><span>,</span>
                            <span>const</span> <span>huffman_decoder_t</span> <span>*</span><span>litlen_dec</span><span>,</span>
                            <span>const</span> <span>huffman_decoder_t</span> <span>*</span><span>dist_dec</span><span>)
{</span>
        <span>uint64_t</span> <span>bits</span><span>;</span>
        <span>size_t</span> <span>used</span><span>,</span> <span>used_tot</span><span>,</span> <span>dist</span><span>,</span> <span>len</span><span>;</span>
        <span>int</span> <span>litlen</span><span>,</span> <span>distsym</span><span>;</span>
        <span>uint16_t</span> <span>ebits</span><span>;</span>

        <span>while</span> <span>(</span><span>true</span><span>) {</span>
                <span>/* Read a litlen symbol. */</span>
                <span>bits</span> <span>=</span> <span>istream_bits</span><span>(</span><span>is</span><span>);</span>
                <span>litlen</span> <span>=</span> <span>huffman_decode</span><span>(</span><span>litlen_dec</span><span>, (</span><span>uint16_t</span><span>)</span><span>bits</span><span>,</span> <span>&amp;</span><span>used</span><span>);</span>
                <span>bits</span> <span>&gt;&gt;=</span> <span>used</span><span>;</span>
                <span>used_tot</span> <span>=</span> <span>used</span><span>;</span>

                <span>if</span> <span>(</span><span>litlen</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>litlen</span> <span>&gt;</span> <span>LITLEN_MAX</span><span>) {</span>
                        <span>/* Failed to decode, or invalid symbol. */</span>
                        <span>return</span> <span>HWINF_ERR</span><span>;
                }</span> <span>else if</span> <span>(</span><span>litlen</span> <span>&lt;=</span> <span>UINT8_MAX</span><span>) {</span>
                        <span>/* Literal. */</span>
                        <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>used_tot</span><span>)) {</span>
                                <span>return</span> <span>HWINF_ERR</span><span>;
                        }</span>
                        <span>if</span> <span>(</span><span>*</span><span>dst_pos</span> <span>==</span> <span>dst_cap</span><span>) {</span>
                                <span>return</span> <span>HWINF_FULL</span><span>;
                        }</span>
                        <span>lz77_output_lit</span><span>(</span><span>dst</span><span>, (</span><span>*</span><span>dst_pos</span><span>)</span><span>++</span><span>, (</span><span>uint8_t</span><span>)</span><span>litlen</span><span>);</span>
                        <span>continue</span><span>;
                }</span> <span>else if</span> <span>(</span><span>litlen</span> <span>==</span> <span>LITLEN_EOB</span><span>) {</span>
                        <span>/* End of block. */</span>
                        <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>used_tot</span><span>)) {</span>
                                <span>return</span> <span>HWINF_ERR</span><span>;
                        }</span>
                        <span>return</span> <span>HWINF_OK</span><span>;
                }</span>

                <span>/* It is a back reference. Figure out the length. */</span>
                <span>assert</span><span>(</span><span>litlen</span> <span>&gt;=</span> <span>LITLEN_TBL_OFFSET</span> <span>&amp;&amp;</span> <span>litlen</span> <span>&lt;=</span> <span>LITLEN_MAX</span><span>);</span>
                <span>len</span>   <span>=</span> <span>litlen_tbl</span><span>[</span><span>litlen</span> <span>-</span> <span>LITLEN_TBL_OFFSET</span><span>].</span><span>base_len</span><span>;</span>
                <span>ebits</span> <span>=</span> <span>litlen_tbl</span><span>[</span><span>litlen</span> <span>-</span> <span>LITLEN_TBL_OFFSET</span><span>].</span><span>ebits</span><span>;</span>
                <span>if</span> <span>(</span><span>ebits</span> <span>!=</span> <span>0</span><span>) {</span>
                        <span>len</span> <span>+=</span> <span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>ebits</span><span>);</span>
                        <span>bits</span> <span>&gt;&gt;=</span> <span>ebits</span><span>;</span>
                        <span>used_tot</span> <span>+=</span> <span>ebits</span><span>;
                }</span>
                <span>assert</span><span>(</span><span>len</span> <span>&gt;=</span> <span>MIN_LEN</span> <span>&amp;&amp;</span> <span>len</span> <span>&lt;=</span> <span>MAX_LEN</span><span>);</span>

                <span>/* Get the distance. */</span>
                <span>distsym</span> <span>=</span> <span>huffman_decode</span><span>(</span><span>dist_dec</span><span>, (</span><span>uint16_t</span><span>)</span><span>bits</span><span>,</span> <span>&amp;</span><span>used</span><span>);</span>
                <span>bits</span> <span>&gt;&gt;=</span> <span>used</span><span>;</span>
                <span>used_tot</span> <span>+=</span> <span>used</span><span>;</span>

                <span>if</span> <span>(</span><span>distsym</span> <span>&lt;</span> <span>0</span> <span>||</span> <span>distsym</span> <span>&gt;</span> <span>DISTSYM_MAX</span><span>) {</span>
                        <span>/* Failed to decode, or invalid symbol. */</span>
                        <span>return</span> <span>HWINF_ERR</span><span>;
                }</span>
                <span>dist</span>  <span>=</span> <span>dist_tbl</span><span>[</span><span>distsym</span><span>].</span><span>base_dist</span><span>;</span>
                <span>ebits</span> <span>=</span> <span>dist_tbl</span><span>[</span><span>distsym</span><span>].</span><span>ebits</span><span>;</span>
                <span>if</span> <span>(</span><span>ebits</span> <span>!=</span> <span>0</span><span>) {</span>
                        <span>dist</span> <span>+=</span> <span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>ebits</span><span>);</span>
                        <span>bits</span> <span>&gt;&gt;=</span> <span>ebits</span><span>;</span>
                        <span>used_tot</span> <span>+=</span> <span>ebits</span><span>;
                }</span>
                <span>assert</span><span>(</span><span>dist</span> <span>&gt;=</span> <span>MIN_DISTANCE</span> <span>&amp;&amp;</span> <span>dist</span> <span>&lt;=</span> <span>MAX_DISTANCE</span><span>);</span>

                <span>assert</span><span>(</span><span>used_tot</span> <span>&lt;=</span> <span>ISTREAM_MIN_BITS</span><span>);</span>
                <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>used_tot</span><span>)) {</span>
                        <span>return</span> <span>HWINF_ERR</span><span>;
                }</span>

                <span>/* Bounds check and output the backref. */</span>
                <span>if</span> <span>(</span><span>dist</span> <span>&gt; *</span><span>dst_pos</span><span>) {</span>
                        <span>return</span> <span>HWINF_ERR</span><span>;
                }</span>
                <span>if</span> <span>(</span><span>round_up</span><span>(</span><span>len</span><span>,</span> <span>8</span><span>)</span> <span>&lt;=</span> <span>dst_cap</span> <span>- *</span><span>dst_pos</span><span>) {</span>
                        <span>output_backref64</span><span>(</span><span>dst</span><span>,</span> <span>*</span><span>dst_pos</span><span>,</span> <span>dist</span><span>,</span> <span>len</span><span>);
                }</span> <span>else if</span> <span>(</span><span>len</span> <span>&lt;=</span> <span>dst_cap</span> <span>- *</span><span>dst_pos</span><span>) {</span>
                        <span>lz77_output_backref</span><span>(</span><span>dst</span><span>,</span> <span>*</span><span>dst_pos</span><span>,</span> <span>dist</span><span>,</span> <span>len</span><span>);
                }</span> <span>else</span> <span>{</span>
                        <span>return</span> <span>HWINF_FULL</span><span>;
                }
                (</span><span>*</span><span>dst_pos</span><span>)</span> <span>+=</span> <span>len</span><span>;
        }
}</span>
</pre></div>


<p>Note that as an optimization when there is enough room in the output buffer, we output back references using the routine below which copies 64 bits at a time. It is "sloppy" in the sense that it often copies a few extra bytes (to the next multiple of 8), but it is much faster than <span>lz77_output_backref</span> since it needs fewer loop iterations and memory accesses. In fact, short back references will now all be handled by a single iteration, which is great for branch prediction.</p>

<div><pre><span>/* Output the (dist,len) backref at dst_pos in dst using 64-bit wide writes.
   There must be enough room for len bytes rounded to the next multiple of 8. */</span>
<span>static</span> <span>void</span> <span>output_backref64</span><span>(</span><span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>size_t</span> <span>dst_pos</span><span>,</span> <span>size_t</span> <span>dist</span><span>,</span>
                             <span>size_t</span> <span>len</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>;</span>
        <span>uint64_t</span> <span>tmp</span><span>;</span>

        <span>assert</span><span>(</span><span>len</span> <span>&gt;</span> <span>0</span><span>);</span>
        <span>assert</span><span>(</span><span>dist</span> <span>&lt;=</span> <span>dst_pos</span> <span>&amp;&amp;</span> <span>"cannot reference before beginning of dst"</span><span>);</span>

        <span>if</span> <span>(</span><span>len</span> <span>&gt;</span> <span>dist</span><span>) {</span>
                <span>/* Self-overlapping backref; fall back to byte-by-byte copy. */</span>
                <span>lz77_output_backref</span><span>(</span><span>dst</span><span>,</span> <span>dst_pos</span><span>,</span> <span>dist</span><span>,</span> <span>len</span><span>);</span>
                <span>return</span><span>;
        }</span>

        <span>i</span> <span>=</span> <span>0</span><span>;</span>
        <span>do</span> <span>{</span>
                <span>memcpy</span><span>(</span><span>&amp;</span><span>tmp</span><span>,</span> <span>&amp;</span><span>dst</span><span>[</span><span>dst_pos</span> <span>-</span> <span>dist</span> <span>+</span> <span>i</span><span>],</span> <span>8</span><span>);</span>
                <span>memcpy</span><span>(</span><span>&amp;</span><span>dst</span><span>[</span><span>dst_pos</span> <span>+</span> <span>i</span><span>],</span> <span>&amp;</span><span>tmp</span><span>,</span> <span>8</span><span>);</span>
                <span>i</span> <span>+=</span> <span>8</span><span>;
        }</span> <span>while</span> <span>(</span><span>i</span> <span>&lt;</span> <span>len</span><span>);
}</span>
</pre></div>


<h4>Dynamic Huffman Code Deflate Blocks</h4>

<p>Deflate blocks using dynamic Huffman codes work similarly to the blocks described above, but instead of using pre-determined Huffman codes for the litlen and dist codes, they use codes that are stored in the Deflate stream itself, at the start of the block. The name is perhaps unfortunate, since dynamic Huffman codes can also refer to codes that change during the coding process, sometimes called <a href="https://en.wikipedia.org/wiki/Adaptive_Huffman_coding">adaptive Huffman coding</a>. The codes described here have nothing to do with that; they are only dynamic in the sense that different blocks can use different codes.</p>

<p>The encoding of the dynamic litlen and dist codes is the most intricate part of the Deflate format, but once the codes have been retrieved, decompression proceeds in the same way as for blocks in the previous section, using <span>inf_block</span>:</p>

<div><pre><span>static</span> <span>inf_stat_t</span> <span>inf_dyn_block</span><span>(</span><span>istream_t</span> <span>*</span><span>is</span><span>,</span> <span>uint8_t</span> <span>*</span><span>dst</span><span>,</span>
                                <span>size_t</span> <span>dst_cap</span><span>,</span> <span>size_t</span> <span>*</span><span>dst_pos</span><span>)
{</span>
        <span>inf_stat_t</span> <span>s</span><span>;</span>
        <span>huffman_decoder_t</span> <span>litlen_dec</span><span>,</span> <span>dist_dec</span><span>;</span>

        <span>s</span> <span>=</span> <span>init_dyn_decoders</span><span>(</span><span>is</span><span>,</span> <span>&amp;</span><span>litlen_dec</span><span>,</span> <span>&amp;</span><span>dist_dec</span><span>);</span>
        <span>if</span> <span>(</span><span>s</span> <span>!=</span> <span>HWINF_OK</span><span>) {</span>
                <span>return</span> <span>s</span><span>;
        }</span>

        <span>return</span> <span>inf_block</span><span>(</span><span>is</span><span>,</span> <span>dst</span><span>,</span> <span>dst_cap</span><span>,</span> <span>dst_pos</span><span>,</span> <span>&amp;</span><span>litlen_dec</span><span>,</span> <span>&amp;</span><span>dist_dec</span><span>);
}</span>
</pre></div>


<p>The litlen and dist codes for a dynamic Deflate block are stored as a series of codeword lengths. Those codeword lengths are themselves encoded using a third Huffman code, which we will call the <em>codelen code</em>. Finally, that code is itself defined by codeword lengths (<span>codelen_lens</span>) stored in the block. (Did I mention it was intricate?)</p>

<p><img src="https://www.hanshq.net/gfx/tex_336f2ad6.png" alt="LaTeX"></p>

<p>At the beginning of the dynamic block are 14 bits that define the number of litlen, dist, and codelen codeword lengths that should be read from the block:</p>

<div><pre><span>#define MIN_CODELEN_LENS 4
#define MAX_CODELEN_LENS 19

#define MIN_LITLEN_LENS 257
#define MAX_LITLEN_LENS 288

#define MIN_DIST_LENS 1
#define MAX_DIST_LENS 32

#define CODELEN_MAX_LIT 15

#define CODELEN_COPY 16
#define CODELEN_COPY_MIN 3
#define CODELEN_COPY_MAX 6

#define CODELEN_ZEROS 17
#define CODELEN_ZEROS_MIN 3
#define CODELEN_ZEROS_MAX 10

#define CODELEN_ZEROS2 18
#define CODELEN_ZEROS2_MIN 11
#define CODELEN_ZEROS2_MAX 138</span>

<span>/* RFC 1951, 3.2.7 */</span>
<span>static const</span> <span>int</span> <span>codelen_lengths_order</span><span>[</span><span>MAX_CODELEN_LENS</span><span>]</span> <span>=</span>
<span>{</span> <span>16</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>0</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>6</span><span>,</span> <span>10</span><span>,</span> <span>5</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>12</span><span>,</span> <span>3</span><span>,</span> <span>13</span><span>,</span> <span>2</span><span>,</span> <span>14</span><span>,</span> <span>1</span><span>,</span> <span>15</span> <span>};</span>

<span>static</span> <span>inf_stat_t</span> <span>init_dyn_decoders</span><span>(</span><span>istream_t</span> <span>*</span><span>is</span><span>,</span>
                                    <span>huffman_decoder_t</span> <span>*</span><span>litlen_dec</span><span>,</span>
                                    <span>huffman_decoder_t</span> <span>*</span><span>dist_dec</span><span>)
{</span>
        <span>uint64_t</span> <span>bits</span><span>;</span>
        <span>size_t</span> <span>num_litlen_lens</span><span>,</span> <span>num_dist_lens</span><span>,</span> <span>num_codelen_lens</span><span>;</span>
        <span>uint8_t</span> <span>codelen_lengths</span><span>[</span><span>MAX_CODELEN_LENS</span><span>];</span>
        <span>uint8_t</span> <span>code_lengths</span><span>[</span><span>MAX_LITLEN_LENS</span> <span>+</span> <span>MAX_DIST_LENS</span><span>];</span>
        <span>size_t</span> <span>i</span><span>,</span> <span>n</span><span>,</span> <span>used</span><span>;</span>
        <span>int</span> <span>sym</span><span>;</span>
        <span>huffman_decoder_t</span> <span>codelen_dec</span><span>;</span>

        <span>bits</span> <span>=</span> <span>istream_bits</span><span>(</span><span>is</span><span>);</span>

        <span>/* Number of litlen codeword lengths (5 bits + 257). */</span>
        <span>num_litlen_lens</span> <span>=</span> <span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>5</span><span>)</span> <span>+</span> <span>MIN_LITLEN_LENS</span><span>;</span>
        <span>bits</span> <span>&gt;&gt;=</span> <span>5</span><span>;</span>
        <span>assert</span><span>(</span><span>num_litlen_lens</span> <span>&lt;=</span> <span>MAX_LITLEN_LENS</span><span>);</span>

        <span>/* Number of dist codeword lengths (5 bits + 1). */</span>
        <span>num_dist_lens</span> <span>=</span> <span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>5</span><span>)</span> <span>+</span> <span>MIN_DIST_LENS</span><span>;</span>
        <span>bits</span> <span>&gt;&gt;=</span> <span>5</span><span>;</span>
        <span>assert</span><span>(</span><span>num_dist_lens</span> <span>&lt;=</span> <span>MAX_DIST_LENS</span><span>);</span>

        <span>/* Number of code length lengths (4 bits + 4). */</span>
        <span>num_codelen_lens</span> <span>=</span> <span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>4</span><span>)</span> <span>+</span> <span>MIN_CODELEN_LENS</span><span>;</span>
        <span>bits</span> <span>&gt;&gt;=</span> <span>4</span><span>;</span>
        <span>assert</span><span>(</span><span>num_codelen_lens</span> <span>&lt;=</span> <span>MAX_CODELEN_LENS</span><span>);</span>

        <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>5</span> <span>+</span> <span>5</span> <span>+</span> <span>4</span><span>)) {</span>
                <span>return</span> <span>HWINF_ERR</span><span>;
        }</span>
</pre></div>


<p>After those bits follow the codeword lengths for the codelen code. The lengths are plain three-bit values, but they are written in a special order defined by <span>codelen_lengths_order</span> above. While there are 19 lengths to be specified, only <span>num_codelen_lens</span> will be read from the stream; the rest are implicitly zero. It is for this reason the lengths are in a special order: to increase the chance that latter lengths will all be zero and do not have to be stored in the block.</p>

<div><pre>        <span>/* Read the codelen codeword lengths (3 bits each)
           and initialize the codelen decoder. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>num_codelen_lens</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>bits</span> <span>=</span> <span>istream_bits</span><span>(</span><span>is</span><span>);</span>
                <span>codelen_lengths</span><span>[</span><span>codelen_lengths_order</span><span>[</span><span>i</span><span>]]</span> <span>=</span>
                        <span>(</span><span>uint8_t</span><span>)</span><span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>3</span><span>);</span>
                <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>3</span><span>)) {</span>
                        <span>return</span> <span>HWINF_ERR</span><span>;
                }
        }</span>
        <span>for</span> <span>(;</span> <span>i</span> <span>&lt;</span> <span>MAX_CODELEN_LENS</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>codelen_lengths</span><span>[</span><span>codelen_lengths_order</span><span>[</span><span>i</span><span>]]</span> <span>=</span> <span>0</span><span>;
        }</span>
        <span>if</span> <span>(</span><span>!</span><span>huffman_decoder_init</span><span>(</span><span>&amp;</span><span>codelen_dec</span><span>,</span> <span>codelen_lengths</span><span>,</span>
                                  <span>MAX_CODELEN_LENS</span><span>)) {</span>
                <span>return</span> <span>HWINF_ERR</span><span>;
        }</span>
</pre></div>


<p>With the codelen decoder set up, we can proceed to read the litlen and dist codeword lengths from the stream.</p>

<div><pre>        <span>/* Read the litlen and dist codeword lengths. */</span>
        <span>i</span> <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span><span>i</span> <span>&lt;</span> <span>num_litlen_lens</span> <span>+</span> <span>num_dist_lens</span><span>) {</span>
                <span>bits</span> <span>=</span> <span>istream_bits</span><span>(</span><span>is</span><span>);</span>
                <span>sym</span> <span>=</span> <span>huffman_decode</span><span>(</span><span>&amp;</span><span>codelen_dec</span><span>, (</span><span>uint16_t</span><span>)</span><span>bits</span><span>,</span> <span>&amp;</span><span>used</span><span>);</span>
                <span>bits</span> <span>&gt;&gt;=</span> <span>used</span><span>;</span>
                <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>used</span><span>)) {</span>
                        <span>return</span> <span>HWINF_ERR</span><span>;
                }</span>

                <span>if</span> <span>(</span><span>sym</span> <span>&gt;=</span> <span>0</span> <span>&amp;&amp;</span> <span>sym</span> <span>&lt;=</span> <span>CODELEN_MAX_LIT</span><span>) {</span>
                        <span>/* A literal codeword length. */</span>
                        <span>code_lengths</span><span>[</span><span>i</span><span>++</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)</span><span>sym</span><span>;
                }</span>
</pre></div>


<p>Lengths 16, 17, and 18 are not real lengths, but indicate that the previous length should be repeated some number of times, or that a zero length should be repeated:</p>

<div><pre>                <span>else</span> <span>if</span> <span>(</span><span>sym</span> <span>==</span> <span>CODELEN_COPY</span><span>) {</span>
                        <span>/* Copy the previous codeword length 3--6 times. */</span>
                        <span>if</span> <span>(</span><span>i</span> <span>&lt;</span> <span>1</span><span>) {</span>
                                <span>return</span> <span>HWINF_ERR</span><span>;</span> <span>/* No previous length. */</span>
                        <span>}</span>
                        <span>n</span> <span>=</span> <span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>2</span><span>)</span> <span>+</span> <span>CODELEN_COPY_MIN</span><span>;</span> <span>/* 2 bits + 3 */</span>
                        <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>2</span><span>)) {</span>
                                <span>return</span> <span>HWINF_ERR</span><span>;
                        }</span>
                        <span>assert</span><span>(</span><span>n</span> <span>&gt;=</span> <span>CODELEN_COPY_MIN</span> <span>&amp;&amp;</span> <span>n</span> <span>&lt;=</span> <span>CODELEN_COPY_MAX</span><span>);</span>
                        <span>if</span> <span>(</span><span>i</span> <span>+</span> <span>n</span> <span>&gt;</span> <span>num_litlen_lens</span> <span>+</span> <span>num_dist_lens</span><span>) {</span>
                                <span>return</span> <span>HWINF_ERR</span><span>;
                        }</span>
                        <span>while</span> <span>(</span><span>n</span><span>--</span><span>) {</span>
                                <span>code_lengths</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>code_lengths</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>];</span>
                                <span>i</span><span>++</span><span>;
                        }
                }</span> <span>else</span> <span>if</span> <span>(</span><span>sym</span> <span>==</span> <span>CODELEN_ZEROS</span><span>) {</span>
                        <span>/* 3--10 zeros. */</span>
                        <span>n</span> <span>=</span> <span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>3</span><span>)</span> <span>+</span> <span>CODELEN_ZEROS_MIN</span><span>;</span> <span>/* 3 bits + 3 */</span>
                        <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>3</span><span>)) {</span>
                                <span>return</span> <span>HWINF_ERR</span><span>;
                        }</span>
                        <span>assert</span><span>(</span><span>n</span> <span>&gt;=</span> <span>CODELEN_ZEROS_MIN</span> <span>&amp;&amp;</span>
                               <span>n</span> <span>&lt;=</span> <span>CODELEN_ZEROS_MAX</span><span>);</span>
                        <span>if</span> <span>(</span><span>i</span> <span>+</span> <span>n</span> <span>&gt;</span> <span>num_litlen_lens</span> <span>+</span> <span>num_dist_lens</span><span>) {</span>
                                <span>return</span> <span>HWINF_ERR</span><span>;
                        }</span>
                        <span>while</span> <span>(</span><span>n</span><span>--</span><span>) {</span>
                                <span>code_lengths</span><span>[</span><span>i</span><span>++</span><span>]</span> <span>=</span> <span>0</span><span>;
                        }
                }</span> <span>else</span> <span>if</span> <span>(</span><span>sym</span> <span>==</span> <span>CODELEN_ZEROS2</span><span>) {</span>
                        <span>/* 11--138 zeros. */</span>
                        <span>n</span> <span>=</span> <span>lsb</span><span>(</span><span>bits</span><span>,</span> <span>7</span><span>)</span> <span>+</span> <span>CODELEN_ZEROS2_MIN</span><span>;</span> <span>/* 7 bits +138 */</span>
                        <span>if</span> <span>(</span><span>!</span><span>istream_advance</span><span>(</span><span>is</span><span>,</span> <span>7</span><span>)) {</span>
                                <span>return</span> <span>HWINF_ERR</span><span>;
                        }</span>
                        <span>assert</span><span>(</span><span>n</span> <span>&gt;=</span> <span>CODELEN_ZEROS2_MIN</span> <span>&amp;&amp;</span>
                               <span>n</span> <span>&lt;=</span> <span>CODELEN_ZEROS2_MAX</span><span>);</span>
                        <span>if</span> <span>(</span><span>i</span> <span>+</span> <span>n</span> <span>&gt;</span> <span>num_litlen_lens</span> <span>+</span> <span>num_dist_lens</span><span>) {</span>
                                <span>return</span> <span>HWINF_ERR</span><span>;
                        }</span>
                        <span>while</span> <span>(</span><span>n</span><span>--</span><span>) {</span>
                                <span>code_lengths</span><span>[</span><span>i</span><span>++</span><span>]</span> <span>=</span> <span>0</span><span>;
                        }
                }</span> <span>else</span> <span>{</span>
                        <span>/* Invalid symbol. */</span>
                        <span>return</span> <span>HWINF_ERR</span><span>;
                }
        }</span>
</pre></div>


<p>Note that the litlen and dist lengths are read one after the other into the same <span>code_lengths</span> array. They could not be read separately, because code length runs can carry over from the last litlen lengths to the first dist lengths.</p>

<p>With the codeword lengths ready for use, we can set up the Huffman decoders and return to the task of decoding literals and back references:</p>

<div><pre>        <span>if</span> <span>(</span><span>!</span><span>huffman_decoder_init</span><span>(</span><span>litlen_dec</span><span>,</span> <span>&amp;</span><span>code_lengths</span><span>[</span><span>0</span><span>],</span>
                                  <span>num_litlen_lens</span><span>)) {</span>
                <span>return</span> <span>HWINF_ERR</span><span>;
        }</span>
        <span>if</span> <span>(</span><span>!</span><span>huffman_decoder_init</span><span>(</span><span>dist_dec</span><span>,</span> <span>&amp;</span><span>code_lengths</span><span>[</span><span>num_litlen_lens</span><span>],</span>
                                  <span>num_dist_lens</span><span>)) {</span>
                <span>return</span> <span>HWINF_ERR</span><span>;
        }</span>

        <span>return</span> <span>HWINF_OK</span><span>;
}</span>
</pre></div>


<h3>Compression (Deflation)</h3>

<p>From the sections above, we have all the tools needed for Deflate compression: Lempel-Ziv, Huffman coding, bitstreams, and the description of the three Deflate block types. This section puts the pieces together to finally perform Deflate compression.</p>

<p>Lempel-Ziv compression parses the source data into a sequence of back references and literals. This sequence needs to be divided and encoded into Deflate blocks as described in the previous section. Choosing how to do this division is sometimes referred to as <em>block splitting</em>. On the one hand, each new block carries some overhead which varies depending on block type and contents, so fewer blocks means less overhead. On the other hand, the overhead from starting a new block might be worth it, for example if the characteristics of the data lead to a more efficient Huffman encoding in the new block and smaller output overall.</p>

<p>Block splitting is a difficult optimization problem. Some compressors (such as <a href="https://github.com/google/zopfli">Zopfli</a>) try harder than others, but most just use a greedy approach: output a block once a certain size has been reached.</p>

<p>The different block types impose different size constraints:</p>

<ul>
<li>Uncompressed blocks can contain at most 65,535 bytes.</li>
<li>Fixed Huffman Code blocks do not have a maximum size.</li>
<li>Dynamic Huffman Code blocks do not generally have a maximum size, but because our implementation of Huffman's algorithm uses 16-bit symbol frequencies, we are limited to at most 65,535 symbols.</li>
</ul>

<p>To be able to freely choose any of the three types for block, we limit the block size to at most 65,534 bytes:</p>

<div><pre><span>/* The largest number of bytes that will fit in any kind of block is 65,534.
   It will fit in an uncompressed block (max 65,535 bytes) and a Huffman
   block with only literals (65,535 symbols including end-of-block marker). */</span>
<span>#define MAX_BLOCK_LEN_BYTES 65534</span>
</pre></div>


<p>We use a structure to keep track of the output bitstream and the contents of the current block during deflation:</p>

<div><pre><span>typedef struct</span> <span>deflate_state_t deflate_state_t</span><span>;</span>
<span>struct</span> <span>deflate_state_t</span> <span>{</span>
        <span>ostream_t</span> <span>os</span><span>;</span>

        <span>const</span> <span>uint8_t</span> <span>*</span><span>block_src</span><span>;</span> <span>/* First src byte in the block. */</span>

        <span>size_t</span> <span>block_len</span><span>;</span>       <span>/* Number of symbols in the current block. */</span>
        <span>size_t</span> <span>block_len_bytes</span><span>;</span> <span>/* Number of src bytes in the block. */

        /* Symbol frequencies for the current block. */</span>
        <span>uint16_t</span> <span>litlen_freqs</span><span>[</span><span>LITLEN_MAX</span> <span>+</span> <span>1</span><span>];</span>
        <span>uint16_t</span> <span>dist_freqs</span><span>[</span><span>DISTSYM_MAX</span> <span>+</span> <span>1</span><span>];</span>

        <span>struct</span> <span>{</span>
                <span>uint16_t</span> <span>distance</span><span>;</span>    <span>/* Backref distance. */</span>
                <span>union</span> <span>{</span>
                        <span>uint16_t</span> <span>lit</span><span>;</span> <span>/* Literal byte or end-of-block. */</span>
                        <span>uint16_t</span> <span>len</span><span>;</span> <span>/* Backref length (distance != 0). */</span>
                <span>}</span> <span>u</span><span>;
        }</span> <span>block</span><span>[</span><span>MAX_BLOCK_LEN_BYTES</span> <span>+</span> <span>1</span><span>];
};</span>

<span>static</span> <span>void</span> <span>reset_block</span><span>(</span><span>deflate_state_t</span> <span>*</span><span>s</span><span>)
{</span>
        <span>s</span><span>-&gt;</span><span>block_len</span> <span>=</span> <span>0</span><span>;</span>
        <span>s</span><span>-&gt;</span><span>block_len_bytes</span> <span>=</span> <span>0</span><span>;</span>
        <span>memset</span><span>(</span><span>s</span><span>-&gt;</span><span>litlen_freqs</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>s</span><span>-&gt;</span><span>litlen_freqs</span><span>));</span>
        <span>memset</span><span>(</span><span>s</span><span>-&gt;</span><span>dist_freqs</span><span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span><span>s</span><span>-&gt;</span><span>dist_freqs</span><span>));
}</span>
</pre></div>


<p>Callback functions are used to update the block with the output from <span>lz77_compress</span>, and write the block to the bitstream when it reaches the maximum size:</p>

<div><pre><span>static</span> <span>bool</span> <span>lit_callback</span><span>(</span><span>uint8_t</span> <span>lit</span><span>,</span> <span>void</span> <span>*</span><span>aux</span><span>)
{</span>
        <span>deflate_state_t</span> <span>*</span><span>s</span> <span>=</span> <span>aux</span><span>;</span>

        <span>if</span> <span>(</span><span>s</span><span>-&gt;</span><span>block_len_bytes</span> <span>+</span> <span>1</span> <span>&gt;</span> <span>MAX_BLOCK_LEN_BYTES</span><span>) {</span>
                <span>if</span> <span>(</span><span>!</span><span>write_block</span><span>(</span><span>s</span><span>,</span> <span>false</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }</span>
                <span>s</span><span>-&gt;</span><span>block_src</span> <span>+=</span> <span>s</span><span>-&gt;</span><span>block_len_bytes</span><span>;</span>
                <span>reset_block</span><span>(</span><span>s</span><span>);
        }</span>

        <span>assert</span><span>(</span><span>s</span><span>-&gt;</span><span>block_len</span> <span>&lt;</span> <span>sizeof</span><span>(</span><span>s</span><span>-&gt;</span><span>block</span><span>)</span> <span>/</span> <span>sizeof</span><span>(</span><span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>0</span><span>]));</span>
        <span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>s</span><span>-&gt;</span><span>block_len</span>  <span>].</span><span>distance</span> <span>=</span> <span>0</span><span>;</span>
        <span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>s</span><span>-&gt;</span><span>block_len</span><span>++</span><span>].</span><span>u</span><span>.</span><span>lit</span> <span>=</span> <span>lit</span><span>;</span>
        <span>s</span><span>-&gt;</span><span>block_len_bytes</span><span>++</span><span>;</span>

        <span>s</span><span>-&gt;</span><span>litlen_freqs</span><span>[</span><span>lit</span><span>]</span><span>++</span><span>;</span>

        <span>return</span> <span>true</span><span>;
}</span>

<span>static</span> <span>bool</span> <span>backref_callback</span><span>(</span><span>size_t</span> <span>dist</span><span>,</span> <span>size_t</span> <span>len</span><span>,</span> <span>void</span> <span>*</span><span>aux</span><span>)
{</span>
        <span>deflate_state_t</span> <span>*</span><span>s</span> <span>=</span> <span>aux</span><span>;</span>

        <span>if</span> <span>(</span><span>s</span><span>-&gt;</span><span>block_len_bytes</span> <span>+</span> <span>len</span> <span>&gt;</span> <span>MAX_BLOCK_LEN_BYTES</span><span>) {</span>
                <span>if</span> <span>(</span><span>!</span><span>write_block</span><span>(</span><span>s</span><span>,</span> <span>false</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }</span>
                <span>s</span><span>-&gt;</span><span>block_src</span> <span>+=</span> <span>s</span><span>-&gt;</span><span>block_len_bytes</span><span>;</span>
                <span>reset_block</span><span>(</span><span>s</span><span>);
        }</span>

        <span>assert</span><span>(</span><span>s</span><span>-&gt;</span><span>block_len</span> <span>&lt;</span> <span>sizeof</span><span>(</span><span>s</span><span>-&gt;</span><span>block</span><span>)</span> <span>/</span> <span>sizeof</span><span>(</span><span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>0</span><span>]));</span>
        <span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>s</span><span>-&gt;</span><span>block_len</span>  <span>].</span><span>distance</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)</span><span>dist</span><span>;</span>
        <span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>s</span><span>-&gt;</span><span>block_len</span><span>++</span><span>].</span><span>u</span><span>.</span><span>len</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)</span><span>len</span><span>;</span>
        <span>s</span><span>-&gt;</span><span>block_len_bytes</span> <span>+=</span> <span>len</span><span>;</span>

        <span>assert</span><span>(</span><span>len</span> <span>&gt;=</span> <span>MIN_LEN</span> <span>&amp;&amp;</span> <span>len</span> <span>&lt;=</span> <span>MAX_LEN</span><span>);</span>
        <span>assert</span><span>(</span><span>dist</span> <span>&gt;=</span> <span>MIN_DISTANCE</span> <span>&amp;&amp;</span> <span>dist</span> <span>&lt;=</span> <span>MAX_DISTANCE</span><span>);</span>
        <span>s</span><span>-&gt;</span><span>litlen_freqs</span><span>[</span><span>len2litlen</span><span>[</span><span>len</span><span>]]</span><span>++</span><span>;</span>
        <span>s</span><span>-&gt;</span><span>dist_freqs</span><span>[</span><span>distance2dist</span><span>[</span><span>dist</span><span>]]</span><span>++</span><span>;</span>

        <span>return</span> <span>true</span><span>;
}</span>
</pre></div>


<p>The interesting part is of course writing the blocks. Writing an uncompressed block is straight-forward:</p>

<div><pre><span>static</span> <span>bool</span> <span>write_uncomp_block</span><span>(</span><span>deflate_state_t</span> <span>*</span><span>s</span><span>,</span> <span>bool</span> <span>final</span><span>)
{</span>
        <span>uint8_t</span> <span>len_nlen</span><span>[</span><span>4</span><span>];</span>

        <span>/* Write the block header. */</span>
        <span>if</span> <span>(</span><span>!</span><span>ostream_write</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>, (</span><span>0x0</span> <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>|</span> <span>final</span><span>,</span> <span>3</span><span>)) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>len_nlen</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>s</span><span>-&gt;</span><span>block_len_bytes</span> <span>&gt;&gt;</span> <span>0</span><span>);</span>
        <span>len_nlen</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>s</span><span>-&gt;</span><span>block_len_bytes</span> <span>&gt;&gt;</span> <span>8</span><span>);</span>
        <span>len_nlen</span><span>[</span><span>2</span><span>]</span> <span>= ~</span><span>len_nlen</span><span>[</span><span>0</span><span>];</span>
        <span>len_nlen</span><span>[</span><span>3</span><span>]</span> <span>= ~</span><span>len_nlen</span><span>[</span><span>1</span><span>];</span>

        <span>if</span> <span>(</span><span>!</span><span>ostream_write_bytes_aligned</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>,</span> <span>len_nlen</span><span>,</span> <span>sizeof</span><span>(</span><span>len_nlen</span><span>))) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>!</span><span>ostream_write_bytes_aligned</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>,</span> <span>s</span><span>-&gt;</span><span>block_src</span><span>,</span>
                                         <span>s</span><span>-&gt;</span><span>block_len_bytes</span><span>)) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>return</span> <span>true</span><span>;
}</span>
</pre></div>


<p>To write a static Huffman block, we first generate canonical Huffman codes based on the fixed codeword lengths for the litlen and dist codes. Then we iterate through the block, writing the symbols using those codes:</p>

<div><pre><span>static</span> <span>bool</span> <span>write_static_block</span><span>(</span><span>deflate_state_t</span> <span>*</span><span>s</span><span>,</span> <span>bool</span> <span>final</span><span>)
{</span>
        <span>huffman_encoder_t</span> <span>litlen_enc</span><span>,</span> <span>dist_enc</span><span>;</span>

        <span>/* Write the block header. */</span>
        <span>if</span> <span>(</span><span>!</span><span>ostream_write</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>, (</span><span>0x1</span> <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>|</span> <span>final</span><span>,</span> <span>3</span><span>)) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>huffman_encoder_init2</span><span>(</span><span>&amp;</span><span>litlen_enc</span><span>,</span> <span>fixed_litlen_lengths</span><span>,</span>
                              <span>sizeof</span><span>(</span><span>fixed_litlen_lengths</span><span>)</span> <span>/</span>
                              <span>sizeof</span><span>(</span><span>fixed_litlen_lengths</span><span>[</span><span>0</span><span>]));</span>
        <span>huffman_encoder_init2</span><span>(</span><span>&amp;</span><span>dist_enc</span><span>,</span> <span>fixed_dist_lengths</span><span>,</span>
                              <span>sizeof</span><span>(</span><span>fixed_dist_lengths</span><span>)</span> <span>/</span>
                              <span>sizeof</span><span>(</span><span>fixed_dist_lengths</span><span>[</span><span>0</span><span>]));</span>

        <span>return</span> <span>write_huffman_block</span><span>(</span><span>s</span><span>,</span> <span>&amp;</span><span>litlen_enc</span><span>,</span> <span>&amp;</span><span>dist_enc</span><span>);
}</span>

<span>static</span> <span>bool</span> <span>write_huffman_block</span><span>(</span><span>deflate_state_t</span> <span>*</span><span>s</span><span>,</span>
                                <span>const</span> <span>huffman_encoder_t</span> <span>*</span><span>litlen_enc</span><span>,</span>
                                <span>const</span> <span>huffman_encoder_t</span> <span>*</span><span>dist_enc</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>,</span> <span>nbits</span><span>;</span>
        <span>uint64_t</span> <span>distance</span><span>,</span> <span>dist</span><span>,</span> <span>len</span><span>,</span> <span>litlen</span><span>,</span> <span>bits</span><span>,</span> <span>ebits</span><span>;</span>

        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>s</span><span>-&gt;</span><span>block_len</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>if</span> <span>(</span><span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>i</span><span>].</span><span>distance</span> <span>==</span> <span>0</span><span>) {</span>
                        <span>/* Literal or EOB. */</span>
                        <span>litlen</span> <span>=</span> <span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>i</span><span>].</span><span>u</span><span>.</span><span>lit</span><span>;</span>
                        <span>assert</span><span>(</span><span>litlen</span> <span>&lt;=</span> <span>LITLEN_EOB</span><span>);</span>
                        <span>if</span> <span>(</span><span>!</span><span>ostream_write</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>,</span>
                                           <span>litlen_enc</span><span>-&gt;</span><span>codewords</span><span>[</span><span>litlen</span><span>],</span>
                                           <span>litlen_enc</span><span>-&gt;</span><span>lengths</span><span>[</span><span>litlen</span><span>])) {</span>
                                <span>return</span> <span>false</span><span>;
                        }</span>
                        <span>continue</span><span>;
                }</span>

                <span>/* Back reference length. */</span>
                <span>len</span> <span>=</span> <span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>i</span><span>].</span><span>u</span><span>.</span><span>len</span><span>;</span>
                <span>litlen</span> <span>=</span> <span>len2litlen</span><span>[</span><span>len</span><span>];</span>

                <span>/* litlen bits */</span>
                <span>bits</span> <span>=</span> <span>litlen_enc</span><span>-&gt;</span><span>codewords</span><span>[</span><span>litlen</span><span>];</span>
                <span>nbits</span> <span>=</span> <span>litlen_enc</span><span>-&gt;</span><span>lengths</span><span>[</span><span>litlen</span><span>];</span>

                <span>/* ebits */</span>
                <span>ebits</span> <span>=</span> <span>len</span> <span>-</span> <span>litlen_tbl</span><span>[</span><span>litlen</span> <span>-</span> <span>LITLEN_TBL_OFFSET</span><span>].</span><span>base_len</span><span>;</span>
                <span>bits</span> <span>|=</span> <span>ebits</span> <span>&lt;&lt;</span> <span>nbits</span><span>;</span>
                <span>nbits</span> <span>+=</span> <span>litlen_tbl</span><span>[</span><span>litlen</span> <span>-</span> <span>LITLEN_TBL_OFFSET</span><span>].</span><span>ebits</span><span>;</span>

                <span>/* Back reference distance. */</span>
                <span>distance</span> <span>=</span> <span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>i</span><span>].</span><span>distance</span><span>;</span>
                <span>dist</span> <span>=</span> <span>distance2dist</span><span>[</span><span>distance</span><span>];</span>

                <span>/* dist bits */</span>
                <span>bits</span> <span>|=</span> <span>(</span><span>uint64_t</span><span>)</span><span>dist_enc</span><span>-&gt;</span><span>codewords</span><span>[</span><span>dist</span><span>]</span> <span>&lt;&lt;</span> <span>nbits</span><span>;</span>
                <span>nbits</span> <span>+=</span> <span>dist_enc</span><span>-&gt;</span><span>lengths</span><span>[</span><span>dist</span><span>];</span>

                <span>/* ebits */</span>
                <span>ebits</span> <span>=</span> <span>distance</span> <span>-</span> <span>dist_tbl</span><span>[</span><span>dist</span><span>].</span><span>base_dist</span><span>;</span>
                <span>bits</span> <span>|=</span> <span>ebits</span> <span>&lt;&lt;</span> <span>nbits</span><span>;</span>
                <span>nbits</span> <span>+=</span> <span>dist_tbl</span><span>[</span><span>dist</span><span>].</span><span>ebits</span><span>;</span>

                <span>if</span> <span>(</span><span>!</span><span>ostream_write</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>,</span> <span>bits</span><span>,</span> <span>nbits</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }
        }</span>

        <span>return</span> <span>true</span><span>;
}</span>
</pre></div>


<p>Dynamic Huffman blocks are of course the trickiest to write, since they include the intricate encoding of the litlen and dist codes. We will use this struct to represent their encoding:</p>

<div><pre><span>typedef struct</span> <span>codelen_sym_t codelen_sym_t</span><span>;</span>
<span>struct</span> <span>codelen_sym_t</span> <span>{</span>
        <span>uint8_t</span> <span>sym</span><span>;</span>
        <span>uint8_t</span> <span>count</span><span>;</span> <span>/* For symbols 16, 17, 18. */</span>
<span>};</span>
</pre></div>


<p>First, we drop trailing zero litlen and dist codeword lengths, and copy them into a common array for encoding. We cannot drop all trailing zeros: it is not possible to encode a Deflate block with fewer than one dist code. (It is also not possible to have fewer then 257 litlen codes, but since there is always an end-of-byte marker, there will always be a non-zero code length for symbol 256.)</p>

<div><pre><span>/* Encode litlen_lens and dist_lens into encoded. *num_litlen_lens and
   *num_dist_lens will be set to the number of encoded litlen and dist lens,
   respectively. Returns the number of elements in encoded. */</span>
<span>static</span> <span>size_t</span> <span>encode_dist_litlen_lens</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>litlen_lens</span><span>,</span>
                                      <span>const</span> <span>uint8_t</span> <span>*</span><span>dist_lens</span><span>,</span>
                                      <span>codelen_sym_t</span> <span>*</span><span>encoded</span><span>,</span>
                                      <span>size_t</span> <span>*</span><span>num_litlen_lens</span><span>,</span>
                                      <span>size_t</span> <span>*</span><span>num_dist_lens</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>,</span> <span>n</span><span>;</span>
        <span>uint8_t</span> <span>lens</span><span>[</span><span>LITLEN_MAX</span> <span>+</span> <span>1</span> <span>+</span> <span>DISTSYM_MAX</span> <span>+</span> <span>1</span><span>];</span>

        <span>*</span><span>num_litlen_lens</span> <span>=</span> <span>LITLEN_MAX</span> <span>+</span> <span>1</span><span>;</span>
        <span>*</span><span>num_dist_lens</span> <span>=</span> <span>DISTSYM_MAX</span> <span>+</span> <span>1</span><span>;</span>

        <span>/* Drop trailing zero litlen lengths. */</span>
        <span>assert</span><span>(</span><span>litlen_lens</span><span>[</span><span>LITLEN_EOB</span><span>]</span> <span>!=</span> <span>0</span> <span>&amp;&amp;</span> <span>"EOB len should be non-zero."</span><span>);</span>
        <span>while</span> <span>(</span><span>litlen_lens</span><span>[</span><span>*</span><span>num_litlen_lens</span> <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>0</span><span>) {
                (</span><span>*</span><span>num_litlen_lens</span><span>)</span><span>--</span><span>;
        }</span>
        <span>assert</span><span>(</span><span>*</span><span>num_litlen_lens</span> <span>&gt;=</span> <span>MIN_LITLEN_LENS</span><span>);</span>

        <span>/* Drop trailing zero dist lengths, keeping at least one. */</span>
        <span>while</span> <span>(</span><span>dist_lens</span><span>[</span><span>*</span><span>num_dist_lens</span> <span>-</span> <span>1</span><span>]</span> <span>==</span> <span>0</span> <span>&amp;&amp; *</span><span>num_dist_lens</span> <span>&gt;</span> <span>1</span><span>) {
                (</span><span>*</span><span>num_dist_lens</span><span>)</span><span>--</span><span>;
        }</span>
        <span>assert</span><span>(</span><span>*</span><span>num_dist_lens</span> <span>&gt;=</span> <span>MIN_DIST_LENS</span><span>);</span>

        <span>/* Copy the lengths into a unified array. */</span>
        <span>n</span> <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt; *</span><span>num_litlen_lens</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>lens</span><span>[</span><span>n</span><span>++</span><span>]</span> <span>=</span> <span>litlen_lens</span><span>[</span><span>i</span><span>];
        }</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt; *</span><span>num_dist_lens</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>lens</span><span>[</span><span>n</span><span>++</span><span>]</span> <span>=</span> <span>dist_lens</span><span>[</span><span>i</span><span>];
        }</span>

        <span>return</span> <span>encode_lens</span><span>(</span><span>lens</span><span>,</span> <span>n</span><span>,</span> <span>encoded</span><span>);
}</span>
</pre></div>


<p>Once the code lengths are in a single array, we perform the encoding, using special symbols for runs of identical code lengths.</p>

<div><pre><span>/* Encode the n code lengths in lens into encoded, returning the number of
   elements in encoded. */</span>
<span>static</span> <span>size_t</span> <span>encode_lens</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>lens</span><span>,</span> <span>size_t</span> <span>n</span><span>,</span> <span>codelen_sym_t</span> <span>*</span><span>encoded</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>,</span> <span>j</span><span>,</span> <span>num_encoded</span><span>;</span>
        <span>uint8_t</span> <span>count</span><span>;</span>

        <span>i</span> <span>=</span> <span>0</span><span>;</span>
        <span>num_encoded</span> <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span><span>i</span> <span>&lt;</span> <span>n</span><span>) {</span>
                <span>if</span> <span>(</span><span>lens</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>0</span><span>) {</span>
                        <span>/* Scan past the end of this zero run (max 138). */</span>
                        <span>for</span> <span>(</span><span>j</span> <span>=</span> <span>i</span><span>;</span> <span>j</span> <span>&lt;</span> <span>min</span><span>(</span><span>n</span><span>,</span> <span>i</span> <span>+</span> <span>CODELEN_ZEROS2_MAX</span><span>)</span> <span>&amp;&amp;</span>
                                    <span>lens</span><span>[</span><span>j</span><span>]</span> <span>==</span> <span>0</span><span>;</span> <span>j</span><span>++</span><span>);</span>
                        <span>count</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>j</span> <span>-</span> <span>i</span><span>);</span>

                        <span>if</span> <span>(</span><span>count</span> <span>&lt;</span> <span>CODELEN_ZEROS_MIN</span><span>) {</span>
                                <span>/* Output a single zero. */</span>
                                <span>encoded</span><span>[</span><span>num_encoded</span><span>++</span><span>].</span><span>sym</span> <span>=</span> <span>0</span><span>;</span>
                                <span>i</span><span>++</span><span>;</span>
                                <span>continue</span><span>;
                        }</span>

                        <span>/* Output a repeated zero. */</span>
                        <span>if</span> <span>(</span><span>count</span> <span>&lt;=</span> <span>CODELEN_ZEROS_MAX</span><span>) {</span>
                                <span>/* Repeated zero 3--10 times. */</span>
                                <span>assert</span><span>(</span><span>count</span> <span>&gt;=</span> <span>CODELEN_ZEROS_MIN</span> <span>&amp;&amp;</span>
                                       <span>count</span> <span>&lt;=</span> <span>CODELEN_ZEROS_MAX</span><span>);</span>
                                <span>encoded</span><span>[</span><span>num_encoded</span><span>].</span><span>sym</span> <span>=</span> <span>CODELEN_ZEROS</span><span>;</span>
                                <span>encoded</span><span>[</span><span>num_encoded</span><span>++</span><span>].</span><span>count</span> <span>=</span> <span>count</span><span>;
                        }</span> <span>else</span> <span>{</span>
                                <span>/* Repeated zero 11--138 times. */</span>
                                <span>assert</span><span>(</span><span>count</span> <span>&gt;=</span> <span>CODELEN_ZEROS2_MIN</span> <span>&amp;&amp;</span>
                                       <span>count</span> <span>&lt;=</span> <span>CODELEN_ZEROS2_MAX</span><span>);</span>
                                <span>encoded</span><span>[</span><span>num_encoded</span><span>].</span><span>sym</span> <span>=</span> <span>CODELEN_ZEROS2</span><span>;</span>
                                <span>encoded</span><span>[</span><span>num_encoded</span><span>++</span><span>].</span><span>count</span> <span>=</span> <span>count</span><span>;
                        }</span>
                        <span>i</span> <span>=</span> <span>j</span><span>;</span>
                        <span>continue</span><span>;
                }</span>

                <span>/* Output len. */</span>
                <span>encoded</span><span>[</span><span>num_encoded</span><span>++</span><span>].</span><span>sym</span> <span>=</span> <span>lens</span><span>[</span><span>i</span><span>++</span><span>];</span>

                <span>/* Scan past the end of the run of this len (max 6). */</span>
                <span>for</span> <span>(</span><span>j</span> <span>=</span> <span>i</span><span>;</span> <span>j</span> <span>&lt;</span> <span>min</span><span>(</span><span>n</span><span>,</span> <span>i</span> <span>+</span> <span>CODELEN_COPY_MAX</span><span>)</span> <span>&amp;&amp;</span>
                            <span>lens</span><span>[</span><span>j</span><span>]</span> <span>==</span> <span>lens</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>];</span> <span>j</span><span>++</span><span>);</span>
                <span>count</span> <span>=</span> <span>(</span><span>uint8_t</span><span>)(</span><span>j</span> <span>-</span> <span>i</span><span>);</span>

                <span>if</span> <span>(</span><span>count</span> <span>&gt;=</span> <span>CODELEN_COPY_MIN</span><span>) {</span>
                        <span>/* Repeat last len 3--6 times. */</span>
                        <span>assert</span><span>(</span><span>count</span> <span>&gt;=</span> <span>CODELEN_COPY_MIN</span> <span>&amp;&amp;</span>
                               <span>count</span> <span>&lt;=</span> <span>CODELEN_COPY_MAX</span><span>);</span>
                        <span>encoded</span><span>[</span><span>num_encoded</span><span>].</span><span>sym</span> <span>=</span> <span>CODELEN_COPY</span><span>;</span>
                        <span>encoded</span><span>[</span><span>num_encoded</span><span>++</span><span>].</span><span>count</span> <span>=</span> <span>count</span><span>;</span>
                        <span>i</span> <span>=</span> <span>j</span><span>;</span>
                        <span>continue</span><span>;
                }
        }</span>

        <span>return</span> <span>num_encoded</span><span>;
}</span>
</pre></div>


<p>The symbols used in the encoding above will in turn get written using a Huffman code, the "codelen code". The codeword lengths of the codelen code are written to the block in a certain order, with lengths more likely to be zero coming last. A function is used to count how many of the lengths that need to be written:</p>

<div><pre><span>static const</span> <span>int</span> <span>codelen_lengths_order</span><span>[</span><span>19</span><span>]</span> <span>=</span>
<span>{</span> <span>16</span><span>,</span> <span>17</span><span>,</span> <span>18</span><span>,</span> <span>0</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>6</span><span>,</span> <span>10</span><span>,</span> <span>5</span><span>,</span> <span>11</span><span>,</span> <span>4</span><span>,</span> <span>12</span><span>,</span> <span>3</span><span>,</span> <span>13</span><span>,</span> <span>2</span><span>,</span> <span>14</span><span>,</span> <span>1</span><span>,</span> <span>15</span> <span>};</span>

<span>/* Count the number of significant (not trailing zeros) codelen lengths. */</span>
<span>size_t</span> <span>count_codelen_lens</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>codelen_lens</span><span>)
{</span>
        <span>size_t</span> <span>n</span> <span>=</span> <span>MAX_CODELEN_LENS</span><span>;</span>

        <span>/* Drop trailing zero lengths. */</span>
        <span>while</span> <span>(</span><span>codelen_lens</span><span>[</span><span>codelen_lengths_order</span><span>[</span><span>n</span> <span>-</span> <span>1</span><span>]]</span> <span>==</span> <span>0</span><span>) {</span>
                <span>n</span><span>--</span><span>;
        }</span>

        <span>/* The first 4 lengths in the order (16, 17, 18, 0) cannot be used to
           encode any non-zero lengths. Since there will always be at least
           one non-zero codeword length (for EOB), n will be &gt;= 4. */</span>
        <span>assert</span><span>(</span><span>n</span> <span>&gt;=</span> <span>MIN_CODELEN_LENS</span> <span>&amp;&amp;</span> <span>n</span> <span>&lt;=</span> <span>MAX_CODELEN_LENS</span><span>);</span>

        <span>return</span> <span>n</span><span>;
}</span>
</pre></div>


<p>Assuming we have the litlen and dist codes set up, the encoding of their codeword lengths, and the code for that encoding, we can write the dynamic Huffman block:</p>

<div><pre><span>static</span> <span>bool</span> <span>write_dynamic_block</span><span>(</span><span>deflate_state_t</span> <span>*</span><span>s</span><span>,</span> <span>bool</span> <span>final</span><span>,</span>
                                <span>size_t</span> <span>num_litlen_lens</span><span>,</span> <span>size_t</span> <span>num_dist_lens</span><span>,</span>
                                <span>size_t</span> <span>num_codelen_lens</span><span>,</span>
                                <span>const</span> <span>huffman_encoder_t</span> <span>*</span><span>codelen_enc</span><span>,</span>
                                <span>const</span> <span>codelen_sym_t</span> <span>*</span><span>encoded_lens</span><span>,</span>
                                <span>size_t</span> <span>num_encoded_lens</span><span>,</span>
                                <span>const</span> <span>huffman_encoder_t</span> <span>*</span><span>litlen_enc</span><span>,</span>
                                <span>const</span> <span>huffman_encoder_t</span> <span>*</span><span>dist_enc</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>;</span>
        <span>uint8_t</span> <span>codelen</span><span>,</span> <span>sym</span><span>;</span>
        <span>size_t</span> <span>nbits</span><span>;</span>
        <span>uint64_t</span> <span>bits</span><span>,</span> <span>hlit</span><span>,</span> <span>hdist</span><span>,</span> <span>hclen</span><span>,</span> <span>count</span><span>;</span>

        <span>/* Block header. */</span>
        <span>bits</span> <span>=</span> <span>(</span><span>0x2</span> <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>|</span> <span>final</span><span>;</span>
        <span>nbits</span> <span>=</span> <span>3</span><span>;</span>

        <span>/* hlit (5 bits) */</span>
        <span>hlit</span> <span>=</span> <span>num_litlen_lens</span> <span>-</span> <span>MIN_LITLEN_LENS</span><span>;</span>
        <span>bits</span> <span>|=</span> <span>hlit</span> <span>&lt;&lt;</span> <span>nbits</span><span>;</span>
        <span>nbits</span> <span>+=</span> <span>5</span><span>;</span>

        <span>/* hdist (5 bits) */</span>
        <span>hdist</span> <span>=</span> <span>num_dist_lens</span> <span>-</span> <span>MIN_DIST_LENS</span><span>;</span>
        <span>bits</span> <span>|=</span> <span>hdist</span> <span>&lt;&lt;</span> <span>nbits</span><span>;</span>
        <span>nbits</span> <span>+=</span> <span>5</span><span>;</span>

        <span>/* hclen (4 bits) */</span>
        <span>hclen</span> <span>=</span> <span>num_codelen_lens</span> <span>-</span> <span>MIN_CODELEN_LENS</span><span>;</span>
        <span>bits</span> <span>|=</span> <span>hclen</span> <span>&lt;&lt;</span> <span>nbits</span><span>;</span>
        <span>nbits</span> <span>+=</span> <span>4</span><span>;</span>

        <span>if</span> <span>(</span><span>!</span><span>ostream_write</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>,</span> <span>bits</span><span>,</span> <span>nbits</span><span>)) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>/* Codelen lengths. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>num_codelen_lens</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>codelen</span> <span>=</span> <span>codelen_enc</span><span>-&gt;</span><span>lengths</span><span>[</span><span>codelen_lengths_order</span><span>[</span><span>i</span><span>]];</span>
                <span>if</span> <span>(</span><span>!</span><span>ostream_write</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>,</span> <span>codelen</span><span>,</span> <span>3</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }
        }</span>

        <span>/* Litlen and dist code lengths. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>num_encoded_lens</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>sym</span> <span>=</span> <span>encoded_lens</span><span>[</span><span>i</span><span>].</span><span>sym</span><span>;</span>

                <span>bits</span> <span>=</span> <span>codelen_enc</span><span>-&gt;</span><span>codewords</span><span>[</span><span>sym</span><span>];</span>
                <span>nbits</span> <span>=</span> <span>codelen_enc</span><span>-&gt;</span><span>lengths</span><span>[</span><span>sym</span><span>];</span>

                <span>count</span> <span>=</span> <span>encoded_lens</span><span>[</span><span>i</span><span>].</span><span>count</span><span>;</span>
                <span>if</span> <span>(</span><span>sym</span> <span>==</span> <span>CODELEN_COPY</span><span>) {</span> <span>/* 2 ebits */</span>
                        <span>bits</span> <span>|=</span> <span>(</span><span>count</span> <span>-</span> <span>CODELEN_COPY_MIN</span><span>)</span> <span>&lt;&lt;</span> <span>nbits</span><span>;</span>
                        <span>nbits</span> <span>+=</span> <span>2</span><span>;
                }</span> <span>else if</span> <span>(</span><span>sym</span> <span>==</span> <span>CODELEN_ZEROS</span><span>) {</span> <span>/* 3 ebits */</span>
                        <span>bits</span> <span>|=</span> <span>(</span><span>count</span> <span>-</span> <span>CODELEN_ZEROS_MIN</span><span>)</span> <span>&lt;&lt;</span> <span>nbits</span><span>;</span>
                        <span>nbits</span> <span>+=</span> <span>3</span><span>;
                }</span> <span>else if</span> <span>(</span><span>sym</span> <span>==</span> <span>CODELEN_ZEROS2</span><span>) {</span> <span>/* 7 ebits */</span>
                        <span>bits</span> <span>|=</span> <span>(</span><span>count</span> <span>-</span> <span>CODELEN_ZEROS2_MIN</span><span>)</span> <span>&lt;&lt;</span> <span>nbits</span><span>;</span>
                        <span>nbits</span> <span>+=</span> <span>7</span><span>;
                }</span>

                <span>if</span> <span>(</span><span>!</span><span>ostream_write</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>,</span> <span>bits</span><span>,</span> <span>nbits</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }
        }</span>

        <span>return</span> <span>write_huffman_block</span><span>(</span><span>s</span><span>,</span> <span>litlen_enc</span><span>,</span> <span>dist_enc</span><span>);
}</span>
</pre></div>


<p>For each block, we want to use the type that needs the smallest number of bits. For an uncompressed block, the length can be computed quickly:</p>

<div><pre><span>/* Calculate the number of bits for an uncompressed block, including header. */</span>
<span>static</span> <span>size_t</span> <span>uncomp_block_len</span><span>(</span><span>const</span> <span>deflate_state_t</span> <span>*</span><span>s</span><span>)
{</span>
        <span>size_t</span> <span>bit_pos</span><span>,</span> <span>padding</span><span>;</span>

        <span>/* Bit position after writing the block header. */</span>
        <span>bit_pos</span> <span>=</span> <span>ostream_bit_pos</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>)</span> <span>+</span> <span>3</span><span>;</span>
        <span>padding</span> <span>=</span> <span>round_up</span><span>(</span><span>bit_pos</span><span>,</span> <span>8</span><span>)</span> <span>-</span> <span>bit_pos</span><span>;</span>

        <span>/* Header + padding + len/nlen + block contents. */</span>
        <span>return</span> <span>3</span> <span>+</span> <span>padding</span> <span>+</span> <span>2</span> <span>*</span> <span>16</span> <span>+</span> <span>s</span><span>-&gt;</span><span>block_len_bytes</span> <span>*</span> <span>8</span><span>;
}</span>
</pre></div>


<p>For Huffman encoded blocks, we can compute the length of the body using the litlen and dist symbol frequencies and codeword lengths:</p>

<div><pre><span>/* Calculate the number of bits for a Huffman encoded block body. */</span>
<span>static</span> <span>size_t</span> <span>huffman_block_body_len</span><span>(</span><span>const</span> <span>deflate_state_t</span> <span>*</span><span>s</span><span>,</span>
                                     <span>const</span> <span>uint8_t</span> <span>*</span><span>litlen_lens</span><span>,</span>
                                     <span>const</span> <span>uint8_t</span> <span>*</span><span>dist_lens</span><span>)
{</span>
        <span>size_t</span> <span>i</span><span>,</span> <span>freq</span><span>,</span> <span>len</span><span>;</span>

        <span>len</span> <span>=</span> <span>0</span><span>;</span>

        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>LITLEN_MAX</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>freq</span> <span>=</span> <span>s</span><span>-&gt;</span><span>litlen_freqs</span><span>[</span><span>i</span><span>];</span>
                <span>len</span> <span>+=</span> <span>litlen_lens</span><span>[</span><span>i</span><span>]</span> <span>*</span> <span>freq</span><span>;</span>

                <span>if</span> <span>(</span><span>i</span> <span>&gt;=</span> <span>LITLEN_TBL_OFFSET</span><span>) {</span>
                        <span>len</span> <span>+=</span> <span>litlen_tbl</span><span>[</span><span>i</span> <span>-</span> <span>LITLEN_TBL_OFFSET</span><span>].</span><span>ebits</span> <span>*</span> <span>freq</span><span>;
                }
        }</span>

        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>DISTSYM_MAX</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>freq</span> <span>=</span> <span>s</span><span>-&gt;</span><span>dist_freqs</span><span>[</span><span>i</span><span>];</span>
                <span>len</span> <span>+=</span> <span>dist_lens</span><span>[</span><span>i</span><span>]</span> <span>*</span> <span>freq</span><span>;</span>
                <span>len</span> <span>+=</span> <span>dist_tbl</span><span>[</span><span>i</span><span>].</span><span>ebits</span> <span>*</span> <span>freq</span><span>;
        }</span>

        <span>return</span> <span>len</span><span>;
}</span>
</pre></div>


<p>For a static block, the total length is 3 bits for the header plus the length of the body. For a dynamic block, computing the size of the header requires a bit more work:</p>

<div><pre><span>/* Calculate the number of bits for a dynamic Huffman block. */</span>
<span>static</span> <span>size_t</span> <span>dyn_block_len</span><span>(</span><span>const</span> <span>deflate_state_t</span> <span>*</span><span>s</span><span>,</span> <span>size_t</span> <span>num_codelen_lens</span><span>,</span>
                            <span>const</span> <span>uint16_t</span> <span>*</span><span>codelen_freqs</span><span>,</span>
                            <span>const</span> <span>huffman_encoder_t</span> <span>*</span><span>codelen_enc</span><span>,</span>
                            <span>const</span> <span>huffman_encoder_t</span> <span>*</span><span>litlen_enc</span><span>,</span>
                            <span>const</span> <span>huffman_encoder_t</span> <span>*</span><span>dist_enc</span><span>)
{</span>
        <span>size_t</span> <span>len</span><span>,</span> <span>i</span><span>,</span> <span>freq</span><span>;</span>

        <span>/* Block header. */</span>
        <span>len</span> <span>=</span> <span>3</span><span>;</span>

        <span>/* Nbr of litlen, dist, and codelen lengths. */</span>
        <span>len</span> <span>+=</span> <span>5</span> <span>+</span> <span>5</span> <span>+</span> <span>4</span><span>;</span>

        <span>/* Codelen lengths. */</span>
        <span>len</span> <span>+=</span> <span>3</span> <span>*</span> <span>num_codelen_lens</span><span>;</span>

        <span>/* Codelen encoding. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>MAX_CODELEN_LENS</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>freq</span> <span>=</span> <span>codelen_freqs</span><span>[</span><span>i</span><span>];</span>
                <span>len</span> <span>+=</span> <span>codelen_enc</span><span>-&gt;</span><span>lengths</span><span>[</span><span>i</span><span>]</span> <span>*</span> <span>freq</span><span>;</span>

                <span>/* Extra bits. */</span>
                <span>if</span> <span>(</span><span>i</span> <span>==</span> <span>CODELEN_COPY</span><span>) {</span>
                        <span>len</span> <span>+=</span> <span>2</span> <span>*</span> <span>freq</span><span>;
                }</span> <span>else if</span> <span>(</span><span>i</span> <span>==</span> <span>CODELEN_ZEROS</span><span>) {</span>
                        <span>len</span> <span>+=</span> <span>3</span> <span>*</span> <span>freq</span><span>;
                }</span> <span>else if</span> <span>(</span><span>i</span> <span>==</span> <span>CODELEN_ZEROS2</span><span>) {</span>
                        <span>len</span> <span>+=</span> <span>7</span> <span>*</span> <span>freq</span><span>;
                }
        }</span>

        <span>return</span> <span>len</span> <span>+</span> <span>huffman_block_body_len</span><span>(</span><span>s</span><span>,</span> <span>litlen_enc</span><span>-&gt;</span><span>lengths</span><span>,</span>
                                            <span>dist_enc</span><span>-&gt;</span><span>lengths</span><span>);
}</span>
</pre></div>


<p>With all this in place, we can write the master block writing function:</p>

<div><pre><span>/* Write the current deflate block, marking it final if that parameter is true,
   returning false if there is not enough room in the output stream. */</span>
<span>static</span> <span>bool</span> <span>write_block</span><span>(</span><span>deflate_state_t</span> <span>*</span><span>s</span><span>,</span> <span>bool</span> <span>final</span><span>)
{</span>
        <span>size_t</span> <span>old_bit_pos</span><span>,</span> <span>uncomp_len</span><span>,</span> <span>static_len</span><span>,</span> <span>dynamic_len</span><span>;</span>
        <span>huffman_encoder_t</span> <span>dyn_litlen_enc</span><span>,</span> <span>dyn_dist_enc</span><span>,</span> <span>codelen_enc</span><span>;</span>
        <span>size_t</span> <span>num_encoded_lens</span><span>,</span> <span>num_litlen_lens</span><span>,</span> <span>num_dist_lens</span><span>;</span>
        <span>codelen_sym_t</span> <span>encoded_lens</span><span>[</span><span>LITLEN_MAX</span> <span>+</span> <span>1</span> <span>+</span> <span>DISTSYM_MAX</span> <span>+</span> <span>1</span><span>];</span>
        <span>uint16_t</span> <span>codelen_freqs</span><span>[</span><span>MAX_CODELEN_LENS</span><span>]</span> <span>=</span> <span>{</span><span>0</span><span>};</span>
        <span>size_t</span> <span>num_codelen_lens</span><span>;</span>
        <span>size_t</span> <span>i</span><span>;</span>

        <span>old_bit_pos</span> <span>=</span> <span>ostream_bit_pos</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>);</span>

        <span>/* Add the end-of-block marker in case we write a Huffman block. */</span>
        <span>assert</span><span>(</span><span>s</span><span>-&gt;</span><span>block_len</span> <span>&lt;</span> <span>sizeof</span><span>(</span><span>s</span><span>-&gt;</span><span>block</span><span>)</span> <span>/</span> <span>sizeof</span><span>(</span><span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>0</span><span>]));</span>
        <span>assert</span><span>(</span><span>s</span><span>-&gt;</span><span>litlen_freqs</span><span>[</span><span>LITLEN_EOB</span><span>]</span> <span>==</span> <span>0</span><span>);</span>
        <span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>s</span><span>-&gt;</span><span>block_len</span>  <span>].</span><span>distance</span> <span>=</span> <span>0</span><span>;</span>
        <span>s</span><span>-&gt;</span><span>block</span><span>[</span><span>s</span><span>-&gt;</span><span>block_len</span><span>++</span><span>].</span><span>u</span><span>.</span><span>lit</span> <span>=</span> <span>LITLEN_EOB</span><span>;</span>
        <span>s</span><span>-&gt;</span><span>litlen_freqs</span><span>[</span><span>LITLEN_EOB</span><span>]</span> <span>=</span> <span>1</span><span>;</span>


        <span>uncomp_len</span> <span>=</span> <span>uncomp_block_len</span><span>(</span><span>s</span><span>);</span>

        <span>static_len</span> <span>=</span> <span>3</span> <span>+</span> <span>huffman_block_body_len</span><span>(</span><span>s</span><span>,</span> <span>fixed_litlen_lengths</span><span>,</span>
                                                <span>fixed_dist_lengths</span><span>);</span>


        <span>/* Compute "dynamic" Huffman codes. */</span>
        <span>huffman_encoder_init</span><span>(</span><span>&amp;</span><span>dyn_litlen_enc</span><span>,</span> <span>s</span><span>-&gt;</span><span>litlen_freqs</span><span>,</span>
                             <span>LITLEN_MAX</span> <span>+</span> <span>1</span><span>,</span> <span>15</span><span>);</span>
        <span>huffman_encoder_init</span><span>(</span><span>&amp;</span><span>dyn_dist_enc</span><span>,</span> <span>s</span><span>-&gt;</span><span>dist_freqs</span><span>,</span> <span>DISTSYM_MAX</span> <span>+</span> <span>1</span><span>,</span> <span>15</span><span>);</span>

        <span>/* Encode the litlen and dist code lengths. */</span>
        <span>num_encoded_lens</span> <span>=</span> <span>encode_dist_litlen_lens</span><span>(</span><span>dyn_litlen_enc</span><span>.</span><span>lengths</span><span>,</span>
                                                   <span>dyn_dist_enc</span><span>.</span><span>lengths</span><span>,</span>
                                                   <span>encoded_lens</span><span>,</span>
                                                   <span>&amp;</span><span>num_litlen_lens</span><span>,</span>
                                                   <span>&amp;</span><span>num_dist_lens</span><span>);</span>

        <span>/* Compute the codelen code. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>num_encoded_lens</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>codelen_freqs</span><span>[</span><span>encoded_lens</span><span>[</span><span>i</span><span>].</span><span>sym</span><span>]</span><span>++</span><span>;
        }</span>
        <span>huffman_encoder_init</span><span>(</span><span>&amp;</span><span>codelen_enc</span><span>,</span> <span>codelen_freqs</span><span>,</span> <span>MAX_CODELEN_LENS</span><span>,</span> <span>7</span><span>);</span>
        <span>num_codelen_lens</span> <span>=</span> <span>count_codelen_lens</span><span>(</span><span>codelen_enc</span><span>.</span><span>lengths</span><span>);</span>

        <span>dynamic_len</span> <span>=</span> <span>dyn_block_len</span><span>(</span><span>s</span><span>,</span> <span>num_codelen_lens</span><span>,</span> <span>codelen_freqs</span><span>,</span>
                                    <span>&amp;</span><span>codelen_enc</span><span>,</span> <span>&amp;</span><span>dyn_litlen_enc</span><span>,</span>
                                    <span>&amp;</span><span>dyn_dist_enc</span><span>);</span>


        <span>if</span> <span>(</span><span>uncomp_len</span> <span>&lt;=</span> <span>dynamic_len</span> <span>&amp;&amp;</span> <span>uncomp_len</span> <span>&lt;=</span> <span>static_len</span><span>) {</span>
                <span>if</span> <span>(</span><span>!</span><span>write_uncomp_block</span><span>(</span><span>s</span><span>,</span> <span>final</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }</span>
                <span>assert</span><span>(</span><span>ostream_bit_pos</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>)</span> <span>-</span> <span>old_bit_pos</span> <span>==</span> <span>uncomp_len</span><span>);
        }</span> <span>else if</span> <span>(</span><span>static_len</span> <span>&lt;=</span> <span>dynamic_len</span><span>) {</span>
                <span>if</span> <span>(</span><span>!</span><span>write_static_block</span><span>(</span><span>s</span><span>,</span> <span>final</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }</span>
                <span>assert</span><span>(</span><span>ostream_bit_pos</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>)</span> <span>-</span> <span>old_bit_pos</span> <span>==</span> <span>static_len</span><span>);
        }</span> <span>else</span> <span>{</span>
                <span>if</span> <span>(</span><span>!</span><span>write_dynamic_block</span><span>(</span><span>s</span><span>,</span> <span>final</span><span>,</span> <span>num_litlen_lens</span><span>,</span>
                                         <span>num_dist_lens</span><span>,</span> <span>num_codelen_lens</span><span>,</span>
                                         <span>&amp;</span><span>codelen_enc</span><span>,</span> <span>encoded_lens</span><span>,</span>
                                         <span>num_encoded_lens</span><span>,</span> <span>&amp;</span><span>dyn_litlen_enc</span><span>,</span>
                                         <span>&amp;</span><span>dyn_dist_enc</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }</span>
                <span>assert</span><span>(</span><span>ostream_bit_pos</span><span>(</span><span>&amp;</span><span>s</span><span>-&gt;</span><span>os</span><span>)</span> <span>-</span> <span>old_bit_pos</span> <span>==</span> <span>dynamic_len</span><span>);
        }</span>

        <span>return</span> <span>true</span><span>;
}</span>
</pre></div>


<p>Finally, the driver of the whole deflation process simply has to set up the initial state, kick off the Lempel-Ziv compression, and write the final block:</p>

<div><pre><span>/* Compress (deflate) the data in src into dst. The number of bytes output, at
   most dst_cap, is stored in *dst_used. Returns false if there is not enough
   room in dst. src and dst must not overlap. */</span>
<span>bool</span> <span>hwdeflate</span><span>(</span><span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>src_len</span><span>,</span> <span>uint8_t</span> <span>*</span><span>dst</span><span>,</span>
               <span>size_t</span> <span>dst_cap</span><span>,</span> <span>size_t</span> <span>*</span><span>dst_used</span><span>)
{</span>
        <span>deflate_state_t</span> <span>s</span><span>;</span>

        <span>ostream_init</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>os</span><span>,</span> <span>dst</span><span>,</span> <span>dst_cap</span><span>);</span>
        <span>reset_block</span><span>(</span><span>&amp;</span><span>s</span><span>);</span>
        <span>s</span><span>.</span><span>block_src</span> <span>=</span> <span>src</span><span>;</span>

        <span>if</span> <span>(</span><span>!</span><span>lz77_compress</span><span>(</span><span>src</span><span>,</span> <span>src_len</span><span>,</span> <span>&amp;</span><span>lit_callback</span><span>,</span>
                           <span>&amp;</span><span>backref_callback</span><span>,</span> <span>&amp;</span><span>s</span><span>)) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>!</span><span>write_block</span><span>(</span><span>&amp;</span><span>s</span><span>,</span> <span>true</span><span>)) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>/* The end of the final block should match the end of src. */</span>
        <span>assert</span><span>(</span><span>s</span><span>.</span><span>block_src</span> <span>+</span> <span>s</span><span>.</span><span>block_len_bytes</span> <span>==</span> <span>src</span> <span>+</span> <span>src_len</span><span>);</span>

        <span>*</span><span>dst_used</span> <span>=</span> <span>ostream_bytes_written</span><span>(</span><span>&amp;</span><span>s</span><span>.</span><span>os</span><span>);</span>

        <span>return</span> <span>true</span><span>;
}</span>
</pre></div>



<h2>The Zip File Format</h2>

<p>We have seen above exactly how the Deflate compression used in Zip files works, but what about the file format itself? This section explains it in detail and provides an implementation. The code is available in <a href="https://www.hanshq.net/files/hwzip/zip.h"><span>zip.h</span></a> and <a href="https://www.hanshq.net/files/hwzip/zip.c"><span>zip.c</span></a>.</p>

<h3>Overview</h3>

<p>The file format is described in PKZip's <a href="https://www.pkware.com/documents/APPNOTE/APPNOTE-2.0.txt">Application Note</a>:</p>

<ol>
<li>Each file, or archive member, in the Zip file has a <em>Local File Header</em> with metadata about the member, such as its filename etc.</li>

<li>The <em>Central Directory</em> serves as an index of the archive. It contains a <em>Central File Header</em> for each archive member and holds a copy of the metadata from the Local File Header, and more information such as the member's offset in the ZIP file.</li>

<li>At the end of the file, directly after the Central Directory, comes the <em>End of Central Directory Record</em>. This contains the size and position of the Central Directory, and an optional comment about the whole archive. It is the starting point for reading a Zip file.</li>
</ol>

<div>
<p><img src="https://www.hanshq.net/gfx/tex_b8b86b0a.png" alt="LaTeX"></p>
</div>

<p>Each archive member is compressed and stored individually. This means that even if there are similarities between files in the archive, those similarities are not exploited to generate better compression.</p>

<p>Having the Central Directory at the end enables an archive to be created gradually. As each member file is compressed, it gets written to the archive, and the index is written afterwards when all the compressed sizes, and therefore the file offsets, are known. A file can also be added to an existing archive fairly easily, by putting it after the last member and re-writing the Central Directory.</p>

<p>The ability to create archives gradually was especially important for archives spanning multiple floppy disks, or volumes. As compression progressed, PKZip would prompt the user to insert new floppies, and finally write the Central Directory to the last one(s). To extract a multi-volume archive, PKZip would first ask for the last floppy in order to read the Central Directory, and then for whatever floppies were needed to extract the requested files.</p>

<p>Perhaps surprisingly, there is no rule against having multiple files with the same name in an archive. This can lead to great confusion during file extraction: if there are multiple files with the specified name, which one should be extracted? Such confusion can turn into security problems. In the Android "Master Key" Bug (<a href="https://nvd.nist.gov/vuln/detail/CVE-2013-4787">CVE-2013-4787</a>, Black Hat <a href="https://media.blackhat.com/us-13/US-13-Forristal-Android-One-Root-to-Own-Them-All-Slides.pdf">slides</a> / <a href="https://www.youtube.com/watch?v=mCF5kaCt4NI">video</a>), this allowed malicious actors to bypass the operating system's cryptographic signature checks when installing programs. Android programs are distributed in <a href="https://en.wikipedia.org/wiki/Android_application_package">APK</a> files, which are essentially Zip files. As it turned out, if an APK contained multiple files with the same name, the signature checking code would pick the <i>last</i> file with that name, whereas the installation code would pick the <i>first</i> file, meaning its signature was never checked. In other words, this minor difference between two Zip libraries made it possible to bypass the entire security model of the operating system.</p>

<p>Unlike most file formats, Zip files are not required to start with a signature or <a href="https://en.wikipedia.org/wiki/File_format#Magic_number">magic number</a>. In fact, it is not specified that a Zip file must start in any particular way at all, making it easy to create a file which is both a valid Zip file and a valid file of another format at the same time, a so called <em>polyglot file</em>. For example, a self-extracting Zip file (such as <a href="https://www.hanshq.net/files/pkz204g.exe">pkz204g.exe</a>) is usually both a valid executable and a Zip file: the first part is an executable, and after that follows the Zip file (which the executable extracts). The operating system can run it as an executable, but a Zip program will open it as a Zip file. This ability for Zip files to also be valid executables may have been the motivation for not requiring a signature at the beginning of the file.</p>

<p>While the self-extracting Zip/executable files are clever, polyglots can also cause security problems, as they may trick software that tries to determine the contents of a file, or allow delivering malicious code along with a file of a different type. For example, <a href="https://en.wikipedia.org/wiki/Gifar">GIFARs</a>, files that are both valid GIF images and Java Archives (JARs, a form of Zip file), have been used in security exploits on the web. For more thoughts on these kinds of problems, see Ange Albertini's <a href="https://www.alchemistowl.org/pocorgtfo/pocorgtfo07.pdf">Abusing file formats article</a> (begins on page 18).</p>

<p>As we will see below, Zip files use 32-bit fields for offsets and sizes, limiting the size of the archive and its members to 4 GB. In <a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-4.5.0.txt">Version 4.5 of the Application Note</a>, PKWare added format extensions to allow 64-bit offsets and sizes. Files using those extensions are said to be in Zip64 format, but that is not covered in this article.</p>


<h3>Data Structures</h3>

<h4>End of Central Directory Record</h4>

<p>The EOCDR is normally used as the starting point for reading a Zip file. It contains the location and size of the Central Directory, and an optional comment about the whole archive.</p>

<p>For Zip files spanning multiple floppy disks, or volumes, the EOCDR also contains information about which disk we are currently on, on what disk the Central Directory begins, etc. This functionality is rarely used these days, and the code in this article does not handle such files.</p>

<p>The EOCDR is identified by the signature <span>'P'</span> <span>'K'</span>, followed by the bytes 5 and 6. It then has the following structure, with integers stored in little-endian byte order:</p>

<div><pre><span>/* End of Central Directory Record. */</span>
<span>struct</span> <span>eocdr</span> <span>{</span>
        <span>uint16_t</span> <span>disk_nbr</span><span>;</span>        <span>/* Number of this disk. */</span>
        <span>uint16_t</span> <span>cd_start_disk</span><span>;</span>   <span>/* Nbr. of disk with start of the CD. */</span>
        <span>uint16_t</span> <span>disk_cd_entries</span><span>;</span> <span>/* Nbr. of CD entries on this disk. */</span>
        <span>uint16_t</span> <span>cd_entries</span><span>;</span>      <span>/* Nbr. of Central Directory entries. */</span>
        <span>uint32_t</span> <span>cd_size</span><span>;</span>         <span>/* Central Directory size in bytes. */</span>
        <span>uint32_t</span> <span>cd_offset</span><span>;</span>       <span>/* Central Directory file offset. */</span>
        <span>uint16_t</span> <span>comment_len</span><span>;</span>     <span>/* Archive comment length. */</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>comment</span><span>;</span>   <span>/* Archive comment. */</span>
<span>};</span>
</pre></div>


<p>The EOCDR should be located at the end of the file. However, since it can have a trailing comment of arbitrary 16-bit length, we may have to search to find the exact position:</p>

<div><pre><span>/* Read 16/32 bits little-endian and bump p forward afterwards. */</span>
<span>#define READ16(p) ((p) += 2, read16le((p) - 2))
#define READ32(p) ((p) += 4, read32le((p) - 4))</span>

<span>/* Size of the End of Central Directory Record, not including comment. */</span>
<span>#define EOCDR_BASE_SZ 22
#define EOCDR_SIGNATURE 0x06054b50  </span><span>/* "PK" little-endian. */</span><span></span>

<span>static</span> <span>bool</span> <span>find_eocdr</span><span>(</span><span>struct</span> <span>eocdr</span> <span>*</span><span>r</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>src_len</span><span>)
{</span>
        <span>size_t</span> <span>comment_len</span><span>;</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>p</span><span>;</span>
        <span>uint32_t</span> <span>signature</span><span>;</span>

        <span>for</span> <span>(</span><span>comment_len</span> <span>=</span> <span>0</span><span>;</span> <span>comment_len</span> <span>&lt;=</span> <span>UINT16_MAX</span><span>;</span> <span>comment_len</span><span>++</span><span>) {</span>
                <span>if</span> <span>(</span><span>src_len</span> <span>&lt;</span> <span>EOCDR_BASE_SZ</span> <span>+</span> <span>comment_len</span><span>) {</span>
                        <span>break</span><span>;
                }</span>

                <span>p</span> <span>= &amp;</span><span>src</span><span>[</span><span>src_len</span> <span>-</span> <span>EOCDR_BASE_SZ</span> <span>-</span> <span>comment_len</span><span>];</span>
                <span>signature</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>

                <span>if</span> <span>(</span><span>signature</span> <span>==</span> <span>EOCDR_SIGNATURE</span><span>) {</span>
                        <span>r</span><span>-&gt;</span><span>disk_nbr</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
                        <span>r</span><span>-&gt;</span><span>cd_start_disk</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
                        <span>r</span><span>-&gt;</span><span>disk_cd_entries</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
                        <span>r</span><span>-&gt;</span><span>cd_entries</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
                        <span>r</span><span>-&gt;</span><span>cd_size</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
                        <span>r</span><span>-&gt;</span><span>cd_offset</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
                        <span>r</span><span>-&gt;</span><span>comment_len</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
                        <span>r</span><span>-&gt;</span><span>comment</span> <span>=</span> <span>p</span><span>;</span>
                        <span>assert</span><span>(</span><span>p</span> <span>== &amp;</span><span>src</span><span>[</span><span>src_len</span> <span>-</span> <span>comment_len</span><span>]</span> <span>&amp;&amp;</span>
                               <span>"All fields read."</span><span>);</span>

                        <span>if</span> <span>(</span><span>r</span><span>-&gt;</span><span>comment_len</span> <span>==</span> <span>comment_len</span><span>) {</span>
                                <span>return</span> <span>true</span><span>;
                        }
                }
        }</span>

        <span>return</span> <span>false</span><span>;
}</span>
</pre></div>


<p>Writing an EOCDR is straight-forward. The function below does that and returns the number of bytes written.</p>

<div><pre><span>/* Write 16/32 bits little-endian and bump p forward afterwards. */</span>
<span>#define WRITE16(p, x) (write16le((p), (x)), (p) += 2)
#define WRITE32(p, x) (write32le((p), (x)), (p) += 4)</span>

<span>static</span> <span>size_t</span> <span>write_eocdr</span><span>(</span><span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>const struct</span> <span>eocdr</span> <span>*</span><span>r</span><span>)
{</span>
        <span>uint8_t</span> <span>*</span><span>p</span> <span>=</span> <span>dst</span><span>;</span>

        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>EOCDR_SIGNATURE</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>r</span><span>-&gt;</span><span>disk_nbr</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>r</span><span>-&gt;</span><span>cd_start_disk</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>r</span><span>-&gt;</span><span>disk_cd_entries</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>r</span><span>-&gt;</span><span>cd_entries</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>r</span><span>-&gt;</span><span>cd_size</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>r</span><span>-&gt;</span><span>cd_offset</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>r</span><span>-&gt;</span><span>comment_len</span><span>);</span>
        <span>assert</span><span>(</span><span>p</span> <span>-</span> <span>dst</span> <span>==</span> <span>EOCDR_BASE_SZ</span><span>);</span>

        <span>if</span> <span>(</span><span>r</span><span>-&gt;</span><span>comment_len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>memcpy</span><span>(</span><span>p</span><span>,</span> <span>r</span><span>-&gt;</span><span>comment</span><span>,</span> <span>r</span><span>-&gt;</span><span>comment_len</span><span>);</span>
                <span>p</span> <span>+=</span> <span>r</span><span>-&gt;</span><span>comment_len</span><span>;
        }</span>

        <span>return</span> <span>(</span><span>size_t</span><span>)(</span><span>p</span> <span>-</span> <span>dst</span><span>);
}</span>
</pre></div>



<h4>Central File Header</h4>

<p>The Central Directory consists of Central File Headers written back-to-back, one for each member of the archive. Each header starts with the signature 'P', 'K', 1, 2, and then has the following structure:</p>

<div><pre><span>#define EXT_ATTR_DIR (1U &lt;&lt; 4)
#define EXT_ATTR_ARC (1U &lt;&lt; 5)</span>

<span>/* Central File Header (Central Directory Entry) */</span>
<span>struct</span> <span>cfh</span> <span>{</span>
        <span>uint16_t</span> <span>made_by_ver</span><span>;</span>    <span>/* Version made by. */</span>
        <span>uint16_t</span> <span>extract_ver</span><span>;</span>    <span>/* Version needed to extract. */</span>
        <span>uint16_t</span> <span>gp_flag</span><span>;</span>        <span>/* General purpose bit flag. */</span>
        <span>uint16_t</span> <span>method</span><span>;</span>         <span>/* Compression method. */</span>
        <span>uint16_t</span> <span>mod_time</span><span>;</span>       <span>/* Modification time. */</span>
        <span>uint16_t</span> <span>mod_date</span><span>;</span>       <span>/* Modification date. */</span>
        <span>uint32_t</span> <span>crc32</span><span>;</span>          <span>/* CRC-32 checksum. */</span>
        <span>uint32_t</span> <span>comp_size</span><span>;</span>      <span>/* Compressed size. */</span>
        <span>uint32_t</span> <span>uncomp_size</span><span>;</span>    <span>/* Uncompressed size. */</span>
        <span>uint16_t</span> <span>name_len</span><span>;</span>       <span>/* Filename length. */</span>
        <span>uint16_t</span> <span>extra_len</span><span>;</span>      <span>/* Extra data length. */</span>
        <span>uint16_t</span> <span>comment_len</span><span>;</span>    <span>/* Comment length. */</span>
        <span>uint16_t</span> <span>disk_nbr_start</span><span>;</span> <span>/* Disk nbr. where file begins. */</span>
        <span>uint16_t</span> <span>int_attrs</span><span>;</span>      <span>/* Internal file attributes. */</span>
        <span>uint32_t</span> <span>ext_attrs</span><span>;</span>      <span>/* External file attributes. */</span>
        <span>uint32_t</span> <span>lfh_offset</span><span>;</span>     <span>/* Local File Header offset. */</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>name</span><span>;</span>     <span>/* Filename. */</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>extra</span><span>;</span>    <span>/* Extra data. */</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>comment</span><span>;</span>  <span>/* File comment. */</span>
<span>};</span>
</pre></div>


<p><span>made_by_ver</span> and <span>extract_ver</span> encode operating system and version information of the program used to add this member, and what version is required to extract it, respectively. The most significant eight bits encode the operating system (for example, 0 means DOS, 3 Unix, 10 Windows NTFS) and the lower eight bits the software version. We will set that version to decimal 20, indicating compatibility with PKZip 2.0.</p>

<p><span>gp_flag</span> contains various flags. Some interesting ones are bit 0, which indicates whether the member is encrypted (out of scope for this article), and bits 1 and 2 which encode the Deflate compression level (0 for normal, 1 for maximum, 2 for fast, 3 for super fast).</p>

<p><span>method</span> encodes the compression method. Method 0 means the data is uncompressed, method 8 means it is deflated. Other values refer to historic or newer algorithms, but almost all Zip files use only these two values.</p>

<p><span>mod_time</span> and <span>mod_date</span> contain the file's modification date and time, encoded in <a href="http://www.ctyme.com/intr/rb-2992.htm#table1665">MS-DOS date/time format</a>. We use the code below to convert to and from regular C <span>time_t</span> timestamps.</p>

<div><pre><span>/* Convert DOS date and time to time_t. */</span>
<span>static</span> <span>time_t</span> <span>dos2ctime</span><span>(</span><span>uint16_t</span> <span>dos_date</span><span>,</span> <span>uint16_t</span> <span>dos_time</span><span>)
{</span>
        <span>struct</span> <span>tm tm</span> <span>=</span> <span>{</span><span>0</span><span>};</span>

        <span>tm</span><span>.</span><span>tm_sec</span> <span>=</span> <span>(</span><span>dos_time</span> <span>&amp;</span> <span>0x1f</span><span>)</span> <span>*</span> <span>2</span><span>;</span>  <span>/* Bits 0--4:  Secs divided by 2. */</span>
        <span>tm</span><span>.</span><span>tm_min</span> <span>=</span> <span>(</span><span>dos_time</span> <span>&gt;&gt;</span> <span>5</span><span>)</span> <span>&amp;</span> <span>0x3f</span><span>;</span> <span>/* Bits 5--10: Minute. */</span>
        <span>tm</span><span>.</span><span>tm_hour</span> <span>=</span> <span>(</span><span>dos_time</span> <span>&gt;&gt;</span> <span>11</span><span>);</span>      <span>/* Bits 11-15: Hour (0--23). */</span>

        <span>tm</span><span>.</span><span>tm_mday</span> <span>=</span> <span>(</span><span>dos_date</span> <span>&amp;</span> <span>0x1f</span><span>);</span>          <span>/* Bits 0--4: Day (1--31). */</span>
        <span>tm</span><span>.</span><span>tm_mon</span> <span>=</span> <span>((</span><span>dos_date</span> <span>&gt;&gt;</span> <span>5</span><span>)</span> <span>&amp;</span> <span>0xf</span><span>)</span> <span>-</span> <span>1</span><span>;</span> <span>/* Bits 5--8: Month (1--12). */</span>
        <span>tm</span><span>.</span><span>tm_year</span> <span>=</span> <span>(</span><span>dos_date</span> <span>&gt;&gt;</span> <span>9</span><span>)</span> <span>+</span> <span>80</span><span>;</span>       <span>/* Bits 9--15: Year-1980. */</span>

        <span>tm</span><span>.</span><span>tm_isdst</span> <span>= -</span><span>1</span><span>;</span>

        <span>return</span> <span>mktime</span><span>(</span><span>&amp;</span><span>tm</span><span>);
}</span>

<span>/* Convert time_t to DOS date and time. */</span>
<span>static</span> <span>void</span> <span>ctime2dos</span><span>(</span><span>time_t</span> <span>t</span><span>,</span> <span>uint16_t</span> <span>*</span><span>dos_date</span><span>,</span> <span>uint16_t</span> <span>*</span><span>dos_time</span><span>)
{</span>
        <span>struct</span> <span>tm</span> <span>*</span><span>tm</span> <span>=</span> <span>localtime</span><span>(</span><span>&amp;</span><span>t</span><span>);</span>

        <span>*</span><span>dos_time</span> <span>=</span> <span>0</span><span>;</span>
        <span>*</span><span>dos_time</span> <span>|=</span> <span>tm</span><span>-&gt;</span><span>tm_sec</span> <span>/</span> <span>2</span><span>;</span>    <span>/* Bits 0--4:  Second divided by two. */</span>
        <span>*</span><span>dos_time</span> <span>|=</span> <span>tm</span><span>-&gt;</span><span>tm_min</span> <span>&lt;&lt;</span> <span>5</span><span>;</span>   <span>/* Bits 5--10: Minute. */</span>
        <span>*</span><span>dos_time</span> <span>|=</span> <span>tm</span><span>-&gt;</span><span>tm_hour</span> <span>&lt;&lt;</span> <span>11</span><span>;</span> <span>/* Bits 11-15: Hour. */</span>

        <span>*</span><span>dos_date</span> <span>=</span> <span>0</span><span>;</span>
        <span>*</span><span>dos_date</span> <span>|=</span> <span>tm</span><span>-&gt;</span><span>tm_mday</span><span>;</span>             <span>/* Bits 0--4:  Day (1--31). */</span>
        <span>*</span><span>dos_date</span> <span>|=</span> <span>(</span><span>tm</span><span>-&gt;</span><span>tm_mon</span> <span>+</span> <span>1</span><span>)</span> <span>&lt;&lt;</span> <span>5</span><span>;</span>   <span>/* Bits 5--8:  Month (1--12). */</span>
        <span>*</span><span>dos_date</span> <span>|=</span> <span>(</span><span>tm</span><span>-&gt;</span><span>tm_year</span> <span>-</span> <span>80</span><span>)</span> <span>&lt;&lt;</span> <span>9</span><span>;</span> <span>/* Bits 9--15: Year from 1980. */</span>
<span>}</span>
</pre></div>


<p>The <span>crc32</span> field contains a <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">cyclic redundancy check</a> value of the uncompressed data. This is used to verify the intergity of the data after extraction. See <a href="https://www.hanshq.net/files/hwzip/crc32.c"><span>crc32.c</span></a> for an implementation.</p>

<p><span>comp_size</span> and <span>uncomp_size</span> contain the compressed and uncompressed size of the member file's data, respectively. The next three fields contain the lengths of the <span>name</span>, <span>comment</span>, and <span>extra</span> data that follow immediately after the header. <span>disk_nbr_start</span> is for archives spanning multiple floppy disks.</p>

<p><span>int_attrs</span> and <span>ext_attrs</span> describe internal and external attributes of the file. Internal attributes pertain to the contents of the file, such as the lowest bit which indicates that it only contains text. The external attributes are such as whether the file is read-only, hidden, etc. The encoding of this field varies by operating system, that is, it depends on <span>made_by_ver</span>. On DOS, the lowest 8 bits contain the file's attributes byte that one would get from an <a href="http://www.ctyme.com/intr/rb-2802.htm">Int 21/AX=4300h</a> system call. For example, bit 4 means it is a directory and bit 5 means the "archive" attribute is set (which is true for most files on DOS). From what I understand, those bits will be set similarly on other operating systems for compatibility. On Unix, the upper 16 bits of this field hold the file mode bits, as returned by <a href="https://linux.die.net/man/2/stat">stat(2)</a> in <span>st_mode</span>.</p>

<p><span>lfh_offset</span> tells us where to find the file's Local File Header, <span>name</span> is the filename (not null terminated), and <span>comment</span> is an optional comment for this archive member (not null terminated). <span>extra</span> can hold optional extra data such as Unix file ownership information, higher resolution modification date and time, or Zip64 fields.</p>

<p>The functions below are used to read and write CFHs.</p>

<div><pre><span>/* Size of a Central File Header, not including name, extra, and comment. */</span>
<span>#define CFH_BASE_SZ 46
#define CFH_SIGNATURE 0x02014b50 </span><span>/* "PK" little-endian. */</span><span></span>

<span>static</span> <span>bool</span> <span>read_cfh</span><span>(</span><span>struct</span> <span>cfh</span> <span>*</span><span>cfh</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>src_len</span><span>,</span>
                     <span>size_t</span> <span>offset</span><span>)
{</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>p</span><span>;</span>
        <span>uint32_t</span> <span>signature</span><span>;</span>

        <span>if</span> <span>(</span><span>offset</span> <span>&gt;</span> <span>src_len</span> <span>||</span> <span>src_len</span> <span>-</span> <span>offset</span> <span>&lt;</span> <span>CFH_BASE_SZ</span><span>) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>p</span> <span>= &amp;</span><span>src</span><span>[</span><span>offset</span><span>];</span>
        <span>signature</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>if</span> <span>(</span><span>signature</span> <span>!=</span> <span>CFH_SIGNATURE</span><span>) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>cfh</span><span>-&gt;</span><span>made_by_ver</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>extract_ver</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>gp_flag</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>method</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>mod_time</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>mod_date</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>crc32</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>comp_size</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>uncomp_size</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>name_len</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>extra_len</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>comment_len</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>disk_nbr_start</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>int_attrs</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>ext_attrs</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>lfh_offset</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>cfh</span><span>-&gt;</span><span>name</span> <span>=</span> <span>p</span><span>;</span>
        <span>cfh</span><span>-&gt;</span><span>extra</span> <span>=</span> <span>cfh</span><span>-&gt;</span><span>name</span> <span>+</span> <span>cfh</span><span>-&gt;</span><span>name_len</span><span>;</span>
        <span>cfh</span><span>-&gt;</span><span>comment</span> <span>=</span> <span>cfh</span><span>-&gt;</span><span>extra</span> <span>+</span> <span>cfh</span><span>-&gt;</span><span>extra_len</span><span>;</span>
        <span>assert</span><span>(</span><span>p</span> <span>== &amp;</span><span>src</span><span>[</span><span>offset</span> <span>+</span> <span>CFH_BASE_SZ</span><span>]</span> <span>&amp;&amp;</span> <span>"All fields read."</span><span>);</span>

        <span>if</span> <span>(</span><span>src_len</span> <span>-</span> <span>offset</span> <span>-</span> <span>CFH_BASE_SZ</span> <span>&lt;</span>
            <span>cfh</span><span>-&gt;</span><span>name_len</span> <span>+</span> <span>cfh</span><span>-&gt;</span><span>extra_len</span> <span>+</span> <span>cfh</span><span>-&gt;</span><span>comment_len</span><span>) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>return</span> <span>true</span><span>;
}</span>

<span>static</span> <span>size_t</span> <span>write_cfh</span><span>(</span><span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>const struct</span> <span>cfh</span> <span>*</span><span>cfh</span><span>)
{</span>
        <span>uint8_t</span> <span>*</span><span>p</span> <span>=</span> <span>dst</span><span>;</span>

        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>CFH_SIGNATURE</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>made_by_ver</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>extract_ver</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>gp_flag</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>method</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>mod_time</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>mod_date</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>crc32</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>comp_size</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>uncomp_size</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>name_len</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>extra_len</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>comment_len</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>disk_nbr_start</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>int_attrs</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>ext_attrs</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>lfh_offset</span><span>);</span>
        <span>assert</span><span>(</span><span>p</span> <span>-</span> <span>dst</span> <span>==</span> <span>CFH_BASE_SZ</span><span>);</span>

        <span>if</span> <span>(</span><span>cfh</span><span>-&gt;</span><span>name_len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>memcpy</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>name</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>name_len</span><span>);</span>
                <span>p</span> <span>+=</span> <span>cfh</span><span>-&gt;</span><span>name_len</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>cfh</span><span>-&gt;</span><span>extra_len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>memcpy</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>extra</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>extra_len</span><span>);</span>
                <span>p</span> <span>+=</span> <span>cfh</span><span>-&gt;</span><span>extra_len</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>cfh</span><span>-&gt;</span><span>comment_len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>memcpy</span><span>(</span><span>p</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>comment</span><span>,</span> <span>cfh</span><span>-&gt;</span><span>comment_len</span><span>);</span>
                <span>p</span> <span>+=</span> <span>cfh</span><span>-&gt;</span><span>comment_len</span><span>;
        }</span>

        <span>return</span> <span>(</span><span>size_t</span><span>)(</span><span>p</span> <span>-</span> <span>dst</span><span>);
}</span>
</pre></div>



<h4>Local File Header</h4>

<p>The data of each archive member is preceded by a Local File Header, which repeats most of the information from the Central File Header.</p>

<p>This redundancy between the central and local file headers was perhaps designed in order to allow PKZip not to have to keep the entire central directory in memory during extraction. Instead, as each file was extracted, the names and other information could be read from the local headers. Additionally, the local headers can be useful for recovering files from a Zip archive where the central directory is missing or corrupted. However, this redundancy is also a major source of ambiguity. For example, what happens when the filenames in the central and local headers mismatch? Such ambiguities often lead to bugs and security problems.</p>

<p>Not everything from the Central File Header is replicated, though. For example, there are no fields for the file's attributes. Also, if the third least significant bit of <span>gp_flags</span> is set, the CRC-32, compressed and uncompressed size fields will be set to zero, and that information will instead be found in a <em>Data Descriptor</em> block after the file's data (not covered here). This allows writing the LFH before knowing how large the member file is or what size it will compress to.</p>

<p>The Local File Header starts with the signature 'P', 'K', 3, 4, and then has the following structure:</p>

<div><pre><span>/* Local File Header. */</span>
<span>struct</span> <span>lfh</span> <span>{</span>
        <span>uint16_t</span> <span>extract_ver</span><span>;</span>
        <span>uint16_t</span> <span>gp_flag</span><span>;</span>
        <span>uint16_t</span> <span>method</span><span>;</span>
        <span>uint16_t</span> <span>mod_time</span><span>;</span>
        <span>uint16_t</span> <span>mod_date</span><span>;</span>
        <span>uint32_t</span> <span>crc32</span><span>;</span>
        <span>uint32_t</span> <span>comp_size</span><span>;</span>
        <span>uint32_t</span> <span>uncomp_size</span><span>;</span>
        <span>uint16_t</span> <span>name_len</span><span>;</span>
        <span>uint16_t</span> <span>extra_len</span><span>;</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>name</span><span>;</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>extra</span><span>;
};</span>
</pre></div>


<p>The functions below read and write LFHs similarly to the other data structures:</p>

<div><pre><span>/* Size of a Local File Header, not including name and extra. */</span>
<span>#define LFH_BASE_SZ 30
#define LFH_SIGNATURE 0x04034b50 </span><span>/* "PK" little-endian. */</span><span></span>

<span>static</span> <span>bool</span> <span>read_lfh</span><span>(</span><span>struct</span> <span>lfh</span> <span>*</span><span>lfh</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>src_len</span><span>,</span>
                     <span>size_t</span> <span>offset</span><span>)
{</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>p</span><span>;</span>
        <span>uint32_t</span> <span>signature</span><span>;</span>

        <span>if</span> <span>(</span><span>offset</span> <span>&gt;</span> <span>src_len</span> <span>||</span> <span>src_len</span> <span>-</span> <span>offset</span> <span>&lt;</span> <span>LFH_BASE_SZ</span><span>) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>p</span> <span>= &amp;</span><span>src</span><span>[</span><span>offset</span><span>];</span>
        <span>signature</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>if</span> <span>(</span><span>signature</span> <span>!=</span> <span>LFH_SIGNATURE</span><span>) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>lfh</span><span>-&gt;</span><span>extract_ver</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>gp_flag</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>method</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>mod_time</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>mod_date</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>crc32</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>comp_size</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>uncomp_size</span> <span>=</span> <span>READ32</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>name_len</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>extra_len</span> <span>=</span> <span>READ16</span><span>(</span><span>p</span><span>);</span>
        <span>lfh</span><span>-&gt;</span><span>name</span> <span>=</span> <span>p</span><span>;</span>
        <span>lfh</span><span>-&gt;</span><span>extra</span> <span>=</span> <span>lfh</span><span>-&gt;</span><span>name</span> <span>+</span> <span>lfh</span><span>-&gt;</span><span>name_len</span><span>;</span>
        <span>assert</span><span>(</span><span>p</span> <span>== &amp;</span><span>src</span><span>[</span><span>offset</span> <span>+</span> <span>LFH_BASE_SZ</span><span>]</span> <span>&amp;&amp;</span> <span>"All fields read."</span><span>);</span>

        <span>if</span> <span>(</span><span>src_len</span> <span>-</span> <span>offset</span> <span>-</span> <span>LFH_BASE_SZ</span> <span>&lt;</span> <span>lfh</span><span>-&gt;</span><span>name_len</span> <span>+</span> <span>lfh</span><span>-&gt;</span><span>extra_len</span><span>) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>return</span> <span>true</span><span>;
}</span>

<span>static</span> <span>size_t</span> <span>write_lfh</span><span>(</span><span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>const struct</span> <span>lfh</span> <span>*</span><span>lfh</span><span>)
{</span>
        <span>uint8_t</span> <span>*</span><span>p</span> <span>=</span> <span>dst</span><span>;</span>

        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>LFH_SIGNATURE</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>extract_ver</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>gp_flag</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>method</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>mod_time</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>mod_date</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>crc32</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>comp_size</span><span>);</span>
        <span>WRITE32</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>uncomp_size</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>name_len</span><span>);</span>
        <span>WRITE16</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>extra_len</span><span>);</span>
        <span>assert</span><span>(</span><span>p</span> <span>-</span> <span>dst</span> <span>==</span> <span>LFH_BASE_SZ</span><span>);</span>

        <span>if</span> <span>(</span><span>lfh</span><span>-&gt;</span><span>name_len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>memcpy</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>name</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>name_len</span><span>);</span>
                <span>p</span> <span>+=</span> <span>lfh</span><span>-&gt;</span><span>name_len</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>lfh</span><span>-&gt;</span><span>extra_len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>memcpy</span><span>(</span><span>p</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>extra</span><span>,</span> <span>lfh</span><span>-&gt;</span><span>extra_len</span><span>);</span>
                <span>p</span> <span>+=</span> <span>lfh</span><span>-&gt;</span><span>extra_len</span><span>;
        }</span>

        <span>return</span> <span>(</span><span>size_t</span><span>)(</span><span>p</span> <span>-</span> <span>dst</span><span>);
}</span>
</pre></div>


<h3>Zip Reader Implementation</h3>

<p>Using the functions above, we provide a function to read a Zip file in memory and get an iterator for accessing the members:</p>

<div><pre><span>typedef</span> <span>size_t zipiter_t</span><span>;</span> <span>/* Zip archive member iterator. */</span>

<span>typedef struct</span> <span>zip_t zip_t</span><span>;</span>
<span>struct</span> <span>zip_t</span> <span>{</span>
        <span>uint16_t</span> <span>num_members</span><span>;</span>    <span>/* Number of members. */</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>comment</span><span>;</span>  <span>/* Zip file comment (not terminated). */</span>
        <span>uint16_t</span> <span>comment_len</span><span>;</span>    <span>/* Zip file comment length. */</span>
        <span>zipiter_t</span> <span>members_begin</span><span>;</span> <span>/* Iterator to the first member. */</span>
        <span>zipiter_t</span> <span>members_end</span><span>;</span>   <span>/* Iterator to the end of members. */</span>

        <span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>;</span>
        <span>size_t</span> <span>src_len</span><span>;
};</span>

<span>/* Initialize zip based on the source data. Returns true on success, or false
   if the data could not be parsed as a valid Zip file. */</span>
<span>bool</span> <span>zip_read</span><span>(</span><span>zip_t</span> <span>*</span><span>zip</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>src</span><span>,</span> <span>size_t</span> <span>src_len</span><span>)
{</span>
        <span>struct</span> <span>eocdr eocdr</span><span>;</span>
        <span>struct</span> <span>cfh cfh</span><span>;</span>
        <span>struct</span> <span>lfh lfh</span><span>;</span>
        <span>size_t</span> <span>i</span><span>,</span> <span>offset</span><span>;</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>comp_data</span><span>;</span>

        <span>zip</span><span>-&gt;</span><span>src</span> <span>=</span> <span>src</span><span>;</span>
        <span>zip</span><span>-&gt;</span><span>src_len</span> <span>=</span> <span>src_len</span><span>;</span>

        <span>if</span> <span>(</span><span>!</span><span>find_eocdr</span><span>(</span><span>&amp;</span><span>eocdr</span><span>,</span> <span>src</span><span>,</span> <span>src_len</span><span>)) {</span>
                <span>return</span> <span>false</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>eocdr</span><span>.</span><span>disk_nbr</span> <span>!=</span> <span>0</span> <span>||</span> <span>eocdr</span><span>.</span><span>cd_start_disk</span> <span>!=</span> <span>0</span> <span>||</span>
            <span>eocdr</span><span>.</span><span>disk_cd_entries</span> <span>!=</span> <span>eocdr</span><span>.</span><span>cd_entries</span><span>) {</span>
                <span>return</span> <span>false</span><span>;</span> <span>/* Cannot handle multi-volume archives. */</span>
        <span>}</span>

        <span>zip</span><span>-&gt;</span><span>num_members</span> <span>=</span> <span>eocdr</span><span>.</span><span>cd_entries</span><span>;</span>
        <span>zip</span><span>-&gt;</span><span>comment</span> <span>=</span> <span>eocdr</span><span>.</span><span>comment</span><span>;</span>
        <span>zip</span><span>-&gt;</span><span>comment_len</span> <span>=</span> <span>eocdr</span><span>.</span><span>comment_len</span><span>;</span>

        <span>offset</span> <span>=</span> <span>eocdr</span><span>.</span><span>cd_offset</span><span>;</span>
        <span>zip</span><span>-&gt;</span><span>members_begin</span> <span>=</span> <span>offset</span><span>;</span>

        <span>/* Read the member info and do a few checks. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>eocdr</span><span>.</span><span>cd_entries</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>if</span> <span>(</span><span>!</span><span>read_cfh</span><span>(</span><span>&amp;</span><span>cfh</span><span>,</span> <span>src</span><span>,</span> <span>src_len</span><span>,</span> <span>offset</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }</span>

                <span>if</span> <span>(</span><span>cfh</span><span>.</span><span>gp_flag</span> <span>&amp;</span> <span>1</span><span>) {</span>
                        <span>return</span> <span>false</span><span>;</span> <span>/* The member is encrypted. */</span>
                <span>}</span>
                <span>if</span> <span>(</span><span>cfh</span><span>.</span><span>method</span> <span>!=</span> <span>ZIP_STORED</span> <span>&amp;&amp;</span> <span>cfh</span><span>.</span><span>method</span> <span>!=</span> <span>ZIP_DEFLATED</span><span>) {</span>
                        <span>return</span> <span>false</span><span>;</span> <span>/* Unsupported compression method. */</span>
                <span>}</span>
                <span>if</span> <span>(</span><span>cfh</span><span>.</span><span>method</span> <span>==</span> <span>ZIP_STORED</span> <span>&amp;&amp;</span>
                    <span>cfh</span><span>.</span><span>uncomp_size</span> <span>!=</span> <span>cfh</span><span>.</span><span>comp_size</span><span>) {</span>
                        <span>return</span> <span>false</span><span>;
                }</span>
                <span>if</span> <span>(</span><span>cfh</span><span>.</span><span>disk_nbr_start</span> <span>!=</span> <span>0</span><span>) {</span>
                        <span>return</span> <span>false</span><span>;</span> <span>/* Cannot handle multi-volume archives. */</span>
                <span>}</span>
                <span>if</span> <span>(</span><span>memchr</span><span>(</span><span>cfh</span><span>.</span><span>name</span><span>,</span> <span>' '</span><span>,</span> <span>cfh</span><span>.</span><span>name_len</span><span>)</span> <span>!=</span> <span>NULL</span><span>) {</span>
                        <span>return</span> <span>false</span><span>;</span> <span>/* Bad filename. */</span>
                <span>}</span>

                <span>if</span> <span>(</span><span>!</span><span>read_lfh</span><span>(</span><span>&amp;</span><span>lfh</span><span>,</span> <span>src</span><span>,</span> <span>src_len</span><span>,</span> <span>cfh</span><span>.</span><span>lfh_offset</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;
                }</span>

                <span>comp_data</span> <span>=</span> <span>lfh</span><span>.</span><span>extra</span> <span>+</span> <span>lfh</span><span>.</span><span>extra_len</span><span>;</span>
                <span>if</span> <span>(</span><span>cfh</span><span>.</span><span>comp_size</span> <span>&gt;</span> <span>src_len</span> <span>-</span> <span>(</span><span>size_t</span><span>)(</span><span>comp_data</span> <span>-</span> <span>src</span><span>)) {</span>
                        <span>return</span> <span>false</span><span>;</span> <span>/* Member data does not fit in src. */</span>
                <span>}</span>

                <span>offset</span> <span>+=</span> <span>CFH_BASE_SZ</span> <span>+</span> <span>cfh</span><span>.</span><span>name_len</span> <span>+</span> <span>cfh</span><span>.</span><span>extra_len</span> <span>+</span>
                          <span>cfh</span><span>.</span><span>comment_len</span><span>;
        }</span>

        <span>zip</span><span>-&gt;</span><span>members_end</span> <span>=</span> <span>offset</span><span>;</span>

        <span>return</span> <span>true</span><span>;
}</span>
</pre></div>


<p>As hinted at above, member iterators are really just Central File Header offsets, through which the members data can be accessed:</p>

<div><pre><span>typedef enum</span> <span>{</span> <span>ZIP_STORED</span> <span>=</span> <span>0</span><span>,</span> <span>ZIP_DEFLATED</span> <span>=</span> <span>8</span> <span>}</span> <span>method_t</span><span>;</span>

<span>typedef struct</span> <span>zipmemb_t zipmemb_t</span><span>;</span>
<span>struct</span> <span>zipmemb_t</span> <span>{</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>name</span><span>;</span>      <span>/* Member name (not null terminated). */</span>
        <span>uint16_t</span> <span>name_len</span><span>;</span>        <span>/* Member name length. */</span>
        <span>time_t</span> <span>mtime</span><span>;</span>             <span>/* Modification time. */</span>
        <span>uint32_t</span> <span>comp_size</span><span>;</span>       <span>/* Compressed size. */</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>comp_data</span><span>;</span> <span>/* Compressed data. */</span>
        <span>method_t</span> <span>method</span><span>;</span>          <span>/* Compression method. */</span>
        <span>uint32_t</span> <span>uncomp_size</span><span>;</span>     <span>/* Uncompressed size. */</span>
        <span>uint32_t</span> <span>crc32</span><span>;</span>           <span>/* CRC-32 checksum. */</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>comment</span><span>;</span>   <span>/* Comment (not null terminated). */</span>
        <span>uint16_t</span> <span>comment_len</span><span>;</span>     <span>/* Comment length. */</span>
        <span>bool</span> <span>is_dir</span><span>;</span>              <span>/* Whether this is a directory. */</span>
        <span>zipiter_t</span> <span>next</span><span>;</span>           <span>/* Iterator to the next member. */</span>
<span>};</span>

<span>/* Get the Zip archive member through iterator it. */</span>
<span>zipmemb_t</span> <span>zip_member</span><span>(</span><span>const</span> <span>zip_t</span> <span>*</span><span>zip</span><span>,</span> <span>zipiter_t</span> <span>it</span><span>)
{</span>
        <span>struct</span> <span>cfh cfh</span><span>;</span>
        <span>struct</span> <span>lfh lfh</span><span>;</span>
        <span>bool</span> <span>ok</span><span>;</span>
        <span>zipmemb_t</span> <span>m</span><span>;</span>

        <span>assert</span><span>(</span><span>it</span> <span>&gt;=</span> <span>zip</span><span>-&gt;</span><span>members_begin</span> <span>&amp;&amp;</span> <span>it</span> <span>&lt;</span> <span>zip</span><span>-&gt;</span><span>members_end</span><span>);</span>

        <span>ok</span> <span>=</span> <span>read_cfh</span><span>(</span><span>&amp;</span><span>cfh</span><span>,</span> <span>zip</span><span>-&gt;</span><span>src</span><span>,</span> <span>zip</span><span>-&gt;</span><span>src_len</span><span>,</span> <span>it</span><span>);</span>
        <span>assert</span><span>(</span><span>ok</span><span>);</span>

        <span>ok</span> <span>=</span> <span>read_lfh</span><span>(</span><span>&amp;</span><span>lfh</span><span>,</span> <span>zip</span><span>-&gt;</span><span>src</span><span>,</span> <span>zip</span><span>-&gt;</span><span>src_len</span><span>,</span> <span>cfh</span><span>.</span><span>lfh_offset</span><span>);</span>
        <span>assert</span><span>(</span><span>ok</span><span>);</span>

        <span>m</span><span>.</span><span>name</span> <span>=</span> <span>cfh</span><span>.</span><span>name</span><span>;</span>
        <span>m</span><span>.</span><span>name_len</span> <span>=</span> <span>cfh</span><span>.</span><span>name_len</span><span>;</span>
        <span>m</span><span>.</span><span>mtime</span> <span>=</span> <span>dos2ctime</span><span>(</span><span>cfh</span><span>.</span><span>mod_date</span><span>,</span> <span>cfh</span><span>.</span><span>mod_time</span><span>);</span>
        <span>m</span><span>.</span><span>comp_size</span> <span>=</span> <span>cfh</span><span>.</span><span>comp_size</span><span>;</span>
        <span>m</span><span>.</span><span>comp_data</span> <span>=</span> <span>lfh</span><span>.</span><span>extra</span> <span>+</span> <span>lfh</span><span>.</span><span>extra_len</span><span>;</span>
        <span>m</span><span>.</span><span>method</span> <span>=</span> <span>cfh</span><span>.</span><span>method</span><span>;</span>
        <span>m</span><span>.</span><span>uncomp_size</span> <span>=</span> <span>cfh</span><span>.</span><span>uncomp_size</span><span>;</span>
        <span>m</span><span>.</span><span>crc32</span> <span>=</span> <span>cfh</span><span>.</span><span>crc32</span><span>;</span>
        <span>m</span><span>.</span><span>comment</span> <span>=</span> <span>cfh</span><span>.</span><span>comment</span><span>;</span>
        <span>m</span><span>.</span><span>comment_len</span> <span>=</span> <span>cfh</span><span>.</span><span>comment_len</span><span>;</span>
        <span>m</span><span>.</span><span>is_dir</span> <span>=</span> <span>(</span><span>cfh</span><span>.</span><span>ext_attrs</span> <span>&amp;</span> <span>EXT_ATTR_DIR</span><span>)</span> <span>!=</span> <span>0</span><span>;</span>

        <span>m</span><span>.</span><span>next</span> <span>=</span> <span>it</span> <span>+</span> <span>CFH_BASE_SZ</span> <span>+</span>
                 <span>cfh</span><span>.</span><span>name_len</span> <span>+</span> <span>cfh</span><span>.</span><span>extra_len</span> <span>+</span> <span>cfh</span><span>.</span><span>comment_len</span><span>;</span>

        <span>assert</span><span>(</span><span>m</span><span>.</span><span>next</span> <span>&lt;=</span> <span>zip</span><span>-&gt;</span><span>members_end</span><span>);</span>

        <span>return</span> <span>m</span><span>;
}</span>
</pre></div>



<h3>Zip Writer Implementation</h3>

<p>To write a Zip file into a memory buffer, we first need to know how much memory to allocate. Since we do not know how much the data will compress before we try it, we calculate an upper bound by using the uncompressed member sizes:</p>

<div><pre><span>/* Compute an upper bound on the dst size required by zip_write() for an
 * archive with num_memb members with certain filenames, sizes, and archive
 * comment. Returns zero on error, e.g. if a filename is longer than 2^16-1, or
 * if the total file size is larger than 2^32-1. */</span>
<span>uint32_t</span> <span>zip_max_size</span><span>(</span><span>uint16_t</span> <span>num_memb</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>const</span> <span>*</span><span>filenames</span><span>,</span>
                      <span>const</span> <span>uint32_t</span> <span>*</span><span>file_sizes</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>comment</span><span>)
{</span>
        <span>size_t</span> <span>comment_len</span><span>,</span> <span>name_len</span><span>;</span>
        <span>uint64_t</span> <span>total</span><span>;</span>
        <span>uint16_t</span> <span>i</span><span>;</span>

        <span>comment_len</span> <span>=</span> <span>(</span><span>comment</span> <span>==</span> <span>NULL</span> <span>?</span> <span>0</span> <span>:</span> <span>strlen</span><span>(</span><span>comment</span><span>));</span>
        <span>if</span> <span>(</span><span>comment_len</span> <span>&gt;</span> <span>UINT16_MAX</span><span>) {</span>
                <span>return</span> <span>0</span><span>;
        }</span>

        <span>total</span> <span>=</span> <span>EOCDR_BASE_SZ</span> <span>+</span> <span>comment_len</span><span>;</span> <span>/* EOCDR */</span>

        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>num_memb</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>assert</span><span>(</span><span>filenames</span><span>[</span><span>i</span><span>]</span> <span>!=</span> <span>NULL</span><span>);</span>
                <span>name_len</span> <span>=</span> <span>strlen</span><span>(</span><span>filenames</span><span>[</span><span>i</span><span>]);</span>
                <span>if</span> <span>(</span><span>name_len</span> <span>&gt;</span> <span>UINT16_MAX</span><span>) {</span>
                        <span>return</span> <span>0</span><span>;
                }</span>

                <span>total</span> <span>+=</span> <span>CFH_BASE_SZ</span> <span>+</span> <span>name_len</span><span>;</span> <span>/* Central File Header */</span>
                <span>total</span> <span>+=</span> <span>LFH_BASE_SZ</span> <span>+</span> <span>name_len</span><span>;</span> <span>/* Local File Header */</span>
                <span>total</span> <span>+=</span> <span>file_sizes</span><span>[</span><span>i</span><span>];</span>          <span>/* Uncompressed data size. */</span>
        <span>}</span>

        <span>if</span> <span>(</span><span>total</span> <span>&gt;</span> <span>UINT32_MAX</span><span>) {</span>
                <span>return</span> <span>0</span><span>;
        }</span>

        <span>return</span> <span>(</span><span>uint32_t</span><span>)</span><span>total</span><span>;
}</span>
</pre></div>


<p>The code below writes a Zip file using Deflate compression for each member where that yields a smaller size:</p>

<div><pre><span>/* Write a Zip file containing num_memb members into dst, which must be large
   enough to hold the resulting data. Returns the number of bytes written, which
   is guaranteed to be less than or equal to the result of zip_max_size() when
   called with the corresponding arguments. comment shall be a null-terminated
   string or null. callback shall be null or point to a function which will
   get called after the compression of each member. */</span>
<span>uint32_t</span> <span>zip_write</span><span>(</span><span>uint8_t</span> <span>*</span><span>dst</span><span>,</span> <span>uint16_t</span> <span>num_memb</span><span>,</span>
                   <span>const</span> <span>char</span> <span>*</span><span>const</span> <span>*</span><span>filenames</span><span>,</span>
                   <span>const</span> <span>uint8_t</span> <span>*</span><span>const</span> <span>*</span><span>file_data</span><span>,</span>
                   <span>const</span> <span>uint32_t</span> <span>*</span><span>file_sizes</span><span>,</span>
                   <span>const</span> <span>time_t</span> <span>*</span><span>mtimes</span><span>,</span>
                   <span>const</span> <span>char</span> <span>*</span><span>comment</span><span>,</span>
                   <span>void</span> <span>(</span><span>*</span><span>callback</span><span>)(</span><span>const</span> <span>char</span> <span>*</span><span>filename</span><span>,</span> <span>uint32_t</span> <span>size</span><span>,</span>
                                    <span>uint32_t</span> <span>comp_size</span><span>))
{</span>
        <span>uint16_t</span> <span>i</span><span>;</span>
        <span>uint8_t</span> <span>*</span><span>p</span><span>;</span>
        <span>struct</span> <span>eocdr eocdr</span><span>;</span>
        <span>struct</span> <span>cfh cfh</span><span>;</span>
        <span>struct</span> <span>lfh lfh</span><span>;</span>
        <span>bool</span> <span>ok</span><span>;</span>
        <span>uint16_t</span> <span>name_len</span><span>;</span>
        <span>uint8_t</span> <span>*</span><span>data_dst</span><span>;</span>
        <span>size_t</span> <span>comp_sz</span><span>;</span>
        <span>uint32_t</span> <span>lfh_offset</span><span>,</span> <span>cd_offset</span><span>,</span> <span>eocdr_offset</span><span>;</span>

        <span>p</span> <span>=</span> <span>dst</span><span>;</span>

        <span>/* Write Local File Headers and deflated or stored data. */</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>num_memb</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>assert</span><span>(</span><span>filenames</span><span>[</span><span>i</span><span>]</span> <span>!=</span> <span>NULL</span><span>);</span>
                <span>assert</span><span>(</span><span>strlen</span><span>(</span><span>filenames</span><span>[</span><span>i</span><span>])</span> <span>&lt;=</span> <span>UINT16_MAX</span><span>);</span>
                <span>name_len</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)</span><span>strlen</span><span>(</span><span>filenames</span><span>[</span><span>i</span><span>]);</span>

                <span>data_dst</span> <span>=</span> <span>p</span> <span>+</span> <span>LFH_BASE_SZ</span> <span>+</span> <span>name_len</span><span>;</span>

                <span>if</span> <span>(</span><span>hwdeflate</span><span>(</span><span>file_data</span><span>[</span><span>i</span><span>],</span> <span>file_sizes</span><span>[</span><span>i</span><span>],</span> <span>data_dst</span><span>,</span>
                              <span>file_sizes</span><span>[</span><span>i</span><span>],</span> <span>&amp;</span><span>comp_sz</span><span>)</span> <span>&amp;&amp;</span>
                                <span>comp_sz</span> <span>&lt;</span> <span>file_sizes</span><span>[</span><span>i</span><span>]) {</span>
                        <span>lfh</span><span>.</span><span>method</span> <span>=</span> <span>ZIP_DEFLATED</span><span>;</span>
                        <span>assert</span><span>(</span><span>comp_sz</span> <span>&lt;=</span> <span>UINT32_MAX</span><span>);</span>
                        <span>lfh</span><span>.</span><span>comp_size</span> <span>=</span> <span>(</span><span>uint32_t</span><span>)</span><span>comp_sz</span><span>;
                }</span> <span>else</span> <span>{</span>
                        <span>memcpy</span><span>(</span><span>data_dst</span><span>,</span> <span>file_data</span><span>[</span><span>i</span><span>],</span> <span>file_sizes</span><span>[</span><span>i</span><span>]);</span>
                        <span>lfh</span><span>.</span><span>method</span> <span>=</span> <span>ZIP_STORED</span><span>;</span>
                        <span>lfh</span><span>.</span><span>comp_size</span> <span>=</span> <span>file_sizes</span><span>[</span><span>i</span><span>];
                }</span>

                <span>if</span> <span>(</span><span>callback</span> <span>!=</span> <span>NULL</span><span>) {</span>
                        <span>callback</span><span>(</span><span>filenames</span><span>[</span><span>i</span><span>],</span> <span>file_sizes</span><span>[</span><span>i</span><span>],</span> <span>lfh</span><span>.</span><span>comp_size</span><span>);
                }</span>

                <span>lfh</span><span>.</span><span>extract_ver</span> <span>=</span> <span>(</span><span>0</span> <span>&lt;&lt;</span> <span>8</span><span>)</span> <span>|</span> <span>20</span><span>;</span> <span>/* DOS | PKZIP 2.0 */</span>
                <span>lfh</span><span>.</span><span>gp_flag</span> <span>=</span> <span>(</span><span>lfh</span><span>.</span><span>method</span> <span>==</span> <span>ZIP_DEFLATED</span> <span>?</span> <span>(</span><span>0x1</span> <span>&lt;&lt;</span> <span>1</span><span>)</span> <span>:</span> <span>0x0</span><span>);</span>
                <span>ctime2dos</span><span>(</span><span>mtimes</span><span>[</span><span>i</span><span>],</span> <span>&amp;</span><span>lfh</span><span>.</span><span>mod_date</span><span>,</span> <span>&amp;</span><span>lfh</span><span>.</span><span>mod_time</span><span>);</span>
                <span>lfh</span><span>.</span><span>crc32</span> <span>=</span> <span>crc32</span><span>(</span><span>file_data</span><span>[</span><span>i</span><span>],</span> <span>file_sizes</span><span>[</span><span>i</span><span>]);</span>
                <span>lfh</span><span>.</span><span>uncomp_size</span> <span>=</span> <span>file_sizes</span><span>[</span><span>i</span><span>];</span>
                <span>lfh</span><span>.</span><span>name_len</span> <span>=</span> <span>name_len</span><span>;</span>
                <span>lfh</span><span>.</span><span>extra_len</span> <span>=</span> <span>0</span><span>;</span>
                <span>lfh</span><span>.</span><span>name</span> <span>=</span> <span>(</span><span>const</span> <span>uint8_t</span><span>*</span><span>)</span><span>filenames</span><span>[</span><span>i</span><span>];</span>
                <span>p</span> <span>+=</span> <span>write_lfh</span><span>(</span><span>p</span><span>,</span> <span>&amp;</span><span>lfh</span><span>);</span>
                <span>p</span> <span>+=</span> <span>lfh</span><span>.</span><span>comp_size</span><span>;
        }</span>

        <span>assert</span><span>(</span><span>p</span> <span>-</span> <span>dst</span> <span>&lt;=</span> <span>UINT32_MAX</span><span>);</span>
        <span>cd_offset</span> <span>=</span> <span>(</span><span>uint32_t</span><span>)(</span><span>p</span> <span>-</span> <span>dst</span><span>);</span>

        <span>/* Write the Central Directory based on the Local File Headers. */</span>
        <span>lfh_offset</span> <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>num_memb</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>ok</span> <span>=</span> <span>read_lfh</span><span>(</span><span>&amp;</span><span>lfh</span><span>,</span> <span>dst</span><span>,</span> <span>SIZE_MAX</span><span>,</span> <span>lfh_offset</span><span>);</span>
                <span>assert</span><span>(</span><span>ok</span><span>);</span>

                <span>cfh</span><span>.</span><span>made_by_ver</span> <span>=</span> <span>lfh</span><span>.</span><span>extract_ver</span><span>;</span>
                <span>cfh</span><span>.</span><span>extract_ver</span> <span>=</span> <span>lfh</span><span>.</span><span>extract_ver</span><span>;</span>
                <span>cfh</span><span>.</span><span>gp_flag</span> <span>=</span> <span>lfh</span><span>.</span><span>gp_flag</span><span>;</span>
                <span>cfh</span><span>.</span><span>method</span> <span>=</span> <span>lfh</span><span>.</span><span>method</span><span>;</span>
                <span>cfh</span><span>.</span><span>mod_time</span> <span>=</span> <span>lfh</span><span>.</span><span>mod_time</span><span>;</span>
                <span>cfh</span><span>.</span><span>mod_date</span> <span>=</span> <span>lfh</span><span>.</span><span>mod_date</span><span>;</span>
                <span>cfh</span><span>.</span><span>crc32</span> <span>=</span> <span>lfh</span><span>.</span><span>crc32</span><span>;</span>
                <span>cfh</span><span>.</span><span>comp_size</span> <span>=</span> <span>lfh</span><span>.</span><span>comp_size</span><span>;</span>
                <span>cfh</span><span>.</span><span>uncomp_size</span> <span>=</span> <span>lfh</span><span>.</span><span>uncomp_size</span><span>;</span>
                <span>cfh</span><span>.</span><span>name_len</span> <span>=</span> <span>lfh</span><span>.</span><span>name_len</span><span>;</span>
                <span>cfh</span><span>.</span><span>extra_len</span> <span>=</span> <span>0</span><span>;</span>
                <span>cfh</span><span>.</span><span>comment_len</span> <span>=</span> <span>0</span><span>;</span>
                <span>cfh</span><span>.</span><span>disk_nbr_start</span> <span>=</span> <span>0</span><span>;</span>
                <span>cfh</span><span>.</span><span>int_attrs</span> <span>=</span> <span>0</span><span>;</span>
                <span>cfh</span><span>.</span><span>ext_attrs</span> <span>=</span> <span>EXT_ATTR_ARC</span><span>;</span>
                <span>cfh</span><span>.</span><span>lfh_offset</span> <span>=</span> <span>lfh_offset</span><span>;</span>
                <span>cfh</span><span>.</span><span>name</span> <span>=</span> <span>lfh</span><span>.</span><span>name</span><span>;</span>
                <span>p</span> <span>+=</span> <span>write_cfh</span><span>(</span><span>p</span><span>,</span> <span>&amp;</span><span>cfh</span><span>);</span>

                <span>lfh_offset</span> <span>+=</span> <span>LFH_BASE_SZ</span> <span>+</span> <span>lfh</span><span>.</span><span>name_len</span> <span>+</span> <span>lfh</span><span>.</span><span>comp_size</span><span>;
        }</span>

        <span>assert</span><span>(</span><span>p</span> <span>-</span> <span>dst</span> <span>&lt;=</span> <span>UINT32_MAX</span><span>);</span>
        <span>eocdr_offset</span> <span>=</span> <span>(</span><span>uint32_t</span><span>)(</span><span>p</span> <span>-</span> <span>dst</span><span>);</span>

        <span>/* Write the End of Central Directory Record. */</span>
        <span>eocdr</span><span>.</span><span>disk_nbr</span> <span>=</span> <span>0</span><span>;</span>
        <span>eocdr</span><span>.</span><span>cd_start_disk</span> <span>=</span> <span>0</span><span>;</span>
        <span>eocdr</span><span>.</span><span>disk_cd_entries</span> <span>=</span> <span>num_memb</span><span>;</span>
        <span>eocdr</span><span>.</span><span>cd_entries</span> <span>=</span> <span>num_memb</span><span>;</span>
        <span>eocdr</span><span>.</span><span>cd_size</span> <span>=</span> <span>eocdr_offset</span> <span>-</span> <span>cd_offset</span><span>;</span>
        <span>eocdr</span><span>.</span><span>cd_offset</span> <span>=</span> <span>cd_offset</span><span>;</span>
        <span>eocdr</span><span>.</span><span>comment_len</span> <span>=</span> <span>(</span><span>uint16_t</span><span>)(</span><span>comment</span> <span>==</span> <span>NULL</span> <span>?</span> <span>0</span> <span>:</span> <span>strlen</span><span>(</span><span>comment</span><span>));</span>
        <span>eocdr</span><span>.</span><span>comment</span> <span>=</span> <span>(</span><span>const</span> <span>uint8_t</span><span>*</span><span>)</span><span>comment</span><span>;</span>
        <span>p</span> <span>+=</span> <span>write_eocdr</span><span>(</span><span>p</span><span>,</span> <span>&amp;</span><span>eocdr</span><span>);</span>

        <span>assert</span><span>(</span><span>p</span> <span>-</span> <span>dst</span> <span>&lt;=</span> <span>zip_max_size</span><span>(</span><span>num_memb</span><span>,</span> <span>filenames</span><span>,</span> <span>file_sizes</span><span>,</span>
                                       <span>comment</span><span>));</span>

        <span>return</span> <span>(</span><span>uint32_t</span><span>)(</span><span>p</span> <span>-</span> <span>dst</span><span>);
}</span>
</pre></div>


<h2>HWZip</h2>

<p>We now know how to read and write Zip files, and how to compress and decompress the data stored within. Let us write a simple Zip program to put it all together. The code is available in <a href="https://www.hanshq.net/files/hwzip/hwzip.c">hwzip.c</a>.</p>

<p>We will use a macro for simple error handling, and a few helper functions for checked memory allocation:</p>

<div><pre><span>#define PERROR_IF(cnd, msg) do { if (cnd) { perror(msg); exit(1); } } while (0)</span>

<span>static</span> <span>void</span> <span>*</span><span>xmalloc</span><span>(</span><span>size_t</span> <span>size</span><span>)
{</span>
        <span>void</span> <span>*</span><span>ptr</span> <span>=</span> <span>malloc</span><span>(</span><span>size</span><span>);</span>
        <span>PERROR_IF</span><span>(</span><span>ptr</span> <span>==</span> <span>NULL</span><span>,</span> <span>"malloc"</span><span>);</span>
        <span>return</span> <span>ptr</span><span>;
}</span>

<span>static</span> <span>void</span> <span>*</span><span>xrealloc</span><span>(</span><span>void</span> <span>*</span><span>ptr</span><span>,</span> <span>size_t</span> <span>size</span><span>)
{</span>
        <span>ptr</span> <span>=</span> <span>realloc</span><span>(</span><span>ptr</span><span>,</span> <span>size</span><span>);</span>
        <span>PERROR_IF</span><span>(</span><span>ptr</span> <span>==</span> <span>NULL</span><span>,</span> <span>"realloc"</span><span>);</span>
        <span>return</span> <span>ptr</span><span>;
}</span>
</pre></div>


<p>Another two functions are used for reading and writing files:</p>

<div><pre><span>static</span> <span>uint8_t</span> <span>*</span><span>read_file</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>filename</span><span>,</span> <span>size_t</span> <span>*</span><span>file_sz</span><span>)
{</span>
        <span>FILE</span> <span>*</span><span>f</span><span>;</span>
        <span>uint8_t</span> <span>*</span><span>buf</span><span>;</span>
        <span>size_t</span> <span>buf_cap</span><span>;</span>

        <span>f</span> <span>=</span> <span>fopen</span><span>(</span><span>filename</span><span>,</span> <span>"rb"</span><span>);</span>
        <span>PERROR_IF</span><span>(</span><span>f</span> <span>==</span> <span>NULL</span><span>,</span> <span>"fopen"</span><span>);</span>

        <span>buf_cap</span> <span>=</span> <span>4096</span><span>;</span>
        <span>buf</span> <span>=</span> <span>xmalloc</span><span>(</span><span>buf_cap</span><span>);</span>

        <span>*</span><span>file_sz</span> <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span><span>feof</span><span>(</span><span>f</span><span>)</span> <span>==</span> <span>0</span><span>) {</span>
                <span>if</span> <span>(</span><span>buf_cap</span> <span>- *</span><span>file_sz</span> <span>==</span> <span>0</span><span>) {</span>
                        <span>buf_cap</span> <span>*=</span> <span>2</span><span>;</span>
                        <span>buf</span> <span>=</span> <span>xrealloc</span><span>(</span><span>buf</span><span>,</span> <span>buf_cap</span><span>);
                }</span>

                <span>*</span><span>file_sz</span> <span>+=</span> <span>fread</span><span>(</span><span>&amp;</span><span>buf</span><span>[</span><span>*</span><span>file_sz</span><span>],</span> <span>1</span><span>,</span> <span>buf_cap</span> <span>- *</span><span>file_sz</span><span>,</span> <span>f</span><span>);</span>
                <span>PERROR_IF</span><span>(</span><span>ferror</span><span>(</span><span>f</span><span>),</span> <span>"fread"</span><span>);
        }</span>

        <span>PERROR_IF</span><span>(</span><span>fclose</span><span>(</span><span>f</span><span>)</span> <span>!=</span> <span>0</span><span>,</span> <span>"fclose"</span><span>);</span>
        <span>return</span> <span>buf</span><span>;
}</span>

<span>static</span> <span>void</span> <span>write_file</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>filename</span><span>,</span> <span>const</span> <span>uint8_t</span> <span>*</span><span>data</span><span>,</span> <span>size_t</span> <span>n</span><span>)
{</span>
        <span>FILE</span> <span>*</span><span>f</span><span>;</span>

        <span>f</span> <span>=</span> <span>fopen</span><span>(</span><span>filename</span><span>,</span> <span>"wb"</span><span>);</span>
        <span>PERROR_IF</span><span>(</span><span>f</span> <span>==</span> <span>NULL</span><span>,</span> <span>"fopen"</span><span>);</span>
        <span>PERROR_IF</span><span>(</span><span>fwrite</span><span>(</span><span>data</span><span>,</span> <span>1</span><span>,</span> <span>n</span><span>,</span> <span>f</span><span>)</span> <span>!=</span> <span>n</span><span>,</span> <span>"fwrite"</span><span>);</span>
        <span>PERROR_IF</span><span>(</span><span>fclose</span><span>(</span><span>f</span><span>)</span> <span>!=</span> <span>0</span><span>,</span> <span>"fclose"</span><span>);
}</span>
</pre></div>


<p>Our ZIP program can be used to perform three functions: to list the contents of, extract, or create a ZIP file. Listing is easiest:</p>

<div><pre><span>static</span> <span>void</span> <span>list_zip</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>filename</span><span>)
{</span>
        <span>uint8_t</span> <span>*</span><span>zip_data</span><span>;</span>
        <span>size_t</span> <span>zip_sz</span><span>;</span>
        <span>zip_t</span> <span>z</span><span>;</span>
        <span>zipiter_t</span> <span>it</span><span>;</span>
        <span>zipmemb_t</span> <span>m</span><span>;</span>

        <span>printf</span><span>(</span><span>"Listing ZIP archive: %s</span><span>

</span><span>"</span><span>,</span> <span>filename</span><span>);</span>

        <span>zip_data</span> <span>=</span> <span>read_file</span><span>(</span><span>filename</span><span>,</span> <span>&amp;</span><span>zip_sz</span><span>);</span>

        <span>if</span> <span>(</span><span>!</span><span>zip_read</span><span>(</span><span>&amp;</span><span>z</span><span>,</span> <span>zip_data</span><span>,</span> <span>zip_sz</span><span>)) {</span>
                <span>printf</span><span>(</span><span>"Failed to parse ZIP file!</span><span>
</span><span>"</span><span>);</span>
                <span>exit</span><span>(</span><span>1</span><span>);
        }</span>

        <span>if</span> <span>(</span><span>z</span><span>.</span><span>comment_len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>printf</span><span>(</span><span>"%.*s</span><span>

</span><span>"</span><span>, (</span><span>int</span><span>)</span><span>z</span><span>.</span><span>comment_len</span><span>,</span> <span>z</span><span>.</span><span>comment</span><span>);
        }</span>

        <span>for</span> <span>(</span><span>it</span> <span>=</span> <span>z</span><span>.</span><span>members_begin</span><span>;</span> <span>it</span> <span>!=</span> <span>z</span><span>.</span><span>members_end</span><span>;</span> <span>it</span> <span>=</span> <span>m</span><span>.</span><span>next</span><span>) {</span>
                <span>m</span> <span>=</span> <span>zip_member</span><span>(</span><span>&amp;</span><span>z</span><span>,</span> <span>it</span><span>);</span>
                <span>printf</span><span>(</span><span>"%.*s</span><span>
</span><span>"</span><span>, (</span><span>int</span><span>)</span><span>m</span><span>.</span><span>name_len</span><span>,</span> <span>m</span><span>.</span><span>name</span><span>);
        }</span>

        <span>printf</span><span>(</span><span>"</span><span>
</span><span>"</span><span>);</span>

        <span>free</span><span>(</span><span>zip_data</span><span>);
}</span>
</pre></div>


<p>Extraction is slightly more involved. We will use helper functions to null-terminate the filename (so it can be passed to <span>fopen</span>), and to perform inflation:</p>

<div><pre><span>static</span> <span>char</span> <span>*</span><span>terminate_str</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>str</span><span>,</span> <span>size_t</span> <span>n</span><span>)
{</span>
        <span>char</span> <span>*</span><span>p</span> <span>=</span> <span>xmalloc</span><span>(</span><span>n</span> <span>+</span> <span>1</span><span>);</span>
        <span>memcpy</span><span>(</span><span>p</span><span>,</span> <span>str</span><span>,</span> <span>n</span><span>);</span>
        <span>p</span><span>[</span><span>n</span><span>]</span> <span>=</span> <span>' '</span><span>;</span>
        <span>return</span> <span>p</span><span>;
}</span>

<span>static</span> <span>uint8_t</span> <span>*</span><span>inflate_member</span><span>(</span><span>const</span> <span>zipmemb_t</span> <span>*</span><span>m</span><span>)
{</span>
        <span>uint8_t</span> <span>*</span><span>p</span><span>;</span>
        <span>size_t</span> <span>src_used</span><span>,</span> <span>dst_used</span><span>;</span>

        <span>assert</span><span>(</span><span>m</span><span>-&gt;</span><span>method</span> <span>==</span> <span>ZIP_DEFLATED</span><span>);</span>

        <span>p</span> <span>=</span> <span>xmalloc</span><span>(</span><span>m</span><span>-&gt;</span><span>uncomp_size</span><span>);</span>

        <span>if</span> <span>(</span><span>hwinflate</span><span>(</span><span>m</span><span>-&gt;</span><span>comp_data</span><span>,</span> <span>m</span><span>-&gt;</span><span>comp_size</span><span>,</span> <span>&amp;</span><span>src_used</span><span>,</span> <span>p</span><span>,</span> <span>m</span><span>-&gt;</span><span>uncomp_size</span><span>,</span>
                      <span>&amp;</span><span>dst_used</span><span>)</span> <span>!=</span> <span>HWINF_OK</span><span>) {</span>
                <span>free</span><span>(</span><span>p</span><span>);</span>
                <span>return</span> <span>NULL</span><span>;
        }</span>

        <span>if</span> <span>(</span><span>src_used</span> <span>!=</span> <span>m</span><span>-&gt;</span><span>comp_size</span> <span>||</span> <span>dst_used</span> <span>!=</span> <span>m</span><span>-&gt;</span><span>uncomp_size</span><span>) {</span>
                <span>free</span><span>(</span><span>p</span><span>);</span>
                <span>return</span> <span>NULL</span><span>;
        }</span>

        <span>return</span> <span>p</span><span>;
}</span>
</pre></div>


<p>Our program will skip any archive member that is in a directory. The reason for this is to avoid so called <a href="https://www.owasp.org/index.php/Path_Traversal">path traversal attacks</a>, where a malicious archive is used to write a file outside the directory specified by the user. See <a href="http://infozip.sourceforge.net/FAQ.html#corruption">Info-ZIP's FAQ</a> for some discussion.</p>

<div><pre><span>static</span> <span>void</span> <span>extract_zip</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>filename</span><span>)
{</span>
        <span>uint8_t</span> <span>*</span><span>zip_data</span><span>;</span>
        <span>size_t</span> <span>zip_sz</span><span>;</span>
        <span>zip_t</span> <span>z</span><span>;</span>
        <span>zipiter_t</span> <span>it</span><span>;</span>
        <span>zipmemb_t</span> <span>m</span><span>;</span>
        <span>char</span> <span>*</span><span>tname</span><span>;</span>
        <span>uint8_t</span> <span>*</span><span>inflated</span><span>;</span>
        <span>const</span> <span>uint8_t</span> <span>*</span><span>uncomp_data</span><span>;</span>

        <span>printf</span><span>(</span><span>"Extracting ZIP archive: %s</span><span>

</span><span>"</span><span>,</span> <span>filename</span><span>);</span>

        <span>zip_data</span> <span>=</span> <span>read_file</span><span>(</span><span>filename</span><span>,</span> <span>&amp;</span><span>zip_sz</span><span>);</span>

        <span>if</span> <span>(</span><span>!</span><span>zip_read</span><span>(</span><span>&amp;</span><span>z</span><span>,</span> <span>zip_data</span><span>,</span> <span>zip_sz</span><span>)) {</span>
                <span>printf</span><span>(</span><span>"Failed to read ZIP file!</span><span>
</span><span>"</span><span>);</span>
                <span>exit</span><span>(</span><span>1</span><span>);
        }</span>

        <span>if</span> <span>(</span><span>z</span><span>.</span><span>comment_len</span> <span>!=</span> <span>0</span><span>) {</span>
                <span>printf</span><span>(</span><span>"%.*s</span><span>

</span><span>"</span><span>, (</span><span>int</span><span>)</span><span>z</span><span>.</span><span>comment_len</span><span>,</span> <span>z</span><span>.</span><span>comment</span><span>);
        }</span>

        <span>for</span> <span>(</span><span>it</span> <span>=</span> <span>z</span><span>.</span><span>members_begin</span><span>;</span> <span>it</span> <span>!=</span> <span>z</span><span>.</span><span>members_end</span><span>;</span> <span>it</span> <span>=</span> <span>m</span><span>.</span><span>next</span><span>) {</span>
                <span>m</span> <span>=</span> <span>zip_member</span><span>(</span><span>&amp;</span><span>z</span><span>,</span> <span>it</span><span>);</span>

                <span>if</span> <span>(</span><span>m</span><span>.</span><span>is_dir</span><span>) {</span>
                        <span>printf</span><span>(</span><span>" (Skipping dir: %.*s)</span><span>
</span><span>"</span><span>,
                               (</span><span>int</span><span>)</span><span>m</span><span>.</span><span>name_len</span><span>,</span> <span>m</span><span>.</span><span>name</span><span>);</span>
                        <span>continue</span><span>;
                }</span>

                <span>if</span> <span>(</span><span>memchr</span><span>(</span><span>m</span><span>.</span><span>name</span><span>,</span> <span>'/'</span><span>,</span>  <span>m</span><span>.</span><span>name_len</span><span>)</span> <span>!=</span> <span>NULL</span> <span>||</span>
                    <span>memchr</span><span>(</span><span>m</span><span>.</span><span>name</span><span>,</span> <span>''</span><span>,</span> <span>m</span><span>.</span><span>name_len</span><span>)</span> <span>!=</span> <span>NULL</span><span>) {</span>
                        <span>printf</span><span>(</span><span>" (Skipping file in dir: %.*s)</span><span>
</span><span>"</span><span>,
                               (</span><span>int</span><span>)</span><span>m</span><span>.</span><span>name_len</span><span>,</span> <span>m</span><span>.</span><span>name</span><span>);</span>
                        <span>continue</span><span>;
                }</span>

                <span>assert</span><span>(</span><span>m</span><span>.</span><span>method</span> <span>==</span> <span>ZIP_STORED</span> <span>||</span> <span>m</span><span>.</span><span>method</span> <span>==</span> <span>ZIP_DEFLATED</span><span>);</span>
                <span>printf</span><span>(</span><span>" %s: %.*s"</span><span>,</span>
                       <span>m</span><span>.</span><span>method</span> <span>==</span> <span>ZIP_STORED</span> <span>?</span> <span>"Extracting"</span> <span>:</span> <span>" Inflating"</span><span>,
                       (</span><span>int</span><span>)</span><span>m</span><span>.</span><span>name_len</span><span>,</span> <span>m</span><span>.</span><span>name</span><span>);</span>
                <span>fflush</span><span>(</span><span>stdout</span><span>);</span>

                <span>if</span> <span>(</span><span>m</span><span>.</span><span>method</span> <span>==</span> <span>ZIP_STORED</span><span>) {</span>
                        <span>assert</span><span>(</span><span>m</span><span>.</span><span>uncomp_size</span> <span>==</span> <span>m</span><span>.</span><span>comp_size</span><span>);</span>
                        <span>inflated</span> <span>=</span> <span>NULL</span><span>;</span>
                        <span>uncomp_data</span> <span>=</span> <span>m</span><span>.</span><span>comp_data</span><span>;
                }</span> <span>else</span> <span>{</span>
                        <span>inflated</span> <span>=</span> <span>inflate_member</span><span>(</span><span>&amp;</span><span>m</span><span>);</span>
                        <span>if</span> <span>(</span><span>inflated</span> <span>==</span> <span>NULL</span><span>) {</span>
                                <span>printf</span><span>(</span><span>"Error: inflation failed!</span><span>
</span><span>"</span><span>);</span>
                                <span>exit</span><span>(</span><span>1</span><span>);
                        }</span>
                        <span>uncomp_data</span> <span>=</span> <span>inflated</span><span>;
                }</span>

                <span>if</span> <span>(</span><span>crc32</span><span>(</span><span>uncomp_data</span><span>,</span> <span>m</span><span>.</span><span>uncomp_size</span><span>)</span> <span>!=</span> <span>m</span><span>.</span><span>crc32</span><span>) {</span>
                        <span>printf</span><span>(</span><span>"Error: CRC-32 mismatch!</span><span>
</span><span>"</span><span>);</span>
                        <span>exit</span><span>(</span><span>1</span><span>);
                }</span>

                <span>tname</span> <span>=</span> <span>terminate_str</span><span>((</span><span>const</span> <span>char</span><span>*</span><span>)</span><span>m</span><span>.</span><span>name</span><span>,</span> <span>m</span><span>.</span><span>name_len</span><span>);</span>
                <span>write_file</span><span>(</span><span>tname</span><span>,</span> <span>uncomp_data</span><span>,</span> <span>m</span><span>.</span><span>uncomp_size</span><span>);</span>
                <span>printf</span><span>(</span><span>"</span><span>
</span><span>"</span><span>);</span>

                <span>free</span><span>(</span><span>inflated</span><span>);</span>
                <span>free</span><span>(</span><span>tname</span><span>);
        }</span>

        <span>printf</span><span>(</span><span>"</span><span>
</span><span>"</span><span>);</span>
        <span>free</span><span>(</span><span>zip_data</span><span>);
}</span>
</pre></div>


<p>To create a Zip archive, we read the input files and feed them to <span>zip_write</span>. Since the C standard library does not provide a way to get the modification time of a file, we use the current time instead (fixing this is left as an exercise to the reader).</p>

<div><pre><span>void</span> <span>zip_callback</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>filename</span><span>,</span> <span>uint32_t</span> <span>size</span><span>,</span> <span>uint32_t</span> <span>comp_size</span><span>)
{</span>
        <span>bool</span> <span>deflated</span> <span>=</span> <span>comp_size</span> <span>&lt;</span> <span>size</span><span>;</span>

        <span>printf</span><span>(</span><span>" %s: %s"</span><span>,</span> <span>deflated</span> <span>?</span> <span>"Deflated"</span> <span>:</span> <span>"  Stored"</span><span>,</span> <span>filename</span><span>);</span>
        <span>if</span> <span>(</span><span>deflated</span><span>) {</span>
                <span>printf</span><span>(</span><span>" (%u%%)"</span><span>,</span> <span>100</span> <span>-</span> <span>100</span> <span>*</span> <span>comp_size</span> <span>/</span> <span>size</span><span>);
        }</span>
        <span>printf</span><span>(</span><span>"</span><span>
</span><span>"</span><span>);
}</span>

<span>static</span> <span>void</span> <span>create_zip</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>zip_filename</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>comment</span><span>,</span>
                       <span>uint16_t</span> <span>n</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>const</span> <span>*</span><span>filenames</span><span>)
{</span>
        <span>time_t</span> <span>mtime</span><span>;</span>
        <span>time_t</span> <span>*</span><span>mtimes</span><span>;</span>
        <span>uint8_t</span> <span>**</span><span>file_data</span><span>;</span>
        <span>uint32_t</span> <span>*</span><span>file_sizes</span><span>;</span>
        <span>size_t</span> <span>file_size</span><span>,</span> <span>zip_size</span><span>;</span>
        <span>uint8_t</span> <span>*</span><span>zip_data</span><span>;</span>
        <span>uint16_t</span> <span>i</span><span>;</span>

        <span>printf</span><span>(</span><span>"Creating ZIP archive: %s</span><span>

</span><span>"</span><span>,</span> <span>zip_filename</span><span>);</span>

        <span>if</span> <span>(</span><span>comment</span> <span>!=</span> <span>NULL</span><span>) {</span>
                <span>printf</span><span>(</span><span>"%s</span><span>

</span><span>"</span><span>,</span> <span>comment</span><span>);
        }</span>

        <span>mtime</span> <span>=</span> <span>time</span><span>(</span><span>NULL</span><span>);</span>

        <span>file_data</span> <span>=</span> <span>xmalloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span><span>file_data</span><span>)</span> <span>*</span> <span>n</span><span>);</span>
        <span>file_sizes</span> <span>=</span> <span>xmalloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span><span>file_sizes</span><span>)</span> <span>*</span> <span>n</span><span>);</span>
        <span>mtimes</span> <span>=</span> <span>xmalloc</span><span>(</span><span>sizeof</span><span>(</span><span>*</span><span>mtimes</span><span>)</span> <span>*</span> <span>n</span><span>);</span>

        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>file_data</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>read_file</span><span>(</span><span>filenames</span><span>[</span><span>i</span><span>],</span> <span>&amp;</span><span>file_size</span><span>);</span>
                <span>if</span> <span>(</span><span>file_size</span> <span>&gt;=</span> <span>UINT32_MAX</span><span>) {</span>
                        <span>printf</span><span>(</span><span>"%s is too large!</span><span>
</span><span>"</span><span>,</span> <span>filenames</span><span>[</span><span>i</span><span>]);</span>
                        <span>exit</span><span>(</span><span>1</span><span>);
                }</span>
                <span>file_sizes</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>(</span><span>uint32_t</span><span>)</span><span>file_size</span><span>;</span>
                <span>mtimes</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>mtime</span><span>;
        }</span>

        <span>zip_size</span> <span>=</span> <span>zip_max_size</span><span>(</span><span>n</span><span>,</span> <span>filenames</span><span>,</span> <span>file_sizes</span><span>,</span> <span>comment</span><span>);</span>
        <span>if</span> <span>(</span><span>zip_size</span> <span>==</span> <span>0</span><span>) {</span>
                <span>printf</span><span>(</span><span>"zip writing not possible"</span><span>);</span>
                <span>exit</span><span>(</span><span>1</span><span>);
        }</span>

        <span>zip_data</span> <span>=</span> <span>xmalloc</span><span>(</span><span>zip_size</span><span>);</span>
        <span>zip_size</span> <span>=</span> <span>zip_write</span><span>(</span><span>zip_data</span><span>,</span> <span>n</span><span>,</span> <span>filenames</span><span>,
                             (</span><span>const</span> <span>uint8_t</span> <span>*</span><span>const</span> <span>*</span><span>)</span><span>file_data</span><span>,</span>
                             <span>file_sizes</span><span>,</span> <span>mtimes</span><span>,</span> <span>comment</span><span>,</span> <span>zip_callback</span><span>);</span>

        <span>write_file</span><span>(</span><span>zip_filename</span><span>,</span> <span>zip_data</span><span>,</span> <span>zip_size</span><span>);</span>
        <span>printf</span><span>(</span><span>"</span><span>
</span><span>"</span><span>);</span>

        <span>free</span><span>(</span><span>zip_data</span><span>);</span>
        <span>for</span> <span>(</span><span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>) {</span>
                <span>free</span><span>(</span><span>file_data</span><span>[</span><span>i</span><span>]);
        }</span>
        <span>free</span><span>(</span><span>mtimes</span><span>);</span>
        <span>free</span><span>(</span><span>file_sizes</span><span>);</span>
        <span>free</span><span>(</span><span>file_data</span><span>);
}</span>
</pre></div>


<p>Finally, <span>main</span> inspects the command-line arguments and decides what to do:</p>

<div><pre><span>static</span> <span>void</span> <span>print_usage</span><span>(</span><span>const</span> <span>char</span> <span>*</span><span>argv0</span><span>)
{</span>
        <span>printf</span><span>(</span><span>"Usage:</span><span>

</span><span>"</span><span>);</span>
        <span>printf</span><span>(</span><span>"  %s list &lt;zipfile&gt;</span><span>
</span><span>"</span><span>,</span> <span>argv0</span><span>);</span>
        <span>printf</span><span>(</span><span>"  %s extract &lt;zipfile&gt;</span><span>
</span><span>"</span><span>,</span> <span>argv0</span><span>);</span>
        <span>printf</span><span>(</span><span>"  %s create &lt;zipfile&gt; [-c &lt;comment&gt;] &lt;files...&gt;</span><span>
</span><span>"</span><span>,</span> <span>argv0</span><span>);</span>
        <span>printf</span><span>(</span><span>"</span><span>
</span><span>"</span><span>);
}</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>) {</span>
        <span>printf</span><span>(</span><span>"</span><span>
</span><span>"</span><span>);</span>
        <span>printf</span><span>(</span><span>"HWZIP "</span> <span>VERSION</span> <span>" -- A very simple ZIP program "</span><span>);</span>
        <span>printf</span><span>(</span><span>"from https://www.hanshq.net/zip.html</span><span>
</span><span>"</span><span>);</span>
        <span>printf</span><span>(</span><span>"</span><span>
</span><span>"</span><span>);</span>

        <span>if</span> <span>(</span><span>argc</span> <span>==</span> <span>3</span> <span>&amp;&amp;</span> <span>strcmp</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>],</span> <span>"list"</span><span>)</span> <span>==</span> <span>0</span><span>) {</span>
                <span>list_zip</span><span>(</span><span>argv</span><span>[</span><span>2</span><span>]);
        }</span> <span>else if</span> <span>(</span><span>argc</span> <span>==</span> <span>3</span> <span>&amp;&amp;</span> <span>strcmp</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>],</span> <span>"extract"</span><span>)</span> <span>==</span> <span>0</span><span>) {</span>
                <span>extract_zip</span><span>(</span><span>argv</span><span>[</span><span>2</span><span>]);
        }</span> <span>else if</span> <span>(</span><span>argc</span> <span>&gt;=</span> <span>3</span> <span>&amp;&amp;</span> <span>strcmp</span><span>(</span><span>argv</span><span>[</span><span>1</span><span>],</span> <span>"create"</span><span>)</span> <span>==</span> <span>0</span><span>) {</span>
                <span>if</span> <span>(</span><span>argc</span> <span>&gt;=</span> <span>5</span> <span>&amp;&amp;</span> <span>strcmp</span><span>(</span><span>argv</span><span>[</span><span>3</span><span>],</span> <span>"-c"</span><span>)</span> <span>==</span> <span>0</span><span>) {</span>
                        <span>create_zip</span><span>(</span><span>argv</span><span>[</span><span>2</span><span>],</span> <span>argv</span><span>[</span><span>4</span><span>], (</span><span>uint16_t</span><span>)(</span><span>argc</span> <span>-</span> <span>5</span><span>),
                                   (</span><span>const</span> <span>char</span> <span>*</span><span>const</span> <span>*</span><span>)</span><span>&amp;</span><span>argv</span><span>[</span><span>5</span><span>]);
                }</span> <span>else</span> <span>{</span>
                        <span>create_zip</span><span>(</span><span>argv</span><span>[</span><span>2</span><span>],</span> <span>NULL</span><span>, (</span><span>uint16_t</span><span>)(</span><span>argc</span> <span>-</span> <span>3</span><span>),
                                   (</span><span>const</span> <span>char</span> <span>*</span><span>const</span> <span>*</span><span>)</span><span>&amp;</span><span>argv</span><span>[</span><span>3</span><span>]);
                }
        }</span> <span>else</span> <span>{</span>
                <span>print_usage</span><span>(</span><span>argv</span><span>[</span><span>0</span><span>]);</span>
                <span>return</span> <span>1</span><span>;
        }</span>

        <span>return</span> <span>0</span><span>;
}</span>
</pre></div>


<h3>Build Instructions</h3>

<p>The full set of source files is available in <a href="https://www.hanshq.net/files/hwzip/hwzip-1.1.zip">hwzip-1.1.zip</a>. To compile HWZip on Linux or Mac:</p>

<!--If the build instructions change, also update the README file.-->

<div><pre>$ clang generate_tables.c &amp;&amp; ./a.out &gt; tables.c
$ clang -O3 -DNDEBUG -march=native -o hwzip crc32.c deflate.c huffman.c 
        hwzip.c lz77.c tables.c zip.c
</pre></div>


<p>Or on Windows, in a Visual Studio Developer Command Prompt (if you do not have Visual Studio, download the <a href="https://aka.ms/buildtools">Build Tools</a>):</p>

<div><pre>cl /TC generate_tables.c &amp;&amp; generate_tables &gt; tables.c
cl /O2 /DNDEBUG /MT /Fehwzip.exe /TC crc32.c deflate.c huffman.c hwzip.c
        lz77.c tables.c zip.c /link setargv.obj
</pre></div>


<p>(setargv.obj is for <a href="https://docs.microsoft.com/en-us/cpp/c-language/expanding-wildcard-arguments">expanding wildcard command-line arguments</a>.)</p>

<h2>Conclusion</h2>

<p>It is fascinating how the evolution of technology is both fast and slow. The Zip format was created 30 years ago based on technology from the fifties and seventies, and while much has changed since then, Zip files are essentially the same and more prevalent than ever. I think it is useful to have a good understanding of how they work.</p>

<h2>Exercises</h2>

<ul>
<li>Make HWZip write each file's modification time rather than the current time when creating archives. Use <a href="https://linux.die.net/man/2/stat">stat(2)</a> on Linux or Mac, and <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfiletime">GetFileTime</a> on Windows. Alternatively, add a command-line flag that allows the user to set a pre-determined modification time for the files.</li>

<li>Using the deflation and inflation code from this article, write a program to create and extract gzip files. The format is a simple wrapper around Deflate-compressed data (normally just one file). It is described in <a href="https://tools.ietf.org/html/rfc1952">RFC 1952</a>.

</li><li>The Zip reader and writer implementations are designed to work with <a href="https://en.wikipedia.org/wiki/Memory-mapped_file">memory-mapped files</a>. Change HWZip to not use <span>read_file</span>, but <a href="https://linux.die.net/man/2/mmap">mmap(2)</a> on Linux or Mac, and <a href="https://docs.microsoft.com/en-us/windows/win32/memory/creating-a-file-mapping-object">CreateFileMapping</a> on Windows.</li>

<li>Change HWZip to support extracting and creating archives using the Zip64 format. See <a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.6.TXT">the most recent appnote.txt</a> for details.</li>
</ul>


<h2>Further Reading</h2>

<ul>
<li>For more information about BBS culture, see Jason Scott's <a href="http://www.bbsdocumentary.com/">BBS: The Documentary</a>. The videos can be found <a href="https://www.youtube.com/playlist?list=PLgE-9Sxs2IBVgJkY-1ZMj0tIFxsJ-vOkv">on YouTube</a>. <a href="https://www.youtube.com/watch?v=MLNXmrF3a9c">Part 8: Compression</a> covers the SEA vs. PKWare "Arc wars". The web site has an <a href="http://www.bbsdocumentary.com/library/CONTROVERSY/LAWSUITS/SEA/">archive of related historical material</a>.</li>

<li>David Fifield's <a href="https://www.bamsoftware.com/hacks/zipbomb/">A better Zip bomb</a> is a great article explaining how to create a Zip file that "explodes" into a very large amount of data when extracted.</li>

<li>Russ Cox's <a href="https://research.swtch.com/zip">Zip Files All The Way Down</a> shows how to create a <em>Zip quine</em>, a Zip file which contains a copy of itself.</li>

<li>Gábor Molnár's <a href="https://github.com/molnarg/ascii-zip">ascii-zip</a> is a program that emits a Deflate stream which is entirely ASCII. It was used in Michele Spagnuolo's <a href="https://blog.miki.it/2014/7/8/abusing-jsonp-with-rosetta-flash/">Rosetta Flash</a> exploit.</li>

<li>Gynvael Coldwind's <a href="https://gynvael.coldwind.pl/?id=682">Ten Thousand Security Pitfalls: the Zip File Format</a> is a detailed presentation about the format from a security perspective.</li>

<li>Fabian Giesen's <a href="https://fgiesen.wordpress.com/2018/02/19/reading-bits-in-far-too-many-ways-part-1/">Reading bits in far too many ways part 1</a>, <a href="https://fgiesen.wordpress.com/2018/02/20/reading-bits-in-far-too-many-ways-part-2/">part 2</a> and <a href="https://fgiesen.wordpress.com/2018/09/27/reading-bits-in-far-too-many-ways-part-3/">part 3</a> are a great source of information on implementing bitstreams.</li>

<li>Colton McAnlis and Aleks Haecky's <a href="http://shop.oreilly.com/product/0636920052036.do">Understanding Compression</a> gives a broad introduction to the subject of data compression.</li>
</ul>

<p><img src="https://www.hanshq.net/gfx/hwzip_easter_egg.jpg" alt="PKWARE 'Get Zipped' button from Comdex Computer Trade Show.">
</p>

                        </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>