<!DOCTYPE html>
<html lang="en">
<head>
    <title>
A visual guide to React Mental models, part 2: useState, useEffect and lifecycles - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="A visual guide to React Mental models, part 2: useState, useEffect and lifecycles - linksfor.dev(s)"/>
    <meta property="og:description" content="I love mental models. They&#x2019;re crucial to understanding complex systems, allowing&#xA;us to intuitively grasp and solve complex problems. This is&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - A visual guide to React Mental models, part 2: useState, useEffect and lifecycles</title>
<div class="readable">
        <h1>A visual guide to React Mental models, part 2: useState, useEffect and lifecycles</h1>
            <div>Reading time: 19-24 minutes</div>
        <div>Posted here: 30 May 2020</div>
        <p><a href="https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/">https://obedparla.com/code/a-visual-guide-to-react-mental-models-part-2-use-state-use-effect-and-lifecycles/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>I love mental models. They’re crucial to understanding complex systems, allowing
us to intuitively grasp and solve complex problems.</p>
<p>This is the second of a three-part series of articles around React mental
models. I’ll <strong>show</strong> you the exact mental models I use with complex React
components by building them from the ground up and by using lots of visual
explanations.</p>
<p>I recommend you read <a href="https://obedparla.com/code/a-visual-guide-to-react-mental-models/">part 1</a>
first, as the mental models in this article are relying of the ones I explained
there. If you want a refresher,
<a href="https://obedparla.com/code/a-visual-guide-to-react-mental-models/#a-complete-react-mental-model-putting-it-all-together">here’s the complete mental model for part 1</a></p>
<blockquote>
<p>Whether you’ve been working with React for years or are just starting, having
a useful mental model is, in my opinion, the fastest way to feel confident
working with it.</p>
</blockquote>
<p>You’ll learn:</p>
<ul>
<li><strong>The useState hook</strong>: how it <em>magically</em> works and how to intuitively
understand it.</li>
<li><strong>The component’s lifecycle: Mounting, Rendering, Unmounting</strong>: the source of
many bugs is a lack of a good mental model around these.</li>
<li><strong>The useEffect hook</strong>: how this powerful Hook actually works?</li>
</ul>
<p>Let’s start!</p>
<h2 id="what-are-mental-models-and-why-are-they-important"><a href="#what-are-mental-models-and-why-are-they-important" aria-label="what are mental models and why are they important permalink"></a>What are mental models and why are they important?</h2>
<p>A mental model is a thought process or mental image that helps us understand
complex systems and to solve hard problems intuitively by guiding us in the
right direction. You use mental models everyday; think of how you imagine the
internet, cars, or the immune system to work. You have a mental model for every
complex system you interact with.</p>
<h2 id="the-mental-model-for-react-so-far"><a href="#the-mental-model-for-react-so-far" aria-label="the mental model for react so far permalink"></a>The mental model for React so far</h2>
<p>Here’s a very quick overview of the React mental model I explained in part 1, or
you can find
<a href="https://obedparla.com/code/a-visual-guide-to-react-mental-models/#a-complete-react-mental-model-putting-it-all-together">the complete version for part 1 here</a>.</p>
<p>A React component is just like a function, it receives <code>props</code> which are a
function’s arguments, and it will re-execute whenever those props change. I
imagine a component as a box that lives within another box.</p>
<p>Each box can have many children but only one parent, and apart from receiving
props from its parent, it has an internal, special variable called <code>state</code>,
which also makes it re-execute (re-render) when it changes.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/1c6caf6685f0bd3381d84a8166579de1/ea2ac/react-rendering-mental-model-from-part1-cleaner.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/1c6caf6685f0bd3381d84a8166579de1/1426f/react-rendering-mental-model-from-part1-cleaner.webp 173w,
/static/1c6caf6685f0bd3381d84a8166579de1/923cb/react-rendering-mental-model-from-part1-cleaner.webp 345w,
/static/1c6caf6685f0bd3381d84a8166579de1/ffce4/react-rendering-mental-model-from-part1-cleaner.webp 690w,
/static/1c6caf6685f0bd3381d84a8166579de1/83d9f/react-rendering-mental-model-from-part1-cleaner.webp 1035w,
/static/1c6caf6685f0bd3381d84a8166579de1/66e35/react-rendering-mental-model-from-part1-cleaner.webp 1231w" sizes="(max-width: 690px) 100vw, 690px" type="image/webp">
        <source srcset="/static/1c6caf6685f0bd3381d84a8166579de1/d9d39/react-rendering-mental-model-from-part1-cleaner.jpg 173w,
/static/1c6caf6685f0bd3381d84a8166579de1/52bea/react-rendering-mental-model-from-part1-cleaner.jpg 345w,
/static/1c6caf6685f0bd3381d84a8166579de1/7efee/react-rendering-mental-model-from-part1-cleaner.jpg 690w,
/static/1c6caf6685f0bd3381d84a8166579de1/078c0/react-rendering-mental-model-from-part1-cleaner.jpg 1035w,
/static/1c6caf6685f0bd3381d84a8166579de1/ea2ac/react-rendering-mental-model-from-part1-cleaner.jpg 1231w" sizes="(max-width: 690px) 100vw, 690px" type="image/jpeg">
        <img src="https://obedparla.com/static/1c6caf6685f0bd3381d84a8166579de1/7efee/react-rendering-mental-model-from-part1-cleaner.jpg" alt="Mental model of a React component re-rendering when props or state change, cleaner than in part 1" title="When props or state changes the component re-renders" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>When props or state changes the component re-renders</figcaption>
  </figure>
<p><a href="https://news.ycombinator.com/item?id=23349160">Enjoying
this article? Let me know on Hacker News!</a></p>
<h2 id="the-usestate-hook-state-in-a-bottle"><a href="#the-usestate-hook-state-in-a-bottle" aria-label="the usestate hook state in a bottle permalink"></a>The useState hook: state in a bottle</h2>
<p>I showed
<a href="https://obedparla.com/code/a-visual-guide-to-react-mental-models/#fitting-reacts-state-into-our-mental-model">how state works in part 1</a>,
and how it is is a special property inside a box. Unlike variables or functions
which are re-declared on every render, the values that come out of <code>useState</code>
always consistent across renders. They get initialized on <code>mount</code> with a default
value, and can only be changed by a <code>set state</code> event.</p>
<p>But how can React prevent <code>state</code> from losing its value on each render? The
answer is <strong>scope</strong>.</p>
<p>I explained the mental model for
<a href="https://obedparla.com/code/a-visual-guide-to-react-mental-models/#closures-in-react">closures and scope in pat 1</a>.
In short, a closure is like a semi-permeable box, letting information from the
outside get in but never leaking anything out.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/e0caedb67992235db77271808958da3d/8a6f5/javascript-closure-mental-model.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/e0caedb67992235db77271808958da3d/1426f/javascript-closure-mental-model.webp 173w,
/static/e0caedb67992235db77271808958da3d/923cb/javascript-closure-mental-model.webp 345w,
/static/e0caedb67992235db77271808958da3d/e922d/javascript-closure-mental-model.webp 375w" sizes="(max-width: 375px) 100vw, 375px" type="image/webp">
        <source srcset="/static/e0caedb67992235db77271808958da3d/d9d39/javascript-closure-mental-model.jpg 173w,
/static/e0caedb67992235db77271808958da3d/52bea/javascript-closure-mental-model.jpg 345w,
/static/e0caedb67992235db77271808958da3d/8a6f5/javascript-closure-mental-model.jpg 375w" sizes="(max-width: 375px) 100vw, 375px" type="image/jpeg">
        <img src="https://obedparla.com/static/e0caedb67992235db77271808958da3d/8a6f5/javascript-closure-mental-model.jpg" alt="A mental model for JavaScript closures, showing different React app and scripts as boxes within Global / Window" title="Javascript closures visualized" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>Javascript closures visualized</figcaption>
  </figure>
<p>With <code>useState</code>, React scopes its value to the outermost closure, which is the
React app containing all your components. In other words, whenever you use
<code>useState</code> React returns a value that is stored <em>outside</em> your component and
hence not changing on each render.</p>
<p>React manages to do this by keeping track of each component and the order in
which each hook is declared. That’s the reason you can’t have a React Hook
inside a conditional. If useState, useEffect, or any other hook is created
<em>conditionally</em> then React cannot properly keep track of it.</p>
<p>This is best explained visually:</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/12ed0cadb923354ab1d89aa87165d055/86435/react-state-scope-mental-model.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/12ed0cadb923354ab1d89aa87165d055/1426f/react-state-scope-mental-model.webp 173w,
/static/12ed0cadb923354ab1d89aa87165d055/923cb/react-state-scope-mental-model.webp 345w,
/static/12ed0cadb923354ab1d89aa87165d055/ef070/react-state-scope-mental-model.webp 368w" sizes="(max-width: 368px) 100vw, 368px" type="image/webp">
        <source srcset="/static/12ed0cadb923354ab1d89aa87165d055/d9d39/react-state-scope-mental-model.jpg 173w,
/static/12ed0cadb923354ab1d89aa87165d055/52bea/react-state-scope-mental-model.jpg 345w,
/static/12ed0cadb923354ab1d89aa87165d055/86435/react-state-scope-mental-model.jpg 368w" sizes="(max-width: 368px) 100vw, 368px" type="image/jpeg">
        <img src="https://obedparla.com/static/12ed0cadb923354ab1d89aa87165d055/86435/react-state-scope-mental-model.jpg" alt="React state scope mental model showing a box with state living in the outer box and not the component box" title="React state is scoped to the outer-most box, that way it doesn't change on every render" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>React state is scoped to the outer-most box, that way it doesn't change on every render</figcaption>
  </figure>
<p>Whenever a component is re-rendered <code>useState</code> asks to get the state for the
current component, React then checks a list containing all states for each
component and returns the corresponding one. This list is stored outside the
component because on each re-render variables and functions are created and
destroyed.</p>
<p>Although this is a technical view of how state works, by understanding it I can
transform some of React’s magic into something I can visualize. For my mental
model I simplify things into a simpler idea.</p>
<p>My mental model when working with <code>useState</code> is this: since state is not
affected by what happens to the box, I imagine it as a <code>constant</code> value within
it. I know that no matter what happens <code>state</code> will remain consistent throughout
the lifetime of my component.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/0843a9f87a69f2084ec10f3bb8ebf061/87d62/react-state-mental-model-detailed.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/0843a9f87a69f2084ec10f3bb8ebf061/1426f/react-state-mental-model-detailed.webp 173w,
/static/0843a9f87a69f2084ec10f3bb8ebf061/923cb/react-state-mental-model-detailed.webp 345w,
/static/0843a9f87a69f2084ec10f3bb8ebf061/0823a/react-state-mental-model-detailed.webp 370w" sizes="(max-width: 370px) 100vw, 370px" type="image/webp">
        <source srcset="/static/0843a9f87a69f2084ec10f3bb8ebf061/d9d39/react-state-mental-model-detailed.jpg 173w,
/static/0843a9f87a69f2084ec10f3bb8ebf061/52bea/react-state-mental-model-detailed.jpg 345w,
/static/0843a9f87a69f2084ec10f3bb8ebf061/87d62/react-state-mental-model-detailed.jpg 370w" sizes="(max-width: 370px) 100vw, 370px" type="image/jpeg">
        <img src="https://obedparla.com/static/0843a9f87a69f2084ec10f3bb8ebf061/87d62/react-state-mental-model-detailed.jpg" alt="Mental model of a React component with state, with state as a constant at the top of the box" title="State remains constant even though the component could change" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>State remains constant even though the component could change</figcaption>
  </figure>
<h3 id="how-does-state-change"><a href="#how-does-state-change" aria-label="how does state change permalink"></a>How does state change?</h3>
<p>Once we understand how state is preserved, it’s important to understand how it
changes.</p>
<p>You may know that state updates are <code>async</code>, but what does that mean? How does
it affect our everyday work?</p>
<p>A simplified explanation of <code>sync</code> and <code>async</code> is:</p>
<ul>
<li><strong>Sync</strong>ronous code blocks the JavaScript thread, where your apps runs, from
doing any other work. Only one piece of code can be run at a time in the
thread.</li>
<li><strong>Async</strong>ronous code doesn’t block the thread because it gets moved to a queue
and runs whenever there’s time available.</li>
</ul>
<p>We use state as a variable, but updating it is <code>async</code>. This makes it easy to
fall into the trap of thinking that a <code>set state</code> will change its value right
away like a variable would, which leads to bugs and frustration, for example:</p>
<div data-language="jsx"><pre><code><span>const</span> <span>Component</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>[</span>searchValue<span>,</span> setSearchValue<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  
  <span>const</span> <span>handleInput</span> <span>=</span> <span>e</span> <span>=&gt;</span> <span>{</span>
    
    <span>setSearchValue</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>;</span>
    <span>fetchSearch</span><span>(</span>searchValue<span>)</span><span>.</span><span>then</span><span>(</span><span>results</span> <span>=&gt;</span> <span>{</span>
      
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>This code is buggy. Imagine a person types <strong>Bye</strong>. The code will search for
<strong>by</strong> instead of <strong>bye</strong> because each new stroke triggers a new
<code>setSearchValue</code> and <code>fetchSearch</code>, but because state updates are <code>async</code> we’re
going to fetch with an outdated <code>searchValue</code>. If a person types fast enough and
we have other JavaScript running, we may even search for <strong>b</strong> since JavaScript
didn’t have time to run the code from the queue yet.</p>
<p>Long story short, don’t expect <code>state</code> to be updated right away. This fixes the
bug:</p>
<div data-language="javascript"><pre><code><span>const</span> <span>Component</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>[</span>searchValue<span>,</span> setSearchValue<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>

  <span>const</span> <span>handleInput</span> <span>=</span> <span>e</span> <span>=&gt;</span> <span>{</span>
    
    <span>const</span> search <span>=</span> e<span>.</span>target<span>.</span>value<span>;</span>
    <span>setSearchValue</span><span>(</span>search<span>)</span><span>;</span>
    <span>fetchSearch</span><span>(</span>search<span>)</span><span>.</span><span>then</span><span>(</span><span>results</span> <span>=&gt;</span> <span>{</span>
      
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>One of the reasons state updates are <code>async</code> is to optimize them. If an app has
hundreds of different states wanting to update at once React will try to batch
as many of them as possible into a single <code>async</code> operation, instead of running
many <code>sync</code> ones. Async operations, in general, are more performant too.</p>
<p>Another reason is consistency. If a state is updated many times in quick
succession, React will only take the latest value for consistency’s sake. This
would be difficult to do if the updates were <code>sync</code> and executed right away.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/a0da8e6bee48daa6f697cd94023a9736/fe1e7/async-state-updating-mental-model.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/a0da8e6bee48daa6f697cd94023a9736/1426f/async-state-updating-mental-model.webp 173w,
/static/a0da8e6bee48daa6f697cd94023a9736/923cb/async-state-updating-mental-model.webp 345w,
/static/a0da8e6bee48daa6f697cd94023a9736/ffce4/async-state-updating-mental-model.webp 690w,
/static/a0da8e6bee48daa6f697cd94023a9736/83d9f/async-state-updating-mental-model.webp 1035w,
/static/a0da8e6bee48daa6f697cd94023a9736/a0e10/async-state-updating-mental-model.webp 1380w,
/static/a0da8e6bee48daa6f697cd94023a9736/d2134/async-state-updating-mental-model.webp 1493w" sizes="(max-width: 690px) 100vw, 690px" type="image/webp">
        <source srcset="/static/a0da8e6bee48daa6f697cd94023a9736/d9d39/async-state-updating-mental-model.jpg 173w,
/static/a0da8e6bee48daa6f697cd94023a9736/52bea/async-state-updating-mental-model.jpg 345w,
/static/a0da8e6bee48daa6f697cd94023a9736/7efee/async-state-updating-mental-model.jpg 690w,
/static/a0da8e6bee48daa6f697cd94023a9736/078c0/async-state-updating-mental-model.jpg 1035w,
/static/a0da8e6bee48daa6f697cd94023a9736/bf2d4/async-state-updating-mental-model.jpg 1380w,
/static/a0da8e6bee48daa6f697cd94023a9736/fe1e7/async-state-updating-mental-model.jpg 1493w" sizes="(max-width: 690px) 100vw, 690px" type="image/jpeg">
        <img src="https://obedparla.com/static/a0da8e6bee48daa6f697cd94023a9736/7efee/async-state-updating-mental-model.jpg" alt="An image of code setting state in a React component next to a mental model of the JS thread and async operations visualizing how it works" title="A mental model of how the JavaScript Thread works with state, React batches state updates together" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>A mental model of how the JavaScript Thread works with state, React batches state updates together</figcaption>
  </figure>
<p>In my mental model, I see individual state values as reliable but slow. Whenever
I update one, I know it can take a while for it to change.</p>
<p>But what happens to state and the component itself, when it’s mounting and
unmounting?</p>
<h2 id="a-components-lifecycle-mental-models-for-mounting-rendering-and-unmounting"><a href="#a-components-lifecycle-mental-models-for-mounting-rendering-and-unmounting" aria-label="a components lifecycle mental models for mounting rendering and unmounting permalink"></a>A Component’s lifecycle: mental models for mounting, rendering, and unmounting</h2>
<p>We used to talk a lot about <strong>lifecycle methods</strong> when only class-components had
access to <code>state</code> and control of what was happening to a component over its
lifetime. But since Hooks came out and allowed us the same kind of power in
functional components, the idea became less relevant.</p>
<p>What’s interesting is that each component still has a lifecycle: its mounted,
rendered and unmounted, and each step must be taken into account for a
fully-functional mental model around React components.</p>
<p>So let’s go through each phase and build a mental model for it, I promise it’ll
make your understanding of a component much better.</p>
<h3 id="mounting-creating-components"><a href="#mounting-creating-components" aria-label="mounting creating components permalink"></a>Mounting: Creating Components</h3>
<p>When React creates or renders a component for the first time it’s <code>mounting</code> it.
Meaning it’s going to be added to the DOM and React will start keeping track of
it.</p>
<p>I like to imagine <code>mounting</code> as a new box being or added inside its parent.</p>
<p>Mounting happens whenever a component hasn’t been rendered, and its parent
decides to render it for the first time. In other words, <code>mounting</code> is a
component being “born”.</p>
<p>A component can be created and destroyed many times, and each time it’s created,
it will be <code>mounted</code> again.</p>
<div data-language="jsx"><pre><code><span>const</span> <span>Component</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>[</span>show<span>,</span> setShow<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>div</span><span>&gt;</span></span><span>
      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setShow</span><span>(</span><span>!</span>show<span>)</span><span>}</span></span><span>&gt;</span></span><span>Show Menu</span><span><span><span>&lt;/</span>button</span><span>&gt;</span></span><span>
      // Mounted with show = true and unomunted with show = false
      </span><span>{</span>show <span>&amp;&amp;</span> <span><span><span>&lt;</span><span>MenuDropdown</span></span> <span>/&gt;</span></span><span>}</span><span>
    </span><span><span><span>&lt;/</span>div</span><span>&gt;</span></span>
  <span>)</span><span>;</span>
<span>}</span><span>;</span></code></pre></div>
<p>React renders components so fast it can look like its hiding them but in
reality, it’s creating and deleting them very quickly. In the example above the
<code>&lt;MenuDropdown /&gt;</code> component will be added and removed from the DOM every time
the button is clicked.</p>
<p>Note how the component’s parent is the one deciding when to mount and unmount
<code>&lt;MenuDropdown /&gt;</code>. This goes up the hierarchy too. If <code>MenuDropdown</code> has
children components they will be <code>mounted</code> or <code>unmounted</code> too. The component
itself never knows when it’s going to be mounted or unmounted.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/6f51402353470d70615fd47245b551fe/4eadb/component-mount-mental-model.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/6f51402353470d70615fd47245b551fe/1426f/component-mount-mental-model.webp 173w,
/static/6f51402353470d70615fd47245b551fe/923cb/component-mount-mental-model.webp 345w,
/static/6f51402353470d70615fd47245b551fe/ffce4/component-mount-mental-model.webp 690w,
/static/6f51402353470d70615fd47245b551fe/e6f0c/component-mount-mental-model.webp 817w" sizes="(max-width: 690px) 100vw, 690px" type="image/webp">
        <source srcset="/static/6f51402353470d70615fd47245b551fe/d9d39/component-mount-mental-model.jpg 173w,
/static/6f51402353470d70615fd47245b551fe/52bea/component-mount-mental-model.jpg 345w,
/static/6f51402353470d70615fd47245b551fe/7efee/component-mount-mental-model.jpg 690w,
/static/6f51402353470d70615fd47245b551fe/4eadb/component-mount-mental-model.jpg 817w" sizes="(max-width: 690px) 100vw, 690px" type="image/jpeg">
        <img src="https://obedparla.com/static/6f51402353470d70615fd47245b551fe/7efee/component-mount-mental-model.jpg" alt="Two boxes next to each other representing the mental model of a React component mounting a child component when logic changes. The component-to-be-mounted is shown with low opacity on the left" title="The parent component re-renders with different logic, causing a child to mount" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>The parent component re-renders with different logic, causing a child to mount</figcaption>
  </figure>
<p>Once a component is <code>mounted</code>, it will do a few things:</p>
<ul>
<li>Initialize <code>useState</code> with default values: this <em>only</em> happens on mount.</li>
<li>Execute the component’s logic.</li>
<li>Do an initial render, adding the elements to the DOM.</li>
<li>Run the <code>useEffect</code> hook.</li>
</ul>
<p>Note that the <code>useEffect</code> hook runs <em>after</em> the initial render. That’s when you
want to run code like creating event listeners, executing heavy logic, or
fetching data. More on this in the
<a href="#the-useeffect-hook-a-complete-mental-model">useEffect section</a> below.</p>
<p>My mental model for <code>mounting</code> is this: whenever a parent box decides a child
must be created, it <strong>mounts</strong> it, then the component will do three things:
assign default values to <code>useState</code>, run its logic, render, and execute the
<code>useEffect</code> hook.</p>
<p>The <code>mount</code> phase is very similar to a normal <code>re-render</code>, with the difference
being initializing <code>useState</code> with default values and the elements being added
to the DOM for the first time. After <code>mount</code> the component remains in the DOM
and is updated further.</p>
<p>Once a component is mounted it will continue to live until it unmounts, doing
any amount of renders in between.</p>
<h3 id="rendering-updating-what-the-user-sees"><a href="#rendering-updating-what-the-user-sees" aria-label="rendering updating what the user sees permalink"></a>Rendering: Updating What The User Sees</h3>
<p>I explained
<a href="https://obedparla.com/code/a-visual-guide-to-react-mental-models/#the-rendering-mental-model-understanding-reacts-magic">the rendering mental model in part 1</a>,
but let’s review it briefly as it’s an important phase.</p>
<p>After a component mounts, any changes to the <code>props</code> or <code>state</code> will cause it to
re-render, re-executing <em>all</em> the code inside of it, including its children
components. After each <code>render</code> the <code>useEffect</code> hook is evaluated again.</p>
<p>I imagine a component as a box and its ability to re-render makes it a re-usable
box. Every render recycles the box, which could output different information
while keeping the same state and code underneath.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/648e36d88ac2ea2557026e0cad8117d2/ea2ac/rerendering-mental-model-part2.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/648e36d88ac2ea2557026e0cad8117d2/1426f/rerendering-mental-model-part2.webp 173w,
/static/648e36d88ac2ea2557026e0cad8117d2/923cb/rerendering-mental-model-part2.webp 345w,
/static/648e36d88ac2ea2557026e0cad8117d2/ffce4/rerendering-mental-model-part2.webp 690w,
/static/648e36d88ac2ea2557026e0cad8117d2/83d9f/rerendering-mental-model-part2.webp 1035w,
/static/648e36d88ac2ea2557026e0cad8117d2/66e35/rerendering-mental-model-part2.webp 1231w" sizes="(max-width: 690px) 100vw, 690px" type="image/webp">
        <source srcset="/static/648e36d88ac2ea2557026e0cad8117d2/d9d39/rerendering-mental-model-part2.jpg 173w,
/static/648e36d88ac2ea2557026e0cad8117d2/52bea/rerendering-mental-model-part2.jpg 345w,
/static/648e36d88ac2ea2557026e0cad8117d2/7efee/rerendering-mental-model-part2.jpg 690w,
/static/648e36d88ac2ea2557026e0cad8117d2/078c0/rerendering-mental-model-part2.jpg 1035w,
/static/648e36d88ac2ea2557026e0cad8117d2/ea2ac/rerendering-mental-model-part2.jpg 1231w" sizes="(max-width: 690px) 100vw, 690px" type="image/jpeg">
        <img src="https://obedparla.com/static/648e36d88ac2ea2557026e0cad8117d2/7efee/rerendering-mental-model-part2.jpg" alt="Mental model of a component mounting, showing 3 boxes in 3 stages: the initial component, props/state change causing a rerender and new component" title="A component re-renders whenever state or props change, or its parent re-renders" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>A component re-renders whenever state or props change, or its parent re-renders</figcaption>
  </figure>
<p>Once a component’s parent decides to stop rendering a child–because of a
conditional, changes in data or any other reason–the component will need to be
unmounted.</p>
<h2 id="unnmountig-deleting-components"><a href="#unnmountig-deleting-components" aria-label="unnmountig deleting components permalink"></a>Unnmountig: Deleting Components</h2>
<p>When a component is <code>unmounted</code> React will remove it from the DOM and stops
keeping track of it. The component is deleted including any <code>state</code> it had.</p>
<p>Like explained in the <code>mounting</code> phase, a component is both <code>mounted</code> and
<code>unmounted</code> by its parent, and if the component, in turn, has children it will
<code>unmount</code> those too, and the cycle repeats until the last child is reached.</p>
<p>In my mental model, I see this as a parent-box trashing a child-box. If you
throw a container to the trash everything inside of it will also go to the
trash, this includes other boxes (components), state, variables, everything.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/2a02814a6135948c37ecb0cc8802eed3/4eadb/component-unmount-mental-model.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/2a02814a6135948c37ecb0cc8802eed3/1426f/component-unmount-mental-model.webp 173w,
/static/2a02814a6135948c37ecb0cc8802eed3/923cb/component-unmount-mental-model.webp 345w,
/static/2a02814a6135948c37ecb0cc8802eed3/ffce4/component-unmount-mental-model.webp 690w,
/static/2a02814a6135948c37ecb0cc8802eed3/e6f0c/component-unmount-mental-model.webp 817w" sizes="(max-width: 690px) 100vw, 690px" type="image/webp">
        <source srcset="/static/2a02814a6135948c37ecb0cc8802eed3/d9d39/component-unmount-mental-model.jpg 173w,
/static/2a02814a6135948c37ecb0cc8802eed3/52bea/component-unmount-mental-model.jpg 345w,
/static/2a02814a6135948c37ecb0cc8802eed3/7efee/component-unmount-mental-model.jpg 690w,
/static/2a02814a6135948c37ecb0cc8802eed3/4eadb/component-unmount-mental-model.jpg 817w" sizes="(max-width: 690px) 100vw, 690px" type="image/jpeg">
        <img src="https://obedparla.com/static/2a02814a6135948c37ecb0cc8802eed3/7efee/component-unmount-mental-model.jpg" alt="Two boxes next to each other representing the mental model of a React component unmount a child component when logic changes. The component-to-be-unmounted is shown with low opacity on the right" title="The parent component re-renders with different logic, causing a child to unmount" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>The parent component re-renders with different logic, causing a child to unmount</figcaption>
  </figure>
<p>But a component can create code <em>outside</em> of itself. What happens to any
subscription, web socket, or event listener created by a component that will be
unmounted?</p>
<p>The answer is nothing. Those functions run outside the component and won’t be
affected by it being deleted. That’s why is important for the component to clean
up after itself before unmounting.</p>
<p>Each function drains resources. Failing to clean them up can lead to nasty bugs,
degraded performance and even security risks.</p>
<p>I think of these functions as gears turning outside my box. They’re set in
motion when the component <code>mounts</code>, and they must be stopped when it <code>unmounts</code>.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/16c28a719ac6eda87f961b42316b1ab9/ae68a/mental-model-of-mounting-external-functions.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/16c28a719ac6eda87f961b42316b1ab9/1426f/mental-model-of-mounting-external-functions.webp 173w,
/static/16c28a719ac6eda87f961b42316b1ab9/923cb/mental-model-of-mounting-external-functions.webp 345w,
/static/16c28a719ac6eda87f961b42316b1ab9/ffce4/mental-model-of-mounting-external-functions.webp 690w,
/static/16c28a719ac6eda87f961b42316b1ab9/83d9f/mental-model-of-mounting-external-functions.webp 1035w,
/static/16c28a719ac6eda87f961b42316b1ab9/6a7bf/mental-model-of-mounting-external-functions.webp 1165w" sizes="(max-width: 690px) 100vw, 690px" type="image/webp">
        <source srcset="/static/16c28a719ac6eda87f961b42316b1ab9/d9d39/mental-model-of-mounting-external-functions.jpg 173w,
/static/16c28a719ac6eda87f961b42316b1ab9/52bea/mental-model-of-mounting-external-functions.jpg 345w,
/static/16c28a719ac6eda87f961b42316b1ab9/7efee/mental-model-of-mounting-external-functions.jpg 690w,
/static/16c28a719ac6eda87f961b42316b1ab9/078c0/mental-model-of-mounting-external-functions.jpg 1035w,
/static/16c28a719ac6eda87f961b42316b1ab9/ae68a/mental-model-of-mounting-external-functions.jpg 1165w" sizes="(max-width: 690px) 100vw, 690px" type="image/jpeg">
        <img src="https://obedparla.com/static/16c28a719ac6eda87f961b42316b1ab9/7efee/mental-model-of-mounting-external-functions.jpg" alt="Two boxes on the sides with gear icons in the middle. A mental model for external functions not being affected by React component unmount" title="A function that lives outside your code won't be removed on `unmount` on its own." loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>A function that lives outside your code won't be removed on `unmount` on its own.</figcaption>
  </figure>
<p>We’re able to clean up or stop these gears through the return function of
<code>useEffect</code>. I will explain in detail in the Effect hook section.</p>
<p>So let’s put all the lifecycle methods into a clear mental model</p>
<h2 id="the-complete-component-lifecycle-mental-model"><a href="#the-complete-component-lifecycle-mental-model" aria-label="the complete component lifecycle mental model permalink"></a>The Complete Component Lifecycle Mental Model</h2>
<p>To summarize so far: a component is just a function, props are the function’s
arguments and state is a special value that React makes sure to keep consistent
across renders. All components must be within other components, and each parent
can have many children within it.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/083891c92c63c1c4240a602182c67277/44313/react-component-mental-model.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/083891c92c63c1c4240a602182c67277/1426f/react-component-mental-model.webp 173w,
/static/083891c92c63c1c4240a602182c67277/923cb/react-component-mental-model.webp 345w,
/static/083891c92c63c1c4240a602182c67277/8d009/react-component-mental-model.webp 379w" sizes="(max-width: 379px) 100vw, 379px" type="image/webp">
        <source srcset="/static/083891c92c63c1c4240a602182c67277/d9d39/react-component-mental-model.jpg 173w,
/static/083891c92c63c1c4240a602182c67277/52bea/react-component-mental-model.jpg 345w,
/static/083891c92c63c1c4240a602182c67277/44313/react-component-mental-model.jpg 379w" sizes="(max-width: 379px) 100vw, 379px" type="image/jpeg">
        <img src="https://obedparla.com/static/083891c92c63c1c4240a602182c67277/44313/react-component-mental-model.jpg" alt=" A complete mental model for a simple stateful React component: a box with props coming from outside, state inside at the top, logic, and components." title="A complete mental model for a simple stateful component" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>A complete mental model for a simple stateful component</figcaption>
  </figure>
<p>Each component has three phases in its lifecycle: mounting, rendering, and
unmounting.</p>
<p>In my mental model, a component is a box and based on some logic it can decide
to create or delete a child box. When it creates it a component is <code>mounted</code> and
when it deletes it, it is <code>unmounted</code>.</p>
<p>A box <code>mounting</code> means it was created and executed. Here’s when <code>useState</code> is
initialized with default values and React renders it so the user can see it, and
starts keeping track of it.</p>
<p>The mounting phase is where we tend to connect to external services, fetch data
or create event listeners.</p>
<p>Once mounted, whenever a box’s props or state changes it will be re-rendered,
which I imagine as the box being recycled and everything <em>but</em> state is
re-executed and re-calculated. What the user sees can change on every new
render. Re-rendering is the second phase, which can happen any number of times,
without limit.</p>
<p>Once a component’s parent decides to remove it, either because of logic, the
parent itself was removed, or data changed, the component will <code>unmount</code>.</p>
<p>When a box <code>unmounts</code> it is thrown away, trashed with everything it contains,
including children components (which in turn have their own <code>unmount</code>). This is
where we have the chance to clean up and delete any external function we
initialized in a <code>useEffect</code>.</p>
<p>The cycle of mounting, re-rendering, and unmounting can happen thousands of
times in your app without you noticing. React is incredibly fast and that’s why
it’s useful to keep a mental model in mind when dealing with complex components
since it’s so hard to see what’s going on in real-time.</p>
<p>But how do we take advantage of these phases in our code? The answer is through
the powerful <code>useEffect</code> hook.</p>
<h2 id="the-useeffect-hook-unlimited-power"><a href="#the-useeffect-hook-unlimited-power" aria-label="the useeffect hook unlimited power permalink"></a>The UseEffect Hook: Unlimited Power!</h2>
<p>The Effect hook allows us to run <strong>side effects</strong> in our components. Whenever
you’re fetching data, connecting to a service or subscription or manually
manipulating the DOM, you’re performing a side effect (also called simply
effect).</p>
<p>A side effect in the context of functions is anything that will make the
function unpredictable, like data or state. A function without side-effects will
be predictable and <em>pure</em>–you might have heard of <code>pure functions</code>–always doing
the exact same thing as long as the inputs remain constant.</p>
<p>An Effect hook always runs <em>after</em> every render. The reason being that side
effects can contain heavy logic or take time, such as fetching data, so in
general they’re better off running after render.</p>
<p>The hook receives two arguments: the function to execute and an array with
values that will be evaluated after each render, these values are called
dependencies.</p>
<div data-language="javascript"><pre><code>
<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>)</span><span>;</span>


<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>


<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  
<span>}</span><span>,</span> <span>[</span>a<span>,</span> b<span>,</span> c<span>]</span><span>)</span><span>;</span></code></pre></div>
<p>Depending on the second argument you have 3 options with different behavior. The
logic for each option is:</p>
<ul>
<li><strong>If not present</strong> the effect will run after every render. This option is not
commonly used, but it’s useful in some situations like needing to do heavy
calculations after each render.</li>
<li><strong>With an empty array</strong> <code>[]</code> the effect runs only once, after <code>mounting</code> and
the first render. This is great for one-time effects such as creating an event
listener.</li>
<li><strong>An array with values</strong> <code>[a, b, c]</code> makes the effect evaluate the
dependencies, whenever a dependency changes the effect will run. This is
useful to run effect when props or state changes, like fetching new data.</li>
</ul>
<figure>
    <span>
      <a href="https://obedparla.com/static/0698801bff1422709e0ad0ae3f76a2e2/ba295/use-effect-dependency-otpions.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/0698801bff1422709e0ad0ae3f76a2e2/1426f/use-effect-dependency-otpions.webp 173w,
/static/0698801bff1422709e0ad0ae3f76a2e2/923cb/use-effect-dependency-otpions.webp 345w,
/static/0698801bff1422709e0ad0ae3f76a2e2/abd74/use-effect-dependency-otpions.webp 529w" sizes="(max-width: 529px) 100vw, 529px" type="image/webp">
        <source srcset="/static/0698801bff1422709e0ad0ae3f76a2e2/d9d39/use-effect-dependency-otpions.jpg 173w,
/static/0698801bff1422709e0ad0ae3f76a2e2/52bea/use-effect-dependency-otpions.jpg 345w,
/static/0698801bff1422709e0ad0ae3f76a2e2/ba295/use-effect-dependency-otpions.jpg 529w" sizes="(max-width: 529px) 100vw, 529px" type="image/jpeg">
        <img src="https://obedparla.com/static/0698801bff1422709e0ad0ae3f76a2e2/ba295/use-effect-dependency-otpions.jpg" alt="Three colorful boxes depicting the three options of the useEffect hook's dependency array: without, empty, with values " title="A visual explanation of useEffect's dependency options" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>A visual explanation of useEffect's dependency options</figcaption>
  </figure>
<p>The dependency array gives <code>useEffect</code> its magic, and it’s important to use it
correctly. You <em>must</em> include all variables used within <code>useEffect</code>, otherwise,
the effect will reference stale values from previous renders when running,
causing bugs.</p>
<p>The ESLint plugin <code>eslint-plugin-react-hooks</code> contains many useful
Hooks-specific rules, including one that will warn you if you missed a
dependency inside a <code>useEffect</code>.</p>
<p>My initial mental model for useEffect has it as a mini-box living inside its
component, with three distinct behaviors depending on the usage of the
dependency array: the effect either runs after every render if there are no
dependencies, only after mount if it’s an empty array, or whenever a dependency
changes if the array has values.</p>
<figure>
    <span>
      <a href="https://obedparla.com/static/0fa496b7f696513c2b2470e1f2bd5fa1/8a6f5/use-effect-inside-component-model.jpg" target="_blank" rel="noopener">
    <span></span>
  <picture>
        <source srcset="/static/0fa496b7f696513c2b2470e1f2bd5fa1/1426f/use-effect-inside-component-model.webp 173w,
/static/0fa496b7f696513c2b2470e1f2bd5fa1/923cb/use-effect-inside-component-model.webp 345w,
/static/0fa496b7f696513c2b2470e1f2bd5fa1/e922d/use-effect-inside-component-model.webp 375w" sizes="(max-width: 375px) 100vw, 375px" type="image/webp">
        <source srcset="/static/0fa496b7f696513c2b2470e1f2bd5fa1/d9d39/use-effect-inside-component-model.jpg 173w,
/static/0fa496b7f696513c2b2470e1f2bd5fa1/52bea/use-effect-inside-component-model.jpg 345w,
/static/0fa496b7f696513c2b2470e1f2bd5fa1/8a6f5/use-effect-inside-component-model.jpg 375w" sizes="(max-width: 375px) 100vw, 375px" type="image/jpeg">
        <img src="https://obedparla.com/static/0fa496b7f696513c2b2470e1f2bd5fa1/8a6f5/use-effect-inside-component-model.jpg" alt="Three boxes representing each useEffect option inside a component box" title="Each useEffect lives inside the component, accessing the same info, but as its own box" loading="lazy">
      </picture>
  </a>
    </span>
    <figcaption>Each useEffect lives inside the component, accessing the same info, but as its own box</figcaption>
  </figure>
<p>There’s another important feature of <code>useEffect</code>, it allows us to clean up
before a <em>new</em> effect is run, or before <code>unmount</code> occurs.</p>
<h3 id="useeffect-during-unmount-cleaning-up"><a href="#useeffect-during-unmount-cleaning-up" aria-label="useeffect during unmount cleaning up permalink"></a>UseEffect during unmount: cleaning up</h3>
<p>Every time we create a subscription, event listener or open connections we must
clean them up when they’re no longer needed, otherwise, we create a memory leak
and degrade the performance of our app.</p>
<p>This is where <code>useEffect</code> comes in handy. By returning a function from it we can
run code before applying the next effect, or if the effect runs only once then
the code runs before <code>unmounting</code> the component.</p>
<div data-language="javascript"><pre><code>

<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>handleResize</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>setWindowWidth</span><span>(</span>window<span>.</span>innerWidth<span>)</span><span>;</span>
  window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> handleResize<span>)</span><span>;</span>

  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> window<span>.</span><span>remoteEventListener</span><span>(</span><span>'resize'</span><span>,</span> handleResize<span>)</span><span>;</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>


<span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>handleStatusChange</span> <span>=</span> <span>streamData</span> <span>=&gt;</span> <span>{</span>
    <span>setStreamData</span><span>(</span>streamData<span>)</span><span>;</span>
  <span>}</span><span>;</span>

  streamingApi<span>.</span><span>subscribeToId</span><span>(</span>props<span>.</span>stream<span>.</span>id<span>,</span> handleStatusChange<span>)</span><span>;</span>

  
  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span>
    streamingApi<span>.</span><span>unsubscribeToId</span><span>(</span>props<span>.</span>stream<span>.</span>id<span>,</span> handleStatusChange<span>)</span><span>;</span>
<span>}</span><span>,</span> <span>[</span>props<span>.</span>stream<span>.</span>id<span>]</span><span>)</span><span>;</span></code></pre></div>
<h2 id="the-complete-react-useeffect-hook-mental-model"><a href="#the-complete-react-useeffect-hook-mental-model" aria-label="the complete react useeffect hook mental model permalink"></a>The Complete React UseEffect Hook Mental Model</h2>
<p>I imagine useEffect as a small box within a component, living alongside the
logic of the component. This box’s code (called an effect) only runs after React
has rendered the component, and it’s the perfect place to run side-effect or
heavy logic.</p>
<p>All of useEffect’s magic comes from its second argument, the dependency array,
and it can have three behaviors from it:</p>
<ul>
<li>No argument: the effect runs after each render</li>
<li>Empty array: the effect only runs after the initial render, and the return
function before unmount.</li>
<li>Array with values: whenever a dependency changes, the effect will run, and the
return function will run <em>before</em> the new effect.</li>
</ul>
<hr>
<p>I hope you’ve found my mental models useful! Explaining them clearly was a
challenge. If you enjoyed reading please share this article, it’s all I ask for
❤️.</p>
<p>This was the second part of a three part series, the next and last part will
cover higher-level concepts such as React <code>context</code> and how to better think of
your app to prevent common performance issues.</p>
<p>You can subscribe to my newsletter if you want to be notified when the third
part is out, as well as many more “Mental Models” articles I have planned
(useEffect in-depth, Git, and more).</p>
<p>We understand so much better with visual aids, and there’s not enough material
like this on the web, so I’m going to create many more articles such as this
(and better, as I hone down my design skills 😅).</p>
<p>What questions do you have? I’m always available in
<a href="https://twitter.com/ObedParla">Twitter</a>, hit me up!</p></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>