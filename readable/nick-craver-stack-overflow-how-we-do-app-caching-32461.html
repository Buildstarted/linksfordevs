<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>Nick Craver - Stack Overflow: How We Do App Caching - 2019 Edition</h1>
        <p>
Reading time: 44-56 minutes        </p>
        <p><a href="https://nickcraver.com/blog/2019/08/06/stack-overflow-how-we-do-app-caching/">https://nickcraver.com/blog/2019/08/06/stack-overflow-how-we-do-app-caching/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
      <div>
        <main>
        <div>
          
          <article>
            <blockquote>
  <p>This is #5 in a <a href="https://nickcraver.com/blog/2016/02/03/stack-overflow-a-technical-deconstruction/">very long series of posts</a> on Stack Overflow‚Äôs architecture.<br>
Previous post (#4): <a href="https://nickcraver.com/blog/2018/11/29/stack-overflow-how-we-do-monitoring/">Stack Overflow: How We Do Monitoring - 2018 Edition</a></p>
</blockquote>

<p>So‚Ä¶caching. What is it? It‚Äôs a way to get a quick payoff by not re-calculating or fetching things over and over, resulting in performance and cost wins.
That‚Äôs even where the name comes from, it‚Äôs a short form of the ‚Äúca-ching!‚Äù cash register sound from the dark ages of 2014 when physical currency was still a thing, before Apple Pay. I‚Äôm a dad now, deal with it.</p>

<p>Let‚Äôs say we need to call an API or query a database server or just take a bajillion numbers (Google says <a href="https://www.merriam-webster.com/dictionary/bajillion">that‚Äôs an actual word</a>, I checked) and add them up.
Those are all relatively <em>crazy</em> expensive. So we <a href="https://en.wikipedia.org/wiki/Cache_(computing)">cache</a> the result ‚Äì we keep it handy for re-use.</p>

<h3 id="why-do-we-cache"><a href="#why-do-we-cache">Why Do We Cache?</a></h3>

<p>I think it‚Äôs important here to discuss <em>just how expensive</em> some of the above things are.
There are several layers of caching already in play in your modern computer.
<!--more-->
As a concrete example, we‚Äôre going to use one of our web servers which currently houses a pair of <a href="https://ark.intel.com/products/81713/Intel-Xeon-Processor-E5-2690-v3-30M-Cache-2-60-GHz-">Intel Xeon E5-2960 v3 CPUs</a>&nbsp;and 2133MHz DIMMs.
Cache access is a ‚Äúhow many cycles‚Äù feature of a processor, so by knowing that we always run at 3.06GHz (performance power mode), we can derive the latencies (<a href="https://www.intel.co.uk/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf">Intel architecture reference here</a> ‚Äì these processors are in the Haswell generation):</p>

<ul>
  <li>L1 (per core): 4 cycles or <strong>~1.3ns</strong> latency - 12x 32KB+32KB</li>
  <li>L2 (per core): 12 cycles or <strong>~3.92ns</strong> latency - 12x 256KB</li>
  <li>L3 (shared): 34 cycles or <strong>~11.11ns</strong> latency - 30MB</li>
  <li>System memory: <strong>~100ns</strong> latency - 8x 8GB</li>
</ul>

<p>Each cache layer is able to store more, but is farther away.
It‚Äôs a trade-off in processor design with balances in play.
For example, more memory per core means (almost certainly) on average putting it farther away on the chip from the core and that has costs in latency, opportunity costs, and power consumption.
How far an electric charge has to travel has substantial impact at this scale; remember that distance is multiplied by <em>billions</em> every second.</p>

<p>And I didn‚Äôt get into disk latency above because we so very rarely touch disk.
Why? Well, I guess to explain that we need to‚Ä¶look at disks.
Ooooooooh shiny disks!
But please don‚Äôt touch them after running around in socks.
At Stack Overflow, anything production that‚Äôs not a backup or logging server is on SSDs.
Local storage generally falls into a few tiers for us:</p>

<ul>
  <li>NVMe SSD: ~120Œºs (<a href="https://www.anandtech.com/show/8104/intel-ssd-dc-p3700-review-the-pcie-ssd-transition-begins-with-nvme/3">source</a>)</li>
  <li>SATA or SAS SSD: ~400‚Äì600Œºs (<a href="https://www.anandtech.com/show/8104/intel-ssd-dc-p3700-review-the-pcie-ssd-transition-begins-with-nvme/3">source</a>)</li>
  <li>Rotational HDD: 2‚Äì6ms (<a href="https://en.wikipedia.org/wiki/Hard_disk_drive_performance_characteristics">source</a>)</li>
</ul>

<p>These numbers are changing all the time, so don‚Äôt focus on exact figures too much.
What we‚Äôre trying to evaluate is the magnitude of the difference of these storage tiers.
Let‚Äôs go down the list (assuming the lower bound of each, these are best case numbers):</p>

<ul>
  <li>L1: 1.3ns</li>
  <li>L2: 3.92ns (<strong>3x slower</strong>)</li>
  <li>L3: 11.11ns (<strong>8.5x slower</strong>)</li>
  <li>DDR4 RAM: 100ns (<strong>77x slower</strong>)</li>
  <li>NVMe SSD: 120,000ns (<strong>92,307x slower</strong>)</li>
  <li>SATA/SAS SSD: 400,000ns (<strong>307,692x slower</strong>)</li>
  <li>Rotational HDD: 2‚Äì6ms (<strong>1,538,461x slower</strong>)</li>
  <li>Microsoft Live Login: 12 redirects and 5s (<strong>3,846,153,846x slower</strong>, approximately)</li>
</ul>

<p>If numbers aren‚Äôt your thing, <a href="https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html">here‚Äôs a neat open source visualization</a> (use the slider!)&nbsp;by <a href="https://github.com/colin-scott">Colin Scott</a>&nbsp;(you can even go see how they‚Äôve evolved over time ‚Äì really neat):</p>

<p><a href="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-Latencies.png" target="_blank"><picture><source type="image/webp" srcset="/blog/content/SO-Caching/SO-Cache-Latencies.webp"><source type="image/png" srcset="/blog/content/SO-Caching/SO-Cache-Latencies.png"><img src="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-Latencies.png" loading="lazy" alt="Cache Latencies"></picture></a></p>

<p>With those performance numbers and a sense of scale in mind, let‚Äôs add some numbers that matter every day.
Let‚Äôs say our data source is <code>X</code>, where what <code>X</code> is doesn‚Äôt matter.
It could be SQL, or a microservice, or a macroservice, or a leftpad service, or Redis, or a file on disk, etc.
The key here is that we‚Äôre comparing that source‚Äôs performance to that of RAM.
Let‚Äôs say our source takes‚Ä¶</p>

<ul>
  <li>100ns (from RAM - fast!)</li>
  <li>1ms (10,000x slower)</li>
  <li>100ms (100,000x slower)</li>
  <li>1s (1,000,000x slower)</li>
</ul>

<p>I don‚Äôt think we need to go further to illustrate the point: <strong>even things that take only 1 millisecond are way, <em>way</em> slower than local RAM</strong>. Remember: millisecond, microsecond, nanosecond ‚Äì just in case anyone else forgets that a 1000ns != 1ms like I sometimes do‚Ä¶</p>

<p>But not all cache is local.
For example, we use Redis for shared caching behind our web tier (<a href="#redis">which we‚Äôll cover in a bit</a>).
Let‚Äôs say we‚Äôre going across our network to get it.
For us, that‚Äôs a 0.17ms roundtrip and you need to also send some data.
For small things (our usual), that‚Äôs going to be around 0.2‚Äì0.5ms total.
Still 2,000‚Äì5,000x slower than local RAM, but also a lot faster than most sources.
Remember, these numbers are because we‚Äôre in a small local LAN. 
Cloud latency will generally be higher, so measure to see your latency.</p>

<p>When we get the data, maybe we also want to massage it in some way.
Probably Swedish.
Maybe we need totals, maybe we need to filter, maybe we need to encode it, maybe we need to fudge with it randomly just to trick you.
That was a test to see if you‚Äôre still reading. You passed!
Whatever the reason, the commonality is generally <em>we want to do <code>&lt;x&gt;</code> once</em>, and not <em>every time we serve it</em>.</p>

<p>Sometimes we‚Äôre saving latency and sometimes we‚Äôre saving CPU.
One or both of those are generally why a cache is introduced.
Now let‚Äôs cover the flip side‚Ä¶</p>

<h3 id="why-wouldnt-we-cache"><a href="#why-wouldnt-we-cache">Why Wouldn‚Äôt We Cache?</a></h3>

<p>For everyone who hates caching, this is the section for you! 
Yes, I‚Äôm totally playing both sides.</p>

<p>Given the above and how drastic the wins are, why <em>wouldn‚Äôt</em> we cache something?
Well, because <strong><em>every single decision has trade-offs</em></strong>. Every. Single. One.
It could be as simple as time spent or opportunity cost, but there‚Äôs still a trade-off.</p>

<p>When it comes to caching, adding a cache comes with some costs:</p>

<ul>
  <li>Purging values if and when needed (cache invalidation ‚Äì <a href="#cache-invalidation">we‚Äôll cover that in a few</a>)</li>
  <li>Memory used by the cache</li>
  <li>Latency of access to the cache (weighed against access to the source)</li>
  <li>Additional time and mental overhead spent debugging something more complicated</li>
</ul>

<p>Whenever a candidate for caching comes up (usually with a new feature), we need to evaluate these things‚Ä¶and that‚Äôs not always an easy thing to do.
Although caching is an exact science, much like astrology, it‚Äôs still tricky.</p>

<p>Here at Stack Overflow, our architecture has one overarching theme: keep it as simple as possible.
Simple is easy to evaluate, reason about, debug, and change if needed.
Only make it more complicated if and when it <strong><em>needs</em></strong> to be more complicated.
That includes cache. Only cache if you need to.
It adds more work and <a href="https://shouldiblamecaching.com/">more chances for bugs</a>, so unless it‚Äôs needed: don‚Äôt.
At least, not yet.</p>

<p>Let‚Äôs start by asking some questions.</p>

<ul>
  <li>Is it that much faster to hit cache?</li>
  <li>What are we saving?</li>
  <li>Is it worth the storage?</li>
  <li>Is it worth the cleanup of said storage (e.g. garbage collection)?</li>
  <li>Will it go on the large object heap immediately?</li>
  <li>How often do we have to invalidate it?</li>
  <li>How many hits per cache entry do we think we‚Äôll get?</li>
  <li>Will it interact with other things that complicate invalidation?</li>
  <li>How many variants will there be?</li>
  <li>Do we have to allocate just to calculate the key?</li>
  <li>Is it a local or remote cache?</li>
  <li>Is it shared between users?</li>
  <li>Is it shared between sites?</li>
  <li>Does it rely on quantum entanglement or does debugging it just make you think that?</li>
  <li>What color is the cache?</li>
</ul>

<p>All of these are questions that come up and affect caching decisions.
I‚Äôll try and cover them through this post.</p>

<h3 id="layers-of-cache-at-stack-overflow"><a href="#layers-of-cache-at-stack-overflow">Layers of Cache at Stack Overflow</a></h3>

<p>We have our own ‚ÄúL1‚Äù/‚ÄùL2‚Äù caches here at Stack Overflow, but I‚Äôll refrain from referring to them that way to avoid confusion with the CPU caches mentioned above.
What we have is several types of cache.
Let‚Äôs first quickly cover local and memory caches here for terminology before a deep dive into the common bits used by them:</p>

<ul>
  <li><strong>‚ÄúGlobal Cache‚Äù</strong>: In-memory cache (global, per web server, and backed by Redis on miss)
    <ul>
      <li>Usually things like a user‚Äôs top bar counts, shared across the network</li>
      <li>This hits local memory (shared keyspace), and then Redis (shared keyspace, using Redis database 0)</li>
    </ul>
  </li>
  <li><strong>‚ÄúSite Cache‚Äù</strong>: In-memory cache (per site, per web server, and backed by Redis on miss)
    <ul>
      <li>Usually things like question lists or user lists that are per-site</li>
      <li>This hits local memory (per-site keyspace, using prefixing), and then Redis (per-site keyspace, using Redis databases)</li>
    </ul>
  </li>
  <li><strong>‚ÄúLocal Cache‚Äù</strong>: In-memory cache (per site, per web server, backed by <em>nothing</em>)
    <ul>
      <li>Usually things that are cheap to fetch, but huge to stream and the Redis hop isn‚Äôt worth it</li>
      <li>This hits local memory only (per-site keyspace, using prefixing)</li>
    </ul>
  </li>
</ul>

<p>What do we mean by ‚Äúper-site‚Äù?
Stack Overflow and the Stack Exchange network of sites is <a href="https://nickcraver.com/blog/2016/02/17/stack-overflow-the-architecture-2016-edition/">a multi-tenant architecture</a>.
Stack Overflow is just one of <a href="https://stackexchange.com/sites#traffic">many hundreds of sites</a>.
This means one process on the web server hosts all the sites, so we need to split up the caching where needed.
And we‚Äôll have to purge it (<a href="#cache-invalidation">we‚Äôll cover how that works too</a>).</p>

<h3 id="redis"><a href="#redis">Redis</a></h3>

<p>Before we discuss how servers and shared cache work, let‚Äôs quickly cover what the shared bits are built on: Redis.
So what is <a href="https://redis.io/">Redis</a>?
It‚Äôs an open source key/value data store with many useful data structures, additional publish/subscriber mechanisms, and rock solid stability.</p>

<p>Why Redis and not <code>&lt;something else&gt;</code>?
Well, because it works. And it works well.
It seemed like a good idea when we needed a shared cache.
It‚Äôs been <em>incredibly</em> rock solid.
We don‚Äôt wait on it ‚Äì it‚Äôs incredibly fast.
We know how it works.
We‚Äôre very familiar with it.
We know how to monitor it.
We know how to spell it.
We maintain one of the most used open source libraries for it.
We can tweak that library if we need.</p>

<p>It‚Äôs a piece of infrastructure we <em>just don‚Äôt worry about</em>.
We basically take it for granted (though we still have an HA setup of replicas ‚Äì we‚Äôre not <em>completely</em> crazy).
When making infrastructure choices, you don‚Äôt just change things for perceived possible value.
Changing takes effort, takes time, and involves risk.
If what you have works well and does what you need, why invest that time and effort and take a risk?
Well‚Ä¶you don‚Äôt.
There are thousands of better things you can do with your time.
Like debating which cache server is best!</p>

<p>We have a few Redis instances to separate concerns of apps (but on the same set of servers), here‚Äôs an example of what one looks like:</p>

<p><a href="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-Opserver.png" target="_blank"><picture><source type="image/webp" srcset="/blog/content/SO-Caching/SO-Cache-Opserver.webp"><source type="image/png" srcset="/blog/content/SO-Caching/SO-Cache-Opserver.png"><img src="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-Opserver.png" loading="lazy" alt="Opserver: Redis View"></picture></a></p>

<p>For the curious, some quick stats from last Tuesday (2019-07-30) This is across all instances on the primary boxes (because we split them up for organization, not performance‚Ä¶one instance could handle everything we do quite easily):</p>
<ul>
  <li>Our Redis physical servers have 256GB of memory, but less than 96GB used.</li>
  <li>1,586,553,473 commands processed per day (3,726,580,897 commands and 86,982 per second peak across all instances ‚Äì due to replicas)</li>
  <li>Average of 2.01% CPU utilization (3.04% peak) for the entire server (&lt; 1% even for the most active instance)</li>
  <li>124,415,398 active keys (422,818,481 including replicas)</li>
  <li>Those numbers are across 308,065,226 HTTP hits (64,717,337 of which were question pages)</li>
</ul>

<p><sub>Note: None of these are Redis limited ‚Äì we‚Äôre far from any limits. It‚Äôs just how much activity there is on our instances.</sub></p>

<p>There are also non-cache reasons we use Redis, namely: we also use the pub/sub mechanism <a href="https://nickcraver.com/blog/2016/02/17/stack-overflow-the-architecture-2016-edition/#websockets-httpsgithubcomstackexchangenetgain">for our websockets</a> that provide realtime updates on scores, rep, etc.
Redis 5.0 <a href="https://redis.io/topics/streams-intro">added Streams</a> which is a perfect fit for our websockets and we‚Äôll likely migrate to them when some other infrastructure pieces are in place (mainly limited by Stack Overflow Enterprise‚Äôs version at the moment).</p>

<h4 id="in-memory--redis-cache"><a href="#in-memory--redis-cache">In-Memory &amp; Redis Cache</a></h4>

<p>Each of the above has an in-memory cache component and some have a backup in that lovely Redis server.</p>

<p>In-memory is simple enough, we‚Äôre just caching things in‚Ä¶ya know, memory.
In ASP.NET MVC 5, this used to be <a href="https://docs.microsoft.com/en-us/dotnet/api/system.web.httpruntime.cache?view=netframework-4.7.2"><code>HttpRuntime.Cache</code></a>.
These days, in preparation for our <a href="https://docs.microsoft.com/en-us/aspnet/core/">ASP.NET Core</a> move, we‚Äôve moved on to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.caching.memorycache"><code>MemoryCache</code></a>.
The differences are tiny and don‚Äôt matter much; both generally provide a way to cache an object for some duration of time.
That‚Äôs all we need here.</p>

<p>For the above caches, we choose a ‚Äúdatabase ID‚Äù.
These relate to the sites we have on the Stack Exchange Network and come from our <code>Sites</code> database table.
<a href="https://stackoverflow.com/">Stack Overflow</a> is 1, <a href="https://serverfault.com/">Server Fault</a> is 2, <a href="https://superuser.com/">Super User</a> is 3, etc.</p>

<p>For local cache, you could approach it a few ways.
Ours is simple: that ID is part of the cache key.
For Global Cache (shared), the ID is zero.
We further (for safety) prefix each cache to avoid conflicts with general key names from whatever else might be in these app-level caches. 
An example key would be:</p>
<div><div><pre><code>prod:1-related-questions:1234
</code></pre></div></div>

<p>That would be the related questions in the sidebar for Question 1234 on Stack Overflow (ID: 1).
If we‚Äôre <strong>only</strong> in-memory, serialization doesn‚Äôt matter and we can just cache any object.
However, if we‚Äôre sending that cache object somewhere (or getting one back from somewhere), we need to serialize it. And fast!
That‚Äôs where <a href="https://github.com/mgravell/protobuf-net">protobuf-net</a> written by our own <a href="https://twitter.com/marcgravell">Marc Gravell</a> comes in.
<a href="https://developers.google.com/protocol-buffers/docs/encoding">Protobuf</a> is a binary encoding format that‚Äôs tremendously efficient in both speed and allocations.
A simple object we want to cache may look like this:</p>

<div><div><pre><code><span>public</span> <span>class</span> <span>RelatedQuestionsCache</span>
<span>{</span>
    <span>public</span> <span>int</span> <span>Count</span> <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
    <span>public</span> <span>string</span> <span>Html</span> <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>With <a href="https://github.com/mgravell/protobuf-net#basic-usage">protobuf attributes</a> to control serialization, it looks like this:</p>

<div><div><pre><code><span>[</span><span>ProtoContract</span><span>]</span>
<span>public</span> <span>class</span> <span>RelatedQuestionsCache</span>
<span>{</span>
    <span>[</span><span>ProtoMember</span><span>(</span><span>1</span><span>)]</span> <span>public</span> <span>int</span> <span>Count</span> <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
    <span>[</span><span>ProtoMember</span><span>(</span><span>2</span><span>)]</span> <span>public</span> <span>string</span> <span>Html</span> <span>{</span> <span>get</span><span>;</span> <span>set</span><span>;</span> <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>So let‚Äôs say we want to cache that object in Site Cache. The flow looks like this (code simplified a bit):</p>

<div><div><pre><code><span>public</span> <span>T</span> <span>Get</span><span>&lt;</span><span>T</span><span>&gt;(</span><span>string</span> <span>key</span><span>)</span>
<span>{</span>
    <span>// Transform to the shared cache key format, e.g. "x" into "prod:1-x"</span>
    <span>var</span> <span>cacheKey</span> <span>=</span> <span>GetCacheKey</span><span>(</span><span>key</span><span>);</span>
    <span>// Do we have it in memory?</span>
    <span>var</span> <span>local</span> <span>=</span> <span>memoryCache</span><span>.</span><span>Get</span><span>&lt;</span><span>RedisWrapper</span><span>&gt;(</span><span>cacheKey</span><span>);</span>
    <span>if</span> <span>(</span><span>local</span> <span>!=</span> <span>null</span><span>)</span>
    <span>{</span>
        <span>// We've got it local - nothing more to do.</span>
        <span>return</span> <span>local</span><span>.</span><span>GetValue</span><span>&lt;</span><span>T</span><span>&gt;();</span>
    <span>}</span>
    <span>// Is Redis connected and readable? This makes Redis a fallback and not critical</span>
    <span>if</span> <span>(</span><span>redisCache</span><span>.</span><span>CanRead</span><span>(</span><span>cacheKey</span><span>))</span> <span>// Key is passed here for the case of Redis Cluster</span>
    <span>{</span>
    	<span>var</span> <span>remote</span> <span>=</span> <span>redisCache</span><span>.</span><span>StringGetWithExpiry</span><span>(</span><span>cacheKey</span><span>)</span>
        <span>if</span> <span>(</span><span>remote</span><span>.</span><span>Value</span> <span>!=</span> <span>null</span><span>)</span>
        <span>{</span>
            <span>// Get our shared construct for caching</span>
       	    <span>var</span> <span>wrapper</span> <span>=</span> <span>RedisWrapper</span><span>.</span><span>From</span><span>(</span><span>remote</span><span>);</span>
            <span>// Set it in our local memory cache so the next hit gets it faster</span>
            <span>memoryCache</span><span>.</span><span>Set</span><span>&lt;</span><span>RedisWrapper</span><span>&gt;(</span><span>key</span><span>,</span> <span>wrapper</span><span>,</span> <span>remote</span><span>.</span><span>Expiry</span><span>);</span>
            <span>// Return the value we found in Redis</span>
            <span>return</span> <span>remote</span><span>.</span><span>Value</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>// No value found, sad panda</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Granted, this code is greatly simplified to convey the point, but we‚Äôre not leaving anything important out.</p>

<p>Why a <code>RedisWrapper&lt;T&gt;</code>?
It synonymizes platform concepts by having a value with a TTL (time-to-live) with the value, just <a href="https://redis.io/commands/ttl">like Redis does</a>.
It also allows the caching of a <code>null</code> value and makes that handling not special-cased.
In other words, you can tell the difference between ‚ÄúIt‚Äôs not cached‚Äù and ‚ÄúWe looked it up. It was null. We cached that null. STOP ASKING!‚Äù
If you‚Äôre curious about <a href="https://github.com/StackExchange/StackExchange.Redis/blob/3f7e5466c6bbff96a3ed1130b637a097d21f3fed/src/StackExchange.Redis/Interfaces/IDatabase.cs#L1871"><code>StringGetWithExpiry</code>, it‚Äôs a StackExchange.Redis method</a> that returns the value and the <code>TTL</code> in one call by pipelining the commands (not 2 round-trip time costs).</p>

<p>A <code>Set&lt;T&gt;</code>&nbsp;for caching a value works exactly the same way:</p>

<ol>
  <li>Cache the value in memory.</li>
  <li>Cache the same value in Redis.</li>
  <li>(Optionally) Alert the other web servers that the value has been updated and instruct them to flush their copy.</li>
</ol>

<h4 id="pipelining"><a href="#pipelining">Pipelining</a></h4>

<p>I want to take a moment and relay a very important thing here: our Redis connections (via <code>StackExchange.Redis</code>) are pipelined.
Think of it like a conveyor belt you can stick something on and it goes somewhere and circles back.
You could stick thousands of things in a row on that conveyor belt before the first reaches the destination or comes back.
If you put a giant thing on there, it means you have to wait to add other things.</p>

<p>The items may be independent, but the conveyor belt is shared.
In our case, the conveyor belt is the connection and the items are commands.
If a large payload goes on or comes back, it occupies the belt for a bit.
This means if you‚Äôre waiting on a specific thing but some nasty big item clogs up he works for a second or two, it may cause collateral damage.
That‚Äôs a timeout.</p>

<p>We often see issues filed from people putting tremendous many-megabyte payloads into Redis with low timeouts, but that doesn‚Äôt work unless the pipe is very, very fast.
They don‚Äôt see the many-megabyte command timing out‚Ä¶they usually see things waiting <em>behind</em> it timing out.</p>

<p>It‚Äôs important to realize that a pipeline is just like any pipe outside a computer.
Whatever its narrowest constraint is, that‚Äôs where it‚Äôll bottleneck.
Except this is a dynamic pipe, more like a hose that can expand or bend or kink.
The bottlenecks are not 100% constant.
In practical terms, this can be <a href="https://docs.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool">thread pool</a> exhaustion (either feeding commands in or handling them coming out).
Or it may be network bandwidth.
And maybe something <em>else</em> is using that network bandwidth impacting us.</p>

<p>Remember that at these levels of latency, viewing things at 1Gb/s or 10Gb/s isn‚Äôt really using the correct unit of time.
For me, it helps to not think in terms of 1Gb/s, but instead in terms of 1Mb/ms.
If we‚Äôre traversing the network in about a millisecond or less, that payload really does matter and can increase the time taken by very measurable and impactful amounts.
That‚Äôs all to say: think small here.
The limits on any system when you‚Äôre dealing with short durations must be considered with relative constraints proportional to the same durations.
When we‚Äôre talking about milliseconds, the fact that we think of most computing concepts only down to the second is often a factor that confuses thinking and discussion.</p>

<h4 id="pipelining-retries"><a href="#pipelining-retries">Pipelining: Retries</a></h4>

<p>The pipelined nature is also why we can‚Äôt retry commands with any confidence.
In this sad world our conveyor belt has turned into the airport baggage pickup loopy thingamajig (<a href="https://www.merriam-webster.com/dictionary/thingamajig">also in the dictionary</a>, for the record) we all know and love.</p>

<p>You put an bag on the thingamajig.
The bag contains something important, probably some really fancy pants.
They‚Äôre going to someone who you wanted to impress.
(We‚Äôre using airport luggage as a very reasonably priced alternative to UPS in this scenario.)
But Mr. Fancy Pants is super nice and promised to return your bag.
So nice.
You did your part.
The bag went on the thingamajig and went out of sight‚Ä¶and never make it back.
Okay‚Ä¶<em>where</em> did it go?!?
We don‚Äôt know!
DAMN YOU BAG!</p>

<p>Maybe the bag made it to the lovely person and got lost on the return trip.
Or maybe it didn‚Äôt.
We still don‚Äôt know!
Should we send it again?
What if we‚Äôre sending them a second pair of fancy pants?
Will they think we think they spill ketchup a lot?
That‚Äôd be weird.
We don‚Äôt want to come on too strong.
And now we‚Äôre just confused and bagless.
So let‚Äôs talk about something that makes even less sense: cache invalidation.</p>

<h4 id="cache-invalidation"><a href="#cache-invalidation">Cache Invalidation</a></h4>

<p>I keep referring to purging above, so how‚Äôs that work?
Redis has <a href="https://redis.io/topics/pubsub">a pub/sub feature</a> where you can push a message out and subscribers all receive it (this message goes to all replicas as well).
Using this simple concept, we can simply have a cache clearing channel we <a href="https://redis.io/commands/subscribe"><code>SUBSCRIBE</code></a> to.
When we want to remove a value early (rather than waiting for TTLs to fall out naturally), we just <a href="https://redis.io/commands/publish"><code>PUBLISH</code></a> that key name to our channel and the listener (think event handler here) just purges the key from local cache.</p>

<p>The steps are:</p>

<ol>
  <li>Purge the value from Redis via <a href="https://redis.io/commands/del"><code>DEL</code></a> or <a href="https://redis.io/commands/unlink"><code>UNLINK</code></a>. Or, just replace the value with a new one‚Ä¶whatever state we‚Äôre after.</li>
  <li>Broadcast the key to the purge channel.</li>
</ol>

<p>Order is important, because reversing these would create a race and end up in a re-fetch of the old value sometimes.
Note that <strong>we‚Äôre not pushing the new value out</strong>.
That‚Äôs not the goal.
Maybe web servers 1‚Äì5 that had the value cache won‚Äôt even ask for it again this duration‚Ä¶so let‚Äôs not be over-eager and wasteful.
All we‚Äôre making them do is get it from Redis <em>if and when</em> it‚Äôs asked for.</p>

<h4 id="combining-everything-getset"><a href="#combining-everything-getset">Combining Everything: GetSet</a></h4>

<p>If you look at the above, you‚Äôd think we‚Äôre doing this a lot:</p>

<div><div><pre><code><span>var</span> <span>val</span> <span>=</span> <span>Current</span><span>.</span><span>SiteCache</span><span>.</span><span>Get</span><span>&lt;</span><span>string</span><span>&gt;(</span><span>key</span><span>);</span>
<span>if</span> <span>(</span><span>val</span> <span>==</span> <span>null</span><span>)</span>
<span>{</span>
    <span>val</span> <span>=</span> <span>FetchFromSource</span><span>();</span>
    <span>Current</span><span>.</span><span>SiteCache</span><span>.</span><span>Set</span><span>(</span><span>key</span><span>,</span> <span>val</span><span>,</span> <span>Timespan</span><span>.</span><span>FromSeconds</span><span>(</span><span>30</span><span>));</span>
<span>}</span>
<span>return</span> <span>val</span><span>;</span>
</code></pre></div></div>

<p>But here‚Äôs where we can greatly improve on things.
First, it‚Äôs repetitive. Ugh.
But more importantly, that code will result in hundreds of simultaneous calls to <code>FetchFromSource()</code> at scale when the cache expires.
What if that fetch is heavy?
Presumably it‚Äôs <em>somewhat</em>&nbsp;expensive, since we‚Äôve decided to cache it in the first place.
We need a better plan.</p>

<p>This is where our most common approach comes in: <code>GetSet&lt;T&gt;()</code>.
Okay, so naming is hard.
Let‚Äôs just agree everyone has regrets and move on.
What do we <em>really</em> want to do here?</p>

<ul>
  <li>Get a value if it‚Äôs there</li>
  <li>Calculate or fetch a value if it‚Äôs not there (and shove it in cache)</li>
  <li>Prevent calculating or fetching the same value many times</li>
  <li>Ensure users wait as little as possible</li>
</ul>

<p>We can use some attributes about who we are and what we do to optimize here.
Let‚Äôs say you load the web page now, or a second ago, or 3 seconds from now.
Does it matter?
Is the Stack Overflow question going to change that much?
The answer is: only if there‚Äôs anything to notice.
Maybe you made an upvote, or an edit, or a comment, etc.
These are things you‚Äôd notice.
We must refresh any caches that pertain to those kinds of activities <em>for you</em>.
But for any of hundreds of other users simultaneously loading that page, skews in data are imperceptible.</p>

<p>That means we have wiggle room. Let‚Äôs exploit that wiggle room for performance.</p>

<p>Here‚Äôs what <code>GetSet&lt;T&gt;</code> looks like today (yes, there‚Äôs an equivalent-ish <code>async</code>&nbsp;version):</p>

<div><div><pre><code><span>public</span> <span>static</span> <span>T</span> <span>GetSet</span><span>&lt;</span><span>T</span><span>&gt;(</span>
    <span>this</span> <span>ImmediateSiteCache</span> <span>cache</span><span>,</span>
    <span>string</span> <span>key</span><span>,</span>
    <span>Func</span><span>&lt;</span><span>T</span><span>,</span> <span>MicroContext</span><span>,</span> <span>T</span><span>&gt;</span> <span>lookup</span><span>,</span>
    <span>int</span> <span>durationSecs</span><span>,</span>
    <span>int</span> <span>serveStaleDataSecs</span><span>,</span>
    <span>GetSetFlags</span> <span>flags</span> <span>=</span> <span>GetSetFlags</span><span>.</span><span>None</span><span>,</span>
    <span>Server</span> <span>server</span> <span>=</span> <span>Server</span><span>.</span><span>PreferMaster</span><span>)</span>
</code></pre></div></div>

<p>The key arguments to this are <code>durationSecs</code> and <code>serveStaleDataSecs</code>.
A call often looks something like this (it‚Äôs a contrived example for simplicity of discussion):</p>

<div><div><pre><code><span>var</span> <span>lookup</span> <span>=</span> <span>Current</span><span>.</span><span>SiteCache</span><span>.</span><span>GetSet</span><span>&lt;</span><span>Dictionary</span><span>&lt;</span><span>int</span><span>,</span> <span>string</span><span>&gt;&gt;(</span><span>"User:DisplayNames"</span><span>,</span> 
   <span>(</span><span>old</span><span>,</span> <span>ctx</span><span>)</span> <span>=&gt;</span> <span>ctx</span><span>.</span><span>DB</span><span>.</span><span>Query</span><span>&lt;(</span><span>int</span> <span>Id</span><span>,</span> <span>string</span> <span>DisplayName</span><span>)&gt;(</span><span>"Select Id, DisplayName From Users"</span><span>)</span>
                       <span>.</span><span>ToDictionary</span><span>(</span><span>i</span> <span>=&gt;</span> <span>i</span><span>.</span><span>Id</span><span>),</span> 
    <span>60</span><span>,</span> <span>5</span><span>*</span><span>60</span><span>);</span>
</code></pre></div></div>

<p>This call goes to the <code>Users</code> table and caches an <code>Id</code>&nbsp;-&gt; <code>DisplayName</code> lookup (we don‚Äôt actually do this, I just needed a simple example).
The key part is the values at the end.
We‚Äôre saying ‚Äúcache for 60 seconds, but serve stale for 5 minutes‚Äù.</p>

<p>The behavior is that for 60 seconds, any hits against this cache only return it.
But we keep the value in memory (and Redis) for 6 minutes total.
In the time between 60 seconds and 6 minutes (from the time cached), we‚Äôll happily <em>still serve the value to users</em>.
But, we‚Äôll kick off a background refresh on another thread at the same time so future users get a fresh value. Rinse and repeat.</p>

<p>Another important detail here is we keep a per-server local lock table (a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2"><code>ConcurrentDictionary</code></a>) that prevents two calls from trying to run that <code>lookup</code> function and getting the value at the same time.
For example, there‚Äôs no win in querying the database 400 times for 400 users.
Users 2 though 400 are better off waiting on the first cache to complete and our database server isn‚Äôt kinda sorta murdered in the process.
Why a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2"><code>ConcurrentDictionary&lt;string, object&gt;</code></a>&nbsp;instead of say a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1"><code>HashSet&lt;string&gt;</code></a>?
Because we want to <code>lock</code> on the <code>object</code>&nbsp;in that dictionary for subsequent callers.
They‚Äôre all waiting on the same fetch and that <code>object</code>&nbsp;represents our fetch.</p>

<p>If you‚Äôre curious about that <code>MicroContext</code>, that goes back to being multi-tenant.
Since the fetch may happen on a background thread, we need to know what it was for.
Which site? Which database? What was the previous cache value?
Those are things we put on the context before passing it to the background thread for the <code>lookup</code> to grab a new value.
Passing the old value also lets us handle an error case as desired, e.g. logging the error and still returning the old value, because giving a user slightly out-of-date data is always always better than an error page.
We choose per call here though.
If returning the old value is bad for some reason ‚Äì just don‚Äôt do that.</p>

<h4 id="types-and-things"><a href="#types-and-things">Types and Things</a></h4>

<p>A question I often get is how do we use DTOs (<a href="https://en.wikipedia.org/wiki/Data_transfer_object">data transfer objects</a>)?
In short, we don‚Äôt.
We only use additional types and allocations <em>when we need to</em>.
For example, if we can run a <code>.Query&lt;MyType&gt;("Select...");</code> from Dapper and stick it into cache, we will.
There‚Äôs little reason to create <em>another</em> type just to cache.</p>

<p>If it makes sense to cache the type that‚Äôs 1:1 with a database table (e.g. <code>Post</code> for the <code>Posts</code> table, or <code>User</code> for the <code>Users</code> table), we‚Äôll cache that.
If there‚Äôs some subtype or combination of things that are the columns from a combined query, we‚Äôll just <code>.Query&lt;T&gt;</code> as that type, populating from those columns, and cache that.
If that still sounds abstract, here‚Äôs a more concrete example:</p>

<div><div><pre><code><span>[</span><span>ProtoContract</span><span>]</span>
<span>public</span> <span>class</span> <span>UserCounts</span>
<span>{</span>
    <span>[</span><span>ProtoMember</span><span>(</span><span>1</span><span>)]</span> <span>public</span> <span>int</span> <span>UserId</span> <span>{</span> <span>get</span><span>;</span> <span>}</span>
    <span>[</span><span>ProtoMember</span><span>(</span><span>2</span><span>)]</span> <span>public</span> <span>int</span> <span>PostCount</span> <span>{</span> <span>get</span><span>;</span> <span>}</span>
    <span>[</span><span>ProtoMember</span><span>(</span><span>3</span><span>)]</span> <span>public</span> <span>int</span> <span>CommentCount</span> <span>{</span> <span>get</span><span>;</span> <span>}</span>
<span>}</span>

<span>public</span> <span>Dictionary</span><span>&lt;</span><span>int</span><span>,</span> <span>UserCounts</span><span>&gt;</span> <span>GetUserCounts</span><span>()</span> <span>=&gt;</span>
    <span>Current</span><span>.</span><span>SiteCache</span><span>.</span><span>GetSet</span><span>&lt;</span><span>Dictionary</span><span>&lt;</span><span>int</span><span>,</span> <span>UserCounts</span><span>&gt;&gt;(</span><span>"All-User-Counts"</span><span>,</span> <span>(</span><span>old</span><span>,</span> <span>ctx</span><span>)</span> <span>=&gt;</span>
    <span>{</span>
        <span>try</span>
        <span>{</span>
            <span>return</span> <span>ctx</span><span>.</span><span>DB</span><span>.</span><span>Query</span><span>&lt;</span><span>UserCounts</span><span>&gt;(</span><span>@"
  Select u.Id UserId, PostCount, CommentCount
    From Users u
         Cross Apply (Select Count(*) PostCount From Posts p Where u.Id = p.OwnerUserId) p
         Cross Apply (Select Count(*) CommentCount From PostComments pc Where u.Id = pc.UserId) pc"</span><span>)</span>
                <span>.</span><span>ToDictionary</span><span>(</span><span>r</span> <span>=&gt;</span> <span>r</span><span>.</span><span>UserId</span><span>);</span>
        <span>}</span>
        <span>catch</span><span>(</span><span>Exception</span> <span>ex</span><span>)</span>
        <span>{</span>
            <span>Env</span><span>.</span><span>LogException</span><span>(</span><span>ex</span><span>);</span>
            <span>return</span> <span>old</span><span>;</span> <span>// Return the old value</span>
        <span>}</span>
    <span>},</span> <span>60</span><span>,</span> <span>5</span><span>*</span><span>60</span><span>);</span>
</code></pre></div></div>

<p>In this example we are taking advantage of <a href="https://github.com/StackExchange/Dapper"><code>Dapper</code></a>‚Äôs built-in column mapping. 
(Note that it sets <code>get</code>-only properties.)
The type used is just for this.
For example, it could even be <code>private</code>, and make this method take a <code>int userId</code> with the <code>Dictionary&lt;int, UserCount&gt;</code> being a method-internal detail.
We‚Äôre also showing how <code>T old</code> and the <code>MicroContext</code> are used here.
If an error occurs, we log it and return the previous value.</p>

<p>So‚Ä¶types. Yeah. We do whatever works.
Our philosophy is to not create a lot of types unless they‚Äôre useful.
DTOs generally don‚Äôt come with just the type, but also include a lot of mapping code ‚Äì or more magical code (e.g. reflection) that maps across and is subject to unintentional breaks down the line.
Keep. It. Simple. That‚Äôs all we‚Äôre doing here.
Simple <em>also</em> means fewer allocations and instantiations.
Performance is often the byproduct of simplicity.</p>

<h4 id="redis-the-good-types"><a href="#redis-the-good-types">Redis: The Good Types</a></h4>

<p>Redis has <a href="https://redis.io/topics/data-types">a variety of data types</a>.
All of the key/value examples thus far use ‚ÄúString‚Äù type in Redis.
But don‚Äôt think of this as a string data type like you‚Äôre used to in programming (for example, <code>string</code> <a href="https://docs.microsoft.com/en-us/dotnet/api/system.string?view=netcore-2.2">in .NET</a>, or <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html">in Java</a>).
It basically means ‚Äúsome bytes‚Äù in the Redis usage.
It could be a string, it could be a binary image, or it could be‚Ä¶well, anything you can store in some bytes!
But, we use most of the other data types in various ways as well:</p>

<ul>
  <li>Redis Lists are useful for queues like our aggregator or account actions to execute in-order.</li>
  <li>Redis Sets are useful for unique lists of items like ‚Äúwhich account IDs are in this alpha test?‚Äù (things that are unique, but not ordered).</li>
  <li>Redis Hashes are useful for things that are dictionary-like, such as ‚ÄúWhat‚Äôs the latest activity date for a site?‚Äù (where the hash key ID is site and the value is a date).
We use this to determine ‚ÄúDo we need to run badges on site X this time?‚Äù and other questions.</li>
  <li>Redis Sorted Sets are useful for ordered things like storing the slowest 100 MiniProfiler traces per route.</li>
</ul>

<p>Speaking of sorted sets, we need to replace the <a href="https://stackoverflow.com/users"><code>/users</code> page</a> to be backed by sorted sets (one per reputation time range) with range queries instead.
Marc and I planned how to do this at a company meetup in Denver many years ago but keep forgetting to do it‚Ä¶</p>

<h3 id="monitoring-cache-performance"><a href="#monitoring-cache-performance">Monitoring Cache Performance</a></h3>

<p>There are a few things to keep an eye on here.
Remember those latency factors above?
It‚Äôs super slow to go off box.
When we‚Äôre rendering question pages in an average of 18‚Äì20ms, taking ~0.5ms for a Redis call is a lot.
A few calls quickly add up to a significant part of our rendering time.</p>

<p>First, we‚Äôll want to keep an eye on this at the page level.
For this, we use <a href="https://miniprofiler.com/dotnet/">MiniProfiler</a> to see every Redis call involved in a page load.
It‚Äôs hooked up with <a href="https://stackexchange.github.io/StackExchange.Redis/Profiling_v2.html">StackExchange.Redis‚Äôs profiling API</a>.
Here‚Äôs an example of what that looks like on a question page, getting my live across-the-network counts for the top bar:</p>

<p><a href="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-MiniProfiler.png" target="_blank"><picture><source type="image/webp" srcset="/blog/content/SO-Caching/SO-Cache-MiniProfiler.webp"><source type="image/png" srcset="/blog/content/SO-Caching/SO-Cache-MiniProfiler.png"><img src="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-MiniProfiler.png" loading="lazy" alt="MiniProfiler: Redis Calls"></picture></a></p>

<p>Second, we want to keep an eye on the Redis instances.
For that, we use <a href="https://github.com/Opserver/Opserver">Opserver</a>.
Here‚Äôs what a single instance looks like:</p>

<p><a href="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-Opserver-Instance.png" target="_blank"><picture><source type="image/webp" srcset="/blog/content/SO-Caching/SO-Cache-Opserver-Instance.webp"><source type="image/png" srcset="/blog/content/SO-Caching/SO-Cache-Opserver-Instance.png"><img src="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-Opserver-Instance.png" loading="lazy" alt="Opserver: Redis Instance"></picture></a></p>

<p>We have some built-in tools there to analyze key usage and the ability to group them by regex pattern.
This lets us combine what we know (we‚Äôre the ones caching!) with the data to see what‚Äôs eating the most space.</p>

<p><sub>
Note: Running such an analysis should only be done on a secondary.
It‚Äôs very abusive on a master at scale.
Opserver will by default run such analysis on a replica and block running it on a master without an override.
</sub></p>

<h3 id="whats-next"><a href="#whats-next">What‚Äôs Next?</a></h3>

<p>.NET Core is well underway here at Stack.
We‚Äôve ported most support services and are working on the main applications now.
There‚Äôs honestly not a lot of cache to the caching layer, but one interesting possibility is <a href="https://github.com/dotnet/corefx/issues/30503"><code>Utf8String</code></a> (which hasn‚Äôt landed yet).
We cache a lot of stuff in total, lots of tiny strings in various places ‚Äì things like ‚ÄúRelated Questions‚Äù in the sidebar.
If those cache entries were UTF8 instead of <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/character-encoding">the .NET default of UTF16</a>, they‚Äôd be half the size.
When you‚Äôre dealing with hundreds of thousands of strings at any given time, it adds up.</p>

<h3 id="story-time"><a href="#story-time">Story Time</a></h3>

<p>I asked what people wanted to know about caching on Twitter and how failures happen came up a lot.
For fun, let‚Äôs recall a few that stand out in my mind:</p>

<h4 id="taking-redis-down-while-trying-to-save-it"><a href="#taking-redis-down-while-trying-to-save-it">Taking Redis Down While Trying to Save It</a></h4>

<p>At one point, our Redis primary cache was getting to be about 70GB total.
This was on 96GB servers.
When we saw the growth over time, we planned a server upgrade and transition.
By the time we got hardware in place and were ready to failover to a new master server, we had reached about 90GB of cache usage.
Phew, close. But we made it!</p>

<p>‚Ä¶or not. I was travelling for this one, but helped planned it all out.
What we didn‚Äôt account for was the memory fork that happens for a <code>BGSAVE</code> in Redis (at least in that version ‚Äì this was back in 2.x).
We were all very relieved to have made preparations in time, so on a weekend we hit the button and fired up data replication to the new server to prepare a failover to it.</p>

<p>And all of our websites promptly went offline.</p>

<p>What happens in the memory fork is that data that‚Äôs changed during the migration gets shadow copied, something that isn‚Äôt released until the clone finishes‚Ä¶because we need the state the server was at to initialize along with all changes since then to replicate to the new node (else we lose those new changes).
So the rate at which new changes rack up is your memory growth during a copy.
That 6GB went fast.
Really fast.
Then Redis crashed, the web servers went without Redis (something they hadn‚Äôt done in years), and they <em>really</em> didn‚Äôt handle it well.</p>

<p>So I pulled over on the side of the road, hopped on our team call, and we got the sites back up‚Ä¶against the new server and an empty cache.
It‚Äôs important to note that Redis didn‚Äôt do anything wrong, we did.
And Redis has been rock solid for a decade here.
It‚Äôs one of the most stable pieces of infrastructure we have‚Ä¶you just don‚Äôt think about it.</p>

<p>But anyway, another lesson learned.</p>

<h4 id="accidentally-not-using-local-cache"><a href="#accidentally-not-using-local-cache">Accidentally Not Using Local Cache</a></h4>

<p>A certain developer we have here will be reading this and cursing my name, but I love you guys and gals so let‚Äôs share anyway!</p>

<p>When we get a cache value back from Redis in our local/remote 2-layer cache story, we actually send two commands: a fetch of the key and a <a href="https://redis.io/commands/ttl"><code>TTL</code></a>.
The result of the TTL tells us how many seconds Redis is caching it for‚Ä¶that‚Äôs how long we also cache it in local server memory.
We used to use a <code>-1</code> sentinel value for TTL through some library code to indicate something didn‚Äôt have a TTL.
The semantics changed in a refactor to <code>null</code> for ‚Äúno TTL‚Äù‚Ä¶and we got some boolean logic wrong. Oops.
A rather simple statement like this from our <code>Get&lt;T&gt;</code> mentioned earlier:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>ttl</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>// ... push into L1</span>
</code></pre></div></div>

<p>Became:</p>
<div><div><pre><code><span>if</span> <span>(</span><span>ttl</span> <span>==</span> <span>null</span><span>)</span> <span>// ... push into L1</span>
</code></pre></div></div>

<p>But <em>most</em> of our caches <strong>DO</strong> have a TTL.
This meant the vast majority of keys (probably something like 95% or more) were no longer caching in L1 (local server memory).
Every single call to any of these keys was going to Redis and back.
Redis was so resilient and fast, we didn‚Äôt notice for a few hours.
The actual logic was then corrected to:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>ttl</span> <span>!=</span> <span>null</span><span>)</span> <span>// ... push into L1</span>
</code></pre></div></div>
<p>‚Ä¶and everyone lived happily ever after.</p>

<h4 id="accidentally-caching-pages-for-000006-seconds"><a href="#accidentally-caching-pages-for-000006-seconds">Accidentally Caching Pages For .000006 Seconds</a></h4>

<p>You read that right.</p>

<p>Back in 2011, we found a bit of code in our page-level output caching when looking into something unrelated:</p>
<div><div><pre><code><span>.</span><span>Duration</span> <span>=</span> <span>new</span> <span>TimeSpan</span><span>(</span><span>60</span><span>);</span>
</code></pre></div></div>
<p>This was intended to cache a thing for a minute.
Which would have worked great if the default constructor for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.timespan.-ctor?view=netframework-4.8#System_TimeSpan__ctor_System_Int64_"><code>TimeSpan</code> was seconds and not ticks</a>.
But! We were excited to find this.
How could cache be broken?
But hey, good news ‚Äì wow we‚Äôre going to get such a performance boost by fixing this!</p>

<p>Nope. Not even a little.
All we saw was memory usage increase a tiny bit.
CPU usage also went up.</p>

<p>For fun: this was included at the end of in an interview <a href="https://channel9.msdn.com/Events/Ch9Live/MIX11/C9L105">back at MIX 2011 with Scott Hanselman</a>.
Wow. We looked so much younger then.
Anyway, that leads us to‚Ä¶</p>

<h4 id="doing-more-harm-than-good"><a href="#doing-more-harm-than-good">Doing More Harm Than Good</a></h4>

<p>For many years, we used to <a href="https://docs.microsoft.com/en-us/aspnet/mvc/overview/older-versions-1/controllers-and-routing/improving-performance-with-output-caching-cs">output cache</a> major pages.
This included the homepage, question list pages, question pages themselves, and RSS feeds.</p>

<p>Remember earlier: when you cache, you need to vary the cache keys based on the variants of cache.
Concretely, this means: anonymous, or not? mobile, or not? deflate, gzip, or no compression?
Realistically, we can‚Äôt (or shouldn‚Äôt) ever output cache for logged-in users.
Your stats are in the top bar and it‚Äôs per-user.
You‚Äôd notice your rep was inconsistent between page views and such.</p>

<p>Anyway, when you step back and combine these variants with the fact that about 80% of all questions are visited every two weeks, you realize that the cache hit rate is low.
Really low.
But the cost of memory to store those strings (most large enough to go directly on the <a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap">large object heap</a>) is very non-trivial.
And the cost of the garbage collector cleaning them up is also non-trivial.</p>

<p>It turns out those two pieces of the equation are <em>so</em> non-trivial that caching did far more harm than good.
The savings we got from the relatively occasional cache hit were drastically outweighed by the cost of having and cleaning up the cache.
This puzzled us a bit at first, but when you zoom out and look at the numbers, it makes perfect sense.</p>

<p>For the past several years, Stack Overflow (and all Q&amp;A sites) output cache <em>nothing</em>.
Output caching is also not present in ASP.NET Core, so phew on not using it.</p>

<p>Full disclosure: we still cache full XML response strings (similar to, but not using output cache) specifically on some RSS feed routes.
We do so because the hit rate is quite high on these routes.
This specific cache has all of the downsides mentioned above, except it‚Äôs well worth it on the hit ratios.</p>

<h4 id="figuring-out-that-the-world-is-crazier-than-you-are"><a href="#figuring-out-that-the-world-is-crazier-than-you-are">Figuring Out That The World Is Crazier Than You Are</a></h4>

<p>When .NET 4.6.0 came out, we found a bug.
I was digging into why MiniProfiler didn‚Äôt show up on the first page load locally, slowly went insane, and then grabbed <a href="https://twitter.com/marcgravell">Marc Gravell</a> to go descend into madness with me.</p>

<p>The bug happened in our cache layer due to the nature of the issue and how it specifically affected only tail calls.
You can read about <a href="https://nickcraver.com/blog/2015/07/27/why-you-should-wait-on-dotnet-46/">how it manifested here</a>, but the general problem is: <strong>methods weren‚Äôt called with the parameters you passed in</strong>.
Ouch.
This resulted in random cache durations for us and was pretty scary when you think about it.
Luckily the problem with the RyuJIT was hotfixed the following month.</p>

<h4 id="net-462-caching-responses-for-2017-years"><a href="#net-462-caching-responses-for-2017-years">.NET 4.6.2 Caching Responses for 2,017 years</a></h4>

<p>Okay this one isn‚Äôt server-side caching at all, but I‚Äôm throwing it in because it was super ‚Äúfun‚Äù. 
Shortly after deploying .NET 4.6.2, we noticed some oddities with client cache behavior, CDN caches growing, and other crazy.
It turns out, <a href="https://twitter.com/nick_craver/status/850403727060107265">there was a bug in .NET 4.6.2</a>.</p>

<p>The cause was simple enough: when comparing the <code>DateTime</code> values of ‚Äúnow‚Äù vs. when a response cache should expire and calculating the difference between those to figure out the <code>max-age</code> portion of the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control"><code>Cache-Control</code> header</a>, the value was subtly reset to 0 on the ‚Äúnow‚Äù side.
So let‚Äôs say:</p>

<div><div><pre><code>2017-04-05 01:17:01 (cache until) - 2017-04-05 01:16:01 (now) = 60 seconds
</code></pre></div></div>

<p>Now, let‚Äôs say that ‚Äúnow‚Äù value was instead <code>0001-01-01 00:00:00</code>‚Ä¶</p>

<div><div><pre><code>2017-04-05 01:17:01 (cache until) - 0001-01-01 00:00:00 (now) = 63,626,951,821 seconds
</code></pre></div></div>

<p>Luckily the math is super easy.
We‚Äôre telling a browser to cache that value for 2017 years, 4 months, 5 days, 1 hour, 17 minutes and 1 second.
Which <em>might</em> be a tad bit of overkill.
Or on CDNs, we‚Äôre telling CDNs to cache things for that long‚Ä¶also problematic.</p>

<p><a href="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-Max-Age.jpg" target="_blank"><picture><source type="image/webp" srcset="/blog/content/SO-Caching/SO-Cache-Max-Age.webp"><source type="image/jpg" srcset="/blog/content/SO-Caching/SO-Cache-Max-Age.jpg"><img src="https://nickcraver.com/blog/content/SO-Caching/SO-Cache-Max-Age.jpg" alt="Oops: Max Age"></picture></a></p>

<p>Well crap. We didn‚Äôt realize this early enough. (Would you have checked for this? Are we idiots?)
So that was in production and a rollback was not a quick solution.
So what do we do?</p>

<p>Luckily, we had moved to Fastly at this point, <a href="https://docs.fastly.com/guides/vcl-tutorials/guide-to-vcl">which uses Varnish &amp; VCL</a>.
So we can just hop in there and detect these crazy <code>max-age</code> values and override them to something sane.
Unless, of course, you screw that up.
Yep.
Turns out on first push we missed a critical piece of the normal hash algorithm for cache keys on Fastly and did things like render people‚Äôs flair back when you tried to load a question.
This was corrected in a few minutes, but still: oops.
Sorry about that.
I reviewed and okayed that code to go out personally.</p>

<h4 id="when-its-sorta-redis-but-not"><a href="#when-its-sorta-redis-but-not">When It‚Äôs Sorta Redis But Not</a></h4>

<p>One issue we had was the host itself interrupting Redis and having perceptible pipeline timeouts.
We looked in Redis: the slowness was random.
The commands doing it didn‚Äôt form any pattern or make any sense (e.g. tiny keys).
We looked at the network and packet traces from both the client and server looked clean ‚Äì the pause was inside the Redis host based on the correlated timings.</p>

<p>Okay so‚Ä¶what is it?
Turns out after a lot of manual profiling and troubleshooting, we found <em>another</em> process on the host that spiked at the same time.
It was a small spike we thought nothing of at first, but <em>how</em> it spiked was important.</p>

<p>It turns out that a monitoring process (dammit!) was kicking off <a href="https://en.wikipedia.org/wiki/Vmstat"><code>vmstat</code></a> to get memory statistics.
Not that often, not that abusive ‚Äì it was actually pretty reasonable.
But what <code>vmstat</code> did was punt Redis off of the CPU core it was running on.
Like a jerk.
Sometimes. Randomly.
Which Redis instance? Well, that depends on the order they started in.
So yeah‚Ä¶this bug <em>seemed</em> to hop around.
The changing of context to another core was enough to see timeouts with how <em>often</em> we were hitting Redis with a constant pipe.</p>

<p>Once we found this and factored in that we have plenty of cores in these boxes, we began pinning Redis to specific cores on the physical hosts.
This ensures the primary function of the servers always has priority and monitoring is secondary.</p>

<p>Since writing this and asking for reviews, I learned that <a href="https://redis.io/topics/latency-monitor">Redis now has built-in latency monitoring</a> which was added shortly after the earlier 2.8 version we were using at the time. Check out <a href="https://redis.io/topics/latency-monitor#latency-doctor"><code>LATENCY DOCTOR</code></a> especially.
AWESOME.
Thank you Salvatore Sanfilippo! He‚Äôs the lovely <a href="https://twitter.com/antirez">@antirez</a>, author of Redis.</p>

<p>Now I need to go put the <code>LATENCY</code> bits into StackExchange.Redis and Opserver‚Ä¶</p>

<h3 id="caching-faq"><a href="#caching-faq">Caching FAQ</a></h3>

<p>I also often get a lot of questions that don‚Äôt really fit so well above, but I wanted to cover them for the curious.
And since you <em>know</em> we love Q&amp;A up in here, let‚Äôs try a new section in these posts that I can easily add to as new questions come up.</p>

<p><strong>Q</strong>: Why don‚Äôt you use <a href="https://redis.io/topics/cluster-tutorial">Redis Cluster</a>?<br>
<strong>A</strong>: There are a few reasons here:</p>
<ol>
  <li>We use <a href="https://redis.io/commands/select">databases</a>, which aren‚Äôt a feature in Cluster (to minimize the message replication header size). We can get around this by moving the database ID into the cache key instead (as we do with local cache above). But, one giant database has maintainability trade-offs, like when you go to figure out which keys are using so much room.</li>
  <li>The replication topology thus far has been node to node, meaning maintenance on the master cluster would require shifting the same topology on a secondary cluster in our DR data center. This would make maintenance harder instead of easier. We‚Äôre waiting for cluster &lt;-&gt; cluster replication, rather than node &lt;-&gt; node replication there.</li>
  <li>It would require 3+ nodes to run correctly (due to elections and such). We currently only run 2 physical Redis servers per data center. Just 1 server is way more performance than we need, and the second is a replica/backup.</li>
</ol>

<p><strong>Q</strong>: Why don‚Äôt you use <a href="https://redis.io/topics/sentinel">Redis Sentinel</a>?<br>
<strong>A</strong>: We looked into this, but the overall management of it wasn‚Äôt any simpler than we had today.
The idea of connecting to an endpoint and being directed over is great, but the management is complicated enough that it‚Äôs not worth changing our current strategy given how incredibly stable Redis is.
One of the biggest issues with Sentinel is the writing of the current topology state <a href="https://groups.google.com/forum/#!searchin/redis-db/puppet$20cluster%7Csort:date/redis-db/1JB7OkaaxZo/w1bAZ23dAgAJ">into the same config file</a>.
This makes it very unfriendly to anyone with managed configs. For example, we use <a href="https://puppet.com/">Puppet</a> here and the file changes would fight with it every run.</p>

<p><strong>Q</strong>: How do you secure <a href="https://stackoverflow.com/teams">Stack Overflow for Teams</a> cache?<br>
<strong>A</strong>: We maintain an isolated network and separate Redis servers for private data.
<a href="https://stackoverflow.com/enterprise">Stack Overflow Enterprise</a> customers each have their own isolated network and Redis instances as well.</p>

<p><strong>Q</strong>: What if Redis goes down?!?1!eleven<br>
<strong>A</strong>: First, there‚Äôs a backup in the data center.
But let‚Äôs assume that fails too!
Who doesn‚Äôt love a good apocalypse? 
Without Redis at all, we‚Äôd limp a bit when restarting the apps.
The cold cache would hurt a bit, smack SQL Server around a little, but we‚Äôd get back up.
You‚Äôd want to build slowly if Redis was down (or just hold off on building in general in this scenario).
As for the data, we would lose very little.
We have treated Redis as optional for local development since before the days it was an infrastructure component at all, and it remains optional today.
This means it‚Äôs not the source of truth for <em>anything</em>.
All cache data it contains could be re-populated from whatever the source is.
That leaves us only with active queues.
The queues in Redis are account merge type actions (executed sub-second ‚Äì so a short queue), the aggregator (tallying network events into our central database), and some analytics (it‚Äôs okay if we lose some A/B test data for a minute).
All of these are okay to have a gap on ‚Äì it‚Äôd be minimal loses.</p>

<p><strong>Q</strong>: Are there downsides to databases?<br>
<strong>A</strong>: Yes, one that I‚Äôm aware of.
At a high limit, it can eventually impact performance by measurable amounts.
When Redis expires keys, it loops over databases to find and clear those keys ‚Äì think of it as checking each ‚Äúnamespace‚Äù.
At a high count, it‚Äôs a bigger loop.
Since this runs every 100ms, that number being big can impact performance.</p>

<p><strong>Q</strong>: Are you going to open source the ‚ÄúL1‚Äù/‚ÄùL2‚Äù cache implementation?<br>
<strong>A</strong>: We‚Äôve always wanted to, but a few things have stood in the way:</p>
<ol>
  <li>It‚Äôs very ‚Äúus‚Äù. By that I mean it‚Äôs very multi-tenant focused and that‚Äôs probably not the best API surface for everyone. This means we really need to sit down and design that API. It‚Äôs a set of APIs we‚Äôd love to put into our <a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis client</a> directly or as another library that uses it.</li>
  <li>There has been an idea to have more core support (e.g. what we use the pub/sub mechanism for) in Redis server itself. That‚Äôs <a href="http://antirez.com/news/130">coming in Redis version 6</a>, so we can do a lot less custom pub/sub and use more standard things other clients will understand there. The less we write for ‚Äújust us‚Äù or ‚Äújust our client‚Äù, the better it is for everyone.</li>
  <li>Time. I wish we all had more of it. It‚Äôs the most precious thing you have ‚Äì never take it for granted.</li>
</ol>

<p><strong>Q</strong>: With pipelining, how do you handle large Redis payloads?<br>
<strong>A</strong>: We have a separate connection called ‚Äúbulky‚Äù for this.
It has higher timeouts and is much more rarely used.
That‚Äôs <em>if</em> it should go in Redis.
If a worth-of-caching item is large but not particularly expensive to fetch, we may not use Redis and simply use ‚ÄúLocal Cache‚Äù, fetching it <code>n</code> times for <code>n</code> web servers.
Per-user features (since user sessions are sticky to web servers on Q&amp;A) may fit this bill as well.</p>

<p><strong>Q</strong>: What happens when someone runs <a href="https://redis.io/commands/keys"><code>KEYS</code></a> on production?<br>
<strong>A</strong>: Tasers, if they‚Äôll let me.
Seriously though, since Redis 2.8.0 you should at least use <a href="https://redis.io/commands/scan"><code>SCAN</code></a> which doesn‚Äôt block Redis for a full key dump ‚Äì it does so in chunks and lets other commands go through.
<code>KEYS</code> can cause a production blockage in a hurry.
And by ‚Äúcan‚Äù, I mean 100% of the time at our scale.</p>

<p><strong>Q</strong>: What happens when someone runs <a href="https://redis.io/commands/flushall"><code>FLUSHALL</code></a> on production?<br>
<strong>A</strong>: It‚Äôs against policy to comment on future criminal investigations.
<a href="https://redis.io/topics/acl">Redis 6 is adding ACLs though</a>, which will limit the suspect pool.</p>

<p><strong>Q</strong>: How do the police investigators figure out what happened in either of the above cases? Or any latency spike?<br>
<strong>A</strong>: Redis has a nifty feature called <a href="https://redis.io/commands/slowlog"><code>SLOWLOG</code></a> which (by default) logs every command over 10ms in duration.
You can adjust this, but everything should be <em>very</em> fast, so that default 10ms is a relative eternity and what we keep it at.
When you run <code>SLOWLOG</code> you can see the last <code>n</code> entries (configurable), the command, and the arguments.
Opserver will show these on the instance page, making it easy to find the offender.
But, it could be network latency or an unrelated CPU spike/theft on the host. (We pin the Redis instances using processor affinity to avoid this.)</p>

<p><strong>Q</strong>: Do you use <a href="https://azure.microsoft.com/en-us/services/cache/">Azure Cache for Redis</a> for <a href="https://stackoverflow.com/enterprise">Stack Overflow Enterprise</a>?<br>
<strong>A</strong>: Yes, but we may not long-term.
It takes <a href="https://feedback.azure.com/forums/169382-cache/suggestions/7049852-work-on-creation-time-of-redis-cache">a surprisingly long time</a> to provision when creating one for test environments and such.
We‚Äôre talking dozens of minutes up to an hour here.
We‚Äôll likely use containers later, which will help us control the version used across all deployment modes as well.</p>

<p><strong>Q</strong>: Do you expect every dev to know all of this to make caching decisions?<br>
<strong>A</strong>: Absolutely not.
I had to look up exact values in many places here. 
My goal is that developers understand a little bit about the layer beneath and relative costs of things ‚Äì or at least a rough idea of them.
That‚Äôs why I stress the orders of magnitude here.
Those are the units you should be considering for cost/benefit evaluations on where and how you choose to cache.
Most people do not run at hundreds of millions of hits a day where the cost multiplier is so high it‚Äôll ruin your day and optimizations decisions are far less important/impactful.
Do what works for you. This is what works for us, with some context on ‚Äúwhy?‚Äù in hopes that it helps you make your decisions.</p>

<h3 id="tools"><a href="#tools">Tools</a></h3>

<p>I just wanted to provide a handy list of the tools mentioned in the article as well as a few other bits we use to help with caching:</p>

<ul>
  <li><a href="https://github.com/StackExchange/StackExchange.Redis">StackExchange.Redis</a> - Our open source .NET Redis client library.</li>
  <li><a href="https://github.com/Opserver/Opserver">Opserver</a> - Our open source dashboard for monitoring, including Redis.</li>
  <li><a href="https://github.com/MiniProfiler/dotnet/">MiniProfiler</a> - Our open source .NET profiling tool, with which we view Redis commands issued on any page load.</li>
  <li><a href="https://github.com/StackExchange/Dapper">Dapper</a> - Our open source object relational mapper for any ADO.NET data source.</li>
  <li><a href="https://github.com/mgravell/protobuf-net">protobuf-net</a> - <a href="https://twitter.com/marcgravell">Marc Gravell</a>‚Äôs Protocol Buffers library for idiomatic .NET.</li>
</ul>

<p>What‚Äôs next?
The way <a href="https://nickcraver.com/blog/2016/02/03/stack-overflow-a-technical-deconstruction/">this series</a> works is I blog in order of what the community wants to know about most.
I normally go by <a href="https://trello.com/b/0zgQjktX/blog-post-queue-for-stack-overflow-topics">the Trello board</a> to see what‚Äôs next, but we probably have a queue jumper coming up.
We‚Äôre almost done porting Stack Overflow to .NET Core and we have a lot of stories and tips to share as well as tools we‚Äôve built to make that migration easier.
The next time you see a lot of words from me may be the next Trello board item, or it may be .NET Core.
If you have questions that you want to see answered in such a post, please put them <a href="https://trello.com/c/fpwHYK97/90-the-move-to-net-core">on the .NET Core card</a> (open to the public) and I‚Äôll be reviewing all of that when I start writing it.
Stay tuned, and thanks for following along.</p>

          </article>
          
          
          
        </div>
        </main>
      </div>
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>

</body>
</html>