<!DOCTYPE html>
<html lang="en">
<head>
    <title>
a solution that allows us to not have to write 6500 different delegates &amp; overloads &#xB7; Issue #2668 &#xB7; dotnet/csharplang &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>a solution that allows us to not have to write 6500 different delegates &amp; overloads · Issue #2668 · dotnet/csharplang · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>In Unity's new DOTS C# high performance game engine, we support this syntax to allow users to tell the system they want to run an data transformation on all entities that have a Position component and a Velocity component.</p><pre><code> EntitiesForEach
      .WithBurst(true)
      .WithSupportStructuralChanges(false)
      .WithName("ApplyVelocities")
      .WithCode((ref Position position, in Velocity velocity) =&gt;
        {
           position.Value += velocity.Value;
        });
</code></pre><p>Our buildsystem recognizes this pattern, and does some IL postprocessing, by virtue of understanding the users intent.</p><p>Notice that the lambda expression that WithCode() takes, has one ref and one in parameter.<br>This makes the jobsystem that runs these transformations realize it can schedule this transormation in parallel with other readers of Velocity component, but not in parallel with other transformations that need to access Position, since that will be written to, as it's marked ref, not in.</p><p>We need WithCode() to be able to take any amount of parameters ideally,  but defenitely not less than 8.   We also would like to give the user full freedom to mark each parameter as ref, in, or by value.    In order to let users write code like this, we today have to create custom delegates like this:</p><pre><code>public delegate void RRR&lt;T0, T1, T2&gt;(ref T0 t0, ref T1 t1, ref T2 t2);
public delegate void RRI&lt;T0, T1, T2&gt;(ref T0 t0, ref T1 t1, in T2 t2);
public delegate void RRV&lt;T0, T1, T2&gt;(ref T0 t0, ref T1 t1, T2 t2);
public delegate void RIR&lt;T0, T1, T2&gt;(ref T0 t0, in T1 t1, ref T2 t2);
public delegate void RII&lt;T0, T1, T2&gt;(ref T0 t0, in T1 t1, in T2 t2);
public delegate void RIV&lt;T0, T1, T2&gt;(ref T0 t0, in T1 t1, T2 t2);
public delegate void RVR&lt;T0, T1, T2&gt;(ref T0 t0, T1 t1, ref T2 t2);
public delegate void RVI&lt;T0, T1, T2&gt;(ref T0 t0, T1 t1, in T2 t2);
public delegate void RVV&lt;T0, T1, T2&gt;(ref T0 t0, T1 t1, T2 t2);
public delegate void IRR&lt;T0, T1, T2&gt;(in T0 t0, ref T1 t1, ref T2 t2);
public delegate void IRI&lt;T0, T1, T2&gt;(in T0 t0, ref T1 t1, in T2 t2);
public delegate void IRV&lt;T0, T1, T2&gt;(in T0 t0, ref T1 t1, T2 t2);
public delegate void IIR&lt;T0, T1, T2&gt;(in T0 t0, in T1 t1, ref T2 t2);
public delegate void III&lt;T0, T1, T2&gt;(in T0 t0, in T1 t1, in T2 t2);
public delegate void IIV&lt;T0, T1, T2&gt;(in T0 t0, in T1 t1, T2 t2);
public delegate void IVR&lt;T0, T1, T2&gt;(in T0 t0, T1 t1, ref T2 t2);
public delegate void IVI&lt;T0, T1, T2&gt;(in T0 t0, T1 t1, in T2 t2);
public delegate void IVV&lt;T0, T1, T2&gt;(in T0 t0, T1 t1, T2 t2);
</code></pre><p>there are 6500 more where those came from.  I've put them up here for reference: <a rel="nofollow" href="https://gist.github.com/lucasmeijer/e7e7c6ae10ef78adaae9b505ca615470">https://gist.github.com/lucasmeijer/e7e7c6ae10ef78adaae9b505ca615470</a></p><p>for each delegate, we need to make a custom overload of the WithCode() function.</p><p>It would be great if we wouldn't have to do that.  It makes visualstudio slow, resharper slow, horrible for docs, etc.</p><p>One possible solution that comes to mind is having some kind of special delegate type that any lambda expression is allowed to be assigned to.  It's fine for our purposes if that instances of that delegate type are not invokable.  We just need the syntax to be valid.</p><p>We'd happily welcome any other ideas, from language features to anything else.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>