<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Use dependency injection in .NET Azure Functions -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Use dependency injection in .NET Azure Functions</h1><div><div id="main" class="content "><p>Azure Functions supports the dependency injection (DI) software design pattern, which is a technique to achieve <a href="https://docs.microsoft.com/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#dependency-inversion" data-linktype="external">Inversion of Control (IoC)</a> between classes and their dependencies.</p><ul><li><p>Dependency injection in Azure Functions is built on the .NET Core Dependency Injection features. Familiarity with the <a href="https://docs.microsoft.com/aspnet/core/fundamentals/dependency-injection" data-linktype="external">.NET Core dependency injection</a> is recommended. There are differences, however, in how you override dependencies and how configuration values are read with Azure Functions on the Consumption plan.</p></li><li><p>Support for dependency injection begins with Azure Functions 2.x.</p></li></ul><h2 id="prerequisites">Prerequisites</h2><p>Before you can use dependency injection, you must install the following NuGet packages:</p><h2 id="register-services">Register services</h2><p>To register services, create a method to configure and add components to an <code>IFunctionsHostBuilder</code> instance.  The Azure Functions host creates an instance of <code>IFunctionsHostBuilder</code> and passes it directly into your method.</p><p>To register the method, add the <code>FunctionsStartup</code> assembly attribute that specifies the type name used during startup.</p><pre><code class="lang-csharp">using System;
using Microsoft.Azure.Functions.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Http;
using Microsoft.Extensions.Logging;

[assembly: FunctionsStartup(typeof(MyNamespace.Startup))]

namespace MyNamespace
{
    public class Startup : FunctionsStartup
    {
        public override void Configure(IFunctionsHostBuilder builder)
        {
            builder.Services.AddHttpClient();

            builder.Services.AddSingleton((s) =&gt; {
                return new MyService();
            });

            builder.Services.AddSingleton&lt;ILoggerProvider, MyLoggerProvider&gt;();
        }
    }
}
</code></pre><h3 id="caveats">Caveats</h3><p>A series of registration steps run before and after the runtime processes the startup class. Therefore, keep in mind the following items:</p><ul><li><p><em>The startup class is meant for only setup and registration.</em> Avoid using services registered at startup during the startup process. For instance, don't try to log a message in a logger that is being registered during startup. This point of the registration process is too early for your services to be available for use. After the <code>Configure</code> method is run, the Functions runtime continues to register additional dependencies, which can affect how your services operate.</p></li><li><p><em>The dependency injection container only holds explicitly registered types</em>. The only services available as injectable types are what are setup in the <code>Configure</code> method. As a result, Functions-specific types like <code>BindingContext</code> and <code>ExecutionContext</code> aren't available during setup or as injectable types.</p></li></ul><h2 id="use-injected-dependencies">Use injected dependencies</h2><p>Constructor injection is used to make your dependencies available in a function. The use of constructor injection requires that you do not use static classes.</p><p>The following sample demonstrates how the <code>IMyService</code> and <code>HttpClient</code> dependencies are injected into an HTTP-triggered function. This example uses the <a href="https://www.nuget.org/packages/Microsoft.Extensions.Http/" data-linktype="external">Microsoft.Extensions.Http</a> package required to register an <code>HttpClient</code> at startup.</p><pre><code class="lang-csharp">using System;
using System.IO;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;

namespace MyNamespace
{
    public class HttpTrigger
    {
        private readonly IMyService _service;
        private readonly HttpClient _client;

        public HttpTrigger(IMyService service, IHttpClientFactory httpClientFactory)
        {
            _service = service;
            _client = httpClientFactory.CreateClient();
        }

        [FunctionName("GetPosts")]
        public async Task&lt;IActionResult&gt; Get(
            [HttpTrigger(AuthorizationLevel.Function, "get", Route = "posts")] HttpRequest req,
            ILogger log)
        {
            log.LogInformation("C# HTTP trigger function processed a request.");
            var res = await _client.GetAsync("https://microsoft.com");
            await _service.AddResponse(res);

            return new OkResult();
        }
    }
}
</code></pre><h2 id="service-lifetimes">Service lifetimes</h2><p>Azure Functions apps provide the same service lifetimes as <a href="https://docs.microsoft.com/aspnet/core/fundamentals/dependency-injection#service-lifetimes" data-linktype="external">ASP.NET Dependency Injection</a>. For a Functions app, the different service lifetimes behave as follows:</p><ul><li><strong>Transient</strong>: Transient services are created upon each request of the service.</li><li><strong>Scoped</strong>: The scoped service lifetime matches a function execution lifetime. Scoped services are created once per execution. Later requests for that service during the execution reuse the existing service instance.</li><li><strong>Singleton</strong>: The singleton service lifetime matches the host lifetime and is reused across function executions on that instance. Singleton lifetime services are recommended for connections and clients, for example <code>SqlConnection</code> or <code>HttpClient</code> instances.</li></ul><p>View or download a <a href="https://aka.ms/functions/di-sample" data-linktype="external">sample of different service lifetimes</a> on GitHub.</p><h2 id="logging-services">Logging services</h2><p>If you need your own logging provider, register a custom type as an <code>ILoggerProvider</code> instance. Application Insights is added by Azure Functions automatically.</p><div class="WARNING"><p>Warning</p><ul><li>Do not add <code>AddApplicationInsightsTelemetry()</code> to the services collection as it registers services that conflict with services provided by the environment.</li><li>Do not register your own <code>TelemetryConfiguration</code> or <code>TelemetryClient</code> if you are using the built-in Application Insights functionality.</li></ul></div><h2 id="function-app-provided-services">Function app provided services</h2><p>The function host registers many services. The following services are safe to take as a dependency in your application:</p><table><thead><tr><th>Service Type</th><th>Lifetime</th><th>Description</th></tr></thead><tbody><tr><td><code>Microsoft.Extensions.Configuration.IConfiguration</code></td><td>Singleton</td><td>Runtime configuration</td></tr><tr><td><code>Microsoft.Azure.WebJobs.Host.Executors.IHostIdProvider</code></td><td>Singleton</td><td>Responsible for providing the ID of the host instance</td></tr></tbody></table><p>If there are other services you want to take a dependency on, <a href="https://github.com/azure/azure-functions-host" data-linktype="external">create an issue and propose them on GitHub</a>.</p><h3 id="overriding-host-services">Overriding host services</h3><p>Overriding services provided by the host is currently not supported.  If there are services you want to override, <a href="https://github.com/azure/azure-functions-host" data-linktype="external">create an issue and propose them on GitHub</a>.</p><h2 id="working-with-options-and-settings">Working with options and settings</h2><p>Values defined in <a href="functions-how-to-use-azure-function-app-settings#settings" data-linktype="relative-path">app settings</a> are available in an <code>IConfiguration</code> instance, which allows you to read app settings values in the startup class.</p><p>You can extract values from the <code>IConfiguration</code> instance into a custom type. Copying the app settings values to a custom type makes it easy test your services by making these values injectable. Settings read into the configuration instance must be simple key/value pairs.</p><p>Consider the following class that includes a property named consistent with an app setting:</p><pre><code class="lang-csharp">public class MyOptions
{
    public string MyCustomSetting { get; set; }
}
</code></pre><p>And a <code>local.settings.json</code> file that might structure the custom setting as follows:</p><pre><code class="lang-json">{
  "IsEncrypted": false,
  "Values": {
    "MyOptions:MyCustomSetting": "Foobar"
  }
}
</code></pre><p>From inside the <code>Startup.Configure</code> method, you can extract values from the <code>IConfiguration</code> instance into your custom type using the following code:</p><pre><code class="lang-csharp">builder.Services.AddOptions&lt;MyOptions&gt;()
                .Configure&lt;IConfiguration&gt;((settings, configuration) =&gt;
                                           {
                                                configuration.GetSection("MyOptions").Bind(settings);
                                           });
</code></pre><p>Calling <code>Bind</code> copies values that have matching property names from the configuration into the custom instance. The options instance is now available in the IoC container to inject into a function.</p><p>The options object is injected into the function as an instance of the generic <code>IOptions</code> interface. Use the <code>Value</code> property to access the values found in your configuration.</p><pre><code class="lang-csharp">using System;
using Microsoft.Extensions.Options;

public class HttpTrigger
{
    private readonly MyOptions _settings;

    public HttpTrigger(IOptions&lt;MyOptions&gt; options)
    {
        _settings = options.Value;
    }
}
</code></pre><p>Refer to <a href="https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options" data-linktype="external">Options pattern in ASP.NET Core</a> for more details regarding working with options.</p><div class="WARNING"><p>Warning</p><p>Avoid attempting to read values from files like <em>local.settings.json</em> or <em>appsettings.{environment}.json</em> on the Consumption plan. Values read from these files related to trigger connections aren't available as the app scales because the hosting infrastructure has no access to the configuration information.</p></div><h2 id="next-steps">Next steps</h2><p>For more information, see the following resources:</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>