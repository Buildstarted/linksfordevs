<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Is it better to &quot;!= 0&#x201D; or &#x201D;== mask&#x201D; when working with enums (C#, RyuJIT) -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Is it better to "!= 0‚Äù or ‚Äù== mask‚Äù when working with enums (C#, RyuJIT)</h1><div><div id="" class=""><h3>Is it better to "!= 0‚Äù or ‚Äù== mask‚Äù when working with enums (C#, RyuJIT) <a href="/id/233785" rel="bookmark nofollow" title="Permalink"><span class="fa fa-link" aria-label="Permalink"></span></a></h3><p class="meta"><span class="fa fa-calendar" aria-label="Published"></span> 20 May 2019
	<span class="divider"></span><span class="fa fa-tags" aria-label="Tags"></span> .NET Core, JIT, RyuJIT
</p><p>First thing first, I know there‚Äôs an <a href="https://docs.microsoft.com/en-us/dotnet/api/system.enum.hasflag"><code>Enum.HasFlag</code> method</a>, yet I‚Äôm not interested in it (or optimizations around it). What I like to know is whether one of these two ways ‚Äì <code>(EnumValue &amp; mask) != 0</code> and <code>(EnumValue &amp; mask) == mask</code> ‚Äì to check for a (<strong>single value</strong>) flag in an enum is better.</p><p>I‚Äôm writing <em>better</em>, because I don‚Äôt want to say faster, as other aspects of such primitive operation might affect the overall result (like code size, register usage, etc.).</p><h4>Hypothesis</h4><p>My guess is that the "!= 0‚Äù is going be the winner, because computers are good doing stuff around value zero (like <code>jnz</code> instruction).</p><h4>Code</h4><p>In all the code following, I‚Äôll be using this enum I aptly named <code>MyEnum</code>. Nothing special.</p><pre><code class="language-csharp">[Flags]
public enum MyEnum
{
    None = 0,
    A = 0x01,
    B = 0x02,
    C = 0x04,
    D = 0x08,
}
</code></pre><p>And two simple methods (with x64/AMD64 assembly right below each).</p><pre><code class="language-csharp">public bool A(MyEnum myEnum)
{
    return (myEnum &amp; MyEnum.B) == MyEnum.B;
}
</code></pre><pre><code class="language-asm">test dl, 0x2
setnz al
movzx eax, al
ret
</code></pre><pre><code class="language-csharp">public bool B(MyEnum myEnum)
{
    return (myEnum &amp; MyEnum.B) != 0;
}
</code></pre><pre><code class="language-asm">test dl, 0x2
setnz al
movzx eax, al
ret
</code></pre><p>Surprisingly both result in exactly the same assembly produced by 64-bit RyuJIT (on .NET Core 2.2.4). Although, it kind of makes sense, both are doing the same. I also learned about <code>setnz</code> and <code>movzx</code> instructions (the <code>movzx</code> strictly speaking is the for returning the value, not for the compare) along the way, as I wasn‚Äôt familiar with these.</p><p>I could stop here and say that both are the same and use whatever I feel like using given the circumstances. But I like to look under.</p><h4>Where‚Äôs the magic happening in RyuJIT</h4><p>I‚Äôm nowhere familiar of internals of RyuJIT, thus I had no idea where is this happening. Time for little thinking. I‚Äôm working with enums, but enums are just numbers, hence maybe the same behavior works for numbers too. That way I know whether to keep <em>grepping</em> for something around enums or look for something more general.</p><p>Sadly doing <code>(value &amp; 0x02) == 0x02</code> and <code>(value &amp; 0x02) != 0</code> (where <code>value</code> is plain <code>int</code>) shows same behavior. I‚Äôll spare you my two hours of semi-methodically (read randomly üòÉ) walking through the RyuJIT‚Äôs code and I‚Äôll jump right into the action.</p><p>The first magic happens in <code>Lowering::OptimizeConstCompare</code>, where <a href="https://github.com/dotnet/coreclr/blob/c5a44f58952c5014f5e1c25b667dca3901fd84a7/src/jit/lower.cpp#L2644">the ‚Äúcompare and‚Äù is transformed into ‚Äútest‚Äù</a> and even <a href="https://github.com/dotnet/coreclr/blob/c5a44f58952c5014f5e1c25b667dca3901fd84a7/src/jit/lower.cpp#L2653-L2654">‚Äúinventing‚Äù the <code>0</code> comparison if possible</a>. That covers transforming ‚Äù== mask‚Äù into "!= 0‚Äù. The other part of the puzzle can be found in <a href="https://github.com/dotnet/coreclr/blob/c5a44f58952c5014f5e1c25b667dca3901fd84a7/src/jit/codegenxarch.cpp#L6351-L6352">the code generation itself</a>. The <code>test reg, reg</code> instruction is shorter than doing <code>cmp reg, 0</code>. And although the saving is not huge (1 byte), if you‚Äôre writing JIT, every byte and CPU cycle more than counts.</p><p>Moreover, as I was researching, I learned about <a href="https://en.wikichip.org/wiki/macro-operation_fusion">macro-fusing instructions</a> in certain architectures and <code>test</code> can (i.e. Intel Core 2, Intel Nehalem, ‚Ä¶) macro-fuse with more conditional jump instructions, compared to <code>cmp</code>.</p><h4>Real world usage</h4><p>Above I said, that both are the same. But carefully looking into <code>Lowering::OptimizeConstCompare</code> at <a href="https://github.com/dotnet/coreclr/blob/c5a44f58952c5014f5e1c25b667dca3901fd84a7/src/jit/lower.cpp#L2657">this line</a>, one can see the <code>0</code> comparison is ‚Äúinvented‚Äù only if the second operand is integral single bit mask constant. That means, if you have a code, where the ‚Äúmask‚Äù is i.e. a variable, it‚Äôs better to use "!= 0‚Äù if you can, else you‚Äôre out of luck with RyuJIT‚Äôs smartness.</p><pre><code class="language-csharp">public bool A(MyEnum myEnum, MyEnum value)
{
    return (myEnum &amp; value) == value;
}
</code></pre><pre><code class="language-asm">and edx, r8d
cmp edx, r8d
setz al
movzx eax, al
ret
</code></pre><pre><code class="language-csharp">public bool B(MyEnum myEnum, MyEnum value)
{
    return (myEnum &amp; value) != 0;
}
</code></pre><pre><code class="language-asm">test r8d, edx
setnz al
movzx eax, al
ret
</code></pre><h4>Summary</h4><p>Although my hypothesis with "!= 0‚Äù was correct, I learned the direct ‚Äúcompare‚Äù with <code>0</code> wasn‚Äôt really the reason. Quite the opposite. And finally, I spent time learning something new and it was fun.</p><p><small>In case you‚Äôd ask; the <a href="https://github.com/dotnet/coreclr/blob/c5a44f58952c5014f5e1c25b667dca3901fd84a7/src/jit/gentree.cpp#L12862"><code>Enum.HasFlag</code> is optimized and doing the same at the end</a>.</small></p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>