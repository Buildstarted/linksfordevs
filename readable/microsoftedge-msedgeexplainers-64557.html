<!DOCTYPE html>
<html lang="en">
<head>
    <title>
MicrosoftEdge/MSEdgeExplainers - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="MicrosoftEdge/MSEdgeExplainers - linksfor.dev(s)"/>
    <meta property="article:author" content="MicrosoftEdge"/>
    <meta property="og:description" content="Home for explainer documents originated by the Microsoft Edge team - MicrosoftEdge/MSEdgeExplainers"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/MicrosoftEdge/MSEdgeExplainers/blob/main/ControlUICustomization/explainer.md"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - MicrosoftEdge/MSEdgeExplainers</title>
<div class="readable">
        <h1>MicrosoftEdge/MSEdgeExplainers</h1>
            <div>by MicrosoftEdge</div>
            <div>Reading time: 32-41 minutes</div>
        <div>Posted here: 21 Jul 2020</div>
        <p><a href="https://github.com/MicrosoftEdge/MSEdgeExplainers/blob/main/ControlUICustomization/explainer.md">https://github.com/MicrosoftEdge/MSEdgeExplainers/blob/main/ControlUICustomization/explainer.md</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="readme">
    <article itemprop="text">
<p>Authors:</p>
<ul>
<li><a href="https://github.com/dandclark">Dan Clark</a> (Microsoft)</li>
<li><a href="https://github.com/BoCupp">Bo Cupp</a> (Microsoft)</li>
<li><a href="https://github.com/mfreed7">Mason Freed</a> (Google)</li>
<li><a href="https://github.com/ipopescu93">Ionel Popescu</a> (Microsoft)</li>
<li><a href="https://github.com/melanierichards">Melanie Richards</a> (Microsoft)</li>
<li><a href="https://github.com/gregwhitworth">Greg Whitworth</a> (Salesforce)</li>
</ul>
<h2>Status of this Document</h2>
<p>This document is intended as a starting point for engaging the community and standards bodies in developing collaborative solutions fit for standardization. As the solutions to problems described in this document progress along the standards-track, we will retain this document as an archive and use this section to keep the community up-to-date with the most current standards venue and content location of future work and discussions.</p>
<ul>
<li>This document status: <strong>Active</strong></li>
<li>Expected venue: <a href="https://wicg.io/" rel="nofollow">W3C Web Incubator Community Group</a></li>
<li>Current version: this document</li>
</ul>
<h2>Introduction</h2>
<p>A common frustration for developers who try to work with the browser's built-in form controls (<code>&lt;select&gt;</code> and various <code>&lt;input&gt;</code> types) is that they cannot customize the appearance of these controls to fit their site's design or user experience. In a survey of <a href="http://gwhitworth.com/surveys/controls-components" rel="nofollow">web developers about form controls and components</a>, the top reason that devs rewrite their own versions of these controls is the inability to sufficiently customize the appearance of the native controls.</p>
<p>When developers reimplement form controls from scratch, they're not able to leverage the work done on the Web Platform to optimize performance, reliability, and accessibility of the native controls. This proposal enables web developers to customize the native controls to fit their site while leaning on investments in the web platform, saving time for developers and improving experience of the end users who interact with the controls.</p>
<h2>Goals</h2>
<ul>
<li>Developers can style any arbitrary part of a native control.</li>
<li>Developers can add arbitrary content into any part of a native control (with some limitations; some interactive content like other controls and things like <code>&lt;iframe&gt;</code>s may be blocked).</li>
<li>For controls composed of multiple parts, developers can style a particular part without rewriting the whole UI.</li>
<li>Developers can customize the UI without needing to reimplement the data model and the code for reacting to user input.  This is in contrast to current approaches for customization like rewriting controls as custom elements, which requires the developer to start from scratch.</li>
<li>Customized controls are accessible by default.</li>
</ul>
<h2>Incremental Approach</h2>
<p>The purpose of this document is to consider a model that achieves the goals above and can be applied to all controls, but the actual application of the model will be one control at a time - each of which will come with their own specific proposals. The roll-out will be based on developer demand and complexity for each control, and may never be applied to some control types.</p>
<p>This document makes heavy use of <code>&lt;select&gt;</code> and <code>&lt;input type="range"&gt;</code> for conceptual examples, but it is not a goal of this document to fully specify the behavior of those controls.  Once there is agreement on the overal controls customization approach, further work will hammer out specific behavior for <code>&lt;select&gt;</code>, <code>&lt;input type="range"&gt;</code>, and other controls.  Progress along these lines has already begun at the <a href="https://open-ui.org/" rel="nofollow">https://open-ui.org/</a> project, for example see the proposed <a href="https://open-ui.org/components/select" rel="nofollow"><code>&lt;select&gt;</code></a> anatomy.</p>
<h2>Use Cases</h2>
<p>The key use case addressed in this proposal is that of a web developer who wants to include a form control on their site but needs a high degree of flexibility over the appearance of the control. They might also wish to add parts to the control UI; for example, an 'X' button inside a <code>&lt;select&gt;</code>'s dropdown that closes the dropdown.</p>
<p>Currently such a developer would need to rewrite the control from scratch, including the code to link the scriptable model of the control to the UI of the control and the ARIA attributes to make it accessible. With this proposal, the developer provides some custom markup and styles for the UI of their control, and the web platform provides the rest.</p>
<h2>Proposed Solution</h2>
<h3>Note on form controls as MVC</h3>
<p>When considering this proposal it can be useful to think of form controls in terms of the MVC design pattern where the control is constituted by three distinct parts: the model, the view, and the controller. These concepts are used throughout the coming section, so we'll define them here:</p>
<ul>
<li><strong>Model</strong>: The data members and the capabilities of the control, accessible to script via its properties and methods. Examples include the <code>value</code>, form association, and validity state.</li>
<li><strong>View</strong>: The user interface. Makes the state of the control visible to the user, and the user can interact with it to change the state of the control.</li>
<li><strong>Controller</strong>: Acts as an intermediary between the model and the view. Informs the model of user interactions with the view through click and keyboard handlers. Informs the view of changes to the control's model through events, CSS pseudo-classes, and exposing relevant properties.</li>
</ul>
<p>Stated in these terms, the goal of this proposal is to allow developers to customize all or part of a control's view while leveraging the native model and controller code.</p>
<h3>Custom content and styles via standardized parts, named slots, and shadow DOM replacement</h3>
<p>Web developers will have three options for customizing native controls:</p>
<ul>
<li>Using standardized parts and states to override the native control styles via pseudo-classes and pseudo-elements.</li>
<li>Using named <code>&lt;slots&gt;</code> to replace parts of the native control UI with developer content, while optionally leaving some native parts in place.</li>
<li>Replacing the entire UI of the native control with an author-supplied shadow root.</li>
</ul>
<h4>Standardized control UI anatomy, parts, and behavior</h4>
<p>One aspect of enabling this functionality for a given control type will be standardizing the anatomy of the control UI in terms of its conceptual parts and their behaviors, with standardized names for those parts.</p>
<p>For the purposes of this document a 'part' is an element that has standardized meaning to the control. This knowledge of those standardized parts allows the platform to wire up the necessary events and attributes to respond to user interaction which allow for a functional and accessible control (the "controller" code).</p>
<p>Rough examples:</p>
<ul>
<li>The anatomy of a <code>&lt;select&gt;</code> could be defined as consisting of 1 'button' part containing 1 'selected-value' part and 1 popup 'listbox' part containing 0-N 'option' parts. At a very high level, the expected behavior of clicking the button is to expand the list, the expected behavior of the selected-value part is to keep its inner text updated to show the value of the currently selected option, the expected behavior of clicking outside the opened list is to collapse it, etc.</li>
<li>The anatomy of an <code>&lt;input type="range"&gt;</code> could be defined as consisting of 1 draggable 'thumb' part that moves along 1 'track' part.</li>
</ul>
<p>When the developer provides a custom UI with the parts identified, the platform can apply native event handlers and ARIA roles to the elements designated as the parts to light up the control's expected behavior and accessibility without extra code from the developer.</p>
<p>Note that the native styles of the controls will not be standardized and are still expected to differ across browsers. The anatomy of the control and the interaction between the conceptual parts is what must be standardized, to ensure that they are a developer's custom control UI will be fully interoperable across browsers.</p>
<h4>Styling native parts using pseudo-classes and the part pseudo-element</h4>
<p>The control parts that are standardized as per the previous section will be exposed to styling by developers via the <code>part</code> pseudo-element.  For example, a developer will be able to change the color of a <code>&lt;select&gt;</code>'s button in an interoperable manner without replacing any of the HTML:</p>
<div><pre><span>&lt;</span><span>style</span><span>&gt;</span>
  .<span>styled-select</span>::<span>part</span>(but<span>to</span>n) {
    <span>background-color</span>: red
  }
<span>&lt;/</span><span>style</span><span>&gt;</span>
<span>&lt;</span><span>select</span> <span>class</span>="<span>styled-select</span>"<span>&gt;</span>
  <span>&lt;</span><span>option</span><span>&gt;</span>choice 1<span>&lt;/</span><span>option</span><span>&gt;</span>
  <span>&lt;</span><span>option</span><span>&gt;</span>choice 2<span>&lt;/</span><span>option</span><span>&gt;</span>
<span>&lt;/</span><span>select</span><span>&gt;</span></pre></div>
<p>Additional states for the controls will also be standardized as appropriate, such as an <code>open</code> state for <code>&lt;select&gt;</code> to allow styling like the following:</p>
<div><pre>.<span>styled-select</span>:<span>open</span>::<span>part</span>(but<span>to</span>n) {
  <span>/* Change the color of the button when the &lt;select&gt; dropdown is open */</span>
  <span>background-color</span>: lightgray;
}</pre></div>
<h4>Named slots</h4>
<p>More powerful customizations will be enabled with named slots.</p>
<p>For each customizable native control type, a set of slot names will be standardized corresponding to each piece of the control's view that a developer might want to replace with their own content. For <code>&lt;select&gt;</code> the platform might expose slot names for the button and for the listbox dropdown that is expanded when the button is clicked. The user could then provide custom content for the parts in this manner, where the styles are defined in the light DOM (that is, outside of the control's shadow DOM).</p>
<div><pre><span>&lt;</span><span>style</span><span>&gt;</span>
  .<span>custom-button</span> {
    <span>/*...*/</span> 
  }

  <span>option</span> {
    <span>/*...*/</span>
  }

  .<span>option-text</span> {
    <span>/*...*/</span>
  }
<span>&lt;/</span><span>style</span><span>&gt;</span>
<span>&lt;</span><span>select</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>button</span>" <span>part</span>="<span>button</span>" <span>class</span>="<span>custom-button</span>"<span>&gt;</span>Choose a pet<span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>listbox</span>" <span>part</span>="<span>listbox</span>" <span>class</span>="<span>custom-listbox</span>"<span>&gt;</span>
    <span>&lt;</span><span>option</span><span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./cat-icon.jpg</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Cat<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
    <span>&lt;</span><span>option</span><span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./dog-icon.jpg</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Dog<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
  <span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>select</span><span>&gt;</span></pre></div>
<p>(The use of the <code>part</code> attribute here is described in the following section).</p>
<p>The result is a <code>&lt;select&gt;</code> that looks something like this when expanded:</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/MicrosoftEdge/MSEdgeExplainers/blob/main/ControlUICustomization/catDogSelect.png"><img src="https://github.com/MicrosoftEdge/MSEdgeExplainers/raw/main/ControlUICustomization/catDogSelect.png" alt="<select> control with custom styles and images"></a></p>
<p>If no content is provided for a given slot, it will fall back to the default UI provided by the web platform. For example, say that the standardized slots for an <code>&lt;input type="range"&gt;</code> are <code>thumb</code> for the moveable thumb of the slider and <code>track</code> for the track that it moves along. If a user wants to tweak the appearance of the thumb but use the default track, they could do so by providing content with <code>slot="thumb"</code> but not <code>slot="track"</code>, and the web platform will fall back to the default UI for the latter (see example in the following <a href="#Light-DOM-content-under-%3Cinput%3E">section</a>).</p>
<h3>Hooking up native controller code to user-provided UI parts</h3>
<p>A goal of this proposal is that users can customize a control's view without needing to write controller code to react to user input, or to update the view in response to scripted changes to the model.</p>
<p>When developer content is slotted in from the light DOM or added to the replaced shadow DOM, platform code will run to identify elements corresponding to the required control parts. These are identified by the value of the <code>part</code> attribute and/or the element type (e.g. <code>&lt;option&gt;</code>s in a <code>&lt;select&gt;</code>).  Note that a <code>part</code> attribute has already been proposed in the context of <a href="https://drafts.csswg.org/css-shadow-parts/#idl" rel="nofollow">CSS Shadow Parts</a>.  The usage proposed here is complementary to the usage with the <code>::part()</code> CSS pseudo-element.</p>
<p>Where applicable, the platform will apply native event handlers to the elements identified this way to handle user input. For example, a keyboard event handler would be applied to the thumb part of an <code>&lt;input type="range"&gt;</code> to move the thumb in response to arrow keys. A click event handler would be applied to an <code>&lt;option&gt;</code> in a <code>&lt;select&gt;</code> so that the value of the <code>&lt;select&gt;</code> is updated to the value of the <code>&lt;option&gt;</code> when it is clicked.</p>
<p>In the <a href="#named-slots">Named Slots</a> section's example, the <code>&lt;div part="button"&gt;</code>, <code>&lt;div part="listbox"&gt;</code>, and the <code>&lt;option&gt;</code> elements would have native event handlers wired up to them in this manner. The remaining elements are just for layout/styling purposes and would not be selectable.</p>
<p>This automatic application of controller code enables developers to make UI tweaks without writing tons of JavaScript to handle input, and ensures that customized control UIs can handle all of the input modalities that users expect.</p>
<h4>Light-DOM content under <code>&lt;input&gt;</code></h4>
<p>A blocker for the idea of using light DOM children to provide custom UI for a control is that the HTML parser does not put children under <code>&lt;input&gt;</code> (see case in <a href="https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inbody" rel="nofollow">"in body" insertion mode</a>).</p>
<p>To work around this limitation we propose that when UI customization is introduced for a given <code>&lt;input&gt;</code> type, it is done by standardizing a new HTMLElement corresponding to the <code>&lt;input&gt;</code> type in question. The new element would be equivalent to an <code>&lt;input&gt;</code> element of the given type, but with all the methods/properties irrelevant to that type removed. The <code>type</code> property would be read-only and always return the string matching the input type corresponding to the element. The key difference is that it would follow the parsing rules for an <a href="https://html.spec.whatwg.org/multipage/parsing.html#ordinary" rel="nofollow">ordinary</a> element and therefore be able to have child DOM elements.</p>
<p>For example, for <code>&lt;input type="range"&gt;</code> an <code>HTMLRangeElement</code> would be introduced. This would have the same methods, properties, and behaviors as an <code>&lt;input&gt;</code> element in the <a href="https://html.spec.whatwg.org/multipage/input.html#range-state-(type=range)" rel="nofollow">Range state</a>, minus the methods and properties only relevant to other <code>&lt;input&gt;</code> types. It could be used as follows to provide a custom SVG slider thumb:</p>
<div><pre><span>&lt;</span><span>range</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>thumb</span>" <span>part</span>="<span>thumb</span>"<span>&gt;</span><span>&lt;</span><span>svg</span><span>&gt;</span><span>&lt;!-- Use SVG to draw the thumb icon... --&gt;</span><span>&lt;/</span><span>svg</span><span>&gt;</span><span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>range</span><span>&gt;</span></pre></div>
<h4>Attribute for opt-in</h4>
<p>Some form controls will need to explicitly opt-in to the new behavior.  <code>&lt;select&gt;</code> in particular would run into issues if we changed the behavior by default, for two reasons:</p>
<ul>
<li>Changing the parsing behavior for <code>&lt;select&gt;</code> to allow other element children by default would likely break a lot of old sites that depend on the current behavior.</li>
<li>The <code>&lt;select&gt;</code> popup currently has the capability to break outside the window of the browser or of an <code>iframe</code>.  Sites likely depend on this behavior, but we would need to remove it for security reasons if <code>&lt;select&gt;</code> is allowed to contain arbitrary content.  So again this would need to be opt-in to avoid breaking existing sites.</li>
</ul>
<p>The proposed opt-in mechanism is a <code>custom</code> attribute present on the element:
<code>&lt;select custom=""&gt;&lt;/select&gt;</code>.  If present, the new behavior would be switched on for that element instance (new parsing rules, content can be slotted into element's native shadow DOM, dropdown doesn't escape window...).</p>
<p>Controls like <code>&lt;range&gt;</code> for which we're introducing new elements wouldn't need this opt-in.</p>
<p>Alternative ideas for opt-in are considered in an <a href="#open-questions">open question</a>.</p>
<h4>Shadow DOM replacement</h4>
<p>An alternative method for allowing developers to provide a custom control view is by swapping in their own shadow DOM.</p>
<p>Calling <code>attachShadow()</code> on any form control currently throws an exception (<a href="https://dom.spec.whatwg.org/#dom-element-attachshadow" rel="nofollow">step 2</a>). When enabling customization for a given control type, this restriction will be removed and calling <code>attachShadow()</code> will result in the default user-agent shadow DOM being swapped out with a new shadow root that can be populated with content provided by the developer:</p>
<div><pre><span>let</span> <span>customSelect</span> <span>=</span> <span>document</span><span>.</span><span>createElement</span><span>(</span><span>'select'</span><span>)</span><span>;</span>
<span>customSelect</span><span>.</span><span>setAttribute</span><span>(</span><span>"custom"</span><span>,</span> <span>""</span><span>)</span><span>;</span>
<span>let</span> <span>selectShadow</span> <span>=</span> <span>customSelect</span><span>.</span><span>attachShadow</span><span>(</span><span>{</span> <span>mode</span>: <span>'open'</span> <span>}</span><span>)</span><span>;</span>
<span>selectShadow</span><span>.</span><span>innerHTML</span> <span>=</span> <span>`My custom select UI`</span><span>;</span>
<span>document</span><span>.</span><span>body</span><span>.</span><span>appendChild</span><span>(</span><span>customSelect</span><span>)</span><span>;</span></pre></div>
<p>(We expect that this eventually will also be possible without JavaScript via declarative shadow DOM <a href="https://github.com/whatwg/dom/pull/858">[1]</a>, <a href="https://github.com/whatwg/html/pull/5465">[2]</a>).</p>
<p>The platform will require that the developer labels the core parts of the user-provided shadow DOM using the part attribute. For example a custom <code>&lt;select&gt;</code> shadow DOM would need to have an element with <code>part="button"</code> and an element with <code>part="listbox"</code>, and a custom shadow-DOM for <code>&lt;input type="range"&gt;</code> would require an element with <code>part="thumb"</code> and <code>part="track"</code>.</p>
<p>If any required parts are not supplied, the shadow DOM will not be rendered. The purpose of this requirement is so that the platform can apply the correct accessibility semantics and user input event handlers so that the control parts respond to users as expected.  When parts are missing, the platform won't make an attempt to guess at the right behavior, and won't render an incomplete control implementation.</p>
<p>We expect that replacing the shadow DOM (as opposed to slotting in content from the light DOM) will be the preferred approach for developers who want to customize the entire UI of the control, or for frameworks who want to ship a customized control that isn't affected by the styles of the host page. Developers who just want to customize part of a control's UI might prefer to use the slotting approach so that they don't need to recreate the entire UI in the shadow.</p>
<h3>Custom view updates in response to scripted model changes</h3>
<p>In most cases, CSS included with a web developer's custom control view will be sufficient to react to control model changes. For example, a custom <code>&lt;select&gt;</code> implementation might include CSS rules like the following to to highlight and un-highlight selected and de-selected options without explicitly watching for changes to the value property.</p>
<div><pre><span>select</span> <span>option</span> {
  <span>/* styles for an option that is not selected */</span>
}

<span>select</span> <span>option</span>[<span>selected</span><span>=</span><span>"true"</span>] {
 <span>/* styles for an option that is selected */</span>
}</pre></div>
<p>In other cases, the developer may want to perform scripted operations in response to control model changes. This will usually be the case for control types with a range of values that are not author supplied, such as <code>&lt;input type="color"&gt;</code>. For these controls, developers will need to watch for scripted changes to the control model in order to update their UI accordingly. We expect that the standard way to do this will be to extend the built-in element type and add a setter for the attributes and properties of interest. The developer may also need to add an input event handler to respond to user input in cases where the native controller code applied to the control parts is not sufficient.</p>
<p>For example, if a custom <code>&lt;select&gt;</code> UI needed to perform scripted updates in response to value changes, the developer could specify the control as follows:</p>
<div><pre><span>class</span> <span>MyCustomSelect</span> <span>extends</span> <span>HTMLSelectElement</span> <span>{</span>
  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>)</span><span>;</span>
    <span>this</span><span>.</span><span>shadow_</span> <span>=</span> <span>this</span><span>.</span><span>attachShadow</span><span>(</span><span>{</span> <span>mode</span>: <span>'open'</span> <span>}</span><span>)</span><span>;</span> <span>// Replace the native shadow root</span>
    <span>this</span><span>.</span><span>shadow_</span><span>.</span><span>innerHTML</span> <span>=</span> <span>`...`</span><span>;</span> <span>// Supply the custom view</span>

    <span>// Ensure that we update the view in response to user input</span>
    <span>this</span><span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>this</span><span>.</span><span>updateView</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>

  <span>// Intercept any scripted setting of the value.  Forward the value</span>
  <span>// change to HTMLSelectElement and update the view.  Can be done for</span>
  <span>// other view-impacting properties as well.</span>
  <span>set</span> <span>value</span><span>(</span><span>newValue</span><span>)</span> <span>{</span>
    <span>super</span><span>.</span><span>value</span> <span>=</span> <span>newValue</span><span>;</span>
    <span>this</span><span>.</span><span>updateView</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>

  <span>updateView</span><span>(</span><span>)</span> <span>{</span>
    <span>// Do whatever work is needed to update the view to reflect the new state</span>
  <span>}</span>
<span>}</span><span>;</span>
<span>window</span><span>.</span><span>customElements</span><span>.</span><span>define</span><span>(</span><span>'custom-select'</span><span>,</span> <span>MyCustomSelect</span><span>,</span> <span>{</span> <span>extends</span>: <span>'select'</span> <span>}</span><span>)</span><span>;</span></pre></div>
<p>It is an <a href="#open-questions">open question</a> whether the ergonomics of managing model/view interactions this way are sufficiently painful that the platform should expose a new way of doing so, or whether this will really be a common use case.</p>
<h3>Ensuring accessibility by default</h3>
<p>A key goal of this proposal is that custom control UIs are accessible by default. To achieve this, the platform controller code will apply implicit accessibility semantics to elements that are identified as known UI parts. These known parts will be identifiable through the value of the <code>part</code> attribute.</p>
<p>The term '<strong>implicit</strong> accessibility semantics' is used in this document in the same sense as the implicit semantics specified by the <a href="https://www.w3.org/TR/html-aam-1.0/" rel="nofollow">HTML AAM</a>.  ARIA attributes won't actually be added to the author's HTML, but the platform will report to accessibility tools as if the appropriate ARIA attributes were present.  This is analogous to how a <code>&lt;button&gt;</code> element is given the ARIA role of button per the <a href="https://www.w3.org/TR/html-aam-1.0/#html-element-role-mappings" rel="nofollow">HTML AAM Element Role Mappings</a>, even if no <code>role</code> content attribute is actually present.</p>
<p>For example, if a developer provides a custom thumb for a range slider:</p>
<div><pre><span>&lt;</span><span>range</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>thumb</span>" <span>part</span>="<span>thumb</span>"<span>&gt;</span><span>&lt;</span><span>svg</span><span>&gt;</span><span>&lt;!-- Use SVG to draw the thumb icon... --&gt;</span><span>&lt;/</span><span>svg</span><span>&gt;</span><span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>range</span><span>&gt;</span></pre></div>
<p>The platform would report the following implicit accessibility semantics to accessibility tools for the <code>&lt;div&gt;</code> with <code>part="thumb"</code>:</p>
<ul>
<li>An ARIA role of <a href="https://www.w3.org/TR/html-aria/#index-aria-slider" rel="nofollow">slider</a>.</li>
<li><a href="https://www.w3.org/TR/wai-aria-1.1/#aria-valuenow" rel="nofollow">aria-valuenow</a> reflecting the value property of the control</li>
<li><a href="https://www.w3.org/TR/wai-aria-1.1/#aria-valuemax" rel="nofollow">aria-valuemax</a> reflecting the max property of the control</li>
<li><a href="https://www.w3.org/TR/wai-aria-1.1/#aria-valuemin" rel="nofollow">aria-valuemin</a> reflecting the min property of the control</li>
</ul>
<h3>Additional examples: Implicit accessibility semantics applied to parts</h3>
<h4>Example 1:</h4>
<p>Consider this HTML:</p>
<div><pre><span>&lt;</span><span>select</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>button</span>" <span>part</span>="<span>button</span>" <span>class</span>="<span>custom-button</span>"<span>&gt;</span>Choose a pet<span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>listbox</span>" <span>part</span>="<span>listbox</span>" <span>class</span>="<span>custom-listbox</span>"<span>&gt;</span>
    <span>&lt;</span><span>option</span><span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./cat-icon.jpg</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Cat<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
    <span>&lt;</span><span>option</span><span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./dog-icon.jpg</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Dog<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
  <span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>select</span><span>&gt;</span></pre></div>
<p>This results in the following implicit ARIA mappings when popup is in closed state (Note that the aria HTML content attributes won't actually be set on the DOM elements; these are just written below for explanatory purposes.  These are added to show that the slotted content will receive these implicit accessibility semantics.  In other words, the accessibility tree will be built as if these elements had these roles and <code>aria-*</code> properties.).</p>
<div><pre><span>&lt;</span><span>select</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>button</span>" <span>part</span>="<span>button</span>" <span>class</span>="<span>custom-button</span>" <span>role</span>="<span>button</span>" <span>aria-haspopup</span>="<span>listbox</span>" <span>aria-expanded</span>="<span>false</span>"<span>&gt;</span>Choose a pet<span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&lt;!-- listbox is display:none when closed, so not in accessibility tree --&gt;</span> 
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>listbox</span>" <span>part</span>="<span>listbox</span>" <span>class</span>="<span>custom-listbox</span>" <span>role</span>="<span>listbox</span>"<span>&gt;</span>
    <span>&lt;</span><span>option</span> <span>role</span>="<span>option</span>"<span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./cat-icon.jpg</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Cat<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
    <span>&lt;</span><span>option</span> <span>role</span>="<span>option</span>"<span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./dog-icon.jpg</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Dog<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
  <span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>select</span><span>&gt;</span></pre></div>
<p>And when in the open state:</p>
<div><pre><span>&lt;</span><span>select</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>button</span>" <span>part</span>="<span>button</span>" <span>class</span>="<span>custom-button</span>" <span>role</span>="<span>button</span>" <span>aria-haspopup</span>="<span>listbox</span>" <span>aria-expanded</span>="<span>true</span>"<span>&gt;</span>Choose a pet<span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>listbox</span>" <span>part</span>="<span>listbox</span>" <span>class</span>="<span>custom-listbox</span>" <span>role</span>="<span>listbox</span>"<span>&gt;</span>
    <span>&lt;</span><span>option</span> <span>role</span>="<span>option</span>" <span>aria-selected</span>="<span>true</span>"<span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./cat-icon.jpg</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Cat<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
    <span>&lt;</span><span>option</span> <span>role</span>="<span>option</span>"<span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./dog-icon.jpg</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Dog<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
  <span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>select</span><span>&gt;</span></pre></div>
<h4>Example 2:</h4>
<p>The following HTML:</p>
<div><pre><span>&lt;</span><span>range</span> <span>value</span>="<span>10</span>" <span>min</span>="<span>0</span>" <span>max</span>="<span>20</span>"<span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>thumb</span>" <span>part</span>="<span>thumb</span>"<span>&gt;</span><span>&lt;</span><span>svg</span><span>&gt;</span><span>&lt;!-- Draw icon with SVG --&gt;</span><span>&lt;/</span><span>svg</span><span>&gt;</span><span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>range</span><span>&gt;</span></pre></div>
<p>Results in these implicit accessibility semantics:</p>
<div><pre><span>&lt;</span><span>range</span> <span>value</span>="<span>10</span>" <span>min</span>="<span>0</span>" <span>max</span>="<span>20</span>"<span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>thumb</span>" <span>part</span>="<span>thumb</span>" <span>role</span>="<span>slider</span>" <span>aria-valuenow</span>="<span>10</span>" <span>aria-valuemin</span>="<span>0</span>" <span>aria-valuemax</span>="<span>20</span>"<span>&gt;</span><span>&lt;</span><span>svg</span><span>&gt;</span><span>&lt;!-- Draw icon with SVG --&gt;</span><span>&lt;/</span><span>svg</span><span>&gt;</span><span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>range</span><span>&gt;</span></pre></div>
<h3>Accessible name computation</h3>
<p>Control parts will generally compute their accessible names and descriptions using the algorithm defined in <a href="https://www.w3.org/TR/accname-aam-1.1/" rel="nofollow">Accessible Name and Description: Computation and API Mappings 1.1</a>.
An important detail here is that some parts are given implicit ARIA roles that support <a href="https://www.w3.org/TR/wai-aria/#namefromcontent" rel="nofollow">name from content</a>, for example <code>&lt;div slot="button"&gt;</code> receives the combobox role and <code>&lt;option&gt;</code> has the option role.  This means that their children are used to calculate their ARIA names.  Revisiting this example and adding alt attributes to the images:</p>
<div><pre><span>&lt;</span><span>select</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>button</span>" <span>part</span>="<span>button</span>" <span>class</span>="<span>custom-button</span>"<span>&gt;</span>Choose a pet<span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>listbox</span>" <span>part</span>="<span>listbox</span>" <span>class</span>="<span>custom-listbox</span>"<span>&gt;</span>
    <span>&lt;</span><span>option</span><span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./cat-icon.jpg</span>" <span>alt</span>="<span>Cat picture</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Cat<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
    <span>&lt;</span><span>option</span><span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./dog-icon.jpg</span>" <span>alt</span>="<span>Dog picture</span>"/&gt;
      <span>&lt;</span><span>div</span> <span>class</span>="<span>option-text</span>"<span>&gt;</span>Dog<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;/</span><span>option</span><span>&gt;</span>
  <span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>select</span><span>&gt;</span></pre></div>
<p>The accessible names are:</p>
<ul>
<li><code>&lt;div slot="button" part="button"&gt;</code>: Choose a pet"</li>
<li><code>&lt;div slot="listbox" part="listbox"&gt;</code>: No accessible name (which is OK since this shouldn't be focusable)</li>
<li>First <code>&lt;option&gt;</code>: Cat picture Cat</li>
<li>Second <code>&lt;option&gt;</code>: Dog picture Dog</li>
</ul>
<p>The presence of the img alt captions in the <code>&lt;option&gt;</code> names is somewhat redundant in this example.  But,  just using the <a href="https://www.w3.org/TR/accname-aam-1.1/" rel="nofollow">Accessible Name and Description: Computation and API Mappings 1.1</a> with <a href="https://www.w3.org/TR/wai-aria/#namefromcontent" rel="nofollow">name from content</a> should provide the best results in normal cases.  Consider the case where the options just consisted of <code>&lt;img&gt;</code> tags, with no option text.  In this scenario it is critical that the accessible names of the <code>&lt;img&gt;</code>s are announced.</p>
<p>In conclusion, the normal accessible name computation algorithm should be suitable for custom controls; no special rules should be necessary.  Developers should use the same considerations for adding <code>alt</code> text to images in custom controls as they would for normal content in a page.</p>
<h3>Accessible name forwarding from control element</h3>
<p>Consider the case where the control element itself has an explicitly set accessible name:</p>
<div><pre><span>&lt;</span><span>label</span> <span>for</span>="<span>my-range</span>"<span>&gt;</span>My custom range<span>&lt;/</span><span>label</span><span>&gt;</span>
<span>&lt;</span><span>range</span> <span>id</span>="<span>my-range' value=</span>"<span>10</span>" min="<span>0</span>" <span>max</span>="<span>20</span>"<span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>thumb</span>" <span>part</span>="<span>thumb</span>"<span>&gt;</span><span>&lt;</span><span>svg</span><span>&gt;</span><span>&lt;!-- Draw icon with SVG --&gt;</span><span>&lt;/</span><span>svg</span><span>&gt;</span><span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;/</span><span>range</span><span>&gt;</span></pre></div>
<p>There was initially a question of whether the accessible name of the light DOM element would need to be "forwarded" by controller code somehow to the custom UI in the shadow DOM.</p>
<p>However, experiments with accessibility tools (Narrator, NVDA, VoiceOver) and a sample page with a named shadow host demonstrated that this is not necessary.  When focus is changed from outside the shadow root to some focusable item within the shadow root, the name of the shadow host is announced, followed by the name of whatever was focused in the shadow.  This behavior should also apply to custom control UIs, so no special handling is necessary to ensure that the light DOM element's name is properly announced.</p>
<h2>Privacy and Security Considerations</h2>
<h3>Privacy</h3>
<p>No considerable privacy concerns are expected, but we welcome community feedback.</p>
<h3>Security</h3>
<p>Some built-in controls have privileged behavior that could be dangerous if opened up to third-party code. For example, the built-in <code>&lt;select&gt;</code>'s dropdown listbox can expand outside the containing browser window and outside of <code>&lt;iframe&gt;</code>s. If arbitrary content is allowed in the <code>&lt;select&gt;</code> this capability could be used for spoofing OS UI outside of the browser frame, or spoofing content of an outer site from within an <code>&lt;iframe&gt;</code>.</p>
<p>All control types that are opened up for customization will have to be carefully examined for such cases of potentially exploitable privileged behavior.</p>
<h2>Alternative Solutions</h2>
<p>An alternative to using named slots to bring custom content into the native control shadow DOM is to use HTML elements that are defined to have special behavior when under the customized element. For example, for <code>&lt;select&gt;</code> we could define special behavior for the <code>&lt;button&gt;</code> element such that it is inserted into the button slot and receives the behavior of the button part.  Additionally we could introduce a new <code>&lt;listbox&gt;</code> element for the listbox part that is automatically placed into the listbox slot.  A developer would then provide custom <code>&lt;select&gt;</code> styling like so:</p>
<div><pre><span>&lt;</span><span>select</span><span>&gt;</span>
  <span>&lt;</span><span>button</span><span>&gt;</span><span>&lt;</span><span>div</span> <span>class</span>="<span>has-custom-button-styles</span>"<span>&gt;</span>Button text<span>&lt;/</span><span>div</span><span>&gt;</span><span>&lt;/</span><span>button</span><span>&gt;</span>
  <span>&lt;</span><span>listbox</span><span>&gt;</span>
    <span>&lt;</span><span>div</span> <span>class</span>="<span>has-custom-listbox-styles</span>"<span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./option1-icon.png</span>"/&gt;<span>&lt;</span><span>option</span><span>&gt;</span>option 1<span>&lt;/</span><span>option</span><span>&gt;</span>
      <span>&lt;</span><span>img</span> <span>src</span>="<span>./option2-icon.png</span>"/&gt;<span>&lt;</span><span>option</span><span>&gt;</span>option 2<span>&lt;/</span><span>option</span><span>&gt;</span>
    <span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&lt;/</span><span>listbox</span><span>&gt;</span>
<span>&lt;/</span><span>select</span><span>&gt;</span></pre></div>
<p>This approach allows the same level of control for the user over which parts of the control they can replace, but has a different set of advantages:</p>
<p><strong>Advantages of <code>&lt;button&gt;</code> and <code>&lt;listbox&gt;</code> approach:</strong></p>
<ul>
<li>May be more intuitive for developers; clearer that they are doing something supported/built-in.</li>
<li>Developers don't need to apply <code>slot</code> and <code>part</code> attributes to indicate where content should be present in the shadow DOM, and where controller code should be hooked up; instead these are determined from the element type.</li>
</ul>
<p><strong>Disadvantages of <code>&lt;button&gt;</code> and <code>&lt;listbox&gt;</code> approach:</strong></p>
<ul>
<li>The approach of adding new elements is less flexible and makes it more difficult to extend customizable UI to other controls. Would we need to add a <code>&lt;slider&gt;</code> or <code>&lt;thumb&gt;</code> element for <code>&lt;input type="range"&gt;</code>? Or a <code>&lt;grid&gt;</code> element for <code>&lt;input type="date"&gt;</code>? etc. etc. On the other hand the <code>&lt;slot&gt;</code> approach just requires us to decide on what named slots and parts we want to support for each new control.</li>
<li>Introducing slots and parts as separate concepts is more powerful than tying them together in the element type.  Introducing them as separate concepts allows for more complex use cases such as the split-button <code>&lt;select&gt;</code> (see <a href="#examples-of-extensability">Examples of Extensibility</a>).</li>
<li>Defining new elements would likely add complexity and lengthen the road to standardization.
<ul>
<li>Defining the parser behavior in particular will be a major source of complexity, especially if we want to use parser fixup to add default content when the developer doesn't provide it. Behavior of <code>&lt;slots&gt;</code> on the other hand is already specified.</li>
</ul>
</li>
</ul>
<h2>Open Questions</h2>
<ul>
<li>Should the platform expose a new way of watching changes to properties like <code>value</code>? This would simplify the work of developers writing complex controls that require manually handling scripted changes to the model. Aside from the method explored in <a href="#Custom-view-updates-in-response-to-scripted-model-changes">Custom view updates in response to scripted model changes</a>, another approach might be to add functionality to <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#the-elementinternals-interface" rel="nofollow">ElementInternals</a> that would allow developers to easily register to watch for changes to properties relevant to the view.</li>
<li>Since we are not standardizing control styles across browsers, there may be interoperability issues with partial styling.  For example if the developer replaces the slider thumb of a <code>&lt;range&gt;</code> but not the track it moves along, there may be pixel differences between the appearance of the track on different browsers that cause the custom thumb to be off-center.  For elements like <code>&lt;select&gt;</code> where the button and listbox don't overlap, this may not be as much of an issue, but even there it's not clear how we can guarantee things won't break if an author needs things to be pixel-perfect.
<ul>
<li>Allowing the developer to clear the default styles and provide their own stylesheet isn't a solution, because different platforms may have used a different HTML structure to build their control views.  E.g. the slider track might be built with styled <code>&lt;div&gt;</code>s in one platform and styled <code>&lt;span&gt;</code>s in another.  So the same developer-provided stylesheet would not work interoperably unless the entire control UI was replaced.</li>
</ul>
</li>
<li>How would <code>&lt;select&gt;</code> work on Mobile platforms, where OS-native UIs are used for some control popups?  Would we switch to the browser popup if we detect that a developer has applied any custom styles or markup for it?</li>
<li>For <code>&lt;range&gt;</code> it's not clear how controller code should position a user-provided slider thumb in reponse to model changes given that control styles will not be standardized.  Simply updating a given CSS property won't work consistently because there could be a variety of platform and author styles that could cause the content to be positioned differently.  It seems that a level of indirection between the controller code and the CSS properties may be necessary, e.g. a CSS variable that the controller code would update based on <code>range.value</code> changes.
<ul>
<li>There could also be difficulties with handling mouse and touch input (including drags) for <code>&lt;range&gt;</code>.  Determining the position of the thumb and the resulting <code>value</code> is not straightforward if the styles of the control are not known.</li>
<li>There is also some question of how wide a range of custom interaction models developers will be able create while still relying on the platform to facilitatate model-view interactions.  Could a <code>&lt;range&gt;</code> that looks like a dial still make use of platform controller code, or would the user have to write the JavaScript themselves for a slider that's not a straight line?</li>
</ul>
</li>
<li>Using a <code>custom</code> attribute for opt-in could result in some tricky corner cases in the event that the attribute is added/removed dynamically.  Consider the case where the <code>&lt;select&gt;</code> is created dynamically via <code>document.createElement()</code>, when the <code>custom</code> attribute must be set using <code>setAttribute()</code>.  When should the transition to the custom behavior be applied?  Applying it at the point of <code>setAttribute()</code> would be inconsistent with how other elements like <code>input[type=range]</code> work when created dynamically; typically the transformation would occur when the element was appended to the DOM.  But, this means that for a dynamically created <code>&lt;select&gt;</code>, the developer would have to wait until the <code>&lt;select&gt;</code> is appended to the DOM before calling <code>attachShadow()</code>.
<ul>
<li>Alternative 1: Don't overload any existing native controls, just mint new element names for all of them.</li>
<li>Alternative 2: Apply the new behavior by default, and provide an opt-out mechanism.</li>
</ul>
</li>
</ul>
<h2>Appendix</h2>
<h3>Another example of extensibility: Split-button select</h3>
<p>Tying the platform's controller code to developer-provided parts enables web developers to extend the control to their needs without writing a bunch of JavaScript to reimplement native functionality. Let's use the <code>&lt;select&gt;</code> as an example with the following <a href="https://open-ui.org/components/select#anatomy-1" rel="nofollow">anatomy</a> template definition:</p>
<div><pre><span>&lt;</span><span>template</span><span>&gt;</span>
  <span>&lt;</span><span>slot</span> <span>name</span>="<span>button-container</span>"<span>&gt;</span>
    <span>&lt;</span><span>button</span> <span>part</span>="<span>button</span>" <span>aria-expanded</span>="<span>${x =&gt; x.open == true}</span>" <span>aria-haspopup</span>="<span>listbox</span>"<span>&gt;</span>
      <span>&lt;</span><span>span</span> <span>part</span>="<span>selected-value</span>"<span>&gt;</span><span>&lt;/</span><span>span</span><span>&gt;</span>
    <span>&lt;/</span><span>button</span><span>&gt;</span>
  <span>&lt;/</span><span>slot</span><span>&gt;</span>
  <span>&lt;</span><span>slot</span> <span>name</span>="<span>listbox-container</span>"<span>&gt;</span>
    <span>&lt;</span><span>listbox</span><span>&gt;</span>
      <span>&lt;</span><span>slot</span><span>&gt;</span><span>&lt;/</span><span>slot</span><span>&gt;</span>
    <span>&lt;/</span><span>listbox</span><span>&gt;</span>
  <span>&lt;/</span><span>slot</span><span>&gt;</span>
<span>&lt;/</span><span>template</span><span>&gt;</span></pre></div>
<p>By exposing the select parts that were historically hidden we can then access them for extending style capabilities. Here is an example HTML markup using the above anatomy to re-create a split button solution similar to <a href="https://getbootstrap.com/docs/4.3/components/dropdowns/#split-button" rel="nofollow">Bootstrap's</a>.</p>
<div><pre><span>&lt;</span><span>select</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>slot</span>="<span>button-container</span>"<span>&gt;</span>
    <span>&lt;</span><span>div</span> <span>class</span>="<span>select-label</span>"<span>&gt;</span>Primary<span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;</span><span>div</span> <span>class</span>="<span>arrow</span>" <span>part</span>="<span>button</span>"<span>&gt;</span><span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&lt;/</span><span>div</span><span>&gt;</span>
  <span>&lt;</span><span>div</span> <span>name</span>="<span>listbox-container</span>" <span>slot</span>=<span>listbox-container</span> <span>part</span>=<span>listbox</span><span>&gt;</span>
    <span>&lt;</span><span>option</span> <span>value</span>="<span>Option One</span>"<span>&gt;</span>Option One<span>&lt;</span><span>option</span><span>&gt;</span>
    <span>&lt;</span><span>option</span> <span>value</span>="<span>Option Two</span>"<span>&gt;</span>Option Two<span>&lt;/</span><span>option</span><span>&gt;</span>
    <span>&lt;</span><span>option</span> <span>value</span>="<span>Option Three</span>"<span>&gt;</span>Option Three<span>&lt;/</span><span>option</span><span>&gt;</span>
    <span>&lt;</span><span>div</span> <span>class</span>="<span>separator</span>"<span>&gt;</span><span>&lt;/</span><span>div</span><span>&gt;</span>
    <span>&lt;</span><span>option</span> <span>value</span>="<span>Option Four</span>"<span>&gt;</span>Option Four<span>&lt;/</span><span>option</span><span>&gt;</span>
  <span>&lt;/</span><span>div</span><span>&gt;</span>
 <span>&lt;/</span><span>select</span><span>&gt;</span></pre></div>
<p>This results in the following rendering (CSS isn't shown):</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/MicrosoftEdge/MSEdgeExplainers/blob/main/ControlUICustomization/splitButtonSelect.png"><img src="https://github.com/MicrosoftEdge/MSEdgeExplainers/raw/main/ControlUICustomization/splitButtonSelect.png" alt="<select> control with button split into an area with text and a clickable down-arrow for opening the dropdown" title="<select> control with button split into an area with text and a clickable down-arrow for opening the dropdown"></a></p>
<p>Let's take a look at why leveraging the MVC paradigm has the potential of making web platform controls so powerful.</p>
<div><pre><span>&lt;</span><span>div</span> <span>class</span>="<span>arrow</span>" <span>part</span>="<span>button</span>"<span>&gt;</span></pre></div>
<p>Because the <code>part="button"</code> has meaning to the <code>&lt;select&gt;</code> it allows the controller code to wire up the necessary events and attributes to ensure accessibility support. Accessibility tools will see the following:</p>
<div><pre><span>&lt;</span><span>div</span> <span>slot</span>="<span>button-container</span>" <span>part</span>="<span>button</span>" <span>tabindex</span>="<span>0</span>" <span>aria-haspopup</span>="<span>true</span>" <span>aria-expanded</span>="<span>false</span>" <span>role</span>="<span>button</span>"<span>&gt;</span></pre></div>
<p>Necessary input events are wired up to the parts as well so the web developer doesn't have to wire up the various end user interactions such as updating <code>aria-expanded</code> upon invocation. Keyboard events will be applied so that for example pressing 'Enter' on the <code>part="button"</code> will open the popup.  The <code>&lt;option&gt;</code> parts will listen for up/down arrows to iterate through the options. This becomes powerful because in this example, there is a separator element between options three and four for decoration but the expected end user traversal just works.</p>
<div><pre><span>&lt;</span><span>option</span> <span>value</span>="<span>Option Three</span>"<span>&gt;</span>Option Three<span>&lt;/</span><span>option</span><span>&gt;</span>
<span>&lt;</span><span>div</span> <span>class</span>="<span>separator</span>"<span>&gt;</span><span>&lt;/</span><span>div</span><span>&gt;</span>
<span>&lt;</span><span>option</span> <span>value</span>="<span>Option Four</span>"<span>&gt;</span>Option Four<span>&lt;/</span><span>option</span><span>&gt;</span></pre></div>
<p>Note that the <code>&lt;div class="arrow"&gt;</code> is the one that gets <code>part="button"</code>, not the <code>&lt;div name="listbox-container"&gt;</code>.  The result of this is that only the half of the button with the dropdown arrow can be clicked to open the popup, which is similar to the behavior of <a href="https://getbootstrap.com/docs/4.3/components/dropdowns/#split-button" rel="nofollow">Bootstrap's split-button</a>.  If we wanted the entire button to activate the popup, then we'd apply <code>part="button"</code> to the <code>&lt;div name="listbox-container"&gt;</code> instead.</p>
</article>
  </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>