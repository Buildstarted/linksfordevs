<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Use pattern matching features to extend data types - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Use pattern matching features to extend data types - linksfor.dev(s)"/>
    <meta property="article:author" content="BillWagner"/>
    <meta property="og:description" content="This advanced tutorial demonstrates how to use pattern matching techniques to create functionality using data and algorithms that are created separately."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/pattern-matching"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Use pattern matching features to extend data types</title>
<div class="readable">
        <h1>Use pattern matching features to extend data types</h1>
            <div>by BillWagner</div>
            <div>Reading time: 19-24 minutes</div>
        <div>Posted here: 09 May 2019</div>
        <p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/pattern-matching">https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/pattern-matching</a></p>
        <hr/>
<div id="readability-page-1" class="page">


	<div data-bi-name="body">

		<div>

			

			<section>
				<div>


				<div id="main-column">

					<main id="main" role="main" data-bi-name="content" lang="en-us" dir="ltr">



						

						<ul data-bi-name="page info" lang="en-us" dir="ltr">
							<li>
								<time role="presentation" datetime="2019-03-13T00:00:00.000Z" data-article-date-source="ms.date">03/13/2019</time>
							</li>
								<li>14 minutes to read</li>
							<li>
								<a href="https://github.com/dotnet/docs/blob/master/docs/csharp/tutorials/pattern-matching.md" title="6 Contributors" aria-label="6 Contributors">
									
								</a>
							</li>

						</ul>

						<nav id="center-doc-outline" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">
							<h3>In this article</h3>
						<ol><li><a href="#prerequisites">Prerequisites</a></li><li><a href="#scenarios-for-pattern-matching">Scenarios for pattern matching</a></li><li><a href="#pattern-matching-designs">Pattern matching designs</a></li><li><a href="#implement-the-basic-toll-calculations">Implement the basic toll calculations</a></li><li><a href="#add-occupancy-pricing">Add occupancy pricing</a></li><li><a href="#add-peak-pricing">Add peak pricing</a></li><li><a href="#next-steps">Next steps</a></li></ol></nav>


						<!-- <content> -->
							
<p>C# 7 introduced basic pattern matching features. Those features are extended in C# 8 with new expressions and patterns. You can write functionality that behaves as though you extended types that may be in other libraries. Another use for patterns is to create functionality your application requires that isn't a fundamental feature of the type being extended.</p>
<p>In this tutorial, you'll learn how to:</p>
<div>
<ul>
<li>Recognize situations where pattern matching should be used.</li>
<li>Use pattern matching expressions to implement behavior based on types and property values.</li>
<li>Combine pattern matching with other techniques to create complete algorithms.</li>
</ul>
</div>
<h2 id="prerequisites">Prerequisites<a href="#prerequisites" aria-labelledby="prerequisites"></a></h2>
<p>Youâ€™ll need to set up your machine to run .NET Core, including the C# 8.0 compiler. The C# 8 compiler is available starting with <a href="https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&amp;utm_source=docs.microsoft.com&amp;utm_campaign=inline+link&amp;utm_content=download+vs2019" data-linktype="external">Visual Studio 2019 version 16.3</a> or <a href="https://dotnet.microsoft.com/download" data-linktype="external">.NET Core 3.0 SDK</a>.</p>
<p>This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</p>
<h2 id="scenarios-for-pattern-matching">Scenarios for pattern matching<a href="#scenarios-for-pattern-matching" aria-labelledby="scenarios-for-pattern-matching"></a></h2>
<p>Modern development often includes integrating data from multiple sources and presenting information and insights from that data in a single cohesive application. You and your team won't have control or access for all the types that represent the incoming data.</p>
<p>The classic object-oriented design would call for creating types in your application that represent each data type from those multiple data sources. Then, your application would work with those new types, build inheritance hierarchies, create virtual methods, and implement abstractions. Those techniques work, and sometimes they are the best tools. Other times you can write less code. You can write more clear code using techniques that separate the data from the operations that manipulate that data.</p>
<p>In this tutorial, you'll create and explore an application that takes incoming data from several external sources for a single scenario. You'll see how <strong>pattern matching</strong> provides an efficient way to consume and process that data in ways that weren't part of the original system.</p>
<p>Consider a major metropolitan area that is using tolls and peak time pricing to manage traffic. You write an application that calculates tolls for a vehicle based on its type. Later enhancements incorporate pricing based on the number of occupants in the vehicle. Further enhancements add pricing based on the time and the day of the week.</p>
<p>From that brief description, you may have quickly sketched out an object hierarchy to model this system. However, your data is coming from multiple sources like other vehicle registration management systems. These systems provide different classes to model that data and you don't have a single object model you can use. In this tutorial, you'll use these simplified classes to model for the vehicle data from these external systems, as shown in the following code:</p>
<pre tabindex="0"><code name="ExternalSystems" data-author-content="namespace ConsumerVehicleRegistration
{
    public class Car
    {
        public int Passengers { get; set; }
    }
}

namespace CommercialRegistration
{
    public class DeliveryTruck
    {
        public int GrossWeightClass { get; set; }
    }
}

namespace LiveryRegistration
{
    public class Taxi
    {
        public int Fares { get; set; }
    }

    public class Bus
    {
        public int Capacity { get; set; }
        public int Riders { get; set; }
    }
}
"><span><span>namespace</span> <span>ConsumerVehicleRegistration</span>
{
    <span>public</span> <span>class</span> <span>Car</span>
    {
        <span>public</span> <span>int</span> Passengers { <span>get</span>; <span>set</span>; }
    }
}

<span>namespace</span> <span>CommercialRegistration</span>
{
    <span>public</span> <span>class</span> <span>DeliveryTruck</span>
    {
        <span>public</span> <span>int</span> GrossWeightClass { <span>get</span>; <span>set</span>; }
    }
}

<span>namespace</span> <span>LiveryRegistration</span>
{
    <span>public</span> <span>class</span> <span>Taxi</span>
    {
        <span>public</span> <span>int</span> Fares { <span>get</span>; <span>set</span>; }
    }

    <span>public</span> <span>class</span> <span>Bus</span>
    {
        <span>public</span> <span>int</span> Capacity { <span>get</span>; <span>set</span>; }
        <span>public</span> <span>int</span> Riders { <span>get</span>; <span>set</span>; }
    }
}
</span></code></pre>
<p>You can download the starter code from the <a href="https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/start" data-linktype="external">dotnet/samples</a> GitHub repository. You can see that the vehicle classes are from different systems, and are in different namespaces. No common base class, other than <code>System.Object</code> can be leveraged.</p>
<h2 id="pattern-matching-designs">Pattern matching designs<a href="#pattern-matching-designs" aria-labelledby="pattern-matching-designs"></a></h2>
<p>The scenario used in this tutorial highlights the kinds of problems that pattern matching is well-suited to solve:</p>
<ul>
<li>The objects you need to work with aren't in an object hierarchy that matches your goals. You may be working with classes that are part of unrelated systems.</li>
<li>The functionality you're adding isn't part of the core abstraction for these classes. The toll paid by a vehicle <em>changes</em> for different types of vehicles, but the toll isn't a core function of the vehicle.</li>
</ul>
<p>When the <em>shape</em> of the data and the <em>operations</em> on that data are not described together, the pattern matching features in C# make it easier to work with.</p>
<h2 id="implement-the-basic-toll-calculations">Implement the basic toll calculations<a href="#implement-the-basic-toll-calculations" aria-labelledby="implement-the-basic-toll-calculations"></a></h2>
<p>The most basic toll calculation relies only on the vehicle type:</p>
<ul>
<li>A <code>Car</code> is $2.00.</li>
<li>A <code>Taxi</code> is $3.50.</li>
<li>A <code>Bus</code> is $5.00.</li>
<li>A <code>DeliveryTruck</code> is $10.00</li>
</ul>
<p>Create a new <code>TollCalculator</code> class, and implement pattern matching on the vehicle type to get the toll amount. The following code shows the initial implementation of the <code>TollCalculator</code>.</p>
<pre tabindex="0"><code data-author-content="using System;
using CommercialRegistration;
using ConsumerVehicleRegistration;
using LiveryRegistration;

namespace toll_calculator
{
    public class TollCalculator
    {
        public decimal CalculateToll(object vehicle) =>
            vehicle switch
        {
            Car c           => 2.00m,
            Taxi t          => 3.50m,
            Bus b           => 5.00m,
            DeliveryTruck t => 10.00m,
            { }             => throw new ArgumentException(message: &quot;Not a known vehicle type&quot;, paramName: nameof(vehicle)),
            null            => throw new ArgumentNullException(nameof(vehicle))
        };
    }
}
"><span><span>using</span> System;
<span>using</span> CommercialRegistration;
<span>using</span> ConsumerVehicleRegistration;
<span>using</span> LiveryRegistration;

<span>namespace</span> <span>toll_calculator</span>
{
    <span>public</span> <span>class</span> <span>TollCalculator</span>
    {
        <span><span>public</span> <span>decimal</span> <span>CalculateToll</span>(<span><span>object</span> vehicle</span>)</span> =&gt;
            vehicle <span>switch</span>
        {
            Car c           =&gt; <span>2.00</span>m,
            Taxi t          =&gt; <span>3.50</span>m,
            Bus b           =&gt; <span>5.00</span>m,
            DeliveryTruck t =&gt; <span>10.00</span>m,
            { }             =&gt; <span>throw</span> <span>new</span> ArgumentException(message: <span>"Not a known vehicle type"</span>, paramName: <span>nameof</span>(vehicle)),
            <span>null</span>            =&gt; <span>throw</span> <span>new</span> ArgumentNullException(<span>nameof</span>(vehicle))
        };
    }
}
</span></code></pre>
<p>The preceding code uses a <strong>switch expression</strong> (not the same as a <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch" data-linktype="relative-path"><code>switch</code></a> statement) that tests the <strong>type pattern</strong>. A <strong>switch expression</strong> begins with the variable, <code>vehicle</code> in the preceding code, followed by the <code>switch</code> keyword. Next comes all the <strong>switch arms</strong> inside curly braces. The <code>switch</code> expression makes other refinements to the syntax that surrounds the <code>switch</code> statement. The <code>case</code> keyword is omitted, and the result of each arm is an expression. The last two arms show a new language feature. The <code>{ }</code> case matches any non-null object that didn't match an earlier arm. This arm catches any incorrect types passed to this method.  The <code>{ }</code> case must follow the cases for each vehicle type. If the order were reversed, the <code>{ }</code> case would take precedence. Finally, the <code>null</code> pattern detects when a <code>null</code> is passed to this method. The <code>null</code> pattern can be last because the other type patterns match only a non-null object of the correct type.</p>
<p>You can test this code using the following code in <code>Program.cs</code>:</p>
<pre tabindex="0"><code data-author-content="using System;
using CommercialRegistration;
using ConsumerVehicleRegistration;
using LiveryRegistration;

namespace toll_calculator
{
    class Program
    {
        static void Main(string[] args)
        {
            var tollCalc = new TollCalculator();

            var car = new Car();
            var taxi = new Taxi();
            var bus = new Bus();
            var truck = new DeliveryTruck();

            Console.WriteLine($&quot;The toll for a car is {tollCalc.CalculateToll(car)}&quot;);
            Console.WriteLine($&quot;The toll for a taxi is {tollCalc.CalculateToll(taxi)}&quot;);
            Console.WriteLine($&quot;The toll for a bus is {tollCalc.CalculateToll(bus)}&quot;);
            Console.WriteLine($&quot;The toll for a truck is {tollCalc.CalculateToll(truck)}&quot;);

            try
            {
                tollCalc.CalculateToll(&quot;this will fail&quot;);
            }
            catch (ArgumentException e)
            {
                Console.WriteLine(&quot;Caught an argument exception when using the wrong type&quot;);
            }
            try
            {
                tollCalc.CalculateToll(null);
            }
            catch (ArgumentNullException e)
            {
                Console.WriteLine(&quot;Caught an argument exception when using null&quot;);
            }
        }
    }
}
"><span><span>using</span> System;
<span>using</span> CommercialRegistration;
<span>using</span> ConsumerVehicleRegistration;
<span>using</span> LiveryRegistration;

<span>namespace</span> <span>toll_calculator</span>
{
    <span>class</span> <span>Program</span>
    {
        <span><span>static</span> <span>void</span> <span>Main</span>(<span><span>string</span>[] args</span>)</span>
        {
            <span>var</span> tollCalc = <span>new</span> TollCalculator();

            <span>var</span> car = <span>new</span> Car();
            <span>var</span> taxi = <span>new</span> Taxi();
            <span>var</span> bus = <span>new</span> Bus();
            <span>var</span> truck = <span>new</span> DeliveryTruck();

            Console.WriteLine(<span>$"The toll for a car is <span>{tollCalc.CalculateToll(car)}</span>"</span>);
            Console.WriteLine(<span>$"The toll for a taxi is <span>{tollCalc.CalculateToll(taxi)}</span>"</span>);
            Console.WriteLine(<span>$"The toll for a bus is <span>{tollCalc.CalculateToll(bus)}</span>"</span>);
            Console.WriteLine(<span>$"The toll for a truck is <span>{tollCalc.CalculateToll(truck)}</span>"</span>);

            <span>try</span>
            {
                tollCalc.CalculateToll(<span>"this will fail"</span>);
            }
            <span>catch</span> (ArgumentException e)
            {
                Console.WriteLine(<span>"Caught an argument exception when using the wrong type"</span>);
            }
            <span>try</span>
            {
                tollCalc.CalculateToll(<span>null</span>);
            }
            <span>catch</span> (ArgumentNullException e)
            {
                Console.WriteLine(<span>"Caught an argument exception when using null"</span>);
            }
        }
    }
}
</span></code></pre>
<p>That code is included in the starter project, but is commented out. Remove the comments, and you can test what you've written.</p>
<p>You're starting to see how patterns can help you create algorithms where the code and the data are separate. The <code>switch</code> expression tests the type and produces different values based on the results. That's only the beginning.</p>
<h2 id="add-occupancy-pricing">Add occupancy pricing<a href="#add-occupancy-pricing" aria-labelledby="add-occupancy-pricing"></a></h2>
<p>The toll authority wants to encourage vehicles to travel at maximum capacity. They've decided to charge more when vehicles have fewer passengers, and encourage full vehicles by offering lower pricing:</p>
<ul>
<li>Cars and taxis with no passengers pay an extra $0.50.</li>
<li>Cars and taxis with two passengers get a $0.50 discount.</li>
<li>Cars and taxis with three or more passengers get a $1.00 discount.</li>
<li>Buses that are less than 50% full pay an extra $2.00.</li>
<li>Buses that are more than 90% full get a $1.00 discount.</li>
</ul>
<p>These rules can be implemented using the <strong>property pattern</strong> in the same switch expression. The property pattern examines properties of the object once the type has been determined. The single case for a <code>Car</code> expands to four different cases:</p>
<pre tabindex="0"><code data-author-content="vehicle switch
{
    Car { Passengers: 0}        => 2.00m + 0.50m,
    Car { Passengers: 1 }       => 2.0m,
    Car { Passengers: 2}        => 2.0m - 0.50m,
    Car c                       => 2.00m - 1.0m,

    // ...
};
"><span>vehicle <span>switch</span>
{
    Car { Passengers: <span>0</span>}        =&gt; <span>2.00</span>m + <span>0.50</span>m,
    Car { Passengers: <span>1</span> }       =&gt; <span>2.0</span>m,
    Car { Passengers: <span>2</span>}        =&gt; <span>2.0</span>m - <span>0.50</span>m,
    Car c                       =&gt; <span>2.00</span>m - <span>1.0</span>m,

    <span>// ...</span>
};
</span></code></pre>
<p>The first three cases test the type as a <code>Car</code>, then check the value of the <code>Passengers</code> property. If both match, that expression is evaluated and returned.</p>
<p>You would also expand the cases for taxis in a similar manner:</p>
<pre tabindex="0"><code data-author-content="vehicle switch
{
    // ...

    Taxi { Fares: 0}  => 3.50m + 1.00m,
    Taxi { Fares: 1 } => 3.50m,
    Taxi { Fares: 2}  => 3.50m - 0.50m,
    Taxi t            => 3.50m - 1.00m,

    // ...
};
"><span>vehicle <span>switch</span>
{
    <span>// ...</span>

    Taxi { Fares: <span>0</span>}  =&gt; <span>3.50</span>m + <span>1.00</span>m,
    Taxi { Fares: <span>1</span> } =&gt; <span>3.50</span>m,
    Taxi { Fares: <span>2</span>}  =&gt; <span>3.50</span>m - <span>0.50</span>m,
    Taxi t            =&gt; <span>3.50</span>m - <span>1.00</span>m,

    <span>// ...</span>
};
</span></code></pre>
<p>In the preceding example, the <code>when</code> clause was omitted on the final case.</p>
<p>Next, implement the occupancy rules by expanding the cases for buses, as shown in the following example:</p>
<pre tabindex="0"><code data-author-content="vehicle switch
{
    // ...

    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,
    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,
    Bus b => 5.00m,

    // ...
};
"><span>vehicle <span>switch</span>
{
    <span>// ...</span>

    <span>Bus b <span>when</span> (<span>(<span>double</span></span>)b.Riders / (<span><span>double</span></span>)b.Capacity) &lt; 0.50</span> =&gt; <span>5.00</span>m + <span>2.00</span>m,
    <span>Bus b <span>when</span> (<span>(<span>double</span></span>)b.Riders / (<span><span>double</span></span>)b.Capacity) &gt; 0.90</span> =&gt; <span>5.00</span>m - <span>1.00</span>m,
    Bus b =&gt; <span>5.00</span>m,

    <span>// ...</span>
};
</span></code></pre>
<p>The toll authority isn't concerned with the number of passengers in the delivery trucks. Instead, they adjust the toll amount based on the weight class of the trucks as follows:</p>
<ul>
<li>Trucks over 5000 lbs are charged an extra $5.00.</li>
<li>Light trucks under 3000 lbs are given a $2.00 discount.</li>
</ul>
<p>That rule is implemented with the following code:</p>
<pre tabindex="0"><code data-author-content="vehicle switch
{
    // ...

    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,
    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,
    DeliveryTruck t => 10.00m,
};
"><span>vehicle <span>switch</span>
{
    <span>// ...</span>

    <span>DeliveryTruck t <span>when</span> (<span>t.GrossWeightClass &gt; <span>5000</span></span>)</span> =&gt; <span>10.00</span>m + <span>5.00</span>m,
    <span>DeliveryTruck t <span>when</span> (<span>t.GrossWeightClass &lt; <span>3000</span></span>)</span> =&gt; <span>10.00</span>m - <span>2.00</span>m,
    DeliveryTruck t =&gt; <span>10.00</span>m,
};
</span></code></pre>
<p>The preceding code shows the <code>when</code> clause of a switch arm. You use the <code>when</code> clause to test conditions other than equality on a property. When you've finished, you'll have a method that looks much like the following:</p>
<pre tabindex="0"><code data-author-content="vehicle switch
{
    Car { Passengers: 0}        => 2.00m + 0.50m,
    Car { Passengers: 1}        => 2.0m,
    Car { Passengers: 2}        => 2.0m - 0.50m,
    Car c                       => 2.00m - 1.0m,

    Taxi { Fares: 0}  => 3.50m + 1.00m,
    Taxi { Fares: 1 } => 3.50m,
    Taxi { Fares: 2}  => 3.50m - 0.50m,
    Taxi t            => 3.50m - 1.00m,

    Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,
    Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,
    Bus b => 5.00m,

    DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,
    DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,
    DeliveryTruck t => 10.00m,
    
    { }     => throw new ArgumentException(message: &quot;Not a known vehicle type&quot;, paramName: nameof(vehicle)),
    null    => throw new ArgumentNullException(nameof(vehicle))
};
"><span>vehicle <span>switch</span>
{
    Car { Passengers: <span>0</span>}        =&gt; <span>2.00</span>m + <span>0.50</span>m,
    Car { Passengers: <span>1</span>}        =&gt; <span>2.0</span>m,
    Car { Passengers: <span>2</span>}        =&gt; <span>2.0</span>m - <span>0.50</span>m,
    Car c                       =&gt; <span>2.00</span>m - <span>1.0</span>m,

    Taxi { Fares: <span>0</span>}  =&gt; <span>3.50</span>m + <span>1.00</span>m,
    Taxi { Fares: <span>1</span> } =&gt; <span>3.50</span>m,
    Taxi { Fares: <span>2</span>}  =&gt; <span>3.50</span>m - <span>0.50</span>m,
    Taxi t            =&gt; <span>3.50</span>m - <span>1.00</span>m,

    <span>Bus b <span>when</span> (<span>(<span>double</span></span>)b.Riders / (<span><span>double</span></span>)b.Capacity) &lt; 0.50</span> =&gt; <span>5.00</span>m + <span>2.00</span>m,
    <span>Bus b <span>when</span> (<span>(<span>double</span></span>)b.Riders / (<span><span>double</span></span>)b.Capacity) &gt; 0.90</span> =&gt; <span>5.00</span>m - <span>1.00</span>m,
    Bus b =&gt; <span>5.00</span>m,

    <span>DeliveryTruck t <span>when</span> (<span>t.GrossWeightClass &gt; <span>5000</span></span>)</span> =&gt; <span>10.00</span>m + <span>5.00</span>m,
    <span>DeliveryTruck t <span>when</span> (<span>t.GrossWeightClass &lt; <span>3000</span></span>)</span> =&gt; <span>10.00</span>m - <span>2.00</span>m,
    DeliveryTruck t =&gt; <span>10.00</span>m,
    
    { }     =&gt; <span>throw</span> <span>new</span> ArgumentException(message: <span>"Not a known vehicle type"</span>, paramName: <span>nameof</span>(vehicle)),
    <span>null</span>    =&gt; <span>throw</span> <span>new</span> ArgumentNullException(<span>nameof</span>(vehicle))
};
</span></code></pre>
<p>Many of these switch arms are examples of <strong>recursive patterns</strong>. For example, <code>Car { Passengers: 1}</code> shows a constant pattern inside a property pattern.</p>
<p>You can make this code less repetitive by using nested switches. The <code>Car</code> and <code>Taxi</code> both have four different arms in the preceding examples. In both cases, you can create a type pattern that feeds into a property pattern. This technique is shown in the following code:</p>
<pre tabindex="0"><code data-author-content="public decimal CalculateToll(object vehicle) =>
    vehicle switch
    {
        Car c => c.Passengers switch
        {
            0 => 2.00m + 0.5m,
            1 => 2.0m,
            2 => 2.0m - 0.5m,
            _ => 2.00m - 1.0m
        },

        Taxi t => t.Fares switch
        {
            0 => 3.50m + 1.00m,
            1 => 3.50m,
            2 => 3.50m - 0.50m,
            _ => 3.50m - 1.00m
        },

        Bus b when ((double)b.Riders / (double)b.Capacity) < 0.50 => 5.00m + 2.00m,
        Bus b when ((double)b.Riders / (double)b.Capacity) > 0.90 => 5.00m - 1.00m,
        Bus b => 5.00m,

        DeliveryTruck t when (t.GrossWeightClass > 5000) => 10.00m + 5.00m,
        DeliveryTruck t when (t.GrossWeightClass < 3000) => 10.00m - 2.00m,
        DeliveryTruck t => 10.00m,

        { }  => throw new ArgumentException(message: &quot;Not a known vehicle type&quot;, paramName: nameof(vehicle)),
        null => throw new ArgumentNullException(nameof(vehicle))
    };
"><span><span><span>public</span> <span>decimal</span> <span>CalculateToll</span>(<span><span>object</span> vehicle</span>)</span> =&gt;
    vehicle <span>switch</span>
    {
        Car c =&gt; c.Passengers <span>switch</span>
        {
            <span>0</span> =&gt; <span>2.00</span>m + <span>0.5</span>m,
            <span>1</span> =&gt; <span>2.0</span>m,
            <span>2</span> =&gt; <span>2.0</span>m - <span>0.5</span>m,
            _ =&gt; <span>2.00</span>m - <span>1.0</span>m
        },

        Taxi t =&gt; t.Fares <span>switch</span>
        {
            <span>0</span> =&gt; <span>3.50</span>m + <span>1.00</span>m,
            <span>1</span> =&gt; <span>3.50</span>m,
            <span>2</span> =&gt; <span>3.50</span>m - <span>0.50</span>m,
            _ =&gt; <span>3.50</span>m - <span>1.00</span>m
        },

        <span>Bus b <span>when</span> (<span>(<span>double</span></span>)b.Riders / (<span><span>double</span></span>)b.Capacity) &lt; 0.50</span> =&gt; <span>5.00</span>m + <span>2.00</span>m,
        <span>Bus b <span>when</span> (<span>(<span>double</span></span>)b.Riders / (<span><span>double</span></span>)b.Capacity) &gt; 0.90</span> =&gt; <span>5.00</span>m - <span>1.00</span>m,
        Bus b =&gt; <span>5.00</span>m,

        <span>DeliveryTruck t <span>when</span> (<span>t.GrossWeightClass &gt; <span>5000</span></span>)</span> =&gt; <span>10.00</span>m + <span>5.00</span>m,
        <span>DeliveryTruck t <span>when</span> (<span>t.GrossWeightClass &lt; <span>3000</span></span>)</span> =&gt; <span>10.00</span>m - <span>2.00</span>m,
        DeliveryTruck t =&gt; <span>10.00</span>m,

        { }  =&gt; <span>throw</span> <span>new</span> ArgumentException(message: <span>"Not a known vehicle type"</span>, paramName: <span>nameof</span>(vehicle)),
        <span>null</span> =&gt; <span>throw</span> <span>new</span> ArgumentNullException(<span>nameof</span>(vehicle))
    };
</span></code></pre>
<p>In the preceding sample, using a recursive expression means you don't repeat the <code>Car</code> and <code>Taxi</code> arms containing child arms that test the property value. This technique isn't used for the <code>Bus</code> and <code>DeliveryTruck</code> arms because those arms are testing ranges for the property, not discrete values.</p>
<h2 id="add-peak-pricing">Add peak pricing<a href="#add-peak-pricing" aria-labelledby="add-peak-pricing"></a></h2>
<p>For the final feature, the toll authority wants to add time sensitive peak pricing. During the morning and evening rush hours, the tolls are doubled. That rule only affects traffic in one direction: inbound to the city in the morning, and outbound in the evening rush hour. During other times during the workday, tolls increase by 50%. Late night and early morning, tolls are reduced by 25%. During the weekend, it's the normal rate, regardless of the time.</p>
<p>You'll use pattern matching for this feature, but you'll integrate it with other techniques. You could build a single pattern match expression that would account for all the combinations of direction, day of the week, and time. The result would be a complicated expression. It would be hard to read and difficult to understand. That makes it hard to ensure correctness. Instead, combine those methods to build a tuple of values that concisely describes all those states. Then use pattern matching to calculate a multiplier for the toll. The tuple contains three discrete conditions:</p>
<ul>
<li>The day is either a weekday or a weekend.</li>
<li>The band of time when the toll is collected.</li>
<li>The direction is into the city or out of the city</li>
</ul>
<p>The following table shows the combinations of input values and the peak pricing multiplier:</p>

<p>There are 16 different combinations of the three variables. By combining some of the conditions, you'll simplify the final switch expression.</p>
<p>The system that collects the tolls uses a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.datetime" data-linktype="absolute-path">DateTime</a> structure for the time when the toll was collected. Build member methods that create the variables from the preceding table. The following function uses a pattern matching switch expression to express whether a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.datetime" data-linktype="absolute-path">DateTime</a> represents a weekend or a weekday:</p>
<pre tabindex="0"><code data-author-content="private static bool IsWeekDay(DateTime timeOfToll) =>
    timeOfToll.DayOfWeek switch
    {
        DayOfWeek.Monday    => true,
        DayOfWeek.Tuesday   => true,
        DayOfWeek.Wednesday => true,
        DayOfWeek.Thursday  => true,
        DayOfWeek.Friday    => true,
        DayOfWeek.Saturday  => false,
        DayOfWeek.Sunday    => false
    };
"><span><span><span>private</span> <span>static</span> <span>bool</span> <span>IsWeekDay</span>(<span>DateTime timeOfToll</span>)</span> =&gt;
    timeOfToll.DayOfWeek <span>switch</span>
    {
        DayOfWeek.Monday    =&gt; <span>true</span>,
        DayOfWeek.Tuesday   =&gt; <span>true</span>,
        DayOfWeek.Wednesday =&gt; <span>true</span>,
        DayOfWeek.Thursday  =&gt; <span>true</span>,
        DayOfWeek.Friday    =&gt; <span>true</span>,
        DayOfWeek.Saturday  =&gt; <span>false</span>,
        DayOfWeek.Sunday    =&gt; <span>false</span>
    };
</span></code></pre>
<p>That method works, but it's repetitious. You can simplify it, as shown in the following code:</p>
<pre tabindex="0"><code name="IsWeekDay" data-author-content="private static bool IsWeekDay(DateTime timeOfToll) =>
    timeOfToll.DayOfWeek switch
    {
        DayOfWeek.Saturday => false,
        DayOfWeek.Sunday   => false,
        _                  => true
    };
"><span><span><span>private</span> <span>static</span> <span>bool</span> <span>IsWeekDay</span>(<span>DateTime timeOfToll</span>)</span> =&gt;
    timeOfToll.DayOfWeek <span>switch</span>
    {
        DayOfWeek.Saturday =&gt; <span>false</span>,
        DayOfWeek.Sunday   =&gt; <span>false</span>,
        _                  =&gt; <span>true</span>
    };
</span></code></pre>
<p>Next, add a similar function to categorize the time into the blocks:</p>
<pre tabindex="0"><code name="GetTimeBand" data-author-content="private enum TimeBand
{
    MorningRush,
    Daytime,
    EveningRush,
    Overnight
}

private static TimeBand GetTimeBand(DateTime timeOfToll)
{
    int hour = timeOfToll.Hour;
    if (hour < 6)
        return TimeBand.Overnight;
    else if (hour < 10)
        return TimeBand.MorningRush;
    else if (hour < 16)
        return TimeBand.Daytime;
    else if (hour < 20)
        return TimeBand.EveningRush;
    else
        return TimeBand.Overnight;
}
"><span><span>private</span> <span>enum</span> TimeBand
{
    MorningRush,
    Daytime,
    EveningRush,
    Overnight
}

<span><span>private</span> <span>static</span> TimeBand <span>GetTimeBand</span>(<span>DateTime timeOfToll</span>)</span>
{
    <span>int</span> hour = timeOfToll.Hour;
    <span>if</span> (hour &lt; <span>6</span>)
        <span>return</span> TimeBand.Overnight;
    <span>else</span> <span>if</span> (hour &lt; <span>10</span>)
        <span>return</span> TimeBand.MorningRush;
    <span>else</span> <span>if</span> (hour &lt; <span>16</span>)
        <span>return</span> TimeBand.Daytime;
    <span>else</span> <span>if</span> (hour &lt; <span>20</span>)
        <span>return</span> TimeBand.EveningRush;
    <span>else</span>
        <span>return</span> TimeBand.Overnight;
}
</span></code></pre>
<p>The previous method doesn't use pattern matching. It's clearer using a familiar cascade of <code>if</code> statements. You do add a private <code>enum</code> to convert each range of time to a discrete value.</p>
<p>After you create those methods, you can use another <code>switch</code> expression with the <strong>tuple pattern</strong> to calculate the pricing premium. You could build a <code>switch</code> expression with all 16 arms:</p>
<pre tabindex="0"><code name="FullTuplePattern" data-author-content="public decimal PeakTimePremiumFull(DateTime timeOfToll, bool inbound) =>
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch
    {
        (true,  TimeBand.MorningRush, true)  => 2.00m,
        (true,  TimeBand.MorningRush, false) => 1.00m,
        (true,  TimeBand.Daytime,     true)  => 1.50m,
        (true,  TimeBand.Daytime,     false) => 1.50m,
        (true,  TimeBand.EveningRush, true)  => 1.00m,
        (true,  TimeBand.EveningRush, false) => 2.00m,
        (true,  TimeBand.Overnight,   true)  => 0.75m,
        (true,  TimeBand.Overnight,   false) => 0.75m,
        (false, TimeBand.MorningRush, true)  => 1.00m,
        (false, TimeBand.MorningRush, false) => 1.00m,
        (false, TimeBand.Daytime,     true)  => 1.00m,
        (false, TimeBand.Daytime,     false) => 1.00m,
        (false, TimeBand.EveningRush, true)  => 1.00m,
        (false, TimeBand.EveningRush, false) => 1.00m,
        (false, TimeBand.Overnight,   true)  => 1.00m,
        (false, TimeBand.Overnight,   false) => 1.00m,
    };
"><span><span><span>public</span> <span>decimal</span> <span>PeakTimePremiumFull</span>(<span>DateTime timeOfToll, <span>bool</span> inbound</span>)</span> =&gt;
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) <span>switch</span>
    {
        (<span>true</span>,  TimeBand.MorningRush, <span>true</span>)  =&gt; <span>2.00</span>m,
        (<span>true</span>,  TimeBand.MorningRush, <span>false</span>) =&gt; <span>1.00</span>m,
        (<span>true</span>,  TimeBand.Daytime,     <span>true</span>)  =&gt; <span>1.50</span>m,
        (<span>true</span>,  TimeBand.Daytime,     <span>false</span>) =&gt; <span>1.50</span>m,
        (<span>true</span>,  TimeBand.EveningRush, <span>true</span>)  =&gt; <span>1.00</span>m,
        (<span>true</span>,  TimeBand.EveningRush, <span>false</span>) =&gt; <span>2.00</span>m,
        (<span>true</span>,  TimeBand.Overnight,   <span>true</span>)  =&gt; <span>0.75</span>m,
        (<span>true</span>,  TimeBand.Overnight,   <span>false</span>) =&gt; <span>0.75</span>m,
        (<span>false</span>, TimeBand.MorningRush, <span>true</span>)  =&gt; <span>1.00</span>m,
        (<span>false</span>, TimeBand.MorningRush, <span>false</span>) =&gt; <span>1.00</span>m,
        (<span>false</span>, TimeBand.Daytime,     <span>true</span>)  =&gt; <span>1.00</span>m,
        (<span>false</span>, TimeBand.Daytime,     <span>false</span>) =&gt; <span>1.00</span>m,
        (<span>false</span>, TimeBand.EveningRush, <span>true</span>)  =&gt; <span>1.00</span>m,
        (<span>false</span>, TimeBand.EveningRush, <span>false</span>) =&gt; <span>1.00</span>m,
        (<span>false</span>, TimeBand.Overnight,   <span>true</span>)  =&gt; <span>1.00</span>m,
        (<span>false</span>, TimeBand.Overnight,   <span>false</span>) =&gt; <span>1.00</span>m,
    };
</span></code></pre>
<p>The above code works, but it can be simplified. All eight combinations for the weekend have the same toll. You can replace all eight with the following line:</p>
<pre tabindex="0"><code data-author-content="(false, _, _) => 1.0m,
"><span>(<span>false</span>, _, _) =&gt; <span>1.0</span>m,
</span></code></pre>
<p>Both inbound and outbound traffic have the same multiplier during the weekday daytime and overnight hours. Those four switch arms can be replaced with the following two lines:</p>
<pre tabindex="0"><code data-author-content="(true, TimeBand.Overnight, _) => 0.75m,
(true, TimeBand.Daytime, _)   => 1.5m,
"><span>(<span>true</span>, TimeBand.Overnight, _) =&gt; <span>0.75</span>m,
(<span>true</span>, TimeBand.Daytime, _)   =&gt; <span>1.5</span>m,
</span></code></pre>
<p>The code should look like the following code after those two changes:</p>
<pre tabindex="0"><code data-author-content="public decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch
    {
        (true, TimeBand.MorningRush, true)  => 2.00m,
        (true, TimeBand.MorningRush, false) => 1.00m,
        (true, TimeBand.Daytime,     _)     => 1.50m,
        (true, TimeBand.EveningRush, true)  => 1.00m,
        (true, TimeBand.EveningRush, false) => 2.00m,
        (true, TimeBand.Overnight,   _)     => 0.75m,
        (false, _,                   _)     => 1.00m,
    };
"><span><span><span>public</span> <span>decimal</span> <span>PeakTimePremium</span>(<span>DateTime timeOfToll, <span>bool</span> inbound</span>)</span> =&gt;
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) <span>switch</span>
    {
        (<span>true</span>, TimeBand.MorningRush, <span>true</span>)  =&gt; <span>2.00</span>m,
        (<span>true</span>, TimeBand.MorningRush, <span>false</span>) =&gt; <span>1.00</span>m,
        (<span>true</span>, TimeBand.Daytime,     _)     =&gt; <span>1.50</span>m,
        (<span>true</span>, TimeBand.EveningRush, <span>true</span>)  =&gt; <span>1.00</span>m,
        (<span>true</span>, TimeBand.EveningRush, <span>false</span>) =&gt; <span>2.00</span>m,
        (<span>true</span>, TimeBand.Overnight,   _)     =&gt; <span>0.75</span>m,
        (<span>false</span>, _,                   _)     =&gt; <span>1.00</span>m,
    };
</span></code></pre>
<p>Finally, you can remove the two rush hour times that pay the regular price. Once you remove those arms, you can replace the <code>false</code> with a discard (<code>_</code>) in the final switch arm. You'll have the following finished method:</p>
<pre tabindex="0"><code name="SimplifiedTuplePattern" data-author-content="public decimal PeakTimePremium(DateTime timeOfToll, bool inbound) =>
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) switch
    {
        (true, TimeBand.Overnight,   _)     => 0.75m,
        (true, TimeBand.Daytime,     _)     => 1.5m,
        (true, TimeBand.MorningRush, true)  => 2.0m,
        (true, TimeBand.EveningRush, false) => 2.0m,
        (_,    _,                    _)     => 1.0m,
    };
"><span><span><span>public</span> <span>decimal</span> <span>PeakTimePremium</span>(<span>DateTime timeOfToll, <span>bool</span> inbound</span>)</span> =&gt;
    (IsWeekDay(timeOfToll), GetTimeBand(timeOfToll), inbound) <span>switch</span>
    {
        (<span>true</span>, TimeBand.Overnight,   _)     =&gt; <span>0.75</span>m,
        (<span>true</span>, TimeBand.Daytime,     _)     =&gt; <span>1.5</span>m,
        (<span>true</span>, TimeBand.MorningRush, <span>true</span>)  =&gt; <span>2.0</span>m,
        (<span>true</span>, TimeBand.EveningRush, <span>false</span>) =&gt; <span>2.0</span>m,
        (_,    _,                    _)     =&gt; <span>1.0</span>m,
    };
</span></code></pre>
<p>This example highlights one of the advantages of pattern matching: the pattern branches are evaluated in order. If you rearrange them so that an earlier branch handles one of your later cases, the compiler warns you about the unreachable code. Those language rules made it easier to do the preceding simplifications with confidence that the code didn't change.</p>
<p>Pattern matching makes some types of code more readable and offers an alternative to object-oriented techniques when you can't add code to your classes. The cloud is causing data and functionality to live apart. The <em>shape</em> of the data and the <em>operations</em> on it aren't necessarily described together. In this tutorial, you consumed existing data in entirely different ways from its original function. Pattern matching gave you the ability to write functionality that overrode those types, even though you couldn't extend them.</p>
<h2 id="next-steps">Next steps<a href="#next-steps" aria-labelledby="next-steps"></a></h2>
<p>You can download the finished code from the <a href="https://github.com/dotnet/samples/tree/master/csharp/tutorials/patterns/finished" data-linktype="external">dotnet/samples</a> GitHub repository. Explore patterns on your own and add this technique into your regular coding activities. Learning these techniques gives you another way to approach problems and create new functionality.</p>

						<!-- </content> -->

						</main>

						<!-- recommended content page section -->

							<nav data-bi-name="recommendation-bottom" hidden="" id="recommended-content-center" aria-labelledby="recommended-content-center-title">
								<h3 id="recommended-content-center-title">Related Articles</h3>
							</nav>

						<!-- end recommended content page section -->

						<!-- rating mobile section -->
								
						<!-- end rating mobile section -->

						<!-- feedback section -->



<section data-bi-name="feedback-section">

	<h2 id="feedback">Feedback</h2>

	

	

	

	<div data-tab-group-independent="" hidden="" data-bi-name="tab-group">
		<ul role="tablist">
			<li role="presentation">
				<a href="#tabpanel-issues-open" role="tab" aria-controls="tabpanel-issues-open" data-tab="issues-open" data-bi-name="tab" aria-selected="true" tabindex="0"></a>
			</li>
			<li role="presentation">
				<a href="#tabpanel-issues-closed" role="tab" aria-controls="tabpanel-issues-closed" data-tab="issues-closed" data-bi-name="tab" aria-selected="false" tabindex="-1"></a>
			</li>
		</ul>
		<section id="tabpanel-issues-open" role="tabpanel" data-tab="issues-open">
			
			<ul aria-label="Open Issues"></ul>
		</section>
		<section id="tabpanel-issues-closed" role="tabpanel" data-tab="issues-closed" hidden="hidden" aria-hidden="true">
			<div>There are no closed issues</div>
			<ul aria-label="Closed Issues"></ul>
		</section>
	</div>
	
</section>

						<!-- end feedback section -->

						<!-- feedback report section -->
						<!-- end feedback report section -->

						
					</div>

					

					<!--end of div.columns -->
				</div>

			<!--end of .primary-holder -->
			</section>

			
		</div>

		<!--end of .mainContainer -->
	</div>

	

	

		
		
	


</div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>