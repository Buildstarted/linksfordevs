<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Don&#x27;t Judge XAML Based On Lines of Code - Nick&#x27;s .NET Travels - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Don&#x27;t Judge XAML Based On Lines of Code - Nick&#x27;s .NET Travels - linksfor.dev(s)"/>
    <meta property="og:description" content="For those following the on-going discussion around the future of XAML and specifically the use of XAML in DotNetMaui/Xamarin.Forms, this post is a follow on from two great posts discussing the options that are, or will be, available for Xamarin.Forms developers as we move forward with DotNetMaui: Mobile Blazor Bindings &#x2013; Getting Started &#x2B; Why &#x2026; Continue reading &quot;Don&#x2019;t Judge XAML Based On Lines of Code&quot;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://nicksnettravels.builttoroam.com/xaml-lines-of-code/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Don&#x27;t Judge XAML Based On Lines of Code - Nick&#x27;s .NET Travels</title>
<div class="readable">
        <h1>Don&#x27;t Judge XAML Based On Lines of Code - Nick&#x27;s .NET Travels</h1>
            <div>Reading time: 23-30 minutes</div>
        <div>Posted here: 28 Jul 2020</div>
        <p><a href="https://nicksnettravels.builttoroam.com/xaml-lines-of-code/">https://nicksnettravels.builttoroam.com/xaml-lines-of-code/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p>For those following the on-going discussion around the future of XAML and specifically the use of XAML in DotNetMaui/Xamarin.Forms, this post is a follow on from two great posts discussing the options that are, or will be, available for Xamarin.Forms developers as we move forward with DotNetMaui: Mobile Blazor Bindings – Getting Started + Why … <a href="https://nicksnettravels.builttoroam.com/xaml-lines-of-code/">Continue reading<span> “Don’t Judge XAML Based On Lines of Code”</span></a></p><div>
<p>For those following the on-going discussion around the future of XAML and specifically the use of XAML in <a href="https://github.com/dotnet/maui">DotNetMaui</a>/<a href="https://github.com/xamarin/xamarin.forms">Xamarin.Forms</a>, this post is a follow on from two great posts discussing the options that are, or will be, available for Xamarin.Forms developers as we move forward with DotNetMaui:</p>
<ul><li><a href="https://www.dylanberry.com/2020/02/05/mobile-blazor-bindings-getting-started-why-you-should-care/">Mobile Blazor Bindings – Getting Started + Why You Should Care</a> (Dylan Berry)</li><li><a href="https://vincenth.net/blog/2020/07/11/c-markup-versus-mobile-blazor-bindings-in-net-maui">C# Markup versus Mobile Blazor Bindings in .NET MAUI</a> (Vincent Hoogendoorn)</li></ul>
<p>I’ve <a href="https://nicksnettravels.builttoroam.com/dotnetmaui-not-a-xaml-platform/">already discussed</a> why I feel that DotNetMaui will extend Xamarin.Forms to be an inclusive platform for developers wanting to build cross platform applications. Recent additions to Xamarin.Forms, such as <a href="https://devblogs.microsoft.com/xamarin/c-sharp-markup-for-xamarin-forms/">C# markup</a>, coupled with the features outlined on the DotNetMaui <a href="https://devblogs.microsoft.com/dotnet/introducing-net-multi-platform-app-ui/">roadmap</a>, suggest that the path forward will be full of options for developers.</p>
<p>This bring me to the point of this post, which is to discuss XAML both in the context of DotNetMaui/Xamarin.Forms but also in the context of <a href="https://docs.microsoft.com/en-us/windows/uwp/">UWP</a>/<a href="https://microsoft.github.io/microsoft-ui-xaml/">WinUI</a>/<a href="https://platform.uno/">Uno</a>. To do this I’m going to re-visit the scenario discussed by Dylan and Vincent and look at some alternatives that might make XAML a bit more appealing</p>
<h2>Xamarin.Forms Visual States</h2>
<p>When I initial read through Dylan’s post and reviewed the XAML I was initially shocked at how hard it was to read and in fact it took me a while to realise why it looked so chaotic and hard to follow. It came down to a couple of things:</p>
<ul><li>Changing XAML attribute values based on data triggers at various points in the XAML</li><li>The lack of Visual States</li><li>Using MultiTrigger to change attribute values based on multiple data values.</li></ul>
<p>Just so that I’m clear, I’m not saying that the code was poorly written; I’m just observing why I found it hard to read. Let me present an alternative XAML for the page and discuss how it makes the code a little more readable.</p>
<pre><span><span>&lt;?</span>xml version=<span>"1.0"</span> encoding=<span>"utf-8"</span><span>?&gt;</span></span>
<span>&lt;<span>ContentPage</span>
    <span>xmlns</span>=<span>"http://xamarin.com/schemas/2014/forms"</span>
    <span>xmlns:x</span>=<span>"http://schemas.microsoft.com/winfx/2009/xaml"</span>
    <span>xmlns:local</span>=<span>"clr-namespace:XamlFlags"</span>
    <span>x:Class</span>=<span>"XamlFlags.MainPage"</span>
    <span>x:Name</span>=<span>"Page"</span>&gt;</span>
    <span>&lt;<span>ContentPage.BindingContext</span>&gt;</span>
        <span>&lt;<span>local:MainPageViewModel</span> /&gt;</span>
    <span>&lt;/<span>ContentPage.BindingContext</span>&gt;</span>
    <span>&lt;<span>StackLayout</span>
        <span>BindableLayout.ItemsSource</span>=<span>"{Binding Options}"</span>&gt;</span>
        <span>&lt;<span>BindableLayout.ItemTemplate</span>&gt;</span>
            <span>&lt;<span>DataTemplate</span>&gt;</span>
                <span>&lt;<span>Frame</span>
                    <span>CornerRadius</span>=<span>"4"</span>
                    <span>Padding</span>=<span>"0"</span>&gt;</span>
                    <span>&lt;<span>StackLayout</span>
                        <span>Orientation</span>=<span>"Horizontal"</span>
                        <span>Padding</span>=<span>"5"</span>
                        <span>BackgroundColor</span>=<span>"White"</span>&gt;</span>
        <span>&lt;<span>VisualStateManager.VisualStateGroups</span>&gt;</span>
            <span>&lt;<span>VisualStateGroup</span>&gt;</span>
                <span>&lt;<span>VisualState</span>
                    <span>x:Name</span>=<span>"IsEnabledAndSelected"</span>&gt;</span>
                    <span>&lt;<span>VisualState.StateTriggers</span>&gt;</span>
                        <span>&lt;<span>StateTrigger</span>
                            <span>IsActive</span>=<span>"{Binding Selected}"</span> /&gt;</span>
                    <span>&lt;/<span>VisualState.StateTriggers</span>&gt;</span>
                    <span>&lt;<span>VisualState.Setters</span>&gt;</span>
                        <span>&lt;<span>Setter</span>
                            <span>Property</span>=<span>"BackgroundColor"</span>
                            <span>Value</span>=<span>"DarkBlue"</span> /&gt;</span>
                        <span>&lt;<span>Setter</span>
                            <span>Property</span>=<span>"IsVisible"</span>
                            <span>Value</span>=<span>"False"</span>
                            <span>TargetName</span>=<span>"OptionsSelectedLabel"</span> /&gt;</span>
                        <span>&lt;<span>Setter</span>
                            <span>Property</span>=<span>"Label.TextColor"</span>
                            <span>Value</span>=<span>"White"</span>
                            <span>TargetName</span>=<span>"OptionsValueLabel"</span> /&gt;</span>
                    <span>&lt;/<span>VisualState.Setters</span>&gt;</span>
                <span>&lt;/<span>VisualState</span>&gt;</span>
                <span>&lt;<span>VisualState</span>
                    <span>x:Name</span>=<span>"IsNotEnabled"</span>&gt;</span>
                    <span>&lt;<span>VisualState.StateTriggers</span>&gt;</span>
                        <span>&lt;<span>StateTrigger</span>
                            <span>IsActive</span>=<span>"{Binding IsNotEnabled}"</span> /&gt;</span>
                    <span>&lt;/<span>VisualState.StateTriggers</span>&gt;</span>
                    <span>&lt;<span>VisualState.Setters</span>&gt;</span>
                        <span>&lt;<span>Setter</span>
                            <span>Property</span>=<span>"IsEnabled"</span>
                            <span>Value</span>=<span>"false"</span> /&gt;</span>
                        <span>&lt;<span>Setter</span>
                            <span>Property</span>=<span>"BackgroundColor"</span>
                            <span>Value</span>=<span>"DarkGray"</span> /&gt;</span>
                        <span>&lt;<span>Setter</span>
                            <span>Property</span>=<span>"Label.TextColor"</span>
                            <span>Value</span>=<span>"LightGray"</span>
                            <span>TargetName</span>=<span>"OptionsValueLabel"</span> /&gt;</span>
                    <span>&lt;/<span>VisualState.Setters</span>&gt;</span>
                <span>&lt;/<span>VisualState</span>&gt;</span>
            <span>&lt;/<span>VisualStateGroup</span>&gt;</span>
        <span>&lt;/<span>VisualStateManager.VisualStateGroups</span>&gt;</span>
                        <span>&lt;<span>Button</span>
                            <span>Text</span>=<span>"Select"</span>
                            <span>Command</span>=<span>"{Binding BindingContext.SelectTypeCommand, Source={x:Reference Page}}"</span>
                            <span>CommandParameter</span>=<span>"{Binding .}"</span> /&gt;</span>
                        <span>&lt;<span>Label</span>
                            <span>Text</span>=<span>"✓"</span>
                            <span>TextColor</span>=<span>"White"</span>
                            <span>x:Name</span>=<span>"OptionsSelectedLabel"</span>
                            <span>FontSize</span>=<span>"12"</span>
                            <span>HorizontalOptions</span>=<span>"EndAndExpand"</span>
                            <span>VerticalOptions</span>=<span>"Center"</span>
                            <span>IsVisible</span>=<span>"false"</span> /&gt;</span>
                        <span>&lt;<span>Label</span>
                            <span>Text</span>=<span>"{Binding Value}"</span>
                            <span>TextColor</span>=<span>"Black"</span>
                            <span>x:Name</span>=<span>"OptionsValueLabel"</span>
                            <span>HorizontalOptions</span>=<span>"EndAndExpand"</span>
                            <span>VerticalOptions</span>=<span>"Center"</span> /&gt;</span>
                    <span>&lt;/<span>StackLayout</span>&gt;</span>
                <span>&lt;/<span>Frame</span>&gt;</span>
            <span>&lt;/<span>DataTemplate</span>&gt;</span>
        <span>&lt;/<span>BindableLayout.ItemTemplate</span>&gt;</span>
    <span>&lt;/<span>StackLayout</span>&gt;</span>
<span>&lt;/<span>ContentPage</span>&gt;</span></pre>
<p>On initial inspection you might be looking at this XAML wondering whether it’s improved the readability. However, if you collapse the VisualStateManager.VisualStateGroups node in the editor, the code immediately looks much more readable, as shown in the following image.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/01.png" alt="" width="500"></figure>
<p>We can clearly make out that the interface is made up of a stack of items with each row being made up off a Button and two Label elements. The default state is for the row to have a White background and for the ✓ Label to be hidden (IsVisible set to false).</p>
<p>Now, let’s look at the contents of the VisualStateManager.VisualStateGroups. In this case it defines a single VisualStateGroup in which I’ve included two VisualState elements. If we consider each row it can be in one of three states:</p>
<ul><li><strong>Enabled and Not Selected</strong> – This is the default state where the item hasn’t been selected (IsEnabled = true, IsSelected = false).</li><li><strong>Enabled and Selected </strong>– This is the state where the item has been selected by the user clicking the Select button (IsEnabled = true, IsSelected = true).</li><li><strong>Is Not Enabled </strong>– When an item in the list is selected, other items may be set to disabled (IsEnabled = false, IsSelected = false). </li></ul>
<p>Even though there are only two VisualStates defined in the XAML, there are in fact three visual states because there is the default state. Each of the VisualState uses a StateTrigger to determine whether the visual state is active or not. Rather than attempting to data bind to two different properties on the underlying data model, I’ve explicitly created single properties that reflect whether the state is active or not. The default state is both the initial state of each row, as well as the state that is returned to if neither of the defined VisualStates are active (ie the StateTrigger IsActive is set to true).</p>
<p>One of the benefits of using visual states is that you can set multiple properties, on one or more different elements, essentially grouping all the changes required for a particular visual states. This eliminates the need to have data triggers littered through the XAML used to define the layout for the page. In this scenario each of the VisualState elements has multiple Setters defining the background colour, the foreground (text) colour and in the case of the IsEnabledAndSelected state, the visibility of the ✓ Label.</p>
<p>As I pointed out earlier, for me, this makes the XAML easier to read. I know other developers prefer to have the data triggers local to where the attributes being changed are in the XAML. This approach has some advantages, particularly where you only have a small number of changes in a large XAML document. </p>
<p>Before we move on from discussing Xamarin.Forms I would point out that the VisualStateManager is a relatively new addition and specifically the ability to use TargetName to target different elements from a single VisualState. I would encourage revisiting your XAML to see whether using the VisualStateManager will simplify your code. Alternatively, you may want to consider breaking your code up into different controls that will help encapsulate things like visual states whilst reducing the complexity of the XAML on each page. We’ll talk more about using UserControls in the context of UWP shortly but the same concept can be used for Xamarin.Forms as well.</p>
<h2>UWP / WindowsUI / Uno</h2>
<p>The XAML used by the Universal Windows Platform (ie UWP) provides a couple of alternatives when it comes to defining the desired layout. In this section we’re going to consider three options: Optimised, UserControl and ContainerStyle (<a href="https://github.com/nickrandolph/xamlflagsdesigner">Code is available on GitHub</a>)</p>
<h3>Optimised for Lines of Code</h3>
<p>In this approach the goal was simply to reduce the number of lines of code. I’m not going to spend much time on this because I fundamentally think measuring the quality of a technology based on the number of lines of code is just ridiculous. The following image shows the resulting 41 lines of XAML – of course this is also contingent on my Visual Studio settings where the first attribute is on the same line as the element; other developers have different options set, so will see different numbers of lines. </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/02.png" alt=""></figure>
<p>I will comment on a couple of things:</p>
<ul><li>Unlike the Xamarin.Forms approach that uses a horizontal StackLayout, this XAML uses a Grid which clearly defines three columns. I prefer this approach as it clearly defines the sizing option for each column. Using a StackLayout with different HorizontalOptions isn’t as clear in my opinion.</li><li>This code uses x:Bind instead of the usual Binding syntax. This allows for code to be generated during compilation that enforces type checking and results in better performance as it reduces the reliance on reflection.</li><li>Rather than using converters this code uses static methods defined on the page to convert property values (in some cases multiple properties) into the required attribute value. In practice I would <strong>not</strong> recommend doing this as it embeds logic in your XAML layout </li></ul>
<h3>UserControl with Visual States</h3>
<p>In the previous section we optimised the XAML by interleaving logic into our XAML layout. This is a practice that I actively try to avoid when defining the XAML for a page or control. I try to ensure the XAML I create is as declarative as possible, which means avoiding calling methods as part of binding expressions. I’d even go so far as to say that you should avoid using converters unless they are simple type converters (the most obvious one being for bool to Visibility conversion). I advocate for all logic to be encapsulated in either the ViewModel (if UI relate logic) or in the Model (if business logic), thus making it testable and ensuring a clean separation from the way that it’s presented (i.e. the View). </p>
<p>Let’s look at how we can keep our XAML clean of logic by following a similar approach to what we did earlier for Xamarin.Forms. What’s interesting about UWP is that if you attempt to follow the same strategy of defining visual states within the DataTemplate you’ll find that it doesn’t work. Instead you either need to define the visual states within a UserControl, or you have to apply the visual states in the ItemContainerStyle. </p>
<p>We’ll start with defining a UserControl which will include the layout for each item in the list, along with the different visual states. Rather than just show you the code, let’s jump into Blend and use the visual designer to build the desired layout. Rather than boring you with creating the project and adding things like the MainViewModel, I’m just going to focus on creating the UserControl.</p>
<p>From Solution Explorer, right-click on the project or a sub-folder and select Add, New Item. </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/03.png" alt="" width="400"></figure>
<p>From the Add New Item dialog, select User Control, give it a name (eg OptionItemControl) and click Add. This should give you a new design surface that we can start adding controls to.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/04.png" alt="" width="400"></figure>
<p>Using the Assets tool window, double-click on the Button and then twice on the TextBlock. Alternatively you can drag these controls onto the design surface.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/05.png" alt="" width="400"></figure>
<p>If you look at the XAML you’ll notice that Blend has added some default attributes to each of the controls that you added. Normally my recommendation would be to tidy up whatever XAML Blend creates, as you go, to ensure your XAML remains clean and does exactly what you want. If you’re not that familiar with XAML, reviewing the XAML that Blend generates is a great way to learn about features that you might not be aware of.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/06.png" alt="" width="400"></figure>
<p>If we look at the design surface we can see that the three controls we added are incorrectly located on the design surface – we’re after a single row with three cells that should hold the “select” Button, a check mark TextBlock and the option value TextBlock. </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/07.png" alt="" width="400"></figure>
<p>Let’s go ahead and create the cells in the Grid by defining three columns. We can do this using the design by hovering the mouse near the top of the design surface. The cursor should change to include a small + sign and if you click with the mouse a new column break will be added. You can then use the designer to specify how the column widths are defined. In this case we want the first column to be Auto and the other two columns to be * (just *, so you may have remove any numeric value added by Blend eg 101* should be changed to just *)</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/08.png" alt="" width="400"></figure>
<p>Next we want to reposition the two TextBlock into the appropriate column. You can do this by simply dragging them using the mouse. As you drag and hover over each cell in the Grid you’ll see alignment and positioning lines appear in red. </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/09.png" alt="" width="400"></figure>
<p>After positioning the TextBlock into the correct column you will want to tidy up the XAML – Blend has an annoying habit of adding Margins and other layout attributes that are typically unnecessary. You can clean up these excess attributes by right-clicking the control and selecting Layout, Reset All.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/10.png" alt="" width="400"></figure>
<p>The next thing to do is to replace the default Text value for the TextBlock from “TextBlock” to something more meaningful. Rather than having to locate the Text property in the properties tool window, you can simply double-click the TextBlock and type directly on the designer. You can do the same thing with the Button control to change the Content to “Select”. </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/11.png" alt="" width="400"></figure>
<p>According to the design we’re aiming to achieve we need to change the default (i.e. Enabled but not Selected) Background to White. Use the colour picker in the Properties tool window to do this. This of course will override the theming and thus break support for dark and light themes, but that’s a topic for another day.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/12.png" alt="" width="400"></figure>
<p>Unfortunately setting the Background to White means we can no longer see the three controls, since their default text colour is currently also White. This can be fixed easily by selecting all three controls in the Objects and Timelines tool window. </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/13.png" alt="" width="400"></figure>
<p>From the Properties tool window, update the Foreground colour to Black.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/14.png" alt="" width="400"></figure>
<p>You’ll also need to adjust the BorderBrush on the Button. After doing this the layout should be similar to the following.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/15.png" alt="" width="400"></figure>
<p>And the XAML for this is quite tidy.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/16.png" alt="" width="400"></figure>
<p>What’s missing are the visual states for when the option is selected and when it’s disabled. We’ll add two VisualStates to the UserControl via the States window. Normally I advocate for creating a third VisualState that represents the default state – this is so that in code you can use the VisualStateManager GoToState method to return to the default layout. However, we’re going to be using state triggers to transition between states, so a third VisualState is not required – when none of the state triggers are set to active, the UserControl will return to the default state.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/17.png" alt="" width="400"></figure>
<p>By clicking on a VisualState in the States tool window we can put Blend into state editing mode. This is highlighted by both the red dot alongside the VisualState, as well as the red border around the design surface. Any changes you make whilst this highlighting is visible will be recorded against the corresponding VisualState.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/18.png" alt="" width="400"></figure>
<p>I’m not going to go through setting all the properties for each VisualState but essentially we need to update the Background colour on the Grid, the Foreground colour on the TextBlock and Button, and the Visibility on the checkmark TextBlock. For the checkmark TextBlock, you’ll need to switch the default Visibility to Collapsed – we had it visible whilst designing the layout but it’s default state is actually to be hidden (i.e. Collapsed).</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/19.png" alt="" width="400"></figure>
<p>As part of defining the VisualStates you may have noticed that the controls in the Objects and Timeline tool window were all given default names like grid, button, textBlock and textBlock1. I would encourage you to give these more meaningful names by double-clicking on them in the Objects and Timeline tool window and typing a new name.</p>
<p>Currently we have completed the design of the UserControl, including the three different states it can be in. However, we haven’t wired it up to any data. If we were to use this UserControl as it is, it would simply show a list of “Option 1”. So that we can wire up some data, let’s add an instance of the OptionViewModel as a design time DataContext for the UserControl (note the use of the d: prefix to indicate design time only). </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/21.png" alt="" width="400"></figure>
<p>Select the TextBlock that should show the OptionViewModel Value property. Click on the small square to the right of the Text property in the Properties tool window and select Create Data Binding.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/22.png" alt="" width="400"></figure>
<p>Since we’ve set up an instance of the OptionViewModel as a design time DataContext, Blend is able to offer suggestions for the Path attribute. Select the Value property and click Ok.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/23.png" alt="" width="400"></figure>
<p>At this point you’ll be wondering why the TextBlock that you just setup data binding for as disappeared from the designer. Well, the good news is that the TextBlock is still there, it just has zero width because the Value property on the OptionViewModel is returning null. This is easily fixed by specifying the Value property on the OptionViewModel specified in the design time DataContext.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/24.png" alt="" width="400"></figure>
<p>Ok, we’re almost there. We have our layout, our Visual States and our data. We still need to be able to trigger then changing of states. For this we’re going to use a state trigger. Click the “Edit Adaptive Triggers” button next to the VisualState.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/25.png" alt="" width="400"></figure>
<p>From the Dropdown at the bottom of the screen select &lt;Other Type…&gt;</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/27.png" alt="" width="400"></figure>
<p>In our project we have a trigger called DualBooleanDataTrigger which will allow us to trigger a VisualState based on the value of two different bool properties. </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/26.png" alt="" width="400"></figure>
<p>Unfortunately this is about as far as the data trigger design experience can take us. Luckily the XAML for the DualBooleanDataTrigger isn’t that complex. As you can see from this image, we need to data bind the DataValue and SecondDataValue attributes to the IsEnabled and IsSelected properties on the OptionViewModel and then we need to specify the value for each of these properties that we want the VisualState to be active for. In this case we want both the IsEnabled and IsSelected properties to be True for this state to be active. </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/29.png" alt="" width="400"></figure>
<p>The last thing we need to do is to wire up the Button to a method that will set the OptionViewModel to be selected. For this, we’re going to use x:Bind so that we can bind directly to a method on the OptionViewModel. In order to do this, we need to expose the the OptionViewModel as a property on the UserControl.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/30.png" alt="" width="400"></figure>
<p>In the MainPage (i.e. where we’re defining the ItemsControl) we need to include an instance of the OptionItemControl in the DataTemplate. In order for x:Bind to work we need to make sure we set the ViewModel to be the current DataContext of the DataTemplate (i.e. binding path of . which can be omitted in this scenario). </p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/31.png" alt="" width="400"></figure>
<p>We then need to specify the Click attribute on the Button.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/32.png" alt="" width="400"></figure>
<p>After completing this we’re done! But let’s take a look at what’s been generated. Well, the good news is that we’ve created the entire user experience without having to write much XAML at all. The bad news is that Blend does a <strong>terrible</strong> job of generating optimized XAML. Take for example the following snippet where you can see that each Setter is spread over 5 lines.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/33.png" alt="" width="400"></figure>
<p>In contrast, when I tidy these up, each Setter takes only 2 lines and that’s only because I have Visual Studio and Blend set to put attributes on new lines.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/34.png" alt="" width="400"></figure>
<p>As you can see from this walk through, you can use a separate UserControl to easily design the layout for the three states required in this design.</p>
<h3>ListView ItemsContainerStyle</h3>
<p>The third option I wanted to briefly discuss (because there’s plenty of room for an entire discussion on this topic) is to override the ItemsContainerStyle for a ListView in order to define the VisualStates for the items in the list. Let’s back up for a second and explain a few things.</p>
<p>The scenario that we’re addressing is a common enough scenario where items in a list are selected. In this case the individual item tracks whether it’s selected (and in fact whether it’s enabled). This approach is actually at odds with the way a number of controls work. Take for example the ListView or GridView which are used to represent a list, or grid, of selectable items. Theses controls have built in styles that represent how each ListViewItem will look in various states. These states include (not an exhaustive list) Selected, Pressed, Enabled and Disabled. Further more, these control separate the appearance of each item (specified using the ItemTemplate) from the behaviour when the user interacts with the items (specified in the ControlTemplate used to define the ListViewItem Template nested in the ItemsContainerStyle). Both the ItemTemplate and ItemsContainerStyle are editable using the visual designer, allowing you to customise the appearance of the item and how it changes when the item is selected or enabled/disabled. </p>
<p>For example in Blend we can right-click on a ListView and select Edit Additional Templates, Edit Generated Item Container (ItemContainerStyle) and then either Edit Current, Edit Copy or Create Empty. I would suggest starting by selecting Edit Copy, which will give you a default style that you can customise, rather than starting from scratch.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/35.png" alt="" width="400"></figure>
<p>In the following image you can see how I’ve defined different VisualStates for the ListViewItem to control the appearance for the three states the item can be in. You can also see all the other states that are available by default on the ListViewItem.</p>
<figure><img src="https://blogimages.builttoroam.com/2020-07-xaml-lines-of-code/36.png" alt="" width="400"></figure>
<p>At this point you might be asking why, since the ListViewItem already has a Selected and a Disabled state, don’t I just use these. Well, the issue we have is that the Background and Foreground properties have three different colours based on the combination of two different properties (IsEnabled and IsSelected). This means we need to define states that are in the same group that respond to changes in both these properties. This is <strong>not</strong> how the built in VisualStates are defined. The Selected and Disabled states are in different VisualStateGroups – if we were to use these to control the same properties, we’ll end up with random and chaotic changes in the appearance. </p>
<blockquote><p>VisualStates in different VisualStateGroups should not control the same property.</p></blockquote>
<p>This is an important rule and one that’s easily forgotten or broken. If you ever see unusual behaviour relating to visual states, make sure you check this rule.</p>
<p>I’m not going to delve further into how to use the ItemsContainerStyle in this post but feel free to check out the <a href="https://github.com/nickrandolph/XamlFlagsDesigner/blob/master/XamlFlagsDesigner/ContainerStyle/MainPage.xaml">source code</a>. You’ll notice that this is very verbose coming in at around 130 lines, and this is using a much simplified ItemsContainerStyle. Unfortunately due to the complexity of the built in styles, the ItemsContainerStyle is a large style, mainly because the Template for the ListViewItem is so large. Don’t let this put you off considering using this approach because it does mean that you can reuse the style across various lists that may have different content.</p>
<h2>Summary</h2>
<p>Wow, sorry this ended up being quite a long post but hopefully you’ll find it useful and get some insight on the various XAML based options available to you. Don’t forget that all the options presented for UWP are able to be taken cross platform using the <a href="https://platform.uno/">Uno Platform</a>.</p>
<p>In summary, yes, XAML is verbose but it does come with options. If you spend time maintaining your XAML you’ll find that it is easy to understand and you can leverage the designer support in Blend and Visual Studio along the way.</p>
<p>I don’t believe that looking at the number of lines of XAML (or C# code) is productive. What is useful is to look at the options that are available and the easy with which you can achieve the desired outcome. </p>
</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>