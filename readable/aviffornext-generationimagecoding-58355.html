<!DOCTYPE html>
<html lang="en">
<head>
    <title>linksfor.dev(s)</title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <div class="readable">
        <h1>AVIF for Next-Generation Image Coding</h1>
        <p>
by Netflix Technology Blog <br/>Reading time: 20-25 minutes        </p>
        <p><a href="https://netflixtechblog.com/avif-for-next-generation-image-coding-b1d75675fe4?gi=d0fd0c5b3288">https://netflixtechblog.com/avif-for-next-generation-image-coding-b1d75675fe4?gi=d0fd0c5b3288</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><div><div><div><p><a href="https://netflixtechblog.com/@NetflixTechBlog?source=post_page-----b1d75675fe4----------------------" rel="noopener"><img alt="Netflix Technology Blog" src="https://miro.medium.com/fit/c/48/48/1*ty4NvNrGg4ReETxqU2N3Og.png" width="48" height="48"></a></p></div></div></div></div><p id="627a" data-selectable-paragraph="">By Aditya Mavlankar, Jan De Cock¬π, Cyril Concolato, Kyle Swanson, Anush Moorthy and Anne Aaron</p><p id="1012" data-selectable-paragraph="">We need an alternative to JPEG that a) is widely supported, b) has better compression efficiency and c) has a wider feature set. We believe <a href="https://aomediacodec.github.io/av1-avif/" target="_blank" rel="noopener">AV1 Image File Format</a> (AVIF) has the potential. Using the <a href="https://github.com/Netflix/image_compression_comparison" target="_blank" rel="noopener">framework</a> we have open sourced, AVIF compression efficiency can be seen at work and compared against a whole range of image codecs that came before it.</p><p id="f8e0" data-selectable-paragraph="">Netflix is enjoyed by its members on a variety of devices ‚Äî smart TVs, phones, tablets, personal computers and streaming devices connected to TV screens. The user interface (UI), intended for browsing the catalog and serving up recommendations, is rich in images and graphics across all device categories. Shown below are screenshots of the Netflix app on iOS as an example.</p></div></div><div><div><p id="020c" data-selectable-paragraph="">Image assets might be <a target="_blank" rel="noopener" href="https://netflixtechblog.com/ava-the-art-and-science-of-image-discovery-at-netflix-a442f163af6">based on still frames from the title</a>, special on-set photography or a combination thereof. Assets could also stem from art generated during the production of the feature.</p><p id="2267" data-selectable-paragraph="">As seen above, image assets typically have <em>gradients, text </em>and<em> graphics</em>, for example the Netflix symbol or other title-specific symbols such as ‚ÄúThe Witcher‚Äù insignia, composited on the image. Such special treatments lead to a variety of peculiarities which do not necessarily arise in natural images. Hard edges, including those with chroma differences on either side of the edge, are common and require good detail preservation, since they typically occur at salient locations and convey important information. Further, there is typically a character or a face in salient locations with a smooth, uncluttered background. Again, preservation of detail on the character‚Äôs face is of primary importance. In some cases, the background is textured and complex, exhibiting a wide range of frequencies.</p><p id="0b8c" data-selectable-paragraph="">After an image asset is ingested, the compression pipeline kicks in and prepares compressed image assets meant for delivering to devices. The goal is to have the compressed image look as close to the original as possible while reducing the number of bytes required. Given the image-heavy nature of the UI, compressing these images well is of primary importance. This involves picking, among other things, the right combination of color subsampling, codec, encoder parameters and encoding resolution.</p></div></div><div><p id="c3dc" data-selectable-paragraph="">Let us take <a href="https://en.wikipedia.org/wiki/Chroma_subsampling" target="_blank" rel="noopener">color subsampling</a> as an example. Choosing 420 subsampling, over the original 444 format, halves the number of samples (counting across all 3 color planes) that need to be encoded while relying on the fact that the human visual system is more sensitive to luma than chroma. However, 420 subsampling can introduce color bleeding and jaggies in locations with color transitions. Below we toggle between the original source in 444 and the source converted to 420 subsampling. The toggling shows loss introduced just by the color subsampling, even before the codec enters the picture.</p></div><div><div><p id="4b06" data-selectable-paragraph="">Nevertheless, there are source images where the loss due to 420 subsampling is not obvious to human perception and in such cases it can be advantageous to use 420 subsampling. Ideally, a codec should be able to support both subsampling formats. However, there are a few codecs that only support 420 subsampling ‚Äî <a href="https://developers.google.com/speed/webp" target="_blank" rel="noopener">webp</a>, discussed below, is one such popular codec.</p><p id="1e8e" data-selectable-paragraph="">The <a href="https://jpeg.org/jpeg/index.html" target="_blank" rel="noopener">JPEG format</a> was introduced in 1992 and is widely popular. It supports various color subsamplings including 420, 422 and 444. JPEG can ingest RGB data and transform it to a luma-chroma representation before performing lossy compression. The discrete cosine transform (DCT) is employed as the decorrelating transform on 8x8 blocks of samples. This is followed by quantization and entropy coding. However, JPEG is restricted to 8-bit imagery and lacks support for alpha channel. The more recent <a href="https://jpeg.org/jpegxt/" target="_blank" rel="noopener">JPEG-XT</a> standard extends JPEG to higher bit-depths, support for alpha channel, lossless compression and more in a backwards compatible way.</p><p id="c326" data-selectable-paragraph="">The <a href="https://jpeg.org/jpeg2000/index.html" target="_blank" rel="noopener">JPEG 2000 format</a>, based on the discrete wavelet transform (DWT), was introduced as a successor to JPEG in the year 2000. It brought a whole range of additional features such as spatial scalability, region of interest coding, range of supported bit-depths, flexible number of color planes, lossless coding, etc. With the motion extension, it was accepted as the <a href="https://xkcd.com/2254/" target="_blank" rel="noopener">video coding standard for digital cinema</a> in 2004.</p><p id="f378" data-selectable-paragraph="">The <a href="https://gigaom.com/2014/07/19/the-story-of-webp-how-google-wants-to-speed-up-the-web-one-image-at-a-time/" target="_blank" rel="noopener">webp</a> format was introduced by Google around 2010. Google added decoding support on Android devices and Chrome browser and also released libraries that developers could add to their apps on other platforms, for example iOS. Webp is based on intra-frame coding from the <a href="https://en.wikipedia.org/wiki/VP8" target="_blank" rel="noopener">VP8</a> video coding format. Webp does not have all the flexibilities of JPEG 2000. It does, however, support lossless coding and also a lossless alpha channel, making it a more efficient and faster alternative to <a href="https://www.w3.org/TR/2003/REC-PNG-20031110/" target="_blank" rel="noopener">PNG</a> in certain situations.</p><p id="f3b7" data-selectable-paragraph="">High-Efficiency Video Coding (<a href="https://www.itu.int/rec/T-REC-H.265" target="_blank" rel="noopener">HEVC</a>) is the successor of H.264, a.k.a. Advanced Video Coding (<a href="https://www.itu.int/rec/T-REC-H.264/en" target="_blank" rel="noopener">AVC</a>) format. HEVC intra-frame coding can be encapsulated in the High-Efficiency Image File Format (HEIF). This format is most notably used by <a href="https://support.apple.com/en-us/HT207022" target="_blank" rel="noopener">Apple devices to store recorded imagery</a>.</p><p id="8b06" data-selectable-paragraph="">Similarly, AV1 Image File Format (<a href="https://aomediacodec.github.io/av1-avif/" target="_blank" rel="noopener">AVIF</a>) allows encapsulating AV1 intra-frame coded content, thus taking advantage of excellent compression gains achieved by AV1 over predecessors. We touch upon some appealing technical features of AVIF in the next section.</p><p id="49b2" data-selectable-paragraph="">The JPEG committee is pursuing a coding format called <a href="https://jpeg.org/jpegxl/index.html" target="_blank" rel="noopener">JPEG XL</a> which includes features aimed at helping the transition from legacy JPEG format. Existing JPEG files can be losslessly transcoded to JPEG XL while achieving file size reduction. Also included is a lightweight conversion process back to JPEG format in order to serve clients that only support legacy JPEG.</p><p id="6b56" data-selectable-paragraph="">Although modern video codecs were developed with primarily video in mind, the intraframe coding tools in a video codec are not significantly different from image compression tooling. Given the huge compression gains of modern video codecs, they are compelling as image coding formats. There is a potential benefit in reusing the hardware in place for video compression/decompression. Image decoding in hardware may not be a primary motivator, given the peculiarities of OS dependent UI composition, and architectural implications of moving uncompressed image pixels around.</p><p id="8a26" data-selectable-paragraph="">In the area of image coding formats, the Moving Picture Experts Group (MPEG) has standardized a codec-agnostic and generic image container format: ISO/IEC 23000‚Äì12 standard (a.k.a. HEIF). HEIF has been used to store most notably HEVC-encoded images (in its HEIC variant) but is also capable of storing AVC-encoded images or even JPEG-encoded images. The Alliance for Open Media (AOM) has recently extended this format to specify the storage of AV1-encoded images in its AVIF format. The base HEIF format offers typical features expected from an image format such as: support for any image codec, ability to use a lossy or a lossless mode for compression, support for varied subsampling and bit-depths, etc. Furthermore, the format also allows the storage of a series of animated frames (offering an efficient and long-awaited alternative to animated GIFs), and the ability to specify an alpha channel (which sees tremendous use in UIs). Further, since the HEIF format borrows learnings from next-generation video compression, the format allows for preserving metadata such as color gamut and high dynamic range (HDR) information.</p><p id="98a7" data-selectable-paragraph="">We have open sourced a Docker based <a href="https://github.com/Netflix/image_compression_comparison" target="_blank" rel="noopener">framework</a> for comparing various image codecs. Salient features include:</p><ol><li id="cb8e" data-selectable-paragraph="">Encode orchestration (with parallelization) and insights generation using Python 3</li><li id="3be1" data-selectable-paragraph="">Easy reproducibility of results and</li><li id="2aab" data-selectable-paragraph="">Easy control of target quality range(s).</li></ol><p id="16e1" data-selectable-paragraph="">Since the framework allows one to specify a target quality (using a certain metric) for target codec(s), and stores these results in a local database, one can easily utilize the Bjontegaard-Delta (BD) rate to compare across codecs since the target points can be restricted to a useful or meaningful quality range, instead of blindly sweeping across the encoder parameter range (such as a quality factor) with fixed parameter values and landing on arbitrary quality points.</p><p id="9200" data-selectable-paragraph="">An an example, below are the calls that would produce compressed images for the choice of codecs at the specified SSIM and VMAF values, with the desired tolerance in target quality:</p><pre><span id="6f1c" data-selectable-paragraph="">main(metric='ssim', target_arr=[0.92, 0.95, 0.97, 0.99], target_tol=0.005, db_file_name='encoding_results_ssim.db')</span><span id="7f83" data-selectable-paragraph="">main(metric='vmaf', target_arr=[75, 80, 85, 90, 95], target_tol=0.5, db_file_name='encoding_results_vmaf.db')</span></pre><p id="6346" data-selectable-paragraph="">For the various codecs and configurations involved in the ensuing comparison, the reader can view the actual command lines in the shared <a href="https://github.com/Netflix/image_compression_comparison" target="_blank" rel="noopener">repository</a>. We have attempted to get the best compression efficiency out of every codec / configuration compared here. The reader is free to experiment with changes to encoding commands within the framework. Furthermore, newer versions of respective software implementations might have been released compared to versions used at the time of gathering below results. For example, a newer software version of Kakadu demo apps is available compared to the one in the <a href="https://github.com/Netflix/image_compression_comparison" target="_blank" rel="noopener">framework</a> snapshot on github used at the time of gathering below results.</p><p id="c290" data-selectable-paragraph="">This is the section where we get to admire the work of the compression community over the last 3 decades by looking at visual examples comparing JPEG and the state-of-the-art.</p><p id="7357" data-selectable-paragraph="">The encoded images shown below are illustrative and meant to compare visual quality at various target bitrates. Please note that the quality of the illustrative encodes is not representative of the high quality bar that Netflix employs for streaming image assets on the actual service, and is meant to be purely educative in nature.</p><p id="c118" data-selectable-paragraph="">Shown below is one original source image from the Kodak dataset and the corresponding result with <strong><em>JPEG 444 @ 20,429 bytes</em></strong> and with <strong><em>AVIF 444 @ 19,788 bytes</em></strong>. The JPEG encode shows very obvious blocking artifacts in the sky, in the pond as well as on the roof. The AVIF encode is much better, with less blocking artifacts, although there is some blurriness and loss of texture on the roof. It is still a remarkable result, given the compression factor of around <strong><em>59x</em></strong> (original image has dimensions 768x512, thus requiring 768x512x3 bytes compared to the 20k bytes of the compressed image).</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*vGFkQIIn_Nzsc6VeQnbwAg.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">An original image from the Kodak dataset</figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*55Zi3QfXNAeW228pPJywrg.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>JPEG 444 @ 20,429 bytes</em></figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*dPXjh-N3O4kOxVZUSjRBeg.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>AVIF 444 @ 19,788 bytes</em></figcaption></figure><p id="9487" data-selectable-paragraph="">For the same source, shown below is the comparison of <strong><em>JPEG 444 @ 40,276 bytes</em></strong> and <strong><em>AVIF 444 @ 39,819 bytes</em></strong>. The JPEG encode still has visible blocking artifacts in the sky, along with ringing around the roof edges and chroma bleeding in several locations. The AVIF image however, is now comparable to the original, with a compression factor of <strong><em>29x</em></strong>.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*S36RsTvrT7CgsobNbtd58Q.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>JPEG 444 @ 40,276 bytes</em></figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*jgnReJsQEeIzskqG7Apflg.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>AVIF 444 @ 39,819 bytes</em></figcaption></figure><p id="6d8e" data-selectable-paragraph="">Shown below is another original source image from the Kodak dataset and the corresponding result with <strong><em>JPEG 444 @ 13,939 bytes</em></strong> and with <strong><em>AVIF 444 @ 4,176 bytes</em></strong>. The JPEG encode shows blocking artifacts around most edges, particularly around the slanting edge as well as color distortions. The AVIF encode looks ‚Äúcleaner‚Äù even though it is one-third the size of the JPEG encode. It is not a perfect rendition of the original, but with a compression factor of <strong><em>282x</em></strong>, this is commendable.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*Tjn9zXQ8ibc14OS6GnvZwQ.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Another original source image from the Kodak dataset</figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*rh9JLgQ25mS5vULoV4IpJw.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>JPEG 444 @ 13,939 bytes</em></figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*7wL86iu4IobGetie12fUOA.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>AVIF 444 @ 4,176 bytes</em></figcaption></figure><p id="6a57" data-selectable-paragraph="">Shown below are results for the same image with slightly higher bit-budget; <strong><em>JPEG 444 @ 19,787 bytes</em></strong> versus <strong><em>AVIF 444 @ 20,120 bytes</em></strong>. The JPEG encode still shows blocking artifacts around the slanting edge whereas the AVIF encode looks nearly identical to the source.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*iQ2BkyM-02-2SWd_6bnhWQ.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">JPEG 444 @ 19,787 bytes</figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*nE8_CbnyvzoCCcJvQOz7xQ.png?q=20" width="768" height="512" role="presentation"></p><p><img width="768" height="512" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>AVIF 444 @ 20,120 bytes</em></figcaption></figure><p id="8e51" data-selectable-paragraph="">Shown below is an original image from the Netflix (internal) 1142x1600 resolution ‚Äúboxshots-1‚Äù dataset. Followed by <strong><em>JPEG 444 @ 69,445 bytes</em></strong> and <strong><em>AVIF 444 @ 40,811 bytes</em></strong>. Severe banding and blocking artifacts along with color distortions are visible in the JPEG encode. Less so in the AVIF encode which is actually 29kB smaller.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*pQAZySFN1TfpnYU352UlbQ.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">An original source image from the Netflix (internal) boxshots-1 dataset</figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*-_ul1ZleQu9Wko7HSRfbeg.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>JPEG 444 @ 69,445 bytes</em></figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*TCaOhjf87NTo9Eeq3TXftQ.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>AVIF 444 @ 40,811 bytes</em></figcaption></figure><p id="6218" data-selectable-paragraph="">Shown below are results for the same image with slightly increased bit-budget. <strong><em>JPEG 444 @ 80,101 bytes</em></strong> versus <strong><em>AVIF 444 @ 85,162 bytes</em></strong>. The banding and blocking is still visible in the JPEG encode whereas the AVIF encode looks very close to the original.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*u4NI4yQ1LQjr3mc5ZDtF9w.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>JPEG 444 @ 80,101 bytes</em></figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*6iIZ3PD3nO3eUmexG0PGBQ.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>AVIF 444 @ 85,162 bytes</em></figcaption></figure><p id="0852" data-selectable-paragraph="">Shown below is another source image from the same boxshots-1 dataset along with <strong><em>JPEG 444 @ 81,745 bytes</em></strong> versus <strong><em>AVIF 444 @ 76,087 bytes</em></strong>. Blocking artifacts overall and mosquito artifacts around text can be seen in the JPEG encode.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*wKsoHtn8Z4eQnprYJweARg.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Another original source image from the Netflix (internal) boxshots-1 dataset</figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*aqfp1VvZ0ysLBssJollFnQ.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>JPEG 444 @ 81,745 bytes</em></figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*bzF41z-_sC4eOzYLFe4avQ.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>AVIF 444 @ 76,087 bytes</em></figcaption></figure><p id="8e3e" data-selectable-paragraph="">Shown below is another source image from the boxshots-1 dataset along with <strong><em>JPEG 444 @ 80,562 bytes</em></strong> versus <strong><em>AVIF 444 @ 80,432 bytes</em></strong>. There is visible banding, blocking and mosquito artifacts in the JPEG encode whereas the AVIF encode looks very close to the original source.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*0m6JEgxVeA6yvdiPeIrTxQ.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph="">Another original source image from the Netflix (internal) boxshots-1 dataset</figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*yu8PI1VKHOwRAxISI3ncxg.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>JPEG 444 @ 80,562 bytes</em></figcaption></figure><figure><div><div><div><div><p><img src="https://miro.medium.com/max/21/1*Q99QLwx4njEX38LwAPNrAw.png?q=20" width="1142" height="1600" role="presentation"></p><p><img width="1142" height="1600" role="presentation"></p></div></div></div></div><figcaption data-selectable-paragraph=""><em>AVIF 444 @ 80,432 bytes</em></figcaption></figure><p id="2021" data-selectable-paragraph="">Shown below are results over public datasets as well as Netflix-internal datasets. The reference codec used is JPEG from the JPEG-XT reference software, using the standard quantization matrix defined in Annex K of the JPEG standard. Following are the codecs and/or configurations tested and reported against the baseline in the form of BD rate.</p><figure><div><div><div><p><img src="https://miro.medium.com/max/30/1*hhln_i44miB7gz1Xcwy-mQ.png?q=20" width="625" height="341" role="presentation"></p><p><img width="625" height="341" role="presentation"></p></div></div></div></figure><p id="1929" data-selectable-paragraph="">The encoding resolution in these experiments is the same as the source resolution. For 420 subsampling encodes, the quality metrics were computed in 420 subsampling domain. Likewise, for 444 subsampling encodes, the quality metrics were computed in 444 subsampling domain. Along with BD rates associated with various quality metrics, such as <a href="https://www.cns.nyu.edu/~lcv/ssim/" target="_blank" rel="noopener">SSIM</a>, <a href="https://ece.uwaterloo.ca/~z70wang/publications/msssim.html" target="_blank" rel="noopener">MS-SSIM</a>, <a href="https://live.ece.utexas.edu/research/Quality/VIF.htm" target="_blank" rel="noopener">VIF</a> and <a href="https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio" target="_blank" rel="noopener">PSNR</a>, we also show rate-quality plots using SSIM as the metric.</p><h2 id="dc29" data-selectable-paragraph="">Kodak dataset; 24 images; 768x512 resolution</h2><p id="414c" data-selectable-paragraph="">We have uploaded the <a href="http://r0k.us/graphics/kodak/" target="_blank" rel="noopener">source</a> images in PNG format <a href="https://drive.google.com/drive/folders/1VK12pBFnYJzJRD1k8uo38yammO-_XtkO?usp=sharing" target="_blank" rel="noopener">here</a> for easy reference. We give the necessary attribution to Kodak as the source of this dataset.</p><p id="b48a" data-selectable-paragraph="">Given a quality metric, for each image, we consider two separate rate-quality curves. One curve associated with the baseline (JPEG) and one curve associated with the target codec. We compare the two and compute the BD-rate which can be interpreted as the average percentage rate reduction for the same quality over the quality region being considered. A negative value implies rate reduction and hence is better compared to the baseline. As a last step, we report the arithmetic mean of BD rates over all images in the dataset. We also highlight the best performer in the tables below.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*qbl6alCWoqxoyzCRCFMuBQ.png?q=20" width="588" height="380" role="presentation"></p><p><img width="588" height="380" role="presentation"></p></div></div></div></div></figure><figure><div><div><div><p><img src="https://miro.medium.com/max/30/1*brg5e6o8PHg02trTYjBMyg.png?q=20" width="589" height="353" role="presentation"></p><p><img width="589" height="353" role="presentation"></p></div></div></div></figure></div></div><div><div><h2 id="9f5c" data-selectable-paragraph="">CLIC dataset; 303 images; 2048x1320 resolution</h2><p id="c9c7" data-selectable-paragraph="">We selected a subset of images from the dataset made public as part of the <a href="https://www.compression.cc/" target="_blank" rel="noopener">workshop and challenge on learned image compression (CLIC)</a>, held in conjunction with CVPR. We have uploaded our selected 303 source images in PNG format <a href="https://drive.google.com/drive/folders/1VK12pBFnYJzJRD1k8uo38yammO-_XtkO?usp=sharing" target="_blank" rel="noopener">here</a> for easy reference with appropriate attribution to CLIC.</p><figure><div><div><div><p><img src="https://miro.medium.com/max/30/1*qvH_h8eFpdVqutDeIWo0HQ.png?q=20" width="590" height="379" role="presentation"></p><p><img width="590" height="379" role="presentation"></p></div></div></div></figure><figure><div><div><div><p><img src="https://miro.medium.com/max/30/1*BdbgK4YS_9JEWaOKycLf9w.png?q=20" width="585" height="348" role="presentation"></p><p><img width="585" height="348" role="presentation"></p></div></div></div></figure></div></div><div><div><h2 id="fb6e" data-selectable-paragraph="">Billboard dataset (Netflix-internal); 223 images; 2048x1152 resolution</h2><p id="9e2d" data-selectable-paragraph="">Billboard images generally occupy a larger canvas than the thumbnail-like boxshot images and are generally horizontal. There is room to overlay text or graphics on one of the sides, either left or right, with salient characters/scenery/art being located on the other side. An example can be seen below. The billboard source images are internal to Netflix and hence do not constitute a public dataset.</p></div></div><div><div><h2 id="84bd" data-selectable-paragraph="">Boxshots-1 dataset (Netflix-internal); 100 images; 1142x1600 resolution</h2><p id="32d0" data-selectable-paragraph="">Unlike billboard images, boxshot images are vertical and typically boxshot images representing different titles are displayed side-by-side in the UI. Examples from this dataset are showcased in the section above on visual examples. The boxshots-1 source images are internal to Netflix and hence do not constitute a public dataset.</p><figure><div><div><div><div><p><img src="https://miro.medium.com/max/30/1*_sedBxiT4I0h3VaOeA9cHQ.png?q=20" width="593" height="381" role="presentation"></p><p><img width="593" height="381" role="presentation"></p></div></div></div></div></figure><figure><div><div><div><p><img src="https://miro.medium.com/max/30/1*mnzwMsNKQiknDmw80goKAw.png?q=20" width="590" height="360" role="presentation"></p><p><img width="590" height="360" role="presentation"></p></div></div></div></figure></div></div><div><div><h2 id="27e2" data-selectable-paragraph="">Boxshots-2 dataset (Netflix-internal); 100 images; 571x800 resolution</h2><p id="19a8" data-selectable-paragraph="">The boxshots-2 dataset also has vertical box art but of lower resolution. The boxshots-2 source images are internal to Netflix and hence do not constitute a public dataset.</p><figure><div><div><div><p><img src="https://miro.medium.com/max/30/1*u7SoHomIwP6lWwtWLu8XmA.png?q=20" width="595" height="385" role="presentation"></p><p><img width="595" height="385" role="presentation"></p></div></div></div></figure><figure><div><div><div><p><img src="https://miro.medium.com/max/30/1*LBesW3-hpWkbnFesGdQr5g.png?q=20" width="591" height="356" role="presentation"></p><p><img width="591" height="356" role="presentation"></p></div></div></div></figure></div></div><div><div><p id="393c" data-selectable-paragraph="">At this point, it might be prudent to discuss the omission of <a target="_blank" rel="noopener" href="https://netflixtechblog.com/vmaf-the-journey-continues-44b51ee9ed12">VMAF</a> as a quality metric here. In <a href="https://ieeexplore.ieee.org/abstract/document/8833510" target="_blank" rel="noopener">previous work</a> we have shown that for JPEG-like distortions and datasets similar to ‚Äúboxshots‚Äù and ‚Äúbillboards‚Äù, VMAF has high correlation with perceived quality. However, VMAF, as of today, is a metric trained and developed to judge encoded videos rather than static images. The range of distortions associated with the range of image codecs in our tests is broader than what was considered in the VMAF development process and to that end, it may not be an accurate measure of image quality for those codecs. Further, today‚Äôs VMAF model is not designed to capture chroma artifacts and hence would be unable to distinguish between 420 and 444 subsampling, for instance, apart from other chroma artifacts (this is also true of some other measures we‚Äôve used, but given the lack of alternatives, we‚Äôve leaned on the side of using the most well tested and documented image quality metrics). This is not to say that VMAF is grossly inaccurate for image quality, but to say that we would not use it in our evaluation of image compression algorithms with such a wide diversity of codecs at this time. We have some exciting upcoming work to improve the accuracy of VMAF for images, across a variety of codecs, and resolutions, including chroma channels in the score. Having said that, the code in the repository computes VMAF and the reader is encouraged to try it out and see that AVIF also shines judging by VMAF as is today.</p><p id="0674" data-selectable-paragraph="">PSNR does not have as high correlation with perceptual quality over a wide quality range. However, if encodes are made with a high PSNR target then one overspends bits but can rest assured that a high PSNR score implies closeness to the original. With perceptually driven metrics, we sometimes see failure manifest in rare cases where the score is undeservingly high but visual quality is lacking.</p><p id="7990" data-selectable-paragraph="">In addition to above quality calculations, we have the following observation which reveals an encouraging trend among modern codecs. After performing an encode with 420 subsampling, let‚Äôs assume we decode the image, up-convert it to 444 subsampling and then compute various metrics by comparing against the original source in 444 format. We call this configuration ‚Äú444u‚Äù to distinguish from above cases where ‚Äúencode-subsampling‚Äù and ‚Äúquality-computation-subsampling‚Äù match. Among the chosen metrics, PSNR_AVG is one which takes all 3 channels (1 luma and 2 chroma) into account. With an older codec like JPEG, the bit-budget is spread thin over more samples while encoding 444 subsampling compared to encoding 420 subsampling. This shows as poorer PSNR_AVG for encoding JPEG with 444 subsampling compared to 420 subsampling, as shown below. However, given a rate target, with modern codecs like HEVC and AVIF, it is simply better to encode 444 subsampling over a wide range of bitrates.</p></div></div><div><p id="fa59" data-selectable-paragraph="">We see that with modern codecs we yield a higher PSNR_AVG when encoding 444 subsampling than 420 subsampling over the entire region of ‚Äúpractical‚Äù rates, even for the other, more practical, datasets such as boxshots-1. Interestingly, with JPEG, we see a crossover; i.e., after crossing a certain rate, it starts being more efficient to encode 444 subsampling. Such <a href="https://ieeexplore.ieee.org/document/7532319" target="_blank" rel="noopener">crossovers</a> are analogous to rate-quality curves crossing over when encoding over <a target="_blank" rel="noopener" href="https://netflixtechblog.com/per-title-encode-optimization-7e99442b62a2">multiple spatial resolutions</a>. Shown below are rate-quality curves for two different source images from the boxshots-1 dataset, comparing JPEG and AVIF in both 444u and 444 configurations.</p></div><div><div><p id="3640" data-selectable-paragraph="">Although AVIF provides superior compression efficiency, it is still at an early deployment stage. Various tools exist to produce and consume AVIF images. The Alliance for Open Media is notably developing an open-source library, called <a href="https://github.com/AOMediaCodec/libavif" target="_blank" rel="noopener">libavif</a>, that can encode and decode AVIF images. The goal of this library is to ease the integration in software from the image community. Such integration has already started, for example, in various browsers, such as Google Chrome, and we expect to see broad support for AVIF images in the near future. Major efforts are also ongoing, in particular from the <a href="https://code.videolan.org/videolan/dav1d" target="_blank" rel="noopener">dav1d</a> team, to make AVIF image decoding as fast as possible, including for 10-bit images. It is conceivable that we will soon test AVIF images on Android following on the heels of our <a target="_blank" rel="noopener" href="https://netflixtechblog.com/netflix-now-streaming-av1-on-android-d5264a515202">recently announced AV1 video adoption efforts on Android</a>.</p><p id="8091" data-selectable-paragraph="">The datasets used above have standard dynamic range (SDR) 8-bit imagery. At Netflix, we are also working on HDR images for the UI and are planning to use AVIF for encoding these HDR image assets. This is a continuation of our <a target="_blank" rel="noopener" href="https://netflixtechblog.com/enhancing-the-netflix-ui-experience-with-hdr-1e7506ad3e8">previous efforts</a> where we experimented with JPEG 2000 as the compression format for HDR images and we are looking forward to the superior compression gains afforded by AVIF.</p><p id="0f13" data-selectable-paragraph="">We would like to thank Marjan Parsa, Pierre Lemieux, Zhi Li, Christos Bampis, Andrey Norkin, Hunter Ford, Igor Okulist, Joe Drago, Benbuck Nason, Yuji Mano, Adam Rofer and Jeff Watts for all their contributions and collaborations.</p><p id="1329" data-selectable-paragraph="">¬πas part of his work while he was affiliated with Netflix</p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>