<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Writing ClrMD extensions for WinDbg and LLDB - Criteo R&amp;D Blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Writing ClrMD extensions for WinDbg and LLDB - Criteo R&amp;D Blog</h1><div><div class="ac ae af ag ah ea aj ak"><p id="d870" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">You may have already read <a href="https://labs.criteo.com/2017/06/clrmd-part-5-how-to-use-clrmd-to-extend-sos-in-windbg/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">the CriteoLabs article about how to write ClrMD extensions for WinDbg</a>. As we move to Linux, we realized that we could not use our debugging toolbox anymore as it was written for WinDbg. Since LLDB is the common debugger for .net NET Core on Linux, I decided to write a compatibility layer to be able to load our extensions in the new environment. And while I was at it, I tried to make the overall process of writing such a debugger extension a bit simpler.</p><h1 id="7975" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Introducing ClrMDExports</h1><p id="74b8" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">How to create an extension that will work with both WinDbg and LLDB? The first step is still to create a new Class Library project. Both .NET Framework and .NET Standard are supported, so feel free to use the one you prefer. Some things to note though:</p><ul class=""><li id="9355" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb hx hy hz">If you choose .NET Framework, make sure not to use any feature that is not compatible with .NET Core (such as AppDomain), or you won’t be able to run your extension in LLDB</li><li id="da4a" class="go gp ed at gq b gr ia gt ib gv ic gx id gz ie hb hx hy hz">If you choose .NET Standard, remember to publish your project to have all the dependencies contained in one folder, as this is not done by default when you compile</li></ul><p id="a1e7" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">After creating your project, add a reference to <a href="https://www.nuget.org/packages/ClrMDExports/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">the ClrMDExports nuget package</a>. It will automatically pull ClrMD and <a href="https://www.nuget.org/packages/UnmanagedExports.Repack/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">UnmanagedExports.Repack</a> as dependencies. UnmanagedExports.Repack is a fork of UnmanagedExports which adds compatibility with .NET Framework 4.7+ and .NET Standard, and supports PackageReference. <strong class="gq if">Make sure that your project targets x86 or x64, as UnmanagedExports won’t work with AnyCPU.</strong></p><p id="db03" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Note that a new <em class="ig">Init.cs</em> file gets added to your project (it should not be visible if you use package references). <strong class="gq if">Do not make any change to this file. </strong>It will be overwritten each time you update the nuget package.</p><p id="9239" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The Init file takes care of exporting the <code class="ih ii ij ik il b">DebugExtensionInitialize</code> method needed by WinDbg, and setups everything so that dependencies are correctly loaded as long as they’re in the same folder as your extension.</p><p id="1fa1" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">The next step is to add your custom commands. You need to create one static method for each command, with the following signature:</p><figure class="im in io ip iq ir"><p id="413a" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Then decorate it with the <code class="ih ii ij ik il b">DllExport</code> attribute that comes with UnmanagedExports. You can use the <code class="ih ii ij ik il b">ExportName</code> parameter of the attribute to define the command name that will be visible to WinDbg/LLDB. Remember that names are case-sensitive!</p><figure class="im in io ip iq ir"><p id="cead" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">In that method, you should only call the method <code class="ih ii ij ik il b">DebuggingContext.Execute</code> provided by ClrMDExports. It takes the value of <code class="ih ii ij ik il b">client</code> and <code class="ih ii ij ik il b">args</code> as parameters, as well as a delegate to another static method with the <code class="ih ii ij ik il b">(ClrRuntime runtime, string args)</code> signature. It’s in that static callback method that you will implement the logic of your command.</p><figure class="im in io ip iq ir"><p id="1a27" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">For your convenience, the console output is automatically redirected to the debugger.</p><p id="4560" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">And that’s it! From there, you can directly load and use your extension in WinDbg:</p><figure class="im in io ip iq ir dm dn paragraph-image"><figcaption class="ax fg jj jk jl do dm dn jm jn as cv">Writing a ClrMD extension for WinDbg is now a matter of minutes</figcaption></figure><h1 id="8e44" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">Running in LLDB on Linux</h1><p id="b5f9" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">As the extension is written for the WinDbg API, it cannot be directly loaded into LLDB. Instead, <a href="https://github.com/kevingosse/LLDB-LoadManaged/" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">I’ve written a meta-plugin</a> that does the translation.</p><p id="bd76" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">How to use it? First, <a href="https://github.com/kevingosse/LLDB-LoadManaged/releases" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">download the latest release</a> of the LLDB-LoadManaged meta-plugin and unzip it in a folder.</p><p id="ae9a" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Then start LLDB and attach to a target (live process or crash dump):</p><pre class="im in io ip iq jo jp cm"><span id="5b8e" class="jq hh ed at il b fg jr js r jt">./lldb -c dump.dmp</span></pre><p id="2642" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Next, load the meta-plugin:</p><pre class="im in io ip iq jo jp cm"><span id="6819" class="jq hh ed at il b fg jr js r jt">plugin load ./loadmanaged/libloadmanaged.so</span></pre><p id="7576" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">It’s important to make sure that the <em class="ig">Mono.Cecil.dll</em> and <em class="ig">PluginInterop.dll</em> files are located in the same folder as <em class="ig">libloadmanaged.so</em>.</p><p id="b8e6" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Upon load, LLDB-LoadManaged will try to locate CoreCLR by browsing the modules loaded in your debug target. If it fails (for instance, because you’re running lldb on a different machine than the target), you can manually set the path by calling <code class="ih ii ij ik il b">SetClrPath</code>:</p><pre class="im in io ip iq jo jp cm"><span id="e311" class="jq hh ed at il b fg jr js r jt">SetClrPath /usr/local/share/dotnet/shared/Microsoft.NETCore.App/2.2.0/</span></pre><p id="9ee8" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Lastly, load the WinDbg extension using the <code class="ih ii ij ik il b">LoadManaged</code> command:</p><pre class="im in io ip iq jo jp cm"><span id="94d8" class="jq hh ed at il b fg jr js r jt">LoadManaged /home/k.gosse/TestExtension.dll</span></pre><p id="44e7" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">(the <code class="ih ii ij ik il b">LoadManaged</code> command does not support relative paths yet)</p><p id="e5db" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">And that’s it! Now you can call the commands exposed by the extension just like you would in WinDbg.</p><figure class="im in io ip iq ir dm dn paragraph-image"><figcaption class="ax fg jj jk jl do dm dn jm jn as cv">The ClrMD extension for WinDbg runs flawlessly in LLDB on Linux</figcaption></figure><p id="1526" class="go gp ed at gq b gr gs gt gu gv gw gx gy gz ha hb dv">Note: both <em class="ig">libloadmanaged.so</em> and <em class="ig">libsosplugin.so</em> host a CLR for their own needs. Unfortunately, <a href="https://github.com/dotnet/coreclr/issues/22529" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">the .NET Core CLR does not support side-by-side scenarios</a>. It means you cannot use LoadManaged and the SOS plugin at the same time. I’m aware this is a huge limitation, but it’s unlikely that it gets fixed on .NET Core side. As a workaround, I will probably work on a managed version of SOS that can be loaded through LoadManaged and replace <em class="ig">libsosplugin.so</em>.</p><h1 id="9cff" class="hg hh ed at as hi ef hj eh hk hl hm hn ho hp hq hr">What’s next</h1><p id="6324" class="go gp ed at gq b gr hs gt ht gv hu gx hv gz hw hb dv">This is still a very early version of LLDB-LoadManaged. In the coming weeks, I’d like to improve the error handling and make the CLR path detection smarter. Still, we already use it on a regular basis at Criteo, so it should be stable enough for the common use-cases. The main added value of using LLDB versus a standalone ClrMD applications is the possibility to attach to a live process (ClrMD on Linux does not support that yet). I also know there’s been some work on a cross-platform REPL environment based on ClrMD (<a href="https://github.com/dotnet/diagnostics/tree/master/src/Tools" class="da by hc hd he hf" target="_blank" rel="noopener nofollow">https://github.com/dotnet/diagnostics/tree/master/src/Tools</a>), so it will be nice to see how both efforts can converge.</p></figure></figure></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>