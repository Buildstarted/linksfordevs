<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Entity component system - Wikipedia -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Entity component system - Wikipedia</h1><div><div class="mw-parser-output"><p><b>Entity–component–system</b> (<b>ECS</b>) is an <a href="/wiki/Software_architecture" title="Software architecture">architectural</a> pattern that is mostly used in game development. ECS follows the <a href="/wiki/Composition_over_inheritance" title="Composition over inheritance">composition over inheritance</a> principle that allows greater flexibility in defining entities where every object in a game's scene is an entity (e.g. enemies, bullets, vehicles, etc.). Every entity consists of one or more components which add behavior or functionality. Therefore, the behavior of an entity can be changed at runtime by adding or removing components. This eliminates the ambiguity problems of deep and wide inheritance hierarchies that are difficult to understand, maintain and extend. Common ECS approaches are highly compatible and often combined with <a href="/wiki/Data-oriented_design" title="Data-oriented design">data-oriented design</a> techniques.
</p><h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Entity_component_system&amp;action=edit&amp;section=1" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2><p>In 2007, the team working on <i><a href="/wiki/Operation_Flashpoint:_Dragon_Rising" title="Operation Flashpoint: Dragon Rising">Operation Flashpoint: Dragon Rising</a></i> experimented with ECS designs, including ones inspired by Bilas/<i>Dungeon Siege</i>, and Adam Martin later wrote a detailed account of ECS design,<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup> including definitions of core terminology and concepts.<sup id="cite_ref-ES-MMOG-2_2-0" class="reference"><a href="#cite_note-ES-MMOG-2-2">[2]</a></sup> In particular, Martin's work popularized the ideas of "Systems" as a first-class element, "Entities as ID's", "Components as raw Data", and "Code stored in Systems, not in Components or Entities".
</p><p>In 2015, <a href="/wiki/Apple_Inc." title="Apple Inc.">Apple Inc.</a> introduced <a href="/w/index.php?title=GameplayKit&amp;action=edit&amp;redlink=1" class="new" title="GameplayKit (page does not exist)">GameplayKit</a>, an <a href="/wiki/API" class="mw-redirect" title="API">API</a> framework for <a href="/wiki/IOS" title="IOS">iOS</a>, <a href="/wiki/MacOS" title="MacOS">macOS</a> and <a href="/wiki/TvOS" title="TvOS">tvOS</a> game development that includes an implementation of ECS. Although it is agnostic to the graphics engine used for rendering a game, it includes convenience support for integrating with Apple's <a href="/w/index.php?title=SpriteKit&amp;action=edit&amp;redlink=1" class="new" title="SpriteKit (page does not exist)">SpriteKit</a>, <a href="/wiki/SceneKit" title="SceneKit">SceneKit</a> and the <a href="/wiki/Xcode" title="Xcode">Xcode</a> Scene Editor.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[3]</a></sup></p><h2><span class="mw-headline" id="Characteristics">Characteristics</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Entity_component_system&amp;action=edit&amp;section=2" title="Edit section: Characteristics">edit</a><span class="mw-editsection-bracket">]</span></span></h2><p>Martin's terminology,<sup id="cite_ref-ES-MMOG-2_2-1" class="reference"><a href="#cite_note-ES-MMOG-2-2">[2]</a></sup> in wide use today:
</p><ul><li>Entity: The entity is a general purpose object. Usually, it only consists of a unique id. They "tag every coarse gameobject as a separate item". Implementations typically use a plain integer for this.<sup id="cite_ref-ESWiki_4-0" class="reference"><a href="#cite_note-ESWiki-4">[4]</a></sup></li><li>Component: the raw data for one aspect of the object, and how it interacts with the world. "Labels the Entity as possessing this particular aspect". Implementations typically use structs, classes, or associative arrays.<sup id="cite_ref-ESWiki_4-1" class="reference"><a href="#cite_note-ESWiki-4">[4]</a></sup></li><li>System: "Each System runs continuously (as though each System had its own private thread) and performs global actions on every Entity that possesses a Component of the same aspect as that System."</li></ul><p>Suppose there is a drawing function. This would be a "System" that iterates through all entities that have both a physical and a visible component, and draws them. The visible component could typically have some information about how an entity should look (e.g. human, monster, sparks flying around, flying arrow), and use the physical component to know where to draw it. Another system could be collision detection. It would iterate through all entities that have a physical component, as it would not care how the entity is drawn. This system would then, for instance, detect arrows that collide with monsters, and generate an event when that happens. It should not need to understand what an arrow is, and what it means when another object is hit by an arrow. Yet another component could be health data, and a system that manages health. Health components would be attached to the human and monster entities, but not to arrow entities. The health management system would subscribe to the event generated from collisions and update health accordingly. This system could also now and then iterate through all entities with the health component, and regenerate health.
</p><p>An entity only consists of an ID and a container of components. The idea is to have no game methods embedded in the entity. The container doesn't have to be located physically together with the entity, but should be easy to find and access. It is a common practice to use a unique ID for each entity. This is not a requirement, but it has several advantages:
</p><ul><li>The entity can be referred using the ID instead of a pointer. This is more robust, as it would allow for the entity to be destroyed without leaving dangling pointers.</li><li>It helps for saving state externally. When the state is loaded again, there is no need for pointers to be reconstructed.</li><li>Data can be shuffled around in memory as needed.</li><li>Entity ids can be used when communicating over a network to uniquely identify the entity.</li></ul><p>Some of these advantages can also be achieved using <a href="/wiki/Smart_pointer" title="Smart pointer">smart pointers</a>.
</p><p>The normal way to send data between systems is to store the data in components. For example, the position of an object can be updated regularly. This position is then used by other systems. If there are a lot of different infrequent events, a lot of flags will be needed in one or more components. Systems will then have to monitor these flags every iteration, which can become inefficient. A solution could be to use the <a href="/wiki/Observer_pattern" title="Observer pattern">observer pattern</a>. All systems that depend on an event subscribe to it. The action from the event will thus only be executed once, when it happens, and no polling is needed.
</p><p>In naïve ECS implementations, every system iterates through the complete list of all entities, and selects only those entities that are needed. The total iteration cost for all systems becomes too costly if the number of systems grows or the number of entities is large. In other ECS architectures, every component type is stored in a separate list, so whatever systems operate on a given type of component are only iterating over objects they care about by default. In this common ECS architecture, the described disadvantage actually becomes a major performance advantage, by more efficiently leveraging the CPU instruction and data caches.
</p><p>The ECS architecture handles dependencies in a very safe and simple way. Since components are simple data buckets, they have no dependencies. Each system will typically register the components an entity must have for the system to operate on it. For example, a render system might register the model, transform, and drawable components. It will then check each entity for those components, and if the entity has them all the system will perform its logic on that entity. If not, the entity is simply skipped, with no need for complex dependency trees. However this can be a place for bugs to hide, since propagating values from one system to another through components may be very hard to debug. ECS may be used where uncoupled data needs to be bound to a given lifetime.
</p><p>The ECS architecture uses composition, not complex inheritance trees. An entity will be typically made up of an ID and a list of components that are attached to it. Any type of game object can be created by adding the correct components to an entity. This can also allow the developer to easily add features of one type of object to another, without any dependency issues. For example, a player entity could have a "bullet" component added to it, and then it would meet the requirements to be manipulated by some "bulletHandler" system, which could result in that player doing damage to things by running into them.
</p><p>In the original talk at GDC <sup id="cite_ref-:0_5-0" class="reference"><a href="#cite_note-:0-5">[5]</a></sup> Scott Bilas compares C++ object system and his new Custom component system. This is consistent with a traditional use of this term in general <a href="/wiki/Systems_engineering" title="Systems engineering">systems engineering</a> with <a href="/wiki/Common_Lisp_Object_System" title="Common Lisp Object System">Common Lisp Object System</a> and <a href="/wiki/Type_system" title="Type system">type system</a> as examples. Therefore, the ideas of "Systems" as a first-class element is a personal opinion essay. Overall, ECS is a mixed personal reflection of orthogonal well-established ideas in general <a href="/wiki/Computer_science" title="Computer science">computer science</a> and <a href="/wiki/Programming_language_theory" title="Programming language theory">programming language theory</a>. For example, components can be seen as a <a href="/wiki/Mixin" title="Mixin">mixin</a> idiom in various programming languages. Alternatively, components are just a small case under the general <a href="/wiki/Delegation_(object-oriented_programming)" title="Delegation (object-oriented programming)">delegation (object-oriented programming)</a> approach and <a href="/wiki/Meta-object_protocol" class="mw-redirect" title="Meta-object protocol">meta-object protocol</a>. I.e. any complete component object system can be expressed with <i>templates</i> and <i>empathy</i> model within The Orlando Treaty<sup id="cite_ref-6" class="reference"><a href="#cite_note-6">[6]</a></sup> vision of <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">object-oriented programming</a>,
</p><h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Entity_component_system&amp;action=edit&amp;section=3" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2><h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Entity_component_system&amp;action=edit&amp;section=4" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2><div class="reflist"><div class="mw-references-wrap"><ol class="references"><li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span><span class="reference-text"><cite class="citation web">Martin, Adam. <a rel="nofollow" class="external text" href="http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/">"Entity Systems are the Future of MMOG Development"</a><span class="reference-accessdate">. Retrieved <span class="nowrap">25 December</span> 2013</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=Entity+Systems+are+the+Future+of+MMOG+Development&amp;rft.aulast=Martin&amp;rft.aufirst=Adam&amp;rft_id=http%3A%2F%2Ft-machine.org%2Findex.php%2F2007%2F09%2F03%2Fentity-systems-are-the-future-of-mmog-development-part-1%2F&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AEntity+component+system" class="Z3988"></span></span></li><li id="cite_note-ES-MMOG-2-2"><span class="mw-cite-backlink">^ <a href="#cite_ref-ES-MMOG-2_2-0"><sup><i><b>a</b></i></sup></a><a href="#cite_ref-ES-MMOG-2_2-1"><sup><i><b>b</b></i></sup></a></span><span class="reference-text"><cite class="citation web">Martin, Adam. <a rel="nofollow" class="external text" href="http://t-machine.org/index.php/2007/11/11/entity-systems-are-the-future-of-mmog-development-part-2/">"Entity Systems are the Future of MMOG Development Part 2"</a><span class="reference-accessdate">. Retrieved <span class="nowrap">25 December</span> 2013</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=Entity+Systems+are+the+Future+of+MMOG+Development+Part+2&amp;rft.aulast=Martin&amp;rft.aufirst=Adam&amp;rft_id=http%3A%2F%2Ft-machine.org%2Findex.php%2F2007%2F11%2F11%2Fentity-systems-are-the-future-of-mmog-development-part-2%2F&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AEntity+component+system" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"></span></li><li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span><span class="reference-text"><a rel="nofollow" class="external free" href="https://developer.apple.com/videos/play/wwdc2015/608/">https://developer.apple.com/videos/play/wwdc2015/608/</a></span></li><li id="cite_note-ESWiki-4"><span class="mw-cite-backlink">^ <a href="#cite_ref-ESWiki_4-0"><sup><i><b>a</b></i></sup></a><a href="#cite_ref-ESWiki_4-1"><sup><i><b>b</b></i></sup></a></span><span class="reference-text"><cite class="citation web"><a rel="nofollow" class="external text" href="http://entity-systems.wikidot.com/">"Entity Systems Wiki"</a><span class="reference-accessdate">. Retrieved <span class="nowrap">31 December</span> 2019</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=Entity+Systems+Wiki&amp;rft_id=http%3A%2F%2Fentity-systems.wikidot.com%2F&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AEntity+component+system" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"></span></li><li id="cite_note-:0-5"><span class="mw-cite-backlink"><b><a href="#cite_ref-:0_5-0">^</a></b></span><span class="reference-text"><cite class="citation web">Bilas, Scott. <a rel="nofollow" class="external text" href="http://gamedevs.org/uploads/data-driven-game-object-system.pdf">"A Data-Driven Game Object System"</a><span class="cs1-format">(PDF)</span><span class="reference-accessdate">. Retrieved <span class="nowrap">25 December</span> 2013</span>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=unknown&amp;rft.btitle=A+Data-Driven+Game+Object+System&amp;rft.aulast=Bilas&amp;rft.aufirst=Scott&amp;rft_id=http%3A%2F%2Fgamedevs.org%2Fuploads%2Fdata-driven-game-object-system.pdf&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3AEntity+component+system" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"></span></li><li id="cite_note-6"><span class="mw-cite-backlink"><b><a href="#cite_ref-6">^</a></b></span><span class="reference-text">Lynn Andrea Stein, Henry Liberman, David Ungar: <i>A shared view of sharing: The Treaty of Orlando</i>. In: Won Kim, Frederick H. Lochovsky (Eds.): <i>Object-Oriented Concepts, Databases, and Applications</i> ACM Press, New York 1989, ch. 3, pp.&nbsp;31–48 <link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"><a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&nbsp;<a href="/wiki/Special:BookSources/0-201-14410-7" title="Special:BookSources/0-201-14410-7">0-201-14410-7</a> (<a rel="nofollow" class="external text" href="http://web.media.mit.edu/~lieber/Publications/Treaty-of-Orlando-Chapter.pdf">online</a>)</span></li></ol></div></div><h2><span class="mw-headline" id="External_links">External links</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Entity_component_system&amp;action=edit&amp;section=5" title="Edit section: External links">edit</a><span class="mw-editsection-bracket">]</span></span></h2></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>