<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Path Building vs Path Verifying: The Chain of Pain - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Path Building vs Path Verifying: The Chain of Pain - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@sleevi_"/>
    <meta property="og:description" content="Disclaimer: This post represents personal opinions and thoughts, and does not represent the views or positions of my employer, Google."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@sleevi_/path-building-vs-path-verifying-the-chain-of-pain-9fbab861d7d6"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Path Building vs Path Verifying: The Chain of Pain</title>
<div class="readable">
        <h1>Path Building vs Path Verifying: The Chain of Pain</h1>
            <div>by https://medium.com/@sleevi_</div>
            <div>Reading time: 19-23 minutes</div>
        <div>Posted here: 24 Jun 2020</div>
        <p><a href="https://medium.com/@sleevi_/path-building-vs-path-verifying-the-chain-of-pain-9fbab861d7d6">https://medium.com/@sleevi_/path-building-vs-path-verifying-the-chain-of-pain-9fbab861d7d6</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@sleevi_?source=post_page-----9fbab861d7d6----------------------"><img alt="Ryan Sleevi" src="https://miro.medium.com/fit/c/96/96/0*f7tlX2YUMTyKGtS3.jpeg" width="48" height="48"></a></p></div></div></div></div><p id="c459" data-selectable-paragraph=""><em>Disclaimer: This post represents personal opinions and thoughts, and does not represent the views or positions of my employer, Google.</em></p><p id="345e" data-selectable-paragraph="">On the last Saturday in May, at 10:48 GMT, a time when most folks in the US were still sleeping, the <a href="https://crt.sh/?id=1" target="_blank" rel="noopener nofollow">self-signed AddTrust External CA Root certificate</a> expired. In an ideal world, this would have been completely uneventful; an idle curiosity for those who embrace certificate numerology, but otherwise nothing of note.</p><p id="e865" data-selectable-paragraph="">Shortly before going to bed that morning, in the process of debugging an unrelated Roku issue (trouble casting), I noticed they were reporting some disruptions should be expected, and so I tweeted a few tweets about what I expected to happen:</p><figure><div></div></figure><p id="fb84" data-selectable-paragraph="">At the time, my thinking was that most libraries were at least capable of handling this scenario, and that at best, it’d be a measure to figure out who hadn’t upgraded to OpenSSL 1.1.x, as better handling for this was one of the important fixes in that release. For example, from the most recent version of Roku’s open source packages, it looked like they were still using <a href="https://roku.app.box.com/v/RokuOpenSourceSoftware/folder/92884148344" target="_blank" rel="noopener nofollow">OpenSSL 1.0.2h</a>, a version with plenty of <a href="https://www.openssl.org/news/openssl-1.0.2-notes.html" target="_blank" rel="noopener nofollow">known CVEs</a>.¹</p><p id="cd3f" data-selectable-paragraph="">By the time I’d woken up, my Twitter notifications were starting to see a <a href="https://twitter.com/__agwa/timelines/1266777818811322368" target="_blank" rel="noopener nofollow">steady stream of folks reporting broken sites, services, and devices</a>, but it <a href="https://twitter.com/sleevi_/status/1266752059140866050" target="_blank" rel="noopener nofollow">wasn’t entirely what I’d expected</a>. While there were the servers with out-of-date versions of OpenSSL, and device vendors who <a href="https://twitter.com/blowdart/status/1267102685553061888" target="_blank" rel="noopener nofollow">looked to be downright bad</a> at updating OpenSSL², a number of broken products seemed to be using LibreSSL, including macOS’s <a href="https://twitter.com/bagder/status/1266833164703498241" target="_blank" rel="noopener nofollow">distribution of cURL</a>, or GnuTLS, such as <a href="https://twitter.com/sleevi_/status/1266872060250402817" target="_blank" rel="noopener nofollow">LG Smart TVs</a> and <a href="https://twitter.com/sleevi_/status/1266731836912422912" target="_blank" rel="noopener nofollow">Debian’s apt</a>. While I expected IoT-targeting libraries that I’d worked with in the past, like MatrixSSL and wolfSSL, to still be awful now as they were when I’d worked with them, I did not expect to see modern macOS and Debian failing over.</p><p id="bc1c" data-selectable-paragraph="">Andrew Ayer quickly put together a post that <a href="https://www.agwa.name/blog/post/fixing_the_addtrust_root_expiration" target="_blank" rel="noopener nofollow">described the problem and possible solutions</a>, but this post is going to take a more in-depth look at the few of the open-source libraries involved, why things went bad, why they’re still bad, and what can be done about it.</p><p id="81f5" data-selectable-paragraph="">To understand the problem, it’s first necessary to dispel a common misconception about certificates. Often, when I talk to people who are responsible for configuring certificates on their servers, they often talk about <em>the</em> certificate chain. The singular set of certificates, from their server’s certificate to a Root owned by the CA they bought their certificate from, as if there is one Right and True Way to configure the server. Any problems that result are inherently the server’s fault, and blame should be placed on the server for being misconfigured.</p><p id="ae0b" data-selectable-paragraph="">It’s not unreasonable for people to have that view. After all, if you look at virtually every TLS/web server software’s configuration, you configure <strong>the</strong> chain. If you read any of the TLS RFCs prior to TLS 1.3, such as <a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener nofollow">RFC 5246</a> (TLS 1.2) you’ll see language directing the TLS server to send <em>the</em> chain, an <a href="https://tools.ietf.org/html/rfc5246#section-7.4.2" target="_blank" rel="noopener nofollow">unbroken sequence of certificates to a root</a>.³</p><p id="3dba" data-selectable-paragraph="">Unfortunately, that’s not the case. There are many chains, with <a href="https://blog.cloudflare.com/introducing-cfssl/" target="_blank" rel="noopener nofollow">different chains are needed by different clients</a>, who have different root stores and different behaviors. The server operator isn’t at fault, the problem is actually quite complex.</p><p id="acf2" data-selectable-paragraph="">This particular problem was caused by libraries that were not prepared to handle that complexity, which has existed since the very earliest days of SSL/TLS and the use of publicly trusted CAs. <a href="https://tools.ietf.org/html/rfc4158" target="_blank" rel="noopener nofollow">Entire RFCs</a> have been written about how to do things correctly, yet these libraries didn’t do that and weren’t prepared, which leads to problems like what we saw.</p><figure><a href="https://tools.ietf.org/html/rfc4158#section-1.5.3"><div><div><div><p><img src="https://miro.medium.com/max/60/1*YBydACvJ4KrSkHGWcPGkQQ.png?q=20" width="527" height="480" role="presentation"></p><p><img width="527" height="480" srcset="https://miro.medium.com/max/552/1*YBydACvJ4KrSkHGWcPGkQQ.png 276w, https://miro.medium.com/max/1000/1*YBydACvJ4KrSkHGWcPGkQQ.png 500w" sizes="500px" role="presentation"></p></div></div></div></a><figcaption data-selectable-paragraph="">Figure 7 from RFC 4158</figcaption></figure><p id="2c54" data-selectable-paragraph="">Figure 7 from <a href="https://tools.ietf.org/html/rfc4158" target="_blank" rel="noopener nofollow">RFC 4158</a> best illustrates the hidden complexity involved here, called “simple” here because we only have 3 CAs, instead of the hundreds that are actually involved. The nodes A, B, and C all represent CA certificates. To keep it “simple”, that there’s one and only one certificate for each of these CAs.</p><p id="954a" data-selectable-paragraph="">For the single server certificate (“EE”), there are four potential paths to a trusted source: EE←B¹←A¹←Trust Anchor, EE←B¹←A²←C¹←Trust Anchor, EE←B²←C¹🡐Trust Anchor, and EE←B²←C²←A¹←Trust Anchor. A¹ and A² are used to indicate that while there’s a single logical CA, called A, there are two distinct certificates associated with it, each with their own properties, restrictions, and, relevant to this incident, expiration. A¹ is issued by our Trust Anchor, while A² is issued by C, a CA that itself has two certificates.</p><p id="79d4" data-selectable-paragraph="">A good PKI implementation, one robust against problems like this, is one that is capable of finding and evaluating all four of those paths. For example, imagine that C¹ and C² both were expired/revoked/untrusted. This would mean that there’s only one valid certificate chain that ends in a trust anchor: EE←B¹←A¹←Trust Anchor. If the server sent the chain EE←B¹←A²←C¹, which includes the expired C¹ certificate, a robust library would know how to replace A² with A¹, which would lead to that trusted path, ensuring things Just Work.</p><p id="a66b" data-selectable-paragraph="">This is roughly what happened with the AddTrust expiration. AddTrust External CA Root was C¹, and USERTrust RSA Certification Authority was A². Clients that had trouble connecting were clients that didn’t know how to swap out A² with A¹, and thus couldn’t verify the path, and blew up spectacularly.</p><p id="484a" data-selectable-paragraph="">Without wanting to get too bogged down in details, it’s worth noting that the term “trust anchor” is not interchangeable with “self-signed/root certificate”. A <a href="https://tools.ietf.org/html/rfc5280#section-6.2" target="_blank" rel="noopener nofollow">trust anchor</a> is, at the core, just a CA name (as in, a <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.4" target="_blank" rel="noopener nofollow">Distinguished Name</a>) and a <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.7" target="_blank" rel="noopener nofollow">public key</a>, although it can have many other optional attributes attached, such as expiration or purpose. It doesn’t have to be a root certificate, or even a certificate for that matter, although certificates are the easiest way to configure them. Looking at that Figure 7 graph again, it’s possible for any CA in that graph to be configured as a trust anchor. That is, if A is a trust anchor, then the client trusts A¹ and A², and if C is a trust anchor, the client trusts C¹ and C² equally⁴. Trust Anchors don’t have to be self-signed — they’re just keys and names — and they affect how certificate paths are verified. This is relevant to the AddTrust expiration, because properly recognizing that USERTrust RSA Certification Authority was itself already configured as a trust anchor would have, in this specific case, also avoided the problem.</p><h2 id="1b10" data-selectable-paragraph="">Visualizing the Problem</h2><figure><a href="https://observablehq.com/@sleevi/graph-of-mozilla-trusted-cas"><div><div><div><p><img alt="A visualization of the Mozilla Trusted CAs PKI graph, showing CAs as nodes, and the certificates that link them as edges." src="https://miro.medium.com/max/60/1*49YxBJ-tbdbYI0yU5Z1GaQ.png?q=20" width="976" height="683"></p><p><img alt="A visualization of the Mozilla Trusted CAs PKI graph, showing CAs as nodes, and the certificates that link them as edges." width="976" height="683" srcset="https://miro.medium.com/max/552/1*49YxBJ-tbdbYI0yU5Z1GaQ.png 276w, https://miro.medium.com/max/1000/1*49YxBJ-tbdbYI0yU5Z1GaQ.png 500w" sizes="500px"></p></div></div></div></a><figcaption data-selectable-paragraph="">Mozilla Trusted CAs, June 8, 2020</figcaption></figure><p id="1e39" data-selectable-paragraph="">In practice, the PKI for publicly trusted CAs is far more complex. You can play around with this in an <a href="https://observablehq.com/@sleevi/graph-of-mozilla-trusted-cas" target="_blank" rel="noopener nofollow">off-the-cuff visualization</a> (<a href="https://gist.github.com/sleevi/6d4c702d0e613cc2e53e3f0d7645ad66" target="_blank" rel="noopener nofollow">source queries</a>) I worked up to see this, which shows just the “current” Mozilla trust store. While my D3 skills are terrible, this hopefully makes it easy to visualize the inherent complexity and relationships, as any certificate with more than one arrow pointing away from it means there are more than one certificate paths. Censys is also helpful, but as you can see in <a href="https://censys.io/certificates/891ee2e23282e5076c9ae9047de8ea900e066f81d6dcd9b843c59078b0f105bc/validation/google_ct_primary" target="_blank" rel="noopener nofollow">some cases</a>, it doesn’t exhaustively display all <a href="https://crt.sh/?id=721305519" target="_blank" rel="noopener nofollow">possible</a> <a href="https://crt.sh/?id=250864698" target="_blank" rel="noopener nofollow">certificate</a> <a href="https://crt.sh/?id=21606053" target="_blank" rel="noopener nofollow">paths</a> that a client might need or encounter. It does, however, show how just four nodes can be represented by 11 different certificate paths.</p><p id="b72d" data-selectable-paragraph="">As messy as this is, it gets worse when considering more than just one trust store. Scott Helme has a decent enough <a href="https://scotthelme.co.uk/impending-doom-root-ca-expiring-legacy-clients/" target="_blank" rel="noopener nofollow">write-up of the problem of legacy clients</a>, and how different paths are needed. The above query is meant to give a small taste of that complexity, which continues to increase when considering older versions of Mozilla’s trust store, such as on poorly-maintained Linux distros, and the trust stores of other vendors, such as Apple and Microsoft.</p><p id="0b0b" data-selectable-paragraph="">A different way of thinking about the problem is that anytime a CA has two or more different issuers, the path graph gets complicated. Looking at <a href="https://gist.github.com/sleevi/81d80c6f60def81cba6442e6948a4b98" target="_blank" rel="noopener nofollow">the list of CAs</a> that have this property, you see every major CA represented. This “problem” was an intentionally introduced feature of X.509v3, which allowed for cross-certificates, in order to better reflect how organizations express trust, and has been widely used since, but is not widely supported outside of browser and operating system verification stacks.</p><p id="25c1" data-selectable-paragraph="">The first step to avoiding the problem is no longer thinking about “the” certificate chain, and instead thinking of building and verifying potential certificate paths, each of which are chains to a trust anchor.</p><p id="e654" data-selectable-paragraph="">Successful client implementations all have one thing in common: they treat the problem as a graph traversal problem, as described in <a href="https://tools.ietf.org/html/rfc4158" target="_blank" rel="noopener nofollow">RFC 4158</a>. The graph is constructed based on the nodes available to the client: the server’s certificate, the additional certificates it sent via TLS, certificates the client has available (both trusted and untrusted), and potentially online sources like those retrieved on-the-fly via the <a href="https://tools.ietf.org/html/rfc5280#section-4.2.2.1" target="_blank" rel="noopener nofollow">authorityInformationAccess extension</a>. The goal is to build a valid path, through this graph, from the end-entity certificate to a trust anchor, by using a depth-first search. The order the server sends things might be used as an optimization hint, or it might be ignored, but in any event, as many paths as possible are tried until one of them works.</p><p id="ba16" data-selectable-paragraph="">RFC 4158 covers this in far greater depth, including discussions about how to avoid cycles and optimize selection. While Golang’s verifier leaves a <a href="https://tools.ietf.org/html/rfc4158#section-3.5.6" target="_blank" rel="noopener nofollow">number </a><a href="https://tools.ietf.org/html/rfc4158#section-3.5.5" target="_blank" rel="noopener nofollow">of</a> <a href="https://tools.ietf.org/html/rfc4158#section-3.5" target="_blank" rel="noopener nofollow">optimizations</a> on the table, it still manages to do this path building in a little <a href="https://golang.org/src/crypto/x509/verify.go#L715" target="_blank" rel="noopener nofollow">less than 400 lines of code</a>, highlighting how easy a DFS search is to implement.</p><p id="788e" data-selectable-paragraph="">It’s typically quite easy to spot a library that’s not capable of this: if the API assumes that there is a singular issuer certificate, it’s going to have a bad time. This can take different forms, but the most common anti-patterns are “get <em>the</em> certificate with this subject name” or “get <em>the</em> issuer for this certificate”. APIs that design around this assumption aren’t really capable of tackling the graph, and as a consequence, will fail in some form. An API should be capable of returning multiple certificates that match a given subject name, so that it can consider all of these when building a certificate path.</p><p id="cfc3" data-selectable-paragraph="">Even if a library supports path building, doing some form of depth-first search in the PKI graph, the next most common mistake is still treating path building and path verification as separable, independent steps. That is, the path builder finds “a chain” that is rooted in a trusted CA, and then completes. The completed chain is then handed to a path verifier, which asks “Does this chain meet all the caller’s/application’s requirements”, and returns a “Yes/No” answer. If the answer is “No”, you want the path builder to consider those other paths in the graph, to see if there are any “Yes” paths. Yet if the path building and verification steps are different, you’re bound to have a bad time.</p><p id="6989" data-selectable-paragraph="">“No” can come for a number of reasons, many of which are touched on in RFC 4158. One of the certificates may be revoked, the certificate might be trusted but not for the purpose the application wants (e.g. trusted for S/MIME e-mails, but not TLS), the certificate policies could be incompatible, the client might have restrictions applied, etc. In the case of Sectigo, “a certificate is expired” was the cause for the “No”, but the applications weren’t prepared to handle that. If your application supports path building, but still assumes there is “<em>the</em> chain” that is supplied to the verifier, bad things will happen.</p><p id="6ff2" data-selectable-paragraph="">If you develop, or contribute, to a library that was affected by this issue, and want to make things more robust, what are the key properties an implementation should have so it can be prepared?</p><ul><li id="fca4" data-selectable-paragraph="">Make sure your APIs return issuer<strong>s</strong>, and not just a single issuer.</li><li id="a4a6" data-selectable-paragraph="">When returning issuers, have a plan to sort them. You can do a simple sort, such as preferring trusted certificates first, or you could consider the strategies from RFC 4158. As RFC 4158 calls out, for every positive example, there’s likely a negative counter-example as well; the joy of engineering is finding the right balance for the use case.</li><li id="7f73" data-selectable-paragraph="">Treat the certificates from the server as TLS 1.3 describes: a collection of certificates that can be used to build out the graph, rather than as an ordered linear chain, although with the first certificate as the server’s certificate.</li><li id="1787" data-selectable-paragraph="">Support some way of discovering additional links in the graph. This could be by allowing the calling application to provide a set of “not positively trusted” certificates, such as Mozilla’s <a href="https://wiki.mozilla.org/Security/CryptoEngineering/Intermediate_Preloading" target="_blank" rel="noopener nofollow">intermediate preloading</a> does, or it could mean supporting fetching authorityInformationAccess and allowing the CA to provide these additional certificates.</li><li id="a41e" data-selectable-paragraph="">Integrate any checks as part of path building, such that path verification is merely a part of path building. You don’t need to build every chain, and then try to verify every chain; verify-as-you-go is a fine strategy. However, it’s essential that if a chain doesn’t verify, path building continues and tries to exhaust all paths before returning.</li><li id="bd9f" data-selectable-paragraph="">As with all graph algorithms, know your limits. Whether it’s the length/depth of the chain, the number of paths explored, the number of signatures verified, or the total time spent examining the graph, apply bounds to limit shenanigans.</li></ul><p id="359d" data-selectable-paragraph="">Once a basic path builder is implemented, as described above, it’s also necessary to think about a number of important API decisions that are relevant for TLS server authentication on the Internet. Some of these are documented, some are lessons hard learned, but all are important if you’re using the same CAs as browsers use, and hoping for the same security.</p><h2 id="2ccc" data-selectable-paragraph="">Name Constraints</h2><p id="78bf" data-selectable-paragraph=""><a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.10" target="_blank" rel="noopener nofollow">RFC 5280 requires</a> (in the <a href="https://tools.ietf.org/html/rfc6919" target="_blank" rel="noopener nofollow">RFC 6919</a> sense) support for nameConstraints. However, support is somewhat loose; only the directoryName constraints need to be supported, and other name types can be ignored if the nameConstraints extension wasn’t marked critical. Unfortunately, dueto older versions of OpenSSL and macOS, which didn’t support nameConstraints and thus certificates <em>correctly</em> failing to work with these systems when the extension was marked critical, the browsers of the CA/Browser Forum decided to allow CAs to issue certificates without marking the extension critical. This is because systems that implemented nameConstraints were protected, and constraining CAs was better than not constraining them, so it was worth the deviation.</p><p id="63f6" data-selectable-paragraph="">If the client library doesn’t support nameConstraints, it’s exposed to risk from these CAs, and so it’s important to fix.</p><p id="b2c6" data-selectable-paragraph="">However, beyond just supporting nameConstraints over the subjectAltName, it’s important to support nameConstraints on the commonName, if the commonName is supported. If a client library supports falling back to commonName, and doesn’t enforce these constraints, the CA can bypass the nameConstraints entirely!</p><p id="9bf5" data-selectable-paragraph="">Tools like <a href="https://nameconstraints.bettertls.com/" target="_blank" rel="noopener nofollow">https://nameconstraints.bettertls.com/</a> provide useful test suites to test exactly these sorts of issues.</p><h2 id="0159" data-selectable-paragraph="">Extended Key Usages</h2><p id="1426" data-selectable-paragraph="">Another common gotcha is not checking Extended Key Usage at all, or not checking it in a “browser-compatible” world. When X.509v3 was introduced, the belief was that <a href="https://security.stackexchange.com/questions/12583/x-509-certificate-policy-mapping-question" target="_blank" rel="noopener nofollow">Certificate Policies</a> would be the main way that CAs were limited in what and how they issued, as that’s what it was designed for. Unfortunately for the IETF, rough consensus and running code had <a href="https://mailarchive.ietf.org/arch/msg/pkix/QQ4vHlYLyYFYnswc14_jTdHHbLg/" target="_blank" rel="noopener nofollow">different ideas</a> on how to restrict issuance, and that involved the use of EKUs. While <a href="https://mailarchive.ietf.org/arch/msg/pkix/aR6Yav3iYPgnQONW37ksLFnR0J4/" target="_blank" rel="noopener nofollow">controversial</a> to <a href="https://mailarchive.ietf.org/arch/msg/pkix/EzBA2NgSx6zi2CG-D2oKaOBbGvE/" target="_blank" rel="noopener nofollow">some</a>, the reality is that the majority of browsers require the EKU on a Subscriber certificate be a subset of the EKUs of the certification path. For example, if an intermediate has an EKU which indicates S/MIME, it cannot be used to issue TLS certificates.</p><p id="9e70" data-selectable-paragraph="">This important check <a href="https://trailofbits.files.wordpress.com/2012/06/flame-md5.pdf" target="_blank" rel="noopener nofollow">could have prevented</a> Flame’s MD5 collision from being useful, but more importantly, it’s the basis for many of the policy decisions in root stores. If one of the EKUs that root store cares about is not present within an Intermediate CA, then in today’s world, “out of sight, out of mind”.</p><p id="1ead" data-selectable-paragraph="">It used to be that, beyond checking for id-kp-serverAuth, implementations also needed to allow intermediates to assert Netscape or Microsoft’s Server-Gated Cryptography EKUs. Why? Because Sectigo’s <em>other</em> <a href="https://crt.sh/?id=10066" target="_blank" rel="noopener nofollow">cross-sign</a> only supported those EKUs. Luckily, that expired June of 2019, and so existing libraries that do that mapping, in order to keep Sectigo certs working, no longer need to do so.</p><h2 id="3847" data-selectable-paragraph="">Weak Crypto Handling</h2><p id="2291" data-selectable-paragraph="">It’s 2020. Do you know where your validation libraries weak crypto knobs are? Successfully disabling SHA-1 requires a robust certificate path builder, as it depends on the ability to consider alternative paths, such as handling a <a href="https://crt.sh/?id=6712" target="_blank" rel="noopener nofollow">SHA-256 cross-sign</a> instead of the <a href="https://crt.sh/?id=155" target="_blank" rel="noopener nofollow">SHA-1 cross-sign</a>. It’s also necessary to handle situations where <a href="https://crt.sh/?caid=270" target="_blank" rel="noopener nofollow">one trust anchor</a> is signed with SHA-1 by <a href="https://crt.sh/?id=18068120" target="_blank" rel="noopener nofollow">another trust anchor</a>. If the path builder doesn’t know how to discover that the first cert is actually a trust anchor, it’d incorrectly reject it.</p><h2 id="def6" data-selectable-paragraph="">Trust Store Design and Trust Anchor Restrictions</h2><p id="6a11" data-selectable-paragraph="">Every browser root store has some notion of additional attributes that can be associated with a trust anchor. For those that store their trust anchors as certificates, it’s rare that these attributes are actually carried in the certificate themselves; they’re often part of the trust store format itself. Users should be wary if the library stores trust anchors as certificates on disk, or in arrays, because the API design fundamentally prevents carrying these attributes through.</p><p id="c317" data-selectable-paragraph="">The most important restriction, particularly for trust stores shared among many applications, is the trust purpose of the CA. Some CAs are only trusted for e-mail, some only for document signing, and some only for the Web. A single trust store often exposes unnecessary risk, because these CAs aren’t managed the same and thinking about the same risk.</p><p id="2bf8" data-selectable-paragraph="">A more popular recent restriction is limiting CAs from issuing new certificates, as measured by the notBefore date of the certificate. If a certificate’s notBefore is greater than some date, it’s not trusted. This is meant to gradually sunset trust in a CA. However, nothing prevents the CA from deceptively setting the notBefore some date in the past, and so it is often accompanied with ensuring some maximum lifetime for certificates, to put an upper bound on the sunset period and how long the CA can backdate.</p><p id="6e7b" data-selectable-paragraph="">Now that you’ve got a better understanding of why/how things work, continue on to the <a target="_blank" rel="noopener" href="https://medium.com/@sleevi_/path-building-vs-path-verifying-implementation-showdown-39a9272b2820">Implementation Showdown</a> to see how various open-source libraries stack up.</p><p id="126c" data-selectable-paragraph="">¹ Roku OS 9.2 is admittedly <a href="https://blog.roku.com/roku-os-92" target="_blank" rel="noopener nofollow">a bit old</a>, first being released on 2019–09–19, which was still (slightly) before it was <a href="https://www.openssl.org/blog/blog/2019/11/07/3.0-update/" target="_blank" rel="noopener nofollow">EOLed</a>, although premium support contracts are still available. <a href="https://support.roku.com/article/228844467-roku-os-software-release-notes" target="_blank" rel="noopener nofollow">Roku OS 9.3</a> is the current release, but no source is available. I’ve <a href="https://www.roku.com/separatelylicensedcode" target="_blank" rel="noopener nofollow">emailed them</a> requesting the source for 9.3, in order to figure out whether they made it to OpenSSL 1.1.x, but to no response. In theory they could be on <a href="https://www.openssl.org/support/contracts.html" target="_blank" rel="noopener nofollow">Premium Level Support</a>.</p><p id="9c0d" data-selectable-paragraph="">² While I love my Ubiquiti Unifi gear, their <a href="https://web.archive.org/web/20160305001123/http://libertybsd.net/ubiquiti/" target="_blank" rel="noopener nofollow">history of GPL woes</a> makes it painful to be certain. While I don’t know for sure that the UDM Pro issue reported was tied to old OpenSSL, one of the few products I could find the GPL Archive for, the <a href="https://www.ui.com/download/edgemax/edgerouter/default/edgerouter-8-xg-firmware-v11011#" target="_blank" rel="noopener nofollow">EdgeRouter 8-XG Firmware v1.10.11, dated 2020–03–01</a>, ships a version of <a href="https://mta.openssl.org/pipermail/openssl-announce/2016-May/000070.html" target="_blank" rel="noopener nofollow">OpenSSL that is over 4 years old</a>: 1.0.1t. This doesn’t inspire much hope.</p><p id="dc5b" data-selectable-paragraph="">³ RFC 8446, the TLS 1.3 RFC, thankfully <a href="https://tools.ietf.org/html/rfc8446#section-4.4.2" target="_blank" rel="noopener nofollow">added language</a> to address this, acknowledging that the only true invariant is that the server’s certificate comes first.</p><p id="660b" data-selectable-paragraph="">⁴ <a href="https://tools.ietf.org/html/rfc6818#section-4" target="_blank" rel="noopener nofollow">RFC 6818, Section 4</a> adds some useful clarifications here. If using a self-signed certificate as a trust anchor, it’s implementation defined whether or not the policies and restrictions apply. For example, some implementations, like Android, ignore the expiration date on certificates used as Trust Anchors, while other implementations, like OpenSSL, enforce them. The trade-offs in these approaches is worthy of an entirely separate article, but the important part is understanding that a trust anchor doesn’t have to be self-signed in order to be a trust anchor. The signature, and potentially many other attributes of the certificate, is ignored.</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>