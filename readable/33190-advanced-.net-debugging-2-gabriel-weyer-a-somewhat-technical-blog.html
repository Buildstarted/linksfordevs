<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Advanced .NET Debugging #2 &#x2013; Gabriel Weyer &#x2013; A somewhat technical blog -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Advanced .NET Debugging #2 – Gabriel Weyer – A somewhat technical blog</h1><div><div id="" class="post-content"><p>I’m continuing to read the excellent <a href="https://www.goodreads.com/book/show/7306509-advanced-net-debugging">Advanced .NET Debugging</a> by Mario Hewardt. Last time I looked at <a href="/2018/04/06/advanced-dotnet-debugging-1/">finding the entry point of a native image</a>. This time around I’ll be investigating the launch of a <strong>managed</strong> image by <code class="highlighter-rouge">Windows</code>.</p><h2 id="prerequisites">Prerequisites</h2><ul><li>A hex viewer
    <ul><li>I used the <a href="https://peclrviewer.azurewebsites.net/">PE CLR Viewer</a> (<strong>disclaimer</strong>: I created this truly ugly looking website)</li></ul></li></ul><h2 id="the-problem">The problem</h2><p>In the section <strong>Loading .NET Assemblies</strong> Mario explains how <code class="highlighter-rouge">Windows</code> is loading a managed image. He’s leveraging <a href="https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-reference">dumpbin.exe</a> which requires a <code class="highlighter-rouge">Visual Studio</code> installation <strong>with</strong> the <code class="highlighter-rouge">C++</code> workload. This has two issues:</p><ul><li>The <code class="highlighter-rouge">C++</code> workload requires a few <code class="highlighter-rouge">GB</code> of hard drive</li><li><code class="highlighter-rouge">dumpbin</code> presents a high-level view of the different headers, hence it’s not a good teaching tool as it abstracts the process of reading the bytes</li></ul><p>I decided to try a different approach. I’ve compiled a <strong>x86</strong> managed image which you can download <a href="https://gabrielweyer.blob.core.windows.net/blog-samples/advanced-dotnet-debugging-2/net461-x86.exe">here</a>. You can then visualise it using the <a href="https://peclrviewer.azurewebsites.net/">PE CLR Viewer</a> and follow me down the rabbit hole.</p><h2 id="finding-the-addressofentrypoint">Finding the <code class="highlighter-rouge">AddressOfEntryPoint</code></h2><p>I recommend you first read the <a href="/2018/04/06/advanced-dotnet-debugging-1/">previous post</a> in this series as it explains core concepts such as <a href="/2018/04/06/advanced-dotnet-debugging-1/#endianness">endianness</a> and <a href="/2018/04/06/advanced-dotnet-debugging-1/#relative-virtual-address">Relative Virtual Address</a>.</p><p>Last time I highlighted a formula to compute the <code class="highlighter-rouge">AddressOfEntryPoint</code> file offset:</p><blockquote><p>Signature file offset + <code class="highlighter-rouge">0x28</code> = <code class="highlighter-rouge">AddressOfEntryPoint</code> file offset</p></blockquote><p>The <code class="highlighter-rouge">signature file offset</code> is always at file offset <code class="highlighter-rouge">0x3C</code>. As seen below it has for value <code class="highlighter-rouge">0x80</code>.</p><p><img src="/assets/advanced-dotnet-debugging-2/signature-file-offset.png" alt="Signature file offset"></p><p>Now that we have the <code class="highlighter-rouge">signature file offset</code>, we can compute the <code class="highlighter-rouge">AddressOfEntryPoint</code> file offset:</p><blockquote><p><code class="highlighter-rouge">0x80</code> + <code class="highlighter-rouge">0x28</code> = <code class="highlighter-rouge">0xA8</code></p></blockquote><p><img src="/assets/advanced-dotnet-debugging-2/address-of-entry-point.png" alt="AddressOfEntryPoint"></p><p>As seen above, <code class="highlighter-rouge">AddressOfEntryPoint</code> has for value <code class="highlighter-rouge">0x2716</code>. But wait we’re not done, the <code class="highlighter-rouge">AddressOfEntryPoint</code> is a <code class="highlighter-rouge">RVA</code> which we need to convert to a file offset.</p><h2 id="converting-the-entry-point-rva-to-a-file-offset">Converting the entry point <code class="highlighter-rouge">RVA</code> to a file offset</h2><p>The entry point is located in the <strong>.text</strong> section (the <strong>.text</strong> section contains executable code), so we’ll need to locate the <strong>.text</strong> section first and this is where the <strong>section headers</strong> come into play. The <strong>section headers</strong> is a conversion table between <code class="highlighter-rouge">RVA</code> and file offset for the different sections:</p><p><img src="/assets/advanced-dotnet-debugging-2/text-section-header.png" alt=".text section header"></p><p>According to the screenshot above the <strong>.text</strong> section has a base <code class="highlighter-rouge">RVA</code> of <code class="highlighter-rouge">0x2000</code> and is located at file offset <code class="highlighter-rouge">0x200</code>. Those two pieces of information will allow us to convert the entry point <code class="highlighter-rouge">RVA</code> into an entry point file offset:</p><blockquote><p>Entry point <code class="highlighter-rouge">RVA</code> - .text base <code class="highlighter-rouge">RVA</code> + .text file offset = entry point file offset</p></blockquote><p>Let’s replace the placeholders with the values we obtained previously:</p><blockquote><p><code class="highlighter-rouge">0x2716</code> - <code class="highlighter-rouge">0x2000</code> + <code class="highlighter-rouge">0x200</code> = <code class="highlighter-rouge">0x916</code></p></blockquote><p>The entry point has for file offset <code class="highlighter-rouge">0x916</code>. But as we’ll see in the next section, this is yet another level of indirection.</p><h2 id="jumping-into-the-import-address-table">Jumping into the Import Address Table</h2><p><img src="/assets/advanced-dotnet-debugging-2/jump.png" alt="JMP"></p><p>Apparently the first part (<code class="highlighter-rouge">FF25</code>) is the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/x86-instructions#control_flow">x86 instruction</a> for <code class="highlighter-rouge">JMP</code> which instruct the computer to jump to an address (the second part):</p><blockquote><p><code class="highlighter-rouge">JMP 402000</code></p></blockquote><p><code class="highlighter-rouge">0x402000</code> is a <code class="highlighter-rouge">VA</code> (<code class="highlighter-rouge">Virtual Address</code>) based on the <strong>image base</strong> which has a value of <code class="highlighter-rouge">0x400000</code> (as seen in the <strong>NT specific fields header</strong> section):</p><p><img src="/assets/advanced-dotnet-debugging-2/image-base.png" alt="Image Base"></p><p>Armed with this knowledge we can convert the <code class="highlighter-rouge">VA</code> to a <code class="highlighter-rouge">RVA</code>:</p><blockquote><p><code class="highlighter-rouge">VA</code> - image base <code class="highlighter-rouge">VA</code> = <code class="highlighter-rouge">RVA</code></p></blockquote><p>Let’s replace the placeholders with the values we obtained previously:</p><blockquote><p><code class="highlighter-rouge">0x402000</code> - <code class="highlighter-rouge">0x400000</code> = <code class="highlighter-rouge">0x2000</code></p></blockquote><p>If we look at the <strong>Data directories</strong> section, we can see than the <strong>Import Address Table</strong> is located at <code class="highlighter-rouge">RVA</code><code class="highlighter-rouge">0x2000</code>. The <strong>Import Address Table</strong> is the first section of the <strong>.text</strong> section.</p><p><img src="/assets/advanced-dotnet-debugging-2/import-address-table-rva.png" alt="Import Address Table RVA"></p><h2 id="jumping-out-of-the-import-address-table">Jumping out of the Import Address Table</h2><p><img src="/assets/advanced-dotnet-debugging-2/import-address-table.png" alt="Import Address Table"></p><p>The <code class="highlighter-rouge">RVA</code> located at file offset <code class="highlighter-rouge">0x200</code> is: <code class="highlighter-rouge">0x26F8</code>. Like a mad rabbit, we continue jumping around. We can reuse the formula to convert a <code class="highlighter-rouge">RVA</code> to a file offset:</p><blockquote><p><code class="highlighter-rouge">0x26F8</code> - <code class="highlighter-rouge">0x2000</code> + <code class="highlighter-rouge">0x200</code> = <code class="highlighter-rouge">0x8F8</code></p></blockquote><p>Now I have good news, <code class="highlighter-rouge">0x8F8</code> is our final destination. Let’s inspect it more closely:</p><p><img src="/assets/advanced-dotnet-debugging-2/real-entry-point.png" alt="Real entry point"></p><p>We skip the leading <code class="highlighter-rouge">NUL</code> bytes, the other bytes are <code class="highlighter-rouge">ASCII</code> characters. The first section is the function name <code class="highlighter-rouge">_CorExeMain</code> and - coming after a <code class="highlighter-rouge">NUL</code> byte - the second section is the name of the executable: <code class="highlighter-rouge">mscoree.dll</code>.</p><p>As it turns out <code class="highlighter-rouge">mscoree.dll</code> is located in the <code class="highlighter-rouge">Windows</code> directory:</p><p><img src="/assets/advanced-dotnet-debugging-2/mscoree.png" alt="mscoree"></p><h2 id="conclusion">Conclusion</h2><p>I’ve demonstrated how to find the entry point of a <strong>x86</strong> managed image but in reality <code class="highlighter-rouge">Windows</code> knows how to execute a managed image just by looking at the <strong>CLI header</strong>. In the case of <strong>x64</strong> managed image the entry point is not even present!</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>