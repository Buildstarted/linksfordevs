<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Performance best practices in C# - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Performance best practices in C# - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@kevingosse"/>
    <meta property="og:description" content="Non-exhaustive list of code patterns to avoid in C#, either because they are risky or perform poorly."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@kevingosse/performance-best-practices-in-c-b85a47bdd93a"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Performance best practices in C#</title>
<div class="readable">
        <h1>Performance best practices in C#</h1>
            <div>by https://medium.com/@kevingosse</div>
            <div>Reading time: 8-10 minutes</div>
        <div>Posted here: 12 May 2020</div>
        <p><a href="https://medium.com/@kevingosse/performance-best-practices-in-c-b85a47bdd93a">https://medium.com/@kevingosse/performance-best-practices-in-c-b85a47bdd93a</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@kevingosse?source=post_page-----b85a47bdd93a----------------------"><img alt="Kevin Gosse" src="https://miro.medium.com/fit/c/96/96/1*uQa2E6LGdotlsEg6fCm1yw.jpeg" width="48" height="48"></a></p></div></div></div></div><p id="2ac7" data-selectable-paragraph="">As I recently had to compile a list of best practices in C# for Criteo, I figured it would be nice to share it publicly. This articles’ goal is to provide a non-exhaustive list of code patterns to avoid, either because they’re risky or because they perform poorly. The list may seem a bit random because it’s out of context, but <strong>all </strong>the items have been spotted in our code at some point and have caused production issues. Hopefully this will serve as a warning and prevent you from making the same mistakes.</p><p id="bc74" data-selectable-paragraph="">Also note that Criteo web services rely on high-performance code, hence the need to avoid inefficient code patterns. Some of those patterns wouldn’t make a noticeable difference in most applications.</p><p id="db01" data-selectable-paragraph="">Last but not least, some points have already been discussed in length in many articles (such as <code>ConfigureAwait</code>), so I do not elaborate on them. The goal is to have a list of points to keep in mind, rather than a in-depth technical description of each of them.</p><p id="e77e" data-selectable-paragraph=""><strong>Don’t ever wait synchronously for non-completed tasks.</strong> Including but not limited to: <code>Task.Wait</code>, <code>Task.Result</code>, <code>Task.GetAwaiter().GetResult()</code>, <code>Task.WaitAny</code>, <code>Task.WaitAll</code>.<br>As a more general advice, any synchronous dependency between two threadpool threads is susceptible to cause threadpool starvation. The causes of the phenomenon are described <a target="_blank" rel="noopener" href="https://medium.com/criteo-labs/net-threadpool-starvation-and-how-queuing-makes-it-worse-512c8d570527">in this article</a>.</p><p id="f2cf" data-selectable-paragraph=""><strong>If your code may be called from a synchronization context, use </strong><code><strong>ConfigureAwait(false)</strong></code><strong><em> </em>on each of your await calls.</strong></p><p id="1e5e" data-selectable-paragraph="">Note however that <code>ConfigureAwait</code> <strong>only ever has a meaning when using the </strong><code><strong>await</strong></code><strong><em> </em>keyword</strong>.</p><p id="712e" data-selectable-paragraph="">For instance, this code doesn’t make any sense:</p><figure><div></div></figure><p id="982c" data-selectable-paragraph=""><strong>Never use </strong><code><strong>async void</strong></code>. An exception thrown in an <code>async void</code> method is propagated to the synchronization context and usually ends up crashing the whole application.</p><p id="51e2" data-selectable-paragraph="">If you can’t return a task in your method (for instance because you’re implementing an interface), move the async code to another method and call it:</p><figure><div></div></figure><p id="4551" data-selectable-paragraph="">Out of habit/muscle memory, you might write:</p><figure><div></div></figure><p id="3a7d" data-selectable-paragraph="">While the code is semantically correct, using the <code>async</code> keyword is not needed here and can have a significant overhead in hot paths. Try removing it whenever possible:</p><figure><div></div></figure><p id="b2c1" data-selectable-paragraph="">However, keep in mind that you can’t use that optimization when your code is wrapped in blocks (like <code>try/catch</code> or <code>using</code>) :</p><figure><div></div></figure><p id="e4e5" data-selectable-paragraph="">In the incorrect version, since the task isn’t awaited inside of the using block, the client might be disposed before the <code>GetAsync</code> call completes.</p><p id="6444" data-selectable-paragraph="">Unless you have a reason to use culture-sensitive comparisons, <strong>always use ordinal comparisons</strong> instead. While it doesn’t make much of a difference with en-US culture because of internal optimizations, the comparisons get one order of magnitude slower with other cultures (up to 2 orders of magnitude on Linux!). As string comparisons are a frequent operation in most applications, it quickly adds up.</p><p id="c16d" data-selectable-paragraph=""><strong>Never use </strong><code><strong>ConcurrentBag&lt;T&gt;</strong></code><strong> without benchmarking</strong>. This collection has been designed for very specific use-cases (when most of the time an item is dequeued by the thread that enqueued it) and suffers from important performance issues if used otherwise. If in need of a concurrent collection, <strong>prefer </strong><code><strong>ConcurrentQueue&lt;T&gt;</strong></code>.</p><p id="eeaf" data-selectable-paragraph=""><strong>Never use </strong><code><strong>ReaderWriterLock&lt;T&gt;</strong></code><strong>/</strong><code><strong>ReaderWriterLockSlim&lt;T&gt;</strong></code><strong> without benchmarking. </strong>While it may be tempting to use this kind of specialized synchronization primitive when dealing with readers and writers, its cost is much higher than a simple <code>Monitor</code> (usable with the <code>lock</code> keyword). Unless the number of readers executing the critical section at the same time is <em>very</em> high, the concurrency won’t be enough to amortize the increased overhead, and the code will perform worse.</p><p id="b6f2" data-selectable-paragraph="">Consider the following code:</p><figure><div></div></figure><p id="7cf6" data-selectable-paragraph="">Resharper suggests to rewrite the code without a lambda function, which may look cleaner:</p><figure><div></div></figure><p id="4199" data-selectable-paragraph="">Unfortunately, doing so introduces a heap allocation at each call. Indeed, the call is compiled as:</p><figure><div></div></figure><p id="1b83" data-selectable-paragraph="">This can have a significant impact if the code is called in a hot spot.</p><p id="7cd6" data-selectable-paragraph="">Using lambda functions triggers a compiler optimization that caches the delegate into a static field, removing that allocation. This only works if <code>Filter</code><em> </em>is static. If not, you may want to cache the delegate yourself:</p><figure><div></div></figure><p id="5835" data-selectable-paragraph="">Calling <code>Enum.ToString</code> in .net is very costly, as reflection is used internally for the conversion and calling a virtual method on struct causes boxing. As much as possible, this should be avoided.</p><p id="9f64" data-selectable-paragraph="">Oftentimes, enums can actually be replaced by const strings:</p><figure><div></div></figure><p id="c728" data-selectable-paragraph="">If you really need an enum, then consider caching the converted value in a dictionary to amortize the cost.</p><p id="edb9" data-selectable-paragraph=""><strong>Note: this is not true anymore in .net core since version 2.1, the optimization is performed automatically by the JIT</strong></p><p id="c5ce" data-selectable-paragraph="">When using enums as flags, it may be tempting to use the <code>Enum.HasFlag</code> method:</p><figure><div></div></figure><p id="5dbb" data-selectable-paragraph="">This code causes two boxing allocations: one to convert <code>Options.Option2</code> to <code>Enum</code>, and another one for the <code>HasFlag</code> virtual call on a struct. This makes this code disproportionately expensive. Instead, you should sacrifice readability and use binary operators:</p><figure><div></div></figure><p id="391b" data-selectable-paragraph="">When using struct in comparisons (for instance, when used as a key for a dictionary), you need to override the <code>Equals</code>/<code>GetHashCode</code> methods. The default implementation uses reflection and is very slow. The implementation generated by Resharper is usually good enough.</p><p id="0d60" data-selectable-paragraph="">More information: <a href="https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/" target="_blank" rel="noopener nofollow">https://devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c/</a></p><p id="1930" data-selectable-paragraph="">Consider the following code:</p><figure><div></div></figure><p id="20aa" data-selectable-paragraph="">It’s tempting to make <code>IntValue</code> a struct to avoid heap allocations. But since <code>AddValue</code> and <code>SendValue</code> expect an interface, and interfaces have reference semantics, the value will be boxed at every call, nullifying the benefits of the “optimization”. In fact, it will allocate even more than if <code>IntValue</code> was a class, since the value will be boxed independently for each call.</p><p id="b590" data-selectable-paragraph="">If you write an API and expect some values to be structs, try using generic methods:</p><figure><div></div></figure><p id="0d37" data-selectable-paragraph="">While making those methods generic looks useless at first glance, it actually allows to avoid the boxing allocation when <code>IntValue</code> is a struct.</p><p id="46b0" data-selectable-paragraph="">Whenever you cancel a <code>CancellationTokenSource</code>, all subscriptions will be executed inside of the current thread. This can lead to unplanned pauses or even subtle deadlocks.</p><figure><div></div></figure><p id="c8a0" data-selectable-paragraph="">You cannot opt-out from this behavior. Therefore, when cancelling a <code>CancellationTokenSource</code>, ask yourself whether you can safely let your current thread be hijacked. If the answer is no, then wrap the call to <code>Cancel</code> inside of a <code>Task.Run</code> to execute it on the threadpool.</p><p id="56b0" data-selectable-paragraph="">Just like <code>CancellationToken</code> subscriptions, <code>TaskCompletionSource</code> continuations are often inlined. This is a nice optimization, but it can be the cause of subtle errors. For instance, consider the following program:</p><figure><div></div></figure><p id="92f7" data-selectable-paragraph="">The call to <code>tcs.SetResult</code><em> </em>causes the continuation of <code>await ProcessAsync()</code><em> </em>to execute in the current thread. Therefore, the statement <code>_mutex.Wait()</code> is executed by the same thread that is supposed to call <code>_mutex.Set()</code>, resulting in a deadlock. This can be prevented by giving the <code>TaskCreationsOptions.RunContinuationsAsynchronously</code> parameter to the <code>TaskCompletionSource</code>.</p><p id="bda9" data-selectable-paragraph=""><strong>Unless you have a good reason to omit it, always use the </strong><code><strong>TaskCreationsOptions.RunContinuationsAsynchronously</strong></code><strong> parameter when creating a </strong><code><strong>TaskCompletionSource</strong></code><strong>.</strong></p><p id="413e" data-selectable-paragraph="">Beware: the code will also compile if you use <code><strong>TaskContinuationOptions</strong>.RunContinuationsAsynchronously</code> instead of <code><strong>TaskCreationOptions</strong>.RunContinuationsAsynchronously</code>, but the parameters will be ignored and the continuations will keep being inlined. This is a surprisingly common error, because <code>TaskContinuationOptions</code> comes before <code>TaskCreationOptions</code> in the auto-completion.</p><p id="62a9" data-selectable-paragraph="">Unless you have a reason to use <code>Task.Factory.StartNew</code>, always favor <code>Task.Run</code> to start a background task. <code>Task.Run</code> uses safer defaults, and more importantly it automatically unwraps the return task, which can prevent subtle errors with async methods. Consider the following program:</p><figure><div></div></figure><p id="4d25" data-selectable-paragraph="">Despite the appearances, “End of program” will be displayed before “Processing done”. This is because <code>Task.Factory.StartNew</code> is going to return a <code>Task&lt;Task&gt;</code>, and the code only waits on the outer task. Correct code could would be either <code>await Task.Factory.StartNew(ProcessAsync).Unwrap()</code><em> </em>or <code>Task.Run(ProcessAsync)</code>.</p><p id="267a" data-selectable-paragraph="">There are only three legitimate use-cases for <code>Task.Factory.StartNew</code>:</p><ul><li id="7951" data-selectable-paragraph="">Starting a task on a different scheduler</li><li id="9c9e" data-selectable-paragraph="">Executing the task on a dedicated thread (using <code>TaskCreationOptions.LongRunning</code>)</li><li id="58ee" data-selectable-paragraph="">Queuing the task on the threadpool global queue (using <code>TaskCreationOptions.PreferFairness</code>)</li></ul></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>