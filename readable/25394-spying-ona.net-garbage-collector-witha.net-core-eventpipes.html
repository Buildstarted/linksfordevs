<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Spying on&#x252C;&#xE1;.NET Garbage Collector with&#x252C;&#xE1;.NET Core EventPipes -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }
    </style>
</head>
<body>
    <div class="grid">
            <h1>Spying on&#x252C;&#xE1;.NET Garbage Collector with&#x252C;&#xE1;.NET Core EventPipes</h1>
        
<div class="readable"><div><div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><div class="uiScale uiScale-ui--regular uiScale-caption--regular u-flexCenter u-marginVertical24 u-fontSize15 js-postMetaLockup"><div class="u-flex0"><a class="link u-baseColor--link avatar" href="https://medium.com/@chnasarre?source=post_header_lockup"><img src="https://cdn-images-1.medium.com/fit/c/100/100/0*p_afBNMUbL9S3Ojv" class="avatar-image u-size50x50" alt="Go to the profile of Christophe Nasarre"></a></div><div class="u-flex1 u-paddingLeft15 u-overflowHidden"></div></div><p id="e5ad" class="graf graf--p graf-after--h3">This post of the series shows how to generate GC logs in&#xA0;.NET Core with the new event pipes architecture and details the events emitted by the CLR during a collection.</p><p id="67ff" class="graf graf--p graf-after--p">Part 1: <a href="http://labs.criteo.com/2018/06/replace-net-performance-counters-by-clr-event-tracing" class="markup--anchor markup--p-anchor">Replace&#xA0;.NET performance counters by CLR event tracing</a>.</p><p id="959f" class="graf graf--p graf-after--p">Part 2: <a href="http://labs.criteo.com/2018/07/grab-etw-session-providers-and-events/" class="markup--anchor markup--p-anchor">Grab ETW Session, Providers and Events</a>.</p><p id="86db" class="graf graf--p graf-after--p">Part 3: CLR Threading events with TraceEvent.</p><p id="ef71" class="graf graf--p graf-after--p">Part 4: <a href="https://medium.com/criteo-labs/spying-on-net-garbage-collector-with-traceevent-f49dc3117de" class="markup--anchor markup--p-anchor">Spying on&#xA0;.NET Garbage Collector with TraceEvent</a>.</p><p id="f4ab" class="graf graf--p graf-after--p">Part 5: <a href="https://medium.com/criteo-labs/c-building-your-own-java-like-gc-logs-in-net-992205fd8d4f" class="markup--anchor markup--p-anchor">Building your own Java GC logs in&#xA0;.NET</a></p><p id="ba16" class="graf graf--p graf-after--h3">The previous episode of the series introduced the notion of &#x201C;GC log&#x201D;, well known in the Java world and how to implement it in&#xA0;.NET thanks to ETW and TraceEvent on Windows. This solution is easy but requires to create an ETW session (and to remember to close it)&#x2026; and is also not supported on Linux. However,&#xA0;<a href="https://medium.com/criteo-labs/c-in-process-clr-event-listeners-with-net-core-2-2-ef4075c14e87" class="markup--anchor markup--p-anchor">.NET Core 2.2 introduced</a> the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventlistener?view=netcore-2.2" class="markup--anchor markup--p-anchor">EventListener class</a> as the best way to receive CLR events both on Windows and Linux but only from inside the process itself. As of today, TraceEvent is not supporting live session with EventPipe/EventListener, only <a href="https://github.com/Microsoft/perfview/blob/master/src/TraceEvent/EventPipe/EventPipeEventSource.cs#L28" class="markup--anchor markup--p-anchor">a file-based constructor is available</a>. This is unfortunate because it means that you can&#x2019;t rely on the huge work done by TraceEvent to parse the CLR events; especially those related to garbage collections. The rest of the post will explain how to decipher raw events.</p><p id="ef00" class="graf graf--p graf-after--p">In addition, there is a bigger problem: the current&#xA0;.NET Core 2.2 implementation is <a href="https://github.com/dotnet/coreclr/issues/21380" class="markup--anchor markup--p-anchor">not working for all CLR events</a>. Long story short, the <code class="markup--code markup--p-code">EventPipe</code> class relies on specific Thread Local Storage slot that is not set by GC background worker threads: the events are not emitted in that case. In addition, there is no per event timestamp information in 2.2. The implementation presented in this post relies on tests done with ETW traces and on the <a href="https://github.com/dotnet/coreclr/pull/21817" class="markup--anchor markup--p-anchor">Pull Request</a> that fixes the issue for&#xA0;.NET Core 3.0, available in Preview 5.</p><p id="175b" class="graf graf--p graf-after--h3">The previous posts of the series were based on C# events raised by the TraceEvent parser with names different from the original CLR events and the <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events" class="markup--anchor markup--p-anchor">corresponding Microsoft Docs</a>. When you implement your EventListener-derived class, each event is received as an <code class="markup--code markup--p-code">EventWrittenEventArgs</code> object in the <code class="markup--code markup--p-code">OnEventWritten</code> override. The <code class="markup--code markup--p-code">EventId</code> and <code class="markup--code markup--p-code">EventName</code> properties allow you to figure out which event is received. If you have worked with TraceEvent before, you might be using the <code class="markup--code markup--p-code">Opcode</code> property but even if a property with the same name exists in <code class="markup--code markup--p-code">EventWrittenEventArgs</code>, the value is completely different and should not be used.</p><p id="67a9" class="graf graf--p graf-after--p">The CLR is versioning the emitted events to be able to add information over time. For example, the <code class="markup--code markup--p-code">EventId</code> of the &#x201C;GCStart&#x201D; event is 1 but the <code class="markup--code markup--p-code">EventName</code> could be <em class="markup--em markup--p-em">GCStart</em>, <em class="markup--em markup--p-em">GCStart_V1</em> or <em class="markup--em markup--p-em">GCStart_V2</em> even though the Microsoft Docs seems to be <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events#gcstart_v1_event" class="markup--anchor markup--p-anchor">stuck on version 1</a>. The following table lists the interesting GC events for&#xA0;.NET Core 2.2/3.0:</p><figure id="627d" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1600/1*NFTfqDwPckWMA7Pjv9oX5A.png"></figure><p id="a30b" class="graf graf--p graf-after--figure">Look at <a href="https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events" class="markup--anchor markup--p-anchor">https://docs.microsoft.com/en-us/dotnet/framework/performance/garbage-collection-etw-events</a> for the documentation related to each event.</p><p id="8e80" class="graf graf--p graf-after--p">If you go back to <a href="https://medium.com/criteo-labs/c-building-your-own-java-like-gc-logs-in-net-992205fd8d4f" class="markup--anchor markup--p-anchor">this previous article</a> of the series, you notice that all details provided by the <code class="markup--code markup--p-code">TraceGC</code> argument are available except for the objects size before and after the collection. These values are embedded in the workload of the <em class="markup--em markup--p-em">GCPerHeapHistory</em> event by the GC code. Unfortunately, these details are not marshalled by the current <code class="markup--code markup--p-code">EventPipe</code> implementation to your <code class="markup--code markup--p-code">OnEventWritten</code> override (read <a href="https://github.com/dotnet/coreclr/issues/24506" class="markup--anchor markup--p-anchor">https://github.com/dotnet/coreclr/issues/24506</a> for more details and when it will be fixed).</p><p id="279b" class="graf graf--p graf-after--p">There is no strongly typed <code class="markup--code markup--p-code">EventArgs</code> per event and you need to know the name of the field you are interested in to get its index. From this index, you get its corresponding value from the <code class="markup--code markup--p-code">Payload</code> property of the received <code class="markup--code markup--p-code">EventWrittenArgs</code>. The following helper method is doing the heavy lifting for you:</p><figure id="1bb6" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/785f28a7ddfa722526a091ea28754042?postId=9f2a986d5705" class></iframe></div></div></figure><p id="98c2" class="graf graf--p graf-after--figure">Now that all interesting events are known, it is time to figure out what is the sequence of events emitted during a garbage collection: a new line with the details should be added to the GC log file when the last event is received.</p><p id="36d4" class="graf graf--p graf-after--h3">So let&#x2019;s go back to the main phases of a garbage collection with the related CLR events as shown in the following figure (with <a href="https://twitter.com/konradkokosa" class="markup--anchor markup--p-anchor">Konrad Kokosa</a> courtesy from <a href="https://www.amazon.com/Pro-NET-Memory-Management-Performance/dp/148424026X" class="markup--anchor markup--p-anchor">his book</a>)</p><figure id="2391" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1600/1*pNJJ5L4IlEaOsH6aHzQ4tQ.png"></figure><p id="0bd1" class="graf graf--p graf-after--figure">This is the expected events for the most complicated case: a background collection with possible foreground ephemeral (gen0 and gen1) collections while the GC threads are concurrently sweeping. However, it is not possible to rely on this specific order of events because the order changes, depending on workstation/background mode and generation 2/ephemeral. Each type of collection triggers events in different order as shown below:</p><figure id="fc57" class="graf graf--figure graf-after--h3"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1600/1*wxICgleCgQgNQKQ7eBd8Zg.png"></figure><figure id="717d" class="graf graf--figure graf-after--h3"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1600/1*mV2osuRu1bwXSgppAvmhvQ.png"></figure><p id="3b30" class="graf graf--p graf-after--figure">Here is a more visual view of what could happen (dark blue is gen 2 and light blue are ephemeral gen0/1):</p><figure id="9055" class="graf graf--figure graf-after--p"><img class="progressiveMedia-noscript js-progressiveMedia-inner" src="https://cdn-images-1.medium.com/max/1600/1*CJb-0oh4Z1vntA2JQpZsog.png"></figure><p id="c33c" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">GCTriggered</strong> event notifies that a new collection will start except in the case of foreground ephemeral gen0/gen1 collections triggered during a background gen2. In that case, you could rely on the <strong class="markup--strong markup--p-strong">GCStart</strong> event and check if a background gen2 is running. This <strong class="markup--strong markup--p-strong">GCStart</strong> event provides the condemned generation in its <code class="markup--code markup--p-code">Depth</code> property. So I keep track of both the current background GC (if any) and the foreground GC (if any) in a <code class="markup--code markup--p-code">GCInfo</code> object:</p><figure id="8cc7" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/3681cd1b2fb395828c66f47451afc91a?postId=9f2a986d5705" class></iframe></div></div></figure><p id="7b65" class="graf graf--p graf-after--figure">The <code class="markup--code markup--p-code">GCDetails</code> class keeps tracks of all the details gathered during a garbage collection:</p><figure id="3992" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/ff04ba33377ab62b2c450c590724ce29?postId=9f2a986d5705" class></iframe></div></div></figure><p id="f6b4" class="graf graf--p graf-after--figure">The <code class="markup--code markup--p-code">HeapDetails</code> stores the size of each generation after a collection:</p><figure id="8470" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/076819f06a289ff705d51c6dff4c9d10?postId=9f2a986d5705" class></iframe></div></div></figure><p id="ee53" class="graf graf--p graf-after--figure">The <code class="markup--code markup--p-code">GCDetails</code> instance is created when the <strong class="markup--strong markup--p-strong">GCStart</strong> event is received:</p><figure id="3eb2" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/b9f2975d70f0b7c0d6a172878bd87961?postId=9f2a986d5705" class></iframe></div></div></figure><p id="9a3b" class="graf graf--p graf-after--figure">This is where it is important to remember if either a background or foreground GC is starting. In the former case, the <code class="markup--code markup--p-code">CurrentBGC</code> field is set and the <code class="markup--code markup--p-code">GCInProgress</code> field is set otherwise with a new <code class="markup--code markup--p-code">GCDetails</code> instance.</p><p id="be4a" class="graf graf--p graf-after--p">That way, when either of <strong class="markup--strong markup--p-strong">GCGlobalHistory</strong> or <strong class="markup--strong markup--p-strong">GCHeapStarts</strong> is received, it is easy to know what is the GC in progress; i.e. if a foreground GC is in progress, an event happens in its context (until the last one <strong class="markup--strong markup--p-strong">GCHeapStats </strong>that will clean the <code class="markup--code markup--p-code">GCInProcess</code> field):</p><figure id="9af6" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/869bcb777cce98c3de0209b21f085522?postId=9f2a986d5705" class></iframe></div></div></figure><p id="a165" class="graf graf--p graf-after--h3">The suspension and pause time are not that complicated to compute. The garbage collector code is relying on the <code class="markup--code markup--p-code">SuspendEE</code> and <code class="markup--code markup--p-code">RestartEE</code> methods provided by the&#xA0;.NET Execution Engine to suspend and restart the application threads respectively. Each of these methods emits a pair of <strong class="markup--strong markup--p-strong">GCxxxBegin</strong> and <strong class="markup--strong markup--p-strong">GCxxxEnd</strong> events. After <strong class="markup--strong markup--p-strong">GCSuspendEEBegin</strong> is emitted, the Execution Engine waits for the application threads to suspend their execution. When all threads are suspended, <strong class="markup--strong markup--p-strong">GCSuspendEEEnd</strong> gets emitted.</p><p id="a7a5" class="graf graf--p graf-after--p">The <strong class="markup--strong markup--p-strong">GCRestartEEBegin</strong> event is emitted when the applications threads begin to resume their execution. When all application threads are resumed, <strong class="markup--strong markup--p-strong">GCRestartEEEnd</strong> gets emitted. The elapsed time between the <strong class="markup--strong markup--p-strong">GCSuspendEEEnd</strong> and <strong class="markup--strong markup--p-strong">GCRestartEEBegin</strong> events is counted as <em class="markup--em markup--p-em">suspension time</em>. However, for simplicity sake, my current implementation sums both the time spent by the Execution Engine to suspend the threads and the pause time due to the GC work.</p><p id="67d7" class="graf graf--p graf-after--p">The suspension start time is kept in <strong class="markup--strong markup--p-strong">GCInfo</strong>:</p><figure id="0fe6" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/3215e11bbaab2b45b5f92b6dcc4b33b1?postId=9f2a986d5705" class></iframe></div></div></figure><p id="e92c" class="graf graf--p graf-after--figure">It will be set when the <strong class="markup--strong markup--p-strong">GCSuspendEEBegin</strong> event is received:</p><figure id="a19a" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/ebff76a8ce9a3a7de0ce5b63b88ec98d?postId=9f2a986d5705" class></iframe></div></div></figure><p id="4a43" class="graf graf--p graf-after--figure">This implementation decision does not provide the same level of suspension details (no fine grain suspension time for inner foreground collections) as the one provided by the TraceEvent parsing.</p><p id="d753" class="graf graf--p graf-after--p">The sibling <strong class="markup--strong markup--p-strong">GCRestartEEEnd</strong> event is used to (1) compute the total pause time and (2) detect when gen0/gen1/non concurrent gen2 collections end:</p><figure id="ba88" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/cd73d8fb13dc8864d3f921ede2555bb3?postId=9f2a986d5705" class></iframe></div></div></figure><p id="82b0" class="graf graf--p graf-after--h3">As shown in the events workflow figure, the <strong class="markup--strong markup--p-strong">GCRestartEEBegin</strong>/<strong class="markup--strong markup--p-strong">GCRestartEEEnd</strong> duo of events are used to detect the end of non-concurrent gen0/1/2 collections. It is more complicated to detect the end of a gen2 background or inner ephemeral gen0/1 collections: <strong class="markup--strong markup--p-strong">GCGlobalHeapHistory</strong> for the former and <strong class="markup--strong markup--p-strong">GCHeapStats</strong> for the latter. However, these two events payload does not contain the piece of information to know if we are in a middle of a background gen 2 or not. With this details in mind, the code of the different event handlers is quite straightforward.</p><p id="8f34" class="graf graf--p graf-after--p">The generations size are retrieved from the <strong class="markup--strong markup--p-strong">GCHeapStat</strong> event:</p><figure id="4183" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/f6c3de655b36473369633c30710c1030?postId=9f2a986d5705" class></iframe></div></div></figure><p id="6eb6" class="graf graf--p graf-after--figure">Remember this is the last event received for a gen0/gen1/foreground gen2 collection so I&#x2019;m using it to clear the <code class="markup--code markup--p-code">GCInProgress</code> field: the next event will be for the current background gen2 if any (<code class="markup--code markup--p-code">CurrentBGC</code> field is not null) or a new collection.</p><p id="1d58" class="graf graf--p graf-after--p">As of today with Preview 5, the before/after generation sizes are not marshalled through event pipes (see the <a href="https://github.com/dotnet/coreclr/issues/24506" class="markup--anchor markup--p-anchor">corresponding bug</a> for more details) so the <strong class="markup--strong markup--p-strong">GCPerHeapHistory </strong>event does not bring any value.</p><p id="10e2" class="graf graf--p graf-after--p">The last <strong class="markup--strong markup--p-strong">GCGlobalHeapHistory</strong> event of background gen 2 collection is also used to detect compaction:</p><figure id="7fb5" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/1be0dd9853c20eb408a5ef89fb704577?postId=9f2a986d5705" class></iframe></div></div></figure><p id="a89b" class="graf graf--p graf-after--figure">In case of a background gen 2, this is the last event so there should not be any collection in progress:</p><figure id="eced" class="graf graf--figure graf--iframe graf-after--p"><div class="aspectRatioPlaceholder is-locked"><div class="iframeContainer"><iframe width="700" height="250" src="https://medium.com/media/8d942fe365d15c6d21d5537cde214a9c?postId=9f2a986d5705" class></iframe></div></div></figure><p id="60a8" class="graf graf--p graf-after--figure">The next received event will start a new garbage collection cycle of events.</p><p id="e788" class="graf graf--p graf-after--p graf--trailing">This post concludes the series about CLR events and how to use them to better understand how the runtime is behaving under the workloads of your applications. The code available on <a href="https://github.com/chrisnas/ClrEvents" class="markup--anchor markup--p-anchor">Github</a> has been updated to provide the <code class="markup--code markup--p-code">EventListenerGcLog</code> class that uses the code demonstrated in this post to generate GC logs with event pipes.</p></div></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>