<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Trace Context -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Trace Context</h1>
    <body class="h-entry"><section id="abstract" class="introductory"><p>This specification defines standard headers and value format to propagate
context information that enables distributed tracing scenarios. The
specification standardizes how context information is sent and modified between
services. Context information uniquely identifies individual requests in a
distributed system and also defines a means to add and propagate
provider-specific context information.</p></section><section id="sotd" class="introductory"><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current <abbr>W3C</abbr> publications and the latest revision of this technical report can be found in the <a href="https://www.w3.org/TR/"><abbr>W3C</abbr> technical reports index</a> at https://www.w3.org/TR/.</em></p><p>This specification is in Candidate Recommendation stage. It was widely viewed
and discussed. It satisfies Distributed Tracing working group technical
requirements. There are a few implementations of this specification available.
We are gathering implementation experience and usage feedback. We recommend the
wide deployment and use of this recommendation.</p><p> This document was published by the <a href="https://www.w3.org/2018/distributed-tracing/">Distributed Tracing Working Group</a> as a Candidate Recommendation. This document is intended to become a <abbr>W3C</abbr> Recommendation. </p><p> <a href="https://github.com/w3c/trace-context/issues/">GitHub Issues</a> are preferred for discussion of this specification. Alternatively, you can send comments to our mailing list. Please send them to <a href="mailto:public-trace-context@w3.org?subject=trace-context">public-trace-context@w3.org</a> (<a href="https://lists.w3.org/Archives/Public/public-trace-context/">archives</a>) with <code>trace-context</code> at the start of your email&apos;s subject . </p><p> <abbr>W3C</abbr> publishes a Candidate Recommendation to indicate that the document is believed to be stable and to encourage implementation by the developer community. This Candidate Recommendation is expected to advance to Proposed Recommendation no earlier than 08 September 2019. </p><p> Please see the Working Group&apos;s <a href="https://github.com/w3c/trace-context/#reference-implementations">implementation report</a>. </p><p> Publication as a Candidate Recommendation does not imply endorsement by the <abbr>W3C</abbr> Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress. </p><p> This document was produced by a group operating under the <a href="https://www.w3.org/Consortium/Patent-Policy/"><abbr>W3C</abbr> Patent Policy</a>. <abbr>W3C</abbr> maintains a <a href="https://www.w3.org/2004/01/pp-impl/108594/status">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains <a href="https://www.w3.org/Consortium/Patent-Policy/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href="https://www.w3.org/Consortium/Patent-Policy/#sec-Disclosure">section 6 of the <abbr>W3C</abbr> Patent Policy</a>. </p><p> This document is governed by the <a id="w3c_process_revision" href="https://www.w3.org/2019/Process-20190301/">1 March 2019 <abbr>W3C</abbr> Process Document</a>. </p></section><nav id="toc"></nav><section id="conformance"><p> As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative. </p><p> The key words <em class="rfc2119">MAY</em>, <em class="rfc2119">MUST</em>, <em class="rfc2119">MUST NOT</em>, <em class="rfc2119">SHOULD</em>, and <em class="rfc2119">SHOULD NOT</em> are to be interpreted as described in [<cite><a class="bibref" href="#bib-rfc2119">RFC2119</a></cite>]. </p></section><section id="overview"><section id="problem-statement"><p>Distributed tracing is a methodology implemented by tracing tools to follow,
analyze and debug a transaction across multiple software components. Typically,
a <a href="#dfn-distributed-traces" class="internalDFN">distributed trace</a> traverses more than one component which requires it
to be uniquely identifiable across all participating systems. Trace context
propagation passes along this unique identification.</p><p>Today, trace context propagation is implemented individually by each tracing
vendor. In multi-vendor environments, this causes interoperability problems,
like:</p><ul>
<li>Traces that are collected by different tracing vendors cannot be correlated as
there is no shared unique identifier.</li>
<li>Traces that cross boundaries between different tracing vendors can not be
propagated as there is no uniformly agreed set of identification that is
forwarded.</li>
<li>Vendor specific metadata might be dropped by intermediaries.</li>
<li>Cloud platform vendors, intermediaries and service providers, cannot guarantee
to support trace context propagation as there is no standard to follow.</li>
</ul><p>In the past, these problems did not have a significant impact as most
applications were monitored by a single tracing vendor and stayed within the
boundaries of a single platform provider. Today, an increasing number of
applications are highly distributed and leverage multiple middleware services
and cloud platforms.</p><p>This transformation of modern applications calls for a distributed tracing
context propagation standard.</p></section><section id="solution"><p>The trace context specification defines a universally agreed-upon format for the
exchange of trace context propagation data - referred to as <em>trace context</em>.
Trace context solves the problems described above by</p><ul>
<li>providing an unique identifier for individual traces and requests, allowing
trace data of multiple providers to be linked together.</li>
<li>providing an agreed-upon mechanism to forward vendor-specific trace data and
avoid broken traces when multiple trace tools participate in a single
transaction.</li>
<li>providing an industry standard that intermediaries, platforms, and hardware
providers can support.</li>
</ul><p>A unified approach for propagating trace data improves visibility into the
behavior of distributed applications, facilitating problem and performance
analysis. The interoperability provided by trace-context is a prerequisite to
manage modern micro-service based applications.</p></section><section id="design-overview"><p>Trace context is split into two individual propagation fields supporting
interoperability and vendor-specific extensibility:</p><ul>
<li><code>traceparent</code> describes the position of the incoming request in its trace
graph in a portable, fixed-length format. Its design focuses on fast parsing.
Every tracing tool <em class="rfc2119">MUST</em> properly set <code>tracestate</code> even when it only relies on
vendor-specific information in <code>tracestate</code></li>
<li><code>tracestate</code> extends <code>traceparent</code> with vendor-specific data represented by a
set of name/value pairs. Storing information in <code>tracestate</code> is optional.</li>
</ul><p>Tracing tools can provide two levels of compliant behavior interacting with
trace context:</p><ul>
<li>At a minimum they <em class="rfc2119">MUST</em> propagate the <code>traceparent</code> and <code>tracestate</code> headers
and guarantee traces are not broken. this behavior is also referred to as
forwarding a trace.</li>
<li>In addition they CAN also choose to participate in a trace by modifying the
<code>traceparent</code> header and relevant parts of the <code>tracestate</code> header containing
their proprietary information. This is also referred to as participating in a
trace.</li>
</ul><p>A tracing tool can choose to change this behavior for each individual request to
a component it is monitoring.</p></section></section><section id="trace-context-http-headers-format"><p>This section describes the binding of the distributed trace context to
<code>traceparent</code> and <code>tracestate</code> http headers.</p><section id="traceparent-field"><p>Field <code>traceparent</code> identifies the request in a tracing system.</p><section id="field-value"><p>This section uses the Augmented Backus-Naur Form (ABNF) notation of
[<cite><a class="bibref" href="#bib-rfc5234">RFC5234</a></cite>], including the DIGIT rule from that document. <code>DIGIT</code> rule defines
a single number character <code>0</code>-<code>9</code>.</p><pre><code class="language-abnf hljs">HEXDIGLC = DIGIT / &quot;a&quot; / &quot;b&quot; / &quot;c&quot; / &quot;d&quot; / &quot;e&quot; / &quot;f&quot; ; lower case hex character
value           = version &quot;-&quot; version-format
version         = 2HEXDIGLC   ; this document assumes version 00. Version 255 is forbidden</code></pre><p>The value is US-ASCII encoded (which is UTF-8 compliant). Character <code>-</code> is used
as a delimiter between fields.</p><p>Version (<code>version</code>) is a 1 byte representing an 8-bit unsigned integer. Version
<code>255</code> is invalid. Current specification assumes the <code>version</code> is set to <code>00</code>.</p><p>The following <code>version-format</code> definition is used for version <code>00</code>.</p><pre><code class="language-abnf hljs">version-format   = trace-id &quot;-&quot; parent-id &quot;-&quot; trace-flags
trace-id         = 32HEXDIGLC  ; 16 bytes array identifier. All zeroes forbidden
parent-id        = 16HEXDIGLC  ; 8 bytes array identifier. All zeroes forbidden
trace-flags      = 2HEXDIGLC   ; 8 bit flags. Currently only one bit is used. See below for details</code></pre><section id="trace-id"><p>Is the ID of the whole trace forest. It is represented as a 16-bytes array, for
example, <code>4bf92f3577b34da6a3ce929d0e0e4736</code>. All bytes zero
(<code>00000000000000000000000000000000</code>) is considered an invalid value.</p><p><code>Trace-id</code> is used to uniquely identify a <a href="#dfn-distributed-traces" class="internalDFN">distributed trace</a>. So
implementation should generate globally unique values. Many algorithms of unique
identification generation are based on some constant part - time or host based
and a random value. There are systems that make random sampling decisions based
on the value of <code>trace-id</code>. So to increase interoperability it is recommended to
keep the random part on the right side of <code>trace-id</code> value.</p><p>When a system operates with a shorter <code>trace-id</code> - it is recommended to fill-in
the extra bytes with random values rather than zeroes. Let&apos;s say the system
works with a 8-byte <code>trace-id</code> like <code>3ce929d0e0e4736</code>. Instead of setting
<code>trace-id</code> value to <code>0000000000000003ce929d0e0e4736</code> it is recommended to
generate a value like <code>4bf92f3577b34da6a3ce929d0e0e4736</code> where
<code>4bf92f3577b34da6a</code> is a random value or a function of time &amp; host value. Note,
even though a system may operate with a shorter <code>trace-id</code> for <a href="#dfn-distributed-traces" class="internalDFN">distributed
trace</a> reporting - full <code>trace-id</code> should be propagated to conform to the
specification.</p><p>Implementations HAVE TO ignore the <code>traceparent</code> when the <code>trace-id</code> is invalid.
For instance, if it contains non-allowed characters.</p></section><section id="parent-id"><p>Is the ID of this call as known by the caller. It is also known as <code>span-id</code> as
a few telemetry systems call the execution of a client call a span. It is
represented as an 8-byte array, for example, <code>00f067aa0ba902b7</code>. All bytes zero
(<code>0000000000000000</code>) is considered an invalid value.</p><p>Implementations HAVE TO ignore the <code>traceparent</code> when the <code>parent-id</code> is
invalid. For instance, if it contains non lower case hex characters.</p></section></section><section id="trace-flags"><p>An <cite><a href="https://en.wikipedia.org/wiki/Bit_field">8-bit field</a></cite> that controls tracing flags such as
sampling, trace level etc. These flags are recommendations given by the caller
rather than strict rules to follow for three reasons:</p><ol>
<li>Trust and abuse</li>
<li>Bug in caller</li>
<li>Different load between caller service and callee service might force callee
to down sample.</li>
</ol><p>You can find more in security section of this specification.</p><p>Like other fields, <code>trace-flags</code> is hex-encoded. For example, all <code>8</code> flags set
would be <code>ff</code> and no flags set would be <code>00</code>.</p><p>As this is a bit field, you cannot interpret flags by decoding the hex value and
looking at the resulting number. For example, a flag <code>00000001</code> could be encoded
as <code>01</code> in hex, or <code>09</code> in hex if present with the flag <code>00001000</code>. A common
mistake in bit fields is forgetting to mask when interpreting flags.</p><p>Here is an example of properly handing trace flags:</p><pre><code class="language-java hljs">static final byte FLAG_RECORDED = 1; // 00000001
...
boolean recorded = (traceFlags &amp; FLAG_RECORDED) == FLAG_RECORDED</code></pre><p>Current version of specification only supports a single flag called <code>recorded</code>.</p><section id="recorded-flag-00000001"><p>When set, the least significant bit documents that the caller may have recorded
trace data. A caller who does not record trace data out-of-band leaves this flag
unset.</p><p>Many distributed tracing scenarios may be broken when only a subset of calls
participated in a <a href="#dfn-distributed-traces" class="internalDFN">distributed trace</a> were recorded. At certain load
recording information about every incoming and outgoing request becomes
prohibitively expensive. Making a random or component-specific decision for data
collection will lead to fragmented data in every <a href="#dfn-distributed-traces" class="internalDFN">distributed trace</a>. Thus
it is typical for tracing vendors and platforms to pass recording decision for
given distributed trace or information needed to make this decision.</p><p>There is no consensus on what is the best algorithm to make a recording
decision. Various techniques include: probability sampling (sample 1 out of 100
<a href="#dfn-distributed-traces" class="internalDFN">distributed traces</a> by flipping a coin), delayed decision (make collection
decision based on duration or a result of a call), deferred sampling (let callee
decide whether information about this request need to be collected). There are
variations and customizations of every technique which can be tracing vendor
specific or application defined.</p><p>Field <code>tracestate</code> is designed to handle the variety of techniques for making
recording decision specific (along any other specific information) for a given
tracing system or a platform. Flag <code>recorded</code> is introduced for better
interoperability between vendors. It allows to communicate recording decision
and enable better experience for the customer.</p><p>For example, when SaaS services participate in <a href="#dfn-distributed-traces" class="internalDFN">distributed trace</a> - this
service has no knowledge of tracing system used by its caller. But this service
may produce records of incoming requests for monitoring or troubleshooting
purposes. Flag <code>recorded</code> can be used to ensure that information about requests
that were marked for recording by caller will also be recorded by SaaS service.
So caller can troubleshoot the behavior of every recorded request.</p><p>Flag <code>recorded</code> has no restriction on its mutations except that it can only be
mutated when <code>parent-id</code> was updated. See section &quot;Mutating the traceparent
field&quot;. However there are set of suggestions that will increase vendors
interoperability.</p><ol>
<li>If component made definitive recording decision - this decision <em class="rfc2119">SHOULD</em> be
reflected in <code>recorded</code> flag.</li>
<li>If component needs to make a recording decision - it <em class="rfc2119">SHOULD</em> respect
<code>recorded</code> flag value. Security considerations should be applied to protect
from abusive or malicious use of this flag - see security section.</li>
<li>If component deferred or delayed decision and only a subset of telemetry will
be recorded - flag <code>recorded</code> should be propagated unchanged. And set to <code>0</code>
as a default option when trace is initiated by this component. There are two
additional options:<ol>
<li>Component that makes deferred or delayed recording decision may
communicate priority of recording by setting <code>recorded</code> flag to <code>1</code> for a
subset of requests.</li>
<li>Component may also fall back to probability sampling to set flag
<code>recorded</code> to <code>1</code> for the subset of requests.</li>
</ol>
</li>
</ol></section><section id="other-flags"><p>The behavior of other flags, such as (<code>00000100</code>) is not defined and reserved
for future use. Implementations <em class="rfc2119">MUST</em> set those to zero.</p></section></section><section id="versioning-of-traceparent"><p>This specification is opinionated about future version of the trace context.
Current version of this specification assumes that the future versions of
<code>traceparent</code> header will be additive to the current one.</p><p>Implementations should follow the following rules when parsing headers with an
unexpected format:</p><ol>
<li>Pass thru services should not analyze version. Pass thru service needs to
expect that headers may have bigger size limits in the future and only
disallow prohibitively large headers.</li>
<li>When version prefix cannot be parsed (it&apos;s not 2 hex characters followed by
dash (<code>-</code>)), implementation should restart the trace.</li>
<li>If higher version is detected - implementation <em class="rfc2119">SHOULD</em> try to parse it.<ol>
<li>If the size of header is shorter than 55 characters -implementation
should not parse header and should restart the trace.</li>
<li>Try parse <code>trace-id</code>: from the first dash - next 32 characters.
Implementations <em class="rfc2119">MUST</em> check 32 characters to be hex. Make sure they are
followed by dash.</li>
<li>Try parse <code>parent-id</code>: from the second dash at 35th position - 16
characters. Implementations <em class="rfc2119">MUST</em> check 16 characters to be hex. Make sure
this is followed by a dash.</li>
<li>Try parse sampling bit of <code>flags</code>: 2 characters from third dash.
Following with either end of string or a dash. If all three values were
parsed successfully - implementation should use them. Implementations
<em class="rfc2119">MUST NOT</em> parse or assume anything about any fields unknown for this
version. Implementations <em class="rfc2119">MUST</em> use these fields to construct the new
<code>traceparent</code> field according to the highest version of the specification
known to the implementation (in this specification it is <code>00</code>).</li>
</ol>
</li>
</ol></section></section><section id="tracestate-field"><p>The <code>tracestate</code> HTTP header field conveys information about request position in
multiple distributed tracing graphs. This header is a companion header for the
<code>traceparent</code>. If library or platform failed to parse <code>traceparent</code> - it <em class="rfc2119">MUST NOT</em> attempt to parse the <code>tracestate</code>. Note, that opposite it not true - failure
to parse <code>tracestate</code> <em class="rfc2119">MUST NOT</em> affect the parsing of <code>traceparent</code>.</p><section id="versioning-of-tracestate"><p>Version of <code>tracestate</code> is defined by the version prefix of <code>traceparent</code>
header. Implementations needs to attempt parsing of <code>tracestate</code> if a higher
version is detected to the best of its ability. It is the implementor&apos;s decision
whether to use partially-parsed <code>tracestate</code> key-value pairs or not.</p></section></section><section id="mutating-the-traceparent-field"><p>Library or platform receiving <code>traceparent</code> request header <em class="rfc2119">MUST</em> send it to
outgoing requests. It <em class="rfc2119">MAY</em> mutate the value of this header before passing to
outgoing requests.</p><p>If the value of the <code>traceparent</code> field wasn&apos;t changed before propagation -
<code>tracestate</code> <em class="rfc2119">MUST NOT</em> be modified as well. Unmodified headers propagation is
typically implemented in pass-thru services like proxies. This behavior may also
be implemented in a service which currently does not collect distributed tracing
information.</p><p>Here is the list of allowed mutations:</p><ol>
<li><strong>Update <code>parent-id</code></strong>. The value of property <code>parent-id</code> can be set to the
new value representing the ID of the current operation. This is the most
typical mutation and should be considered a default.</li>
<li><strong>Indicate recorded state</strong>. The value of <code>recorded</code> flag of <code>trace-flags</code>
may be set to <code>1</code> if it had value <code>0</code> before or vice versa. <code>parent-id</code> <em class="rfc2119">MUST</em>
be set to the new value with the <code>recorded</code> flag update. See details of
<code>recorded</code> flag for more information on how this flag is recommended to be
used.</li>
<li><strong>Update <code>recorded</code></strong>. The value of <code>recorded</code> reflects the caller&apos;s
recording behavior: either the trace data were dropped or may have been
recorded out-of-band. This mutation gives the downstream tracer information
about the likelihood its parent&apos;s information was recorded.</li>
<li><strong>Restarting trace</strong>. All properties - <code>trace-id</code>, <code>parent-id</code>, <code>trace-flags</code>
are regenerated. This mutation is used in the services defined as a front
gate into secure networks and eliminates a potential denial of service attack
surface. Implementations <em class="rfc2119">SHOULD</em> clean up <code>tracestate</code> collection on
<code>traceparent</code> restart. There are rare cases when the original <code>tracestate</code>
entries must be preserved after restart. Typically, when <code>trace-id</code> will be
reverted back at some point of the trace flow - for instance, when it leaves
the secure network. However, it <em class="rfc2119">SHOULD</em> be an explicit decision, not a default
behavior. As trace vendors may rely on <code>trace-id</code> matching <code>tracestate</code>
values.</li>
</ol><p>Libraries and platforms <em class="rfc2119">MUST NOT</em> make any other mutations to the <code>traceparent</code>
header.</p></section><section id="mutating-the-tracestate-field"><p>Library or platform receiving <code>tracestate</code> request header <em class="rfc2119">MUST</em> send it to
outgoing requests. It <em class="rfc2119">MAY</em> mutate the value of this header before passing to
outgoing requests. The main concept of <code>tracestate</code> mutations is that the order
of unmodified key-value pairs <em class="rfc2119">MUST</em> be preserved. Modified keys <em class="rfc2119">MUST</em> be moved to
the beginning of the list.</p><p>Here is the list of allowed mutations:</p><ol>
<li><strong>Update key value</strong>. The value of any key can be updated. Modified keys <em class="rfc2119">MUST</em>
be moved to the beginning of the list. This is the most common mutation
resuming the trace.</li>
<li><strong>Add new key-value pair</strong>. New key-value pair should be added into the
beginning of the list.</li>
<li><strong>Delete the key-value pair</strong>. Any key-value pair <em class="rfc2119">MAY</em> be deleted. It is
highly discouraged to delete keys that weren&apos;t generated by the same tracing
system or platform. Deletion of unknown key-value pair will break correlation
in other systems. This mutation enables two scenarios. The first is proxies
can block certain <code>tracestate</code> keys for privacy and security concerns. The
second scenario is a truncation of long <code>tracestate</code>&apos;s.</li>
</ol></section></section><section id="other-communication-protocols"><p>While trace context is defined for HTTP the authors acknowledge it is also
relevant for other communication protocols. Extensions of this specification as
well as specifications produced by external organizations define the format of
trace context serialization and deserialization for other protocols. Note, that
these extensions may be at a different maturity level than this specification.</p><p>Please refer to the [<cite><a class="bibref" href="#bib-trace-context-protocols-registry">trace-context-protocols-registry</a></cite>] for the details of trace context
implementation for other protocols.</p></section><section id="privacy-considerations"><p>Requirements to propagate headers to downstream services as well as storing
values of these headers opens up potential privacy concerns. Trace vendors <em class="rfc2119">MUST NOT</em> use <code>traceparent</code> and <code>tracestate</code> fields for any personally identifiable or
otherwise sensitive information. The only purpose of these fields is to enable
trace correlation.</p><p>Trace vendors <em class="rfc2119">MUST</em> assess the risk of header abuse. This section provides some
considerations and initial assessment of the risk associated with storing and
propagating these headers. Tracing systems or platforms may choose to inspect
and remove sensitive information from the fields before allowing the tracing
system to execute code that potentially can propagate or store these fields. All
mutations should, however, conform to the list of mutations defined in this
specification.</p><section id="privacy-of-traceparent-field"><p>The <code>traceparent</code> field is comprised of randomly-generated numbers. If a random
number generator leverages any user identifiable information like IP address as
seed state - this information may be exposed. Random number generators <em class="rfc2119">MUST NOT</em>
rely on any information that can potentially be user identifiable.</p><p>Another privacy risk of the <code>traceparent</code> field is an ability to correlate calls
made as part of a single transaction. A downstream service may track and
correlate two or more calls made in a single transaction and make assumptions
about the identity of the caller of one call based on information from another
call.</p><p>Note, both of the mentioned privacy concerns of the <code>traceparent</code> field are
theoretical rather than practical. Some services initiating or receiving a call
<em class="rfc2119">MAY</em> choose to restart a <code>traceparent</code> field to eliminate those risks completely.
It is recommended to find a way to minimize the number of <a href="#dfn-distributed-traces" class="internalDFN">distributed
trace</a> restarts to promote interoperability of tracing vendors. Instead,
different techniques may be used. For example, services may define trust
boundaries of upstream and downstream connections and the level of exposure any
calls may bring. For instance, only restart <code>traceparent</code> for authentication
calls from or to external services.</p><p>Services may also define an algorithm and audit mechanism to validate randomness
of incoming or outgoing random numbers in the <code>traceparent</code> field. Note, this
algorithm will be services-specific and not a part of this specification. One
example could be a temporal algorithm where a reversible hash function is
applied to the current clock time. The receiver can validate that the time is
within agreed upon boundaries, meaning the random number was generated with the
required algorithm and in fact doesn&apos;t contain any personal identifiable
information.</p></section><section id="privacy-of-tracestate-field"><p>The <code>tracestate</code> field may contain any opaque value in any of the keys. The main
purpose of this header is to provide additional vendor-specific
trace-identification information across different distributed tracing systems.</p><p>Tracing systems <em class="rfc2119">MUST NOT</em> include any personally identifiable information in the
<code>tracestate</code> header.</p><p>Platforms and tracing systems extremely sensitive to personal information
exposure <em class="rfc2119">MAY</em> implement selective removal of values corresponding to the unknown
keys. This mutation of the <code>tracestate</code> field is not forbidden, but highly
discouraged. As it defeats the purpose of this field for allowing multiple
tracing systems to collaborate.</p></section><section id="other-risks"><p>In implementations where <code>traceparent</code> and <code>tracestate</code> headers are included in
responses, these values may inadvertently be passed to cross-origin callers.
Implementations should ensure that they only include these response headers when
responding to systems that participated in the trace.</p></section></section><section id="security-considerations"><p>There are two types of potential security risks associated with this
specification: information exposure and denial of service attacks against the
tracing system.</p><p>Services and platforms relying on <code>traceparent</code> and <code>tracestate</code> headers should
also follow all the best practices of parsing potentially malicious headers.
Including checking for header length and content of header values. These
practices help to avoid buffer overflow and html injection attacks.</p><section id="information-exposure"><p>As mentioned in the privacy section, information in <code>traceparent</code> and
<code>tracestate</code> headers may carry information that can be considered sensitive. For
example, <code>traceparent</code> may allow one call to be correlated to the data sent with
another call. <code>tracestate</code> may imply the version of monitoring software used by
the caller. This information could potentially be used to create a larger
attack.</p><p>Application owners should either ensure that no proprietary or confidential
information is stored in the <code>tracestate</code>, or they should ensure that
<code>tracestate</code> isn&apos;t present in requests to external systems.</p></section><section id="denial-of-service"><p>When distributed tracing is enabled on a service with a public API and naively
continues any trace with the <code>recorded</code> flag set, a malicious attacker could
overwhelm an application with tracing overhead, forge <code>trace-id</code> collisions that
make monitoring data unusable, or run up your tracing bill with your SaaS
tracing vendor.</p><p>Tracing vendors and platforms should account for these situations and make sure
that checks and balances are in place to protect denial of monitoring by
malicious or badly authored callers.</p><p>One examples of such protection may be different tracing behavior for
authenticated and unauthenticated requests. Various rate limiters for data
recording can also be implemented.</p></section><section id="other-risks-0"><p>Application owners need to make sure to test all code paths leading to the
sending of <code>traceparent</code> and <code>tracestate</code> headers. For example, in single page
browser applications it is typical to make cross-origin calls. If one of these
code path leads to the sending of <code>traceparent</code> and <code>tracestate</code> headers -
cross-origin calls restricted via <a href="https://fetch.spec.whatwg.org/#http-access-control-request-headers"><code>Access-Control-Allow-Headers</code></a>
[<cite><a class="bibref" href="#bib-fetch">FETCH</a></cite>], it may fail.</p></section></section><section class="appendix" id="acknowledgments"><p>Thanks to Adrian Cole, Christoph Neum&#xFC;ller, Daniel Khan, Erika Arnold, Fabian
Lange, Matthew Wear, Reiley Yang, Ted Young, Tyler Benson, Victor Soares for
their contributions to this work.</p></section><section class="informative" id="glossary"><p><em>This section is non-normative.</em></p><dl>
<dt><dfn id="dfn-distributed-traces">Distributed trace</dfn></dt>
<dd>
A distributed trace is a set of events, triggered as a result
of a single logical operation, consolidated across various
components of an application. A distributed trace contains
events that cross process, network and security boundaries.
A distributed trace may be initiated when someone presses a
button to start an action on a website - in this example, the
trace will represent calls made between the downstream services
that handled the chain of requests initiated by this button
being pressed.
</dd>
</dl></section><section id="references" class="appendix"> <section id="normative-references"> <dl class="bibliography"> <dt id="bib-bit-field">[BIT-FIELD]</dt><dd><a href="https://en.wikipedia.org/wiki/Bit_field"><cite>8-bit field</cite></a>. Wikipedia. URL: <a href="https://en.wikipedia.org/wiki/Bit_field">https://en.wikipedia.org/wiki/Bit_field</a></dd><dt id="bib-fetch">[FETCH]</dt><dd><a href="https://fetch.spec.whatwg.org/"><cite>Fetch Standard</cite></a>. Anne van Kesteren. WHATWG. Living Standard. URL: <a href="https://fetch.spec.whatwg.org/">https://fetch.spec.whatwg.org/</a></dd><dt id="bib-rfc0020">[RFC0020]</dt><dd><a href="https://tools.ietf.org/html/rfc20"><cite>ASCII format for network interchange</cite></a>. V.G. Cerf. IETF. October 1969. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc20">https://tools.ietf.org/html/rfc20</a></dd><dt id="bib-rfc2119">[RFC2119]</dt><dd><a href="https://tools.ietf.org/html/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. S. Bradner. IETF. March 1997. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a></dd><dt id="bib-rfc5234">[RFC5234]</dt><dd><a href="https://tools.ietf.org/html/rfc5234"><cite>Augmented BNF for Syntax Specifications: ABNF</cite></a>. D. Crocker, Ed.; P. Overell. IETF. January 2008. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc5234">https://tools.ietf.org/html/rfc5234</a></dd><dt id="bib-rfc7230">[RFC7230]</dt><dd><a href="https://tools.ietf.org/html/rfc7230"><cite>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</cite></a>. R. Fielding, Ed.; J. Reschke, Ed.. IETF. June 2014. Proposed Standard. URL: <a href="https://tools.ietf.org/html/rfc7230">https://tools.ietf.org/html/rfc7230</a></dd><dt id="bib-trace-context-protocols-registry">[trace-context-protocols-registry]</dt><dd><a href="https://www.w3.org/TR/trace-context-protocols-registry/"><cite>Trace Context Protocols Registry</cite></a>. Sergey Kanzhelev; Philippe Le H&#xE9;garet. W3C. 14 March 2019. W3C Note. URL: <a href="https://www.w3.org/TR/trace-context-protocols-registry/">https://www.w3.org/TR/trace-context-protocols-registry/</a></dd> </dl></section></section><p id="back-to-top"><a href="#toc"><abbr>&#x2191;</abbr></a></p></body>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>