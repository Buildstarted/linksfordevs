<!DOCTYPE html>
<html lang="en">
<head>
    <title>
The Elusive Frame Timing - Alen Ladavac -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>The Elusive Frame Timing - Alen Ladavac</h1><div><div class="ac ae af ag ah cz aj ak"><p id="02f3" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">…on the third frame the tree on the “slower” video is significantly <strong class="gt ks">ahead</strong> of its counterpart on the correct video (circled in red). You can also notice that this frame apparently took a longer time (circled in yellow).</p><p id="d6e7" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">Wait, wait, wait… if a video is “slower”, and the frame “took more time” how can it be ahead?</p><p id="d16a" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">Well, to explain this, you have to understand how games, and other 3D interactive applications are actually doing their animation and rendering nowadays. (Experienced developers will excuse me if I’m boring them with things they know here, but I have to make sure all the gamers that might be interested in this can follow the text.)</p><h2 id="6321" class="gd ge dc bk bj gf gg gh gi gj gk gl gm gn go gp gq">A brief history of frame timing</h2><p id="a82a" class="gr gs dc bk gt b dw gu dy gv gw gx gy gz ha hb hc cu">A long time ago, in a galaxy far, far away… When developers made first video games, they would normally design for the exact frame rate that the display runs on. In the NTSC regions which run TVs at 60 Hz, it would mean 60 fps, in PAL/SECAM regions which run TVs at 50 Hz, it would mean 50 fps. They would never even exercise a thought of perhaps “dropping a frame”.</p><p id="4e95" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">Most games were very streamlined and simplified concepts, running on fixed hardware — usually an arcade console, or a well known “<a href="https://en.wikipedia.org/wiki/Home_computer" class="at cg ir is it iu" target="_blank" rel="noopener nofollow">home micro-computer</a>”, like <em class="ja">ZX Spectrum</em>, <em class="ja">C64</em>, <em class="ja">Atari ST</em>, <em class="ja">Amstrad CPC 464</em>, <em class="ja">Amiga</em>, etc. Basically, one designed, implemented and tested for a particular machine and particular frame rate, and was 100% sure that it would never drop a frame anywhere.</p><p id="494f" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">Velocities of objects were also stored in “frame” units. So you wouldn’t say how many <em class="ja">pixels per second </em>a character would move, but how many <em class="ja">pixels per frame</em>. In <a href="https://en.wikipedia.org/wiki/Sonic_the_Hedgehog_(1991_video_game)" class="at cg ir is it iu" target="_blank" rel="noopener nofollow">Sonic The Hedgehog</a> for Sega Genesis, e.g. rolling speed is known to be exactly <a href="http://tasvideos.org/GameResources/Genesis/SonicTheHedgehog.html" class="at cg ir is it iu" target="_blank" rel="noopener nofollow">16 pixels per frame</a>. Many games even had separate versions for PAL and NTSC regions where animations were hand-drawn specifically for 50 fps and 60 fps respectively. Basically, running at any other frame rate was not an option.</p><p id="fa98" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">As games started running on more varied machines — notably PCs with expandable and upgradeable hardware — one couldn’t be sure which frame rate the game will run on anymore. Compounding that fact was the fact that games became more complicated and unpredictable — most notably 3D games can have large variances in scene complexities, sometimes even player-driven variances. E.g. everyone loves shooting at a stack of fuel barrels — causing a huge explosion, nice fireworks… and an inevitable frame drop. But we don’t mind the frame drop there — because it’s so much fun.</p><p id="d0cc" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">So it can be hard to predict how long it will take to simulate and render one frame. (Note that on consoles today, we still have fixed hardware, but the games themselves are often quite unpredictable and complex anyway.)</p><p id="c74c" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">If you cannot be sure which frame rate the game will be running at, you have to measure the current frame rate and continually adapt the game’s physics and animation speed. If one frame is taking 1/60th of a second (16.67 ms), and your character runs 10 m/s, then it moves by 1/6th of a meter in each frame. But if the frame is not 1/60th anymore, rather it suddenly started taking 1/30th of a second (33.33ms) — you have to start moving the character by 1/3rd of a meter (two times “faster”) per frame, so that it continues moving at the same apparent speed on screen.</p><p id="0952" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">How does a game do this? Basically —it measures time at the start of one frame, then on the start of the next one and calculates the difference. It’s quite a simple method, but it works very well. Sorry, it <em class="ja">used to work </em>very well. Back in the ’90s (remember those “35 fps speeds for serious competitive netplay” from the beginning), people were more than happy with this method. But at that time, a <em class="ja">graphics card</em> (remember, they weren’t even called <em class="ja">GPUs</em> then) was a very “thin” piece of hardware, and the main CPU had direct control over when things get to the screen. If you didn’t have a 3D accelerator, the CPU was even drawing the things directly. So it knew exactly when they are ending up on screen.</p><h2 id="1978" class="gd ge dc bk bj gf gg gh gi gj gk gl gm gn go gp gq">What is actually going on today</h2><p id="1186" class="gr gs dc bk gt b dw gu dy gv gw gx gy gz ha hb hc cu">Over time, as we started having more complex GPUs, those GPUs became more and more “<a href="https://en.wikipedia.org/wiki/Asynchronous_system" class="at cg ir is it iu" target="_blank" rel="noopener nofollow">asynchronous</a>”. That means that when the CPU gives a command to the GPU to draw something on the screen, the GPU just stores that command in a buffer, so that the CPU can go on with its own business while the GPU is rendering. That ultimately results in the situation where the CPU tells the GPU that “this is the end of the frame” and the GPU just stores this as a nice piece of data. But it doesn’t really treat it as something of much urgency. How could it — when it is still processing some of the previously issued commands. It will show the frame on the screen when it’s done with all the work it’s been given before.</p><p id="8062" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">So, when a game is trying to calculate the timing by subtracting timestamps at the start of two successive frames, the relevance of that is, to be blunt… quite dubious. Let’s get back to our example from those short videos. We had those frames with camera panning across some trees:</p><figure class="he hf hg hh hi hj cl cm paragraph-image"><figcaption class="bo ex im in io cn cl cm ip iq bj dv">Six consecutive frames from the comparison video, with precise timing. Top is correct, bottom is <em class="kr">heartbeat stutter.</em></figcaption></figure><p id="8a5a" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">Now recall this thing with timing and movements. In the first two frames, the frame timing was 16.67ms (which is 1/60th of a second), and the camera moves by the same amount in the top and bottom cases, so the trees are in sync. In the third frame, (in the bottom, stuttering case) the game saw that the frame time is 24.8ms, (which is more than 1/60th of a second), so it thinks that the frame rate has dropped and rushes to move the camera a bit more… only to find on the next, fourth frame the timing is only 10.7ms, so the camera moves a bit less there, and the trees are now more or less in sync again. (They don’t completely recover until about two frames later when everything reconsolidates finally.)</p><p id="d995" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">What happens here is that the game measures what it <em class="ja">thinks </em>is start of each frame, and those frame times sometimes oscillate due to various factors, especially on a busy multitasking system like a PC. So at some points, the game <em class="ja">thinks</em> it didn’t make 60 fps, so it generates animation frames slated for a slower frame rate at <em class="ja">some of the points in time</em>. But due to the asynchronous nature of GPU operation, the GPU actually <em class="ja">does </em>make it in time for 60 fps <em class="ja">on every single frame in this sequence</em>.</p><blockquote class="jz"><p class="dd b kj kk bo">This is what we see as a stutter — animation generated for a varying frame rate (heartbeat) being displayed at actual correct fixed frame rate.</p></blockquote><p id="c0dc" class="gr gs dc bk gt b dw ku dy kv gw kw gy kx ha ky hc cu">So, basically, there’s no problem whatsoever — everything <em class="ja">is </em>running smoothly, it’s just that the game doesn’t know it.</p><p id="a58a" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">This brings us to the point from the beginning of the article. When we finally figured out that this is what caused the problem (actually, it’s an illusion of a problem — there’s no problem in fact, right?), here’s what we did for a test:</p><figure class="he hf hg hh hi hj"><figcaption class="bo ex im in io cn cl cm ip iq bj dv">First we observe the “heartbeat” and then we use a little trick to make it go away.</figcaption></figure><p id="66b8" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">In the first part of the video above, you can see the <em class="ja">heartbeat </em>issue from the beginning. Then we change a “magic” option and after that — everything becomes perfectly smooth!</p><p id="0c35" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">What’s the magic option? In <em class="ja">Serious Engine</em>, we call this <code class="ih jm jn jo jp b">sim_fSyncRate=60</code> . In layman’s terms it basically means: “completely ignore all these timing shenanigans and pretend that we are always measuring steady 60 fps”. And it makes everything run smoothly — only because <strong class="gt ks">it was always running smoothly to begin with!</strong> The only reason why it ever looked stuttering is because the timing used for animation was wrong.</p><p id="89e4" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">So that’s it? We just do that and everything is great?</p><h2 id="f75b" class="gd ge dc bk bj gf gg gh gi gj gk gl gm gn go gp gq">Is the solution that simple?</h2><p id="f166" class="gr gs dc bk gt b dw gu dy gv gw gx gy gz ha hb hc cu">Unfortunately… nope. That was only for a developer test. If we would stop measuring frame rate in real-world situations and just assume it is always 60, then when it <em class="ja">does </em>drop below 60 — and on a PC it <strong class="gt ks">will</strong> drop sooner or later for various reasons: OS running something in the background, power-saving or overheating protection down-clocking the GPU/CPU… who knows —then everything will slow down.</p><p id="2ceb" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">So, if we measure frame time, it stutters, if we don’t, everything can slow down at some points. What then?</p><p id="f820" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">The real solution would be to measure not when the frame has started/ended rendering, but when the image was shown on the screen.</p><blockquote class="jz"><p class="dd b kj kk bo">So, how can the game know when a frame’s image is actually shown on screen? You might be surprised to learn that, in the current situation— there’s no way to do it!</p></blockquote><p id="c6bf" class="gr gs dc bk gt b dw ku dy kv gw kw gy kx ha ky hc cu">Shocking, I know. One would expect this would be a basic feature of every graphics API. But it turns out that as things have been changing slowly here and there, everyone basically dropped the ball on this issue. We all forgot about the fine details of what is going on, kept doing basically what we were doing all the time, and the graphics APIs have evolved in all other aspects but this one: There’s no way for the application to know for sure when a frame was <em class="ja">actually </em>displayed on the screen. You can know when it finished rendering. But not when it got displayed.</p><h2 id="0ea0" class="gd ge dc bk bj gf gg gh gi gj gk gl gm gn go gp gq">What now?</h2><p id="f10e" class="gr gs dc bk gt b dw gu dy gv gw gx gy gz ha hb hc cu">Worry not, it’s not all that grim. Many people in the graphics ecosystem are currently busily <a href="https://twitter.com/Plagman2/status/974370471394201603" class="at cg ir is it iu" target="_blank" rel="noopener nofollow">working on</a> implementing support for proper frame timing, under various names for different APIs. <a href="https://en.wikipedia.org/wiki/Vulkan_(API)" class="at cg ir is it iu" target="_blank" rel="noopener nofollow">Vulkan API</a> already has an extension called <code class="ih jm jn jo jp b">VK_GOOGLE_display_timing</code> which was <a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=GDC-Vulkan-Stutter-Frames" class="at cg ir is it iu" target="_blank" rel="noopener nofollow">shown useful</a> in a proof of concept implementation, but it is available only for a limited range of hardware and mostly on Android and Linux.</p><p id="1491" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">Work is now underway to provide such, and better facilities, hopefully in all the major graphics APIs. When? It’s hard to say, because the problem cuts quite deep into various OS subsystems.</p><p id="a635" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">I can promise you, though, that we at Croteam are advocating tirelessly for this problem to be fixed as soon as possible — and everyone in the interactive graphics ecosystem is very understanding and helpful.</p><p id="6b76" class="gr gs dc bk gt b dw iv dy iw gw ix gy iy ha iz hc cu">We are looking forward to having this available to a broader public, and when that happens, we will provide an update for The Talos Principle that implements this feature.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>