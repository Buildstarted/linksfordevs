<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Buying and Selling stocks with maximum profit - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Buying and Selling stocks with maximum profit - linksfor.dev(s)"/>
    <meta property="og:description" content="Summary This posting continues the discussion about algorithmic thinking solving a well know problem that is known as&#xA0; Best Time to Buy and Sell Stock. The solution to this problem is hard and I do&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://codingismycraft.com/index.php/2020/07/05/buying-and-selling-stocks-with-maximum-profit/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Buying and Selling stocks with maximum profit</title>
<div class="readable">
        <h1>Buying and Selling stocks with maximum profit</h1>
            <div>Reading time: 11-14 minutes</div>
        <div>Posted here: 07 Jul 2020</div>
        <p><a href="http://codingismycraft.com/index.php/2020/07/05/buying-and-selling-stocks-with-maximum-profit/">http://codingismycraft.com/index.php/2020/07/05/buying-and-selling-stocks-with-maximum-profit/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
<figure>
<img src="http://i2.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-2.gif?resize=514%2C328" alt="" title="bss-2">
</figure>
<h2>Summary</h2>
<p>This posting continues the discussion about algorithmic thinking solving a well know problem that is known as&nbsp; <strong> Best Time to Buy and Sell Stock.</strong></p>
<p>The solution to this problem is hard and I do not believe that it makes a good interview question but it is still a good exercise that might take an intermediate developer a few hours to solve.</p>
<p>To gain the maximum value you should allocate enough time to try to solve it in an efficient way before you read the solution.</p>
<h2>The problem</h2>
<p>We are given a list of integers representing stock prices; we must find the maximum profit that can be made assuming at most two no overlapping BUY – SELL transactions.</p>
<p>For example assuming the following list of prices:</p>
<p>[7, 3, 13, 13, 6, 19, 10, 8, 15, 18]</p>
<p>the maximum profit that can be made is <strong>26 </strong>which is made as follows:</p>
<p>Buy at 3 – Sell at 19,&nbsp; Buy at 8 – Sell at 18</p>
<p>as can be seen in this picture:</p>
<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-1.gif?resize=458%2C309" alt="bss-1" width="458" height="309"></p>
<h2>Initial thoughts</h2>
<p>From the first glance, the problem looks simple; as we will see shortly it is not!</p>
<p>Thinking about the problem we can see that there exist three “types” of solutions:</p>
<ul>
<li>No pair of Buy – Sell that shows profit.</li>
<li>One pair of Buy – Sell that shows the maximum profit.</li>
<li>Two pairs of Buy – Sell that shows the maximum profit.</li>
</ul>
<p>It is trivial to convert this approach to a function that creates all the pairs by 2 and 4 points and return the maximum profit:</p>
<div><div id="highlighter_162114"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p></td><td><div><p><code>import</code> <code>itertools</code></p><p><code>def</code> <code>get_max_profit(prices):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>all_indexes </code><code>=</code> <code>list</code><code>(</code><code>range</code><code>(</code><code>len</code><code>(prices)))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_profit </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>i1, i2 </code><code>in</code> <code>itertools.combinations(all_indexes, </code><code>2</code><code>):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>assert</code> <code>i1 &lt; i2 profit </code><code>=</code> <code>prices[i2] </code><code>-</code> <code>prices[i1] </code><code>if</code> <code>profit &gt; max_profit:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_profit </code><code>=</code> <code>profit</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>i1, i2, i3, i4 </code><code>in</code> <code>itertools.combinations(all_indexes, </code><code>4</code><code>):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>assert</code> <code>i1 &lt; i2 &lt; i3 &lt; i4 profit </code><code>=</code> <code>prices[i2] </code><code>-</code> <code>prices[i1] </code><code>+</code> <code>prices[i4] </code><code>-</code> <code>prices[i3] </code><code>if</code> <code>profit &gt; max_profit:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_profit </code><code>=</code> <code>profit</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>max_profit</code></p><p><code>assert</code> <code>get_max_profit([</code><code>7</code><code>, </code><code>3</code><code>, </code><code>13</code><code>, </code><code>13</code><code>, </code><code>6</code><code>, </code><code>19</code><code>, </code><code>10</code><code>, </code><code>8</code><code>, </code><code>15</code><code>, </code><code>18</code><code>]) </code><code>=</code><code>=</code> <code>26</code></p></div></td></tr></tbody></table></div></div>
<p>To make performance testing easier lets create a function to return a random price sequence and run the get_max_profit function for different sizes of input:</p>
<div><div id="highlighter_487535"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p></td><td><div><p><code>import</code> <code>timeit</code></p><p><code>import</code> <code>functools</code></p><p><code>import</code> <code>random</code></p><p><code>def</code> <code>creating_dummy_prices(n):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>[random.randint(</code><code>0</code><code>, </code><code>20</code><code>) </code><code>for</code> <code>_ </code><code>in</code> <code>range</code><code>(n)]</code></p><p><code>for</code> <code>n </code><code>in</code> <code>[</code><code>10</code><code>, </code><code>20</code><code>, </code><code>100</code><code>, </code><code>150</code><code>, </code><code>200</code><code>]:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>data </code><code>=</code> <code>creating_dummy_prices(n)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>f </code><code>=</code> <code>functools.partial(get_max_profit, data)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(f</code><code>'Number of prices: {n}'</code><code>, </code><code>' Duration in seconds'</code><code>, timeit.timeit(f, number</code><code>=</code><code>1</code><code>))</code></p></div></td></tr></tbody></table></div></div>
<p>The code above produces the following output:</p>
<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-3.gif?resize=599%2C140" alt="bss-3" width="599" height="140"></p>
<p>Note that a sequence of 20 points requires a few milliseconds but as we ramp up to 200 we are quickly reaching more than 13 seconds.</p>
<p>This happens because our solution is extremely slow; note that we are calculating all the possible pairs for 2 and 4 points taken from prices meaning that the number of the required profit calculations are given by the following formula:</p>
<p><img src="http://i2.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-4.gif?resize=125%2C68" alt="bss-4" width="125" height="68"></p>
<p>which translates to a quadratic time complexity:</p>
<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-5.gif?resize=75%2C46" alt="bss-5" width="75" height="46"></p>
<p>It is clear that we need to a smarter solution that will allow us to solve it in a more efficient way.</p>
<h2>A better performing “brutal solution”</h2>
<p>As we think the problem deeper, we realize that for each data point in the prices curve we have a left – right maximum profit transaction meaning that if we iterate though all the points and store all the totals (counting only positive values) their maximum&nbsp; will be the desired value.</p>
<p>In this case the complexity of our solution will be proportional to the size of the array multiplied by the cost of finding the larger transaction in the left – right sides of the curve.</p>
<p>To try this approach we need to create a function that will receive a subsection of prices and return the maximum possible profit for it what is important though is that we want to avoid the creation of all possible pairs as we have done before and reduce the finding of the largest profit transaction to a single pass per subsection. After a little thinking we end up with the following solution:</p>
<div><div id="highlighter_994702"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p></td><td><div><p><code>import</code> <code>timeit</code></p><p><code>import</code> <code>functools</code></p><p><code>import</code> <code>random</code></p><p><code>def</code> <code>creating_dummy_prices(n):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>[random.randint(</code><code>0</code><code>, </code><code>20</code><code>) </code><code>for</code> <code>_ </code><code>in</code> <code>range</code><code>(n)]</code></p><p><code>def</code> <code>brutal_find_max_delta(a):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>largest_so_far </code><code>=</code> <code>None</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lower_so_far </code><code>=</code> <code>None</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>value </code><code>in</code> <code>a:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>largest_so_far </code><code>is</code> <code>None</code> <code>or</code> <code>largest_so_far &lt; value: largest_so_far </code><code>=</code> <code>value </code><code>if</code> <code>lower_so_far </code><code>is</code> <code>None</code> <code>or</code> <code>lower_so_far &gt; value:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lower_so_far </code><code>=</code> <code>value</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>largest_so_far </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>max</code><code>(m, largest_so_far </code><code>-</code> <code>lower_so_far)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>m</code></p><p><code>def</code> <code>brutal_solution(b):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>s </code><code>=</code> <code>brutal_find_max_delta(b)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>i </code><code>in</code> <code>range</code><code>(</code><code>2</code><code>, </code><code>len</code><code>(b) </code><code>-</code> <code>1</code><code>):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>x1, x2 </code><code>=</code> <code>b[</code><code>0</code><code>:i], b[i:]</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>s </code><code>=</code> <code>max</code><code>(s, brutal_find_max_delta(x1) </code><code>+</code> <code>brutal_find_max_delta(x2))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>s</code></p><p><code>for</code> <code>n </code><code>in</code> <code>[</code><code>10</code><code>, </code><code>20</code><code>, </code><code>100</code><code>, </code><code>150</code><code>, </code><code>200</code><code>]:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>data </code><code>=</code> <code>creating_dummy_prices(n)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>f </code><code>=</code> <code>functools.partial(brutal_solution, data)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(f</code><code>'Number of prices: {n}'</code><code>, </code><code>' Duration in seconds'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>timeit.timeit(f, number</code><code>=</code><code>1</code><code>))</code></p></div></td></tr></tbody></table></div></div>
<p>Which gives us the following output:</p>
<p><img src="http://i0.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-6.gif?resize=581%2C189" alt="bss-6" width="581" height="189"></p>
<p>Note that calculating the maximum profit now takes 0.16 which compared to the 13.29 that we have gotten before looks like a great improvement but we still have more work to do.</p>
<p>If we increase the size of the curve and run the following code:</p>
<div><div id="highlighter_339938"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><div><p><code>for</code> <code>n </code><code>in</code> <code>[</code><code>1000</code><code>, </code><code>2000</code><code>, </code><code>3000</code><code>, </code><code>5000</code><code>]:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>data </code><code>=</code> <code>creating_dummy_prices(n)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>f </code><code>=</code> <code>functools.partial(brutal_solution, data)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(f</code><code>'Number of prices: {n}'</code><code>, </code><code>' Duration in seconds'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>timeit.timeit(f, number</code><code>=</code><code>1</code><code>))</code></p></div></td></tr></tbody></table></div></div>
<p>we are getting the following timings:</p>
<p><img src="http://i0.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-7.gif?resize=588%2C114" alt="bss-7" width="588" height="114"></p>
<p>Although much faster than before, the function slows down quickly as the size of the curve grows.</p>
<p>Before we move forward and try to improve our solution it will be helpful to understand our current solution which is based on two basic concepts:</p>
<ul>
<li>Each data point in the curve divides it to a left – right section</li>
<li>We can calculate the maximum profit by iterating through all the points and compare their left – right totals</li>
<li>We need to calculate the maximum profit for each subsection</li>
</ul>

<p>The algorithm to calculate the maximum profit for a subsection is interesting so lets take a closer look onto it..</p>
<h2>Maximum profit for sequence of prices</h2>
<p>Calculating the transaction with the maximum profit for a sub-sequence is at the heart of our solution and we need to digest it well in order to understand the solution to our problem.</p>
<p>Given the sequence of prices [8, 12, 1, 9, 6, 11] it is easy to conclude that the maximum profit that can be made is 10 (buy on the third point and sell in the tenth) :</p>
<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-8.gif?resize=444%2C309" alt="bss-8" width="444" height="309"></p>
<p>To find out this profit we will need to iterate through the whole curve and at each point “remember” the lowest and highest prices we have seen so far. More than this we need to be sure that the lowest price occurs before the highest; this is what makes this algorithm a bit tricky.</p>
<p>As we move forward (to the right) if we discover a new lowest price we reinitialize our stored lower value to the new one and also set the maximum value to zero otherwise if we have reached a new larger value we are replacing the larger value so far with it.</p>
<p>At this point it is simple to calculate the larger profit for any iteration point if we compare the current profit with the previous, this is exactly what this code is doing:</p>
<div><div id="highlighter_812515"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></td><td><div><p><code>def</code> <code>brutal_find_max_delta(a):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>largest_so_far </code><code>=</code> <code>None</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lower_so_far </code><code>=</code> <code>None</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>value </code><code>in</code> <code>a:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>largest_so_far </code><code>is</code> <code>None</code> <code>or</code> <code>largest_so_far &lt; value: largest_so_far </code><code>=</code> <code>value </code><code>if</code> <code>lower_so_far </code><code>is</code> <code>None</code> <code>or</code> <code>lower_so_far &gt; value:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lower_so_far </code><code>=</code> <code>value</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>largest_so_far </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>max</code><code>(m, largest_so_far </code><code>-</code> <code>lower_so_far)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>m</code></p></div></td></tr></tbody></table></div></div>
<p>Since we are iterating through all the prices passed to the function its complexity is O(m) (m is the length of the passed in array).</p>
<p>As said before to calculate the maximum possible profit for zero, one or two transactions we need to iterate through the whole sequence of prices (whose length is n) and for each point call the brutal_find_max_delta function for the left and right side. Note the for each point the complexity will be: O(m) + O(n-m) or O(n).</p>
<p>Based on this the total complexity of the brutal solution will be quadratic:</p>
<p><img src="http://i0.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-9.gif?resize=198%2C33" alt="bss-9" width="198" height="33"></p>
<p>So, although this approach is an improvement when compare to the previous solution, it is still very slow and needs to be improved further.</p>
<p>Tip: Before you continue be sure that you understand the implementation of brutal_find_max_delta.</p>
<h2>Precalculating maximum profits</h2>
<p>In our solution about we note that what is really “expensive” is the calculation of the left – right maximums; this makes us to think if we can simplify their calculations by re-using some of the already calculated data. Our approach will be to create a new list having the same length as the passed in list of prices where each point will have the left-wise maximum profit.</p>
<p>Doing so appears to be quite easy changing the brutal_find_max_delta to keep track of the maximums per point:</p>
<div><div id="highlighter_442467"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p></td><td><div><p><code>def</code> <code>left_side_max_deltas(prices):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>deltas </code><code>=</code> <code>[</code><code>0</code><code>] </code><code>*</code> <code>len</code><code>(prices)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>largest_so_far </code><code>=</code> <code>None</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lower_so_far </code><code>=</code> <code>None</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>index, value </code><code>in</code> <code>enumerate</code><code>(prices):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>largest_so_far </code><code>is</code> <code>None</code> <code>or</code> <code>largest_so_far &lt; value: largest_so_far </code><code>=</code> <code>value </code><code>if</code> <code>lower_so_far </code><code>is</code> <code>None</code> <code>or</code> <code>lower_so_far &gt; value:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lower_so_far </code><code>=</code> <code>value</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>largest_so_far </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>max</code><code>(m, largest_so_far </code><code>-</code> <code>lower_so_far)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>deltas[index] </code><code>=</code> <code>m</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>deltas</code></p></div></td></tr></tbody></table></div></div>
<p>Calling this function using the above testing data:</p>
<div><div id="highlighter_43680"><table><tbody><tr><td><p>1</p></td><td><div><p><code>print</code><code>(left_side_max_deltas([</code><code>8</code><code>, </code><code>12</code><code>, </code><code>1</code><code>, </code><code>9</code><code>, </code><code>6</code><code>, </code><code>11</code><code>]))</code></p></div></td></tr></tbody></table></div></div>
<p>We are getting the following output:</p>
<p>[0, 4, 4, 8, 8, 10]</p>
<p>as can be seen in this graph:</p>
<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-10.gif?resize=578%2C350" alt="bss-10" width="578" height="350"></p>
<p>With a simple modification of the left_side_max_deltas we can write a similar function to calculate the maximums from the right side of a point:</p>
<div><div id="highlighter_567981"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p></td><td><div><p><code>def</code> <code>right_side_max_deltas(prices):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>deltas </code><code>=</code> <code>[</code><code>0</code><code>] </code><code>*</code> <code>len</code><code>(prices)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>index </code><code>=</code> <code>len</code><code>(prices) </code><code>-</code> <code>1</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>largest_so_far </code><code>=</code> <code>None</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lower_so_far </code><code>=</code> <code>None</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>index &gt;</code><code>=</code> <code>0</code><code>:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>value </code><code>=</code> <code>prices[index]</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>largest_so_far </code><code>is</code> <code>None</code> <code>or</code> <code>largest_so_far &lt; value: largest_so_far </code><code>=</code> <code>value lower_so_far </code><code>=</code> <code>value </code><code>if</code> <code>lower_so_far </code><code>is</code> <code>None</code> <code>or</code> <code>lower_so_far &gt; value:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>lower_so_far </code><code>=</code> <code>value</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>max</code><code>(m, largest_so_far </code><code>-</code> <code>lower_so_far)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>deltas[index] </code><code>=</code> <code>m</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>index </code><code>-</code><code>=</code> <code>1</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>deltas</code></p></div></td></tr></tbody></table></div></div>
<p>Running the new functions with the same curve as before:</p>
<div><div id="highlighter_121384"><table><tbody><tr><td><p>1</p></td><td><div><p><code>print</code><code>(right_side_max_deltas([</code><code>8</code><code>, </code><code>12</code><code>, </code><code>1</code><code>, </code><code>9</code><code>, </code><code>6</code><code>, </code><code>11</code><code>]))</code></p></div></td></tr></tbody></table></div></div>
<p>returns the following list:</p>
<p>[10, 10, 10, 5, 5, 0]</p>
<p>where each data point represents the maximum area that can be found on the right of it as can be seen in this graph:</p>
<p><img src="http://i0.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-11.gif?resize=582%2C347" alt="bss-11" width="582" height="347"></p>
<h2>The efficient solution</h2>
<p>Now that we have the left – right maximum profit curve creation functions ready we can write a function to allow us to solve the problem:</p>
<div><div id="highlighter_825725"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p></td><td><div><p><code>def</code> <code>get_max_profit(prices):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>index </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>left </code><code>=</code> <code>left_side_max_deltas(prices)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>right </code><code>=</code> <code>right_side_max_deltas(prices)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>index &lt; </code><code>len</code><code>(prices):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>m </code><code>=</code> <code>max</code><code>(m, left[index] </code><code>+</code> <code>right[index])</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>index </code><code>+</code><code>=</code> <code>1</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>m</code></p><p><code>assert</code> <code>get_max_profit([</code><code>7</code><code>, </code><code>3</code><code>, </code><code>13</code><code>, </code><code>13</code><code>, </code><code>6</code><code>, </code><code>19</code><code>, </code><code>10</code><code>, </code><code>8</code><code>, </code><code>15</code><code>, </code><code>18</code><code>]) </code><code>=</code><code>=</code> <code>26</code></p></div></td></tr></tbody></table></div></div>
<p>The time complexity of our solution is O(n) and since we are keeping the pre-calculated maximums in memory our memory complexity is also O(n).</p>
<p>Stress testing our new function gives the following results:</p>
<div><div id="highlighter_606316"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><div><p><code>for</code> <code>n </code><code>in</code> <code>[</code><code>10</code><code>, </code><code>20</code><code>, </code><code>100</code><code>, </code><code>150</code><code>, </code><code>200</code><code>, </code><code>1000</code><code>, </code><code>10000</code><code>, </code><code>100000</code><code>]:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>data </code><code>=</code> <code>creating_dummy_prices(n)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>f </code><code>=</code> <code>functools.partial(get_max_profit, data)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(f</code><code>'Number of prices: {n}'</code><code>, </code><code>' Duration in seconds'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>timeit.timeit(f, number</code><code>=</code><code>1</code><code>))</code></p></div></td></tr></tbody></table></div></div>
<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/bss-12.gif?resize=533%2C199" alt="bss-12" width="533" height="199"></p>
<p>Notice how dramatically faster the new solution is;a price curve of 100,000 data points now takes less than a tenth of a second to be calculated meaning that we have reached an effective and acceptable solution.</p>
<h2>Conclusion</h2>
<p>To solve our problem we initially created a very simple solution which was very slow, thinking a little deeper we were able to improve its performance to be faster and then we discovered a trick that allowed us to come up with an efficient algorithm for our problem; the same process is applicable to most of the problems that require a special algorithm.</p>

	</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>