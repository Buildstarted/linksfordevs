<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Low allocation async/await for C#/.NET -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Low allocation async/await for C#/.NET</h1><div><div id="" class="main-content"><p>Low-allocation utilies for writing <code class="highlighter-rouge">async</code> methods, and related tools</p><h3 id="contents">Contents</h3><hr><h2 id="pooledvaluetask--pooledvaluetaskt"><code class="highlighter-rouge">PooledValueTask</code> / <code class="highlighter-rouge">PooledValueTask&lt;T&gt;</code></h2><p>These are the main tools of the library; their purpose is to remove the boxing of the async state-machine and builder that happens when a method
marked <code class="highlighter-rouge">async</code> performs an <code class="highlighter-rouge">await</code> on an awaitable target that <em>is not yet complete</em>, i.e.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span><span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="nf">SomeMethod</span><span class="p">()</span><span class="p">{</span><span class="k">await</span><span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span><span class="c1">// *is not yet complete*</span><span class="k">return</span><span class="m">42</span><span class="p">}</span></code></pre></div></div><p>If you’ve ever looked at an application that uses <code class="highlighter-rouge">async</code> / <code class="highlighter-rouge">await</code> in a memory profiler and seen things like <code class="highlighter-rouge">System.Runtime.CompilerServices.AsyncTaskMethodBuilder</code><code class="highlighter-rouge">1.AsyncStateMachineBox</code><code class="highlighter-rouge">1</code>
or <code class="highlighter-rouge">YourLib.&lt;&lt;SomeMethod&gt;g__Inner|8_0&gt;d</code>, then that’s what I’m talking about. You can avoid this by simply using a different return type:</p><ul><li><code class="highlighter-rouge">PooledValueTask&lt;T&gt;</code> instead of <code class="highlighter-rouge">ValueTask&lt;T&gt;</code></li><li><code class="highlighter-rouge">PooledValueTask</code> instead of <code class="highlighter-rouge">ValueTask</code></li></ul><p>For <code class="highlighter-rouge">private</code> / <code class="highlighter-rouge">internal</code> methods, you can probably just <em>change the return type directly</em>:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span><span class="k">async</span><span class="n">PooledValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="nf">SomeMethod</span><span class="p">()</span><span class="p">{</span><span class="k">await</span><span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span><span class="c1">// *is not yet complete*</span><span class="k">return</span><span class="m">42</span><span class="p">}</span></code></pre></div></div><p>For methods on your <code class="highlighter-rouge">public</code> API surface, you can use a “local function” to achieve the same thing without changing the exposed return type:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="n">ValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span><span class="nf">SomeMethod</span><span class="p">()</span><span class="c1">// not marked async</span><span class="p">{</span><span class="k">return</span><span class="nf">Impl</span><span class="p">();</span><span class="k">async</span><span class="n">PooledValueTask</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;()</span><span class="nf">Impl</span><span class="p">()</span><span class="p">{</span><span class="k">await</span><span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span><span class="c1">// *is not yet complete*</span><span class="k">return</span><span class="m">42</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>(all of the <code class="highlighter-rouge">Pooled*</code> types have <code class="highlighter-rouge">implicit</code> conversion operators to their more well-recognized brethren).</p><p>And that’s it! That’s all you have to do. The “catch” (there’s always a catch) is that awaiting the same pending operation <em>more than once</em><strong>no longer works</strong>:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">pending</span><span class="p">=</span><span class="nf">SomeIncompleteMethodAsync</span><span class="p">();</span><span class="c1">// note no "await" here</span><span class="kt">var</span><span class="n">x</span><span class="p">=</span><span class="k">await</span><span class="n">pending</span><span class="p">;</span><span class="kt">var</span><span class="n">y</span><span class="p">=</span><span class="k">await</span><span class="n">pending</span><span class="p">;</span><span class="c1">// BOOM! await the **same result**</span></code></pre></div></div><p>In reality, <strong>this almost never happens</strong>. Usually you <code class="highlighter-rouge">await</code> something <em>once</em>, <em>almost always</em> right away. So… yeah.</p><hr><h2 id="pooledtask--pooledtaskt"><code class="highlighter-rouge">PooledTask</code> / <code class="highlighter-rouge">PooledTask&lt;T&gt;</code></h2><p>These work very similarly to <code class="highlighter-rouge">PooledValueTask[&lt;T&gt;]</code>, but for the <code class="highlighter-rouge">Task[&lt;T&gt;]</code> API. It can’t be <em>quite</em> as frugal, as in most cases a <code class="highlighter-rouge">Task[&lt;T&gt;]</code>
will still need to be allocated (unless it is the non-generic <code class="highlighter-rouge">PooledTask</code> signature, and the operation completes synchronously), but it
still avoids the state-machine box etc. Note that this API <strong>is not</strong> impacted by the “you can only await it once” change (you can
await these as many times as you like - they are, after all, <code class="highlighter-rouge">Task[&lt;T&gt;]</code>), but again: <em>this is used incredibly rarely anyway</em>.</p><h2 id="fireandforget"><code class="highlighter-rouge">FireAndForget</code></h2><p>Ever find yourself needing a fire-and-forget API? This adds one. All you do is declare the return type as <code class="highlighter-rouge">FireAndForget</code>:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FireAndForget</span><span class="nf">SomeMethod</span><span class="p">(...)</span><span class="p">{</span><span class="c1">// .. things before the first incomplete await happen on the calling thread</span><span class="k">await</span><span class="nf">SomeIncompleteMethod</span><span class="p">();</span><span class="c1">// .. other bits continue running in the background</span><span class="p">}</span></code></pre></div></div><p>As soon as the method uses <code class="highlighter-rouge">await</code> against an incomplete operation, the calling
task regains control as though it were complete; the rest of the operation continues in the background. The caller can simply <code class="highlighter-rouge">await</code>
the fire-and-forget method with confidence that it only runs synchronously to the first incomplete operation. If you’re not in an <code class="highlighter-rouge">async</code>
method, you can use “discard” to tell the compiler not to tell you to <code class="highlighter-rouge">await</code> it:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">_</span><span class="p">=</span><span class="nf">SomeFireAndForgetMethodAsync</span><span class="p">();</span></code></pre></div></div><p>You won’t get unobserved-task-exception problems. If you want to see any exceptions that happen, there is an event <code class="highlighter-rouge">FireAndForget.Exception</code>
that you can subscribe to. Otherwise, they just evaporate.</p><hr><h2 id="configuredyieldawaitable"><code class="highlighter-rouge">ConfiguredYieldAwaitable</code></h2><p>Related to <code class="highlighter-rouge">FireAndForget</code> - when you <code class="highlighter-rouge">await Task.Yield()</code> it always respects the sync-context/task-scheduler; sometimes <em>you don’t want to</em>.
For many awaitables there is a <code class="highlighter-rouge">.ConfigureAwait(continueOnCapturedContext: false)</code> method that you can use to suppress this, but
not on <code class="highlighter-rouge">Task.Yield()</code>… <em>until now</em>. Usage is, as you would expect:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span><span class="n">Task</span><span class="p">.</span><span class="nf">Yield</span><span class="p">().</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span></code></pre></div></div><hr><h2 id="valuetaskcompletionsourcet"><code class="highlighter-rouge">ValueTaskCompletionSource&lt;T&gt;</code></h2><p>Do you make use of <code class="highlighter-rouge">TaskCompletionSource&lt;T&gt;</code>? Do you hate that this adds another allocation <em>on top of</em> the <code class="highlighter-rouge">Task&lt;T&gt;</code> that you actually wanted?
<code class="highlighter-rouge">ValueTaskCompletionSource&lt;T&gt;</code> is your friend. It uses smoke and magic to work like <code class="highlighter-rouge">TaskCompletionSource&lt;T&gt;</code>, but without the extra
allocation (unless it discovers that the magic isn’t working for your system). Usage:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">source</span><span class="p">=</span><span class="n">ValueTaskCompletionSource</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;.</span><span class="nf">Create</span><span class="p">();</span><span class="c1">// ...</span><span class="n">source</span><span class="p">.</span><span class="nf">TrySetResult</span><span class="p">(</span><span class="m">42</span><span class="p">);</span><span class="c1">// etc</span></code></pre></div></div><p>The main difference here is that you now have a <code class="highlighter-rouge">struct</code> instead of a <code class="highlighter-rouge">class</code>. If you want to test whether an instance is a <em>real</em> value
(as opposed to the <code class="highlighter-rouge">default</code>), check <code class="highlighter-rouge">.HasTask</code>.</p><hr><h2 id="pooledvaluetasksource--pooledvaluetasksourcet"><code class="highlighter-rouge">PooledValueTaskSource</code> / <code class="highlighter-rouge">PooledValueTaskSource&lt;T&gt;</code></h2><p>These again work like <code class="highlighter-rouge">TaskCompletionSource&lt;T&gt;</code>, but a: for <code class="highlighter-rouge">ValueType[&lt;T&gt;]</code>, and b: with the same zero-allocation features that
<code class="highlighter-rouge">PooledValueTask</code> / <code class="highlighter-rouge">PooledValueTask&lt;T&gt;</code> exhibit. Once again, the “catch” is that you can only await their <code class="highlighter-rouge">.Task</code><em>once</em>. Usage:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">source</span><span class="p">=</span><span class="n">PooledValueTaskSource</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;.</span><span class="nf">Create</span><span class="p">();</span><span class="c1">// ...</span><span class="n">source</span><span class="p">.</span><span class="nf">TrySetResult</span><span class="p">(</span><span class="m">42</span><span class="p">);</span><span class="c1">// etc</span></code></pre></div></div><hr><h2 id="lazytaskcompletionsource--lazytaskcompletionsourcet"><code class="highlighter-rouge">LazyTaskCompletionSource / LazyTaskCompletionSource&lt;T&gt;</code></h2><p>Sometimes, you have an API where you <em>aren’t sure</em> whether someone is subscribing to the <code class="highlighter-rouge">Task</code>/<code class="highlighter-rouge">Task&lt;T&gt;</code> results - for example
you have properties like:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span><span class="n">Task</span><span class="n">SomeStepCompleted</span><span class="p">{</span><span class="k">get</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>It would be a shame to allocate a <code class="highlighter-rouge">Task</code> for this <em>just in case</em>, so <code class="highlighter-rouge">LazyTaskCompletionSource[&lt;T&gt;]</code> allows you to <em>rent</em> state
that can manage <em>lazily</em> creating a task. If the <code class="highlighter-rouge">.Task</code> is read before the value is set, a <em>source</em> is used to provide a
pending task; if the result gets set before the value is read, then some optimizations may be possible (<code class="highlighter-rouge">Task.CompletedTask</code>, etc).
And if the <code class="highlighter-rouge">.Task</code> is never queried: no task or source is allocated. These types are disposable; disposing them releases any
rented state for re-use.</p><hr><h2 id="pool"><code class="highlighter-rouge">Pool</code></h2><p>Ever need a light-weight basic pool of objects? That’s this. Nothing fancy. The first API is a simple get/put:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span><span class="n">obj</span><span class="p">=</span><span class="n">Pool</span><span class="p">.</span><span class="n">TryRent</span><span class="p">&lt;</span><span class="n">SomeType</span><span class="p">&gt;()</span><span class="p">??</span><span class="k">new</span><span class="nf">SomeType</span><span class="p">();</span><span class="c1">// ...</span><span class="n">Pool</span><span class="p">.</span><span class="nf">Return</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span></code></pre></div></div><p>Note that it leaves creation to you (hence the <code class="highlighter-rouge">?? new SomeType()</code>), and it is the caller’s responsibility to not retain and access
a reference object that you have notionally returned to the pool.</p><p>Considerations:</p><ul><li>you may wish to use <code class="highlighter-rouge">try</code>/<code class="highlighter-rouge">finally</code> to put things back into the pool even if you leave through failure</li><li>if the object might <strong>unnecessarily</strong> keep large graphs of sub-objects “reachable” (in terms of GC), you should ensure that any references are wiped before putting an object into the pool</li><li>if the object implements <code class="highlighter-rouge">IResettable</code>, the pool will automatically call the <code class="highlighter-rouge">Reset()</code> method for you before storing items in the pool</li></ul><p>A second API is exposed for use with value-types; there are a lot of scenarios in which you have some state that you need to expose
to an API that takes <code class="highlighter-rouge">object</code> - especially with callbacks like <code class="highlighter-rouge">WaitCallback</code>, <code class="highlighter-rouge">SendOrPostCallback</code>, <code class="highlighter-rouge">Action&lt;object&gt;</code>, etc. The data
will only be unboxed once at the receiver - so: rather than use a <em>regular</em> box, we can <em>rent</em> a box. Also, if you have multiple items of
state that you need to convey - consider a value-tuple.</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="n">id</span><span class="p">=</span><span class="p">...</span><span class="kt">string</span><span class="n">name</span><span class="p">=</span><span class="p">...</span><span class="kt">var</span><span class="n">obj</span><span class="p">=</span><span class="n">Pool</span><span class="p">.</span><span class="nf">Box</span><span class="p">((</span><span class="n">id</span><span class="p">,</span><span class="n">name</span><span class="p">));</span><span class="c1">// ... probably pass obj to a callback-API</span></code></pre></div></div><p>then later:</p><div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kt">var</span><span class="n">id</span><span class="p">,</span><span class="kt">var</span><span class="n">name</span><span class="p">)</span><span class="p">=</span><span class="n">Pool</span><span class="p">.</span><span class="n">UnboxAndReturn</span><span class="p">&lt;(</span><span class="kt">int</span><span class="p">,</span><span class="kt">string</span><span class="p">)&gt;(</span><span class="n">obj</span><span class="p">);</span><span class="c1">// use id/name as usual</span></code></pre></div></div><p>It is the caller’s responsibility to only access the state once.</p><p>The pool is global (<code class="highlighter-rouge">static</code>) and pretty modest in size. You can control it <em>a bit</em> by adding <code class="highlighter-rouge">[PoolSize(...)]</code> to the custom
classes and value-types that you use.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>