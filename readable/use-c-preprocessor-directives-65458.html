<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Use C# Preprocessor Directives - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Use C# Preprocessor Directives - linksfor.dev(s)"/>
    <meta property="article:author" content="Khalid Abuhakmeh"/>
    <meta property="og:description" content="Run configurations are one of those things that many .NET developers take for granted. Whenever we start a new project, we have two basic configurations: Debug and Release. For most of us, that&#x2019;s more than enough to deliver a capable production application. For those of us targeting multiple platforms, we may need a configuration for each destination platform."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://khalidabuhakmeh.com/csharp-preprocessor-directives"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Use C# Preprocessor Directives</title>
<div class="readable">
        <h1>Use C# Preprocessor Directives</h1>
            <div>by Khalid Abuhakmeh</div>
            <div>Reading time: 7-9 minutes</div>
        <div>Posted here: 10 Aug 2020</div>
        <p><a href="https://khalidabuhakmeh.com/csharp-preprocessor-directives">https://khalidabuhakmeh.com/csharp-preprocessor-directives</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
                <p>Run configurations are one of those things that many .NET developers take for granted. Whenever we start a new project, we have two basic configurations: <code>Debug</code> and <code>Release</code>. For most of us, that’s more than enough to deliver a capable production application. For those of us targeting multiple platforms, we may need a configuration for each destination platform.</p>

<p>In this post, we’ll walk through the basics of C# preprocessor directives. We’ll use keywords like <code>define</code>, <code>if</code>, <code>else</code>, <code>elif</code>, and <code>undef</code> to change our application’s behavior. We’ll also look at some of the predefined preprocessor directives that come with the .NET Framework. Finally, we’ll see how we can alter the preprocessor directives on our run configurations.</p>

<!--more-->

<h2 id="what-is-a-preprocessor-directive"><a href="#what-is-a-preprocessor-directive">What is a Preprocessor Directive</a></h2>

<p><strong>A preprocessor directive gives us the ability to define blocks of code that only get compiled if we meet criteria.</strong> Previously we mentioned that most C# projects start with two different run configurations of <code>Debug</code> and <code>Release</code>. If we look at the preprocessor directives defined for each run configuration, we’ll see they differ.</p>

<table>
  <thead>
    <tr>
      <th>Run Configuration</th>
      <th>Preprocessor Directives</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Debug</td>
      <td>
<code>DEBUG</code>, <code>TRACE</code>
</td>
    </tr>
    <tr>
      <td>Release</td>
      <td><code>TRACE</code></td>
    </tr>
  </tbody>
</table>

<p>The <code>Debug</code> run configuration has two preprocessors, while <code>Release</code> only has one preprocessor. In <code>Debug</code>, we can define additional code blocks that increase our ability to diagnose and fix issues.</p>

<div><div><pre><code><span>internal</span> <span>class</span> <span>Program</span>
<span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>string</span><span>[]</span> <span>args</span><span>)</span>
    <span>{</span>
    <span>#</span><span>if</span> <span>DEBUG</span>
        <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Before the hello, World!"</span><span>);</span>
    <span>#</span><span>endif</span>
        
        <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Hello, World!"</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<h2 id="how-to-use-preprocessor-directives"><a href="#how-to-use-preprocessor-directives">How To Use Preprocessor Directives</a></h2>

<p>There are several ways to introduce preprocessor directives into our projects.</p>

<ol>
  <li>Predefined by the .NET Framework</li>
  <li>Run Configuration Compile Constants</li>
  <li>Using the <code>define</code> keyword in code</li>
  <li>Using the <code>-define</code> option with the compiler.</li>
</ol>

<h3 id="predefined-preprocessor-directives"><a href="#predefined-preprocessor-directives">Predefined Preprocessor Directives</a></h3>

<p>C# has many <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/" target="_blank" rel="noopener noreferrer">predefined preprocessor symbols</a> representing all the available target frameworks found in our development environment. These preprocessor directives can help us transition legacy code to newer platforms, or target future platforms while maintaining our codebase for the present. Here is a list of known predefined directives, and we can assume the .NET team will continue the pattern for future iterations of SDK releases.</p>

<table>
  <thead>
    <tr>
      <th>Target Frameworks</th>
      <th>Preprocessor Directives</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>.NET Framework</td>
      <td>
<code>NETFRAMEWORK</code>, <code>NET20</code>, <code>NET35</code>, <code>NET40</code>, <code>NET45</code>,<code>NET451</code>, <code>NET452</code>, <code>NET46</code>, <code>NET461</code>, <code>NET462</code>, <code>NET47</code>, <code>NET471</code>, <code>NET472</code>, <code>NET48</code>
</td>
    </tr>
    <tr>
      <td>.NET Standard</td>
      <td>
<code>NETSTANDARD</code>, <code>NETSTANDARD1_0</code>, <code>NETSTANDARD1_1</code>,<code>NETSTANDARD1_2</code>, <code>NETSTANDARD1_3</code>, <code>NETSTANDARD1_4</code>, <code>NETSTANDARD1_5</code>,<code>NETSTANDARD1_6</code>, <code>NETSTANDARD2_0</code>, <code>NETSTANDARD2_1</code>
</td>
    </tr>
    <tr>
      <td>.NET Core</td>
      <td>
<code>NETCOREAPP</code>, <code>NETCOREAPP1_0</code>, <code>NETCOREAPP1_1</code>, <code>NETCOREAPP2_0</code>, <code>NETCOREAPP2_1</code>, <code>NETCOREAPP2_2</code>, <code>NETCOREAPP3_0</code>, <code>NETCOREAPP3_1</code>
</td>
    </tr>
  </tbody>
</table>

<p>Other development platforms may also introduce a set of specific preprocessor directives. For example, the Unity Game Engine presents an <a href="https://docs.unity3d.com/Manual/PlatformDependentCompilation.html" target="_blank" rel="noopener noreferrer">abundant list of preprocessor directives</a> for each target platform from Android, iOS, WebGL, and more.</p>

<h3 id="run-configuration-constants"><a href="#run-configuration-constants">Run Configuration Constants</a></h3>

<p>One of the most straightforward approaches to adding additional compile constants is by adding them to a specific run configuration. We can modify our run configuration by right-clicking the <code>properties</code> of our project in our IDE. Here is a screenshot from Rider.</p>

<p><img src="https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/preprocessor/run-configuration.png" srcset="https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_320/https://khalidabuhakmeh.com/assets/images/posts/preprocessor/run-configuration.png 320w, https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_540/https://khalidabuhakmeh.com/assets/images/posts/preprocessor/run-configuration.png 540w, https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_760/https://khalidabuhakmeh.com/assets/images/posts/preprocessor/run-configuration.png 760w, https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_980/https://khalidabuhakmeh.com/assets/images/posts/preprocessor/run-configuration.png 980w, https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_1200/https://khalidabuhakmeh.com/assets/images/posts/preprocessor/run-configuration.png 1200w" sizes="100vw" alt="run configuration in JetBrains Rider" loading="lazy" width="1500" height="974" crossorigin="anonymous"></p>

<p>We can add additional preprocessor directives or remove them from our compilation.</p>

<h3 id="using-the-define-keyword-in-code"><a href="#using-the-define-keyword-in-code">Using the Define Keyword In Code</a></h3>

<p>We can leverage the <code>define</code> keyword to create preprocessor directives inside of our C# files. <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/preprocessor-define" target="_blank" rel="noopener noreferrer">There are caveats to this approach</a>.</p>

<ol>
  <li>The symbol must appear at the top of the file before any instructions.</li>
  <li>The new symbol does not conflict with another preprocessor directive.</li>
  <li>The scope of the symbol is the file in which we define it.</li>
</ol>

<p>Let’s have a look at this use case:</p>

<div><div><pre><code><span>#define Hello
</span><span>using</span> <span>System</span><span>;</span>

<span>namespace</span> <span>Changes</span>
<span>{</span>
    <span>internal</span> <span>class</span> <span>Program</span>
    <span>{</span>
        <span>public</span> <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>string</span><span>[]</span> <span>args</span><span>)</span>
        <span>{</span>
            <span>#</span><span>if</span> <span>Hello</span>
            <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Hello, World!"</span><span>);</span>
            <span>#</span><span>endif</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<h3 id="using-the-define-compiler-option"><a href="#using-the-define-compiler-option">Using the Define Compiler Option</a></h3>

<p>Instead of modifying our run configuration, we can also make compile-time decisions about our preprocessor directives. When calling the C# compiler, we can pass in our directives <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/define-compiler-option" target="_blank" rel="noopener noreferrer">using the <code>-define</code> option</a>.</p>

<div><div><pre><code><span>&gt;</span><span> </span>csc HelloWorld.cs <span>-define</span>:DEBUG<span>;</span>Hello
</code></pre></div></div>

<p>This approach works, but it is a little less convenient than modifying our run configurations. This approach may be useful in continuous integration environments that may be looking at environment variables. That said, C# projects support multiple run configurations, and that approach may be more deterministic.</p>

<h2 id="code-example"><a href="#code-example">Code Example</a></h2>

<p>We can think of preprocessor directives as boolean values, and so does C#. Because of their logical nature, we get to use boolean operators to make preprocessor decisions. Take the following example.</p>

<div><div><pre><code><span>#define FIZZ
#define BUZZ
</span>
<span>using</span> <span>System</span><span>;</span>

<span>namespace</span> <span>Changes</span>
<span>{</span>
    <span>internal</span> <span>class</span> <span>Program</span>
    <span>{</span>
        <span>public</span> <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>string</span><span>[]</span> <span>args</span><span>)</span>
        <span>{</span>
            <span>#</span><span>if</span> <span>(</span><span>FIZZ</span> <span>&amp;&amp;</span> <span>BUZZ</span><span>)</span>
                <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"FizzBuzz"</span><span>);</span>
            <span>#</span><span>elif</span> <span>(</span><span>FIZZ</span><span>)</span>
                <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Fizz"</span><span>);</span>
            <span>#</span><span>elif</span> <span>(</span><span>BUZZ</span><span>)</span>
                <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"FizzBuzz"</span><span>);</span>
            <span>#</span><span>else</span>
                <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Hello, World!"</span><span>);</span>
            <span>#</span><span>endif</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>We can use keywords like <code>if</code>, <code>elif</code>, and <code>endif</code> to create a logical structure for compilation. We can also use operators like <code>and (&amp;&amp;)</code>, <code>or (||)</code>, and <code>not (!)</code> to create intricate scenarios.</p>

<p>Not commonly used, but we can also use the <code>undef</code> keyword to unregister a preprocessor directive.</p>

<div><div><pre><code><span>#define FIZZ
#define BUZZ
#undef FIZZ
#undef BUZZ
</span>
<span>using</span> <span>System</span><span>;</span>

<span>namespace</span> <span>Changes</span>
<span>{</span>
    <span>internal</span> <span>class</span> <span>Program</span>
    <span>{</span>
        <span>public</span> <span>static</span> <span>void</span> <span>Main</span><span>(</span><span>string</span><span>[]</span> <span>args</span><span>)</span>
        <span>{</span>
            <span>#</span><span>if</span> <span>(</span><span>FIZZ</span> <span>&amp;&amp;</span> <span>BUZZ</span><span>)</span>
                <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"FizzBuzz"</span><span>);</span>
            <span>#</span><span>elif</span> <span>(</span><span>FIZZ</span><span>)</span>
                <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Fizz"</span><span>);</span>
            <span>#</span><span>elif</span> <span>(</span><span>BUZZ</span><span>)</span>
                <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"FizzBuzz"</span><span>);</span>
            <span>#</span><span>else</span>
                <span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Hello, World!"</span><span>);</span>
            <span>#</span><span>endif</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>In the above example, its as if our symbols of <code>FIZZ</code> and <code>BUZZ</code> never existed. The <code>undef</code> keyword may be helpful to opt file out of a directive for debugging purposes.</p>

<h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>

<p>Preprocessor directives are a powerful tool for removing code blocks from our compilation step. It can help us target multiple platforms and share a majority of our code between different audiences. Development platforms like Xamarin, Mono, and even .NET itself have used preprocessor directives to a high degree of success. The most recommended approach is to alter our project run configurations, but we have many options, as we can see. Finally, while this approach is powerful, many developers should consider a strategy outside of compilation, like feature flags, if they intend to toggle behavior during runtime.</p>


            </div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>