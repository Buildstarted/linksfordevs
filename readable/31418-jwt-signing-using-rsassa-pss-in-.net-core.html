<!DOCTYPE html>
<html lang="en">
<head>
    <title>
JWT Signing using RSASSA-PSS in .NET Core -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>JWT Signing using RSASSA-PSS in .NET Core</h1><div><div class="col-lg-10" itemprop="articleBody"><p>
As of <a title="" href="https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/releases/tag/5.5.0" target="_blank">version 5.5</a>, Microsoft’s IdentityModel library now supports the signing of JSON Web Tokens using the RSASSA-PSS (Probabilistic Signature Scheme) digital signature algorithm.
This is great news if you’re looking to start building .NET Core systems that implement OpenID’s Financial-grade API and Open Banking, where PS256 <a title="FAPI - Read &amp; Write API Security Profile" href="https://openid.net/specs/openid-financial-api-part-2.html#jws-algorithm-considerations" target="_blank">should</a> be used for signing.
</p><p>
You can find the full list of support for various .NET targets on <a title="Identity Model - Supported Algorithms" href="https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/wiki/Supported-Algorithms#rsa" target="_blank">GitHub</a>, but the exciting thing is that <strong>PS256, PS384, and PS512 are now supported on .NET Core</strong>.
</p><h2>RS256 vs. PS256</h2><p>
When deciding between two algorithms such as RS256 (<em>RSASSA-PKCS1-v1_5 using SHA-256</em>) and PS256 (<em>RSASSA-PSS using SHA-256 and MGF1 with SHA-256</em>), we would prefer to use PS256.
That’s not to say RSASSA-PKCS1-v1_5 is broken, but rather that RSASSA-PSS simply has desirable features that the other does not, in the form of a probabilistic signature scheme and a security proof.
</p><p>
With RSASSA-PKCS1-v1_5 we’re stuck with a deterministic signature, meaning the same two inputs (e.g. JWTs) would create the same signature.
With RSASSA-PSS, we get a probabilistic signature, meaning the same two inputs would create different signatures, thanks to the introduction of some random data, while still being verifiable by the same public key.
</p><p>
A probabilistic signature plus a verifiable security proof makes cryptographers much happier.
</p><p>
I also ran the two .NET implementations through BenchmarkDotNet but struggled to find any noticeable performance differences between them.
Signature length is also identical between the two.
</p><h2>PS256 in .NET Core</h2><p>
To get the right APIs we’ll need <code>Microsoft.IdentityModel.JsonWebTokens</code> version 5.5 (or greater).
This will also bring in the various <code>Microsoft.IdentityModel</code> libraries that we need:
</p><pre><code class="language-custom">install-package Microsoft.IdentityModel.JsonWebTokens</code></pre><p>
We then need an RSA key to sign and validate tokens with.
<a title="RFC 7518 - JSON Web Algorithms (JWA)" href="https://tools.ietf.org/html/rfc7518#section-3.5" target="_blank">RFC 7518</a>, which defines PS256, enforces a key size of at least 2048 bits.
You could load a private key from an X509 certificate, but here we’ll create one in code:
</p><pre><code class="language-csharp">var key = new RsaSecurityKey(RSA.Create(2048));</code></pre><h3>Token Creation</h3><p>
We can then new up our JWT token handler, a token descriptor, and then use the handler’s <code>CreateToken</code> method to create our JWT.
These APIs should be familiar if you have created JWTs before.
</p><pre><code class="language-csharp">var handler = new JsonWebTokenHandler();
var now = DateTime.UtcNow;

var descriptor = new SecurityTokenDescriptor
    {
        Issuer = "me",
        Audience = "you",
        IssuedAt = now,
        NotBefore = now,
        Expires = now.AddMinutes(5),
        Subject = new ClaimsIdentity(new List&lt;Claim&gt; {new Claim("sub", "scott")}),
        SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.RsaSsaPssSha256)
    };

string jwt = handler.CreateToken(descriptor);</code></pre><h3>Token Validation</h3><p>
To validate our token, we use the same APIs as normal, calling <code>ValidateToken</code> on our token handler.
This would be indistinguishable from validating a token signed using RS256:
</p><pre><code class="language-csharp">TokenValidationResult result = handler.ValidateToken(jwt,
    new TokenValidationParameters
    {
        ValidIssuer = "me",
        ValidAudience = "you",
        IssuerSigningKey = new RsaSecurityKey(key.Rsa.ExportParameters(false))
    });</code></pre><h2>Deterministic vs. Probabilistic</h2><p>
Using the above handlers and descriptors, we can also prove the deterministic behavior of RSASSA-PKCS1-v1_5, and the probabilistic behavior of RSASSA-PSS, by simply calling the <code>CreateToken</code> method twice for each one.
The following unit tests prove this:
</p><pre><code class="language-csharp">[Fact]
public void WhenGeneratedWithDeterministicSignatureScheme_ExpectIdenticalJwts()
{
    descriptor.SigningCredentials = new SigningCredentials(key, "RS256");

    var token1 = handler.CreateToken(descriptor);
    var token2 = handler.CreateToken(descriptor);

    Assert.Equal(token1, token2);
}

[Fact]
public void WhenGeneratedWithProbabilisticSignatureScheme_ExpectDifferentJwts()
{
    descriptor.SigningCredentials = new SigningCredentials(key, "PS256");

    var token1 = handler.CreateToken(descriptor);
    var token2 = handler.CreateToken(descriptor);

    Assert.NotEqual(token1, token2);
}</code></pre><h2>Source Code and Test Runner <i class="fab fa-github"></i></h2><p>
You can find the full source from this article <a title="GitHub - PS256 JWT" href="https://github.com/scottbrady91/Blog-Example-Classes/tree/master/RsaPssJwtSigning" target="_blank">on GitHub</a>.
It’s a console app showing PS256 JWT creation and validation, and the two unit tests shown above.
</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>