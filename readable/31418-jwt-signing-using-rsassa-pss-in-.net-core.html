<!DOCTYPE html>
<html lang="en">
<head>
    <title>
JWT Signing using RSASSA-PSS in .NET Core -
linksfor.dev(s)
    </title>
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>JWT Signing using RSASSA-PSS in .NET Core</h1>
    <div class="col-lg-10">
<p>
As of <a href="https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/releases/tag/5.5.0">version 5.5</a>, Microsoft&#x2019;s IdentityModel library now supports the signing of JSON Web Tokens using the RSASSA-PSS (Probabilistic Signature Scheme) digital signature algorithm.
This is great news if you&#x2019;re looking to start building .NET Core systems that implement OpenID&#x2019;s Financial-grade API and Open Banking, where PS256 must be used for signing.
</p>
<p>
You can find the full list of support for various .NET targets on <a href="https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/wiki/Supported-Algorithms#rsa">GitHub</a>, but the exciting thing is that <strong>PS256, PS384, and PS512 are now supported on .NET Core</strong>.
</p>
<h2>RS256 vs. PS256</h2>
<p>
When deciding between two algorithms such as RS256 (<em>RSASSA-PKCS1-v1_5 using SHA-256</em>) and PS256 (<em>RSASSA-PSS using SHA-256 and MGF1 with SHA-256</em>), we would prefer to use PS256.
That&#x2019;s not to say RSASSA-PKCS1-v1_5 is broken, but rather that RSASSA-PSS simply has desirable features that the other does not, in the form of a probabilistic signature scheme and a security proof.
</p>
<p>
With RSASSA-PKCS1-v1_5 we&#x2019;re stuck with a deterministic signature, meaning the same two inputs (e.g. JWTs) would create the same signature.
With RSASSA-PSS, we get a probabilistic signature, meaning the same two inputs would create different signatures, thanks to the introduction of some random data, while still being verifiable by the same public key.
</p>
<p>
A probabilistic signature plus a verifiable security proof makes cryptographers much happier.
</p>
<p>
I also ran the two .NET implementations through BenchmarkDotNet but struggled to find any noticeable performance differences between them.
Signature length is also identical between the two.
</p>
<h2>PS256 in .NET Core</h2>
<p>
To get the right APIs we&#x2019;ll need <code>System.IdentityModel.Tokens.Jwt</code> version 5.5 (or greater).
This will also bring in the various <code>Microsoft.IdentityModel</code> libraries that we need:
</p>
<pre><code class="language-custom">install-package System.IdentityModel.Tokens.Jwt</code></pre>
<p>
We then need an RSA key to sign and validate tokens with.
<a href="https://tools.ietf.org/html/rfc7518#section-3.5">RFC 7518</a>, which defines PS256, enforces a key size of at least 2048 bits.
You could load a private key from an X509 certificate, but here we&#x2019;ll create one in code:
</p>
<pre><code class="language-csharp">var key = new RsaSecurityKey(RSA.Create(2048));</code></pre>
<h3>Token Creation</h3>
<p>
We can then new up our security token handler, a token descriptor, and then use the handler&#x2019;s <code>CreateEncodedJwt</code> method to create our JWT.
These APIs should be familiar if you have created JWTs before.
</p>
<pre><code class="language-csharp">var handler = new JwtSecurityTokenHandler();
var now = DateTime.UtcNow;

var descriptor = new SecurityTokenDescriptor
    {
        Issuer = &quot;me&quot;,
        Audience = &quot;you&quot;,
        IssuedAt = now,
        NotBefore = now,
        Expires = now.AddMinutes(5),
        Subject = new ClaimsIdentity(new List&lt;Claim&gt; {new Claim(&quot;sub&quot;, &quot;scott&quot;)}),
        SigningCredentials = new SigningCredentials(key, SecurityAlgorithms.RsaSsaPssSha256)
    };

var jwt = handler.CreateEncodedJwt(descriptor);</code></pre>
<h3>Token Validation</h3>
<p>
To validate our token, we use the same APIs as normal, calling <code>ValidateToken</code> on our security token handler.
This would be indistinguishable from validating a token signed using RS256:
</p>
<pre><code class="language-csharp">var claimsPrincipal = handler.ValidateToken(
    jwt,
    new TokenValidationParameters
    {
        ValidIssuer = &quot;me&quot;
        ValidAudience = &quot;you&quot;
        IssuerSigningKey = new RsaSecurityKey(key.Rsa.ExportParameters(false))
    },
    out SecurityToken parsedToken);</code></pre>
<h2>Deterministic vs. Probabilistic</h2>
<p>
Using the above handlers and descriptors, we can also prove the deterministic behavior of RSASSA-PKCS1-v1_5, and the probabilistic behavior of RSASSA-PSS, by simply calling the <code>CreateEncodedJwt</code> method twice for each one.
The following unit tests prove this:
</p>
<pre><code class="language-csharp">[Fact]
public void WhenGeneratedWithDeterministicSignatureScheme_ExpectIdenticalJwts()
{
    descriptor.SigningCredentials = new SigningCredentials(key, &quot;RS256&quot;);

    var token1 = handler.CreateEncodedJwt(descriptor);
    var token2 = handler.CreateEncodedJwt(descriptor);

    Assert.Equal(token1, token2);
}

[Fact]
public void WhenGeneratedWithProbabilisticSignatureScheme_ExpectDifferentJwts()
{
    descriptor.SigningCredentials = new SigningCredentials(key, &quot;PS256&quot;);

    var token1 = handler.CreateEncodedJwt(descriptor);
    var token2 = handler.CreateEncodedJwt(descriptor);

    Assert.NotEqual(token1, token2);
}</code></pre>
<h2>Source Code and Test Runner <i class="fab fa-github"></i></h2>
<p>
You can find the full source from this article <a href="https://github.com/scottbrady91/Blog-Example-Classes/tree/master/RsaPssJwtSigning">on GitHub</a>.
It&#x2019;s a console app showing PS256 JWT creation and validation, and the two unit tests shown above.
</p>
</div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>