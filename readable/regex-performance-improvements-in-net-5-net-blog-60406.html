<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Regex Performance Improvements in .NET 5 | .NET Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Regex Performance Improvements in .NET 5 | .NET Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Stephen ToubFollow"/>
    <meta property="og:description" content="The System.Text.RegularExpressions namespace has been in .NET for years, all the way back to .NET Framework 1.1. It&#x2019;s used in hundreds of places within the .NET implementation itself, and directly by thousands upon thousands of applications. Across all of that, it represents a significant source of CPU consumption."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Regex Performance Improvements in .NET 5 | .NET Blog</title>
<div class="readable">
        <h1>Regex Performance Improvements in .NET 5 | .NET Blog</h1>
            <div>by Stephen ToubFollow</div>
            <div>Reading time: 50-64 minutes</div>
        <div>Posted here: 05 Apr 2020</div>
        <p><a href="https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/">https://devblogs.microsoft.com/dotnet/regex-performance-improvements-in-net-5/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://secure.gravatar.com/avatar/49e67eaea0533a547f3489aa03707bbb?s=58&amp;d=mm&amp;r=g" width="58" height="58" alt="Avatar"></p></div></div></div><p>April 2nd, 2020</p><p>The <code>System.Text.RegularExpressions</code> namespace has been in .NET for years, all the way back to .NET Framework 1.1. It’s used in hundreds of places within the .NET implementation itself, and directly by thousands upon thousands of applications. Across all of that, it represents a significant source of CPU consumption.</p><p>However, from a performance perspective, <code>Regex</code> hasn’t received a lot of love in the intervening years. Its caching strategy was changed in .NET Framework 2.0 in the 2006 timeframe. .NET Core 2.0 saw the return of the implementation behind <code>RegexOptions.Compiled</code> (in .NET Core 1.x the <code>RegexOptions.Compiled</code> option was a nop). .NET Core 3.0 benefited from some of <code>Regex</code>‘s internals being updated to utilize <code>Span&lt;T&gt;</code> to improve memory utilization in certain scenarios. And along the way, a few very welcome community contributions have improved targeted areas, such as with <a href="https://github.com/dotnet/corefx/pull/32899" target="_blank">dotnet/corefx#32899</a>, which reduced accesses to <code>CultureInfo.CurrentCulture</code> when executing a <code>RegexOptions.Compiled | RegexOptions.IgnoreCase</code> expression. But beyond that, the implementation has largely been what it was 15 years ago.</p><p>For .NET 5 (<a href="https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-2/">Preview 2</a> of which was released this week), we’ve invested in some significant improvements to the <code>Regex</code> engine. On many of the expressions we’ve tried, these changes routinely result in throughput improvements of 3-6x, and in some cases, much more. In this post, I’ll walk through some of the myriad of changes that have gone into <code>System.Text.RegularExpressions</code> in .NET 5. The changes have had measurable impact on our own uses, and we hope these improvements will result in measurable wins in your libraries and apps, as well.</p><h2>Regex Internals</h2><p>To understand some of the changes made, it’s helpful to understand some <code>Regex</code> internals.</p><p>The <code>Regex</code> constructor does all the work to take the regular expression pattern and prepare to match inputs against it:</p><ul><li><p><strong><code>RegexParser</code></strong>. The pattern is fed into the internal <code>RegexParser</code> type, which understands the regular expression syntax and parses it into a node tree. For example, the expression <code>a|bcd</code> gets translated into an “alternation” <code>RegexNode</code> with two child nodes, one that represents the single character <code>a</code> and one that represents the “multi” <code>bcd</code>. The parser also does optimizations on the tree, translating one tree into another equivalent one that provides for a more efficient representation and/or that can be executed more efficiently.</p></li><li><p><strong><code>RegexWriter</code></strong>. The node tree isn’t an ideal representation for performing a match, so the output of the parser is fed to the internal <code>RegexWriter</code> class, which writes out a compact series of opcodes that represent the instructions for performing a match. The name of this type is “writer” because it “writes” out the opcodes; other engines often refer to this as “compilation”, but the .NET engine uses different terminology because it reserves the “compilation” term for optional compilation to MSIL.</p></li><li><p><strong><code>RegexCompiler</code></strong> <em>(optional)</em>. If the <code>RegexOptions.Compiled</code> option isn’t specified, then the opcodes output by <code>RegexWriter</code> are used by the internal <code>RegexInterpreter</code> class later at match time to interpret/execute the instructions to perform the match, and nothing further is required during <code>Regex</code> construction. If, however, <code>RegexOptions.Compiled</code> is specified, then the constructor takes the previously output assets and feeds them into the internal <code>RegexCompiler</code> class. <code>RegexCompiler</code> then uses reflection emit to generate MSIL that represents the work the interpreter would do, but specialized for this specific expression. For example, when matching against the character ‘c’ in the pattern, the interpreter would need to load the comparison value from a variable, whereas the compiler hardcodes that ‘c’ as a constant in the generated IL.</p></li></ul><p>Once the <code>Regex</code> has been constructed, it can be used for matching, via instance methods like <code>IsMatch</code>, <code>Match</code>, <code>Matches</code>, <code>Replace</code>, and <code>Split</code> (<code>Match</code> returns a <code>Match</code> object which then exposes a <code>NextMatch</code> method that enables iterating through the matches, lazily evaluated). Those operations end up in a “scan” loop (some other engines refer to it as a “transmission” loop) that at its core essentially does the following:</p><pre><code><span>while</span><span> </span><span>(</span><span>FindFirstChar</span><span>())</span><span>
</span><span>{</span><span>
    </span><span>Go</span><span>();</span><span>
    </span><span>if</span><span> </span><span>(</span><span>_match </span><span>!=</span><span> </span><span>null</span><span>)</span><span>
        </span><span>return</span><span> _match</span><span>;</span><span>
    _pos</span><span>++;</span><span>
</span><span>}</span><span>
</span><span>return</span><span> </span><span>null</span><span>;</span></code></pre><p>Here, <code>_pos</code> is the current position we’re at in the input. The virtual <code>FindFirstChar</code> starts at <code>_pos</code> and looks for the first place in the input text that the regular expression could possibly match; this is not executing the full engine, but rather doing as efficient as possible a search to find the location at which it would be worthwhile running the full engine. The better a job <code>FindFirstChar</code> can do at minimizing false positives and the faster it can find valid locations, the faster the expression will be processed. If it doesn’t find a good starting point, nothing will possibly match, so we’re done. If it does find a good starting point, it updates <code>_pos</code> and then it executes the engine at that found position, by invoking the virtual <code>Go</code>. If <code>Go</code> doesn’t find a match, we bump the current position and start over, but if <code>Go</code> does, it stores the match information and that data is returned. Obviously, the faster we can execute <code>Go</code>, too, the better.</p><p>All of this logic is in the public <code>RegexRunner</code> base class. <code>RegexInterpreter</code> derives from <code>RegexRunner</code> and overrides both <code>FindFirstChar</code> and <code>Go</code> with implementations that interpret the regular expression, as represented by the opcodes generated by <code>RegexWriter</code>. <code>RegexCompiler</code> uses <code>DynamicMethod</code>s to generate two methods, one for <code>FindFirstChar</code> and one for <code>Go</code>; delegates are created from these and are invoked from another type derived from <code>RegexRunner</code>.</p><h2>.NET 5 Improvements</h2><p>For the rest of this post, we’ll walk through various optimizations that have been made for <code>Regex</code> in .NET 5. This is not an exhaustive list, but it highlights some of the most impactful changes.</p><h3>CharInClass</h3><p>Regular expressions support “character classes”, which define the set of characters that an input character should or should not match in order for that position to be considered a match. Character classes are delineated with square brackets. Here are some examples:</p><ul><li><p><code>[abc]</code>. Matches <code>'a'</code>, <code>'b'</code>, or <code>'c'</code>.</p></li><li><p><code>[^\n]</code>. Matches anything <em>other</em> than a line feed character. (Unless <code>RegexOptions.Singleline</code> is specified, this is the exact character class you get from using <code>.</code> in an expression.)</p></li><li><p><code>[a-cx-z]</code>. Matches <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, <code>'x'</code>, <code>'y'</code>, or <code>'z'</code>.</p></li><li><p><code>[\d\s\p{IsGreek}]</code>. Matches any Unicode digit or white-space or Greek character. (This is an interesting difference from most other regular expression engines. For example, in other engines, often <code>\d</code> by default maps to <code>[0-9]</code> and you can opt-in to it instead mapping to all Unicode digits, which is <code>[\p{Nd}]</code>, whereas in .NET you get the latter by default and using <code>RegexOptions.ECMAScript</code> opts-out to the former.)</p></li></ul><p>When a pattern containing a character class is passed to the <code>Regex</code> constructor, part of the <code>RegexParser</code>‘s job is to translate that character class into something it can more easily query at run-time. The parser uses the internal <code>RegexCharClass</code> type to parse the character class and extract essentially three things (there’s a bit more, but this is sufficient for this discussion):</p><ol><li><p>Whether the pattern is negated</p></li><li><p>The sorted set of ranges of matching characters</p></li><li><p>The sorted set of Unicode categories of matching characters</p></li></ol><p>This is all implementation detail, but that information is then persisted in a string which can be passed to the protected <a href="https://docs.microsoft.com/dotnet/api/system.text.regularexpressions.regexrunner.charinclass?view=netcore-3.1" target="_blank"><code>RegexRunner.CharInClass</code></a> method in order to determine whether a given <code>Char</code> is contained in the character class.</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-ctor-char-class.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-ctor-char-class.png" alt="Transformed character class string" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-ctor-char-class.png 410w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-ctor-char-class-300x74.png 300w" sizes="(max-width: 410px) 100vw, 410px"> </a></p><p>Prior to .NET 5, every single time a character needed to be matched against a character class, it would call that <code>CharInClass</code> method. <code>CharInClass</code> then does a binary search of the ranges to determine whether the specified character is stored in one, and if it’s not, it gets the Unicode category of the target character and does a linear search of the Unicode categories to see if it’s a match. So, for an expression like <code>^\d*$</code> (which asserts that it’s at the start of the input, then matches any number of Unicode digits, and then asserts it’s at the end of the input), given an input of 1000 digits, this will make 1000 calls to <code>CharInClass</code>. That adds up.</p><p>In .NET 5, we’re now much smarter about how we do this, in particular when <code>RegexOptions.Compiled</code> is used, which in general is used any time a developer cares a lot about the throughput of a <code>Regex</code>. One solution would be, for every character class, to maintain a lookup table that maps an input character to a yes/no decision about whether it’s in the class or not. While we could do that, a <code>System.Char</code> is a 16-bit value, which means, at one bit per character, we’d need an 8K lookup table for every character class, and that also adds up. Instead, we first try to handle some common cases using existing functionality in the platform or otherwise simple math that makes matching fast. For example, for <code>\d</code>, instead of generating a call to <code>RegexRunner.CharInClass(ch, charClassString)</code>, we now simply generate a call to <code>char.IsDigit(ch)</code>; <code>IsDigit</code> is already optimized with lookup tables, gets inlined, and performs very well. Similarly for <code>\s</code>, we now generate a call to <code>char.IsWhitespace(ch)</code>. For simple character classes that contain just a few characters, we’ll just generate the direct comparisons, e.g. for <code>[az]</code> we’ll generate the equivalent of <code>(ch == 'a') | (ch == 'z')</code>. And for simple character classes that contain just a single range, we’ll generate the check with a single subtraction and comparison, e.g. <code>[a-z]</code> results in <code>(uint)ch - 'a' &lt; 26</code>, and <code>[^0-9]</code> results in <code>!((uint)c - '0' &lt; 10)</code>. We’ll also special-case other common specifications; for example, if the entire character class is a single Unicode category, we’ll just generate a call to <code>char.GetUnicodeInfo</code> (which also has a fast lookup table) and do the comparison, e.g. <code>[\p{Lu}]</code> becomes <code>char.GetUnicodeInfo(c) == UnicodeCategory.UppercaseLetter</code>.</p><p>Of course, while that covers a large number of common cases, it certainly doesn’t cover them all. And just because we don’t want to generate an 8K lookup table for every character class doesn’t mean we can’t generate a lookup table at all. Instead, if we don’t hit one of these common cases, we do generate a lookup table, but just for ASCII, which only requires 16 bytes (128 bits), and which tends to be a very good compromise given typical inputs in regex-based scenarios. Since we’re generating methods using <code>DynamicMethod</code>, we don’t easily have the ability to store additional data in the static data portion of the assembly, but what we can do is utilize constant strings as a data store; MSIL has opcodes for loading constant strings, and reflection emit has good support for generating such instructions. So, for each lookup table, we can simply create the 8-character string we need, fill it with the opaque bitmap data, and spit that out with <code>ldstr</code> in the IL. We can then treat it as we would any other bitmap, e.g. to determine whether a given char <code>ch</code> matches, we generate the equivalent of this:</p><pre><code><span>bool</span><span> result </span><span>=</span><span> ch </span><span>&lt;</span><span> </span><span>128</span><span> </span><span>?</span><span> </span><span>(</span><span>lookup</span><span>[</span><span>c </span><span>&gt;&gt;</span><span> </span><span>4</span><span>]</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>(</span><span>c </span><span>&amp;</span><span> </span><span>0xF</span><span>)))</span><span> </span><span>!=</span><span> </span><span>0</span><span> </span><span>:</span><span> </span><span>NonAsciiFallback</span><span>;</span></code></pre><p>In words, we use the top three bits of the character to select the 0th through 7th char in the lookup table string, and then use the bottom four bits as an index into the 16-bit value at that location; if it’s a 1, we matched, if it’s not, we didn’t. For characters then <code>&gt;= 128</code>, we need a fallback, and that fallback can be a variety of things based on some analysis performed on the character class. Worst case, the fallback is just the call to <code>RegexRunner.CharInClass</code> we would have otherwise made, but we can often do better. For example, it’s common that we can tell from the input pattern that all possible matches will be <code>&lt; 128</code>, in which case we don’t need a fallback at all, e.g. for the character class <code>[0-9a-fA-F]</code> (aka hexadecimal), we’ll instead generate the equivalent of:</p><pre><code><span>bool</span><span> result </span><span>=</span><span> ch </span><span>&lt;</span><span> </span><span>128</span><span> </span><span>&amp;&amp;</span><span> </span><span>(</span><span>lookup</span><span>[</span><span>c </span><span>&gt;&gt;</span><span> </span><span>4</span><span>]</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>(</span><span>c </span><span>&amp;</span><span> </span><span>0xF</span><span>)))</span><span> </span><span>!=</span><span> </span><span>0</span><span>;</span></code></pre><p>Conversely, we may be able to determine that every character above 127 is going to match. For example, the character class <code>[^aeiou]</code> (everything other than ASCII lowercase vowels) will instead result in code equivalent to:</p><pre><code><span>bool</span><span> result </span><span>=</span><span> ch </span><span>&gt;=</span><span> </span><span>128</span><span> </span><span>||</span><span> </span><span>(</span><span>lookup</span><span>[</span><span>c </span><span>&gt;&gt;</span><span> </span><span>4</span><span>]</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>(</span><span>c </span><span>&amp;</span><span> </span><span>0xF</span><span>)))</span><span> </span><span>!=</span><span> </span><span>0</span><span>;</span></code></pre><p>And so on.</p><p>All of the above is for <code>RegexOptions.Compiled</code>, but interpreted expressions aren’t left out in the cold. For interpreted expressions, we currently generate a similar lookup table, but we do so lazily, populating the table for a given input character the first time we see it, and then storing that answer for all future evaluations of that character against that character class. (We might revisit how we do this, but this is how things exist as of .NET 5 Preview 2.)</p><p>The net result of this can be significant throughput gains on expressions that evaluate character classes frequently. For example, here’s a microbenchmark that’s matching ASCII letters and digits against an input with 62 such values:</p><pre><code><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>

</span><span>public</span><span> </span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[]</span><span> args</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>BenchmarkSwitcher</span><span>.</span><span>FromAssemblies</span><span>(</span><span>new</span><span>[]</span><span> </span><span>{</span><span> </span><span>typeof</span><span>(</span><span>Program</span><span>).</span><span>Assembly</span><span> </span><span>}).</span><span>Run</span><span>(</span><span>args</span><span>);</span><span>

    </span><span>private</span><span> </span><span>Regex</span><span> _regex </span><span>=</span><span> </span><span>new</span><span> </span><span>Regex</span><span>(</span><span>"[a-zA-Z0-9]*"</span><span>,</span><span> </span><span>RegexOptions</span><span>.</span><span>Compiled</span><span>);</span><span>
    
    </span><span>[</span><span>Benchmark</span><span>]</span><span> </span><span>public</span><span> </span><span>bool</span><span> </span><span>IsMatch</span><span>()</span><span> </span><span>=&gt;</span><span> _regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"abcdefghijklmnopqrstuvwxyz123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span>);</span><span>
</span><span>}</span></code></pre><p>And here’s my project file:</p><pre><code><span>&lt;project</span><span> </span><span>Sdk</span><span>=</span><span>"Microsoft.NET.Sdk"</span><span>&gt;</span><span>
    </span><span>&lt;propertygroup&gt;</span><span>
        </span><span>&lt;langversion&gt;</span><span>preview</span><span>&lt;/langversion&gt;</span><span>
        </span><span>&lt;outputtype&gt;</span><span>Exe</span><span>&lt;/outputtype&gt;</span><span>
        </span><span>&lt;targetframeworks&gt;</span><span>netcoreapp5.0;netcoreapp3.1</span><span>&lt;/targetframeworks&gt;</span><span>
    </span><span>&lt;/propertygroup&gt;</span><span>
    
    </span><span>&lt;itemgroup&gt;</span><span>
        </span><span>&lt;packagereference</span><span> </span><span>Include</span><span>=</span><span>"benchmarkdotnet"</span><span> </span><span>Version</span><span>=</span><span>"0.12.0.1229"</span><span>&gt;&lt;/packagereference&gt;</span><span>
    </span><span>&lt;/itemgroup&gt;</span><span>
</span><span>&lt;/project&gt;</span></code></pre><p>On my machine, I have two directories, one containing .NET Core 3.1 and one containing a build of .NET 5 (what’s labeled here as <code>master</code>, since it’s a build of the <code>master</code> branch from <code>dotnet/runtime</code>). When I execute the above with:</p><pre><code><span>dotnet run </span><span>-</span><span>c </span><span>Release</span><span> </span><span>-</span><span>f netcoreapp3</span><span>.</span><span>1</span><span> </span><span>--</span><span>filter </span><span>**</span><span> </span><span>--</span><span>corerun d</span><span>:</span><span>\coreclrtest\netcore31\corerun</span><span>.</span><span>exe d</span><span>:</span><span>\coreclrtest\master\corerun</span><span>.</span><span>exe</span></code></pre><p>to run the benchmark against both builds, I get these results:</p><div><table><thead><tr><th>Method</th><th>Toolchain</th><th>Mean</th><th>Error</th><th>StdDev</th><th>Ratio</th></tr></thead><tbody><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>102.3 ns</td><td>1.33 ns</td><td>1.24 ns</td><td>0.17</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>585.7 ns</td><td>2.80 ns</td><td>2.49 ns</td><td>1.00</td></tr></tbody></table></div><h3>Codegen Like a Dev Might Write</h3><p>As mentioned, when <code>RegexOptions.Compiled</code> is used with a <code>Regex</code>, we use reflection emit to generate two methods for it, one to implement <code>FindFirstChar</code> and one to implement <code>Go</code>. To support the possibility of backtracking, <code>Go</code> ends up containing a lot of code that often isn’t necessary. The code is also generated in a way that often includes unnecessary field reads and writes, that incurs bounds checking the JIT is unable to eliminate, and so on. In .NET 5, we’ve improved the code generated for many expressions.</p><p>Consider the expression <code>@"a\sb"</code>, which matches an <code>'a'</code>, any Unicode whitespace, and a <code>'b'</code>. Previously, decompiling the IL emitted for <code>Go</code> would look something like this:</p><pre><code><span>public</span><span> </span><span>override</span><span> </span><span>void</span><span> </span><span>Go</span><span>()</span><span>
</span><span>{</span><span>
    </span><span>string</span><span> runtext </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtext</span><span>;</span><span>
    </span><span>int</span><span> runtextstart </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtextstart</span><span>;</span><span>
    </span><span>int</span><span> runtextbeg </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtextbeg</span><span>;</span><span>
    </span><span>int</span><span> runtextend </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtextend</span><span>;</span><span>
    </span><span>int</span><span> num </span><span>=</span><span> runtextpos</span><span>;</span><span>
    </span><span>int</span><span>[]</span><span> runtrack </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtrack</span><span>;</span><span>
    </span><span>int</span><span> runtrackpos </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtrackpos</span><span>;</span><span>
    </span><span>int</span><span>[]</span><span> runstack </span><span>=</span><span> </span><span>base</span><span>.</span><span>runstack</span><span>;</span><span>
    </span><span>int</span><span> runstackpos </span><span>=</span><span> </span><span>base</span><span>.</span><span>runstackpos</span><span>;</span><span>

    </span><span>CheckTimeout</span><span>();</span><span>
    runtrack</span><span>[--</span><span>runtrackpos</span><span>]</span><span> </span><span>=</span><span> num</span><span>;</span><span>
    runtrack</span><span>[--</span><span>runtrackpos</span><span>]</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>

    </span><span>CheckTimeout</span><span>();</span><span>
    runstack</span><span>[--</span><span>runstackpos</span><span>]</span><span> </span><span>=</span><span> num</span><span>;</span><span>
    runtrack</span><span>[--</span><span>runtrackpos</span><span>]</span><span> </span><span>=</span><span> </span><span>1</span><span>;</span><span>

    </span><span>CheckTimeout</span><span>();</span><span>
    </span><span>if</span><span> </span><span>(</span><span>num </span><span>&lt;</span><span> runtextend </span><span>&amp;&amp;</span><span> runtext</span><span>[</span><span>num</span><span>++]</span><span> </span><span>==</span><span> </span><span>'a'</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>CheckTimeout</span><span>();</span><span>
        </span><span>if</span><span> </span><span>(</span><span>num </span><span>&lt;</span><span> runtextend </span><span>&amp;&amp;</span><span> </span><span>RegexRunner</span><span>.</span><span>CharInClass</span><span>(</span><span>runtext</span><span>[</span><span>num</span><span>++],</span><span> </span><span>"\0\0\u0001d"</span><span>))</span><span>
        </span><span>{</span><span>
            </span><span>CheckTimeout</span><span>();</span><span>
            </span><span>if</span><span> </span><span>(</span><span>num </span><span>&lt;</span><span> runtextend </span><span>&amp;&amp;</span><span> runtext</span><span>[</span><span>num</span><span>++]</span><span> </span><span>==</span><span> </span><span>'b'</span><span>)</span><span>
            </span><span>{</span><span>
                </span><span>CheckTimeout</span><span>();</span><span>
                </span><span>int</span><span> num2 </span><span>=</span><span> runstack</span><span>[</span><span>runstackpos</span><span>++];</span><span>

                </span><span>Capture</span><span>(</span><span>0</span><span>,</span><span> num2</span><span>,</span><span> num</span><span>);</span><span>
                runtrack</span><span>[--</span><span>runtrackpos</span><span>]</span><span> </span><span>=</span><span> num2</span><span>;</span><span>
                runtrack</span><span>[--</span><span>runtrackpos</span><span>]</span><span> </span><span>=</span><span> </span><span>2</span><span>;</span><span>
                </span><span>goto</span><span> IL_0131</span><span>;</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>while</span><span> </span><span>(</span><span>true</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>base</span><span>.</span><span>runtrackpos </span><span>=</span><span> runtrackpos</span><span>;</span><span>
        </span><span>base</span><span>.</span><span>runstackpos </span><span>=</span><span> runstackpos</span><span>;</span><span>
        </span><span>EnsureStorage</span><span>();</span><span>
        runtrackpos </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtrackpos</span><span>;</span><span>
        runstackpos </span><span>=</span><span> </span><span>base</span><span>.</span><span>runstackpos</span><span>;</span><span>
        runtrack </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtrack</span><span>;</span><span>
        runstack </span><span>=</span><span> </span><span>base</span><span>.</span><span>runstack</span><span>;</span><span>

        </span><span>switch</span><span> </span><span>(</span><span>runtrack</span><span>[</span><span>runtrackpos</span><span>++])</span><span>
        </span><span>{</span><span>
            </span><span>case</span><span> </span><span>1</span><span>:</span><span>
                </span><span>CheckTimeout</span><span>();</span><span>
                runstackpos</span><span>++;</span><span>
                </span><span>continue</span><span>;</span><span>

            </span><span>case</span><span> </span><span>2</span><span>:</span><span>
                </span><span>CheckTimeout</span><span>();</span><span>
                runstack</span><span>[--</span><span>runstackpos</span><span>]</span><span> </span><span>=</span><span> runtrack</span><span>[</span><span>runtrackpos</span><span>++];</span><span>
                </span><span>Uncapture</span><span>();</span><span>
                </span><span>continue</span><span>;</span><span>
        </span><span>}</span><span>

        </span><span>break</span><span>;</span><span>
    </span><span>}</span><span>

    </span><span>CheckTimeout</span><span>();</span><span>
    num </span><span>=</span><span> runtrack</span><span>[</span><span>runtrackpos</span><span>++];</span><span>
    </span><span>goto</span><span> IL_0131</span><span>;</span><span>

    IL_0131</span><span>:</span><span>
    </span><span>CheckTimeout</span><span>();</span><span>
    runtextpos </span><span>=</span><span> num</span><span>;</span><span>
</span><span>}</span></code></pre><p>There’s a whole lot of stuff there, and it requires some squinting and searching to see the core of the implementation as just a few lines in the middle of the method. Now in .NET 5, that same expression results in this code being generated:</p><pre><code><span>protected</span><span> </span><span>override</span><span> </span><span>void</span><span> </span><span>Go</span><span>()</span><span>
</span><span>{</span><span>
    </span><span>string</span><span> runtext </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtext</span><span>;</span><span>
    </span><span>int</span><span> runtextend </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtextend</span><span>;</span><span>
    </span><span>int</span><span> runtextpos</span><span>;</span><span>
    </span><span>int</span><span> start </span><span>=</span><span> runtextpos </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtextpos</span><span>;</span><span>
    </span><span>ReadOnlySpan</span><span>&lt;char&gt;</span><span> readOnlySpan </span><span>=</span><span> runtext</span><span>.</span><span>AsSpan</span><span>(</span><span>runtextpos</span><span>,</span><span> runtextend </span><span>-</span><span> runtextpos</span><span>);</span><span>
    </span><span>if</span><span> </span><span>(</span><span>0u</span><span> </span><span>&lt;</span><span> </span><span>(</span><span>uint</span><span>)</span><span>readOnlySpan</span><span>.</span><span>Length</span><span> </span><span>&amp;&amp;</span><span> readOnlySpan</span><span>[</span><span>0</span><span>]</span><span> </span><span>==</span><span> </span><span>'a'</span><span> </span><span>&amp;&amp;</span><span>
        </span><span>1u</span><span> </span><span>&lt;</span><span> </span><span>(</span><span>uint</span><span>)</span><span>readOnlySpan</span><span>.</span><span>Length</span><span> </span><span>&amp;&amp;</span><span> </span><span>char</span><span>.</span><span>IsWhiteSpace</span><span>(</span><span>readOnlySpan</span><span>[</span><span>1</span><span>])</span><span> </span><span>&amp;&amp;</span><span>
        </span><span>2u</span><span> </span><span>&lt;</span><span> </span><span>(</span><span>uint</span><span>)</span><span>readOnlySpan</span><span>.</span><span>Length</span><span> </span><span>&amp;&amp;</span><span> readOnlySpan</span><span>[</span><span>2</span><span>]</span><span> </span><span>==</span><span> </span><span>'b'</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>Capture</span><span>(</span><span>0</span><span>,</span><span> start</span><span>,</span><span> </span><span>base</span><span>.</span><span>runtextpos </span><span>=</span><span> runtextpos </span><span>+</span><span> </span><span>3</span><span>);</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>If you’re anything like me, you look at the first version and your eyes glaze over, but if you look at the second, you can actually read and understand what it’s doing. Beyond being understandable and more easily debugged, it’s also less code to be executed, does better with bounds check eliminations, reads and writes fields and arrays less, and so on. The net result of this is it also executes much faster. (There’s some further possibility for improvements here, such as removing two length checks, potentially reordering some of the checks, but overall it’s a vast improvement over what was there before.)</p><h3>Span-based Searching with Vectorized Methods</h3><p>Regular expressions are all about searching for stuff. As a result, we often find ourselves running loops looking for various things. For example, consider the expression <code>hello.*world</code>. Previously if you were to decompile the code we generate in the <code>Go</code> method for matching the <code>.*</code>, it would look something like this:</p><pre><code><span>while</span><span> </span><span>(--</span><span>num3 </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span>
</span><span>{</span><span>
    </span><span>if</span><span> </span><span>(</span><span>runtext</span><span>[</span><span>num</span><span>++]</span><span> </span><span>==</span><span> </span><span>'\n'</span><span>)</span><span>
    </span><span>{</span><span>
        num</span><span>--;</span><span>
        </span><span>break</span><span>;</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>In other words, we’re manually iterating through the input text string looking character by character for <code>\n</code> (remember that by default a <code>.</code> means “anything other than <code>\n</code>“, so <code>.*</code> means “match everything until you find <code>\n</code>“). But, .NET has long had methods that do exactly such searches, like <code>IndexOf</code>, and as of recent releases, <code>IndexOf</code> is vectorized such that it can compare multiple characters at the same time rather than just looking at each individually. Now in .NET 5, instead of generating code like the above, we end up with code like this:</p><pre><code><span>num2 </span><span>=</span><span> runtext</span><span>.</span><span>AsSpan</span><span>(</span><span>runtextpos</span><span>,</span><span> num</span><span>).</span><span>IndexOf</span><span>(</span><span>'\n'</span><span>);</span></code></pre><p>Using <code>IndexOf</code> rather than generating our own loop then means that such searches in <code>Regex</code> are implicitly vectorized, and any improvements to such implementations also accrue here. It also means the generated code is simpler. The impact of this can be seen with a benchmark like this:</p><pre><code><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>

</span><span>public</span><span> </span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[]</span><span> args</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>BenchmarkSwitcher</span><span>.</span><span>FromAssemblies</span><span>(</span><span>new</span><span>[]</span><span> </span><span>{</span><span> </span><span>typeof</span><span>(</span><span>Program</span><span>).</span><span>Assembly</span><span> </span><span>}).</span><span>Run</span><span>(</span><span>args</span><span>);</span><span>

    </span><span>private</span><span> </span><span>Regex</span><span> _regex </span><span>=</span><span> </span><span>new</span><span> </span><span>Regex</span><span>(</span><span>"hello.*world"</span><span>,</span><span> </span><span>RegexOptions</span><span>.</span><span>Compiled</span><span>);</span><span>
    
    </span><span>[</span><span>Benchmark</span><span>]</span><span> </span><span>public</span><span> </span><span>bool</span><span> </span><span>IsMatch</span><span>()</span><span> </span><span>=&gt;</span><span> _regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"hello.  this is a test to see if it's able to find something more quickly in the world."</span><span>);</span><span>
</span><span>}</span></code></pre><p>Even for an input string that’s not particularly large, this has a measurable impact:</p><div><table><thead><tr><th>Method</th><th>Toolchain</th><th>Mean</th><th>Error</th><th>StdDev</th><th>Ratio</th></tr></thead><tbody><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>71.03 ns</td><td>0.308 ns</td><td>0.257 ns</td><td>0.47</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>149.80 ns</td><td>0.913 ns</td><td>0.809 ns</td><td>1.00</td></tr></tbody></table></div><p><code>IndexOfAny</code> also ends up being a significant work-horse in .NET 5’s implementation, especially for <code>FindFirstChar</code> implementations. One of the existing optimizations the .NET <code>Regex</code> implementation employs is an analysis for what are all of the possible characters that could start an expression; that produces a character class, which <code>FindFirstChar</code> then uses to generate a search for the next location that could start a match. This can be seen by looking at a decompiled version of the generated code for the expression <code>([ab]cd|ef[g-i])jklm</code>. A valid match to this expression can begin with only <code>'a'</code>, <code>'b'</code>, or <code>'e'</code>, and so the optimizer generates a character class <code>[abe]</code> which <code>FindFirstChar</code> then uses:</p><pre><code><span>public</span><span> </span><span>override</span><span> </span><span>bool</span><span> </span><span>FindFirstChar</span><span>()</span><span>
</span><span>{</span><span>
    </span><span>int</span><span> num </span><span>=</span><span> runtextpos</span><span>;</span><span>
    </span><span>string</span><span> runtext </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtext</span><span>;</span><span>
    </span><span>int</span><span> num2 </span><span>=</span><span> runtextend </span><span>-</span><span> num</span><span>;</span><span>
    </span><span>if</span><span> </span><span>(</span><span>num2 </span><span>&gt;</span><span> </span><span>0</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>int</span><span> result</span><span>;</span><span>
        </span><span>while</span><span> </span><span>(</span><span>true</span><span>)</span><span>
        </span><span>{</span><span>
            num2</span><span>--;</span><span>
            </span><span>if</span><span> </span><span>(!</span><span>RegexRunner</span><span>.</span><span>CharInClass</span><span>(</span><span>runtext</span><span>[</span><span>num</span><span>++],</span><span> </span><span>"\0\u0004\0acef"</span><span>))</span><span>
            </span><span>{</span><span>
                </span><span>if</span><span> </span><span>(</span><span>num2 </span><span>&lt;=</span><span> </span><span>0</span><span>)</span><span>
                </span><span>{</span><span>
                    result </span><span>=</span><span> </span><span>0</span><span>;</span><span>
                    </span><span>break</span><span>;</span><span>
                </span><span>}</span><span>
                </span><span>continue</span><span>;</span><span>
            </span><span>}</span><span>
            num</span><span>--;</span><span>
            result </span><span>=</span><span> </span><span>1</span><span>;</span><span>
            </span><span>break</span><span>;</span><span>
        </span><span>}</span><span>
        runtextpos </span><span>=</span><span> num</span><span>;</span><span>
        </span><span>return</span><span> </span><span>(</span><span>byte</span><span>)</span><span>result </span><span>!=</span><span> </span><span>0</span><span>;</span><span>
    </span><span>}</span><span>
    </span><span>return</span><span> </span><span>false</span><span>;</span><span>
</span><span>}</span></code></pre><p>A few things to note here:</p><ul><li><p>We can see each character is evaluated via <code>CharInClass</code>, as discussed earlier. And we can see the string passed to <code>CharInClass</code> is the generated internal and searchable representation of that class (the first character says there’s no negation, the second character says there are four characters used to represent ranges, the third character says there are no Unicode categories, and then the next four characters represent two ranges, with an inclusive lower-bound and an exclusive upper-bound).</p></li><li><p>We can see that we evaluate each character individually, rather than being able to evaluate multiple characters together.</p></li><li><p>We only look at the first character, and if it’s a match, we exit out to allow the engine to execute in full for <code>Go</code>.</p></li></ul><p>In .NET 5 Preview 2, we instead now generate this:</p><pre><code><span>protected</span><span> </span><span>override</span><span> </span><span>bool</span><span> </span><span>FindFirstChar</span><span>()</span><span>
</span><span>{</span><span>
    </span><span>int</span><span> runtextpos </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtextpos</span><span>;</span><span>
    </span><span>int</span><span> runtextend </span><span>=</span><span> </span><span>base</span><span>.</span><span>runtextend</span><span>;</span><span>
    </span><span>if</span><span> </span><span>(</span><span>runtextpos </span><span>&lt;=</span><span> runtextend </span><span>-</span><span> </span><span>7</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>ReadOnlySpan</span><span>&lt;char&gt;</span><span> readOnlySpan </span><span>=</span><span> runtext</span><span>.</span><span>AsSpan</span><span>(</span><span>runtextpos</span><span>,</span><span> runtextend </span><span>-</span><span> runtextpos</span><span>);</span><span>
        </span><span>for</span><span> </span><span>(</span><span>int</span><span> num </span><span>=</span><span> </span><span>0</span><span>;</span><span> num </span><span>&lt;</span><span> readOnlySpan</span><span>.</span><span>Length</span><span> </span><span>-</span><span> </span><span>2</span><span>;</span><span> num</span><span>++)</span><span>
        </span><span>{</span><span>
            </span><span>int</span><span> num2 </span><span>=</span><span> readOnlySpan</span><span>.</span><span>Slice</span><span>(</span><span>num</span><span>).</span><span>IndexOfAny</span><span>(</span><span>'a'</span><span>,</span><span> </span><span>'b'</span><span>,</span><span> </span><span>'e'</span><span>);</span><span>
            num </span><span>=</span><span> num2 </span><span>+</span><span> num</span><span>;</span><span>
            </span><span>if</span><span> </span><span>(</span><span>num2 </span><span>&lt;</span><span> </span><span>0</span><span> </span><span>||</span><span> readOnlySpan</span><span>.</span><span>Length</span><span> </span><span>-</span><span> </span><span>2</span><span> </span><span>&lt;=</span><span> num</span><span>)</span><span>
            </span><span>{</span><span>
                </span><span>break</span><span>;</span><span>
            </span><span>}</span><span>

            </span><span>int</span><span> num3 </span><span>=</span><span> readOnlySpan</span><span>[</span><span>num </span><span>+</span><span> </span><span>1</span><span>];</span><span>
            </span><span>if</span><span> </span><span>((</span><span>num3 </span><span>==</span><span> </span><span>'c'</span><span>)</span><span> </span><span>|</span><span> </span><span>(</span><span>num3 </span><span>==</span><span> </span><span>'f'</span><span>))</span><span>
            </span><span>{</span><span>
                num3 </span><span>=</span><span> readOnlySpan</span><span>[</span><span>num </span><span>+</span><span> </span><span>2</span><span>];</span><span>
                </span><span>if</span><span> </span><span>(</span><span>num3 </span><span>&lt;</span><span> </span><span>128</span><span> </span><span>&amp;&amp;</span><span> </span><span>(</span><span>"\0\0\0\0\0\0ΐ\0"</span><span>[</span><span>num3 </span><span>&gt;&gt;</span><span> </span><span>4</span><span>]</span><span> </span><span>&amp;</span><span> </span><span>(</span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>(</span><span>num3 </span><span>&amp;</span><span> </span><span>0xF</span><span>)))</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span>
                </span><span>{</span><span>
                    </span><span>base</span><span>.</span><span>runtextpos </span><span>=</span><span> runtextpos </span><span>+</span><span> num</span><span>;</span><span>
                    </span><span>return</span><span> </span><span>true</span><span>;</span><span>
                </span><span>}</span><span>
            </span><span>}</span><span>
        </span><span>}</span><span>
    </span><span>}</span><span>

    </span><span>base</span><span>.</span><span>runtextpos </span><span>=</span><span> runtextend</span><span>;</span><span>
    </span><span>return</span><span> </span><span>false</span><span>;</span><span>
</span><span>}</span></code></pre><p>Some interesting things to note here:</p><ul><li><p>We now use <code>IndexOfAny</code> to do the search for the three target characters. <code>IndexOfAny</code> is vectorized, so it can take advantage of SIMD instructions to compare multiple characters at once, and any future improvements we make to further optimize <code>IndexOfAny</code> will accrue to such <code>FindFirstChar</code> implementations implicitly.</p></li><li><p>If <code>IndexOfAny</code> finds a match, we don’t just immediately return in order to give <code>Go</code> a chance to execute. We instead do some fast checks on the next few characters to increase the likelihood that this is actually a match. In the original expression, you can see that the only possible values that could match the second character are <code>'c'</code> and <code>'f'</code>, so the implementation does a fast comparison check for those. And you can see that the third character has to match either <code>'d'</code> or <code>[g-i]</code>, so the implementation combines those into a single character class <code>[dg-i]</code>, which is then evaluate using a bitmap. Both of those latter character checks highlight the improved codegen that we now emit for character classes.</p></li></ul><p>We can see the potential impact of this in a test like this:</p><pre><code><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Linq</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>
    
</span><span>public</span><span> </span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[]</span><span> args</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>BenchmarkSwitcher</span><span>.</span><span>FromAssemblies</span><span>(</span><span>new</span><span>[]</span><span> </span><span>{</span><span> </span><span>typeof</span><span>(</span><span>Program</span><span>).</span><span>Assembly</span><span> </span><span>}).</span><span>Run</span><span>(</span><span>args</span><span>);</span><span>
    
    </span><span>private</span><span> </span><span>static</span><span> </span><span>Random</span><span> s_rand </span><span>=</span><span> </span><span>new</span><span> </span><span>Random</span><span>(</span><span>42</span><span>);</span><span>
    
    </span><span>private</span><span> </span><span>Regex</span><span> _regex </span><span>=</span><span> </span><span>new</span><span> </span><span>Regex</span><span>(</span><span>"([ab]cd|ef[g-i])jklm"</span><span>,</span><span> </span><span>RegexOptions</span><span>.</span><span>Compiled</span><span>);</span><span>
    </span><span>private</span><span> </span><span>string</span><span> _input </span><span>=</span><span> </span><span>string</span><span>.</span><span>Concat</span><span>(</span><span>Enumerable</span><span>.</span><span>Range</span><span>(</span><span>0</span><span>,</span><span> </span><span>1000</span><span>).</span><span>Select</span><span>(</span><span>_ </span><span>=&gt;</span><span> </span><span>(</span><span>char</span><span>)(</span><span>'a'</span><span> </span><span>+</span><span> s_rand</span><span>.</span><span>Next</span><span>(</span><span>26</span><span>))));</span><span>
    
    </span><span>[</span><span>Benchmark</span><span>]</span><span> </span><span>public</span><span> </span><span>bool</span><span> </span><span>IsMatch</span><span>()</span><span> </span><span>=&gt;</span><span> _regex</span><span>.</span><span>IsMatch</span><span>(</span><span>_input</span><span>);</span><span>
</span><span>}</span></code></pre><p>which on my machine yields the results:</p><div><table><thead><tr><th>Method</th><th>Toolchain</th><th>Mean</th><th>Error</th><th>StdDev</th><th>Ratio</th></tr></thead><tbody><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>1.084 us</td><td>0.0068 us</td><td>0.0061 us</td><td>0.08</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>14.235 us</td><td>0.0620 us</td><td>0.0550 us</td><td>1.00</td></tr></tbody></table></div><p>The previous code difference also highlights another interesting improvement, specifically the difference between the old code’s <code>int num2 = runtextend - num; if (num2 &gt; 0)</code> and the new code’s <code>if (runtextpos &lt;= runtextend - 7)</code>. As mentioned earlier, the <code>RegexParser</code> parses the input pattern into a node tree, over which analysis and optimizations are performed. .NET 5 includes a variety of new analyses, some simple, some more complex. One of the more simpler examples is the parser will now do a quick scan of the expression to determine if there’s a minimum length that any input would have to be in order to match. Consider the expression <code>[0-9]{3}-[0-9]{2}-[0-9]{4}</code>, which might be used to match a United States social security number (three ASCII digits, a dash, two ASCII digits, a dash, four ASCII digits). We can easily see that any valid match for this pattern would require at least 11 characters; if we were provided with an input that was 10 or fewer, or if we got to within 10 characters of the end of the input without having found a match, we could immediately fail the match without proceeding further, because there’s no possible way it would match.</p><pre><code><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Diagnosers</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>

</span><span>public</span><span> </span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[]</span><span> args</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>BenchmarkSwitcher</span><span>.</span><span>FromAssemblies</span><span>(</span><span>new</span><span>[]</span><span> </span><span>{</span><span> </span><span>typeof</span><span>(</span><span>Program</span><span>).</span><span>Assembly</span><span> </span><span>}).</span><span>Run</span><span>(</span><span>args</span><span>);</span><span>

    </span><span>private</span><span> </span><span>readonly</span><span> </span><span>Regex</span><span> _regex </span><span>=</span><span> </span><span>new</span><span> </span><span>Regex</span><span>(</span><span>"[0-9]{3}-[0-9]{2}-[0-9]{4}"</span><span>,</span><span> </span><span>RegexOptions</span><span>.</span><span>Compiled</span><span>);</span><span>
    
    </span><span>[</span><span>Benchmark</span><span>]</span><span> </span><span>public</span><span> </span><span>bool</span><span> </span><span>IsMatch</span><span>()</span><span> </span><span>=&gt;</span><span> _regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"123-45-678"</span><span>);</span><span>
</span><span>}</span></code></pre><div><table><thead><tr><th>Method</th><th>Toolchain</th><th>Mean</th><th>Error</th><th>StdDev</th><th>Ratio</th></tr></thead><tbody><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>19.39 ns</td><td>0.148 ns</td><td>0.139 ns</td><td>0.04</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>459.86 ns</td><td>1.893 ns</td><td>1.771 ns</td><td>1.00</td></tr></tbody></table></div><h3>Backtracking Elimination</h3><p>The .NET <code>Regex</code> implementation currently employs a backtracking engine. Such an implementation can support a variety of features that can’t easily or efficiently be supported by <a href="https://docs.microsoft.com/dotnet/standard/base-types/details-of-regular-expression-behavior#benefits-of-the-nfa-engine" target="_blank">DFA-based engines</a>, such as backreferences, and it can be very efficient in terms of memory utilization as well as in throughput for common cases. However, backtracking has a significant downside that it can lead to degenerate cases where matching takes exponential time in the length of the input. This is why the .NET <code>Regex</code> class exposes the ability to set a <a href="https://docs.microsoft.com/dotnet/api/system.text.regularexpressions.regex.-ctor?view=netcore-3.1#System_Text_RegularExpressions_Regex__ctor_System_String_System_Text_RegularExpressions_RegexOptions_System_TimeSpan_" target="_blank">timeout</a>, so that runaway matching can be interrupted by an exception.</p><p>The <a href="https://docs.microsoft.com/dotnet/standard/base-types/backtracking-in-regular-expressions" target="_blank">.NET documentation</a> has more details, but suffice it to say, it’s up to the developer to write regular expressions in a way that are not subject to excessive backtracking. One of the ways to do this is to employ “atomic groups”, which tell the engine that once the group has matched, the implementation must not backtrack into it, and it’s generally used when such backtracking won’t be beneficial. Consider an example expression <code>a+b</code> matched against the input <code>aaaa</code>:</p><ul><li><p>The <code>Go</code> engine starts matching <code>a+</code>. This operation is greedy, so it matches the first <code>a</code>, then the <code>aa</code>, then the <code>aaa</code>, and then the <code>aaaa</code>. It then sees it’s at the end of the input.</p></li><li><p>There’s no <code>b</code> to match, so the engine backtracks 1, with the <code>a+</code> now matching <code>aaa</code>.</p></li><li><p>There’s still no <code>b</code> to match, so the engine backtracks 1, with the <code>a+</code> now matching <code>aa</code>.</p></li><li><p>There’s still no <code>b</code> to match, so the engine backtracks 1, with the <code>a+</code> now matching <code>a</code>.</p></li><li><p>There’s still no <code>b</code> to match, and <code>a+</code> requires at least 1 a, so the match fails.</p></li></ul><p>But, all of that backtracking was provably unnecessary. There’s nothing the <code>a+</code> could match that the <code>b</code> could have also matched, so no amount of backtracking here would be fruitful. Seeing that, the developer could instead use the expression <code>(?&gt;a+)b</code>. That <code>(?&gt;</code> and <code>)</code> are the start and end of an atomic group, which says that once that group has matched and the engine moves past the group, it must not backtrack back into it. With our previous example of matching against <code>aaaa</code> then, this would happen instead:</p><ul><li><p>The <code>Go</code> engine starts matching <code>a+</code>. This operation is greedy, so it matches the first <code>a</code>, then the <code>aa</code>, then the <code>aaa</code>, and then the <code>aaaa</code>. It then sees it’s at the end of the input.</p></li><li><p>There’s no <code>b</code> to match, so the match fails.</p></li></ul><p>Much shorter, and this is just a simple example. So, a developer can do this analysis themselves and find places to manually insert atomic groups, but really, how many developers think to do that or take the time to do so?</p><p>Instead, .NET 5 now analyzes regular expressions as part of the node tree optimization phase, adding atomic groups where it sees that they won’t make a semantic difference but could help to avoid backtracking. For example:</p><ul><li><p><code>a+b</code> will become <code>(?&gt;a+)b</code>, as there’s nothing <code>a+</code> can “give back” that’ll match <code>b</code></p></li><li><p><code>\d+\s*</code> will become <code>(?&gt;\d+)(?&gt;\s*)</code>, as there’s nothing that could match <code>\d</code> that could also match <code>\s</code>, and <code>\s</code> is at the end of the expression.</p></li><li><p><code>a*([xyz]|hello)</code> will become <code>(?&gt;a*)([xyz]|hello)</code>, as in a successful match <code>a</code> could be followed by <code>x</code>, by <code>y</code>, by <code>z</code>, or by <code>h</code>, and there’s no overlap with any of those.</p></li></ul><p>This is just one example of tree rewriting that .NET 5 will now perform. It’ll do other rewrites, in part with a goal of eliminating backtracking. For example, it’ll now coalesce various forms of loops that are adjacent to each other. Consider the degenerate example <code>a*a*a*a*a*a*a*b</code>. In .NET 5, this will now be rewritten to just be the functionally equivalent <code>a*b</code>, which per the previous discussion will then further be rewritten as <code>(?&gt;a*)b</code>. That turns a potentially very expensive execution into one with linear execution time. It’s almost pointless showing an example benchmark, as we’re dealing with different algorithmic complexities, but I’ll do it anyway, just for fun:</p><pre><code><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>
    
</span><span>public</span><span> </span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[]</span><span> args</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>BenchmarkSwitcher</span><span>.</span><span>FromAssemblies</span><span>(</span><span>new</span><span>[]</span><span> </span><span>{</span><span> </span><span>typeof</span><span>(</span><span>Program</span><span>).</span><span>Assembly</span><span> </span><span>}).</span><span>Run</span><span>(</span><span>args</span><span>);</span><span>
    
    </span><span>private</span><span> </span><span>Regex</span><span> _regex </span><span>=</span><span> </span><span>new</span><span> </span><span>Regex</span><span>(</span><span>"a*a*a*a*a*a*a*b"</span><span>,</span><span> </span><span>RegexOptions</span><span>.</span><span>Compiled</span><span>);</span><span>
    
    </span><span>[</span><span>Benchmark</span><span>]</span><span> </span><span>public</span><span> </span><span>bool</span><span> </span><span>IsMatch</span><span>()</span><span> </span><span>=&gt;</span><span> _regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"aaaaaaaaaaaaaaaaaaaaa"</span><span>);</span><span>
</span><span>}</span></code></pre><div><table><thead><tr><th>Method</th><th>Toolchain</th><th>Mean</th><th>Error</th><th>StdDev</th><th>Ratio</th></tr></thead><tbody><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>379.2 ns</td><td>2.52 ns</td><td>2.36 ns</td><td>0.000</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>22,367,426.9 ns</td><td>123,981.09 ns</td><td>115,971.99 ns</td><td>1.000</td></tr></tbody></table></div><p>Backtracking reduction isn’t limited just to loops. Alternations represent another source of backtracking, as the implementation will match in a manner similar to how you might if you were matching by hand: try one alternation branch and proceed as far as you can, and then if the match fails, go back and try the next branch, and so on. Thus, reduction of backtracking from alternations is also useful.</p><p>One such rewrite now performed has to do with alternation prefix factoring. Consider the expression <code>what is (?:this|that)</code> evaluated against the text <code>what is it</code>. The engine will match the <code>what is</code>, and will then try to match <code>it</code> against <code>this</code>; it won’t match, so it’ll backtrack and try to match <code>it</code> against <code>that</code>. But both branches of the alternation begin with <code>th</code>. If we instead factor that out, and rewrite the expression to be <code>what is th(?:is|at)</code>, we can now avoid the backtracking. The engine will match the <code>what is</code>, will try to match the <code>th</code> against the <code>it</code>, will fail, and that’s it.</p><p>This optimization also ends up exposing more text to an existing optimization used by <code>FindFirstChar</code>. If there are multiple fixed characters at the beginning of the pattern, <code>FindFirstChar</code> will use a Boyer-Moore implementation to find that text in the input string. The larger the pattern exposed to the Boyer-Moore algorithm, the better it can do at quickly finding a match and minimizing false positives that would cause <code>FindFirstChar</code> to exit to the <code>Go</code> engine. By pulling text out of such an alternation, we increase the amount of text available in this case to Boyer-Moore.</p><p>As another related example, .NET 5 now finds cases where the expression can be implicitly anchored even if the developer didn’t specify to do so, which can also help with backtracking elimination. Consider the example <code>.*hello</code> with the input <code>abcdefghijk</code>. The implementation will start at position 0 and evaluate the expression at that point. Doing so will match the whole string <code>abcdefghijk</code> against the <code>.*</code>, and will then backtrack from there to try to match the <code>hello</code>, which it will fail to do. The engine will fail the match, and we’ll then bump to the next position. The engine will then match the rest of the string <code>bcdefghijk</code> against the <code>.*</code>, and will then backtrack from there to try to match the <code>hello</code>, which it will again fail to do. And so on. The observation to make here is that such retries by bumping to the next position are generally not going to be successful, and the expression can be implicitly anchored to only match at the beginning of lines. That then enables <code>FindFirstChar</code> to skip positions that can’t possibly match and avoid the attempted engine match at those locations.</p><pre><code><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Diagnosers</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>

</span><span>public</span><span> </span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[]</span><span> args</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>BenchmarkSwitcher</span><span>.</span><span>FromAssemblies</span><span>(</span><span>new</span><span>[]</span><span> </span><span>{</span><span> </span><span>typeof</span><span>(</span><span>Program</span><span>).</span><span>Assembly</span><span> </span><span>}).</span><span>Run</span><span>(</span><span>args</span><span>);</span><span>

    </span><span>private</span><span> </span><span>readonly</span><span> </span><span>Regex</span><span> _regex </span><span>=</span><span> </span><span>new</span><span> </span><span>Regex</span><span>(@</span><span>".*text"</span><span>,</span><span> </span><span>RegexOptions</span><span>.</span><span>Compiled</span><span>);</span><span>
    
    </span><span>[</span><span>Benchmark</span><span>]</span><span> </span><span>public</span><span> </span><span>bool</span><span> </span><span>IsMatch</span><span>()</span><span> </span><span>=&gt;</span><span> _regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"This is a test.\nDoes it match this?\nWhat about this text?"</span><span>);</span><span>
</span><span>}</span></code></pre><div><table><thead><tr><th>Method</th><th>Toolchain</th><th>Mean</th><th>Error</th><th>StdDev</th><th>Ratio</th></tr></thead><tbody><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>644.1 ns</td><td>3.63 ns</td><td>3.39 ns</td><td>0.21</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>3,024.9 ns</td><td>22.66 ns</td><td>20.09 ns</td><td>1.00</td></tr></tbody></table></div><p>(Just to make sure it’s clear, many regular expressions will still employ backtracking in .NET 5, and thus developers still need to be careful about running untrusted regular expressions.)</p><h3>Regex.* static methods and concurrency</h3><p>The <code>Regex</code> class exposes both instance and static methods. The static methods are primarily intended as a convenience, as under the covers they still need to use and operate on a <code>Regex</code> instance. The implementation could instantiate a new <code>Regex</code> and go through the full parsing/optimization/codegen routine each time one of these static methods was used, but in some scenarios that would be an egregious waste of time and space. Instead, <code>Regex</code> maintains a cache of the last few <code>Regex</code> objects used, indexed by everything that makes them unique, e.g. the pattern, the <code>RegexOptions</code>, even the current culture (since that can impact <code>IgnoreCase</code> matching). This cache is limited in size, capped at <code>Regex.CacheSize</code>, and thus the implementation employs a least recently used (LRU) cache: when the cache is full and another <code>Regex</code> needs to be added, the implementation throws away the least recently used item in the cache.</p><p>One simple way to implement such an LRU cache is with a linked list: every time an item is accessed, it’s removed from the list and added back to the front. Such an approach, however, has a big downside, in particular in a concurrent world: synchronization. If every read is actually a mutation, we need to ensure that concurrent reads, and thus concurrent mutations, don’t corrupt the list. Such a list is exactly what previous releases of .NET employed, and a global lock was used to protect it. In .NET Core 2.1, a <a href="https://github.com/dotnet/corefx/pull/27278" target="_blank">nice change</a> submitted by a community member improved this for some scenarios by making it possible to access the most recently used item lock-free, which improved throughput and scalability for workloads where the same <code>Regex</code> was used via the static methods repeatedly. For other cases, however, the implementation still locked on every usage.</p><p>It’s possible to see the impact of this locking by looking at a tool like the Concurrency Visualizer, which is an extension to Visual Studio available in its extensions gallery. By running a sample app like this under the profiler:</p><pre><code><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Threading</span><span>.</span><span>Tasks</span><span>;</span><span>
    
</span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>()</span><span>
    </span><span>{</span><span>
        </span><span>Parallel</span><span>.</span><span>Invoke</span><span>(</span><span>
            </span><span>()</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>while</span><span> </span><span>(</span><span>true</span><span>)</span><span> </span><span>Regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"abc"</span><span>,</span><span> </span><span>"^abc$"</span><span>);</span><span> </span><span>},</span><span>
            </span><span>()</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>while</span><span> </span><span>(</span><span>true</span><span>)</span><span> </span><span>Regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"def"</span><span>,</span><span> </span><span>"^def$"</span><span>);</span><span> </span><span>},</span><span>
            </span><span>()</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>while</span><span> </span><span>(</span><span>true</span><span>)</span><span> </span><span>Regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"ghi"</span><span>,</span><span> </span><span>"^ghi$"</span><span>);</span><span> </span><span>},</span><span>
            </span><span>()</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>while</span><span> </span><span>(</span><span>true</span><span>)</span><span> </span><span>Regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"jkl"</span><span>,</span><span> </span><span>"^jkl$"</span><span>);</span><span> </span><span>});</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>we can see images like this:</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-before.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-before.png" alt="Contention from Regex static methods" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-before.png 1036w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-before-300x45.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-before-1024x154.png 1024w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-before-768x116.png 768w" sizes="(max-width: 1036px) 100vw, 1036px"> </a></p><p>Each row is a thread doing work as part of this <code>Parallel.Invoke</code>. Areas in green are when the thread is actually executing code. Areas in yellow are when the thread has been pre-empted by the operating system because it needed the core to run another thread. Areas in red are when the thread is blocked waiting for something. In this case, all that red is because threads are waiting on that shared global lock in the <code>Regex</code> cache.</p><p>With .NET 5, the picture instead looks like this:</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-after.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-after.png" alt="No contention from Regex static methods" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-after.png 1030w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-after-300x44.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-after-1024x150.png 1024w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-contention-after-768x113.png 768w" sizes="(max-width: 1030px) 100vw, 1030px"> </a></p><p>Notice, no more red. This is because the cache has been re-written to be entirely lock-free for reads; the only time a lock is taken is when a new <code>Regex</code> is added to the cache, but even while that’s happening, other threads can proceed to read instances from the cache and use them. This means that as long as <code>Regex.CacheSize</code> is properly sized for an app and its typical usage of the <code>Regex</code> static methods, such accesses will no longer incur the kinds of delays they did in the past. As of today, the value defaults to 15, but the property has a setter so that it can be changed to better suit an app’s needs.</p><p>Allocation for the static methods has also been improved, by changing exactly what is cached so as to avoid allocating unnecessary wrapper objects. We can see this with a modified version of the previous example:</p><pre><code><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Threading</span><span>.</span><span>Tasks</span><span>;</span><span>

</span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>()</span><span>
    </span><span>{</span><span>
        </span><span>Parallel</span><span>.</span><span>Invoke</span><span>(</span><span>
            </span><span>()</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>for</span><span> </span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>10</span><span>_000</span><span>;</span><span> i</span><span>++)</span><span> </span><span>Regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"abc"</span><span>,</span><span> </span><span>"^abc$"</span><span>);</span><span> </span><span>},</span><span>
            </span><span>()</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>for</span><span> </span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>10</span><span>_000</span><span>;</span><span> i</span><span>++)</span><span> </span><span>Regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"def"</span><span>,</span><span> </span><span>"^def$"</span><span>);</span><span> </span><span>},</span><span>
            </span><span>()</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>for</span><span> </span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>10</span><span>_000</span><span>;</span><span> i</span><span>++)</span><span> </span><span>Regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"ghi"</span><span>,</span><span> </span><span>"^ghi$"</span><span>);</span><span> </span><span>},</span><span>
            </span><span>()</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>for</span><span> </span><span>(</span><span>int</span><span> i </span><span>=</span><span> </span><span>0</span><span>;</span><span> i </span><span>&lt;</span><span> </span><span>10</span><span>_000</span><span>;</span><span> i</span><span>++)</span><span> </span><span>Regex</span><span>.</span><span>IsMatch</span><span>(</span><span>"jkl"</span><span>,</span><span> </span><span>"^jkl$"</span><span>);</span><span> </span><span>});</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>and running it with the <a href="https://docs.microsoft.com/visualstudio/profiling/dotnet-alloc-tool" target="_blank">.NET Object Allocation Tracking</a> tool in Visual Studio. On the left is .NET Core 3.1, and on the right is .NET 5 Preview 2:</p><p><a href="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-alloc.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-alloc.png" alt="Reduced allocation from Regex static methods" srcset="https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-alloc.png 1990w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-alloc-300x121.png 300w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-alloc-1024x414.png 1024w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-alloc-768x311.png 768w, https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2020/03/regex-static-alloc-1536x621.png 1536w" sizes="(max-width: 1990px) 100vw, 1990px"> </a></p><p>In particular, note the line containing 40,000 allocations on the left that’s instead only 4 on the right.</p><h3>Other Overhead Reduction</h3><p>We’ve walked through some of the key improvements that have gone into regular expressions in .NET 5, but the list is by no means complete. There is a laundry list of smaller optimizations that have been made all over the place, and while we can’t enumerate them all here, we can walk through a few more.</p><p>In some places, we’ve utilized forms of vectorization beyond what was discussed previously. For example, when <code>RegexOptions.Compiled</code> is used and the pattern contains a string of characters, the compiler emits a check for each character individually. You can see this if you look at the decompiled code for an expression like <code>abcd</code>, which would previously result in code something like this:</p><pre><code><span>if</span><span> </span><span>(</span><span>4</span><span> </span><span>&lt;=</span><span> runtextend </span><span>-</span><span> runtextpos </span><span>&amp;&amp;</span><span>
    runtext</span><span>[</span><span>runtextpos</span><span>]</span><span> </span><span>==</span><span> </span><span>'a'</span><span> </span><span>&amp;&amp;</span><span>
    runtext</span><span>[</span><span>runtextpos </span><span>+</span><span> </span><span>1</span><span>]</span><span> </span><span>==</span><span> </span><span>'b'</span><span> </span><span>&amp;&amp;</span><span>
    runtext</span><span>[</span><span>runtextpos </span><span>+</span><span> </span><span>2</span><span>]</span><span> </span><span>==</span><span> </span><span>'c'</span><span> </span><span>&amp;&amp;</span><span>
    runtext</span><span>[</span><span>runtextpos </span><span>+</span><span> </span><span>3</span><span>]</span><span> </span><span>==</span><span> </span><span>'d'</span><span>)</span></code></pre><p>In .NET 5, when using <code>DynamicMethod</code> to create the compiled code, we now instead try to compare <code>Int64</code> values (on a 64-bit system, or <code>Int32</code>s on a 32-bit system), rather than comparing individual <code>Char</code>s. That means for the previous example we’ll instead now generate code akin to this:</p><pre><code><span>if</span><span> </span><span>(</span><span>3u</span><span> </span><span>&lt;</span><span> </span><span>(</span><span>uint</span><span>)</span><span>readOnlySpan</span><span>.</span><span>Length</span><span> </span><span>&amp;&amp;</span><span> </span><span>*(</span><span>long</span><span>*)</span><span>readOnlySpan</span><span>.</span><span>_pointer </span><span>==</span><span> </span><span>28147922879250529L</span><span>)</span></code></pre><p>(I say “akin to”, because we can’t represent in C# the exact IL that’s generated, which is more aligned with using members of the <code>Unsafe</code> type.). We don’t need to worry about endianness issues here, because the code generating the <code>Int64</code>/<code>Int32</code> values used for comparison is happening on the same machine (and even in the same process) as the one loading the input values for comparison.</p><p>Another example is something that was actually shown earlier in a previous generated code sample, but glossed over. You may have noticed earlier on when comparing the outputs for the <code>@"a\sb"</code> expression that the previous code contained calls to <code>CheckTimeout()</code> but the new code did not. This <code>CheckTimeout()</code> function is used to check whether our execution time has exceeded what’s allowed by the timeout value provided to the <code>Regex</code> when it was constructed. But the default timeout used when no timeout is provided is “infinite”, and thus “infinite” is a very common value. Since we will never exceed an infinite timeout, when we compile the code for a <code>RegexOptions.Compiled</code> regular expression, we check the timeout, and if it’s infinite, we skip generating these <code>CheckTimeout()</code> calls.</p><p>Similar optimizations exist in other places. For example, by default <code>Regex</code> does case-sensitive comparisons. Only if <code>RegexOptions.IgnoreCase</code> is specified (or if the expression itself contains instructions to perform case-insensitive matches) are case-insensitive comparisons used, and only if case-insensitive comparisons are used do we need to access <code>CultureInfo.CurrentCulture</code> in order to determine how to perform that comparison. Further, if <code>RegexOptions.InvariantCulture</code> is specified, we also don’t need to access <code>CultureInfo.CurrentCulture</code>, because it’ll never be used. All of this means we can avoid generating the code that accesses <code>CultureInfo.CurrentCulture</code> if we prove that it’ll never be needed. On top of that, we can make <code>RegexOptions.InvariantCulture</code> faster by emitting calls to <code>char.ToLowerInvariant</code> rather than <code>char.ToLower(CultureInfo.InvariantCulture)</code>, especially since <code>ToLowerInvariant</code> has also been improved in .NET 5 (yet another example where by changing <code>Regex</code> to use other framework functionality, it implicitly benefits any time we improve those utilized functions).</p><p>Another interesting change was to <code>Regex.Replace</code> and <code>Regex.Split</code>. These methods were implemented as wrappers around <code>Regex.Match</code>, layering their functionality on top of it. That, however, meant that every time a match was found, we would exit the scan loop, work our way back up through the various layers of abstraction, perform the work on the match, and then call back into the engine, work our way back down to the scan loop, and so on. On top of that, each match would require a new <code>Match</code> object be created. Now in .NET 5, there’s a dedicated callback-based loop used internally by these methods, which lets us stay in the tight scan loop and reuse the same <code>Match</code> object over and over (something that wouldn’t be safe if exposed publicly but which can be done as an internal implementation detail). The memory management used in implementing <code>Replace</code> has also been tuned to focus on tracking regions of the input to be replaced or not, rather than tracking each individual character. The net effect of this can be fairly impactful on both throughput and memory allocation, in particular for very long inputs with relatively few replacements.</p><pre><code><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Linq</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>
    
</span><span>[</span><span>MemoryDiagnoser</span><span>]</span><span>
</span><span>public</span><span> </span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[]</span><span> args</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>BenchmarkSwitcher</span><span>.</span><span>FromAssemblies</span><span>(</span><span>new</span><span>[]</span><span> </span><span>{</span><span> </span><span>typeof</span><span>(</span><span>Program</span><span>).</span><span>Assembly</span><span> </span><span>}).</span><span>Run</span><span>(</span><span>args</span><span>);</span><span>
    
    </span><span>private</span><span> </span><span>Regex</span><span> _regex </span><span>=</span><span> </span><span>new</span><span> </span><span>Regex</span><span>(</span><span>"a"</span><span>,</span><span> </span><span>RegexOptions</span><span>.</span><span>Compiled</span><span>);</span><span>
    </span><span>private</span><span> </span><span>string</span><span> _input </span><span>=</span><span> </span><span>string</span><span>.</span><span>Concat</span><span>(</span><span>Enumerable</span><span>.</span><span>Repeat</span><span>(</span><span>"abcdefghijklmnopqrstuvwxyz"</span><span>,</span><span> </span><span>1_000_000</span><span>));</span><span>
    
    </span><span>[</span><span>Benchmark</span><span>]</span><span> </span><span>public</span><span> </span><span>string</span><span> </span><span>Replace</span><span>()</span><span> </span><span>=&gt;</span><span> _regex</span><span>.</span><span>Replace</span><span>(</span><span>_input</span><span>,</span><span> </span><span>"A"</span><span>);</span><span>
</span><span>}</span></code></pre><div><table><thead><tr><th>Method</th><th>Toolchain</th><th>Mean</th><th>Error</th><th>StdDev</th><th>Ratio</th><th>Gen 0</th><th>Gen 1</th><th>Gen 2</th><th>Allocated</th></tr></thead><tbody><tr><td>Replace</td><td>\master\corerun.exe</td><td>93.79 ms</td><td>1.120 ms</td><td>0.935 ms</td><td>0.45</td><td>–</td><td>–</td><td>–</td><td>81.59 MB</td></tr><tr><td>Replace</td><td>\netcore31\corerun.exe</td><td>209.59 ms</td><td>3.654 ms</td><td>3.418 ms</td><td>1.00</td><td>33666.6667</td><td>666.6667</td><td>666.6667</td><td>371.96 MB</td></tr></tbody></table></div><h2>“Show Me The Money”</h2><p>All of this comes together to produce significantly better performance on a wide array of benchmarks. To exemplify that, I searched around the web for regex benchmarks and ran several.</p><p>The benchmarks at <a href="https://github.com/mariomka/regex-benchmark/blob/969eca41b4302c8c58d0bd547c36b5964f0b18fb/csharp/Benchmark.cs" target="_blank">mariomka/regex-benchmark</a> already had a C# version, so that was an easy thing to simply compile and run:</p><pre><code><span>using</span><span> </span><span>System</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>IO</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Diagnostics</span><span>;</span><span>

</span><span>class</span><span> </span><span>Benchmark</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[]</span><span> args</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>if</span><span> </span><span>(</span><span>args</span><span>.</span><span>Length</span><span> </span><span>!=</span><span> </span><span>1</span><span>)</span><span>
        </span><span>{</span><span>
            </span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>"Usage: benchmark &lt;filename&gt;"</span><span>);</span><span>
            </span><span>Environment</span><span>.</span><span>Exit</span><span>(</span><span>1</span><span>);</span><span>
        </span><span>}</span><span>

        </span><span>StreamReader</span><span> reader </span><span>=</span><span> </span><span>new</span><span> </span><span>System</span><span>.</span><span>IO</span><span>.</span><span>StreamReader</span><span>(</span><span>args</span><span>[</span><span>0</span><span>]);</span><span>
        </span><span>string</span><span> data </span><span>=</span><span> reader</span><span>.</span><span>ReadToEnd</span><span>();</span><span>
    
        </span><span>// Email</span><span>
        </span><span>Benchmark</span><span>.</span><span>Measure</span><span>(</span><span>data</span><span>,</span><span> </span><span>@</span><span>"[\w\.+-]+@[\w\.-]+\.[\w\.-]+"</span><span>);</span><span>
    
        </span><span>// URI</span><span>
        </span><span>Benchmark</span><span>.</span><span>Measure</span><span>(</span><span>data</span><span>,</span><span> </span><span>@</span><span>"[\w]+://[^/\s?#]+[^\s?#]+(?:\?[^\s#]*)?(?:#[^\s]*)?"</span><span>);</span><span>
    
        </span><span>// IP</span><span>
        </span><span>Benchmark</span><span>.</span><span>Measure</span><span>(</span><span>data</span><span>,</span><span> </span><span>@</span><span>"(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9])"</span><span>);</span><span>
    </span><span>}</span><span>
    
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Measure</span><span>(</span><span>string</span><span> data</span><span>,</span><span> </span><span>string</span><span> pattern</span><span>)</span><span>
    </span><span>{</span><span>
        </span><span>Stopwatch</span><span> stopwatch </span><span>=</span><span> </span><span>Stopwatch</span><span>.</span><span>StartNew</span><span>();</span><span>
    
        </span><span>MatchCollection</span><span> matches </span><span>=</span><span> </span><span>Regex</span><span>.</span><span>Matches</span><span>(</span><span>data</span><span>,</span><span> pattern</span><span>,</span><span> </span><span>RegexOptions</span><span>.</span><span>Compiled</span><span>);</span><span>
        </span><span>int</span><span> count </span><span>=</span><span> matches</span><span>.</span><span>Count</span><span>;</span><span>
    
        stopwatch</span><span>.</span><span>Stop</span><span>();</span><span>
    
        </span><span>Console</span><span>.</span><span>WriteLine</span><span>(</span><span>stopwatch</span><span>.</span><span>Elapsed</span><span>.</span><span>TotalMilliseconds</span><span>.</span><span>ToString</span><span>(</span><span>"G"</span><span>,</span><span> </span><span>System</span><span>.</span><span>Globalization</span><span>.</span><span>CultureInfo</span><span>.</span><span>InvariantCulture</span><span>)</span><span> </span><span>+</span><span> </span><span>" - "</span><span> </span><span>+</span><span> count</span><span>);</span><span>
    </span><span>}</span><span>
</span><span>}</span></code></pre><p>On my machine, here’s the console output using .NET Core 3.1:</p><pre><code><span>966.9274</span><span> </span><span>-</span><span> </span><span>92</span><span>
</span><span>746.3963</span><span> </span><span>-</span><span> </span><span>5301</span><span>
</span><span>65.6778</span><span> </span><span>-</span><span> </span><span>5</span></code></pre><p>and the console output using .NET 5:</p><pre><code><span>274.3515</span><span> </span><span>-</span><span> </span><span>92</span><span>
</span><span>159.3629</span><span> </span><span>-</span><span> </span><span>5301</span><span>
</span><span>15.6075</span><span> </span><span>-</span><span> </span><span>5</span></code></pre><p>The numbers before the dashes are the execution times, and the numbers after the dashes are the answers (so it’s a good thing that the second numbers remain the same). The execution times drop precipitously: that’s a 3.5x, 4.6x, and 4.2x improvement, respectively!</p><p>I also found https://zherczeg.github.io/sljit/regex_perf.html, which has a variety of benchmarks but no C# version. I translated it into a Benchmark.NET test:</p><pre><code><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Attributes</span><span>;</span><span>
</span><span>using</span><span> </span><span>BenchmarkDotNet</span><span>.</span><span>Running</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>IO</span><span>;</span><span>
</span><span>using</span><span> </span><span>System</span><span>.</span><span>Text</span><span>.</span><span>RegularExpressions</span><span>;</span><span>
    
</span><span>[</span><span>MemoryDiagnoser</span><span>]</span><span>
</span><span>public</span><span> </span><span>class</span><span> </span><span>Program</span><span>
</span><span>{</span><span>
    </span><span>static</span><span> </span><span>void</span><span> </span><span>Main</span><span>(</span><span>string</span><span>[]</span><span> args</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>BenchmarkSwitcher</span><span>.</span><span>FromAssemblies</span><span>(</span><span>new</span><span>[]</span><span> </span><span>{</span><span> </span><span>typeof</span><span>(</span><span>Program</span><span>).</span><span>Assembly</span><span> </span><span>}).</span><span>Run</span><span>(</span><span>args</span><span>);</span><span>
    
    </span><span>private</span><span> </span><span>static</span><span> </span><span>string</span><span> s_input </span><span>=</span><span> </span><span>File</span><span>.</span><span>ReadAllText</span><span>(@</span><span>"d:\mtent12.txt"</span><span>);</span><span>
    </span><span>private</span><span> </span><span>Regex</span><span> _regex</span><span>;</span><span>
    
    </span><span>[</span><span>GlobalSetup</span><span>]</span><span>
    </span><span>public</span><span> </span><span>void</span><span> </span><span>Setup</span><span>()</span><span> </span><span>=&gt;</span><span> _regex </span><span>=</span><span> </span><span>new</span><span> </span><span>Regex</span><span>(</span><span>Pattern</span><span>,</span><span> </span><span>RegexOptions</span><span>.</span><span>Compiled</span><span>);</span><span>
    
    </span><span>[</span><span>Params</span><span>(</span><span>
        </span><span>@</span><span>"Twain"</span><span>,</span><span>
        </span><span>@</span><span>"(?i)Twain"</span><span>,</span><span>
        </span><span>@</span><span>"[a-z]shing"</span><span>,</span><span>
        </span><span>@</span><span>"Huck[a-zA-Z]+|Saw[a-zA-Z]+"</span><span>,</span><span>
        </span><span>@</span><span>"\b\w+nn\b"</span><span>,</span><span>
        </span><span>@</span><span>"[a-q][^u-z]{13}x"</span><span>,</span><span>
        </span><span>@</span><span>"Tom|Sawyer|Huckleberry|Finn"</span><span>,</span><span>
        </span><span>@</span><span>"(?i)Tom|Sawyer|Huckleberry|Finn"</span><span>,</span><span>
        </span><span>@</span><span>".{0,2}(Tom|Sawyer|Huckleberry|Finn)"</span><span>,</span><span>
        </span><span>@</span><span>".{2,4}(Tom|Sawyer|Huckleberry|Finn)"</span><span>,</span><span>
        </span><span>@</span><span>"Tom.{10,25}river|river.{10,25}Tom"</span><span>,</span><span>
        </span><span>@</span><span>"[a-zA-Z]+ing"</span><span>,</span><span>
        </span><span>@</span><span>"\s[a-zA-Z]{0,12}ing\s"</span><span>,</span><span>
        </span><span>@</span><span>"([A-Za-z]awyer|[A-Za-z]inn)\s"</span><span>
    </span><span>)]</span><span>
    </span><span>public</span><span> </span><span>string</span><span> </span><span>Pattern</span><span> </span><span>{</span><span> </span><span>get</span><span>;</span><span> </span><span>set</span><span>;</span><span> </span><span>}</span><span>
    
    </span><span>[</span><span>Benchmark</span><span>]</span><span> </span><span>public</span><span> </span><span>bool</span><span> </span><span>IsMatch</span><span>()</span><span> </span><span>=&gt;</span><span> _regex</span><span>.</span><span>IsMatch</span><span>(</span><span>s_input</span><span>);</span><span>
</span><span>}</span></code></pre><p>and ran it against the ~20MB text file input provided from that page, getting the following results:</p><div><table><thead><tr><th>Method</th><th>Toolchain</th><th>Pattern</th><th>Mean</th><th>Ratio</th></tr></thead><tbody><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>(?i)T(…)Finn [31]</td><td>12,703.08 ns</td><td>0.32</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>(?i)T(…)Finn [31]</td><td>40,207.12 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>(?i)Twain</td><td>159.81 ns</td><td>0.84</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>(?i)Twain</td><td>189.49 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>([A-Z(…)nn)\s [29]</td><td>6,903,345.70 ns</td><td>0.10</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>([A-Z(…)nn)\s [29]</td><td>67,388,775.83 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>.{0,2(…)Finn) [35]</td><td>1,311,160.79 ns</td><td>0.68</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>.{0,2(…)Finn) [35]</td><td>1,942,021.93 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>.{2,4(…)Finn) [35]</td><td>1,202,730.97 ns</td><td>0.67</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>.{2,4(…)Finn) [35]</td><td>1,790,485.74 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>Huck[(…)A-Z]+ [26]</td><td>282,030.24 ns</td><td>0.01</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>Huck[(…)A-Z]+ [26]</td><td>19,908,290.62 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>Tom.{(…)5}Tom [33]</td><td>8,817,983.04 ns</td><td>0.09</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>Tom.{(…)5}Tom [33]</td><td>94,075,640.48 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>TomS(…)Finn [27]</td><td>39,214.62 ns</td><td>0.14</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>TomS(…)Finn [27]</td><td>281,452.38 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>Twain</td><td>64.44 ns</td><td>0.77</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>Twain</td><td>83.61 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>[a-q][^u-z]{13}x</td><td>1,695.15 ns</td><td>0.09</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>[a-q][^u-z]{13}x</td><td>19,412.31 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>[a-zA-Z]+ing</td><td>3,042.12 ns</td><td>0.31</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>[a-zA-Z]+ing</td><td>9,896.25 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>[a-z]shing</td><td>28,212.30 ns</td><td>0.24</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>[a-z]shing</td><td>117,954.06 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>\b\w+nn\b</td><td>32,278,974.55 ns</td><td>0.21</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>\b\w+nn\b</td><td>152,395,335.00 ns</td><td>1.00</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>IsMatch</td><td>\master\corerun.exe</td><td>\s[a-(…)ing\s [21]</td><td>1,181.86 ns</td><td>0.23</td></tr><tr><td>IsMatch</td><td>\netcore31\corerun.exe</td><td>\s[a-(…)ing\s [21]</td><td>5,161.79 ns</td><td>1.00</td></tr></tbody></table></div><p>Some of those ratios are quite lovely.</p><p>Another is the <a href="https://github.com/dotnet/performance/blob/5034fb017953fdecdf3a3a115202d2a71c831941/src/benchmarks/micro/runtime/BenchmarksGame/regex-redux-5.cs" target="_blank">“regex-redux”</a> benchmark from the “The Computer Language Benchmarks Game”. There’s an implementation of this harnessed in the dotnet/performance repo, so I ran that:</p><div><table><thead><tr><th>Method</th><th>Toolchain</th><th>options</th><th>Mean</th><th>Error</th><th>StdDev</th><th>Median</th><th>Min</th><th>Max</th><th>Ratio</th><th>RatioSD</th><th>Gen 0</th><th>Gen 1</th><th>Gen 2</th><th>Allocated</th></tr></thead><tbody><tr><td>RegexRedux_5</td><td>\master\corerun.exe</td><td>Compiled</td><td>7.941 ms</td><td>0.0661 ms</td><td>0.0619 ms</td><td>7.965 ms</td><td>7.782 ms</td><td>8.009 ms</td><td>0.30</td><td>0.01</td><td>–</td><td>–</td><td>–</td><td>2.67 MB</td></tr><tr><td>RegexRedux_5</td><td>\netcore31\corerun.exe</td><td>Compiled</td><td>26.311 ms</td><td>0.5058 ms</td><td>0.4731 ms</td><td>26.368 ms</td><td>25.310 ms</td><td>27.198 ms</td><td>1.00</td><td>0.00</td><td>1571.4286</td><td>–</td><td>–</td><td>12.19 MB</td></tr></tbody></table></div><p>Thus on this benchmark, .NET 5 is 3.3x the throughput of .NET Core 3.1.</p><h2>Call to Action</h2><p>We’d love your feedback and contributions in multiple ways.</p><p><a href="https://dotnet.microsoft.com/download/dotnet-core/5.0" target="_blank">Download .NET 5 Preview 2</a> and try it out with your regular expressions. Do you see measurable gains? If so, tell us about it. If not, tell us about that, too, so that we can work together to find ways to improve things for your most valuable expressions.</p><p>Are there specific regular expressions that are important to you? If so, please share them with us; we’d love to augment our test suite with real-world regular expressions from you, your input data, and the corresponding expected results, so as to help ensure that we don’t regress things important to you as we make further improvements to the code base. In fact, we’d welcome PRs to dotnet/runtime to augment the test suite in just that way. You can see that in addition to thousands of synthetic test cases, the <code>Regex</code> test suite contains <a href="https://github.com/dotnet/runtime/blob/820cc140f145dd669378fe5252f34f3c4a3cb8b4/src/libraries/System.Text.RegularExpressions/tests/Regex.KnownPattern.Tests.cs" target="_blank">a bunch of examples sourced</a> from documentation, tutorials, and real applications; if you have expressions you think should be added here, please submit PRs. We’ve changed a lot of code as part of these performance improvements, and while we’ve been diligent about validation, surely some bugs have crept in. Feedback from you with your important expressions will help to shore this up!</p><p>As much work as has been done in .NET 5 already, we also have a laundry list of additional known work that can be explored, catalogued at <a href="https://github.com/dotnet/runtime/issues/1349" target="_blank">dotnet/runtime#1349</a>. We would welcome additional suggestions here, and more so actual prototyping or productizing of some of the ideas outlined there (with appropriate performance vetting, testing, etc.) Some examples:</p><ul><li><p><strong>Improve the automatic addition of atomic groups for loops.</strong> As noted in this post, we now automatically insert atomic groups in a bunch of places where we can detect they may help reduce backtracking while keeping semantics identical. We know, however, there are some gaps in our analysis, and it’d be great to fill those. For example, the implementation will now change <code>a*b+c</code> to be <code>(?&gt;a*)(?&gt;b+)c</code>, as it will see that <code>b+</code> won’t give anything back that can match <code>c</code>, and <code>a*</code> won’t give anything back that can match <code>b</code> (and the <code>b+</code> means there must be at least one <code>b</code>). However, the expression <code>a*b*c</code> will be transformed into <code>a*(?&gt;b*)c</code> rather than <code>(?&gt;a*)(?&gt;b*)c</code>, even though the latter is appropriate. The issue here is we only currently look at the next node in the sequence, and here the <code>b*</code> may match zero items which means the next node after the <code>a*</code> could be the <code>c</code>, and we don’t currently look that far ahead.</p></li><li><p><strong>Improve the automatic addition of atomic groups for alternations</strong>. We can do more to automatically upgrade alternations to be atomic based on an analysis of the alternation. For example, given an expression like <code>(Bonjour|Hello), .*</code>, we know that if <code>Bonjour</code> matched, there’s no possible way <code>Hello</code> will also match, so this alternation could be made atomic.</p></li><li><p><strong>Improve the vectorization of <code>IndexOfAny</code></strong>. As noted in this post, we now use built-in functions wherever possible, such that improvements to those implicitly benefit <code>Regex</code> as well (in addition to every other workload using them). Our reliance on <code>IndexOfAny</code> is now so high in some regular expressions that it can represent a huge portion of the processing, e.g. on the “regex redux” benchmark shown earlier, ~30% of the overall time is spent in <code>IndexOfAny</code>. There is opportunity here to improve this function, and thereby improve <code>Regex</code> as well. This is covered separately by <a href="https://github.com/dotnet/runtime/issues/25023" target="_blank">dotnet/runtime#25023</a>.</p></li><li><p><strong>Prototype a DFA implementation</strong>. Certain aspects of the .NET regular expression support are difficult to do with a DFA-based regex engine, but some operations should be doable with minimal concern. For example, <code>Regex.IsMatch</code> doesn’t need to be concerned with capture semantics (.NET has some extra features around captures that make it even more challenging than in other implementations), so if the expression is seen to not contain problematic constructs like backreferences or lookarounds, for <code>IsMatch</code> we could explore employing a DFA-based engine, and possibly that could grow to more widespread use in time.</p></li><li><p><strong>Improve testing</strong>. If you’re interested in tests more than in implementation, there are some valuable things to be done here, too. Our code coverage is already very high, but there are still gaps; plugging those (and potentially finding dead code in the process) would be helpful. Finding and incorporating other appropriately licensed test suites to provide more coverage of varying expressions is also valuable.</p></li></ul><p>Thanks for reading. And enjoy!</p></div></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>