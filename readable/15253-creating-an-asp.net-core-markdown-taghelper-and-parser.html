<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating an ASP.NET Core Markdown TagHelper and Parser -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Creating an ASP.NET Core Markdown TagHelper and Parser</h1><div><div id="ArticleBody" class="postcontent" itemprop="articleBody"><p><img src="https://weblog.west-wind.com/images/2019/A-Markdown-TagHelper-and-Parser-for-ASP.NET-Core/ScribeImage.jpg" alt=""></p><p>A few months ago I wrote about creating a <a href="https://weblog.west-wind.com/posts/2017/Sep/13/A-Literal-Markdown-Control-for-ASPNET-WebForms">literal Markdown Control for WebForms</a>, where I described a simple content control that takes the content from within a tag and parses the embedded Markdown and then produces HTML output in its stead. I created a WebForms control mainly for selfish reasons, because I have tons of semi-static content on my content sites that still live in classic ASP.NET ASPX pages.</p><p>Since I wrote that article I've gotten a lot of requests to write about an ASP.NET Core version for something similar and - back to my own selfishness - I'm also starting to deploy a few content heavy sites that have mostly static html content that would be well served by Markdown using ASP.NET Core and Razor Pages. So it's time to build an ASP.NET Core version by creating a <code>&lt;markdown&gt;</code> TagHelper which I cover in this post. Along the same lines, I also created a <a href="https://weblog.west-wind.com/posts/2018/Apr/18/Creating-a-generic-Markdown-Page-Handler-using-ASPNET-Core-Middleware">generic markdown page processing Middleware component</a> that can be used to generically serve arbitrary Markdown documents in any ASP.NET Core site which I cover in a <a href="https://weblog.west-wind.com/posts/2018/Apr/18/Creating-a-generic-Markdown-Page-Handler-using-ASPNET-Core-Middleware">separate post</a> next week.</p><p>There are already a number of Markdown TagHelper implementations available, but I'm a big fan of the <a href="https://github.com/lunet-io/markdig">MarkDig Markdown Parser</a>, so I set out to create an <strong>ASP.NET Core Tag Helper</strong> that provides the same functionality as the WebForms control I previously created.</p><h2 id="get-it">Get it</h2><p>This library provides:</p><ul><li>A Markdown TagHelper</li><li>Markdown Parsing function</li><li>Markdown Page Processing Middleware that allows you to serve Markdown Pages as HTML</li></ul><p>In this post I cover the first two, the Markdown Page processor is covered in a <a href="https://weblog.west-wind.com/posts/2018/Apr/18/Creating-a-generic-Markdown-Page-Handler-using-ASPNET-Core-Middleware">separate post</a>.</p><p>The packaged <strong>Westwind.AspnetCore.Markdown</strong> component includes simple Markdown Parsing support for code or Razor pages and a the TagHelper for your ASP.NET Core applications.</p><p>It's available as a <a href="https://www.nuget.org/packages/Westwind.AspNetCore.Markdown">NuGet Package</a>:</p><pre><code>PM&gt; Install-Package Westwind.AspNetCore.Markdown
</code></pre><p>And you can take a look at the source code on Github:</p><p><em>Note: the GitHub repository was recently moved out of the <a href="https://github.com/RickStrahl/Westwind.AspNetCore">Westwind.AspnetCore</a> into its own dedicated package.</em></p><h2 id="quick-overview">Quick Overview</h2><p>The two key features are the Markdown Parser and the Markdown TagHelper.</p><h3 id="markdown-parsing">Markdown Parsing</h3><p>This library uses the popular Markdig Markdown parser along with configuration options to customize how Markdown is rendered.</p><p>At the highest level there are is a static Markdown instance that you can use to parse Markdown to an HTML string:</p><pre><code class="language-cs">var html = Markdown.Parse("This is some **markdown** text and some `code`.")
</code></pre><p>For use in Razor there's also another version that returns an <code>HtmlString</code> so you don't need <code>@html.Raw()</code> to display the rendered Markdown:</p><pre><code class="language-html">&lt;div&gt;@Markdown.ParseHtmlString(model.MarkdownNotes)&lt;/div&gt;
</code></pre><h3 id="markdown-taghelper">Markdown TagHelper</h3><p>Using the TagHelper you can render Markdown like this inside of a Razor Page:</p><pre><code class="language-html">&lt;markdown&gt;
    #### This is Markdown text inside of a Markdown block

    * Item 1
    * Item 2
 
    ### Dynamic Data is supported:
    The current Time is: @DateTime.Now.ToString("HH:mm:ss")

    ```cs
    // this c# is a code block
    for (int i = 0; i &lt; lines.Length; i++)
    {
        line1 = lines[i];
        if (!string.IsNullOrEmpty(line1))
            break;
    }
    ```
&lt;/markdown&gt;
</code></pre><p>The Markdown is expanded into HTML to replace the markdown TagHelper content.</p><p>You can also bind to Model values using the <code>markdown</code> attribute:</p><pre><code class="language-html">@model MarkdownModel

&lt;markdown markdown="Model.MarkdownText" /&gt;
</code></pre><h2 id="why-do-i-need-a-markdown-taghelpercontrol">Why do I need a Markdown TagHelper/Control?</h2><p>Let's take a step back - why would you even need a content control for Markdown Parsing?</p><p>Markdown is everywhere these days and I for one have become incredibly dependent on it for a variety of text scenarios. I use it for blogging, for documentation both for code on Git repos and actual extended documentation. I use it for note keeping and collaboration in Gists or Github Repos, as well as a data entry format for many applications that need to display text content a little bit more richly than using plain text. Since I created the Markdown control I've also been using that extensively for quite a bit of my static content and it's made it much easier to manage some of my content this way.</p><h3 id="what-does-it-do">What does it do?</h3><p>The main reason for this component is the ability to <strong>embed</strong> Markdown into content with a simple tag that gets parsed into HTML at runtime. This is very useful for content pages that contain a lot of raw static text. It's a lot easier to write Markdown text in content pages than it is to write HTML tag soup consisting of <code>&lt;p&gt;</code>,<code>&lt;ul&gt;</code> and <code>&lt;h3&gt;</code> tags. Markdown is a heck of a lot more comfortable to type and maintain and this works well for common text content. It won't replace HTML for markup for an entire page, but it can be a great help with large content blocks inside of a larger HTML page.</p><p>In this post I'll create <code>&lt;markdown&gt;</code> TagHelper that can convert inline Markdown like this:</p><pre><code class="language-html">&lt;h3&gt;Markdown Tag Helper Block&lt;/h3&gt;

&lt;markdown&gt;
    #### This is Markdown text inside of a Markdown block

    * Item 1
    * Item 2
 
    ### Dynamic Data is supported:
    The current Time is: @DateTime.Now.ToString("HH:mm:ss")

    `` `cs
    // this c# is a code block
    for (int i = 0; i &lt; lines.Length; i++)
    {
        line1 = lines[i];
        if (!string.IsNullOrEmpty(line1))
            break;
    }
    `` `
    
&lt;/markdown&gt;
</code></pre><p>The content of the control is rendered to HTML at runtime which looks like this:</p><p><img src="https://weblog.west-wind.com/images/2019/A-Markdown-TagHelper-and-Parser-for-ASP.NET-Core/MarkdownRendered.png" alt=""></p><p>The above renders with default Bootstrap styling of an ASP.NET Core MVC default Web site plus <a href="https://highlightjs.org/">hilightjs</a> for the code highlighting. You can check out the full <a href="https://github.com/RickStrahl/Westwind.AspNetCore/blob/master/SampleWeb/Pages/Markdown.cshtml"><code>Markdown.cshtml</code> page on Github</a>. The code of that page also includes the highlightjs hookup code to make the source code sample look nice.</p><p>It's important to understand that rendered Markdown is <strong>just HTML</strong> there's nothing in Markdown that handles styling of the content - that's left up to the host site or tool that displays the final HTML output. Any formatting comes from the host application, in this case the stock ASP.NET Core template for sample purposes.</p><p>Using this control allows you to easily create content areas inside of HTML documents that are rendered from Markdown. You write Markdown, the control renders HTML at runtime.</p><p>As part of this component I'll also provide a simple way to parse Markdown in code and inside of @RazorPages.</p><h2 id="creating-a-markdown-taghelper">Creating a Markdown TagHelper</h2><p>Before we dive in let's briefly discuss what TagHelpers are for those of you new to ASP.NET Core and then look at what it takes to create one.</p><h3 id="what-is-a-taghelper">What is a TagHelper?</h3><p>TagHelpers are a new feature for ASP.NET Core MVC, and it's easily one of the nicest improvements for server side HTML generation. TagHelpers are self contained components that are embedded into a <strong>@Razor</strong> page. TagHelpers look like HTML tags and unlike Razor expressions (@Expression) feel natural inside of standard HTML content in a Razor page.</p><p>Many of the existing Model binding and HTML helpers in ASP.NET have been replaced by TagHelpers and TagHelper behaviors that allow you to directly bind to HTML controls in a page. For example, here is an Input tag bound to a model value.</p><p>For example:</p><pre><code class="language-html">&lt;input type="email" asp-for="Email" 
       placeholder="Your email address"
       class="form-control"/&gt;
</code></pre><p>where <code>asp-for</code> extends the <code>input</code> element with an extension attribute to provide the model binding to the value property. This replaces:</p><pre><code class="language-html">@Html.TextBoxFor(model =&gt; model.Email, 
                 new { @class = "form-control",
                      placeholder = "your email address", 
                      type = "email" })
</code></pre><p>Which would you rather use? 😃 TagHelpers make it easier to write your HTML markup by sticking to standard HTML syntax which feels more natural than using Razor expressions.</p><h3 id="make-your-own-taghelpers">Make your own TagHelpers</h3><p>Another important point is that it's very easy to create your own TagHelpers which is the focus of this post. The interface to create a TagHelper is primarily a single method interface that takes a Context input to get element, tag and content information and an output string that has to be generated of for the actual TagHelper output. Using this approach feels very natural and makes it easy to create your own tag helpers with minimal fuss.</p><p>A TagHelper encapsulates rendering logic via a very simple <code>ProcessAsync()</code> interface that renders a chunk of HTML content into the page at the location the TagHelper is defined. The <code>ProcessAsync()</code> method takes a TagHelper Context as input to let you get at the element and attributes for input, and provides an output that you can write string output to generate your embedded content. As we'll see it takes very little code to create a very useful TagHelper.</p><p>In order to use TagHelpers they have to be registered with MVC, either in the page or more likely in the <code>_ViewImports.cshtml</code> page of the project.</p><p>To create a Tag Helper these are the things you typically need to do:</p><ul><li>Create a new Class and Inherit from <code>TagHelper</code></li><li>Create your TagHelper implementation via <code>ProcessAsync()</code> or <code>Process()</code>.</li><li>Register your TagHelper in <code>_ViewImports.cshtml</code></li><li>Reference your TagHelper in your pages</li><li>Rock on!</li></ul><h3 id="creating-the-markdowntaghelper-class">Creating the MarkdownTagHelper Class</h3><p>For the <code>&lt;markdown&gt;</code> TagHelper I want to create a content control whose content can be retrieved and parsed as Markdown and then converted into HTML. Optionally you can also use a <code>Markdown</code> property to bind Markdown for rendering - so if you have Markdown as part of data in your model you can bind it to this property/attribute in lieu of static content you provide.</p><p>Here's the base code for the <code>MarkdownTagHelper</code> that accomplishes these tasks:</p><pre><code class="language-cs">[HtmlTargetElement("markdown")]
public class MarkdownTagHelper : TagHelper
{
    [HtmlAttributeName("normalize-whitespace")]
    public bool NormalizeWhitespace { get; set; } = true;

    [HtmlAttributeName("markdown")]
    public ModelExpression Markdown { get; set; }

    public override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output)
    {
        await base.ProcessAsync(context, output);

        string content = null;
        if (Markdown != null)
            content = Markdown.Model?.ToString();

        if (content == null)            
            content = (await output.GetChildContentAsync(NullHtmlEncoder.Default))
                            .GetContent(NullHtmlEncoder.Default);

        if (string.IsNullOrEmpty(content))
            return;

        content = content.Trim('\n', '\r');

        string markdown = NormalizeWhiteSpaceText(content);            

        var parser = MarkdownParserFactory.GetParser();
        var html = parser.Parse(markdown);

        output.TagName = null;  // Remove the &lt;markdown&gt; element
        output.Content.SetHtmlContent(html);
    }
}
</code></pre><p>Before you can use the TagHelper in a page you'll need to register it with the MVC application by sticking the following into the <code>_ViewImports.cshtml</code>:</p><pre><code class="language-html">@addTagHelper *, Westwind.AspNetCore.Markdown
</code></pre><p>Now you're ready to use the TagHelper:</p><pre><code class="language-html">&lt;markdown&gt;This is **Markdown Text**. Render me!&lt;/markdown&gt;
</code></pre><p>As you can see the code to handle the actual processing of the markdown is very short and easy to understand. It grabs either the content of the <code>&lt;markdown&gt;</code> element or the <code>markdown</code> attribute and then passes that to the the Markdown Parser to process. The parser turns the Markdown text into HTML which is the written out as HTML content using <code>output.Content.SetHtmlContent()</code>.</p><p>The code uses an abstraction for the Markdown Parser so the parser can be more easily replaced in the future without affecting the TagHelper code. I've gone through a few iterations of Markdown Parsers before landing on MarkDig, and I use this code in many places where I add Markdown parsing. I'll come back to the Markdown Parser in a minute.</p><h3 id="markdown-attribute-and-databinding">Markdown Attribute and DataBinding</h3><p>In addition to the content you can also bind to the <code>markdown</code> attribute which allows for programmatic assignment and databinding.</p><pre><code>@model MarkdownModel
@{
    Model.MarkdownText = "This is some **Markdown**!";
}

&lt;markdown markdown="Model.MarkdownText" /&gt;
</code></pre><p>The <code>markdown</code> attribute accepts binding expressions you can bind Markdown for display from model values or other expressions easily.</p><h3 id="normalizing-markdown-text">Normalizing Markdown Text</h3><p>One issue with using a TagHelper or Control for Markdown is that Markdown expects no margins in the Markdown text to process.</p><p>If you have Markdown like this:</p><pre><code class="language-html">&lt;markdown&gt;
    #### This is Markdown text inside of a Markdown block

    * Item 1
    * Item 2
 
    ### Dynamic Data is supported:
    The current Time is: @DateTime.Now.ToString("HH:mm:ss")

    ```cs
    // this c# is a code block
    for (int i = 0; i &lt; lines.Length; i++)
    {
        line1 = lines[i];
        if (!string.IsNullOrEmpty(line1))
            break;
    }
    ```
&lt;/markdown&gt;
</code></pre><p>and leave this Markdown in its raw form with the indent, the Markdown parser would render the entire Markdown text as a <strong>code block</strong>, because the text is indented with 4 spaces which is constitutes a code block in Markdown. Not what we want here!</p><p>This is where the <code>NormalizeWhiteSpace</code> property comes into play. This flag, which is <code>true</code> by default, determines whether leading repeated white space is stripped from the embedded Markdown block.</p><p>Here's the code to strip leading white space:</p><pre><code class="language-cs">string NormalizeWhiteSpaceText(string text)
{
    if (!NormalizeWhitespace || string.IsNullOrEmpty(text))
        return text;

    var lines = GetLines(text);
    if (lines.Length &lt; 1)
        return text;

    string line1 = null;

    // find first non-empty line
    for (int i = 0; i &lt; lines.Length; i++)
    {
        line1 = lines[i];
        if (!string.IsNullOrEmpty(line1))
            break;
    }

    if (string.IsNullOrEmpty(line1))
        return text;

    string trimLine = line1.TrimStart();
    int whitespaceCount = line1.Length - trimLine.Length;
    if (whitespaceCount == 0)
        return text;

    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; lines.Length; i++)
    {
        if (lines[i].Length &gt; whitespaceCount)
            sb.AppendLine(lines[i].Substring(whitespaceCount));
        else
            sb.AppendLine(lines[i]);
    }

    return sb.ToString();
}

string[] GetLines(string s, int maxLines = 0)
{
    if (s == null)
        return null;

    s = s.Replace("\r\n", "\n");

    if (maxLines &lt; 1)
        return s.Split(new char[] { '\n' });

    return s.Split(new char[] { '\n' }).Take(maxLines).ToArray();
}
</code></pre><p>This code works by looking at the first non-empty line and checking for leading White space. It captures this white space and then removes that same leading whitespace from all lines of the content. This works as long as the Markdown Block uses consistent white space for all lines (ie. all tabs or all n spaces etc.).</p><p>If <code>normalize-whitespace="false"</code> in the document, you can still use the TagHelper but you have to ensure the that text is left justified in the saved razor file. This is hard if you're using Visual Studio as it'll try to reformat the doc and re-introduce the whitespace, so the default for this attribute is <code>true</code>.</p><p>To look at the complete code for this class you can check the code on Github:</p><h3 id="razor-expressions-in-markdown">Razor Expressions in Markdown</h3><p>If you look back at the Markdown example above you might have noticed that the embedded Markdown includes a @Razor expression inside of the <code>&lt;markdown&gt;</code> tag.</p><p>The following works as you would expect:</p><pre><code class="language-html">&lt;markdown&gt;
The current Time is: **@DateTime.Now.ToString("HH:mm:ss")**
&lt;/markdown&gt;
</code></pre><p>Razor processes the expression <strong>before</strong> it passes the content to the TagHelper, so in this example the date is already expanded when the Markdown parsing is fired.</p><blockquote><h4 id="icon-info-circle-razor-expressions-and-encoding"><i class="fa fa-info-circle"></i>  Razor Expressions and Encoding</h4><p>If you look at the code that parses the <strong>content</strong> of the Razor tag helper element you'll notice this nasty syntax:</p><pre><code class="language-cs">if (content == null)            
    content = (await output.GetChildContentAsync(NullHtmlEncoder.Default))
             .GetContent(NullHtmlEncoder.Default);
</code></pre><p>This is necessary to ensure that any expressions evaluated <strong>are not HTML encoded</strong> when parsed. Razor Expressions encode by default and that's not what we want inside of the Markdown content here, so the <code>NullHtmlEncoder.Default</code> essentially creates a pass-through encoder that does nothing and simply returns the raw output of an expression. Keep this in mind when building your own tag helpers that work with content. Thanks to <a href="https://twitter.com/DamianEdwards">Damien Edwards</a> for pointing that out.</p></blockquote><p>This is pretty cool - you can essentially use most of Razor's features in place. Just make sure that you generate <strong>Markdown</strong> compatible text from your Razor expressions and code.</p><h2 id="markdown-parsing-with-markdig">Markdown Parsing with Markdig</h2><p>The TagHelper above relies on a customized MarkdownParser implentation. As mentioned this component uses the MarkDig Markdown parser, but I added some abstraction around the Markdown Parser as I've switched parsers frequently in the past before settling pretty solidly on MarkDig.</p><p>Parsing Markdown with Markdig is pretty simple, and if you want to be quick about it, you can easily create a function that does the following to parse Markdown using MarkDig:</p><pre><code class="language-cs">public static class Markdown
{
    public static string Parse(string markdown) 
    {
        var pipeline = new MarkdownPipelineBuilder()
                             .UseAdvancedExtensions()
                             .Build();
        return Markdown.ToHtml(markdown, pipeline);
    }
}        
</code></pre><p>MarkDig uses a configuration pipeline of support features that you can add on top of the base parser. The example above adds a number of common extensions (like Github Flavored Markdown, List Extensions etc.), but you can also add each of the components you want to customize exactly how you want Markdown to be parsed.</p><p>The code above is not super efficient as the pipeline needs to be recreated for each parse operation and that's part of the reason that I built a small abstraction layer around the Markdown parser so the parser can be easily switched without affecting the rest of the application and so that the generated Pipeline can be cached for better performance.</p><h3 id="a-markdownparserfactory">A MarkdownParserFactory</h3><p>The first thing is a Markdown Parser factory that provides an <code>IMarkdownParser</code> interface which has little more than that a <code>Parse()</code> method:</p><pre><code class="language-cs">public interface IMarkdownParser
{
    string Parse(string markdown);
}
</code></pre><p>The Factory then produces the Interface with at this point a hardcoded implementation for MarkDig in place. The factory also caches the Parser instance so it can be reused without reloading the entire parsing pipeline on each parse operation:</p><pre><code class="language-cs">/// &lt;summary&gt;
/// Retrieves an instance of a markdown parser
/// &lt;/summary&gt;
public static class MarkdownParserFactory
{
    /// &lt;summary&gt;
    /// Use a cached instance of the Markdown Parser to keep alive
    /// &lt;/summary&gt;
    static IMarkdownParser CurrentParser;

    /// &lt;summary&gt;
    /// Retrieves a cached instance of the markdown parser
    /// &lt;/summary&gt;                
    /// &lt;param name="forceLoad"&gt;Forces the parser to be reloaded - otherwise previously loaded instance is used&lt;/param&gt;
    /// &lt;param name="usePragmaLines"&gt;If true adds pragma line ids into the document that the editor can sync to&lt;/param&gt;
    /// &lt;returns&gt;Mardown Parser Interface&lt;/returns&gt;
    public static IMarkdownParser GetParser(bool usePragmaLines = false,
                                            bool forceLoad = false)                                                
    {
        if (!forceLoad &amp;&amp; CurrentParser != null)
            return CurrentParser;
        
        CurrentParser = new MarkdownParserMarkdig(usePragmaLines, forceLoad);

        return CurrentParser;
    }
}
</code></pre><p>Finally there's the actual <code>MarkDigMarkdownParser</code> implementation that's responsible for handling the actual configuration of the parser pipeline and parsing the Markdown to HTML. The class inherits from a <code>MarkdownParserBase</code> class that provides a few optional pre and post processing features such as font awesome font-embedding, yaml stripping (which is not built into MarkDig but not other parsers) etc.</p><pre><code class="language-cs">/// &lt;summary&gt;
/// Wrapper around the MarkDig parser that provides a cached
/// instance of the Markdown parser. Hooks up custom processing.
/// &lt;/summary&gt;
public class  MarkdownParserMarkdig : MarkdownParserBase
{
    public static MarkdownPipeline Pipeline;

    private readonly bool _usePragmaLines;

    public MarkdownParserMarkdig(bool usePragmaLines = false, bool force = false, Action&lt;MarkdownPipelineBuilder&gt; markdigConfiguration = null)
    {
        _usePragmaLines = usePragmaLines;
        if (force || Pipeline == null)
        {                
            var builder = CreatePipelineBuilder(markdigConfiguration);                
            Pipeline = builder.Build();
        }
    }

    /// &lt;summary&gt;
    /// Parses the actual markdown down to html
    /// &lt;/summary&gt;
    /// &lt;param name="markdown"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;        
    public override string Parse(string markdown)
    {
        if (string.IsNullOrEmpty(markdown))
            return string.Empty;

        var htmlWriter = new StringWriter();
        var renderer = CreateRenderer(htmlWriter);

        Markdig.Markdown.Convert(markdown, renderer, Pipeline);

        var html = htmlWriter.ToString();
        
        html = ParseFontAwesomeIcons(html);

        //if (!mmApp.Configuration.MarkdownOptions.AllowRenderScriptTags)
        html = ParseScript(html);  
                  
        return html;
    }

    public virtual MarkdownPipelineBuilder CreatePipelineBuilder(Action&lt;MarkdownPipelineBuilder&gt; markdigConfiguration)
        {
            MarkdownPipelineBuilder builder = null;

            // build it explicitly
            if (markdigConfiguration == null)
            {
                builder = new MarkdownPipelineBuilder()
                    .UseEmphasisExtras()
                    .UsePipeTables()
                    .UseGridTables()
                    .UseFooters()
                    .UseFootnotes()
                    .UseCitations()
                    .UseAutoLinks() // URLs are parsed into anchors
                    .UseAutoIdentifiers(AutoIdentifierOptions.GitHub) // Headers get id="name" 
                    .UseAbbreviations()
                    .UseYamlFrontMatter()
                    .UseEmojiAndSmiley(true)
                    .UseMediaLinks()
                    .UseListExtras()
                    .UseFigures()
                    .UseTaskLists()
                    .UseCustomContainers()
                    .UseGenericAttributes();

                //builder = builder.UseSmartyPants();            

                if (_usePragmaLines)
                    builder = builder.UsePragmaLines();

                return builder;
            }
            
            
            // let the passed in action configure the builder
            builder = new MarkdownPipelineBuilder();
            markdigConfiguration.Invoke(builder);

            if (_usePragmaLines)
                builder = builder.UsePragmaLines();
            
            return builder;
        }

        protected virtual IMarkdownRenderer CreateRenderer(TextWriter writer)
        {
            return new HtmlRenderer(writer);
        }
    }

    protected virtual IMarkdownRenderer CreateRenderer(TextWriter writer)
    {
        return new HtmlRenderer(writer);
    }
}
</code></pre><p>The key bit about this class is that it can be used to configure how the Markdown Parser renders to HTML.</p><p>That's a bit of setup, but once it's all done you can now do:</p><pre><code class="language-cs">var parser = MarkdownParserFactory.GetParser();
var html = parser.Parse(markdown);
</code></pre><p>and that's what the Markdown TagHelper uses to get a cached MarkdownParser instance for processing.</p><h3 id="overriding-markdig-pipeline-with-configuration">Overriding MarkDig Pipeline with Configuration</h3><p>This component uses the MarkDig Markdown Parser which allows for explicit feature configuration via many of its built-in extensions. The default configuration enables the most commonly used Markdown features and defaults to Github Flavored Markdown for most settings.</p><p>If you need to customize what features are supported you can override the pipeline creation explicitly in the <code>Startup.ConfigureServices</code> method and calling <code>services.AddMarkdown()</code>:</p><pre><code class="language-cs">services.AddMarkdown(config =&gt;
{
    // Create custom MarkdigPipeline 
    // using MarkDig; for extension methods
    config.ConfigureMarkdigPipeline = builder =&gt;
    {
        builder.UseEmphasisExtras(Markdig.Extensions.EmphasisExtras.EmphasisExtraOptions.Default)
            .UsePipeTables()
            .UseGridTables()                        
            .UseAutoIdentifiers(AutoIdentifierOptions.GitHub) // Headers get id="name" 
            .UseAutoLinks() // URLs are parsed into anchors
            .UseAbbreviations()
            .UseYamlFrontMatter()
            .UseEmojiAndSmiley(true)                        
            .UseListExtras()
            .UseFigures()
            .UseTaskLists()
            .UseCustomContainers()
            .UseGenericAttributes();
    };
});
</code></pre><p>This code gets passed an empty <code>MarkDigPipelineBuilder</code> that you can use to create a custom parser pipeline with just the features you need. When set this configuration is used every time the Markdown parser instance is created instead of the default behavior.</p><blockquote><h4 id="markdown-pipeline-configuration-options">Markdown Pipeline Configuration Options</h4><p>The library also supports configuration of the Markdown pileline via configuration handler that can be set up in the <code>Startup.Configure</code> method. <a href="https://weblog.west-wind.com/posts/2018/Apr/18/Creating-a-generic-Markdown-Page-Handler-in-ASPNET-Core#configuration-options">I cover the details of configuration in my next post</a> on the the Page Handling Markdown Middleware.</p></blockquote><h3 id="standalone-markdown-processing">Standalone Markdown Processing</h3><p>In addition to the TagHelper there's also a static class that lets you easily process Markdown in code or inside of a RazorPage, using a static <code>Markdown</code> class:</p><pre><code class="language-csharp">public static class Markdown
{
    /// &lt;summary&gt;
    /// Renders raw markdown from string to HTML
    /// &lt;/summary&gt;
    /// &lt;param name="markdown"&gt;&lt;/param&gt;
    /// &lt;param name="usePragmaLines"&gt;&lt;/param&gt;
    /// &lt;param name="forceReload"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static string Parse(string markdown, bool usePragmaLines = false, bool forceReload = false)
    {
        if (string.IsNullOrEmpty(markdown))
            return "";

        var parser = MarkdownParserFactory.GetParser(usePragmaLines, forceReload);
        return parser.Parse(markdown);
    }

    /// &lt;summary&gt;
    /// Renders raw Markdown from string to HTML.
    /// &lt;/summary&gt;
    /// &lt;param name="markdown"&gt;&lt;/param&gt;
    /// &lt;param name="usePragmaLines"&gt;&lt;/param&gt;
    /// &lt;param name="forceReload"&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static HtmlString ParseHtmlString(string markdown, bool usePragmaLines = false, bool forceReload = false)
    {
        return new HtmlString(Parse(markdown, usePragmaLines, forceReload));
    }
}
</code></pre><p>In code you can now do:</p><pre><code class="language-cs">string html = Markdown.Parse(markdownText)
</code></pre><p>Inside of Razor code you can do:</p><pre><code class="language-html">&lt;div&gt;@Markdown.ParseHtmlString(Model.ProductInfoMarkdown)&lt;/div&gt;
</code></pre><h3 id="summary">Summary</h3><p>As with the WebForms control none of this is anything very new, but I find that this is such a common use case that it's worth to have a reusable and easily accessible component for this sort of functionality. With a small Nuget package it's easy to add Markdown support both for content embedding as well as simple parsing.</p><p>As Markdown is getting ever more ubiquitous, most applications can benefit from including some Markdown features. For content sites especially Markdown can be a good fit for creating the actual text content inside of pages and the <code>&lt;markdown&gt;</code> control discussed here actually makes that very easy.</p><p>I was recently helping my girlfriend set up a landing page for her Web site and using Markdown I was able to actually set up a few content blocks in the page and let her loose on editing her own content easily. No way that would have worked with raw HTML.</p><p>Enjoy...</p><h3 id="resources">Resources</h3><div><h3>Other Posts you might also like
            </h3></div></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>