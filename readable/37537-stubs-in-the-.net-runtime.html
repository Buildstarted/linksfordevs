<!DOCTYPE html>
<html lang="en">
<head>
    <title>
&#x201C;Stubs&#x201D; in the .NET Runtime -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>&#x201C;Stubs&#x201D; in the .NET Runtime</h1>
    <div class="post"> <span class="post-date">26 Sep 2019 - 11778 words</span> <p>As the saying goes:</p> <blockquote> <p>&#x201C;All problems in computer science can be solved by another level of indirection&#x201D;</p> <p>- <a href="https://www2.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html#another_level_of_indirection">David Wheeler</a></p>
</blockquote> <p>and it certainly seems like the &#x2018;.NET Runtime&#x2019; Engineers took this advice to heart!</p> <p><a href="https://en.wikipedia.org/wiki/Method_stub">&#x2018;Stubs&#x2019;</a>, as they&#x2019;re known in the runtime (sometimes <a href="https://en.wikipedia.org/wiki/Thunk">&#x2018;Thunks&#x2019;</a>), provide a level of indirection throughout the source code, there&#x2019;s almost <a href="https://github.com/dotnet/coreclr/search?q=stub+OR+thunk&amp;unscoped_q=stub+OR+thunk">500 mentions of them</a>!</p> <p>This post will explore <strong>what</strong> they are, <strong>how</strong> they work and <strong>why</strong> they&#x2019;re needed.</p> <p><strong>Table of Contents</strong></p> <h2 id="what-are-stubs">What are stubs?</h2> <p>In the context of the .NET Runtime, &#x2018;stubs&#x2019; look something like this:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Call-site                                         Callee
+--------------+           +---------+           +-------------+
|              |           |         |           |             |
|              +----------&gt;+  Stub   + - - - - -&gt;+             |
|              |           |         |           |             |
+--------------+           +---------+           +-------------+
</code></pre></div></div> <p>So they sit between a method &#x2018;<em>call-site</em>&#x2019; (i.e. code such as <code class="highlighter-rouge">var result = Foo(..);</code>) and the &#x2018;<em>callee</em>&#x2019; (where the method itself is implemented, the native/assembly code) and I like to think of them as doing <strong>tidy-up</strong> or <strong>fix-up</strong> work. Note that moving from the &#x2018;stub&#x2019; to the &#x2018;callee&#x2019; isn&#x2019;t another full method call (hence the dotted line), it&#x2019;s often just a single <code class="highlighter-rouge">jmp</code> or <code class="highlighter-rouge">call</code> assembly instruction, so the 2nd transition doesn&#x2019;t involve all the same work that was initially done at the call-site (pushing/popping arguments into registers, increasing the stack space, etc).</p> <p>The stubs themselves can be as simple as just a few assembly instructions or something more complicated, we&#x2019;ll look at individual examples <a href="#types-of-stubs">later on in this post</a>.</p> <p>Now, to be clear, not <em>all</em> method calls require a stub, if you&#x2019;re doing a regular call to an <em>static</em> or <em>instance</em> method that just goes directly from the &#x2018;call-site&#x2019; to the &#x2018;callee&#x2019;. But once you involve <a href="#virtual-stub-dispatch-vsd">virtual methods</a>, <a href="#delegates">delegates</a> or <a href="#generics">generics</a> things get a bit more complicated.</p> <h3 id="why-are-stubs-needed">Why are stubs needed?</h3> <p>There are several reasons that stubs need to be created by the runtime:</p> <ul> <li><strong>Required Functionality</strong> <ul> <li>For instance <a href="#delegates">Delegates</a> and <a href="#arrays">Arrays</a> <em>must</em> be provided but the runtime, their method bodies are not generated by the C#/F#/VB.NET compiler and neither do they exist in the <a href="https://github.com/dotnet/corefx">Base-Class Libraries</a>. This requirement is outlined in the <a href="/2018/04/06/Taking-a-look-at-the-ECMA-335-Standard-for-.NET/">ECMA 355 Spec</a>, for instance &#x2018;Partition I&#x2019; in section &#x2018;8.9.1 Array types&#x2019; says: <blockquote> <p>Exact array types are <strong>created automatically by the VES when they are required</strong>. Hence, the operations on an array type are defined by the CTS. These generally are: allocating the array based on size and lower-bound information, indexing the array to read and write a value, computing the address of an element of the array (a managed pointer), and querying for the rank, bounds, and the total number of values stored in the array.</p> </blockquote> <p>Likewise for delegates, which are covered in &#x2018;I.8.9.3 Delegates&#x2019;:</p> <blockquote> <p>While, for the most part, delegates appear to be simply another kind of user-defined class, they are tightly controlled. <strong>The implementations of the methods are provided by the VES, not user code</strong>. The only additional members that can be defined on delegate types are static or instance methods.</p> </blockquote> </li> </ul> </li> <li><strong>Performance</strong> </li> <li><strong>Consistent method calls</strong> <ul> <li>A final factor is that having &#x2018;stubs&#x2019; makes the work of the JIT compiler easier. As we will see in the rest of the post, stubs deal with a variety of different types of method calls. This means the the JIT can generate more straightforward code for any given &#x2018;call site&#x2019;, because it (mostly) doesn&#x2019;t care whats happening in the &#x2018;callee&#x2019;. If stubs didn&#x2019;t exist, for a given method call the JIT would have to generate different code depending on whether generics where involved or not, if it was a virtual or non-virtual call, if it was going via a delegate, etc. Stubs abstact a lot of this behaviour away from the JIT, allowing it to deal with a more simple &#x2018;Application Binary Interface&#x2019; (ABI).</li> </ul> </li>
</ul> <h3 id="clr-application-binary-interface-abi">CLR &#x2018;Application Binary Interface&#x2019; (ABI)</h3> <p>Therefore, another way to think about &#x2018;stubs&#x2019; is that they are part of what makes the CLR-specific <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/clr-abi.md">&#x2018;Application Binary Interface&#x2019; (ABI)</a> work.</p> <p>All code needs to work with the ABI or &#x2018;calling convention&#x2019; of the CPU/OS that it&#x2019;s running on, for instance by following the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">x86 calling convention</a>, <a href="https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=vs-2019">x64 calling convention</a> or <a href="https://wiki.osdev.org/System_V_ABI">System V ABI</a>. This applies across runtimes, for more on this see:</p> <p>As an aside, if you want more information about &#x2018;calling conventions&#x2019; here&#x2019;s some links that I found useful:</p> <p>However, on-top of what the CLR <em>has</em> to support due to the CPU/OS conventions, it also has it&#x2019;s own <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/clr-abi.md">extended ABI</a> for <em>.NET-specific</em> use cases, including:</p> <ul> <li><a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/clr-abi.md#the-this-pointer">&#x201C;this&#x201D; pointer</a>: <blockquote> <p><strong>The managed &#x201C;this&#x201D; pointer is treated like a new kind of argument not covered by the native ABI</strong>, so we chose to always pass it as the first argument in (AMD64) <code class="highlighter-rouge">RCX</code> or (ARM, ARM64) <code class="highlighter-rouge">R0</code>.
AMD64-only: Up to .NET Framework 4.5, the managed &#x201C;this&#x201D; pointer was treated just like the native &#x201C;this&#x201D; pointer (meaning it was the second argument when the call used a return buffer and was passed in <code class="highlighter-rouge">RDX</code> instead of <code class="highlighter-rouge">RCX</code>). Starting with .NET Framework 4.5, it is always the first argument.</p> </blockquote> </li> <li><a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/clr-abi.md#generics">Generics</a> or more specifically to handle &#x2018;Shared generics&#x2019;: <blockquote> <p><strong>In cases where the code address does not uniquely identify a generic instantiation of a method, then a &#x2018;generic instantiation parameter&#x2019; is required</strong>. Often the &#x201C;this&#x201D; pointer can serve dual-purpose as the instantiation parameter. When the &#x201C;this&#x201D; pointer is not the generic parameter, <strong>the generic parameter is passed as an additional argument</strong>..</p> </blockquote> </li> <li><a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/clr-abi.md#hidden-parameters">Hidden Parameters</a>, covering &#x2018;Stub dispatch&#x2019;, &#x2018;Fast Pinvoke&#x2019;, &#x2018;Calli Pinvoke&#x2019; and &#x2018;Normal PInvoke&#x2019;. For instance, here&#x2019;s why &#x2018;PInvoke&#x2019; has a hidden parameter: <blockquote> <p><em>Normal PInvoke</em> - The VM <strong>shares IL stubs based on signatures</strong>, but wants the <strong>right method to show up in call stack and exceptions</strong>, so the MethodDesc for the exact PInvoke is passed in the (x86) <code class="highlighter-rouge">EAX</code> / (AMD64) <code class="highlighter-rouge">R10</code> / (ARM, ARM64) <code class="highlighter-rouge">R12</code> (in the JIT: <code class="highlighter-rouge">REG_SECRET_STUB_PARAM</code>). Then in the IL stub, when the JIT gets <code class="highlighter-rouge">CORJIT_FLG_PUBLISH_SECRET_PARAM</code>, it must move the register into a compiler temp.</p> </blockquote> </li>
</ul> <p>Not all of these scenarios need a stub, for instance the &#x2018;this&#x2019; pointer is handled directly by the JIT, but many do as we&#x2019;ll see in the rest of the post.</p> <h3 id="stub-management">Stub Management</h3> <p>So we&#x2019;ve seen why stubs are needed and what type of functionality they can provide. But before we look at all the specific examples that exist in the <a href="https://github.com/dotnet/coreclr/tree/master/src">CoreCLR source</a>, I just wanted to take some time to understand the common or shared concerns that apply to all stubs.</p> <p>Stubs in the CLR are snippets of assembly code, but they have to be stored in memory and have their life-time managed. Also, they have to play nice with the debugger, from <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/coding-guidelines/clr-code-guide.md">What Every CLR Developer Must Know Before Writing Code</a>:</p> <blockquote> <p><strong>2.8 Is your code compatible with managed debugging?</strong></p> <ul> <li>..</li> <li>If you add a new stub (or way to call managed code), make sure that you can <strong>source-level step-in (F11) it under the debugger</strong>. The debugger is not psychic. A source-level step-in needs to be able to go <strong>from the source-line before a call to the source-line after the call</strong>, or managed code developers will be very confused. If you make that call transition be a giant 500 line stub, you must cooperate with the debugger for it to know how to step-through it. (<strong>This is what StubManagers are all about. See <a href="https://github.com/dotnet/coreclr/blob/master/src/vm/stubmgr.h">src\vm\stubmgr.h</a></strong>). Try doing a step-in through your new codepath under the debugger.</li> </ul>
</blockquote> <p>So every type of stub has a <code class="highlighter-rouge">StubManager</code> which deals with the allocation, storage and lookup of the stubs. The lookup is significant, as it provides the mapping from an arbitrary memory address to the type of stub (if any) that created the code. As an example, here&#x2019;s what the <code class="highlighter-rouge">CheckIsStub_Internal(..)</code> method <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L2107-L2122">here</a> and <code class="highlighter-rouge">DoTraceStub(..)</code> method <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L2124-L2140">here</a> look like for the <code class="highlighter-rouge">DelegateInvokeStubManager</code>:</p> <pre><code class="language-C++">BOOL DelegateInvokeStubManager::CheckIsStub_Internal(PCODE stubStartAddress)
{
    LIMITED_METHOD_DAC_CONTRACT;

    bool fIsStub = false;

#ifndef DACCESS_COMPILE
#ifndef _TARGET_X86_
    fIsStub = fIsStub || (stubStartAddress == GetEEFuncEntryPoint(SinglecastDelegateInvokeStub));
#endif
#endif // !DACCESS_COMPILE

    fIsStub = fIsStub || GetRangeList()-&gt;IsInRange(stubStartAddress);

    return fIsStub;
}

BOOL DelegateInvokeStubManager::DoTraceStub(PCODE stubStartAddress, TraceDestination *trace)
{
    LIMITED_METHOD_CONTRACT;

    LOG((LF_CORDB, LL_EVERYTHING, &quot;DelegateInvokeStubManager::DoTraceStub called\n&quot;));

    _ASSERTE(CheckIsStub_Internal(stubStartAddress));

    // If it&apos;s a MC delegate, then we want to set a BP &amp; do a context-ful
    // manager push, so that we can figure out if this call will be to a
    // single multicast delegate or a multi multicast delegate
    trace-&gt;InitForManagerPush(stubStartAddress, this);

    LOG_TRACE_DESTINATION(trace, stubStartAddress, &quot;DelegateInvokeStubManager::DoTraceStub&quot;);

    return TRUE;
}
</code></pre> <p>The code to initialise the various stub managers is <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/appdomain.cpp#L1668-L1679">here</a> in <code class="highlighter-rouge">SystemDomain::Attach()</code> and by working through the list we can get a sense of what each category of stub does (plus the informative comments in the code help!)</p> <ul> <li><code class="highlighter-rouge">PrecodeStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L972-L1123">here</a> <ul> <li>&#x2018;<em>Stub manager functions &amp; globals</em>&#x2019;</li> </ul> </li> <li><code class="highlighter-rouge">DelegateInvokeStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L2061-L2343">here</a> <ul> <li>&#x2018;<em>Since we don&#x2019;t generate delegate invoke stubs at runtime on IA64, we can&#x2019;t use the StubLinkStubManager for these stubs. Instead, we create an additional DelegateInvokeStubManager instead.</em>&#x2019;</li> </ul> </li> <li><code class="highlighter-rouge">JumpStubStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L1334-L1381">here</a> <ul> <li>&#x2018;<em>Stub manager for jump stubs created by ExecutionManager::jumpStub() These are currently used only on the 64-bit targets IA64 and AMD64</em>&#x2019;</li> </ul> </li> <li><code class="highlighter-rouge">RangeSectionStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L1383-L1591">here</a> <ul> <li>&#x2018;<em>Stub manager for code sections. It forwards the query to the more appropriate stub manager, or handles the query itself.</em>&#x2019;</li> </ul> </li> <li><code class="highlighter-rouge">ILStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L1593-L1893">here</a> <ul> <li>&#x2018;<em>This is the stub manager for IL stubs</em>&#x2019;</li> </ul> </li> <li><code class="highlighter-rouge">InteropDispatchStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L1897-L2058">here</a> <ul> <li>&#x2018;<em>This is used to recognize GenericComPlusCallStub, VarargPInvokeStub, and GenericPInvokeCalliHelper.</em>&#x2019;</li> </ul> </li> <li><code class="highlighter-rouge">StubLinkStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L1126-L1282">here</a></li> <li><code class="highlighter-rouge">ThunkHeapStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L1286-L13321">here</a> <ul> <li>&#x2018;<em>Note, the only reason we have this stub manager is so that we can recgonize UMEntryThunks for IsTransitionStub. ..</em>&#x2019;</li> </ul> </li> <li><code class="highlighter-rouge">TailCallStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L2350-L2488">here</a> <ul> <li>&#x2018;<em>This is the stub manager to help the managed debugger step into a tail call. It helps the debugger trace through JIT_TailCall().</em>&#x2019; (from stubmgr.h)</li> </ul> </li> <li><code class="highlighter-rouge">ThePreStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1993-L2032">here</a> (in prestub.cpp) <ul> <li>&#x2018;<em>The following code manages the PreStub. All method stubs initially use the prestub.</em>&#x2019;</li> </ul> </li> <li><code class="highlighter-rouge">VirtualCallStubManager</code> implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/virtualcallstub.cpp">here</a> (in virtualcallstub.cpp) </li>
</ul> <p>Finally, we can also see the &#x2018;StubManagers&#x2019; in action if we use the <code class="highlighter-rouge">eeheap</code> <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/sos-dll-sos-debugging-extension#commands">SOS command</a> to inspect the &#x2018;heap dump&#x2019; of a .NET Process, as it helps report the size of the different &#x2018;stub heaps&#x2019;:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; !eeheap -loader

Loader Heap:
--------------------------------------
System Domain: 704fd058
LowFrequencyHeap: Size: 0x0(0)bytes.
HighFrequencyHeap: 002e2000(8000:1000) Size: 0x1000(4096)bytes.
StubHeap: 002ea000(2000:1000) Size: 0x1000(4096)bytes.
Virtual Call Stub Heap:
- IndcellHeap: Size: 0x0(0)bytes.
- LookupHeap: Size: 0x0(0)bytes.
- ResolveHeap: Size: 0x0(0)bytes.
- DispatchHeap: Size: 0x0(0)bytes.
- CacheEntryHeap: Size: 0x0(0)bytes.
Total size: 0x2000(8192)bytes
--------------------------------------
</code></pre></div></div> <p>(output taken from <a href="https://blogs.msdn.microsoft.com/carlos/2009/11/09/net-generics-and-code-bloat-or-its-lack-thereof/">.NET Generics and Code Bloat (or its lack thereof)</a>)</p> <p>You can see that in this case the entire &#x2018;stub heap&#x2019; is taking up 4096 bytes and in addition there are more in-depth statistics covering the heaps used by <a href="#virtual-stub-dispatch-vsd">virtual call dispatch</a>.</p> <h2 id="types-of-stubs">Types of stubs</h2> <p>The different stubs used by the runtime fall into 3 main categories:</p> <p>Most stubs are wired up in <code class="highlighter-rouge">MethodDesc::DoPrestub(..)</code>, in this <a href="https://github.com/dotnet/coreclr/blob/964461ca69639003914fd4fedaf08baf1f388f7e/src/vm/prestub.cpp#L1891-L1941">section of code</a> or <a href="https://github.com/dotnet/coreclr/blob/964461ca69639003914fd4fedaf08baf1f388f7e/src/vm/prestub.cpp#L1801-LL1816">this section</a> for COM Interop. The stubs generated include the following (definitions taken from <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/method-descriptor.md#kinds-of-methoddescs">BOTR - &#x2018;Kinds of MethodDescs&#x2019;</a>, also see <code class="highlighter-rouge">enum MethodClassification</code> <a href="https://github.com/dotnet/coreclr/blob/855491b895b187bdc396c491884a370b11d999e9/src/vm/method.hpp#L100-L125">here</a>):</p> <ul> <li><strong>Instantiating</strong> in (<code class="highlighter-rouge">FEATURE_SHARE_GENERIC_CODE</code>, on by default) in <code class="highlighter-rouge">MakeInstantiatingStubWorker(..)</code> <a href="https://github.com/dotnet/coreclr/blob/964461ca69639003914fd4fedaf08baf1f388f7e/src/vm/prestub.cpp#L1505-L1552">here</a> <ul> <li><em>Used for less common IL methods that have generic instantiation or that do not have preallocated slot in method table.</em></li> </ul> </li> <li><strong>P/Invoke</strong> (a.k.a <strong>NDirect</strong>) in <code class="highlighter-rouge">GetStubForInteropMethod(..)</code> <a href="https://github.com/dotnet/coreclr/blob/2832f54a6602cd4c0dff4fa65163345ab3ad953c/src/vm/dllimport.cpp#L5757-L5824">here</a> <ul> <li><em>P/Invoke methods. These are methods marked with DllImport attribute.</em></li> </ul> </li> <li><strong>FCall</strong> methods in <code class="highlighter-rouge">ECall::GetFCallImpl(..)</code> <a href="https://github.com/dotnet/coreclr/blob/1f3f474a13bdde1c5fecdf8cd9ce525dbe5df000/src/vm/ecall.cpp#L355-L522">here</a> <ul> <li><em>Internal methods implemented in unmanaged code. These are methods marked with <code class="highlighter-rouge">MethodImplAttribute(MethodImplOptions.InternalCall)</code> attribute, delegate constructors and tlbimp constructors.</em></li> </ul> </li> <li><strong>Array</strong> methods in <code class="highlighter-rouge">GenerateArrayOpStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/cab949098dcdab9d458f102eb59e81311bac45c4/src/vm/array.cpp#L1023-L1068">here</a> <ul> <li><em>Array methods whose implementation is provided by the runtime (Get, Set, Address)</em></li> </ul> </li> <li><strong>EEImpl</strong> in <code class="highlighter-rouge">PCODE COMDelegate::GetInvokeMethodStub(EEImplMethodDesc* pMD)</code> <a href="https://github.com/dotnet/coreclr/blob/d3e39bc2f81e3dbf9e4b96347f62b49d8700336c/src/vm/comdelegate.cpp#L2075-L2118">here</a> <ul> <li><em>Delegate methods, implementation provided by the runtime</em></li> </ul> </li> <li><strong>COM Interop</strong> (<code class="highlighter-rouge">FEATURE_COMINTEROP</code>, on by default) in <code class="highlighter-rouge">GetStubForInteropMethod(..)</code> <a href="https://github.com/dotnet/coreclr/blob/2832f54a6602cd4c0dff4fa65163345ab3ad953c/src/vm/dllimport.cpp#L5757-L5824">here</a> <ul> <li><em>COM interface methods. Since the non-generic interfaces can be used for COM interop by default, this kind is usually used for all interface methods.</em></li> </ul> </li> <li><strong>Unboxing</strong> in <code class="highlighter-rouge">Stub * MakeUnboxingStubWorker(MethodDesc *pMD)</code> <a href="https://github.com/dotnet/coreclr/blob/964461ca69639003914fd4fedaf08baf1f388f7e/src/vm/prestub.cpp#L1470-L1502">here</a></li>
</ul> <p>Right, now lets look at the individual stub in more detail.</p> <h3 id="precode">Precode</h3> <p>First up, we&#x2019;ll take a look at &#x2018;precode&#x2019; stubs, because they are used by all other types of stubs, as explained in the BotR page on <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/method-descriptor.md#precode">Method Descriptors</a>:</p> <blockquote> <p>The precode is a small fragment of code used to implement temporary entry points and an <strong>efficient wrapper for stubs</strong>. Precode is a niche code-generator for these two cases, generating the most efficient code possible. In an ideal world, all native code dynamically generated by the runtime would be produced by the JIT. That&#x2019;s not feasible in this case, given the specific requirements of these two scenarios. The basic precode on x86 may look like this:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mov eax,pMethodDesc // Load MethodDesc into scratch register
jmp target          // Jump to a target
</code></pre></div> </div> <p><strong>Efficient Stub wrappers:</strong> The implementation of certain methods (e.g. P/Invoke, delegate invocation, multi dimensional array setters and getters) is provided by the runtime, typically as hand-written assembly stubs. Precode provides a <strong>space-efficient wrapper over stubs, to multiplex them for multiple callers</strong>.</p> <p>The worker code of the stub is wrapped by a precode fragment that can be mapped to the MethodDesc and that jumps to the worker code of the stub. The worker code of the stub can be shared between multiple methods this way. It is an important optimization used to implement P/Invoke marshalling stubs.</p>
</blockquote> <p>By providing a &#x2018;pointer&#x2019; to the <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/method.hpp#L178-L2041">MethodDesc class</a>, the precode allows any subsequent stub to have access to <em>a lot</em> of information about a method call and it&#x2019;s containing <code class="highlighter-rouge">Type</code> via the <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/methodtable.h#L601-L4175">MethodTable</a> (&#x2018;hot&#x2019;) and <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/class.h#L797-L2050">EEClass</a> (&#x2018;cold&#x2019;) data structures. The MethodDesc data-structure is one of the most fundamental types in the runtime, hence why it has it&#x2019;s own <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/method-descriptor.md">BotR page</a>.</p> <p>Each &#x2018;precode&#x2019; is created in <code class="highlighter-rouge">MethodDesc::GetOrCreatePrecode()</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/method.cpp#L4712-L4776">here</a> and there are several different types as we can see in this <code class="highlighter-rouge">enum</code> from <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/precode.h#L19-L31">/vm/precode.h</a>:</p> <pre><code class="language-C++">enum PrecodeType {
    PRECODE_INVALID         = InvalidPrecode::Type,
    PRECODE_STUB            = StubPrecode::Type,
#ifdef HAS_NDIRECT_IMPORT_PRECODE
    PRECODE_NDIRECT_IMPORT  = NDirectImportPrecode::Type,
#endif // HAS_NDIRECT_IMPORT_PRECODE
#ifdef HAS_FIXUP_PRECODE
    PRECODE_FIXUP           = FixupPrecode::Type,
#endif // HAS_FIXUP_PRECODE
#ifdef HAS_THISPTR_RETBUF_PRECODE
    PRECODE_THISPTR_RETBUF  = ThisPtrRetBufPrecode::Type,
#endif // HAS_THISPTR_RETBUF_PRECODE
};
</code></pre> <p>As always, the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/method-descriptor.md#types-of-precode">BotR page</a> describes the different types in great detail, but in summary:</p> <ul> <li><strong>StubPrecode</strong> - <em>.. is the basic precode type. It loads MethodDesc into a scratch register and then jumps. It must be implemented for precodes to work. It is used as fallback when no other specialized precode type is available.</em></li> <li><strong>FixupPrecode</strong> - <em>.. is used when the final target does not require MethodDesc in scratch register. The FixupPrecode saves a few cycles by avoiding loading MethodDesc into the scratch register. The most common usage of FixupPrecode is for method fixups in NGen images.</em></li> <li><strong>ThisPtrRetBufPrecode</strong> - <em>.. is used to switch a return buffer and the this pointer for open instance delegates returning valuetypes. It is used to convert the calling convention of <code class="highlighter-rouge">MyValueType Bar(Foo x)</code> to the calling convention of <code class="highlighter-rouge">MyValueType Foo::Bar()</code>.</em></li> <li><strong>NDirectImportPrecode</strong> (a.k.a P/Invoke) - <em>.. is used for lazy binding of unmanaged P/Invoke targets. This precode is for convenience and to reduce amount of platform specific plumbing.</em></li>
</ul> <p>Finally, to give you an idea of some real-world scenarios for &#x2018;precode&#x2019; stubs, take a look at <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/cgenamd64.cpp#L732-L736">this comment</a> from the <code class="highlighter-rouge">DoesSlotCallPrestub(..)</code> method (AMD64):</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// AMD64 has the following possible sequences for prestub logic:
// 1. slot -&gt; temporary entrypoint -&gt; prestub
// 2. slot -&gt; precode -&gt; prestub
// 3. slot -&gt; precode -&gt; jumprel64 (jump stub) -&gt; prestub
// 4. slot -&gt; precode -&gt; jumprel64 (NGEN case) -&gt; prestub
</code></pre></div></div> <h4 id="just-in-time-jit-and-tiered-compilation">&#x2018;Just-in-time&#x2019; (JIT) and &#x2018;Tiered&#x2019; Compilation</h4> <p>However, another piece of functionality that &#x2018;precodes&#x2019; provide is related to &#x2018;just-in-time&#x2019; (JIT) compilation, again from the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/method-descriptor.md#precode">BotR page</a>:</p> <blockquote> <p><strong>Temporary entry points</strong>: Methods must provide entry points before they are jitted so that jitted code has an address to call them. These temporary entry points are provided by precode. They are a specific form of stub wrappers.</p> <p><strong>This technique is a lazy approach to jitting</strong>, which provides a performance optimization in both space and time. Otherwise, the transitive closure of a method would need to be jitted before it was executed. This would be a waste, since only the dependencies of taken code branches (e.g. if statement) require jitting.</p> <p>Each temporary entry point is much smaller than a typical method body. They need to be small since there are a lot of them, even at the cost of performance. The temporary entry points are executed just once before the actual code for the method is generated.</p>
</blockquote> <p>So these &#x2018;temporary entry points&#x2019; provide something concrete that can be referenced before a method has been JITted. They then trigger the JIT-compilation which does the job of generating the native code for a method. The entire process looks like this (dotted lines represent a pointer indirection, solid lines are a &#x2018;control transfer&#x2019; e.g. a jmp/call assembly instruction):</p> <p><strong>Before JITing</strong></p> <p><img src="/images/2019/09/01 - Before JITing.svg" alt="Before JITing"></p> <p>Here we see the &#x2018;temporary entry point&#x2019; pointing to the &#x2018;fixup precode&#x2019;, which ultimately calls into the <code class="highlighter-rouge">PrestubWorker()</code> function <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1555-L1668">here</a>.</p> <p><strong>After JIting</strong></p> <p><img src="/images/2019/09/02 - After JITing - Normal.svg" alt="After JIting - Normal"></p> <p>Once the method has been JITted, we can see that the <code class="highlighter-rouge">PrestubWorker</code> is now out of the picture and instead we have the native code for the function. In addition, there is now a &#x2018;stable entry point&#x2019; that can be used by any other code that wants to execute the function. Also, we can see that the &#x2018;fixup precode&#x2019; has been &#x2018;backpatched&#x2019; to also point at the &#x2018;native code&#x2019;. For an idea of how this &#x2018;back-patching&#x2019; works, see the <code class="highlighter-rouge">StubPrecode ::SetTargetInterlocked(..)</code> method <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm64/cgencpu.h#L551-L610">here</a> (ARM64).</p> <p><strong>After JIting - Tiered Compilation</strong></p> <p><img src="/images/2019/09/03 - After JITing - Tiered Compilation.svg" alt="After JIting - Tiered Compilation"></p> <p>However, there is also another &#x2018;after&#x2019; scenario, now that .NET Core has <a href="https://devblogs.microsoft.com/dotnet/tiered-compilation-preview-in-net-core-2-1/">&#x2018;Tiered Compilation&#x2019;</a>. Here we see that the &#x2018;stable entry point&#x2019; still goes via the &#x2018;fixup precode&#x2019;, it doesn&#x2019;t directly call into the &#x2018;native code&#x2019;. This is because &#x2018;tiered compilation&#x2019; counts how many times a method is called and once it decides the method is &#x2018;<em>hot</em>&#x2019;, it re-compiles a more optimised version that will give better performance. This &#x2018;call counting&#x2019; takes place in <a href="https://github.com/dotnet/coreclr/blob/d8d6d8a5/src/vm/prestub.cpp#L1986">this code</a> in <code class="highlighter-rouge">MethodDesc::DoPrestub(..)</code> which calls into <code class="highlighter-rouge">CodeVersionManager::PublishNonJumpStampVersionableCodeIfNecessary(..)</code> <a href="https://github.com/dotnet/coreclr/blob/d8d6d8a5/src/vm/codeversion.cpp#L2295-L2474">here</a> and then if <code class="highlighter-rouge">shouldCountCalls</code> is true, it ends up calling <code class="highlighter-rouge">CallCounter::OnMethodCodeVersionCalledSubsequently(..)</code> <a href="https://github.com/dotnet/coreclr/blob/d8d6d8a5/src/vm/callcounter.cpp#L83-L109">here</a>.</p> <p>What&#x2019;s been interesting to watch during the development of &#x2018;tiered compilation&#x2019; is that (not surprisingly) there has been a significant amount of work to ensure that the extra level of indirection doesn&#x2019;t make the entire process slower, for instance see <a href="https://github.com/dotnet/coreclr/pull/21292">Patch vtable slots and similar when tiering is enabled #21292</a>.</p> <p>Like all the other stubs, &#x2018;precodes&#x2019; have different versions for different CPU architectures. As a reference, the list below contains links to all of them:</p> <p>Finally, for even more information on the JITing process, see:</p> <h3 id="stubs-as-il">Stubs-as-IL</h3> <p>&#x2018;Stubs as IL&#x2019; actually describes several types of individual stubs, but what they all have in common is they&#x2019;re generated from <a href="https://www.techopedia.com/definition/24290/intermediate-language-il-net">&#x2018;Intermediate Language&#x2019;</a> (IL) which is then compiled by the JIT, in exactly the same way it handles the code we write (after it&#x2019;s first been compiled from C#/F#/VB.NET into IL by another compiler).</p> <p>This makes sense, it&#x2019;s far easier to write the IL once and then have the JIT worry about compiling it for different CPU architectures, rather than having to write raw assembly each time (for x86/x64/arm/etc). However all stubs were hand-written assembly in <a href="https://github.com/dotnet/coreclr/pull/18476#issuecomment-400810704">.NET Framework 1.0</a>:</p> <blockquote> <p>What you have described is how it actually works. The only difference is that the shuffle thunk is hand-emitted in assembly and not generated by the JIT for historic reasons. All stubs (including all interop stubs) were hand-emitted like this in .NET Framework 1.0. <strong>Starting with .NET Framework 2.0, we have been converting the stubs to be generated by the JIT (the runtime generates IL for the stub, and then the JIT compiles the IL as regular method)</strong>. The shuffle thunk is one of the few remaining ones not converted yet. Also, we have the IL path on some platforms but not others - <code class="highlighter-rouge">FEATURE_STUBS_AS_IL</code> is related to it.</p>
</blockquote> <p>In the CoreCLR source code, &#x2018;stubs as IL&#x2019; are controlled by the feature flag <code class="highlighter-rouge">FEATURE_STUBS_AS_IL</code>, with the following additional flags for each specific type:</p>
<ul> <li><code class="highlighter-rouge">StubsAsIL</code></li> <li><code class="highlighter-rouge">ArrayStubAsIL</code></li> <li><code class="highlighter-rouge">MulticastStubAsIL</code></li>
</ul> <p>On <code class="highlighter-rouge">Windows</code> only some features are implemented with IL stubs, see <a href="https://github.com/dotnet/coreclr/blob/7df151664237b539de91f1394e97f145460d05b6/clr.featuredefines.props#L26-L28">this code</a>, e.g. &#x2018;ArrayStubAsIL&#x2019; is disabled on &#x2018;x86&#x2019;, but enabled elsewhere.</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;PropertyGroup</span> <span class="na">Condition=</span><span class="s">&quot;&apos;$(TargetsWindows)&apos; == &apos;true&apos;&quot;</span><span class="nt">&gt;</span> <span class="nt">&lt;FeatureArrayStubAsIL</span> <span class="na">Condition=</span><span class="s">&quot;&apos;$(Platform)&apos; != &apos;x86&apos;&quot;</span><span class="nt">&gt;</span>true<span class="nt">&lt;/FeatureArrayStubAsIL&gt;</span> <span class="nt">&lt;FeatureMulticastStubAsIL</span> <span class="na">Condition=</span><span class="s">&quot;&apos;$(Platform)&apos; != &apos;x86&apos;&quot;</span><span class="nt">&gt;</span>true<span class="nt">&lt;/FeatureMulticastStubAsIL&gt;</span> <span class="nt">&lt;FeatureStubsAsIL</span> <span class="na">Condition=</span><span class="s">&quot;&apos;$(Platform)&apos; == &apos;arm64&apos;&quot;</span><span class="nt">&gt;</span>true<span class="nt">&lt;/FeatureStubsAsIL&gt;</span> ...
<span class="nt">&lt;/PropertyGroup&gt;</span>
</code></pre></div></div> <p>On <code class="highlighter-rouge">Unix</code> they are all done in IL, regardless of CPU Arch, as <a href="https://github.com/dotnet/coreclr/blob/7df151664237b539de91f1394e97f145460d05b6/clr.featuredefines.props#L20-L22">this code</a> shows:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;PropertyGroup</span> <span class="na">Condition=</span><span class="s">&quot;&apos;$(TargetsUnix)&apos; == &apos;true&apos;&quot;</span><span class="nt">&gt;</span> ... <span class="nt">&lt;FeatureArrayStubAsIL&gt;</span>true<span class="nt">&lt;/FeatureArrayStubAsIL&gt;</span> <span class="nt">&lt;FeatureMulticastStubAsIL&gt;</span>true<span class="nt">&lt;/FeatureMulticastStubAsIL&gt;</span> <span class="nt">&lt;FeatureStubsAsIL&gt;</span>true<span class="nt">&lt;/FeatureStubsAsIL&gt;</span>
<span class="nt">&lt;/PropertyGroup&gt;</span>
</code></pre></div></div> <p>Finally, here&#x2019;s the complete list of stubs that can be implemented in IL from <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/ilstubresolver.h#L73-L93">/vm/ilstubresolver.h</a>:</p> <pre><code class="language-C++"> enum ILStubType
 {
     Unassigned = 0,
     CLRToNativeInteropStub,
     CLRToCOMInteropStub,
     CLRToWinRTInteropStub,
     NativeToCLRInteropStub,
     COMToCLRInteropStub,
     WinRTToCLRInteropStub,
#ifdef FEATURE_ARRAYSTUB_AS_IL 
     ArrayOpStub,
#endif
#ifdef FEATURE_MULTICASTSTUB_AS_IL
     MulticastDelegateStub,
#endif
#ifdef FEATURE_STUBS_AS_IL
     SecureDelegateStub,
     UnboxingILStub,
     InstantiatingStub,
#endif
 };
</code></pre> <p>But the usage of IL stubs has grown over time and it seems that they are the preferred mechanism where possible as they&#x2019;re easier to write and debug. See <a href="https://github.com/dotnet/coreclr/pull/9752">[x86/Linux] Enable FEATURE_ARRAYSTUB_AS_IL</a>, <a href="https://github.com/dotnet/coreclr/pull/11624">Switch multicast delegate stub on Windows x64 to use stubs-as-il</a> and <a href="https://github.com/dotnet/coreclr/pull/26169#issuecomment-521518184">Fix GenerateShuffleArray to support cyclic shuffles #26169 (comment)</a> for more information.</p> <h3 id="pinvoke-reverse-pinvoke-and-calli">P/Invoke, Reverse P/Invoke and &#x2018;calli&#x2019;</h3> <p>All these stubs have one thing in common, they allow a transition between &#x2018;managed&#x2019; and &#x2018;un-managed&#x2019; (or native) code. To make this safe and to preserve the guarantees that the .NET runtime provides, stubs are used every time the transition is made.</p> <p>This entire process is outlined in great detail in the BotR page <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/clr-abi.md#per-call-site-pinvoke-work">CLR ABI - PInvokes</a>, from the &#x2018;Per-call-site PInvoke work&#x2019; section:</p> <blockquote> <ol> <li>For direct calls, the JITed code sets <code class="highlighter-rouge">InlinedCallFrame-&gt;m_pDatum</code> to the MethodDesc of the call target. <ul> <li>For JIT64, indirect calls within <strong>IL stubs</strong> sets it to the secret parameter (this seems redundant, but it might have changed since the per-frame initialization?).</li> <li>For JIT32 (ARM) indirect calls, it sets this member to the size of the pushed arguments, according to the comments. The implementation however always passed 0.</li> </ul> </li> <li>For JIT64/AMD64 only: Next for <strong>non-IL stubs</strong>, the InlinedCallFrame is &#x2018;pushed&#x2019; by setting <code class="highlighter-rouge">Thread-&gt;m_pFrame</code> to point to the InlinedCallFrame (recall that the per-frame initialization already set <code class="highlighter-rouge">InlinedCallFrame-&gt;m_pNext</code> to point to the previous top). For <strong>IL stubs</strong> this step is accomplished in the per-frame initialization.</li> <li>The Frame is made active by setting <code class="highlighter-rouge">InlinedCallFrame-&gt;m_pCallerReturnAddress</code>.</li> <li>The code then toggles the GC mode by setting <code class="highlighter-rouge">Thread-&gt;m_fPreemptiveGCDisabled = 0</code>.</li> <li>Starting now, no GC pointers may be live in registers. RyuJit LSRA meets this requirement by adding special refPositon <code class="highlighter-rouge">RefTypeKillGCRefs</code> before unmanaged calls and special helpers.</li> <li><strong>Then comes the actual call/PInvoke.</strong></li> <li>The GC mode is set back by setting <code class="highlighter-rouge">Thread-&gt;m_fPreemptiveGCDisabled = 1</code>.</li> <li>Then we check to see if <code class="highlighter-rouge">g_TrapReturningThreads</code> is set (non-zero). If it is, we call <code class="highlighter-rouge">CORINFO_HELP_STOP_FOR_GC</code>. <ul> <li>For ARM, this helper call preserves the return register(s): <code class="highlighter-rouge">R0</code>, <code class="highlighter-rouge">R1</code>, <code class="highlighter-rouge">S0</code>, and <code class="highlighter-rouge">D0</code>.</li> <li>For AMD64, the generated code must manually preserve the return value of the PInvoke by moving it to a non-volatile register or a stack location.</li> </ul> </li> <li>Starting now, GC pointers may once again be live in registers.</li> <li>Clear the <code class="highlighter-rouge">InlinedCallFrame-&gt;m_pCallerReturnAddress</code> back to 0.</li> <li>For JIT64/AMD64 only: For <strong>non-IL stubs</strong> &#x2018;pop&#x2019; the Frame chain by resetting <code class="highlighter-rouge">Thread-&gt;m_pFrame</code> back to <code class="highlighter-rouge">InlinedCallFrame.m_pNext</code>.</li> </ol> <p>Saving/restoring all the non-volatile registers helps by preventing any registers that are unused in the current frame from accidentally having a live GC pointer value from a parent frame. The argument and return registers are &#x2018;safe&#x2019; because they cannot be GC refs. Any refs should have been pinned elsewhere and instead passed as native pointers.</p> <p>For <strong>IL stubs</strong>, the Frame chain isn&#x2019;t popped at the call site, so instead it must be popped right before the epilog and right before any jmp calls. It looks like we do not support tail calls from PInvoke <strong>IL stubs</strong>?</p>
</blockquote> <p>As you can see, quite a bit of the work is to keep the Garbage Collector (GC) happy. This makes sense because once execution moves into un-managed/native code the .NET runtime has no control over what&#x2019;s happening, so it needs to ensure that the GC doesn&#x2019;t clean up or move around objects that are being used in the native code. It achives this by constraining what the GC can do (on the current thread) from the time execution moves into un-managed code and keeps that in place until it returns back to the mamanged side.</p> <p>On top of that, there needs to be support for allowing <a href="/2019/01/21/Stackwalking-in-the-.NET-Runtime/">&#x2018;stack walking&#x2019; or &#x2018;unwinding</a>, to allowing debugging and produce meaningful stack traces. This is done by setting up <em>frames</em> that are put in place when control transitions from managed -&gt; un-managed, before being removed (&#x2018;popped&#x2019;) when transitioning back. Here&#x2019;s a list of the different scenarios that are covered, from <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/frames.h#L147-L193">/vm/frames.h</a>:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is the list of Interop stubs &amp; transition helpers with information
regarding what (if any) Frame they used and where they were set up:

P/Invoke:
 JIT inlined: The code to call the method is inlined into the caller by the JIT.
    InlinedCallFrame is erected by the JITted code.
 Requires marshaling: The stub does not erect any frames explicitly but contains
    an unmanaged CALLI which turns it into the JIT inlined case.

Delegate over a native function pointer:
 The same as P/Invoke but the raw JIT inlined case is not present (the call always
 goes through an IL stub).

Calli:
 The same as P/Invoke.
 PInvokeCalliFrame is erected in stub generated by GenerateGetStubForPInvokeCalli
 before calling to GetILStubForCalli which generates the IL stub. This happens only
 the first time a call via the corresponding VASigCookie is made.

ClrToCom:
 Late-bound or eventing: The stub is generated by GenerateGenericComplusWorker
    (x86) or exists statically as GenericComPlusCallStub[RetBuffArg] (64-bit),
    and it erects a ComPlusMethodFrame frame.
 Early-bound: The stub does not erect any frames explicitly but contains an
    unmanaged CALLI which turns it into the JIT inlined case.

ComToClr:
 Normal stub:
 Interpreted: The stub is generated by ComCall::CreateGenericComCallStub
    (in ComToClrCall.cpp) and it erects a ComMethodFrame frame.
 Prestub:
  The prestub is ComCallPreStub (in ComCallableWrapper.cpp) and it erects a ComPrestubMethodFrame frame.

Reverse P/Invoke (used for C++ exports &amp; fixups as well as delegates
obtained from function pointers):
 Normal stub:
  x86: The stub is generated by UMEntryThunk::CompileUMThunkWorker
    (in DllImportCallback.cpp) and it is frameless. It calls directly
    the managed target or to IL stub if marshaling is required.
  non-x86: The stub exists statically as UMThunkStub and calls to IL stub.
 Prestub:
  The prestub is generated by GenerateUMThunkPrestub (x86) or exists statically
  as TheUMEntryPrestub (64-bit), and it erects an UMThkCallFrame frame.

Reverse P/Invoke AppDomain selector stub:
 The asm helper is IJWNOADThunkJumpTarget (in asmhelpers.asm) and it is frameless.
</code></pre></div></div> <p>The P/Invoke <strong>IL stubs</strong> are <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1895-L1899">wired up</a> in the <code class="highlighter-rouge">MethodDesc::DoPrestub(..)</code> method (note that P/Invoke is also known as <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/method-descriptor.md#kinds-of-methoddescs">&#x2018;NDirect&#x2019;</a>), in addition they are also created <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1787-L1800">here</a> when being used for &#x2018;COM Interop&#x2019;. That code then calls into <code class="highlighter-rouge">GetStubForInteropMethod(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/dllimport.cpp#L5757-L5824">in /vm/dllimport.cpp</a>, before branching off to handle each case:</p> <ul> <li>P/Invoke calls into <code class="highlighter-rouge">NDirect::GetStubForILStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/dllimport.cpp#L5607-L5664">here</a></li> <li>Reverse P/Invoke calls into another overload of <code class="highlighter-rouge">NDirect::GetStubForILStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/dllimport.cpp#L5584-L5605">here</a></li> <li>COM Interop goes to <code class="highlighter-rouge">ComPlusCall::GetStubForILStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/clrtocomcall.cpp#L394-L471">here in /vm/clrtocomcall.cpp</a></li> <li>EE implemented methods end up in <code class="highlighter-rouge">COMDelegate::GetStubForILStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/comdelegate.cpp#L1502-L1518">here</a> (for more info on <code class="highlighter-rouge">EEImpl</code> methods see <a href="https://github.com/dotnet/coreclr/blob/masterDocumentation/botr/method-descriptor.md#kinds-of-methoddescs">&#x2018;Kinds of MethodDescs&#x2019;</a>)</li>
</ul> <p>There are also hand-written assembly stubs for the differents scenarios, such as <code class="highlighter-rouge">JIT_PInvokeBegin</code>, <code class="highlighter-rouge">JIT_PInvokeEnd</code> and <code class="highlighter-rouge">VarargPInvokeStub</code>, these can be seen in the files below:</p> <p>As an example, <code class="highlighter-rouge">calli</code> method calls (see <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes.calli?view=netframework-4.8">OpCodes.Calli</a>) end up in <code class="highlighter-rouge">GenericPInvokeCalliHelper</code>, which has a nice bit of ASCII art in the <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/i386/asmhelpers.S#L636-L725">i386 version</a>:</p> <pre><code class="language-C++">// stack layout at this point:
//
// |         ...          |
// |   stack arguments    | ESP + 16
// +----------------------+
// |     VASigCookie*     | ESP + 12
// +----------------------+
// |    return address    | ESP + 8
// +----------------------+
// | CALLI target address | ESP + 4
// +----------------------+
// |   stub entry point   | ESP + 0
// ------------------------
</code></pre> <p>However, all these stubs can have an adverse impact on start-up time, see <a href="https://github.com/dotnet/coreclr/issues/22212">Large numbers of Pinvoke stubs created on startup</a> for example. This impact has been mitigated by compiling the stubs &#x2018;Ahead-of-Time&#x2019; (AOT) and storing them in the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/readytorun-overview.md">&#x2018;Ready-to-Run&#x2019; images</a> (replacement format for <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator">NGEN (Native Image Generator)</a>). From <a href="https://github.com/dotnet/coreclr/pull/24823">R2R ilstubs</a>:</p> <blockquote> <p>IL stub generation for interop takes measurable time at startup, and it is possible to generate some of them in an ahead of time</p> <p>This change introduces ahead of time R2R compilation of IL stubs</p>
</blockquote> <p>Related work was done in <a href="https://github.com/dotnet/coreclr/pull/22560">Enable R2R compilation/inlining of PInvoke stubs where no marshalling is required</a> and <a href="https://github.com/dotnet/coreclr/pull/24834">PInvoke stubs for Unix platforms</a> (&#x2018;Enables inlining of PInvoke stubs for Unix platforms&#x2019;).</p> <p>Finally, for even more information on the issues involved, see:</p> <h4 id="marshalling">Marshalling</h4> <p>However, dealing with the &#x2018;managed&#x2019; to &#x2018;un-managed&#x2019; transition is only one part of the story. The other is that there are also stubs created to deal with the &#x2018;marshalling&#x2019; of arguments between the 2 sides. This process of &#x2018;Interop Marshalling&#x2019; is explained nicely in the <a href="https://docs.microsoft.com/en-us/dotnet/framework/interop/interop-marshaling">Microsoft docs</a>:</p> <blockquote> <p>Interop marshaling governs how data is passed in method arguments and return values between managed and unmanaged memory during calls. Interop marshaling is a run-time activity performed by the common language runtime&#x2019;s marshaling service.</p> <p>Most data types have common representations in both managed and unmanaged memory. The interop marshaler handles these types for you. Other types can be ambiguous or not represented at all in managed memory.</p>
</blockquote> <p>Like many stubs in the CLR, the marshalling stubs have evolved over time. As we can read in the excellent post <a href="https://devblogs.microsoft.com/dotnet/improvements-to-interop-marshaling-in-v4-il-stubs-everywhere/">Improvements to Interop Marshaling in V4: IL Stubs Everywhere</a>:</p> <blockquote> <p><strong>History</strong>
The 1.0 and 1.1 versions of the CLR had several different techniques for creating and executing these stubs that were each designed for marshaling different types of signatures. These techniques ranged from <strong>directly generated x86 assembly instructions</strong> for simple signatures to <strong>generating specialized ML (an internal marshaling language)</strong> and running them through an <strong>internal interpreter</strong> for the most complicated signatures. This system worked well enough &#x2013; although not without difficulties &#x2013; in 1.0 and 1.1 but presented us with a serious maintenance problem when 2.0, and its support for multiple processor architectures, came around.</p>
</blockquote> <p>That&#x2019;s right, there was an internal interpreter built into early version of the .NET CLR that had the job of running the &#x2018;marshalling language&#x2019; (ML) code!</p> <p>However, it then goes on to explain why this process wasn&#x2019;t sustainable:</p> <blockquote> <p>We realized early in the process of adding 64 bit support to 2.0 that this approach was not sustainable across multiple architectures. <strong>Had we continued with the same strategy we would have had to create parallel marshaling infrastructures for each new architecture we supported (remember in 2.0 we introduced support for both x64 and IA64) which would, in addition to the initial cost, at least triple the cost of every new marshaling feature or bug fix</strong>. We needed one marshaling stub technology that would work on multiple processor architectures and could be efficiently executed on each one: enter IL stubs.</p>
</blockquote> <p>The solution was to implement all stubs using &#x2018;Intermediate Language&#x2019; (IL) that is CPU-agnostic. Then the JIT-compiler is used to convert the IL into machine code for each CPU architecture, which makes sense because it&#x2019;s exactly what the JIT is good at. Also worth noting is that this work still continues today, for instance see <a href="https://github.com/dotnet/coreclr/pull/26340">Implement struct marshalling via IL Stubs instead of via FieldMarshalers #26340</a>.</p> <p>Finally, there is a really nice investigation into the whole process in <a href="http://devops.lol/pinvoke-beyond-the-magic/">PInvoke: beyond the magic</a> (also <a href="http://devops.lol/compile-time-marshalling/">Compile time marshalling</a>). What&#x2019;s also nice is that you can use PerfView to <a href="https://twitter.com/matthewwarren/status/1124268756413374465">see the stubs that the runtime generates</a>.</p> <h3 id="generics">Generics</h3> <p>It is reasonably well known that generics in .NET use &#x2018;code sharing&#x2019; to save space. That is, given a generic method such as <code class="highlighter-rouge">public void Insert&lt;T&gt;(..)</code>, <strong>one method body</strong> of &#x2018;native code&#x2019; will be created and shared by the <em>instantiated</em> types of <code class="highlighter-rouge">Insert&lt;Foo&gt;(..)</code> and <code class="highlighter-rouge">Insert&lt;Bar&gt;(..)</code> (assumning that <code class="highlighter-rouge">Foo</code> and <code class="highlighter-rouge">Bar</code> are <em>references</em> types), but <strong>different</strong> versions will be created for <code class="highlighter-rouge">Insert&lt;int&gt;(..)</code> and <code class="highlighter-rouge">Insert&lt;double&gt;(..)</code> (as <code class="highlighter-rouge">int</code>/<code class="highlighter-rouge">double</code> are <em>value</em> types). This is possible, for the <a href="https://stackoverflow.com/a/598738">reasons outlined by Jon Skeet</a> in a StackOverflow question:</p> <blockquote> <p>.. consider what the CLR needs to know about a type. It includes:</p> <ul> <li>The size of a value of that type (i.e. if you have a variable of some type, how much space will that memory need?)</li> <li>How to treat the value in terms of garbage collection: is it a reference to an object, or a value which may in turn contain other references?</li> </ul> <p>For all reference types, the answers to these questions are the same. The size is just the size of a pointer, and the value is always just a reference (so if the variable is considered a root, the GC needs to recursively descend into it).</p> <p>For value types, the answers can vary significantly.</p>
</blockquote> <p>But, this poses a problem. What about if the &#x2018;shared&#x2019; method needs to do something specific for each type, like call <code class="highlighter-rouge">typeof(T)</code>?</p> <p>This whole issue is explained in these 2 great posts, which I really recommend you take the time to read:</p> <p>I&#x2019;m not going to repeat what they cover here, except to say that (not surprisingly) &#x2018;stubs&#x2019; are used to solve this issue, in conjunction with a &#x2018;hidden&#x2019; parameter. These stubs are known as &#x2018;instantiating&#x2019; stubs and we can find out more about them in <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/method.hpp#L811-L817">this comment</a>:</p> <blockquote> <p>Instantiating Stubs - Return TRUE if this is this a special stub used to implement an <strong>instantiated generic method or per-instantiation static method</strong>. The action of an instantiating stub is - pass on a <code class="highlighter-rouge">MethodTable</code> or <code class="highlighter-rouge">InstantiatedMethodDesc</code> extra argument to shared code</p>
</blockquote> <p>The different scenarios are handled in <code class="highlighter-rouge">MakeInstantiatingStubWorker(..)</code> in <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1510-L1534">/vm/prestub.cpp</a>, you can see the check for <code class="highlighter-rouge">HasMethodInstantiation</code> and the fall-back to a &#x2018;per-instantiation static method&#x2019;:</p> <pre><code class="language-C++">    // It&apos;s an instantiated generic method
    // Fetch the shared code associated with this instantiation
    pSharedMD = pMD-&gt;GetWrappedMethodDesc();
    _ASSERTE(pSharedMD != NULL &amp;&amp; pSharedMD != pMD);

    if (pMD-&gt;HasMethodInstantiation())
    {
        extraArg = pMD;
    }
    else
    {
        // It&apos;s a per-instantiation static method
        extraArg = pMD-&gt;GetMethodTable();
    }
    Stub *pstub = NULL;

#ifdef FEATURE_STUBS_AS_IL
    pstub = CreateInstantiatingILStub(pSharedMD, extraArg);
#else
    CPUSTUBLINKER sl;
    _ASSERTE(pSharedMD != NULL &amp;&amp; pSharedMD != pMD);
    sl.EmitInstantiatingMethodStub(pSharedMD, extraArg);

    pstub = sl.Link(pMD-&gt;GetLoaderAllocator()-&gt;GetStubHeap());
#endif
</code></pre> <p>As a reminder, <code class="highlighter-rouge">FEATURE_STUBS_AS_IL</code> is defined for <em>all</em> Unix versions of the CoreCLR, but on Windows it&#x2019;s only used with ARM64.</p> <ul> <li>When <code class="highlighter-rouge">FEATURE_STUBS_AS_IL</code> is defined, the code calls into <code class="highlighter-rouge">CreateInstantiatingILStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1353-L1452">here</a>. To get an overview of what it&#x2019;s doing, we can take a look at the steps called-out in the code comments: <ul> <li><code class="highlighter-rouge">// 1. Build the new signature</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1394">here</a></li> <li><code class="highlighter-rouge">// 2. Emit the method body</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1398">here</a></li> <li><code class="highlighter-rouge">// 2.2 Push the rest of the arguments for x86</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1406">here</a></li> <li><code class="highlighter-rouge">// 2.3 Push the hidden context param</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1413">here</a></li> <li><code class="highlighter-rouge">// 2.4 Push the rest of the arguments for not x86</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1418">here</a></li> <li><code class="highlighter-rouge">// 2.5 Push the target address</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1425">here</a></li> <li><code class="highlighter-rouge">// 2.6 Do the calli</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1428">here</a></li> </ul> </li> <li>When <code class="highlighter-rouge">FEATURE_STUBS_AS_IL</code> is <strong>note</strong> defined, per CPU/OS versions of <code class="highlighter-rouge">EmitInstantiatingMethodStub(..)</code> are used, they exist for: <ul> <li>i386 in <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/i386/stublinkerx86.cpp#L3197-L3394">/vm/i386/stublinkerx86.cpp</a></li> <li>ARM in <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm/stubs.cpp#L2121-L2142">/vm/arm/stubs.cpp</a></li> </ul> </li>
</ul> <p>In the last case, (<code class="highlighter-rouge">EmitInstantiatingMethodStub(..)</code> on ARM), the stub shares code with the instantiating version of the <em>unboxing</em> stub, so the heavy-lifting is done in <code class="highlighter-rouge">StubLinkerCPU::ThumbEmitCallWithGenericInstantiationParameter(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm/stubs.cpp#L1677-L2118">here</a>. This method is over 400 lines for fairly complex code, althrough there is also a nice piece of <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm/stubs.cpp#L1917-L1951">ASCII art</a> (for info on why this &#x2018;complex&#x2019; case is needed see <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm/stubs.cpp#L1687-L1701">this comment</a>):</p> <pre><code class="language-C++">// Complex case where we need to emit a new stack frame and copy the arguments.

// Calculate the size of the new stack frame:
//
//            +------------+
//      SP -&gt; |            | &lt;-- Space for helper arg, if isRelative is true
//            +------------+
//            |            | &lt;-+
//            :            :   | Outgoing arguments
//            |            | &lt;-+
//            +------------+
//            | Padding    | &lt;-- Optional, maybe required so that SP is 64-bit aligned
//            +------------+
//            | GS Cookie  |
//            +------------+
//        +-&gt; | vtable ptr |
//        |   +------------+
//        |   | m_Next     |
//        |   +------------+
//        |   | R4         | &lt;-+
//   Stub |   +------------+   |
// Helper |   :            :   |
//  Frame |   +------------+   | Callee saved registers
//        |   | R11        |   |
//        |   +------------+   |
//        |   | LR/RetAddr | &lt;-+
//        |   +------------+
//        |   | R0         | &lt;-+
//        |   +------------+   |
//        |   :            :   | Argument registers
//        |   +------------+   |
//        +-&gt; | R3         | &lt;-+
//            +------------+
//  Old SP -&gt; |            |
//
</code></pre> <h3 id="delegates">Delegates</h3> <p>Delegates in .NET provide a nice abstraction over the top of a function call, from <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/">Delegates (C# Programming Guide)</a>:</p> <blockquote> <p>A delegate is a type that represents references to methods with a particular parameter list and return type. When you instantiate a delegate, you can associate its instance with any method with a compatible signature and return type. You can invoke (or call) the method through the delegate instance.</p>
</blockquote> <p>But under the hood there is quite a bit going on, for the full story take a look at <a href="/2017/01/25/How-do-.NET-delegates-work/">How do .NET delegates work?</a>, but in summary, there are several different types of delegates, as shown in this table from <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/comdelegate.cpp#L3145-L3175">/vm/comdelegate.cpp</a>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// DELEGATE KINDS TABLE
//
// _target _methodPtr _methodPtrAux _invocationList _invocationCount
//
// 1- Instance closed &apos;this&apos; ptr target method null null 0
// 2- Instance open non-virt delegate shuffle thunk target method null 0
// 3- Instance open virtual delegate Virtual-stub dispatch method id null 0
// 4- Static closed first arg target method null null 0
// 5- Static closed (special sig) delegate specialSig thunk target method first arg 0
// 6- Static opened delegate shuffle thunk target method null 0
// 7- Secure delegate call thunk MethodDesc (frame) target delegate creator assembly //
// Delegate invoke arg count == target method arg count - 2, 3, 6
// Delegate invoke arg count == 1 + target method arg count - 1, 4, 5
//
// 1, 4 - MulticastDelegate.ctor1 (simply assign _target and _methodPtr)
// 5 - MulticastDelegate.ctor2 (see table, takes 3 args)
// 2, 6 - MulticastDelegate.ctor3 (take shuffle thunk)
// 3 - MulticastDelegate.ctor4 (take shuffle thunk, retrieve MethodDesc) ???
//
// 7 - Needs special handling
</span></code></pre></div></div> <p>The difference between <a href="https://blog.slaks.net/2011/06/open-delegates-vs-closed-delegates.html">Open Delegates vs. Closed Delegates</a> is nicely illustrated in this code sample from the linked post:</p> <pre><code class="language-C#">Func&lt;string&gt; closed = new Func&lt;string&gt;(&quot;a&quot;.ToUpperInvariant);
Func&lt;string, string&gt; open = (Func&lt;string, string&gt;)
    Delegate.CreateDelegate(
        typeof(Func&lt;string, string&gt;),
        typeof(string).GetMethod(&quot;ToUpperInvariant&quot;)
    );

closed();     //Returns &quot;A&quot;
open(&quot;abc&quot;);  //Returns &quot;ABC&quot;
</code></pre> <p>Stubs are used in several scenarios, including the intruiging named &#x2018;shuffle thunk&#x2019; whose job it is to literally shuffle arguments around! In the simplest case, this process looks a bit like the following:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Delegate Call: [delegateThisPtr, arg1, arg2, ...]

Method Call:   [targetThisPtr, arg1, arg2, ...]
</code></pre></div></div> <p>So when you invoke a delegate, the <code class="highlighter-rouge">Invoke(..)</code> method (generated by CLR), expects a &#x2018;this&#x2019; pointer of the delegate object itself. However when the target method is called (i.e. the method the delagate &#x2018;wraps&#x2019;), the &#x2018;this&#x2019; pointer needs to be the one for the type/class that the target method exists in, hence all the swapping/shuffling.</p> <p>Of couse things get more complicated when you deal with static methods (no &#x2018;this&#x2019; pointer) and different CPU calling conventions, as this answer to the question <a href="https://github.com/dotnet/coreclr/pull/18476#issuecomment-400805569">&#x2018;<em>What in the world is a shuffle thunk cache?</em>&#x2019;</a> explains:</p> <blockquote> <p>When you use a delegate to call a method, <strong>the JIT doesn&#x2019;t know at the time it generates the code what the delegate points to</strong>. It can e.g. be a member method or a static method. So the JIT generates arguments to registers and stack based on the signature of the delegate and the call then doesn&#x2019;t call the target method directly, <strong>but a shuffle thunk instead</strong>. This thunk is generated based on the caller side signature and the real target method signature and shuffles the arguments in registers and on stack to correspond to the target calling convention. <strong>So if it needs to add &#x201C;this&#x201D; pointer into the first argument register, it needs to move the first argument register to the second, the second to the third and the last to the stack (obviously in the right order so that nothing gets overwritten)</strong>. And e.g. Unix amd64 calling convention makes it even more interesting when there are arguments that are structs that can be passed in multiple registers.</p>
</blockquote> <h4 id="singlecast-delegates">Singlecast Delegates</h4> <p>&#x2018;Singlecast&#x2019; delegates (as opposed to the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/how-to-combine-delegates-multicast-delegates">&#x2018;multicast&#x2019; variants</a>) are the most common scenario and so they&#x2019;re written as optimised &#x2018;stubs&#x2019;, starting in:</p> <p>For example, this is the <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/AsmHelpers.asm#L746-L761">AMD64 (Windows) version</a> of <code class="highlighter-rouge">SinglecastDelegateInvokeStub</code>:</p> <pre><code class="language-assembly">LEAF_ENTRY SinglecastDelegateInvokeStub, _TEXT

        test    rcx, rcx
        jz      NullObject

        mov     rax, [rcx + OFFSETOF__DelegateObject___methodPtr]
        mov     rcx, [rcx + OFFSETOF__DelegateObject___target]  ; replace &quot;this&quot; pointer

        jmp     rax

NullObject:
        mov     rcx, CORINFO_NullReferenceException_ASM
        jmp     JIT_InternalThrow

LEAF_END SinglecastDelegateInvokeStub, _TEXT
</code></pre> <p>As you can see, it reaches into the internals of the <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/object.h#L2223-L2266">DelegateObject</a>, pulls out the values in the <code class="highlighter-rouge">methodPtr</code> and <code class="highlighter-rouge">target</code> fields and puts them into the the <code class="highlighter-rouge">rax</code> and <code class="highlighter-rouge">rcx</code> registers.</p> <h4 id="shuffle-thunks">Shuffle Thunks</h4> <p>Finally, let&#x2019;s look at &#x2018;shuffle thunks&#x2019; in more detail (cases 2, 3, 6 from the table above).</p> <ul> <li>There are created in several places in the CoreCLR source, which all call into <code class="highlighter-rouge">COMDelegate::SetupShuffleThunk(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/comdelegate.cpp#L580-L636">here</a> <ol> <li><code class="highlighter-rouge">COMDelegate::BindToMethod(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/comdelegate.cpp#L864-L1037">here</a></li> <li><code class="highlighter-rouge">COMDelegate::DelegateConstruct(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/comdelegate.cpp#L1680-L1889">here</a></li> <li><code class="highlighter-rouge">COMDelegate::GetDelegateCtor(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/comdelegate.cpp#L3049-L3256">here</a></li> </ol> </li> <li><code class="highlighter-rouge">COMDelegate::SetupShuffleThunk(..)</code> then calls <code class="highlighter-rouge">GenerateShuffleArray(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/comdelegate.cpp#L243-L508">here</a></li> <li>Followed by a call to <code class="highlighter-rouge">StubCacheBase::Canonicalize(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubcache.cpp#L70-L165">here</a>, that ends up in <code class="highlighter-rouge">ShuffleThunkCache::CompileStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/comdelegate.h#L234-L244">here</a></li> <li>This ends up calls the CPU-specific method <code class="highlighter-rouge">EmitShuffleThunk(..)</code>: <ul> <li><a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/i386/stublinkerx86.cpp#L3815-L4096">src/vm/i386</a> (also does AMD64 and UNIX_AMD64_ABI)</li> <li><a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm/stubs.cpp#L1422-L1604">src/vm/arm</a></li> <li><a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm64/stubs.cpp#L1760-L1802">src/vm/arm64</a></li> </ul> </li>
</ul> <p>Note how the stubs are cached in the <code class="highlighter-rouge">ShuffleThunkCache</code> where possible. This is because the thunks don&#x2019;t have to be unique <em>per method</em> they can be shared across multiple methods as long as the signatures are compatible.</p> <p>However, these stubs are not straight-forward and sometimes they go wrong, for instance <a href="https://github.com/dotnet/coreclr/issues/26054">Infinite loop in GenerateShuffleArray on unix64 #26054</a>, fixed in <a href="https://github.com/dotnet/coreclr/pull/26169">PR #26169</a>. Also see <a href="https://github.com/dotnet/coreclr/issues/16833">Corrupted struct passed to delegate constructed via reflection #16833</a> and
<a href="https://github.com/dotnet/coreclr/pull/16904">Fix shuffling thunk for Unix AMD64 #16904</a> for more examples.</p> <p>To give a flavour of what they need to do, here&#x2019;s the code of the <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm64/stubs.cpp#L1760-L1802">ARM64 version</a>, which is by far the simplest one!! If you want to understand the full complexities, take a look at the <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm/stubs.cpp#L1422-L1604">ARM version</a> which is 182 LOC or the <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/i386/stublinkerx86.cpp#L3815-L4096">x86 one</a> at 281 LOC!!</p> <pre><code class="language-C++">// Emits code to adjust arguments for static delegate target.
VOID StubLinkerCPU::EmitShuffleThunk(ShuffleEntry *pShuffleEntryArray)
{
    // On entry x0 holds the delegate instance. Look up the real target address stored in the MethodPtrAux
    // field and save it in x16(ip). Tailcall to the target method after re-arranging the arguments
    // ldr x16, [x0, #offsetof(DelegateObject, _methodPtrAux)]
    EmitLoadStoreRegImm(eLOAD, IntReg(16), IntReg(0), DelegateObject::GetOffsetOfMethodPtrAux());
    //add x11, x0, DelegateObject::GetOffsetOfMethodPtrAux() - load the indirection cell into x11 used by ResolveWorkerAsmStub
    EmitAddImm(IntReg(11), IntReg(0), DelegateObject::GetOffsetOfMethodPtrAux());

    for (ShuffleEntry* pEntry = pShuffleEntryArray; pEntry-&gt;srcofs != ShuffleEntry::SENTINEL; pEntry++)
    {
        if (pEntry-&gt;srcofs &amp; ShuffleEntry::REGMASK)
        {
            // If source is present in register then destination must also be a register
            _ASSERTE(pEntry-&gt;dstofs &amp; ShuffleEntry::REGMASK);

            EmitMovReg(IntReg(pEntry-&gt;dstofs &amp; ShuffleEntry::OFSMASK), IntReg(pEntry-&gt;srcofs &amp; ShuffleEntry::OFSMASK));
        }
        else if (pEntry-&gt;dstofs &amp; ShuffleEntry::REGMASK)
        {
            // source must be on the stack
            _ASSERTE(!(pEntry-&gt;srcofs &amp; ShuffleEntry::REGMASK));

            EmitLoadStoreRegImm(eLOAD, IntReg(pEntry-&gt;dstofs &amp; ShuffleEntry::OFSMASK), RegSp, pEntry-&gt;srcofs * sizeof(void*));
        }
        else
        {
            // source must be on the stack
            _ASSERTE(!(pEntry-&gt;srcofs &amp; ShuffleEntry::REGMASK));

            // dest must be on the stack
            _ASSERTE(!(pEntry-&gt;dstofs &amp; ShuffleEntry::REGMASK));

            EmitLoadStoreRegImm(eLOAD, IntReg(9), RegSp, pEntry-&gt;srcofs * sizeof(void*));
            EmitLoadStoreRegImm(eSTORE, IntReg(9), RegSp, pEntry-&gt;dstofs * sizeof(void*));
        }
    }

    // Tailcall to target
    // br x16
    EmitJumpRegister(IntReg(16));
}
</code></pre> <h3 id="unboxing">Unboxing</h3> <p>I&#x2019;ve written about this type of &#x2018;stub&#x2019; before in <a href="/2017/08/02/A-look-at-the-internals-of-boxing-in-the-CLR/#unboxing-stub-creation">A look at the internals of &#x2018;boxing&#x2019; in the CLR</a>, but in summary the unboxing stub needs to handle steps 2) and 3) from the diagram below:</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. MyStruct:         [0x05 0x00 0x00 0x00]

                     |   Object Header   |   MethodTable  |   MyStruct    |
2. MyStruct (Boxed): [0x40 0x5b 0x6f 0x6f 0xfe 0x7 0x0 0x0 0x5 0x0 0x0 0x0]
                                          ^
                    object &apos;this&apos; pointer | 

                     |   Object Header   |   MethodTable  |   MyStruct    |
3. MyStruct (Boxed): [0x40 0x5b 0x6f 0x6f 0xfe 0x7 0x0 0x0 0x5 0x0 0x0 0x0]
                                                           ^
                                   adjusted &apos;this&apos; pointer | 
</code></pre></div></div> <p><strong>Key to the diagram</strong></p> <ol> <li>Original <code class="highlighter-rouge">struct</code>, on the <strong>stack</strong></li> <li>The <code class="highlighter-rouge">struct</code> being <em>boxed</em> into an <code class="highlighter-rouge">object</code> that lives on the <strong>heap</strong></li> <li>Adjustment made to <em>this</em> pointer so <code class="highlighter-rouge">MyStruct::ToString()</code> will work</li>
</ol> <p>These stubs make is possible for &#x2018;value types&#x2019; (structs) to override methods from <code class="highlighter-rouge">System.Object</code>, such as <code class="highlighter-rouge">ToString()</code> and <code class="highlighter-rouge">GetHashCode()</code>. The fix-up is needed because structs don&#x2019;t have an &#x2018;object header&#x2019;, but when they&#x2019;re <em>boxed</em> into an <code class="highlighter-rouge">Object</code> they do. So the stub has the job of moving or adjusting the &#x2018;this&#x2019; pointer so that the code in the <code class="highlighter-rouge">ToString()</code> method can work the same, regardless of whether it&#x2019;s operating on a regular &#x2018;struct&#x2019; or one that&#x2019;s been boxed into an &#x2018;object.</p> <p>The unboxing stubs are created in <code class="highlighter-rouge">MethodDesc::DoPrestub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1455-L1487">here</a>, which in turn calls into <code class="highlighter-rouge">MakeUnboxingStubWorker(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1455-L1487">here</a></p> <ul> <li>when <code class="highlighter-rouge">FEATURE_STUBS_AS_IL</code> is <strong>disabled</strong> it then calls <code class="highlighter-rouge">EmitUnboxMethodStub(..)</code> to create the stub, there are per-CPU versions: </li> <li>when <code class="highlighter-rouge">FEATURE_STUBS_AS_IL</code> is <strong>enabled</strong> is instead calls into <code class="highlighter-rouge">CreateUnboxingILStubForSharedGenericValueTypeMethods(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1258-L1351">here</a></li>
</ul> <p>For more information on some of the internal details of unboxing stubs and how they interact with <a href="#generics">&#x2018;generic instantiations&#x2019;</a> see <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/genmeth.cpp#L641-L703">this informative comment</a> and one in the code for <code class="highlighter-rouge">MethodDesc::FindOrCreateAssociatedMethodDesc(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/genmeth.cpp#L843-L1036">here</a>.</p> <h3 id="arrays">Arrays</h3> <p>As discussed <a href="#why-are-stubs-needed">at the beginning</a>, the method bodies for arrays is provided by the runtime, that is the array access methods, &#x2018;get&#x2019; and &#x2018;set&#x2019;, that allow <code class="highlighter-rouge">var a = myArray[5]</code> and <code class="highlighter-rouge">myArray[7] = 5</code> to work. Not surprisingly, these are done as stubs to allow them to be as small and efficient as possible.</p> <p>Here is the flow for wiring up &#x2018;array stubs&#x2019;. It all starts up in <code class="highlighter-rouge">MethodDesc::DoPrestub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/prestub.cpp#L1914">here</a>:</p> <ul> <li>If <code class="highlighter-rouge">FEATURE_ARRAYSTUB_AS_IL</code> is defined (see <a href="#stubs-as-il">&#x2018;Stubs-as-IL&#x2019;</a>), it happens in <code class="highlighter-rouge">GenerateArrayOpStub(ArrayMethodDesc* pMD)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/array.cpp#L1023-L1068">here</a> <ul> <li>Then <code class="highlighter-rouge">ArrayOpLinker::EmitStub()</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/array.cpp#L778-L1020">here</a>, which is responsible for generating 3 types of stubs <code class="highlighter-rouge">{ ILSTUB_ARRAYOP_GET, ILSTUB_ARRAYOP_SET, ILSTUB_ARRAYOP_ADDRESS }</code>.</li> <li>Before calling <code class="highlighter-rouge">ILStubCache::CreateAndLinkNewILStubMethodDesc(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/ilstubcache.cpp#L84-L138">here</a></li> <li>Finally ending up in <code class="highlighter-rouge">JitILStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/dllimport.cpp#L5666-L5712">here</a></li> </ul> </li> <li>When <code class="highlighter-rouge">FEATURE_ARRAYSTUB_AS_IL</code> isn&#x2019;t defined, happens in another version of <code class="highlighter-rouge">GenerateArrayOpStub(ArrayMethodDesc* pMD)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/array.cpp#L1255-L1271">lower down</a> <ul> <li>Then <code class="highlighter-rouge">void GenerateArrayOpScript(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/array.cpp#L1071-L1226">here</a></li> <li>Followed by a call to <code class="highlighter-rouge">StubCacheBase::Canonicalize(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubcache.cpp#L70-L165">here</a>, that ends up in <code class="highlighter-rouge">ArrayStubCache::CompileStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/array.cpp#L1273-L1279">here</a>.</li> <li>Eventually, we end up in <code class="highlighter-rouge">StubLinkerCPU::EmitArrayOpStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/i386/stublinkerx86.cpp#L4786-L5636">here</a>, which does the heavy lifting (despite being under &#x2018;\src\vm\i386&apos; seems to support x86 and AMD64?)</li> </ul> </li>
</ul> <p>I&#x2019;m not going to include the code for the &#x2018;stub-as-IL&#x2019; (<code class="highlighter-rouge">ArrayOpLinker::EmitStub()</code>) or the assembly code (<code class="highlighter-rouge">StubLinkerCPU::EmitArrayOpStub(..)</code>) versions of the array stubs because they&#x2019;re both 100&#x2019;s of lines long, dealing with type and bounds checking, computing address, multi-dimensional arrays and mode. But to give an idea of the complexities, take a look at this comment from <code class="highlighter-rouge">StubLinkerCPU::EmitArrayOpStub(..)</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/i386/stublinkerx86.cpp#L4809">here</a>:</p> <pre><code class="language-C++">// Register usage
//
//                                          x86                 AMD64
// Inputs:
//  managed array                           THIS_kREG (ecx)     THIS_kREG (rcx)
//  index 0                                 edx                 rdx
//  index 1/value                           &lt;stack&gt;             r8
//  index 2/value                           &lt;stack&gt;             r9
//  expected element type for LOADADDR      eax                 rax                 rdx
// Working registers:
//  total (accumulates unscaled offset)     edi                 r10
//  factor (accumulates the slice factor)   esi                 r11
</code></pre> <p>Finally, these stubs are still being improved, for example see <a href="https://github.com/dotnet/coreclr/pull/22376/files">Use unsigned index extension in muldi-dimensional array stubs</a>.</p> <h3 id="tail-calls">Tail Calls</h3> <p>The .NET runtime provides a nice optimisation when doing &#x2018;tail calls&#x2019;, that (amoung other things) will prevent <code class="highlighter-rouge">StackoverflowExceptions</code> in recursive scenarios. For more on <em>why</em> these tail call optimisations are useful and how they work, take a look at:</p> <p>In summary, a tail call optimisation allows the <em>same</em> stack frame to be re-used if in the <em>caller</em>, there is no work done after the function call to the <em>callee</em> (see <a href="https://blogs.msdn.microsoft.com/davbr/2007/06/20/tail-call-jit-conditions/">Tail call JIT conditions</a> (2007) for a more precise definition).</p> <p>And why is this beneficial? From <a href="https://blogs.msdn.microsoft.com/clrcodegeneration/2009/05/11/tail-call-improvements-in-net-framework-4/">Tail Call Improvements in .NET Framework 4</a>:</p> <blockquote> <p>The primary reason for a tail call as an optimization is to improve data locality, memory usage, and cache usage. By doing a tail call the callee will use the same stack space as the caller. This reduces memory pressure. It marginally improves the cache because the same memory is reused for subsequent callers and thus can stay in the cache, rather than evicting some older cache line to make room for a new cache line.</p>
</blockquote> <p>To make this clear, the code below <em>can</em> benefit from the optimisation, because both functions return straight after calling each the other:</p> <pre><code class="language-C#">public static long Ping(int cnt, long val)
{
    if (cnt-- == 0)
        return val;

    return Pong(cnt, val + cnt);
}

public static long Pong(int cnt, long val)
{
    if (cnt-- == 0)
        return val;

    return Ping(cnt, val + cnt);
}
</code></pre> <p>However, if the code was changed to the version below, the optimisation would no longer work because <code class="highlighter-rouge">PingNotOptimised(..)</code> does some extra work between calling <code class="highlighter-rouge">Pong(..)</code> and when it returns:</p> <pre><code class="language-C#">public static long PingNotOptimised(int cnt, long val)
{
    if (cnt-- == 0)
        return val;

    var result = Pong(cnt, val + cnt);
    result += 1; // prevents the Tail-call optimization
    return result;
}

public static long Pong(int cnt, long val)
{
    if (cnt-- == 0)
        return val;

    return PingNotOptimised(cnt, val + cnt);
}
</code></pre> <p>You can see the difference in the code emitted by the JIT compiler for the different scenarios <a href="https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBDAzgWwB8ABAJgAJiBGAdgFgAoAb0fLfIHoPyBhCAExjlc2fAAcANkIBmUCPnIALDBjG4QXAOYBLDIoCuwAHSR8HfhAwA7GBg5hci7FEnYrmjtty59MXB1IAVhQUAGIvHxhTfBgrDDgaAE4ABgAOVFJSVnZqJEoUcgBZbG0rAApqZIBtAF1yZ01cAEpsthYGdk7ODmojakSygAVSzTLSjCNihAA1bAlfNHJkpqaAblaurl7+oZGAOUsAeTEMbXwvGH4xuMnsGbmFpZX1jvYAX0YN4gBmSio8iQQdzkYbua4YchgOKLQHAgBucxarzaG062mk5DKUPicHIAF48U9UV02MQaOQERIXsTSeTBkDRtjFpTyABqSFxNYktgbD7I8hfX65ciwzQg/ZHE5nC5XcYcjAwhkUxEbdrc8jozHYuC4glE/nqsnKqmfA3sBFQciwHwSCGE+lgpnGtnytY0q1+fS2tmEqirbrkMSwOGxDC4ch6IQAFRKEjgYDmEnIECl5wAXthTkD3UbrV6MC9OnzOoK/gClQ7RnKnaLjUjOmruZqsXEdfjCct3Z0jZTqWbaeLHdDnezsW7+90jaDNAcMMdTudcJcWwqR67C+9GG8gA=">in SharpLab</a>.</p> <p>But where do the &#x2018;tail call optimisation <em>stubs</em>&#x2019; come into play? Helpfully there is a tail call related <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/tailcalls-with-helpers.md">design doc</a> that explains, from &#x2018;current way of handling tail-calls&#x2019;:</p> <blockquote> <p><strong>Fast tail calls</strong>
These are tail calls that are handled directly by the jitter and no runtime cooperation is needed. They are limited to cases where:</p> <ul> <li>Return value and call target arguments are all either primitive types, reference types, or valuetypes with a single primitive type or reference type fields</li> <li>The aligned size of call target arguments is less or equal to aligned size of caller arguments</li> </ul>
</blockquote> <p>So, the stubs aren&#x2019;t always needed, sometimes the work can be done by the JIT, if there scenario is simple enough.</p> <p>However for the more complex cases, a &#x2018;helper&#x2019; stub is needed:</p> <blockquote> <p><strong>Tail calls using a helper</strong>
Tail calls in cases where we cannot perform the call in a simple way are implemented using a tail call helper. Here is a rough description of how it works:</p> <ul> <li>For each tail call target, the jitter asks runtime to <strong>generate an assembler argument copying routine</strong>. This routine reads vararg list of arguments and places the arguments in their proper slots in the CONTEXT or on the stack. Together with the argument copying routine, the runtime also builds a list of offsets of references and byrefs for return value of reference type or structs returned in a hidden return buffer and for structs passed by ref. The gc layout data block is stored at the end of the argument copying thunk.</li> <li>At the time of the tail call, the caller generates a vararg list of all arguments of the tail called function and then calls <code class="highlighter-rouge">JIT_TailCall</code> runtime function. It passes it the copying routine address, the target address and the vararg list of the arguments.</li> <li>The <code class="highlighter-rouge">JIT_TailCall</code> then performs the following:
&#x2026;</li> </ul>
</blockquote> <p>To see the rest of the steps that <code class="highlighter-rouge">JIT_TailCall</code> takes you can read the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/tailcalls-with-helpers.md#tail-calls-using-a-helper">design doc</a> or if you&#x2019;re really keen you can look at the code in <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/jithelpers.cpp#L5978-L6195">/vm/jithelpers.cpp</a>. Also, there&#x2019;s a useful explanation of what it needs to handle in the JIT code, see <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/jit/morph.cpp#L7491-L7528">here</a> and <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/jit/lower.cpp#L2125-L2150">here</a>.</p> <p>However, we&#x2019;re just going to focus on the stubs, refered to as an &#x2018;assembler argument copying routine&#x2019;. Firstly, we can see that they have their own stub manager, <code class="highlighter-rouge">TailCallStubManager</code>, which is implemented <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/stubmgr.cpp#L2350-L2488">here</a> and allows the stubs to play nicely with the debugger. Also interesting to look at is the <code class="highlighter-rouge">TailCallFrame</code> <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/frames.h#L3141-L3271">here</a> that is used to ensure that the &#x2018;stack walker&#x2019; can work well with tail calls.</p> <p>Now, onto the stubs themselves, the &#x2018;copying routines&#x2019; are provided by the runtime via a call to <code class="highlighter-rouge">CEEInfo::getTailCallCopyArgsThunk(..)</code> in <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/jitinterface.cpp#L13814-L13838">/vm/jitinterface.cpp</a>. This in turn calls the CPU specific versions of <code class="highlighter-rouge">CPUSTUBLINKER::CreateTailCallCopyArgsThunk(..)</code>:</p> <ul> <li>X86 <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/i386/stublinkerx86.cpp#L6042-L6435">/vm/i386/stublinkerx86.cpp</a></li> <li>ARM <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm/stubs.cpp#L3089-L3339">/vm/arm/stubs.cpp</a></li>
</ul> <p>These routines have the complex and hairy job of dealing with the CPU registers and calling conventions. They achieve this by dynamicially emitting assembly instructions, to create a function that looks like the <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/i386/stublinkerx86.cpp#L6051-L6064">following pseudo code</a> (X86 version):</p> <pre><code class="language-C++">    // size_t CopyArguments(va_list args,         (RCX)
    //                      CONTEXT *pCtx,        (RDX)
    //                      DWORD64 *pvStack,     (R8)
    //                      size_t cbStack)       (R9)
    // {
    //     if (pCtx != NULL) {
    //         foreach (arg in args) {
    //             copy into pCtx or pvStack
    //         }
    //     }
    //     return &lt;size of stack needed&gt;;
    // }
</code></pre> <p>In addition there is one other type of stub that is used. Known as the <code class="highlighter-rouge">TailCallHelperStub</code>, they also come in per-CPU versions:</p> <ul> <li>AMD64 <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/JitHelpers_Fast.asm#L858-L956">/vm/amd64/JitHelpers_Fast.asm</a></li> <li>ARM <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm/asmhelpers.asm#L203-L315">/vm/arm/asmhelpers.asm</a>.</li>
</ul> <p>Going forward, there are several limitations of to this approach of using per-CPU stubs, <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/tailcalls-with-helpers.md#tail-calls-using-a-helper">as the design doc explains</a>:</p> <blockquote> <ul> <li><strong>It is expensive to port to new platforms</strong> <ul> <li>Parsing the vararg list is not possible to do in a portable way on Unix. Unlike on Windows, the list is not stored a linear sequence of the parameter data bytes in memory. va_list on Unix is an opaque data type, some of the parameters can be in registers and some in the memory.</li> <li>Generating the copying asm routine needs to be done for each target architecture / platform differently. And it is also very complex, error prone and impossible to do on platforms where code generation at runtime is not allowed.</li> </ul> </li> <li><strong>It is slower than it has to be</strong> <ul> <li>The parameters are copied possibly twice - once from the vararg list to the stack and then one more time if there was not enough space in the caller&#x2019;s stack frame.</li> <li><code class="highlighter-rouge">RtlRestoreContext</code> restores all registers from the <code class="highlighter-rouge">CONTEXT</code> structure, not just a subset of them that is really necessary for the functionality, so it results in another unnecessary memory accesses.</li> </ul> </li> <li><strong>Stack walking over the stack frames of the tail calls requires runtime assistance.</strong></li> </ul>
</blockquote> <p>Fortunately, it then goes into great depth discussing how a new approach <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/tailcalls-with-helpers.md#the-new-approach-to-tail-calls-using-helpers">could be implemented</a> and how it would solve these issues. Even better, work has already started and we can follow along in <a href="https://github.com/dotnet/coreclr/pull/26418">Implement portable tailcall helpers #26418</a> (currently sitting at &#x2018;31 of 55&#x2019; tasks completed, with over 50 files modified, it&#x2019;s not a small job!).</p> <p>Finally, for other PRs related to tail calls, see:</p> <h3 id="virtual-stub-dispatch-vsd">Virtual Stub Dispatch (VSD)</h3> <p>I&#x2019;ve saved the best for last, &#x2018;Virtual Stub Dispatch&#x2019; or VSD is such an in-depth topic, that it an entire <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/virtual-stub-dispatch.md">BotR page devoted to it</a>!! From the introduction:</p> <blockquote> <p>Virtual stub dispatching (VSD) is the <strong>technique of using stubs for virtual method invocations instead of the traditional virtual method table</strong>. In the past, interface dispatch required that interfaces had process-unique identifiers, and that every loaded interface was added to a global interface virtual table map. This requirement meant that all interfaces and all classes that implemented interfaces had to be restored at runtime in NGEN scenarios, causing significant startup working set increases. <strong>The motivation for stub dispatching was to eliminate much of the related working set, as well as distribute the remaining work throughout the lifetime of the process</strong>.</p>
</blockquote> <p>It then goes on to say:</p> <blockquote> <p>Although it is possible for VSD to dispatch both virtual instance and interface method calls, <strong>it is currently used only for interface dispatch</strong>.</p>
</blockquote> <p>So despite having the work &#x2018;virtual&#x2019; in the title, it&#x2019;s not actually used for C# methods with the <code class="highlighter-rouge">virtual</code> modifier on them. However, if you look at the <a href="https://sharplab.io/#v2:EYLgxg9gTgpgtADwGwBYA0AXEBLANgHwAEAmARgFgAoQgZgAIS6BhOkOgSQDEII6BvKnSEN6hFHQAiEbhAAUASn6DhKgPSrJvAM4QAtjAwALbADsA5gEJlQgL5U7lKrTqmMMKADMAhmBgcZSpR0AJBimjIKANzC9kA==">IL for interface methods</a> you can see why they are also known as &#x2018;virtual&#x2019;.</p> <p>Virtual Stub Dispatch is so complex, it actually has several different stub types, from <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/virtualcallstub.h#L311--L318">/vm/virtualcallstub.h</a>:</p> <pre><code class="language-C++">enum StubKind { 
  SK_UNKNOWN, 
  SK_LOOKUP,      // Lookup Stubs are SLOW stubs that simply call into the runtime to do all work.
  SK_DISPATCH,    // Dispatch Stubs have a fast check for one type otherwise jumps to runtime.  Works for monomorphic sites
  SK_RESOLVE,     // Resolve Stubs do a hash lookup before fallling back to the runtime.  Works for polymorphic sites.
  SK_VTABLECALL,  // Stub that jumps to a target method using vtable-based indirections. Works for non-interface calls.
  SK_BREAKPOINT 
};
</code></pre> <p>So there are the following types (these are links to the <code class="highlighter-rouge">AMD64</code> versions, <code class="highlighter-rouge">x86</code> versions are in <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/i386/virtualcallstubcpu.hpp">/vm/i386/virtualcallstubcpu.hpp</a>):</p> <ul> <li><a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/virtualcallstubcpu.hpp#L50-L82">Lookup Stubs</a>: <ul> <li><code class="highlighter-rouge">// Virtual and interface call sites are initially setup to point at LookupStubs. This is because the runtime type of the &lt;this&gt; pointer is not yet known, so the target cannot be resolved.</code></li> </ul> </li> <li><a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/virtualcallstubcpu.hpp#L194-L286">Dispatch Stubs</a>: <ul> <li><code class="highlighter-rouge">// Monomorphic and mostly monomorphic call sites eventually point to DispatchStubs. A dispatch stub has an expected type (expectedMT), target address (target) and fail address (failure). If the calling frame does in fact have the &lt;this&gt; type be of the expected type, then control is transfered to the target address, the method implementation. If not, then control is transfered to the fail address, a fail stub (see below) where a polymorphic lookup is done to find the correct address to go to.</code></li> <li>There&#x2019;s also specific versions, <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/virtualcallstubcpu.hpp#L118-L143">DispatchStubShort</a> and <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/virtualcallstubcpu.hpp#L154-L183">DispatchStubLong</a>, see <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/virtualcallstubcpu.hpp#L110-L116">this comment</a> for why they are both needed.</li> </ul> </li> <li><a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/virtualcallstubcpu.hpp#L337-L435">Resolve Stubs</a>: <ul> <li><code class="highlighter-rouge">// Polymorphic call sites and monomorphic calls that fail end up in a ResolverStub. There is only one resolver stub built for any given token, even though there may be many call sites that use that token and many distinct &lt;this&gt; types that are used in the calling call frames. A resolver stub actually has two entry points, one for polymorphic call sites and one for dispatch stubs that fail on their expectedMT test.  There is a third part of the resolver stub that enters the ee when a decision should be made about changing the callsite.</code></li> </ul> </li> <li><a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/virtualcallstubcpu.hpp#L460-L494">V-Table or Virtual Call Stubs</a> <ul> <li><code class="highlighter-rouge">//These are jump stubs that perform a vtable-base virtual call. These stubs assume that an object is placed in the first argument register (this pointer). From there, the stub extracts the MethodTable pointer, followed by the vtable pointer, and finally jumps to the target method at a given slot in the vtable.</code></li> </ul> </li>
</ul> <p>The below diagram shows the general control flow between these stubs</p> <p><img src="/images/2019/09/virtualstubdispatch-fig2.png" alt="Virtual Stub Dispatch"></p> <p>(Image from <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/virtual-stub-dispatch.md#design-of-virtual-stub-dispatch">&#x2018;Design of Virtual Stub Dispatch&#x2019;</a>)</p> <p>Finally, if you want <em>even</em> more in-depth information see <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/virtualcallstub.h#L176-L219">this comment</a>.</p> <p>However, these stubs come at a cost, which makes <em>virtual</em> method calls more expensive than <em>direct</em> ones. This is why <em>de-virtualization</em> is so important, i.e. the process of the .NET JIT detecting when a <em>virtual</em> call can instead be replaced by a <em>direct</em> one. There has been some work done in .NET Core to improve this, see <a href="https://github.com/dotnet/coreclr/pull/9230">Simple devirtualization #9230</a> which covers <code class="highlighter-rouge">sealed</code> classes/methods and when the object type is known <em>exactly</em>. However there is still more to be done, as shown in <a href="https://github.com/dotnet/coreclr/issues/9908">JIT: devirtualization next steps #9908</a>, where &#x2018;5 of 23&#x2019; tasks have been completed.</p> <h2 id="other-types-of-stubs">Other Types of Stubs</h2> <p>This post is already <em>way</em> too long, so I don&#x2019;t intend to offer any analysis of the following stubs. Instead I&#x2019;ve just included some links to more information so you can read up on any that interest you!</p> <p><strong>&#x2018;Jump&#x2019; stubs</strong></p> <p><strong>&#x2018;Function Pointer&#x2019; stubs</strong></p> <ul> <li>&#x2018;Function Pointer&#x2019; Stubs, see <a href="https://github.com/dotnet/coreclr/blob/master/src/vm/fptrstubs.cpp">/vm/fptrstubs.cpp</a> and <a href="https://github.com/dotnet/coreclr/blob/master/src/vm/fptrstubs.h">/vm/fptrstubs.h</a></li> <li><code class="highlighter-rouge">// FuncPtrStubs contains stubs that is used by GetMultiCallableAddrOfCode() if the function has not been jitted. Using a stub decouples ldftn from the prestub, so prestub does not need to be backpatched. This stub is also used in other places which need a function pointer</code></li>
</ul> <p><strong>&#x2018;Thread Hijacking&#x2019; stubs</strong></p> <p>From the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/botr/threading.md">BotR page on &#x2018;Threading&#x2019;</a>:</p> <blockquote> <ul> <li>If fully interruptable, it is safe to perform a GC at any point, since the thread is, by definition, at a safe point. It is reasonable to leave the thread suspended at this point (because it&#x2019;s safe) but various historical OS bugs prevent this from working, because the CONTEXT retrieved earlier may be corrupt). Instead, the thread&#x2019;s instruction pointer is overwritten, redirecting it to a <strong>stub</strong> that will capture a more complete CONTEXT, leave cooperative mode, wait for the GC to complete, reenter cooperative mode, and restore the thread to its previous state.</li> <li>If partially-interruptable, the thread is, by definition, not at a safe point. However, the caller will be at a safe point (method transition). Using that knowledge, the CLR &#x201C;hijacks&#x201D; the top-most stack frame&#x2019;s return address (physically overwrite that location on the stack) with a <strong>stub</strong> similar to the one used for fully-interruptable code. When the method returns, it will no longer return to its actual caller, but rather to the <strong>stub</strong> (the method may also perform a GC poll, inserted by the JIT, before that point, which will cause it to leave cooperative mode and undo the hijack).</li> </ul>
</blockquote> <p>Done with the <code class="highlighter-rouge">OnHijackTripThread</code> method in <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/amd64/AsmHelpers.asm#L431-L456">/vm/amd64/AsmHelpers.asm</a>, which calls into <code class="highlighter-rouge">OnHijackWorker(..)</code> in <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/threadsuspend.cpp#L5691-L5734">/vm/threadsuspend.cpp</a>.</p> <p><strong>&#x2018;NGEN Fixup&#x2019; stubs</strong></p> <p>From <a href="https://web.archive.org/web/20090213104137/http://msdn.microsoft.com/en-us/magazine/cc163610.aspx#S7">CLR Inside Out - The Performance Benefits of NGen</a> (2006):</p> <blockquote> <p>Throughput of NGen-compiled code is lower than that of JIT-compiled code primarily for one reason: cross-assembly references. In JIT-compiled code, cross-assembly references can be implemented as direct calls or jumps since the exact addresses of these references are known at run time. For statically compiled code, however, <strong>cross-assembly references need to go through a jump slot that gets populated with the correct address at run time by executing a method pre-stub</strong>. The method pre-stub ensures, among other things, that the <strong>native images for assemblies referenced by that method are loaded into memory before the method is executed</strong>. The pre-stub only needs to be executed the first time the method is called; it is short-circuited out for subsequent calls. However, every time the method is called, cross-assembly references do need to go through a level of indirection. This is principally what accounted for the 5-10 percent drop in throughput for NGen-compiled code when compared to JIT-compiled code.</p>
</blockquote> <p>Also see the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/jump-stubs.md#ngen">&#x2018;NGEN&#x2019; section</a> of the &#x2018;jump stub&#x2019; design doc.</p> <h2 id="stubs-in-the-mono-runtime">Stubs in the Mono Runtime</h2> <p>Mono refers to &#x2018;Stubs&#x2019; as &#x2018;Trampolines&#x2019; and they&#x2019;re <a href="https://github.com/mono/mono/search?l=C&amp;q=trampoline&amp;type=Code">widely used</a> in the source code.</p> <p>The Mono docs have an excellent page <a href="https://www.mono-project.com/docs/advanced/runtime/docs/trampolines/">all about &#x2018;Trampolines&#x2019;</a>, that lists the following types:</p> <p>Also the docs page on <a href="https://www.mono-project.com/docs/advanced/runtime/docs/generic-sharing/">Generic Sharing</a> has some good, in-depth information.</p> <h2 id="conclusion">Conclusion</h2> <p>So it turns out that &#x2018;stubs&#x2019; are way more prevelant in the .NET Core Runtime that I imagined when I first started on this post. They are an interesting technique and they contain a fair amount of complexity. In addition, I only covered each stub in isolation, in reality many of them have to play nicely together, for instance imagine a <code class="highlighter-rouge">delegate</code> calling a <code class="highlighter-rouge">virtual</code> method that has <code class="highlighter-rouge">generic</code> type parameters and you can see that things start to get complex! (that scenario <em>might</em> contain 3 seperate stubs, although they are also <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/arm/stubs.cpp#L1677-L1684">shared where possible</a>). If you were then to add <code class="highlighter-rouge">array</code> methods, <code class="highlighter-rouge">P/Invoke</code> marshalling and <code class="highlighter-rouge">un-boxing</code> to the mix, things get <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/comdelegate.cpp#L3228-L3252">even more hairy</a> and <a href="https://github.com/dotnet/coreclr/blob/4895a06c/src/vm/genmeth.cpp#L660-L703">even more complex</a>!</p> <p><strong>If anyone has read this far and wants a fun challenge, try and figure out what&#x2019;s the most stubs you can force a single method call to go via! If you do, let me know in the comments or <a href="https://twitter.com/matthewwarren">via twitter</a></strong></p> <p>Finally, by knowing <strong>where</strong> and <strong>when</strong> stubs are involved in our method calls, we can start to understand the overhead of each scenario. For instance, it explains why <code class="highlighter-rouge">delegate</code> method calls are a bit slower than calling a method directly and why &#x2018;de-virtualization&#x2019; is so important. Having the JIT be able to perform extra analysis to determine that a virtual call can be converted into a direct one skips an entire level of indirection, for more on this see:</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
    <script>
        (function() {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function() {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) {}
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>