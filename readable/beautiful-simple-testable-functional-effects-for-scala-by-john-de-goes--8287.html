<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Beautiful, Simple, Testable Functional Effects for Scala by John De Goes - Signify Technology - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Beautiful, Simple, Testable Functional Effects for Scala by John De Goes - Signify Technology - linksfor.dev(s)"/>
    <meta property="og:description" content="Want to know more about the dark side of Tagless-Final? In this article John De Goes advises that it may not be the best option for Scala however he has an alternative, check it out! What are your thoughts? &amp;#39;See my accompanying talk, The Death of Finally Tagless, which was released today and covers ZIO Environment. Today&#x2019;s functional effect systems for Scala, such as the ZIO library that I work on, are incredibly powerful. They provide an effect data type that unifies synchronous, asynchronou..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.signifytechnology.com/blog/2019/03/beautiful-simple-testable-functional-effects-for-scala-by-john-de-goes"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Beautiful, Simple, Testable Functional Effects for Scala by John De Goes - Signify Technology</title>
<div class="readable">
        <h1>Beautiful, Simple, Testable Functional Effects for Scala by John De Goes - Signify Technology</h1>
            <div>Reading time: 38-48 minutes</div>
        <div>Posted here: 12 Mar 2019</div>
        <p><a href="https://www.signifytechnology.com/blog/2019/03/beautiful-simple-testable-functional-effects-for-scala-by-john-de-goes">https://www.signifytechnology.com/blog/2019/03/beautiful-simple-testable-functional-effects-for-scala-by-john-de-goes</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
		<p>Connecting...</p>
		
		

		
	




		<section id="content">
<div>
	<div>
		<div id="blog">
			<p><img alt="W1siziisijiwmtkvmdmvmtivmtevntavntmvndgyl3blegvscy1wag90by0xoti3nta3lmpwzwcixsxbinailcj0ahvtyiisijkwmhg5mdbcdtawm2uixv0" data-reference="943ce1085f487d3d7d47a9d490ad5ea4" src="https://d3jh33bzyw1wep.cloudfront.net/s3/W1siZiIsIjIwMTkvMDMvMTIvMTEvNTAvNTMvNDgyL3BleGVscy1waG90by0xOTI3NTA3LmpwZWciXSxbInAiLCJ0aHVtYiIsIjkwMHg5MDBcdTAwM2UiXV0"></p><p><strong>Want to know more about the dark side of&nbsp;Tagless-Final?</strong></p>

<p><strong>In this article <a href="https://twitter.com/jdegoes?lang=en">John De Goes</a> advises that it may not be the best option for Scala however he has an alternative, check it out!</strong></p>

<p><strong>What are your thoughts?</strong></p>





<p>'<strong>See my accompanying talk,&nbsp;The Death of Finally Tagless, which was released today and covers ZIO Environment.</strong></p>

<p>Today‚Äôs functional effect systems for Scala, such as the&nbsp;<a href="https://github.com/scalaz/scalaz-zio">ZIO library</a>&nbsp;that I work on, are&nbsp;<em>incredibly&nbsp;</em>powerful.</p>

<p>They provide an effect data type that unifies synchronous, asynchronous, concurrent, and resource effects, and support automatic error propagation across these boundaries.</p>

<p>They‚Äôre way faster and more powerful than Scala‚Äôs '<strong>Future</strong>', well-documented, reasonably easy to use, and sometimes come equipped with concurrent data structures, a fiber-based concurrency model, and compositional interruption and timeouts for efficient global computation.</p>

<p>They‚Äôre also purely functional, and showcase the power of pure functional programming to solve modern business problems.</p>

<p>Unfortunately, there‚Äôs a dark secret to these functional effect systems: out of the box, they don‚Äôt live up to the full promise of functional programming. Despite being referentially transparent, they‚Äôre not really testable.</p>



<h3><strong>Untestable Effects</strong></h3>

<div>
<p>Functional programming ordinarily gives us the incredible ability to easily test our software.</p>

<p>The reason for this is quite simple: in functional programming, all a function does is map its input to some output. Functions are total (they return an output for every input), deterministic (they return the same output for the same input), and free of side effects (they only compute the return value, and don‚Äôt interact with the outside world).</p>

<p>Surprisingly to many, these properties also hold for functions that returns functional&nbsp;<em>effects</em>. A functional effect, it turns out, is just an immutable data structure that&nbsp;describes&nbsp;an effect, without actually executing it.</p>

<p>Functional programs construct and compose these data structures together using operations like '<strong>map</strong>' and '<strong>flatMap</strong>', resulting in a data structure that&nbsp;models&nbsp;the entire effectful application. Then in the application‚Äôs main function, the data structure is translated, step-by-step, into the effectful operations that it describes.</p>

<p>The simplest way to build a functional effect is to&nbsp;<em>describe&nbsp;</em>an effect by using a data structure to store a&nbsp;<em>thunk&nbsp;</em>(a '<strong>Function0</strong>' in Scala‚Äôs terminology) that holds an arbitrary hunk of effectful Scala code.</p>

<p>Here‚Äôs a data type called '<strong>IO</strong>' which does exactly this:</p>

<pre><code>class IO[+A](val unsafeInterpret: () =&gt; A) { s =&gt;
  def map[B](f: A =&gt; B) = flatMap(f.andThen(IO.effect(_)))
  def flatMap[B](f: A =&gt; IO[B]): IO[B] =
    IO.effect(f(s.unsafeInterpret()).unsafeInterpret())
}
object IO {
  def effect[A](eff: =&gt; A) = new IO(() =&gt; eff)
}</code></pre>

<p>Now we can construct pure functions that return functional effects (<em>models </em>of effects) quite simply:</p>

<pre><code>def putStrLn(line: String): IO[Unit] = 
  IO.effect(println(line))

val getStrLn: IO[String] = 
  IO.effect(scala.io.StdIn.readLine())</code></pre>

<p>These functions are total, deterministic, and free of side effects, because they don‚Äôt<em>&nbsp;do</em>&nbsp;anything effectful, they merely build a data structure that&nbsp;<em>describes&nbsp;</em>effectful operations.</p>

<p>Using '<strong>map</strong>' and '<strong>flatMap</strong>', we can build describes of whole effectful programs. For example, the following '<strong>IO</strong>' program asks the user for some input and prints it back out to them:</p>

<pre><code>val program: IO[String] = 
  for {
    _    &lt;- putStrLn("Good morning, what's your name?")
    name &lt;- getStrLn
    _    &lt;- putStrLn(s"Great to meet you, $name")
  } yield name</code></pre>

<p>Now if you evaluate '<strong>program</strong>'&nbsp;in the Scala REPL, you‚Äôll find that it doesn‚Äôt actually&nbsp;<em>do</em>&nbsp;anything except construct an '<strong>IO</strong>' value, which is itself an immutable data structure.</p>

<p>However, you can (non-functionally) interpret this program to the effects that it describes by calling the '<strong>unsafeInterpret()</strong>' function:</p>

<pre><code>program.unsafeInterpret()</code></pre>

<p>In this way, while we can‚Äôt avoid doing something ‚Äúnon-functional‚Äù forever, we can at least make the vast majority of our code purely functional, and benefit from increased power of abstraction, refactoring, and testability.</p>

<p>Well,&nbsp;in <em>theory</em>. There‚Äôs a big problem with&nbsp;<em>testability</em>.</p>

<p>In our tests, we need to call functions and verify their outputs match our expectations. Unfortunately, '<strong>IO</strong>' values, like the above '<strong>program</strong>' value, cannot be compared to other '<strong>IO</strong>' values. The reason is that they embed arbitrary hunks of Scala code inside them (functions), and Scala functions cannot be compared for equality.</p>

<p>Although Scala functions do have '<strong>equals</strong>' and '<strong>hashCode</strong>', like all ojbects, these do not have meaningful implementations; they are not based on what the function does, but rather, based on the&nbsp;<em>reference&nbsp;</em>of the constructed object.</p>

<p>An easy way to see this is comparing the values of two '<strong>putStrLn</strong>' values constructed with the same text output:</p>

<pre><code>&gt; putStrLn("Hello") == putStrLn("Hello")
: false </code></pre>

<p>Even though both of these '<strong>IO</strong>' values represent the&nbsp;<em>same&nbsp;</em>program, Scala cannot know that, because functions cannot be sensibly compared for equality. This is not just a limitation of Scala, but rather a fundamental limitation of computation: in Turing complete languages, we cannot know for sure if two functions are equal, even if we look at their implementations.</p>

<p>This means that while functional effect systems&nbsp;<em>do&nbsp;</em>provide us lots of concrete, tangible benefits (asynchronicity, concurrency, resource-safety, etc.), and while they&nbsp;do&nbsp;give us increased powers of abstraction and refactoring, they don‚Äôt make it any easier to test effectful code.</p>

<p>In part to solve this problem (and in part to gain a benefit called&nbsp;<em>parametric reasoning</em>), some Scala functional programmers have used&nbsp;<em>tagless-final</em>, a technique popularized in Haskell.</p>



<h3><strong>Tagless-Final 101</strong></h3>

<div>
<p>In tagless-final, we often use<em>&nbsp;type classes</em>&nbsp;to model effects (although it‚Äôs&nbsp;<em>possible&nbsp;</em>to use records, this approach seems not very popular in Scala).</p>

<p>So instead of interacting with '<strong>putStrLn</strong>' and '<strong>getStrLn</strong>' directly, we define a type class to describe console capabilities. The type class is&nbsp;<em>parameterized </em>over the effect type:</p>

<pre><code>trait Console[F[_]] {
  def putStrLn(line: String): F[Unit]

  val getStrLn: F[String]
}
object Console {
  def apply[F[_]](implicit F: Console[F]): Console[F] = F
}</code></pre>

<p>Then we can define instances of this type class for '<strong>IO</strong>':</p>

<pre><code>implicit val ConsoleIO: Console[IO] = new Console[IO] {
  def putStrLn(line: String): IO[Unit] = 
    IO.effect(println(line))

  val getStrLn: IO[String] = 
    IO.effect(scala.io.StdIn.readLine())
}</code></pre>

<p>Now we write programs that are&nbsp;<em>polymorphic&nbsp;</em>in the effect type, which express which capabilities they require from the effect by using type class constraints (commonly modeled using context bounds, which desugar to implicit parameter lists):</p>

<pre><code>def program[F[_]: Console: Monad]: F[String] = 
  for {
    _    &lt;- Console[F].putStrLn("Good morning, what's your name?")
    name &lt;- Console[F].getStrLn
    _    &lt;- Console[F].putStrLn(s"Great to meet you, $name")
  } yield name</code></pre>

<p>Since this program is&nbsp;<em>polymorphic&nbsp;</em>in the effect type, you can&nbsp;instantiate&nbsp;it to any concrete data type (such as '<strong>IO</strong>') that supports its required capabilities. For example:</p>

<pre><code>val programIO: IO[String] = program[IO]</code></pre>

<p>(This assumes a sutiable instance of some '<strong>Monad</strong>' type class has been defined for '<strong>IO</strong>', which is required because Scala‚Äôs '<strong>for</strong>' comprehension desugars to '<strong>map</strong>' and '<strong>flatMap</strong>'.)</p>

<p>Once all this machinery is in place, it becomes fairly straightforward to define a data type just for testing:</p>

<pre><code>case class TestData(input: List[String], output: List[String])
case class TestIO[A](run: TestData =&gt; (TestData, A)) { s =&gt;
  def map[B](f: A =&gt; B): TestIO[B] = flatMap(TestIO.value(_))
  def flatMap[B](f: A =&gt; TestIO[B]): TestIO[B] = 
    TestIO(d =&gt; 
      (s run d) match { case (d, a) =&gt; f(a) run d })
}
object TestIO {
  def value[A](a: =&gt; A): TestIO[A] = TestIO(d =&gt; (d, a))
}</code></pre>

<p>With this test data type, you can define an instance of the '<strong>Console</strong>' type class that simply pulls lines of input from the test data, and writes lines of output to the test data (left as an exercise for the reader!).</p>

<p>Once you define this and the '<strong>Monad</strong>' instance, you can instantiate the polymorphic program to the test effect:</p>

<pre><code>val programTest: TestIO[String] = program[TestIO]</code></pre>

<p>Finally, at long last testability has been regained: you can write fast, deterministic unit tests that thoroughly test your application logic. Your CI builds will complete quickly and you can refactor with confidence.</p>

<p>Unfortunately, this benefit comes at considerable cost.</p>



<h3><strong>The Dark Side of Tagless-Final</strong></h3>

<p>The tagless-final approach is robust, and many people are quite happy using the technique to build production business applications. However, the technique suffers from a number of drawbacks, each explored in the sections that follow.</p>

<div>
<h3><strong>Massive Ramp-Up</strong></h3>

<div>
<p>As demonstrated in this article, the tagless-final technique is not for the faint of heart. It requires advanced knowledge of the Scala programming language, functional programming, and how we model some functional constructs in Scala.</p>

<p>In particular, to competently use tagless-final in all common scenarios, you will have to understand:</p>

<ol>
	<li>Functional Effects.</li>
	<li>Parametric Polymorphism.</li>
	<li>Higher-kinded Types.</li>
	<li>Type Classes &amp; their Scala encoding.</li>
	<li>Type Class Instances &amp; their Scala encoding.</li>
	<li>Partial Type Application (AKA&nbsp;<em>Type Lambdas</em>).</li>
	<li>The Monad Hierarchy.</li>
</ol>

<div>
<p>These are not topics that one co-worker can casually introduce to another co-worker over a lunch break. It‚Äôs not possible to sneak tagless-final into a code base. Some combination of training and / or mentorship are required.</p>



<h3><strong>Type Class Abuse</strong></h3>

<div>
<p>Although you don‚Äôt have to use type classes for tagless-final (indeed, the earliest encoding used ML, but type classes were used in the seminal&nbsp;<em>Finally Tagless</em>&nbsp;paper), it‚Äôs overwhelmingly common to do so in the Scala community.</p>

<p>The reason is that type classes give you nicer syntax and help you thread the (many) constraints throughout your application.</p>

<p>Unfortunately, this is an abuse of the concept of a type class. A type class, fundamentally, is an&nbsp;<em>abstraction</em>. It lets us talk about the ways in which data types are similar, by describing those similarities with&nbsp;<em>algebraic laws</em>.</p>

<p>These algebraic laws let us write generic code across many different data types that share a mathematically-precise definition of&nbsp;<em>similar structure</em>, making our functional code principled in a way that ad hoc polymorphism is not.</p>

<p>Tagless-final type classes do not, in general, have algebraic laws. Most have no laws at all. This represents a serious abuse of the construct of a type class and an impediment for teaching type classes to Scala developers.</p>



<h3><strong>Big Bang</strong></h3>

<div>
<p>If we wish to use tagless-final to test a method deep inside our code base, a method which uses '<strong>Future</strong>' or maybe '<strong>IO</strong>', then we cannot make a small series of rote changes.</p>

<p>Instead, we have to perform a ‚Äúbig bang‚Äù style refactoring, which involves a commitment to tagless-final and a lot of work to obtain testability for a single method.</p>

<p><em>Big bang</em>&nbsp;refactoring can improve a code base, but it is often at odds with the needs of shipping software. It‚Äôs friendlier to the business if we can make changes incrementally and pay only for what we need today.</p>



<h3><strong>Tedious Repetition</strong></h3>

<div>
<p>Constraints on type classes are propagated with implicit parameter lists. Context bounds provide a more compact syntax for implicit parameter lists, but when a method that‚Äôs polymorphic in an effect requires a lot of different type classes, it can still be unwieldly:</p>

<pre><code>ef genFeed[F[_]: Monad: 
  Logging: UserDatabase:         
  ProfileDatabase: RedisCache: 
  GeoIPService: AuthService: 
  SessionManager: Localization:   
  Config: EventQueue: Concurrent:   
  Async: MetricsManager]: F[Feed] = ???</code></pre>

<p>Unfortunately, if you are following functional programming best practices, and pushing dependencies to the edges, requiring as little as possible from every method, then you will find yourself engaging in tedious repetition of similar lists of context bounds:</p>

<pre><code>def cacheFeed[F[_]: Monad: 
  Logging: UserDatabase:         
  ProfileDatabase: RedisCache:  
  Config: EventQueue: Concurrent:   
  Async: MetricsManager](feed: Feed): F[Unit] = ???</code></pre>

<p>Some developers try to work around this tedium by creating ‚Äúmodule‚Äù classes that declare the same set of dependencies for every method inside the module‚Äîeven if many methods require less than the full set of constraints across all methods.</p>

<p>This technique makes it easier to deal with the tedium, but at the cost of overly constraining methods and making weakening so-called&nbsp;<em>parametric reasoning.</em></p>



<h3><strong>Stubborn Repetition</strong></h3>

<div>
<p>Not only is there a lot of repetition in tagless-final programs, but this repetition proves stubborn to abstraction.</p>

<p>Ideally, if we have two methods with the same set of type class constraints, we‚Äôd like to be able to create&nbsp;<em>something&nbsp;</em>to represent that set of constraints, and then use it to remove the duplication across the two methods:</p>

<pre><code>def method1[F[_]: AllConstraints] = ???

def method2[F[_]: AllConstraints] = ???</code></pre>

<p>Unfortunately, Scala does not have any mechanism to abstract across duplicated parameter lists.</p>

<p>So not only is the repetition quite tedious, but it‚Äôs unavoidable, due to limitations in the Scala programming language.</p>



<h3><strong>Completely Uninferrable</strong></h3>
</div>

<div>
<p>One of the reasons writing Haskell or PureScript is so exceedingly pleasant is the universal and flawless type inference. Scala has enough type inference to make it a joy compared to Java, but many types in Scala cannot be infered (full inference for a higher-kinded type system in the presence of subtyping is still research-grade).</p>

<p>We would love to be able to take advantage of type inference for tagless-final programs, writing the equivalent of:</p>

<pre><code>def genFeed = ...</code></pre>

<p>Unfortunately, the type class constraints cannot be inferred, even in theory, because they are not actually type parameters, but values in an implicit parameter list (in a language in which anything can be implicit), and asking any compiler to infer arbitrary implicit parameter lists is unreasonable.</p>

<p>Not only do we have to type out the full list of constraints every time, but if we get the constraints wrong, the error messages will fail with non-obvious ‚Äúimplicit not found‚Äù or ‚Äúmethod not found‚Äù errors.</p>

<p>The lack of full type inference for tagless-final programs makes writing them an exercise in discipline and self-control, and raises the knowledge and skill barrier for becoming proficient in writing programs in this style.</p>



<h3><strong>Fake Parametric Guarantees</strong></h3>
</div>

<div>
<p>An often-touted benefit of tagless-final is that it provides us with<em>&nbsp;parametric reasoning</em>.</p>

<p>This claim is not without merit. For example, if we look at the following method signature, we should be able to tell from its type that it works with any effect that provides '<strong>Monad</strong>', and is therefore free of effects (it may only use&nbsp;Monad&nbsp;operations, such as '<strong>map</strong>', '<strong>flatMap</strong>', and '<strong>ap</strong>'):</p>

<pre><code>def innocent[F[_]: Monad]: F[Unit] = ???</code></pre>

<p>However, since Scala does not restrict procedural effects, this means that we can embed them anywhere, even in supposedly pure code like this:</p>

<pre><code>def innocent[F[_]: Monad]: F[Unit] = {
  println("What guarantees?")

  Monad[F].point(())
}</code></pre>

<p>Worse still, it is trivial to write a helper method that can embed&nbsp;<em>any&nbsp;</em>effect into any '<strong>Applicative</strong>', even an '<strong>Applicative</strong>' with a strict (non-lazy) version of '<strong>point</strong>':</p>

<pre><code>def effect[F[_]: Applicative](a: =&gt; A): F[A] = 
  Applicative[F].point(()).map(_ =&gt; a)</code></pre>

<p>The '<strong>effect</strong>' helper method itself violates neither Scalazzi (the pure functional subset of Scala), nor any '<strong>Applicative</strong>' laws.</p>

<p>We may use this helper method to further contaminate the original definition of '<strong>innocent</strong>':</p>

<pre><code>def innocent[F[_]: Monad]: F[Unit] = {
  println("What guarantees?")

  effect(System.exit(42))
}</code></pre>

<p>We‚Äôve now trivially embedding a raw effect, which will be executed before the creation of '<strong>F[Unit]</strong>', and an effect inside the '<strong>Applicative</strong>'.</p>

<p>In a large code base, whatever&nbsp;<em>can&nbsp;</em>happen,&nbsp;<em>will&nbsp;</em>happen.</p>

<p>As a testament to this fact, it is common practice among new users of effect systems to accidentally embed effects inside the functions they pass to '<strong>map</strong>' and '<strong>flatMap</strong>' (in fact, some effect monads&nbsp;<em>encourage&nbsp;</em>this anti-pattern), as well as embed effects inside lazy versions of the '<strong>Monad</strong>' '<strong>point</strong>' operation.</p>

<p>The benefits of&nbsp;<em>parametric reasoning</em>&nbsp;do apply to tagless-final programs, but only&nbsp;<em>up to discipline</em>. Yet, a lot of other techniques with fewer drawbacks&nbsp;also provide reasoning benefits&nbsp;<em>up to discipline.</em></p>



<h3><strong>Summary of Tagless-Final</strong></h3>

<div>
<p>Tagless-final does have benefits and experienced functional programmers have deployed many production-worthy applications using the technique.</p>

<p>However, looking at all these drawbacks, it‚Äôs hard to recommend tagless-final for most Scala shops.</p>

<p>In my opinion, the technique will never go mainstream, and because of all the machinery and ceremony involved, encouraging tagless-final may push more people away from functional programming in Scala than it lures in.</p>

<p>As I have long argued, some techniques that work well in other programming languages (like monad transformers in Haskell), simply don‚Äôt work well in Scala. We can‚Äôt make them work, and nor do we need to, because we can find other techniques that give us similar benefits without the costs.</p>

<p>In the next section, I present one such technique that I believe is exceptionally well-suited for Scala.</p>



<h3><strong>Discarding the Extraneous</strong></h3>

<div>
<p>If testability is our primary concern, then it‚Äôs possible we can take a page from Java. If we want to write testable code in Java, then we use interfaces, and we provide different implementations for live and test scenarios.</p>

<p>In the case of our preceding example, we can create a simple Scala trait to represent console capabilities:</p>

<pre><code>trait Console {
  def putStrLn(line: String): IO[Unit]

  val getStrLn: IO[Unit]
}</code></pre>

<p>This is just an ordinary interface. The only difference is that the methods return functional effects. They don‚Äôt actually&nbsp;<em>do,</em> they only&nbsp;<em>describe</em>.</p>

<p>It‚Äôs easy to teach this to Scala developers, because they probably have used interfaces in Scala and whatever programming languages they knew before Scala.</p>

<p>Now our program, which requires console capabilities, can simply accept '<strong>Console</strong>' as a parameter:</p>

<pre><code>def program(c: Console): IO[Unit] = 
  for {
    _    &lt;- c.println("Good morning, " +
                      "What is your name?")
    name &lt;- c.readLine
    _    &lt;- c.println(s"Good to meet you, $name!")
  } yield ()</code></pre>

<p>We can provide either test or production instances of '<strong>Console</strong>', ensuring we can reliably test our program.</p>

<p>This technique works reasonably well for tiny programs, but most programs will require more than one service. If you try to scale this technique up, it becomes quite unpleasant:</p>

<pre><code>def program(s1: Service1, s2: Service2,
            s3: Service3, ‚Ä¶ sn: ServiceN) =
  for {
    a &lt;- foo(s1, s9, s3)("localhost", 42)
    b &lt;- bar(sn, s19, s3)(a, 1024)
    ...
 } yield z</code></pre>

<p>The pain results from us having to thread '<strong>n</strong>' services into our methods, and then manually pass subsets of these services into all of the methods that we call.</p>

<p>Indeed, this is the pain that&nbsp;<em>dependency injection</em>&nbsp;was invented to solve. It should not be surprising if we take a more object-oriented approach to solving the testability problem, we will end up in dependency injection territory.</p>

<p>Fortunately, using the&nbsp;<em>module pattern</em>, we can at least make steps toward something usable.</p>



<h3><strong>The Module Pattern</strong></h3>
</div>

<div>
<p>The module pattern involves placing our services inside a module trait to provide easier composition. Sometimes this pattern can be identified by the '<strong>HasXYZ</strong>' naming convention‚Äîfor example, '<strong>HasConsole</strong>'.</p>

<p>To use this pattern, you first define a module, which contains a single field with the appropriate service type:</p>

<pre><code>trait HasConsole {
  def console: ConsoleService
}</code></pre>

<p>Then you define the service type as normal:</p>

<pre><code>trait ConsoleService {
  def putStrLn(line: String): IO[Unit]

  val getStrLn: IO[Unit]
}</code></pre>

<p>Now personally, to avoid extraneous typing, I prefer to choose a simplified naming convention and organizational style: I use a shortname for the module, and put the service definition inside the companion object of the module.</p>

<p>For example:</p>

<pre><code>trait Console {
  def console: Console.Service
}
object Console {
  trait Service {
    def putStrLn(line: String): IO[Unit]

    val getStrLn: IO[Unit]
  }
}</code></pre>

<p>In any case, with the module pattern, we are now able to take advantage of<em>&nbsp;intersection types</em>&nbsp;to compose multiple modules into a single module.</p>



<h3><strong>Module Composition</strong></h3>
</div>

<div>
<p>Scala 3 has first-class support for intersection types. But in the meantime, we can use the '<strong>with</strong>'&nbsp;operator, which provides pseudo-intersection types.</p>

<p>The '<strong>with</strong>'&nbsp;operator enables us to create a type that must satisfy multiple requirements. In our case, we can use it to create a module that contains many services.</p>

<pre><code>def program(s: Module1 with Module2 ... with ModuleN) =
  for {
    a &lt;- foo(s)("localhost", 42)
    b &lt;- bar(s)(a, 1024)
    ...
  } yield z</code></pre>

<p>Notice the&nbsp;<em>dramatic&nbsp;</em>reduction in the amount of work necessary to thread services throughout our application.</p>

<p>Our method now takes a single service parameter, which, using intersection types, bundles together all of its module dependencies into a single module.</p>

<p>Further, when we pass service dependencies down the stack, we can simply pass the bundle, because due to Scala‚Äôs support for subtyping, we are free to pass methods&nbsp;<em>more&nbsp;</em>than they require (this is called&nbsp;<em>contravariance</em>).</p>

<p>While a satisfying improvement over the predecessor, there‚Äôs still the painful passing of a single parameter all the way from the top of our application to the bottom.</p>

<p>Fortunately, functional programming provides an extremely simple and elegant solution to this problem.</p>



<h3><strong>The Reader Monad</strong></h3>
</div>

<div>
<p>The '<strong>Reader</strong>' monad is a monadic data structure that can be used to automated passing an environment from one level in the application down to lower levels.</p>

<p>Every level of the application has access to the environment, and they can even do local modifications (the environment can vary at each level of the application, if so desired).</p>

<p>The '<strong>Reader</strong>' monad is explained elsewhere, so I won‚Äôt go into depth on how it works, but I‚Äôll present a simple reference implementation:</p>

<pre><code>case class Reader[-R, +A](provide: R =&gt; A) { self =&gt;
  def map[B](f: A =&gt; B) = flatMap(a =&gt; Reader.point(f(a)))
  def flatMap[R1 &lt;: R, B](f: A =&gt; Reader[R1, B]) =
    Reader[R, B](r =&gt; f(self.provide(r)).provide(r))
}
object Reader {
  def point[A](a: =&gt; A): Reader[Any, A] = Reader(_ =&gt; a)
  def environment[R]: Reader[R, R] = Reader(identity)
  def access[R, A](f: R =&gt; A): Reader[R, A] = 
    environment[R].map(f)
}</code></pre>

<p>A '<strong>Reader[R, A]</strong>' is an effect that requires environment '<strong>R</strong>' and produces a value of type '<strong>A</strong>'.</p>

<p>So, for example, a '<strong>Reader[Config, String]</strong>' is an effect that requires a '<strong>Config</strong>' and produces a value of type '<strong>String</strong>'. To extract the '<strong>String</strong>' from the '<strong>Reader</strong>', you first have to&nbsp;<em>provide&nbsp;</em>the '<strong>Config</strong>' that it requires:</p>

<pre><code>case class Config(serverName: String, port: Int)

val serverName: Reader[Config, String] = 
  Reader.access[Config](_.serverName)

val name = serverName.provide(Config("localhost", 43))</code></pre>

<p>Now a '<strong>Reader[Any, A]</strong>' means that the effect can work with&nbsp;anyenvironment. This is equivalent to saying it requires&nbsp;no&nbsp;environment. You can extract values from these type of effects by supplying any value at all (for example, unit):</p>

<pre><code>val tempFile: Reader[Any, String] = 
  Reader.point("/tmp/tempfile.dat")

val file = tempFile.provide(())</code></pre>

<p>Note that the '<strong>Reader</strong>' definition above only models&nbsp;<em>reader&nbsp;</em>effects, not effects like input / output, which were modeled by our previous '<strong>IO</strong>' data type.</p>

<p>However, if we ignore that fact, then if one squints hard enough, one can see a path forward to a final simplification of the module pattern, which uses the '<strong>Reader</strong>' monad to pass modules:</p>

<pre><code>def program: Reader[Module1 with ... with ModuleN, String] =
  for {
    a &lt;- foo("localhost", 42)
    b &lt;- bar(a, 1024)
    ...
  } yield z</code></pre>

<p>This step is not so far away. There is a '<strong>Reader</strong>' monad transformer that can add the reader effect to any base monad, including the '<strong>IO</strong>' monad. However, not only are monad transformers very slow in Scala (adding 2-4x overhead per layer), but they have clumsy ergonomics and bad type inference.</p>

<p>So instead, using a technique called&nbsp;effect rotation, we can bake the reader effect into the base effect monad, yielding a data type that is high-performance, and, if we are&nbsp;<em>very thoughtful</em>&nbsp;in the design of the data type, opening the door to&nbsp;<em>delightful&nbsp;</em>ergonomics and&nbsp;<em>flawless&nbsp;</em>type inference.</p>

<p>This is the approach taken by<em>&nbsp;ZIO Environment</em>, a new feature in ZIO and quite possibly the most defining feature of the impending 1.0 release of the ZIO library.</p>



<h3><strong>ZIO Environment</strong></h3>
</div>

<div>
<p>ZIO Environment uses a functional effect data type with three type parameters:</p>

<pre><code>ZIO[R, E, A]</code></pre>

<p>The interpretation of these type parameters is as follows:</p>

<ul>
	<li>'<strong>R</strong>'‚ÄîThis is the type of the environment required to run the effect, which can range from a bundle of modules, to just some configuration details, to '<strong>Any</strong>' (indicating no requirement).</li>
	<li>'<strong>E</strong>'‚ÄîThis is the type of error the effect may fail with, which can range from '<strong>Throwable</strong>', to a custom data type (which may or may not extend '<strong>Throwable</strong>' / '<strong>Exception</strong>'), to '<strong>Nothing</strong>' (indicating the effect cannot fail).</li>
	<li>'<strong>A</strong>'‚ÄîThis is the type of value the effect may succeed with, which can be anything, but if the effect runs forever (or runs until error), it could also be '<strong>Nothing</strong>'.</li>
</ul>

<div>
<p>Not everyone may be comfortable using the full ZIO data type, so the library defines three type synonyms for common cases:</p>

<pre><code>type UIO[+A] = ZIO[Any, Nothing, A]
type Task[+A] = ZIO[Any, Throwable, A]
type IO[+E, +A] = ZIO[Any, E, A]</code></pre>

<p>The meaning of these types is as follows:</p>

<ul>
	<li>'<strong>UIO</strong>'‚ÄîUnexceptional effect, which doesn‚Äôt require any specific environment and cannot fail.</li>
	<li>'<strong>Task</strong>'‚ÄîAn effect that doesn‚Äôt require any specific environment and can fail with any '<strong>Throwable</strong>'.</li>
	<li>'<strong>IO</strong>'‚ÄîAn effect that can fail with an '<strong>E</strong>'.</li>
</ul>

<div>
<p>All of these type aliases have companion objects, which can be used to construct values of these types. For example, <strong>'Task.succeed(42)</strong>' constructs a '<strong>Task[Int]</strong>', which of course is really a '<strong>ZIO[Any, Throwable, Int]</strong>'.</p>

<p>This hierarchy of power allows users to start with '<strong>Task</strong>' and possibly '<strong>UIO</strong>'(any type they handle errors, they‚Äôll get something that has type '<strong>UIO</strong>'), and then gradually migrate to either '<strong>IO</strong>' or '<strong>ZIO</strong>', or maybe their own type alias that uses offers a combination of types suited to their application.</p>

<p>In this post, I won‚Äôt talk about the '<strong>E</strong>' and '<strong>A</strong>' parameters, since you can find&nbsp;<a href="http://degoes.net/articles/bifunctor-io">previous material</a>&nbsp;on these, and&nbsp;<a href="https://github.com/scalaz/scalaz-zio">ZIO itself</a>, including Scaladoc and the microsite, have extensive documentation on failure and success values.</p>

<p>Rather, I‚Äôll focus on a few methods that help you use the new '<strong>R</strong>' type parameter, and then we‚Äôll take a look at how we can use these methods to solve the testability problem.</p>



<h3><strong>Core Environment</strong></h3>
</div>

<div>
<p>ZIO Environment just adds two new primitive functions (and then a couple helpers based on these):</p>

<pre><code>sealed trait ZIO[-R, +E, +A] {
  ...
  def provide(environment: R): ZIO[Any, E, A] = ...
  ...
}
object ZIO {
  ...
  def accessM[R, E, A](f: R =&gt; ZIO[R, E, A]): ZIO[R, E, A] =  
    ...
  def access[R, E, A](f: R =&gt; A): ZIO[R, Nothing, A] =
    accessM(ZIO.succeed(_))
  def environment[R]: ZIO[R, Nothing, R] = access(identity)
}</code></pre>

<p>The core functions are '<strong>ZIO#provide</strong>', which allows you to ‚Äúfeed‚Äù an '<strong>R</strong>' to an effect that requires an '<strong>R</strong>', to eliminate its requirement; by changing the environment type parameter to '<strong>Any</strong>'); and '<strong>ZIO.accessM</strong>', which allows you to effectfully access part of the environment.</p>

<p>Just like a function whose input requires '<strong>Any</strong>' can be fed anything (including '<strong>()</strong>'), and which therefore has no requirements, an effect whose environment is '<strong>Any</strong>' has no requirements (this is different than '<strong>ZIO[Unit, E, A]'</strong>, which is a type indicating the effect requires the '<strong>Unit</strong>' value).</p>

<p>The helper functions are '<strong>ZIO.access</strong>', which allows you to (non-effectfully) access part of the environment, and '<strong>ZIO.environment</strong>', which gives you the whole environment.</p>

<p>To really understand how the core methods can help us solve the testability problem, let‚Äôs revisit the console example, this time using ZIO Environment.</p>



<h3><strong>Console Environment</strong></h3>

<div>
<p>To make our console program testable, we‚Äôre going to start out defining a module and associated service class. We‚Äôve seen these before, and there are no substantial changes this time around:</p>

<pre><code>import scalaz.zio._

trait Console { def console: Console.Service }
object Console {
  trait Service {
    def println(line: String): UIO[Unit]
    val readLine: IO[IOException, String]
  }
  trait Live extends Console.Service {
    import scala.io.StdIn.readLine

    def println(line: String) = 
      UIO.effectTotal(scala.io.StdIn.println(line))
    val readLine = 
      IO.effect(readLine()).refineOrDie(JustIOExceptions)
  }
  object Live extends Live
}</code></pre>

<p>Note that in the console service, the '<strong>println</strong>'&nbsp;function returns a '<strong>UIO[Unit]</strong>' (because it cannot fail), while the '<strong>readLine</strong>' function returns an '<strong>IO[IOException, String]</strong>', because it might fail because of an '<strong>IOException</strong>'.</p>

<p>If you wanted to be less precise, but also eliminate the need to think about the types, you could just use '<strong>Task</strong>' everywhere, which is more familiar to Scala developers who have used '<strong>Future</strong>' and don‚Äôt yet think about typed errors.</p>

<p>The '<strong>Console</strong>' companion object holds an implementation of the '<strong>Live</strong>' version, while a test implementation of the '<strong>Console</strong><strong>.Service</strong>'&nbsp;interface could live inside a test package.</p>

<p>Notice how there are no polymorphic types, no higher-kinded types, no type classes, no type class instances, no implicits, and no monads. This is literally just an interface and implementation, where the methods return functional effects.</p>

<p>The next step is to define a few helper functions, to make using the module easier. This step isn‚Äôt necessary, but it‚Äôs convenient, so I‚Äôll show the technique:</p>

<pre><code>package object console {
  def println(line: String): ZIO[Console, Nothing, Unit] =
    ZIO.accessM(_.console println line)

  val readLine: ZIO[Console, IOException, String] =
    ZIO.accessM(_.console.readLine)
}</code></pre>

<p>This package object, which I called '<strong>console</strong>', defines '<strong>println</strong>'&nbsp;and '<strong>readLine</strong>' functions that return functional effects. These functional effects are defined by using '<strong>ZIO.accessM</strong>', which gives us access to any set of modules we want. In this case, we just need the '<strong>Console</strong>' module, which is reflected in the return types.</p>

<p>Using these helper functions, we can now build our purely functional ZIO program:</p>

<pre><code>import console._

val program: ZIO[Console, IOException, String] =
  for {
    _    &lt;- println("Good morning, what is your name?")
    name &lt;- readLine
    _    &lt;- println(s"Good to meet you, $name!")
  } yield name</code></pre>

<p>Again notice the simplicy of this definition. Without any of the final tagless machinery, a basic understanding of functional effects and '<strong>for</strong>' comprehensions is all that‚Äôs necessary to write code like this.</p>

<p>Now when we need to unsafely interpret this data structure into the effect that it represents, we will generally first provide its required environment using the '<strong>ZIO#provide</strong>' method. Since this effect only requires '<strong>Console</strong>', and since we have already written an implementation in '<strong>Console</strong><strong>.Live</strong>', we can easily provide our program its production environment:</p>

<pre><code>val programLive: IO[IOException, String] = 
  program.provide(Console.Live)</code></pre>

<p>Notice the use of the type synonym '<strong>IO[IOException, String]</strong>', which of course expands to '<strong>ZIO[Any, IOException, String]</strong>', indicating our effect no longer requires any specific environment.</p>

<p>We‚Äôre now ready to run our program, which we can do with the default runtime system in ZIO:</p>

<pre><code>DefaultRuntime.unsafeRun(programLive)</code></pre>

<p>It‚Äôs nearly as easy to test our program. All we have to do is construct an implementation of the '<strong>Console</strong><strong>.Service</strong>' interface for testing:</p>

<pre><code>object TestConsole extends Console {
  val console: Console.Service = ...
}</code></pre>

<p>Now we can run the same program using our test service:</p>

<pre><code>val programTest = program.provide(TestConsole)
DefaultRuntime.unsafeRun(programTest)</code></pre>

<p>That‚Äôs all there is to ZIO Environment! With just two primitives ('<strong>provide</strong>' and '<strong>accessM</strong>'), and an additional type parameter, we‚Äôre able to completely solve the testability problem in a way that requires only a tiny fraction of the knowledge and skills of tagless-final.</p>

<p>But it gets even better than this!</p>



<h3><strong>Delightful Functional Effects</strong></h3>
</div>

<div>
<p>Tagless-final had a number of drawbacks beyond just a massive ramp up curve. In the next few sections, we‚Äôll look at how ZIO Environment stacks up against tagless-final.</p>



<h3><strong>Composable</strong></h3>

<div>
<p>Like tagless-final, ZIO Environment is composable: we can compose requirements horizontally, using the '<strong>with</strong>'&nbsp;operator for type intersection:</p>

<pre><code>trait Console { def console: Console.Service }
trait Logging { def logging: Logging.Service }
trait Persistence { def persistence: Persistence.Service }
...

val program: ZIO[Console with Logging with Persistence,
                 ProgramError, Unit] = ...</code></pre>



<h3><strong>Performant</strong></h3>

<div>
<p>Like tagless-final, but to an even greater extent (because all ZIO methods are monomorphic), ZIO Environment is high-performance.</p>

<p>If you tried to emulate the ZIO Environment technique in another effect type, using the '<strong>ReaderT</strong>' monad transformer, then you would suffer as much as a 4x performance penalty. If you tried to emulate both ZIO Typed Errors as well, using an '<strong>EitherT</strong>' monad transformer, you could suffer as much as an 8x performance penalty.</p>

<p>Thanks to effect rotation, ZIO gives you the benefits of the reader and either monad transformers, without any of the cost, and with far better ergonomics and type inference.</p>



<h3><strong>Fully Inferable</strong></h3>

<div>
<p>As an experienced functional programmer who has used and generally likes tagless-final, I personally find one of the most compelling benefits of ZIO Environment to be&nbsp;<em>type</em><em> inference.</em></p>

<p>Thanks to a careful design and appropriate use of variance, ZIO is fully inferable (!). In fact, as far as I‚Äôm aware, it‚Äôs the&nbsp;only&nbsp;approach to testable functional effects in Scala that‚Äôs demonstrated to be fully inferable.</p>

<p>This means if you use many different modules, you can call functions from all the modules, and the Scala compiler will infer the proper environment.</p>

<p>As an example:</p>

<pre><code>val program =
  for {
    _    &lt;- putStrLn("Good morning, what is your name?")
    name &lt;- getStrLn
    _    &lt;- savePreferences(name)
    _    &lt;- log.debug("Saved $name to configuration")
    _    &lt;- putStrLn(s"Good to meet you, $name!")
  } yield ()</code></pre>

<p>In this case, Scala will infer the environment to be 'Console with Persistence with Logging'.</p>

<p>Not only can Scala infer the type, but if you give an explicit type annotation, but it‚Äôs incorrect, the hints that Scala provides will eventually lead you to the correct type signature.</p>

<p>Even if you believe in providing top-level type signatures, being able to infer local signatures, have your IDE insert the top-level signatures, or just ask Scala for the corret type (by intentionally inserting the wrong type) is a tremendous benefit to productivity and makes working with ZIO effects an extremely pleasant experience.</p>



<h3><strong>Concise</strong></h3>

<div>
<p>With full inference, ZIO can be extremely concise. However, inference is actually not necessary for concision.</p>

<p>Because ZIO Environment uses a type parameter, and because Scala has type aliases, this means we can eliminate all duplication in method signatures:</p>

<pre><code>trait Console { def console: Console.Service }
trait Logging { def logging: Logging.Service }
trait Persistence { def persistence: Persistence.Service }
...

type ProgramEnv = Console with Logging with Persistence

val program1: ZIO[ProgramEnv, AppError, Unit] = ...

val program2: ZIO[ProgramEnv, AppError, String] = ...</code></pre>

<p>In fact, if we want to create a custom effect type, with our own environment and error type, it‚Äôs easy to do that too:</p>

<pre><code>type Program[A] = ZIO[Console with Logging with Persistence, 
                      AppError, A]

val program1: Program[Unit] = ...
val program2: Program[String] = ... </code></pre>

<p>Type synonyms like this, especially when combined with associated companion objects, can make it possible for beginners to rapidly become productive in a large code base. Further, they enable beginners and experts alike to avoid repeating themselves, which makes code maintenance easier, less costly, and more predictable.</p>



<h3><strong>Modular</strong></h3>

<div>
<p>With ZIO Environment, there is no need to build up a monolothic environment. Rather, individual layers of the application can supply local environments to lower layers.</p>

<p>An example of this technique is shown below:</p>

<pre><code>def fn1: ZIO[R1, E, A] = {
  def fn2: ZIO[R2, E, B] = ...

  val localEnvironment: R2 = ...
  val v1 = fn2.provide(localEnvironment)
  ...
}
val globalEnvironment: R1 = ...
val v2 = fn1.provide(globalEnvironment)
...</code></pre>

<p>This is only one technique to provide vertical modularity. Over time, other techniques may emerge.</p>

<p>Achieving modularity with tagless-final is possible, but quite difficult and hacky, relying on creating local type class instances. In comparison, modularity is something that other approaches like '<strong>Free</strong>' and MTL excel at.</p>



<h3><strong>Incremental</strong></h3>
</div>

<div>
<p>Unlike tagless-final, a code base that uses no abstraction, which is merely using some base functional effect like '<strong>Task</strong>', can be modified every-so-slightly to allow testability of something deep in the stack.</p>

<p>For example, let‚Äôs say we have a database call deeply embedded everywhere inside our program:</p>

<pre><code>// Deeply nested code:
def myCode: Task[Unit] = ‚Ä¶
  for {
    ...
    result &lt;- database.query(q)
    ...
  } yield ()</code></pre>

<p>We would like to be able to test application logic without connecting to a real database, because that will slow our tests down and may fail for unrelated reasons.</p>

<p>In order to do this, we need merely refactor the '<strong>database.query</strong>'&nbsp;function to require a '<strong>Database</strong>' module. Then with simple introduction of a type synonym, we can leave the code unchanged:</p>

<pre><code>type TaskDB[A] = ZIO[Database, Throwable, A]
...
def myCodeV2: TaskDB[Unit] = ‚Ä¶
  for {
    ...
    result &lt;- database.query(q)
    ...
  } yield ()</code></pre>

<p>All of the other code can stay exactly the same as it is. The only change we needed to make was the type synonym (which we could have called '<strong>Task</strong>', if we didn‚Äôt want to update the type signatures at all), and the single method we wanted to make testable.</p>

<p>In an ideal world, everything would always be 100% testable; and if we needed to make legacy code testable, we would have the resources necessary to make&nbsp;<em>all&nbsp;</em>the effects testable.</p>

<p>Yet in the real world, we often don‚Äôt have the time or luxury of making our greenfield code&nbsp;<em>fully&nbsp;</em>testable from day one;&nbsp;or&nbsp;of doing giant refactorings to legacy code.</p>

<p>ZIO Environment lets us make&nbsp;<em>pinpoint&nbsp;</em>changes, and pay for&nbsp;only&nbsp;the cost of testing what we&nbsp;<em>need&nbsp;</em>to test today. As a result, it helps us deal with real world code bases and meet the needs of the business.</p>



<h3><strong>Summary</strong></h3>
</div>

<div>
<p>Functional effects can be enormously beneficial to solving modern business problems. Yet as we‚Äôve seen in this approach, because of the way functional effects are implemented, we don‚Äôt gain all the beneifts of pure functional code.</p>

<p>While functional effects give us the ability to abstract over our programs and to refactor them without changing their meaning, we can‚Äôt easily test functional effects, because we don‚Äôt have a way to compare two effects for equality.</p>

<p>Solutions like tagless-final help us re-introduce testability into our functional applications (along with other benefits, like parametric reasoning). However, they come with a massive ramp up curve, they don‚Äôt integrate well into Scala, and their ergonomics, boilerplate, and ceremony can be unpleasant and further alienating to developers.</p>

<p>The new approach pioneered in ZIO Environment allows us to regain testability, but without any additional ramp up time(beyond the ramp up required for functional effects). It‚Äôs friendly to beginning functional programmers, and unlike tagless-final, the new approach is fully inferable, modular, and can be used incrementally, just where we need it.</p>

<p>For the first time, it feels like Scala has an idiomatic solution for testable functional effects. Something that‚Äôs fast, fully inferable, with a low barrier to entry.</p>

<p>If you‚Äôd like to give it a try, head over to the&nbsp;<a href="https://github.com/scalaz/scalaz-zio">ZIO project page</a>, where you will find the&nbsp;<a href="https://scalaz.github.io/scalaz-zio/">ZIO microsite</a> and the&nbsp;<a href="https://gitter.im/scalaz/scalaz-zio">Gitter chatroom</a>.</p>

<p>As of today, the first release candidate (RC) for ZIO 1.0 has been published, which means a (nearly) stable API and a focus on documentation, polish, and performance. It‚Äôs my hope that ZIO 1.0 will be released sometime in March, and that the 1.x line will enjoy at least a full year of backward-compatible tweaks, fine-tunings, and enhancements to the microsite.</p>

<p>If you‚Äôre still using '<strong>Future</strong>' and on the fence about a functional effect system, now‚Äôs the perfect time to jump in and give ZIO (or one of the other functional effect systems) a try. You might just find you can‚Äôt live without one!</p>

<p>P.S.&nbsp;A huge thanks to&nbsp;<a href="https://twitter.com/wiemzin">Wiem Zine Elabidine</a>&nbsp;for her work on ZIO Environment, and to&nbsp;<a href="https://twitter.com/itrvd">Itamar Ravid</a>,&nbsp;<a href="https://twitter.com/regiskuckaertz">Regis Kuckaertz</a>, and&nbsp;<a href="https://twitter.com/kaidaxofficial">Kai&nbsp;</a>for their early feedback on the ZIO Environment project, and to&nbsp;<a href="https://twitter.com/skillsmatter">SkillsMatter</a>&nbsp;for the opportunity to present this work at Scala Matters, London.'</p>





<p><small>This article was written by <a href="https://twitter.com/jdegoes?lang=en">John De Goes</a> and posted originally on&nbsp;<a href="http://degoes.net/articles/zio-environment">degoes.net</a></small></p>
</div>
</div>
</div>
</div>


</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>

			
    


	

		</div>
		
	</div>
</div>
</section>
		
	</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>