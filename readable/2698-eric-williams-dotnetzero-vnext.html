<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Eric Williams - DotNetZero vNext -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Eric Williams - DotNetZero vNext</h1><div><div class="all_external_links"><p>I've been working on a new version of <a href="https://dotnetzero.com">dotnetzero</a> (formerly psakezero). This v2 version has a number of changes that were fun to build.</p><p><img alt="Silvrback blog image" class="sb_float_center" src="https://silvrback.s3.amazonaws.com/uploads/c192a7e1-f464-4f9e-a0a3-1f57fb7d8262/dotnetzero01.png"></p><h3 id="large-refactoring-into-smaller-powershell-functions">Large refactoring into smaller PowerShell functions</h3><p>I'm trying out an approach that takes each PowerShell function and places them into their own file. This was for a couple of reasons. One was forcing me to start to remove some of the global state from the 'application' and two their are functions that are useful, to me, in other areas and I wanted to be able to easily access them.</p><blockquote><p>The old PsakeZero version just wasn't setup very well. It was a bit paradoxical in that it had a monolith script and with a number of HTTP Uris where other data persisted. You don't have to read ahead to see that there would be a barrage of HTTP requests fired off when it executed.</p></blockquote><p>With a directory structure full of scripts I still waned the end result to be a single script. I created a highly meta 'build script' which spins through the appropriate directories and 'compiles' them into the 'application' that is served up to the end user.</p><h3 id="embedded-content">Embedded Content</h3><p>One of the user selected options is to install Psake for the task runner. Psake is built on and uses PowerShell which means I have a need to create or lay down some PowerShell for the user in some scenarios. I wanted to keep the source of these content slugs in PowerShell so the next person (read-as: me) had a chance of 'seeing' the intent without having to visually un-escape everything while reading. I think that if I tried to have the build script escape all the content I would have run into edge cases that the escapinator would have missed so I opted for a bit of a nuclear option.</p><p>Again using the build process I take those selected embedded content directories and encode the file content so that in no way that it could be interpreted by PowerShell as valid executable script or commands which would cause problems at run time for dotnetzero.</p><p><em>Here is an example those compression functions being used</em></p><div class="highlight"><pre><span></span>»  $functionContent = Get-Content -Raw .\New-Directory.ps1
»  $compressedFunction = $functionContent | Compress-String
»  Write-Host $compressedFunction
H4sIAAAAAAAEAEsrzUsuyczPU/BLLdd1ySxKTS7JL6pUqOblUgCCaOfclJzUEqfMvJTMvHQNzViIcEFiUWKuggaEAwIqBYklGRCuJoQCGedZkpqroOuWX5ScqgDmhFQWpCogLNENAOqC6FWoUfAvLdH1K83J4eWq5eUCACei7sKXAAAA
»  ($compressedFunction | Expand-String) -eq $functionContent
True
»  $compressedFunction | Expand-String
function New-Directory {
    [CmdletBinding()]
    param (
        $path
    )
    New-Item -Force -ItemType Directory -Path $path | Out-Null
}
</pre></div><p>And the sample implementation</p><h3 id="wraps-up-dotnet-new-for-adding-projects-to-the-source-tree">Wraps up dotnet new for adding projects to the source tree</h3><p>One of the things that the old version did not do was give the user a starting point for new .NET projects. Part of this was because the dotnet templating feature wasn't around yet and I wasn't about to implement some convoluted clone repo strategy - I don't care for the approach for starting projects. Now that we have the dotnet cli template feature I wanted to at least wrap up the list template information of <code>dotnet new</code> so that the user would have a jumping off point to get some source code projects stubbed out for their repo.</p><p>If you have the dotnet cli installed you can run <code>dotnet new --list</code> which will display the installed templates on the machine. <em>Below is a sample</em></p><div class="highlight"><pre><span></span>Templates                          Short Name  Language     Tags
-------------------------------------------------------------------------------
Console Application                console     [C#], F#, VB Common/Console
Class library                      classlib    [C#], F#, VB Common/Library
Unit Test Project                  mstest      [C#], F#, VB Test/MSTest
xUnit Test Project                 xunit       [C#], F#, VB Test/xUnit
ASP.NET Core Empty                 web         [C#], F#     Web/Empty
ASP.NET Core Web App (mvc)         mvc         [C#], F#     Web/MVC     
ASP.NET Core Web App               razor       [C#]         Web/MVC/Razor Pages
ASP.NET Core w/ Angular            angular     [C#]         Web/MVC/SPA
ASP.NET Core w/ React.js           react       [C#]         Web/MVC/SPA
ASP.NET Core w/ React.js and Redux reactredux  [C#]         Web/MVC/SPA
ASP.NET Core Web API               webapi      [C#], F#     Web/WebAPI
global.json file                   globaljson               Config
NuGet Config                       nugetconfig              Config
Web Config                         webconfig                Config
Solution File                      sln                      Solution
Razor Page                         page                     Web/ASP.NET
MVC ViewImports                    viewimports              Web/ASP.NET
MVC ViewStart                      viewstart                Web/ASP.NET
</pre></div><p>This shows you a list of templates you can call with either their full or short name. After some old school parsing I turned them into .NET objects in PowerShell so that I could drive selections via an index id.</p><div class="highlight"><pre><span></span>----------------------------------------------------------------
  Installed dotnet templates
----------------------------------------------------------------
    1 Console Application
    2 Class library
    3 Unit Test Project
    4 xUnit Test Project
    5 ASP.NET Core Empty
    6 ASP.NET Core Web App (mvc)
    7 ASP.NET Core Web App
    8 ASP.NET Core w/ Angular
    9 ASP.NET Core w/ React.js
   10 ASP.NET Core w/ React.js and Redux
   11 ASP.NET Core Web API
   12 global.json file
   13 NuGet Config
   14 Web Config
   15 Solution File
   16 Razor Page
   17 MVC ViewImports
   18 MVC ViewStart
----------------------------------------------------------------

Adding projects to your solution
Select dotnet item # to add to your solution
(blank to quit/finish):
</pre></div><p>This wizard will collect the project type and name add that to a collection to pass onto the New-DotNetSolution function which will then issue all the appropriate commands on the dotnet cli to create your solution.</p><blockquote><p>one of the things I like about this feature is that it will also prompt you to add a test project after each application based template.</p></blockquote><div class="highlight"><pre><span></span>Adding projects to your solution
Select dotnet item # to add to your solution
(blank to quit/finish): 11
ASP.NET Core Web API Name: API
Do you want to add unit test project?
[N] No  [M] mstest  [X] xunit  [?] Help (default is "N"):
</pre></div><p>It also gives you a status section so you can see what you are building with the name and type of project.</p><div class="highlight"><pre><span></span>----------------------------------------------------------------
  2 Selected Project(s)
----------------------------------------------------------------
 - API
   ASP.NET Core Web API
 - API.Tests
   xUnit Test Project
----------------------------------------------------------------

Adding projects to your solution
Select dotnet item # to add to your solution
(blank to quit/finish):
</pre></div><p>If you keep adding application type items to the collection the test question will change to a <em>yes</em> or <em>no</em> since you've already decided on xUnit or one of the other testing frameworks installed in the local template cache.</p><div class="highlight"><pre><span></span>Adding projects to your solution
Select dotnet item # to add to your solution
(blank to quit/finish): 7
ASP.NET Core Web App Name: Web
Do you want to add unit test project?
[N] No  [Y] Yes  [?] Help (default is "Y"):
</pre></div><p>And when you are done you issue a empty item it starts actually building the project. The next item in the pipeline just takes the collection and in the incoming solution name and create your application.</p><p>For the most part this process is fairly straight forward. It creates the solution, creates the projects, adds the projects to the solution, checks for test project names by convention and sets up the connecting references for their respective project, runs the restore, build and when (you going to always add test projects, right?) runs the test command for those.</p><blockquote><p>item of note here is that part of the restore section it will check the directories for a package.json and run <code>npm install</code> in those respective directories. This keeps those those web based projects in a state that will allow them to initially compile as part of this wizard processes.</p></blockquote><p><img alt="Silvrback blog image" class="sb_float_center" src="https://s3-us-west-2.amazonaws.com/motowilliams-blog-media/dotnetzero-vnext/dotnetzero-sample-run-01.gif"></p><h3 id="allows-for-selected-task-runners">Allows for selected task runners</h3><p>Another new feature is the ability to select different task runners for your new project. The default is still Psake but I've also added a basic install of <a href="https://cakebuild.net/">Cake Build</a>. <a href="https://github.com/nightroman/Invoke-Build">Invoke-Build</a> will be added shortly as well.</p><p>All of the runners are tucked behind a <code>run.ps1</code> file that handles all the bootstrapping of the runner and any dependencies they might have. This is a common pattern I use across my projects so that the default build can easily be ran with no args but also specific tasks can be executed that the developers may need for daily work. For examples <code>.\run.ps1 compile-css</code> or <code>.\run.ps1 update-database</code> etc</p><p><img alt="Silvrback blog image" class="sb_float_center" src="https://s3-us-west-2.amazonaws.com/motowilliams-blog-media/dotnetzero-vnext/dotnetzero-sample-run-02.gif"></p><h3 id="hosted-on-azure-functions">Hosted on Azure Functions</h3><p>I think of the best features of dotnetzero is how you can execute it. <code>irm dotnetzero.com | iex</code> or <code>Invoke-RestMethod dotnetzero.com | Invoke-Expression</code> and you are off to the the races. You can also use <code>Invoke-WebRequest</code> or <code>iwr</code> but your machine needs to have gone thought those initial IE runs otherwise you need the <code>-UseBasicParsing</code> flag and that former simple easy to remember command is gone.</p><p>You can also visit <a href="https://dotnetzero.com">https://dotnetzero.com</a> in your browser and you'll see the brochure page I created for the project. The reason this works is a HTTP principle called <a href="https://en.wikipedia.org/wiki/Content_negotiation">Content-Negotiation</a> or conneg for short. This allows the site to serve html when it sees a browser request, serve the PowerShell script when those requests are made as PowerShell send a User-Agent header — Yes I'm a bad person for sniffing the User-Agent. When curl sends a similar request it will send a shell script which is really out of date and under powered at the moment.</p><p>The back end for this is on Azure Functions and Azure Blob Storage. I have Azure Function Proxy sitting in front of this so thatstand alone commands can be requested. The current command list is just one but if you issue a <code>irm dotnetzero.com/dotnetcli | iex</code> you can run just the wizard portion of the application.</p><p>Here is what that looks like</p><div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">"$schema"</span><span class="p">:</span><span class="s2">"http://json.schemastore.org/proxies"</span><span class="p">,</span><span class="nt">"proxies"</span><span class="p">:</span><span class="p">{</span><span class="nt">"appcli"</span><span class="p">:</span><span class="p">{</span><span class="nt">"matchCondition"</span><span class="p">:</span><span class="p">{</span><span class="nt">"route"</span><span class="p">:</span><span class="s2">"/dotnetcli"</span><span class="p">},</span><span class="nt">"backendUri"</span><span class="p">:</span><span class="s2">"https://example.com/api/fullapp"</span><span class="p">,</span><span class="nt">"requestOverrides"</span><span class="p">:</span><span class="p">{</span><span class="nt">"backend.request.method"</span><span class="p">:</span><span class="s2">"get"</span><span class="p">,</span><span class="nt">"backend.request.querystring.clicmd"</span><span class="p">:</span><span class="s2">"Get-DotNetProjects | New-DotNetSolution"</span><span class="p">,</span><span class="nt">"backend.request.querystring.beta"</span><span class="p">:</span><span class="s2">"false"</span><span class="p">}</span><span class="p">},</span><span class="nt">"approot"</span><span class="p">:</span><span class="p">{</span><span class="nt">"matchCondition"</span><span class="p">:</span><span class="p">{</span><span class="nt">"route"</span><span class="p">:</span><span class="s2">"/"</span><span class="p">},</span><span class="nt">"backendUri"</span><span class="p">:</span><span class="s2">"https://example.com/api/fullapp"</span><span class="p">,</span><span class="nt">"requestOverrides"</span><span class="p">:</span><span class="p">{</span><span class="nt">"backend.request.method"</span><span class="p">:</span><span class="s2">"get"</span><span class="p">,</span><span class="nt">"backend.request.querystring.clicmd"</span><span class="p">:</span><span class="s2">"New-SourceTree"</span><span class="p">,</span><span class="nt">"backend.request.querystring.beta"</span><span class="p">:</span><span class="s2">"false"</span><span class="p">}</span><span class="p">}</span><span class="p">}</span><span class="p">}</span></pre></div><p>This is basically converting the route match into additional query string parameters that the Azure Function parses. The default is just to run the <code>New-SourceTree</code> command but when the <code>/dotnetcli</code> is passed to the end the wizard or <code>Get-DotNetProjects | New-DotNetSolution</code> command chain is then used. This is where having all the functions sent down together comes in handy. It allows for PowerShell Command Composition™.</p><p><img alt="Silvrback blog image" class="sb_float_center" src="https://s3-us-west-2.amazonaws.com/motowilliams-blog-media/dotnetzero-vnext/dotnetzero-sample-run-03.gif"></p><p>Feel free to take it for a spin and let me know what you think.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>