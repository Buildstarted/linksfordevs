<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Adding a delay to ASP.NET Core Web API methods to simulate slow or erratic networks -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Adding a delay to ASP.NET Core Web API methods to simulate slow or erratic networks</h1><div><div id="post-4506" class=""><p>I recently commented on a tweet by @jongalloway, saying:</p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">A thousand times this! Run your app with an artificial delay introduced into server responses and look for things that don't make sense. There's a good chance you'll find some things that just plain break because of timing assumptions. Fixing both will be wins for your users <a href="https://t.co/cwVqq3w3Rz">https://t.co/cwVqq3w3Rz</a></p>
â€” Robert Wray (@robertwrayuk) <a href="https://twitter.com/robertwrayuk/status/1107028783473852416?ref_src=twsrc%5Etfw">March 16, 2019</a></blockquote><p>It got me thinking about ways to do this in ASP.NET Core,&nbsp;other than the simple and manual process of whacking a breakpoint at the start of each action and leaving it spinning for a while or adding a delay using a network monitoring tool. The answer I came up with was <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-2.2#action-filters">filters</a>, specifically action filters. According to the documentation:</p><blockquote>Filters in ASP.NET Core MVC allow you to run code before or after specific stages in the request processing pipeline.</blockquote><p>This gave me exactly what I want, a way to run code (specifically some code to introduce a delay) at a specific stage of the request. For the purposes of the exercise the <em>when</em> didn't particularly matter to me, though if you've got server side code that relies on being hit within a specific time-frame, e.g. within a second of the client-side request being initiated, you may need to take this into account.</p><p>The filter I put together actually ended up being pretty simple:</p><p>Filter code:</p><pre>using Microsoft.AspNetCore.Mvc.Filters;
using Microsoft.Extensions.Configuration;
using System.Threading.Tasks;

namespace CoreDelayingTactics.Filters
{
    public class DelayFilter : IAsyncActionFilter
    {
        private int _delayInMs;
        public DelayFilter(IConfiguration configuration)
        {
            _<span>delayInMs = configuration.GetValue&lt;int&gt;("ApiDelayDuration", 0);</span>
        }

        async Task IAsyncActionFilter.OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
        {
            await Task.Delay(_delayInMs);
            await next();
        }
    }
}
</pre><p>There are two things to point out about the&nbsp;filter; firstly, it's not production code and should really have logging&nbsp;(you want&nbsp;something in your logs so you can see when it's&nbsp;active in production, right?), possibly a skip past the call to Task.Delay if the value is 0, validation of the delay value, perhaps even a #if DEBUG so that the call to Task.Delay&nbsp;gets compiled out in release builds. Secondly, it's using Task.Delay instead of the ubiquitous Thread.Sleep. Pretty much everything I've read says that using Thread.Sleep in async code is a bad idea (to be fair it's usually a sign that you're hacking your way round a problem even in non-async code) but Task.Delay is far more palatable. Even in code like this that isn't "production" code it's important to do things the right way so as to ensure that something isn't later taken as a "well, it's done here so it must be fine" example.</p><p>I've used the standard ASP.NET Core template and added the filter by wiring it in through the&nbsp;ConfigureServices method in Startup.cs:</p><pre>public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc(options =&gt;
        {
            options.Filters.Add(typeof(DelayFilter));
        })
        .AddNewtonsoftJson();
}
</pre><p>With that done, the last thing to do is add a setting to<em> appsettings.json</em> so&nbsp;the filter actually introduces a delay:</p><pre>{
  "Logging": {
    "LogLevel": {
      "Default": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*",
  <strong>"ApiDelayDuration":  "5000"</strong>
}
</pre><p>Now to test it, by hitting one of the sample actions that's included in the template (https://localhost:44363/api/values), which shows this result in Fiddler:</p><pre>ACTUAL PERFORMANCE
--------------
ClientConnected:	06:29:08.372
ClientBeginRequest:	06:29:08.449
GotRequestHeaders:	06:29:08.449
ClientDoneRequest:	06:29:08.449
Determine Gateway:	0ms
DNS Lookup: 		0ms
TCP/IP Connect:	0ms
HTTPS Handshake:	0ms
ServerConnected:	06:29:08.409
FiddlerBeginRequest:	06:29:08.449
ServerGotRequest:	06:29:08.450
ServerBeginResponse:	06:29:13.728
GotResponseHeaders:	06:29:13.728
ServerDoneResponse:	06:29:13.793
ClientBeginResponse:	06:29:13.793
ClientDoneResponse:	06:29:13.794

	Overall Elapsed:	<strong>0:00:05.344
</strong></pre><p>That's all there is to it. Hopefully this'll come in handy&nbsp;for you.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>