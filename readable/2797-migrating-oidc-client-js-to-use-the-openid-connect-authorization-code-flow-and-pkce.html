<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Migrating oidc-client-js to use the OpenID Connect Authorization Code Flow and PKCE -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Migrating oidc-client-js to use the OpenID Connect Authorization Code Flow and PKCE</h1><div><div class="col-lg-10" itemprop="articleBody"><p>
Recently, there’s been a bit of a palaver around a <a title="OAuth 2.0 for Browser-Based Apps" href="https://tools.ietf.org/html/draft-parecki-oauth-browser-based-apps-02" target="_blank" rel="noopener">draft specification</a> proposed to the OAuth Working Group and its recommendation of abandoning the implicit flow in browser-based applications, e.g. Single Page Applications (SPAs), in favor of the authorization code flow with Proof-Key for Code Exchange (PKCE).
</p><p>
This article is going to look at how to update the Angular application found in my previous article “<a href="/Angular/SPA-Authentiction-using-OpenID-Connect-Angular-CLI-and-oidc-client" title="SPA Authentication using OpenID Connect, Angular CLI and oidc-client" target="_blank">SPA Authentication using OpenID Connect, Angular CLI and oidc-client</a>”, to start using the authorization code flow and PKCE.
</p><h2>Do I need to panic and abandon the implicit flow?</h2><p>
No.
If you are using OpenID Connect in the way I’ve <a href="/Angular/SPA-Authentiction-using-OpenID-Connect-Angular-CLI-and-oidc-client" title="SPA Authentication using OpenID Connect, Angular CLI and oidc-client" target="_blank">previously detailed</a>, then the only significant benefit this new recommendation gives us is that we completely remove access tokens from the URL.
Since we were using the hash fragment response type, then this was already a pretty slim risk, especially compared with the fact that we store tokens in browser storage.
<strong>This is more of an exercise in hardening than patching a major vulnerability</strong>.
</p><p>For pragmatic advice around the use of the implicit flow, check out:</p><p>I’m sure I’ll write my own ranty article on the subject at some point…</p><h2>Oidc-client-js using the authorization code flow and PKCE</h2><p>
First, you’ll need the latest version of oidc-client:
</p><pre><code class="language-json">"oidc-client": "^1.6.1"</code></pre><p>
You’ll then need to update the <code>UserManagerSettings</code> to something that looks like the following:
</p><pre><code class="language-javascript">export function getClientSettings(): UserManagerSettings {
  return {
    authority: 'http://localhost:5555/',
    client_id: 'angular_spa',
    redirect_uri: 'http://localhost:4200/auth-callback',
    post_logout_redirect_uri: 'http://localhost:4200/',
    response_type: "code",
    scope: "openid profile api1",
    filterProtocolClaims: true,
    loadUserInfo: true
  };
}</code></pre><p>
All that’s changed is that the <code>response_type</code> is now <code>code</code>, meaning we receive an authorization code in return from the authorization endpoint, instead of an identity token and access token.
</p><p>
By setting this response type, two other things change in the background:
</p><ul><li>PKCE starts being used automatically (a code_challenge will be sent in the authorization request and a code_verifier in our new token request)</li><li>
The response mode changes to query, at least when using IdentityServer4.
This means that the authorization code is returned in the query string as opposed to the hash fragment that we typically used with the implicit flow
</li></ul><p>
The use of PKCE gives us validation opportunities within both the authorization server and the client application.
The authorization server can confirm that it is the client application swapping the code for tokens is the same as the client who made the initial request (using PKCE), and the client app can confirm that those tokens were intended in response to its request (using the nonce value).
Where we store the code verifier and nonce values in our client application affects how much benefits this really brings us.
</p><p>
Using the hash fragment as the response mode will further limit the exposure of the authorization code, however, support for this is still being built into IdentityServer4 at time of writing.
</p><h2>IdentityServer4 Configuration for Browser-Based Client Application</h2><p>
IdentityServer4 requires 3 changes: the <code>AllowedGrantTypes</code>, <code>RequirePkce</code>, and <code>RequireClientSecret</code>.
The latter is unnecessary due to the client application still being a public client, and therefore untrustworthy when it comes to client credentials.
</p><p>
This makes our IdentityServer4 client configuration look something like:
</p><pre><code class="language-csharp">new Client {
    ClientId = "angular_spa",
    ClientName = "Angular 4 Client",
    AllowedGrantTypes = GrantTypes.Code,
    RequirePkce = true,
    RequireClientSecret = false,
    AllowedScopes = new List&lt;string&gt; {"openid", "profile", "api1"},
    RedirectUris = new List&lt;string&gt; {"http://localhost:4200/auth-callback", "http://localhost:4200/silent-refresh.html"},
    PostLogoutRedirectUris = new List&lt;string&gt; {"http://localhost:4200/"},
    AllowedCorsOrigins = new List&lt;string&gt; {"http://localhost:4200"},
    AllowAccessTokensViaBrowser = true
}</code></pre><h2>Refreshing Tokens</h2><p>
Silent refresh is still the preferred method for getting new tokens.
In my opinion, refresh tokens are still way too risky to have within a client application running within the context of the browser.
Silent refresh still works using the method detailed in my article “<a href="/OpenID-Connect/Silent-Refresh-Refreshing-Access-Tokens-when-using-the-Implicit-Flow" title="Silent Refresh - Refreshing Access Tokens when using the Implicit Flow" target="_blank">Silent Refresh - Refreshing Access Tokens when using the Implicit Flow</a>”.
</p><p>
Until refresh tokens can be bound to both a client application and that individual session (maybe token binding or mutual TLS?), then I’m sticking with silent refresh.
</p><h2>Source Code <i class="fab fa-github"></i></h2><p>
I’ve updated the <a title="Source Code" href="https://github.com/scottbrady91/Angular4-OidcClientJs-Example" target="_blank" rel="noopener">GitHub repository</a> for my existing article to use authorization code and PKCE.
Migration, as you can see is relatively painless.
You can still access the implicit version on the branch <code>implicit</code>.
</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>