<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Concurrent programming, with examples - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Concurrent programming, with examples - linksfor.dev(s)"/>
    <meta property="og:description" content="Detailed guide to POSIX threads (pthreads) with fun examples"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://begriffs.com/posts/2020-03-23-concurrent-programming.html?hn=1"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Concurrent programming, with examples</title>
<div class="readable">
        <h1>Concurrent programming, with examples</h1>
            <div>Reading time: 62-78 minutes</div>
        <div>Posted here: 24 Mar 2020</div>
        <p><a href="https://begriffs.com/posts/2020-03-23-concurrent-programming.html?hn=1">https://begriffs.com/posts/2020-03-23-concurrent-programming.html?hn=1</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
      

      <div>
        <div>
  

  <div>
    <p>Mention concurrency and you‚Äôre bound to get two kinds of unsolicited advice: first that it‚Äôs a nightmarish problem which will melt your brain, and second that there‚Äôs a magical programming language or niche paradigm which will make all your problems disappear.</p>
<p>We won‚Äôt run to either extreme here. Instead we‚Äôll cover the production workhorses for concurrent software ‚Äì threading and locking ‚Äì and learn about them through a series of interesting programs. By the end of this article you‚Äôll know the terminology and patterns used by POSIX threads (pthreads).</p>
<p>This is an introduction rather than a reference. Plenty of reference material exists for pthreads ‚Äì whole books in fact. I won‚Äôt dwell on all the options of the API, but will briskly give you the big picture. None of the examples contain error handling because it would merely clutter them.</p>
<h3 id="table-of-contents">Table of contents</h3>
<ul>
<li><a href="#concurrency-vs-parallelism">Concurrency vs parallelism</a></li>
<li><a href="#our-first-concurrent-program">Our first concurrent program</a></li>
<li><a href="#data-races">Data races</a></li>
<li><a href="#locks-and-deadlock">Locks and deadlock</a></li>
<li><a href="#condition-variables">Condition variables</a></li>
<li><a href="#other-synchronization-primitives">Other synchronization primitives</a>
<ul>
<li><a href="#barriers">Barriers</a></li>
<li><a href="#spinlocks">Spinlocks</a></li>
<li><a href="#reader-writer-locks">Reader-writer locks</a></li>
<li><a href="#semaphores">Semaphores</a></li>
</ul></li>
<li><a href="#cancellation">Cancellation</a></li>
<li><a href="#development-tools">Development tools</a>
<ul>
<li><a href="#valgrind-drd-and-helgrind">Valgrind DRD and helgrind</a></li>
<li><a href="#clang-threadsanitizer-tsan">Clang ThreadSanitizer (TSan)</a></li>
<li><a href="#mutrace">Mutrace</a></li>
<li><a href="#off-cpu-profiling">Off-CPU profiling</a></li>
<li><a href="#macos-instruments">macOS Instruments</a></li>
<li><a href="#perf-c2c">perf c2c</a></li>
<li><a href="#intel-vtune-profiler">Intel VTune Profiler</a></li>
</ul></li>
<li><a href="#further-reading">Further reading</a></li>
</ul>
<h3 id="concurrency-vs-parallelism">Concurrency vs parallelism</h3>
<p>First it‚Äôs important to distinguish concurrency vs parallelism. <strong>Concurrency</strong> is the ability of parts of a program to work correctly when executed out of order. For instance, imagine tasks A and B. One way to execute them is sequentially, meaning doing all steps for A, then all for B:</p>
<svg width="250" height="50" style="display: block; margin: 0 auto;">
<rect width="120" height="50" style="fill:rgb(0,0,127);stroke-width:1;stroke:rgb(0,0,0)"></rect> <text x="55" y="30" fill="white">A</text> <rect x="130" width="120" height="50" style="fill:rgb(127,0,0);stroke-width:1;stroke:rgb(0,0,0)"></rect> <text x="185" y="30" fill="white">B</text>
</svg>
<p>Concurrent execution, on the other hand, alternates doing a little of each task until both are all complete:</p>
<svg width="250" height="50" style="display: block; margin: 0 auto;">
<rect width="40" height="50" style="fill:rgb(0,0,127);stroke-width:1;stroke:rgb(0,0,0)"></rect> <rect x="50" width="10" height="50" style="fill:rgb(127,0,0);stroke-width:1;stroke:rgb(0,0,0)"></rect> <rect x="70" width="10" height="50" style="fill:rgb(0,0,127);stroke-width:1;stroke:rgb(0,0,0)"></rect> <rect x="90" width="20" height="50" style="fill:rgb(127,0,0);stroke-width:1;stroke:rgb(0,0,0)"></rect> <rect x="120" width="10" height="50" style="fill:rgb(0,0,127);stroke-width:1;stroke:rgb(0,0,0)"></rect> <rect x="140" width="30" height="50" style="fill:rgb(127,0,0);stroke-width:1;stroke:rgb(0,0,0)"></rect> <rect x="180" width="20" height="50" style="fill:rgb(0,0,127);stroke-width:1;stroke:rgb(0,0,0)"></rect> <rect x="210" width="10" height="50" style="fill:rgb(127,0,0);stroke-width:1;stroke:rgb(0,0,0)"></rect> <rect x="230" width="20" height="50" style="fill:rgb(0,0,127);stroke-width:1;stroke:rgb(0,0,0)"></rect>
</svg>
<p>Concurrency allows a program to make progress even when certain parts are blocked. For instance, when one task is waiting for user input, the system can switch to another task and do calculations.</p>
<p>When tasks don‚Äôt just interleave, but run at the same time, that‚Äôs called <strong>parallelism</strong>. Multiple CPU cores can run instructions simultaneously:</p>
<svg width="120" height="110" style="display: block; margin: 0 auto;">
<rect width="120" height="50" style="fill:rgb(0,0,127);stroke-width:1;stroke:rgb(0,0,0)"></rect> <text x="55" y="30" fill="white">A</text> <rect y="55" width="120" height="50" style="fill:rgb(127,0,0);stroke-width:1;stroke:rgb(0,0,0)"></rect> <text x="55" y="85" fill="white">B</text>
</svg>
<p>When a program ‚Äì even without hardware parallelism ‚Äì switches rapidly enough from one task to another, it can feel to the user that tasks are executing at the same time. You could say it provides the ‚Äúillusion of parallelism.‚Äù However, true parallelism has the potential for greater processor throughput for problems that can be broken into independent subtasks. Some ways of dealing with concurrency, such as multi-threaded programming, can exploit hardware parallelism automatically when available.</p>
<p>Some languages (or more accurately, some language implementations) are unable to achieve true multi-threaded parallelism. Ruby MRI and CPython for instance use a global interpreter lock (GIL) to simplify their implementation. The GIL prevents more than one thread from running at once. Programs in these interpreters can benefit from I/O concurrency, but not extra computational power.</p>
<h3 id="our-first-concurrent-program">Our first concurrent program</h3>
<p>Languages and libraries offer different ways to add concurrency to a program. UNIX for instance has a bunch of disjointed mechanisms like signals, asynchronous I/O (AIO), select, poll, and setjmp/longjmp. Using these mechanisms can complicate program structure and make programs harder to read than sequential code.</p>
<p>Threads offer a cleaner and more consistent way to address these motivations. For I/O they‚Äôre usually clearer than polling or callbacks, and for processing they are more efficient than Unix processes.</p>
<h4 id="crazy-bankers">Crazy bankers</h4>
<p>Let‚Äôs get started by adding concurrency to a program to simulate a bunch of crazy bankers sending random amounts of money from one bank account to another. The bankers don‚Äôt communicate with one another, so this is a demonstration of concurrency without synchronization.</p>
<p>Adding concurrency is the easy part. The real work is in making threads wait for one another to ensure a correct result. We‚Äôll see a number of mechanisms and patterns for synchronization later, but for now let‚Äôs see what goes wrong without synchronization.</p>
<div><pre><code><span>/* banker.c */</span>

<span>#include </span><span>&lt;stdio.h&gt;</span>
<span>#include </span><span>&lt;stdlib.h&gt;</span>
<span>#include </span><span>&lt;pthread.h&gt;</span>
<span>#include </span><span>&lt;time.h&gt;</span>

<span>#define N_ACCOUNTS 10</span>
<span>#define N_THREADS  20</span>
<span>#define N_ROUNDS   10000</span>

<span>/* 10 accounts with $100 apiece means there's $1,000</span>
<span>   in the system. Let's hope it stays that way...  */</span>
<span>#define INIT_BALANCE 100</span>

<span>/* making a struct here for the benefit of future</span>
<span>   versions of this program */</span>
<span>struct</span> account
{
	<span>long</span> balance;
} accts[N_ACCOUNTS];

<span>/* Helper for bankers to choose an account and amount at</span>
<span>   random. It came from Steve Summit's excellent C FAQ</span>
<span>   http://c-faq.com/lib/randrange.html */</span>
<span>int</span> rand_range(<span>int</span> N)
{
	<span>return</span> (<span>int</span>)((<span>double</span>)rand() / ((<span>double</span>)RAND_MAX + <span>1</span>) * N);
}

<span>/* each banker will run this function concurrently. The</span>
<span>   weird signature is required for a thread function */</span>
<span>void</span> *disburse(<span>void</span> *arg)
{
	<span>size_t</span> i, from, to;
	<span>long</span> payment;

	<span>/* idiom to tell compiler arg is unused */</span>
	(<span>void</span>)arg;

	<span>for</span> (i = <span>0</span>; i &lt; N_ROUNDS; i++)
	{
		<span>/* pick distinct 'from' and 'to' accounts */</span>
		from = rand_range(N_ACCOUNTS);
		<span>do</span> {
			to = rand_range(N_ACCOUNTS);
		} <span>while</span> (to == from);

		<span>/* go nuts sending money, try not to overdraft */</span>
		<span>if</span> (accts[from].balance &gt; <span>0</span>)
		{
			payment = <span>1</span> + rand_range(accts[from].balance);
			accts[from].balance -= payment;
			accts[to].balance   += payment;
		}
	}
	<span>return</span> NULL;
}

<span>int</span> main(<span>void</span>)
{
	<span>size_t</span> i;
	<span>long</span> total;
	pthread_t ts[N_THREADS];

	srand(time(NULL));

	<span>for</span> (i = <span>0</span>; i &lt; N_ACCOUNTS; i++)
		accts[i].balance = INIT_BALANCE;

	printf(<span>"Initial money in system: %d</span><span>
</span><span>"</span>,
		N_ACCOUNTS * INIT_BALANCE);

	<span>/* start the threads, using whatever parallelism the</span>
<span>	   system happens to offer. Note that pthread_create</span>
<span>	   is the *only* function that creates concurrency */</span>
	<span>for</span> (i = <span>0</span>; i &lt; N_THREADS; i++)
		pthread_create(&amp;ts[i], NULL, disburse, NULL);

	<span>/* wait for the threads to all finish, using the</span>
<span>	   pthread_t handles pthread_create gave us */</span>
	<span>for</span> (i = <span>0</span>; i &lt; N_THREADS; i++)
		pthread_join(ts[i], NULL);

	<span>for</span> (total = <span>0</span>, i = <span>0</span>; i &lt; N_ACCOUNTS; i++)
		total += accts[i].balance;

	printf(<span>"Final money in system: %ld</span><span>
</span><span>"</span>, total);
}</code></pre></div>
<p>The following simple Makefile can be used to compile all the programs in this article:</p>
<div><pre><code><span>.POSIX:</span>
<span>CFLAGS </span><span>=</span><span> -std=c99 -pedantic -D_POSIX_C_SOURCE=200809L -Wall -Wextra</span>
<span>LDFLAGS </span><span>=</span><span> -lpthread</span></code></pre></div>
<p>Make‚Äôs default <a href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html#tag_20_76_13_09">suffix rules</a> mean that if you have <code>foo.c</code> you can simply run <code>make foo</code> and it knows what to do without your needing to add any extra rules to the Makefile.</p>
<h3 id="data-races">Data races</h3>
<p>Try compiling and running <code>banker.c</code>. Notice anything strange?</p>
<p>Threads share memory directly. Each thread can read and write variables in shared memory without any overhead. However when threads simultaneously read and write the same data it‚Äôs called a <strong>data race</strong> and generally causes problems.</p>
<p>In particular, threads in <code>banker.c</code> have data races when they read and write account balances. The bankers program moves money between accounts, however the total amount of money in the system does not remain constant. The books don‚Äôt balance. Exactly how the program behaves depends on thread scheduling policies of the operating system. On OpenBSD the total money seldom stays at $1,000. Sometimes money gets duplicated, sometimes it vanishes. On macOS the result is generally that all the money disappears, or even becomes negative!</p>
<p>The property that money is neither created nor destroyed in a bank is an example of a <strong>program invariant</strong>, and it gets violated by data races. Note that parallelism is not required for a race, only concurrency.</p>
<p>Here‚Äôs the problematic code in the <code>disburse()</code> function:</p>
<div><pre><code>payment = <span>1</span> + rand_range(accts[from].balance);
accts[from].balance -= payment;
accts[to].balance   += payment;</code></pre></div>
<p>The threads running this code can be paused or interleaved at any time. Not just between any of the statements, but partway through arithmetic operations which may not execute atomically on the hardware. Never rely on ‚Äúthread inertia,‚Äù which is the mistaken feeling that the thread will finish a group of statements without interference.</p>
<p>Let‚Äôs examine exactly how statements can interleave between banker threads, and the resulting problems. The columns of the table below are threads, and the rows are moments in time.</p>
<p>Here‚Äôs a timeline where two threads read the same account balance when planning how much money to transfer. It can cause an overdraft.</p>
<table>
<caption>
Overdrafting
</caption>
<thead>
<tr>
<th>
Thread A
</th>
<th>
Thread B
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
payment = 1 + rand_range(accts[from].balance);
</td>
<td></td>
</tr>
<tr>
<td></td>
<td>
payment = 1 + rand_range(accts[from].balance);
</td>
</tr>
<tr>
<td colspan="2">
At this point, thread B‚Äôs payment-to-be may be in excess of the true balance because thread A has already earmarked some of the money unbeknownst to B.
</td>
</tr>
<tr>
<td>
accts[from].balance -= payment;
</td>
<td></td>
</tr>
<tr>
<td></td>
<td>
accts[from].balance -= payment;
</td>
</tr>
<tr>
<td colspan="2">
Some of the same dollars could be transferred twice and the originating account could even go negative if the overlap of the payments is big enough.
</td>
</tr>
</tbody>
</table>
<p>Here‚Äôs a timeline where the debit made by one thread can be undone by that made by another.</p>
<table>
<caption>
Lost debit
</caption>
<thead>
<tr>
<th>
Thread A
</th>
<th>
Thread B
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
accts[from].balance -= payment;
</td>
<td>
accts[from].balance -= payment;
</td>
</tr>
<tr>
<td colspan="2">
If <code>-=</code> is not atomic, the threads might switch execution after reading the balance and after doing arithmetic, but before assignment. Thus one assignment would be overwritten by the other. The ‚Äúlost update‚Äù creates extra money in the system.
</td>
</tr>
</tbody>
</table>
<p>Similar problems can occur when bankers have a data race in destination accounts. Races in the destination account would tend to decrease total money supply. (To learn more about concurrency problems, see my article <a href="https://begriffs.com/posts/2017-08-01-practical-guide-sql-isolation.html">Practical Guide to SQL Transaction Isolation</a>).</p>
<h3 id="locks-and-deadlock">Locks and deadlock</h3>
<p>In the example above, we found that a certain section of code was vulnerable to data races. Such tricky parts of a program are called <strong>critical sections.</strong> We must ensure each thread gets all the way through the section before another thread is allowed to enter it.</p>
<p>To give threads mutually exclusive access to a critical section, pthreads provides the mutually exclusive lock (<strong>mutex</strong> for short). The pattern is:</p>
<div><pre><code>pthread_mutex_lock(&amp;some_mutex);

<span>/* ... do things in the critical section ... */</span>

pthread_mutex_unlock(&amp;some_mutex);</code></pre></div>
<p>Any thread calling <code>pthread_mutex_lock</code> on a previously locked mutex will go to sleep and not be scheduled until the mutex is unlocked (and any other threads already waiting on the mutex have gone first).</p>
<p>Another way to look at mutexes is that their job is to preserve program invariants. The critical section between locking and unlocking is a place where a certain invariant may be temporarily broken, as long as it is restored by the end. Some people recommend adding an <code>assert()</code> statement before unlocking, to help document the invariant. If an invariant is difficult to specify in an assertion, a comment can be useful instead.</p>
<p>A function is called <strong>thread-safe</strong> if multiple invocations can safely run concurrently. A cheap, but inefficient, way to make any function thread-safe is to give it its own mutex and lock it right away:</p>
<div><pre><code><span>/* inefficient but effective way to protect a function */</span>

pthread_mutex_t foo_mtx = PTHREAD_MUTEX_INITIALIZER;

<span>void</span> foo(<span>/* some arguments */</span>)
{
	pthread_mutex_lock(&amp;foo_mtx);

	<span>/* we're safe in here, but it's a bottleneck */</span>

	pthread_mutex_unlock(&amp;foo_mtx);
}</code></pre></div>
<p>To see why this is inefficient, imagine if <code>foo()</code> was designed to output characters to a file specified in its arguments. Because the function takes a global lock, no two threads could run it at once, even if they wanted to write to different files. Writing to different files should be independent activities, and what we really want to protect against are two threads concurrently writing the <em>same</em> file.</p>
<p>The amount of data that a mutex protects is called its <strong>granularity,</strong> and smaller granularity can often be more efficient. In our <code>foo()</code> example, we could store a mutex for every file we write, and have the function choose and lock the appropriate mutex. Multi-threaded programs typically add a mutex as a member variable to data structures, to associate the lock with its data.</p>
<p>Let‚Äôs update the banker program to keep a mutex in each account and prevent data races.</p>
<div><pre><code><span>/* banker_lock.c */</span>

<span>#include </span><span>&lt;stdio.h&gt;</span>
<span>#include </span><span>&lt;stdlib.h&gt;</span>
<span>#include </span><span>&lt;pthread.h&gt;</span>
<span>#include </span><span>&lt;time.h&gt;</span>

<span>#define N_ACCOUNTS 10</span>
<span>#define N_THREADS  100</span>
<span>#define N_ROUNDS   10000</span>

<span>struct</span> account
{
	<span>long</span> balance;
	<span>/* add a mutex to prevent races on balance */</span>
	pthread_mutex_t mtx;
} accts[N_ACCOUNTS];

<span>int</span> rand_range(<span>int</span> N)
{
	<span>return</span> (<span>int</span>)((<span>double</span>)rand() / ((<span>double</span>)RAND_MAX + <span>1</span>) * N);
}

<span>void</span> *disburse(<span>void</span> *arg)
{
	<span>size_t</span> i, from, to;
	<span>long</span> payment;

	(<span>void</span>)arg;

	<span>for</span> (i = <span>0</span>; i &lt; N_ROUNDS; i++)
	{
		from = rand_range(N_ACCOUNTS);
		<span>do</span> {
			to = rand_range(N_ACCOUNTS);
		} <span>while</span> (to == from);

		<span>/* get an exclusive lock on both balances before</span>
<span>		   updating (there's a problem with this, see below) */</span>
		pthread_mutex_lock(&amp;accts[from].mtx);
		pthread_mutex_lock(&amp;accts[to].mtx);
		<span>if</span> (accts[from].balance &gt; <span>0</span>)
		{
			payment = <span>1</span> + rand_range(accts[from].balance);
			accts[from].balance -= payment;
			accts[to].balance   += payment;
		}
		pthread_mutex_unlock(&amp;accts[to].mtx);
		pthread_mutex_unlock(&amp;accts[from].mtx);
	}
	<span>return</span> NULL;
}

<span>int</span> main(<span>void</span>)
{
	<span>size_t</span> i;
	<span>long</span> total;
	pthread_t ts[N_THREADS];

	srand(time(NULL));

	<span>/* set the initial balance, but also create a</span>
<span>	   new mutex for each account */</span>
	<span>for</span> (i = <span>0</span>; i &lt; N_ACCOUNTS; i++)
		accts[i] = (<span>struct</span> account)
			{<span>100</span>, PTHREAD_MUTEX_INITIALIZER};

	<span>for</span> (i = <span>0</span>; i &lt; N_THREADS; i++)
		pthread_create(&amp;ts[i], NULL, disburse, NULL);

	<span>for</span> (i = <span>0</span>; i &lt; N_THREADS; i++)
		pthread_join(ts[i], NULL);

	<span>for</span> (total = <span>0</span>, i = <span>0</span>; i &lt; N_ACCOUNTS; i++)
		total += accts[i].balance;

	printf(<span>"Total money in system: %ld</span><span>
</span><span>"</span>, total);
}</code></pre></div>
<p>Now everything should be safe. No money being created or destroyed, just perfect exchanges between the accounts. The invariant is that the total balance of the source and destination accounts is the same before we transfer the money as after. It‚Äôs broken only inside the critical section.</p>
<p>As a side note, at this point you might think it would be more efficient be to take a single lock at a time, like this:</p>
<ul>
<li>lock the source account</li>
<li>withdraw money into a thread local variable</li>
<li>unlock the source account</li>
<li>(danger zone!)</li>
<li>lock the destination account</li>
<li>deposit the money</li>
<li>unlock the destination account</li>
</ul>
<p>This would not be safe. During the time between unlocking the source account and locking the destination, the invariant does not hold, yet another thread could observe this state. For instance a report running in another thread just at that time could read the balance of both accounts and observe money missing from the system.</p>
<p>We do need to lock both accounts during the transfer. However the way we‚Äôre doing it causes a different problem. Try to run the program. It gets stuck forever and never prints the final balance! It‚Äôs threads are <strong>deadlocked.</strong></p>
<p>Deadlock is the second villain of concurrent programming, and happens when threads wait on each others‚Äô locks, but no thread unlocks for any other. The case of the bankers is a classic simple form called the <strong>deadly embrace.</strong> Here‚Äôs how it plays out:</p>
<table>
<caption>
Deadly embrace
</caption>
<thead>
<tr>
<th>
Thread A
</th>
<th>
Thread B
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
lock account 1
</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
lock account 2
</td>
</tr>
<tr>
<td>
lock account 2
</td>
<td>
</td>
</tr>
<tr>
<td colspan="2">
At this point thread A is blocked because thread B already holds a lock on account 2.
</td>
</tr>
<tr>
<td>
</td>
<td>
lock account 1
</td>
</tr>
<tr>
<td colspan="2">
Now thread B is blocked because thread A holds a lock on account 1. However thread A will never unlock account 1 because thread A is blocked!
</td>
</tr>
</tbody>
</table>
<p>The problem happens because threads lock resources in different orders, and because they refuse to give locks up. We can solve the problem by addressing either of these causes.</p>
<p>The first approach to preventing deadlock is to enforce a <strong>locking hierarchy.</strong> This means the programmer comes up with an arbitrary order for locks, and always takes ‚Äúearlier‚Äù locks before ‚Äúlater‚Äù ones. The terminology comes from locks in hierarchical data structures like trees, but it really amounts to using any kind of consistent locking order.</p>
<p>In our case of the banker program we store all the accounts in an array, so we can use the array index as the lock order. Let‚Äôs compare.</p>
<div><pre><code><span>/* the original way to lock mutexes, which caused deadlock */</span>

pthread_mutex_lock(&amp;accts[from].mtx);
pthread_mutex_lock(&amp;accts[to].mtx);
<span>/* move money */</span>
pthread_mutex_unlock(&amp;accts[to].mtx);
pthread_mutex_unlock(&amp;accts[from].mtx);</code></pre></div>
<p>Here‚Äôs a safe way, enforcing a locking hierarchy:</p>
<div><pre><code><span>/* lock mutexes in earlier accounts first */</span>

<span>#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span>
<span>#define MAX(a,b) ((a) &lt; (b) ? (b) : (a))</span>

pthread_mutex_lock(&amp;accts[MIN(from, to)].mtx);
pthread_mutex_lock(&amp;accts[MAX(from, to)].mtx);
<span>/* move money */</span>
pthread_mutex_unlock(&amp;accts[MAX(from, to)].mtx);
pthread_mutex_unlock(&amp;accts[MIN(from, to)].mtx);

<span>/* notice we unlock in opposite order */</span></code></pre></div>
<p>A locking hierarchy is the most efficient way to prevent deadlock, but it isn‚Äôt always easy to contrive. It‚Äôs also creates a potentially undocumented coupling between different parts of a program which need to collaborate in the convention.</p>
<p><strong>Backoff</strong> is a different way to prevent deadlock which works for locks taken in any order. It takes a lock, but then checks whether the next is obtainable. If not, it unlocks the first to allow another thread to make progress, and tries again.</p>
<div><pre><code><span>/* using pthread_mutex_trylock to dodge deadlock */</span>

<span>while</span> (<span>1</span>)
{
	pthread_mutex_lock(&amp;accts[from].mtx);
	
	<span>if</span> (pthread_mutex_trylock(&amp;accts[to].mtx) == <span>0</span>)
		<span>break</span>; <span>/* got both locks */</span>

	<span>/* didn't get the second one, so unlock the first */</span>
	pthread_mutex_unlock(&amp;accts[from].mtx);
	<span>/* force a sleep so another thread can try --</span>
<span>	   include &lt;sched.h&gt; for this function */</span>
	sched_yield();
}
<span>/* move money */</span>
pthread_mutex_unlock(&amp;accts[to].mtx);
pthread_mutex_unlock(&amp;accts[from].mtx);</code></pre></div>
<p>One tricky part is the call to <code>sched_yield()</code>. Without it the loop will immediately try to grab the lock again, competing as hard as it can with other threads who could make more productive use of the lock. This causes <strong>livelock</strong>, where threads fight for access to the locks. The <code>sched_yield()</code> puts the calling thread to sleep and at the back of the scheduler‚Äôs run queue.</p>
<p>Despite its flexibility, backoff is definitely less efficient than a locking hierarchy because it can make wasted calls to lock and unlock mutexes. Try modifying the banker program with these approaches and measure how fast they run.</p>
<h3 id="condition-variables">Condition variables</h3>
<p>After safely getting access to a shared variable with a mutex, a thread may discover that the value of the variable is not yet suitable for the thread to act upon. For instance, if the thread was looking for an item to process in a shared queue, but found the queue was empty. The thread could poll the value, but this is inefficient. Pthreads provides <strong>condition variables</strong> to allow threads to wait for events of interest or notify other threads when these events happen.</p>
<p>Condition variables are not themselves locks, nor do they hold any value of their own. They are merely events with a programmer-assigned meaning. For example, a structure representing a queue could have a mutex for safely accessing the data, plus some condition variables. One to represent the event of the queue becoming empty, and another to announce when a new item is added.</p>
<p>Before getting deeper into how condition variables work, let‚Äôs see one in action with our banker program. We‚Äôll measure contention between the bankers. First we‚Äôll increase the number of threads and accounts, and keep statistics about how many bankers manage to get inside the <code>disburse()</code> critical section at once. Any time the max score is broken, we‚Äôll signal a condition variable. A dedicated thread will wait on it and update a scoreboard.</p>
<div><pre><code><span>/* banker_stats.c */</span>

<span>#include </span><span>&lt;stdio.h&gt;</span>
<span>#include </span><span>&lt;stdlib.h&gt;</span>
<span>#include </span><span>&lt;pthread.h&gt;</span>
<span>#include </span><span>&lt;time.h&gt;</span>

<span>/* increase the accounts and threads, but make sure there are</span>
<span> * "too many" threads so they tend to block each other */</span>
<span>#define N_ACCOUNTS 50</span>
<span>#define N_THREADS  100</span>
<span>#define N_ROUNDS   10000</span>

<span>#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span>
<span>#define MAX(a,b) ((a) &lt; (b) ? (b) : (a))</span>

<span>struct</span> account
{
	<span>long</span> balance;
	pthread_mutex_t mtx;
} accts[N_ACCOUNTS];

<span>int</span> rand_range(<span>int</span> N)
{
	<span>return</span> (<span>int</span>)((<span>double</span>)rand() / ((<span>double</span>)RAND_MAX + <span>1</span>) * N);
}

<span>/* keep a special mutex and condition variable</span>
<span> * reserved for just the stats */</span>
pthread_mutex_t stats_mtx = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t  stats_cnd = PTHREAD_COND_INITIALIZER;
<span>int</span> stats_curr = <span>0</span>, stats_best = <span>0</span>;

<span>/* use this interface to modify the stats */</span>
<span>void</span> stats_change(<span>int</span> delta)
{
	pthread_mutex_lock(&amp;stats_mtx);
	stats_curr += delta;
	<span>if</span> (stats_curr &gt; stats_best)
	{
		stats_best = stats_curr;
		<span>/* signal new high score */</span>
		pthread_cond_broadcast(&amp;stats_cnd);
	}
	pthread_mutex_unlock(&amp;stats_mtx);
}

<span>/* a dedicated thread to update the scoreboard UI */</span>
<span>void</span> *stats_print(<span>void</span> *arg)
{
	<span>int</span> prev_best;

	(<span>void</span>)arg;

	<span>/* we never return, nobody needs to</span>
<span>	 * pthread_join() with us */</span>
	pthread_detach(pthread_self());

	<span>while</span> (<span>1</span>)
	{
		pthread_mutex_lock(&amp;stats_mtx);

		prev_best = stats_best;
		<span>/* go to sleep until stats change, and always</span>
<span>		 * check that they actually have changed */</span>
		<span>while</span> (prev_best == stats_best)
			pthread_cond_wait(
				&amp;stats_cnd, &amp;stats_mtx);

		pthread_mutex_unlock(&amp;stats_mtx);

		<span>/* overwrite current line with new score */</span>
		printf(<span>"</span><span></span><span>%2d"</span>, stats_best);
		fflush(stdout);
	}
}

<span>void</span> *disburse(<span>void</span> *arg)
{
	<span>size_t</span> i, from, to;
	<span>long</span> payment;

	(<span>void</span>)arg;

	<span>for</span> (i = <span>0</span>; i &lt; N_ROUNDS; i++)
	{
		from = rand_range(N_ACCOUNTS);
		<span>do</span> {
			to = rand_range(N_ACCOUNTS);
		} <span>while</span> (to == from);

		pthread_mutex_lock(&amp;accts[MIN(from, to)].mtx);
		pthread_mutex_lock(&amp;accts[MAX(from, to)].mtx);

		<span>/* notice we still have a lock hierarchy, because</span>
<span>		 * we call stats_change() after locking all account</span>
<span>		 * mutexes (stats_mtx comes last) */</span>
		stats_change(<span>1</span>); <span>/* another banker in crit sec */</span>
		<span>if</span> (accts[from].balance &gt; <span>0</span>)
		{
			payment = <span>1</span> + rand_range(accts[from].balance);
			accts[from].balance -= payment;
			accts[to].balance   += payment;
		}
		stats_change(-<span>1</span>); <span>/* leaving crit sec */</span>

		pthread_mutex_unlock(&amp;accts[MAX(from, to)].mtx);
		pthread_mutex_unlock(&amp;accts[MIN(from, to)].mtx);
	}
	<span>return</span> NULL;
}

<span>int</span> main(<span>void</span>)
{
	<span>size_t</span> i;
	<span>long</span> total;
	pthread_t ts[N_THREADS], stats;

	srand(time(NULL));

	<span>for</span> (i = <span>0</span>; i &lt; N_ACCOUNTS; i++)
		accts[i] = (<span>struct</span> account)
			{<span>100</span>, PTHREAD_MUTEX_INITIALIZER};

	<span>for</span> (i = <span>0</span>; i &lt; N_THREADS; i++)
		pthread_create(&amp;ts[i], NULL, disburse, NULL);

	<span>/* start thread to update the user on how many bankers</span>
<span>	 * are in the disburse() critical section at once */</span>
	pthread_create(&amp;stats, NULL, stats_print, NULL);

	<span>for</span> (i = <span>0</span>; i &lt; N_THREADS; i++)
		pthread_join(ts[i], NULL);

	<span>/* not joining with the thread running stats_print,</span>
<span>	 * we'll let it disappar when main exits */</span>

	<span>for</span> (total = <span>0</span>, i = <span>0</span>; i &lt; N_ACCOUNTS; i++)
		total += accts[i].balance;

	printf(<span>"</span><span>
</span><span>Total money in system: %ld</span><span>
</span><span>"</span>, total);
}</code></pre></div>
<p>With fifty accounts and a hundred threads, not all threads will be able to be in the critical section of <code>disburse()</code> at once. It varies between runs. Run the program and see how well it does on your machine. (One complication is that making all threads synchronize on <code>stats_mtx</code> may throw off the measurement, because there are threads who could have executed independently but now must interact.)</p>
<p>Let‚Äôs look at how to properly use condition variables. We notified threads of a new event with <code>pthread_cond_broadcast(&amp;stats_cnd)</code>. This function marks all threads waiting on <code>state_cnd</code> as ready to run.</p>
<p>Sometimes multiple threads are waiting on a single cond var. A broadcast will wake them all, but sometimes the event source knows that only one thread will be able to do any work. For instance if only one item is added to a shared queue. In that case the <code>pthread_cond_signal</code> function is better than <code>pthread_cond_broadcast</code>. Unnecessarily waking multiple threads causes overhead. In our case we know that only one thread is waiting on the cond var, so it really makes no difference.</p>
<p>Remember that it‚Äôs never <em>wrong</em> to use a broadcast, whereas in some cases it might be wrong to use a signal. Signal is just an optimized broadcast.</p>
<p>The waiting side of a cond var ought always to have this pattern:</p>
<div><pre><code>pthread_mutex_lock(&amp;mutex);
<span>while</span> (!PREDICATE)
	pthread_cond_wait(&amp;cond_var, &amp;mutex);
pthread_mutex_unlock(&amp;mutex);</code></pre></div>
<p>Condition variables are always associated with a predicate, and the association is implicit in the programmer‚Äôs head. You shouldn‚Äôt reuse a condition variable for multiple predicates. The intention is that code will signal the cond var when the predicate becomes true.</p>
<p>Before testing the predicate we lock a mutex that covers the data being tested. That way no other thread can change the data immediately after we test it (also <code>pthread_cond_wait()</code> requires a locked mutex). If the predicate is already true we needn‚Äôt wait on the cond var, so the loop falls through, otherwise the thread begins to wait.</p>
<p>Condition variables allow you to make this series of events atomic: unlock a mutex, register our interest in the event, and block. Without that atomicity another thread might awaken to take our lock and broadcast before we‚Äôve registered ourselves as interested. Without the atomicity we could be blocked forever.</p>
<p>When <code>pthread_cond_wait()</code> returns, the calling thread awakens and atomically gets its mutex back. It‚Äôs all set to check the predicate again in the loop. But why check the predicate? Wasn‚Äôt the cond var signaled because the predicate was true, and isn‚Äôt the relevant data protected by a mutex? There are three reasons to check:</p>
<ol>
<li>If the condition variable had been broadcast, other threads might have been listening, and another might have been scheduled first and might have done our job. The loop tests for that interception.</li>
<li>On some multiprocessor systems, making condition variable wakeup completely predictable might substantially slow down all cond var operations. Such systems allow <strong>spurious wakeups</strong>, and threads need to be prepared to check if they were woken appropriately.</li>
<li>It can be convenient to signal on a loose predicate. Threads can signal the variables when the event seems <em>likely</em>, or even mistakenly signal, and the program will still work. For instance, we signal when when <code>stats_best</code> gets a new high score, but we could have chosen to signal at every invocation of <code>stats_change()</code>.</li>
</ol>
<p>Given that we have to pass a locked mutex to <code>pthread_cond_wait()</code>, which we had to create, why don‚Äôt cond vars come with their own built-in mutex? The reason is flexibility. Although you should use only one mutex with a cond var, there can be multiple cond vars for the same mutex. Think of the example of the mutex protecting a queue, and the different events that can happen in the queue.</p>
<h3 id="other-synchronization-primitives">Other synchronization primitives</h3>
<h4 id="barriers">Barriers</h4>
<p>It‚Äôs time to bid farewell to the banker programs, and turn to something more lively: Conway‚Äôs Game of Life! The game has a set of rules operating on a grid of cells that determines which cells live or die based on how many living neighbors each has.</p>
<p>The game can take advantage of multiple processors, using each processor to operate on a different part of the grid in parallel. It‚Äôs a so-called <strong>embarrassingly parallel</strong> problem because each section of the grid can be processed in isolation, without needing results from other sections.</p>
<p>Barriers ensure that all threads have reached a particular stage in a parallel computation before allowing any to proceed to the next stage. Each thread calls <code>pthread_barrier_wait()</code> to rendezvous with the others. One of the threads, chosen randomly, will see the <code>PTHREAD_BARRIER_SERIAL_THREAD</code> return value, which nominates that thread to do any cleanup or preparation between stages.</p>
<div><pre><code><span>/* life.c */</span>

<span>#include </span><span>&lt;assert.h&gt;</span>
<span>#include </span><span>&lt;pthread.h&gt;</span>
<span>#include </span><span>&lt;stdbool.h&gt;</span>
<span>#include </span><span>&lt;stdio.h&gt;</span>
<span>#include </span><span>&lt;stdlib.h&gt;</span>
<span>#include </span><span>&lt;string.h&gt;</span>
<span>#include </span><span>&lt;time.h&gt;</span>

<span>/* mandatory in POSIX.1-2008, but check laggards like macOS */</span>
<span>#include </span><span>&lt;unistd.h&gt;</span>
<span>#if !defined(_POSIX_BARRIERS) || _POSIX_BARRIERS &lt; 0</span>
<span>#error your OS lacks POSIX barrier support</span>
<span>#endif</span>

<span>/* dimensions of board */</span>
<span>#define ROWS 32</span>
<span>#define COLS 78</span>
<span>/* how long to pause between rounds */</span>
<span>#define FRAME_MS 100</span>
<span>#define THREADS 4</span>

<span>/* proper modulus (in C, '%' is merely remainder) */</span>
<span>#define MOD(x,N) (((x) &lt; 0) ? ((x) % (N) + (N)) : ((x) % (N)))</span>

bool alive[ROWS][COLS], alive_next[ROWS][COLS];
pthread_barrier_t tick;

<span>/* Should a cell live or die? Using ssize_t because we have</span>
<span>   to deal with signed arithmetic like row-1 when row=0 */</span>
bool fate(<span>ssize_t</span> row, <span>ssize_t</span> col)
{
	<span>ssize_t</span> i, j;
	<span>short</span> neighbors = <span>0</span>;

	assert(<span>0</span> &lt;= row &amp;&amp; row &lt; ROWS);
	assert(<span>0</span> &lt;= col &amp;&amp; col &lt; COLS);

	<span>/* joined edges form a torus */</span>
	<span>for</span> (i = row-<span>1</span>; i &lt;= row+<span>1</span>; i++)
		<span>for</span> (j = col-<span>1</span>; j &lt;= col+<span>1</span>; j++)
			neighbors += alive[MOD(i, ROWS)][MOD(j, COLS)];
	<span>/* don't count self as a neighbor */</span>
	neighbors -= alive[row][col];

	<span>return</span> neighbors == <span>3</span> ||
		(neighbors == <span>2</span> &amp;&amp; alive[row][col]);
}

<span>/* overwrite the board on screen */</span>
<span>void</span> draw(<span>void</span>)
{
	<span>ssize_t</span> i, j;

	<span>/* clear screen (non portable, requires ANSI terminal) */</span>
	fputs(<span>"</span><span></span><span>[2J</span><span></span><span>[1;1H"</span>, stdout);

	flockfile(stdout);
	<span>for</span> (i = <span>0</span>; i &lt; ROWS; i++)
	{
		<span>/* putchar_unlocked is thread safe when stdout is locked,</span>
<span>		   and it's as fast as single-threaded putchar */</span>
		<span>for</span> (j = <span>0</span>; j &lt; COLS; j++)
			putchar_unlocked(alive[i][j] ? <span>'X'</span> : <span>' '</span>);
		putchar_unlocked(<span>'
'</span>);
	}
	funlockfile(stdout);
	fflush(stdout);
}

<span>void</span> *update_strip(<span>void</span> *arg)
{
	<span>ssize_t</span> offset = *(<span>ssize_t</span>*)arg, i, j;
	<span>struct</span> timespec t;

	t.tv_sec = <span>0</span>;
	t.tv_nsec = FRAME_MS * <span>1000000</span>;

	<span>while</span> (<span>1</span>)
	{
		<span>if</span> (pthread_barrier_wait(&amp;tick) ==
			PTHREAD_BARRIER_SERIAL_THREAD)
		{
			<span>/* we drew the short straw, so we're on graphics duty */</span>

			<span>/* could have used pointers to multidimensional</span>
<span>			 * arrays and swapped them rather than memcpy'ing</span>
<span>			 * the array contents, but it makes the code a</span>
<span>			 * little more complicated with dereferences */</span>
			memcpy(alive, alive_next, <span>sizeof</span> alive);
			draw();
			nanosleep(&amp;t, NULL);
		}

		<span>/* rejoin at another barrier to avoid data race on</span>
<span>		   the game board while it's copied and drawn */</span>
		pthread_barrier_wait(&amp;tick);
		<span>for</span> (i = offset; i &lt; offset + (ROWS / THREADS); i++)
			<span>for</span> (j = <span>0</span>; j &lt; COLS; j++)
				alive_next[i][j] = fate(i, j);
	}

	<span>return</span> NULL;
}

<span>int</span> main(<span>void</span>)
{
	pthread_t *workers;
	<span>ssize_t</span> *offsets;
	<span>size_t</span> i, j;

	assert(ROWS % THREADS == <span>0</span>);
	<span>/* main counts as a thread, so need only THREADS-1 more */</span>
	workers = malloc(<span>sizeof</span>(*workers) * (THREADS-<span>1</span>));
	offsets = malloc(<span>sizeof</span>(*offsets) * ROWS / THREADS);

	srand(time(NULL));
	<span>for</span> (i = <span>0</span>; i &lt; ROWS; i++)
		<span>for</span> (j = <span>0</span>; j &lt; COLS; j++)
			alive_next[i][j] = rand() &lt; (<span>int</span>)((RAND_MAX+1u) / <span>3</span>);

	pthread_barrier_init(&amp;tick, NULL, THREADS);
	<span>for</span> (i = <span>0</span>; i &lt; THREADS-<span>1</span>; i++)
	{
		offsets[i] = i * ROWS / THREADS;
		pthread_create(&amp;workers[i], NULL, update_strip, &amp;offsets[i]);
	}

	<span>/* use current thread as a worker too */</span>
	offsets[i] = i * ROWS / THREADS;
	update_strip(&amp;offsets[i]);

	<span>/* shouldn't ever get here */</span>
	pthread_barrier_destroy(&amp;tick);
	free(offsets);
	free(workers);
	<span>return</span> EXIT_SUCCESS;
}</code></pre></div>
<p>It‚Äôs a fun example although slightly contrived. We‚Äôre adding a sleep between rounds to slow down the animation, so it‚Äôs unnecessary to chase parallelism. Also there‚Äôs a memoized algorithm called hashlife we should be using if pure speed is the goal. However our code illustrates a natural use for barriers.</p>
<p>Notice how we wait at the barrier twice in rapid succession. After emerging from the first barrier, one of the threads (chosen at random) copies the new state to the board and draws it. The other threads run ahead to the next barrier and wait there so they don‚Äôt cause a data race writing to the board. Once the drawing thread arrives at the barrier with them, then all can proceed to calculate cells‚Äô fate for the next round.</p>
<p>Barriers are guaranteed to be present in POSIX.1-2008, but are optional in earlier versions of the standard. Notably macOS is stuck at an old version of POSIX. Presumably they‚Äôre too busy ‚Äúinnovating‚Äù with their keyboard touchbar to invest in operating system fundamentals.</p>
<h4 id="spinlocks">Spinlocks</h4>
<p>Spinlocks are implementations of mutexes optimized for fine-grained locking. Often used in low level code like drivers or operating systems, spinlocks are designed to be the most primitive and fastest sync mechanism available. They‚Äôre generally not appropriate for application programming. They are only truly necessary for situations like interrupt handlers when a thread is not allowed to go to sleep for any reason.</p>
<p>Aside from that scenario, it‚Äôs better to just use a mutex, since mutexes are pretty efficient these days. Modern mutexes often try a short-lived internal spinlock and fall back to heavier techniques only as needed. Mutexes also sometimes use a wait queue called a <strong>futex</strong>, which can take a lock in user-space whenever there is no contention from another thread.</p>
<p>When attempting to lock a spinlock, a thread runs a tight loop repeatedly checking a value in shared memory for a sign it‚Äôs safe to proceed. Spinlock implementations use special atomic assembly language instructions to test that the value is unlocked and lock it. The particular instructions vary per architecture, and can be performed in user space to avoid the overhead of a system call.</p>
<p>The while waiting for a lock, the loop doesn‚Äôt block the thread, but instead continues running and burns CPU energy. The technique works only on true multi-processor systems or a uniprocessor system with preemption enabled. On a uniprocessor system with cooperative threading the loop could never be interrupted, and will livelock.</p>
<p>In POSIX.1-2008 spinlock support is mandatory. In previous versions the presence of this feature was indicated by the <code>_POSIX_SPIN_LOCKS</code> macro. Spinlock functions start with <code>pthread_spin_</code>.</p>
<h4 id="reader-writer-locks">Reader-writer locks</h4>
<p>Whereas a mutex enforces mutual exclusion, a <strong>reader-writer lock</strong> allows concurrent read access. Multiple threads can read in parallel, but all block when a thread takes the lock for writing. The increased concurrency can improve application performance. However, blindly replacing mutexes with reader-writer locks ‚Äúfor performance‚Äù doesn‚Äôt work. Our earlier banker program, for instance, could suffer from duplicate withdrawals if it allowed multiple readers in an account at once.</p>
<p>Below is an rwlock example. It‚Äôs a password cracker I call 5dm (md5 backwards). It aims for maximum parallelism searching for a preimage of an MD5 hash. Worker threads periodically poll whether one among them has found an answer, and they use a reader-writer lock to avoid blocking on each other when doing so.</p>
<p>The example is slightly contrived, in that the difficulty of brute forcing passwords increases exponentially with their length. Using multiple threads reduces the time by only a constant factor ‚Äì but 4x faster is still 4x faster on a four core computer!</p>
<p>The example below uses <code>MD5()</code> from OpenSSL. To build it, include <code>pkg-config --cflags libcrypto</code> in the CFLAGS and <code>pkg-config --libs libcrypto</code> in LDFLAGS. To run it, pass in an MD5 hash and max preimage search length. Note the <code>-n</code> in echo to suppress the newline, since newline is not in our search alphabet:</p>
<div><pre><code>$ <span>time</span> ./5dm <span>$(</span><span>echo</span> -n <span>'fun'</span> <span>|</span> <span>md5</span><span>)</span> 5
<span>fun</span>

<span>real</span>  0m0.067s
<span>user</span>  0m0.205s
<span>sys</span>	  0m0.007s</code></pre></div>
<p>Notice how 0.2 seconds of CPU time elapsed in parallel, but the user got their answer in 0.067 seconds.</p>
<p>On to the code:</p>
<div><pre><code><span>/* 5dm.c */</span>

<span>#include </span><span>&lt;stdbool.h&gt;</span>
<span>#include </span><span>&lt;stdio.h&gt;</span>
<span>#include </span><span>&lt;stdlib.h&gt;</span>
<span>#include </span><span>&lt;string.h&gt;</span>

<span>#include </span><span>&lt;openssl/md5.h&gt;</span>
<span>#include </span><span>&lt;pthread.h&gt;</span>

<span>/* build arbitrary words from the ascii between ' ' and '~' */</span>
<span>#define ASCII_FIRST ' '</span>
<span>#define ASCII_LAST  '~'</span>
<span>#define N_ALPHA (1 + ASCII_LAST - ASCII_FIRST)</span>
<span>/* refuse to search beyond this astronomical length */</span>
<span>#define LONGEST_PREIMAGE 128</span>

<span>#define MAX(x,y) ((x)&lt;(y) ? (y) : (x))</span>

<span>/* a fast way to enumerate words, operating on an array in-place */</span>
<span>unsigned</span> word_advance(<span>char</span> *word, <span>unsigned</span> delta)
{
	<span>if</span> (delta == <span>0</span>)
		<span>return</span> <span>0</span>;
	<span>if</span> (*word == '<span>0</span>')
	{
		*word++ = ASCII_FIRST + delta - <span>1</span>;
		*word = '<span>0</span>';
	}
	<span>else</span>
	{
		<span>char</span> c = *word - ASCII_FIRST;
		*word = ASCII_FIRST + ((c + delta) % N_ALPHA);
		<span>if</span> (c + delta &gt;= N_ALPHA)
			<span>return</span> <span>1</span> + word_advance(word+<span>1</span>, <span>1</span> <span>/* not delta */</span>);
	}
	<span>return</span> <span>1</span>;
}

<span>/* pack each pair of ASCII hex digits into single bytes */</span>
bool hex2md5(<span>const</span> <span>char</span> *hex, <span>unsigned</span> <span>char</span> *b)
{
	<span>int</span> offset = <span>0</span>;
	<span>if</span>(strlen(hex) != MD5_DIGEST_LENGTH*<span>2</span>)
		<span>return</span> false;
	<span>while</span> (offset &lt; MD5_DIGEST_LENGTH*<span>2</span>)
	{
		<span>if</span> (sscanf(hex+offset, <span>"%2hhx"</span>, b++) == <span>1</span>)
			offset += <span>2</span>;
		<span>else</span>
			<span>return</span> false;
	}
	<span>return</span> true;
}

<span>/* random things a worker will need, since thread</span>
<span> * functions receive only one argument */</span>
<span>struct</span> goal
{
	<span>/* input */</span>
	pthread_t *workers;
	<span>size_t</span> n_workers;
	<span>size_t</span> max_len;
	<span>unsigned</span> <span>char</span> hash[MD5_DIGEST_LENGTH];

	<span>/* output */</span>
	pthread_rwlock_t lock;
	<span>char</span> preimage[LONGEST_PREIMAGE];
	bool success;
};

<span>/* custom starting word for each worker, but shared goal */</span>
<span>struct</span> task
{
	<span>struct</span> goal *goal;
	<span>char</span> initial_preimage[LONGEST_PREIMAGE];
};

<span>void</span> *crack_thread(<span>void</span> *arg)
{
	<span>struct</span> task *t = arg;
	<span>unsigned</span> len, changed;
	<span>unsigned</span> <span>char</span> hashed[MD5_DIGEST_LENGTH];
	<span>char</span> preimage[LONGEST_PREIMAGE];
	<span>int</span> iterations = <span>0</span>;

	strcpy(preimage, t-&gt;initial_preimage);
	len = strlen(preimage);

	<span>while</span> (len &lt;= t-&gt;goal-&gt;max_len)
	{
		MD5((<span>const</span> <span>unsigned</span> <span>char</span>*)preimage, len, hashed);
		<span>if</span> (memcmp(hashed, t-&gt;goal-&gt;hash, MD5_DIGEST_LENGTH) == <span>0</span>)
		{
			<span>/* success -- tell others to call it off */</span>
			pthread_rwlock_wrlock(&amp;t-&gt;goal-&gt;lock);

			t-&gt;goal-&gt;success = true;
			strcpy(t-&gt;goal-&gt;preimage, preimage);

			pthread_rwlock_unlock(&amp;t-&gt;goal-&gt;lock);
			<span>return</span> NULL;
		}
		<span>/* each worker jumps ahead n_workers words, and all workers</span>
<span>		   started at an offset, so all words are covered */</span>
		changed = word_advance(preimage, t-&gt;goal-&gt;n_workers);
		len = MAX(len, changed);

		<span>/* check if another worker has succeeded, but only every</span>
<span>		   thousandth iteration, since taking the lock adds overhead */</span>
		<span>if</span> (iterations++ % <span>1000</span> == <span>0</span>)
		{
			<span>/* in the overwhelming majority of cases workers only read,</span>
<span>			   so an rwlock allows them to continue in parallel */</span>
			pthread_rwlock_rdlock(&amp;t-&gt;goal-&gt;lock);
			<span>int</span> success = t-&gt;goal-&gt;success;
			pthread_rwlock_unlock(&amp;t-&gt;goal-&gt;lock);
			<span>if</span> (success)
				<span>return</span> NULL;
		}
	}
	<span>return</span> NULL;
}

<span>/* launch a parallel search for an md5 preimage */</span>
bool crack(<span>const</span> <span>unsigned</span> <span>char</span> *md5, <span>size_t</span> max_len,
           <span>unsigned</span> threads, <span>char</span> *result)
{
	<span>struct</span> goal g =
	{
		.workers   = malloc(threads * <span>sizeof</span>(pthread_t)),
		.n_workers = threads,
		.max_len   = max_len,
		.success   = false,
		.lock      = PTHREAD_RWLOCK_INITIALIZER
	};
	memcpy(g.hash, md5, MD5_DIGEST_LENGTH);

	<span>struct</span> task *tasks = malloc(threads * <span>sizeof</span>(<span>struct</span> task));

	<span>for</span> (<span>size_t</span> i = <span>0</span>; i &lt; threads; i++)
	{
		tasks[i].goal = &amp;g;
		tasks[i].initial_preimage[<span>0</span>] = '<span>0</span>';
		<span>/* offset the starting word for each worker by i */</span>
		word_advance(tasks[i].initial_preimage, i);
		pthread_create(g.workers+i, NULL, crack_thread, tasks+i);
	}

	<span>/* if one worker finds the answer, others will abort */</span>
	<span>for</span> (<span>size_t</span> i = <span>0</span>; i &lt; threads; i++)
		pthread_join(g.workers[i], NULL);

	<span>if</span> (g.success)
		strcpy(result, g.preimage);

	free(tasks);
	free(g.workers);
	<span>return</span> g.success;
}

<span>int</span> main(<span>int</span> argc, <span>char</span> **argv)
{
	<span>char</span> preimage[LONGEST_PREIMAGE];
	<span>int</span> max_len = <span>4</span>;
	<span>unsigned</span> <span>char</span> md5[MD5_DIGEST_LENGTH];

	<span>if</span> (argc != <span>2</span> &amp;&amp; argc != <span>3</span>)
	{
		fprintf(stderr,
		        <span>"Usage: %s md5-string [search-depth]</span><span>
</span><span>"</span>,
		        argv[<span>0</span>]);
		<span>return</span> EXIT_FAILURE;
	}

	<span>if</span> (!hex2md5(argv[<span>1</span>], md5))
	{
		fprintf(stderr,
		       <span>"Could not parse as md5: %s</span><span>
</span><span>"</span>, argv[<span>1</span>]);
		<span>return</span> EXIT_FAILURE;
	}

	<span>if</span> (argc &gt; <span>2</span> &amp;&amp; strtol(argv[<span>2</span>], NULL, <span>10</span>))
		<span>if</span> ((max_len = strtol(argv[<span>2</span>], NULL, <span>10</span>)) &gt; LONGEST_PREIMAGE)
		{
			fprintf(stderr,
					<span>"Preimages limited to %d characters</span><span>
</span><span>"</span>,
					LONGEST_PREIMAGE);
			<span>return</span> EXIT_FAILURE;
		}

	<span>if</span> (crack(md5, max_len, <span>4</span>, preimage))
	{
		puts(preimage);
		<span>return</span> EXIT_SUCCESS;
	}
	<span>else</span>
	{
		fprintf(stderr,
				<span>"Could not find result in strings up to length %d</span><span>
</span><span>"</span>,
		        max_len);
		<span>return</span> EXIT_FAILURE;
	}
}</code></pre></div>
<p>Although read-write locks can be implemented in terms of mutexes and condition variables, such implementations are significantly less efficient than is possible. Therefore, this synchronization primitive is included in POSIX.1-2008 for the purpose of allowing more efficient implementations in multi-processor systems.</p>
<p>The final thing to be aware of is that an rwlock implementation can choose either reader-preference or writer-preference. When readers and writers are contending for a lock, the preference determines who gets to skip the queue and go first. When there is a lot of reader activity with a reader-preference, then a writer will continually get moved to the end of the line and experience <strong>starvation</strong>, where it never gets to write. I noticed writer starvation on Linux (glibc) when running four threads on a little 1-core virtual machine. Glibc provides the nonportable <code>pthread_rwlockattr_setkind_np()</code> function to specify a preference.</p>
<p>You may have noticed that workers in our password cracker use polling to see whether the solution has been found, and whether they should give up. We‚Äôll examine a more explicit method of cancellation in a later section.</p>
<h4 id="semaphores">Semaphores</h4>
<p>Semaphores keep count of, in the abstract, an amount of resource ‚Äúunits‚Äù available. Threads can safely add or remove a unit without causing a data race. When a thread requests a unit but there are none, then the thread will block.</p>
<p>A semaphore is like a mix between a lock and a condition variable. Unlike mutexes, semaphores have no concept of an owner. Any thread may release threads blocked on a semaphore, whereas with a mutex the lock holder must unlock it. Unlike a condition variable, a semaphore operates independently of a predicate.</p>
<p>An example of a problem uniquely suited for semaphores would be to ensure that exactly two threads run at once on a task. You would initialize the semaphore to the value two, and allow a bunch of threads to wait on the semaphore. After two get past, the rest will block. When each thread is done, it posts one unit back to the semaphore, which allows another thread to take its place.</p>
<p>In reality, if you‚Äôve got pthreads, you only <em>need</em> semaphores for asynchronous signal handlers. You <em>can</em> use them in other situations, but this is the only place they are needed. Mutexes aren‚Äôt async signal safe. Making them so would be much slower than an implementation that isn‚Äôt async signal safe, and would slow down ordinary mutex operation.</p>
<p>Here‚Äôs an example of posting a semaphore from a signal handler:</p>
<div><pre><code><span>/* sem_tickler.c */</span>

<span>#include </span><span>&lt;semaphore.h&gt;</span>
<span>#include </span><span>&lt;signal.h&gt;</span>
<span>#include </span><span>&lt;stdio.h&gt;</span>

<span>#include </span><span>&lt;unistd.h&gt;</span>
<span>#if !defined(_POSIX_SEMAPHORES) || _POSIX_SEMAPHORES &lt; 0</span>
<span>#error your OS lacks POSIX semaphore support</span>
<span>#endif</span>

sem_t tickler;

<span>void</span> int_catch(<span>int</span> sig)
{
	(<span>void</span>) sig;

	signal(SIGINT, &amp;int_catch);
	sem_post(&amp;tickler); <span>/* async signal safe: */</span>
}

<span>int</span> main(<span>void</span>)
{
	sem_init(&amp;tickler, <span>0</span>, <span>0</span>);
	signal(SIGINT, &amp;int_catch);

	<span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>3</span>; i++)
	{
		sem_wait(&amp;tickler);
		puts(<span>"That tickles!"</span>);
	}
	puts(<span>"(Died from overtickling)"</span>);
	<span>return</span> <span>0</span>;
}</code></pre></div>
<p>Semaphores aren‚Äôt even necessary for proper signal handling. It‚Äôs easier to have a thread simply <code>sigwait()</code> than it is to set up an asynchronous handler. In the example below, the main thread waits, but you can spawn a dedicated thread for this in a real application.</p>
<div><pre><code><span>/* sigwait_tickler.c */</span>

<span>#include </span><span>&lt;signal.h&gt;</span>
<span>#include </span><span>&lt;stdio.h&gt;</span>

<span>int</span> main(<span>void</span>)
{
	sigset_t set;
	<span>int</span> which;
	sigemptyset(&amp;set);
	sigaddset(&amp;set, SIGINT);

	<span>for</span> (<span>int</span> i = <span>0</span>; i &lt; <span>3</span>; i++)
	{
		sigwait(&amp;set, &amp;which);
		puts(<span>"That tickles!"</span>);
	}
	puts(<span>"(Died from overtickling)"</span>);
	<span>return</span> <span>0</span>;
}</code></pre></div>
<p>So don‚Äôt feel dependent on semaphores. In fact your system may not have them. The POSIX semaphore API works with pthreads and is present in POSIX.1-2008, but is an optional part of POSIX.1b in earlier versions. Apple, for one, <a href="https://lists.apple.com/archives/darwin-kernel/2009/Apr/msg00010.html">decided</a> to punt, so the semaphore functions on macOS are stubbed to return error codes.</p>
<h3 id="cancellation">Cancellation</h3>
<p>Thread cancellation is generally used when you have threads doing long-running tasks and there‚Äôs a way for a user to abort through the UI or console. Another common scenario is when multiple threads set off to explore a search space and one finds the answer first.</p>
<p>Our previous reader-writer lock example was the second scenario, where the threads explored a search space. It was an example of do-it-yourself cancellation through polling. However sometimes threads aren‚Äôt able to poll, such as when they are blocked on I/O or a lock. Pthreads offers an API to cancel threads even in those situations.</p>
<p>By default a cancelled thread isn‚Äôt immediately blown away, because it may have a mutex locked, be holding resources, or have a potentially broken invariant. The canceller wouldn‚Äôt know how to repair that invariant without some complicated logic. The thread to be canceled needs to be written to do cleanup and unlock mutexes.</p>
<p>For each thread, cancellation can be enabled or disabled, and if enabled, may be in deferred or asynchronous mode. The default is enabled and deferred, which allows a cancelled thread to survive until the next <strong>cancellation points</strong>, such as waiting on a condition variable or blocking on IO (see <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_05_02">full list</a>). In a purely computational section of code you can add your own cancellation points with <code>pthread_testcancel()</code>.</p>
<p>Let‚Äôs see how to modify our previous MD5 cracking example using standard pthread cancellation. Three of the functions are the same as before: <code>word_advance()</code>, <code>hex2md5()</code>, and <code>main()</code>. But we now use a condition variable to alert <code>crack()</code> whenever a <code>crack_thread()</code> returns.</p>
<div><pre><code><span>/* 5dm-testcancel.c */</span>

<span>#include </span><span>&lt;stdbool.h&gt;</span>
<span>#include </span><span>&lt;stdio.h&gt;</span>
<span>#include </span><span>&lt;stdlib.h&gt;</span>
<span>#include </span><span>&lt;string.h&gt;</span>

<span>#include </span><span>&lt;openssl/md5.h&gt;</span>
<span>#include </span><span>&lt;pthread.h&gt;</span>

<span>#define ASCII_FIRST ' '</span>
<span>#define ASCII_LAST  '~'</span>
<span>#define N_ALPHA (1 + ASCII_LAST - ASCII_FIRST)</span>
<span>#define LONGEST_PREIMAGE 128</span>

<span>#define MAX(x,y) ((x)&lt;(y) ? (y) : (x))</span>

<span>unsigned</span> word_advance(<span>char</span> *word, <span>unsigned</span> delta)
{
	<span>if</span> (delta == <span>0</span>)
		<span>return</span> <span>0</span>;
	<span>if</span> (*word == '<span>0</span>')
	{
		*word++ = ASCII_FIRST + delta - <span>1</span>;
		*word = '<span>0</span>';
	}
	<span>else</span>
	{
		<span>char</span> c = *word - ASCII_FIRST;
		*word = ASCII_FIRST + ((c + delta) % N_ALPHA);
		<span>if</span> (c + delta &gt;= N_ALPHA)
			<span>return</span> <span>1</span> + word_advance(word+<span>1</span>, <span>1</span> <span>/* not delta */</span>);
	}
	<span>return</span> <span>1</span>;
}

bool hex2md5(<span>const</span> <span>char</span> *hex, <span>unsigned</span> <span>char</span> *b)
{
	<span>int</span> offset = <span>0</span>;
	<span>if</span>(strlen(hex) != MD5_DIGEST_LENGTH*<span>2</span>)
		<span>return</span> false;
	<span>while</span> (offset &lt; MD5_DIGEST_LENGTH*<span>2</span>)
	{
		<span>if</span> (sscanf(hex+offset, <span>"%2hhx"</span>, b++) == <span>1</span>)
			offset += <span>2</span>;
		<span>else</span>
			<span>return</span> false;
	}
	<span>return</span> true;
}

<span>struct</span> goal
{
	<span>/* input */</span>
	pthread_t *workers;
	<span>size_t</span> n_workers;
	<span>size_t</span> max_len;
	<span>unsigned</span> <span>char</span> hash[MD5_DIGEST_LENGTH];

	<span>/* output */</span>
	pthread_mutex_t lock;
	pthread_cond_t returning;
	<span>unsigned</span> n_done;
	<span>char</span> preimage[LONGEST_PREIMAGE];
	bool success;
};

<span>struct</span> task
{
	<span>struct</span> goal *goal;
	<span>char</span> initial_preimage[LONGEST_PREIMAGE];
};

<span>void</span> *crack_thread(<span>void</span> *arg)
{
	<span>struct</span> task *t = arg;
	<span>unsigned</span> len, changed;
	<span>unsigned</span> <span>char</span> hashed[MD5_DIGEST_LENGTH];
	<span>char</span> preimage[LONGEST_PREIMAGE];
	<span>int</span> iterations = <span>0</span>;

	strcpy(preimage, t-&gt;initial_preimage);
	len = strlen(preimage);

	<span>while</span> (len &lt;= t-&gt;goal-&gt;max_len)
	{
		MD5((<span>const</span> <span>unsigned</span> <span>char</span>*)preimage, len, hashed);
		<span>if</span> (memcmp(hashed, t-&gt;goal-&gt;hash, MD5_DIGEST_LENGTH) == <span>0</span>)
		{
			pthread_mutex_lock(&amp;t-&gt;goal-&gt;lock);

			t-&gt;goal-&gt;success = true;
			strcpy(t-&gt;goal-&gt;preimage, preimage);
			t-&gt;goal-&gt;n_done++;

			<span>/* alert the boss that another worker is done */</span>
			pthread_cond_signal(&amp;t-&gt;goal-&gt;returning);
			pthread_mutex_unlock(&amp;t-&gt;goal-&gt;lock);
			<span>return</span> NULL;
		}
		changed = word_advance(preimage, t-&gt;goal-&gt;n_workers);
		len = MAX(len, changed);

		<span>if</span> (iterations++ % <span>1000</span> == <span>0</span>)
			pthread_testcancel(); <span>/* add a cancellation point */</span>
	}

	pthread_mutex_lock(&amp;t-&gt;goal-&gt;lock);
	t-&gt;goal-&gt;n_done++;
	<span>/* alert the boss that another worker is done */</span>
	pthread_cond_signal(&amp;t-&gt;goal-&gt;returning);
	pthread_mutex_unlock(&amp;t-&gt;goal-&gt;lock);
	<span>return</span> NULL;
}

<span>/* cancellation cleanup function that we also call</span>
<span> * during regular exit from the crack() function */</span>
<span>void</span> crack_cleanup(<span>void</span> *arg)
{
	<span>struct</span> task *tasks = arg;
	<span>struct</span> goal *g = tasks[<span>0</span>].goal;

	<span>/* this mutex unlock pairs with the lock in the crack() function */</span>
	pthread_mutex_unlock(&amp;g-&gt;lock);
	<span>for</span> (<span>size_t</span> i = <span>0</span>; i &lt; g-&gt;n_workers; i++)
	{
		pthread_cancel(g-&gt;workers[i]);
		<span>/* must wait for each to terminate, so that freeing</span>
<span>		 * their shared memory is safe */</span>
		pthread_join(g-&gt;workers[i], NULL);
	}
	<span>/* now it's safe to free memory */</span>
	free(g-&gt;workers);
	free(tasks);
}

bool crack(<span>const</span> <span>unsigned</span> <span>char</span> *md5, <span>size_t</span> max_len,
           <span>unsigned</span> threads, <span>char</span> *result)
{
	<span>struct</span> goal g =
	{
		.workers   = malloc(threads * <span>sizeof</span>(pthread_t)),
		.n_workers = threads,
		.max_len   = max_len,
		.success   = false,
		.n_done    = <span>0</span>,
		.lock      = PTHREAD_MUTEX_INITIALIZER,
		.returning = PTHREAD_COND_INITIALIZER
	};
	memcpy(g.hash, md5, MD5_DIGEST_LENGTH);

	<span>struct</span> task *tasks = malloc(threads * <span>sizeof</span>(<span>struct</span> task));

	<span>for</span> (<span>size_t</span> i = <span>0</span>; i &lt; threads; i++)
	{
		tasks[i].goal = &amp;g;
		tasks[i].initial_preimage[<span>0</span>] = '<span>0</span>';
		word_advance(tasks[i].initial_preimage, i);
		pthread_create(g.workers+i, NULL, crack_thread, tasks+i);
	}

	<span>/* coming up to cancellation points, so establish</span>
<span>	 * a cleanup handler */</span>
	pthread_cleanup_push(crack_cleanup, tasks);

	pthread_mutex_lock(&amp;g.lock);
	<span>/* We can't join() on all the workers now because it's up to</span>
<span>	 * us to cancel them after one finds the answer. We have to</span>
<span>	 * remain responsive and not block on any particular worker */</span>
	<span>while</span> (!g.success &amp;&amp; g.n_done &lt; threads)
		pthread_cond_wait(&amp;g.returning, &amp;g.lock);
	<span>/* at this point either a thread succeeded or all have given up */</span>
	<span>if</span> (g.success)
		strcpy(result, g.preimage);
	<span>/* mutex unlocked in the cleanup handler */</span>

	<span>/* Use the same cleanup handler for normal exit too. The "1"</span>
<span>	 * argument says to execute the function we had previous pushed */</span>
	pthread_cleanup_pop(<span>1</span>);
	<span>return</span> g.success;
}

<span>int</span> main(<span>int</span> argc, <span>char</span> **argv)
{
	<span>char</span> preimage[LONGEST_PREIMAGE];
	<span>int</span> max_len = <span>4</span>;
	<span>unsigned</span> <span>char</span> md5[MD5_DIGEST_LENGTH];

	<span>if</span> (argc != <span>2</span> &amp;&amp; argc != <span>3</span>)
	{
		fprintf(stderr,
		        <span>"Usage: %s md5-string [search-depth]</span><span>
</span><span>"</span>,
		        argv[<span>0</span>]);
		<span>return</span> EXIT_FAILURE;
	}

	<span>if</span> (!hex2md5(argv[<span>1</span>], md5))
	{
		fprintf(stderr,
		       <span>"Could not parse as md5: %s</span><span>
</span><span>"</span>, argv[<span>1</span>]);
		<span>return</span> EXIT_FAILURE;
	}

	<span>if</span> (argc &gt; <span>2</span> &amp;&amp; strtol(argv[<span>2</span>], NULL, <span>10</span>))
		<span>if</span> ((max_len = strtol(argv[<span>2</span>], NULL, <span>10</span>)) &gt; LONGEST_PREIMAGE)
		{
			fprintf(stderr,
					<span>"Preimages limited to %d characters</span><span>
</span><span>"</span>,
					LONGEST_PREIMAGE);
			<span>return</span> EXIT_FAILURE;
		}

	<span>if</span> (crack(md5, max_len, <span>4</span>, preimage))
	{
		puts(preimage);
		<span>return</span> EXIT_SUCCESS;
	}
	<span>else</span>
	{
		fprintf(stderr,
				<span>"Could not find result in strings up to length %d</span><span>
</span><span>"</span>,
		        max_len);
		<span>return</span> EXIT_FAILURE;
	}
}</code></pre></div>
<p>Using cancellation is actually a little more flexible than our rwlock implementation in 5dm. If the <code>crack()</code> function is running in its own thread, the whole thing can now be cancelled. The cancellation handler will ‚Äúpass along‚Äù the cancellation to each of the worker threads.</p>
<p>Writing general purpose library code that works with threads requires some care. It should handle deferred cancellation gracefully, including disabling cancellation when appropriate and always using cleanup handlers.</p>
<p>For cleanup handlers, notice the pattern of how we <code>pthread_cleanup_push()</code> the cancellation handler, and later <code>pthread_cleanup_pop()</code> it for regular (non-cancel) cleanup too. Using the same cleanup procedure in all situations makes the code more reliable.</p>
<p>Also notice how the boss thread now cancels workers, rather than the winning worker cancelling the others. You can join a canceled thread, but you can‚Äôt cancel an already joined (or detached) thread. If you want to both cancel and join a thread it ought to be done in one place.</p>
<p>Let‚Äôs turn out attention to the new worker threads. They are still polling for cancellation, like they polled with the reader-writer locks, but in this case they do it with a new function:</p>
<div><pre><code><span>if</span> (iterations++ % <span>1000</span> == <span>0</span>)
	pthread_testcancel();</code></pre></div>
<p>Admittedly it adds a little overhead to poll every thousandth loop, both with the rwlock, and with the testcancel. It also adds latency to the time between the cancellation request and the thread quitting, since the loop could run up to 999 times in between. A more efficient but dangerous method is to enable <strong>asynchronous cancellation</strong>, meaning the thread immediately dies when cancelled.</p>
<p>Async cancellation is dangerous because code is seldom async-cancel-safe. Anything that uses locks or works with shared state even slightly can break badly. Async-cancel-safe code can call very few functions, since those functions may not be safe. This includes calling libraries that use something as innocent as <code>malloc()</code>, since stopping malloc part way through could corrupt the heap.</p>
<p>Our <code>crack_thread()</code> function should be async-cancel-safe, at least during its calculation and not when taking locks. The <code>MD5()</code> function from OpenSSL also appears to be safe. Here‚Äôs how we can rewrite our function (notice how we disable cancellation before taking a lock):</p>
<div><pre><code><span>/* rewritten to use async cancellation */</span>

<span>void</span> *crack_thread(<span>void</span> *arg)
{
	<span>struct</span> task *t = arg;
	<span>unsigned</span> len, changed;
	<span>unsigned</span> <span>char</span> hashed[MD5_DIGEST_LENGTH];
	<span>char</span> preimage[LONGEST_PREIMAGE];
	<span>int</span> cancel_type, cancel_state;

	strcpy(preimage, t-&gt;initial_preimage);
	len = strlen(preimage);

	<span>/* async so we don't have to pthread_testcancel() */</span>
	pthread_setcanceltype(
			PTHREAD_CANCEL_ASYNCHRONOUS, &amp;cancel_type);

	<span>while</span> (len &lt;= t-&gt;goal-&gt;max_len)
	{
		MD5((<span>const</span> <span>unsigned</span> <span>char</span>*)preimage, len, hashed);
		<span>if</span> (memcmp(hashed, t-&gt;goal-&gt;hash, MD5_DIGEST_LENGTH) == <span>0</span>)
		{
			<span>/* protect the mutex against async cancellation */</span>
			pthread_setcancelstate(
					PTHREAD_CANCEL_DISABLE, &amp;cancel_state);
			pthread_mutex_lock(&amp;t-&gt;goal-&gt;lock);

			t-&gt;goal-&gt;success = true;
			strcpy(t-&gt;goal-&gt;preimage, preimage);
			t-&gt;goal-&gt;n_done++;

			pthread_cond_signal(&amp;t-&gt;goal-&gt;returning);
			pthread_mutex_unlock(&amp;t-&gt;goal-&gt;lock);
			<span>return</span> NULL;
		}
		changed = word_advance(preimage, t-&gt;goal-&gt;n_workers);
		len = MAX(len, changed);
	}

	<span>/* restore original cancellation type */</span>
	pthread_setcanceltype(cancel_type, &amp;cancel_type);

	pthread_mutex_lock(&amp;t-&gt;goal-&gt;lock);
	t-&gt;goal-&gt;n_done++;
	pthread_cond_signal(&amp;t-&gt;goal-&gt;returning);
	pthread_mutex_unlock(&amp;t-&gt;goal-&gt;lock);
	<span>return</span> NULL;
}</code></pre></div>
<p>Asynchronous cancellation does not appear to work on macOS, but as we‚Äôve seen that‚Äôs par for the course on that operating system.</p>
<h3 id="development-tools">Development tools</h3>
<h4 id="valgrind-drd-and-helgrind">Valgrind DRD and helgrind</h4>
<p><a href="https://valgrind.org/docs/manual/drd-manual.html">DRD</a> and <a href="https://valgrind.org/docs/manual/hg-manual.html">Helgrind</a> are Valgrind tools for detecting errors in multithreaded C and C++ programs. The tools work for any program that uses the POSIX threading primitives or that uses threading concepts built on top of the POSIX threading primitives.</p>
<p>The tools have overlapping abilities like detecting data races and improper use of the pthreads API. Additionally, Helgrind can detect locking hierarchy violations, and DRD can alert when there is lock contention.</p>
<p>Both tools pinpoint the lines of code where problems arise. For example, we can run DRD on our first crazy bankers program:</p>
<div><pre><code><span>valgrind</span> --tool=drd ./banker</code></pre></div>
<p>Here is a characteristic example of an error it emits:</p>
<pre><code>==8524== Thread 3:
==8524== Conflicting load by thread 3 at 0x003090b0 size 8
==8524==    at 0x1088BD: disburse (banker.c:48)
==8524==    by 0x4C324F3: vgDrd_thread_wrapper (drd_pthread_intercepts.c:444)
==8524==    by 0x4E514A3: start_thread (pthread_create.c:456)
==8524== Allocation context: BSS section of /home/admin/banker
==8524== Other segment start (thread 2)
==8524==    at 0x514FD01: clone (clone.S:80)
==8524== Other segment end (thread 2)
==8524==    at 0x509D820: rand (rand.c:26)
==8524==    by 0x108857: rand_range (banker.c:26)
==8524==    by 0x1088A0: disburse (banker.c:42)
==8524==    by 0x4C324F3: vgDrd_thread_wrapper (drd_pthread_intercepts.c:444)
==8524==    by 0x4E514A3: start_thread (pthread_create.c:456)</code></pre>
<p>It finds conflicting loads and stores from lines 48, 51, and 52.</p>
<div><pre><code><span>48</span>: <span>if</span> (accts[from].balance &gt; <span>0</span>)
<span>49</span>: {
<span>50</span>:		payment = <span>1</span> + rand_range(accts[from].balance);
<span>51</span>:		accts[from].balance -= payment;
<span>52</span>:		accts[to].balance   += payment;
<span>53</span>: }</code></pre></div>
<p>Helgrind can identify the lock hierarchy violation in our example of deadlocking bankers:</p>
<div><pre><code><span>valgrind</span> --tool=helgrind ./banker_lock</code></pre></div>
<pre><code>==8989== Thread #4: lock order "0x3091F8 before 0x3090D8" violated
==8989==
==8989== Observed (incorrect) order is: acquisition of lock at 0x3090D8
==8989==    at 0x4C3010C: mutex_lock_WRK (hg_intercepts.c:904)
==8989==    by 0x1089B9: disburse (banker_lock.c:38)
==8989==    by 0x4C32D06: mythread_wrapper (hg_intercepts.c:389)
==8989==    by 0x4E454A3: start_thread (pthread_create.c:456)
==8989==
==8989==  followed by a later acquisition of lock at 0x3091F8
==8989==    at 0x4C3010C: mutex_lock_WRK (hg_intercepts.c:904)
==8989==    by 0x1089D1: disburse (banker_lock.c:39)
==8989==    by 0x4C32D06: mythread_wrapper (hg_intercepts.c:389)
==8989==    by 0x4E454A3: start_thread (pthread_create.c:456)</code></pre>
<p>To identify when there is too much contention for a lock, we can ask DRD to alert us when a thread blocks for more than <em>n</em> milliseconds on a mutex:</p>
<div><pre><code><span>valgrind</span> --tool=drd --exclusive-threshold=2 ./banker_lock_hierarchy</code></pre></div>
<p>Since we throw too many threads at a small number of accounts, we see wait times that cross the threshold, like this one that waited seven ms:</p>
<pre><code>==7565== Acquired at:
==7565==    at 0x483F428: pthread_mutex_lock_intercept (drd_pthread_intercepts.c:888)
==7565==    by 0x483F428: pthread_mutex_lock (drd_pthread_intercepts.c:898)
==7565==    by 0x109280: disburse (banker_lock_hierarchy.c:40)
==7565==    by 0x483C114: vgDrd_thread_wrapper (drd_pthread_intercepts.c:444)
==7565==    by 0x4863FA2: start_thread (pthread_create.c:486)
==7565==    by 0x49764CE: clone (clone.S:95)
==7565== Lock on mutex 0x10c258 was held during 7 ms (threshold: 2 ms).
==7565==    at 0x4840478: pthread_mutex_unlock_intercept (drd_pthread_intercepts.c:978)
==7565==    by 0x4840478: pthread_mutex_unlock (drd_pthread_intercepts.c:991)
==7565==    by 0x109395: disburse (banker_lock_hierarchy.c:47)
==7565==    by 0x483C114: vgDrd_thread_wrapper (drd_pthread_intercepts.c:444)
==7565==    by 0x4863FA2: start_thread (pthread_create.c:486)
==7565==    by 0x49764CE: clone (clone.S:95)
==7565== mutex 0x10c258 was first observed at:
==7565==    at 0x483F368: pthread_mutex_lock_intercept (drd_pthread_intercepts.c:885)
==7565==    by 0x483F368: pthread_mutex_lock (drd_pthread_intercepts.c:898)
==7565==    by 0x109280: disburse (banker_lock_hierarchy.c:40)
==7565==    by 0x483C114: vgDrd_thread_wrapper (drd_pthread_intercepts.c:444)
==7565==    by 0x4863FA2: start_thread (pthread_create.c:486)
==7565==    by 0x49764CE: clone (clone.S:95)</code></pre>
<h4 id="clang-threadsanitizer-tsan">Clang ThreadSanitizer (TSan)</h4>
<p>ThreadSanitizer is a clang instrumentation module. To use it, choose <code>CC = clang</code> and add <code>-fsanitize=thread</code> to CFLAGS. Then when you build programs, they will be modified to detect data races and print statistics to stderr.</p>
<p>Here‚Äôs a portion of the output when running the bankers program:</p>
<pre><code>WARNING: ThreadSanitizer: data race (pid=11312)
  Read of size 8 at 0x0000014aeeb0 by thread T2:
    #0 disburse /home/admin/banker.c:48 (banker+0x0000004a4372)

  Previous write of size 8 at 0x0000014aeeb0 by thread T1:
    #0 disburse /home/admin/banker.c:52 (banker+0x0000004a43ba)</code></pre>
<p>TSan can also detect lock hierarchy violations, such as in banker_lock:</p>
<pre><code>WARNING: ThreadSanitizer: lock-order-inversion (potential deadlock) (pid=10095)
  Cycle in lock order graph: M1 (0x0000014aef78) =&gt; M2 (0x0000014aeeb8) =&gt; M1

  Mutex M2 acquired here while holding mutex M1 in thread T1:
    #0 pthread_mutex_lock &lt;null&gt; (banker_lock+0x000000439a10)
    #1 disburse /home/admin/banker_lock.c:39 (banker_lock+0x0000004a4398)

    Hint: use TSAN_OPTIONS=second_deadlock_stack=1 to get more informative warning message

  Mutex M1 acquired here while holding mutex M2 in thread T9:
    #0 pthread_mutex_lock &lt;null&gt; (banker_lock+0x000000439a10)
    #1 disburse /home/admin/banker_lock.c:39 (banker_lock+0x0000004a4398)</code></pre>
<h4 id="mutrace">Mutrace</h4>
<p>While Valgrind DRD can identify highly contended locks, it virtualizes the execution of the program under test, and skews the numbers. Other utilities can use software probes to get this information from a test running at full speed. In BSD land there is the <a href="http://dtrace.org/guide/chp-plockstat.html">plockstat</a> provider for DTrace, and on Linux there is the specially-written <a href="http://0pointer.de/blog/projects/mutrace.html">mutrace</a>. I had a lot of trouble trying to get plockstat to work on FreeBSD, so here‚Äôs an example of using mutrace to analyze our banker program.</p>
<div><pre><code><span>mutrace</span> ./banker_lock_hierarchy</code></pre></div>
<pre><code>mutrace: Showing 10 most contended mutexes:

 Mutex #   Locked  Changed    Cont. tot.Time[ms] avg.Time[ms] max.Time[ms]  Flags
       0   200211   153664    95985      991.349        0.005        0.267 M-.--.
       1   200552   142173    61902      641.963        0.003        0.170 M-.--.
       2   199657   140837    47723      476.737        0.002        0.125 M-.--.
       3   199566   140863    39268      371.451        0.002        0.108 M-.--.
       4   199936   141381    33243      295.909        0.001        0.090 M-.--.
       5   199548   141297    28193      232.647        0.001        0.084 M-.--.
       6   200329   142027    24230      183.301        0.001        0.066 M-.--.
       7   199951   142338    21018      142.494        0.001        0.057 M-.--.
       8   200145   142990    18201      107.692        0.001        0.052 M-.--.
       9   200105   143794    15713       76.231        0.000        0.028 M-.--.
                                                                           ||||||
                                                                           /|||||
          Object:                                     M = Mutex, W = RWLock /||||
           State:                                 x = dead, ! = inconsistent /|||
             Use:                                 R = used in realtime thread /||
      Mutex Type:                 r = RECURSIVE, e = ERRRORCHECK, a = ADAPTIVE /|
  Mutex Protocol:                                      i = INHERIT, p = PROTECT /
     RWLock Kind: r = PREFER_READER, w = PREFER_WRITER, W = PREFER_WRITER_NONREC

mutrace: Note that the flags column R is only valid in --track-rt mode!

mutrace: Total runtime is 1896.903 ms.

mutrace: Results for SMP with 4 processors.</code></pre>
<h4 id="off-cpu-profiling">Off-CPU profiling</h4>
<p>Typical profilers measure the amount of CPU time spent in each function. However when a thread is blocked by I/O, a lock, or a condition variable, then it isn‚Äôt using CPU time. To determine where functions spend the most ‚Äúwall clock time,‚Äù we need to sample the call stack for all threads at intervals, and count how frequently we see each entry. When a thread is off-CPU its call stack stays unchanged.</p>
<p>The <code>pstack</code> program is traditionally the way to get a snapshot of a running program‚Äôs stack. It exists on old Unices, and used to be on Linux until Linux made a breaking change. The most portable way to get stack snapshots is using gdb with an awk wrapper, as documented in the <a href="http://poormansprofiler.org/">Poor Man‚Äôs Profiler</a>.</p>
<p>Remember our early condition variable example that measured how many threads entered the critical section in <code>disburse()</code> at once? We asked whether synchronization on <code>stats_mtx</code> threw off the measurement. With off-CPU profiling we can look for clues.</p>
<p>Here‚Äôs a script based on the Poor Man‚Äôs Profiler:</p>
<div><pre><code><span>./banker_stats</span> <span>&amp;</span>
<span>pid=$!</span>

<span>while</span> <span>kill</span> -0 <span>$pid</span>
  <span>do</span>
    <span>gdb</span> -ex <span>"set pagination 0"</span> -ex <span>"thread apply all bt"</span> -batch -p <span>$pid</span>
  <span>done</span> <span>|</span> <span></span>
<span>awk</span> <span>'</span>
<span>  BEGIN { s = ""; }</span>
<span>  /^Thread/ { print s; s = ""; }</span>
<span>  /^#/ { if (s != "" ) { s = s "," $4} else { s = $4 } }</span>
<span>  END { print s }'</span> <span>|</span> <span></span>
<span>sort</span> <span>|</span> <span>uniq</span> -c <span>|</span> <span>sort</span> -r -n -k 1,1</code></pre></div>
<p>It outputs limited information, but we can see that waiting for locks in <code>disburse()</code> takes the majority of program time, being present in 872 of our samples. By contrast, waiting for the <code>stats_mtx</code> lock in <code>stats_update()</code> doesn‚Äôt appear in our sample at all. It must have had very little affect on our parallelism.</p>
<pre><code>    872 at,__GI___pthread_mutex_lock,disburse,start_thread,clone
     11 at,__random,rand,rand_range,disburse,start_thread,clone
      9 expected=0,,mutex=0x562533c3f0c0,&lt;stats_cnd&gt;,,stats_print,start_thread,clone
      9 __GI___pthread_timedjoin_ex,main
      5 at,__pthread_mutex_unlock_usercnt,disburse,start_thread,clone
      1 at,__pthread_mutex_unlock_usercnt,stats_change,disburse,start_thread,clone
      1 at,__GI___pthread_mutex_lock,stats_change,disburse,start_thread,clone
      1 __random,rand,rand_range,disburse,start_thread,clone</code></pre>
<h4 id="macos-instruments">macOS Instruments</h4>
<p>Although Mac‚Äôs POSIX thread support is pretty weak, its XCode tooling does include a nice profiler. From the Instruments application, choose the profiling template called ‚ÄúSystem Trace.‚Äù It adds a GUI on top of DTrace to display thread states (among other things). I modified our banker program to use only five threads and recorded its run. The Instruments app visualizes every event that happens, including threads blocking and being interrupted:</p>
<div>
<p><img src="https://begriffs.com/images/thread-states.png" alt="thread states"></p><p>thread states</p>
</div>
<p>Within the program you can zoom into the history and hover over events for info.</p>
<h4 id="perf-c2c">perf c2c</h4>
<p>Perf is a Linux tool to measure hardware performance counters during the execution of a program. Joe Mario created a Perf feature called <a href="https://joemario.github.io/blog/2016/09/01/c2c-blog/">c2c</a> which detects <strong>false sharing</strong> of variables between CPUs.</p>
<p>In a NUMA multi-core computer, each CPU has its own set of caches, and all CPUs share main memory. Memory is divided into fixed size blocks (often 64 bytes) called <strong>cache lines</strong>. Any time a CPU reads or writes memory, it must fetch or store the entire cache line surrounding the desired address. If one CPU has already cached a line, and another CPU writes to that area in memory, the system has to perform an expensive operation to make the caches coherent.</p>
<p>When two unrelated variables in a program are stored close enough together in memory to be in the same cache line, it can cause a performance problem in multi-threaded programs. If threads running on separate CPUs access the unrelated variables, it can cause a tug of war between their underlying cache line, which is called false sharing.</p>
<p>For instance, our Game of Life simulator could potentially have false sharing at the edges of each section of board accessed by each thread. To verify this, I attempted to run perf c2c on an Amazon EC2 instance (since I lack a physical computer running Linux), but got an error that memory events are not supported on the virtual machine. I was running kernel 4.19.0 on Intel Xeon Platinum 8124M CPUs, so I assume this was a security restriction from Amazon.</p>
<p>If you are able to run c2c, and detect false sharing in a multi-threaded program, the solution is to align the variables more aggressively. POSIX provides the <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html">posix_memalign()</a> function to allocate bytes aligned on a desired boundary. In our Life example, we could have used an array of pointers to dynamically allocated rows rather than a contiguous two-dimensional array.</p>
<h4 id="intel-vtune-profiler">Intel VTune Profiler</h4>
<p>The VTune Profiler is available for free (with registration) on Linux, macOS, and Windows. It works on x86 hardware only of course. I haven‚Äôt used it, but their <a href="https://software.intel.com/en-us/vtune/features/multithreaded">marketing page</a> shows some nice pictures. The tool can visually identify the granularity of locks, present a prioritized list of synchronization objects that hurt performance, and visualize lock contention.</p>
<h3 id="further-reading">Further reading</h3>
<ul>
<li><a href="https://www.goodreads.com/book/show/987956.Programming_with_Posix_Threads">Programming with Posix Threads</a> by David R. Butenhof</li>
<li><a href="https://www.goodreads.com/book/show/828272.Pthreads_Programming">Pthreads Programming</a> by Bradford Nichols, Dick Buttlar, Jacqueline Farrell</li>
<li><a href="https://www.goodreads.com/book/show/15710583-is-parallel-programming-hard-and-if-so-what-can-you-do-about-it">Is Parallel Programming Hard, And, If So, What Can You Do About It?</a> by Paul McKenney</li>
</ul>
  </div>
</div>

      </div>
    </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>