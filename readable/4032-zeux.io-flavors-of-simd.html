<!DOCTYPE html>
<html lang="en">
<head>
    <title>
zeux.io - Flavors of SIMD -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook" xmlns=""><div id="readInner" class="margin-medium size-medium"><h1>zeux.io - Flavors of SIMD</h1><div><div class="post" xmlns="http://www.w3.org/1999/xhtml"><h1 class="post-title">Flavors of SIMD</h1><span class="post-date">

17 Feb 2019

</span><p>During development of <a href="https://github.com/zeux/meshoptimizer">meshoptimizer</a> a question that comes up relatively often is “should this algorithm use SIMD?”. The library is performance-oriented, but SIMD doesn’t always provide significant performance benefits - unfortunately, the use of SIMD can make the code less portable and less maintainable, so this tradeoff has to be resolved on a case by case basis. When performance is of utmost importance, such as vertex/index codecs, separate SIMD implementations for SSE and NEON instruction sets need to be developed and maintained. In other cases it’s helpful to understand how much SIMD can help to make the decision. Today we will go through the exercise of accelerating sloppy mesh simplifier, a new algorithm that was recently added to the library, using SSEn/AVXn instruction sets.</p><p><a href="/images/simplifysimd_1.jpg"><img src="/images/simplifysimd_1.jpg" alt=""></a></p><p>For our benchmark, we will be simplifying a 6M triangle “Thai Buddha” model, reducing it to 0.1% of the triangle count. We will use one compiler, Microsoft Visual Studio 2019, to target x64 architecture.
The scalar algorithm can perform this simplification in about 210 ms<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>, using one thread of an Intel Core i7-8700K (running at ~4.4 GHz). Simplification can be parallelized in some cases by splitting a mesh into chunks, however this requires some extra connectivity analysis to be able to preserve chunk boundaries, so for now we’ll limit ourselves to pure SIMD optimizations.</p><h1 id="measure-seven-times">Measure seven times</h1><p>To understand our opportunities for optimization, let’s profile the code using Intel VTune; we’ll be running simplification 100 times to make sure we have enough profiling data.</p><p><a href="/images/simplifysimd_2.png"><img src="/images/simplifysimd_2.png" alt=""></a></p><p>Here I’m using the microarchitecture exploration mode to get both the time each function takes as well as where the bottlenecks are. We can see that simplification is performed using a set of functions; each function is self-contained in that all of the time is spent in the function itself, not in any callees. The list of functions is sorted by the time they take, here’s the same list sorted by the order in which they execute, to make the algorithm easier to understand:</p><ul><li><code class="language-plaintext highlighter-rouge">rescalePositions</code> normalizes positions of all vertices into a unit cube to prepare for quantization using <code class="language-plaintext highlighter-rouge">computeVertexIds</code></li><li><code class="language-plaintext highlighter-rouge">computeVertexIds</code> computes a 30-bit quantized id for each vertex by taking a uniform grid of a given size and quantizing each axis to the grid (grid size fits into 10 bits, thus the id needs up to 30)</li><li><code class="language-plaintext highlighter-rouge">countTriangles</code> computes the approximate number of triangles that the simplifier would produce given a grid size, assuming that all vertices that lie in the same grid cell are merged together</li><li><code class="language-plaintext highlighter-rouge">fillVertexCells</code> fills a table that maps each vertex to a cell that this vertex belongs to; all vertices with the same id map to the same cell</li><li><code class="language-plaintext highlighter-rouge">fillCellQuadrics</code> fills a <code class="language-plaintext highlighter-rouge">Quadric</code> (a symmetric 4x4 matrix) structure for each cell that represents the aggregate information about geometry contributing to the cell</li><li><code class="language-plaintext highlighter-rouge">fillCellRemap</code> computes a vertex index for each cell, picking one of the vertices that lies in this cell and minimizes the geometric distortion according to the error quadric</li><li><code class="language-plaintext highlighter-rouge">filterTriangles</code> outputs the final set of triangles according to the vertex-&gt;cell-&gt;vertex mapping tables built earlier; naive mapping can produce ~5% duplicate triangles on average, so the function filters out duplicates.</li></ul><p><code class="language-plaintext highlighter-rouge">computeVertexIds</code> and <code class="language-plaintext highlighter-rouge">countTriangles</code> run multiple times - the algorithm determines the grid size to perform vertex merging by doing an accelerated binary search to reach the target triangle count, 6000 in this case, and computes the number of triangles that each grid size would generate for each iteration. Other functions run just once. On the file in question, it takes us 5 search passes to find the target grid size, that happens to be 40<sup>3</sup> in this case.</p><p>VTune helpfully tells us that the most expensive function is the function that computes quadrics, accounting for close to half of the total runtime of 21 seconds. This will be our first target for SIMD optimization.</p><h1 id="piecewise-simd">Piecewise SIMD</h1><p>Let’s look at the source of <code class="language-plaintext highlighter-rouge">fillCellQuadrics</code> to get a better idea of what it needs to compute:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span><span class="kt">void</span><span class="nf">fillCellQuadrics</span><span class="p">(</span><span class="n">Quadric</span><span class="o">*</span><span class="n">cell_quadrics</span><span class="p">,</span><span class="k">const</span><span class="kt">unsigned</span><span class="kt">int</span><span class="o">*</span><span class="n">indices</span><span class="p">,</span><span class="kt">size_t</span><span class="n">index_count</span><span class="p">,</span><span class="k">const</span><span class="n">Vector3</span><span class="o">*</span><span class="n">vertex_positions</span><span class="p">,</span><span class="k">const</span><span class="kt">unsigned</span><span class="kt">int</span><span class="o">*</span><span class="n">vertex_cells</span><span class="p">)</span><span class="p">{</span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">index_count</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="mi">3</span><span class="p">)</span><span class="p">{</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i0</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i1</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i2</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c0</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c1</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c2</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i2</span><span class="p">];</span><span class="kt">bool</span><span class="n">single_cell</span><span class="o">=</span><span class="p">(</span><span class="n">c0</span><span class="o">==</span><span class="n">c1</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">c0</span><span class="o">==</span><span class="n">c2</span><span class="p">);</span><span class="kt">float</span><span class="n">weight</span><span class="o">=</span><span class="n">single_cell</span><span class="o">?</span><span class="mf">3.</span><span class="n">f</span><span class="o">:</span><span class="mf">1.</span><span class="n">f</span><span class="p">;</span><span class="n">Quadric</span><span class="n">Q</span><span class="p">;</span><span class="n">quadricFromTriangle</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i2</span><span class="p">],</span><span class="n">weight</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="n">single_cell</span><span class="p">)</span><span class="p">{</span><span class="n">quadricAdd</span><span class="p">(</span><span class="n">cell_quadrics</span><span class="p">[</span><span class="n">c0</span><span class="p">],</span><span class="n">Q</span><span class="p">);</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="n">quadricAdd</span><span class="p">(</span><span class="n">cell_quadrics</span><span class="p">[</span><span class="n">c0</span><span class="p">],</span><span class="n">Q</span><span class="p">);</span><span class="n">quadricAdd</span><span class="p">(</span><span class="n">cell_quadrics</span><span class="p">[</span><span class="n">c1</span><span class="p">],</span><span class="n">Q</span><span class="p">);</span><span class="n">quadricAdd</span><span class="p">(</span><span class="n">cell_quadrics</span><span class="p">[</span><span class="n">c2</span><span class="p">],</span><span class="n">Q</span><span class="p">);</span><span class="p">}</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>The function goes over all triangles, computes a quadric for each one, and adds it to the quadrics for each cell. Quadric is a symmetric 4x4 matrix which is represented as 10 floats:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="n">Quadric</span><span class="p">{</span><span class="kt">float</span><span class="n">a00</span><span class="p">;</span><span class="kt">float</span><span class="n">a10</span><span class="p">,</span><span class="n">a11</span><span class="p">;</span><span class="kt">float</span><span class="n">a20</span><span class="p">,</span><span class="n">a21</span><span class="p">,</span><span class="n">a22</span><span class="p">;</span><span class="kt">float</span><span class="n">b0</span><span class="p">,</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">c</span><span class="p">;</span><span class="p">};</span></code></pre></div></div><p>Computing the quadric requires computing a plane equation for the triangle, building the quadric matrix and weighing it using the triangle area:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span><span class="kt">void</span><span class="nf">quadricFromPlane</span><span class="p">(</span><span class="n">Quadric</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="kt">float</span><span class="n">a</span><span class="p">,</span><span class="kt">float</span><span class="n">b</span><span class="p">,</span><span class="kt">float</span><span class="n">c</span><span class="p">,</span><span class="kt">float</span><span class="n">d</span><span class="p">)</span><span class="p">{</span><span class="n">Q</span><span class="p">.</span><span class="n">a00</span><span class="o">=</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">;</span><span class="n">Q</span><span class="p">.</span><span class="n">a10</span><span class="o">=</span><span class="n">b</span><span class="o">*</span><span class="n">a</span><span class="p">;</span><span class="n">Q</span><span class="p">.</span><span class="n">a11</span><span class="o">=</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="n">Q</span><span class="p">.</span><span class="n">a20</span><span class="o">=</span><span class="n">c</span><span class="o">*</span><span class="n">a</span><span class="p">;</span><span class="n">Q</span><span class="p">.</span><span class="n">a21</span><span class="o">=</span><span class="n">c</span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="n">Q</span><span class="p">.</span><span class="n">a22</span><span class="o">=</span><span class="n">c</span><span class="o">*</span><span class="n">c</span><span class="p">;</span><span class="n">Q</span><span class="p">.</span><span class="n">b0</span><span class="o">=</span><span class="n">d</span><span class="o">*</span><span class="n">a</span><span class="p">;</span><span class="n">Q</span><span class="p">.</span><span class="n">b1</span><span class="o">=</span><span class="n">d</span><span class="o">*</span><span class="n">b</span><span class="p">;</span><span class="n">Q</span><span class="p">.</span><span class="n">b2</span><span class="o">=</span><span class="n">d</span><span class="o">*</span><span class="n">c</span><span class="p">;</span><span class="n">Q</span><span class="p">.</span><span class="n">c</span><span class="o">=</span><span class="n">d</span><span class="o">*</span><span class="n">d</span><span class="p">;</span><span class="p">}</span><span class="k">static</span><span class="kt">void</span><span class="nf">quadricFromTriangle</span><span class="p">(</span><span class="n">Quadric</span><span class="o">&amp;</span><span class="n">Q</span><span class="p">,</span><span class="k">const</span><span class="n">Vector3</span><span class="o">&amp;</span><span class="n">p0</span><span class="p">,</span><span class="k">const</span><span class="n">Vector3</span><span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span><span class="k">const</span><span class="n">Vector3</span><span class="o">&amp;</span><span class="n">p2</span><span class="p">,</span><span class="kt">float</span><span class="n">weight</span><span class="p">)</span><span class="p">{</span><span class="n">Vector3</span><span class="n">p10</span><span class="o">=</span><span class="p">{</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p1</span><span class="p">.</span><span class="n">z</span><span class="o">-</span><span class="n">p0</span><span class="p">.</span><span class="n">z</span><span class="p">};</span><span class="n">Vector3</span><span class="n">p20</span><span class="o">=</span><span class="p">{</span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p2</span><span class="p">.</span><span class="n">z</span><span class="o">-</span><span class="n">p0</span><span class="p">.</span><span class="n">z</span><span class="p">};</span><span class="n">Vector3</span><span class="n">normal</span><span class="o">=</span><span class="p">{</span><span class="n">p10</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">p20</span><span class="p">.</span><span class="n">z</span><span class="o">-</span><span class="n">p10</span><span class="p">.</span><span class="n">z</span><span class="o">*</span><span class="n">p20</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">p10</span><span class="p">.</span><span class="n">z</span><span class="o">*</span><span class="n">p20</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">p10</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">p20</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="n">p10</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">p20</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="n">p10</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">p20</span><span class="p">.</span><span class="n">x</span><span class="p">};</span><span class="kt">float</span><span class="n">area</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">normal</span><span class="p">);</span><span class="kt">float</span><span class="n">distance</span><span class="o">=</span><span class="n">normal</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">p0</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">normal</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">p0</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">normal</span><span class="p">.</span><span class="n">z</span><span class="o">*</span><span class="n">p0</span><span class="p">.</span><span class="n">z</span><span class="p">;</span><span class="n">quadricFromPlane</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">normal</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">normal</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">normal</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="o">-</span><span class="n">distance</span><span class="p">);</span><span class="n">quadricMul</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">area</span><span class="o">*</span><span class="n">weight</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><p>This looks like a lot of floating-point operations, and we should be able to implement them using SIMD. Let’s start by representing each vector as a 4-wide SIMD vector, and also let’s change the <code class="language-plaintext highlighter-rouge">Quadric</code> structure to have 12 floats instead of 10 so that it fits exactly into 3 SIMD registers<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>; we’ll also reorder the fields to make computations in <code class="language-plaintext highlighter-rouge">quadricFromPlane</code> more uniform:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span><span class="n">Quadric</span><span class="p">{</span><span class="kt">float</span><span class="n">a00</span><span class="p">,</span><span class="n">a11</span><span class="p">,</span><span class="n">a22</span><span class="p">;</span><span class="kt">float</span><span class="n">pad0</span><span class="p">;</span><span class="kt">float</span><span class="n">a10</span><span class="p">,</span><span class="n">a21</span><span class="p">,</span><span class="n">a20</span><span class="p">;</span><span class="kt">float</span><span class="n">pad1</span><span class="p">;</span><span class="kt">float</span><span class="n">b0</span><span class="p">,</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">c</span><span class="p">;</span><span class="p">};</span></code></pre></div></div><p>Some of the computations here, notably the dot product needed to normalize the normal and compute the plane distance, don’t map well to earlier versions of SSE - fortunately, SSE4.1 introduced a dot product instruction that is quite handy here.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span><span class="kt">void</span><span class="nf">fillCellQuadrics</span><span class="p">(</span><span class="n">Quadric</span><span class="o">*</span><span class="n">cell_quadrics</span><span class="p">,</span><span class="k">const</span><span class="kt">unsigned</span><span class="kt">int</span><span class="o">*</span><span class="n">indices</span><span class="p">,</span><span class="kt">size_t</span><span class="n">index_count</span><span class="p">,</span><span class="k">const</span><span class="n">Vector3</span><span class="o">*</span><span class="n">vertex_positions</span><span class="p">,</span><span class="k">const</span><span class="kt">unsigned</span><span class="kt">int</span><span class="o">*</span><span class="n">vertex_cells</span><span class="p">)</span><span class="p">{</span><span class="k">const</span><span class="kt">int</span><span class="n">yzx</span><span class="o">=</span><span class="n">_MM_SHUFFLE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="k">const</span><span class="kt">int</span><span class="n">zxy</span><span class="o">=</span><span class="n">_MM_SHUFFLE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="k">const</span><span class="kt">int</span><span class="n">dp_xyz</span><span class="o">=</span><span class="mh">0x7f</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">index_count</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="mi">3</span><span class="p">)</span><span class="p">{</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i0</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i1</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i2</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c0</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c1</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c2</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i2</span><span class="p">];</span><span class="kt">bool</span><span class="n">single_cell</span><span class="o">=</span><span class="p">(</span><span class="n">c0</span><span class="o">==</span><span class="n">c1</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">c0</span><span class="o">==</span><span class="n">c2</span><span class="p">);</span><span class="n">__m128</span><span class="n">p0</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i0</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">p1</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i1</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">p2</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i2</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">p10</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p0</span><span class="p">);</span><span class="n">__m128</span><span class="n">p20</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">p0</span><span class="p">);</span><span class="n">__m128</span><span class="n">normal</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">p10</span><span class="p">,</span><span class="n">p10</span><span class="p">,</span><span class="n">yzx</span><span class="p">),</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">p20</span><span class="p">,</span><span class="n">p20</span><span class="p">,</span><span class="n">zxy</span><span class="p">)),</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">p10</span><span class="p">,</span><span class="n">p10</span><span class="p">,</span><span class="n">zxy</span><span class="p">),</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">p20</span><span class="p">,</span><span class="n">p20</span><span class="p">,</span><span class="n">yzx</span><span class="p">)));</span><span class="n">__m128</span><span class="n">areasq</span><span class="o">=</span><span class="n">_mm_dp_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">normal</span><span class="p">,</span><span class="n">dp_xyz</span><span class="p">);</span><span class="c1">// SSE4.1</span><span class="n">__m128</span><span class="n">area</span><span class="o">=</span><span class="n">_mm_sqrt_ps</span><span class="p">(</span><span class="n">areasq</span><span class="p">);</span><span class="c1">// masks the result of the division when area==0</span><span class="c1">// scalar version does this in normalize()</span><span class="n">normal</span><span class="o">=</span><span class="n">_mm_and_ps</span><span class="p">(</span><span class="n">_mm_div_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">area</span><span class="p">),</span><span class="n">_mm_cmpneq_ps</span><span class="p">(</span><span class="n">area</span><span class="p">,</span><span class="n">_mm_setzero_ps</span><span class="p">()));</span><span class="n">__m128</span><span class="n">distance</span><span class="o">=</span><span class="n">_mm_dp_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">dp_xyz</span><span class="p">);</span><span class="c1">// SSE4.1</span><span class="n">__m128</span><span class="n">negdistance</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">_mm_setzero_ps</span><span class="p">(),</span><span class="n">distance</span><span class="p">);</span><span class="n">__m128</span><span class="n">normalnegdist</span><span class="o">=</span><span class="n">_mm_blend_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">negdistance</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span><span class="n">__m128</span><span class="n">Qx</span><span class="o">=</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">normal</span><span class="p">);</span><span class="n">__m128</span><span class="n">Qy</span><span class="o">=</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">normal</span><span class="p">,</span><span class="n">_MM_SHUFFLE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span><span class="n">_mm_shuffle_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">normal</span><span class="p">,</span><span class="n">_MM_SHUFFLE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)));</span><span class="n">__m128</span><span class="n">Qz</span><span class="o">=</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">negdistance</span><span class="p">,</span><span class="n">normalnegdist</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="n">single_cell</span><span class="p">)</span><span class="p">{</span><span class="n">area</span><span class="o">=</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">area</span><span class="p">,</span><span class="n">_mm_set1_ps</span><span class="p">(</span><span class="mf">3.</span><span class="n">f</span><span class="p">));</span><span class="n">Qx</span><span class="o">=</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">Qx</span><span class="p">,</span><span class="n">area</span><span class="p">);</span><span class="n">Qy</span><span class="o">=</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">Qy</span><span class="p">,</span><span class="n">area</span><span class="p">);</span><span class="n">Qz</span><span class="o">=</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">Qz</span><span class="p">,</span><span class="n">area</span><span class="p">);</span><span class="n">Quadric</span><span class="o">&amp;</span><span class="n">q0</span><span class="o">=</span><span class="n">cell_quadrics</span><span class="p">[</span><span class="n">c0</span><span class="p">];</span><span class="n">__m128</span><span class="n">q0x</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="p">.</span><span class="n">a00</span><span class="p">);</span><span class="n">__m128</span><span class="n">q0y</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="p">.</span><span class="n">a10</span><span class="p">);</span><span class="n">__m128</span><span class="n">q0z</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="p">.</span><span class="n">b0</span><span class="p">);</span><span class="n">_mm_storeu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="p">.</span><span class="n">a00</span><span class="p">,</span><span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">q0x</span><span class="p">,</span><span class="n">Qx</span><span class="p">));</span><span class="n">_mm_storeu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="p">.</span><span class="n">a10</span><span class="p">,</span><span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">q0y</span><span class="p">,</span><span class="n">Qy</span><span class="p">));</span><span class="n">_mm_storeu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q0</span><span class="p">.</span><span class="n">b0</span><span class="p">,</span><span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">q0z</span><span class="p">,</span><span class="n">Qz</span><span class="p">));</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">// omitted for brevity, repeats the if() body</span><span class="c1">// three times for c0/c1/c2</span><span class="p">}</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>There’s nothing particularly interesting in this code; we use unaligned loads/stores a lot here - while it’s possible to align the input Vector3 data, there doesn’t seem to be a noticeable penalty here for unaligned reads. Note that in the first half of the function that computes the normal and area, we aren’t utilizing vector units that well - our vectors have 3 components, and in some cases just one (see <code class="language-plaintext highlighter-rouge">areasq</code>/<code class="language-plaintext highlighter-rouge">area</code>/<code class="language-plaintext highlighter-rouge">distance</code> computation), whereas the hardware can perform 4 operations at once. Regardless, let’s see how much this helped.</p><p><a href="/images/simplifysimd_3.png"><img src="/images/simplifysimd_3.png" alt=""></a></p><p><code class="language-plaintext highlighter-rouge">fillCellQuadrics</code> now takes 5.3 seconds per 100 runs instead of 9.8, which saves ~45 ms for one simplification run - not bad, but somewhat underwhelming. Besides using just 3 components out of 4 in many instructions, we also are using dot product that has a pretty hefty latency. If you’ve written any SIMD code before, you know that the right way to compute dot products…</p><h1 id="whens-the-last-time-you-had-one-quadric">When’s the last time you had one quadric?</h1><p>… is to compute four of them at once. Instead of storing one normal vector in one SIMD register, we’ll use 3 registers - one will store 4 <code class="language-plaintext highlighter-rouge">x</code> components of a normal vector, one will store <code class="language-plaintext highlighter-rouge">y</code> and the third will store <code class="language-plaintext highlighter-rouge">z</code>. For this to work, we need to have 4 vectors to work with at once - which means we’ll be processing 4 triangles at once.</p><p>We’re dealing with a lot of arrays that are indexed dynamically - while normally it can help to pre-transpose your data to already have arrays of <code class="language-plaintext highlighter-rouge">x</code>/<code class="language-plaintext highlighter-rouge">y</code>/<code class="language-plaintext highlighter-rouge">z</code> components<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>, this will not work well with dynamic indexing so we’ll load 4 triangles worth of data as we normally do, and transpose the vectors using a handy <code class="language-plaintext highlighter-rouge">_MM_TRANSPOSE</code> macro.</p><p>In theory, a pure application of this principle would mean that we need to compute each component of the final 4 quadrics in its own SIMD register (e.g. we’d have <code class="language-plaintext highlighter-rouge">__m128 Q_a00</code> which will have 4 <code class="language-plaintext highlighter-rouge">a00</code> members of the final quadrics). In this case, the operations on quadrics lend themselves pretty nicely to 4-wide SIMD, and doing this transformation actually makes the code slower - so we’ll only transpose the initial vectors, and then transpose the plane equations back and run the exact same code we used to run to compute the quadrics, but repeated 4 times. Here’s how the code that computes the plane equations looks after this, with the remaining sections omitted for brevity:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i00</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i01</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i02</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i10</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i11</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i12</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i20</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i21</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i22</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i30</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i31</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i32</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="c1">// load first vertex of each triangle and transpose into vectors with components (pw0 isn't used later)</span><span class="n">__m128</span><span class="n">px0</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i00</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">py0</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i10</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">pz0</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i20</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">pw0</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i30</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">_MM_TRANSPOSE4_PS</span><span class="p">(</span><span class="n">px0</span><span class="p">,</span><span class="n">py0</span><span class="p">,</span><span class="n">pz0</span><span class="p">,</span><span class="n">pw0</span><span class="p">);</span><span class="c1">// load second vertex of each triangle and transpose into vectors with components</span><span class="n">__m128</span><span class="n">px1</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i01</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">py1</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i11</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">pz1</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i21</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">pw1</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i31</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">_MM_TRANSPOSE4_PS</span><span class="p">(</span><span class="n">px1</span><span class="p">,</span><span class="n">py1</span><span class="p">,</span><span class="n">pz1</span><span class="p">,</span><span class="n">pw1</span><span class="p">);</span><span class="c1">// load third vertex of each triangle and transpose into vectors with components</span><span class="n">__m128</span><span class="n">px2</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i02</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">py2</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i12</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">pz2</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i22</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m128</span><span class="n">pw2</span><span class="o">=</span><span class="n">_mm_loadu_ps</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i32</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">_MM_TRANSPOSE4_PS</span><span class="p">(</span><span class="n">px2</span><span class="p">,</span><span class="n">py2</span><span class="p">,</span><span class="n">pz2</span><span class="p">,</span><span class="n">pw2</span><span class="p">);</span><span class="c1">// p1 - p0</span><span class="n">__m128</span><span class="n">px10</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">px1</span><span class="p">,</span><span class="n">px0</span><span class="p">);</span><span class="n">__m128</span><span class="n">py10</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">py1</span><span class="p">,</span><span class="n">py0</span><span class="p">);</span><span class="n">__m128</span><span class="n">pz10</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">pz1</span><span class="p">,</span><span class="n">pz0</span><span class="p">);</span><span class="c1">// p2 - p0</span><span class="n">__m128</span><span class="n">px20</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">px2</span><span class="p">,</span><span class="n">px0</span><span class="p">);</span><span class="n">__m128</span><span class="n">py20</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">py2</span><span class="p">,</span><span class="n">py0</span><span class="p">);</span><span class="n">__m128</span><span class="n">pz20</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">pz2</span><span class="p">,</span><span class="n">pz0</span><span class="p">);</span><span class="c1">// cross(p10, p20)</span><span class="n">__m128</span><span class="n">normalx</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">py10</span><span class="p">,</span><span class="n">pz20</span><span class="p">),</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">pz10</span><span class="p">,</span><span class="n">py20</span><span class="p">));</span><span class="n">__m128</span><span class="n">normaly</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">pz10</span><span class="p">,</span><span class="n">px20</span><span class="p">),</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">px10</span><span class="p">,</span><span class="n">pz20</span><span class="p">));</span><span class="n">__m128</span><span class="n">normalz</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">px10</span><span class="p">,</span><span class="n">py20</span><span class="p">),</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">py10</span><span class="p">,</span><span class="n">px20</span><span class="p">));</span><span class="c1">// normalize; note that areasq/area now contain 4 values, not just one</span><span class="n">__m128</span><span class="n">areasq</span><span class="o">=</span><span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">normalx</span><span class="p">,</span><span class="n">normalx</span><span class="p">),</span><span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">normaly</span><span class="p">,</span><span class="n">normaly</span><span class="p">),</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">normalz</span><span class="p">,</span><span class="n">normalz</span><span class="p">)));</span><span class="n">__m128</span><span class="n">area</span><span class="o">=</span><span class="n">_mm_sqrt_ps</span><span class="p">(</span><span class="n">areasq</span><span class="p">);</span><span class="n">__m128</span><span class="n">areanz</span><span class="o">=</span><span class="n">_mm_cmpneq_ps</span><span class="p">(</span><span class="n">area</span><span class="p">,</span><span class="n">_mm_setzero_ps</span><span class="p">());</span><span class="n">normalx</span><span class="o">=</span><span class="n">_mm_and_ps</span><span class="p">(</span><span class="n">_mm_div_ps</span><span class="p">(</span><span class="n">normalx</span><span class="p">,</span><span class="n">area</span><span class="p">),</span><span class="n">areanz</span><span class="p">);</span><span class="n">normaly</span><span class="o">=</span><span class="n">_mm_and_ps</span><span class="p">(</span><span class="n">_mm_div_ps</span><span class="p">(</span><span class="n">normaly</span><span class="p">,</span><span class="n">area</span><span class="p">),</span><span class="n">areanz</span><span class="p">);</span><span class="n">normalz</span><span class="o">=</span><span class="n">_mm_and_ps</span><span class="p">(</span><span class="n">_mm_div_ps</span><span class="p">(</span><span class="n">normalz</span><span class="p">,</span><span class="n">area</span><span class="p">),</span><span class="n">areanz</span><span class="p">);</span><span class="n">__m128</span><span class="n">distance</span><span class="o">=</span><span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">normalx</span><span class="p">,</span><span class="n">px0</span><span class="p">),</span><span class="n">_mm_add_ps</span><span class="p">(</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">normaly</span><span class="p">,</span><span class="n">py0</span><span class="p">),</span><span class="n">_mm_mul_ps</span><span class="p">(</span><span class="n">normalz</span><span class="p">,</span><span class="n">pz0</span><span class="p">)));</span><span class="n">__m128</span><span class="n">negdistance</span><span class="o">=</span><span class="n">_mm_sub_ps</span><span class="p">(</span><span class="n">_mm_setzero_ps</span><span class="p">(),</span><span class="n">distance</span><span class="p">);</span><span class="c1">// this computes the plane equations (a, b, c, d) for each of the 4 triangles</span><span class="n">__m128</span><span class="n">plane0</span><span class="o">=</span><span class="n">normalx</span><span class="p">;</span><span class="n">__m128</span><span class="n">plane1</span><span class="o">=</span><span class="n">normaly</span><span class="p">;</span><span class="n">__m128</span><span class="n">plane2</span><span class="o">=</span><span class="n">normalz</span><span class="p">;</span><span class="n">__m128</span><span class="n">plane3</span><span class="o">=</span><span class="n">negdistance</span><span class="p">;</span><span class="n">_MM_TRANSPOSE4_PS</span><span class="p">(</span><span class="n">plane0</span><span class="p">,</span><span class="n">plane1</span><span class="p">,</span><span class="n">plane2</span><span class="p">,</span><span class="n">plane3</span><span class="p">);</span></code></pre></div></div><p>The code got quite a bit longer; we’re now processing 4 triangles in each loop iteration - we no longer need any SSE4.1 instructions for that though, and we should be utilizing SIMD units better now. Did this actually help?</p><p><a href="/images/simplifysimd_4.png"><img src="/images/simplifysimd_4.png" alt=""></a></p><p>… ok, this wasn’t really worth it. We did get a tiny bit faster, and <code class="language-plaintext highlighter-rouge">fillCellQuadrics</code> is now almost exactly 2x faster compared to the non-SIMD function we started with, but it’s not clear if the significant increase in complexity justifies this. In theory we should be able to use AVX2 and process 8 triangles per loop iteration, however this requires even more manual loop unrolling<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>. Let’s try something else instead.</p><h1 id="avx2--sse2--sse2">AVX2 = SSE2 + SSE2</h1><p>AVX2 is a somewhat peculiar instruction set. It gives you 8-wide floating point registers and allows to compute 8 operations using just one instruction; however, generally speaking instructions have the same behavior as two SSE2 instructions ran on two individual halves of the register<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>. For example, <code class="language-plaintext highlighter-rouge">_mm_dp_ps</code> computes a dot product between two SSE2 registers; <code class="language-plaintext highlighter-rouge">_mm256_dp_ps</code> computes two dot products between two halves of two AVX2 registers, so it’s limited to a 4-wide product for each half.</p><p>This often makes AVX2 code different from a general-purpose “8-wide SIMD”, but it works in our favor here - instead of trying to improve vectorization by transposing the 4-wide vectors, let’s go back to our first attempt at SIMD and unroll the loop 2x, using AVX2 instructions instead of SSE2/SSE4. We’ll still need to load and store 4-wide vectors, but in general the code is just a result of replacing <code class="language-plaintext highlighter-rouge">__m128</code> with <code class="language-plaintext highlighter-rouge">__m256</code> and <code class="language-plaintext highlighter-rouge">_mm_</code> with <code class="language-plaintext highlighter-rouge">_mm256_</code> with a few tweaks:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i00</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i01</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i02</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i10</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i11</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">i12</span><span class="o">=</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="n">__m256</span><span class="n">p0</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i10</span><span class="p">].</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i00</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m256</span><span class="n">p1</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i11</span><span class="p">].</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i01</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m256</span><span class="n">p2</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i12</span><span class="p">].</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i02</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m256</span><span class="n">p10</span><span class="o">=</span><span class="n">_mm256_sub_ps</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p0</span><span class="p">);</span><span class="n">__m256</span><span class="n">p20</span><span class="o">=</span><span class="n">_mm256_sub_ps</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span><span class="n">p0</span><span class="p">);</span><span class="n">__m256</span><span class="n">normal</span><span class="o">=</span><span class="n">_mm256_sub_ps</span><span class="p">(</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">_mm256_shuffle_ps</span><span class="p">(</span><span class="n">p10</span><span class="p">,</span><span class="n">p10</span><span class="p">,</span><span class="n">yzx</span><span class="p">),</span><span class="n">_mm256_shuffle_ps</span><span class="p">(</span><span class="n">p20</span><span class="p">,</span><span class="n">p20</span><span class="p">,</span><span class="n">zxy</span><span class="p">)),</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">_mm256_shuffle_ps</span><span class="p">(</span><span class="n">p10</span><span class="p">,</span><span class="n">p10</span><span class="p">,</span><span class="n">zxy</span><span class="p">),</span><span class="n">_mm256_shuffle_ps</span><span class="p">(</span><span class="n">p20</span><span class="p">,</span><span class="n">p20</span><span class="p">,</span><span class="n">yzx</span><span class="p">)));</span><span class="n">__m256</span><span class="n">areasq</span><span class="o">=</span><span class="n">_mm256_dp_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">normal</span><span class="p">,</span><span class="n">dp_xyz</span><span class="p">);</span><span class="n">__m256</span><span class="n">area</span><span class="o">=</span><span class="n">_mm256_sqrt_ps</span><span class="p">(</span><span class="n">areasq</span><span class="p">);</span><span class="n">__m256</span><span class="n">areanz</span><span class="o">=</span><span class="n">_mm256_cmp_ps</span><span class="p">(</span><span class="n">area</span><span class="p">,</span><span class="n">_mm256_setzero_ps</span><span class="p">(),</span><span class="n">_CMP_NEQ_OQ</span><span class="p">);</span><span class="n">normal</span><span class="o">=</span><span class="n">_mm256_and_ps</span><span class="p">(</span><span class="n">_mm256_div_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">area</span><span class="p">),</span><span class="n">areanz</span><span class="p">);</span><span class="n">__m256</span><span class="n">distance</span><span class="o">=</span><span class="n">_mm256_dp_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">p0</span><span class="p">,</span><span class="n">dp_xyz</span><span class="p">);</span><span class="n">__m256</span><span class="n">negdistance</span><span class="o">=</span><span class="n">_mm256_sub_ps</span><span class="p">(</span><span class="n">_mm256_setzero_ps</span><span class="p">(),</span><span class="n">distance</span><span class="p">);</span><span class="n">__m256</span><span class="n">normalnegdist</span><span class="o">=</span><span class="n">_mm256_blend_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">negdistance</span><span class="p">,</span><span class="mh">0x88</span><span class="p">);</span><span class="n">__m256</span><span class="n">Qx</span><span class="o">=</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">normal</span><span class="p">);</span><span class="n">__m256</span><span class="n">Qy</span><span class="o">=</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">_mm256_shuffle_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">normal</span><span class="p">,</span><span class="n">_MM_SHUFFLE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span><span class="n">_mm256_shuffle_ps</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span><span class="n">normal</span><span class="p">,</span><span class="n">_MM_SHUFFLE</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)));</span><span class="n">__m256</span><span class="n">Qz</span><span class="o">=</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">negdistance</span><span class="p">,</span><span class="n">normalnegdist</span><span class="p">);</span></code></pre></div></div><p>After this we could take each 128-bit half of the resulting <code class="language-plaintext highlighter-rouge">Qx</code>/<code class="language-plaintext highlighter-rouge">Qy</code>/<code class="language-plaintext highlighter-rouge">Qz</code> vectors and run the same code we used to run to add quadrics; instead, we’ll assume that if one triangle has all three vertices in the same cell (<code class="language-plaintext highlighter-rouge">single_cell == true</code>), then it’s likely that the other triangle has all three vertices in one cell, possibly a different one, and perform the final quadric aggregation using AVX2 as well:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c00</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i00</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c01</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i01</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c02</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i02</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c10</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i10</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c11</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i11</span><span class="p">];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">c12</span><span class="o">=</span><span class="n">vertex_cells</span><span class="p">[</span><span class="n">i12</span><span class="p">];</span><span class="kt">bool</span><span class="n">single_cell</span><span class="o">=</span><span class="p">(</span><span class="n">c00</span><span class="o">==</span><span class="n">c01</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">c00</span><span class="o">==</span><span class="n">c02</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">c10</span><span class="o">==</span><span class="n">c11</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">c10</span><span class="o">==</span><span class="n">c12</span><span class="p">);</span><span class="k">if</span><span class="p">(</span><span class="n">single_cell</span><span class="p">)</span><span class="p">{</span><span class="n">area</span><span class="o">=</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">area</span><span class="p">,</span><span class="n">_mm256_set1_ps</span><span class="p">(</span><span class="mf">3.</span><span class="n">f</span><span class="p">));</span><span class="n">Qx</span><span class="o">=</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">Qx</span><span class="p">,</span><span class="n">area</span><span class="p">);</span><span class="n">Qy</span><span class="o">=</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">Qy</span><span class="p">,</span><span class="n">area</span><span class="p">);</span><span class="n">Qz</span><span class="o">=</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">Qz</span><span class="p">,</span><span class="n">area</span><span class="p">);</span><span class="n">Quadric</span><span class="o">&amp;</span><span class="n">q00</span><span class="o">=</span><span class="n">cell_quadrics</span><span class="p">[</span><span class="n">c00</span><span class="p">];</span><span class="n">Quadric</span><span class="o">&amp;</span><span class="n">q10</span><span class="o">=</span><span class="n">cell_quadrics</span><span class="p">[</span><span class="n">c10</span><span class="p">];</span><span class="n">__m256</span><span class="n">q0x</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q10</span><span class="p">.</span><span class="n">a00</span><span class="p">,</span><span class="o">&amp;</span><span class="n">q00</span><span class="p">.</span><span class="n">a00</span><span class="p">);</span><span class="n">__m256</span><span class="n">q0y</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q10</span><span class="p">.</span><span class="n">a10</span><span class="p">,</span><span class="o">&amp;</span><span class="n">q00</span><span class="p">.</span><span class="n">a10</span><span class="p">);</span><span class="n">__m256</span><span class="n">q0z</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q10</span><span class="p">.</span><span class="n">b0</span><span class="p">,</span><span class="o">&amp;</span><span class="n">q00</span><span class="p">.</span><span class="n">b0</span><span class="p">);</span><span class="n">_mm256_storeu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q10</span><span class="p">.</span><span class="n">a00</span><span class="p">,</span><span class="o">&amp;</span><span class="n">q00</span><span class="p">.</span><span class="n">a00</span><span class="p">,</span><span class="n">_mm256_add_ps</span><span class="p">(</span><span class="n">q0x</span><span class="p">,</span><span class="n">Qx</span><span class="p">));</span><span class="n">_mm256_storeu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q10</span><span class="p">.</span><span class="n">a10</span><span class="p">,</span><span class="o">&amp;</span><span class="n">q00</span><span class="p">.</span><span class="n">a10</span><span class="p">,</span><span class="n">_mm256_add_ps</span><span class="p">(</span><span class="n">q0y</span><span class="p">,</span><span class="n">Qy</span><span class="p">));</span><span class="n">_mm256_storeu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q10</span><span class="p">.</span><span class="n">b0</span><span class="p">,</span><span class="o">&amp;</span><span class="n">q00</span><span class="p">.</span><span class="n">b0</span><span class="p">,</span><span class="n">_mm256_add_ps</span><span class="p">(</span><span class="n">q0z</span><span class="p">,</span><span class="n">Qz</span><span class="p">));</span><span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">// omitted for brevity</span><span class="p">}</span></code></pre></div></div><p>The resulting code is simpler, shorter and faster than our failed SSE2 approach:</p><p><a href="/images/simplifysimd_5.png"><img src="/images/simplifysimd_5.png" alt=""></a></p><p>Of course, we didn’t get 8x faster than our original scalar code with AVX2, we’re just 2.45x faster. Our loads and stores are still 4-wide since we’re forced to work with inconvenient memory layout due to dynamic indexing, and the computations aren’t optimal for SIMD - but with this change, <code class="language-plaintext highlighter-rouge">fillCellQuadrics</code> is no longer the top on our profile, and we should focus on other functions.</p><h1 id="gather-round-children">Gather ‘round, children</h1><p>We saved 4.8 seconds off our test run (48 msec per simplification run), and our top offender is now <code class="language-plaintext highlighter-rouge">countTriangles</code>. The function is seemingly simple, but it does run 5 times instead of just once, so it makes sense that it would account for disproportionately more time:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span><span class="kt">size_t</span><span class="nf">countTriangles</span><span class="p">(</span><span class="k">const</span><span class="kt">unsigned</span><span class="kt">int</span><span class="o">*</span><span class="n">vertex_ids</span><span class="p">,</span><span class="k">const</span><span class="kt">unsigned</span><span class="kt">int</span><span class="o">*</span><span class="n">indices</span><span class="p">,</span><span class="kt">size_t</span><span class="n">index_count</span><span class="p">)</span><span class="p">{</span><span class="kt">size_t</span><span class="n">result</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">index_count</span><span class="p">;</span><span class="n">i</span><span class="o">+=</span><span class="mi">3</span><span class="p">)</span><span class="p">{</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">id0</span><span class="o">=</span><span class="n">vertex_ids</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">]];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">id1</span><span class="o">=</span><span class="n">vertex_ids</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]];</span><span class="kt">unsigned</span><span class="kt">int</span><span class="n">id2</span><span class="o">=</span><span class="n">vertex_ids</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]];</span><span class="n">result</span><span class="o">+=</span><span class="p">(</span><span class="n">id0</span><span class="o">!=</span><span class="n">id1</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">id0</span><span class="o">!=</span><span class="n">id2</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">id1</span><span class="o">!=</span><span class="n">id2</span><span class="p">);</span><span class="p">}</span><span class="k">return</span><span class="n">result</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p>It iterates over all original triangles, and computes the number of non-degenerate triangles by comparing vertex ids. It’s not immediately clear how to make this use SIMD… unless you use gathers.</p><p>AVX2 is the instruction set that introduced a family of gather/scatter instructions to x64 SIMD; each instruction can take a vector register that contains 4 or 8 indices, and perform 4 or 8 loads or stores simultaneously. If we could use gathers here, we could load 3 indices, perform gather on all of them at once (or in groups of 4 or 8), and compare the results. Gathers have historically been pretty slow on Intel CPUs, however let’s try this. To make gathers easier to do we’ll load 8 triangles worth of index data, transpose the vectors similarly to our earlier attempt, and do the comparisons on respective elements of each vector:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">triangle_count</span><span class="o">&amp;</span><span class="o">~</span><span class="mi">7</span><span class="p">);</span><span class="n">i</span><span class="o">+=</span><span class="mi">8</span><span class="p">)</span><span class="p">{</span><span class="n">__m256</span><span class="n">tri0</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="p">(</span><span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">],</span><span class="p">(</span><span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">]);</span><span class="n">__m256</span><span class="n">tri1</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="p">(</span><span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">],</span><span class="p">(</span><span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">]);</span><span class="n">__m256</span><span class="n">tri2</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="p">(</span><span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">],</span><span class="p">(</span><span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">]);</span><span class="n">__m256</span><span class="n">tri3</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="p">(</span><span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">],</span><span class="p">(</span><span class="k">const</span><span class="kt">float</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">indices</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">0</span><span class="p">]);</span><span class="n">_MM_TRANSPOSE8_LANE4_PS</span><span class="p">(</span><span class="n">tri0</span><span class="p">,</span><span class="n">tri1</span><span class="p">,</span><span class="n">tri2</span><span class="p">,</span><span class="n">tri3</span><span class="p">);</span><span class="n">__m256i</span><span class="n">i0</span><span class="o">=</span><span class="n">_mm256_castps_si256</span><span class="p">(</span><span class="n">tri0</span><span class="p">);</span><span class="n">__m256i</span><span class="n">i1</span><span class="o">=</span><span class="n">_mm256_castps_si256</span><span class="p">(</span><span class="n">tri1</span><span class="p">);</span><span class="n">__m256i</span><span class="n">i2</span><span class="o">=</span><span class="n">_mm256_castps_si256</span><span class="p">(</span><span class="n">tri2</span><span class="p">);</span><span class="n">__m256i</span><span class="n">id0</span><span class="o">=</span><span class="n">_mm256_i32gather_epi32</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">vertex_ids</span><span class="p">,</span><span class="n">i0</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span><span class="n">__m256i</span><span class="n">id1</span><span class="o">=</span><span class="n">_mm256_i32gather_epi32</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">vertex_ids</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span><span class="n">__m256i</span><span class="n">id2</span><span class="o">=</span><span class="n">_mm256_i32gather_epi32</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">vertex_ids</span><span class="p">,</span><span class="n">i2</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span><span class="n">__m256i</span><span class="n">deg</span><span class="o">=</span><span class="n">_mm256_or_si256</span><span class="p">(</span><span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">id1</span><span class="p">,</span><span class="n">id2</span><span class="p">),</span><span class="n">_mm256_or_si256</span><span class="p">(</span><span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">id0</span><span class="p">,</span><span class="n">id1</span><span class="p">),</span><span class="n">_mm256_cmpeq_epi32</span><span class="p">(</span><span class="n">id0</span><span class="p">,</span><span class="n">id2</span><span class="p">)));</span><span class="n">result</span><span class="o">+=</span><span class="mi">8</span><span class="o">-</span><span class="n">_mm_popcnt_u32</span><span class="p">(</span><span class="n">_mm256_movemask_epi8</span><span class="p">(</span><span class="n">deg</span><span class="p">))</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span><span class="p">}</span></code></pre></div></div><p><code class="language-plaintext highlighter-rouge">_MM_TRANSPOSE8_LANE4_PS</code> macro is an AVX2 equivalent of <code class="language-plaintext highlighter-rouge">_MM_TRANSPOSE4_PS</code> that’s not present in the standard header but is easy to derive; it takes 4 AVX2 vectors and transposes two 4x4 matrices that they represent independently:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define _MM_TRANSPOSE8_LANE4_PS(row0, row1, row2, row3) \
do { \
    __m256 __t0, __t1, __t2, __t3; \
    __t0 = _mm256_unpacklo_ps(row0, row1); \
    __t1 = _mm256_unpackhi_ps(row0, row1); \
    __t2 = _mm256_unpacklo_ps(row2, row3); \
    __t3 = _mm256_unpackhi_ps(row2, row3); \
    row0 = _mm256_shuffle_ps(__t0, __t2, _MM_SHUFFLE(1, 0, 1, 0)); \
    row1 = _mm256_shuffle_ps(__t0, __t2, _MM_SHUFFLE(3, 2, 3, 2)); \
    row2 = _mm256_shuffle_ps(__t1, __t3, _MM_SHUFFLE(1, 0, 1, 0)); \
    row3 = _mm256_shuffle_ps(__t1, __t3, _MM_SHUFFLE(3, 2, 3, 2)); \
} while (0)
</span></code></pre></div></div><p>We have to transpose the vectors using floating-point register operations because of some idiosyncrasies in SSE2/AVX2 instruction sets. We also load data a bit sloppily; however, it seems like this mostly doesn’t matter because we’re bound by the performance of gather:</p><p><a href="/images/simplifysimd_6.png"><img src="/images/simplifysimd_6.png" alt=""></a></p><p><code class="language-plaintext highlighter-rouge">countTriangles</code> does run ~27% faster now, and note that CPI - cycles per instruction - is now pretty abysmal; we’re dispatching ~4x less instructions but gather instructions take a lot of time. It’s great that they help us run a bit faster, but of course the performance gains are somewhat underwhelming. We did manage to get under <code class="language-plaintext highlighter-rouge">fillCellQuadrics</code> in profile, which brings us to our last function in the top we haven’t looked at yet.</p><h1 id="chapter-6-where-things-are-as-they-should-be">Chapter 6, where things are as they should be</h1><p><code class="language-plaintext highlighter-rouge">computeVertexIds</code> is the last remaining function we’ll look at today - it runs 6 times during our algorithm so it’s also a great target for optimization. This function is the first one that actually looks like it should map cleanly to SIMD:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span><span class="kt">void</span><span class="nf">computeVertexIds</span><span class="p">(</span><span class="kt">unsigned</span><span class="kt">int</span><span class="o">*</span><span class="n">vertex_ids</span><span class="p">,</span><span class="k">const</span><span class="n">Vector3</span><span class="o">*</span><span class="n">vertex_positions</span><span class="p">,</span><span class="kt">size_t</span><span class="n">vertex_count</span><span class="p">,</span><span class="kt">int</span><span class="n">grid_size</span><span class="p">)</span><span class="p">{</span><span class="n">assert</span><span class="p">(</span><span class="n">grid_size</span><span class="o">&gt;=</span><span class="mi">1</span><span class="o">&amp;&amp;</span><span class="n">grid_size</span><span class="o">&lt;=</span><span class="mi">1024</span><span class="p">);</span><span class="kt">float</span><span class="n">cell_scale</span><span class="o">=</span><span class="kt">float</span><span class="p">(</span><span class="n">grid_size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">vertex_count</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="p">{</span><span class="k">const</span><span class="n">Vector3</span><span class="o">&amp;</span><span class="n">v</span><span class="o">=</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="kt">int</span><span class="n">xi</span><span class="o">=</span><span class="kt">int</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">cell_scale</span><span class="o">+</span><span class="mf">0.5</span><span class="n">f</span><span class="p">);</span><span class="kt">int</span><span class="n">yi</span><span class="o">=</span><span class="kt">int</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">cell_scale</span><span class="o">+</span><span class="mf">0.5</span><span class="n">f</span><span class="p">);</span><span class="kt">int</span><span class="n">zi</span><span class="o">=</span><span class="kt">int</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="o">*</span><span class="n">cell_scale</span><span class="o">+</span><span class="mf">0.5</span><span class="n">f</span><span class="p">);</span><span class="n">vertex_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">yi</span><span class="o">&lt;&lt;</span><span class="mi">10</span><span class="p">)</span><span class="o">|</span><span class="n">zi</span><span class="p">;</span><span class="p">}</span><span class="p">}</span></code></pre></div></div><p>After all other optimizations we’ve explored here we know what we need to do - we need to unroll the loop 4 or 8 times, since it doesn’t make any sense to try to accelerate just one iteration, transpose vector components, and perform the computation in parallel on all of them. Let’s do this with AVX2, processing 8 vertices at a time:</p><div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__m256</span><span class="n">scale</span><span class="o">=</span><span class="n">_mm256_set1_ps</span><span class="p">(</span><span class="n">cell_scale</span><span class="p">);</span><span class="n">__m256</span><span class="n">half</span><span class="o">=</span><span class="n">_mm256_set1_ps</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">);</span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">vertex_count</span><span class="o">&amp;</span><span class="o">~</span><span class="mi">7</span><span class="p">);</span><span class="n">i</span><span class="o">+=</span><span class="mi">8</span><span class="p">)</span><span class="p">{</span><span class="n">__m256</span><span class="n">vx</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">].</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m256</span><span class="n">vy</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">5</span><span class="p">].</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m256</span><span class="n">vz</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">6</span><span class="p">].</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">__m256</span><span class="n">vw</span><span class="o">=</span><span class="n">_mm256_loadu2_m128</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">7</span><span class="p">].</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">vertex_positions</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">].</span><span class="n">x</span><span class="p">);</span><span class="n">_MM_TRANSPOSE8_LANE4_PS</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="n">vy</span><span class="p">,</span><span class="n">vz</span><span class="p">,</span><span class="n">vw</span><span class="p">);</span><span class="n">__m256i</span><span class="n">xi</span><span class="o">=</span><span class="n">_mm256_cvttps_epi32</span><span class="p">(</span><span class="n">_mm256_add_ps</span><span class="p">(</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">vx</span><span class="p">,</span><span class="n">scale</span><span class="p">),</span><span class="n">half</span><span class="p">));</span><span class="n">__m256i</span><span class="n">yi</span><span class="o">=</span><span class="n">_mm256_cvttps_epi32</span><span class="p">(</span><span class="n">_mm256_add_ps</span><span class="p">(</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">vy</span><span class="p">,</span><span class="n">scale</span><span class="p">),</span><span class="n">half</span><span class="p">));</span><span class="n">__m256i</span><span class="n">zi</span><span class="o">=</span><span class="n">_mm256_cvttps_epi32</span><span class="p">(</span><span class="n">_mm256_add_ps</span><span class="p">(</span><span class="n">_mm256_mul_ps</span><span class="p">(</span><span class="n">vz</span><span class="p">,</span><span class="n">scale</span><span class="p">),</span><span class="n">half</span><span class="p">));</span><span class="n">__m256i</span><span class="n">id</span><span class="o">=</span><span class="n">_mm256_or_si256</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span><span class="n">_mm256_or_si256</span><span class="p">(</span><span class="n">_mm256_slli_epi32</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="mi">20</span><span class="p">),</span><span class="n">_mm256_slli_epi32</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span><span class="mi">10</span><span class="p">)));</span><span class="n">_mm256_storeu_si256</span><span class="p">((</span><span class="n">__m256i</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">vertex_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">id</span><span class="p">);</span><span class="p">}</span></code></pre></div></div><p>And look at the results:</p><p><a href="/images/simplifysimd_7.png"><img src="/images/simplifysimd_7.png" alt=""></a></p><p>We made <code class="language-plaintext highlighter-rouge">computeVertexIds</code> 2x faster, which, with all other optimizations combined, brings our total runtime to ~120 ms for one simplification run, which adds up to 50 million triangles/second.</p><p>It may look like we’re not getting the level of performance that we expected to see again - shouldn’t <code class="language-plaintext highlighter-rouge">computeVertexIds</code> improve more than 2x from introducing SIMD? To answer this, let’s try to see how much work this function is doing.</p><p><code class="language-plaintext highlighter-rouge">computeVertexIds</code> is ran 6 times during the course of one simplification run - 5 times during the binary search, and once at the end to compute the final ids that are used for further processing. Each time this function processes 3M vertices, reading 12 bytes for each vertex and writing 4 bytes.</p><p>In total, this function processes 1800M vertices over 100 runs of the algorithm, reading 21 GB of data and writing 7 GB back. To process 28 GB of data in 1.46 seconds requires 19 GB/sec bandwidth. Running <code class="language-plaintext highlighter-rouge">memcmp(block1, block2, 512 MB)</code> on this system finishes in 45 msec, which makes me think that only about 22 GB/sec is achievable on a single core<sup id="fnref:6"><a href="#fn:6" class="footnote">6</a></sup>. Essentially we’re now running close to memory speed and improving performance further would require packing our vertex data tighter so that positions require less than 12 bytes to store.</p><h1 id="conclusion">Conclusion</h1><p>We’ve taken a pretty well optimized algorithm that could simplify very large meshes at a rate of 28 million triangles per second, and used SSE and AVX instruction sets to make it almost 2x faster, achieving 50 million triangles/second. Along this journey we had to explore different ways to apply SIMD - using SIMD registers to store 3-wide vectors, attempting to leverage SoA transposes, using AVX2 to store two 3-wide vectors, using gathers to load data slightly faster than it’s possible with scalar instructions and, finally, a straightforward application of AVX2 for stream processing.</p><p>SIMD often isn’t a good starting point for optimization - the sloppy simplifier went through many iterations of both algorithmic optimizations and micro-optimizations without the use of platform-specific instructions; however, at some point most other optimization opportunities are exhausted and, if performance is critical, SIMD is a fantastic tool to be able to use when necessary.</p><p>I’m not sure how many of these optimizations will end up in <code class="language-plaintext highlighter-rouge">meshoptimizer</code> master - after all, this was mostly an experiment to see how much it’s possible to push the hardware without drastically changing any algorithms involved. Hopefully this was informative and can give you ideas to optimize your code. The final source code for this article is <a href="https://gist.github.com/zeux/1171b770c105b11c3bde128e1d3a16ec">available here</a>; this work is based off <a href="https://github.com/zeux/meshoptimizer/commit/99ab49af6706daf9716c0f1e2d1a1d99fdf12d81">meshoptimizer 99ab49</a>, with Thai Buddha model available <a href="https://sketchfab.com/3d-models/thai-buddha-cba029e262bd4f22a7ee4fcf064e22ee">on Sketchfab</a>.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>