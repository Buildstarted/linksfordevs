<!DOCTYPE html>
<html lang="en">
<head>
    <title>
[PATCH 0/3] namei: implement various scoping AT_* flags - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="[PATCH 0/3] namei: implement various scoping AT_* flags - linksfor.dev(s)"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/T/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - [PATCH 0/3] namei: implement various scoping AT_* flags</title>
<div class="readable">
        <h1>[PATCH 0/3] namei: implement various scoping AT_* flags</h1>
            <div>Reading time: 305-387 minutes</div>
        <div>Posted here: 27 Feb 2019</div>
        <p><a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/T/">https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/T/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><pre><a href="#eea91fe1fc4f7cb11eb3dd0425f7e86840e317a56" id="mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">*</a> <u id="u"><b>[PATCH 0/3] namei: implement various scoping AT_* flags</b></u>
<b>@ 2018-09-29 10:34 Aleksa Sarai</b>
  2018-09-29 10:34 ` <a href="#m1383f86e3b88f40c8cb1ba987680029c591c723c">[PATCH 1/3] namei: implement O_BENEATH-style</a> " Aleksa Sarai
                   ` <a href="#r1383f86e3b88f40c8cb1ba987680029c591c723c">(7 more replies)</a>
  <a href="#rea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">0 siblings, 8 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-09-29 10:34 UTC (<a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/raw">raw</a>)
  To: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan
  Cc: David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers, Aleksa Sarai

The need for some sort of control over VFS's path resolution (to avoid
malicious paths resulting in inadvertent breakouts) has been a very
long-standing desire of many userspace applications. This patchset is a
revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.

The most obvious change is that AT_NO_JUMPS has been split as dicussed
in the original thread, along with a further split of AT_NO_PROCLINKS
which means that each individual property of AT_NO_JUMPS is now a
separate flag:

  * Path-based escapes from the starting-point using "/" or ".." are
    blocked by AT_BENEATH.
  * Mountpoint crossings are blocked by AT_XDEV.
  * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
	correctly it actually blocks any user of nd_jump_link() because it
	allows out-of-VFS path resolution manipulation).

AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS). At
Linus' suggestion in the original thread, I've also implemented
AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
"proclink" resolution).

An additional improvement was made to AT_XDEV. The original AT_NO_JUMPS
path didn't consider "/tmp/.." as a mountpoint crossing -- this patch
blocks this as well (feel free to ask me to remove it if you feel this
is not sane).

Currently I've only enabled these for openat(2) and the stat(2) family.
I would hope we could enable it for basically every *at(2) syscall --
but many of them appear to not have a @flags argument and thus we'll
need to add several new syscalls to do this. I'm more than happy to send
those patches, but I'd prefer to know that this preliminary work is
acceptable before doing a bunch of copy-paste to add new sets of *at(2)
syscalls.

One additional feature I've implemented is AT_THIS_ROOT (I imagine this
is probably going to be more contentious than the refresh of
AT_NO_JUMPS, so I've included it in a separate patch). The patch itself
describes my reasoning, but the shortened version of the premise is that
continer runtimes need to have a way to resolve paths within a
potentially malicious rootfs. Container runtimes currently do this in
userspace[2] which has implicit race conditions that are not resolvable
in userspace (or use fork+exec+chroot and SCM_RIGHTS passing which is
inefficient). AT_THIS_ROOT allows for per-call chroot-like semantics for
path resolution, which would be invaluable for us -- and the
implementation is basically identical to AT_BENEATH (except that we
don't return errors when someone actually hits the root).

I've added some selftests for this, but it's not clear to me whether
they should live here or in xfstests (as far as I can tell there are no
other VFS tests in selftests, while there are some tests that look like
generic VFS tests in xfstests). If you'd prefer them to be included in
xfstests, let me know.

[1]: <a href="https://lore.kernel.org/patchwork/patch/784221/">https://lore.kernel.org/patchwork/patch/784221/</a>
[2]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>

Aleksa Sarai (3):
  namei: implement O_BENEATH-style AT_* flags
  namei: implement AT_THIS_ROOT chroot-like path resolution
  selftests: vfs: add AT_* path resolution tests

 fs/fcntl.c                                    |   2 +-
 fs/namei.c                                    | 158 ++++++++++++------
 fs/open.c                                     |  10 ++
 fs/stat.c                                     |  15 +-
 include/linux/fcntl.h                         |   3 +-
 include/linux/namei.h                         |   8 +
 include/uapi/asm-generic/fcntl.h              |  20 +++
 include/uapi/linux/fcntl.h                    |  10 ++
 tools/testing/selftests/Makefile              |   1 +
 tools/testing/selftests/vfs/.gitignore        |   1 +
 tools/testing/selftests/vfs/Makefile          |  13 ++
 tools/testing/selftests/vfs/at_flags.h        |  40 +++++
 tools/testing/selftests/vfs/common.sh         |  37 ++++
 .../selftests/vfs/tests/0001_at_beneath.sh    |  72 ++++++++
 .../selftests/vfs/tests/0002_at_xdev.sh       |  54 ++++++
 .../vfs/tests/0003_at_no_proclinks.sh         |  50 ++++++
 .../vfs/tests/0004_at_no_symlinks.sh          |  49 ++++++
 .../selftests/vfs/tests/0005_at_this_root.sh  |  66 ++++++++
 tools/testing/selftests/vfs/vfs_helper.c      | 154 +++++++++++++++++
 19 files changed, 707 insertions(+), 56 deletions(-)
 create mode 100644 tools/testing/selftests/vfs/.gitignore
 create mode 100644 tools/testing/selftests/vfs/Makefile
 create mode 100644 tools/testing/selftests/vfs/at_flags.h
 create mode 100644 tools/testing/selftests/vfs/common.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0001_at_beneath.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0002_at_xdev.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0005_at_this_root.sh
 create mode 100644 tools/testing/selftests/vfs/vfs_helper.c

-- 
2.19.0


<a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56" id="eea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">^</a> <a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/">permalink</a> <a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/t/#u">nested</a>] <a href="#rea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">53+ messages in thread</a></pre><hr><pre><a href="#e1383f86e3b88f40c8cb1ba987680029c591c723c" id="m1383f86e3b88f40c8cb1ba987680029c591c723c">*</a> <b>[PATCH 1/3] namei: implement O_BENEATH-style AT_* flags</b>
  2018-09-29 10:34 <a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Aleksa Sarai
<b>@ 2018-09-29 10:34 ` " Aleksa Sarai</b>
  2018-09-29 14:48   ` <a href="#mbb17b5e39af1ab7962ea44cc159ac0b57a3386fd">Christian Brauner</a>
                     ` <a href="#rbb17b5e39af1ab7962ea44cc159ac0b57a3386fd">(2 more replies)</a>
  2018-09-29 13:15 ` <a href="#m90d20073791a183830564405f81c63f760551f20">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Aleksa Sarai
                   ` <a href="#r90d20073791a183830564405f81c63f760551f20">(6 subsequent siblings)</a>
  <a href="#r1383f86e3b88f40c8cb1ba987680029c591c723c">7 siblings, 3 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-09-29 10:34 UTC (<a href="https://lore.kernel.org/lkml/20180929103453.12025-2-cyphar@cyphar.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180929103453.12025-2-cyphar@cyphar.com/raw">raw</a>)
  To: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan
  Cc: David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers, Aleksa Sarai

Add the following flags for path resolution. The primary justification
for these flags is to allow for programs to be far more strict about how
they want path resolution to handle symlinks, mountpoint crossings, and
paths that escape the dirfd (through an absolute path or ".."
shenanigans).

This is of particular concern to container runtimes that want to be very
careful about malicious root filesystems that a container's init might
have screwed around with (and there is no real way to protect against
this in userspace if you consider potential races against a malicious
container's init).

* AT_BENEATH: Disallow ".." or absolute paths (either in the path or
  found during symlink resolution) to escape the starting point of name
  resolution, though ".." is permitted in cases like "foo/../bar".
  Relative symlinks are still allowed (as long as they don't escape the
  starting point).

* AT_XDEV: Disallow mount-point crossing (both *down* into one, or *up*
  from one). The primary "scoping" use is to blocking resolution that
  crosses a bind-mount, which has a similar property to a symlink (in
  the way that it allows for escape from the starting-point). Since it
  is not possible to differentiate bind-mounts However since
  bind-mounting requires privileges (in ways symlinks don't) this has
  been split from LOOKUP_BENEATH. The naming is based on "find -xdev"
  (though find(1) doesn't walk upwards, the semantics seem obvious).

* AT_NO_PROCLINK: Disallows -&gt;get_link "symlink" jumping. This is a very
  specific restriction, and it exists because /proc/$pid/fd/...
  "symlinks" allow for access outside nd-&gt;root and pose risk to
  container runtimes that don't want to be tricked into accessing a host
  path (but do want to allow no-funny-business symlink resolution).

* AT_NO_SYMLINK: Disallows symlink jumping *of any kind*. Implies
  AT_NO_PROCLINK (obviously).

The AT_NO_*LINK flags return -ELOOP if path resolution would violates
their requirement, while the others all return -EXDEV. Currently these
are only enabled for the stat(2) family and the openat(2) family (the
latter has its own brand of O_* flags with the same semantics). Ideally
these flags would be supported by all *at(2) syscalls, but this will
require adding flags arguments to many of them (and will be done in a
separate patchset).

Cc: Andy Lutomirski &lt;luto@kernel.org&gt;
Cc: Eric Biederman &lt;ebiederm@xmission.com&gt;
Cc: Christian Brauner &lt;christian@brauner.io&gt;
Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
---
 <a id="iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:fcntl.c" href="#Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:fcntl.c">fs/fcntl.c                      </a> |  2 +-
 <a id="iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:namei.c" href="#Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:namei.c">fs/namei.c                      </a> | 61 ++++++++++++++++++++++++++------
 <a id="iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:open.c" href="#Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:open.c">fs/open.c                       </a> |  8 +++++
 <a id="iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:stat.c" href="#Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:stat.c">fs/stat.c                       </a> | 13 +++++--
 <a id="iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:linux:fcntl.h" href="#Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:linux:fcntl.h">include/linux/fcntl.h           </a> |  3 +-
 <a id="iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:linux:namei.h" href="#Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:linux:namei.h">include/linux/namei.h           </a> |  7 ++++
 <a id="iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:uapi:asm-generic:fcntl.h" href="#Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:uapi:asm-generic:fcntl.h">include/uapi/asm-generic/fcntl.h</a> | 17 +++++++++
 <a id="iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:uapi:linux:fcntl.h" href="#Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:uapi:linux:fcntl.h">include/uapi/linux/fcntl.h      </a> |  8 +++++
 8 files changed, 104 insertions(+), 15 deletions(-)

<span><a href="#iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:fcntl.c" id="Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:fcntl.c">diff</a> --git a/fs/fcntl.c b/fs/fcntl.c
index 4137d96534a6..e343618736f7 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
</span><span>@@ -1031,7 +1031,7 @@</span> static int __init fcntl_init(void)
 	 * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
 	 * is defined as O_NONBLOCK on some platforms and not on others.
 	 */
<span>-	BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
</span><span>+	BUILD_BUG_ON(25 - 1 /* for O_RDONLY being 0 */ !=
</span> 		HWEIGHT32(
 			(VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
 			__FMODE_EXEC | __FMODE_NONOTIFY));
<span><a href="#iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:namei.c" id="Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:namei.c">diff</a> --git a/fs/namei.c b/fs/namei.c
index fb913148d4d1..757dd783771c 100644
--- a/fs/namei.c
+++ b/fs/namei.c
</span><span>@@ -859,6 +859,8 @@</span> static int nd_jump_root(struct nameidata *nd)
 		path_get(&amp;nd-&gt;path);
 		nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
 	}
<span>+	if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH))
+		return -EXDEV;
</span> 	nd-&gt;flags |= LOOKUP_JUMPED;
 	return 0;
 }
<span>@@ -1083,14 +1085,19 @@</span> const char *get_link(struct nameidata *nd)
 		} else {
 			res = get(dentry, inode, &amp;last-&gt;done);
 		}
<span>+		/* If we just jumped it was because of a procfs-style link. */
+		if (unlikely(nd-&gt;flags &amp; LOOKUP_JUMPED) &amp;&amp;
+		    unlikely(nd-&gt;flags &amp; LOOKUP_NO_PROCLINKS))
+			return ERR_PTR(-ELOOP);
</span> 		if (IS_ERR_OR_NULL(res))
 			return res;
 	}
 	if (*res == '/') {
 		if (!nd-&gt;root.mnt)
 			set_root(nd);
<span>-		if (unlikely(nd_jump_root(nd)))
-			return ERR_PTR(-ECHILD);
</span><span>+		error = nd_jump_root(nd);
+		if (unlikely(error))
+			return ERR_PTR(error);
</span> 		while (unlikely(*++res == '/'))
 			;
 	}
<span>@@ -1271,12 +1278,16 @@</span> static int follow_managed(struct path *path, struct nameidata *nd)
 		break;
 	}
 
<span>-	if (need_mntput &amp;&amp; path-&gt;mnt == mnt)
-		mntput(path-&gt;mnt);
</span><span>+	if (need_mntput) {
+		if (path-&gt;mnt == mnt)
+			mntput(path-&gt;mnt);
+		if (unlikely(nd-&gt;flags &amp; LOOKUP_XDEV))
+			ret = -EXDEV;
+		else
+			nd-&gt;flags |= LOOKUP_JUMPED;
+	}
</span> 	if (ret == -EISDIR || !ret)
 		ret = 1;
<span>-	if (need_mntput)
-		nd-&gt;flags |= LOOKUP_JUMPED;
</span> 	if (unlikely(ret &lt; 0))
 		path_put_conditional(path, nd);
 	return ret;
<span>@@ -1333,6 +1344,8 @@</span> static bool __follow_mount_rcu(struct nameidata *nd, struct path *path,
 		mounted = __lookup_mnt(path-&gt;mnt, path-&gt;dentry);
 		if (!mounted)
 			break;
<span>+		if (unlikely(nd-&gt;flags &amp; LOOKUP_XDEV))
+			return false;
</span> 		path-&gt;mnt = &amp;mounted-&gt;mnt;
 		path-&gt;dentry = mounted-&gt;mnt.mnt_root;
 		nd-&gt;flags |= LOOKUP_JUMPED;
<span>@@ -1353,8 +1366,11 @@</span> static int follow_dotdot_rcu(struct nameidata *nd)
 	struct inode *inode = nd-&gt;inode;
 
 	while (1) {
<span>-		if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root))
</span><span>+		if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) {
+			if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH))
+				return -EXDEV;
</span> 			break;
<span>+		}
</span> 		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
 			struct dentry *old = nd-&gt;path.dentry;
 			struct dentry *parent = old-&gt;d_parent;
<span>@@ -1379,6 +1395,8 @@</span> static int follow_dotdot_rcu(struct nameidata *nd)
 				return -ECHILD;
 			if (&amp;mparent-&gt;mnt == nd-&gt;path.mnt)
 				break;
<span>+			if (unlikely(nd-&gt;flags &amp; LOOKUP_XDEV))
+				return -EXDEV;
</span> 			/* we know that mountpoint was pinned */
 			nd-&gt;path.dentry = mountpoint;
 			nd-&gt;path.mnt = &amp;mparent-&gt;mnt;
<span>@@ -1481,8 +1499,11 @@</span> static int path_parent_directory(struct path *path)
 static int follow_dotdot(struct nameidata *nd)
 {
 	while(1) {
<span>-		if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root))
</span><span>+		if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) {
+			if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH))
+				return -EXDEV;
</span> 			break;
<span>+		}
</span> 		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
 			int ret = path_parent_directory(&amp;nd-&gt;path);
 			if (ret)
<span>@@ -1491,6 +1512,8 @@</span> static int follow_dotdot(struct nameidata *nd)
 		}
 		if (!follow_up(&amp;nd-&gt;path))
 			break;
<span>+		if (unlikely(nd-&gt;flags &amp; LOOKUP_XDEV))
+			return -EXDEV;
</span> 	}
 	follow_mount(&amp;nd-&gt;path);
 	nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
<span>@@ -1720,6 +1743,8 @@</span> static int pick_link(struct nameidata *nd, struct path *link,
 {
 	int error;
 	struct saved *last;
<span>+	if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_SYMLINKS))
+		return -ELOOP;
</span> 	if (unlikely(nd-&gt;total_link_count++ &gt;= MAXSYMLINKS)) {
 		path_to_nameidata(link, nd);
 		return -ELOOP;
<span>@@ -2175,6 +2200,8 @@</span> static const char *path_init(struct nameidata *nd, unsigned flags)
 
 	if (!*s)
 		flags &amp;= ~LOOKUP_RCU;
<span>+	if (flags &amp; LOOKUP_NO_SYMLINKS)
+		flags |= LOOKUP_NO_PROCLINKS;
</span> 	if (flags &amp; LOOKUP_RCU)
 		rcu_read_lock();
 
<span>@@ -2204,10 +2231,12 @@</span> static const char *path_init(struct nameidata *nd, unsigned flags)
 
 	nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
 	if (*s == '/') {
<span>+		int error;
</span> 		set_root(nd);
<span>-		if (likely(!nd_jump_root(nd)))
-			return s;
-		return ERR_PTR(-ECHILD);
</span><span>+		error = nd_jump_root(nd);
+		if (unlikely(error))
+			s = ERR_PTR(error);
+		return s;
</span> 	} else if (nd-&gt;dfd == AT_FDCWD) {
 		if (flags &amp; LOOKUP_RCU) {
 			struct fs_struct *fs = current-&gt;fs;
<span>@@ -2223,6 +2252,11 @@</span> static const char *path_init(struct nameidata *nd, unsigned flags)
 			get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path);
 			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
 		}
<span>+		if (unlikely(flags &amp; LOOKUP_BENEATH)) {
+			nd-&gt;root = nd-&gt;path;
+			if (!(flags &amp; LOOKUP_RCU))
+				path_get(&amp;nd-&gt;root);
+		}
</span> 		return s;
 	} else {
 		/* Caller must check execute permissions on the starting path component */
<span>@@ -2247,6 +2281,11 @@</span> static const char *path_init(struct nameidata *nd, unsigned flags)
 			path_get(&amp;nd-&gt;path);
 			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
 		}
<span>+		if (unlikely(flags &amp; LOOKUP_BENEATH)) {
+			nd-&gt;root = nd-&gt;path;
+			if (!(flags &amp; LOOKUP_RCU))
+				path_get(&amp;nd-&gt;root);
+		}
</span> 		fdput(f);
 		return s;
 	}
<span><a href="#iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:open.c" id="Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:open.c">diff</a> --git a/fs/open.c b/fs/open.c
index 0285ce7dbd51..80f5f566a5ff 100644
--- a/fs/open.c
+++ b/fs/open.c
</span><span>@@ -988,6 +988,14 @@</span> static inline int build_open_flags(int flags, umode_t mode, struct open_flags *o
 		lookup_flags |= LOOKUP_DIRECTORY;
 	if (!(flags &amp; O_NOFOLLOW))
 		lookup_flags |= LOOKUP_FOLLOW;
<span>+	if (flags &amp; O_BENEATH)
+		lookup_flags |= LOOKUP_BENEATH;
+	if (flags &amp; O_XDEV)
+		lookup_flags |= LOOKUP_XDEV;
+	if (flags &amp; O_NOPROCLINKS)
+		lookup_flags |= LOOKUP_NO_PROCLINKS;
+	if (flags &amp; O_NOSYMLINKS)
+		lookup_flags |= LOOKUP_NO_SYMLINKS;
</span> 	op-&gt;lookup_flags = lookup_flags;
 	return 0;
 }
<span><a href="#iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:stat.c" id="Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0fs:stat.c">diff</a> --git a/fs/stat.c b/fs/stat.c
index f8e6fb2c3657..791e61b916ae 100644
--- a/fs/stat.c
+++ b/fs/stat.c
</span><span>@@ -170,8 +170,9 @@</span> int vfs_statx(int dfd, const char __user *filename, int flags,
 	int error = -EINVAL;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;
 
<span>-	if ((flags &amp; ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
-		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
</span><span>+	if (flags &amp; ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT | AT_EMPTY_PATH |
+		      KSTAT_QUERY_FLAGS | AT_BENEATH | AT_XDEV |
+		      AT_NO_PROCLINKS | AT_NO_SYMLINKS))
</span> 		return -EINVAL;
 
 	if (flags &amp; AT_SYMLINK_NOFOLLOW)
<span>@@ -180,6 +181,14 @@</span> int vfs_statx(int dfd, const char __user *filename, int flags,
 		lookup_flags &amp;= ~LOOKUP_AUTOMOUNT;
 	if (flags &amp; AT_EMPTY_PATH)
 		lookup_flags |= LOOKUP_EMPTY;
<span>+	if (flags &amp; AT_BENEATH)
+		lookup_flags |= LOOKUP_BENEATH;
+	if (flags &amp; AT_XDEV)
+		lookup_flags |= LOOKUP_XDEV;
+	if (flags &amp; AT_NO_PROCLINKS)
+		lookup_flags |= LOOKUP_NO_PROCLINKS;
+	if (flags &amp; AT_NO_SYMLINKS)
+		lookup_flags |= LOOKUP_NO_SYMLINKS;
</span> 
 retry:
 	error = user_path_at(dfd, filename, lookup_flags, &amp;path);
<span><a href="#iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:linux:fcntl.h" id="Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:linux:fcntl.h">diff</a> --git a/include/linux/fcntl.h b/include/linux/fcntl.h
index 27dc7a60693e..ad5bba4b5b12 100644
--- a/include/linux/fcntl.h
+++ b/include/linux/fcntl.h
</span><span>@@ -9,7 +9,8 @@</span>
 	(O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
 	 O_APPEND | O_NDELAY | O_NONBLOCK | O_NDELAY | __O_SYNC | O_DSYNC | \
 	 FASYNC	| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
<span>-	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
</span><span>+	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_BENEATH | O_XDEV | \
+	 O_NOPROCLINKS | O_NOSYMLINKS)
</span> 
 #ifndef force_o_largefile
 #define force_o_largefile() (BITS_PER_LONG != 32)
<span><a href="#iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:linux:namei.h" id="Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:linux:namei.h">diff</a> --git a/include/linux/namei.h b/include/linux/namei.h
index a78606e8e3df..5ff7f3362d1b 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
</span><span>@@ -47,6 +47,13 @@</span> enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_EMPTY		0x4000
 #define LOOKUP_DOWN		0x8000
 
<span>+/* Scoping flags for lookup. */
+#define LOOKUP_BENEATH		0x010000 /* No escaping from starting point. */
+#define LOOKUP_XDEV		0x020000 /* No mountpoint crossing. */
+#define LOOKUP_NO_PROCLINKS	0x040000 /* No /proc/$pid/fd/ "symlink" crossing. */
+#define LOOKUP_NO_SYMLINKS	0x080000 /* No symlink crossing *at all*.
+					    Implies LOOKUP_NO_PROCLINKS. */
+
</span> extern int path_pts(struct path *path);
 
 extern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);
<span><a href="#iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:uapi:asm-generic:fcntl.h" id="Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:uapi:asm-generic:fcntl.h">diff</a> --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
index 9dc0bf0c5a6e..c2bf5983e46a 100644
--- a/include/uapi/asm-generic/fcntl.h
+++ b/include/uapi/asm-generic/fcntl.h
</span><span>@@ -97,6 +97,23 @@</span>
 #define O_NDELAY	O_NONBLOCK
 #endif
 
<span>+/*
+ * These are identical to their AT_* counterparts (which affect the entireity
+ * of path resolution).
+ */
+#ifndef O_BENEATH
+#define O_BENEATH	00040000000 /* *Not* the same as capsicum's O_BENEATH! */
+#endif
+#ifndef O_XDEV
+#define O_XDEV		00100000000
+#endif
+#ifndef O_NOPROCLINKS
+#define O_NOPROCLINKS	00200000000
+#endif
+#ifndef O_NOSYMLINKS
+#define O_NOSYMLINKS	01000000000
+#endif
+
</span> #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get close_on_exec */
 #define F_SETFD		2	/* set/clear close_on_exec */
<span><a href="#iZ2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:uapi:linux:fcntl.h" id="Z2e.:..:20180929103453.12025-2-cyphar::40cyphar.com:0include:uapi:linux:fcntl.h">diff</a> --git a/include/uapi/linux/fcntl.h b/include/uapi/linux/fcntl.h
index 594b85f7cb86..551a9e2166a8 100644
--- a/include/uapi/linux/fcntl.h
+++ b/include/uapi/linux/fcntl.h
</span><span>@@ -92,5 +92,13 @@</span>
 
 #define AT_RECURSIVE		0x8000	/* Apply to the entire subtree */
 
<span>+/* Flags which affect path *resolution*, not just last-component handling. */
+#define AT_BENEATH		0x10000	/* No absolute paths or ".." escaping
+					   (in-path or through symlinks) */
+#define AT_XDEV			0x20000 /* No mountpoint crossing. */
+#define AT_NO_PROCLINKS		0x40000 /* No /proc/$pid/fd/... "symlinks". */
+#define AT_NO_SYMLINKS		0x80000 /* No symlinks *at all*.
+					   Implies AT_NO_PROCLINKS. */
+
</span> 
 #endif /* _UAPI_LINUX_FCNTL_H */
-- 
2.19.0


<a href="#m1383f86e3b88f40c8cb1ba987680029c591c723c" id="e1383f86e3b88f40c8cb1ba987680029c591c723c">^</a> <a href="https://lore.kernel.org/lkml/20180929103453.12025-2-cyphar@cyphar.com/">permalink</a> <a href="https://lore.kernel.org/lkml/20180929103453.12025-2-cyphar@cyphar.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180929103453.12025-2-cyphar@cyphar.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180929103453.12025-2-cyphar@cyphar.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180929103453.12025-2-cyphar@cyphar.com/t/#u">nested</a>] <a href="#r1383f86e3b88f40c8cb1ba987680029c591c723c">53+ messages in thread</a></pre><hr><pre><a href="#e90d20073791a183830564405f81c63f760551f20" id="m90d20073791a183830564405f81c63f760551f20">*</a> <b>[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-09-29 10:34 <a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Aleksa Sarai
  2018-09-29 10:34 ` <a href="#m1383f86e3b88f40c8cb1ba987680029c591c723c">[PATCH 1/3] namei: implement O_BENEATH-style</a> " Aleksa Sarai
<b>@ 2018-09-29 13:15 ` Aleksa Sarai</b>
  2018-09-29 13:15   ` <a href="#m1e8d6e44df122828245b146d8d64b9d8a03ac028">[PATCH 3/3] selftests: vfs: add AT_* path resolution tests</a> Aleksa Sarai
  2018-09-29 16:35   ` <a href="#m85db30139fa0747cca01a4a7b71ba3f88ab3207c">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Jann Horn
  2018-09-29 14:25 ` <a href="#m3b43f05d63e0487bb74cc85c7a6b88ae1782756d">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Andy Lutomirski
                   ` <a href="#r3b43f05d63e0487bb74cc85c7a6b88ae1782756d">(5 subsequent siblings)</a>
  <a href="#r90d20073791a183830564405f81c63f760551f20">7 siblings, 2 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-09-29 13:15 UTC (<a href="https://lore.kernel.org/lkml/20180929131534.24472-1-cyphar@cyphar.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180929131534.24472-1-cyphar@cyphar.com/raw">raw</a>)
  To: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan
  Cc: David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers, Aleksa Sarai

The primary motivation for the need for this flag is container runtimes
which have to interact with malicious root filesystems in the host
namespaces. One of the first requirements for a container runtime to be
secure against a malicious rootfs is that they correctly scope symlinks
(that is, they should be scoped as though they are chroot(2)ed into the
container's rootfs) and ".."-style paths. The already-existing AT_XDEV
and AT_NO_PROCLINKS help defend against other potential attacks in a
malicious rootfs scenario.

Currently most container runtimes try to do this resolution in
userspace[1], causing many potential race conditions. In addition, the
"obvious" alternative (actually performing a {ch,pivot_}root(2))
requires a fork+exec which is *very* costly if necessary for every
filesystem operation involving a container.

The most significant change in semantics with AT_THIS_ROOT is that
*at(2) syscalls now no longer have the property that an absolute
pathname causes the dirfd to be ignored completely (if LOOKUP_CHROOT is
specified). The reasoning behind this is that AT_THIS_ROOT necessarily
has to chroot-scope symlinks with absolute paths to dirfd, and so doing
it for the base path seems to be the most consistent behaviour (and also
avoids foot-gunning users who want to chroot-scope paths that might be
absolute).

Currently this is only enabled for the stat(2) and openat(2) family (the
latter has its own flag O_THISROOT with the same semantics). Ideally
this flag would be supported by all *at(2) syscalls, but this will
require adding flags arguments to many of them (and will be done in a
separate patchset).

[1]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>

Cc: Eric Biederman &lt;ebiederm@xmission.com&gt;
Cc: Christian Brauner &lt;christian@brauner.io&gt;
Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
---
 <a id="iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:fcntl.c" href="#Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:fcntl.c">fs/fcntl.c                      </a> |   2 +-
 <a id="iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:namei.c" href="#Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:namei.c">fs/namei.c                      </a> | 121 +++++++++++++++++--------------
 <a id="iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:open.c" href="#Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:open.c">fs/open.c                       </a> |   2 +
 <a id="iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:stat.c" href="#Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:stat.c">fs/stat.c                       </a> |   4 +-
 <a id="iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:linux:fcntl.h" href="#Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:linux:fcntl.h">include/linux/fcntl.h           </a> |   2 +-
 <a id="iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:linux:namei.h" href="#Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:linux:namei.h">include/linux/namei.h           </a> |   1 +
 <a id="iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:uapi:asm-generic:fcntl.h" href="#Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:uapi:asm-generic:fcntl.h">include/uapi/asm-generic/fcntl.h</a> |   3 +
 <a id="iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:uapi:linux:fcntl.h" href="#Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:uapi:linux:fcntl.h">include/uapi/linux/fcntl.h      </a> |   2 +
 8 files changed, 81 insertions(+), 56 deletions(-)

<span><a href="#iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:fcntl.c" id="Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:fcntl.c">diff</a> --git a/fs/fcntl.c b/fs/fcntl.c
index e343618736f7..4c36c5b9fdb9 100644
--- a/fs/fcntl.c
+++ b/fs/fcntl.c
</span><span>@@ -1031,7 +1031,7 @@</span> static int __init fcntl_init(void)
 	 * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
 	 * is defined as O_NONBLOCK on some platforms and not on others.
 	 */
<span>-	BUILD_BUG_ON(25 - 1 /* for O_RDONLY being 0 */ !=
</span><span>+	BUILD_BUG_ON(26 - 1 /* for O_RDONLY being 0 */ !=
</span> 		HWEIGHT32(
 			(VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
 			__FMODE_EXEC | __FMODE_NONOTIFY));
<span><a href="#iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:namei.c" id="Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:namei.c">diff</a> --git a/fs/namei.c b/fs/namei.c
index 757dd783771c..1b984f0dbbb4 100644
--- a/fs/namei.c
+++ b/fs/namei.c
</span><span>@@ -2193,9 +2193,64 @@</span> static int link_path_walk(const char *name, struct nameidata *nd)
 	}
 }
 
<span>+/*
+ * Configure nd-&gt;path based on the nd-&gt;dfd. This is only used as part of
+ * path_init().
+ */
+static inline int dirfd_path_init(struct nameidata *nd)
+{
+	if (nd-&gt;dfd == AT_FDCWD) {
+		if (nd-&gt;flags &amp; LOOKUP_RCU) {
+			struct fs_struct *fs = current-&gt;fs;
+			unsigned seq;
+
+			do {
+				seq = read_seqcount_begin(&amp;fs-&gt;seq);
+				nd-&gt;path = fs-&gt;pwd;
+				nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
+				nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
+			} while (read_seqcount_retry(&amp;fs-&gt;seq, seq));
+		} else {
+			get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path);
+			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
+		}
+	} else {
+		/* Caller must check execute permissions on the starting path component */
+		struct fd f = fdget_raw(nd-&gt;dfd);
+		struct dentry *dentry;
+
+		if (!f.file)
+			return -EBADF;
+
+		dentry = f.file-&gt;f_path.dentry;
+
+		if (*nd-&gt;name-&gt;name &amp;&amp; unlikely(!d_can_lookup(dentry))) {
+			fdput(f);
+			return -ENOTDIR;
+		}
+
+		nd-&gt;path = f.file-&gt;f_path;
+		if (nd-&gt;flags &amp; LOOKUP_RCU) {
+			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
+			nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
+		} else {
+			path_get(&amp;nd-&gt;path);
+			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
+		}
+		fdput(f);
+	}
+	if (unlikely(nd-&gt;flags &amp; (LOOKUP_CHROOT | LOOKUP_BENEATH))) {
+		nd-&gt;root = nd-&gt;path;
+		if (!(nd-&gt;flags &amp; LOOKUP_RCU))
+			path_get(&amp;nd-&gt;root);
+	}
+	return 0;
+}
+
</span> /* must be paired with terminate_walk() */
 static const char *path_init(struct nameidata *nd, unsigned flags)
 {
<span>+	int error;
</span> 	const char *s = nd-&gt;name-&gt;name;
 
 	if (!*s)
<span>@@ -2230,65 +2285,25 @@</span> static const char *path_init(struct nameidata *nd, unsigned flags)
 	nd-&gt;path.dentry = NULL;
 
 	nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
<span>+	if (unlikely(flags &amp; LOOKUP_CHROOT)) {
+		error = dirfd_path_init(nd);
+		if (unlikely(error))
+			return ERR_PTR(error);
+	}
</span> 	if (*s == '/') {
<span>-		int error;
-		set_root(nd);
</span><span>+		if (likely(!nd-&gt;root.mnt))
+			set_root(nd);
</span> 		error = nd_jump_root(nd);
 		if (unlikely(error))
 			s = ERR_PTR(error);
 		return s;
<span>-	} else if (nd-&gt;dfd == AT_FDCWD) {
-		if (flags &amp; LOOKUP_RCU) {
-			struct fs_struct *fs = current-&gt;fs;
-			unsigned seq;
-
-			do {
-				seq = read_seqcount_begin(&amp;fs-&gt;seq);
-				nd-&gt;path = fs-&gt;pwd;
-				nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
-				nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
-			} while (read_seqcount_retry(&amp;fs-&gt;seq, seq));
-		} else {
-			get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path);
-			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
-		}
-		if (unlikely(flags &amp; LOOKUP_BENEATH)) {
-			nd-&gt;root = nd-&gt;path;
-			if (!(flags &amp; LOOKUP_RCU))
-				path_get(&amp;nd-&gt;root);
-		}
-		return s;
-	} else {
-		/* Caller must check execute permissions on the starting path component */
-		struct fd f = fdget_raw(nd-&gt;dfd);
-		struct dentry *dentry;
-
-		if (!f.file)
-			return ERR_PTR(-EBADF);
-
-		dentry = f.file-&gt;f_path.dentry;
-
-		if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) {
-			fdput(f);
-			return ERR_PTR(-ENOTDIR);
-		}
-
-		nd-&gt;path = f.file-&gt;f_path;
-		if (flags &amp; LOOKUP_RCU) {
-			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
-			nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
-		} else {
-			path_get(&amp;nd-&gt;path);
-			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
-		}
-		if (unlikely(flags &amp; LOOKUP_BENEATH)) {
-			nd-&gt;root = nd-&gt;path;
-			if (!(flags &amp; LOOKUP_RCU))
-				path_get(&amp;nd-&gt;root);
-		}
-		fdput(f);
-		return s;
</span> 	}
<span>+	if (likely(!nd-&gt;path.mnt)) {
+		error = dirfd_path_init(nd);
+		if (unlikely(error))
+			return ERR_PTR(error);
+	}
+	return s;
</span> }
 
 static const char *trailing_symlink(struct nameidata *nd)
<span><a href="#iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:open.c" id="Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:open.c">diff</a> --git a/fs/open.c b/fs/open.c
index 80f5f566a5ff..81d148f626cd 100644
--- a/fs/open.c
+++ b/fs/open.c
</span><span>@@ -996,6 +996,8 @@</span> static inline int build_open_flags(int flags, umode_t mode, struct open_flags *o
 		lookup_flags |= LOOKUP_NO_PROCLINKS;
 	if (flags &amp; O_NOSYMLINKS)
 		lookup_flags |= LOOKUP_NO_SYMLINKS;
<span>+	if (flags &amp; O_THISROOT)
+		lookup_flags |= LOOKUP_CHROOT;
</span> 	op-&gt;lookup_flags = lookup_flags;
 	return 0;
 }
<span><a href="#iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:stat.c" id="Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0fs:stat.c">diff</a> --git a/fs/stat.c b/fs/stat.c
index 791e61b916ae..e8366e4812c3 100644
--- a/fs/stat.c
+++ b/fs/stat.c
</span><span>@@ -172,7 +172,7 @@</span> int vfs_statx(int dfd, const char __user *filename, int flags,
 
 	if (flags &amp; ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT | AT_EMPTY_PATH |
 		      KSTAT_QUERY_FLAGS | AT_BENEATH | AT_XDEV |
<span>-		      AT_NO_PROCLINKS | AT_NO_SYMLINKS))
</span><span>+		      AT_NO_PROCLINKS | AT_NO_SYMLINKS | AT_THIS_ROOT))
</span> 		return -EINVAL;
 
 	if (flags &amp; AT_SYMLINK_NOFOLLOW)
<span>@@ -189,6 +189,8 @@</span> int vfs_statx(int dfd, const char __user *filename, int flags,
 		lookup_flags |= LOOKUP_NO_PROCLINKS;
 	if (flags &amp; AT_NO_SYMLINKS)
 		lookup_flags |= LOOKUP_NO_SYMLINKS;
<span>+	if (flags &amp; AT_THIS_ROOT)
+		lookup_flags |= LOOKUP_CHROOT;
</span> 
 retry:
 	error = user_path_at(dfd, filename, lookup_flags, &amp;path);
<span><a href="#iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:linux:fcntl.h" id="Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:linux:fcntl.h">diff</a> --git a/include/linux/fcntl.h b/include/linux/fcntl.h
index ad5bba4b5b12..95480cd4c09d 100644
--- a/include/linux/fcntl.h
+++ b/include/linux/fcntl.h
</span><span>@@ -10,7 +10,7 @@</span>
 	 O_APPEND | O_NDELAY | O_NONBLOCK | O_NDELAY | __O_SYNC | O_DSYNC | \
 	 FASYNC	| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
 	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_BENEATH | O_XDEV | \
<span>-	 O_NOPROCLINKS | O_NOSYMLINKS)
</span><span>+	 O_NOPROCLINKS | O_NOSYMLINKS | O_THISROOT)
</span> 
 #ifndef force_o_largefile
 #define force_o_largefile() (BITS_PER_LONG != 32)
<span><a href="#iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:linux:namei.h" id="Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:linux:namei.h">diff</a> --git a/include/linux/namei.h b/include/linux/namei.h
index 5ff7f3362d1b..7ec9e2d84649 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
</span><span>@@ -53,6 +53,7 @@</span> enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
 #define LOOKUP_NO_PROCLINKS	0x040000 /* No /proc/$pid/fd/ "symlink" crossing. */
 #define LOOKUP_NO_SYMLINKS	0x080000 /* No symlink crossing *at all*.
 					    Implies LOOKUP_NO_PROCLINKS. */
<span>+#define LOOKUP_CHROOT		0x100000 /* Treat dirfd as %current-&gt;fs-&gt;root. */
</span> 
 extern int path_pts(struct path *path);
 
<span><a href="#iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:uapi:asm-generic:fcntl.h" id="Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:uapi:asm-generic:fcntl.h">diff</a> --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
index c2bf5983e46a..11206b0e927c 100644
--- a/include/uapi/asm-generic/fcntl.h
+++ b/include/uapi/asm-generic/fcntl.h
</span><span>@@ -113,6 +113,9 @@</span>
 #ifndef O_NOSYMLINKS
 #define O_NOSYMLINKS	01000000000
 #endif
<span>+#ifndef O_THISROOT
+#define O_THISROOT	02000000000
+#endif
</span> 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get close_on_exec */
<span><a href="#iZ2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:uapi:linux:fcntl.h" id="Z2e.:..:20180929131534.24472-1-cyphar::40cyphar.com:0include:uapi:linux:fcntl.h">diff</a> --git a/include/uapi/linux/fcntl.h b/include/uapi/linux/fcntl.h
index 551a9e2166a8..ea978457b68f 100644
--- a/include/uapi/linux/fcntl.h
+++ b/include/uapi/linux/fcntl.h
</span><span>@@ -99,6 +99,8 @@</span>
 #define AT_NO_PROCLINKS		0x40000 /* No /proc/$pid/fd/... "symlinks". */
 #define AT_NO_SYMLINKS		0x80000 /* No symlinks *at all*.
 					   Implies AT_NO_PROCLINKS. */
<span>+#define AT_THIS_ROOT		0x100000 /* Path resolution acts as though
+					   it is chroot-ed into dirfd. */
</span> 
 
 #endif /* _UAPI_LINUX_FCNTL_H */
-- 
2.19.0


<a href="#m90d20073791a183830564405f81c63f760551f20" id="e90d20073791a183830564405f81c63f760551f20">^</a> <a href="https://lore.kernel.org/lkml/20180929131534.24472-1-cyphar@cyphar.com/">permalink</a> <a href="https://lore.kernel.org/lkml/20180929131534.24472-1-cyphar@cyphar.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180929131534.24472-1-cyphar@cyphar.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180929131534.24472-1-cyphar@cyphar.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180929131534.24472-1-cyphar@cyphar.com/t/#u">nested</a>] <a href="#r90d20073791a183830564405f81c63f760551f20">53+ messages in thread</a></pre><hr><pre><a href="#e1e8d6e44df122828245b146d8d64b9d8a03ac028" id="m1e8d6e44df122828245b146d8d64b9d8a03ac028">*</a> <b>[PATCH 3/3] selftests: vfs: add AT_* path resolution tests</b>
  2018-09-29 13:15 ` <a href="#m90d20073791a183830564405f81c63f760551f20">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Aleksa Sarai
<b>@ 2018-09-29 13:15   ` Aleksa Sarai</b>
  2018-09-29 16:35   ` <a href="#m85db30139fa0747cca01a4a7b71ba3f88ab3207c">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Jann Horn
  <a href="#r1e8d6e44df122828245b146d8d64b9d8a03ac028">1 sibling, 0 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-09-29 13:15 UTC (<a href="https://lore.kernel.org/lkml/20180929131534.24472-2-cyphar@cyphar.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180929131534.24472-2-cyphar@cyphar.com/raw">raw</a>)
  To: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan
  Cc: David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers, Aleksa Sarai

With the addition of so many new scoping flags, it's necessary to have
some sort of validation that they really work. There were no vfs
self-tests in the past, so this also includes a basic framework that
future VFS tests can use.

Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
---
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:Makefile" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:Makefile">tools/testing/selftests/Makefile             </a> |   1 +
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:.gitignore" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:.gitignore">tools/testing/selftests/vfs/.gitignore       </a> |   1 +
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:Makefile" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:Makefile">tools/testing/selftests/vfs/Makefile         </a> |  13 ++
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:at_flags.h" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:at_flags.h">tools/testing/selftests/vfs/at_flags.h       </a> |  40 +++++
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:common.sh" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:common.sh">tools/testing/selftests/vfs/common.sh        </a> |  37 +++++
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0001_at_beneath.sh" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0001_at_beneath.sh">.../selftests/vfs/tests/0001_at_beneath.sh   </a> |  72 ++++++++
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0002_at_xdev.sh" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0002_at_xdev.sh">.../selftests/vfs/tests/0002_at_xdev.sh      </a> |  54 ++++++
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0vfs:tests:0003_at_no_proclinks.sh" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0vfs:tests:0003_at_no_proclinks.sh">.../vfs/tests/0003_at_no_proclinks.sh        </a> |  50 ++++++
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0vfs:tests:0004_at_no_symlinks.sh" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0vfs:tests:0004_at_no_symlinks.sh">.../vfs/tests/0004_at_no_symlinks.sh         </a> |  49 ++++++
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0005_at_this_root.sh" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0005_at_this_root.sh">.../selftests/vfs/tests/0005_at_this_root.sh </a> |  66 ++++++++
 <a id="iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:vfs_helper.c" href="#Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:vfs_helper.c">tools/testing/selftests/vfs/vfs_helper.c     </a> | 154 ++++++++++++++++++
 11 files changed, 537 insertions(+)
 create mode 100644 tools/testing/selftests/vfs/.gitignore
 create mode 100644 tools/testing/selftests/vfs/Makefile
 create mode 100644 tools/testing/selftests/vfs/at_flags.h
 create mode 100644 tools/testing/selftests/vfs/common.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0001_at_beneath.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0002_at_xdev.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
 create mode 100755 tools/testing/selftests/vfs/tests/0005_at_this_root.sh
 create mode 100644 tools/testing/selftests/vfs/vfs_helper.c

<span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:Makefile" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:Makefile">diff</a> --git a/tools/testing/selftests/Makefile b/tools/testing/selftests/Makefile
index f1fe492c8e17..6f814e49071f 100644
--- a/tools/testing/selftests/Makefile
+++ b/tools/testing/selftests/Makefile
</span><span>@@ -43,6 +43,7 @@</span> ifneq (1, $(quicktest))
 TARGETS += timers
 endif
 TARGETS += user
<span>+TARGETS += vfs
</span> TARGETS += vm
 TARGETS += x86
 TARGETS += zram
<span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:.gitignore" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:.gitignore">diff</a> --git a/tools/testing/selftests/vfs/.gitignore b/tools/testing/selftests/vfs/.gitignore
new file mode 100644
index 000000000000..c57ebcba14c0
--- /dev/null
+++ b/tools/testing/selftests/vfs/.gitignore
</span><span>@@ -0,0 +1 @@</span>
<span>+/vfs_helper
</span><span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:Makefile" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:Makefile">diff</a> --git a/tools/testing/selftests/vfs/Makefile b/tools/testing/selftests/vfs/Makefile
new file mode 100644
index 000000000000..8ca3cef43dc3
--- /dev/null
+++ b/tools/testing/selftests/vfs/Makefile
</span><span>@@ -0,0 +1,13 @@</span>
<span>+# SPDX-License-Identifier: GPL-2.0+
+# Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
+# Copyright (C) 2018 SUSE LLC.
+
+# Makefile for mount selftests.
+CFLAGS = -Wall \
+         -O2 \
+         -I../../../../usr/include/
+
+TEST_PROGS := $(wildcard tests/*.sh)
+TEST_GEN_FILES := vfs_helper
+
+include ../lib.mk
</span><span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:at_flags.h" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:at_flags.h">diff</a> --git a/tools/testing/selftests/vfs/at_flags.h b/tools/testing/selftests/vfs/at_flags.h
new file mode 100644
index 000000000000..a8ca8f689753
--- /dev/null
+++ b/tools/testing/selftests/vfs/at_flags.h
</span><span>@@ -0,0 +1,40 @@</span>
<span>+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
+ * Copyright (C) 2018 SUSE LLC.
+ */
+
+#ifndef __AT_FLAGS_H__
+#define __AT_FLAGS_H__
+
+/* These come from &lt;uapi/asm-generic/linux/fcntl.h&gt; */
+#ifndef O_BENEATH
+# define O_BENEATH	00040000000
+# define O_XDEV		00100000000
+# define O_NOPROCLINKS	00200000000
+# define O_NOSYMLINKS	01000000000
+# define O_THISROOT	02000000000
+#endif
+#ifndef AT_BENEATH
+# define AT_BENEATH		0x8000
+# define AT_XDEV		0x10000
+# define AT_NO_PROCLINKS	0x20000
+# define AT_NO_SYMLINKS		0x40000
+# define AT_THIS_ROOT		0x80000
+#endif
+
+struct flag {
+	const char *name;
+	unsigned int at_flag, open_flag;
+};
+
+struct flag AT_FLAGS[] = {
+	{ .name = "beneath",	  .at_flag = AT_BENEATH,      .open_flag = O_BENEATH },
+	{ .name = "xdev",	  .at_flag = AT_XDEV,	      .open_flag = O_XDEV },
+	{ .name = "no_proclinks", .at_flag = AT_NO_PROCLINKS, .open_flag = O_NOPROCLINKS },
+	{ .name = "no_symlinks",  .at_flag = AT_NO_SYMLINKS,  .open_flag = O_NOSYMLINKS },
+	{ .name = "this_root",	  .at_flag = AT_THIS_ROOT, .open_flag = O_THISROOT },
+	{ 0 }, /* terminate */
+};
+
+#endif /* !defined(__AT_FLAGS_H__) */
</span><span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:common.sh" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:common.sh">diff</a> --git a/tools/testing/selftests/vfs/common.sh b/tools/testing/selftests/vfs/common.sh
new file mode 100644
index 000000000000..82ac8ad2a5a5
--- /dev/null
+++ b/tools/testing/selftests/vfs/common.sh
</span><span>@@ -0,0 +1,37 @@</span>
<span>+#!/bin/bash
+# SPDX-License-Identifier: GPL-2.0+
+# Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
+# Copyright (C) 2018 SUSE LLC.
+
+set -e -o pipefail
+
+tmpdir="$(mktemp -d --tmpdir vfs_test.XXXXXX)"
+trap "rm -rf $tmpdir" EXIT
+
+root="$tmpdir/root"
+mkdir -p "$root"
+
+function fail() {
+	echo "# not ok" "$@"
+	exit 1
+}
+
+ksft_skip=4
+function skip() {
+	echo "# skip" "$@"
+	exit "$ksft_skip"
+}
+
+function run() {
+	local old_flags="$-"
+	set +eET
+	output="$("$@" 2&gt;&amp;1)"
+	status="$?"
+	set "-$old_flags"
+}
+
+testrootdir="$(readlink -f "$(dirname "$BASH_SOURCE")")"
+function vfs_helper() {
+	run "$testrootdir/vfs_helper" "$@"
+}
+vfs_ops=( "open" "stat" "lstat" )
</span><span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0001_at_beneath.sh" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0001_at_beneath.sh">diff</a> --git a/tools/testing/selftests/vfs/tests/0001_at_beneath.sh b/tools/testing/selftests/vfs/tests/0001_at_beneath.sh
new file mode 100755
index 000000000000..9a03b0953032
--- /dev/null
+++ b/tools/testing/selftests/vfs/tests/0001_at_beneath.sh
</span><span>@@ -0,0 +1,72 @@</span>
<span>+#!/bin/bash
+# SPDX-License-Identifier: GPL-2.0+
+# Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
+# Copyright (C) 2018 SUSE LLC.
+
+sourcedir="$(readlink -f "$(dirname "$BASH_SOURCE")")"
+source "$sourcedir/../common.sh"
+
+touch "$root/inside"
+ln -s / "$root/rootlink"
+ln -s .. "$root/dotdot"
+ln -s "/../../../../../../$root" "$root/badlink"
+
+mkdir -p "$root/subdir"
+ln -s ../inside "$root/subdir/dotdotinside"
+ln -s ../subdir "$root/subdir/dotdotsubdir"
+ln -s subdir "$root/subdirlink"
+ln -s ../subdirlink/../../inside "$root/subdir/complexlink"
+
+for op in "${vfs_ops[@]}"
+do
+	vfs_helper -o "$op" -F beneath -d "$root" ..
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op beneath [/root/].."
+
+	vfs_helper -o "$op" -F beneath -d "$root" ../root
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op beneath [/root/]../root"
+
+	vfs_helper -o "$op" -F beneath -d "$root" dotdot/root
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op beneath [/root/]dotdot(=..)/root"
+
+	vfs_helper -o "$op" -F beneath -d "$root" "$root"
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op beneath [/root/]/root"
+
+	vfs_helper -o "$op" -F beneath -d "$root" rootlink
+	if [[ "$op" == "lstat" ]]
+	then
+		[[ "$status" = 0 ]] || fail "$op beneath [/root/]rootlink(=/)"
+	else
+		[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op beneath [/root/]rootlink(=/)"
+	fi
+
+	vfs_helper -o "$op" -F beneath -d "$root" rootlink/
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op beneath [/root/]rootlink(=/)/"
+
+	vfs_helper -o "$op" -F beneath -d "$root" "rootlink/$root"
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op beneath [/root/]rootlink(=/)/root"
+
+	vfs_helper -o "$op" -F beneath -d "$root" badlink
+	if [[ "$op" == "lstat" ]]
+	then
+		[[ "$status" = 0 ]] || fail "$op beneath [/root/]badlink(=/../.../root)"
+	else
+		[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op beneath [/root/]badlink(=/../.../root)"
+	fi
+
+	vfs_helper -o "$op" -F beneath -d "$root" subdir/../inside
+	[[ "$status" -eq 0 ]] || fail "$op beneath [/root/]subdir/../inside"
+
+	vfs_helper -o "$op" -F beneath -d "$root" subdir/dotdotinside
+	[[ "$status" -eq 0 ]] || fail "$op beneath [/root/]subdir/dotdotinside(=../inside)"
+
+	vfs_helper -o "$op" -F beneath -d "$root" subdir/dotdotsubdir/
+	[[ "$status" -eq 0 ]] || fail "$op beneath [/root/]subdir/dotdotsubdir(=../subdir)/"
+
+	vfs_helper -o "$op" -F beneath -d "$root" subdir/complexlink
+	if [[ "$op" == "lstat" ]]
+	then
+		[[ "$status" = 0 ]] || fail "$op beneath [/root/]complexlink(=../subdirlink/../../inside)"
+	else
+		[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op beneath [/root/]complexlink(=../subdirlink/../../inside)"
+	fi
+done
</span><span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0002_at_xdev.sh" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0002_at_xdev.sh">diff</a> --git a/tools/testing/selftests/vfs/tests/0002_at_xdev.sh b/tools/testing/selftests/vfs/tests/0002_at_xdev.sh
new file mode 100755
index 000000000000..06be58a8ffe7
--- /dev/null
+++ b/tools/testing/selftests/vfs/tests/0002_at_xdev.sh
</span><span>@@ -0,0 +1,54 @@</span>
<span>+#!/bin/bash
+# SPDX-License-Identifier: GPL-2.0+
+# Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
+# Copyright (C) 2018 SUSE LLC.
+
+sourcedir="$(readlink -f "$(dirname "$BASH_SOURCE")")"
+source "$sourcedir/../common.sh"
+
+( mountpoint -q "/tmp" ) || skip "/tmp is not a mountpoint"
+
+touch /tmp/foo
+
+ln -s /tmp "$root/link_tmp"
+
+for op in "${vfs_ops[@]}"
+do
+	vfs_helper -o "$op" -F xdev -d / tmp/
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/]tmp/"
+
+	vfs_helper -o "$op" -F xdev -d / tmp/foo
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/]tmp/foo"
+
+	vfs_helper -o "$op" -F xdev -d "$root" /tmp
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/root/]/tmp"
+
+	vfs_helper -o "$op" -F xdev -d "$root" /tmp/
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/root/]/tmp/"
+
+	vfs_helper -o "$op" -F xdev -d "$root" /tmp/foo
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/root/]/tmp/foo"
+
+	vfs_helper -o "$op" -F xdev -d /tmp foo
+	[[ "$status" = 0 ]] || fail "$op xdev [/tmp/]foo"
+
+	vfs_helper -o "$op" -F xdev -d /tmp ..
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/tmp/].."
+
+	vfs_helper -o "$op" -F xdev -d /tmp ../
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/tmp/]../"
+
+	vfs_helper -o "$op" -F xdev -d /tmp ../tmp
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/tmp/]../tmp"
+
+	vfs_helper -o "$op" -F xdev -d "$root" link_tmp
+	if [[ "$op" == "lstat" ]]
+	then
+		[[ "$status" = 0 ]] || fail "$op xdev [/root/]link_tmp(=/tmp)"
+	else
+		[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/root/]link_tmp(=/tmp)"
+	fi
+
+	vfs_helper -o "$op" -F xdev -d "$root" link_tmp/
+	[[ "$(errno "$status")" =~ "EXDEV "* ]] || fail "$op xdev [/root/]link_tmp(=/tmp)/"
+done
</span><span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0vfs:tests:0003_at_no_proclinks.sh" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0vfs:tests:0003_at_no_proclinks.sh">diff</a> --git a/tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh b/tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
new file mode 100755
index 000000000000..41d9655a1e46
--- /dev/null
+++ b/tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
</span><span>@@ -0,0 +1,50 @@</span>
<span>+#!/bin/bash
+# SPDX-License-Identifier: GPL-2.0+
+# Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
+# Copyright (C) 2018 SUSE LLC.
+
+sourcedir="$(readlink -f "$(dirname "$BASH_SOURCE")")"
+source "$sourcedir/../common.sh"
+
+[ -e "/proc/$$/cwd" ] || skip "/proc/$$/cwd doesn't exist"
+
+ln -s / "$root/testlink"
+
+for op in "${vfs_ops[@]}"
+do
+	for flags in {no_proclinks,no_symlinks,"no_proclinks,no_symlinks"}
+	do
+		vfs_helper -o "$op" -F "$flags" "/proc/$$/stat"
+		[[ "$status" = 0 ]] || fail "$op $flags /proc/$$/stat"
+
+		vfs_helper -o "$op" -F "$flags" "/proc/$$/cwd"
+		if [[ "$op" == "lstat" ]]
+		then
+			[[ "$status" = 0 ]] || fail "$op $flags /proc/$$/cwd"
+		else
+			[[ "$(errno "$status")" =~ "ELOOP "* ]] || fail "$op $flags /proc/$$/cwd"
+		fi
+
+		vfs_helper -o "$op" -F "$flags" -d "$root" "testlink/"
+		if [[ "$flags" == "no_proclinks" ]]
+		then
+			[[ "$status" = 0 ]] || fail "$op $flags [/root/]testlink/"
+		else
+			[[ "$(errno "$status")" =~ "ELOOP "* ]] || fail "$op $flags [/root/]testlink/"
+		fi
+
+		vfs_helper -o "$op" -F "$flags" "/proc/$$/cwd/"
+		[[ "$(errno "$status")" =~ "ELOOP "* ]] || fail "$op $flags /proc/$$/cwd/"
+
+		vfs_helper -o "$op" -F "$flags" "/proc/$$/cwd/$BASH_SOURCE"
+		[[ "$(errno "$status")" =~ "ELOOP "* ]] || fail "$op $flags /proc/$$/cwd/$BASH_SOURCE"
+
+		vfs_helper -o "$op" -F "$flags" -d "/proc/self" cwd
+		if [[ "$op" == "lstat" ]]
+		then
+			[[ "$status" = 0 ]] || fail "$op $flags [/proc/self/]cwd"
+		else
+			[[ "$(errno "$status")" =~ "ELOOP "* ]] || fail "$op $flags [/proc/self]/cwd"
+		fi
+	done
+done
</span><span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0vfs:tests:0004_at_no_symlinks.sh" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0vfs:tests:0004_at_no_symlinks.sh">diff</a> --git a/tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh b/tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
new file mode 100755
index 000000000000..f7ec7e37f06a
--- /dev/null
+++ b/tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
</span><span>@@ -0,0 +1,49 @@</span>
<span>+#!/bin/bash
+# SPDX-License-Identifier: GPL-2.0+
+# Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
+# Copyright (C) 2018 SUSE LLC.
+
+sourcedir="$(readlink -f "$(dirname "$BASH_SOURCE")")"
+source "$sourcedir/../common.sh"
+
+mkdir -p "$root/dir"
+touch "$root/foo"
+
+ln -s . "$root/link_dot"
+ln -s .. "$root/link_dotdot"
+ln -s foo "$root/link_foo"
+
+for op in "${vfs_ops[@]}"
+do
+	vfs_helper -o "$op" -F no_symlinks -d "$root" foo
+	[[ "$status" = 0 ]] || fail "$op no_symlinks [/root/]foo"
+
+	vfs_helper -o "$op" -F no_symlinks -d "$root" ../root/foo
+	[[ "$status" = 0 ]] || fail "$op no_symlinks [/root/]../root/foo"
+
+	vfs_helper -o "$op" -F no_symlinks -d "$root" link_foo
+	if [[ "$op" == "lstat" ]]
+	then
+		[[ "$status" = 0 ]] || fail "$op no_symlinks [/root/]link_foo(=foo)"
+	else
+		[[ "$(errno "$status")" =~ "ELOOP "* ]] || fail "$op no_symlinks [/root/]link_foo(=foo)"
+	fi
+
+	vfs_helper -o "$op" -F no_proclinks -d "$root" link_foo
+	[[ "$status" = 0 ]] || fail "$op no_proclinks [/root/]link_foo(=foo)"
+
+	vfs_helper -o "$op" -F no_symlinks -d "$root" link_dotdot/
+	[[ "$(errno "$status")" =~ "ELOOP "* ]] || fail "$op no_symlinks [/root/]link_dotdot(=..)/"
+
+	vfs_helper -o "$op" -F no_proclinks -d "$root" link_dotdot/
+	[[ "$status" = 0 ]] || fail "$op no_proclinks [/root/]link_dotdot(=..)/"
+
+	vfs_helper -o "$op" -F no_symlinks -d "$root" link_dot/dir
+	[[ "$(errno "$status")" =~ "ELOOP "* ]] || fail "$op no_symlinks [/root/]link_dot(=.)/dir"
+
+	vfs_helper -o "$op" -F no_proclinks -d "$root" link_dot/dir
+	[[ "$status" = 0 ]] || fail "$op no_proclinks [/root/]link_dot(=.)/dir"
+
+	vfs_helper -o "$op" -F no_symlinks -d "$root" ../root/link_dot/link_dotdot/root/dir
+	[[ "$(errno "$status")" =~ "ELOOP "* ]] || fail "$op no_symlinks [/root/]../root/link_dot(=.)/link_dotdot(=..)/root/dir"
+done
</span><span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0005_at_this_root.sh" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0selftests:vfs:tests:0005_at_this_root.sh">diff</a> --git a/tools/testing/selftests/vfs/tests/0005_at_this_root.sh b/tools/testing/selftests/vfs/tests/0005_at_this_root.sh
new file mode 100755
index 000000000000..aba23c28a7b7
--- /dev/null
+++ b/tools/testing/selftests/vfs/tests/0005_at_this_root.sh
</span><span>@@ -0,0 +1,66 @@</span>
<span>+#!/bin/bash
+# SPDX-License-Identifier: GPL-2.0+
+# Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
+# Copyright (C) 2018 SUSE LLC.
+
+sourcedir="$(readlink -f "$(dirname "$BASH_SOURCE")")"
+source "$sourcedir/../common.sh"
+
+mkdir -p "$root/var" "$root/etc" "$root/usr/bin" "$root/usr/local/bin"
+ln -s bash "$root/usr/bin/sh"
+ln -s ../../bin/bash "$root/usr/local/bin/bash"
+ln -s /bin/sh "$root/usr/local/bin/sh"
+ln -s ../bin3 "$root/var/bin"
+ln -s /usr/bin "$root/bin"
+ln -s /usr/local/bin "$root/bin4"
+ln -s ../../../../../../../../../bin "$root/bin2"
+ln -s /../../../../../../../../../bin "$root/bin3"
+touch "$root/etc/passwd" "$root/usr/bin/bash"
+
+# How should each path be mapped to a host path, in the form
+# 'path:hostpath[:hostpath_trailing]'. Everything is assumed to be ${root}
+# prefixed.
+host_mappings=(
+	# Basic paths.
+	"..:."
+	"/:."
+	"/../../../../../../:."
+	"../var/../../../../../etc/passwd:etc/passwd"
+	"/var/../../../../../etc/passwd:etc/passwd"
+	"/../../../../../../var/../../../../../etc/passwd:etc/passwd"
+	"etc/passwd:etc/passwd"
+	"/etc/passwd:etc/passwd"
+
+	# Basic symlink paths.
+	"/bin/bash:usr/bin/bash"
+	"/bin/sh:usr/bin/bash:usr/bin/sh"
+	"/bin2/bash:usr/bin/bash"
+	"/bin2/sh:usr/bin/bash:usr/bin/sh"
+	"/bin3/sh:usr/bin/bash:usr/bin/sh"
+	"/bin3/bash:usr/bin/bash"
+
+	# More complicated symlink paths.
+	"/bin4/../../local/bin/bash:usr/bin/bash:usr/local/bin/bash"
+	"/bin4/../../local/bin/sh:usr/bin/bash:usr/local/bin/sh"
+	"/bin4/../../../../../../../../../../usr/local/bin/bash:usr/bin/bash:usr/local/bin/bash"
+	"/bin4/../../../../../../../../../../usr/local/bin/sh:usr/bin/bash:usr/local/bin/sh"
+	"/bin/../../bin4/../../local/bin/bash:usr/bin/bash:usr/local/bin/bash"
+	"/bin/../../bin4/../../local/bin/sh:usr/bin/bash:usr/local/bin/sh"
+)
+
+for op in "${vfs_ops[@]}"
+do
+	for mapping in "${host_mappings[@]}"
+	do
+		IFS=":" read path hostpath hostpath_trailing &lt;&lt;&lt; "$mapping"
+		[[ "$hostpath_trailing" ]] || export hostpath_trailing="$hostpath"
+		[[ "$op" == "lstat" ]] &amp;&amp; export hostpath="$hostpath_trailing"
+
+		# Compare with and without this_root...
+		vfs_helper -o "$op" -d "$root" "$hostpath"
+		old_status="$status" old_output="$output"
+		vfs_helper -o "$op" -F this_root -d "$root" "$path"
+		[[ "$status" = "$old_status" ]] || fail "$op this_root $path=$status neq $old_status"
+		[[ "$output" == "$old_output" ]] || fail "$op this_root $path=$output neq $old_output"
+	done
+done
</span><span><a href="#iZ2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:vfs_helper.c" id="Z2e.:..:20180929131534.24472-2-cyphar::40cyphar.com:0tools:testing:selftests:vfs:vfs_helper.c">diff</a> --git a/tools/testing/selftests/vfs/vfs_helper.c b/tools/testing/selftests/vfs/vfs_helper.c
new file mode 100644
index 000000000000..d67ec74a3fca
--- /dev/null
+++ b/tools/testing/selftests/vfs/vfs_helper.c
</span><span>@@ -0,0 +1,154 @@</span>
<span>+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
+ * Copyright (C) 2018 SUSE LLC.
+ */
+
+#define _GNU_SOURCE
+
+#include &lt;errno.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;limits.h&gt;
+
+#include "at_flags.h"
+#include "../kselftest.h"
+
+#define bail(...)							\
+	do {								\
+		fprintf(stderr, __VA_ARGS__);				\
+		fputs("\n", stderr);					\
+		exit(1);						\
+	} while (0)
+
+extern char *__progname;
+#define usage()								\
+	bail("usage: %s -o {open|stat|lstat} [-d &lt;dirfd-path&gt;] "	\
+			"[-F [&lt;flag1&gt;,...&lt;flagN&gt;] &lt;path&gt;", __progname)
+
+static unsigned int parse_at_flags(char *opts)
+{
+	char *opt, *saveptr = NULL;
+	unsigned int flags = 0;
+
+	opt = strtok_r(opts, ",", &amp;saveptr);
+	do {
+		unsigned int found = 0;
+
+		if (!*opt)
+			continue;
+		for (struct flag *flag = AT_FLAGS; flag-&gt;name != NULL; flag++) {
+			if (!strcmp(opt, flag-&gt;name))
+				found |= flag-&gt;at_flag;
+		}
+		if (!found)
+			bail("unknown openat(2) flag: %s", opt);
+		flags |= found;
+	} while ((opt = strtok_r(NULL, ",", &amp;saveptr)) != NULL);
+
+	return flags;
+}
+
+int stat_wrapper(int dirfd, const char *pathname, unsigned int flags)
+{
+	struct stat st = {0};
+	int err;
+
+	err = fstatat(dirfd, pathname, &amp;st, flags);
+	if (err &lt; 0)
+		return err;
+
+	printf("%lu:%lu\n", st.st_dev, st.st_ino);
+	return 0;
+}
+
+int lstat_wrapper(int dirfd, const char *pathname, unsigned int flags)
+{
+	return stat_wrapper(dirfd, pathname, flags | AT_SYMLINK_NOFOLLOW);
+}
+
+int openat_wrapper(int dirfd, const char *pathname, unsigned int flags)
+{
+	int fd;
+	char *fdpath = NULL, fullpath[PATH_MAX] = {0};
+
+	fd = openat(dirfd, pathname, flags);
+	if (fd &lt; 0)
+		return fd;
+
+	/* Print the fully-qualified path using /proc/pid/fd/... */
+	if (asprintf(&amp;fdpath, "/proc/self/fd/%d", fd) &lt; 0)
+		bail("asprintf /proc/self/fd/%d: %m", fd);
+	if (readlink(fdpath, fullpath, PATH_MAX) &lt; 0)
+		bail("readlink %s: %m", fdpath);
+	puts(fullpath);
+	return fd;
+}
+
+int main(int argc, char **argv)
+{
+	int opt, ret, dirfd;
+	unsigned int flags = 0;
+	char *opstr = NULL, *dir_path = NULL, *path = NULL;
+	int (*opfunc)(int dirfd, const char *pathname, unsigned int flags);
+
+	while ((opt = getopt(argc, argv, "o:d:F:")) != -1) {
+		switch (opt) {
+		case 'o':
+			opstr = optarg;
+			break;
+		case 'd':
+			dir_path = optarg;
+			break;
+		case 'F':
+			flags |= parse_at_flags(optarg);
+			break;
+		default:
+			usage();
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+
+	if (argc != 1)
+		usage();
+	path = argv[0];
+
+	if (!opstr)
+		usage();
+	else if (!strcmp(opstr, "stat"))
+		opfunc = stat_wrapper;
+	else if (!strcmp(opstr, "lstat"))
+		opfunc = lstat_wrapper;
+	else if (!strcmp(opstr, "open"))
+		opfunc = openat_wrapper;
+	else
+		usage();
+
+	if (opfunc == openat_wrapper) {
+		unsigned int open_flags = 0;
+
+		for (struct flag *flag = AT_FLAGS; flag-&gt;name != NULL; flag++) {
+			if (flags &amp; flag-&gt;at_flag)
+				open_flags |= flag-&gt;open_flag;
+		}
+		flags = open_flags;
+	}
+
+	dirfd = AT_FDCWD;
+	if (dir_path) {
+		dirfd = open(dir_path, O_PATH|O_DIRECTORY);
+		if (dirfd &lt; 0)
+			bail("cannot open dir_path: %m");
+	}
+
+	ret = opfunc(dirfd, path, flags);
+	if (ret &lt; 0)
+		ret = -errno;
+	return (ret &lt; 0) ? -ret : 0;
+}
</span>-- 
2.19.0


<a href="#m1e8d6e44df122828245b146d8d64b9d8a03ac028" id="e1e8d6e44df122828245b146d8d64b9d8a03ac028">^</a> <a href="https://lore.kernel.org/lkml/20180929131534.24472-2-cyphar@cyphar.com/">permalink</a> <a href="https://lore.kernel.org/lkml/20180929131534.24472-2-cyphar@cyphar.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180929131534.24472-2-cyphar@cyphar.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180929131534.24472-2-cyphar@cyphar.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180929131534.24472-2-cyphar@cyphar.com/t/#u">nested</a>] <a href="#r1e8d6e44df122828245b146d8d64b9d8a03ac028">53+ messages in thread</a></pre><hr><pre><a href="#e3b43f05d63e0487bb74cc85c7a6b88ae1782756d" id="m3b43f05d63e0487bb74cc85c7a6b88ae1782756d">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 10:34 <a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Aleksa Sarai
  2018-09-29 10:34 ` <a href="#m1383f86e3b88f40c8cb1ba987680029c591c723c">[PATCH 1/3] namei: implement O_BENEATH-style</a> " Aleksa Sarai
  2018-09-29 13:15 ` <a href="#m90d20073791a183830564405f81c63f760551f20">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Aleksa Sarai
<b>@ 2018-09-29 14:25 ` Andy Lutomirski</b>
  2018-09-29 15:45   ` <a href="#m9f9890d1668a388b92fa59ce7deaf65756554661">Aleksa Sarai</a>
  2018-09-29 14:38 ` <a href="#m721f6dd62a1bdc1658cc2a2ea8b21397577190c7">Christian Brauner</a>
                   ` <a href="#r721f6dd62a1bdc1658cc2a2ea8b21397577190c7">(4 subsequent siblings)</a>
  <a href="#r3b43f05d63e0487bb74cc85c7a6b88ae1782756d">7 siblings, 1 reply; 53+ messages in thread</a>
From: Andy Lutomirski @ 2018-09-29 14:25 UTC (<a href="https://lore.kernel.org/lkml/1EE20CA2-4C8B-4A80-B613-0277D92B376D@amacapital.net/">permalink</a> / <a href="https://lore.kernel.org/lkml/1EE20CA2-4C8B-4A80-B613-0277D92B376D@amacapital.net/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers



<span>&gt; On Sep 29, 2018, at 3:34 AM, Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt; 
&gt; The need for some sort of control over VFS's path resolution (to avoid
&gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt; long-standing desire of many userspace applications. This patchset is a
&gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.
&gt; 
&gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt; which means that each individual property of AT_NO_JUMPS is now a
&gt; separate flag:
&gt; 
&gt;  * Path-based escapes from the starting-point using "/" or ".." are
&gt;    blocked by AT_BENEATH.
</span>
Seems useful.

<span>&gt;  * Mountpoint crossings are blocked by AT_XDEV.
</span>
Seems useful.

<span>&gt;  * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt;    correctly it actually blocks any user of nd_jump_link() because it
&gt;    allows out-of-VFS path resolution manipulation).
&gt; 
</span>
So how do I disable following symlinks? ISTM the most natural way would be to have AT_NO_SYMLINKS, and to have that flag disable proc links.

<a href="#m3b43f05d63e0487bb74cc85c7a6b88ae1782756d" id="e3b43f05d63e0487bb74cc85c7a6b88ae1782756d">^</a> <a href="https://lore.kernel.org/lkml/1EE20CA2-4C8B-4A80-B613-0277D92B376D@amacapital.net/">permalink</a> <a href="https://lore.kernel.org/lkml/1EE20CA2-4C8B-4A80-B613-0277D92B376D@amacapital.net/raw">raw</a> <a href="https://lore.kernel.org/lkml/1EE20CA2-4C8B-4A80-B613-0277D92B376D@amacapital.net/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/1EE20CA2-4C8B-4A80-B613-0277D92B376D@amacapital.net/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/1EE20CA2-4C8B-4A80-B613-0277D92B376D@amacapital.net/t/#u">nested</a>] <a href="#r3b43f05d63e0487bb74cc85c7a6b88ae1782756d">53+ messages in thread</a></pre><hr><pre><a href="#e721f6dd62a1bdc1658cc2a2ea8b21397577190c7" id="m721f6dd62a1bdc1658cc2a2ea8b21397577190c7">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 10:34 <a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Aleksa Sarai
                   ` <a href="#r3b43f05d63e0487bb74cc85c7a6b88ae1782756d">(2 preceding siblings ...)</a>
  2018-09-29 14:25 ` <a href="#m3b43f05d63e0487bb74cc85c7a6b88ae1782756d">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Andy Lutomirski
<b>@ 2018-09-29 14:38 ` Christian Brauner</b>
  2018-09-30  4:44   ` <a href="#me5648719f5bf462dbe857542b9eac97ec3340a8f">Aleksa Sarai</a>
  2018-09-30 13:54 ` <a href="#mcd41f1f73fed393394dbf021d3b8dd2c678b37c3">Alban Crequy</a>
                   ` <a href="#rcd41f1f73fed393394dbf021d3b8dd2c678b37c3">(3 subsequent siblings)</a>
  <a href="#r721f6dd62a1bdc1658cc2a2ea8b21397577190c7">7 siblings, 1 reply; 53+ messages in thread</a>
From: Christian Brauner @ 2018-09-29 14:38 UTC (<a href="https://lore.kernel.org/lkml/20180929143814.yfo6rud7dkyb5ip4@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180929143814.yfo6rud7dkyb5ip4@brauner.io/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Eric Biederman, Tycho Andersen,
	linux-kernel, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers

On Sat, Sep 29, 2018 at 08:34:50PM +1000, Aleksa Sarai wrote:
<span>&gt; The need for some sort of control over VFS's path resolution (to avoid
&gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt; long-standing desire of many userspace applications. This patchset is a
&gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.
&gt; 
&gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt; which means that each individual property of AT_NO_JUMPS is now a
&gt; separate flag:
&gt; 
&gt;   * Path-based escapes from the starting-point using "/" or ".." are
&gt;     blocked by AT_BENEATH.
&gt;   * Mountpoint crossings are blocked by AT_XDEV.
&gt;   * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt; 	correctly it actually blocks any user of nd_jump_link() because it
&gt; 	allows out-of-VFS path resolution manipulation).
&gt; 
&gt; AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS). At
&gt; Linus' suggestion in the original thread, I've also implemented
&gt; AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
&gt; "proclink" resolution).
&gt; 
&gt; An additional improvement was made to AT_XDEV. The original AT_NO_JUMPS
&gt; path didn't consider "/tmp/.." as a mountpoint crossing -- this patch
&gt; blocks this as well (feel free to ask me to remove it if you feel this
&gt; is not sane).
</span>
Imho, these flags are very much needed and they all are pretty useful
not just for container runtimes but in general.

<span>&gt; 
&gt; Currently I've only enabled these for openat(2) and the stat(2) family.
&gt; I would hope we could enable it for basically every *at(2) syscall --
&gt; but many of them appear to not have a @flags argument and thus we'll
&gt; need to add several new syscalls to do this. I'm more than happy to send
&gt; those patches, but I'd prefer to know that this preliminary work is
&gt; acceptable before doing a bunch of copy-paste to add new sets of *at(2)
&gt; syscalls.
</span>
We should really make sure that we can't make due with openat() alone
before adding a bunch of new syscalls. So there's no need to rush into
this. :)

<span>&gt; 
&gt; One additional feature I've implemented is AT_THIS_ROOT (I imagine this
&gt; is probably going to be more contentious than the refresh of
&gt; AT_NO_JUMPS, so I've included it in a separate patch). The patch itself
&gt; describes my reasoning, but the shortened version of the premise is that
&gt; continer runtimes need to have a way to resolve paths within a
&gt; potentially malicious rootfs. Container runtimes currently do this in
&gt; userspace[2] which has implicit race conditions that are not resolvable
&gt; in userspace (or use fork+exec+chroot and SCM_RIGHTS passing which is
&gt; inefficient). AT_THIS_ROOT allows for per-call chroot-like semantics for
&gt; path resolution, which would be invaluable for us -- and the
&gt; implementation is basically identical to AT_BENEATH (except that we
&gt; don't return errors when someone actually hits the root).
&gt; 
&gt; I've added some selftests for this, but it's not clear to me whether
&gt; they should live here or in xfstests (as far as I can tell there are no
&gt; other VFS tests in selftests, while there are some tests that look like
&gt; generic VFS tests in xfstests). If you'd prefer them to be included in
&gt; xfstests, let me know.
&gt; 
&gt; [1]: <a href="https://lore.kernel.org/patchwork/patch/784221/">https://lore.kernel.org/patchwork/patch/784221/</a>
&gt; [2]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>
&gt; 
&gt; Aleksa Sarai (3):
&gt;   namei: implement O_BENEATH-style AT_* flags
&gt;   namei: implement AT_THIS_ROOT chroot-like path resolution
&gt;   selftests: vfs: add AT_* path resolution tests
&gt; 
&gt;  fs/fcntl.c                                    |   2 +-
&gt;  fs/namei.c                                    | 158 ++++++++++++------
&gt;  fs/open.c                                     |  10 ++
&gt;  fs/stat.c                                     |  15 +-
&gt;  include/linux/fcntl.h                         |   3 +-
&gt;  include/linux/namei.h                         |   8 +
&gt;  include/uapi/asm-generic/fcntl.h              |  20 +++
&gt;  include/uapi/linux/fcntl.h                    |  10 ++
&gt;  tools/testing/selftests/Makefile              |   1 +
&gt;  tools/testing/selftests/vfs/.gitignore        |   1 +
&gt;  tools/testing/selftests/vfs/Makefile          |  13 ++
&gt;  tools/testing/selftests/vfs/at_flags.h        |  40 +++++
&gt;  tools/testing/selftests/vfs/common.sh         |  37 ++++
&gt;  .../selftests/vfs/tests/0001_at_beneath.sh    |  72 ++++++++
&gt;  .../selftests/vfs/tests/0002_at_xdev.sh       |  54 ++++++
&gt;  .../vfs/tests/0003_at_no_proclinks.sh         |  50 ++++++
&gt;  .../vfs/tests/0004_at_no_symlinks.sh          |  49 ++++++
&gt;  .../selftests/vfs/tests/0005_at_this_root.sh  |  66 ++++++++
&gt;  tools/testing/selftests/vfs/vfs_helper.c      | 154 +++++++++++++++++
&gt;  19 files changed, 707 insertions(+), 56 deletions(-)
&gt;  create mode 100644 tools/testing/selftests/vfs/.gitignore
&gt;  create mode 100644 tools/testing/selftests/vfs/Makefile
&gt;  create mode 100644 tools/testing/selftests/vfs/at_flags.h
&gt;  create mode 100644 tools/testing/selftests/vfs/common.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0001_at_beneath.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0002_at_xdev.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0005_at_this_root.sh
&gt;  create mode 100644 tools/testing/selftests/vfs/vfs_helper.c
&gt; 
&gt; -- 
&gt; 2.19.0
&gt; 
</span>
<a href="#m721f6dd62a1bdc1658cc2a2ea8b21397577190c7" id="e721f6dd62a1bdc1658cc2a2ea8b21397577190c7">^</a> <a href="https://lore.kernel.org/lkml/20180929143814.yfo6rud7dkyb5ip4@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/20180929143814.yfo6rud7dkyb5ip4@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180929143814.yfo6rud7dkyb5ip4@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180929143814.yfo6rud7dkyb5ip4@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180929143814.yfo6rud7dkyb5ip4@brauner.io/t/#u">nested</a>] <a href="#r721f6dd62a1bdc1658cc2a2ea8b21397577190c7">53+ messages in thread</a></pre><hr><pre><a href="#ebb17b5e39af1ab7962ea44cc159ac0b57a3386fd" id="mbb17b5e39af1ab7962ea44cc159ac0b57a3386fd">*</a> <b>Re: [PATCH 1/3] namei: implement O_BENEATH-style AT_* flags</b>
  2018-09-29 10:34 ` <a href="#m1383f86e3b88f40c8cb1ba987680029c591c723c">[PATCH 1/3] namei: implement O_BENEATH-style</a> " Aleksa Sarai
<b>@ 2018-09-29 14:48   ` Christian Brauner</b>
  2018-09-29 15:34     ` <a href="#md95e36d9e2636c3601761385249d006ea3f5c525">Aleksa Sarai</a>
  2018-09-30  4:38   ` <a href="#m87f541d8dc933342c485dd668073dfec153d374c">Aleksa Sarai</a>
  2018-10-01 12:28   ` <a href="#m00fa1270161fca853ab401153f61255570562b60">Jann Horn</a>
  <a href="#rbb17b5e39af1ab7962ea44cc159ac0b57a3386fd">2 siblings, 1 reply; 53+ messages in thread</a>
From: Christian Brauner @ 2018-09-29 14:48 UTC (<a href="https://lore.kernel.org/lkml/20180929144845.4nglr3sf3jyzosfz@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180929144845.4nglr3sf3jyzosfz@brauner.io/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Eric Biederman, Tycho Andersen,
	linux-kernel, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers

On Sat, Sep 29, 2018 at 08:34:51PM +1000, Aleksa Sarai wrote:
<span>&gt; Add the following flags for path resolution. The primary justification
&gt; for these flags is to allow for programs to be far more strict about how
&gt; they want path resolution to handle symlinks, mountpoint crossings, and
&gt; paths that escape the dirfd (through an absolute path or ".."
&gt; shenanigans).
&gt; 
&gt; This is of particular concern to container runtimes that want to be very
&gt; careful about malicious root filesystems that a container's init might
&gt; have screwed around with (and there is no real way to protect against
&gt; this in userspace if you consider potential races against a malicious
&gt; container's init).
&gt; 
&gt; * AT_BENEATH: Disallow ".." or absolute paths (either in the path or
&gt;   found during symlink resolution) to escape the starting point of name
&gt;   resolution, though ".." is permitted in cases like "foo/../bar".
&gt;   Relative symlinks are still allowed (as long as they don't escape the
&gt;   starting point).
&gt; 
&gt; * AT_XDEV: Disallow mount-point crossing (both *down* into one, or *up*
&gt;   from one). The primary "scoping" use is to blocking resolution that
&gt;   crosses a bind-mount, which has a similar property to a symlink (in
&gt;   the way that it allows for escape from the starting-point). Since it
&gt;   is not possible to differentiate bind-mounts However since
&gt;   bind-mounting requires privileges (in ways symlinks don't) this has
&gt;   been split from LOOKUP_BENEATH. The naming is based on "find -xdev"
&gt;   (though find(1) doesn't walk upwards, the semantics seem obvious).
&gt; 
&gt; * AT_NO_PROCLINK: Disallows -&gt;get_link "symlink" jumping. This is a very
&gt;   specific restriction, and it exists because /proc/$pid/fd/...
&gt;   "symlinks" allow for access outside nd-&gt;root and pose risk to
&gt;   container runtimes that don't want to be tricked into accessing a host
&gt;   path (but do want to allow no-funny-business symlink resolution).
&gt; 
&gt; * AT_NO_SYMLINK: Disallows symlink jumping *of any kind*. Implies
&gt;   AT_NO_PROCLINK (obviously).
&gt; 
&gt; The AT_NO_*LINK flags return -ELOOP if path resolution would violates
&gt; their requirement, while the others all return -EXDEV. Currently these
&gt; are only enabled for the stat(2) family and the openat(2) family (the
&gt; latter has its own brand of O_* flags with the same semantics). Ideally
&gt; these flags would be supported by all *at(2) syscalls, but this will
&gt; require adding flags arguments to many of them (and will be done in a
&gt; separate patchset).
&gt; 
&gt; Cc: Andy Lutomirski &lt;luto@kernel.org&gt;
&gt; Cc: Eric Biederman &lt;ebiederm@xmission.com&gt;
&gt; Cc: Christian Brauner &lt;christian@brauner.io&gt;
&gt; Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
</span>
Not to be a stickler about protocol but given that this is based heavily
on ideas from prior patchsets and suggestions as you mentioned it might
make sense to cite them as links and also maybe add some Suggested-by
lines for some of the authors for the sake of posterity. :)

[1]: <a href="https://lwn.net/Articles/721443/">https://lwn.net/Articles/721443/</a>
[2]: <a href="https://lwn.net/Articles/723057/">https://lwn.net/Articles/723057/</a>

<span>&gt; ---
&gt;  fs/fcntl.c                       |  2 +-
&gt;  fs/namei.c                       | 61 ++++++++++++++++++++++++++------
&gt;  fs/open.c                        |  8 +++++
&gt;  fs/stat.c                        | 13 +++++--
&gt;  include/linux/fcntl.h            |  3 +-
&gt;  include/linux/namei.h            |  7 ++++
&gt;  include/uapi/asm-generic/fcntl.h | 17 +++++++++
&gt;  include/uapi/linux/fcntl.h       |  8 +++++
&gt;  8 files changed, 104 insertions(+), 15 deletions(-)
&gt; 
&gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; index 4137d96534a6..e343618736f7 100644
&gt; --- a/fs/fcntl.c
&gt; +++ b/fs/fcntl.c
&gt; @@ -1031,7 +1031,7 @@ static int __init fcntl_init(void)
&gt;  	 * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt;  	 * is defined as O_NONBLOCK on some platforms and not on others.
&gt;  	 */
&gt; -	BUILD_BUG_ON(21 - 1 /* for O_RDONLY being 0 */ !=
&gt; +	BUILD_BUG_ON(25 - 1 /* for O_RDONLY being 0 */ !=
&gt;  		HWEIGHT32(
&gt;  			(VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt;  			__FMODE_EXEC | __FMODE_NONOTIFY));
&gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; index fb913148d4d1..757dd783771c 100644
&gt; --- a/fs/namei.c
&gt; +++ b/fs/namei.c
&gt; @@ -859,6 +859,8 @@ static int nd_jump_root(struct nameidata *nd)
&gt;  		path_get(&amp;nd-&gt;path);
&gt;  		nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt;  	}
&gt; +	if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH))
&gt; +		return -EXDEV;
&gt;  	nd-&gt;flags |= LOOKUP_JUMPED;
&gt;  	return 0;
&gt;  }
&gt; @@ -1083,14 +1085,19 @@ const char *get_link(struct nameidata *nd)
&gt;  		} else {
&gt;  			res = get(dentry, inode, &amp;last-&gt;done);
&gt;  		}
&gt; +		/* If we just jumped it was because of a procfs-style link. */
&gt; +		if (unlikely(nd-&gt;flags &amp; LOOKUP_JUMPED) &amp;&amp;
&gt; +		    unlikely(nd-&gt;flags &amp; LOOKUP_NO_PROCLINKS))
&gt; +			return ERR_PTR(-ELOOP);
&gt;  		if (IS_ERR_OR_NULL(res))
&gt;  			return res;
&gt;  	}
&gt;  	if (*res == '/') {
&gt;  		if (!nd-&gt;root.mnt)
&gt;  			set_root(nd);
&gt; -		if (unlikely(nd_jump_root(nd)))
&gt; -			return ERR_PTR(-ECHILD);
&gt; +		error = nd_jump_root(nd);
&gt; +		if (unlikely(error))
&gt; +			return ERR_PTR(error);
&gt;  		while (unlikely(*++res == '/'))
&gt;  			;
&gt;  	}
&gt; @@ -1271,12 +1278,16 @@ static int follow_managed(struct path *path, struct nameidata *nd)
&gt;  		break;
&gt;  	}
&gt;  
&gt; -	if (need_mntput &amp;&amp; path-&gt;mnt == mnt)
&gt; -		mntput(path-&gt;mnt);
&gt; +	if (need_mntput) {
&gt; +		if (path-&gt;mnt == mnt)
&gt; +			mntput(path-&gt;mnt);
&gt; +		if (unlikely(nd-&gt;flags &amp; LOOKUP_XDEV))
&gt; +			ret = -EXDEV;
&gt; +		else
&gt; +			nd-&gt;flags |= LOOKUP_JUMPED;
&gt; +	}
&gt;  	if (ret == -EISDIR || !ret)
&gt;  		ret = 1;
&gt; -	if (need_mntput)
&gt; -		nd-&gt;flags |= LOOKUP_JUMPED;
&gt;  	if (unlikely(ret &lt; 0))
&gt;  		path_put_conditional(path, nd);
&gt;  	return ret;
&gt; @@ -1333,6 +1344,8 @@ static bool __follow_mount_rcu(struct nameidata *nd, struct path *path,
&gt;  		mounted = __lookup_mnt(path-&gt;mnt, path-&gt;dentry);
&gt;  		if (!mounted)
&gt;  			break;
&gt; +		if (unlikely(nd-&gt;flags &amp; LOOKUP_XDEV))
&gt; +			return false;
&gt;  		path-&gt;mnt = &amp;mounted-&gt;mnt;
&gt;  		path-&gt;dentry = mounted-&gt;mnt.mnt_root;
&gt;  		nd-&gt;flags |= LOOKUP_JUMPED;
&gt; @@ -1353,8 +1366,11 @@ static int follow_dotdot_rcu(struct nameidata *nd)
&gt;  	struct inode *inode = nd-&gt;inode;
&gt;  
&gt;  	while (1) {
&gt; -		if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root))
&gt; +		if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) {
&gt; +			if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH))
&gt; +				return -EXDEV;
&gt;  			break;
&gt; +		}
&gt;  		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
&gt;  			struct dentry *old = nd-&gt;path.dentry;
&gt;  			struct dentry *parent = old-&gt;d_parent;
&gt; @@ -1379,6 +1395,8 @@ static int follow_dotdot_rcu(struct nameidata *nd)
&gt;  				return -ECHILD;
&gt;  			if (&amp;mparent-&gt;mnt == nd-&gt;path.mnt)
&gt;  				break;
&gt; +			if (unlikely(nd-&gt;flags &amp; LOOKUP_XDEV))
&gt; +				return -EXDEV;
&gt;  			/* we know that mountpoint was pinned */
&gt;  			nd-&gt;path.dentry = mountpoint;
&gt;  			nd-&gt;path.mnt = &amp;mparent-&gt;mnt;
&gt; @@ -1481,8 +1499,11 @@ static int path_parent_directory(struct path *path)
&gt;  static int follow_dotdot(struct nameidata *nd)
&gt;  {
&gt;  	while(1) {
&gt; -		if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root))
&gt; +		if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) {
&gt; +			if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH))
&gt; +				return -EXDEV;
&gt;  			break;
&gt; +		}
&gt;  		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
&gt;  			int ret = path_parent_directory(&amp;nd-&gt;path);
&gt;  			if (ret)
&gt; @@ -1491,6 +1512,8 @@ static int follow_dotdot(struct nameidata *nd)
&gt;  		}
&gt;  		if (!follow_up(&amp;nd-&gt;path))
&gt;  			break;
&gt; +		if (unlikely(nd-&gt;flags &amp; LOOKUP_XDEV))
&gt; +			return -EXDEV;
&gt;  	}
&gt;  	follow_mount(&amp;nd-&gt;path);
&gt;  	nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; @@ -1720,6 +1743,8 @@ static int pick_link(struct nameidata *nd, struct path *link,
&gt;  {
&gt;  	int error;
&gt;  	struct saved *last;
&gt; +	if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_SYMLINKS))
&gt; +		return -ELOOP;
&gt;  	if (unlikely(nd-&gt;total_link_count++ &gt;= MAXSYMLINKS)) {
&gt;  		path_to_nameidata(link, nd);
&gt;  		return -ELOOP;
&gt; @@ -2175,6 +2200,8 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
&gt;  
&gt;  	if (!*s)
&gt;  		flags &amp;= ~LOOKUP_RCU;
&gt; +	if (flags &amp; LOOKUP_NO_SYMLINKS)
&gt; +		flags |= LOOKUP_NO_PROCLINKS;
&gt;  	if (flags &amp; LOOKUP_RCU)
&gt;  		rcu_read_lock();
&gt;  
&gt; @@ -2204,10 +2231,12 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
&gt;  
&gt;  	nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
&gt;  	if (*s == '/') {
&gt; +		int error;
&gt;  		set_root(nd);
&gt; -		if (likely(!nd_jump_root(nd)))
&gt; -			return s;
&gt; -		return ERR_PTR(-ECHILD);
&gt; +		error = nd_jump_root(nd);
&gt; +		if (unlikely(error))
&gt; +			s = ERR_PTR(error);
&gt; +		return s;
&gt;  	} else if (nd-&gt;dfd == AT_FDCWD) {
&gt;  		if (flags &amp; LOOKUP_RCU) {
&gt;  			struct fs_struct *fs = current-&gt;fs;
&gt; @@ -2223,6 +2252,11 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
&gt;  			get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path);
&gt;  			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt;  		}
&gt; +		if (unlikely(flags &amp; LOOKUP_BENEATH)) {
&gt; +			nd-&gt;root = nd-&gt;path;
&gt; +			if (!(flags &amp; LOOKUP_RCU))
&gt; +				path_get(&amp;nd-&gt;root);
&gt; +		}
&gt;  		return s;
&gt;  	} else {
&gt;  		/* Caller must check execute permissions on the starting path component */
&gt; @@ -2247,6 +2281,11 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
&gt;  			path_get(&amp;nd-&gt;path);
&gt;  			nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt;  		}
&gt; +		if (unlikely(flags &amp; LOOKUP_BENEATH)) {
&gt; +			nd-&gt;root = nd-&gt;path;
&gt; +			if (!(flags &amp; LOOKUP_RCU))
&gt; +				path_get(&amp;nd-&gt;root);
&gt; +		}
&gt;  		fdput(f);
&gt;  		return s;
&gt;  	}
&gt; diff --git a/fs/open.c b/fs/open.c
&gt; index 0285ce7dbd51..80f5f566a5ff 100644
&gt; --- a/fs/open.c
&gt; +++ b/fs/open.c
&gt; @@ -988,6 +988,14 @@ static inline int build_open_flags(int flags, umode_t mode, struct open_flags *o
&gt;  		lookup_flags |= LOOKUP_DIRECTORY;
&gt;  	if (!(flags &amp; O_NOFOLLOW))
&gt;  		lookup_flags |= LOOKUP_FOLLOW;
&gt; +	if (flags &amp; O_BENEATH)
&gt; +		lookup_flags |= LOOKUP_BENEATH;
&gt; +	if (flags &amp; O_XDEV)
&gt; +		lookup_flags |= LOOKUP_XDEV;
&gt; +	if (flags &amp; O_NOPROCLINKS)
&gt; +		lookup_flags |= LOOKUP_NO_PROCLINKS;
&gt; +	if (flags &amp; O_NOSYMLINKS)
&gt; +		lookup_flags |= LOOKUP_NO_SYMLINKS;
&gt;  	op-&gt;lookup_flags = lookup_flags;
&gt;  	return 0;
&gt;  }
&gt; diff --git a/fs/stat.c b/fs/stat.c
&gt; index f8e6fb2c3657..791e61b916ae 100644
&gt; --- a/fs/stat.c
&gt; +++ b/fs/stat.c
&gt; @@ -170,8 +170,9 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
&gt;  	int error = -EINVAL;
&gt;  	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT;
&gt;  
&gt; -	if ((flags &amp; ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT |
&gt; -		       AT_EMPTY_PATH | KSTAT_QUERY_FLAGS)) != 0)
&gt; +	if (flags &amp; ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT | AT_EMPTY_PATH |
&gt; +		      KSTAT_QUERY_FLAGS | AT_BENEATH | AT_XDEV |
&gt; +		      AT_NO_PROCLINKS | AT_NO_SYMLINKS))
&gt;  		return -EINVAL;
&gt;  
&gt;  	if (flags &amp; AT_SYMLINK_NOFOLLOW)
&gt; @@ -180,6 +181,14 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
&gt;  		lookup_flags &amp;= ~LOOKUP_AUTOMOUNT;
&gt;  	if (flags &amp; AT_EMPTY_PATH)
&gt;  		lookup_flags |= LOOKUP_EMPTY;
&gt; +	if (flags &amp; AT_BENEATH)
&gt; +		lookup_flags |= LOOKUP_BENEATH;
&gt; +	if (flags &amp; AT_XDEV)
&gt; +		lookup_flags |= LOOKUP_XDEV;
&gt; +	if (flags &amp; AT_NO_PROCLINKS)
&gt; +		lookup_flags |= LOOKUP_NO_PROCLINKS;
&gt; +	if (flags &amp; AT_NO_SYMLINKS)
&gt; +		lookup_flags |= LOOKUP_NO_SYMLINKS;
&gt;  
&gt;  retry:
&gt;  	error = user_path_at(dfd, filename, lookup_flags, &amp;path);
&gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; index 27dc7a60693e..ad5bba4b5b12 100644
&gt; --- a/include/linux/fcntl.h
&gt; +++ b/include/linux/fcntl.h
&gt; @@ -9,7 +9,8 @@
&gt;  	(O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \
&gt;  	 O_APPEND | O_NDELAY | O_NONBLOCK | O_NDELAY | __O_SYNC | O_DSYNC | \
&gt;  	 FASYNC	| O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; -	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
&gt; +	 O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_BENEATH | O_XDEV | \
&gt; +	 O_NOPROCLINKS | O_NOSYMLINKS)
&gt;  
&gt;  #ifndef force_o_largefile
&gt;  #define force_o_largefile() (BITS_PER_LONG != 32)
&gt; diff --git a/include/linux/namei.h b/include/linux/namei.h
&gt; index a78606e8e3df..5ff7f3362d1b 100644
&gt; --- a/include/linux/namei.h
&gt; +++ b/include/linux/namei.h
&gt; @@ -47,6 +47,13 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
&gt;  #define LOOKUP_EMPTY		0x4000
&gt;  #define LOOKUP_DOWN		0x8000
&gt;  
&gt; +/* Scoping flags for lookup. */
&gt; +#define LOOKUP_BENEATH		0x010000 /* No escaping from starting point. */
&gt; +#define LOOKUP_XDEV		0x020000 /* No mountpoint crossing. */
&gt; +#define LOOKUP_NO_PROCLINKS	0x040000 /* No /proc/$pid/fd/ "symlink" crossing. */
&gt; +#define LOOKUP_NO_SYMLINKS	0x080000 /* No symlink crossing *at all*.
&gt; +					    Implies LOOKUP_NO_PROCLINKS. */
&gt; +
&gt;  extern int path_pts(struct path *path);
&gt;  
&gt;  extern int user_path_at_empty(int, const char __user *, unsigned, struct path *, int *empty);
&gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; index 9dc0bf0c5a6e..c2bf5983e46a 100644
&gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; @@ -97,6 +97,23 @@
&gt;  #define O_NDELAY	O_NONBLOCK
&gt;  #endif
&gt;  
&gt; +/*
&gt; + * These are identical to their AT_* counterparts (which affect the entireity
&gt; + * of path resolution).
&gt; + */
&gt; +#ifndef O_BENEATH
&gt; +#define O_BENEATH	00040000000 /* *Not* the same as capsicum's O_BENEATH! */
&gt; +#endif
&gt; +#ifndef O_XDEV
&gt; +#define O_XDEV		00100000000
&gt; +#endif
&gt; +#ifndef O_NOPROCLINKS
&gt; +#define O_NOPROCLINKS	00200000000
&gt; +#endif
&gt; +#ifndef O_NOSYMLINKS
&gt; +#define O_NOSYMLINKS	01000000000
&gt; +#endif
&gt; +
&gt;  #define F_DUPFD		0	/* dup */
&gt;  #define F_GETFD		1	/* get close_on_exec */
&gt;  #define F_SETFD		2	/* set/clear close_on_exec */
&gt; diff --git a/include/uapi/linux/fcntl.h b/include/uapi/linux/fcntl.h
&gt; index 594b85f7cb86..551a9e2166a8 100644
&gt; --- a/include/uapi/linux/fcntl.h
&gt; +++ b/include/uapi/linux/fcntl.h
&gt; @@ -92,5 +92,13 @@
&gt;  
&gt;  #define AT_RECURSIVE		0x8000	/* Apply to the entire subtree */
&gt;  
&gt; +/* Flags which affect path *resolution*, not just last-component handling. */
&gt; +#define AT_BENEATH		0x10000	/* No absolute paths or ".." escaping
&gt; +					   (in-path or through symlinks) */
&gt; +#define AT_XDEV			0x20000 /* No mountpoint crossing. */
&gt; +#define AT_NO_PROCLINKS		0x40000 /* No /proc/$pid/fd/... "symlinks". */
&gt; +#define AT_NO_SYMLINKS		0x80000 /* No symlinks *at all*.
&gt; +					   Implies AT_NO_PROCLINKS. */
&gt; +
&gt;  
&gt;  #endif /* _UAPI_LINUX_FCNTL_H */
&gt; -- 
&gt; 2.19.0
&gt; 
</span>
<a href="#mbb17b5e39af1ab7962ea44cc159ac0b57a3386fd" id="ebb17b5e39af1ab7962ea44cc159ac0b57a3386fd">^</a> <a href="https://lore.kernel.org/lkml/20180929144845.4nglr3sf3jyzosfz@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/20180929144845.4nglr3sf3jyzosfz@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180929144845.4nglr3sf3jyzosfz@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180929144845.4nglr3sf3jyzosfz@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180929144845.4nglr3sf3jyzosfz@brauner.io/t/#u">nested</a>] <a href="#rbb17b5e39af1ab7962ea44cc159ac0b57a3386fd">53+ messages in thread</a></pre><hr><pre><a href="#ed95e36d9e2636c3601761385249d006ea3f5c525" id="md95e36d9e2636c3601761385249d006ea3f5c525">*</a> <b>Re: [PATCH 1/3] namei: implement O_BENEATH-style AT_* flags</b>
  2018-09-29 14:48   ` <a href="#mbb17b5e39af1ab7962ea44cc159ac0b57a3386fd">Christian Brauner</a>
<b>@ 2018-09-29 15:34     ` Aleksa Sarai</b>
  <a href="#rd95e36d9e2636c3601761385249d006ea3f5c525">0 siblings, 0 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-09-29 15:34 UTC (<a href="https://lore.kernel.org/lkml/20180929152754.rbh37oluivbywdja@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180929152754.rbh37oluivbywdja@ryuk/raw">raw</a>)
  To: Christian Brauner
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Eric Biederman, Tycho Andersen,
	linux-kernel, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers

<a href="https://lore.kernel.org/lkml/20180929152754.rbh37oluivbywdja@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 773 bytes --]</a>

On 2018-09-29, Christian Brauner &lt;christian@brauner.io&gt; wrote:
<span>&gt; &gt; Cc: Andy Lutomirski &lt;luto@kernel.org&gt;
&gt; &gt; Cc: Eric Biederman &lt;ebiederm@xmission.com&gt;
&gt; &gt; Cc: Christian Brauner &lt;christian@brauner.io&gt;
&gt; &gt; Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
&gt; 
&gt; Not to be a stickler about protocol but given that this is based heavily
&gt; on ideas from prior patchsets and suggestions as you mentioned it might
&gt; make sense to cite them as links and also maybe add some Suggested-by
&gt; lines for some of the authors for the sake of posterity. :)
</span>
Oops -- yup, I will fix that up.

<span>&gt; [1]: <a href="https://lwn.net/Articles/721443/">https://lwn.net/Articles/721443/</a>
&gt; [2]: <a href="https://lwn.net/Articles/723057/">https://lwn.net/Articles/723057/</a>
</span>
-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20180929152754.rbh37oluivbywdja@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#md95e36d9e2636c3601761385249d006ea3f5c525" id="ed95e36d9e2636c3601761385249d006ea3f5c525">^</a> <a href="https://lore.kernel.org/lkml/20180929152754.rbh37oluivbywdja@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20180929152754.rbh37oluivbywdja@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180929152754.rbh37oluivbywdja@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180929152754.rbh37oluivbywdja@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180929152754.rbh37oluivbywdja@ryuk/t/#u">nested</a>] <a href="#rd95e36d9e2636c3601761385249d006ea3f5c525">53+ messages in thread</a></pre><hr><pre><a href="#e9f9890d1668a388b92fa59ce7deaf65756554661" id="m9f9890d1668a388b92fa59ce7deaf65756554661">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 14:25 ` <a href="#m3b43f05d63e0487bb74cc85c7a6b88ae1782756d">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Andy Lutomirski
<b>@ 2018-09-29 15:45   ` Aleksa Sarai</b>
  2018-09-29 16:34     ` <a href="#ma7d3a3f2eecc4c0cc375a249b47e94e33377c744">Andy Lutomirski</a>
  <a href="#r9f9890d1668a388b92fa59ce7deaf65756554661">0 siblings, 1 reply; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-09-29 15:45 UTC (<a href="https://lore.kernel.org/lkml/20180929154551.jsi6dt3xjxdxoqeh@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180929154551.jsi6dt3xjxdxoqeh@ryuk/raw">raw</a>)
  To: Andy Lutomirski
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers

<a href="https://lore.kernel.org/lkml/20180929154551.jsi6dt3xjxdxoqeh@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 2381 bytes --]</a>

On 2018-09-29, Andy Lutomirski &lt;luto@amacapital.net&gt; wrote:
<span>&gt; &gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt; &gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt; &gt; which means that each individual property of AT_NO_JUMPS is now a
&gt; &gt; separate flag:
&gt; &gt; 
&gt; &gt;  * Path-based escapes from the starting-point using "/" or ".." are
&gt; &gt;    blocked by AT_BENEATH.
&gt; 
&gt; Seems useful.
&gt; 
&gt; &gt;  * Mountpoint crossings are blocked by AT_XDEV.
&gt; 
&gt; Seems useful.
&gt; 
&gt; &gt;  * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt; &gt;    correctly it actually blocks any user of nd_jump_link() because it
&gt; &gt;    allows out-of-VFS path resolution manipulation).
&gt; &gt; 
&gt; 
&gt; So how do I disable following symlinks? ISTM the most natural way
&gt; would be to have AT_NO_SYMLINKS, and to have that flag disable proc
&gt; links.
</span>
So, this patchset has both AT_NO_SYMLINKS and AT_NO_PROCLINKS.

* AT_NO_SYMLINKS blocks *all* symlinks (which is something Linus requested
  in the original thread[2] -- apparently this is something that would
  be useful to git even if wouldn't violate AT_BENEATH). This implies
  AT_NO_PROCLINKS.

* AT_NO_PROCLINKS only blocks procfs-style "symlinks" (filesystem
  "symlinks" that call nd_jump_link() themselves -- currently only
  procfs and nsfs).

The reason why we need AT_NO_PROCLINKS is that "proclinks"[*] allow for
breaking-out of nd-&gt;root without a trivial way of detecting it (since
the filesystem can manipulate nd-&gt;path almost arbitrarily outside of the
control of VFS). Al Viro's original patchset[1] also blocked these but
it was all included within AT_NO_JUMPS.

Requiring you to block *all* symlinks in order to block "proclinks"
seems to be a bit overkill to me (especially if consider that
AT_THIS_ROOT|AT_NO_PROCLINKS is definitely a usecase most container
runtimes would be _very_ interested in -- while AT_NO_SYMLINKS will
cause issues with most distribution images).

[*]: Sorry for the awful naming, I'm not sure what the correct name is
	 (I've called them "super symlinks" in the past) -- if you have a
	 better name please let me know!

[1]: <a href="https://lwn.net/Articles/721443/">https://lwn.net/Articles/721443/</a>
[2]: <a href="https://marc.info/?l=linux-kernel&amp;m=149394765324531&amp;w=2">https://marc.info/?l=linux-kernel&amp;m=149394765324531&amp;w=2</a>

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20180929154551.jsi6dt3xjxdxoqeh@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#m9f9890d1668a388b92fa59ce7deaf65756554661" id="e9f9890d1668a388b92fa59ce7deaf65756554661">^</a> <a href="https://lore.kernel.org/lkml/20180929154551.jsi6dt3xjxdxoqeh@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20180929154551.jsi6dt3xjxdxoqeh@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180929154551.jsi6dt3xjxdxoqeh@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180929154551.jsi6dt3xjxdxoqeh@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180929154551.jsi6dt3xjxdxoqeh@ryuk/t/#u">nested</a>] <a href="#r9f9890d1668a388b92fa59ce7deaf65756554661">53+ messages in thread</a></pre><hr><pre><a href="#ea7d3a3f2eecc4c0cc375a249b47e94e33377c744" id="ma7d3a3f2eecc4c0cc375a249b47e94e33377c744">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 15:45   ` <a href="#m9f9890d1668a388b92fa59ce7deaf65756554661">Aleksa Sarai</a>
<b>@ 2018-09-29 16:34     ` Andy Lutomirski</b>
  2018-09-29 19:44       ` <a href="#ma8e202c0d14e5763bfff6e7338febd7d1a51a83f">Matthew Wilcox</a>
  <a href="#ra7d3a3f2eecc4c0cc375a249b47e94e33377c744">0 siblings, 1 reply; 53+ messages in thread</a>
From: Andy Lutomirski @ 2018-09-29 16:34 UTC (<a href="https://lore.kernel.org/lkml/9D01A225-05BE-4B4A-873A-94168D17F687@amacapital.net/">permalink</a> / <a href="https://lore.kernel.org/lkml/9D01A225-05BE-4B4A-873A-94168D17F687@amacapital.net/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers



<span>&gt; On Sep 29, 2018, at 8:45 AM, Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt; 
&gt; On 2018-09-29, Andy Lutomirski &lt;luto@amacapital.net&gt; wrote:
&gt;&gt;&gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt;&gt;&gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt;&gt;&gt; which means that each individual property of AT_NO_JUMPS is now a
&gt;&gt;&gt; separate flag:
&gt;&gt;&gt; 
&gt;&gt;&gt; * Path-based escapes from the starting-point using "/" or ".." are
&gt;&gt;&gt;   blocked by AT_BENEATH.
&gt;&gt; 
&gt;&gt; Seems useful.
&gt;&gt; 
&gt;&gt;&gt; * Mountpoint crossings are blocked by AT_XDEV.
&gt;&gt; 
&gt;&gt; Seems useful.
&gt;&gt; 
&gt;&gt;&gt; * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt;&gt;&gt;   correctly it actually blocks any user of nd_jump_link() because it
&gt;&gt;&gt;   allows out-of-VFS path resolution manipulation).
&gt;&gt;&gt; 
&gt;&gt; 
&gt;&gt; So how do I disable following symlinks? ISTM the most natural way
&gt;&gt; would be to have AT_NO_SYMLINKS, and to have that flag disable proc
&gt;&gt; links.
&gt; 
&gt; So, this patchset has both AT_NO_SYMLINKS and AT_NO_PROCLINKS.
</span>
And AT_THIS_ROOT, which is neat. Want to update your cover letter to include all of this?  Or at I just reading the wrong thing?

<span>&gt; 
&gt; * AT_NO_SYMLINKS blocks *all* symlinks (which is something Linus requested
&gt;  in the original thread[2] -- apparently this is something that would
&gt;  be useful to git even if wouldn't violate AT_BENEATH). This implies
&gt;  AT_NO_PROCLINKS.
&gt; 
&gt; * AT_NO_PROCLINKS only blocks procfs-style "symlinks" (filesystem
&gt;  "symlinks" that call nd_jump_link() themselves -- currently only
&gt;  procfs and nsfs).
&gt; 
</span>
Hmm. Im not sure that blocking nsfs links is always what the container runtime wants, but the overall concept sounds quite useful.  Maybe call it AT_NO_TELEPORT?  Or AT_NO_MAGIC_LINKS?

Also, as a perhaps-silly suggestion: if you end up adding a new syscall, I can see a use for a mode that does the path walk but, rather than failing on a disallowed link, stops early and indicates where it stopped. Then web servers, samba, etc can more efficiently implement custom behavior when links are encountered.  And it may also be useful to have a variant of AT_THIS_ROOT where trying to escape is an error instead of having it just get stuck at the root.

<a href="#ma7d3a3f2eecc4c0cc375a249b47e94e33377c744" id="ea7d3a3f2eecc4c0cc375a249b47e94e33377c744">^</a> <a href="https://lore.kernel.org/lkml/9D01A225-05BE-4B4A-873A-94168D17F687@amacapital.net/">permalink</a> <a href="https://lore.kernel.org/lkml/9D01A225-05BE-4B4A-873A-94168D17F687@amacapital.net/raw">raw</a> <a href="https://lore.kernel.org/lkml/9D01A225-05BE-4B4A-873A-94168D17F687@amacapital.net/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/9D01A225-05BE-4B4A-873A-94168D17F687@amacapital.net/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/9D01A225-05BE-4B4A-873A-94168D17F687@amacapital.net/t/#u">nested</a>] <a href="#ra7d3a3f2eecc4c0cc375a249b47e94e33377c744">53+ messages in thread</a></pre><hr><pre><a href="#e85db30139fa0747cca01a4a7b71ba3f88ab3207c" id="m85db30139fa0747cca01a4a7b71ba3f88ab3207c">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-09-29 13:15 ` <a href="#m90d20073791a183830564405f81c63f760551f20">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Aleksa Sarai
  2018-09-29 13:15   ` <a href="#m1e8d6e44df122828245b146d8d64b9d8a03ac028">[PATCH 3/3] selftests: vfs: add AT_* path resolution tests</a> Aleksa Sarai
<b>@ 2018-09-29 16:35   ` Jann Horn</b>
  2018-09-29 17:25     ` <a href="#m55dcd0750c094ebe0bc62c39c395b0163bb41bf2">Andy Lutomirski</a>
                       ` <a href="#r55dcd0750c094ebe0bc62c39c395b0163bb41bf2">(3 more replies)</a>
  <a href="#r85db30139fa0747cca01a4a7b71ba3f88ab3207c">1 sibling, 4 replies; 53+ messages in thread</a>
From: Jann Horn @ 2018-09-29 16:35 UTC (<a href="https://lore.kernel.org/lkml/CAG48ez30WJhbsro2HOc_DR7V91M+hNFzBP5ogRMZaxbAORvqzg@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CAG48ez30WJhbsro2HOc_DR7V91M+hNFzBP5ogRMZaxbAORvqzg@mail.gmail.com/raw">raw</a>)
  To: cyphar, Eric W. Biederman
  Cc: jlayton, Bruce Fields, Al Viro, Arnd Bergmann, shuah,
	David Howells, Andy Lutomirski, christian, Tycho Andersen,
	kernel list, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers, Linux API

+cc linux-api; please keep them in CC for future versions of the patch

On Sat, Sep 29, 2018 at 4:29 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
<span>&gt; The primary motivation for the need for this flag is container runtimes
&gt; which have to interact with malicious root filesystems in the host
&gt; namespaces. One of the first requirements for a container runtime to be
&gt; secure against a malicious rootfs is that they correctly scope symlinks
&gt; (that is, they should be scoped as though they are chroot(2)ed into the
&gt; container's rootfs) and ".."-style paths. The already-existing AT_XDEV
&gt; and AT_NO_PROCLINKS help defend against other potential attacks in a
&gt; malicious rootfs scenario.
</span>
So, I really like the concept for patch 1 of this series (but haven't
read the code yet); but I dislike this patch because of its footgun
potential.

If this patch landed as-is, the manpage would need some big warning
labels. chroot() basically provides no security guarantees at all; and
yes, that includes that if you do `chroot(...); chdir("/");
open(attacker_controlled_path, ...);`, you can potentially end up
opening a file outside the chroot. See
<a href="https://github.com/QubesOS/qubes-secpack/blob/master/QSBs/qsb-014-2015.txt">https://github.com/QubesOS/qubes-secpack/blob/master/QSBs/qsb-014-2015.txt</a>
for an example, where Qubes OS did pretty much that, and ended up with
a potentially exploitable security bug because of that, where one VM,
while performing a file transfer into another VM, could write outside
of the transfer target directory.
The problem is what happens if a folder you are walking through is
concurrently moved out of the chroot. Consider the following scenario:

You attempt to open "C/../../etc/passwd" under the root "/A/B".
Something else concurrently moves /A/B/C to /A/C. This can result in
the following:

1. You start the path walk and reach /A/B/C.
2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
3. Your path walk follows the first ".." up into /A. This is outside
the process root, but you never actually encountered the process root,
so you don't notice.
4. Your path walk follows the second ".." up to /. Again, this is
outside the process root, but you don't notice.
5. Your path walk walks down to /etc/passwd, and the open completes
successfully. You now have an fd pointing outside your chroot.

If the root of your walk is below an attacker-controlled directory,
this of course means that you lose instantly. If you point the root of
the walk at a directory out of which a process in the container
wouldn't be able to move the file, you're probably kinda mostly fine -
as long as you know, for certain, that nothing else on the system
would ever do that. But I still wouldn't feel good about that.

(Yes, this means that if you run an SFTP server with OpenSSH's
ChrootDirectory directive, you have to be very careful about these
things.)

I believe that the only way to robustly use this would be to point the
dirfd at a mount point, such that you know that being moved out of the
chroot is impossible because the mount point limits movement of
directories under it. (Well, technically, it doesn't, but it ensures
that if a directory does dangerously move away, the syscall fails.) It
might make sense to hardcode this constraint in the implementation of
AT_THIS_ROOT, to keep people from shooting themselves in the foot.

<span>&gt; Currently most container runtimes try to do this resolution in
&gt; userspace[1], causing many potential race conditions. In addition, the
&gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; requires a fork+exec which is *very* costly if necessary for every
&gt; filesystem operation involving a container.
</span>
Wait. fork() I understand, but why exec? And actually, you don't need
a full fork() either, clone() lets you do this with some process parts
shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
the file descriptor table shared. And why chroot()/pivot_root(),
wouldn't you want to use setns()? I think something like this should
work (except that you should add some error handling - omitted here
because I'm lazy), assuming that the container runtime does NOT have
CAP_SYS_ADMIN in the init namespace (otherwise it's easier). Of
course, this is entirely untested, and probably won't compile because
I screwed something up. :P But you should get the idea...

// Ensure that we are non-dumpable. Together with
// commit bfedb589252c, this ensures that container root
// can't trace our child once it enters the container.
// My patch
// <a href="https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/">https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/</a>
// would make this unnecessary, but that patch didn't
// land because Eric nacked it (for political reasons,
// because people incorrectly claimed that this was a
// security fix):
// <a href="https://lore.kernel.org/lkml/8760z7fope.fsf@x220.int.ebiederm.org/">https://lore.kernel.org/lkml/8760z7fope.fsf@x220.int.ebiederm.org/</a>
// Note that dumpability is per-mm, not per-process,
// so this hack has the unfortunate side effect of preventing
// unprivileged debugging of the container runtime.
// Oh well.
prctl(PR_SET_DUMPABLE, SUID_DUMP_DISABLE);
// Inform gcc that this particular syscall will effectively
// return twice, just like vfork() or setjmp().
__attribute__((returns_twice)) long syscall_(long sysno, ...) = (void*)syscall;
int result_fd = -1;
// CLONE_FILES means we don't need to do fd passing,
//     we share the file descriptor table.
// CLONE_VM means we don't have the cost of duplicating
//     our VMAs and page tables, and we don't have to mark
//     all our pagetable entries as readonly for copy-on-write.
// CLONE_VFORK is a dirty hack to avoid having to
//     allocate a child stack.
// Lack of SIGCHLD means we don't want to have to wait()
//     for the child.
int child_pid = syscall_(__NR_clone, CLONE_FILES|CLONE_VM|CLONE_VFORK,
0, 0, 0, 0);
if (child_pid == 0) {
  // Enter the container's user namespace; this allows us
  // to afterwards join its mount namespace even if we're
  // not capable in the init namespace.
  // (I believe that it should be possible to change the kernel
  // such that this is not required if you have set the
  // no-new-privs flag.)
  setns(container_user_ns_fd, CLONE_NEWUSER);
  // Entering the filesystem namespace automatically
  // moves us to that namespace's filesystem root.
  setns(container_fs_ns_fd, CLONE_NEWNS);
  result_fd = open(untrusted_container_path, ...);
  syscall(__NR_exit, 0);
}

<span>&gt; The most significant change in semantics with AT_THIS_ROOT is that
&gt; *at(2) syscalls now no longer have the property that an absolute
&gt; pathname causes the dirfd to be ignored completely (if LOOKUP_CHROOT is
&gt; specified). The reasoning behind this is that AT_THIS_ROOT necessarily
&gt; has to chroot-scope symlinks with absolute paths to dirfd, and so doing
&gt; it for the base path seems to be the most consistent behaviour (and also
&gt; avoids foot-gunning users who want to chroot-scope paths that might be
&gt; absolute).
&gt;
&gt; Currently this is only enabled for the stat(2) and openat(2) family (the
&gt; latter has its own flag O_THISROOT with the same semantics). Ideally
&gt; this flag would be supported by all *at(2) syscalls, but this will
&gt; require adding flags arguments to many of them (and will be done in a
&gt; separate patchset).
&gt;
&gt; [1]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>
&gt;
&gt; Cc: Eric Biederman &lt;ebiederm@xmission.com&gt;
&gt; Cc: Christian Brauner &lt;christian@brauner.io&gt;
&gt; Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
&gt; ---
&gt;  fs/fcntl.c                       |   2 +-
&gt;  fs/namei.c                       | 121 +++++++++++++++++--------------
&gt;  fs/open.c                        |   2 +
&gt;  fs/stat.c                        |   4 +-
&gt;  include/linux/fcntl.h            |   2 +-
&gt;  include/linux/namei.h            |   1 +
&gt;  include/uapi/asm-generic/fcntl.h |   3 +
&gt;  include/uapi/linux/fcntl.h       |   2 +
&gt;  8 files changed, 81 insertions(+), 56 deletions(-)
&gt;
&gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; index e343618736f7..4c36c5b9fdb9 100644
&gt; --- a/fs/fcntl.c
&gt; +++ b/fs/fcntl.c
&gt; @@ -1031,7 +1031,7 @@ static int __init fcntl_init(void)
&gt;          * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt;          * is defined as O_NONBLOCK on some platforms and not on others.
&gt;          */
&gt; -       BUILD_BUG_ON(25 - 1 /* for O_RDONLY being 0 */ !=
&gt; +       BUILD_BUG_ON(26 - 1 /* for O_RDONLY being 0 */ !=
&gt;                 HWEIGHT32(
&gt;                         (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt;                         __FMODE_EXEC | __FMODE_NONOTIFY));
&gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; index 757dd783771c..1b984f0dbbb4 100644
&gt; --- a/fs/namei.c
&gt; +++ b/fs/namei.c
&gt; @@ -2193,9 +2193,64 @@ static int link_path_walk(const char *name, struct nameidata *nd)
&gt;         }
&gt;  }
&gt;
&gt; +/*
&gt; + * Configure nd-&gt;path based on the nd-&gt;dfd. This is only used as part of
&gt; + * path_init().
&gt; + */
&gt; +static inline int dirfd_path_init(struct nameidata *nd)
&gt; +{
&gt; +       if (nd-&gt;dfd == AT_FDCWD) {
&gt; +               if (nd-&gt;flags &amp; LOOKUP_RCU) {
&gt; +                       struct fs_struct *fs = current-&gt;fs;
&gt; +                       unsigned seq;
&gt; +
&gt; +                       do {
&gt; +                               seq = read_seqcount_begin(&amp;fs-&gt;seq);
&gt; +                               nd-&gt;path = fs-&gt;pwd;
&gt; +                               nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; +                               nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
&gt; +                       } while (read_seqcount_retry(&amp;fs-&gt;seq, seq));
&gt; +               } else {
&gt; +                       get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path);
&gt; +                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; +               }
&gt; +       } else {
&gt; +               /* Caller must check execute permissions on the starting path component */
&gt; +               struct fd f = fdget_raw(nd-&gt;dfd);
&gt; +               struct dentry *dentry;
&gt; +
&gt; +               if (!f.file)
&gt; +                       return -EBADF;
&gt; +
&gt; +               dentry = f.file-&gt;f_path.dentry;
&gt; +
&gt; +               if (*nd-&gt;name-&gt;name &amp;&amp; unlikely(!d_can_lookup(dentry))) {
&gt; +                       fdput(f);
&gt; +                       return -ENOTDIR;
&gt; +               }
&gt; +
&gt; +               nd-&gt;path = f.file-&gt;f_path;
&gt; +               if (nd-&gt;flags &amp; LOOKUP_RCU) {
&gt; +                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; +                       nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
&gt; +               } else {
&gt; +                       path_get(&amp;nd-&gt;path);
&gt; +                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; +               }
&gt; +               fdput(f);
&gt; +       }
&gt; +       if (unlikely(nd-&gt;flags &amp; (LOOKUP_CHROOT | LOOKUP_BENEATH))) {
&gt; +               nd-&gt;root = nd-&gt;path;
&gt; +               if (!(nd-&gt;flags &amp; LOOKUP_RCU))
&gt; +                       path_get(&amp;nd-&gt;root);
&gt; +       }
&gt; +       return 0;
&gt; +}
&gt; +
&gt;  /* must be paired with terminate_walk() */
&gt;  static const char *path_init(struct nameidata *nd, unsigned flags)
&gt;  {
&gt; +       int error;
&gt;         const char *s = nd-&gt;name-&gt;name;
&gt;
&gt;         if (!*s)
&gt; @@ -2230,65 +2285,25 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
&gt;         nd-&gt;path.dentry = NULL;
&gt;
&gt;         nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
&gt; +       if (unlikely(flags &amp; LOOKUP_CHROOT)) {
&gt; +               error = dirfd_path_init(nd);
&gt; +               if (unlikely(error))
&gt; +                       return ERR_PTR(error);
&gt; +       }
&gt;         if (*s == '/') {
&gt; -               int error;
&gt; -               set_root(nd);
&gt; +               if (likely(!nd-&gt;root.mnt))
&gt; +                       set_root(nd);
&gt;                 error = nd_jump_root(nd);
&gt;                 if (unlikely(error))
&gt;                         s = ERR_PTR(error);
&gt;                 return s;
&gt; -       } else if (nd-&gt;dfd == AT_FDCWD) {
&gt; -               if (flags &amp; LOOKUP_RCU) {
&gt; -                       struct fs_struct *fs = current-&gt;fs;
&gt; -                       unsigned seq;
&gt; -
&gt; -                       do {
&gt; -                               seq = read_seqcount_begin(&amp;fs-&gt;seq);
&gt; -                               nd-&gt;path = fs-&gt;pwd;
&gt; -                               nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; -                               nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
&gt; -                       } while (read_seqcount_retry(&amp;fs-&gt;seq, seq));
&gt; -               } else {
&gt; -                       get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path);
&gt; -                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; -               }
&gt; -               if (unlikely(flags &amp; LOOKUP_BENEATH)) {
&gt; -                       nd-&gt;root = nd-&gt;path;
&gt; -                       if (!(flags &amp; LOOKUP_RCU))
&gt; -                               path_get(&amp;nd-&gt;root);
&gt; -               }
&gt; -               return s;
&gt; -       } else {
&gt; -               /* Caller must check execute permissions on the starting path component */
&gt; -               struct fd f = fdget_raw(nd-&gt;dfd);
&gt; -               struct dentry *dentry;
&gt; -
&gt; -               if (!f.file)
&gt; -                       return ERR_PTR(-EBADF);
&gt; -
&gt; -               dentry = f.file-&gt;f_path.dentry;
&gt; -
&gt; -               if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) {
&gt; -                       fdput(f);
&gt; -                       return ERR_PTR(-ENOTDIR);
&gt; -               }
&gt; -
&gt; -               nd-&gt;path = f.file-&gt;f_path;
&gt; -               if (flags &amp; LOOKUP_RCU) {
&gt; -                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; -                       nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
&gt; -               } else {
&gt; -                       path_get(&amp;nd-&gt;path);
&gt; -                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; -               }
&gt; -               if (unlikely(flags &amp; LOOKUP_BENEATH)) {
&gt; -                       nd-&gt;root = nd-&gt;path;
&gt; -                       if (!(flags &amp; LOOKUP_RCU))
&gt; -                               path_get(&amp;nd-&gt;root);
&gt; -               }
&gt; -               fdput(f);
&gt; -               return s;
&gt;         }
&gt; +       if (likely(!nd-&gt;path.mnt)) {
&gt; +               error = dirfd_path_init(nd);
&gt; +               if (unlikely(error))
&gt; +                       return ERR_PTR(error);
&gt; +       }
&gt; +       return s;
&gt;  }
&gt;
&gt;  static const char *trailing_symlink(struct nameidata *nd)
&gt; diff --git a/fs/open.c b/fs/open.c
&gt; index 80f5f566a5ff..81d148f626cd 100644
&gt; --- a/fs/open.c
&gt; +++ b/fs/open.c
&gt; @@ -996,6 +996,8 @@ static inline int build_open_flags(int flags, umode_t mode, struct open_flags *o
&gt;                 lookup_flags |= LOOKUP_NO_PROCLINKS;
&gt;         if (flags &amp; O_NOSYMLINKS)
&gt;                 lookup_flags |= LOOKUP_NO_SYMLINKS;
&gt; +       if (flags &amp; O_THISROOT)
&gt; +               lookup_flags |= LOOKUP_CHROOT;
&gt;         op-&gt;lookup_flags = lookup_flags;
&gt;         return 0;
&gt;  }
&gt; diff --git a/fs/stat.c b/fs/stat.c
&gt; index 791e61b916ae..e8366e4812c3 100644
&gt; --- a/fs/stat.c
&gt; +++ b/fs/stat.c
&gt; @@ -172,7 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
&gt;
&gt;         if (flags &amp; ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT | AT_EMPTY_PATH |
&gt;                       KSTAT_QUERY_FLAGS | AT_BENEATH | AT_XDEV |
&gt; -                     AT_NO_PROCLINKS | AT_NO_SYMLINKS))
&gt; +                     AT_NO_PROCLINKS | AT_NO_SYMLINKS | AT_THIS_ROOT))
&gt;                 return -EINVAL;
&gt;
&gt;         if (flags &amp; AT_SYMLINK_NOFOLLOW)
&gt; @@ -189,6 +189,8 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
&gt;                 lookup_flags |= LOOKUP_NO_PROCLINKS;
&gt;         if (flags &amp; AT_NO_SYMLINKS)
&gt;                 lookup_flags |= LOOKUP_NO_SYMLINKS;
&gt; +       if (flags &amp; AT_THIS_ROOT)
&gt; +               lookup_flags |= LOOKUP_CHROOT;
&gt;
&gt;  retry:
&gt;         error = user_path_at(dfd, filename, lookup_flags, &amp;path);
&gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; index ad5bba4b5b12..95480cd4c09d 100644
&gt; --- a/include/linux/fcntl.h
&gt; +++ b/include/linux/fcntl.h
&gt; @@ -10,7 +10,7 @@
&gt;          O_APPEND | O_NDELAY | O_NONBLOCK | O_NDELAY | __O_SYNC | O_DSYNC | \
&gt;          FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt;          O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_BENEATH | O_XDEV | \
&gt; -        O_NOPROCLINKS | O_NOSYMLINKS)
&gt; +        O_NOPROCLINKS | O_NOSYMLINKS | O_THISROOT)
&gt;
&gt;  #ifndef force_o_largefile
&gt;  #define force_o_largefile() (BITS_PER_LONG != 32)
&gt; diff --git a/include/linux/namei.h b/include/linux/namei.h
&gt; index 5ff7f3362d1b..7ec9e2d84649 100644
&gt; --- a/include/linux/namei.h
&gt; +++ b/include/linux/namei.h
&gt; @@ -53,6 +53,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
&gt;  #define LOOKUP_NO_PROCLINKS    0x040000 /* No /proc/$pid/fd/ "symlink" crossing. */
&gt;  #define LOOKUP_NO_SYMLINKS     0x080000 /* No symlink crossing *at all*.
&gt;                                             Implies LOOKUP_NO_PROCLINKS. */
&gt; +#define LOOKUP_CHROOT          0x100000 /* Treat dirfd as %current-&gt;fs-&gt;root. */
&gt;
&gt;  extern int path_pts(struct path *path);
&gt;
&gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; index c2bf5983e46a..11206b0e927c 100644
&gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; @@ -113,6 +113,9 @@
&gt;  #ifndef O_NOSYMLINKS
&gt;  #define O_NOSYMLINKS   01000000000
&gt;  #endif
&gt; +#ifndef O_THISROOT
&gt; +#define O_THISROOT     02000000000
&gt; +#endif
&gt;
&gt;  #define F_DUPFD                0       /* dup */
&gt;  #define F_GETFD                1       /* get close_on_exec */
&gt; diff --git a/include/uapi/linux/fcntl.h b/include/uapi/linux/fcntl.h
&gt; index 551a9e2166a8..ea978457b68f 100644
&gt; --- a/include/uapi/linux/fcntl.h
&gt; +++ b/include/uapi/linux/fcntl.h
&gt; @@ -99,6 +99,8 @@
&gt;  #define AT_NO_PROCLINKS                0x40000 /* No /proc/$pid/fd/... "symlinks". */
&gt;  #define AT_NO_SYMLINKS         0x80000 /* No symlinks *at all*.
&gt;                                            Implies AT_NO_PROCLINKS. */
&gt; +#define AT_THIS_ROOT           0x100000 /* Path resolution acts as though
&gt; +                                          it is chroot-ed into dirfd. */
&gt;
&gt;
&gt;  #endif /* _UAPI_LINUX_FCNTL_H */
&gt; --
&gt; 2.19.0
&gt;
&gt;
</span>
<a href="#m85db30139fa0747cca01a4a7b71ba3f88ab3207c" id="e85db30139fa0747cca01a4a7b71ba3f88ab3207c">^</a> <a href="https://lore.kernel.org/lkml/CAG48ez30WJhbsro2HOc_DR7V91M+hNFzBP5ogRMZaxbAORvqzg@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CAG48ez30WJhbsro2HOc_DR7V91M+hNFzBP5ogRMZaxbAORvqzg@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CAG48ez30WJhbsro2HOc_DR7V91M+hNFzBP5ogRMZaxbAORvqzg@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CAG48ez30WJhbsro2HOc_DR7V91M+hNFzBP5ogRMZaxbAORvqzg@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CAG48ez30WJhbsro2HOc_DR7V91M+hNFzBP5ogRMZaxbAORvqzg@mail.gmail.com/t/#u">nested</a>] <a href="#r85db30139fa0747cca01a4a7b71ba3f88ab3207c">53+ messages in thread</a></pre><hr><pre><a href="#e55dcd0750c094ebe0bc62c39c395b0163bb41bf2" id="m55dcd0750c094ebe0bc62c39c395b0163bb41bf2">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-09-29 16:35   ` <a href="#m85db30139fa0747cca01a4a7b71ba3f88ab3207c">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Jann Horn
<b>@ 2018-09-29 17:25     ` Andy Lutomirski</b>
  2018-10-01  9:46       ` <a href="#m1f79f0bf1b6db2badf3e2e999b8ef7acd303a661">Aleksa Sarai</a>
  2018-10-01  5:44     ` <a href="#mbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">Aleksa Sarai</a>
                       ` <a href="#rbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">(2 subsequent siblings)</a>
  <a href="#r55dcd0750c094ebe0bc62c39c395b0163bb41bf2">3 siblings, 1 reply; 53+ messages in thread</a>
From: Andy Lutomirski @ 2018-09-29 17:25 UTC (<a href="https://lore.kernel.org/lkml/F0E08B90-F10B-4897-913D-CA18E99A987D@amacapital.net/">permalink</a> / <a href="https://lore.kernel.org/lkml/F0E08B90-F10B-4897-913D-CA18E99A987D@amacapital.net/raw">raw</a>)
  To: Jann Horn
  Cc: cyphar, Eric W. Biederman, jlayton, Bruce Fields, Al Viro,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski, christian,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API



<span>&gt; On Sep 29, 2018, at 9:35 AM, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; 
&gt; +cc linux-api; please keep them in CC for future versions of the patch
&gt; 
&gt;&gt; On Sat, Sep 29, 2018 at 4:29 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt;&gt; The primary motivation for the need for this flag is container runtimes
&gt;&gt; which have to interact with malicious root filesystems in the host
&gt;&gt; namespaces. One of the first requirements for a container runtime to be
&gt;&gt; secure against a malicious rootfs is that they correctly scope symlinks
&gt;&gt; (that is, they should be scoped as though they are chroot(2)ed into the
&gt;&gt; container's rootfs) and ".."-style paths. The already-existing AT_XDEV
&gt;&gt; and AT_NO_PROCLINKS help defend against other potential attacks in a
&gt;&gt; malicious rootfs scenario.
&gt; 
&gt; So, I really like the concept for patch 1 of this series (but haven't
&gt; read the code yet); but I dislike this patch because of its footgun
&gt; potential.
&gt; 
</span>
The code could do it differently: do the path walk and then, before accepting the result, walk back up and make sure the result is under the starting point.

This is *not* a full solution, though, since a walk above the root gas side effects on timing, various caches, and possibly network traffic, so its open to Spectre-like attacks in which a malicious container could use a runtime-initiated AT_THIS_ROOT to infer the existence of directories outside the container.

But whats the container usecase?  Any sane container is based on pivot_root or similar, so the runtime can just do the walk in the container context. IOW Im a bit confused as to the exact intended use of the whole series. Can you elaborate?

<a href="#m55dcd0750c094ebe0bc62c39c395b0163bb41bf2" id="e55dcd0750c094ebe0bc62c39c395b0163bb41bf2">^</a> <a href="https://lore.kernel.org/lkml/F0E08B90-F10B-4897-913D-CA18E99A987D@amacapital.net/">permalink</a> <a href="https://lore.kernel.org/lkml/F0E08B90-F10B-4897-913D-CA18E99A987D@amacapital.net/raw">raw</a> <a href="https://lore.kernel.org/lkml/F0E08B90-F10B-4897-913D-CA18E99A987D@amacapital.net/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/F0E08B90-F10B-4897-913D-CA18E99A987D@amacapital.net/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/F0E08B90-F10B-4897-913D-CA18E99A987D@amacapital.net/t/#u">nested</a>] <a href="#r55dcd0750c094ebe0bc62c39c395b0163bb41bf2">53+ messages in thread</a></pre><hr><pre><a href="#ea8e202c0d14e5763bfff6e7338febd7d1a51a83f" id="ma8e202c0d14e5763bfff6e7338febd7d1a51a83f">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 16:34     ` <a href="#ma7d3a3f2eecc4c0cc375a249b47e94e33377c744">Andy Lutomirski</a>
<b>@ 2018-09-29 19:44       ` Matthew Wilcox</b>
  <a href="#ra8e202c0d14e5763bfff6e7338febd7d1a51a83f">0 siblings, 0 replies; 53+ messages in thread</a>
From: Matthew Wilcox @ 2018-09-29 19:44 UTC (<a href="https://lore.kernel.org/lkml/20180929194429.GA1702@bombadil.infradead.org/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180929194429.GA1702@bombadil.infradead.org/raw">raw</a>)
  To: Andy Lutomirski
  Cc: Aleksa Sarai, Jeff Layton, J. Bruce Fields, Al Viro,
	Arnd Bergmann, Shuah Khan, David Howells, Andy Lutomirski,
	Christian Brauner, Eric Biederman, Tycho Andersen, linux-kernel,
	linux-fsdevel, linux-arch, linux-kselftest, dev, containers

On Sat, Sep 29, 2018 at 09:34:24AM -0700, Andy Lutomirski wrote:
<span>&gt; Also, as a perhaps-silly suggestion: if you end up adding a new
&gt; syscall, I can see a use for a mode that does the path walk but, rather
&gt; than failing on a disallowed link, stops early and indicates where it
&gt; stopped. Then web servers, samba, etc can more efficiently implement
&gt; custom behavior when links are encountered.  And it may also be useful
&gt; to have a variant of AT_THIS_ROOT where trying to escape is an error
&gt; instead of having it just get stuck at the root.
</span>
AT_USER_LINKS indicating that userspace wants to resolve symlinks
themselves?

<a href="#ma8e202c0d14e5763bfff6e7338febd7d1a51a83f" id="ea8e202c0d14e5763bfff6e7338febd7d1a51a83f">^</a> <a href="https://lore.kernel.org/lkml/20180929194429.GA1702@bombadil.infradead.org/">permalink</a> <a href="https://lore.kernel.org/lkml/20180929194429.GA1702@bombadil.infradead.org/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180929194429.GA1702@bombadil.infradead.org/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180929194429.GA1702@bombadil.infradead.org/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180929194429.GA1702@bombadil.infradead.org/t/#u">nested</a>] <a href="#ra8e202c0d14e5763bfff6e7338febd7d1a51a83f">53+ messages in thread</a></pre><hr><pre><a href="#e87f541d8dc933342c485dd668073dfec153d374c" id="m87f541d8dc933342c485dd668073dfec153d374c">*</a> <b>Re: [PATCH 1/3] namei: implement O_BENEATH-style AT_* flags</b>
  2018-09-29 10:34 ` <a href="#m1383f86e3b88f40c8cb1ba987680029c591c723c">[PATCH 1/3] namei: implement O_BENEATH-style</a> " Aleksa Sarai
  2018-09-29 14:48   ` <a href="#mbb17b5e39af1ab7962ea44cc159ac0b57a3386fd">Christian Brauner</a>
<b>@ 2018-09-30  4:38   ` Aleksa Sarai</b>
  2018-10-01 12:28   ` <a href="#m00fa1270161fca853ab401153f61255570562b60">Jann Horn</a>
  <a href="#r87f541d8dc933342c485dd668073dfec153d374c">2 siblings, 0 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-09-30  4:38 UTC (<a href="https://lore.kernel.org/lkml/20180930043823.2pgzrtgcziaou7ov@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180930043823.2pgzrtgcziaou7ov@ryuk/raw">raw</a>)
  To: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan
  Cc: David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Aleksa Sarai, Tycho Andersen, linux-kernel,
	linux-fsdevel, linux-arch, linux-kselftest, dev, containers

<a href="https://lore.kernel.org/lkml/20180930043823.2pgzrtgcziaou7ov@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 941 bytes --]</a>

On 2018-09-29, Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
<span>&gt; * AT_XDEV: Disallow mount-point crossing (both *down* into one, or *up*
&gt;   from one). The primary "scoping" use is to blocking resolution that
&gt;   crosses a bind-mount, which has a similar property to a symlink (in
&gt;   the way that it allows for escape from the starting-point). Since it
&gt;   is not possible to differentiate bind-mounts However since
&gt;   bind-mounting requires privileges (in ways symlinks don't) this has
&gt;   been split from LOOKUP_BENEATH. The naming is based on "find -xdev"
&gt;   (though find(1) doesn't walk upwards, the semantics seem obvious).
</span>
I've just noticed that the mountpoint-crossing code for AT_XDEV doesn't
detect things like:

   % ln -s / /tmp/jumpup
   % vfs_helper -o open -F xdev -d /tmp jumpup
   /

I will fix that in v2.

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20180930043823.2pgzrtgcziaou7ov@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#m87f541d8dc933342c485dd668073dfec153d374c" id="e87f541d8dc933342c485dd668073dfec153d374c">^</a> <a href="https://lore.kernel.org/lkml/20180930043823.2pgzrtgcziaou7ov@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20180930043823.2pgzrtgcziaou7ov@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180930043823.2pgzrtgcziaou7ov@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180930043823.2pgzrtgcziaou7ov@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180930043823.2pgzrtgcziaou7ov@ryuk/t/#u">nested</a>] <a href="#r87f541d8dc933342c485dd668073dfec153d374c">53+ messages in thread</a></pre><hr><pre><a href="#ee5648719f5bf462dbe857542b9eac97ec3340a8f" id="me5648719f5bf462dbe857542b9eac97ec3340a8f">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 14:38 ` <a href="#m721f6dd62a1bdc1658cc2a2ea8b21397577190c7">Christian Brauner</a>
<b>@ 2018-09-30  4:44   ` Aleksa Sarai</b>
  <a href="#re5648719f5bf462dbe857542b9eac97ec3340a8f">0 siblings, 0 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-09-30  4:44 UTC (<a href="https://lore.kernel.org/lkml/20180930044411.orcuw7xok4szqzzo@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20180930044411.orcuw7xok4szqzzo@ryuk/raw">raw</a>)
  To: Christian Brauner
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Eric Biederman, Tycho Andersen,
	linux-kernel, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers

<a href="https://lore.kernel.org/lkml/20180930044411.orcuw7xok4szqzzo@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 1054 bytes --]</a>

On 2018-09-29, Christian Brauner &lt;christian@brauner.io&gt; wrote:
<span>&gt; &gt; Currently I've only enabled these for openat(2) and the stat(2) family.
&gt; &gt; I would hope we could enable it for basically every *at(2) syscall --
&gt; &gt; but many of them appear to not have a @flags argument and thus we'll
&gt; &gt; need to add several new syscalls to do this. I'm more than happy to send
&gt; &gt; those patches, but I'd prefer to know that this preliminary work is
&gt; &gt; acceptable before doing a bunch of copy-paste to add new sets of *at(2)
&gt; &gt; syscalls.
&gt; 
&gt; We should really make sure that we can't make due with openat() alone
&gt; before adding a bunch of new syscalls. So there's no need to rush into
&gt; this. :)
</span>
Yeah, I think that we could (mostly) make do with openat(2). We might
need to have renameat(2) and a few others, but if we had more support
for AT_EMPTY_PATH you should be able to just O_PATH|O_{BENEATH,XDEV,...}
and then operate on the O_PATH fd.

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20180930044411.orcuw7xok4szqzzo@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#me5648719f5bf462dbe857542b9eac97ec3340a8f" id="ee5648719f5bf462dbe857542b9eac97ec3340a8f">^</a> <a href="https://lore.kernel.org/lkml/20180930044411.orcuw7xok4szqzzo@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20180930044411.orcuw7xok4szqzzo@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20180930044411.orcuw7xok4szqzzo@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20180930044411.orcuw7xok4szqzzo@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20180930044411.orcuw7xok4szqzzo@ryuk/t/#u">nested</a>] <a href="#re5648719f5bf462dbe857542b9eac97ec3340a8f">53+ messages in thread</a></pre><hr><pre><a href="#ecd41f1f73fed393394dbf021d3b8dd2c678b37c3" id="mcd41f1f73fed393394dbf021d3b8dd2c678b37c3">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 10:34 <a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Aleksa Sarai
                   ` <a href="#r721f6dd62a1bdc1658cc2a2ea8b21397577190c7">(3 preceding siblings ...)</a>
  2018-09-29 14:38 ` <a href="#m721f6dd62a1bdc1658cc2a2ea8b21397577190c7">Christian Brauner</a>
<b>@ 2018-09-30 13:54 ` Alban Crequy</b>
  2018-09-30 14:02   ` <a href="#m76bb4a153a3c330bc4b0436f64935f15b304cae1">Christian Brauner</a>
  2018-09-30 19:45 ` <a href="#mdf028b806a86c9a075bc1ebf67e0e630a54a2ba6">Mickal Salan</a>
                   ` <a href="#rdf028b806a86c9a075bc1ebf67e0e630a54a2ba6">(2 subsequent siblings)</a>
  <a href="#rcd41f1f73fed393394dbf021d3b8dd2c678b37c3">7 siblings, 1 reply; 53+ messages in thread</a>
From: Alban Crequy @ 2018-09-30 13:54 UTC (<a href="https://lore.kernel.org/lkml/CADZs7q5mFGMvtbAHzjKdC8b7byz8pvBOaLBOTxnXRwTZ1LfCAw@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CADZs7q5mFGMvtbAHzjKdC8b7byz8pvBOaLBOTxnXRwTZ1LfCAw@mail.gmail.com/raw">raw</a>)
  To: cyphar
  Cc: jlayton, bfields, Alexander Viro, arnd, shuah, dhowells, luto,
	christian, Eric W . Biederman, tycho, LKML, linux-fsdevel,
	linux-arch, linux-kselftest, dev, Linux Containers, jsafrane,
	msau

On Sat, Sep 29, 2018 at 12:35 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
<span>&gt;
&gt; The need for some sort of control over VFS's path resolution (to avoid
&gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt; long-standing desire of many userspace applications. This patchset is a
&gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.
&gt;
&gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt; which means that each individual property of AT_NO_JUMPS is now a
&gt; separate flag:
&gt;
&gt;   * Path-based escapes from the starting-point using "/" or ".." are
&gt;     blocked by AT_BENEATH.
&gt;   * Mountpoint crossings are blocked by AT_XDEV.
&gt;   * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt;         correctly it actually blocks any user of nd_jump_link() because it
&gt;         allows out-of-VFS path resolution manipulation).
&gt;
&gt; AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS). At
&gt; Linus' suggestion in the original thread, I've also implemented
&gt; AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
&gt; "proclink" resolution).
</span>
It seems quite useful to me.

<span>&gt; An additional improvement was made to AT_XDEV. The original AT_NO_JUMPS
&gt; path didn't consider "/tmp/.." as a mountpoint crossing -- this patch
&gt; blocks this as well (feel free to ask me to remove it if you feel this
&gt; is not sane).
&gt;
&gt; Currently I've only enabled these for openat(2) and the stat(2) family.
&gt; I would hope we could enable it for basically every *at(2) syscall --
&gt; but many of them appear to not have a @flags argument and thus we'll
&gt; need to add several new syscalls to do this. I'm more than happy to send
&gt; those patches, but I'd prefer to know that this preliminary work is
&gt; acceptable before doing a bunch of copy-paste to add new sets of *at(2)
&gt; syscalls.
</span>
What do you think of an equivalent feature AT_NO_SYMLINKS flag for mount()?

I guess that would have made the fix for CVE-2017-1002101 in
Kubernetes easier to write:
<a href="https://kubernetes.io/blog/2018/04/04/fixing-subpath-volume-vulnerability/">https://kubernetes.io/blog/2018/04/04/fixing-subpath-volume-vulnerability/</a>

<span>&gt; One additional feature I've implemented is AT_THIS_ROOT (I imagine this
&gt; is probably going to be more contentious than the refresh of
&gt; AT_NO_JUMPS, so I've included it in a separate patch). The patch itself
&gt; describes my reasoning, but the shortened version of the premise is that
&gt; continer runtimes need to have a way to resolve paths within a
&gt; potentially malicious rootfs. Container runtimes currently do this in
&gt; userspace[2] which has implicit race conditions that are not resolvable
&gt; in userspace (or use fork+exec+chroot and SCM_RIGHTS passing which is
&gt; inefficient). AT_THIS_ROOT allows for per-call chroot-like semantics for
&gt; path resolution, which would be invaluable for us -- and the
&gt; implementation is basically identical to AT_BENEATH (except that we
&gt; don't return errors when someone actually hits the root).
&gt;
&gt; I've added some selftests for this, but it's not clear to me whether
&gt; they should live here or in xfstests (as far as I can tell there are no
&gt; other VFS tests in selftests, while there are some tests that look like
&gt; generic VFS tests in xfstests). If you'd prefer them to be included in
&gt; xfstests, let me know.
&gt;
&gt; [1]: <a href="https://lore.kernel.org/patchwork/patch/784221/">https://lore.kernel.org/patchwork/patch/784221/</a>
&gt; [2]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>
&gt;
&gt; Aleksa Sarai (3):
&gt;   namei: implement O_BENEATH-style AT_* flags
&gt;   namei: implement AT_THIS_ROOT chroot-like path resolution
&gt;   selftests: vfs: add AT_* path resolution tests
&gt;
&gt;  fs/fcntl.c                                    |   2 +-
&gt;  fs/namei.c                                    | 158 ++++++++++++------
&gt;  fs/open.c                                     |  10 ++
&gt;  fs/stat.c                                     |  15 +-
&gt;  include/linux/fcntl.h                         |   3 +-
&gt;  include/linux/namei.h                         |   8 +
&gt;  include/uapi/asm-generic/fcntl.h              |  20 +++
&gt;  include/uapi/linux/fcntl.h                    |  10 ++
&gt;  tools/testing/selftests/Makefile              |   1 +
&gt;  tools/testing/selftests/vfs/.gitignore        |   1 +
&gt;  tools/testing/selftests/vfs/Makefile          |  13 ++
&gt;  tools/testing/selftests/vfs/at_flags.h        |  40 +++++
&gt;  tools/testing/selftests/vfs/common.sh         |  37 ++++
&gt;  .../selftests/vfs/tests/0001_at_beneath.sh    |  72 ++++++++
&gt;  .../selftests/vfs/tests/0002_at_xdev.sh       |  54 ++++++
&gt;  .../vfs/tests/0003_at_no_proclinks.sh         |  50 ++++++
&gt;  .../vfs/tests/0004_at_no_symlinks.sh          |  49 ++++++
&gt;  .../selftests/vfs/tests/0005_at_this_root.sh  |  66 ++++++++
&gt;  tools/testing/selftests/vfs/vfs_helper.c      | 154 +++++++++++++++++
&gt;  19 files changed, 707 insertions(+), 56 deletions(-)
&gt;  create mode 100644 tools/testing/selftests/vfs/.gitignore
&gt;  create mode 100644 tools/testing/selftests/vfs/Makefile
&gt;  create mode 100644 tools/testing/selftests/vfs/at_flags.h
&gt;  create mode 100644 tools/testing/selftests/vfs/common.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0001_at_beneath.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0002_at_xdev.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0005_at_this_root.sh
&gt;  create mode 100644 tools/testing/selftests/vfs/vfs_helper.c
&gt;
&gt; --
&gt; 2.19.0
</span>
<a href="#mcd41f1f73fed393394dbf021d3b8dd2c678b37c3" id="ecd41f1f73fed393394dbf021d3b8dd2c678b37c3">^</a> <a href="https://lore.kernel.org/lkml/CADZs7q5mFGMvtbAHzjKdC8b7byz8pvBOaLBOTxnXRwTZ1LfCAw@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CADZs7q5mFGMvtbAHzjKdC8b7byz8pvBOaLBOTxnXRwTZ1LfCAw@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CADZs7q5mFGMvtbAHzjKdC8b7byz8pvBOaLBOTxnXRwTZ1LfCAw@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CADZs7q5mFGMvtbAHzjKdC8b7byz8pvBOaLBOTxnXRwTZ1LfCAw@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CADZs7q5mFGMvtbAHzjKdC8b7byz8pvBOaLBOTxnXRwTZ1LfCAw@mail.gmail.com/t/#u">nested</a>] <a href="#rcd41f1f73fed393394dbf021d3b8dd2c678b37c3">53+ messages in thread</a></pre><hr><pre><a href="#e76bb4a153a3c330bc4b0436f64935f15b304cae1" id="m76bb4a153a3c330bc4b0436f64935f15b304cae1">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-30 13:54 ` <a href="#mcd41f1f73fed393394dbf021d3b8dd2c678b37c3">Alban Crequy</a>
<b>@ 2018-09-30 14:02   ` Christian Brauner</b>
  <a href="#r76bb4a153a3c330bc4b0436f64935f15b304cae1">0 siblings, 0 replies; 53+ messages in thread</a>
From: Christian Brauner @ 2018-09-30 14:02 UTC (<a href="https://lore.kernel.org/lkml/58BB23FF-E652-4C58-AEE4-4B5376D03BF0@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/58BB23FF-E652-4C58-AEE4-4B5376D03BF0@brauner.io/raw">raw</a>)
  To: Alban Crequy, cyphar
  Cc: jlayton, bfields, Alexander Viro, arnd, shuah, dhowells, luto,
	Eric W . Biederman, tycho, LKML, linux-fsdevel, linux-arch,
	linux-kselftest, dev, Linux Containers, jsafrane, msau

On September 30, 2018 3:54:31 PM GMT+02:00, Alban Crequy &lt;alban@kinvolk.io&gt; wrote:
<span>&gt;On Sat, Sep 29, 2018 at 12:35 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt;
&gt;wrote:
&gt;&gt;
&gt;&gt; The need for some sort of control over VFS's path resolution (to
&gt;avoid
&gt;&gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt;&gt; long-standing desire of many userspace applications. This patchset is
&gt;a
&gt;&gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few
&gt;additions.
&gt;&gt;
&gt;&gt; The most obvious change is that AT_NO_JUMPS has been split as
&gt;dicussed
&gt;&gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt;&gt; which means that each individual property of AT_NO_JUMPS is now a
&gt;&gt; separate flag:
&gt;&gt;
&gt;&gt;   * Path-based escapes from the starting-point using "/" or ".." are
&gt;&gt;     blocked by AT_BENEATH.
&gt;&gt;   * Mountpoint crossings are blocked by AT_XDEV.
&gt;&gt;   * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt;&gt;         correctly it actually blocks any user of nd_jump_link()
&gt;because it
&gt;&gt;         allows out-of-VFS path resolution manipulation).
&gt;&gt;
&gt;&gt; AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS).
&gt;At
&gt;&gt; Linus' suggestion in the original thread, I've also implemented
&gt;&gt; AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
&gt;&gt; "proclink" resolution).
&gt;
&gt;It seems quite useful to me.
&gt;
&gt;&gt; An additional improvement was made to AT_XDEV. The original
&gt;AT_NO_JUMPS
&gt;&gt; path didn't consider "/tmp/.." as a mountpoint crossing -- this patch
&gt;&gt; blocks this as well (feel free to ask me to remove it if you feel
&gt;this
&gt;&gt; is not sane).
&gt;&gt;
&gt;&gt; Currently I've only enabled these for openat(2) and the stat(2)
&gt;family.
&gt;&gt; I would hope we could enable it for basically every *at(2) syscall --
&gt;&gt; but many of them appear to not have a @flags argument and thus we'll
&gt;&gt; need to add several new syscalls to do this. I'm more than happy to
&gt;send
&gt;&gt; those patches, but I'd prefer to know that this preliminary work is
&gt;&gt; acceptable before doing a bunch of copy-paste to add new sets of
&gt;*at(2)
&gt;&gt; syscalls.
&gt;
&gt;What do you think of an equivalent feature AT_NO_SYMLINKS flag for
&gt;mount()?
</span>
That's something we discussed  but that would need to be part of the new mount API work by David. The current mount API doesn't take AT_* flags since it doesn't operate on fds and we're (sort of) out of mount flags.

<span>&gt;
&gt;I guess that would have made the fix for CVE-2017-1002101 in
&gt;Kubernetes easier to write:
&gt;<a href="https://kubernetes.io/blog/2018/04/04/fixing-subpath-volume-vulnerability/">https://kubernetes.io/blog/2018/04/04/fixing-subpath-volume-vulnerability/</a>
&gt;
&gt;&gt; One additional feature I've implemented is AT_THIS_ROOT (I imagine
&gt;this
&gt;&gt; is probably going to be more contentious than the refresh of
&gt;&gt; AT_NO_JUMPS, so I've included it in a separate patch). The patch
&gt;itself
&gt;&gt; describes my reasoning, but the shortened version of the premise is
&gt;that
&gt;&gt; continer runtimes need to have a way to resolve paths within a
&gt;&gt; potentially malicious rootfs. Container runtimes currently do this in
&gt;&gt; userspace[2] which has implicit race conditions that are not
&gt;resolvable
&gt;&gt; in userspace (or use fork+exec+chroot and SCM_RIGHTS passing which is
&gt;&gt; inefficient). AT_THIS_ROOT allows for per-call chroot-like semantics
&gt;for
&gt;&gt; path resolution, which would be invaluable for us -- and the
&gt;&gt; implementation is basically identical to AT_BENEATH (except that we
&gt;&gt; don't return errors when someone actually hits the root).
&gt;&gt;
&gt;&gt; I've added some selftests for this, but it's not clear to me whether
&gt;&gt; they should live here or in xfstests (as far as I can tell there are
&gt;no
&gt;&gt; other VFS tests in selftests, while there are some tests that look
&gt;like
&gt;&gt; generic VFS tests in xfstests). If you'd prefer them to be included
&gt;in
&gt;&gt; xfstests, let me know.
&gt;&gt;
&gt;&gt; [1]: <a href="https://lore.kernel.org/patchwork/patch/784221/">https://lore.kernel.org/patchwork/patch/784221/</a>
&gt;&gt; [2]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>
&gt;&gt;
&gt;&gt; Aleksa Sarai (3):
&gt;&gt;   namei: implement O_BENEATH-style AT_* flags
&gt;&gt;   namei: implement AT_THIS_ROOT chroot-like path resolution
&gt;&gt;   selftests: vfs: add AT_* path resolution tests
&gt;&gt;
&gt;&gt;  fs/fcntl.c                                    |   2 +-
&gt;&gt;  fs/namei.c                                    | 158
&gt;++++++++++++------
&gt;&gt;  fs/open.c                                     |  10 ++
&gt;&gt;  fs/stat.c                                     |  15 +-
&gt;&gt;  include/linux/fcntl.h                         |   3 +-
&gt;&gt;  include/linux/namei.h                         |   8 +
&gt;&gt;  include/uapi/asm-generic/fcntl.h              |  20 +++
&gt;&gt;  include/uapi/linux/fcntl.h                    |  10 ++
&gt;&gt;  tools/testing/selftests/Makefile              |   1 +
&gt;&gt;  tools/testing/selftests/vfs/.gitignore        |   1 +
&gt;&gt;  tools/testing/selftests/vfs/Makefile          |  13 ++
&gt;&gt;  tools/testing/selftests/vfs/at_flags.h        |  40 +++++
&gt;&gt;  tools/testing/selftests/vfs/common.sh         |  37 ++++
&gt;&gt;  .../selftests/vfs/tests/0001_at_beneath.sh    |  72 ++++++++
&gt;&gt;  .../selftests/vfs/tests/0002_at_xdev.sh       |  54 ++++++
&gt;&gt;  .../vfs/tests/0003_at_no_proclinks.sh         |  50 ++++++
&gt;&gt;  .../vfs/tests/0004_at_no_symlinks.sh          |  49 ++++++
&gt;&gt;  .../selftests/vfs/tests/0005_at_this_root.sh  |  66 ++++++++
&gt;&gt;  tools/testing/selftests/vfs/vfs_helper.c      | 154
&gt;+++++++++++++++++
&gt;&gt;  19 files changed, 707 insertions(+), 56 deletions(-)
&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/.gitignore
&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/Makefile
&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/at_flags.h
&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/common.sh
&gt;&gt;  create mode 100755
&gt;tools/testing/selftests/vfs/tests/0001_at_beneath.sh
&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0002_at_xdev.sh
&gt;&gt;  create mode 100755
&gt;tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
&gt;&gt;  create mode 100755
&gt;tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
&gt;&gt;  create mode 100755
&gt;tools/testing/selftests/vfs/tests/0005_at_this_root.sh
&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/vfs_helper.c
&gt;&gt;
&gt;&gt; --
&gt;&gt; 2.19.0
</span>

<a href="#m76bb4a153a3c330bc4b0436f64935f15b304cae1" id="e76bb4a153a3c330bc4b0436f64935f15b304cae1">^</a> <a href="https://lore.kernel.org/lkml/58BB23FF-E652-4C58-AEE4-4B5376D03BF0@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/58BB23FF-E652-4C58-AEE4-4B5376D03BF0@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/58BB23FF-E652-4C58-AEE4-4B5376D03BF0@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/58BB23FF-E652-4C58-AEE4-4B5376D03BF0@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/58BB23FF-E652-4C58-AEE4-4B5376D03BF0@brauner.io/t/#u">nested</a>] <a href="#r76bb4a153a3c330bc4b0436f64935f15b304cae1">53+ messages in thread</a></pre><hr><pre><a href="#edf028b806a86c9a075bc1ebf67e0e630a54a2ba6" id="mdf028b806a86c9a075bc1ebf67e0e630a54a2ba6">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 10:34 <a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Aleksa Sarai
                   ` <a href="#rcd41f1f73fed393394dbf021d3b8dd2c678b37c3">(4 preceding siblings ...)</a>
  2018-09-30 13:54 ` <a href="#mcd41f1f73fed393394dbf021d3b8dd2c678b37c3">Alban Crequy</a>
<b>@ 2018-09-30 19:45 ` Mickal Salan</b>
  2018-09-30 21:46   ` <a href="#m0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00">Jann Horn</a>
  2018-10-01  4:08 ` <a href="#md2ecb7fd499b6542bec872079f27680e1f28a304">Dave Chinner</a>
  2018-10-01 13:28 ` <a href="#ma484ed4979004d9f23a406cac8f134aa029b1322">David Laight</a>
  <a href="#rdf028b806a86c9a075bc1ebf67e0e630a54a2ba6">7 siblings, 1 reply; 53+ messages in thread</a>
From: Mickal Salan @ 2018-09-30 19:45 UTC (<a href="https://lore.kernel.org/lkml/39d64180-73d5-6f27-e455-956143a5b5d3@digikod.net/">permalink</a> / <a href="https://lore.kernel.org/lkml/39d64180-73d5-6f27-e455-956143a5b5d3@digikod.net/raw">raw</a>)
  To: Aleksa Sarai, Jeff Layton, J. Bruce Fields, Al Viro,
	Arnd Bergmann, Shuah Khan
  Cc: David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers,
	linux-security-module, Kees Cook, Andy Lutomirski

<a href="https://lore.kernel.org/lkml/39d64180-73d5-6f27-e455-956143a5b5d3@digikod.net/1.1-a.txt">[-- Attachment #1.1: Type: text/plain, Size: 5461 bytes --]</a>

As a side note, I'm still working on Landlock which can achieve the same
goal but in a more flexible and dynamic way: <a href="https://landlock.io/">https://landlock.io</a>

Regards,
 Mickal

On 9/29/18 12:34, Aleksa Sarai wrote:
<span>&gt; The need for some sort of control over VFS's path resolution (to avoid
&gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt; long-standing desire of many userspace applications. This patchset is a
&gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.
&gt; 
&gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt; which means that each individual property of AT_NO_JUMPS is now a
&gt; separate flag:
&gt; 
&gt;   * Path-based escapes from the starting-point using "/" or ".." are
&gt;     blocked by AT_BENEATH.
&gt;   * Mountpoint crossings are blocked by AT_XDEV.
&gt;   * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt; 	correctly it actually blocks any user of nd_jump_link() because it
&gt; 	allows out-of-VFS path resolution manipulation).
&gt; 
&gt; AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS). At
&gt; Linus' suggestion in the original thread, I've also implemented
&gt; AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
&gt; "proclink" resolution).
&gt; 
&gt; An additional improvement was made to AT_XDEV. The original AT_NO_JUMPS
&gt; path didn't consider "/tmp/.." as a mountpoint crossing -- this patch
&gt; blocks this as well (feel free to ask me to remove it if you feel this
&gt; is not sane).
&gt; 
&gt; Currently I've only enabled these for openat(2) and the stat(2) family.
&gt; I would hope we could enable it for basically every *at(2) syscall --
&gt; but many of them appear to not have a @flags argument and thus we'll
&gt; need to add several new syscalls to do this. I'm more than happy to send
&gt; those patches, but I'd prefer to know that this preliminary work is
&gt; acceptable before doing a bunch of copy-paste to add new sets of *at(2)
&gt; syscalls.
&gt; 
&gt; One additional feature I've implemented is AT_THIS_ROOT (I imagine this
&gt; is probably going to be more contentious than the refresh of
&gt; AT_NO_JUMPS, so I've included it in a separate patch). The patch itself
&gt; describes my reasoning, but the shortened version of the premise is that
&gt; continer runtimes need to have a way to resolve paths within a
&gt; potentially malicious rootfs. Container runtimes currently do this in
&gt; userspace[2] which has implicit race conditions that are not resolvable
&gt; in userspace (or use fork+exec+chroot and SCM_RIGHTS passing which is
&gt; inefficient). AT_THIS_ROOT allows for per-call chroot-like semantics for
&gt; path resolution, which would be invaluable for us -- and the
&gt; implementation is basically identical to AT_BENEATH (except that we
&gt; don't return errors when someone actually hits the root).
&gt; 
&gt; I've added some selftests for this, but it's not clear to me whether
&gt; they should live here or in xfstests (as far as I can tell there are no
&gt; other VFS tests in selftests, while there are some tests that look like
&gt; generic VFS tests in xfstests). If you'd prefer them to be included in
&gt; xfstests, let me know.
&gt; 
&gt; [1]: <a href="https://lore.kernel.org/patchwork/patch/784221/">https://lore.kernel.org/patchwork/patch/784221/</a>
&gt; [2]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>
&gt; 
&gt; Aleksa Sarai (3):
&gt;   namei: implement O_BENEATH-style AT_* flags
&gt;   namei: implement AT_THIS_ROOT chroot-like path resolution
&gt;   selftests: vfs: add AT_* path resolution tests
&gt; 
&gt;  fs/fcntl.c                                    |   2 +-
&gt;  fs/namei.c                                    | 158 ++++++++++++------
&gt;  fs/open.c                                     |  10 ++
&gt;  fs/stat.c                                     |  15 +-
&gt;  include/linux/fcntl.h                         |   3 +-
&gt;  include/linux/namei.h                         |   8 +
&gt;  include/uapi/asm-generic/fcntl.h              |  20 +++
&gt;  include/uapi/linux/fcntl.h                    |  10 ++
&gt;  tools/testing/selftests/Makefile              |   1 +
&gt;  tools/testing/selftests/vfs/.gitignore        |   1 +
&gt;  tools/testing/selftests/vfs/Makefile          |  13 ++
&gt;  tools/testing/selftests/vfs/at_flags.h        |  40 +++++
&gt;  tools/testing/selftests/vfs/common.sh         |  37 ++++
&gt;  .../selftests/vfs/tests/0001_at_beneath.sh    |  72 ++++++++
&gt;  .../selftests/vfs/tests/0002_at_xdev.sh       |  54 ++++++
&gt;  .../vfs/tests/0003_at_no_proclinks.sh         |  50 ++++++
&gt;  .../vfs/tests/0004_at_no_symlinks.sh          |  49 ++++++
&gt;  .../selftests/vfs/tests/0005_at_this_root.sh  |  66 ++++++++
&gt;  tools/testing/selftests/vfs/vfs_helper.c      | 154 +++++++++++++++++
&gt;  19 files changed, 707 insertions(+), 56 deletions(-)
&gt;  create mode 100644 tools/testing/selftests/vfs/.gitignore
&gt;  create mode 100644 tools/testing/selftests/vfs/Makefile
&gt;  create mode 100644 tools/testing/selftests/vfs/at_flags.h
&gt;  create mode 100644 tools/testing/selftests/vfs/common.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0001_at_beneath.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0002_at_xdev.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0005_at_this_root.sh
&gt;  create mode 100644 tools/testing/selftests/vfs/vfs_helper.c
&gt; 
</span>

<a href="https://lore.kernel.org/lkml/39d64180-73d5-6f27-e455-956143a5b5d3@digikod.net/2-signature.asc">[-- Attachment #2: OpenPGP digital signature --]
[-- Type: application/pgp-signature, Size: 488 bytes --]</a>

<a href="#mdf028b806a86c9a075bc1ebf67e0e630a54a2ba6" id="edf028b806a86c9a075bc1ebf67e0e630a54a2ba6">^</a> <a href="https://lore.kernel.org/lkml/39d64180-73d5-6f27-e455-956143a5b5d3@digikod.net/">permalink</a> <a href="https://lore.kernel.org/lkml/39d64180-73d5-6f27-e455-956143a5b5d3@digikod.net/raw">raw</a> <a href="https://lore.kernel.org/lkml/39d64180-73d5-6f27-e455-956143a5b5d3@digikod.net/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/39d64180-73d5-6f27-e455-956143a5b5d3@digikod.net/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/39d64180-73d5-6f27-e455-956143a5b5d3@digikod.net/t/#u">nested</a>] <a href="#rdf028b806a86c9a075bc1ebf67e0e630a54a2ba6">53+ messages in thread</a></pre><hr><pre><a href="#e0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00" id="m0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-30 19:45 ` <a href="#mdf028b806a86c9a075bc1ebf67e0e630a54a2ba6">Mickal Salan</a>
<b>@ 2018-09-30 21:46   ` Jann Horn</b>
  2018-09-30 22:37     ` <a href="#m6f6dac21d23ad55bf619634955f15a52e93874d6">Mickal Salan</a>
  <a href="#r0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00">0 siblings, 1 reply; 53+ messages in thread</a>
From: Jann Horn @ 2018-09-30 21:46 UTC (<a href="https://lore.kernel.org/lkml/CAG48ez1CUHTKrpbwJxXkYoUKm5eYV15LuRRO+dXveo=MQvjJkA@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CAG48ez1CUHTKrpbwJxXkYoUKm5eYV15LuRRO+dXveo=MQvjJkA@mail.gmail.com/raw">raw</a>)
  To: mic
  Cc: cyphar, jlayton, Bruce Fields, Al Viro, Arnd Bergmann, shuah,
	David Howells, Andy Lutomirski, christian, Eric W. Biederman,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, linux-security-module,
	Kees Cook

On Sun, Sep 30, 2018 at 10:39 PM Mickal Salan &lt;mic@digikod.net&gt; wrote:
<span>&gt; As a side note, I'm still working on Landlock which can achieve the same
&gt; goal but in a more flexible and dynamic way: <a href="https://landlock.io/">https://landlock.io</a>
</span>
Isn't Landlock mostly intended for userspace that wants to impose a
custom Mandatory Access Control policy on itself, restricting the
whole process?

As far as I can tell, a major usecase for AT_BENEATH are privileged
processes that do not want to restrict all filesystem operations they
perform, but want to sometimes impose limits on filesystem traversal
for the duration of a single system call. For example, a process might
want to first open a file from an untrusted filesystem area with
AT_BENEATH, and afterwards open a configuration file without
AT_BENEATH.

How would you do this in Landlock? Use a BPF map to store per-thread
filesystem restrictions, and then do bpf() calls before and after
every restricted filesystem access to set and unset the policy for the
current syscall?

<span>&gt; On 9/29/18 12:34, Aleksa Sarai wrote:
&gt; &gt; The need for some sort of control over VFS's path resolution (to avoid
&gt; &gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt; &gt; long-standing desire of many userspace applications. This patchset is a
&gt; &gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.
&gt; &gt;
&gt; &gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt; &gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt; &gt; which means that each individual property of AT_NO_JUMPS is now a
&gt; &gt; separate flag:
&gt; &gt;
&gt; &gt;   * Path-based escapes from the starting-point using "/" or ".." are
&gt; &gt;     blocked by AT_BENEATH.
&gt; &gt;   * Mountpoint crossings are blocked by AT_XDEV.
&gt; &gt;   * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt; &gt;       correctly it actually blocks any user of nd_jump_link() because it
&gt; &gt;       allows out-of-VFS path resolution manipulation).
&gt; &gt;
&gt; &gt; AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS). At
&gt; &gt; Linus' suggestion in the original thread, I've also implemented
&gt; &gt; AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
&gt; &gt; "proclink" resolution).
&gt; &gt;
&gt; &gt; An additional improvement was made to AT_XDEV. The original AT_NO_JUMPS
&gt; &gt; path didn't consider "/tmp/.." as a mountpoint crossing -- this patch
&gt; &gt; blocks this as well (feel free to ask me to remove it if you feel this
&gt; &gt; is not sane).
&gt; &gt;
&gt; &gt; Currently I've only enabled these for openat(2) and the stat(2) family.
&gt; &gt; I would hope we could enable it for basically every *at(2) syscall --
&gt; &gt; but many of them appear to not have a @flags argument and thus we'll
&gt; &gt; need to add several new syscalls to do this. I'm more than happy to send
&gt; &gt; those patches, but I'd prefer to know that this preliminary work is
&gt; &gt; acceptable before doing a bunch of copy-paste to add new sets of *at(2)
&gt; &gt; syscalls.
&gt; &gt;
&gt; &gt; One additional feature I've implemented is AT_THIS_ROOT (I imagine this
&gt; &gt; is probably going to be more contentious than the refresh of
&gt; &gt; AT_NO_JUMPS, so I've included it in a separate patch). The patch itself
&gt; &gt; describes my reasoning, but the shortened version of the premise is that
&gt; &gt; continer runtimes need to have a way to resolve paths within a
&gt; &gt; potentially malicious rootfs. Container runtimes currently do this in
&gt; &gt; userspace[2] which has implicit race conditions that are not resolvable
&gt; &gt; in userspace (or use fork+exec+chroot and SCM_RIGHTS passing which is
&gt; &gt; inefficient). AT_THIS_ROOT allows for per-call chroot-like semantics for
&gt; &gt; path resolution, which would be invaluable for us -- and the
&gt; &gt; implementation is basically identical to AT_BENEATH (except that we
&gt; &gt; don't return errors when someone actually hits the root).
&gt; &gt;
&gt; &gt; I've added some selftests for this, but it's not clear to me whether
&gt; &gt; they should live here or in xfstests (as far as I can tell there are no
&gt; &gt; other VFS tests in selftests, while there are some tests that look like
&gt; &gt; generic VFS tests in xfstests). If you'd prefer them to be included in
&gt; &gt; xfstests, let me know.
&gt; &gt;
&gt; &gt; [1]: <a href="https://lore.kernel.org/patchwork/patch/784221/">https://lore.kernel.org/patchwork/patch/784221/</a>
&gt; &gt; [2]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>
&gt; &gt;
&gt; &gt; Aleksa Sarai (3):
&gt; &gt;   namei: implement O_BENEATH-style AT_* flags
&gt; &gt;   namei: implement AT_THIS_ROOT chroot-like path resolution
&gt; &gt;   selftests: vfs: add AT_* path resolution tests
&gt; &gt;
&gt; &gt;  fs/fcntl.c                                    |   2 +-
&gt; &gt;  fs/namei.c                                    | 158 ++++++++++++------
&gt; &gt;  fs/open.c                                     |  10 ++
&gt; &gt;  fs/stat.c                                     |  15 +-
&gt; &gt;  include/linux/fcntl.h                         |   3 +-
&gt; &gt;  include/linux/namei.h                         |   8 +
&gt; &gt;  include/uapi/asm-generic/fcntl.h              |  20 +++
&gt; &gt;  include/uapi/linux/fcntl.h                    |  10 ++
&gt; &gt;  tools/testing/selftests/Makefile              |   1 +
&gt; &gt;  tools/testing/selftests/vfs/.gitignore        |   1 +
&gt; &gt;  tools/testing/selftests/vfs/Makefile          |  13 ++
&gt; &gt;  tools/testing/selftests/vfs/at_flags.h        |  40 +++++
&gt; &gt;  tools/testing/selftests/vfs/common.sh         |  37 ++++
&gt; &gt;  .../selftests/vfs/tests/0001_at_beneath.sh    |  72 ++++++++
&gt; &gt;  .../selftests/vfs/tests/0002_at_xdev.sh       |  54 ++++++
&gt; &gt;  .../vfs/tests/0003_at_no_proclinks.sh         |  50 ++++++
&gt; &gt;  .../vfs/tests/0004_at_no_symlinks.sh          |  49 ++++++
&gt; &gt;  .../selftests/vfs/tests/0005_at_this_root.sh  |  66 ++++++++
&gt; &gt;  tools/testing/selftests/vfs/vfs_helper.c      | 154 +++++++++++++++++
&gt; &gt;  19 files changed, 707 insertions(+), 56 deletions(-)
&gt; &gt;  create mode 100644 tools/testing/selftests/vfs/.gitignore
&gt; &gt;  create mode 100644 tools/testing/selftests/vfs/Makefile
&gt; &gt;  create mode 100644 tools/testing/selftests/vfs/at_flags.h
&gt; &gt;  create mode 100644 tools/testing/selftests/vfs/common.sh
&gt; &gt;  create mode 100755 tools/testing/selftests/vfs/tests/0001_at_beneath.sh
&gt; &gt;  create mode 100755 tools/testing/selftests/vfs/tests/0002_at_xdev.sh
&gt; &gt;  create mode 100755 tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
&gt; &gt;  create mode 100755 tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
&gt; &gt;  create mode 100755 tools/testing/selftests/vfs/tests/0005_at_this_root.sh
&gt; &gt;  create mode 100644 tools/testing/selftests/vfs/vfs_helper.c
&gt; &gt;
&gt;
</span>
<a href="#m0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00" id="e0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00">^</a> <a href="https://lore.kernel.org/lkml/CAG48ez1CUHTKrpbwJxXkYoUKm5eYV15LuRRO+dXveo=MQvjJkA@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CAG48ez1CUHTKrpbwJxXkYoUKm5eYV15LuRRO+dXveo=MQvjJkA@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CAG48ez1CUHTKrpbwJxXkYoUKm5eYV15LuRRO+dXveo=MQvjJkA@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CAG48ez1CUHTKrpbwJxXkYoUKm5eYV15LuRRO+dXveo=MQvjJkA@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CAG48ez1CUHTKrpbwJxXkYoUKm5eYV15LuRRO+dXveo=MQvjJkA@mail.gmail.com/t/#u">nested</a>] <a href="#r0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00">53+ messages in thread</a></pre><hr><pre><a href="#e6f6dac21d23ad55bf619634955f15a52e93874d6" id="m6f6dac21d23ad55bf619634955f15a52e93874d6">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-30 21:46   ` <a href="#m0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00">Jann Horn</a>
<b>@ 2018-09-30 22:37     ` Mickal Salan</b>
  2018-10-01 20:14       ` <a href="#m440b5bdeba29f11233cdb944b183af4d6c48fb1f">James Morris</a>
  <a href="#r6f6dac21d23ad55bf619634955f15a52e93874d6">0 siblings, 1 reply; 53+ messages in thread</a>
From: Mickal Salan @ 2018-09-30 22:37 UTC (<a href="https://lore.kernel.org/lkml/0ca12a6e-a86b-5d50-40b9-e76c1a4bc6a0@digikod.net/">permalink</a> / <a href="https://lore.kernel.org/lkml/0ca12a6e-a86b-5d50-40b9-e76c1a4bc6a0@digikod.net/raw">raw</a>)
  To: Jann Horn
  Cc: cyphar, jlayton, Bruce Fields, Al Viro, Arnd Bergmann, shuah,
	David Howells, Andy Lutomirski, christian, Eric W. Biederman,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, linux-security-module,
	Kees Cook, Linux API

<a href="https://lore.kernel.org/lkml/0ca12a6e-a86b-5d50-40b9-e76c1a4bc6a0@digikod.net/1.1-a.txt">[-- Attachment #1.1: Type: text/plain, Size: 7549 bytes --]</a>


On 9/30/18 23:46, Jann Horn wrote:
<span>&gt; On Sun, Sep 30, 2018 at 10:39 PM Mickal Salan &lt;mic@digikod.net&gt; wrote:
&gt;&gt; As a side note, I'm still working on Landlock which can achieve the same
&gt;&gt; goal but in a more flexible and dynamic way: <a href="https://landlock.io/">https://landlock.io</a>
&gt; 
&gt; Isn't Landlock mostly intended for userspace that wants to impose a
&gt; custom Mandatory Access Control policy on itself, restricting the
&gt; whole process?
&gt; 
&gt; As far as I can tell, a major usecase for AT_BENEATH are privileged
&gt; processes that do not want to restrict all filesystem operations they
&gt; perform, but want to sometimes impose limits on filesystem traversal
&gt; for the duration of a single system call. For example, a process might
&gt; want to first open a file from an untrusted filesystem area with
&gt; AT_BENEATH, and afterwards open a configuration file without
&gt; AT_BENEATH.
</span>
I didn't realized this was the main use case for AT_BENEATH. Landlock is
indeed dedicated to apply a security policy on a set of processes. This
set can be a process and its children (seccomp-like), or another set of
processes that may be identified with a cgroup.

<span>&gt; 
&gt; How would you do this in Landlock? Use a BPF map to store per-thread
&gt; filesystem restrictions, and then do bpf() calls before and after
&gt; every restricted filesystem access to set and unset the policy for the
&gt; current syscall?
</span>
Another way to apply a security policy could be to tied it to a file
descriptor, similarly to Capsicum, which could enable to create
programmable (real) capabilities. This way, it would be possible to
"wrap" a file descriptor with a Landlock program and use it with
FD-based syscalls or pass it to other processes. This would not require
changes to the FS subsystem, but only the Landlock LSM code. This isn't
done yet but I plan to add this new way to restrict operations on file
descriptors.

Anyway, for the use case you mentioned, the AT_BENEATH flag(s) should be
simple to use and enough for now. We must be careful of the hardcoded
policy though.


<span>&gt; 
&gt;&gt; On 9/29/18 12:34, Aleksa Sarai wrote:
&gt;&gt;&gt; The need for some sort of control over VFS's path resolution (to avoid
&gt;&gt;&gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt;&gt;&gt; long-standing desire of many userspace applications. This patchset is a
&gt;&gt;&gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.
&gt;&gt;&gt;
&gt;&gt;&gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt;&gt;&gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt;&gt;&gt; which means that each individual property of AT_NO_JUMPS is now a
&gt;&gt;&gt; separate flag:
&gt;&gt;&gt;
&gt;&gt;&gt;   * Path-based escapes from the starting-point using "/" or ".." are
&gt;&gt;&gt;     blocked by AT_BENEATH.
&gt;&gt;&gt;   * Mountpoint crossings are blocked by AT_XDEV.
&gt;&gt;&gt;   * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt;&gt;&gt;       correctly it actually blocks any user of nd_jump_link() because it
&gt;&gt;&gt;       allows out-of-VFS path resolution manipulation).
&gt;&gt;&gt;
&gt;&gt;&gt; AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS). At
&gt;&gt;&gt; Linus' suggestion in the original thread, I've also implemented
&gt;&gt;&gt; AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
&gt;&gt;&gt; "proclink" resolution).
&gt;&gt;&gt;
&gt;&gt;&gt; An additional improvement was made to AT_XDEV. The original AT_NO_JUMPS
&gt;&gt;&gt; path didn't consider "/tmp/.." as a mountpoint crossing -- this patch
&gt;&gt;&gt; blocks this as well (feel free to ask me to remove it if you feel this
&gt;&gt;&gt; is not sane).
&gt;&gt;&gt;
&gt;&gt;&gt; Currently I've only enabled these for openat(2) and the stat(2) family.
&gt;&gt;&gt; I would hope we could enable it for basically every *at(2) syscall --
&gt;&gt;&gt; but many of them appear to not have a @flags argument and thus we'll
&gt;&gt;&gt; need to add several new syscalls to do this. I'm more than happy to send
&gt;&gt;&gt; those patches, but I'd prefer to know that this preliminary work is
&gt;&gt;&gt; acceptable before doing a bunch of copy-paste to add new sets of *at(2)
&gt;&gt;&gt; syscalls.
&gt;&gt;&gt;
&gt;&gt;&gt; One additional feature I've implemented is AT_THIS_ROOT (I imagine this
&gt;&gt;&gt; is probably going to be more contentious than the refresh of
&gt;&gt;&gt; AT_NO_JUMPS, so I've included it in a separate patch). The patch itself
&gt;&gt;&gt; describes my reasoning, but the shortened version of the premise is that
&gt;&gt;&gt; continer runtimes need to have a way to resolve paths within a
&gt;&gt;&gt; potentially malicious rootfs. Container runtimes currently do this in
&gt;&gt;&gt; userspace[2] which has implicit race conditions that are not resolvable
&gt;&gt;&gt; in userspace (or use fork+exec+chroot and SCM_RIGHTS passing which is
&gt;&gt;&gt; inefficient). AT_THIS_ROOT allows for per-call chroot-like semantics for
&gt;&gt;&gt; path resolution, which would be invaluable for us -- and the
&gt;&gt;&gt; implementation is basically identical to AT_BENEATH (except that we
&gt;&gt;&gt; don't return errors when someone actually hits the root).
&gt;&gt;&gt;
&gt;&gt;&gt; I've added some selftests for this, but it's not clear to me whether
&gt;&gt;&gt; they should live here or in xfstests (as far as I can tell there are no
&gt;&gt;&gt; other VFS tests in selftests, while there are some tests that look like
&gt;&gt;&gt; generic VFS tests in xfstests). If you'd prefer them to be included in
&gt;&gt;&gt; xfstests, let me know.
&gt;&gt;&gt;
&gt;&gt;&gt; [1]: <a href="https://lore.kernel.org/patchwork/patch/784221/">https://lore.kernel.org/patchwork/patch/784221/</a>
&gt;&gt;&gt; [2]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>
&gt;&gt;&gt;
&gt;&gt;&gt; Aleksa Sarai (3):
&gt;&gt;&gt;   namei: implement O_BENEATH-style AT_* flags
&gt;&gt;&gt;   namei: implement AT_THIS_ROOT chroot-like path resolution
&gt;&gt;&gt;   selftests: vfs: add AT_* path resolution tests
&gt;&gt;&gt;
&gt;&gt;&gt;  fs/fcntl.c                                    |   2 +-
&gt;&gt;&gt;  fs/namei.c                                    | 158 ++++++++++++------
&gt;&gt;&gt;  fs/open.c                                     |  10 ++
&gt;&gt;&gt;  fs/stat.c                                     |  15 +-
&gt;&gt;&gt;  include/linux/fcntl.h                         |   3 +-
&gt;&gt;&gt;  include/linux/namei.h                         |   8 +
&gt;&gt;&gt;  include/uapi/asm-generic/fcntl.h              |  20 +++
&gt;&gt;&gt;  include/uapi/linux/fcntl.h                    |  10 ++
&gt;&gt;&gt;  tools/testing/selftests/Makefile              |   1 +
&gt;&gt;&gt;  tools/testing/selftests/vfs/.gitignore        |   1 +
&gt;&gt;&gt;  tools/testing/selftests/vfs/Makefile          |  13 ++
&gt;&gt;&gt;  tools/testing/selftests/vfs/at_flags.h        |  40 +++++
&gt;&gt;&gt;  tools/testing/selftests/vfs/common.sh         |  37 ++++
&gt;&gt;&gt;  .../selftests/vfs/tests/0001_at_beneath.sh    |  72 ++++++++
&gt;&gt;&gt;  .../selftests/vfs/tests/0002_at_xdev.sh       |  54 ++++++
&gt;&gt;&gt;  .../vfs/tests/0003_at_no_proclinks.sh         |  50 ++++++
&gt;&gt;&gt;  .../vfs/tests/0004_at_no_symlinks.sh          |  49 ++++++
&gt;&gt;&gt;  .../selftests/vfs/tests/0005_at_this_root.sh  |  66 ++++++++
&gt;&gt;&gt;  tools/testing/selftests/vfs/vfs_helper.c      | 154 +++++++++++++++++
&gt;&gt;&gt;  19 files changed, 707 insertions(+), 56 deletions(-)
&gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/.gitignore
&gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/Makefile
&gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/at_flags.h
&gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/common.sh
&gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0001_at_beneath.sh
&gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0002_at_xdev.sh
&gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
&gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
&gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0005_at_this_root.sh
&gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/vfs_helper.c
&gt;&gt;&gt;
&gt;&gt;
&gt; 
&gt; 
</span>

<a href="https://lore.kernel.org/lkml/0ca12a6e-a86b-5d50-40b9-e76c1a4bc6a0@digikod.net/2-signature.asc">[-- Attachment #2: OpenPGP digital signature --]
[-- Type: application/pgp-signature, Size: 488 bytes --]</a>

<a href="#m6f6dac21d23ad55bf619634955f15a52e93874d6" id="e6f6dac21d23ad55bf619634955f15a52e93874d6">^</a> <a href="https://lore.kernel.org/lkml/0ca12a6e-a86b-5d50-40b9-e76c1a4bc6a0@digikod.net/">permalink</a> <a href="https://lore.kernel.org/lkml/0ca12a6e-a86b-5d50-40b9-e76c1a4bc6a0@digikod.net/raw">raw</a> <a href="https://lore.kernel.org/lkml/0ca12a6e-a86b-5d50-40b9-e76c1a4bc6a0@digikod.net/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/0ca12a6e-a86b-5d50-40b9-e76c1a4bc6a0@digikod.net/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/0ca12a6e-a86b-5d50-40b9-e76c1a4bc6a0@digikod.net/t/#u">nested</a>] <a href="#r6f6dac21d23ad55bf619634955f15a52e93874d6">53+ messages in thread</a></pre><hr><pre><a href="#ed2ecb7fd499b6542bec872079f27680e1f28a304" id="md2ecb7fd499b6542bec872079f27680e1f28a304">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 10:34 <a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Aleksa Sarai
                   ` <a href="#rdf028b806a86c9a075bc1ebf67e0e630a54a2ba6">(5 preceding siblings ...)</a>
  2018-09-30 19:45 ` <a href="#mdf028b806a86c9a075bc1ebf67e0e630a54a2ba6">Mickal Salan</a>
<b>@ 2018-10-01  4:08 ` Dave Chinner</b>
  2018-10-01  5:47   ` <a href="#mded88ab4253fc25b051efa833e15625a583d674a">Aleksa Sarai</a>
  2018-10-01 13:28 ` <a href="#ma484ed4979004d9f23a406cac8f134aa029b1322">David Laight</a>
  <a href="#rd2ecb7fd499b6542bec872079f27680e1f28a304">7 siblings, 1 reply; 53+ messages in thread</a>
From: Dave Chinner @ 2018-10-01  4:08 UTC (<a href="https://lore.kernel.org/lkml/20181001040821.GP31060@dastard/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001040821.GP31060@dastard/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers

On Sat, Sep 29, 2018 at 08:34:50PM +1000, Aleksa Sarai wrote:
<span>&gt; I've added some selftests for this, but it's not clear to me whether
&gt; they should live here or in xfstests (as far as I can tell there are no
&gt; other VFS tests in selftests, while there are some tests that look like
&gt; generic VFS tests in xfstests). If you'd prefer them to be included in
&gt; xfstests, let me know.
</span>
xfstests, please. That way the new functionality will get immediate
coverage by all the main filesystem development and distro QA
teams....

Cheers,

Dave.
-- 
Dave Chinner
david@fromorbit.com

<a href="#md2ecb7fd499b6542bec872079f27680e1f28a304" id="ed2ecb7fd499b6542bec872079f27680e1f28a304">^</a> <a href="https://lore.kernel.org/lkml/20181001040821.GP31060@dastard/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001040821.GP31060@dastard/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001040821.GP31060@dastard/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001040821.GP31060@dastard/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001040821.GP31060@dastard/t/#u">nested</a>] <a href="#rd2ecb7fd499b6542bec872079f27680e1f28a304">53+ messages in thread</a></pre><hr><pre><a href="#ebab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1" id="mbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-09-29 16:35   ` <a href="#m85db30139fa0747cca01a4a7b71ba3f88ab3207c">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Jann Horn
  2018-09-29 17:25     ` <a href="#m55dcd0750c094ebe0bc62c39c395b0163bb41bf2">Andy Lutomirski</a>
<b>@ 2018-10-01  5:44     ` Aleksa Sarai</b>
  2018-10-01 10:13       ` <a href="#mfc968a7da9d5629a298a520b5ea1b852a73ab01a">Jann Horn</a>
                         ` <a href="#rfc968a7da9d5629a298a520b5ea1b852a73ab01a">(3 more replies)</a>
  2018-10-01 14:00     ` <a href="#md4dd13f53e4b9d8535513d1aed0b121a8d5cfc51">Christian Brauner</a>
  2018-10-04 16:26     ` <a href="#m1363e6020e3fcd93078ba4165aac2ccfb07ef4a5">Aleksa Sarai</a>
  <a href="#rbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">3 siblings, 4 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-01  5:44 UTC (<a href="https://lore.kernel.org/lkml/20181001054246.gfinmx3api7kjhmc@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001054246.gfinmx3api7kjhmc@ryuk/raw">raw</a>)
  To: Jann Horn
  Cc: Eric W. Biederman, jlayton, Bruce Fields, Al Viro, Arnd Bergmann,
	shuah, David Howells, Andy Lutomirski, christian, Tycho Andersen,
	kernel list, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers, Linux API

<a href="https://lore.kernel.org/lkml/20181001054246.gfinmx3api7kjhmc@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 6954 bytes --]</a>

On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
<span>&gt; The problem is what happens if a folder you are walking through is
&gt; concurrently moved out of the chroot. Consider the following scenario:
&gt; 
&gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; the following:
&gt; 
&gt; 1. You start the path walk and reach /A/B/C.
&gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; the process root, but you never actually encountered the process root,
&gt; so you don't notice.
&gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; outside the process root, but you don't notice.
&gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; successfully. You now have an fd pointing outside your chroot.
&gt; 
&gt; If the root of your walk is below an attacker-controlled directory,
&gt; this of course means that you lose instantly. If you point the root of
&gt; the walk at a directory out of which a process in the container
&gt; wouldn't be able to move the file, you're probably kinda mostly fine -
&gt; as long as you know, for certain, that nothing else on the system
&gt; would ever do that. But I still wouldn't feel good about that.
</span>
Please correct me if I'm wrong here (this is the first patch I've
written for VFS). Isn't the retry/LOOKUP_REVAL code meant to handle this
-- or does that only handle if a particular path component changes
*while* it's being walked through? Is it possible for a path walk to
succeed after a path component was unmounted (obviously you can't delete
a directory path component since you'd get -ENOTEMPTY)?

If this is an issue for AT_THIS_ROOT, I believe this might also be an
issue for AT_BENEATH since they are effectively both using the same
nd-&gt;root trick (so you could similarly trick AT_BENEATH to not error
out). So we'd need to figure out how to solve this problem in order for
AT_BENEATH to be safe.

Speaking naively, doesn't it make sense to invalidate the walk if a path
component was modified? Or is this something that would be far too
costly with little benefit? What if we do more aggressive nd-&gt;root
checks when resolving with AT_BENEATH or AT_THIS_ROOT (or if nd-&gt;root !=
current-&gt;mnt_ns-&gt;root)?

Regarding chroot attacks, I was aware of the trivial
chroot-open-chroot-fchdir attack but I was not aware that there was a
rename attack for chroot. Thanks for bringing this up!

<span>&gt; I believe that the only way to robustly use this would be to point the
&gt; dirfd at a mount point, such that you know that being moved out of the
&gt; chroot is impossible because the mount point limits movement of
&gt; directories under it. (Well, technically, it doesn't, but it ensures
&gt; that if a directory does dangerously move away, the syscall fails.) It
&gt; might make sense to hardcode this constraint in the implementation of
&gt; AT_THIS_ROOT, to keep people from shooting themselves in the foot.
</span>
Unless I'm missing something, would this not also affect using a
mountpoint as a dirfd-root (with MS_MOVE of an already-walked-through
path component) -- or does MS_MOVE cause a rewalk in a way that rename
does not?

I wouldn't mind tying AT_THIS_ROOT to only work on mountpoints (I
thought that bind-mounts would be an issue but you also get -EXDEV when
trying to rename across bind-mounts even if they are on the same
underlying filesystem). But AT_BENEATH might be a more bitter pill to
swallow. I'm not sure.

In the usecase of container runtimes, we wouldn't generally be doing
resolution of attacker-controlled paths but it still definitely doesn't
hurt to consider this part of the threat model -- to avoid foot-gunning
as you've said. (There also might be some nested-container cases where
you might want to do that.)

<span>&gt; &gt; Currently most container runtimes try to do this resolution in
&gt; &gt; userspace[1], causing many potential race conditions. In addition, the
&gt; &gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; &gt; requires a fork+exec which is *very* costly if necessary for every
&gt; &gt; filesystem operation involving a container.
&gt; 
&gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt; a full fork() either, clone() lets you do this with some process parts
&gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt; wouldn't you want to use setns()?
</span>
You're right about this -- for C runtimes. In Go we cannot do a raw
clone() or fork() (if you do it manually with RawSyscall you'll end with
broken runtime state). So you're forced to do fork+exec (which then
means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
for CLONE_VFORK.

(It should be noted that multi-threaded C runtimes have somewhat similar
issues -- AFAIK you can technically only use AS-Safe glibc functions
after a fork() but that's more of a theoretical concern here. If you
just use raw syscalls there isn't an issue.)

As for why use setns() rather than pivot_root(), there are cases where
you're operating on a container's image without a running container
(think image extraction or snapshotting tools). In those cases, you
would need to set up a dummy container process in order to setns() into
its namespaces. You are right that setns() would be a better option if
you want the truthful state of what mounts the container sees.

[I also don't like the idea of joining the user namespace of a malicious
container unless it's necessary but that's probably just needless
paranoia more than anything -- since you're not joining the pidns you
aren't trivially addressable by a malicious container.]

<span>&gt; // Ensure that we are non-dumpable. Together with
&gt; // commit bfedb589252c, this ensures that container root
&gt; // can't trace our child once it enters the container.
&gt; // My patch
&gt; // <a href="https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/">https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/</a>
&gt; // would make this unnecessary, but that patch didn't
&gt; // land because Eric nacked it (for political reasons,
&gt; // because people incorrectly claimed that this was a
&gt; // security fix):
</span>
Unless I'm very much mistaken this was fixed by bfedb589252c ("mm: Add a
user_ns owner to mm_struct and fix ptrace permission checks"). If you
join a user namespace then processes within that user namespace won't
have ptrace_may_access() permissions because your mm is owned by an
ancestor user namespace -- only after exec() will you be traceable.

We still use PR_SET_DUMPABLE in runc but that's because we support older
kernels (and people don't use user namespaces under Docker) but with
user namespaces this should not be required anymore.

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181001054246.gfinmx3api7kjhmc@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#mbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1" id="ebab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">^</a> <a href="https://lore.kernel.org/lkml/20181001054246.gfinmx3api7kjhmc@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001054246.gfinmx3api7kjhmc@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001054246.gfinmx3api7kjhmc@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001054246.gfinmx3api7kjhmc@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001054246.gfinmx3api7kjhmc@ryuk/t/#u">nested</a>] <a href="#rbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">53+ messages in thread</a></pre><hr><pre><a href="#eded88ab4253fc25b051efa833e15625a583d674a" id="mded88ab4253fc25b051efa833e15625a583d674a">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-10-01  4:08 ` <a href="#md2ecb7fd499b6542bec872079f27680e1f28a304">Dave Chinner</a>
<b>@ 2018-10-01  5:47   ` Aleksa Sarai</b>
  2018-10-01  6:14     ` <a href="#m3383405a3f2f149a8a3ac42ba8869b988296ad1c">Dave Chinner</a>
  <a href="#rded88ab4253fc25b051efa833e15625a583d674a">0 siblings, 1 reply; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-01  5:47 UTC (<a href="https://lore.kernel.org/lkml/20181001054723.lekp3nqgctdyly7m@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001054723.lekp3nqgctdyly7m@ryuk/raw">raw</a>)
  To: Dave Chinner
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers

<a href="https://lore.kernel.org/lkml/20181001054723.lekp3nqgctdyly7m@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 804 bytes --]</a>

On 2018-10-01, Dave Chinner &lt;david@fromorbit.com&gt; wrote:
<span>&gt; &gt; I've added some selftests for this, but it's not clear to me whether
&gt; &gt; they should live here or in xfstests (as far as I can tell there are no
&gt; &gt; other VFS tests in selftests, while there are some tests that look like
&gt; &gt; generic VFS tests in xfstests). If you'd prefer them to be included in
&gt; &gt; xfstests, let me know.
&gt; 
&gt; xfstests, please. That way the new functionality will get immediate
&gt; coverage by all the main filesystem development and distro QA
&gt; teams....
</span>
Sure, will do. Do you want me to submit them in parallel -- and what is
the correct ML to submit changes to xfstests? Sorry for the silly
questions. :P

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181001054723.lekp3nqgctdyly7m@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#mded88ab4253fc25b051efa833e15625a583d674a" id="eded88ab4253fc25b051efa833e15625a583d674a">^</a> <a href="https://lore.kernel.org/lkml/20181001054723.lekp3nqgctdyly7m@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001054723.lekp3nqgctdyly7m@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001054723.lekp3nqgctdyly7m@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001054723.lekp3nqgctdyly7m@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001054723.lekp3nqgctdyly7m@ryuk/t/#u">nested</a>] <a href="#rded88ab4253fc25b051efa833e15625a583d674a">53+ messages in thread</a></pre><hr><pre><a href="#e3383405a3f2f149a8a3ac42ba8869b988296ad1c" id="m3383405a3f2f149a8a3ac42ba8869b988296ad1c">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-10-01  5:47   ` <a href="#mded88ab4253fc25b051efa833e15625a583d674a">Aleksa Sarai</a>
<b>@ 2018-10-01  6:14     ` Dave Chinner</b>
  <a href="#r3383405a3f2f149a8a3ac42ba8869b988296ad1c">0 siblings, 0 replies; 53+ messages in thread</a>
From: Dave Chinner @ 2018-10-01  6:14 UTC (<a href="https://lore.kernel.org/lkml/20181001061427.GR31060@dastard/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001061427.GR31060@dastard/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers

On Mon, Oct 01, 2018 at 03:47:23PM +1000, Aleksa Sarai wrote:
<span>&gt; On 2018-10-01, Dave Chinner &lt;david@fromorbit.com&gt; wrote:
&gt; &gt; &gt; I've added some selftests for this, but it's not clear to me whether
&gt; &gt; &gt; they should live here or in xfstests (as far as I can tell there are no
&gt; &gt; &gt; other VFS tests in selftests, while there are some tests that look like
&gt; &gt; &gt; generic VFS tests in xfstests). If you'd prefer them to be included in
&gt; &gt; &gt; xfstests, let me know.
&gt; &gt; 
&gt; &gt; xfstests, please. That way the new functionality will get immediate
&gt; &gt; coverage by all the main filesystem development and distro QA
&gt; &gt; teams....
&gt; 
&gt; Sure, will do. Do you want me to submit them in parallel --
</span>
That's usually the way we do things, but we don't tend to commit the
fstests changes until the thing it is testing has landed upstream.

<span>&gt; and what is
&gt; the correct ML to submit changes to xfstests?
</span>
fstests@vger.kernel.org

<span>&gt; Sorry for the silly questions. :P
</span>
You're going to have many more of them when you start moving the
tests across to fstests :P

Cheers,

Dave.
-- 
Dave Chinner
david@fromorbit.com

<a href="#m3383405a3f2f149a8a3ac42ba8869b988296ad1c" id="e3383405a3f2f149a8a3ac42ba8869b988296ad1c">^</a> <a href="https://lore.kernel.org/lkml/20181001061427.GR31060@dastard/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001061427.GR31060@dastard/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001061427.GR31060@dastard/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001061427.GR31060@dastard/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001061427.GR31060@dastard/t/#u">nested</a>] <a href="#r3383405a3f2f149a8a3ac42ba8869b988296ad1c">53+ messages in thread</a></pre><hr><pre><a href="#e1f79f0bf1b6db2badf3e2e999b8ef7acd303a661" id="m1f79f0bf1b6db2badf3e2e999b8ef7acd303a661">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-09-29 17:25     ` <a href="#m55dcd0750c094ebe0bc62c39c395b0163bb41bf2">Andy Lutomirski</a>
<b>@ 2018-10-01  9:46       ` Aleksa Sarai</b>
  <a href="#r1f79f0bf1b6db2badf3e2e999b8ef7acd303a661">0 siblings, 0 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-01  9:46 UTC (<a href="https://lore.kernel.org/lkml/20181001090809.6t7ydq7gk2bwbout@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001090809.6t7ydq7gk2bwbout@ryuk/raw">raw</a>)
  To: Andy Lutomirski
  Cc: Jann Horn, Eric W. Biederman, jlayton, Bruce Fields, Al Viro,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski, christian,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API

<a href="https://lore.kernel.org/lkml/20181001090809.6t7ydq7gk2bwbout@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 2687 bytes --]</a>

On 2018-09-29, Andy Lutomirski &lt;luto@amacapital.net&gt; wrote:
<span>&gt; &gt;&gt; On Sat, Sep 29, 2018 at 4:29 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt; &gt;&gt; The primary motivation for the need for this flag is container runtimes
&gt; &gt;&gt; which have to interact with malicious root filesystems in the host
&gt; &gt;&gt; namespaces. One of the first requirements for a container runtime to be
&gt; &gt;&gt; secure against a malicious rootfs is that they correctly scope symlinks
&gt; &gt;&gt; (that is, they should be scoped as though they are chroot(2)ed into the
&gt; &gt;&gt; container's rootfs) and ".."-style paths. The already-existing AT_XDEV
&gt; &gt;&gt; and AT_NO_PROCLINKS help defend against other potential attacks in a
&gt; &gt;&gt; malicious rootfs scenario.
&gt; &gt; 
&gt; &gt; So, I really like the concept for patch 1 of this series (but haven't
&gt; &gt; read the code yet); but I dislike this patch because of its footgun
&gt; &gt; potential.
&gt; &gt; 
&gt; 
&gt; The code could do it differently: do the path walk and then, before
&gt; accepting the result, walk back up and make sure the result is under
&gt; the starting point.
&gt; 
&gt; This is *not* a full solution, though, since a walk above the root gas
&gt; side effects on timing, various caches, and possibly network traffic,
&gt; so its open to Spectre-like attacks in which a malicious container
&gt; could use a runtime-initiated AT_THIS_ROOT to infer the existence of
&gt; directories outside the container.
</span>
I think that one way to solve this problem might be to have more strict
checks on nd-&gt;root in follow_dotdot(). The problem here (as far as I can
tell) is that ".." could end up skipping past the root because of a
rename, however walking *down* into a path shouldn't be a problem (even
absolute symlinks shouldn't be a problem because they will nd_jump_root
and will land back in the root).

However, I'm not entirely sure what happens to nd-&gt;root if it gets
renamed -- can you still safely do checks against it (we'd need to do
some sort of is_descendant() check on the current path before we handle
".." in follow_dotdot).

That way, we wouldn't shouldn't have the spectre-like attack problem
(since the attack would be halted at the ".." stage -- before the path
walk can proceed into host paths). Would this be sufficient or is there
a more serious issue I'm missing?

<span>&gt; But whats the container usecase?  Any sane container is based on
&gt; pivot_root or similar, so the runtime can just do the walk in the
&gt; container context. IOW Im a bit confused as to the exact intended use
&gt; of the whole series. Can you elaborate?
</span>
I went into this in my response to Jann.

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181001090809.6t7ydq7gk2bwbout@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#m1f79f0bf1b6db2badf3e2e999b8ef7acd303a661" id="e1f79f0bf1b6db2badf3e2e999b8ef7acd303a661">^</a> <a href="https://lore.kernel.org/lkml/20181001090809.6t7ydq7gk2bwbout@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001090809.6t7ydq7gk2bwbout@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001090809.6t7ydq7gk2bwbout@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001090809.6t7ydq7gk2bwbout@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001090809.6t7ydq7gk2bwbout@ryuk/t/#u">nested</a>] <a href="#r1f79f0bf1b6db2badf3e2e999b8ef7acd303a661">53+ messages in thread</a></pre><hr><pre><a href="#efc968a7da9d5629a298a520b5ea1b852a73ab01a" id="mfc968a7da9d5629a298a520b5ea1b852a73ab01a">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-01  5:44     ` <a href="#mbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">Aleksa Sarai</a>
<b>@ 2018-10-01 10:13       ` Jann Horn</b>
  2018-10-01 16:18         ` <a href="#madb4f69d46d490beab7f3563227268b15c6ed379">Aleksa Sarai</a>
  2018-10-01 10:42       ` <a href="#m1b782ac97737b5e7b08cbd17245d59b61dc647d6">Christian Brauner</a>
                         ` <a href="#r1b782ac97737b5e7b08cbd17245d59b61dc647d6">(2 subsequent siblings)</a>
  <a href="#rfc968a7da9d5629a298a520b5ea1b852a73ab01a">3 siblings, 1 reply; 53+ messages in thread</a>
From: Jann Horn @ 2018-10-01 10:13 UTC (<a href="https://lore.kernel.org/lkml/CAG48ez3ApZC5cGzTxyt1ej0CyhYPD4PUEf5nbkqPmNbO+daOXQ@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CAG48ez3ApZC5cGzTxyt1ej0CyhYPD4PUEf5nbkqPmNbO+daOXQ@mail.gmail.com/raw">raw</a>)
  To: cyphar, Eric W. Biederman, Al Viro
  Cc: jlayton, Bruce Fields, Arnd Bergmann, shuah, David Howells,
	Andy Lutomirski, christian, Tycho Andersen, kernel list,
	linux-fsdevel, linux-arch, linux-kselftest, dev, containers,
	Linux API

On Mon, Oct 1, 2018 at 7:44 AM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
<span>&gt; On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; The problem is what happens if a folder you are walking through is
&gt; &gt; concurrently moved out of the chroot. Consider the following scenario:
&gt; &gt;
&gt; &gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; &gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; &gt; the following:
&gt; &gt;
&gt; &gt; 1. You start the path walk and reach /A/B/C.
&gt; &gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; &gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; &gt; the process root, but you never actually encountered the process root,
&gt; &gt; so you don't notice.
&gt; &gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; &gt; outside the process root, but you don't notice.
&gt; &gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; &gt; successfully. You now have an fd pointing outside your chroot.
&gt; &gt;
&gt; &gt; If the root of your walk is below an attacker-controlled directory,
&gt; &gt; this of course means that you lose instantly. If you point the root of
&gt; &gt; the walk at a directory out of which a process in the container
&gt; &gt; wouldn't be able to move the file, you're probably kinda mostly fine -
&gt; &gt; as long as you know, for certain, that nothing else on the system
&gt; &gt; would ever do that. But I still wouldn't feel good about that.
&gt;
&gt; Please correct me if I'm wrong here (this is the first patch I've
&gt; written for VFS). Isn't the retry/LOOKUP_REVAL code meant to handle this
&gt; -- or does that only handle if a particular path component changes
&gt; *while* it's being walked through?
</span>
Eric Biederman should be able to talk about all this much better than
me, but as far as I know, the LOOKUP_REVAL path is only for dealing
with some special filesystems like procfs.

<span>&gt; Is it possible for a path walk to
&gt; succeed after a path component was unmounted (obviously you can't delete
&gt; a directory path component since you'd get -ENOTEMPTY)?
</span>
I don't think so, but I'm not exactly a VFS expert.

<span>&gt; If this is an issue for AT_THIS_ROOT, I believe this might also be an
&gt; issue for AT_BENEATH since they are effectively both using the same
&gt; nd-&gt;root trick (so you could similarly trick AT_BENEATH to not error
&gt; out). So we'd need to figure out how to solve this problem in order for
&gt; AT_BENEATH to be safe.
</span>
Oh, wait, what? I think I didn't notice that the semantics of
AT_BENEATH changed like that since the original posting of David
Drysdale's O_BENEATH_ONLY patch
(<a href="https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/">https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/</a>).
David's patch had nice, straightforward semantics, blocking any form
of upwards traversal. Why was that changed? Does anyone actually want
to use paths that contain ".." with AT_BENEATH? I would strongly
prefer something that blocks any use of "..".

@Al: It looks like this already changed back when you posted
<a href="https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/">https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/</a>
?

<span>&gt; Speaking naively, doesn't it make sense to invalidate the walk if a path
&gt; component was modified? Or is this something that would be far too
&gt; costly with little benefit? What if we do more aggressive nd-&gt;root
&gt; checks when resolving with AT_BENEATH or AT_THIS_ROOT (or if nd-&gt;root !=
&gt; current-&gt;mnt_ns-&gt;root)?
</span>
It seems to me like doing that would basically require looking at each
node in the path walk twice? And it'd be difficult to guarantee
forward progress unless you're willing to do some fairly heavy
locking.

<span>&gt; Regarding chroot attacks, I was aware of the trivial
&gt; chroot-open-chroot-fchdir attack but I was not aware that there was a
&gt; rename attack for chroot. Thanks for bringing this up!
&gt;
&gt; &gt; I believe that the only way to robustly use this would be to point the
&gt; &gt; dirfd at a mount point, such that you know that being moved out of the
&gt; &gt; chroot is impossible because the mount point limits movement of
&gt; &gt; directories under it. (Well, technically, it doesn't, but it ensures
&gt; &gt; that if a directory does dangerously move away, the syscall fails.) It
&gt; &gt; might make sense to hardcode this constraint in the implementation of
&gt; &gt; AT_THIS_ROOT, to keep people from shooting themselves in the foot.
&gt;
&gt; Unless I'm missing something, would this not also affect using a
&gt; mountpoint as a dirfd-root (with MS_MOVE of an already-walked-through
&gt; path component) -- or does MS_MOVE cause a rewalk in a way that rename
&gt; does not?
</span>
Hmm. Good point.

It looks to me like you probably wouldn't be able to walk up through a
mountpoint in RCU mode after the mount hierarchy has changed (see
follow_dotdot_rcu()), but it might work in refwalk mode.

Eric?

<span>&gt; I wouldn't mind tying AT_THIS_ROOT to only work on mountpoints (I
&gt; thought that bind-mounts would be an issue but you also get -EXDEV when
&gt; trying to rename across bind-mounts even if they are on the same
&gt; underlying filesystem). But AT_BENEATH might be a more bitter pill to
&gt; swallow. I'm not sure.
</span>
Which is part of why I strongly prefer the semantics from David
Drysdale's O_BENEATH_ONLY.

<span>&gt; In the usecase of container runtimes, we wouldn't generally be doing
&gt; resolution of attacker-controlled paths but it still definitely doesn't
&gt; hurt to consider this part of the threat model -- to avoid foot-gunning
&gt; as you've said. (There also might be some nested-container cases where
&gt; you might want to do that.)
&gt;
&gt; &gt; &gt; Currently most container runtimes try to do this resolution in
&gt; &gt; &gt; userspace[1], causing many potential race conditions. In addition, the
&gt; &gt; &gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; &gt; &gt; requires a fork+exec which is *very* costly if necessary for every
&gt; &gt; &gt; filesystem operation involving a container.
&gt; &gt;
&gt; &gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt; &gt; a full fork() either, clone() lets you do this with some process parts
&gt; &gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt; &gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt; &gt; wouldn't you want to use setns()?
&gt;
&gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; for CLONE_VFORK.
</span>
If you insist on implementing every last bit of your code in Go, I guess.

<span>&gt; (It should be noted that multi-threaded C runtimes have somewhat similar
&gt; issues -- AFAIK you can technically only use AS-Safe glibc functions
&gt; after a fork() but that's more of a theoretical concern here. If you
&gt; just use raw syscalls there isn't an issue.)
&gt;
&gt; As for why use setns() rather than pivot_root(), there are cases where
&gt; you're operating on a container's image without a running container
&gt; (think image extraction or snapshotting tools). In those cases, you
&gt; would need to set up a dummy container process in order to setns() into
&gt; its namespaces. You are right that setns() would be a better option if
&gt; you want the truthful state of what mounts the container sees.
&gt;
&gt; [I also don't like the idea of joining the user namespace of a malicious
&gt; container unless it's necessary but that's probably just needless
&gt; paranoia more than anything -- since you're not joining the pidns you
&gt; aren't trivially addressable by a malicious container.]
&gt;
&gt; &gt; // Ensure that we are non-dumpable. Together with
&gt; &gt; // commit bfedb589252c, this ensures that container root
&gt; &gt; // can't trace our child once it enters the container.
&gt; &gt; // My patch
&gt; &gt; // <a href="https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/">https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/</a>
&gt; &gt; // would make this unnecessary, but that patch didn't
&gt; &gt; // land because Eric nacked it (for political reasons,
&gt; &gt; // because people incorrectly claimed that this was a
&gt; &gt; // security fix):
&gt;
&gt; Unless I'm very much mistaken this was fixed by bfedb589252c ("mm: Add a
&gt; user_ns owner to mm_struct and fix ptrace permission checks"). If you
&gt; join a user namespace then processes within that user namespace won't
&gt; have ptrace_may_access() permissions because your mm is owned by an
&gt; ancestor user namespace -- only after exec() will you be traceable.
</span>
Nope. The code added in bfedb589252c only applies if `get_dumpable(mm)
!= SUID_DUMP_USER`.

Looking at the current version, you can see that
`ptrace_has_cap(tcred-&gt;user_ns, mode)` is enough to ptrace a process
that is not nondumpable.

<span>&gt; We still use PR_SET_DUMPABLE in runc but that's because we support older
&gt; kernels (and people don't use user namespaces under Docker) but with
&gt; user namespaces this should not be required anymore.
</span>
<a href="#mfc968a7da9d5629a298a520b5ea1b852a73ab01a" id="efc968a7da9d5629a298a520b5ea1b852a73ab01a">^</a> <a href="https://lore.kernel.org/lkml/CAG48ez3ApZC5cGzTxyt1ej0CyhYPD4PUEf5nbkqPmNbO+daOXQ@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CAG48ez3ApZC5cGzTxyt1ej0CyhYPD4PUEf5nbkqPmNbO+daOXQ@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CAG48ez3ApZC5cGzTxyt1ej0CyhYPD4PUEf5nbkqPmNbO+daOXQ@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CAG48ez3ApZC5cGzTxyt1ej0CyhYPD4PUEf5nbkqPmNbO+daOXQ@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CAG48ez3ApZC5cGzTxyt1ej0CyhYPD4PUEf5nbkqPmNbO+daOXQ@mail.gmail.com/t/#u">nested</a>] <a href="#rfc968a7da9d5629a298a520b5ea1b852a73ab01a">53+ messages in thread</a></pre><hr><pre><a href="#e1b782ac97737b5e7b08cbd17245d59b61dc647d6" id="m1b782ac97737b5e7b08cbd17245d59b61dc647d6">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-01  5:44     ` <a href="#mbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">Aleksa Sarai</a>
  2018-10-01 10:13       ` <a href="#mfc968a7da9d5629a298a520b5ea1b852a73ab01a">Jann Horn</a>
<b>@ 2018-10-01 10:42       ` Christian Brauner</b>
  2018-10-01 11:29         ` <a href="#ma3c591b3743f9cdd74d7a81a42ab62150623f9cc">Jann Horn</a>
  2018-10-01 13:55       ` <a href="#ma82a25fbd4af29c4ea56cff51c5aaf74ada5b785">Bruce Fields</a>
  2018-10-01 14:28       ` <a href="#m3b93afe618d6a330d4d98444dabad9e268b0e1bc">Andy Lutomirski</a>
  <a href="#r1b782ac97737b5e7b08cbd17245d59b61dc647d6">3 siblings, 1 reply; 53+ messages in thread</a>
From: Christian Brauner @ 2018-10-01 10:42 UTC (<a href="https://lore.kernel.org/lkml/20181001104202.f6tz54s3fbvld56g@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001104202.f6tz54s3fbvld56g@brauner.io/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jann Horn, Eric W. Biederman, jlayton, Bruce Fields, Al Viro,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API

On Mon, Oct 01, 2018 at 03:44:28PM +1000, Aleksa Sarai wrote:
<span>&gt; On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; The problem is what happens if a folder you are walking through is
&gt; &gt; concurrently moved out of the chroot. Consider the following scenario:
&gt; &gt; 
&gt; &gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; &gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; &gt; the following:
&gt; &gt; 
&gt; &gt; 1. You start the path walk and reach /A/B/C.
&gt; &gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; &gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; &gt; the process root, but you never actually encountered the process root,
&gt; &gt; so you don't notice.
&gt; &gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; &gt; outside the process root, but you don't notice.
&gt; &gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; &gt; successfully. You now have an fd pointing outside your chroot.
&gt; &gt; 
&gt; &gt; If the root of your walk is below an attacker-controlled directory,
&gt; &gt; this of course means that you lose instantly. If you point the root of
&gt; &gt; the walk at a directory out of which a process in the container
&gt; &gt; wouldn't be able to move the file, you're probably kinda mostly fine -
&gt; &gt; as long as you know, for certain, that nothing else on the system
&gt; &gt; would ever do that. But I still wouldn't feel good about that.
&gt; 
&gt; Please correct me if I'm wrong here (this is the first patch I've
&gt; written for VFS). Isn't the retry/LOOKUP_REVAL code meant to handle this
&gt; -- or does that only handle if a particular path component changes
&gt; *while* it's being walked through? Is it possible for a path walk to
&gt; succeed after a path component was unmounted (obviously you can't delete
&gt; a directory path component since you'd get -ENOTEMPTY)?
&gt; 
&gt; If this is an issue for AT_THIS_ROOT, I believe this might also be an
&gt; issue for AT_BENEATH since they are effectively both using the same
&gt; nd-&gt;root trick (so you could similarly trick AT_BENEATH to not error
&gt; out). So we'd need to figure out how to solve this problem in order for
&gt; AT_BENEATH to be safe.
&gt; 
&gt; Speaking naively, doesn't it make sense to invalidate the walk if a path
&gt; component was modified? Or is this something that would be far too
&gt; costly with little benefit? What if we do more aggressive nd-&gt;root
&gt; checks when resolving with AT_BENEATH or AT_THIS_ROOT (or if nd-&gt;root !=
&gt; current-&gt;mnt_ns-&gt;root)?
&gt; 
&gt; Regarding chroot attacks, I was aware of the trivial
&gt; chroot-open-chroot-fchdir attack but I was not aware that there was a
&gt; rename attack for chroot. Thanks for bringing this up!
&gt; 
&gt; &gt; I believe that the only way to robustly use this would be to point the
&gt; &gt; dirfd at a mount point, such that you know that being moved out of the
&gt; &gt; chroot is impossible because the mount point limits movement of
&gt; &gt; directories under it. (Well, technically, it doesn't, but it ensures
&gt; &gt; that if a directory does dangerously move away, the syscall fails.) It
&gt; &gt; might make sense to hardcode this constraint in the implementation of
&gt; &gt; AT_THIS_ROOT, to keep people from shooting themselves in the foot.
&gt; 
&gt; Unless I'm missing something, would this not also affect using a
&gt; mountpoint as a dirfd-root (with MS_MOVE of an already-walked-through
&gt; path component) -- or does MS_MOVE cause a rewalk in a way that rename
&gt; does not?
&gt; 
&gt; I wouldn't mind tying AT_THIS_ROOT to only work on mountpoints (I
&gt; thought that bind-mounts would be an issue but you also get -EXDEV when
&gt; trying to rename across bind-mounts even if they are on the same
&gt; underlying filesystem). But AT_BENEATH might be a more bitter pill to
&gt; swallow. I'm not sure.
&gt; 
&gt; In the usecase of container runtimes, we wouldn't generally be doing
&gt; resolution of attacker-controlled paths but it still definitely doesn't
&gt; hurt to consider this part of the threat model -- to avoid foot-gunning
&gt; as you've said. (There also might be some nested-container cases where
&gt; you might want to do that.)
&gt; 
&gt; &gt; &gt; Currently most container runtimes try to do this resolution in
&gt; &gt; &gt; userspace[1], causing many potential race conditions. In addition, the
&gt; &gt; &gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; &gt; &gt; requires a fork+exec which is *very* costly if necessary for every
&gt; &gt; &gt; filesystem operation involving a container.
&gt; &gt; 
&gt; &gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt; &gt; a full fork() either, clone() lets you do this with some process parts
&gt; &gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt; &gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt; &gt; wouldn't you want to use setns()?
&gt; 
&gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; for CLONE_VFORK.
&gt; 
&gt; (It should be noted that multi-threaded C runtimes have somewhat similar
&gt; issues -- AFAIK you can technically only use AS-Safe glibc functions
&gt; after a fork() but that's more of a theoretical concern here. If you
&gt; just use raw syscalls there isn't an issue.)
&gt; 
&gt; As for why use setns() rather than pivot_root(), there are cases where
&gt; you're operating on a container's image without a running container
&gt; (think image extraction or snapshotting tools). In those cases, you
&gt; would need to set up a dummy container process in order to setns() into
&gt; its namespaces. You are right that setns() would be a better option if
&gt; you want the truthful state of what mounts the container sees.
&gt; 
&gt; [I also don't like the idea of joining the user namespace of a malicious
&gt; container unless it's necessary but that's probably just needless
&gt; paranoia more than anything -- since you're not joining the pidns you
&gt; aren't trivially addressable by a malicious container.]
&gt; 
&gt; &gt; // Ensure that we are non-dumpable. Together with
&gt; &gt; // commit bfedb589252c, this ensures that container root
&gt; &gt; // can't trace our child once it enters the container.
&gt; &gt; // My patch
&gt; &gt; // <a href="https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/">https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/</a>
&gt; &gt; // would make this unnecessary, but that patch didn't
&gt; &gt; // land because Eric nacked it (for political reasons,
&gt; &gt; // because people incorrectly claimed that this was a
&gt; &gt; // security fix):
&gt; 
&gt; Unless I'm very much mistaken this was fixed by bfedb589252c ("mm: Add a
&gt; user_ns owner to mm_struct and fix ptrace permission checks"). If you
&gt; join a user namespace then processes within that user namespace won't
&gt; have ptrace_may_access() permissions because your mm is owned by an
&gt; ancestor user namespace -- only after exec() will you be traceable.
</span>
That is not _completely_ true. 
Iirc (Please someone do yell at me if I'm wrong!), this is as follows.
You will in fact be dumpable as long as you don't set{g,u}id() to an
effective uid that is different from the effective uid of the process
that created the task. For example, if you clone(CLONE_NEWUSER) as an
unprivileged user with uid and euid 1000 you are in fact dumpable and
thus traceable *but* if you do a setuid(0) in the new task then you will
end up with old-&gt;euid = 1000 and new-&gt;euid = 0 at which point the kernel
will remove the dumpable flag and the creating process cannot trace you
anymore (which has funny consequences for lsm isolation and sending fds
around). Iiuc, The same logic applies when you do a setns() to another
user namespace.

	/* dumpability changes */
	if (!uid_eq(old-&gt;euid, new-&gt;euid) ||
	    !gid_eq(old-&gt;egid, new-&gt;egid) ||
	    !uid_eq(old-&gt;fsuid, new-&gt;fsuid) ||
	    !gid_eq(old-&gt;fsgid, new-&gt;fsgid) ||
	    !cred_cap_issubset(old, new)) {
		if (task-&gt;mm)
			set_dumpable(task-&gt;mm, suid_dumpable); &lt;&lt;&lt; suid_dumpable == 0 at this point
		task-&gt;pdeath_signal = 0;
		smp_wmb();
	}

<span>&gt; 
&gt; We still use PR_SET_DUMPABLE in runc but that's because we support older
&gt; kernels (and people don't use user namespaces under Docker) but with
&gt; user namespaces this should not be required anymore.
&gt; 
&gt; -- 
&gt; Aleksa Sarai
&gt; Senior Software Engineer (Containers)
&gt; SUSE Linux GmbH
&gt; &lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;
</span>


<a href="#m1b782ac97737b5e7b08cbd17245d59b61dc647d6" id="e1b782ac97737b5e7b08cbd17245d59b61dc647d6">^</a> <a href="https://lore.kernel.org/lkml/20181001104202.f6tz54s3fbvld56g@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001104202.f6tz54s3fbvld56g@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001104202.f6tz54s3fbvld56g@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001104202.f6tz54s3fbvld56g@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001104202.f6tz54s3fbvld56g@brauner.io/t/#u">nested</a>] <a href="#r1b782ac97737b5e7b08cbd17245d59b61dc647d6">53+ messages in thread</a></pre><hr><pre><a href="#ea3c591b3743f9cdd74d7a81a42ab62150623f9cc" id="ma3c591b3743f9cdd74d7a81a42ab62150623f9cc">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-01 10:42       ` <a href="#m1b782ac97737b5e7b08cbd17245d59b61dc647d6">Christian Brauner</a>
<b>@ 2018-10-01 11:29         ` Jann Horn</b>
  2018-10-01 12:35           ` <a href="#md836ca3a6928d79163766ed39bda531b37819f9a">Christian Brauner</a>
  <a href="#ra3c591b3743f9cdd74d7a81a42ab62150623f9cc">0 siblings, 1 reply; 53+ messages in thread</a>
From: Jann Horn @ 2018-10-01 11:29 UTC (<a href="https://lore.kernel.org/lkml/CAG48ez32xKKdtNWreLUMqB+tOfMy-bUK2Bo=vujOTb3qK9NwBg@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CAG48ez32xKKdtNWreLUMqB+tOfMy-bUK2Bo=vujOTb3qK9NwBg@mail.gmail.com/raw">raw</a>)
  To: christian
  Cc: cyphar, Eric W. Biederman, jlayton, Bruce Fields, Al Viro,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API

On Mon, Oct 1, 2018 at 12:42 PM Christian Brauner &lt;christian@brauner.io&gt; wrote:
<span>&gt; On Mon, Oct 01, 2018 at 03:44:28PM +1000, Aleksa Sarai wrote:
&gt; &gt; On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; &gt; The problem is what happens if a folder you are walking through is
&gt; &gt; &gt; concurrently moved out of the chroot. Consider the following scenario:
&gt; &gt; &gt;
&gt; &gt; &gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; &gt; &gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; &gt; &gt; the following:
&gt; &gt; &gt;
&gt; &gt; &gt; 1. You start the path walk and reach /A/B/C.
&gt; &gt; &gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; &gt; &gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; &gt; &gt; the process root, but you never actually encountered the process root,
&gt; &gt; &gt; so you don't notice.
&gt; &gt; &gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; &gt; &gt; outside the process root, but you don't notice.
&gt; &gt; &gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; &gt; &gt; successfully. You now have an fd pointing outside your chroot.
&gt; &gt; &gt;
&gt; &gt; &gt; If the root of your walk is below an attacker-controlled directory,
&gt; &gt; &gt; this of course means that you lose instantly. If you point the root of
&gt; &gt; &gt; the walk at a directory out of which a process in the container
&gt; &gt; &gt; wouldn't be able to move the file, you're probably kinda mostly fine -
&gt; &gt; &gt; as long as you know, for certain, that nothing else on the system
&gt; &gt; &gt; would ever do that. But I still wouldn't feel good about that.
&gt; &gt;
&gt; &gt; Please correct me if I'm wrong here (this is the first patch I've
&gt; &gt; written for VFS). Isn't the retry/LOOKUP_REVAL code meant to handle this
&gt; &gt; -- or does that only handle if a particular path component changes
&gt; &gt; *while* it's being walked through? Is it possible for a path walk to
&gt; &gt; succeed after a path component was unmounted (obviously you can't delete
&gt; &gt; a directory path component since you'd get -ENOTEMPTY)?
&gt; &gt;
&gt; &gt; If this is an issue for AT_THIS_ROOT, I believe this might also be an
&gt; &gt; issue for AT_BENEATH since they are effectively both using the same
&gt; &gt; nd-&gt;root trick (so you could similarly trick AT_BENEATH to not error
&gt; &gt; out). So we'd need to figure out how to solve this problem in order for
&gt; &gt; AT_BENEATH to be safe.
&gt; &gt;
&gt; &gt; Speaking naively, doesn't it make sense to invalidate the walk if a path
&gt; &gt; component was modified? Or is this something that would be far too
&gt; &gt; costly with little benefit? What if we do more aggressive nd-&gt;root
&gt; &gt; checks when resolving with AT_BENEATH or AT_THIS_ROOT (or if nd-&gt;root !=
&gt; &gt; current-&gt;mnt_ns-&gt;root)?
&gt; &gt;
&gt; &gt; Regarding chroot attacks, I was aware of the trivial
&gt; &gt; chroot-open-chroot-fchdir attack but I was not aware that there was a
&gt; &gt; rename attack for chroot. Thanks for bringing this up!
&gt; &gt;
&gt; &gt; &gt; I believe that the only way to robustly use this would be to point the
&gt; &gt; &gt; dirfd at a mount point, such that you know that being moved out of the
&gt; &gt; &gt; chroot is impossible because the mount point limits movement of
&gt; &gt; &gt; directories under it. (Well, technically, it doesn't, but it ensures
&gt; &gt; &gt; that if a directory does dangerously move away, the syscall fails.) It
&gt; &gt; &gt; might make sense to hardcode this constraint in the implementation of
&gt; &gt; &gt; AT_THIS_ROOT, to keep people from shooting themselves in the foot.
&gt; &gt;
&gt; &gt; Unless I'm missing something, would this not also affect using a
&gt; &gt; mountpoint as a dirfd-root (with MS_MOVE of an already-walked-through
&gt; &gt; path component) -- or does MS_MOVE cause a rewalk in a way that rename
&gt; &gt; does not?
&gt; &gt;
&gt; &gt; I wouldn't mind tying AT_THIS_ROOT to only work on mountpoints (I
&gt; &gt; thought that bind-mounts would be an issue but you also get -EXDEV when
&gt; &gt; trying to rename across bind-mounts even if they are on the same
&gt; &gt; underlying filesystem). But AT_BENEATH might be a more bitter pill to
&gt; &gt; swallow. I'm not sure.
&gt; &gt;
&gt; &gt; In the usecase of container runtimes, we wouldn't generally be doing
&gt; &gt; resolution of attacker-controlled paths but it still definitely doesn't
&gt; &gt; hurt to consider this part of the threat model -- to avoid foot-gunning
&gt; &gt; as you've said. (There also might be some nested-container cases where
&gt; &gt; you might want to do that.)
&gt; &gt;
&gt; &gt; &gt; &gt; Currently most container runtimes try to do this resolution in
&gt; &gt; &gt; &gt; userspace[1], causing many potential race conditions. In addition, the
&gt; &gt; &gt; &gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; &gt; &gt; &gt; requires a fork+exec which is *very* costly if necessary for every
&gt; &gt; &gt; &gt; filesystem operation involving a container.
&gt; &gt; &gt;
&gt; &gt; &gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt; &gt; &gt; a full fork() either, clone() lets you do this with some process parts
&gt; &gt; &gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt; &gt; &gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt; &gt; &gt; wouldn't you want to use setns()?
&gt; &gt;
&gt; &gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; &gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; &gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; &gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; &gt; for CLONE_VFORK.
&gt; &gt;
&gt; &gt; (It should be noted that multi-threaded C runtimes have somewhat similar
&gt; &gt; issues -- AFAIK you can technically only use AS-Safe glibc functions
&gt; &gt; after a fork() but that's more of a theoretical concern here. If you
&gt; &gt; just use raw syscalls there isn't an issue.)
&gt; &gt;
&gt; &gt; As for why use setns() rather than pivot_root(), there are cases where
&gt; &gt; you're operating on a container's image without a running container
&gt; &gt; (think image extraction or snapshotting tools). In those cases, you
&gt; &gt; would need to set up a dummy container process in order to setns() into
&gt; &gt; its namespaces. You are right that setns() would be a better option if
&gt; &gt; you want the truthful state of what mounts the container sees.
&gt; &gt;
&gt; &gt; [I also don't like the idea of joining the user namespace of a malicious
&gt; &gt; container unless it's necessary but that's probably just needless
&gt; &gt; paranoia more than anything -- since you're not joining the pidns you
&gt; &gt; aren't trivially addressable by a malicious container.]
&gt; &gt;
&gt; &gt; &gt; // Ensure that we are non-dumpable. Together with
&gt; &gt; &gt; // commit bfedb589252c, this ensures that container root
&gt; &gt; &gt; // can't trace our child once it enters the container.
&gt; &gt; &gt; // My patch
&gt; &gt; &gt; // <a href="https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/">https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/</a>
&gt; &gt; &gt; // would make this unnecessary, but that patch didn't
&gt; &gt; &gt; // land because Eric nacked it (for political reasons,
&gt; &gt; &gt; // because people incorrectly claimed that this was a
&gt; &gt; &gt; // security fix):
&gt; &gt;
&gt; &gt; Unless I'm very much mistaken this was fixed by bfedb589252c ("mm: Add a
&gt; &gt; user_ns owner to mm_struct and fix ptrace permission checks"). If you
&gt; &gt; join a user namespace then processes within that user namespace won't
&gt; &gt; have ptrace_may_access() permissions because your mm is owned by an
&gt; &gt; ancestor user namespace -- only after exec() will you be traceable.
&gt;
&gt; That is not _completely_ true.
&gt; Iirc (Please someone do yell at me if I'm wrong!), this is as follows.
&gt; You will in fact be dumpable as long as you don't set{g,u}id() to an
&gt; effective uid that is different from the effective uid of the process
&gt; that created the task. For example, if you clone(CLONE_NEWUSER) as an
&gt; unprivileged user with uid and euid 1000 you are in fact dumpable and
&gt; thus traceable *but* if you do a setuid(0) in the new task then you will
&gt; end up with old-&gt;euid = 1000 and new-&gt;euid = 0 at which point the kernel
&gt; will remove the dumpable flag and the creating process cannot trace you
&gt; anymore (which has funny consequences for lsm isolation and sending fds
&gt; around). Iiuc, The same logic applies when you do a setns() to another
&gt; user namespace.
</span>
(Note that this is only true if your un-namespaced UID actually
changes. If you create a user namespace and then write to its uid_map
such that your namespaced UID is zero, that won't trigger this logic.)

<a href="#ma3c591b3743f9cdd74d7a81a42ab62150623f9cc" id="ea3c591b3743f9cdd74d7a81a42ab62150623f9cc">^</a> <a href="https://lore.kernel.org/lkml/CAG48ez32xKKdtNWreLUMqB+tOfMy-bUK2Bo=vujOTb3qK9NwBg@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CAG48ez32xKKdtNWreLUMqB+tOfMy-bUK2Bo=vujOTb3qK9NwBg@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CAG48ez32xKKdtNWreLUMqB+tOfMy-bUK2Bo=vujOTb3qK9NwBg@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CAG48ez32xKKdtNWreLUMqB+tOfMy-bUK2Bo=vujOTb3qK9NwBg@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CAG48ez32xKKdtNWreLUMqB+tOfMy-bUK2Bo=vujOTb3qK9NwBg@mail.gmail.com/t/#u">nested</a>] <a href="#ra3c591b3743f9cdd74d7a81a42ab62150623f9cc">53+ messages in thread</a></pre><hr><pre><a href="#e00fa1270161fca853ab401153f61255570562b60" id="m00fa1270161fca853ab401153f61255570562b60">*</a> <b>Re: [PATCH 1/3] namei: implement O_BENEATH-style AT_* flags</b>
  2018-09-29 10:34 ` <a href="#m1383f86e3b88f40c8cb1ba987680029c591c723c">[PATCH 1/3] namei: implement O_BENEATH-style</a> " Aleksa Sarai
  2018-09-29 14:48   ` <a href="#mbb17b5e39af1ab7962ea44cc159ac0b57a3386fd">Christian Brauner</a>
  2018-09-30  4:38   ` <a href="#m87f541d8dc933342c485dd668073dfec153d374c">Aleksa Sarai</a>
<b>@ 2018-10-01 12:28   ` Jann Horn</b>
  2018-10-01 13:00     ` <a href="#md260e196a4c724d56ef8025c70584b9967d30d3a">Christian Brauner</a>
  <a href="#r00fa1270161fca853ab401153f61255570562b60">2 siblings, 1 reply; 53+ messages in thread</a>
From: Jann Horn @ 2018-10-01 12:28 UTC (<a href="https://lore.kernel.org/lkml/CAG48ez17EQuJQAZUg5hDFXhkjnnVFh39=aD+j0FBdsoTONSGEA@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CAG48ez17EQuJQAZUg5hDFXhkjnnVFh39=aD+j0FBdsoTONSGEA@mail.gmail.com/raw">raw</a>)
  To: cyphar, Al Viro, Eric W. Biederman, Andy Lutomirski
  Cc: jlayton, Bruce Fields, Arnd Bergmann, shuah, David Howells,
	christian, Tycho Andersen, kernel list, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers

On Sat, Sep 29, 2018 at 4:28 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
<span>&gt; Add the following flags for path resolution. The primary justification
&gt; for these flags is to allow for programs to be far more strict about how
&gt; they want path resolution to handle symlinks, mountpoint crossings, and
&gt; paths that escape the dirfd (through an absolute path or ".."
&gt; shenanigans).
&gt;
&gt; This is of particular concern to container runtimes that want to be very
&gt; careful about malicious root filesystems that a container's init might
&gt; have screwed around with (and there is no real way to protect against
&gt; this in userspace if you consider potential races against a malicious
&gt; container's init).
&gt;
&gt; * AT_BENEATH: Disallow ".." or absolute paths (either in the path or
&gt;   found during symlink resolution) to escape the starting point of name
&gt;   resolution, though ".." is permitted in cases like "foo/../bar".
&gt;   Relative symlinks are still allowed (as long as they don't escape the
&gt;   starting point).
</span>
As I said on the other thread, I would strongly prefer an API that
behaves along the lines of David Drysdale's old patch
<a href="https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/">https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/</a>
: Forbid any use of "..". This would also be more straightforward to
implement safely. If that doesn't work for you, I would like it if you
could at least make that an option. I would like it if this API could
mitigate straightforward directory traversal bugs such as
<a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1583">https://bugs.chromium.org/p/project-zero/issues/detail?id=1583</a>, where
a confused deputy attempts to access a path like
"/mnt/media_rw/../../data" while intending to access a directory under
"/mnt/media_rw".

<span>&gt; * AT_XDEV: Disallow mount-point crossing (both *down* into one, or *up*
&gt;   from one). The primary "scoping" use is to blocking resolution that
&gt;   crosses a bind-mount, which has a similar property to a symlink (in
&gt;   the way that it allows for escape from the starting-point). Since it
&gt;   is not possible to differentiate bind-mounts However since
&gt;   bind-mounting requires privileges (in ways symlinks don't) this has
&gt;   been split from LOOKUP_BENEATH. The naming is based on "find -xdev"
&gt;   (though find(1) doesn't walk upwards, the semantics seem obvious).
&gt;
&gt; * AT_NO_PROCLINK: Disallows -&gt;get_link "symlink" jumping. This is a very
&gt;   specific restriction, and it exists because /proc/$pid/fd/...
&gt;   "symlinks" allow for access outside nd-&gt;root and pose risk to
&gt;   container runtimes that don't want to be tricked into accessing a host
&gt;   path (but do want to allow no-funny-business symlink resolution).
</span>
AT_BENEATH has to imply AT_NO_PROCLINK, right? Especially with the
semantics you picked for AT_BENEATH. With the original O_BENEATH_ONLY
semantics, it might be okay to not imply AT_NO_PROCLINK...

<span>&gt; * AT_NO_SYMLINK: Disallows symlink jumping *of any kind*. Implies
&gt;   AT_NO_PROCLINK (obviously).
&gt;
&gt; The AT_NO_*LINK flags return -ELOOP if path resolution would violates
&gt; their requirement, while the others all return -EXDEV. Currently these
&gt; are only enabled for the stat(2) family and the openat(2) family (the
&gt; latter has its own brand of O_* flags with the same semantics). Ideally
&gt; these flags would be supported by all *at(2) syscalls, but this will
&gt; require adding flags arguments to many of them (and will be done in a
&gt; separate patchset).
</span>
<a href="#m00fa1270161fca853ab401153f61255570562b60" id="e00fa1270161fca853ab401153f61255570562b60">^</a> <a href="https://lore.kernel.org/lkml/CAG48ez17EQuJQAZUg5hDFXhkjnnVFh39=aD+j0FBdsoTONSGEA@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CAG48ez17EQuJQAZUg5hDFXhkjnnVFh39=aD+j0FBdsoTONSGEA@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CAG48ez17EQuJQAZUg5hDFXhkjnnVFh39=aD+j0FBdsoTONSGEA@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CAG48ez17EQuJQAZUg5hDFXhkjnnVFh39=aD+j0FBdsoTONSGEA@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CAG48ez17EQuJQAZUg5hDFXhkjnnVFh39=aD+j0FBdsoTONSGEA@mail.gmail.com/t/#u">nested</a>] <a href="#r00fa1270161fca853ab401153f61255570562b60">53+ messages in thread</a></pre><hr><pre><a href="#ed836ca3a6928d79163766ed39bda531b37819f9a" id="md836ca3a6928d79163766ed39bda531b37819f9a">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-01 11:29         ` <a href="#ma3c591b3743f9cdd74d7a81a42ab62150623f9cc">Jann Horn</a>
<b>@ 2018-10-01 12:35           ` Christian Brauner</b>
  <a href="#rd836ca3a6928d79163766ed39bda531b37819f9a">0 siblings, 0 replies; 53+ messages in thread</a>
From: Christian Brauner @ 2018-10-01 12:35 UTC (<a href="https://lore.kernel.org/lkml/20181001123535.yjo3fqkahc3q77in@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001123535.yjo3fqkahc3q77in@brauner.io/raw">raw</a>)
  To: Jann Horn
  Cc: cyphar, Eric W. Biederman, jlayton, Bruce Fields, Al Viro,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API

On Mon, Oct 01, 2018 at 01:29:16PM +0200, Jann Horn wrote:
<span>&gt; On Mon, Oct 1, 2018 at 12:42 PM Christian Brauner &lt;christian@brauner.io&gt; wrote:
&gt; &gt; On Mon, Oct 01, 2018 at 03:44:28PM +1000, Aleksa Sarai wrote:
&gt; &gt; &gt; On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; &gt; &gt; The problem is what happens if a folder you are walking through is
&gt; &gt; &gt; &gt; concurrently moved out of the chroot. Consider the following scenario:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; &gt; &gt; &gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; &gt; &gt; &gt; the following:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; 1. You start the path walk and reach /A/B/C.
&gt; &gt; &gt; &gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; &gt; &gt; &gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; &gt; &gt; &gt; the process root, but you never actually encountered the process root,
&gt; &gt; &gt; &gt; so you don't notice.
&gt; &gt; &gt; &gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; &gt; &gt; &gt; outside the process root, but you don't notice.
&gt; &gt; &gt; &gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; &gt; &gt; &gt; successfully. You now have an fd pointing outside your chroot.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; If the root of your walk is below an attacker-controlled directory,
&gt; &gt; &gt; &gt; this of course means that you lose instantly. If you point the root of
&gt; &gt; &gt; &gt; the walk at a directory out of which a process in the container
&gt; &gt; &gt; &gt; wouldn't be able to move the file, you're probably kinda mostly fine -
&gt; &gt; &gt; &gt; as long as you know, for certain, that nothing else on the system
&gt; &gt; &gt; &gt; would ever do that. But I still wouldn't feel good about that.
&gt; &gt; &gt;
&gt; &gt; &gt; Please correct me if I'm wrong here (this is the first patch I've
&gt; &gt; &gt; written for VFS). Isn't the retry/LOOKUP_REVAL code meant to handle this
&gt; &gt; &gt; -- or does that only handle if a particular path component changes
&gt; &gt; &gt; *while* it's being walked through? Is it possible for a path walk to
&gt; &gt; &gt; succeed after a path component was unmounted (obviously you can't delete
&gt; &gt; &gt; a directory path component since you'd get -ENOTEMPTY)?
&gt; &gt; &gt;
&gt; &gt; &gt; If this is an issue for AT_THIS_ROOT, I believe this might also be an
&gt; &gt; &gt; issue for AT_BENEATH since they are effectively both using the same
&gt; &gt; &gt; nd-&gt;root trick (so you could similarly trick AT_BENEATH to not error
&gt; &gt; &gt; out). So we'd need to figure out how to solve this problem in order for
&gt; &gt; &gt; AT_BENEATH to be safe.
&gt; &gt; &gt;
&gt; &gt; &gt; Speaking naively, doesn't it make sense to invalidate the walk if a path
&gt; &gt; &gt; component was modified? Or is this something that would be far too
&gt; &gt; &gt; costly with little benefit? What if we do more aggressive nd-&gt;root
&gt; &gt; &gt; checks when resolving with AT_BENEATH or AT_THIS_ROOT (or if nd-&gt;root !=
&gt; &gt; &gt; current-&gt;mnt_ns-&gt;root)?
&gt; &gt; &gt;
&gt; &gt; &gt; Regarding chroot attacks, I was aware of the trivial
&gt; &gt; &gt; chroot-open-chroot-fchdir attack but I was not aware that there was a
&gt; &gt; &gt; rename attack for chroot. Thanks for bringing this up!
&gt; &gt; &gt;
&gt; &gt; &gt; &gt; I believe that the only way to robustly use this would be to point the
&gt; &gt; &gt; &gt; dirfd at a mount point, such that you know that being moved out of the
&gt; &gt; &gt; &gt; chroot is impossible because the mount point limits movement of
&gt; &gt; &gt; &gt; directories under it. (Well, technically, it doesn't, but it ensures
&gt; &gt; &gt; &gt; that if a directory does dangerously move away, the syscall fails.) It
&gt; &gt; &gt; &gt; might make sense to hardcode this constraint in the implementation of
&gt; &gt; &gt; &gt; AT_THIS_ROOT, to keep people from shooting themselves in the foot.
&gt; &gt; &gt;
&gt; &gt; &gt; Unless I'm missing something, would this not also affect using a
&gt; &gt; &gt; mountpoint as a dirfd-root (with MS_MOVE of an already-walked-through
&gt; &gt; &gt; path component) -- or does MS_MOVE cause a rewalk in a way that rename
&gt; &gt; &gt; does not?
&gt; &gt; &gt;
&gt; &gt; &gt; I wouldn't mind tying AT_THIS_ROOT to only work on mountpoints (I
&gt; &gt; &gt; thought that bind-mounts would be an issue but you also get -EXDEV when
&gt; &gt; &gt; trying to rename across bind-mounts even if they are on the same
&gt; &gt; &gt; underlying filesystem). But AT_BENEATH might be a more bitter pill to
&gt; &gt; &gt; swallow. I'm not sure.
&gt; &gt; &gt;
&gt; &gt; &gt; In the usecase of container runtimes, we wouldn't generally be doing
&gt; &gt; &gt; resolution of attacker-controlled paths but it still definitely doesn't
&gt; &gt; &gt; hurt to consider this part of the threat model -- to avoid foot-gunning
&gt; &gt; &gt; as you've said. (There also might be some nested-container cases where
&gt; &gt; &gt; you might want to do that.)
&gt; &gt; &gt;
&gt; &gt; &gt; &gt; &gt; Currently most container runtimes try to do this resolution in
&gt; &gt; &gt; &gt; &gt; userspace[1], causing many potential race conditions. In addition, the
&gt; &gt; &gt; &gt; &gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; &gt; &gt; &gt; &gt; requires a fork+exec which is *very* costly if necessary for every
&gt; &gt; &gt; &gt; &gt; filesystem operation involving a container.
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt; &gt; &gt; &gt; a full fork() either, clone() lets you do this with some process parts
&gt; &gt; &gt; &gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt; &gt; &gt; &gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt; &gt; &gt; &gt; wouldn't you want to use setns()?
&gt; &gt; &gt;
&gt; &gt; &gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; &gt; &gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; &gt; &gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; &gt; &gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; &gt; &gt; for CLONE_VFORK.
&gt; &gt; &gt;
&gt; &gt; &gt; (It should be noted that multi-threaded C runtimes have somewhat similar
&gt; &gt; &gt; issues -- AFAIK you can technically only use AS-Safe glibc functions
&gt; &gt; &gt; after a fork() but that's more of a theoretical concern here. If you
&gt; &gt; &gt; just use raw syscalls there isn't an issue.)
&gt; &gt; &gt;
&gt; &gt; &gt; As for why use setns() rather than pivot_root(), there are cases where
&gt; &gt; &gt; you're operating on a container's image without a running container
&gt; &gt; &gt; (think image extraction or snapshotting tools). In those cases, you
&gt; &gt; &gt; would need to set up a dummy container process in order to setns() into
&gt; &gt; &gt; its namespaces. You are right that setns() would be a better option if
&gt; &gt; &gt; you want the truthful state of what mounts the container sees.
&gt; &gt; &gt;
&gt; &gt; &gt; [I also don't like the idea of joining the user namespace of a malicious
&gt; &gt; &gt; container unless it's necessary but that's probably just needless
&gt; &gt; &gt; paranoia more than anything -- since you're not joining the pidns you
&gt; &gt; &gt; aren't trivially addressable by a malicious container.]
&gt; &gt; &gt;
&gt; &gt; &gt; &gt; // Ensure that we are non-dumpable. Together with
&gt; &gt; &gt; &gt; // commit bfedb589252c, this ensures that container root
&gt; &gt; &gt; &gt; // can't trace our child once it enters the container.
&gt; &gt; &gt; &gt; // My patch
&gt; &gt; &gt; &gt; // <a href="https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/">https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/</a>
&gt; &gt; &gt; &gt; // would make this unnecessary, but that patch didn't
&gt; &gt; &gt; &gt; // land because Eric nacked it (for political reasons,
&gt; &gt; &gt; &gt; // because people incorrectly claimed that this was a
&gt; &gt; &gt; &gt; // security fix):
&gt; &gt; &gt;
&gt; &gt; &gt; Unless I'm very much mistaken this was fixed by bfedb589252c ("mm: Add a
&gt; &gt; &gt; user_ns owner to mm_struct and fix ptrace permission checks"). If you
&gt; &gt; &gt; join a user namespace then processes within that user namespace won't
&gt; &gt; &gt; have ptrace_may_access() permissions because your mm is owned by an
&gt; &gt; &gt; ancestor user namespace -- only after exec() will you be traceable.
&gt; &gt;
&gt; &gt; That is not _completely_ true.
&gt; &gt; Iirc (Please someone do yell at me if I'm wrong!), this is as follows.
&gt; &gt; You will in fact be dumpable as long as you don't set{g,u}id() to an
&gt; &gt; effective uid that is different from the effective uid of the process
&gt; &gt; that created the task. For example, if you clone(CLONE_NEWUSER) as an
&gt; &gt; unprivileged user with uid and euid 1000 you are in fact dumpable and
&gt; &gt; thus traceable *but* if you do a setuid(0) in the new task then you will
&gt; &gt; end up with old-&gt;euid = 1000 and new-&gt;euid = 0 at which point the kernel
&gt; &gt; will remove the dumpable flag and the creating process cannot trace you
&gt; &gt; anymore (which has funny consequences for lsm isolation and sending fds
&gt; &gt; around). Iiuc, The same logic applies when you do a setns() to another
&gt; &gt; user namespace.
&gt; 
&gt; (Note that this is only true if your un-namespaced UID actually
&gt; changes. If you create a user namespace and then write to its uid_map
&gt; such that your namespaced UID is zero, that won't trigger this logic.)
</span>
The way I figured this works is that it actually only applies to the
case where you're creating a user namespace as an unprivileged user. And
even in that case you will retain dumpability in two cases:
1. mapping userns id 0 to &lt;my-unpriv-host-uid&gt;
and any identity mapping, i.e.
2. mapping &lt;my-unpriv-host-uid&gt; to &lt;my-unpriv-host-uid&gt;

If you're creating a user namespace as root and set up mappings you
should always retain the dumpable flag (I might not be remembering all
corner-cases atm.) if you don't muck with capability sets and so on.

<a href="#md836ca3a6928d79163766ed39bda531b37819f9a" id="ed836ca3a6928d79163766ed39bda531b37819f9a">^</a> <a href="https://lore.kernel.org/lkml/20181001123535.yjo3fqkahc3q77in@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001123535.yjo3fqkahc3q77in@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001123535.yjo3fqkahc3q77in@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001123535.yjo3fqkahc3q77in@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001123535.yjo3fqkahc3q77in@brauner.io/t/#u">nested</a>] <a href="#rd836ca3a6928d79163766ed39bda531b37819f9a">53+ messages in thread</a></pre><hr><pre><a href="#ed260e196a4c724d56ef8025c70584b9967d30d3a" id="md260e196a4c724d56ef8025c70584b9967d30d3a">*</a> <b>Re: [PATCH 1/3] namei: implement O_BENEATH-style AT_* flags</b>
  2018-10-01 12:28   ` <a href="#m00fa1270161fca853ab401153f61255570562b60">Jann Horn</a>
<b>@ 2018-10-01 13:00     ` Christian Brauner</b>
  2018-10-01 16:04       ` <a href="#m976af4e59482b98696b0e918a77ff53493dfe932">Aleksa Sarai</a>
  <a href="#rd260e196a4c724d56ef8025c70584b9967d30d3a">0 siblings, 1 reply; 53+ messages in thread</a>
From: Christian Brauner @ 2018-10-01 13:00 UTC (<a href="https://lore.kernel.org/lkml/20181001130038.s5ztphs3pl2zt3ut@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001130038.s5ztphs3pl2zt3ut@brauner.io/raw">raw</a>)
  To: Jann Horn
  Cc: cyphar, Al Viro, Eric W. Biederman, Andy Lutomirski, jlayton,
	Bruce Fields, Arnd Bergmann, shuah, David Howells,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers

On Mon, Oct 01, 2018 at 02:28:03PM +0200, Jann Horn wrote:
<span>&gt; On Sat, Sep 29, 2018 at 4:28 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt; &gt; Add the following flags for path resolution. The primary justification
&gt; &gt; for these flags is to allow for programs to be far more strict about how
&gt; &gt; they want path resolution to handle symlinks, mountpoint crossings, and
&gt; &gt; paths that escape the dirfd (through an absolute path or ".."
&gt; &gt; shenanigans).
&gt; &gt;
&gt; &gt; This is of particular concern to container runtimes that want to be very
&gt; &gt; careful about malicious root filesystems that a container's init might
&gt; &gt; have screwed around with (and there is no real way to protect against
&gt; &gt; this in userspace if you consider potential races against a malicious
&gt; &gt; container's init).
&gt; &gt;
&gt; &gt; * AT_BENEATH: Disallow ".." or absolute paths (either in the path or
&gt; &gt;   found during symlink resolution) to escape the starting point of name
&gt; &gt;   resolution, though ".." is permitted in cases like "foo/../bar".
&gt; &gt;   Relative symlinks are still allowed (as long as they don't escape the
&gt; &gt;   starting point).
&gt; 
&gt; As I said on the other thread, I would strongly prefer an API that
&gt; behaves along the lines of David Drysdale's old patch
&gt; <a href="https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/">https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/</a>
&gt; : Forbid any use of "..". This would also be more straightforward to
&gt; implement safely. If that doesn't work for you, I would like it if you
&gt; could at least make that an option. I would like it if this API could
&gt; mitigate straightforward directory traversal bugs such as
&gt; <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1583">https://bugs.chromium.org/p/project-zero/issues/detail?id=1583</a>, where
&gt; a confused deputy attempts to access a path like
&gt; "/mnt/media_rw/../../data" while intending to access a directory under
&gt; "/mnt/media_rw".
</span>
Oh, the semantics for this changed in this patchset, hah. I was still on
vacation so didn't get to look at it before it was sent out. From prior
discussion I remember that the original intention actual was what you
argue for. And the patchset should be as tight as possible. Having
special cases where ".." is allowed just sounds like an invitation for
userspace to get it wrong.
Aleksa, did you have a specific use-case in mind that made you change
this or was it already present in an earlier iteration of the patchset
by someone else?

<span>&gt; 
&gt; &gt; * AT_XDEV: Disallow mount-point crossing (both *down* into one, or *up*
&gt; &gt;   from one). The primary "scoping" use is to blocking resolution that
&gt; &gt;   crosses a bind-mount, which has a similar property to a symlink (in
&gt; &gt;   the way that it allows for escape from the starting-point). Since it
&gt; &gt;   is not possible to differentiate bind-mounts However since
&gt; &gt;   bind-mounting requires privileges (in ways symlinks don't) this has
&gt; &gt;   been split from LOOKUP_BENEATH. The naming is based on "find -xdev"
&gt; &gt;   (though find(1) doesn't walk upwards, the semantics seem obvious).
&gt; &gt;
&gt; &gt; * AT_NO_PROCLINK: Disallows -&gt;get_link "symlink" jumping. This is a very
&gt; &gt;   specific restriction, and it exists because /proc/$pid/fd/...
&gt; &gt;   "symlinks" allow for access outside nd-&gt;root and pose risk to
&gt; &gt;   container runtimes that don't want to be tricked into accessing a host
&gt; &gt;   path (but do want to allow no-funny-business symlink resolution).
&gt; 
&gt; AT_BENEATH has to imply AT_NO_PROCLINK, right? Especially with the
&gt; semantics you picked for AT_BENEATH. With the original O_BENEATH_ONLY
&gt; semantics, it might be okay to not imply AT_NO_PROCLINK...
&gt; 
&gt; &gt; * AT_NO_SYMLINK: Disallows symlink jumping *of any kind*. Implies
&gt; &gt;   AT_NO_PROCLINK (obviously).
&gt; &gt;
&gt; &gt; The AT_NO_*LINK flags return -ELOOP if path resolution would violates
&gt; &gt; their requirement, while the others all return -EXDEV. Currently these
&gt; &gt; are only enabled for the stat(2) family and the openat(2) family (the
&gt; &gt; latter has its own brand of O_* flags with the same semantics). Ideally
&gt; &gt; these flags would be supported by all *at(2) syscalls, but this will
&gt; &gt; require adding flags arguments to many of them (and will be done in a
&gt; &gt; separate patchset).
</span>
<a href="#md260e196a4c724d56ef8025c70584b9967d30d3a" id="ed260e196a4c724d56ef8025c70584b9967d30d3a">^</a> <a href="https://lore.kernel.org/lkml/20181001130038.s5ztphs3pl2zt3ut@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001130038.s5ztphs3pl2zt3ut@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001130038.s5ztphs3pl2zt3ut@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001130038.s5ztphs3pl2zt3ut@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001130038.s5ztphs3pl2zt3ut@brauner.io/t/#u">nested</a>] <a href="#rd260e196a4c724d56ef8025c70584b9967d30d3a">53+ messages in thread</a></pre><hr><pre><a href="#ea484ed4979004d9f23a406cac8f134aa029b1322" id="ma484ed4979004d9f23a406cac8f134aa029b1322">*</a> <b>RE: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-29 10:34 <a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Aleksa Sarai
                   ` <a href="#rd2ecb7fd499b6542bec872079f27680e1f28a304">(6 preceding siblings ...)</a>
  2018-10-01  4:08 ` <a href="#md2ecb7fd499b6542bec872079f27680e1f28a304">Dave Chinner</a>
<b>@ 2018-10-01 13:28 ` David Laight</b>
  2018-10-01 16:15   ` <a href="#mf3466ab646463504a28cfdbf74b8d96866715417">Aleksa Sarai</a>
  <a href="#ra484ed4979004d9f23a406cac8f134aa029b1322">7 siblings, 1 reply; 53+ messages in thread</a>
From: David Laight @ 2018-10-01 13:28 UTC (<a href="https://lore.kernel.org/lkml/1f1d699b1c8d472495a5b07199c31a6e@AcuMS.aculab.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/1f1d699b1c8d472495a5b07199c31a6e@AcuMS.aculab.com/raw">raw</a>)
  To: Aleksa Sarai, Jeff Layton, J. Bruce Fields, Al Viro,
	Arnd Bergmann, Shuah Khan
  Cc: David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers

From: Aleksa Sarai
<span>&gt; Sent: 29 September 2018 11:35
&gt; 
&gt; The need for some sort of control over VFS's path resolution (to avoid
&gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt; long-standing desire of many userspace applications. This patchset is a
&gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.
&gt; 
&gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt; which means that each individual property of AT_NO_JUMPS is now a
&gt; separate flag:
&gt; 
&gt;   * Path-based escapes from the starting-point using "/" or ".." are
&gt;     blocked by AT_BENEATH.
</span>
You may need to allow absolute paths that refer to items inside
the controlled area.
(Even if done by a textual replacement based on the expected name
of the base directory.)

<span>&gt;   * Mountpoint crossings are blocked by AT_XDEV.
</span>
You might want a mountpoint flag that allows crossing into the mounted
filesystem (you may need to get out in order to do pwd()).

<span>&gt;   * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt; 	correctly it actually blocks any user of nd_jump_link() because it
&gt; 	allows out-of-VFS path resolution manipulation).
</span>
Or 'fix' the /proc/$pid/fd/$fd code to open the actual vnode rather than
being a symlink (although this might still let you get a directory vnode).
FWIW this is what NetBSD does - you can link the open file back into
the filesystem!

<span>&gt; 
&gt; AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS). At
&gt; Linus' suggestion in the original thread, I've also implemented
&gt; AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
&gt; "proclink" resolution).
</span>
What about allowing 'trivial' symlinks?

...
<span>&gt; Currently I've only enabled these for openat(2) and the stat(2) family.
&gt; I would hope we could enable it for basically every *at(2) syscall --
&gt; but many of them appear to not have a @flags argument and thus we'll
&gt; need to add several new syscalls to do this. I'm more than happy to send
&gt; those patches, but I'd prefer to know that this preliminary work is
&gt; acceptable before doing a bunch of copy-paste to add new sets of *at(2)
&gt; syscalls.
</span>
If you make the flags a property of the directory vnode (perhaps as
well as any syscall flags), and make it inherited by vnode lookup then
it can be used to stop library functions (or entire binaries) using
blocked paths.
You'd then only need to add an fcntl() call to set the flags (but never
clear them) to get the restriction applied to every lookup.
...

	David

-
Registered Address Lakeside, Bramley Road, Mount Farm, Milton Keynes, MK1 1PT, UK
Registration No: 1397386 (Wales)


<a href="#ma484ed4979004d9f23a406cac8f134aa029b1322" id="ea484ed4979004d9f23a406cac8f134aa029b1322">^</a> <a href="https://lore.kernel.org/lkml/1f1d699b1c8d472495a5b07199c31a6e@AcuMS.aculab.com/">permalink</a> <a href="https://lore.kernel.org/lkml/1f1d699b1c8d472495a5b07199c31a6e@AcuMS.aculab.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/1f1d699b1c8d472495a5b07199c31a6e@AcuMS.aculab.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/1f1d699b1c8d472495a5b07199c31a6e@AcuMS.aculab.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/1f1d699b1c8d472495a5b07199c31a6e@AcuMS.aculab.com/t/#u">nested</a>] <a href="#ra484ed4979004d9f23a406cac8f134aa029b1322">53+ messages in thread</a></pre><hr><pre><a href="#ea82a25fbd4af29c4ea56cff51c5aaf74ada5b785" id="ma82a25fbd4af29c4ea56cff51c5aaf74ada5b785">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-01  5:44     ` <a href="#mbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">Aleksa Sarai</a>
  2018-10-01 10:13       ` <a href="#mfc968a7da9d5629a298a520b5ea1b852a73ab01a">Jann Horn</a>
  2018-10-01 10:42       ` <a href="#m1b782ac97737b5e7b08cbd17245d59b61dc647d6">Christian Brauner</a>
<b>@ 2018-10-01 13:55       ` Bruce Fields</b>
  2018-10-01 14:28       ` <a href="#m3b93afe618d6a330d4d98444dabad9e268b0e1bc">Andy Lutomirski</a>
  <a href="#ra82a25fbd4af29c4ea56cff51c5aaf74ada5b785">3 siblings, 0 replies; 53+ messages in thread</a>
From: Bruce Fields @ 2018-10-01 13:55 UTC (<a href="https://lore.kernel.org/lkml/20181001135558.GB25003@fieldses.org/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001135558.GB25003@fieldses.org/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jann Horn, Eric W. Biederman, jlayton, Al Viro, Arnd Bergmann,
	shuah, David Howells, Andy Lutomirski, christian, Tycho Andersen,
	kernel list, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers, Linux API

On Mon, Oct 01, 2018 at 03:44:28PM +1000, Aleksa Sarai wrote:
<span>&gt; On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; The problem is what happens if a folder you are walking through is
&gt; &gt; concurrently moved out of the chroot. Consider the following scenario:
&gt; &gt; 
&gt; &gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; &gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; &gt; the following:
&gt; &gt; 
&gt; &gt; 1. You start the path walk and reach /A/B/C.
&gt; &gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; &gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; &gt; the process root, but you never actually encountered the process root,
&gt; &gt; so you don't notice.
&gt; &gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; &gt; outside the process root, but you don't notice.
&gt; &gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; &gt; successfully. You now have an fd pointing outside your chroot.
&gt; &gt; 
&gt; &gt; If the root of your walk is below an attacker-controlled directory,
&gt; &gt; this of course means that you lose instantly. If you point the root of
&gt; &gt; the walk at a directory out of which a process in the container
&gt; &gt; wouldn't be able to move the file, you're probably kinda mostly fine -
&gt; &gt; as long as you know, for certain, that nothing else on the system
&gt; &gt; would ever do that. But I still wouldn't feel good about that.
&gt; 
&gt; Please correct me if I'm wrong here (this is the first patch I've
&gt; written for VFS). Isn't the retry/LOOKUP_REVAL code meant to handle this
</span>
No.

...
<span>&gt; Speaking naively, doesn't it make sense to invalidate the walk if a path
&gt; component was modified? Or is this something that would be far too
&gt; costly with little benefit?
</span>
Lookups and renames can definitely proceed in parallel, and yes I
suspect it would be difficult to get good performance and guaranteed
forward progress if you required lookup of the full path to be atomic
with respect to renames.

--b.

<a href="#ma82a25fbd4af29c4ea56cff51c5aaf74ada5b785" id="ea82a25fbd4af29c4ea56cff51c5aaf74ada5b785">^</a> <a href="https://lore.kernel.org/lkml/20181001135558.GB25003@fieldses.org/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001135558.GB25003@fieldses.org/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001135558.GB25003@fieldses.org/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001135558.GB25003@fieldses.org/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001135558.GB25003@fieldses.org/t/#u">nested</a>] <a href="#ra82a25fbd4af29c4ea56cff51c5aaf74ada5b785">53+ messages in thread</a></pre><hr><pre><a href="#ed4dd13f53e4b9d8535513d1aed0b121a8d5cfc51" id="md4dd13f53e4b9d8535513d1aed0b121a8d5cfc51">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-09-29 16:35   ` <a href="#m85db30139fa0747cca01a4a7b71ba3f88ab3207c">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Jann Horn
  2018-09-29 17:25     ` <a href="#m55dcd0750c094ebe0bc62c39c395b0163bb41bf2">Andy Lutomirski</a>
  2018-10-01  5:44     ` <a href="#mbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">Aleksa Sarai</a>
<b>@ 2018-10-01 14:00     ` Christian Brauner</b>
  2018-10-04 16:26     ` <a href="#m1363e6020e3fcd93078ba4165aac2ccfb07ef4a5">Aleksa Sarai</a>
  <a href="#rd4dd13f53e4b9d8535513d1aed0b121a8d5cfc51">3 siblings, 0 replies; 53+ messages in thread</a>
From: Christian Brauner @ 2018-10-01 14:00 UTC (<a href="https://lore.kernel.org/lkml/20181001140008.q6jupeylvfld2zpy@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001140008.q6jupeylvfld2zpy@brauner.io/raw">raw</a>)
  To: Jann Horn
  Cc: cyphar, Eric W. Biederman, jlayton, Bruce Fields, Al Viro,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API

On Sat, Sep 29, 2018 at 06:35:17PM +0200, Jann Horn wrote:
<span>&gt; +cc linux-api; please keep them in CC for future versions of the patch
&gt; 
&gt; On Sat, Sep 29, 2018 at 4:29 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt; &gt; The primary motivation for the need for this flag is container runtimes
&gt; &gt; which have to interact with malicious root filesystems in the host
&gt; &gt; namespaces. One of the first requirements for a container runtime to be
&gt; &gt; secure against a malicious rootfs is that they correctly scope symlinks
&gt; &gt; (that is, they should be scoped as though they are chroot(2)ed into the
&gt; &gt; container's rootfs) and ".."-style paths. The already-existing AT_XDEV
&gt; &gt; and AT_NO_PROCLINKS help defend against other potential attacks in a
&gt; &gt; malicious rootfs scenario.
&gt; 
&gt; So, I really like the concept for patch 1 of this series (but haven't
&gt; read the code yet); but I dislike this patch because of its footgun
&gt; potential.
&gt; 
&gt; If this patch landed as-is, the manpage would need some big warning
&gt; labels. chroot() basically provides no security guarantees at all; and
&gt; yes, that includes that if you do `chroot(...); chdir("/");
&gt; open(attacker_controlled_path, ...);`, you can potentially end up
&gt; opening a file outside the chroot. See
&gt; <a href="https://github.com/QubesOS/qubes-secpack/blob/master/QSBs/qsb-014-2015.txt">https://github.com/QubesOS/qubes-secpack/blob/master/QSBs/qsb-014-2015.txt</a>
&gt; for an example, where Qubes OS did pretty much that, and ended up with
&gt; a potentially exploitable security bug because of that, where one VM,
&gt; while performing a file transfer into another VM, could write outside
&gt; of the transfer target directory.
&gt; The problem is what happens if a folder you are walking through is
&gt; concurrently moved out of the chroot. Consider the following scenario:
&gt; 
&gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; the following:
&gt; 
&gt; 1. You start the path walk and reach /A/B/C.
&gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; the process root, but you never actually encountered the process root,
&gt; so you don't notice.
&gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; outside the process root, but you don't notice.
&gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; successfully. You now have an fd pointing outside your chroot.
&gt; 
&gt; If the root of your walk is below an attacker-controlled directory,
&gt; this of course means that you lose instantly. If you point the root of
&gt; the walk at a directory out of which a process in the container
&gt; wouldn't be able to move the file, you're probably kinda mostly fine -
&gt; as long as you know, for certain, that nothing else on the system
&gt; would ever do that. But I still wouldn't feel good about that.
&gt; 
&gt; (Yes, this means that if you run an SFTP server with OpenSSH's
&gt; ChrootDirectory directive, you have to be very careful about these
&gt; things.)
&gt; 
&gt; I believe that the only way to robustly use this would be to point the
&gt; dirfd at a mount point, such that you know that being moved out of the
&gt; chroot is impossible because the mount point limits movement of
&gt; directories under it. (Well, technically, it doesn't, but it ensures
&gt; that if a directory does dangerously move away, the syscall fails.) It
&gt; might make sense to hardcode this constraint in the implementation of
&gt; AT_THIS_ROOT, to keep people from shooting themselves in the foot.
</span>
I'm very much in favor of dropping AT_THIS_ROOT from this patch series
at least for now and only land the first patch. The first patch is
something that we really want and that it seems we can find a good
design for.
If AT_THIS_ROOT is a feature that still makes sense we can revisit it.

<span>&gt; 
&gt; &gt; Currently most container runtimes try to do this resolution in
&gt; &gt; userspace[1], causing many potential race conditions. In addition, the
&gt; &gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; &gt; requires a fork+exec which is *very* costly if necessary for every
&gt; &gt; filesystem operation involving a container.
&gt; 
&gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt; a full fork() either, clone() lets you do this with some process parts
&gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt; wouldn't you want to use setns()? I think something like this should
&gt; work (except that you should add some error handling - omitted here
&gt; because I'm lazy), assuming that the container runtime does NOT have
&gt; CAP_SYS_ADMIN in the init namespace (otherwise it's easier). Of
&gt; course, this is entirely untested, and probably won't compile because
&gt; I screwed something up. :P But you should get the idea...
&gt; 
&gt; // Ensure that we are non-dumpable. Together with
&gt; // commit bfedb589252c, this ensures that container root
&gt; // can't trace our child once it enters the container.
&gt; // My patch
&gt; // <a href="https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/">https://lore.kernel.org/lkml/1451098351-8917-1-git-send-email-jann@thejh.net/</a>
&gt; // would make this unnecessary, but that patch didn't
&gt; // land because Eric nacked it (for political reasons,
&gt; // because people incorrectly claimed that this was a
&gt; // security fix):
&gt; // <a href="https://lore.kernel.org/lkml/8760z7fope.fsf@x220.int.ebiederm.org/">https://lore.kernel.org/lkml/8760z7fope.fsf@x220.int.ebiederm.org/</a>
&gt; // Note that dumpability is per-mm, not per-process,
&gt; // so this hack has the unfortunate side effect of preventing
&gt; // unprivileged debugging of the container runtime.
&gt; // Oh well.
&gt; prctl(PR_SET_DUMPABLE, SUID_DUMP_DISABLE);
&gt; // Inform gcc that this particular syscall will effectively
&gt; // return twice, just like vfork() or setjmp().
&gt; __attribute__((returns_twice)) long syscall_(long sysno, ...) = (void*)syscall;
&gt; int result_fd = -1;
&gt; // CLONE_FILES means we don't need to do fd passing,
&gt; //     we share the file descriptor table.
&gt; // CLONE_VM means we don't have the cost of duplicating
&gt; //     our VMAs and page tables, and we don't have to mark
&gt; //     all our pagetable entries as readonly for copy-on-write.
&gt; // CLONE_VFORK is a dirty hack to avoid having to
&gt; //     allocate a child stack.
&gt; // Lack of SIGCHLD means we don't want to have to wait()
&gt; //     for the child.
&gt; int child_pid = syscall_(__NR_clone, CLONE_FILES|CLONE_VM|CLONE_VFORK,
&gt; 0, 0, 0, 0);
&gt; if (child_pid == 0) {
&gt;   // Enter the container's user namespace; this allows us
&gt;   // to afterwards join its mount namespace even if we're
&gt;   // not capable in the init namespace.
&gt;   // (I believe that it should be possible to change the kernel
&gt;   // such that this is not required if you have set the
&gt;   // no-new-privs flag.)
&gt;   setns(container_user_ns_fd, CLONE_NEWUSER);
&gt;   // Entering the filesystem namespace automatically
&gt;   // moves us to that namespace's filesystem root.
&gt;   setns(container_fs_ns_fd, CLONE_NEWNS);
&gt;   result_fd = open(untrusted_container_path, ...);
&gt;   syscall(__NR_exit, 0);
&gt; }
&gt; 
&gt; &gt; The most significant change in semantics with AT_THIS_ROOT is that
&gt; &gt; *at(2) syscalls now no longer have the property that an absolute
&gt; &gt; pathname causes the dirfd to be ignored completely (if LOOKUP_CHROOT is
&gt; &gt; specified). The reasoning behind this is that AT_THIS_ROOT necessarily
&gt; &gt; has to chroot-scope symlinks with absolute paths to dirfd, and so doing
&gt; &gt; it for the base path seems to be the most consistent behaviour (and also
&gt; &gt; avoids foot-gunning users who want to chroot-scope paths that might be
&gt; &gt; absolute).
&gt; &gt;
&gt; &gt; Currently this is only enabled for the stat(2) and openat(2) family (the
&gt; &gt; latter has its own flag O_THISROOT with the same semantics). Ideally
&gt; &gt; this flag would be supported by all *at(2) syscalls, but this will
&gt; &gt; require adding flags arguments to many of them (and will be done in a
&gt; &gt; separate patchset).
&gt; &gt;
&gt; &gt; [1]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>
&gt; &gt;
&gt; &gt; Cc: Eric Biederman &lt;ebiederm@xmission.com&gt;
&gt; &gt; Cc: Christian Brauner &lt;christian@brauner.io&gt;
&gt; &gt; Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
&gt; &gt; ---
&gt; &gt;  fs/fcntl.c                       |   2 +-
&gt; &gt;  fs/namei.c                       | 121 +++++++++++++++++--------------
&gt; &gt;  fs/open.c                        |   2 +
&gt; &gt;  fs/stat.c                        |   4 +-
&gt; &gt;  include/linux/fcntl.h            |   2 +-
&gt; &gt;  include/linux/namei.h            |   1 +
&gt; &gt;  include/uapi/asm-generic/fcntl.h |   3 +
&gt; &gt;  include/uapi/linux/fcntl.h       |   2 +
&gt; &gt;  8 files changed, 81 insertions(+), 56 deletions(-)
&gt; &gt;
&gt; &gt; diff --git a/fs/fcntl.c b/fs/fcntl.c
&gt; &gt; index e343618736f7..4c36c5b9fdb9 100644
&gt; &gt; --- a/fs/fcntl.c
&gt; &gt; +++ b/fs/fcntl.c
&gt; &gt; @@ -1031,7 +1031,7 @@ static int __init fcntl_init(void)
&gt; &gt;          * Exceptions: O_NONBLOCK is a two bit define on parisc; O_NDELAY
&gt; &gt;          * is defined as O_NONBLOCK on some platforms and not on others.
&gt; &gt;          */
&gt; &gt; -       BUILD_BUG_ON(25 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt; +       BUILD_BUG_ON(26 - 1 /* for O_RDONLY being 0 */ !=
&gt; &gt;                 HWEIGHT32(
&gt; &gt;                         (VALID_OPEN_FLAGS &amp; ~(O_NONBLOCK | O_NDELAY)) |
&gt; &gt;                         __FMODE_EXEC | __FMODE_NONOTIFY));
&gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; index 757dd783771c..1b984f0dbbb4 100644
&gt; &gt; --- a/fs/namei.c
&gt; &gt; +++ b/fs/namei.c
&gt; &gt; @@ -2193,9 +2193,64 @@ static int link_path_walk(const char *name, struct nameidata *nd)
&gt; &gt;         }
&gt; &gt;  }
&gt; &gt;
&gt; &gt; +/*
&gt; &gt; + * Configure nd-&gt;path based on the nd-&gt;dfd. This is only used as part of
&gt; &gt; + * path_init().
&gt; &gt; + */
&gt; &gt; +static inline int dirfd_path_init(struct nameidata *nd)
&gt; &gt; +{
&gt; &gt; +       if (nd-&gt;dfd == AT_FDCWD) {
&gt; &gt; +               if (nd-&gt;flags &amp; LOOKUP_RCU) {
&gt; &gt; +                       struct fs_struct *fs = current-&gt;fs;
&gt; &gt; +                       unsigned seq;
&gt; &gt; +
&gt; &gt; +                       do {
&gt; &gt; +                               seq = read_seqcount_begin(&amp;fs-&gt;seq);
&gt; &gt; +                               nd-&gt;path = fs-&gt;pwd;
&gt; &gt; +                               nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; &gt; +                               nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
&gt; &gt; +                       } while (read_seqcount_retry(&amp;fs-&gt;seq, seq));
&gt; &gt; +               } else {
&gt; &gt; +                       get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path);
&gt; &gt; +                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; &gt; +               }
&gt; &gt; +       } else {
&gt; &gt; +               /* Caller must check execute permissions on the starting path component */
&gt; &gt; +               struct fd f = fdget_raw(nd-&gt;dfd);
&gt; &gt; +               struct dentry *dentry;
&gt; &gt; +
&gt; &gt; +               if (!f.file)
&gt; &gt; +                       return -EBADF;
&gt; &gt; +
&gt; &gt; +               dentry = f.file-&gt;f_path.dentry;
&gt; &gt; +
&gt; &gt; +               if (*nd-&gt;name-&gt;name &amp;&amp; unlikely(!d_can_lookup(dentry))) {
&gt; &gt; +                       fdput(f);
&gt; &gt; +                       return -ENOTDIR;
&gt; &gt; +               }
&gt; &gt; +
&gt; &gt; +               nd-&gt;path = f.file-&gt;f_path;
&gt; &gt; +               if (nd-&gt;flags &amp; LOOKUP_RCU) {
&gt; &gt; +                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; &gt; +                       nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
&gt; &gt; +               } else {
&gt; &gt; +                       path_get(&amp;nd-&gt;path);
&gt; &gt; +                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; &gt; +               }
&gt; &gt; +               fdput(f);
&gt; &gt; +       }
&gt; &gt; +       if (unlikely(nd-&gt;flags &amp; (LOOKUP_CHROOT | LOOKUP_BENEATH))) {
&gt; &gt; +               nd-&gt;root = nd-&gt;path;
&gt; &gt; +               if (!(nd-&gt;flags &amp; LOOKUP_RCU))
&gt; &gt; +                       path_get(&amp;nd-&gt;root);
&gt; &gt; +       }
&gt; &gt; +       return 0;
&gt; &gt; +}
&gt; &gt; +
&gt; &gt;  /* must be paired with terminate_walk() */
&gt; &gt;  static const char *path_init(struct nameidata *nd, unsigned flags)
&gt; &gt;  {
&gt; &gt; +       int error;
&gt; &gt;         const char *s = nd-&gt;name-&gt;name;
&gt; &gt;
&gt; &gt;         if (!*s)
&gt; &gt; @@ -2230,65 +2285,25 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
&gt; &gt;         nd-&gt;path.dentry = NULL;
&gt; &gt;
&gt; &gt;         nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
&gt; &gt; +       if (unlikely(flags &amp; LOOKUP_CHROOT)) {
&gt; &gt; +               error = dirfd_path_init(nd);
&gt; &gt; +               if (unlikely(error))
&gt; &gt; +                       return ERR_PTR(error);
&gt; &gt; +       }
&gt; &gt;         if (*s == '/') {
&gt; &gt; -               int error;
&gt; &gt; -               set_root(nd);
&gt; &gt; +               if (likely(!nd-&gt;root.mnt))
&gt; &gt; +                       set_root(nd);
&gt; &gt;                 error = nd_jump_root(nd);
&gt; &gt;                 if (unlikely(error))
&gt; &gt;                         s = ERR_PTR(error);
&gt; &gt;                 return s;
&gt; &gt; -       } else if (nd-&gt;dfd == AT_FDCWD) {
&gt; &gt; -               if (flags &amp; LOOKUP_RCU) {
&gt; &gt; -                       struct fs_struct *fs = current-&gt;fs;
&gt; &gt; -                       unsigned seq;
&gt; &gt; -
&gt; &gt; -                       do {
&gt; &gt; -                               seq = read_seqcount_begin(&amp;fs-&gt;seq);
&gt; &gt; -                               nd-&gt;path = fs-&gt;pwd;
&gt; &gt; -                               nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; &gt; -                               nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
&gt; &gt; -                       } while (read_seqcount_retry(&amp;fs-&gt;seq, seq));
&gt; &gt; -               } else {
&gt; &gt; -                       get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path);
&gt; &gt; -                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; &gt; -               }
&gt; &gt; -               if (unlikely(flags &amp; LOOKUP_BENEATH)) {
&gt; &gt; -                       nd-&gt;root = nd-&gt;path;
&gt; &gt; -                       if (!(flags &amp; LOOKUP_RCU))
&gt; &gt; -                               path_get(&amp;nd-&gt;root);
&gt; &gt; -               }
&gt; &gt; -               return s;
&gt; &gt; -       } else {
&gt; &gt; -               /* Caller must check execute permissions on the starting path component */
&gt; &gt; -               struct fd f = fdget_raw(nd-&gt;dfd);
&gt; &gt; -               struct dentry *dentry;
&gt; &gt; -
&gt; &gt; -               if (!f.file)
&gt; &gt; -                       return ERR_PTR(-EBADF);
&gt; &gt; -
&gt; &gt; -               dentry = f.file-&gt;f_path.dentry;
&gt; &gt; -
&gt; &gt; -               if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) {
&gt; &gt; -                       fdput(f);
&gt; &gt; -                       return ERR_PTR(-ENOTDIR);
&gt; &gt; -               }
&gt; &gt; -
&gt; &gt; -               nd-&gt;path = f.file-&gt;f_path;
&gt; &gt; -               if (flags &amp; LOOKUP_RCU) {
&gt; &gt; -                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; &gt; -                       nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
&gt; &gt; -               } else {
&gt; &gt; -                       path_get(&amp;nd-&gt;path);
&gt; &gt; -                       nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
&gt; &gt; -               }
&gt; &gt; -               if (unlikely(flags &amp; LOOKUP_BENEATH)) {
&gt; &gt; -                       nd-&gt;root = nd-&gt;path;
&gt; &gt; -                       if (!(flags &amp; LOOKUP_RCU))
&gt; &gt; -                               path_get(&amp;nd-&gt;root);
&gt; &gt; -               }
&gt; &gt; -               fdput(f);
&gt; &gt; -               return s;
&gt; &gt;         }
&gt; &gt; +       if (likely(!nd-&gt;path.mnt)) {
&gt; &gt; +               error = dirfd_path_init(nd);
&gt; &gt; +               if (unlikely(error))
&gt; &gt; +                       return ERR_PTR(error);
&gt; &gt; +       }
&gt; &gt; +       return s;
&gt; &gt;  }
&gt; &gt;
&gt; &gt;  static const char *trailing_symlink(struct nameidata *nd)
&gt; &gt; diff --git a/fs/open.c b/fs/open.c
&gt; &gt; index 80f5f566a5ff..81d148f626cd 100644
&gt; &gt; --- a/fs/open.c
&gt; &gt; +++ b/fs/open.c
&gt; &gt; @@ -996,6 +996,8 @@ static inline int build_open_flags(int flags, umode_t mode, struct open_flags *o
&gt; &gt;                 lookup_flags |= LOOKUP_NO_PROCLINKS;
&gt; &gt;         if (flags &amp; O_NOSYMLINKS)
&gt; &gt;                 lookup_flags |= LOOKUP_NO_SYMLINKS;
&gt; &gt; +       if (flags &amp; O_THISROOT)
&gt; &gt; +               lookup_flags |= LOOKUP_CHROOT;
&gt; &gt;         op-&gt;lookup_flags = lookup_flags;
&gt; &gt;         return 0;
&gt; &gt;  }
&gt; &gt; diff --git a/fs/stat.c b/fs/stat.c
&gt; &gt; index 791e61b916ae..e8366e4812c3 100644
&gt; &gt; --- a/fs/stat.c
&gt; &gt; +++ b/fs/stat.c
&gt; &gt; @@ -172,7 +172,7 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
&gt; &gt;
&gt; &gt;         if (flags &amp; ~(AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT | AT_EMPTY_PATH |
&gt; &gt;                       KSTAT_QUERY_FLAGS | AT_BENEATH | AT_XDEV |
&gt; &gt; -                     AT_NO_PROCLINKS | AT_NO_SYMLINKS))
&gt; &gt; +                     AT_NO_PROCLINKS | AT_NO_SYMLINKS | AT_THIS_ROOT))
&gt; &gt;                 return -EINVAL;
&gt; &gt;
&gt; &gt;         if (flags &amp; AT_SYMLINK_NOFOLLOW)
&gt; &gt; @@ -189,6 +189,8 @@ int vfs_statx(int dfd, const char __user *filename, int flags,
&gt; &gt;                 lookup_flags |= LOOKUP_NO_PROCLINKS;
&gt; &gt;         if (flags &amp; AT_NO_SYMLINKS)
&gt; &gt;                 lookup_flags |= LOOKUP_NO_SYMLINKS;
&gt; &gt; +       if (flags &amp; AT_THIS_ROOT)
&gt; &gt; +               lookup_flags |= LOOKUP_CHROOT;
&gt; &gt;
&gt; &gt;  retry:
&gt; &gt;         error = user_path_at(dfd, filename, lookup_flags, &amp;path);
&gt; &gt; diff --git a/include/linux/fcntl.h b/include/linux/fcntl.h
&gt; &gt; index ad5bba4b5b12..95480cd4c09d 100644
&gt; &gt; --- a/include/linux/fcntl.h
&gt; &gt; +++ b/include/linux/fcntl.h
&gt; &gt; @@ -10,7 +10,7 @@
&gt; &gt;          O_APPEND | O_NDELAY | O_NONBLOCK | O_NDELAY | __O_SYNC | O_DSYNC | \
&gt; &gt;          FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
&gt; &gt;          O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE | O_BENEATH | O_XDEV | \
&gt; &gt; -        O_NOPROCLINKS | O_NOSYMLINKS)
&gt; &gt; +        O_NOPROCLINKS | O_NOSYMLINKS | O_THISROOT)
&gt; &gt;
&gt; &gt;  #ifndef force_o_largefile
&gt; &gt;  #define force_o_largefile() (BITS_PER_LONG != 32)
&gt; &gt; diff --git a/include/linux/namei.h b/include/linux/namei.h
&gt; &gt; index 5ff7f3362d1b..7ec9e2d84649 100644
&gt; &gt; --- a/include/linux/namei.h
&gt; &gt; +++ b/include/linux/namei.h
&gt; &gt; @@ -53,6 +53,7 @@ enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};
&gt; &gt;  #define LOOKUP_NO_PROCLINKS    0x040000 /* No /proc/$pid/fd/ "symlink" crossing. */
&gt; &gt;  #define LOOKUP_NO_SYMLINKS     0x080000 /* No symlink crossing *at all*.
&gt; &gt;                                             Implies LOOKUP_NO_PROCLINKS. */
&gt; &gt; +#define LOOKUP_CHROOT          0x100000 /* Treat dirfd as %current-&gt;fs-&gt;root. */
&gt; &gt;
&gt; &gt;  extern int path_pts(struct path *path);
&gt; &gt;
&gt; &gt; diff --git a/include/uapi/asm-generic/fcntl.h b/include/uapi/asm-generic/fcntl.h
&gt; &gt; index c2bf5983e46a..11206b0e927c 100644
&gt; &gt; --- a/include/uapi/asm-generic/fcntl.h
&gt; &gt; +++ b/include/uapi/asm-generic/fcntl.h
&gt; &gt; @@ -113,6 +113,9 @@
&gt; &gt;  #ifndef O_NOSYMLINKS
&gt; &gt;  #define O_NOSYMLINKS   01000000000
&gt; &gt;  #endif
&gt; &gt; +#ifndef O_THISROOT
&gt; &gt; +#define O_THISROOT     02000000000
&gt; &gt; +#endif
&gt; &gt;
&gt; &gt;  #define F_DUPFD                0       /* dup */
&gt; &gt;  #define F_GETFD                1       /* get close_on_exec */
&gt; &gt; diff --git a/include/uapi/linux/fcntl.h b/include/uapi/linux/fcntl.h
&gt; &gt; index 551a9e2166a8..ea978457b68f 100644
&gt; &gt; --- a/include/uapi/linux/fcntl.h
&gt; &gt; +++ b/include/uapi/linux/fcntl.h
&gt; &gt; @@ -99,6 +99,8 @@
&gt; &gt;  #define AT_NO_PROCLINKS                0x40000 /* No /proc/$pid/fd/... "symlinks". */
&gt; &gt;  #define AT_NO_SYMLINKS         0x80000 /* No symlinks *at all*.
&gt; &gt;                                            Implies AT_NO_PROCLINKS. */
&gt; &gt; +#define AT_THIS_ROOT           0x100000 /* Path resolution acts as though
&gt; &gt; +                                          it is chroot-ed into dirfd. */
&gt; &gt;
&gt; &gt;
&gt; &gt;  #endif /* _UAPI_LINUX_FCNTL_H */
&gt; &gt; --
&gt; &gt; 2.19.0
&gt; &gt;
&gt; &gt;
</span>
<a href="#md4dd13f53e4b9d8535513d1aed0b121a8d5cfc51" id="ed4dd13f53e4b9d8535513d1aed0b121a8d5cfc51">^</a> <a href="https://lore.kernel.org/lkml/20181001140008.q6jupeylvfld2zpy@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001140008.q6jupeylvfld2zpy@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001140008.q6jupeylvfld2zpy@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001140008.q6jupeylvfld2zpy@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001140008.q6jupeylvfld2zpy@brauner.io/t/#u">nested</a>] <a href="#rd4dd13f53e4b9d8535513d1aed0b121a8d5cfc51">53+ messages in thread</a></pre><hr><pre><a href="#e3b93afe618d6a330d4d98444dabad9e268b0e1bc" id="m3b93afe618d6a330d4d98444dabad9e268b0e1bc">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-01  5:44     ` <a href="#mbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">Aleksa Sarai</a>
                         ` <a href="#ra82a25fbd4af29c4ea56cff51c5aaf74ada5b785">(2 preceding siblings ...)</a>
  2018-10-01 13:55       ` <a href="#ma82a25fbd4af29c4ea56cff51c5aaf74ada5b785">Bruce Fields</a>
<b>@ 2018-10-01 14:28       ` Andy Lutomirski</b>
  2018-10-02  7:32         ` <a href="#m304562dd58656fd5ce4cf51430201c473d7baa4f">Aleksa Sarai</a>
  <a href="#r3b93afe618d6a330d4d98444dabad9e268b0e1bc">3 siblings, 1 reply; 53+ messages in thread</a>
From: Andy Lutomirski @ 2018-10-01 14:28 UTC (<a href="https://lore.kernel.org/lkml/C89D720F-3CC4-4FA9-9CBB-E41A67360A6B@amacapital.net/">permalink</a> / <a href="https://lore.kernel.org/lkml/C89D720F-3CC4-4FA9-9CBB-E41A67360A6B@amacapital.net/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jann Horn, Eric W. Biederman, jlayton, Bruce Fields, Al Viro,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski, christian,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API


<span>&gt;&gt;&gt; Currently most container runtimes try to do this resolution in
&gt;&gt;&gt; userspace[1], causing many potential race conditions. In addition, the
&gt;&gt;&gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt;&gt;&gt; requires a fork+exec which is *very* costly if necessary for every
&gt;&gt;&gt; filesystem operation involving a container.
&gt;&gt; 
&gt;&gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt;&gt; a full fork() either, clone() lets you do this with some process parts
&gt;&gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt;&gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt;&gt; wouldn't you want to use setns()?
&gt; 
&gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; for CLONE_VFORK.
</span>
I must admit that Im not very sympathetic to the argument that Gos runtime model is incompatible with the simpler solution.

Anyway, it occurs to me that the real problem is that setns() and chroot() are both overkill for this use case. Whats needed is to start your walk from /proc/pid-in-container/root, with two twists:

1. Do the walk as though rooted at a directory. This is basically just your AT_THIS_ROOT, but the footgun is avoided because the dirfd you use is from a foreign namespace, and, except for symlinks to absolute paths, no amount of .. racing is going to escape the *namespace*.

2. Avoid /proc. Its not just the *links*  you really dont want to walk into /proc/self. *Maybe* procfs is already careful enough when mounted in a namespace?

<a href="#m3b93afe618d6a330d4d98444dabad9e268b0e1bc" id="e3b93afe618d6a330d4d98444dabad9e268b0e1bc">^</a> <a href="https://lore.kernel.org/lkml/C89D720F-3CC4-4FA9-9CBB-E41A67360A6B@amacapital.net/">permalink</a> <a href="https://lore.kernel.org/lkml/C89D720F-3CC4-4FA9-9CBB-E41A67360A6B@amacapital.net/raw">raw</a> <a href="https://lore.kernel.org/lkml/C89D720F-3CC4-4FA9-9CBB-E41A67360A6B@amacapital.net/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/C89D720F-3CC4-4FA9-9CBB-E41A67360A6B@amacapital.net/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/C89D720F-3CC4-4FA9-9CBB-E41A67360A6B@amacapital.net/t/#u">nested</a>] <a href="#r3b93afe618d6a330d4d98444dabad9e268b0e1bc">53+ messages in thread</a></pre><hr><pre><a href="#e976af4e59482b98696b0e918a77ff53493dfe932" id="m976af4e59482b98696b0e918a77ff53493dfe932">*</a> <b>Re: [PATCH 1/3] namei: implement O_BENEATH-style AT_* flags</b>
  2018-10-01 13:00     ` <a href="#md260e196a4c724d56ef8025c70584b9967d30d3a">Christian Brauner</a>
<b>@ 2018-10-01 16:04       ` Aleksa Sarai</b>
  2018-10-04 17:20         ` <a href="#m805a98d1da56907d6f5b4fb1ffbe2390a20dcbca">Christian Brauner</a>
  <a href="#r976af4e59482b98696b0e918a77ff53493dfe932">0 siblings, 1 reply; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-01 16:04 UTC (<a href="https://lore.kernel.org/lkml/20181001160431.emb6b2hf32b754cl@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001160431.emb6b2hf32b754cl@ryuk/raw">raw</a>)
  To: Christian Brauner
  Cc: Jann Horn, Al Viro, Eric W. Biederman, Andy Lutomirski, jlayton,
	Bruce Fields, Arnd Bergmann, shuah, David Howells,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers

<a href="https://lore.kernel.org/lkml/20181001160431.emb6b2hf32b754cl@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 2409 bytes --]</a>

On 2018-10-01, Christian Brauner &lt;christian@brauner.io&gt; wrote:
<span>&gt; On Mon, Oct 01, 2018 at 02:28:03PM +0200, Jann Horn wrote:
&gt; &gt; On Sat, Sep 29, 2018 at 4:28 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt; &gt; &gt; * AT_BENEATH: Disallow ".." or absolute paths (either in the path or
&gt; &gt; &gt;   found during symlink resolution) to escape the starting point of name
&gt; &gt; &gt;   resolution, though ".." is permitted in cases like "foo/../bar".
&gt; &gt; &gt;   Relative symlinks are still allowed (as long as they don't escape the
&gt; &gt; &gt;   starting point).
&gt; &gt; 
&gt; &gt; As I said on the other thread, I would strongly prefer an API that
&gt; &gt; behaves along the lines of David Drysdale's old patch
&gt; &gt; <a href="https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/">https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/</a>
&gt; &gt; : Forbid any use of "..". This would also be more straightforward to
&gt; &gt; implement safely. If that doesn't work for you, I would like it if you
&gt; &gt; could at least make that an option. I would like it if this API could
&gt; &gt; mitigate straightforward directory traversal bugs such as
&gt; &gt; <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1583">https://bugs.chromium.org/p/project-zero/issues/detail?id=1583</a>, where
&gt; &gt; a confused deputy attempts to access a path like
&gt; &gt; "/mnt/media_rw/../../data" while intending to access a directory under
&gt; &gt; "/mnt/media_rw".
&gt; 
&gt; Oh, the semantics for this changed in this patchset, hah. I was still on
&gt; vacation so didn't get to look at it before it was sent out. From prior
&gt; discussion I remember that the original intention actual was what you
&gt; argue for. And the patchset should be as tight as possible. Having
&gt; special cases where ".." is allowed just sounds like an invitation for
&gt; userspace to get it wrong.
&gt; Aleksa, did you have a specific use-case in mind that made you change
&gt; this or was it already present in an earlier iteration of the patchset
&gt; by someone else?
</span>
Al's original patchset allowed "..". A quick survey of my machine shows
that there are 100k symlinks that contain ".." (~37% of all symlinks on
my machine). This indicates to me that you would be restricting a large
amount of reasonable resolutions because of this restriction.

I posted a proposed way to protect against ".." shenanigans. If it's
turns out this is not possible, I'm okay with disallowing ".." (assuming
Al is also okay with that).

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181001160431.emb6b2hf32b754cl@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#m976af4e59482b98696b0e918a77ff53493dfe932" id="e976af4e59482b98696b0e918a77ff53493dfe932">^</a> <a href="https://lore.kernel.org/lkml/20181001160431.emb6b2hf32b754cl@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001160431.emb6b2hf32b754cl@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001160431.emb6b2hf32b754cl@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001160431.emb6b2hf32b754cl@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001160431.emb6b2hf32b754cl@ryuk/t/#u">nested</a>] <a href="#r976af4e59482b98696b0e918a77ff53493dfe932">53+ messages in thread</a></pre><hr><pre><a href="#ef3466ab646463504a28cfdbf74b8d96866715417" id="mf3466ab646463504a28cfdbf74b8d96866715417">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-10-01 13:28 ` <a href="#ma484ed4979004d9f23a406cac8f134aa029b1322">David Laight</a>
<b>@ 2018-10-01 16:15   ` Aleksa Sarai</b>
  2018-10-03 13:21     ` <a href="#m7e2548354abfae7ff3b3b4e175ac0faa81866045">David Laight</a>
  <a href="#rf3466ab646463504a28cfdbf74b8d96866715417">0 siblings, 1 reply; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-01 16:15 UTC (<a href="https://lore.kernel.org/lkml/20181001161535.3zslyuk6vmnpioy6@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001161535.3zslyuk6vmnpioy6@ryuk/raw">raw</a>)
  To: David Laight
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers

<a href="https://lore.kernel.org/lkml/20181001161535.3zslyuk6vmnpioy6@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 4181 bytes --]</a>

On 2018-10-01, David Laight &lt;David.Laight@ACULAB.COM&gt; wrote:
<span>&gt; &gt; The need for some sort of control over VFS's path resolution (to avoid
&gt; &gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt; &gt; long-standing desire of many userspace applications. This patchset is a
&gt; &gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.
&gt; &gt; 
&gt; &gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt; &gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt; &gt; which means that each individual property of AT_NO_JUMPS is now a
&gt; &gt; separate flag:
&gt; &gt; 
&gt; &gt;   * Path-based escapes from the starting-point using "/" or ".." are
&gt; &gt;     blocked by AT_BENEATH.
&gt; 
&gt; You may need to allow absolute paths that refer to items inside
&gt; the controlled area.
&gt; (Even if done by a textual replacement based on the expected name
&gt; of the base directory.)
</span>
This is sort of what AT_THIS_ROOT does. I didn't want to include it for
AT_BENEATH because it would be just as contentious as AT_THIS_ROOT
currently is. :P

<span>&gt; &gt;   * Mountpoint crossings are blocked by AT_XDEV.
&gt; 
&gt; You might want a mountpoint flag that allows crossing into the mounted
&gt; filesystem (you may need to get out in order to do pwd()).
</span>
Like a mount flag? I'm not sure how I feel about that. The intention is
to allow for a process to have control over how path lookups are
handled, and tying it to a mount flag means that it's no longer entirely
up to the process.

<span>&gt; &gt;   * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt; &gt; 	correctly it actually blocks any user of nd_jump_link() because it
&gt; &gt; 	allows out-of-VFS path resolution manipulation).
&gt; 
&gt; Or 'fix' the /proc/$pid/fd/$fd code to open the actual vnode rather than
&gt; being a symlink (although this might still let you get a directory vnode).
&gt; FWIW this is what NetBSD does - you can link the open file back into
&gt; the filesystem!
</span>
Isn't this how it works currently? The /proc/$pid/fd/$fd "symlinks" are
actually references to the underlying file (they can even escape a
pivot_root()) -- you can re-open them or do any number of other dodgy
things through /proc with them (we definitely abuse this in container
runtimes -- and I'm sure plenty of other people do as well).

<span>&gt; &gt; AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS). At
&gt; &gt; Linus' suggestion in the original thread, I've also implemented
&gt; &gt; AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
&gt; &gt; "proclink" resolution).
&gt; 
&gt; What about allowing 'trivial' symlinks?
</span>
The use-case of AT_NO_SYMLINKS that Linus pitched[1] is that git wants
to have a unique name for every object and so allowing trivial symlinks
is a no-go. I assume "trivial" here means "no-'..' components"?

<span>&gt; &gt; Currently I've only enabled these for openat(2) and the stat(2) family.
&gt; &gt; I would hope we could enable it for basically every *at(2) syscall --
&gt; &gt; but many of them appear to not have a @flags argument and thus we'll
&gt; &gt; need to add several new syscalls to do this. I'm more than happy to send
&gt; &gt; those patches, but I'd prefer to know that this preliminary work is
&gt; &gt; acceptable before doing a bunch of copy-paste to add new sets of *at(2)
&gt; &gt; syscalls.
&gt; 
&gt; If you make the flags a property of the directory vnode (perhaps as
&gt; well as any syscall flags), and make it inherited by vnode lookup then
&gt; it can be used to stop library functions (or entire binaries) using
&gt; blocked paths.
&gt; You'd then only need to add an fcntl() call to set the flags (but never
&gt; clear them) to get the restriction applied to every lookup.
</span>
This seems like it might be useful, but it could always be done as a
follow-up patch by just setting LOOKUP_BLAH if the dirfd has the flag
set. I'm also a little bit concerned that (because fd flags are set on
the 'struct file') if you start sharing fds then you can no longer use
the lookup scoping for security (a racing process could remove the
flags while the management process resolves through it).

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181001161535.3zslyuk6vmnpioy6@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#mf3466ab646463504a28cfdbf74b8d96866715417" id="ef3466ab646463504a28cfdbf74b8d96866715417">^</a> <a href="https://lore.kernel.org/lkml/20181001161535.3zslyuk6vmnpioy6@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001161535.3zslyuk6vmnpioy6@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001161535.3zslyuk6vmnpioy6@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001161535.3zslyuk6vmnpioy6@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001161535.3zslyuk6vmnpioy6@ryuk/t/#u">nested</a>] <a href="#rf3466ab646463504a28cfdbf74b8d96866715417">53+ messages in thread</a></pre><hr><pre><a href="#eadb4f69d46d490beab7f3563227268b15c6ed379" id="madb4f69d46d490beab7f3563227268b15c6ed379">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-01 10:13       ` <a href="#mfc968a7da9d5629a298a520b5ea1b852a73ab01a">Jann Horn</a>
<b>@ 2018-10-01 16:18         ` Aleksa Sarai</b>
  2018-10-04 17:27           ` <a href="#m8fd9ac6f0a3adff4a8c4bb48b08d4a3183f9b343">Christian Brauner</a>
  <a href="#radb4f69d46d490beab7f3563227268b15c6ed379">0 siblings, 1 reply; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-01 16:18 UTC (<a href="https://lore.kernel.org/lkml/20181001161833.sg5iy6gk7n7crcvy@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181001161833.sg5iy6gk7n7crcvy@ryuk/raw">raw</a>)
  To: Jann Horn
  Cc: Eric W. Biederman, Al Viro, jlayton, Bruce Fields, Arnd Bergmann,
	shuah, David Howells, Andy Lutomirski, christian, Tycho Andersen,
	kernel list, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers, Linux API

<a href="https://lore.kernel.org/lkml/20181001161833.sg5iy6gk7n7crcvy@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 3691 bytes --]</a>

On 2018-10-01, Jann Horn &lt;jannh@google.com&gt; wrote:
<span>&gt; &gt; If this is an issue for AT_THIS_ROOT, I believe this might also be an
&gt; &gt; issue for AT_BENEATH since they are effectively both using the same
&gt; &gt; nd-&gt;root trick (so you could similarly trick AT_BENEATH to not error
&gt; &gt; out). So we'd need to figure out how to solve this problem in order for
&gt; &gt; AT_BENEATH to be safe.
&gt; 
&gt; Oh, wait, what? I think I didn't notice that the semantics of
&gt; AT_BENEATH changed like that since the original posting of David
&gt; Drysdale's O_BENEATH_ONLY patch
&gt; (<a href="https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/">https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/</a>).
&gt; David's patch had nice, straightforward semantics, blocking any form
&gt; of upwards traversal. Why was that changed? Does anyone actually want
&gt; to use paths that contain ".." with AT_BENEATH? I would strongly
&gt; prefer something that blocks any use of "..".
&gt; 
&gt; @Al: It looks like this already changed back when you posted
&gt; <a href="https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/">https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/</a>
&gt; ?
</span>
Yes, I copied the semantics from Al's patchset. I don't know why he felt
strongly that this was the best idea, but in my opinion allowing paths
like "a/../b/../c" seems like it's quite useful because otherwise you
wouldn't be able to operate on most distribution root filesystems (many
have symlinks that have ".." components). Looking at my own (openSUSE)
machine there are something like 100k such symlinks (~37% of symlinks on
my machine).

While I do understand that the easiest way of solving this problem is to
disallow ".." entirely with AT_BENEATH, given that support ".." has
utility, I would like to know whether it's actually not possible to have
this work safely.

<span>&gt; &gt; Speaking naively, doesn't it make sense to invalidate the walk if a path
&gt; &gt; component was modified? Or is this something that would be far too
&gt; &gt; costly with little benefit? What if we do more aggressive nd-&gt;root
&gt; &gt; checks when resolving with AT_BENEATH or AT_THIS_ROOT (or if nd-&gt;root !=
&gt; &gt; current-&gt;mnt_ns-&gt;root)?
&gt; 
&gt; It seems to me like doing that would basically require looking at each
&gt; node in the path walk twice? And it'd be difficult to guarantee
&gt; forward progress unless you're willing to do some fairly heavy
&gt; locking.
</span>
I had another idea since I wrote my previous mail -- since the issue (at
least the way I understand it) is that ".." can "skip" over nd-&gt;root
because of the rename, what if we had some sort of is_descendant() check
within follow_dotdot()? (FWIW, ".." already has some pretty interesting
"hand-over-hand" locking semantics.) This should be effectively similar
to how prepend_path() deals with a path that is not reachable from @root
(I'm not sure if the locking is acceptable for the namei path though).

Since ".." with AT_THIS_ROOT (or AT_BENEATH) is not going to be the most
common component type (and we only need to do these checks for those
flags), I would think that the extra cost would not be _that_ awful.

Would this work?

<span>&gt; &gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; &gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; &gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; &gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; &gt; for CLONE_VFORK.
&gt; 
&gt; If you insist on implementing every last bit of your code in Go, I guess.
</span>
Fair enough, though I believe this would affect most multi-threaded
programs as well (regardless of the language they're written in).

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181001161833.sg5iy6gk7n7crcvy@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#madb4f69d46d490beab7f3563227268b15c6ed379" id="eadb4f69d46d490beab7f3563227268b15c6ed379">^</a> <a href="https://lore.kernel.org/lkml/20181001161833.sg5iy6gk7n7crcvy@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181001161833.sg5iy6gk7n7crcvy@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181001161833.sg5iy6gk7n7crcvy@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181001161833.sg5iy6gk7n7crcvy@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181001161833.sg5iy6gk7n7crcvy@ryuk/t/#u">nested</a>] <a href="#radb4f69d46d490beab7f3563227268b15c6ed379">53+ messages in thread</a></pre><hr><pre><a href="#e440b5bdeba29f11233cdb944b183af4d6c48fb1f" id="m440b5bdeba29f11233cdb944b183af4d6c48fb1f">*</a> <b>Re: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-09-30 22:37     ` <a href="#m6f6dac21d23ad55bf619634955f15a52e93874d6">Mickal Salan</a>
<b>@ 2018-10-01 20:14       ` James Morris</b>
  <a href="#r440b5bdeba29f11233cdb944b183af4d6c48fb1f">0 siblings, 0 replies; 53+ messages in thread</a>
From: James Morris @ 2018-10-01 20:14 UTC (<a href="https://lore.kernel.org/lkml/alpine.LRH.2.21.1810020610290.14406@namei.org/">permalink</a> / <a href="https://lore.kernel.org/lkml/alpine.LRH.2.21.1810020610290.14406@namei.org/raw">raw</a>)
  To: Mickal Salan
  Cc: Jann Horn, cyphar, jlayton, Bruce Fields, Al Viro, Arnd Bergmann,
	shuah, David Howells, Andy Lutomirski, christian,
	Eric W. Biederman, Tycho Andersen, kernel list, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers,
	linux-security-module, Kees Cook, Linux API

<a href="https://lore.kernel.org/lkml/alpine.LRH.2.21.1810020610290.14406@namei.org/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 6502 bytes --]</a>

On Mon, 1 Oct 2018, Mickal Salan wrote:

<span>&gt; Another way to apply a security policy could be to tied it to a file
&gt; descriptor, similarly to Capsicum, which could enable to create
&gt; programmable (real) capabilities. This way, it would be possible to
&gt; "wrap" a file descriptor with a Landlock program and use it with
&gt; FD-based syscalls or pass it to other processes. This would not require
&gt; changes to the FS subsystem, but only the Landlock LSM code. This isn't
&gt; done yet but I plan to add this new way to restrict operations on file
&gt; descriptors.
</span>
Very interesting!

This could possibly be an LSM which stacks/integrates with other LSMs to 
enforce MAC of object capabilities.



<span>&gt; 
&gt; Anyway, for the use case you mentioned, the AT_BENEATH flag(s) should be
&gt; simple to use and enough for now. We must be careful of the hardcoded
&gt; policy though.
&gt; 
&gt; 
&gt; &gt; 
&gt; &gt;&gt; On 9/29/18 12:34, Aleksa Sarai wrote:
&gt; &gt;&gt;&gt; The need for some sort of control over VFS's path resolution (to avoid
&gt; &gt;&gt;&gt; malicious paths resulting in inadvertent breakouts) has been a very
&gt; &gt;&gt;&gt; long-standing desire of many userspace applications. This patchset is a
&gt; &gt;&gt;&gt; revival of Al Viro's old AT_NO_JUMPS[1] patchset with a few additions.
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; The most obvious change is that AT_NO_JUMPS has been split as dicussed
&gt; &gt;&gt;&gt; in the original thread, along with a further split of AT_NO_PROCLINKS
&gt; &gt;&gt;&gt; which means that each individual property of AT_NO_JUMPS is now a
&gt; &gt;&gt;&gt; separate flag:
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt;   * Path-based escapes from the starting-point using "/" or ".." are
&gt; &gt;&gt;&gt;     blocked by AT_BENEATH.
&gt; &gt;&gt;&gt;   * Mountpoint crossings are blocked by AT_XDEV.
&gt; &gt;&gt;&gt;   * /proc/$pid/fd/$fd resolution is blocked by AT_NO_PROCLINKS (more
&gt; &gt;&gt;&gt;       correctly it actually blocks any user of nd_jump_link() because it
&gt; &gt;&gt;&gt;       allows out-of-VFS path resolution manipulation).
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; AT_NO_JUMPS is now effectively (AT_BENEATH|AT_XDEV|AT_NO_PROCLINKS). At
&gt; &gt;&gt;&gt; Linus' suggestion in the original thread, I've also implemented
&gt; &gt;&gt;&gt; AT_NO_SYMLINKS which just denies _all_ symlink resolution (including
&gt; &gt;&gt;&gt; "proclink" resolution).
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; An additional improvement was made to AT_XDEV. The original AT_NO_JUMPS
&gt; &gt;&gt;&gt; path didn't consider "/tmp/.." as a mountpoint crossing -- this patch
&gt; &gt;&gt;&gt; blocks this as well (feel free to ask me to remove it if you feel this
&gt; &gt;&gt;&gt; is not sane).
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; Currently I've only enabled these for openat(2) and the stat(2) family.
&gt; &gt;&gt;&gt; I would hope we could enable it for basically every *at(2) syscall --
&gt; &gt;&gt;&gt; but many of them appear to not have a @flags argument and thus we'll
&gt; &gt;&gt;&gt; need to add several new syscalls to do this. I'm more than happy to send
&gt; &gt;&gt;&gt; those patches, but I'd prefer to know that this preliminary work is
&gt; &gt;&gt;&gt; acceptable before doing a bunch of copy-paste to add new sets of *at(2)
&gt; &gt;&gt;&gt; syscalls.
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; One additional feature I've implemented is AT_THIS_ROOT (I imagine this
&gt; &gt;&gt;&gt; is probably going to be more contentious than the refresh of
&gt; &gt;&gt;&gt; AT_NO_JUMPS, so I've included it in a separate patch). The patch itself
&gt; &gt;&gt;&gt; describes my reasoning, but the shortened version of the premise is that
&gt; &gt;&gt;&gt; continer runtimes need to have a way to resolve paths within a
&gt; &gt;&gt;&gt; potentially malicious rootfs. Container runtimes currently do this in
&gt; &gt;&gt;&gt; userspace[2] which has implicit race conditions that are not resolvable
&gt; &gt;&gt;&gt; in userspace (or use fork+exec+chroot and SCM_RIGHTS passing which is
&gt; &gt;&gt;&gt; inefficient). AT_THIS_ROOT allows for per-call chroot-like semantics for
&gt; &gt;&gt;&gt; path resolution, which would be invaluable for us -- and the
&gt; &gt;&gt;&gt; implementation is basically identical to AT_BENEATH (except that we
&gt; &gt;&gt;&gt; don't return errors when someone actually hits the root).
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; I've added some selftests for this, but it's not clear to me whether
&gt; &gt;&gt;&gt; they should live here or in xfstests (as far as I can tell there are no
&gt; &gt;&gt;&gt; other VFS tests in selftests, while there are some tests that look like
&gt; &gt;&gt;&gt; generic VFS tests in xfstests). If you'd prefer them to be included in
&gt; &gt;&gt;&gt; xfstests, let me know.
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; [1]: <a href="https://lore.kernel.org/patchwork/patch/784221/">https://lore.kernel.org/patchwork/patch/784221/</a>
&gt; &gt;&gt;&gt; [2]: <a href="https://github.com/cyphar/filepath-securejoin">https://github.com/cyphar/filepath-securejoin</a>
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt; Aleksa Sarai (3):
&gt; &gt;&gt;&gt;   namei: implement O_BENEATH-style AT_* flags
&gt; &gt;&gt;&gt;   namei: implement AT_THIS_ROOT chroot-like path resolution
&gt; &gt;&gt;&gt;   selftests: vfs: add AT_* path resolution tests
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;&gt;  fs/fcntl.c                                    |   2 +-
&gt; &gt;&gt;&gt;  fs/namei.c                                    | 158 ++++++++++++------
&gt; &gt;&gt;&gt;  fs/open.c                                     |  10 ++
&gt; &gt;&gt;&gt;  fs/stat.c                                     |  15 +-
&gt; &gt;&gt;&gt;  include/linux/fcntl.h                         |   3 +-
&gt; &gt;&gt;&gt;  include/linux/namei.h                         |   8 +
&gt; &gt;&gt;&gt;  include/uapi/asm-generic/fcntl.h              |  20 +++
&gt; &gt;&gt;&gt;  include/uapi/linux/fcntl.h                    |  10 ++
&gt; &gt;&gt;&gt;  tools/testing/selftests/Makefile              |   1 +
&gt; &gt;&gt;&gt;  tools/testing/selftests/vfs/.gitignore        |   1 +
&gt; &gt;&gt;&gt;  tools/testing/selftests/vfs/Makefile          |  13 ++
&gt; &gt;&gt;&gt;  tools/testing/selftests/vfs/at_flags.h        |  40 +++++
&gt; &gt;&gt;&gt;  tools/testing/selftests/vfs/common.sh         |  37 ++++
&gt; &gt;&gt;&gt;  .../selftests/vfs/tests/0001_at_beneath.sh    |  72 ++++++++
&gt; &gt;&gt;&gt;  .../selftests/vfs/tests/0002_at_xdev.sh       |  54 ++++++
&gt; &gt;&gt;&gt;  .../vfs/tests/0003_at_no_proclinks.sh         |  50 ++++++
&gt; &gt;&gt;&gt;  .../vfs/tests/0004_at_no_symlinks.sh          |  49 ++++++
&gt; &gt;&gt;&gt;  .../selftests/vfs/tests/0005_at_this_root.sh  |  66 ++++++++
&gt; &gt;&gt;&gt;  tools/testing/selftests/vfs/vfs_helper.c      | 154 +++++++++++++++++
&gt; &gt;&gt;&gt;  19 files changed, 707 insertions(+), 56 deletions(-)
&gt; &gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/.gitignore
&gt; &gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/Makefile
&gt; &gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/at_flags.h
&gt; &gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/common.sh
&gt; &gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0001_at_beneath.sh
&gt; &gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0002_at_xdev.sh
&gt; &gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0003_at_no_proclinks.sh
&gt; &gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0004_at_no_symlinks.sh
&gt; &gt;&gt;&gt;  create mode 100755 tools/testing/selftests/vfs/tests/0005_at_this_root.sh
&gt; &gt;&gt;&gt;  create mode 100644 tools/testing/selftests/vfs/vfs_helper.c
&gt; &gt;&gt;&gt;
&gt; &gt;&gt;
&gt; &gt; 
&gt; &gt; 
&gt; 
&gt; 
</span>
-- 
James Morris
&lt;jmorris@namei.org&gt;

<a href="#m440b5bdeba29f11233cdb944b183af4d6c48fb1f" id="e440b5bdeba29f11233cdb944b183af4d6c48fb1f">^</a> <a href="https://lore.kernel.org/lkml/alpine.LRH.2.21.1810020610290.14406@namei.org/">permalink</a> <a href="https://lore.kernel.org/lkml/alpine.LRH.2.21.1810020610290.14406@namei.org/raw">raw</a> <a href="https://lore.kernel.org/lkml/alpine.LRH.2.21.1810020610290.14406@namei.org/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/alpine.LRH.2.21.1810020610290.14406@namei.org/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/alpine.LRH.2.21.1810020610290.14406@namei.org/t/#u">nested</a>] <a href="#r440b5bdeba29f11233cdb944b183af4d6c48fb1f">53+ messages in thread</a></pre><hr><pre><a href="#e304562dd58656fd5ce4cf51430201c473d7baa4f" id="m304562dd58656fd5ce4cf51430201c473d7baa4f">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-01 14:28       ` <a href="#m3b93afe618d6a330d4d98444dabad9e268b0e1bc">Andy Lutomirski</a>
<b>@ 2018-10-02  7:32         ` Aleksa Sarai</b>
  2018-10-03 22:09           ` <a href="#m8fbac970df152ad10bbac3ed851b557cf300dee8">Andy Lutomirski</a>
  2018-10-06 20:56           ` <a href="#m30776acf058e9ccb26876491eaf5ecb147104ad1">Florian Weimer</a>
  <a href="#r304562dd58656fd5ce4cf51430201c473d7baa4f">0 siblings, 2 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-02  7:32 UTC (<a href="https://lore.kernel.org/lkml/20181002073220.7mzndna4tdnxdvdt@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181002073220.7mzndna4tdnxdvdt@ryuk/raw">raw</a>)
  To: Andy Lutomirski
  Cc: Jann Horn, Eric W. Biederman, jlayton, Bruce Fields, Al Viro,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski, christian,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API

<a href="https://lore.kernel.org/lkml/20181002073220.7mzndna4tdnxdvdt@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 3183 bytes --]</a>

On 2018-10-01, Andy Lutomirski &lt;luto@amacapital.net&gt; wrote:
<span>&gt; &gt;&gt;&gt; Currently most container runtimes try to do this resolution in
&gt; &gt;&gt;&gt; userspace[1], causing many potential race conditions. In addition, the
&gt; &gt;&gt;&gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; &gt;&gt;&gt; requires a fork+exec which is *very* costly if necessary for every
&gt; &gt;&gt;&gt; filesystem operation involving a container.
&gt; &gt;&gt; 
&gt; &gt;&gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt; &gt;&gt; a full fork() either, clone() lets you do this with some process parts
&gt; &gt;&gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt; &gt;&gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt; &gt;&gt; wouldn't you want to use setns()?
&gt; &gt; 
&gt; &gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; &gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; &gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; &gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; &gt; for CLONE_VFORK.
&gt; 
&gt; I must admit that Im not very sympathetic to the argument that Gos
&gt; runtime model is incompatible with the simpler solution.
</span>
Multi-threaded programs have a similar issue (though with Go it's much
worse). If you fork a multi-threaded C program then you can only safely
use AS-Safe glibc functions (those that are safe within a signal
handler). But if you're just doing three syscalls this shouldn't be as
big of a problem as Go where you can't even do said syscalls.

<span>&gt; Anyway, it occurs to me that the real problem is that setns() and
&gt; chroot() are both overkill for this use case.
</span>
I agree. My diversion to Go was to explain why it was particularly bad
for cri-o/rkt/runc/Docker/etc.

<span>&gt; Whats needed is to start your walk from /proc/pid-in-container/root,
&gt; with two twists:
&gt; 
&gt; 1. Do the walk as though rooted at a directory. This is basically just
&gt; your AT_THIS_ROOT, but the footgun is avoided because the dirfd you
&gt; use is from a foreign namespace, and, except for symlinks to absolute
&gt; paths, no amount of .. racing is going to escape the *namespace*.
</span>
This is quite clever and I'll admit I hadn't thought of this. This
definitely fixes the ".." issue, but as you've said it won't handle
absolute symlinks (which means userspace has the same races that we
currently have even if you assume that you have a container process
already running -- CVE-2018-15664 is one of many examples of this).

(AT_THIS_ROOT using /proc/$container/root would in principle fix all of
the mentioned issues -- but as I said before I'd like to see whether
hardening ".." would be enough to solve the escape problem.)

<span>&gt; 2. Avoid /proc. Its not just the *links*  you really dont want to
&gt; walk into /proc/self. *Maybe* procfs is already careful enough when
&gt; mounted in a namespace?
</span>
I just tried it and /proc/self gives you -ENOENT. I believe this is
because it does a check against the pid namespace that the procfs mount
has pinned.

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181002073220.7mzndna4tdnxdvdt@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#m304562dd58656fd5ce4cf51430201c473d7baa4f" id="e304562dd58656fd5ce4cf51430201c473d7baa4f">^</a> <a href="https://lore.kernel.org/lkml/20181002073220.7mzndna4tdnxdvdt@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181002073220.7mzndna4tdnxdvdt@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181002073220.7mzndna4tdnxdvdt@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181002073220.7mzndna4tdnxdvdt@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181002073220.7mzndna4tdnxdvdt@ryuk/t/#u">nested</a>] <a href="#r304562dd58656fd5ce4cf51430201c473d7baa4f">53+ messages in thread</a></pre><hr><pre><a href="#e7e2548354abfae7ff3b3b4e175ac0faa81866045" id="m7e2548354abfae7ff3b3b4e175ac0faa81866045">*</a> <b>RE: [PATCH 0/3] namei: implement various scoping AT_* flags</b>
  2018-10-01 16:15   ` <a href="#mf3466ab646463504a28cfdbf74b8d96866715417">Aleksa Sarai</a>
<b>@ 2018-10-03 13:21     ` David Laight</b>
  <a href="#r7e2548354abfae7ff3b3b4e175ac0faa81866045">0 siblings, 0 replies; 53+ messages in thread</a>
From: David Laight @ 2018-10-03 13:21 UTC (<a href="https://lore.kernel.org/lkml/71b13208253f4b3fa82640ec96bf9301@AcuMS.aculab.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/71b13208253f4b3fa82640ec96bf9301@AcuMS.aculab.com/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jeff Layton, J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Christian Brauner,
	Eric Biederman, Tycho Andersen, linux-kernel, linux-fsdevel,
	linux-arch, linux-kselftest, dev, containers

From: Aleksa Sarai
<span>&gt; Sent: 01 October 2018 17:16
&gt; 
&gt; On 2018-10-01, David Laight &lt;David.Laight@ACULAB.COM&gt; wrote:
</span>...
<span>&gt; &gt; &gt;   * Mountpoint crossings are blocked by AT_XDEV.
&gt; &gt;
&gt; &gt; You might want a mountpoint flag that allows crossing into the mounted
&gt; &gt; filesystem (you may need to get out in order to do pwd()).
&gt; 
&gt; Like a mount flag? I'm not sure how I feel about that. The intention is
&gt; to allow for a process to have control over how path lookups are
&gt; handled, and tying it to a mount flag means that it's no longer entirely
&gt; up to the process.
</span>
Right, but you may have some mount points that you don't want to cross
and others that it is perfectly fine to cross.
For example you might want to be able to cross into a 'tmp' filesystem.

...
<span>&gt; &gt; If you make the flags a property of the directory vnode (perhaps as
&gt; &gt; well as any syscall flags), and make it inherited by vnode lookup then
&gt; &gt; it can be used to stop library functions (or entire binaries) using
&gt; &gt; blocked paths.
&gt; &gt; You'd then only need to add an fcntl() call to set the flags (but never
&gt; &gt; clear them) to get the restriction applied to every lookup.
&gt; 
&gt; This seems like it might be useful, but it could always be done as a
&gt; follow-up patch by just setting LOOKUP_BLAH if the dirfd has the flag
&gt; set. I'm also a little bit concerned that (because fd flags are set on
&gt; the 'struct file') if you start sharing fds then you can no longer use
&gt; the lookup scoping for security (a racing process could remove the
&gt; flags while the management process resolves through it).
</span>
I was thinking that the flags would never be removable.
A management process might have to flip its cwd back and forth
in order to clear the flags (opendir(".") should give a different
struct file).

This all gets tied up with the slight requirement for per-thread cwd.

I had another thought that the crudentials structure used for a file
lookup could also be taken from the cwd (not sure how it would
get there - especially if you need the correct group list).
That would allow a 'management' process to open a file in the context
of the target user process.

	David

-
Registered Address Lakeside, Bramley Road, Mount Farm, Milton Keynes, MK1 1PT, UK
Registration No: 1397386 (Wales)


<a href="#m7e2548354abfae7ff3b3b4e175ac0faa81866045" id="e7e2548354abfae7ff3b3b4e175ac0faa81866045">^</a> <a href="https://lore.kernel.org/lkml/71b13208253f4b3fa82640ec96bf9301@AcuMS.aculab.com/">permalink</a> <a href="https://lore.kernel.org/lkml/71b13208253f4b3fa82640ec96bf9301@AcuMS.aculab.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/71b13208253f4b3fa82640ec96bf9301@AcuMS.aculab.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/71b13208253f4b3fa82640ec96bf9301@AcuMS.aculab.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/71b13208253f4b3fa82640ec96bf9301@AcuMS.aculab.com/t/#u">nested</a>] <a href="#r7e2548354abfae7ff3b3b4e175ac0faa81866045">53+ messages in thread</a></pre><hr><pre><a href="#e8fbac970df152ad10bbac3ed851b557cf300dee8" id="m8fbac970df152ad10bbac3ed851b557cf300dee8">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-02  7:32         ` <a href="#m304562dd58656fd5ce4cf51430201c473d7baa4f">Aleksa Sarai</a>
<b>@ 2018-10-03 22:09           ` Andy Lutomirski</b>
  2018-10-06 20:56           ` <a href="#m30776acf058e9ccb26876491eaf5ecb147104ad1">Florian Weimer</a>
  <a href="#r8fbac970df152ad10bbac3ed851b557cf300dee8">1 sibling, 0 replies; 53+ messages in thread</a>
From: Andy Lutomirski @ 2018-10-03 22:09 UTC (<a href="https://lore.kernel.org/lkml/CALCETrXZ_Kg25gToCzzM=4g1Z3mQgou8RmF6OWoh3+vuPk3vUA@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CALCETrXZ_Kg25gToCzzM=4g1Z3mQgou8RmF6OWoh3+vuPk3vUA@mail.gmail.com/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jann Horn, Eric W. Biederman, Jeff Layton, J. Bruce Fields,
	Al Viro, Arnd Bergmann, Shuah Khan, David Howells,
	Andrew Lutomirski, Christian Brauner, Tycho Andersen, LKML,
	Linux FS Devel, linux-arch, open list:KERNEL SELFTEST FRAMEWORK,
	dev, Linux Containers, Linux API

On Tue, Oct 2, 2018 at 12:32 AM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
<span>&gt;
&gt; On 2018-10-01, Andy Lutomirski &lt;luto@amacapital.net&gt; wrote:
&gt; &gt; &gt;&gt;&gt; Currently most container runtimes try to do this resolution in
&gt; &gt; &gt;&gt;&gt; userspace[1], causing many potential race conditions. In addition, the
&gt; &gt; &gt;&gt;&gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; &gt; &gt;&gt;&gt; requires a fork+exec which is *very* costly if necessary for every
&gt; &gt; &gt;&gt;&gt; filesystem operation involving a container.
&gt; &gt; &gt;&gt;
&gt; &gt; &gt;&gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt; &gt; &gt;&gt; a full fork() either, clone() lets you do this with some process parts
&gt; &gt; &gt;&gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt; &gt; &gt;&gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt; &gt; &gt;&gt; wouldn't you want to use setns()?
&gt; &gt; &gt;
&gt; &gt; &gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; &gt; &gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; &gt; &gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; &gt; &gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; &gt; &gt; for CLONE_VFORK.
&gt; &gt;
&gt; &gt; I must admit that Im not very sympathetic to the argument that Gos
&gt; &gt; runtime model is incompatible with the simpler solution.
&gt;
&gt; Multi-threaded programs have a similar issue (though with Go it's much
&gt; worse). If you fork a multi-threaded C program then you can only safely
&gt; use AS-Safe glibc functions (those that are safe within a signal
&gt; handler). But if you're just doing three syscalls this shouldn't be as
&gt; big of a problem as Go where you can't even do said syscalls.
&gt;
&gt; &gt; Anyway, it occurs to me that the real problem is that setns() and
&gt; &gt; chroot() are both overkill for this use case.
&gt;
&gt; I agree. My diversion to Go was to explain why it was particularly bad
&gt; for cri-o/rkt/runc/Docker/etc.
&gt;
&gt; &gt; Whats needed is to start your walk from /proc/pid-in-container/root,
&gt; &gt; with two twists:
&gt; &gt;
&gt; &gt; 1. Do the walk as though rooted at a directory. This is basically just
&gt; &gt; your AT_THIS_ROOT, but the footgun is avoided because the dirfd you
&gt; &gt; use is from a foreign namespace, and, except for symlinks to absolute
&gt; &gt; paths, no amount of .. racing is going to escape the *namespace*.
&gt;
&gt; This is quite clever and I'll admit I hadn't thought of this. This
&gt; definitely fixes the ".." issue, but as you've said it won't handle
&gt; absolute symlinks (which means userspace has the same races that we
&gt; currently have even if you assume that you have a container process
&gt; already running -- CVE-2018-15664 is one of many examples of this).
&gt;
&gt; (AT_THIS_ROOT using /proc/$container/root would in principle fix all of
&gt; the mentioned issues -- but as I said before I'd like to see whether
&gt; hardening ".." would be enough to solve the escape problem.)
</span>
Hmm.  Good point.

<a href="#m8fbac970df152ad10bbac3ed851b557cf300dee8" id="e8fbac970df152ad10bbac3ed851b557cf300dee8">^</a> <a href="https://lore.kernel.org/lkml/CALCETrXZ_Kg25gToCzzM=4g1Z3mQgou8RmF6OWoh3+vuPk3vUA@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CALCETrXZ_Kg25gToCzzM=4g1Z3mQgou8RmF6OWoh3+vuPk3vUA@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CALCETrXZ_Kg25gToCzzM=4g1Z3mQgou8RmF6OWoh3+vuPk3vUA@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CALCETrXZ_Kg25gToCzzM=4g1Z3mQgou8RmF6OWoh3+vuPk3vUA@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CALCETrXZ_Kg25gToCzzM=4g1Z3mQgou8RmF6OWoh3+vuPk3vUA@mail.gmail.com/t/#u">nested</a>] <a href="#r8fbac970df152ad10bbac3ed851b557cf300dee8">53+ messages in thread</a></pre><hr><pre><a href="#e1363e6020e3fcd93078ba4165aac2ccfb07ef4a5" id="m1363e6020e3fcd93078ba4165aac2ccfb07ef4a5">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-09-29 16:35   ` <a href="#m85db30139fa0747cca01a4a7b71ba3f88ab3207c">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Jann Horn
                       ` <a href="#rd4dd13f53e4b9d8535513d1aed0b121a8d5cfc51">(2 preceding siblings ...)</a>
  2018-10-01 14:00     ` <a href="#md4dd13f53e4b9d8535513d1aed0b121a8d5cfc51">Christian Brauner</a>
<b>@ 2018-10-04 16:26     ` Aleksa Sarai</b>
  2018-10-04 17:31       ` <a href="#m85e4ef7cc31f70b859e7112e14c624d1ce7b87ee">Christian Brauner</a>
  2018-10-04 18:26       ` <a href="#m18be51e2a413ec671a98bf761c85a657651c0a3f">Jann Horn</a>
  <a href="#r1363e6020e3fcd93078ba4165aac2ccfb07ef4a5">3 siblings, 2 replies; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-04 16:26 UTC (<a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/raw">raw</a>)
  To: Jann Horn
  Cc: Eric W. Biederman, jlayton, Bruce Fields, Al Viro, Arnd Bergmann,
	shuah, David Howells, Andy Lutomirski, christian, Tycho Andersen,
	kernel list, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers, Linux API

<a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/1.1-a.txt">[-- Attachment #1.1: Type: text/plain, Size: 5425 bytes --]</a>

On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
<span>&gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; the following:
&gt; 
&gt; 1. You start the path walk and reach /A/B/C.
&gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; the process root, but you never actually encountered the process root,
&gt; so you don't notice.
&gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; outside the process root, but you don't notice.
&gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; successfully. You now have an fd pointing outside your chroot.
</span>
I've been playing with this and I have the following patch, which
according to my testing protects against attacks where ".." skips over
nd-&gt;root. It abuses __d_path to figure out if nd-&gt;path can be resolved
from nd-&gt;root (obviously a proper version of this patch would refactor
__d_path so it could be used like this -- and would not return
-EMULTIHOP).

I've also attached my reproducer. With it, I was seeing fairly constant
breakouts before this patch and after it I didn't see a single breakout
after running it overnight. Obviously this is not conclusive, but I'm
hoping that it can show what my idea for protecting against ".." was.

Does this patch make sense? Or is there something wrong with it that I'm
not seeing?

--8&lt;-------------------------------------------------------------------

There is a fairly easy-to-exploit race condition with chroot(2) (and
thus by extension AT_THIS_ROOT and AT_BENEATH) where a rename(2) of a
path can be used to "skip over" nd-&gt;root and thus escape to the
filesystem above nd-&gt;root.

  thread1 [attacker]:
    for (;;)
      renameat2(AT_FDCWD, "/a/b/c", AT_FDCWD, "/a/d", RENAME_EXCHANGE);
  thread2 [victim]:
    for (;;)
      openat(dirb, "b/c/../../etc/shadow", O_THISROOT);

With fairly significant regularity, thread2 will resolve to
"/etc/shadow" rather than "/a/b/etc/shadow". With this patch, such cases
will be detected during ".." resolution (which is the weak point of
chroot(2) -- since walking *into* a subdirectory tautologically cannot
result in you walking *outside* nd-&gt;root).

The use of __d_path here might seem suspect, however we don't mind if a
path is moved from within the chroot to outside the chroot and we
incorrectly decide it is safe (because at that point we are still within
the set of files which were accessible at the beginning of resolution).
However, we can fail resolution on the next path component if it remains
outside of the root. A path which has always been outside nd-&gt;root
during resolution will never be resolveable from nd-&gt;root and thus will
always be blocked.

DO NOT MERGE: Currently this code returns -EMULTIHOP in this case,
	      purely as a debugging measure (so that you can see that
	      the protection actually does something). Obviously in the
	      proper patch this will return -EXDEV.

Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
---
 <a id="iZ2e.:..:20181004162611.vdlujbdguvagalpt::40ryuk:1:1fs:namei.c" href="#Z2e.:..:20181004162611.vdlujbdguvagalpt::40ryuk:1:1fs:namei.c">fs/namei.c</a> | 32 ++++++++++++++++++++++++++++++--
 1 file changed, 30 insertions(+), 2 deletions(-)

<span><a href="#iZ2e.:..:20181004162611.vdlujbdguvagalpt::40ryuk:1:1fs:namei.c" id="Z2e.:..:20181004162611.vdlujbdguvagalpt::40ryuk:1:1fs:namei.c">diff</a> --git a/fs/namei.c b/fs/namei.c
index 6f995e6de6b1..c8349693d47b 100644
--- a/fs/namei.c
+++ b/fs/namei.c
</span><span>@@ -53,8 +53,8 @@</span>
  * The new code replaces the old recursive symlink resolution with
  * an iterative one (in case of non-nested symlink chains).  It does
  * this with calls to &lt;fs&gt;_follow_link().
<span>- * As a side effect, dir_namei(), _namei() and follow_link() are now 
- * replaced with a single function lookup_dentry() that can handle all 
</span><span>+ * As a side effect, dir_namei(), _namei() and follow_link() are now
+ * replaced with a single function lookup_dentry() that can handle all
</span>  * the special cases of the former code.
  *
  * With the new dcache, the pathname is stored at each inode, at least as
<span>@@ -1375,6 +1375,20 @@</span> static int follow_dotdot_rcu(struct nameidata *nd)
 				return -EXDEV;
 			break;
 		}
<span>+		if (unlikely(nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT))) {
+			char *pathbuf, *pathptr;
+
+			pathbuf = kmalloc(PATH_MAX, GFP_ATOMIC);
+			if (!pathbuf)
+				return -ECHILD;
+			pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
+			kfree(pathbuf);
+			if (IS_ERR_OR_NULL(pathptr)) {
+				if (!pathptr)
+					pathptr = ERR_PTR(-EMULTIHOP);
+				return PTR_ERR(pathptr);
+			}
+		}
</span> 		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
 			struct dentry *old = nd-&gt;path.dentry;
 			struct dentry *parent = old-&gt;d_parent;
<span>@@ -1510,6 +1524,20 @@</span> static int follow_dotdot(struct nameidata *nd)
 				return -EXDEV;
 			break;
 		}
<span>+		if (unlikely(nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT))) {
+			char *pathbuf, *pathptr;
+
+			pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
+			if (!pathbuf)
+				return -ENOMEM;
+			pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
+			kfree(pathbuf);
+			if (IS_ERR_OR_NULL(pathptr)) {
+				if (!pathptr)
+					pathptr = ERR_PTR(-EMULTIHOP);
+				return PTR_ERR(pathptr);
+			}
+		}
</span> 		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
 			int ret = path_parent_directory(&amp;nd-&gt;path);
 			if (ret)
-- 
2.19.0

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/1.2-rename_attack.c">[-- Attachment #1.2: rename_attack.c --]
[-- Type: text/x-c, Size: 3172 bytes --]</a>

// SPDX-License-Identifier: GPL-2.0+
/*
 * Author: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
 * Copyright (C) 2018 SUSE LLC.
 */

#define _GNU_SOURCE
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;linux/fs.h&gt;

/* These come from &lt;uapi/asm-generic/linux/fcntl.h&gt; */
#ifndef O_BENEATH
# define O_BENEATH	00040000000
# define O_XDEV		00100000000
# define O_NOPROCLINKS	00200000000
# define O_NOSYMLINKS	01000000000
# define O_THISROOT	02000000000
#endif
#ifndef AT_BENEATH
# define AT_BENEATH		0x8000
# define AT_XDEV		0x10000
# define AT_NO_PROCLINKS	0x20000
# define AT_NO_SYMLINKS		0x40000
# define AT_THIS_ROOT		0x80000
#endif

#define bail(...)							\
	do {								\
		fprintf(stderr, __VA_ARGS__);				\
		fputs("\n", stderr);					\
		exit(1);						\
	} while (0)

int renameat2(int olddirfd, const char *oldpath,
	      int newdirfd, const char *newpath, unsigned int flags)
{
	errno = syscall(__NR_renameat2, olddirfd, oldpath,
					newdirfd, newpath, flags);
	return errno &lt; 0 ? -1 : 0;
}

char *sprint_path(int fd)
{
	char *fdpath = NULL, *fullpath;
	if (asprintf(&amp;fdpath, "/proc/self/fd/%d", fd) &lt; 0)
		return NULL;

	fullpath = malloc(PATH_MAX+1);
	if (!fullpath)
		goto out1;
	memset(fullpath, '\0', PATH_MAX+1);
	if (readlink(fdpath, fullpath, PATH_MAX) &lt; 0)
		goto out2;

	free(fdpath);
	return fullpath;

out2:
	free(fullpath);
out1:
	free(fdpath);
	return NULL;
}

int rename_attacker(int dirfd, char *namea, char *nameb)
{
	for (;;) {
		if (renameat2(dirfd, namea, dirfd, nameb, RENAME_EXCHANGE) &lt; 0)
			fprintf(stderr, "rename a&lt;=&gt;b failed: %m\n");
	}
	return 1;
}

int openat_victim(int dirfd, char *path, unsigned int flags)
{
	char *last_path = NULL;
	int last_errno = 0;

	for (;;) {
		int fd = openat(dirfd, path, flags);
		if (fd &lt; 0) {
			if (errno != last_errno)
				printf("errno=%m\n");
			last_errno = errno;
		} else {
			char *path = sprint_path(fd);
			if (!strcmp(path, "/")) {
				puts("[[ BREAKOUT ]]");
				printf("fd=%d\n", fd);
				for (;;)
					;
			}
			if (!last_path || strcmp(last_path, path)) {
				printf("path=%s\n", path);
				free(last_path);
				last_path = strdup(path);
			}
			free(path);
			close(fd);
		}
	}
	free(last_path);
	return 1;
}

int main(void)
{
	char tmppath[] = "__TEST_rename_attack.XXXXXX";

	if (!mkdtemp(tmppath))
		bail("mkdtemp: %m");

	int tmpfd = openat(AT_FDCWD, tmppath, O_PATH|O_DIRECTORY);
	if (tmpfd &lt; 0)
		bail("open tmppath: %m");

	// Make dira and dirb.
	if (mkdirat(tmpfd, "a", 0755) &lt; 0)
		bail("mkdir dira: %m");
	if (mkdirat(tmpfd, "b", 0755) &lt; 0)
		bail("mkdir dirb: %m");
	if (mkdirat(tmpfd, "a/c", 0755) &lt; 0)
		bail("mkdir dira/c: %m");

	// Open "a".
	int afd = openat(tmpfd, "a", O_PATH|O_DIRECTORY);
	if (afd &lt; 0)
		bail("open dira: %m");

	pid_t child = fork();
	if (child &lt; 0)
		bail("fork child: %m");
	else if (!child)
		return rename_attacker(tmpfd, "a/c", "b");
	else
		return openat_victim(afd, "c/../../../../../../../../../../../../../../../../../../../../../../../../../", O_THISROOT|O_RDONLY);

	return 1;
}

<a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#m1363e6020e3fcd93078ba4165aac2ccfb07ef4a5" id="e1363e6020e3fcd93078ba4165aac2ccfb07ef4a5">^</a> <a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181004162611.vdlujbdguvagalpt@ryuk/t/#u">nested</a>] <a href="#r1363e6020e3fcd93078ba4165aac2ccfb07ef4a5">53+ messages in thread</a></pre><hr><pre><a href="#e805a98d1da56907d6f5b4fb1ffbe2390a20dcbca" id="m805a98d1da56907d6f5b4fb1ffbe2390a20dcbca">*</a> <b>Re: [PATCH 1/3] namei: implement O_BENEATH-style AT_* flags</b>
  2018-10-01 16:04       ` <a href="#m976af4e59482b98696b0e918a77ff53493dfe932">Aleksa Sarai</a>
<b>@ 2018-10-04 17:20         ` Christian Brauner</b>
  <a href="#r805a98d1da56907d6f5b4fb1ffbe2390a20dcbca">0 siblings, 0 replies; 53+ messages in thread</a>
From: Christian Brauner @ 2018-10-04 17:20 UTC (<a href="https://lore.kernel.org/lkml/20181004172050.wja5nwjkfa3jjmzw@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181004172050.wja5nwjkfa3jjmzw@brauner.io/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jann Horn, Al Viro, Eric W. Biederman, Andy Lutomirski, jlayton,
	Bruce Fields, Arnd Bergmann, shuah, David Howells,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers

On Tue, Oct 02, 2018 at 02:04:31AM +1000, Aleksa Sarai wrote:
<span>&gt; On 2018-10-01, Christian Brauner &lt;christian@brauner.io&gt; wrote:
&gt; &gt; On Mon, Oct 01, 2018 at 02:28:03PM +0200, Jann Horn wrote:
&gt; &gt; &gt; On Sat, Sep 29, 2018 at 4:28 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt; &gt; &gt; &gt; * AT_BENEATH: Disallow ".." or absolute paths (either in the path or
&gt; &gt; &gt; &gt;   found during symlink resolution) to escape the starting point of name
&gt; &gt; &gt; &gt;   resolution, though ".." is permitted in cases like "foo/../bar".
&gt; &gt; &gt; &gt;   Relative symlinks are still allowed (as long as they don't escape the
&gt; &gt; &gt; &gt;   starting point).
&gt; &gt; &gt; 
&gt; &gt; &gt; As I said on the other thread, I would strongly prefer an API that
&gt; &gt; &gt; behaves along the lines of David Drysdale's old patch
&gt; &gt; &gt; <a href="https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/">https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/</a>
&gt; &gt; &gt; : Forbid any use of "..". This would also be more straightforward to
&gt; &gt; &gt; implement safely. If that doesn't work for you, I would like it if you
&gt; &gt; &gt; could at least make that an option. I would like it if this API could
&gt; &gt; &gt; mitigate straightforward directory traversal bugs such as
&gt; &gt; &gt; <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1583">https://bugs.chromium.org/p/project-zero/issues/detail?id=1583</a>, where
&gt; &gt; &gt; a confused deputy attempts to access a path like
&gt; &gt; &gt; "/mnt/media_rw/../../data" while intending to access a directory under
&gt; &gt; &gt; "/mnt/media_rw".
&gt; &gt; 
&gt; &gt; Oh, the semantics for this changed in this patchset, hah. I was still on
&gt; &gt; vacation so didn't get to look at it before it was sent out. From prior
&gt; &gt; discussion I remember that the original intention actual was what you
&gt; &gt; argue for. And the patchset should be as tight as possible. Having
&gt; &gt; special cases where ".." is allowed just sounds like an invitation for
&gt; &gt; userspace to get it wrong.
&gt; &gt; Aleksa, did you have a specific use-case in mind that made you change
&gt; &gt; this or was it already present in an earlier iteration of the patchset
&gt; &gt; by someone else?
&gt; 
&gt; Al's original patchset allowed "..". A quick survey of my machine shows
&gt; that there are 100k symlinks that contain ".." (~37% of all symlinks on
&gt; my machine). This indicates to me that you would be restricting a large
&gt; amount of reasonable resolutions because of this restriction.
&gt; 
&gt; I posted a proposed way to protect against ".." shenanigans. If it's
&gt; turns out this is not possible, I'm okay with disallowing ".." (assuming
&gt; Al is also okay with that).
</span>
Sounds acceptable to me.

<a href="#m805a98d1da56907d6f5b4fb1ffbe2390a20dcbca" id="e805a98d1da56907d6f5b4fb1ffbe2390a20dcbca">^</a> <a href="https://lore.kernel.org/lkml/20181004172050.wja5nwjkfa3jjmzw@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/20181004172050.wja5nwjkfa3jjmzw@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181004172050.wja5nwjkfa3jjmzw@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181004172050.wja5nwjkfa3jjmzw@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181004172050.wja5nwjkfa3jjmzw@brauner.io/t/#u">nested</a>] <a href="#r805a98d1da56907d6f5b4fb1ffbe2390a20dcbca">53+ messages in thread</a></pre><hr><pre><a href="#e8fd9ac6f0a3adff4a8c4bb48b08d4a3183f9b343" id="m8fd9ac6f0a3adff4a8c4bb48b08d4a3183f9b343">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-01 16:18         ` <a href="#madb4f69d46d490beab7f3563227268b15c6ed379">Aleksa Sarai</a>
<b>@ 2018-10-04 17:27           ` Christian Brauner</b>
  <a href="#r8fd9ac6f0a3adff4a8c4bb48b08d4a3183f9b343">0 siblings, 0 replies; 53+ messages in thread</a>
From: Christian Brauner @ 2018-10-04 17:27 UTC (<a href="https://lore.kernel.org/lkml/20181004172733.x75nmwqan2iu3kyv@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181004172733.x75nmwqan2iu3kyv@brauner.io/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jann Horn, Eric W. Biederman, Al Viro, jlayton, Bruce Fields,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API

On Tue, Oct 02, 2018 at 02:18:33AM +1000, Aleksa Sarai wrote:
<span>&gt; On 2018-10-01, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; &gt; If this is an issue for AT_THIS_ROOT, I believe this might also be an
&gt; &gt; &gt; issue for AT_BENEATH since they are effectively both using the same
&gt; &gt; &gt; nd-&gt;root trick (so you could similarly trick AT_BENEATH to not error
&gt; &gt; &gt; out). So we'd need to figure out how to solve this problem in order for
&gt; &gt; &gt; AT_BENEATH to be safe.
&gt; &gt; 
&gt; &gt; Oh, wait, what? I think I didn't notice that the semantics of
&gt; &gt; AT_BENEATH changed like that since the original posting of David
&gt; &gt; Drysdale's O_BENEATH_ONLY patch
&gt; &gt; (<a href="https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/">https://lore.kernel.org/lkml/1439458366-8223-2-git-send-email-drysdale@google.com/</a>).
&gt; &gt; David's patch had nice, straightforward semantics, blocking any form
&gt; &gt; of upwards traversal. Why was that changed? Does anyone actually want
&gt; &gt; to use paths that contain ".." with AT_BENEATH? I would strongly
&gt; &gt; prefer something that blocks any use of "..".
&gt; &gt; 
&gt; &gt; @Al: It looks like this already changed back when you posted
&gt; &gt; <a href="https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/">https://lore.kernel.org/lkml/20170429220414.GT29622@ZenIV.linux.org.uk/</a>
&gt; &gt; ?
&gt; 
&gt; Yes, I copied the semantics from Al's patchset. I don't know why he felt
&gt; strongly that this was the best idea, but in my opinion allowing paths
&gt; like "a/../b/../c" seems like it's quite useful because otherwise you
&gt; wouldn't be able to operate on most distribution root filesystems (many
&gt; have symlinks that have ".." components). Looking at my own (openSUSE)
&gt; machine there are something like 100k such symlinks (~37% of symlinks on
&gt; my machine).
&gt; 
&gt; While I do understand that the easiest way of solving this problem is to
&gt; disallow ".." entirely with AT_BENEATH, given that support ".." has
&gt; utility, I would like to know whether it's actually not possible to have
&gt; this work safely.
&gt; 
&gt; &gt; &gt; Speaking naively, doesn't it make sense to invalidate the walk if a path
&gt; &gt; &gt; component was modified? Or is this something that would be far too
&gt; &gt; &gt; costly with little benefit? What if we do more aggressive nd-&gt;root
&gt; &gt; &gt; checks when resolving with AT_BENEATH or AT_THIS_ROOT (or if nd-&gt;root !=
&gt; &gt; &gt; current-&gt;mnt_ns-&gt;root)?
&gt; &gt; 
&gt; &gt; It seems to me like doing that would basically require looking at each
&gt; &gt; node in the path walk twice? And it'd be difficult to guarantee
&gt; &gt; forward progress unless you're willing to do some fairly heavy
&gt; &gt; locking.
&gt; 
&gt; I had another idea since I wrote my previous mail -- since the issue (at
&gt; least the way I understand it) is that ".." can "skip" over nd-&gt;root
&gt; because of the rename, what if we had some sort of is_descendant() check
&gt; within follow_dotdot()? (FWIW, ".." already has some pretty interesting
&gt; "hand-over-hand" locking semantics.) This should be effectively similar
&gt; to how prepend_path() deals with a path that is not reachable from @root
&gt; (I'm not sure if the locking is acceptable for the namei path though).
&gt; 
&gt; Since ".." with AT_THIS_ROOT (or AT_BENEATH) is not going to be the most
&gt; common component type (and we only need to do these checks for those
&gt; flags), I would think that the extra cost would not be _that_ awful.
&gt; 
&gt; Would this work?
&gt; 
&gt; &gt; &gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; &gt; &gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; &gt; &gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; &gt; &gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; &gt; &gt; for CLONE_VFORK.
&gt; &gt; 
&gt; &gt; If you insist on implementing every last bit of your code in Go, I guess.
&gt; 
&gt; Fair enough, though I believe this would affect most multi-threaded
&gt; programs as well (regardless of the language they're written in).
</span>
(Depends on whether you do any explicit locking and have atfork handlers
for your locks and so on. If you do a clone syscall directly to avoid
having libc running any additional atfork handlers (flushing streams
etc.) it's doable though not ideal.)

<a href="#m8fd9ac6f0a3adff4a8c4bb48b08d4a3183f9b343" id="e8fd9ac6f0a3adff4a8c4bb48b08d4a3183f9b343">^</a> <a href="https://lore.kernel.org/lkml/20181004172733.x75nmwqan2iu3kyv@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/20181004172733.x75nmwqan2iu3kyv@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181004172733.x75nmwqan2iu3kyv@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181004172733.x75nmwqan2iu3kyv@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181004172733.x75nmwqan2iu3kyv@brauner.io/t/#u">nested</a>] <a href="#r8fd9ac6f0a3adff4a8c4bb48b08d4a3183f9b343">53+ messages in thread</a></pre><hr><pre><a href="#e85e4ef7cc31f70b859e7112e14c624d1ce7b87ee" id="m85e4ef7cc31f70b859e7112e14c624d1ce7b87ee">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-04 16:26     ` <a href="#m1363e6020e3fcd93078ba4165aac2ccfb07ef4a5">Aleksa Sarai</a>
<b>@ 2018-10-04 17:31       ` Christian Brauner</b>
  2018-10-04 18:26       ` <a href="#m18be51e2a413ec671a98bf761c85a657651c0a3f">Jann Horn</a>
  <a href="#r85e4ef7cc31f70b859e7112e14c624d1ce7b87ee">1 sibling, 0 replies; 53+ messages in thread</a>
From: Christian Brauner @ 2018-10-04 17:31 UTC (<a href="https://lore.kernel.org/lkml/20181004173121.e6tfwd6nc2geuv5c@brauner.io/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181004173121.e6tfwd6nc2geuv5c@brauner.io/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Jann Horn, Eric W. Biederman, jlayton, Bruce Fields, Al Viro,
	Arnd Bergmann, shuah, David Howells, Andy Lutomirski,
	Tycho Andersen, kernel list, linux-fsdevel, linux-arch,
	linux-kselftest, dev, containers, Linux API

On Fri, Oct 05, 2018 at 02:26:11AM +1000, Aleksa Sarai wrote:
<span>&gt; On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; &gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; &gt; the following:
&gt; &gt; 
&gt; &gt; 1. You start the path walk and reach /A/B/C.
&gt; &gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; &gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; &gt; the process root, but you never actually encountered the process root,
&gt; &gt; so you don't notice.
&gt; &gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; &gt; outside the process root, but you don't notice.
&gt; &gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; &gt; successfully. You now have an fd pointing outside your chroot.
&gt; 
&gt; I've been playing with this and I have the following patch, which
&gt; according to my testing protects against attacks where ".." skips over
&gt; nd-&gt;root. It abuses __d_path to figure out if nd-&gt;path can be resolved
&gt; from nd-&gt;root (obviously a proper version of this patch would refactor
&gt; __d_path so it could be used like this -- and would not return
&gt; -EMULTIHOP).
&gt; 
&gt; I've also attached my reproducer. With it, I was seeing fairly constant
&gt; breakouts before this patch and after it I didn't see a single breakout
&gt; after running it overnight. Obviously this is not conclusive, but I'm
&gt; hoping that it can show what my idea for protecting against ".." was.
&gt; 
&gt; Does this patch make sense? Or is there something wrong with it that I'm
&gt; not seeing?
</span>
Interesting.
Apart from the abuse of __d_path() :) the question I'd have is whether
this just minimizes the race window or if you can provide a sound
argument that this actually can't happen anymore with this patch.

<span>&gt; 
&gt; --8&lt;-------------------------------------------------------------------
&gt; 
&gt; There is a fairly easy-to-exploit race condition with chroot(2) (and
&gt; thus by extension AT_THIS_ROOT and AT_BENEATH) where a rename(2) of a
&gt; path can be used to "skip over" nd-&gt;root and thus escape to the
&gt; filesystem above nd-&gt;root.
&gt; 
&gt;   thread1 [attacker]:
&gt;     for (;;)
&gt;       renameat2(AT_FDCWD, "/a/b/c", AT_FDCWD, "/a/d", RENAME_EXCHANGE);
&gt;   thread2 [victim]:
&gt;     for (;;)
&gt;       openat(dirb, "b/c/../../etc/shadow", O_THISROOT);
&gt; 
&gt; With fairly significant regularity, thread2 will resolve to
&gt; "/etc/shadow" rather than "/a/b/etc/shadow". With this patch, such cases
&gt; will be detected during ".." resolution (which is the weak point of
&gt; chroot(2) -- since walking *into* a subdirectory tautologically cannot
&gt; result in you walking *outside* nd-&gt;root).
&gt; 
&gt; The use of __d_path here might seem suspect, however we don't mind if a
&gt; path is moved from within the chroot to outside the chroot and we
&gt; incorrectly decide it is safe (because at that point we are still within
&gt; the set of files which were accessible at the beginning of resolution).
&gt; However, we can fail resolution on the next path component if it remains
&gt; outside of the root. A path which has always been outside nd-&gt;root
&gt; during resolution will never be resolveable from nd-&gt;root and thus will
&gt; always be blocked.
&gt; 
&gt; DO NOT MERGE: Currently this code returns -EMULTIHOP in this case,
&gt; 	      purely as a debugging measure (so that you can see that
&gt; 	      the protection actually does something). Obviously in the
&gt; 	      proper patch this will return -EXDEV.
&gt; 
&gt; Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
&gt; ---
&gt;  fs/namei.c | 32 ++++++++++++++++++++++++++++++--
&gt;  1 file changed, 30 insertions(+), 2 deletions(-)
&gt; 
&gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; index 6f995e6de6b1..c8349693d47b 100644
&gt; --- a/fs/namei.c
&gt; +++ b/fs/namei.c
&gt; @@ -53,8 +53,8 @@
&gt;   * The new code replaces the old recursive symlink resolution with
&gt;   * an iterative one (in case of non-nested symlink chains).  It does
&gt;   * this with calls to &lt;fs&gt;_follow_link().
&gt; - * As a side effect, dir_namei(), _namei() and follow_link() are now 
&gt; - * replaced with a single function lookup_dentry() that can handle all 
&gt; + * As a side effect, dir_namei(), _namei() and follow_link() are now
&gt; + * replaced with a single function lookup_dentry() that can handle all
&gt;   * the special cases of the former code.
&gt;   *
&gt;   * With the new dcache, the pathname is stored at each inode, at least as
&gt; @@ -1375,6 +1375,20 @@ static int follow_dotdot_rcu(struct nameidata *nd)
&gt;  				return -EXDEV;
&gt;  			break;
&gt;  		}
&gt; +		if (unlikely(nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT))) {
&gt; +			char *pathbuf, *pathptr;
&gt; +
&gt; +			pathbuf = kmalloc(PATH_MAX, GFP_ATOMIC);
&gt; +			if (!pathbuf)
&gt; +				return -ECHILD;
&gt; +			pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
&gt; +			kfree(pathbuf);
&gt; +			if (IS_ERR_OR_NULL(pathptr)) {
&gt; +				if (!pathptr)
&gt; +					pathptr = ERR_PTR(-EMULTIHOP);
&gt; +				return PTR_ERR(pathptr);
&gt; +			}
&gt; +		}
&gt;  		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
&gt;  			struct dentry *old = nd-&gt;path.dentry;
&gt;  			struct dentry *parent = old-&gt;d_parent;
&gt; @@ -1510,6 +1524,20 @@ static int follow_dotdot(struct nameidata *nd)
&gt;  				return -EXDEV;
&gt;  			break;
&gt;  		}
&gt; +		if (unlikely(nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT))) {
&gt; +			char *pathbuf, *pathptr;
&gt; +
&gt; +			pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
&gt; +			if (!pathbuf)
&gt; +				return -ENOMEM;
&gt; +			pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
&gt; +			kfree(pathbuf);
&gt; +			if (IS_ERR_OR_NULL(pathptr)) {
&gt; +				if (!pathptr)
&gt; +					pathptr = ERR_PTR(-EMULTIHOP);
&gt; +				return PTR_ERR(pathptr);
&gt; +			}
&gt; +		}
&gt;  		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
&gt;  			int ret = path_parent_directory(&amp;nd-&gt;path);
&gt;  			if (ret)
&gt; -- 
&gt; 2.19.0
&gt; 
&gt; -- 
&gt; Aleksa Sarai
&gt; Senior Software Engineer (Containers)
&gt; SUSE Linux GmbH
&gt; &lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;
</span>




<a href="#m85e4ef7cc31f70b859e7112e14c624d1ce7b87ee" id="e85e4ef7cc31f70b859e7112e14c624d1ce7b87ee">^</a> <a href="https://lore.kernel.org/lkml/20181004173121.e6tfwd6nc2geuv5c@brauner.io/">permalink</a> <a href="https://lore.kernel.org/lkml/20181004173121.e6tfwd6nc2geuv5c@brauner.io/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181004173121.e6tfwd6nc2geuv5c@brauner.io/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181004173121.e6tfwd6nc2geuv5c@brauner.io/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181004173121.e6tfwd6nc2geuv5c@brauner.io/t/#u">nested</a>] <a href="#r85e4ef7cc31f70b859e7112e14c624d1ce7b87ee">53+ messages in thread</a></pre><hr><pre><a href="#e18be51e2a413ec671a98bf761c85a657651c0a3f" id="m18be51e2a413ec671a98bf761c85a657651c0a3f">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-04 16:26     ` <a href="#m1363e6020e3fcd93078ba4165aac2ccfb07ef4a5">Aleksa Sarai</a>
  2018-10-04 17:31       ` <a href="#m85e4ef7cc31f70b859e7112e14c624d1ce7b87ee">Christian Brauner</a>
<b>@ 2018-10-04 18:26       ` Jann Horn</b>
  2018-10-05 15:07         ` <a href="#m58349a7dd77014369e798bbf75c59baf77e64596">Aleksa Sarai</a>
  <a href="#r18be51e2a413ec671a98bf761c85a657651c0a3f">1 sibling, 1 reply; 53+ messages in thread</a>
From: Jann Horn @ 2018-10-04 18:26 UTC (<a href="https://lore.kernel.org/lkml/CAG48ez2u--Wac7d9n3idC92Pd-M40QzYtR6FKR8PAYr=VQHUBQ@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CAG48ez2u--Wac7d9n3idC92Pd-M40QzYtR6FKR8PAYr=VQHUBQ@mail.gmail.com/raw">raw</a>)
  To: cyphar
  Cc: Eric W. Biederman, jlayton, Bruce Fields, Al Viro, Arnd Bergmann,
	shuah, David Howells, Andy Lutomirski, christian, Tycho Andersen,
	kernel list, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers, Linux API

On Thu, Oct 4, 2018 at 6:26 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
<span>&gt; On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; &gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; &gt; the following:
&gt; &gt;
&gt; &gt; 1. You start the path walk and reach /A/B/C.
&gt; &gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; &gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; &gt; the process root, but you never actually encountered the process root,
&gt; &gt; so you don't notice.
&gt; &gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; &gt; outside the process root, but you don't notice.
&gt; &gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; &gt; successfully. You now have an fd pointing outside your chroot.
&gt;
&gt; I've been playing with this and I have the following patch, which
&gt; according to my testing protects against attacks where ".." skips over
&gt; nd-&gt;root. It abuses __d_path to figure out if nd-&gt;path can be resolved
&gt; from nd-&gt;root (obviously a proper version of this patch would refactor
&gt; __d_path so it could be used like this -- and would not return
&gt; -EMULTIHOP).
&gt;
&gt; I've also attached my reproducer. With it, I was seeing fairly constant
&gt; breakouts before this patch and after it I didn't see a single breakout
&gt; after running it overnight. Obviously this is not conclusive, but I'm
&gt; hoping that it can show what my idea for protecting against ".." was.
&gt;
&gt; Does this patch make sense? Or is there something wrong with it that I'm
&gt; not seeing?
&gt;
&gt; --8&lt;-------------------------------------------------------------------
&gt;
&gt; There is a fairly easy-to-exploit race condition with chroot(2) (and
&gt; thus by extension AT_THIS_ROOT and AT_BENEATH) where a rename(2) of a
&gt; path can be used to "skip over" nd-&gt;root and thus escape to the
&gt; filesystem above nd-&gt;root.
&gt;
&gt;   thread1 [attacker]:
&gt;     for (;;)
&gt;       renameat2(AT_FDCWD, "/a/b/c", AT_FDCWD, "/a/d", RENAME_EXCHANGE);
&gt;   thread2 [victim]:
&gt;     for (;;)
&gt;       openat(dirb, "b/c/../../etc/shadow", O_THISROOT);
&gt;
&gt; With fairly significant regularity, thread2 will resolve to
&gt; "/etc/shadow" rather than "/a/b/etc/shadow". With this patch, such cases
&gt; will be detected during ".." resolution (which is the weak point of
&gt; chroot(2) -- since walking *into* a subdirectory tautologically cannot
&gt; result in you walking *outside* nd-&gt;root).
&gt;
&gt; The use of __d_path here might seem suspect, however we don't mind if a
&gt; path is moved from within the chroot to outside the chroot and we
&gt; incorrectly decide it is safe (because at that point we are still within
&gt; the set of files which were accessible at the beginning of resolution).
&gt; However, we can fail resolution on the next path component if it remains
&gt; outside of the root. A path which has always been outside nd-&gt;root
&gt; during resolution will never be resolveable from nd-&gt;root and thus will
&gt; always be blocked.
&gt;
&gt; DO NOT MERGE: Currently this code returns -EMULTIHOP in this case,
&gt;               purely as a debugging measure (so that you can see that
&gt;               the protection actually does something). Obviously in the
&gt;               proper patch this will return -EXDEV.
&gt;
&gt; Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
&gt; ---
&gt;  fs/namei.c | 32 ++++++++++++++++++++++++++++++--
&gt;  1 file changed, 30 insertions(+), 2 deletions(-)
&gt;
&gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; index 6f995e6de6b1..c8349693d47b 100644
&gt; --- a/fs/namei.c
&gt; +++ b/fs/namei.c
&gt; @@ -53,8 +53,8 @@
&gt;   * The new code replaces the old recursive symlink resolution with
&gt;   * an iterative one (in case of non-nested symlink chains).  It does
&gt;   * this with calls to &lt;fs&gt;_follow_link().
&gt; - * As a side effect, dir_namei(), _namei() and follow_link() are now
&gt; - * replaced with a single function lookup_dentry() that can handle all
&gt; + * As a side effect, dir_namei(), _namei() and follow_link() are now
&gt; + * replaced with a single function lookup_dentry() that can handle all
&gt;   * the special cases of the former code.
&gt;   *
&gt;   * With the new dcache, the pathname is stored at each inode, at least as
&gt; @@ -1375,6 +1375,20 @@ static int follow_dotdot_rcu(struct nameidata *nd)
&gt;                                 return -EXDEV;
&gt;                         break;
&gt;                 }
&gt; +               if (unlikely(nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT))) {
&gt; +                       char *pathbuf, *pathptr;
&gt; +
&gt; +                       pathbuf = kmalloc(PATH_MAX, GFP_ATOMIC);
&gt; +                       if (!pathbuf)
&gt; +                               return -ECHILD;
&gt; +                       pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
&gt; +                       kfree(pathbuf);
&gt; +                       if (IS_ERR_OR_NULL(pathptr)) {
&gt; +                               if (!pathptr)
&gt; +                                       pathptr = ERR_PTR(-EMULTIHOP);
&gt; +                               return PTR_ERR(pathptr);
&gt; +                       }
&gt; +               }
</span>
One somewhat problematic thing about this approach is that if someone
tries to lookup
"a/a/a/a/a/a/a/a/a/a/[...]/../../../../../../../../../.." for some
reason, you'll have quadratic runtime: For each "..", you'll have to
walk up to the root.

<a href="#m18be51e2a413ec671a98bf761c85a657651c0a3f" id="e18be51e2a413ec671a98bf761c85a657651c0a3f">^</a> <a href="https://lore.kernel.org/lkml/CAG48ez2u--Wac7d9n3idC92Pd-M40QzYtR6FKR8PAYr=VQHUBQ@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CAG48ez2u--Wac7d9n3idC92Pd-M40QzYtR6FKR8PAYr=VQHUBQ@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CAG48ez2u--Wac7d9n3idC92Pd-M40QzYtR6FKR8PAYr=VQHUBQ@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CAG48ez2u--Wac7d9n3idC92Pd-M40QzYtR6FKR8PAYr=VQHUBQ@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CAG48ez2u--Wac7d9n3idC92Pd-M40QzYtR6FKR8PAYr=VQHUBQ@mail.gmail.com/t/#u">nested</a>] <a href="#r18be51e2a413ec671a98bf761c85a657651c0a3f">53+ messages in thread</a></pre><hr><pre><a href="#e58349a7dd77014369e798bbf75c59baf77e64596" id="m58349a7dd77014369e798bbf75c59baf77e64596">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-04 18:26       ` <a href="#m18be51e2a413ec671a98bf761c85a657651c0a3f">Jann Horn</a>
<b>@ 2018-10-05 15:07         ` Aleksa Sarai</b>
  2018-10-05 15:55           ` <a href="#m5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9">Jann Horn</a>
  <a href="#r58349a7dd77014369e798bbf75c59baf77e64596">0 siblings, 1 reply; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-05 15:07 UTC (<a href="https://lore.kernel.org/lkml/20181005150728.mgqnpkbukpeu3bsm@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181005150728.mgqnpkbukpeu3bsm@ryuk/raw">raw</a>)
  To: Jann Horn
  Cc: Eric W. Biederman, jlayton, Bruce Fields, Al Viro, Arnd Bergmann,
	shuah, David Howells, Andy Lutomirski, christian, Tycho Andersen,
	kernel list, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers, Linux API

<a href="https://lore.kernel.org/lkml/20181005150728.mgqnpkbukpeu3bsm@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 10352 bytes --]</a>

On 2018-10-04, Jann Horn &lt;jannh@google.com&gt; wrote:
<span>&gt; On Thu, Oct 4, 2018 at 6:26 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt; &gt; On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; &gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; &gt; &gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; &gt; &gt; the following:
&gt; &gt; &gt;
&gt; &gt; &gt; 1. You start the path walk and reach /A/B/C.
&gt; &gt; &gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; &gt; &gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; &gt; &gt; the process root, but you never actually encountered the process root,
&gt; &gt; &gt; so you don't notice.
&gt; &gt; &gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; &gt; &gt; outside the process root, but you don't notice.
&gt; &gt; &gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; &gt; &gt; successfully. You now have an fd pointing outside your chroot.
&gt; &gt;
&gt; &gt; I've been playing with this and I have the following patch, which
&gt; &gt; according to my testing protects against attacks where ".." skips over
&gt; &gt; nd-&gt;root. It abuses __d_path to figure out if nd-&gt;path can be resolved
&gt; &gt; from nd-&gt;root (obviously a proper version of this patch would refactor
&gt; &gt; __d_path so it could be used like this -- and would not return
&gt; &gt; -EMULTIHOP).
&gt; &gt;
&gt; &gt; I've also attached my reproducer. With it, I was seeing fairly constant
&gt; &gt; breakouts before this patch and after it I didn't see a single breakout
&gt; &gt; after running it overnight. Obviously this is not conclusive, but I'm
&gt; &gt; hoping that it can show what my idea for protecting against ".." was.
&gt; &gt;
&gt; &gt; Does this patch make sense? Or is there something wrong with it that I'm
&gt; &gt; not seeing?
&gt; &gt;
&gt; &gt; --8&lt;-------------------------------------------------------------------
&gt; &gt;
&gt; &gt; There is a fairly easy-to-exploit race condition with chroot(2) (and
&gt; &gt; thus by extension AT_THIS_ROOT and AT_BENEATH) where a rename(2) of a
&gt; &gt; path can be used to "skip over" nd-&gt;root and thus escape to the
&gt; &gt; filesystem above nd-&gt;root.
&gt; &gt;
&gt; &gt;   thread1 [attacker]:
&gt; &gt;     for (;;)
&gt; &gt;       renameat2(AT_FDCWD, "/a/b/c", AT_FDCWD, "/a/d", RENAME_EXCHANGE);
&gt; &gt;   thread2 [victim]:
&gt; &gt;     for (;;)
&gt; &gt;       openat(dirb, "b/c/../../etc/shadow", O_THISROOT);
&gt; &gt;
&gt; &gt; With fairly significant regularity, thread2 will resolve to
&gt; &gt; "/etc/shadow" rather than "/a/b/etc/shadow". With this patch, such cases
&gt; &gt; will be detected during ".." resolution (which is the weak point of
&gt; &gt; chroot(2) -- since walking *into* a subdirectory tautologically cannot
&gt; &gt; result in you walking *outside* nd-&gt;root).
&gt; &gt;
&gt; &gt; The use of __d_path here might seem suspect, however we don't mind if a
&gt; &gt; path is moved from within the chroot to outside the chroot and we
&gt; &gt; incorrectly decide it is safe (because at that point we are still within
&gt; &gt; the set of files which were accessible at the beginning of resolution).
&gt; &gt; However, we can fail resolution on the next path component if it remains
&gt; &gt; outside of the root. A path which has always been outside nd-&gt;root
&gt; &gt; during resolution will never be resolveable from nd-&gt;root and thus will
&gt; &gt; always be blocked.
&gt; &gt;
&gt; &gt; DO NOT MERGE: Currently this code returns -EMULTIHOP in this case,
&gt; &gt;               purely as a debugging measure (so that you can see that
&gt; &gt;               the protection actually does something). Obviously in the
&gt; &gt;               proper patch this will return -EXDEV.
&gt; &gt;
&gt; &gt; Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
&gt; &gt; ---
&gt; &gt;  fs/namei.c | 32 ++++++++++++++++++++++++++++++--
&gt; &gt;  1 file changed, 30 insertions(+), 2 deletions(-)
&gt; &gt;
&gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; index 6f995e6de6b1..c8349693d47b 100644
&gt; &gt; --- a/fs/namei.c
&gt; &gt; +++ b/fs/namei.c
&gt; &gt; @@ -53,8 +53,8 @@
&gt; &gt;   * The new code replaces the old recursive symlink resolution with
&gt; &gt;   * an iterative one (in case of non-nested symlink chains).  It does
&gt; &gt;   * this with calls to &lt;fs&gt;_follow_link().
&gt; &gt; - * As a side effect, dir_namei(), _namei() and follow_link() are now
&gt; &gt; - * replaced with a single function lookup_dentry() that can handle all
&gt; &gt; + * As a side effect, dir_namei(), _namei() and follow_link() are now
&gt; &gt; + * replaced with a single function lookup_dentry() that can handle all
&gt; &gt;   * the special cases of the former code.
&gt; &gt;   *
&gt; &gt;   * With the new dcache, the pathname is stored at each inode, at least as
&gt; &gt; @@ -1375,6 +1375,20 @@ static int follow_dotdot_rcu(struct nameidata *nd)
&gt; &gt;                                 return -EXDEV;
&gt; &gt;                         break;
&gt; &gt;                 }
&gt; &gt; +               if (unlikely(nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT))) {
&gt; &gt; +                       char *pathbuf, *pathptr;
&gt; &gt; +
&gt; &gt; +                       pathbuf = kmalloc(PATH_MAX, GFP_ATOMIC);
&gt; &gt; +                       if (!pathbuf)
&gt; &gt; +                               return -ECHILD;
&gt; &gt; +                       pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
&gt; &gt; +                       kfree(pathbuf);
&gt; &gt; +                       if (IS_ERR_OR_NULL(pathptr)) {
&gt; &gt; +                               if (!pathptr)
&gt; &gt; +                                       pathptr = ERR_PTR(-EMULTIHOP);
&gt; &gt; +                               return PTR_ERR(pathptr);
&gt; &gt; +                       }
&gt; &gt; +               }
&gt; 
&gt; One somewhat problematic thing about this approach is that if someone
&gt; tries to lookup
&gt; "a/a/a/a/a/a/a/a/a/a/[...]/../../../../../../../../../.." for some
&gt; reason, you'll have quadratic runtime: For each "..", you'll have to
&gt; walk up to the root.
</span>
What if we took rename_lock (call it nd-&gt;r_seq) at the start of the
resolution, and then only tried the __d_path-style check

  if (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
      read_seqretry(&amp;mount_lock, nd-&gt;m_seq))
	  /* do the __d_path lookup. */

That way you would only hit the slow path if there were concurrent
renames or mounts *and* you are doing a path resolution with
AT_THIS_ROOT or AT_BENEATH. I've attached a modified patch that does
this (and after some testing it also appears to work).

I'm not sure if there's a way to always avoid the quadratic lookup
without (significantly and probably unreasonably) changing how dcache
invalidation works. And obviously using this slow path if there was
_any_ rename on the _entire_ system is suboptimal, but I think it is a
significant improvement.

Another possibility is to expand on Andy's suggestion to use
/proc/$pid/root, and instead require AT_THIS_ROOT to use the root of a
namespace as its dirfd (I'm not sure if there's a trivial way to detect
this though). This wouldn't help with AT_BENEATH, but it should protect
against ".." shenanigans without any ".." handling changes. (This is
less ideal because it requires a container process, but it is another
way of dealing with the issue.)

---
 <a id="iZ2e.:..:20181005150728.mgqnpkbukpeu3bsm::40ryuk:1fs:namei.c" href="#Z2e.:..:20181005150728.mgqnpkbukpeu3bsm::40ryuk:1fs:namei.c">fs/namei.c</a> | 49 ++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 46 insertions(+), 3 deletions(-)

<span><a href="#iZ2e.:..:20181005150728.mgqnpkbukpeu3bsm::40ryuk:1fs:namei.c" id="Z2e.:..:20181005150728.mgqnpkbukpeu3bsm::40ryuk:1fs:namei.c">diff</a> --git a/fs/namei.c b/fs/namei.c
index 6f995e6de6b1..12c9be175cb4 100644
--- a/fs/namei.c
+++ b/fs/namei.c
</span><span>@@ -493,7 +493,7 @@</span> struct nameidata {
 	struct path	root;
 	struct inode	*inode; /* path.dentry.d_inode */
 	unsigned int	flags;
<span>-	unsigned	seq, m_seq;
</span><span>+	unsigned	seq, m_seq, r_seq;
</span> 	int		last_type;
 	unsigned	depth;
 	int		total_link_count;
<span>@@ -1375,6 +1375,27 @@</span> static int follow_dotdot_rcu(struct nameidata *nd)
 				return -EXDEV;
 			break;
 		}
<span>+		if (unlikely((nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT)) &amp;&amp;
+			     (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
+			      read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))) {
+			char *pathbuf, *pathptr;
+
+			nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
+			/* Cannot take m_seq here. */
+
+			pathbuf = kmalloc(PATH_MAX, GFP_ATOMIC);
+			if (!pathbuf)
+				return -ECHILD;
+			pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
+			kfree(pathbuf);
+			if (IS_ERR_OR_NULL(pathptr)) {
+				int error = PTR_ERR_OR_ZERO(pathptr);
+
+				if (!error)
+					error = nd_jump_root(nd);
+				return error;
+			}
+		}
</span> 		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
 			struct dentry *old = nd-&gt;path.dentry;
 			struct dentry *parent = old-&gt;d_parent;
<span>@@ -1510,6 +1531,27 @@</span> static int follow_dotdot(struct nameidata *nd)
 				return -EXDEV;
 			break;
 		}
<span>+		if (unlikely((nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT)) &amp;&amp;
+			     (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
+			      read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))) {
+			char *pathbuf, *pathptr;
+
+			nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
+			/* Cannot take m_seq here. */
+
+			pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
+			if (!pathbuf)
+				return -ENOMEM;
+			pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
+			kfree(pathbuf);
+			if (IS_ERR_OR_NULL(pathptr)) {
+				int error = PTR_ERR_OR_ZERO(pathptr);
+
+				if (!error)
+					error = nd_jump_root(nd);
+				return error;
+			}
+		}
</span> 		if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
 			int ret = path_parent_directory(&amp;nd-&gt;path);
 			if (ret)
<span>@@ -2269,6 +2311,9 @@</span> static const char *path_init(struct nameidata *nd, unsigned flags)
 	nd-&gt;last_type = LAST_ROOT; /* if there are only slashes... */
 	nd-&gt;flags = flags | LOOKUP_JUMPED | LOOKUP_PARENT;
 	nd-&gt;depth = 0;
<span>+	nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
+	nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
+
</span> 	if (flags &amp; LOOKUP_ROOT) {
 		struct dentry *root = nd-&gt;root.dentry;
 		struct inode *inode = root-&gt;d_inode;
<span>@@ -2279,7 +2324,6 @@</span> static const char *path_init(struct nameidata *nd, unsigned flags)
 		if (flags &amp; LOOKUP_RCU) {
 			nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);
 			nd-&gt;root_seq = nd-&gt;seq;
<span>-			nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
</span> 		} else {
 			path_get(&amp;nd-&gt;path);
 		}
<span>@@ -2290,7 +2334,6 @@</span> static const char *path_init(struct nameidata *nd, unsigned flags)
 	nd-&gt;path.mnt = NULL;
 	nd-&gt;path.dentry = NULL;
 
<span>-	nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
</span> 	if (unlikely(flags &amp; (LOOKUP_CHROOT | LOOKUP_XDEV))) {
 		error = dirfd_path_init(nd);
 		if (unlikely(error))
-- 
2.19.0


-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181005150728.mgqnpkbukpeu3bsm@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#m58349a7dd77014369e798bbf75c59baf77e64596" id="e58349a7dd77014369e798bbf75c59baf77e64596">^</a> <a href="https://lore.kernel.org/lkml/20181005150728.mgqnpkbukpeu3bsm@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181005150728.mgqnpkbukpeu3bsm@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181005150728.mgqnpkbukpeu3bsm@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181005150728.mgqnpkbukpeu3bsm@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181005150728.mgqnpkbukpeu3bsm@ryuk/t/#u">nested</a>] <a href="#r58349a7dd77014369e798bbf75c59baf77e64596">53+ messages in thread</a></pre><hr><pre><a href="#e5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9" id="m5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-05 15:07         ` <a href="#m58349a7dd77014369e798bbf75c59baf77e64596">Aleksa Sarai</a>
<b>@ 2018-10-05 15:55           ` Jann Horn</b>
  2018-10-06  2:10             ` <a href="#mef6f237463d6f0d3748b2fccb1bef7afa5f85339">Aleksa Sarai</a>
  <a href="#r5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9">0 siblings, 1 reply; 53+ messages in thread</a>
From: Jann Horn @ 2018-10-05 15:55 UTC (<a href="https://lore.kernel.org/lkml/CAG48ez3FG0axt92F=+vDe1Q=kj-YngmCgFqDET7E2xCE1mOgeg@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CAG48ez3FG0axt92F=+vDe1Q=kj-YngmCgFqDET7E2xCE1mOgeg@mail.gmail.com/raw">raw</a>)
  To: cyphar, Eric W. Biederman, Al Viro
  Cc: jlayton, Bruce Fields, Arnd Bergmann, shuah, David Howells,
	Andy Lutomirski, christian, Tycho Andersen, kernel list,
	linux-fsdevel, linux-arch, linux-kselftest, dev, containers,
	Linux API

On Fri, Oct 5, 2018 at 5:07 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
<span>&gt; On 2018-10-04, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; On Thu, Oct 4, 2018 at 6:26 PM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
&gt; &gt; &gt; On 2018-09-29, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; &gt; &gt; You attempt to open "C/../../etc/passwd" under the root "/A/B".
&gt; &gt; &gt; &gt; Something else concurrently moves /A/B/C to /A/C. This can result in
&gt; &gt; &gt; &gt; the following:
&gt; &gt; &gt; &gt;
&gt; &gt; &gt; &gt; 1. You start the path walk and reach /A/B/C.
&gt; &gt; &gt; &gt; 2. The other process moves /A/B/C to /A/C. Your path walk is now at /A/C.
&gt; &gt; &gt; &gt; 3. Your path walk follows the first ".." up into /A. This is outside
&gt; &gt; &gt; &gt; the process root, but you never actually encountered the process root,
&gt; &gt; &gt; &gt; so you don't notice.
&gt; &gt; &gt; &gt; 4. Your path walk follows the second ".." up to /. Again, this is
&gt; &gt; &gt; &gt; outside the process root, but you don't notice.
&gt; &gt; &gt; &gt; 5. Your path walk walks down to /etc/passwd, and the open completes
&gt; &gt; &gt; &gt; successfully. You now have an fd pointing outside your chroot.
&gt; &gt; &gt;
&gt; &gt; &gt; I've been playing with this and I have the following patch, which
&gt; &gt; &gt; according to my testing protects against attacks where ".." skips over
&gt; &gt; &gt; nd-&gt;root. It abuses __d_path to figure out if nd-&gt;path can be resolved
&gt; &gt; &gt; from nd-&gt;root (obviously a proper version of this patch would refactor
&gt; &gt; &gt; __d_path so it could be used like this -- and would not return
&gt; &gt; &gt; -EMULTIHOP).
&gt; &gt; &gt;
&gt; &gt; &gt; I've also attached my reproducer. With it, I was seeing fairly constant
&gt; &gt; &gt; breakouts before this patch and after it I didn't see a single breakout
&gt; &gt; &gt; after running it overnight. Obviously this is not conclusive, but I'm
&gt; &gt; &gt; hoping that it can show what my idea for protecting against ".." was.
&gt; &gt; &gt;
&gt; &gt; &gt; Does this patch make sense? Or is there something wrong with it that I'm
&gt; &gt; &gt; not seeing?
&gt; &gt; &gt;
&gt; &gt; &gt; --8&lt;-------------------------------------------------------------------
&gt; &gt; &gt;
&gt; &gt; &gt; There is a fairly easy-to-exploit race condition with chroot(2) (and
&gt; &gt; &gt; thus by extension AT_THIS_ROOT and AT_BENEATH) where a rename(2) of a
&gt; &gt; &gt; path can be used to "skip over" nd-&gt;root and thus escape to the
&gt; &gt; &gt; filesystem above nd-&gt;root.
&gt; &gt; &gt;
&gt; &gt; &gt;   thread1 [attacker]:
&gt; &gt; &gt;     for (;;)
&gt; &gt; &gt;       renameat2(AT_FDCWD, "/a/b/c", AT_FDCWD, "/a/d", RENAME_EXCHANGE);
&gt; &gt; &gt;   thread2 [victim]:
&gt; &gt; &gt;     for (;;)
&gt; &gt; &gt;       openat(dirb, "b/c/../../etc/shadow", O_THISROOT);
&gt; &gt; &gt;
&gt; &gt; &gt; With fairly significant regularity, thread2 will resolve to
&gt; &gt; &gt; "/etc/shadow" rather than "/a/b/etc/shadow". With this patch, such cases
&gt; &gt; &gt; will be detected during ".." resolution (which is the weak point of
&gt; &gt; &gt; chroot(2) -- since walking *into* a subdirectory tautologically cannot
&gt; &gt; &gt; result in you walking *outside* nd-&gt;root).
&gt; &gt; &gt;
&gt; &gt; &gt; The use of __d_path here might seem suspect, however we don't mind if a
&gt; &gt; &gt; path is moved from within the chroot to outside the chroot and we
&gt; &gt; &gt; incorrectly decide it is safe (because at that point we are still within
&gt; &gt; &gt; the set of files which were accessible at the beginning of resolution).
&gt; &gt; &gt; However, we can fail resolution on the next path component if it remains
&gt; &gt; &gt; outside of the root. A path which has always been outside nd-&gt;root
&gt; &gt; &gt; during resolution will never be resolveable from nd-&gt;root and thus will
&gt; &gt; &gt; always be blocked.
&gt; &gt; &gt;
&gt; &gt; &gt; DO NOT MERGE: Currently this code returns -EMULTIHOP in this case,
&gt; &gt; &gt;               purely as a debugging measure (so that you can see that
&gt; &gt; &gt;               the protection actually does something). Obviously in the
&gt; &gt; &gt;               proper patch this will return -EXDEV.
&gt; &gt; &gt;
&gt; &gt; &gt; Signed-off-by: Aleksa Sarai &lt;cyphar@cyphar.com&gt;
&gt; &gt; &gt; ---
&gt; &gt; &gt;  fs/namei.c | 32 ++++++++++++++++++++++++++++++--
&gt; &gt; &gt;  1 file changed, 30 insertions(+), 2 deletions(-)
&gt; &gt; &gt;
&gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; index 6f995e6de6b1..c8349693d47b 100644
&gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; @@ -53,8 +53,8 @@
&gt; &gt; &gt;   * The new code replaces the old recursive symlink resolution with
&gt; &gt; &gt;   * an iterative one (in case of non-nested symlink chains).  It does
&gt; &gt; &gt;   * this with calls to &lt;fs&gt;_follow_link().
&gt; &gt; &gt; - * As a side effect, dir_namei(), _namei() and follow_link() are now
&gt; &gt; &gt; - * replaced with a single function lookup_dentry() that can handle all
&gt; &gt; &gt; + * As a side effect, dir_namei(), _namei() and follow_link() are now
&gt; &gt; &gt; + * replaced with a single function lookup_dentry() that can handle all
&gt; &gt; &gt;   * the special cases of the former code.
&gt; &gt; &gt;   *
&gt; &gt; &gt;   * With the new dcache, the pathname is stored at each inode, at least as
&gt; &gt; &gt; @@ -1375,6 +1375,20 @@ static int follow_dotdot_rcu(struct nameidata *nd)
&gt; &gt; &gt;                                 return -EXDEV;
&gt; &gt; &gt;                         break;
&gt; &gt; &gt;                 }
&gt; &gt; &gt; +               if (unlikely(nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT))) {
&gt; &gt; &gt; +                       char *pathbuf, *pathptr;
&gt; &gt; &gt; +
&gt; &gt; &gt; +                       pathbuf = kmalloc(PATH_MAX, GFP_ATOMIC);
&gt; &gt; &gt; +                       if (!pathbuf)
&gt; &gt; &gt; +                               return -ECHILD;
&gt; &gt; &gt; +                       pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
&gt; &gt; &gt; +                       kfree(pathbuf);
&gt; &gt; &gt; +                       if (IS_ERR_OR_NULL(pathptr)) {
&gt; &gt; &gt; +                               if (!pathptr)
&gt; &gt; &gt; +                                       pathptr = ERR_PTR(-EMULTIHOP);
&gt; &gt; &gt; +                               return PTR_ERR(pathptr);
&gt; &gt; &gt; +                       }
&gt; &gt; &gt; +               }
&gt; &gt;
&gt; &gt; One somewhat problematic thing about this approach is that if someone
&gt; &gt; tries to lookup
&gt; &gt; "a/a/a/a/a/a/a/a/a/a/[...]/../../../../../../../../../.." for some
&gt; &gt; reason, you'll have quadratic runtime: For each "..", you'll have to
&gt; &gt; walk up to the root.
&gt;
&gt; What if we took rename_lock (call it nd-&gt;r_seq) at the start of the
&gt; resolution, and then only tried the __d_path-style check
&gt;
&gt;   if (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
&gt;       read_seqretry(&amp;mount_lock, nd-&gt;m_seq))
&gt;           /* do the __d_path lookup. */
&gt;
&gt; That way you would only hit the slow path if there were concurrent
&gt; renames or mounts *and* you are doing a path resolution with
&gt; AT_THIS_ROOT or AT_BENEATH. I've attached a modified patch that does
&gt; this (and after some testing it also appears to work).
</span>
Yeah, I think that might do the job.

<span>&gt; I'm not sure if there's a way to always avoid the quadratic lookup
&gt; without (significantly and probably unreasonably) changing how dcache
&gt; invalidation works. And obviously using this slow path if there was
&gt; _any_ rename on the _entire_ system is suboptimal, but I think it is a
&gt; significant improvement.
</span>
Yeah, I think this is much better.

<span>&gt; Another possibility is to expand on Andy's suggestion to use
&gt; /proc/$pid/root, and instead require AT_THIS_ROOT to use the root of a
&gt; namespace as its dirfd (I'm not sure if there's a trivial way to detect
&gt; this though). This wouldn't help with AT_BENEATH, but it should protect
&gt; against ".." shenanigans without any ".." handling changes. (This is
&gt; less ideal because it requires a container process, but it is another
&gt; way of dealing with the issue.)
</span>
(For container usecases, but not for a web server that uses AT_BENEATH.)

<span>&gt; ---
&gt;  fs/namei.c | 49 ++++++++++++++++++++++++++++++++++++++++++++++---
&gt;  1 file changed, 46 insertions(+), 3 deletions(-)
&gt;
&gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; index 6f995e6de6b1..12c9be175cb4 100644
&gt; --- a/fs/namei.c
&gt; +++ b/fs/namei.c
&gt; @@ -493,7 +493,7 @@ struct nameidata {
&gt;         struct path     root;
&gt;         struct inode    *inode; /* path.dentry.d_inode */
&gt;         unsigned int    flags;
&gt; -       unsigned        seq, m_seq;
&gt; +       unsigned        seq, m_seq, r_seq;
&gt;         int             last_type;
&gt;         unsigned        depth;
&gt;         int             total_link_count;
&gt; @@ -1375,6 +1375,27 @@ static int follow_dotdot_rcu(struct nameidata *nd)
&gt;                                 return -EXDEV;
&gt;                         break;
&gt;                 }
&gt; +               if (unlikely((nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT)) &amp;&amp;
&gt; +                            (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
&gt; +                             read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))) {
&gt; +                       char *pathbuf, *pathptr;
&gt; +
&gt; +                       nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
&gt; +                       /* Cannot take m_seq here. */
&gt; +
&gt; +                       pathbuf = kmalloc(PATH_MAX, GFP_ATOMIC);
&gt; +                       if (!pathbuf)
&gt; +                               return -ECHILD;
&gt; +                       pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
&gt; +                       kfree(pathbuf);
</span>
You're doing this check before actually looking up the parent, right?
So as long as I don't trigger the "path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)"
check that you do for O_BENEATH, escaping up by one level is possible,
right? You should probably move this check so that it happens after
following "..".

(Also: I assume that you're going to get rid of that memory allocation
in a future version.)

<span>&gt; +                       if (IS_ERR_OR_NULL(pathptr)) {
&gt; +                               int error = PTR_ERR_OR_ZERO(pathptr);
&gt; +
&gt; +                               if (!error)
&gt; +                                       error = nd_jump_root(nd);
&gt; +                               return error;
&gt; +                       }
&gt; +               }
&gt;                 if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
&gt;                         struct dentry *old = nd-&gt;path.dentry;
&gt;                         struct dentry *parent = old-&gt;d_parent;
&gt; @@ -1510,6 +1531,27 @@ static int follow_dotdot(struct nameidata *nd)
&gt;                                 return -EXDEV;
&gt;                         break;
&gt;                 }
&gt; +               if (unlikely((nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT)) &amp;&amp;
&gt; +                            (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
&gt; +                             read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))) {
&gt; +                       char *pathbuf, *pathptr;
&gt; +
&gt; +                       nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
&gt; +                       /* Cannot take m_seq here. */
&gt; +
&gt; +                       pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);
&gt; +                       if (!pathbuf)
&gt; +                               return -ENOMEM;
&gt; +                       pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
&gt; +                       kfree(pathbuf);
&gt; +                       if (IS_ERR_OR_NULL(pathptr)) {
&gt; +                               int error = PTR_ERR_OR_ZERO(pathptr);
&gt; +
&gt; +                               if (!error)
&gt; +                                       error = nd_jump_root(nd);
&gt; +                               return error;
&gt; +                       }
&gt; +               }
</span>
Same problem as in the RCU case above.

<span>&gt;                 if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
&gt;                         int ret = path_parent_directory(&amp;nd-&gt;path);
&gt;                         if (ret)
&gt; @@ -2269,6 +2311,9 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
&gt;         nd-&gt;last_type = LAST_ROOT; /* if there are only slashes... */
&gt;         nd-&gt;flags = flags | LOOKUP_JUMPED | LOOKUP_PARENT;
&gt;         nd-&gt;depth = 0;
&gt; +       nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
&gt; +       nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
</span>
This means that now, attempting to perform a lookup while something is
holding the rename_lock will spin on the lock. I don't know whether
that's a problem in practice though. Does anyone on this thread know
whether this is problematic?

<a href="#m5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9" id="e5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9">^</a> <a href="https://lore.kernel.org/lkml/CAG48ez3FG0axt92F=+vDe1Q=kj-YngmCgFqDET7E2xCE1mOgeg@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CAG48ez3FG0axt92F=+vDe1Q=kj-YngmCgFqDET7E2xCE1mOgeg@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CAG48ez3FG0axt92F=+vDe1Q=kj-YngmCgFqDET7E2xCE1mOgeg@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CAG48ez3FG0axt92F=+vDe1Q=kj-YngmCgFqDET7E2xCE1mOgeg@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CAG48ez3FG0axt92F=+vDe1Q=kj-YngmCgFqDET7E2xCE1mOgeg@mail.gmail.com/t/#u">nested</a>] <a href="#r5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9">53+ messages in thread</a></pre><hr><pre><a href="#eef6f237463d6f0d3748b2fccb1bef7afa5f85339" id="mef6f237463d6f0d3748b2fccb1bef7afa5f85339">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-05 15:55           ` <a href="#m5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9">Jann Horn</a>
<b>@ 2018-10-06  2:10             ` Aleksa Sarai</b>
  2018-10-08 10:50               ` <a href="#m4c795d3247c020bd39ddd7208adb99113fe8d8da">Jann Horn</a>
  <a href="#ref6f237463d6f0d3748b2fccb1bef7afa5f85339">0 siblings, 1 reply; 53+ messages in thread</a>
From: Aleksa Sarai @ 2018-10-06  2:10 UTC (<a href="https://lore.kernel.org/lkml/20181006021002.6vzsdwd3klddbmji@ryuk/">permalink</a> / <a href="https://lore.kernel.org/lkml/20181006021002.6vzsdwd3klddbmji@ryuk/raw">raw</a>)
  To: Jann Horn
  Cc: Eric W. Biederman, Al Viro, jlayton, Bruce Fields, Arnd Bergmann,
	shuah, David Howells, Andy Lutomirski, christian, Tycho Andersen,
	kernel list, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers, cyphar@cyphar.com Linux API

<a href="https://lore.kernel.org/lkml/20181006021002.6vzsdwd3klddbmji@ryuk/1-a.txt">[-- Attachment #1: Type: text/plain, Size: 3987 bytes --]</a>

On 2018-10-05, Jann Horn &lt;jannh@google.com&gt; wrote:
<span>&gt; &gt; What if we took rename_lock (call it nd-&gt;r_seq) at the start of the
&gt; &gt; resolution, and then only tried the __d_path-style check
&gt; &gt;
&gt; &gt;   if (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
&gt; &gt;       read_seqretry(&amp;mount_lock, nd-&gt;m_seq))
&gt; &gt;           /* do the __d_path lookup. */
&gt; &gt;
&gt; &gt; That way you would only hit the slow path if there were concurrent
&gt; &gt; renames or mounts *and* you are doing a path resolution with
&gt; &gt; AT_THIS_ROOT or AT_BENEATH. I've attached a modified patch that does
&gt; &gt; this (and after some testing it also appears to work).
&gt; 
&gt; Yeah, I think that might do the job.
</span>
*phew* I was all out of other ideas. :P

<span>&gt; &gt; ---
&gt; &gt;  fs/namei.c | 49 ++++++++++++++++++++++++++++++++++++++++++++++---
&gt; &gt;  1 file changed, 46 insertions(+), 3 deletions(-)
&gt; &gt;
&gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; index 6f995e6de6b1..12c9be175cb4 100644
&gt; &gt; --- a/fs/namei.c
&gt; &gt; +++ b/fs/namei.c
&gt; &gt; @@ -493,7 +493,7 @@ struct nameidata {
&gt; &gt;         struct path     root;
&gt; &gt;         struct inode    *inode; /* path.dentry.d_inode */
&gt; &gt;         unsigned int    flags;
&gt; &gt; -       unsigned        seq, m_seq;
&gt; &gt; +       unsigned        seq, m_seq, r_seq;
&gt; &gt;         int             last_type;
&gt; &gt;         unsigned        depth;
&gt; &gt;         int             total_link_count;
&gt; &gt; @@ -1375,6 +1375,27 @@ static int follow_dotdot_rcu(struct nameidata *nd)
&gt; &gt;                                 return -EXDEV;
&gt; &gt;                         break;
&gt; &gt;                 }
&gt; &gt; +               if (unlikely((nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT)) &amp;&amp;
&gt; &gt; +                            (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
&gt; &gt; +                             read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))) {
&gt; &gt; +                       char *pathbuf, *pathptr;
&gt; &gt; +
&gt; &gt; +                       nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
&gt; &gt; +                       /* Cannot take m_seq here. */
&gt; &gt; +
&gt; &gt; +                       pathbuf = kmalloc(PATH_MAX, GFP_ATOMIC);
&gt; &gt; +                       if (!pathbuf)
&gt; &gt; +                               return -ECHILD;
&gt; &gt; +                       pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
&gt; &gt; +                       kfree(pathbuf);
&gt; 
&gt; You're doing this check before actually looking up the parent, right?
&gt; So as long as I don't trigger the "path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)"
&gt; check that you do for O_BENEATH, escaping up by one level is possible,
&gt; right? You should probably move this check so that it happens after
&gt; following "..".
</span>
Yup, you're right. I'll do that.

<span>&gt; (Also: I assume that you're going to get rid of that memory allocation
&gt; in a future version.)
</span>
Sure. Would you prefer adding some scratch space in nameidata, or that I
change __d_path so it accepts NULL as the buffer (and thus it doesn't
actually do any string operations)?

<span>&gt; &gt;                 if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
&gt; &gt;                         int ret = path_parent_directory(&amp;nd-&gt;path);
&gt; &gt;                         if (ret)
&gt; &gt; @@ -2269,6 +2311,9 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
&gt; &gt;         nd-&gt;last_type = LAST_ROOT; /* if there are only slashes... */
&gt; &gt;         nd-&gt;flags = flags | LOOKUP_JUMPED | LOOKUP_PARENT;
&gt; &gt;         nd-&gt;depth = 0;
&gt; &gt; +       nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
&gt; &gt; +       nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
&gt; 
&gt; This means that now, attempting to perform a lookup while something is
&gt; holding the rename_lock will spin on the lock. I don't know whether
&gt; that's a problem in practice though. Does anyone on this thread know
&gt; whether this is problematic?
</span>
I could make it so that we only take &amp;rename_lock
  if (nd-&gt;flags &amp; (FOLLOW_BENEATH | FOLLOW_CHROOT)),
since it's not used outside of that path.

-- 
Aleksa Sarai
Senior Software Engineer (Containers)
SUSE Linux GmbH
&lt;<a href="https://www.cyphar.com/">https://www.cyphar.com/</a>&gt;

<a href="https://lore.kernel.org/lkml/20181006021002.6vzsdwd3klddbmji@ryuk/2-signature.asc">[-- Attachment #2: signature.asc --]
[-- Type: application/pgp-signature, Size: 833 bytes --]</a>

<a href="#mef6f237463d6f0d3748b2fccb1bef7afa5f85339" id="eef6f237463d6f0d3748b2fccb1bef7afa5f85339">^</a> <a href="https://lore.kernel.org/lkml/20181006021002.6vzsdwd3klddbmji@ryuk/">permalink</a> <a href="https://lore.kernel.org/lkml/20181006021002.6vzsdwd3klddbmji@ryuk/raw">raw</a> <a href="https://lore.kernel.org/lkml/20181006021002.6vzsdwd3klddbmji@ryuk/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/20181006021002.6vzsdwd3klddbmji@ryuk/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/20181006021002.6vzsdwd3klddbmji@ryuk/t/#u">nested</a>] <a href="#ref6f237463d6f0d3748b2fccb1bef7afa5f85339">53+ messages in thread</a></pre><hr><pre><a href="#e30776acf058e9ccb26876491eaf5ecb147104ad1" id="m30776acf058e9ccb26876491eaf5ecb147104ad1">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-02  7:32         ` <a href="#m304562dd58656fd5ce4cf51430201c473d7baa4f">Aleksa Sarai</a>
  2018-10-03 22:09           ` <a href="#m8fbac970df152ad10bbac3ed851b557cf300dee8">Andy Lutomirski</a>
<b>@ 2018-10-06 20:56           ` Florian Weimer</b>
  2018-10-06 21:49             ` <a href="#m74e9eec1d0fc221f91ceff157e299f934b825964">Christian Brauner</a>
  <a href="#r30776acf058e9ccb26876491eaf5ecb147104ad1">1 sibling, 1 reply; 53+ messages in thread</a>
From: Florian Weimer @ 2018-10-06 20:56 UTC (<a href="https://lore.kernel.org/lkml/875zyeg5fs.fsf@mid.deneb.enyo.de/">permalink</a> / <a href="https://lore.kernel.org/lkml/875zyeg5fs.fsf@mid.deneb.enyo.de/raw">raw</a>)
  To: Aleksa Sarai
  Cc: Andy Lutomirski, Jann Horn, Eric W. Biederman, jlayton,
	Bruce Fields, Al Viro, Arnd Bergmann, shuah, David Howells,
	Andy Lutomirski, christian, Tycho Andersen, kernel list,
	linux-fsdevel, linux-arch, linux-kselftest, dev, containers,
	Linux API

* Aleksa Sarai:

<span>&gt; On 2018-10-01, Andy Lutomirski &lt;luto@amacapital.net&gt; wrote:
&gt;&gt; &gt;&gt;&gt; Currently most container runtimes try to do this resolution in
&gt;&gt; &gt;&gt;&gt; userspace[1], causing many potential race conditions. In addition, the
&gt;&gt; &gt;&gt;&gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt;&gt; &gt;&gt;&gt; requires a fork+exec which is *very* costly if necessary for every
&gt;&gt; &gt;&gt;&gt; filesystem operation involving a container.
&gt;&gt; &gt;&gt; 
&gt;&gt; &gt;&gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt;&gt; &gt;&gt; a full fork() either, clone() lets you do this with some process parts
&gt;&gt; &gt;&gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt;&gt; &gt;&gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt;&gt; &gt;&gt; wouldn't you want to use setns()?
&gt;&gt; &gt; 
&gt;&gt; &gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt;&gt; &gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt;&gt; &gt; broken runtime state). So you're forced to do fork+exec (which then
&gt;&gt; &gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt;&gt; &gt; for CLONE_VFORK.
&gt;&gt; 
&gt;&gt; I must admit that Im not very sympathetic to the argument that Gos
&gt;&gt; runtime model is incompatible with the simpler solution.
&gt;
&gt; Multi-threaded programs have a similar issue (though with Go it's much
&gt; worse). If you fork a multi-threaded C program then you can only safely
&gt; use AS-Safe glibc functions (those that are safe within a signal
&gt; handler). But if you're just doing three syscalls this shouldn't be as
&gt; big of a problem as Go where you can't even do said syscalls.
</span>
The situation is a bit more complicated.  There are many programs out
there which use malloc and free (at least indirectly) after a fork,
and we cannot break them.  In glibc, we have a couple of subsystems
which are put into a known state before calling the fork/clone system
call if the application calls fork.  The price we pay for that is a
fork which is not POSIX-compliant because it is not async-signal-safe.
Admittedly, other libcs chose different trade-offs.

However, what is the same across libcs is this: You cannot call the
clone system call directly and get a fully working new process.  Some
things break.  For example, for recursive mutexes, we need to know the
TID of the current thread, and we cannot perform a system call to get
it for performance reasons.  So everyone has a TID cache for that.
But the TID cache does not get reset when you bypass the fork
implementation in libc, so you end up with subtle corruption bugs on
TID reuse.

So I'd say that in most cases, the C situation is pretty much the same
as the Go situation.  If I recall correctly, the problem for Go is
that it cannot call setns from Go code because it fails in the kernel
for multi-threaded processes, and Go processes are already
multi-threaded when user Go code runs.

<a href="#m30776acf058e9ccb26876491eaf5ecb147104ad1" id="e30776acf058e9ccb26876491eaf5ecb147104ad1">^</a> <a href="https://lore.kernel.org/lkml/875zyeg5fs.fsf@mid.deneb.enyo.de/">permalink</a> <a href="https://lore.kernel.org/lkml/875zyeg5fs.fsf@mid.deneb.enyo.de/raw">raw</a> <a href="https://lore.kernel.org/lkml/875zyeg5fs.fsf@mid.deneb.enyo.de/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/875zyeg5fs.fsf@mid.deneb.enyo.de/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/875zyeg5fs.fsf@mid.deneb.enyo.de/t/#u">nested</a>] <a href="#r30776acf058e9ccb26876491eaf5ecb147104ad1">53+ messages in thread</a></pre><hr><pre><a href="#e74e9eec1d0fc221f91ceff157e299f934b825964" id="m74e9eec1d0fc221f91ceff157e299f934b825964">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-06 20:56           ` <a href="#m30776acf058e9ccb26876491eaf5ecb147104ad1">Florian Weimer</a>
<b>@ 2018-10-06 21:49             ` Christian Brauner</b>
  <a href="#r74e9eec1d0fc221f91ceff157e299f934b825964">0 siblings, 0 replies; 53+ messages in thread</a>
From: Christian Brauner @ 2018-10-06 21:49 UTC (<a href="https://lore.kernel.org/lkml/CAHrFyr7213j+dEuKvSg9HFRMec3VK7hubJXCpQrWN+erTJ9hWw@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CAHrFyr7213j+dEuKvSg9HFRMec3VK7hubJXCpQrWN+erTJ9hWw@mail.gmail.com/raw">raw</a>)
  To: fw
  Cc: Aleksa Sarai, luto, Jann Horn, Eric W . Biederman, Jeff Layton,
	J. Bruce Fields, Al Viro, Arnd Bergmann, Shuah Khan,
	David Howells, Andy Lutomirski, Tycho Andersen, LKML,
	linux-fsdevel, linux-arch, linux-kselftest, dev,
	Linux Containers, Linux API

On Sat, Oct 6, 2018 at 10:56 PM Florian Weimer &lt;fw@deneb.enyo.de&gt; wrote:
<span>&gt;
&gt; * Aleksa Sarai:
&gt;
&gt; &gt; On 2018-10-01, Andy Lutomirski &lt;luto@amacapital.net&gt; wrote:
&gt; &gt;&gt; &gt;&gt;&gt; Currently most container runtimes try to do this resolution in
&gt; &gt;&gt; &gt;&gt;&gt; userspace[1], causing many potential race conditions. In addition, the
&gt; &gt;&gt; &gt;&gt;&gt; "obvious" alternative (actually performing a {ch,pivot_}root(2))
&gt; &gt;&gt; &gt;&gt;&gt; requires a fork+exec which is *very* costly if necessary for every
&gt; &gt;&gt; &gt;&gt;&gt; filesystem operation involving a container.
&gt; &gt;&gt; &gt;&gt;
&gt; &gt;&gt; &gt;&gt; Wait. fork() I understand, but why exec? And actually, you don't need
&gt; &gt;&gt; &gt;&gt; a full fork() either, clone() lets you do this with some process parts
&gt; &gt;&gt; &gt;&gt; shared. And then you also shouldn't need to use SCM_RIGHTS, just keep
&gt; &gt;&gt; &gt;&gt; the file descriptor table shared. And why chroot()/pivot_root(),
&gt; &gt;&gt; &gt;&gt; wouldn't you want to use setns()?
&gt; &gt;&gt; &gt;
&gt; &gt;&gt; &gt; You're right about this -- for C runtimes. In Go we cannot do a raw
&gt; &gt;&gt; &gt; clone() or fork() (if you do it manually with RawSyscall you'll end with
&gt; &gt;&gt; &gt; broken runtime state). So you're forced to do fork+exec (which then
&gt; &gt;&gt; &gt; means that you can't use CLONE_FILES and must use SCM_RIGHTS). Same goes
&gt; &gt;&gt; &gt; for CLONE_VFORK.
&gt; &gt;&gt;
&gt; &gt;&gt; I must admit that Im not very sympathetic to the argument that Gos
&gt; &gt;&gt; runtime model is incompatible with the simpler solution.
&gt; &gt;
&gt; &gt; Multi-threaded programs have a similar issue (though with Go it's much
&gt; &gt; worse). If you fork a multi-threaded C program then you can only safely
&gt; &gt; use AS-Safe glibc functions (those that are safe within a signal
&gt; &gt; handler). But if you're just doing three syscalls this shouldn't be as
&gt; &gt; big of a problem as Go where you can't even do said syscalls.
&gt;
&gt; The situation is a bit more complicated.  There are many programs out
&gt; there which use malloc and free (at least indirectly) after a fork,
&gt; and we cannot break them.  In glibc, we have a couple of subsystems
&gt; which are put into a known state before calling the fork/clone system
&gt; call if the application calls fork.  The price we pay for that is a
&gt; fork which is not POSIX-compliant because it is not async-signal-safe.
&gt; Admittedly, other libcs chose different trade-offs.
&gt;
&gt; However, what is the same across libcs is this: You cannot call the
&gt; clone system call directly and get a fully working new process.  Some
&gt; things break.  For example, for recursive mutexes, we need to know the
&gt; TID of the current thread, and we cannot perform a system call to get
&gt; it for performance reasons.  So everyone has a TID cache for that.
&gt; But the TID cache does not get reset when you bypass the fork
&gt; implementation in libc, so you end up with subtle corruption bugs on
&gt; TID reuse.
</span>
Sure, but recursive mutexes etc. are very specific use-case.
I'd even go so far to say that if you use mutexes + threads and then
also fork in those threads you're hosed anyway. If you don't things get a little
cleaner assuming you don't call library functions that use mutexes
internally.
Event then you might (sometimes at least) still get around most problems
with atfork handlers (thought I really don't like him). But you know more
about this then I do. :)

<span>&gt;
&gt; So I'd say that in most cases, the C situation is pretty much the same
&gt; as the Go situation.  If I recall correctly, the problem for Go is
&gt; that it cannot call setns from Go code because it fails in the kernel
&gt; for multi-threaded processes, and Go processes are already
&gt; multi-threaded when user Go code runs.
</span>
That is true for *some* namespaces (user, mount) but not for all.
For example, setns(CLONE_NEWNET) would be fine from go.
But the go runtime thinks it's clever to clone a new thread in between
entry and exit of a syscall. If you switch namespaces you might end
up with a new thread that belongs to the wrong namespace which is
very problematic.
So you can either rely on calling some go magic that locks
you to a specific os thread but that does only work in later go versions or
you go the constructor route, i.e. you e.g. implement a (dummy)
subcommand that you can call and that triggers the execution of a
C function that is marked with __attribute__((constructor)) that runs
before the go runtime and in which you can do setns(), fork() and
friends (somewhat) safely. This has very
bad performance and is a nasty hack but it's really unavoidable.

<a href="#m74e9eec1d0fc221f91ceff157e299f934b825964" id="e74e9eec1d0fc221f91ceff157e299f934b825964">^</a> <a href="https://lore.kernel.org/lkml/CAHrFyr7213j+dEuKvSg9HFRMec3VK7hubJXCpQrWN+erTJ9hWw@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CAHrFyr7213j+dEuKvSg9HFRMec3VK7hubJXCpQrWN+erTJ9hWw@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CAHrFyr7213j+dEuKvSg9HFRMec3VK7hubJXCpQrWN+erTJ9hWw@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CAHrFyr7213j+dEuKvSg9HFRMec3VK7hubJXCpQrWN+erTJ9hWw@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CAHrFyr7213j+dEuKvSg9HFRMec3VK7hubJXCpQrWN+erTJ9hWw@mail.gmail.com/t/#u">nested</a>] <a href="#r74e9eec1d0fc221f91ceff157e299f934b825964">53+ messages in thread</a></pre><hr><pre><a href="#e4c795d3247c020bd39ddd7208adb99113fe8d8da" id="m4c795d3247c020bd39ddd7208adb99113fe8d8da">*</a> <b>Re: [PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</b>
  2018-10-06  2:10             ` <a href="#mef6f237463d6f0d3748b2fccb1bef7afa5f85339">Aleksa Sarai</a>
<b>@ 2018-10-08 10:50               ` Jann Horn</b>
  <a href="#r4c795d3247c020bd39ddd7208adb99113fe8d8da">0 siblings, 0 replies; 53+ messages in thread</a>
From: Jann Horn @ 2018-10-08 10:50 UTC (<a href="https://lore.kernel.org/lkml/CAG48ez3M84-iL7_9__G81L+16K1eT3j-=QTjL_kVy6BC6sYZzQ@mail.gmail.com/">permalink</a> / <a href="https://lore.kernel.org/lkml/CAG48ez3M84-iL7_9__G81L+16K1eT3j-=QTjL_kVy6BC6sYZzQ@mail.gmail.com/raw">raw</a>)
  To: cyphar
  Cc: Eric W. Biederman, Al Viro, jlayton, Bruce Fields, Arnd Bergmann,
	shuah, David Howells, Andy Lutomirski, christian, Tycho Andersen,
	kernel list, linux-fsdevel, linux-arch, linux-kselftest, dev,
	containers, Linux API

On Sat, Oct 6, 2018 at 4:10 AM Aleksa Sarai &lt;cyphar@cyphar.com&gt; wrote:
<span>&gt; On 2018-10-05, Jann Horn &lt;jannh@google.com&gt; wrote:
&gt; &gt; &gt; What if we took rename_lock (call it nd-&gt;r_seq) at the start of the
&gt; &gt; &gt; resolution, and then only tried the __d_path-style check
&gt; &gt; &gt;
&gt; &gt; &gt;   if (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
&gt; &gt; &gt;       read_seqretry(&amp;mount_lock, nd-&gt;m_seq))
&gt; &gt; &gt;           /* do the __d_path lookup. */
&gt; &gt; &gt;
&gt; &gt; &gt; That way you would only hit the slow path if there were concurrent
&gt; &gt; &gt; renames or mounts *and* you are doing a path resolution with
&gt; &gt; &gt; AT_THIS_ROOT or AT_BENEATH. I've attached a modified patch that does
&gt; &gt; &gt; this (and after some testing it also appears to work).
&gt; &gt;
&gt; &gt; Yeah, I think that might do the job.
&gt;
&gt; *phew* I was all out of other ideas. :P
&gt;
&gt; &gt; &gt; ---
&gt; &gt; &gt;  fs/namei.c | 49 ++++++++++++++++++++++++++++++++++++++++++++++---
&gt; &gt; &gt;  1 file changed, 46 insertions(+), 3 deletions(-)
&gt; &gt; &gt;
&gt; &gt; &gt; diff --git a/fs/namei.c b/fs/namei.c
&gt; &gt; &gt; index 6f995e6de6b1..12c9be175cb4 100644
&gt; &gt; &gt; --- a/fs/namei.c
&gt; &gt; &gt; +++ b/fs/namei.c
&gt; &gt; &gt; @@ -493,7 +493,7 @@ struct nameidata {
&gt; &gt; &gt;         struct path     root;
&gt; &gt; &gt;         struct inode    *inode; /* path.dentry.d_inode */
&gt; &gt; &gt;         unsigned int    flags;
&gt; &gt; &gt; -       unsigned        seq, m_seq;
&gt; &gt; &gt; +       unsigned        seq, m_seq, r_seq;
&gt; &gt; &gt;         int             last_type;
&gt; &gt; &gt;         unsigned        depth;
&gt; &gt; &gt;         int             total_link_count;
&gt; &gt; &gt; @@ -1375,6 +1375,27 @@ static int follow_dotdot_rcu(struct nameidata *nd)
&gt; &gt; &gt;                                 return -EXDEV;
&gt; &gt; &gt;                         break;
&gt; &gt; &gt;                 }
&gt; &gt; &gt; +               if (unlikely((nd-&gt;flags &amp; (LOOKUP_BENEATH | LOOKUP_CHROOT)) &amp;&amp;
&gt; &gt; &gt; +                            (read_seqretry(&amp;rename_lock, nd-&gt;r_seq) ||
&gt; &gt; &gt; +                             read_seqretry(&amp;mount_lock, nd-&gt;m_seq)))) {
&gt; &gt; &gt; +                       char *pathbuf, *pathptr;
&gt; &gt; &gt; +
&gt; &gt; &gt; +                       nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
&gt; &gt; &gt; +                       /* Cannot take m_seq here. */
&gt; &gt; &gt; +
&gt; &gt; &gt; +                       pathbuf = kmalloc(PATH_MAX, GFP_ATOMIC);
&gt; &gt; &gt; +                       if (!pathbuf)
&gt; &gt; &gt; +                               return -ECHILD;
&gt; &gt; &gt; +                       pathptr = __d_path(&amp;nd-&gt;path, &amp;nd-&gt;root, pathbuf, PATH_MAX);
&gt; &gt; &gt; +                       kfree(pathbuf);
&gt; &gt;
&gt; &gt; You're doing this check before actually looking up the parent, right?
&gt; &gt; So as long as I don't trigger the "path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)"
&gt; &gt; check that you do for O_BENEATH, escaping up by one level is possible,
&gt; &gt; right? You should probably move this check so that it happens after
&gt; &gt; following "..".
&gt;
&gt; Yup, you're right. I'll do that.
&gt;
&gt; &gt; (Also: I assume that you're going to get rid of that memory allocation
&gt; &gt; in a future version.)
&gt;
&gt; Sure. Would you prefer adding some scratch space in nameidata, or that I
&gt; change __d_path so it accepts NULL as the buffer (and thus it doesn't
&gt; actually do any string operations)?
</span>
Well, I think accepting a NULL buffer would be much cleaner; but keep
in mind that I'm just someone making suggestions, Al Viro is the one
who has to like your code. :P

<span>&gt; &gt; &gt;                 if (nd-&gt;path.dentry != nd-&gt;path.mnt-&gt;mnt_root) {
&gt; &gt; &gt;                         int ret = path_parent_directory(&amp;nd-&gt;path);
&gt; &gt; &gt;                         if (ret)
&gt; &gt; &gt; @@ -2269,6 +2311,9 @@ static const char *path_init(struct nameidata *nd, unsigned flags)
&gt; &gt; &gt;         nd-&gt;last_type = LAST_ROOT; /* if there are only slashes... */
&gt; &gt; &gt;         nd-&gt;flags = flags | LOOKUP_JUMPED | LOOKUP_PARENT;
&gt; &gt; &gt;         nd-&gt;depth = 0;
&gt; &gt; &gt; +       nd-&gt;m_seq = read_seqbegin(&amp;mount_lock);
&gt; &gt; &gt; +       nd-&gt;r_seq = read_seqbegin(&amp;rename_lock);
&gt; &gt;
&gt; &gt; This means that now, attempting to perform a lookup while something is
&gt; &gt; holding the rename_lock will spin on the lock. I don't know whether
&gt; &gt; that's a problem in practice though. Does anyone on this thread know
&gt; &gt; whether this is problematic?
&gt;
&gt; I could make it so that we only take &amp;rename_lock
&gt;   if (nd-&gt;flags &amp; (FOLLOW_BENEATH | FOLLOW_CHROOT)),
&gt; since it's not used outside of that path.
</span>
I think that might be a sensible change; but as I said, I don't
actually know whether it's necessary, and it would be very helpful if
someone who actually knows commented on this.

<a href="#m4c795d3247c020bd39ddd7208adb99113fe8d8da" id="e4c795d3247c020bd39ddd7208adb99113fe8d8da">^</a> <a href="https://lore.kernel.org/lkml/CAG48ez3M84-iL7_9__G81L+16K1eT3j-=QTjL_kVy6BC6sYZzQ@mail.gmail.com/">permalink</a> <a href="https://lore.kernel.org/lkml/CAG48ez3M84-iL7_9__G81L+16K1eT3j-=QTjL_kVy6BC6sYZzQ@mail.gmail.com/raw">raw</a> <a href="https://lore.kernel.org/lkml/CAG48ez3M84-iL7_9__G81L+16K1eT3j-=QTjL_kVy6BC6sYZzQ@mail.gmail.com/#R">reply</a>	[<a href="https://lore.kernel.org/lkml/CAG48ez3M84-iL7_9__G81L+16K1eT3j-=QTjL_kVy6BC6sYZzQ@mail.gmail.com/T/#u"><b>flat</b></a>|<a href="https://lore.kernel.org/lkml/CAG48ez3M84-iL7_9__G81L+16K1eT3j-=QTjL_kVy6BC6sYZzQ@mail.gmail.com/t/#u">nested</a>] <a href="#r4c795d3247c020bd39ddd7208adb99113fe8d8da">53+ messages in thread</a></pre><hr><pre>end of thread, back to <a href="https://lore.kernel.org/lkml/">index</a>

<b id="t">Thread overview:</b> 53+ messages (download: <a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/t.mbox.gz">mbox.gz</a> / follow: <a href="https://lore.kernel.org/lkml/20180929103453.12025-1-cyphar@cyphar.com/t.atom">Atom feed</a>)
-- links below jump to the message on this page --
2018-09-29 10:34 <a href="#mea91fe1fc4f7cb11eb3dd0425f7e86840e317a56" id="rea91fe1fc4f7cb11eb3dd0425f7e86840e317a56">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Aleksa Sarai
2018-09-29 10:34 ` <a href="#m1383f86e3b88f40c8cb1ba987680029c591c723c" id="r1383f86e3b88f40c8cb1ba987680029c591c723c">[PATCH 1/3] namei: implement O_BENEATH-style</a> " Aleksa Sarai
2018-09-29 14:48   ` <a href="#mbb17b5e39af1ab7962ea44cc159ac0b57a3386fd" id="rbb17b5e39af1ab7962ea44cc159ac0b57a3386fd">Christian Brauner</a>
2018-09-29 15:34     ` <a href="#md95e36d9e2636c3601761385249d006ea3f5c525" id="rd95e36d9e2636c3601761385249d006ea3f5c525">Aleksa Sarai</a>
2018-09-30  4:38   ` <a href="#m87f541d8dc933342c485dd668073dfec153d374c" id="r87f541d8dc933342c485dd668073dfec153d374c">Aleksa Sarai</a>
2018-10-01 12:28   ` <a href="#m00fa1270161fca853ab401153f61255570562b60" id="r00fa1270161fca853ab401153f61255570562b60">Jann Horn</a>
2018-10-01 13:00     ` <a href="#md260e196a4c724d56ef8025c70584b9967d30d3a" id="rd260e196a4c724d56ef8025c70584b9967d30d3a">Christian Brauner</a>
2018-10-01 16:04       ` <a href="#m976af4e59482b98696b0e918a77ff53493dfe932" id="r976af4e59482b98696b0e918a77ff53493dfe932">Aleksa Sarai</a>
2018-10-04 17:20         ` <a href="#m805a98d1da56907d6f5b4fb1ffbe2390a20dcbca" id="r805a98d1da56907d6f5b4fb1ffbe2390a20dcbca">Christian Brauner</a>
2018-09-29 13:15 ` <a href="#m90d20073791a183830564405f81c63f760551f20" id="r90d20073791a183830564405f81c63f760551f20">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Aleksa Sarai
2018-09-29 13:15   ` <a href="#m1e8d6e44df122828245b146d8d64b9d8a03ac028" id="r1e8d6e44df122828245b146d8d64b9d8a03ac028">[PATCH 3/3] selftests: vfs: add AT_* path resolution tests</a> Aleksa Sarai
2018-09-29 16:35   ` <a href="#m85db30139fa0747cca01a4a7b71ba3f88ab3207c" id="r85db30139fa0747cca01a4a7b71ba3f88ab3207c">[PATCH 2/3] namei: implement AT_THIS_ROOT chroot-like path resolution</a> Jann Horn
2018-09-29 17:25     ` <a href="#m55dcd0750c094ebe0bc62c39c395b0163bb41bf2" id="r55dcd0750c094ebe0bc62c39c395b0163bb41bf2">Andy Lutomirski</a>
2018-10-01  9:46       ` <a href="#m1f79f0bf1b6db2badf3e2e999b8ef7acd303a661" id="r1f79f0bf1b6db2badf3e2e999b8ef7acd303a661">Aleksa Sarai</a>
2018-10-01  5:44     ` <a href="#mbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1" id="rbab7c14d09dfa3c33017c5d3b5f27dc4d1bdd5a1">Aleksa Sarai</a>
2018-10-01 10:13       ` <a href="#mfc968a7da9d5629a298a520b5ea1b852a73ab01a" id="rfc968a7da9d5629a298a520b5ea1b852a73ab01a">Jann Horn</a>
2018-10-01 16:18         ` <a href="#madb4f69d46d490beab7f3563227268b15c6ed379" id="radb4f69d46d490beab7f3563227268b15c6ed379">Aleksa Sarai</a>
2018-10-04 17:27           ` <a href="#m8fd9ac6f0a3adff4a8c4bb48b08d4a3183f9b343" id="r8fd9ac6f0a3adff4a8c4bb48b08d4a3183f9b343">Christian Brauner</a>
2018-10-01 10:42       ` <a href="#m1b782ac97737b5e7b08cbd17245d59b61dc647d6" id="r1b782ac97737b5e7b08cbd17245d59b61dc647d6">Christian Brauner</a>
2018-10-01 11:29         ` <a href="#ma3c591b3743f9cdd74d7a81a42ab62150623f9cc" id="ra3c591b3743f9cdd74d7a81a42ab62150623f9cc">Jann Horn</a>
2018-10-01 12:35           ` <a href="#md836ca3a6928d79163766ed39bda531b37819f9a" id="rd836ca3a6928d79163766ed39bda531b37819f9a">Christian Brauner</a>
2018-10-01 13:55       ` <a href="#ma82a25fbd4af29c4ea56cff51c5aaf74ada5b785" id="ra82a25fbd4af29c4ea56cff51c5aaf74ada5b785">Bruce Fields</a>
2018-10-01 14:28       ` <a href="#m3b93afe618d6a330d4d98444dabad9e268b0e1bc" id="r3b93afe618d6a330d4d98444dabad9e268b0e1bc">Andy Lutomirski</a>
2018-10-02  7:32         ` <a href="#m304562dd58656fd5ce4cf51430201c473d7baa4f" id="r304562dd58656fd5ce4cf51430201c473d7baa4f">Aleksa Sarai</a>
2018-10-03 22:09           ` <a href="#m8fbac970df152ad10bbac3ed851b557cf300dee8" id="r8fbac970df152ad10bbac3ed851b557cf300dee8">Andy Lutomirski</a>
2018-10-06 20:56           ` <a href="#m30776acf058e9ccb26876491eaf5ecb147104ad1" id="r30776acf058e9ccb26876491eaf5ecb147104ad1">Florian Weimer</a>
2018-10-06 21:49             ` <a href="#m74e9eec1d0fc221f91ceff157e299f934b825964" id="r74e9eec1d0fc221f91ceff157e299f934b825964">Christian Brauner</a>
2018-10-01 14:00     ` <a href="#md4dd13f53e4b9d8535513d1aed0b121a8d5cfc51" id="rd4dd13f53e4b9d8535513d1aed0b121a8d5cfc51">Christian Brauner</a>
2018-10-04 16:26     ` <a href="#m1363e6020e3fcd93078ba4165aac2ccfb07ef4a5" id="r1363e6020e3fcd93078ba4165aac2ccfb07ef4a5">Aleksa Sarai</a>
2018-10-04 17:31       ` <a href="#m85e4ef7cc31f70b859e7112e14c624d1ce7b87ee" id="r85e4ef7cc31f70b859e7112e14c624d1ce7b87ee">Christian Brauner</a>
2018-10-04 18:26       ` <a href="#m18be51e2a413ec671a98bf761c85a657651c0a3f" id="r18be51e2a413ec671a98bf761c85a657651c0a3f">Jann Horn</a>
2018-10-05 15:07         ` <a href="#m58349a7dd77014369e798bbf75c59baf77e64596" id="r58349a7dd77014369e798bbf75c59baf77e64596">Aleksa Sarai</a>
2018-10-05 15:55           ` <a href="#m5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9" id="r5e10a8fbb0f9c822dd3466c0f9b5077dfcea3ba9">Jann Horn</a>
2018-10-06  2:10             ` <a href="#mef6f237463d6f0d3748b2fccb1bef7afa5f85339" id="ref6f237463d6f0d3748b2fccb1bef7afa5f85339">Aleksa Sarai</a>
2018-10-08 10:50               ` <a href="#m4c795d3247c020bd39ddd7208adb99113fe8d8da" id="r4c795d3247c020bd39ddd7208adb99113fe8d8da">Jann Horn</a>
2018-09-29 14:25 ` <a href="#m3b43f05d63e0487bb74cc85c7a6b88ae1782756d" id="r3b43f05d63e0487bb74cc85c7a6b88ae1782756d">[PATCH 0/3] namei: implement various scoping AT_* flags</a> Andy Lutomirski
2018-09-29 15:45   ` <a href="#m9f9890d1668a388b92fa59ce7deaf65756554661" id="r9f9890d1668a388b92fa59ce7deaf65756554661">Aleksa Sarai</a>
2018-09-29 16:34     ` <a href="#ma7d3a3f2eecc4c0cc375a249b47e94e33377c744" id="ra7d3a3f2eecc4c0cc375a249b47e94e33377c744">Andy Lutomirski</a>
2018-09-29 19:44       ` <a href="#ma8e202c0d14e5763bfff6e7338febd7d1a51a83f" id="ra8e202c0d14e5763bfff6e7338febd7d1a51a83f">Matthew Wilcox</a>
2018-09-29 14:38 ` <a href="#m721f6dd62a1bdc1658cc2a2ea8b21397577190c7" id="r721f6dd62a1bdc1658cc2a2ea8b21397577190c7">Christian Brauner</a>
2018-09-30  4:44   ` <a href="#me5648719f5bf462dbe857542b9eac97ec3340a8f" id="re5648719f5bf462dbe857542b9eac97ec3340a8f">Aleksa Sarai</a>
2018-09-30 13:54 ` <a href="#mcd41f1f73fed393394dbf021d3b8dd2c678b37c3" id="rcd41f1f73fed393394dbf021d3b8dd2c678b37c3">Alban Crequy</a>
2018-09-30 14:02   ` <a href="#m76bb4a153a3c330bc4b0436f64935f15b304cae1" id="r76bb4a153a3c330bc4b0436f64935f15b304cae1">Christian Brauner</a>
2018-09-30 19:45 ` <a href="#mdf028b806a86c9a075bc1ebf67e0e630a54a2ba6" id="rdf028b806a86c9a075bc1ebf67e0e630a54a2ba6">Mickal Salan</a>
2018-09-30 21:46   ` <a href="#m0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00" id="r0b42c42b84829ba0ebbe3635fbc8119ffcb8ee00">Jann Horn</a>
2018-09-30 22:37     ` <a href="#m6f6dac21d23ad55bf619634955f15a52e93874d6" id="r6f6dac21d23ad55bf619634955f15a52e93874d6">Mickal Salan</a>
2018-10-01 20:14       ` <a href="#m440b5bdeba29f11233cdb944b183af4d6c48fb1f" id="r440b5bdeba29f11233cdb944b183af4d6c48fb1f">James Morris</a>
2018-10-01  4:08 ` <a href="#md2ecb7fd499b6542bec872079f27680e1f28a304" id="rd2ecb7fd499b6542bec872079f27680e1f28a304">Dave Chinner</a>
2018-10-01  5:47   ` <a href="#mded88ab4253fc25b051efa833e15625a583d674a" id="rded88ab4253fc25b051efa833e15625a583d674a">Aleksa Sarai</a>
2018-10-01  6:14     ` <a href="#m3383405a3f2f149a8a3ac42ba8869b988296ad1c" id="r3383405a3f2f149a8a3ac42ba8869b988296ad1c">Dave Chinner</a>
2018-10-01 13:28 ` <a href="#ma484ed4979004d9f23a406cac8f134aa029b1322" id="ra484ed4979004d9f23a406cac8f134aa029b1322">David Laight</a>
2018-10-01 16:15   ` <a href="#mf3466ab646463504a28cfdbf74b8d96866715417" id="rf3466ab646463504a28cfdbf74b8d96866715417">Aleksa Sarai</a>
2018-10-03 13:21     ` <a href="#m7e2548354abfae7ff3b3b4e175ac0faa81866045" id="r7e2548354abfae7ff3b3b4e175ac0faa81866045">David Laight</a>
</pre><hr><pre>LKML Archive on lore.kernel.org

Archives are clonable:
	git clone --mirror https://lore.kernel.org/lkml/0 lkml/git/0.git
	git clone --mirror https://lore.kernel.org/lkml/1 lkml/git/1.git
	git clone --mirror https://lore.kernel.org/lkml/2 lkml/git/2.git
	git clone --mirror https://lore.kernel.org/lkml/3 lkml/git/3.git
	git clone --mirror https://lore.kernel.org/lkml/4 lkml/git/4.git
	git clone --mirror https://lore.kernel.org/lkml/5 lkml/git/5.git
	git clone --mirror https://lore.kernel.org/lkml/6 lkml/git/6.git
	git clone --mirror https://lore.kernel.org/lkml/7 lkml/git/7.git
	git clone --mirror https://lore.kernel.org/lkml/8 lkml/git/8.git

	# If you have public-inbox 1.1+ installed, you may
	# initialize and index your mirror using the following commands:
	public-inbox-init -V2 lkml lkml/ https://lore.kernel.org/lkml \
		linux-kernel@vger.kernel.org
	public-inbox-index lkml

Example <a href="https://lore.kernel.org/lkml/_/text/config/raw">config snippet</a> for mirrors

Newsgroup available over NNTP:
	<a href="nntp://nntp.lore.kernel.org/org.kernel.vger.linux-kernel">nntp://nntp.lore.kernel.org/org.kernel.vger.linux-kernel</a>


AGPL code for this site: git clone <a href="https://public-inbox.org/public-inbox.git">https://public-inbox.org/public-inbox.git</a></pre></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>