<!DOCTYPE html>
<html lang="en">
<head>
    <title>
dotnet/runtime - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="dotnet/runtime - linksfor.dev(s)"/>
    <meta property="og:description" content=".NET is a cross-platform runtime for cloud, IoT, and desktop apps. - dotnet/runtime"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://github.com/dotnet/runtime/blob/fcd862e/src/coreclr/src/vm/methodtable.h#L606-L620"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - dotnet/runtime</title>
<div class="readable">
        <h1>dotnet/runtime</h1>
            <div>Reading time: 256-325 minutes</div>
        <div>Posted here: 23 Feb 2020</div>
        <p><a href="https://github.com/dotnet/runtime/blob/fcd862e/src/coreclr/src/vm/methodtable.h#L606-L620">https://github.com/dotnet/runtime/blob/fcd862e/src/coreclr/src/vm/methodtable.h#L606-L620</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div itemprop="text">
      
<table data-tab-size="4">
      <tbody><tr>
        <td id="L1" data-line-number="1"></td>
        <td id="LC1"><span><span>//</span> Licensed to the .NET Foundation under one or more agreements.</span></td>
      </tr>
      <tr>
        <td id="L2" data-line-number="2"></td>
        <td id="LC2"><span><span>//</span> The .NET Foundation licenses this file to you under the MIT license.</span></td>
      </tr>
      <tr>
        <td id="L3" data-line-number="3"></td>
        <td id="LC3"><span><span>//</span> See the LICENSE file in the project root for more information.</span></td>
      </tr>
      <tr>
        <td id="L4" data-line-number="4"></td>
        <td id="LC4"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L5" data-line-number="5"></td>
        <td id="LC5"><span><span>//</span> File: methodtable.h</span></td>
      </tr>
      <tr>
        <td id="L6" data-line-number="6"></td>
        <td id="LC6"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L7" data-line-number="7"></td>
        <td id="LC7">
</td>
      </tr>
      <tr>
        <td id="L8" data-line-number="8"></td>
        <td id="LC8">#<span>ifndef</span> _METHODTABLE_H_</td>
      </tr>
      <tr>
        <td id="L9" data-line-number="9"></td>
        <td id="LC9">#<span>define</span> <span>_METHODTABLE_H_</span></td>
      </tr>
      <tr>
        <td id="L10" data-line-number="10"></td>
        <td id="LC10">
</td>
      </tr>
      <tr>
        <td id="L11" data-line-number="11"></td>
        <td id="LC11"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L12" data-line-number="12"></td>
        <td id="LC12"><span> *  Include Files</span></td>
      </tr>
      <tr>
        <td id="L13" data-line-number="13"></td>
        <td id="LC13"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L14" data-line-number="14"></td>
        <td id="LC14">#<span>include</span> <span><span>"</span>vars.hpp<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L15" data-line-number="15"></td>
        <td id="LC15">#<span>include</span> <span><span>"</span>cor.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L16" data-line-number="16"></td>
        <td id="LC16">#<span>include</span> <span><span>"</span>hash.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L17" data-line-number="17"></td>
        <td id="LC17">#<span>include</span> <span><span>"</span>crst.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L18" data-line-number="18"></td>
        <td id="LC18">#<span>include</span> <span><span>"</span>cgensys.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L19" data-line-number="19"></td>
        <td id="LC19">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L20" data-line-number="20"></td>
        <td id="LC20">#<span>include</span> <span><span>"</span>stdinterfaces.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L21" data-line-number="21"></td>
        <td id="LC21">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L22" data-line-number="22"></td>
        <td id="LC22">#<span>include</span> <span><span>"</span>slist.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L23" data-line-number="23"></td>
        <td id="LC23">#<span>include</span> <span><span>"</span>spinlock.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L24" data-line-number="24"></td>
        <td id="LC24">#<span>include</span> <span><span>"</span>typehandle.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L25" data-line-number="25"></td>
        <td id="LC25">#<span>include</span> <span><span>"</span>eehash.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L26" data-line-number="26"></td>
        <td id="LC26">#<span>include</span> <span><span>"</span>contractimpl.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L27" data-line-number="27"></td>
        <td id="LC27">#<span>include</span> <span><span>"</span>generics.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L28" data-line-number="28"></td>
        <td id="LC28">#<span>include</span> <span><span>"</span>fixuppointer.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L29" data-line-number="29"></td>
        <td id="LC29">#<span>include</span> <span><span>"</span>gcinfotypes.h<span>"</span></span></td>
      </tr>
      <tr>
        <td id="L30" data-line-number="30"></td>
        <td id="LC30">
</td>
      </tr>
      <tr>
        <td id="L31" data-line-number="31"></td>
        <td id="LC31"><span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L32" data-line-number="32"></td>
        <td id="LC32"><span> * Forward Declarations</span></td>
      </tr>
      <tr>
        <td id="L33" data-line-number="33"></td>
        <td id="LC33"><span> <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L34" data-line-number="34"></td>
        <td id="LC34">class    AppDomain;</td>
      </tr>
      <tr>
        <td id="L35" data-line-number="35"></td>
        <td id="LC35">class    ArrayClass;</td>
      </tr>
      <tr>
        <td id="L36" data-line-number="36"></td>
        <td id="LC36">class    ArrayMethodDesc;</td>
      </tr>
      <tr>
        <td id="L37" data-line-number="37"></td>
        <td id="LC37"><span>struct</span>   ClassCtorInfoEntry;</td>
      </tr>
      <tr>
        <td id="L38" data-line-number="38"></td>
        <td id="LC38">class ClassLoader;</td>
      </tr>
      <tr>
        <td id="L39" data-line-number="39"></td>
        <td id="LC39">class FCallMethodDesc;</td>
      </tr>
      <tr>
        <td id="L40" data-line-number="40"></td>
        <td id="LC40">class    EEClass;</td>
      </tr>
      <tr>
        <td id="L41" data-line-number="41"></td>
        <td id="LC41">class    EnCFieldDesc;</td>
      </tr>
      <tr>
        <td id="L42" data-line-number="42"></td>
        <td id="LC42">class FieldDesc;</td>
      </tr>
      <tr>
        <td id="L43" data-line-number="43"></td>
        <td id="LC43">class JIT_TrialAlloc;</td>
      </tr>
      <tr>
        <td id="L44" data-line-number="44"></td>
        <td id="LC44"><span>struct</span> LayoutRawFieldInfo;</td>
      </tr>
      <tr>
        <td id="L45" data-line-number="45"></td>
        <td id="LC45">class MetaSig;</td>
      </tr>
      <tr>
        <td id="L46" data-line-number="46"></td>
        <td id="LC46">class    MethodDesc;</td>
      </tr>
      <tr>
        <td id="L47" data-line-number="47"></td>
        <td id="LC47">class    MethodDescChunk;</td>
      </tr>
      <tr>
        <td id="L48" data-line-number="48"></td>
        <td id="LC48">class    MethodTable;</td>
      </tr>
      <tr>
        <td id="L49" data-line-number="49"></td>
        <td id="LC49">class    Module;</td>
      </tr>
      <tr>
        <td id="L50" data-line-number="50"></td>
        <td id="LC50">class    Object;</td>
      </tr>
      <tr>
        <td id="L51" data-line-number="51"></td>
        <td id="LC51">class    Stub;</td>
      </tr>
      <tr>
        <td id="L52" data-line-number="52"></td>
        <td id="LC52">class    Substitution;</td>
      </tr>
      <tr>
        <td id="L53" data-line-number="53"></td>
        <td id="LC53">class    TypeHandle;</td>
      </tr>
      <tr>
        <td id="L54" data-line-number="54"></td>
        <td id="LC54">class   Dictionary;</td>
      </tr>
      <tr>
        <td id="L55" data-line-number="55"></td>
        <td id="LC55">class   AllocMemTracker;</td>
      </tr>
      <tr>
        <td id="L56" data-line-number="56"></td>
        <td id="LC56">class   SimpleRWLock;</td>
      </tr>
      <tr>
        <td id="L57" data-line-number="57"></td>
        <td id="LC57">class   MethodDataCache;</td>
      </tr>
      <tr>
        <td id="L58" data-line-number="58"></td>
        <td id="LC58">class   EEClassLayoutInfo;</td>
      </tr>
      <tr>
        <td id="L59" data-line-number="59"></td>
        <td id="LC59">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L60" data-line-number="60"></td>
        <td id="LC60">class   ComCallWrapperTemplate;</td>
      </tr>
      <tr>
        <td id="L61" data-line-number="61"></td>
        <td id="LC61">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L62" data-line-number="62"></td>
        <td id="LC62">#<span>ifdef</span> FEATURE_COMINTEROP_UNMANAGED_ACTIVATION</td>
      </tr>
      <tr>
        <td id="L63" data-line-number="63"></td>
        <td id="LC63">class ClassFactoryBase;</td>
      </tr>
      <tr>
        <td id="L64" data-line-number="64"></td>
        <td id="LC64">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP_UNMANAGED_ACTIVATION</span></td>
      </tr>
      <tr>
        <td id="L65" data-line-number="65"></td>
        <td id="LC65">class ArgDestination;</td>
      </tr>
      <tr>
        <td id="L66" data-line-number="66"></td>
        <td id="LC66"><span>enum</span> class WellKnownAttribute : DWORD;</td>
      </tr>
      <tr>
        <td id="L67" data-line-number="67"></td>
        <td id="LC67">
</td>
      </tr>
      <tr>
        <td id="L68" data-line-number="68"></td>
        <td id="LC68"><span><span>//</span>============================================================================</span></td>
      </tr>
      <tr>
        <td id="L69" data-line-number="69"></td>
        <td id="LC69"><span><span>//</span> This is the in-memory structure of a class and it will evolve.</span></td>
      </tr>
      <tr>
        <td id="L70" data-line-number="70"></td>
        <td id="LC70"><span><span>//</span>============================================================================</span></td>
      </tr>
      <tr>
        <td id="L71" data-line-number="71"></td>
        <td id="LC71">
</td>
      </tr>
      <tr>
        <td id="L72" data-line-number="72"></td>
        <td id="LC72"><span><span>//</span> &lt;TODO&gt;</span></td>
      </tr>
      <tr>
        <td id="L73" data-line-number="73"></td>
        <td id="LC73"><span><span>//</span> Add a sync block</span></td>
      </tr>
      <tr>
        <td id="L74" data-line-number="74"></td>
        <td id="LC74"><span><span>//</span> Also this class currently has everything public - this may changes</span></td>
      </tr>
      <tr>
        <td id="L75" data-line-number="75"></td>
        <td id="LC75"><span><span>//</span> Might also need to hold onto the meta data loader fot this class&lt;/TODO&gt;</span></td>
      </tr>
      <tr>
        <td id="L76" data-line-number="76"></td>
        <td id="LC76">
</td>
      </tr>
      <tr>
        <td id="L77" data-line-number="77"></td>
        <td id="LC77"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L78" data-line-number="78"></td>
        <td id="LC78"><span><span>//</span> A MethodTable contains an array of these structures, which describes each interface implemented</span></td>
      </tr>
      <tr>
        <td id="L79" data-line-number="79"></td>
        <td id="LC79"><span><span>//</span> by this class (directly declared or indirectly declared).</span></td>
      </tr>
      <tr>
        <td id="L80" data-line-number="80"></td>
        <td id="LC80"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L81" data-line-number="81"></td>
        <td id="LC81"><span><span>//</span> Generic type instantiations (in C# syntax: C&lt;ty_1,...,ty_n&gt;) are represented by</span></td>
      </tr>
      <tr>
        <td id="L82" data-line-number="82"></td>
        <td id="LC82"><span><span>//</span> MethodTables, i.e. a new MethodTable gets allocated for each such instantiation.</span></td>
      </tr>
      <tr>
        <td id="L83" data-line-number="83"></td>
        <td id="LC83"><span><span>//</span> The entries in these tables (i.e. the code) are, however, often shared.</span></td>
      </tr>
      <tr>
        <td id="L84" data-line-number="84"></td>
        <td id="LC84"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L85" data-line-number="85"></td>
        <td id="LC85"><span><span>//</span> In particular, a MethodTable's vtable contents (and hence method descriptors) may be</span></td>
      </tr>
      <tr>
        <td id="L86" data-line-number="86"></td>
        <td id="LC86"><span><span>//</span> shared between compatible instantiations (e.g. List&lt;string&gt; and List&lt;object&gt; have</span></td>
      </tr>
      <tr>
        <td id="L87" data-line-number="87"></td>
        <td id="LC87"><span><span>//</span> the same vtable *contents*).  Likewise the EEClass will be shared between</span></td>
      </tr>
      <tr>
        <td id="L88" data-line-number="88"></td>
        <td id="LC88"><span><span>//</span> compatible instantiations whenever the vtable contents are.</span></td>
      </tr>
      <tr>
        <td id="L89" data-line-number="89"></td>
        <td id="LC89"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L90" data-line-number="90"></td>
        <td id="LC90"><span><span>//</span> !!! Thus that it is _not_ generally the case that GetClass.GetMethodTable() == t. !!!</span></td>
      </tr>
      <tr>
        <td id="L91" data-line-number="91"></td>
        <td id="LC91"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L92" data-line-number="92"></td>
        <td id="LC92"><span><span>//</span> Instantiated interfaces have their own method tables unique to the instantiation e.g. I&lt;string&gt; is</span></td>
      </tr>
      <tr>
        <td id="L93" data-line-number="93"></td>
        <td id="LC93"><span><span>//</span> distinct from I&lt;int&gt; and I&lt;object&gt;</span></td>
      </tr>
      <tr>
        <td id="L94" data-line-number="94"></td>
        <td id="LC94"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L95" data-line-number="95"></td>
        <td id="LC95"><span><span>//</span> For generic types the interface map lists generic interfaces</span></td>
      </tr>
      <tr>
        <td id="L96" data-line-number="96"></td>
        <td id="LC96"><span><span>//</span> For instantiated types the interface map lists instantiated interfaces</span></td>
      </tr>
      <tr>
        <td id="L97" data-line-number="97"></td>
        <td id="LC97"><span><span>//</span>   e.g. for C&lt;T&gt; : I&lt;T&gt;, J&lt;string&gt;</span></td>
      </tr>
      <tr>
        <td id="L98" data-line-number="98"></td>
        <td id="LC98"><span><span>//</span> the interface map for C would list I and J</span></td>
      </tr>
      <tr>
        <td id="L99" data-line-number="99"></td>
        <td id="LC99"><span><span>//</span> the interface map for C&lt;int&gt; would list I&lt;int&gt; and J&lt;string&gt;</span></td>
      </tr>
      <tr>
        <td id="L100" data-line-number="100"></td>
        <td id="LC100"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L101" data-line-number="101"></td>
        <td id="LC101"><span>struct</span> InterfaceInfo_t</td>
      </tr>
      <tr>
        <td id="L102" data-line-number="102"></td>
        <td id="LC102">{</td>
      </tr>
      <tr>
        <td id="L103" data-line-number="103"></td>
        <td id="LC103">#<span>ifdef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L104" data-line-number="104"></td>
        <td id="LC104">    friend class NativeImageDumper;</td>
      </tr>
      <tr>
        <td id="L105" data-line-number="105"></td>
        <td id="LC105">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L106" data-line-number="106"></td>
        <td id="LC106">
</td>
      </tr>
      <tr>
        <td id="L107" data-line-number="107"></td>
        <td id="LC107">    <span><span>//</span> Method table of the interface</span></td>
      </tr>
      <tr>
        <td id="L108" data-line-number="108"></td>
        <td id="LC108">#<span>if</span> defined(FEATURE_NGEN_RELOCS_OPTIMIZATIONS)</td>
      </tr>
      <tr>
        <td id="L109" data-line-number="109"></td>
        <td id="LC109">    RelativeFixupPointer&lt;PTR_MethodTable&gt; m_pMethodTable;</td>
      </tr>
      <tr>
        <td id="L110" data-line-number="110"></td>
        <td id="LC110">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L111" data-line-number="111"></td>
        <td id="LC111">    FixupPointer&lt;PTR_MethodTable&gt; m_pMethodTable;</td>
      </tr>
      <tr>
        <td id="L112" data-line-number="112"></td>
        <td id="LC112">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L113" data-line-number="113"></td>
        <td id="LC113">
</td>
      </tr>
      <tr>
        <td id="L114" data-line-number="114"></td>
        <td id="LC114">public:</td>
      </tr>
      <tr>
        <td id="L115" data-line-number="115"></td>
        <td id="LC115">    FORCEINLINE PTR_MethodTable <span>GetMethodTable</span>()</td>
      </tr>
      <tr>
        <td id="L116" data-line-number="116"></td>
        <td id="LC116">    {</td>
      </tr>
      <tr>
        <td id="L117" data-line-number="117"></td>
        <td id="LC117">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L118" data-line-number="118"></td>
        <td id="LC118">        <span>return</span> <span>ReadPointerMaybeNull</span>(this, &amp;InterfaceInfo_t::m_pMethodTable);</td>
      </tr>
      <tr>
        <td id="L119" data-line-number="119"></td>
        <td id="LC119">    }</td>
      </tr>
      <tr>
        <td id="L120" data-line-number="120"></td>
        <td id="LC120">
</td>
      </tr>
      <tr>
        <td id="L121" data-line-number="121"></td>
        <td id="LC121">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L122" data-line-number="122"></td>
        <td id="LC122">    <span>void</span> <span>SetMethodTable</span>(MethodTable * pMT)</td>
      </tr>
      <tr>
        <td id="L123" data-line-number="123"></td>
        <td id="LC123">    {</td>
      </tr>
      <tr>
        <td id="L124" data-line-number="124"></td>
        <td id="LC124">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L125" data-line-number="125"></td>
        <td id="LC125">        m_pMethodTable.<span>SetValueMaybeNull</span>(pMT);</td>
      </tr>
      <tr>
        <td id="L126" data-line-number="126"></td>
        <td id="LC126">    }</td>
      </tr>
      <tr>
        <td id="L127" data-line-number="127"></td>
        <td id="LC127">
</td>
      </tr>
      <tr>
        <td id="L128" data-line-number="128"></td>
        <td id="LC128">    <span><span>//</span> Get approximate method table. This is used by the type loader before the type is fully loaded.</span></td>
      </tr>
      <tr>
        <td id="L129" data-line-number="129"></td>
        <td id="LC129">    PTR_MethodTable <span>GetApproxMethodTable</span>(Module * pContainingModule);</td>
      </tr>
      <tr>
        <td id="L130" data-line-number="130"></td>
        <td id="LC130">#<span>endif</span> <span><span>//</span> !DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L131" data-line-number="131"></td>
        <td id="LC131">
</td>
      </tr>
      <tr>
        <td id="L132" data-line-number="132"></td>
        <td id="LC132">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L133" data-line-number="133"></td>
        <td id="LC133">    <span>InterfaceInfo_t</span>(InterfaceInfo_t &amp;right)</td>
      </tr>
      <tr>
        <td id="L134" data-line-number="134"></td>
        <td id="LC134">    {</td>
      </tr>
      <tr>
        <td id="L135" data-line-number="135"></td>
        <td id="LC135">        m_pMethodTable.<span>SetValueMaybeNull</span>(right.<span>m_pMethodTable</span>.<span>GetValueMaybeNull</span>());</td>
      </tr>
      <tr>
        <td id="L136" data-line-number="136"></td>
        <td id="LC136">    }</td>
      </tr>
      <tr>
        <td id="L137" data-line-number="137"></td>
        <td id="LC137">#<span>else</span> <span><span>//</span> !DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L138" data-line-number="138"></td>
        <td id="LC138">private:</td>
      </tr>
      <tr>
        <td id="L139" data-line-number="139"></td>
        <td id="LC139">    <span>InterfaceInfo_t</span>(InterfaceInfo_t &amp;right);</td>
      </tr>
      <tr>
        <td id="L140" data-line-number="140"></td>
        <td id="LC140">#<span>endif</span> <span><span>//</span> !DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L141" data-line-number="141"></td>
        <td id="LC141">};  <span><span>//</span> struct InterfaceInfo_t</span></td>
      </tr>
      <tr>
        <td id="L142" data-line-number="142"></td>
        <td id="LC142">
</td>
      </tr>
      <tr>
        <td id="L143" data-line-number="143"></td>
        <td id="LC143"><span>typedef</span> <span>DPTR</span>(InterfaceInfo_t) PTR_InterfaceInfo;</td>
      </tr>
      <tr>
        <td id="L144" data-line-number="144"></td>
        <td id="LC144">
</td>
      </tr>
      <tr>
        <td id="L145" data-line-number="145"></td>
        <td id="LC145">namespace ClassCompat</td>
      </tr>
      <tr>
        <td id="L146" data-line-number="146"></td>
        <td id="LC146">{</td>
      </tr>
      <tr>
        <td id="L147" data-line-number="147"></td>
        <td id="LC147">    <span>struct</span> InterfaceInfo_t;</td>
      </tr>
      <tr>
        <td id="L148" data-line-number="148"></td>
        <td id="LC148">};</td>
      </tr>
      <tr>
        <td id="L149" data-line-number="149"></td>
        <td id="LC149">
</td>
      </tr>
      <tr>
        <td id="L150" data-line-number="150"></td>
        <td id="LC150"><span><span>//</span> Data needed when simulating old VTable layout for COM Interop</span></td>
      </tr>
      <tr>
        <td id="L151" data-line-number="151"></td>
        <td id="LC151"><span><span>//</span> This is necessary as the data is saved in MethodDescs and we need</span></td>
      </tr>
      <tr>
        <td id="L152" data-line-number="152"></td>
        <td id="LC152"><span><span>//</span> to simulate different values without copying or changing the existing</span></td>
      </tr>
      <tr>
        <td id="L153" data-line-number="153"></td>
        <td id="LC153"><span><span>//</span> MethodDescs</span></td>
      </tr>
      <tr>
        <td id="L154" data-line-number="154"></td>
        <td id="LC154"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L155" data-line-number="155"></td>
        <td id="LC155"><span><span>//</span> This will be created in a parallel array to ppMethodDescList and</span></td>
      </tr>
      <tr>
        <td id="L156" data-line-number="156"></td>
        <td id="LC156"><span><span>//</span> ppUnboxMethodDescList in the bmtMethAndFieldDescs structure below</span></td>
      </tr>
      <tr>
        <td id="L157" data-line-number="157"></td>
        <td id="LC157"><span>struct</span> InteropMethodTableSlotData</td>
      </tr>
      <tr>
        <td id="L158" data-line-number="158"></td>
        <td id="LC158">{</td>
      </tr>
      <tr>
        <td id="L159" data-line-number="159"></td>
        <td id="LC159">    <span>enum</span></td>
      </tr>
      <tr>
        <td id="L160" data-line-number="160"></td>
        <td id="LC160">    {</td>
      </tr>
      <tr>
        <td id="L161" data-line-number="161"></td>
        <td id="LC161">        e_DUPLICATE = <span>0x0001</span>              <span><span>//</span> The entry is duplicate</span></td>
      </tr>
      <tr>
        <td id="L162" data-line-number="162"></td>
        <td id="LC162">    };</td>
      </tr>
      <tr>
        <td id="L163" data-line-number="163"></td>
        <td id="LC163">
</td>
      </tr>
      <tr>
        <td id="L164" data-line-number="164"></td>
        <td id="LC164">    MethodDesc *pMD;                <span><span>//</span> The MethodDesc for this slot</span></td>
      </tr>
      <tr>
        <td id="L165" data-line-number="165"></td>
        <td id="LC165">    WORD        wSlot;              <span><span>//</span> The simulated slot value for the MethodDesc</span></td>
      </tr>
      <tr>
        <td id="L166" data-line-number="166"></td>
        <td id="LC166">    WORD        wFlags;             <span><span>//</span> The simulated duplicate value</span></td>
      </tr>
      <tr>
        <td id="L167" data-line-number="167"></td>
        <td id="LC167">    MethodDesc *pDeclMD;            <span><span>//</span> To keep track of MethodImpl's</span></td>
      </tr>
      <tr>
        <td id="L168" data-line-number="168"></td>
        <td id="LC168">
</td>
      </tr>
      <tr>
        <td id="L169" data-line-number="169"></td>
        <td id="LC169">    <span>void</span> <span>SetDuplicate</span>()</td>
      </tr>
      <tr>
        <td id="L170" data-line-number="170"></td>
        <td id="LC170">    {</td>
      </tr>
      <tr>
        <td id="L171" data-line-number="171"></td>
        <td id="LC171">        wFlags |= e_DUPLICATE;</td>
      </tr>
      <tr>
        <td id="L172" data-line-number="172"></td>
        <td id="LC172">    }</td>
      </tr>
      <tr>
        <td id="L173" data-line-number="173"></td>
        <td id="LC173">
</td>
      </tr>
      <tr>
        <td id="L174" data-line-number="174"></td>
        <td id="LC174">    BOOL <span>IsDuplicate</span>() {</td>
      </tr>
      <tr>
        <td id="L175" data-line-number="175"></td>
        <td id="LC175">        <span>return</span> ((BOOL)(wFlags &amp; e_DUPLICATE));</td>
      </tr>
      <tr>
        <td id="L176" data-line-number="176"></td>
        <td id="LC176">    }</td>
      </tr>
      <tr>
        <td id="L177" data-line-number="177"></td>
        <td id="LC177">
</td>
      </tr>
      <tr>
        <td id="L178" data-line-number="178"></td>
        <td id="LC178">    WORD <span>GetSlot</span>() {</td>
      </tr>
      <tr>
        <td id="L179" data-line-number="179"></td>
        <td id="LC179">        <span>return</span> wSlot;</td>
      </tr>
      <tr>
        <td id="L180" data-line-number="180"></td>
        <td id="LC180">    }</td>
      </tr>
      <tr>
        <td id="L181" data-line-number="181"></td>
        <td id="LC181">
</td>
      </tr>
      <tr>
        <td id="L182" data-line-number="182"></td>
        <td id="LC182">    <span>void</span> <span>SetSlot</span>(WORD wSlot) {</td>
      </tr>
      <tr>
        <td id="L183" data-line-number="183"></td>
        <td id="LC183">        this-&gt;<span>wSlot</span> = wSlot;</td>
      </tr>
      <tr>
        <td id="L184" data-line-number="184"></td>
        <td id="LC184">    }</td>
      </tr>
      <tr>
        <td id="L185" data-line-number="185"></td>
        <td id="LC185">};  <span><span>//</span> struct InteropMethodTableSlotData</span></td>
      </tr>
      <tr>
        <td id="L186" data-line-number="186"></td>
        <td id="LC186">
</td>
      </tr>
      <tr>
        <td id="L187" data-line-number="187"></td>
        <td id="LC187">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L188" data-line-number="188"></td>
        <td id="LC188"><span>struct</span> InteropMethodTableData</td>
      </tr>
      <tr>
        <td id="L189" data-line-number="189"></td>
        <td id="LC189">{</td>
      </tr>
      <tr>
        <td id="L190" data-line-number="190"></td>
        <td id="LC190">    WORD cVTable;                          <span><span>//</span> Count of vtable slots</span></td>
      </tr>
      <tr>
        <td id="L191" data-line-number="191"></td>
        <td id="LC191">    InteropMethodTableSlotData *pVTable;    <span><span>//</span> Data for each slot</span></td>
      </tr>
      <tr>
        <td id="L192" data-line-number="192"></td>
        <td id="LC192">
</td>
      </tr>
      <tr>
        <td id="L193" data-line-number="193"></td>
        <td id="LC193">    WORD cNonVTable;                       <span><span>//</span> Count of non-vtable slots</span></td>
      </tr>
      <tr>
        <td id="L194" data-line-number="194"></td>
        <td id="LC194">    InteropMethodTableSlotData *pNonVTable; <span><span>//</span> Data for each slot</span></td>
      </tr>
      <tr>
        <td id="L195" data-line-number="195"></td>
        <td id="LC195">
</td>
      </tr>
      <tr>
        <td id="L196" data-line-number="196"></td>
        <td id="LC196">    WORD            cInterfaceMap;         <span><span>//</span> Count of interfaces</span></td>
      </tr>
      <tr>
        <td id="L197" data-line-number="197"></td>
        <td id="LC197">    ClassCompat::InterfaceInfo_t *</td>
      </tr>
      <tr>
        <td id="L198" data-line-number="198"></td>
        <td id="LC198">                    pInterfaceMap;         <span><span>//</span> The interface map</span></td>
      </tr>
      <tr>
        <td id="L199" data-line-number="199"></td>
        <td id="LC199">
</td>
      </tr>
      <tr>
        <td id="L200" data-line-number="200"></td>
        <td id="LC200">    <span><span>//</span> Utility methods</span></td>
      </tr>
      <tr>
        <td id="L201" data-line-number="201"></td>
        <td id="LC201">    <span>static</span> WORD <span>GetRealMethodDesc</span>(MethodTable *pMT, MethodDesc *pMD);</td>
      </tr>
      <tr>
        <td id="L202" data-line-number="202"></td>
        <td id="LC202">    <span>static</span> WORD <span>GetSlotForMethodDesc</span>(MethodTable *pMT, MethodDesc *pMD);</td>
      </tr>
      <tr>
        <td id="L203" data-line-number="203"></td>
        <td id="LC203">    ClassCompat::InterfaceInfo_t* <span>FindInterface</span>(MethodTable *pInterface);</td>
      </tr>
      <tr>
        <td id="L204" data-line-number="204"></td>
        <td id="LC204">    WORD <span>GetStartSlotForInterface</span>(MethodTable* pInterface);</td>
      </tr>
      <tr>
        <td id="L205" data-line-number="205"></td>
        <td id="LC205">};</td>
      </tr>
      <tr>
        <td id="L206" data-line-number="206"></td>
        <td id="LC206">
</td>
      </tr>
      <tr>
        <td id="L207" data-line-number="207"></td>
        <td id="LC207">class InteropMethodTableSlotDataMap</td>
      </tr>
      <tr>
        <td id="L208" data-line-number="208"></td>
        <td id="LC208">{</td>
      </tr>
      <tr>
        <td id="L209" data-line-number="209"></td>
        <td id="LC209">protected:</td>
      </tr>
      <tr>
        <td id="L210" data-line-number="210"></td>
        <td id="LC210">    InteropMethodTableSlotData *m_pSlotData;</td>
      </tr>
      <tr>
        <td id="L211" data-line-number="211"></td>
        <td id="LC211">    DWORD                       m_cSlotData;</td>
      </tr>
      <tr>
        <td id="L212" data-line-number="212"></td>
        <td id="LC212">    DWORD                       m_iCurSlot;</td>
      </tr>
      <tr>
        <td id="L213" data-line-number="213"></td>
        <td id="LC213">
</td>
      </tr>
      <tr>
        <td id="L214" data-line-number="214"></td>
        <td id="LC214">public:</td>
      </tr>
      <tr>
        <td id="L215" data-line-number="215"></td>
        <td id="LC215">    <span>InteropMethodTableSlotDataMap</span>(InteropMethodTableSlotData *pSlotData, DWORD cSlotData);</td>
      </tr>
      <tr>
        <td id="L216" data-line-number="216"></td>
        <td id="LC216">    InteropMethodTableSlotData *<span>GetData</span>(MethodDesc *pMD);</td>
      </tr>
      <tr>
        <td id="L217" data-line-number="217"></td>
        <td id="LC217">    BOOL <span>Exists</span>(MethodDesc *pMD);</td>
      </tr>
      <tr>
        <td id="L218" data-line-number="218"></td>
        <td id="LC218">
</td>
      </tr>
      <tr>
        <td id="L219" data-line-number="219"></td>
        <td id="LC219">protected:</td>
      </tr>
      <tr>
        <td id="L220" data-line-number="220"></td>
        <td id="LC220">    InteropMethodTableSlotData *<span>Exists_Helper</span>(MethodDesc *pMD);</td>
      </tr>
      <tr>
        <td id="L221" data-line-number="221"></td>
        <td id="LC221">    InteropMethodTableSlotData *<span>GetNewEntry</span>();</td>
      </tr>
      <tr>
        <td id="L222" data-line-number="222"></td>
        <td id="LC222">};  <span><span>//</span> class InteropMethodTableSlotDataMap</span></td>
      </tr>
      <tr>
        <td id="L223" data-line-number="223"></td>
        <td id="LC223">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L224" data-line-number="224"></td>
        <td id="LC224">
</td>
      </tr>
      <tr>
        <td id="L225" data-line-number="225"></td>
        <td id="LC225"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L226" data-line-number="226"></td>
        <td id="LC226"><span><span>//</span> This struct contains cached information on the GUID associated with a type.</span></td>
      </tr>
      <tr>
        <td id="L227" data-line-number="227"></td>
        <td id="LC227"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L228" data-line-number="228"></td>
        <td id="LC228">
</td>
      </tr>
      <tr>
        <td id="L229" data-line-number="229"></td>
        <td id="LC229"><span>struct</span> GuidInfo</td>
      </tr>
      <tr>
        <td id="L230" data-line-number="230"></td>
        <td id="LC230">{</td>
      </tr>
      <tr>
        <td id="L231" data-line-number="231"></td>
        <td id="LC231">    GUID         m_Guid;                <span><span>//</span> The actual guid of the type.</span></td>
      </tr>
      <tr>
        <td id="L232" data-line-number="232"></td>
        <td id="LC232">    BOOL         m_bGeneratedFromName;  <span><span>//</span> A boolean indicating if it was generated from the</span></td>
      </tr>
      <tr>
        <td id="L233" data-line-number="233"></td>
        <td id="LC233">                                        <span><span>//</span> name of the type.</span></td>
      </tr>
      <tr>
        <td id="L234" data-line-number="234"></td>
        <td id="LC234">};</td>
      </tr>
      <tr>
        <td id="L235" data-line-number="235"></td>
        <td id="LC235">
</td>
      </tr>
      <tr>
        <td id="L236" data-line-number="236"></td>
        <td id="LC236"><span>typedef</span> <span>DPTR</span>(GuidInfo) PTR_GuidInfo;</td>
      </tr>
      <tr>
        <td id="L237" data-line-number="237"></td>
        <td id="LC237">
</td>
      </tr>
      <tr>
        <td id="L238" data-line-number="238"></td>
        <td id="LC238">
</td>
      </tr>
      <tr>
        <td id="L239" data-line-number="239"></td>
        <td id="LC239"><span><span>//</span> GenericsDictInfo is stored at negative offset of the dictionary</span></td>
      </tr>
      <tr>
        <td id="L240" data-line-number="240"></td>
        <td id="LC240"><span>struct</span> GenericsDictInfo</td>
      </tr>
      <tr>
        <td id="L241" data-line-number="241"></td>
        <td id="LC241">{</td>
      </tr>
      <tr>
        <td id="L242" data-line-number="242"></td>
        <td id="LC242">#<span>ifdef</span> HOST_64BIT</td>
      </tr>
      <tr>
        <td id="L243" data-line-number="243"></td>
        <td id="LC243">    DWORD m_dwPadding;               <span><span>//</span> Just to keep the size a multiple of 8</span></td>
      </tr>
      <tr>
        <td id="L244" data-line-number="244"></td>
        <td id="LC244">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L245" data-line-number="245"></td>
        <td id="LC245">
</td>
      </tr>
      <tr>
        <td id="L246" data-line-number="246"></td>
        <td id="LC246">    <span><span>//</span> Total number of instantiation dictionaries including inherited ones</span></td>
      </tr>
      <tr>
        <td id="L247" data-line-number="247"></td>
        <td id="LC247">    <span><span>//</span>   i.e. how many instantiated classes (including this one) are there in the hierarchy?</span></td>
      </tr>
      <tr>
        <td id="L248" data-line-number="248"></td>
        <td id="LC248">    <span><span>//</span> See comments about PerInstInfo</span></td>
      </tr>
      <tr>
        <td id="L249" data-line-number="249"></td>
        <td id="LC249">    WORD   m_wNumDicts;</td>
      </tr>
      <tr>
        <td id="L250" data-line-number="250"></td>
        <td id="LC250">
</td>
      </tr>
      <tr>
        <td id="L251" data-line-number="251"></td>
        <td id="LC251">    <span><span>//</span> Number of type parameters (NOT including those of superclasses).</span></td>
      </tr>
      <tr>
        <td id="L252" data-line-number="252"></td>
        <td id="LC252">    WORD   m_wNumTyPars;</td>
      </tr>
      <tr>
        <td id="L253" data-line-number="253"></td>
        <td id="LC253">};  <span><span>//</span> struct GenericsDictInfo</span></td>
      </tr>
      <tr>
        <td id="L254" data-line-number="254"></td>
        <td id="LC254"><span>typedef</span> <span>DPTR</span>(GenericsDictInfo) PTR_GenericsDictInfo;</td>
      </tr>
      <tr>
        <td id="L255" data-line-number="255"></td>
        <td id="LC255">
</td>
      </tr>
      <tr>
        <td id="L256" data-line-number="256"></td>
        <td id="LC256"><span>struct</span> GenericsStaticsInfo</td>
      </tr>
      <tr>
        <td id="L257" data-line-number="257"></td>
        <td id="LC257">{</td>
      </tr>
      <tr>
        <td id="L258" data-line-number="258"></td>
        <td id="LC258">    <span><span>//</span> Pointer to field descs for statics</span></td>
      </tr>
      <tr>
        <td id="L259" data-line-number="259"></td>
        <td id="LC259">    RelativePointer&lt;PTR_FieldDesc&gt; m_pFieldDescs;</td>
      </tr>
      <tr>
        <td id="L260" data-line-number="260"></td>
        <td id="LC260">
</td>
      </tr>
      <tr>
        <td id="L261" data-line-number="261"></td>
        <td id="LC261">    <span><span>//</span> Method table ID for statics</span></td>
      </tr>
      <tr>
        <td id="L262" data-line-number="262"></td>
        <td id="LC262">    SIZE_T              m_DynamicTypeID;</td>
      </tr>
      <tr>
        <td id="L263" data-line-number="263"></td>
        <td id="LC263">
</td>
      </tr>
      <tr>
        <td id="L264" data-line-number="264"></td>
        <td id="LC264">};  <span><span>//</span> struct GenericsStaticsInfo</span></td>
      </tr>
      <tr>
        <td id="L265" data-line-number="265"></td>
        <td id="LC265"><span>typedef</span> <span>DPTR</span>(GenericsStaticsInfo) PTR_GenericsStaticsInfo;</td>
      </tr>
      <tr>
        <td id="L266" data-line-number="266"></td>
        <td id="LC266">
</td>
      </tr>
      <tr>
        <td id="L267" data-line-number="267"></td>
        <td id="LC267">
</td>
      </tr>
      <tr>
        <td id="L268" data-line-number="268"></td>
        <td id="LC268"><span><span>//</span> CrossModuleGenericsStaticsInfo is used in NGen images for statics of cross-module</span></td>
      </tr>
      <tr>
        <td id="L269" data-line-number="269"></td>
        <td id="LC269"><span><span>//</span> generic instantiations. CrossModuleGenericsStaticsInfo is optional member of</span></td>
      </tr>
      <tr>
        <td id="L270" data-line-number="270"></td>
        <td id="LC270"><span><span>//</span> MethodTableWriteableData.</span></td>
      </tr>
      <tr>
        <td id="L271" data-line-number="271"></td>
        <td id="LC271"><span>struct</span> CrossModuleGenericsStaticsInfo</td>
      </tr>
      <tr>
        <td id="L272" data-line-number="272"></td>
        <td id="LC272">{</td>
      </tr>
      <tr>
        <td id="L273" data-line-number="273"></td>
        <td id="LC273">    <span><span>//</span> Module this method table statics are attached to.</span></td>
      </tr>
      <tr>
        <td id="L274" data-line-number="274"></td>
        <td id="LC274">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L275" data-line-number="275"></td>
        <td id="LC275">    <span><span>//</span> The statics has to be attached to module referenced from the generic instantiation</span></td>
      </tr>
      <tr>
        <td id="L276" data-line-number="276"></td>
        <td id="LC276">    <span><span>//</span> in domain-neutral code. We need to guarantee that the module for the statics</span></td>
      </tr>
      <tr>
        <td id="L277" data-line-number="277"></td>
        <td id="LC277">    <span><span>//</span> has a valid local represenation in an appdomain.</span></td>
      </tr>
      <tr>
        <td id="L278" data-line-number="278"></td>
        <td id="LC278">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L279" data-line-number="279"></td>
        <td id="LC279">    PTR_Module          m_pModuleForStatics;</td>
      </tr>
      <tr>
        <td id="L280" data-line-number="280"></td>
        <td id="LC280">
</td>
      </tr>
      <tr>
        <td id="L281" data-line-number="281"></td>
        <td id="LC281">    <span><span>//</span> Method table ID for statics</span></td>
      </tr>
      <tr>
        <td id="L282" data-line-number="282"></td>
        <td id="LC282">    SIZE_T              m_DynamicTypeID;</td>
      </tr>
      <tr>
        <td id="L283" data-line-number="283"></td>
        <td id="LC283">};  <span><span>//</span> struct CrossModuleGenericsStaticsInfo</span></td>
      </tr>
      <tr>
        <td id="L284" data-line-number="284"></td>
        <td id="LC284"><span>typedef</span> <span>DPTR</span>(CrossModuleGenericsStaticsInfo) PTR_CrossModuleGenericsStaticsInfo;</td>
      </tr>
      <tr>
        <td id="L285" data-line-number="285"></td>
        <td id="LC285">
</td>
      </tr>
      <tr>
        <td id="L286" data-line-number="286"></td>
        <td id="LC286">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L287" data-line-number="287"></td>
        <td id="LC287"><span>struct</span> RCWPerTypeData;</td>
      </tr>
      <tr>
        <td id="L288" data-line-number="288"></td>
        <td id="LC288">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L289" data-line-number="289"></td>
        <td id="LC289">
</td>
      </tr>
      <tr>
        <td id="L290" data-line-number="290"></td>
        <td id="LC290"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L291" data-line-number="291"></td>
        <td id="LC291"><span><span>//</span> This struct consolidates the writeable parts of the MethodTable</span></td>
      </tr>
      <tr>
        <td id="L292" data-line-number="292"></td>
        <td id="LC292"><span><span>//</span> so that we can layout a read-only MethodTable with a pointer</span></td>
      </tr>
      <tr>
        <td id="L293" data-line-number="293"></td>
        <td id="LC293"><span><span>//</span> to the writeable parts of the MethodTable in an ngen image</span></td>
      </tr>
      <tr>
        <td id="L294" data-line-number="294"></td>
        <td id="LC294"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L295" data-line-number="295"></td>
        <td id="LC295"><span>struct</span> MethodTableWriteableData</td>
      </tr>
      <tr>
        <td id="L296" data-line-number="296"></td>
        <td id="LC296">{</td>
      </tr>
      <tr>
        <td id="L297" data-line-number="297"></td>
        <td id="LC297">    friend class MethodTable;</td>
      </tr>
      <tr>
        <td id="L298" data-line-number="298"></td>
        <td id="LC298">#<span>if</span> defined(DACCESS_COMPILE)</td>
      </tr>
      <tr>
        <td id="L299" data-line-number="299"></td>
        <td id="LC299">    friend class NativeImageDumper;</td>
      </tr>
      <tr>
        <td id="L300" data-line-number="300"></td>
        <td id="LC300">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L301" data-line-number="301"></td>
        <td id="LC301">
</td>
      </tr>
      <tr>
        <td id="L302" data-line-number="302"></td>
        <td id="LC302">    <span>enum</span></td>
      </tr>
      <tr>
        <td id="L303" data-line-number="303"></td>
        <td id="LC303">    {</td>
      </tr>
      <tr>
        <td id="L304" data-line-number="304"></td>
        <td id="LC304">        <span><span>//</span> AS YOU ADD NEW FLAGS PLEASE CONSIDER WHETHER Generics::NewInstantiation NEEDS</span></td>
      </tr>
      <tr>
        <td id="L305" data-line-number="305"></td>
        <td id="LC305">        <span><span>//</span> TO BE UPDATED IN ORDER TO ENSURE THAT METHODTABLES DUPLICATED FOR GENERIC INSTANTIATIONS</span></td>
      </tr>
      <tr>
        <td id="L306" data-line-number="306"></td>
        <td id="LC306">        <span><span>//</span> CARRY THE CORRECT INITIAL FLAGS.</span></td>
      </tr>
      <tr>
        <td id="L307" data-line-number="307"></td>
        <td id="LC307">
</td>
      </tr>
      <tr>
        <td id="L308" data-line-number="308"></td>
        <td id="LC308">        enum_flag_Unrestored                = <span>0x00000004</span>,</td>
      </tr>
      <tr>
        <td id="L309" data-line-number="309"></td>
        <td id="LC309">        enum_flag_HasApproxParent           = <span>0x00000010</span>,</td>
      </tr>
      <tr>
        <td id="L310" data-line-number="310"></td>
        <td id="LC310">        enum_flag_UnrestoredTypeKey         = <span>0x00000020</span>,</td>
      </tr>
      <tr>
        <td id="L311" data-line-number="311"></td>
        <td id="LC311">        enum_flag_IsNotFullyLoaded          = <span>0x00000040</span>,</td>
      </tr>
      <tr>
        <td id="L312" data-line-number="312"></td>
        <td id="LC312">        enum_flag_DependenciesLoaded        = <span>0x00000080</span>,     <span><span>//</span> class and all depedencies loaded up to CLASS_LOADED_BUT_NOT_VERIFIED</span></td>
      </tr>
      <tr>
        <td id="L313" data-line-number="313"></td>
        <td id="LC313">
</td>
      </tr>
      <tr>
        <td id="L314" data-line-number="314"></td>
        <td id="LC314">        enum_flag_SkipWinRTOverride         = <span>0x00000100</span>,     <span><span>//</span> No WinRT override is needed</span></td>
      </tr>
      <tr>
        <td id="L315" data-line-number="315"></td>
        <td id="LC315">
</td>
      </tr>
      <tr>
        <td id="L316" data-line-number="316"></td>
        <td id="LC316">        enum_flag_CanCompareBitsOrUseFastGetHashCode       = <span>0x00000200</span>,     <span><span>//</span> Is any field type or sub field type overrode Equals or GetHashCode</span></td>
      </tr>
      <tr>
        <td id="L317" data-line-number="317"></td>
        <td id="LC317">        enum_flag_HasCheckedCanCompareBitsOrUseFastGetHashCode   = <span>0x00000400</span>,  <span><span>//</span> Whether we have checked the overridden Equals or GetHashCode</span></td>
      </tr>
      <tr>
        <td id="L318" data-line-number="318"></td>
        <td id="LC318">
</td>
      </tr>
      <tr>
        <td id="L319" data-line-number="319"></td>
        <td id="LC319">#<span>ifdef</span> FEATURE_PREJIT</td>
      </tr>
      <tr>
        <td id="L320" data-line-number="320"></td>
        <td id="LC320">        <span><span>//</span> These flags are used only at ngen time. We store them here since</span></td>
      </tr>
      <tr>
        <td id="L321" data-line-number="321"></td>
        <td id="LC321">        <span><span>//</span> we are running out of available flags in MethodTable. They may eventually</span></td>
      </tr>
      <tr>
        <td id="L322" data-line-number="322"></td>
        <td id="LC322">        <span><span>//</span> go into ngen speficic state.</span></td>
      </tr>
      <tr>
        <td id="L323" data-line-number="323"></td>
        <td id="LC323">        enum_flag_NGEN_IsFixedUp            = <span>0x00010000</span>, <span><span>//</span> This MT has been fixed up during NGEN</span></td>
      </tr>
      <tr>
        <td id="L324" data-line-number="324"></td>
        <td id="LC324">        enum_flag_NGEN_IsNeedsRestoreCached = <span>0x00020000</span>, <span><span>//</span> Set if we have cached the results of needs restore computation</span></td>
      </tr>
      <tr>
        <td id="L325" data-line-number="325"></td>
        <td id="LC325">        enum_flag_NGEN_CachedNeedsRestore   = <span>0x00040000</span>, <span><span>//</span> The result of the needs restore computation</span></td>
      </tr>
      <tr>
        <td id="L326" data-line-number="326"></td>
        <td id="LC326">        enum_flag_NGEN_OverridingInterface  = <span>0x00080000</span>, <span><span>//</span> Overriding interface that we should generate WinRT CCW stubs for.</span></td>
      </tr>
      <tr>
        <td id="L327" data-line-number="327"></td>
        <td id="LC327">
</td>
      </tr>
      <tr>
        <td id="L328" data-line-number="328"></td>
        <td id="LC328">#<span>ifdef</span> FEATURE_READYTORUN_COMPILER</td>
      </tr>
      <tr>
        <td id="L329" data-line-number="329"></td>
        <td id="LC329">        enum_flag_NGEN_IsLayoutFixedComputed                    = <span>0x0010000</span>, <span><span>//</span> Set if we have cached the result of IsLayoutFixed computation</span></td>
      </tr>
      <tr>
        <td id="L330" data-line-number="330"></td>
        <td id="LC330">        enum_flag_NGEN_IsLayoutFixed                            = <span>0x0020000</span>, <span><span>//</span> The result of the IsLayoutFixed computation</span></td>
      </tr>
      <tr>
        <td id="L331" data-line-number="331"></td>
        <td id="LC331">        enum_flag_NGEN_IsLayoutInCurrentVersionBubbleComputed   = <span>0x0040000</span>, <span><span>//</span> Set if we have cached the result of IsLayoutInCurrentVersionBubble computation</span></td>
      </tr>
      <tr>
        <td id="L332" data-line-number="332"></td>
        <td id="LC332">        enum_flag_NGEN_IsLayoutInCurrentVersionBubble           = <span>0x0080000</span>, <span><span>//</span> The result of the IsLayoutInCurrentVersionBubble computation</span></td>
      </tr>
      <tr>
        <td id="L333" data-line-number="333"></td>
        <td id="LC333">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L334" data-line-number="334"></td>
        <td id="LC334">
</td>
      </tr>
      <tr>
        <td id="L335" data-line-number="335"></td>
        <td id="LC335">#<span>endif</span> <span><span>//</span> FEATURE_PREJIT</span></td>
      </tr>
      <tr>
        <td id="L336" data-line-number="336"></td>
        <td id="LC336">
</td>
      </tr>
      <tr>
        <td id="L337" data-line-number="337"></td>
        <td id="LC337">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L338" data-line-number="338"></td>
        <td id="LC338">        enum_flag_ParentMethodTablePointerValid =  <span>0x40000000</span>,</td>
      </tr>
      <tr>
        <td id="L339" data-line-number="339"></td>
        <td id="LC339">        enum_flag_HasInjectedInterfaceDuplicates = <span>0x80000000</span>,</td>
      </tr>
      <tr>
        <td id="L340" data-line-number="340"></td>
        <td id="LC340">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L341" data-line-number="341"></td>
        <td id="LC341">    };</td>
      </tr>
      <tr>
        <td id="L342" data-line-number="342"></td>
        <td id="LC342">    DWORD      m_dwFlags;                  <span><span>//</span> Lot of empty bits here.</span></td>
      </tr>
      <tr>
        <td id="L343" data-line-number="343"></td>
        <td id="LC343">
</td>
      </tr>
      <tr>
        <td id="L344" data-line-number="344"></td>
        <td id="LC344">    <span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L345" data-line-number="345"></td>
        <td id="LC345"><span>     * m_hExposedClassObject is LoaderAllocator slot index to</span></td>
      </tr>
      <tr>
        <td id="L346" data-line-number="346"></td>
        <td id="LC346"><span>     * a RuntimeType instance for this class.</span></td>
      </tr>
      <tr>
        <td id="L347" data-line-number="347"></td>
        <td id="LC347"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L348" data-line-number="348"></td>
        <td id="LC348">    LOADERHANDLE m_hExposedClassObject;</td>
      </tr>
      <tr>
        <td id="L349" data-line-number="349"></td>
        <td id="LC349">
</td>
      </tr>
      <tr>
        <td id="L350" data-line-number="350"></td>
        <td id="LC350">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L351" data-line-number="351"></td>
        <td id="LC351">    <span><span>//</span> to avoid verify same method table too many times when it's not changing, we cache the GC count</span></td>
      </tr>
      <tr>
        <td id="L352" data-line-number="352"></td>
        <td id="LC352">    <span><span>//</span> on which the method table is verified. When fast GC STRESS is turned on, we only verify the MT if</span></td>
      </tr>
      <tr>
        <td id="L353" data-line-number="353"></td>
        <td id="LC353">    <span><span>//</span> current GC count is bigger than the number. Note most thing which will invalidate a MT will require a</span></td>
      </tr>
      <tr>
        <td id="L354" data-line-number="354"></td>
        <td id="LC354">    <span><span>//</span> GC (like AD unload)</span></td>
      </tr>
      <tr>
        <td id="L355" data-line-number="355"></td>
        <td id="LC355">    Volatile&lt;DWORD&gt; m_dwLastVerifedGCCnt;</td>
      </tr>
      <tr>
        <td id="L356" data-line-number="356"></td>
        <td id="LC356">
</td>
      </tr>
      <tr>
        <td id="L357" data-line-number="357"></td>
        <td id="LC357">#<span>ifdef</span> HOST_64BIT</td>
      </tr>
      <tr>
        <td id="L358" data-line-number="358"></td>
        <td id="LC358">    DWORD m_dwPadding;               <span><span>//</span> Just to keep the size a multiple of 8</span></td>
      </tr>
      <tr>
        <td id="L359" data-line-number="359"></td>
        <td id="LC359">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L360" data-line-number="360"></td>
        <td id="LC360">
</td>
      </tr>
      <tr>
        <td id="L361" data-line-number="361"></td>
        <td id="LC361">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L362" data-line-number="362"></td>
        <td id="LC362">
</td>
      </tr>
      <tr>
        <td id="L363" data-line-number="363"></td>
        <td id="LC363">    <span><span>//</span> Optional CrossModuleGenericsStaticsInfo may be here.</span></td>
      </tr>
      <tr>
        <td id="L364" data-line-number="364"></td>
        <td id="LC364">
</td>
      </tr>
      <tr>
        <td id="L365" data-line-number="365"></td>
        <td id="LC365">public:</td>
      </tr>
      <tr>
        <td id="L366" data-line-number="366"></td>
        <td id="LC366">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L367" data-line-number="367"></td>
        <td id="LC367">    <span>inline</span> BOOL <span>IsParentMethodTablePointerValid</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L368" data-line-number="368"></td>
        <td id="LC368">    {</td>
      </tr>
      <tr>
        <td id="L369" data-line-number="369"></td>
        <td id="LC369">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L370" data-line-number="370"></td>
        <td id="LC370">
</td>
      </tr>
      <tr>
        <td id="L371" data-line-number="371"></td>
        <td id="LC371">        <span>return</span> (m_dwFlags &amp; enum_flag_ParentMethodTablePointerValid);</td>
      </tr>
      <tr>
        <td id="L372" data-line-number="372"></td>
        <td id="LC372">    }</td>
      </tr>
      <tr>
        <td id="L373" data-line-number="373"></td>
        <td id="LC373">    <span>inline</span> <span>void</span> <span>SetParentMethodTablePointerValid</span>()</td>
      </tr>
      <tr>
        <td id="L374" data-line-number="374"></td>
        <td id="LC374">    {</td>
      </tr>
      <tr>
        <td id="L375" data-line-number="375"></td>
        <td id="LC375">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L376" data-line-number="376"></td>
        <td id="LC376">
</td>
      </tr>
      <tr>
        <td id="L377" data-line-number="377"></td>
        <td id="LC377">        m_dwFlags |= enum_flag_ParentMethodTablePointerValid;</td>
      </tr>
      <tr>
        <td id="L378" data-line-number="378"></td>
        <td id="LC378">    }</td>
      </tr>
      <tr>
        <td id="L379" data-line-number="379"></td>
        <td id="LC379">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L380" data-line-number="380"></td>
        <td id="LC380">
</td>
      </tr>
      <tr>
        <td id="L381" data-line-number="381"></td>
        <td id="LC381">#<span>ifdef</span> FEATURE_PREJIT</td>
      </tr>
      <tr>
        <td id="L382" data-line-number="382"></td>
        <td id="LC382">
</td>
      </tr>
      <tr>
        <td id="L383" data-line-number="383"></td>
        <td id="LC383">    <span>void</span> <span>Save</span>(DataImage *image, MethodTable *pMT, DWORD profilingFlags) <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L384" data-line-number="384"></td>
        <td id="LC384">    <span>void</span> <span>Fixup</span>(DataImage *image, MethodTable *pMT, BOOL needsRestore);</td>
      </tr>
      <tr>
        <td id="L385" data-line-number="385"></td>
        <td id="LC385">
</td>
      </tr>
      <tr>
        <td id="L386" data-line-number="386"></td>
        <td id="LC386">    <span>inline</span> BOOL <span>IsFixedUp</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L387" data-line-number="387"></td>
        <td id="LC387">    {</td>
      </tr>
      <tr>
        <td id="L388" data-line-number="388"></td>
        <td id="LC388">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L389" data-line-number="389"></td>
        <td id="LC389">
</td>
      </tr>
      <tr>
        <td id="L390" data-line-number="390"></td>
        <td id="LC390">        <span>return</span> (m_dwFlags &amp; enum_flag_NGEN_IsFixedUp);</td>
      </tr>
      <tr>
        <td id="L391" data-line-number="391"></td>
        <td id="LC391">    }</td>
      </tr>
      <tr>
        <td id="L392" data-line-number="392"></td>
        <td id="LC392">    <span>inline</span> <span>void</span> <span>SetFixedUp</span>()</td>
      </tr>
      <tr>
        <td id="L393" data-line-number="393"></td>
        <td id="LC393">    {</td>
      </tr>
      <tr>
        <td id="L394" data-line-number="394"></td>
        <td id="LC394">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L395" data-line-number="395"></td>
        <td id="LC395">
</td>
      </tr>
      <tr>
        <td id="L396" data-line-number="396"></td>
        <td id="LC396">        m_dwFlags |= enum_flag_NGEN_IsFixedUp;</td>
      </tr>
      <tr>
        <td id="L397" data-line-number="397"></td>
        <td id="LC397">    }</td>
      </tr>
      <tr>
        <td id="L398" data-line-number="398"></td>
        <td id="LC398">
</td>
      </tr>
      <tr>
        <td id="L399" data-line-number="399"></td>
        <td id="LC399">    <span>inline</span> BOOL <span>IsNeedsRestoreCached</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L400" data-line-number="400"></td>
        <td id="LC400">    {</td>
      </tr>
      <tr>
        <td id="L401" data-line-number="401"></td>
        <td id="LC401">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L402" data-line-number="402"></td>
        <td id="LC402">
</td>
      </tr>
      <tr>
        <td id="L403" data-line-number="403"></td>
        <td id="LC403">        <span>return</span> (m_dwFlags &amp; enum_flag_NGEN_IsNeedsRestoreCached);</td>
      </tr>
      <tr>
        <td id="L404" data-line-number="404"></td>
        <td id="LC404">    }</td>
      </tr>
      <tr>
        <td id="L405" data-line-number="405"></td>
        <td id="LC405">
</td>
      </tr>
      <tr>
        <td id="L406" data-line-number="406"></td>
        <td id="LC406">    <span>inline</span> BOOL <span>GetCachedNeedsRestore</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L407" data-line-number="407"></td>
        <td id="LC407">    {</td>
      </tr>
      <tr>
        <td id="L408" data-line-number="408"></td>
        <td id="LC408">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L409" data-line-number="409"></td>
        <td id="LC409">
</td>
      </tr>
      <tr>
        <td id="L410" data-line-number="410"></td>
        <td id="LC410">        <span>_ASSERTE</span>(<span>IsNeedsRestoreCached</span>());</td>
      </tr>
      <tr>
        <td id="L411" data-line-number="411"></td>
        <td id="LC411">        <span>return</span> (m_dwFlags &amp; enum_flag_NGEN_CachedNeedsRestore);</td>
      </tr>
      <tr>
        <td id="L412" data-line-number="412"></td>
        <td id="LC412">    }</td>
      </tr>
      <tr>
        <td id="L413" data-line-number="413"></td>
        <td id="LC413">
</td>
      </tr>
      <tr>
        <td id="L414" data-line-number="414"></td>
        <td id="LC414">    <span>inline</span> <span>void</span> <span>SetCachedNeedsRestore</span>(BOOL fNeedsRestore)</td>
      </tr>
      <tr>
        <td id="L415" data-line-number="415"></td>
        <td id="LC415">    {</td>
      </tr>
      <tr>
        <td id="L416" data-line-number="416"></td>
        <td id="LC416">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L417" data-line-number="417"></td>
        <td id="LC417">
</td>
      </tr>
      <tr>
        <td id="L418" data-line-number="418"></td>
        <td id="LC418">        <span>_ASSERTE</span>(!<span>IsNeedsRestoreCached</span>());</td>
      </tr>
      <tr>
        <td id="L419" data-line-number="419"></td>
        <td id="LC419">        m_dwFlags |= enum_flag_NGEN_IsNeedsRestoreCached;</td>
      </tr>
      <tr>
        <td id="L420" data-line-number="420"></td>
        <td id="LC420">        <span>if</span> (fNeedsRestore) m_dwFlags |= enum_flag_NGEN_CachedNeedsRestore;</td>
      </tr>
      <tr>
        <td id="L421" data-line-number="421"></td>
        <td id="LC421">    }</td>
      </tr>
      <tr>
        <td id="L422" data-line-number="422"></td>
        <td id="LC422">
</td>
      </tr>
      <tr>
        <td id="L423" data-line-number="423"></td>
        <td id="LC423">    <span>inline</span> <span>void</span> <span>SetIsOverridingInterface</span>()</td>
      </tr>
      <tr>
        <td id="L424" data-line-number="424"></td>
        <td id="LC424">    {</td>
      </tr>
      <tr>
        <td id="L425" data-line-number="425"></td>
        <td id="LC425">        CONTRACTL</td>
      </tr>
      <tr>
        <td id="L426" data-line-number="426"></td>
        <td id="LC426">        {</td>
      </tr>
      <tr>
        <td id="L427" data-line-number="427"></td>
        <td id="LC427">            THROWS;</td>
      </tr>
      <tr>
        <td id="L428" data-line-number="428"></td>
        <td id="LC428">            GC_NOTRIGGER;</td>
      </tr>
      <tr>
        <td id="L429" data-line-number="429"></td>
        <td id="LC429">            MODE_ANY;</td>
      </tr>
      <tr>
        <td id="L430" data-line-number="430"></td>
        <td id="LC430">        }</td>
      </tr>
      <tr>
        <td id="L431" data-line-number="431"></td>
        <td id="LC431">        CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L432" data-line-number="432"></td>
        <td id="LC432">
</td>
      </tr>
      <tr>
        <td id="L433" data-line-number="433"></td>
        <td id="LC433">        <span>if</span> ((m_dwFlags &amp; enum_flag_NGEN_OverridingInterface) != <span>0</span>) <span>return</span>;</td>
      </tr>
      <tr>
        <td id="L434" data-line-number="434"></td>
        <td id="LC434">        <span>FastInterlockOr</span>((ULONG *) &amp;m_dwFlags, enum_flag_NGEN_OverridingInterface);</td>
      </tr>
      <tr>
        <td id="L435" data-line-number="435"></td>
        <td id="LC435">    }</td>
      </tr>
      <tr>
        <td id="L436" data-line-number="436"></td>
        <td id="LC436">
</td>
      </tr>
      <tr>
        <td id="L437" data-line-number="437"></td>
        <td id="LC437">    <span>inline</span> BOOL <span>IsOverridingInterface</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L438" data-line-number="438"></td>
        <td id="LC438">    {</td>
      </tr>
      <tr>
        <td id="L439" data-line-number="439"></td>
        <td id="LC439">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L440" data-line-number="440"></td>
        <td id="LC440">        <span>return</span> (m_dwFlags &amp; enum_flag_NGEN_OverridingInterface);</td>
      </tr>
      <tr>
        <td id="L441" data-line-number="441"></td>
        <td id="LC441">    }</td>
      </tr>
      <tr>
        <td id="L442" data-line-number="442"></td>
        <td id="LC442">#<span>endif</span> <span><span>//</span> FEATURE_PREJIT</span></td>
      </tr>
      <tr>
        <td id="L443" data-line-number="443"></td>
        <td id="LC443">
</td>
      </tr>
      <tr>
        <td id="L444" data-line-number="444"></td>
        <td id="LC444">
</td>
      </tr>
      <tr>
        <td id="L445" data-line-number="445"></td>
        <td id="LC445">    <span>inline</span> LOADERHANDLE <span>GetExposedClassObjectHandle</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L446" data-line-number="446"></td>
        <td id="LC446">    {</td>
      </tr>
      <tr>
        <td id="L447" data-line-number="447"></td>
        <td id="LC447">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L448" data-line-number="448"></td>
        <td id="LC448">        <span>return</span> m_hExposedClassObject;</td>
      </tr>
      <tr>
        <td id="L449" data-line-number="449"></td>
        <td id="LC449">    }</td>
      </tr>
      <tr>
        <td id="L450" data-line-number="450"></td>
        <td id="LC450">
</td>
      </tr>
      <tr>
        <td id="L451" data-line-number="451"></td>
        <td id="LC451">    <span>void</span> <span>SetIsNotFullyLoadedForBuildMethodTable</span>()</td>
      </tr>
      <tr>
        <td id="L452" data-line-number="452"></td>
        <td id="LC452">    {</td>
      </tr>
      <tr>
        <td id="L453" data-line-number="453"></td>
        <td id="LC453">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L454" data-line-number="454"></td>
        <td id="LC454">
</td>
      </tr>
      <tr>
        <td id="L455" data-line-number="455"></td>
        <td id="LC455">        <span><span>//</span> Used only during method table initialization - no need for logging or Interlocked Exchange.</span></td>
      </tr>
      <tr>
        <td id="L456" data-line-number="456"></td>
        <td id="LC456">        m_dwFlags |= (MethodTableWriteableData::enum_flag_UnrestoredTypeKey |</td>
      </tr>
      <tr>
        <td id="L457" data-line-number="457"></td>
        <td id="LC457">                      MethodTableWriteableData::enum_flag_Unrestored |</td>
      </tr>
      <tr>
        <td id="L458" data-line-number="458"></td>
        <td id="LC458">                      MethodTableWriteableData::enum_flag_IsNotFullyLoaded |</td>
      </tr>
      <tr>
        <td id="L459" data-line-number="459"></td>
        <td id="LC459">                      MethodTableWriteableData::enum_flag_HasApproxParent);</td>
      </tr>
      <tr>
        <td id="L460" data-line-number="460"></td>
        <td id="LC460">    }</td>
      </tr>
      <tr>
        <td id="L461" data-line-number="461"></td>
        <td id="LC461">
</td>
      </tr>
      <tr>
        <td id="L462" data-line-number="462"></td>
        <td id="LC462">    <span>void</span> <span>SetIsRestoredForBuildMethodTable</span>()</td>
      </tr>
      <tr>
        <td id="L463" data-line-number="463"></td>
        <td id="LC463">    {</td>
      </tr>
      <tr>
        <td id="L464" data-line-number="464"></td>
        <td id="LC464">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L465" data-line-number="465"></td>
        <td id="LC465">
</td>
      </tr>
      <tr>
        <td id="L466" data-line-number="466"></td>
        <td id="LC466">        <span><span>//</span> Used only during method table initialization - no need for logging or Interlocked Exchange.</span></td>
      </tr>
      <tr>
        <td id="L467" data-line-number="467"></td>
        <td id="LC467">        m_dwFlags &amp;= ~(MethodTableWriteableData::enum_flag_UnrestoredTypeKey |</td>
      </tr>
      <tr>
        <td id="L468" data-line-number="468"></td>
        <td id="LC468">                       MethodTableWriteableData::enum_flag_Unrestored);</td>
      </tr>
      <tr>
        <td id="L469" data-line-number="469"></td>
        <td id="LC469">    }</td>
      </tr>
      <tr>
        <td id="L470" data-line-number="470"></td>
        <td id="LC470">
</td>
      </tr>
      <tr>
        <td id="L471" data-line-number="471"></td>
        <td id="LC471">    <span>void</span> <span>SetIsRestoredForBuildArrayMethodTable</span>()</td>
      </tr>
      <tr>
        <td id="L472" data-line-number="472"></td>
        <td id="LC472">    {</td>
      </tr>
      <tr>
        <td id="L473" data-line-number="473"></td>
        <td id="LC473">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L474" data-line-number="474"></td>
        <td id="LC474">
</td>
      </tr>
      <tr>
        <td id="L475" data-line-number="475"></td>
        <td id="LC475">        <span><span>//</span> Used only during method table initialization - no need for logging or Interlocked Exchange.</span></td>
      </tr>
      <tr>
        <td id="L476" data-line-number="476"></td>
        <td id="LC476">        <span>SetIsRestoredForBuildMethodTable</span>();</td>
      </tr>
      <tr>
        <td id="L477" data-line-number="477"></td>
        <td id="LC477">
</td>
      </tr>
      <tr>
        <td id="L478" data-line-number="478"></td>
        <td id="LC478">        <span><span>//</span> Array's parent is always precise </span></td>
      </tr>
      <tr>
        <td id="L479" data-line-number="479"></td>
        <td id="LC479">        m_dwFlags &amp;= ~(MethodTableWriteableData::enum_flag_HasApproxParent);</td>
      </tr>
      <tr>
        <td id="L480" data-line-number="480"></td>
        <td id="LC480">
</td>
      </tr>
      <tr>
        <td id="L481" data-line-number="481"></td>
        <td id="LC481">    }</td>
      </tr>
      <tr>
        <td id="L482" data-line-number="482"></td>
        <td id="LC482">
</td>
      </tr>
      <tr>
        <td id="L483" data-line-number="483"></td>
        <td id="LC483">    <span>inline</span> CrossModuleGenericsStaticsInfo * <span>GetCrossModuleGenericsStaticsInfo</span>()</td>
      </tr>
      <tr>
        <td id="L484" data-line-number="484"></td>
        <td id="LC484">    {</td>
      </tr>
      <tr>
        <td id="L485" data-line-number="485"></td>
        <td id="LC485">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L486" data-line-number="486"></td>
        <td id="LC486">
</td>
      </tr>
      <tr>
        <td id="L487" data-line-number="487"></td>
        <td id="LC487">        SIZE_T size = <span>sizeof</span>(MethodTableWriteableData);</td>
      </tr>
      <tr>
        <td id="L488" data-line-number="488"></td>
        <td id="LC488">        <span>return</span> <span>PTR_CrossModuleGenericsStaticsInfo</span>(dac_cast&lt;TADDR&gt;(this) + size);</td>
      </tr>
      <tr>
        <td id="L489" data-line-number="489"></td>
        <td id="LC489">    }</td>
      </tr>
      <tr>
        <td id="L490" data-line-number="490"></td>
        <td id="LC490">
</td>
      </tr>
      <tr>
        <td id="L491" data-line-number="491"></td>
        <td id="LC491">};  <span><span>//</span> struct MethodTableWriteableData</span></td>
      </tr>
      <tr>
        <td id="L492" data-line-number="492"></td>
        <td id="LC492">
</td>
      </tr>
      <tr>
        <td id="L493" data-line-number="493"></td>
        <td id="LC493"><span>typedef</span> <span>DPTR</span>(MethodTableWriteableData) PTR_MethodTableWriteableData;</td>
      </tr>
      <tr>
        <td id="L494" data-line-number="494"></td>
        <td id="LC494"><span>typedef</span> <span>DPTR</span>(MethodTableWriteableData <span>const</span>) PTR_Const_MethodTableWriteableData;</td>
      </tr>
      <tr>
        <td id="L495" data-line-number="495"></td>
        <td id="LC495">
</td>
      </tr>
      <tr>
        <td id="L496" data-line-number="496"></td>
        <td id="LC496">#<span>ifdef</span> UNIX_AMD64_ABI_ITF</td>
      </tr>
      <tr>
        <td id="L497" data-line-number="497"></td>
        <td id="LC497"><span>inline</span></td>
      </tr>
      <tr>
        <td id="L498" data-line-number="498"></td>
        <td id="LC498">SystemVClassificationType <span>CorInfoType2UnixAmd64Classification</span>(CorElementType eeType)</td>
      </tr>
      <tr>
        <td id="L499" data-line-number="499"></td>
        <td id="LC499">{</td>
      </tr>
      <tr>
        <td id="L500" data-line-number="500"></td>
        <td id="LC500">    <span>static</span> <span>const</span> SystemVClassificationType toSystemVAmd64ClassificationTypeMap[] = {</td>
      </tr>
      <tr>
        <td id="L501" data-line-number="501"></td>
        <td id="LC501">        SystemVClassificationTypeUnknown,               <span><span>//</span> ELEMENT_TYPE_END</span></td>
      </tr>
      <tr>
        <td id="L502" data-line-number="502"></td>
        <td id="LC502">        SystemVClassificationTypeUnknown,               <span><span>//</span> ELEMENT_TYPE_VOID</span></td>
      </tr>
      <tr>
        <td id="L503" data-line-number="503"></td>
        <td id="LC503">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_BOOLEAN</span></td>
      </tr>
      <tr>
        <td id="L504" data-line-number="504"></td>
        <td id="LC504">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_CHAR</span></td>
      </tr>
      <tr>
        <td id="L505" data-line-number="505"></td>
        <td id="LC505">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_I1</span></td>
      </tr>
      <tr>
        <td id="L506" data-line-number="506"></td>
        <td id="LC506">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_U1</span></td>
      </tr>
      <tr>
        <td id="L507" data-line-number="507"></td>
        <td id="LC507">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_I2</span></td>
      </tr>
      <tr>
        <td id="L508" data-line-number="508"></td>
        <td id="LC508">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_U2</span></td>
      </tr>
      <tr>
        <td id="L509" data-line-number="509"></td>
        <td id="LC509">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_I4</span></td>
      </tr>
      <tr>
        <td id="L510" data-line-number="510"></td>
        <td id="LC510">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_U4</span></td>
      </tr>
      <tr>
        <td id="L511" data-line-number="511"></td>
        <td id="LC511">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_I8</span></td>
      </tr>
      <tr>
        <td id="L512" data-line-number="512"></td>
        <td id="LC512">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_U8</span></td>
      </tr>
      <tr>
        <td id="L513" data-line-number="513"></td>
        <td id="LC513">        SystemVClassificationTypeSSE,                   <span><span>//</span> ELEMENT_TYPE_R4</span></td>
      </tr>
      <tr>
        <td id="L514" data-line-number="514"></td>
        <td id="LC514">        SystemVClassificationTypeSSE,                   <span><span>//</span> ELEMENT_TYPE_R8</span></td>
      </tr>
      <tr>
        <td id="L515" data-line-number="515"></td>
        <td id="LC515">        SystemVClassificationTypeIntegerReference,      <span><span>//</span> ELEMENT_TYPE_STRING</span></td>
      </tr>
      <tr>
        <td id="L516" data-line-number="516"></td>
        <td id="LC516">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_PTR</span></td>
      </tr>
      <tr>
        <td id="L517" data-line-number="517"></td>
        <td id="LC517">        SystemVClassificationTypeIntegerByRef,          <span><span>//</span> ELEMENT_TYPE_BYREF</span></td>
      </tr>
      <tr>
        <td id="L518" data-line-number="518"></td>
        <td id="LC518">        SystemVClassificationTypeStruct,                <span><span>//</span> ELEMENT_TYPE_VALUETYPE</span></td>
      </tr>
      <tr>
        <td id="L519" data-line-number="519"></td>
        <td id="LC519">        SystemVClassificationTypeIntegerReference,      <span><span>//</span> ELEMENT_TYPE_CLASS</span></td>
      </tr>
      <tr>
        <td id="L520" data-line-number="520"></td>
        <td id="LC520">        SystemVClassificationTypeIntegerReference,      <span><span>//</span> ELEMENT_TYPE_VAR (type variable)</span></td>
      </tr>
      <tr>
        <td id="L521" data-line-number="521"></td>
        <td id="LC521">        SystemVClassificationTypeIntegerReference,      <span><span>//</span> ELEMENT_TYPE_ARRAY</span></td>
      </tr>
      <tr>
        <td id="L522" data-line-number="522"></td>
        <td id="LC522">        SystemVClassificationTypeIntegerReference,      <span><span>//</span> ELEMENT_TYPE_GENERICINST</span></td>
      </tr>
      <tr>
        <td id="L523" data-line-number="523"></td>
        <td id="LC523">        SystemVClassificationTypeStruct,                <span><span>//</span> ELEMENT_TYPE_TYPEDBYREF</span></td>
      </tr>
      <tr>
        <td id="L524" data-line-number="524"></td>
        <td id="LC524">        SystemVClassificationTypeUnknown,               <span><span>//</span> ELEMENT_TYPE_VALUEARRAY_UNSUPPORTED</span></td>
      </tr>
      <tr>
        <td id="L525" data-line-number="525"></td>
        <td id="LC525">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_I</span></td>
      </tr>
      <tr>
        <td id="L526" data-line-number="526"></td>
        <td id="LC526">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_U</span></td>
      </tr>
      <tr>
        <td id="L527" data-line-number="527"></td>
        <td id="LC527">        SystemVClassificationTypeUnknown,               <span><span>//</span> ELEMENT_TYPE_R_UNSUPPORTED</span></td>
      </tr>
      <tr>
        <td id="L528" data-line-number="528"></td>
        <td id="LC528">
</td>
      </tr>
      <tr>
        <td id="L529" data-line-number="529"></td>
        <td id="LC529">        <span><span>//</span> put the correct type when we know our implementation</span></td>
      </tr>
      <tr>
        <td id="L530" data-line-number="530"></td>
        <td id="LC530">        SystemVClassificationTypeInteger,               <span><span>//</span> ELEMENT_TYPE_FNPTR</span></td>
      </tr>
      <tr>
        <td id="L531" data-line-number="531"></td>
        <td id="LC531">        SystemVClassificationTypeIntegerReference,      <span><span>//</span> ELEMENT_TYPE_OBJECT</span></td>
      </tr>
      <tr>
        <td id="L532" data-line-number="532"></td>
        <td id="LC532">        SystemVClassificationTypeIntegerReference,      <span><span>//</span> ELEMENT_TYPE_SZARRAY</span></td>
      </tr>
      <tr>
        <td id="L533" data-line-number="533"></td>
        <td id="LC533">        SystemVClassificationTypeIntegerReference,      <span><span>//</span> ELEMENT_TYPE_MVAR</span></td>
      </tr>
      <tr>
        <td id="L534" data-line-number="534"></td>
        <td id="LC534">
</td>
      </tr>
      <tr>
        <td id="L535" data-line-number="535"></td>
        <td id="LC535">        SystemVClassificationTypeUnknown,               <span><span>//</span> ELEMENT_TYPE_CMOD_REQD</span></td>
      </tr>
      <tr>
        <td id="L536" data-line-number="536"></td>
        <td id="LC536">        SystemVClassificationTypeUnknown,               <span><span>//</span> ELEMENT_TYPE_CMOD_OPT</span></td>
      </tr>
      <tr>
        <td id="L537" data-line-number="537"></td>
        <td id="LC537">        SystemVClassificationTypeUnknown,               <span><span>//</span> ELEMENT_TYPE_INTERNAL</span></td>
      </tr>
      <tr>
        <td id="L538" data-line-number="538"></td>
        <td id="LC538">    };</td>
      </tr>
      <tr>
        <td id="L539" data-line-number="539"></td>
        <td id="LC539">
</td>
      </tr>
      <tr>
        <td id="L540" data-line-number="540"></td>
        <td id="LC540">    <span>_ASSERTE</span>(<span>sizeof</span>(toSystemVAmd64ClassificationTypeMap) == ELEMENT_TYPE_MAX);</td>
      </tr>
      <tr>
        <td id="L541" data-line-number="541"></td>
        <td id="LC541">    <span>_ASSERTE</span>(eeType &lt; (CorElementType) <span>sizeof</span>(toSystemVAmd64ClassificationTypeMap));</td>
      </tr>
      <tr>
        <td id="L542" data-line-number="542"></td>
        <td id="LC542">    <span><span>//</span> spot check of the map</span></td>
      </tr>
      <tr>
        <td id="L543" data-line-number="543"></td>
        <td id="LC543">    <span>_ASSERTE</span>((SystemVClassificationType)toSystemVAmd64ClassificationTypeMap[ELEMENT_TYPE_I4] == SystemVClassificationTypeInteger);</td>
      </tr>
      <tr>
        <td id="L544" data-line-number="544"></td>
        <td id="LC544">    <span>_ASSERTE</span>((SystemVClassificationType)toSystemVAmd64ClassificationTypeMap[ELEMENT_TYPE_PTR] == SystemVClassificationTypeInteger);</td>
      </tr>
      <tr>
        <td id="L545" data-line-number="545"></td>
        <td id="LC545">    <span>_ASSERTE</span>((SystemVClassificationType)toSystemVAmd64ClassificationTypeMap[ELEMENT_TYPE_VALUETYPE] == SystemVClassificationTypeStruct);</td>
      </tr>
      <tr>
        <td id="L546" data-line-number="546"></td>
        <td id="LC546">    <span>_ASSERTE</span>((SystemVClassificationType)toSystemVAmd64ClassificationTypeMap[ELEMENT_TYPE_TYPEDBYREF] == SystemVClassificationTypeStruct);</td>
      </tr>
      <tr>
        <td id="L547" data-line-number="547"></td>
        <td id="LC547">    <span>_ASSERTE</span>((SystemVClassificationType)toSystemVAmd64ClassificationTypeMap[ELEMENT_TYPE_BYREF] == SystemVClassificationTypeIntegerByRef);</td>
      </tr>
      <tr>
        <td id="L548" data-line-number="548"></td>
        <td id="LC548">
</td>
      </tr>
      <tr>
        <td id="L549" data-line-number="549"></td>
        <td id="LC549">    <span>return</span> (((<span>unsigned</span>)eeType) &lt; ELEMENT_TYPE_MAX) ? (toSystemVAmd64ClassificationTypeMap[(<span>unsigned</span>)eeType]) : SystemVClassificationTypeUnknown;</td>
      </tr>
      <tr>
        <td id="L550" data-line-number="550"></td>
        <td id="LC550">};</td>
      </tr>
      <tr>
        <td id="L551" data-line-number="551"></td>
        <td id="LC551">
</td>
      </tr>
      <tr>
        <td id="L552" data-line-number="552"></td>
        <td id="LC552">#<span>define</span> <span>SYSTEMV_EIGHT_BYTE_SIZE_IN_BYTES</span>                    <span>8</span> <span><span>//</span> Size of an eightbyte in bytes.</span></td>
      </tr>
      <tr>
        <td id="L553" data-line-number="553"></td>
        <td id="LC553">#<span>define</span> <span>SYSTEMV_MAX_NUM_FIELDS_IN_REGISTER_PASSED_STRUCT</span>    <span>16</span> <span><span>//</span> Maximum number of fields in struct passed in registers</span></td>
      </tr>
      <tr>
        <td id="L554" data-line-number="554"></td>
        <td id="LC554">
</td>
      </tr>
      <tr>
        <td id="L555" data-line-number="555"></td>
        <td id="LC555"><span>struct</span> SystemVStructRegisterPassingHelper</td>
      </tr>
      <tr>
        <td id="L556" data-line-number="556"></td>
        <td id="LC556">{</td>
      </tr>
      <tr>
        <td id="L557" data-line-number="557"></td>
        <td id="LC557">    <span>SystemVStructRegisterPassingHelper</span>(<span>unsigned</span> <span>int</span> totalStructSize) :</td>
      </tr>
      <tr>
        <td id="L558" data-line-number="558"></td>
        <td id="LC558">        <span>structSize</span>(totalStructSize),</td>
      </tr>
      <tr>
        <td id="L559" data-line-number="559"></td>
        <td id="LC559">        <span>eightByteCount</span>(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L560" data-line-number="560"></td>
        <td id="LC560">        <span>inEmbeddedStruct</span>(<span>false</span>),</td>
      </tr>
      <tr>
        <td id="L561" data-line-number="561"></td>
        <td id="LC561">        <span>currentUniqueOffsetField</span>(<span>0</span>),</td>
      </tr>
      <tr>
        <td id="L562" data-line-number="562"></td>
        <td id="LC562">        <span>largestFieldOffset</span>(-<span>1</span>)</td>
      </tr>
      <tr>
        <td id="L563" data-line-number="563"></td>
        <td id="LC563">    {</td>
      </tr>
      <tr>
        <td id="L564" data-line-number="564"></td>
        <td id="LC564">        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; CLR_SYSTEMV_MAX_EIGHTBYTES_COUNT_TO_PASS_IN_REGISTERS; i++)</td>
      </tr>
      <tr>
        <td id="L565" data-line-number="565"></td>
        <td id="LC565">        {</td>
      </tr>
      <tr>
        <td id="L566" data-line-number="566"></td>
        <td id="LC566">            eightByteClassifications[i] = SystemVClassificationTypeNoClass;</td>
      </tr>
      <tr>
        <td id="L567" data-line-number="567"></td>
        <td id="LC567">            eightByteSizes[i] = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L568" data-line-number="568"></td>
        <td id="LC568">            eightByteOffsets[i] = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L569" data-line-number="569"></td>
        <td id="LC569">        }</td>
      </tr>
      <tr>
        <td id="L570" data-line-number="570"></td>
        <td id="LC570">
</td>
      </tr>
      <tr>
        <td id="L571" data-line-number="571"></td>
        <td id="LC571">        <span><span>//</span> Initialize the work arrays</span></td>
      </tr>
      <tr>
        <td id="L572" data-line-number="572"></td>
        <td id="LC572">        <span>for</span> (<span>int</span> i = <span>0</span>; i &lt; SYSTEMV_MAX_NUM_FIELDS_IN_REGISTER_PASSED_STRUCT; i++)</td>
      </tr>
      <tr>
        <td id="L573" data-line-number="573"></td>
        <td id="LC573">        {</td>
      </tr>
      <tr>
        <td id="L574" data-line-number="574"></td>
        <td id="LC574">            fieldClassifications[i] = SystemVClassificationTypeNoClass;</td>
      </tr>
      <tr>
        <td id="L575" data-line-number="575"></td>
        <td id="LC575">            fieldSizes[i] = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L576" data-line-number="576"></td>
        <td id="LC576">            fieldOffsets[i] = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L577" data-line-number="577"></td>
        <td id="LC577">        }</td>
      </tr>
      <tr>
        <td id="L578" data-line-number="578"></td>
        <td id="LC578">    }</td>
      </tr>
      <tr>
        <td id="L579" data-line-number="579"></td>
        <td id="LC579">
</td>
      </tr>
      <tr>
        <td id="L580" data-line-number="580"></td>
        <td id="LC580">    <span><span>//</span> Input state.</span></td>
      </tr>
      <tr>
        <td id="L581" data-line-number="581"></td>
        <td id="LC581">    <span>unsigned</span> <span>int</span>                    structSize;</td>
      </tr>
      <tr>
        <td id="L582" data-line-number="582"></td>
        <td id="LC582">
</td>
      </tr>
      <tr>
        <td id="L583" data-line-number="583"></td>
        <td id="LC583">    <span><span>//</span> These fields are the output; these are what is computed by the classification algorithm.</span></td>
      </tr>
      <tr>
        <td id="L584" data-line-number="584"></td>
        <td id="LC584">    <span>unsigned</span> <span>int</span>                    eightByteCount;</td>
      </tr>
      <tr>
        <td id="L585" data-line-number="585"></td>
        <td id="LC585">    SystemVClassificationType       eightByteClassifications[CLR_SYSTEMV_MAX_EIGHTBYTES_COUNT_TO_PASS_IN_REGISTERS];</td>
      </tr>
      <tr>
        <td id="L586" data-line-number="586"></td>
        <td id="LC586">    <span>unsigned</span> <span>int</span>                    eightByteSizes[CLR_SYSTEMV_MAX_EIGHTBYTES_COUNT_TO_PASS_IN_REGISTERS];</td>
      </tr>
      <tr>
        <td id="L587" data-line-number="587"></td>
        <td id="LC587">    <span>unsigned</span> <span>int</span>                    eightByteOffsets[CLR_SYSTEMV_MAX_EIGHTBYTES_COUNT_TO_PASS_IN_REGISTERS];</td>
      </tr>
      <tr>
        <td id="L588" data-line-number="588"></td>
        <td id="LC588">
</td>
      </tr>
      <tr>
        <td id="L589" data-line-number="589"></td>
        <td id="LC589">    <span><span>//</span> Helper members to track state.</span></td>
      </tr>
      <tr>
        <td id="L590" data-line-number="590"></td>
        <td id="LC590">    <span>bool</span>                            inEmbeddedStruct;</td>
      </tr>
      <tr>
        <td id="L591" data-line-number="591"></td>
        <td id="LC591">    <span>unsigned</span> <span>int</span>                    currentUniqueOffsetField; <span><span>//</span> A virtual field that could encompass many overlapping fields.</span></td>
      </tr>
      <tr>
        <td id="L592" data-line-number="592"></td>
        <td id="LC592">    <span>int</span>                             largestFieldOffset;</td>
      </tr>
      <tr>
        <td id="L593" data-line-number="593"></td>
        <td id="LC593">    SystemVClassificationType       fieldClassifications[SYSTEMV_MAX_NUM_FIELDS_IN_REGISTER_PASSED_STRUCT];</td>
      </tr>
      <tr>
        <td id="L594" data-line-number="594"></td>
        <td id="LC594">    <span>unsigned</span> <span>int</span>                    fieldSizes[SYSTEMV_MAX_NUM_FIELDS_IN_REGISTER_PASSED_STRUCT];</td>
      </tr>
      <tr>
        <td id="L595" data-line-number="595"></td>
        <td id="LC595">    <span>unsigned</span> <span>int</span>                    fieldOffsets[SYSTEMV_MAX_NUM_FIELDS_IN_REGISTER_PASSED_STRUCT];</td>
      </tr>
      <tr>
        <td id="L596" data-line-number="596"></td>
        <td id="LC596">};</td>
      </tr>
      <tr>
        <td id="L597" data-line-number="597"></td>
        <td id="LC597">
</td>
      </tr>
      <tr>
        <td id="L598" data-line-number="598"></td>
        <td id="LC598"><span>typedef</span> <span>DPTR</span>(SystemVStructRegisterPassingHelper) SystemVStructRegisterPassingHelperPtr;</td>
      </tr>
      <tr>
        <td id="L599" data-line-number="599"></td>
        <td id="LC599">
</td>
      </tr>
      <tr>
        <td id="L600" data-line-number="600"></td>
        <td id="LC600">#<span>endif</span> <span><span>//</span> UNIX_AMD64_ABI_ITF</span></td>
      </tr>
      <tr>
        <td id="L601" data-line-number="601"></td>
        <td id="LC601">
</td>
      </tr>
      <tr>
        <td id="L602" data-line-number="602"></td>
        <td id="LC602"><span><span>//</span>===============================================================================================</span></td>
      </tr>
      <tr>
        <td id="L603" data-line-number="603"></td>
        <td id="LC603"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L604" data-line-number="604"></td>
        <td id="LC604"><span><span>//</span> GC data appears before the beginning of the MethodTable</span></td>
      </tr>
      <tr>
        <td id="L605" data-line-number="605"></td>
        <td id="LC605"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L606" data-line-number="606"></td>
        <td id="LC606"><span><span>//</span>@GENERICS:</span></td>
      </tr>
      <tr>
        <td id="L607" data-line-number="607"></td>
        <td id="LC607"><span><span>//</span> Each generic type has a corresponding "generic" method table that serves the following</span></td>
      </tr>
      <tr>
        <td id="L608" data-line-number="608"></td>
        <td id="LC608"><span><span>//</span> purposes:</span></td>
      </tr>
      <tr>
        <td id="L609" data-line-number="609"></td>
        <td id="LC609"><span><span>//</span> * The method table pointer is used as a representative for the generic type e.g. in reflection</span></td>
      </tr>
      <tr>
        <td id="L610" data-line-number="610"></td>
        <td id="LC610"><span><span>//</span> * MethodDescs for methods in the vtable are used for reflection; they should never be invoked.</span></td>
      </tr>
      <tr>
        <td id="L611" data-line-number="611"></td>
        <td id="LC611"><span><span>//</span> Some other information (e.g. BaseSize) makes no sense "generically" but unfortunately gets put in anyway.</span></td>
      </tr>
      <tr>
        <td id="L612" data-line-number="612"></td>
        <td id="LC612"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L613" data-line-number="613"></td>
        <td id="LC613"><span><span>//</span> Each distinct instantiation of a generic type has its own MethodTable structure.</span></td>
      </tr>
      <tr>
        <td id="L614" data-line-number="614"></td>
        <td id="LC614"><span><span>//</span> However, the EEClass structure can be shared between compatible instantiations e.g. List&lt;string&gt; and List&lt;object&gt;.</span></td>
      </tr>
      <tr>
        <td id="L615" data-line-number="615"></td>
        <td id="LC615"><span><span>//</span> In that case, MethodDescs are also shared between compatible instantiations (but see below about generic methods).</span></td>
      </tr>
      <tr>
        <td id="L616" data-line-number="616"></td>
        <td id="LC616"><span><span>//</span> Hence the vtable entries for MethodTables belonging to such an EEClass are the same.</span></td>
      </tr>
      <tr>
        <td id="L617" data-line-number="617"></td>
        <td id="LC617"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L618" data-line-number="618"></td>
        <td id="LC618"><span><span>//</span> The non-vtable section of such MethodTables are only present for one of the instantiations (the first one</span></td>
      </tr>
      <tr>
        <td id="L619" data-line-number="619"></td>
        <td id="LC619"><span><span>//</span> requested) as non-vtable entries are never accessed through the vtable pointer of an object so it's always possible</span></td>
      </tr>
      <tr>
        <td id="L620" data-line-number="620"></td>
        <td id="LC620"><span><span>//</span> to ensure that they are accessed through the representative MethodTable that contains them.</span></td>
      </tr>
      <tr>
        <td id="L621" data-line-number="621"></td>
        <td id="LC621">
</td>
      </tr>
      <tr>
        <td id="L622" data-line-number="622"></td>
        <td id="LC622"><span><span>//</span> A MethodTable is the fundamental representation of type in the runtime.  It is this structure that</span></td>
      </tr>
      <tr>
        <td id="L623" data-line-number="623"></td>
        <td id="LC623"><span><span>//</span> objects point at (see code:Object).  It holds the size and GC layout of the type, as well as the dispatch table</span></td>
      </tr>
      <tr>
        <td id="L624" data-line-number="624"></td>
        <td id="LC624"><span><span>//</span> for virtual dispach (but not interface dispatch).  There is a distinct method table for every instance of</span></td>
      </tr>
      <tr>
        <td id="L625" data-line-number="625"></td>
        <td id="LC625"><span><span>//</span> a generic type. From here you can get to</span></td>
      </tr>
      <tr>
        <td id="L626" data-line-number="626"></td>
        <td id="LC626"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L627" data-line-number="627"></td>
        <td id="LC627"><span><span>//</span> * code:EEClass</span></td>
      </tr>
      <tr>
        <td id="L628" data-line-number="628"></td>
        <td id="LC628"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L629" data-line-number="629"></td>
        <td id="LC629"><span><span>//</span> Important fields</span></td>
      </tr>
      <tr>
        <td id="L630" data-line-number="630"></td>
        <td id="LC630"><span><span>//</span>     * code:MethodTable.m_pEEClass - pointer to the cold part of the type.</span></td>
      </tr>
      <tr>
        <td id="L631" data-line-number="631"></td>
        <td id="LC631"><span><span>//</span>     * code:MethodTable.m_pParentMethodTable - the method table of the parent type.</span></td>
      </tr>
      <tr>
        <td id="L632" data-line-number="632"></td>
        <td id="LC632"><span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L633" data-line-number="633"></td>
        <td id="LC633">class MethodTableBuilder;</td>
      </tr>
      <tr>
        <td id="L634" data-line-number="634"></td>
        <td id="LC634">class MethodTable</td>
      </tr>
      <tr>
        <td id="L635" data-line-number="635"></td>
        <td id="LC635">{</td>
      </tr>
      <tr>
        <td id="L636" data-line-number="636"></td>
        <td id="LC636">    <span><span>/*</span>***********************************</span></td>
      </tr>
      <tr>
        <td id="L637" data-line-number="637"></td>
        <td id="LC637"><span>     *  FRIEND FUNCTIONS</span></td>
      </tr>
      <tr>
        <td id="L638" data-line-number="638"></td>
        <td id="LC638"><span>     ***********************************<span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L639" data-line-number="639"></td>
        <td id="LC639">    <span><span>//</span> DO NOT ADD FRIENDS UNLESS ABSOLUTELY NECESSARY</span></td>
      </tr>
      <tr>
        <td id="L640" data-line-number="640"></td>
        <td id="LC640">    <span><span>//</span> USE ACCESSORS TO READ/WRITE private field members</span></td>
      </tr>
      <tr>
        <td id="L641" data-line-number="641"></td>
        <td id="LC641">
</td>
      </tr>
      <tr>
        <td id="L642" data-line-number="642"></td>
        <td id="LC642">    <span><span>//</span> Special access for setting up String object method table correctly</span></td>
      </tr>
      <tr>
        <td id="L643" data-line-number="643"></td>
        <td id="LC643">    friend class ClassLoader;</td>
      </tr>
      <tr>
        <td id="L644" data-line-number="644"></td>
        <td id="LC644">    friend class JIT_TrialAlloc;</td>
      </tr>
      <tr>
        <td id="L645" data-line-number="645"></td>
        <td id="LC645">    friend class Module;</td>
      </tr>
      <tr>
        <td id="L646" data-line-number="646"></td>
        <td id="LC646">    friend class EEClass;</td>
      </tr>
      <tr>
        <td id="L647" data-line-number="647"></td>
        <td id="LC647">    friend class MethodTableBuilder;</td>
      </tr>
      <tr>
        <td id="L648" data-line-number="648"></td>
        <td id="LC648">    friend class CheckAsmOffsets;</td>
      </tr>
      <tr>
        <td id="L649" data-line-number="649"></td>
        <td id="LC649">#<span>if</span> defined(DACCESS_COMPILE)</td>
      </tr>
      <tr>
        <td id="L650" data-line-number="650"></td>
        <td id="LC650">    friend class NativeImageDumper;</td>
      </tr>
      <tr>
        <td id="L651" data-line-number="651"></td>
        <td id="LC651">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L652" data-line-number="652"></td>
        <td id="LC652">
</td>
      </tr>
      <tr>
        <td id="L653" data-line-number="653"></td>
        <td id="LC653">public:</td>
      </tr>
      <tr>
        <td id="L654" data-line-number="654"></td>
        <td id="LC654">    <span><span>//</span> Do some sanity checking to make sure it's a method table</span></td>
      </tr>
      <tr>
        <td id="L655" data-line-number="655"></td>
        <td id="LC655">    <span><span>//</span> and not pointing to some random memory.  In particular</span></td>
      </tr>
      <tr>
        <td id="L656" data-line-number="656"></td>
        <td id="LC656">    <span><span>//</span> check that (apart from the special case of instantiated generic types) we have</span></td>
      </tr>
      <tr>
        <td id="L657" data-line-number="657"></td>
        <td id="LC657">    <span><span>//</span> GetCanonicalMethodTable() == this;</span></td>
      </tr>
      <tr>
        <td id="L658" data-line-number="658"></td>
        <td id="LC658">    BOOL <span>SanityCheck</span>();</td>
      </tr>
      <tr>
        <td id="L659" data-line-number="659"></td>
        <td id="LC659">
</td>
      </tr>
      <tr>
        <td id="L660" data-line-number="660"></td>
        <td id="LC660">    <span>static</span> <span>void</span>         <span>CallFinalizer</span>(Object *obj);</td>
      </tr>
      <tr>
        <td id="L661" data-line-number="661"></td>
        <td id="LC661">
</td>
      </tr>
      <tr>
        <td id="L662" data-line-number="662"></td>
        <td id="LC662">public:</td>
      </tr>
      <tr>
        <td id="L663" data-line-number="663"></td>
        <td id="LC663">    PTR_Module <span>GetModule</span>();</td>
      </tr>
      <tr>
        <td id="L664" data-line-number="664"></td>
        <td id="LC664">    PTR_Module <span>GetModule_NoLogging</span>();</td>
      </tr>
      <tr>
        <td id="L665" data-line-number="665"></td>
        <td id="LC665">    Assembly *<span>GetAssembly</span>();</td>
      </tr>
      <tr>
        <td id="L666" data-line-number="666"></td>
        <td id="LC666">
</td>
      </tr>
      <tr>
        <td id="L667" data-line-number="667"></td>
        <td id="LC667">    PTR_Module <span>GetModuleIfLoaded</span>();</td>
      </tr>
      <tr>
        <td id="L668" data-line-number="668"></td>
        <td id="LC668">
</td>
      </tr>
      <tr>
        <td id="L669" data-line-number="669"></td>
        <td id="LC669">    <span><span>//</span> GetDomain on an instantiated type, e.g. C&lt;ty1,ty2&gt; returns the SharedDomain if all the</span></td>
      </tr>
      <tr>
        <td id="L670" data-line-number="670"></td>
        <td id="LC670">    <span><span>//</span> constituent parts of the type are SharedDomain (i.e. domain-neutral),</span></td>
      </tr>
      <tr>
        <td id="L671" data-line-number="671"></td>
        <td id="LC671">    <span><span>//</span> and returns an AppDomain if any of the parts are from an AppDomain,</span></td>
      </tr>
      <tr>
        <td id="L672" data-line-number="672"></td>
        <td id="LC672">    <span><span>//</span> i.e. are domain-bound.  Note that if any of the parts are domain-bound</span></td>
      </tr>
      <tr>
        <td id="L673" data-line-number="673"></td>
        <td id="LC673">    <span><span>//</span> then they will all belong to the same domain.</span></td>
      </tr>
      <tr>
        <td id="L674" data-line-number="674"></td>
        <td id="LC674">    PTR_BaseDomain <span>GetDomain</span>();</td>
      </tr>
      <tr>
        <td id="L675" data-line-number="675"></td>
        <td id="LC675">
</td>
      </tr>
      <tr>
        <td id="L676" data-line-number="676"></td>
        <td id="LC676">    <span><span>//</span> Does this immediate item live in an NGEN module?</span></td>
      </tr>
      <tr>
        <td id="L677" data-line-number="677"></td>
        <td id="LC677">    BOOL <span>IsZapped</span>();</td>
      </tr>
      <tr>
        <td id="L678" data-line-number="678"></td>
        <td id="LC678">
</td>
      </tr>
      <tr>
        <td id="L679" data-line-number="679"></td>
        <td id="LC679">    <span><span>//</span> For types that are part of an ngen-ed assembly this gets the</span></td>
      </tr>
      <tr>
        <td id="L680" data-line-number="680"></td>
        <td id="LC680">    <span><span>//</span> Module* that contains this methodtable.</span></td>
      </tr>
      <tr>
        <td id="L681" data-line-number="681"></td>
        <td id="LC681">    PTR_Module <span>GetZapModule</span>();</td>
      </tr>
      <tr>
        <td id="L682" data-line-number="682"></td>
        <td id="LC682">
</td>
      </tr>
      <tr>
        <td id="L683" data-line-number="683"></td>
        <td id="LC683">    <span><span>//</span> For regular, non-constructed types, GetLoaderModule() == GetModule()</span></td>
      </tr>
      <tr>
        <td id="L684" data-line-number="684"></td>
        <td id="LC684">    <span><span>//</span> For constructed types (e.g. int[], Dict&lt;int[], C&gt;) the hash table through which a type</span></td>
      </tr>
      <tr>
        <td id="L685" data-line-number="685"></td>
        <td id="LC685">    <span><span>//</span> is accessed lives in a "loader module". The rule for determining the loader module must ensure</span></td>
      </tr>
      <tr>
        <td id="L686" data-line-number="686"></td>
        <td id="LC686">    <span><span>//</span> that a type never outlives its loader module with respect to app-domain unloading</span></td>
      </tr>
      <tr>
        <td id="L687" data-line-number="687"></td>
        <td id="LC687">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L688" data-line-number="688"></td>
        <td id="LC688">    <span><span>//</span> GetModuleForStatics() is the third kind of module. GetModuleForStatics() is module that</span></td>
      </tr>
      <tr>
        <td id="L689" data-line-number="689"></td>
        <td id="LC689">    <span><span>//</span> statics are attached to.</span></td>
      </tr>
      <tr>
        <td id="L690" data-line-number="690"></td>
        <td id="LC690">    PTR_Module <span>GetLoaderModule</span>();</td>
      </tr>
      <tr>
        <td id="L691" data-line-number="691"></td>
        <td id="LC691">    PTR_LoaderAllocator <span>GetLoaderAllocator</span>();</td>
      </tr>
      <tr>
        <td id="L692" data-line-number="692"></td>
        <td id="LC692">
</td>
      </tr>
      <tr>
        <td id="L693" data-line-number="693"></td>
        <td id="LC693">    <span>void</span> <span>SetLoaderModule</span>(Module* pModule);</td>
      </tr>
      <tr>
        <td id="L694" data-line-number="694"></td>
        <td id="LC694">    <span>void</span> <span>SetLoaderAllocator</span>(LoaderAllocator* pAllocator);</td>
      </tr>
      <tr>
        <td id="L695" data-line-number="695"></td>
        <td id="LC695">
</td>
      </tr>
      <tr>
        <td id="L696" data-line-number="696"></td>
        <td id="LC696">    <span><span>//</span> Get the domain local module - useful for static init checks</span></td>
      </tr>
      <tr>
        <td id="L697" data-line-number="697"></td>
        <td id="LC697">    PTR_DomainLocalModule   <span>GetDomainLocalModule</span>();</td>
      </tr>
      <tr>
        <td id="L698" data-line-number="698"></td>
        <td id="LC698">
</td>
      </tr>
      <tr>
        <td id="L699" data-line-number="699"></td>
        <td id="LC699">    MethodTable *<span>LoadEnclosingMethodTable</span>(ClassLoadLevel targetLevel = CLASS_DEPENDENCIES_LOADED);</td>
      </tr>
      <tr>
        <td id="L700" data-line-number="700"></td>
        <td id="LC700">
</td>
      </tr>
      <tr>
        <td id="L701" data-line-number="701"></td>
        <td id="LC701">    LPCWSTR <span>GetPathForErrorMessages</span>();</td>
      </tr>
      <tr>
        <td id="L702" data-line-number="702"></td>
        <td id="LC702">
</td>
      </tr>
      <tr>
        <td id="L703" data-line-number="703"></td>
        <td id="LC703">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L704" data-line-number="704"></td>
        <td id="LC704">    <span><span>//</span> COM INTEROP</span></td>
      </tr>
      <tr>
        <td id="L705" data-line-number="705"></td>
        <td id="LC705">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L706" data-line-number="706"></td>
        <td id="LC706">    BOOL <span>IsProjectedFromWinRT</span>();</td>
      </tr>
      <tr>
        <td id="L707" data-line-number="707"></td>
        <td id="LC707">    BOOL <span>IsExportedToWinRT</span>();</td>
      </tr>
      <tr>
        <td id="L708" data-line-number="708"></td>
        <td id="LC708">    BOOL <span>IsWinRTDelegate</span>();</td>
      </tr>
      <tr>
        <td id="L709" data-line-number="709"></td>
        <td id="LC709">    BOOL <span>IsWinRTRedirectedInterface</span>(TypeHandle::InteropKind interopKind);</td>
      </tr>
      <tr>
        <td id="L710" data-line-number="710"></td>
        <td id="LC710">    BOOL <span>IsWinRTRedirectedDelegate</span>();</td>
      </tr>
      <tr>
        <td id="L711" data-line-number="711"></td>
        <td id="LC711">
</td>
      </tr>
      <tr>
        <td id="L712" data-line-number="712"></td>
        <td id="LC712">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L713" data-line-number="713"></td>
        <td id="LC713">    TypeHandle <span>GetCoClassForInterface</span>();</td>
      </tr>
      <tr>
        <td id="L714" data-line-number="714"></td>
        <td id="LC714">
</td>
      </tr>
      <tr>
        <td id="L715" data-line-number="715"></td>
        <td id="LC715">private:</td>
      </tr>
      <tr>
        <td id="L716" data-line-number="716"></td>
        <td id="LC716">    TypeHandle <span>SetupCoClassForInterface</span>();</td>
      </tr>
      <tr>
        <td id="L717" data-line-number="717"></td>
        <td id="LC717">
</td>
      </tr>
      <tr>
        <td id="L718" data-line-number="718"></td>
        <td id="LC718">public:</td>
      </tr>
      <tr>
        <td id="L719" data-line-number="719"></td>
        <td id="LC719">    DWORD <span>IsComClassInterface</span>();</td>
      </tr>
      <tr>
        <td id="L720" data-line-number="720"></td>
        <td id="LC720">
</td>
      </tr>
      <tr>
        <td id="L721" data-line-number="721"></td>
        <td id="LC721">    <span><span>//</span> Retrieves the COM interface type.</span></td>
      </tr>
      <tr>
        <td id="L722" data-line-number="722"></td>
        <td id="LC722">    CorIfaceAttr    <span>GetComInterfaceType</span>();</td>
      </tr>
      <tr>
        <td id="L723" data-line-number="723"></td>
        <td id="LC723">    <span>void</span> <span>SetComInterfaceType</span>(CorIfaceAttr ItfType);</td>
      </tr>
      <tr>
        <td id="L724" data-line-number="724"></td>
        <td id="LC724">
</td>
      </tr>
      <tr>
        <td id="L725" data-line-number="725"></td>
        <td id="LC725">    <span><span>//</span> Determines whether this is a WinRT-legal type</span></td>
      </tr>
      <tr>
        <td id="L726" data-line-number="726"></td>
        <td id="LC726">    BOOL <span>IsLegalWinRTType</span>(OBJECTREF *poref);</td>
      </tr>
      <tr>
        <td id="L727" data-line-number="727"></td>
        <td id="LC727">
</td>
      </tr>
      <tr>
        <td id="L728" data-line-number="728"></td>
        <td id="LC728">    <span><span>//</span> Determines whether this is a WinRT-legal type - don't use it with array</span></td>
      </tr>
      <tr>
        <td id="L729" data-line-number="729"></td>
        <td id="LC729">    BOOL <span>IsLegalNonArrayWinRTType</span>();</td>
      </tr>
      <tr>
        <td id="L730" data-line-number="730"></td>
        <td id="LC730">
</td>
      </tr>
      <tr>
        <td id="L731" data-line-number="731"></td>
        <td id="LC731">    MethodTable *<span>GetDefaultWinRTInterface</span>();</td>
      </tr>
      <tr>
        <td id="L732" data-line-number="732"></td>
        <td id="LC732">
</td>
      </tr>
      <tr>
        <td id="L733" data-line-number="733"></td>
        <td id="LC733">    OBJECTHANDLE <span>GetOHDelegate</span>();</td>
      </tr>
      <tr>
        <td id="L734" data-line-number="734"></td>
        <td id="LC734">    <span>void</span> <span>SetOHDelegate</span> (OBJECTHANDLE _ohDelegate);</td>
      </tr>
      <tr>
        <td id="L735" data-line-number="735"></td>
        <td id="LC735">
</td>
      </tr>
      <tr>
        <td id="L736" data-line-number="736"></td>
        <td id="LC736">    CorClassIfaceAttr <span>GetComClassInterfaceType</span>();</td>
      </tr>
      <tr>
        <td id="L737" data-line-number="737"></td>
        <td id="LC737">    TypeHandle <span>GetDefItfForComClassItf</span>();</td>
      </tr>
      <tr>
        <td id="L738" data-line-number="738"></td>
        <td id="LC738">
</td>
      </tr>
      <tr>
        <td id="L739" data-line-number="739"></td>
        <td id="LC739">    <span>void</span> <span>GetEventInterfaceInfo</span>(MethodTable **ppSrcItfType, MethodTable **ppEvProvType);</td>
      </tr>
      <tr>
        <td id="L740" data-line-number="740"></td>
        <td id="LC740">
</td>
      </tr>
      <tr>
        <td id="L741" data-line-number="741"></td>
        <td id="LC741">    BOOL            <span>IsExtensibleRCW</span>();</td>
      </tr>
      <tr>
        <td id="L742" data-line-number="742"></td>
        <td id="LC742">
</td>
      </tr>
      <tr>
        <td id="L743" data-line-number="743"></td>
        <td id="LC743">    <span><span>//</span> Helper to get parent class skipping over COM class in</span></td>
      </tr>
      <tr>
        <td id="L744" data-line-number="744"></td>
        <td id="LC744">    <span><span>//</span> the hierarchy</span></td>
      </tr>
      <tr>
        <td id="L745" data-line-number="745"></td>
        <td id="LC745">    MethodTable* <span>GetComPlusParentMethodTable</span>();</td>
      </tr>
      <tr>
        <td id="L746" data-line-number="746"></td>
        <td id="LC746">
</td>
      </tr>
      <tr>
        <td id="L747" data-line-number="747"></td>
        <td id="LC747">    <span><span>//</span> class is a WinRT object class (is itself or derives from a ProjectedFromWinRT class)</span></td>
      </tr>
      <tr>
        <td id="L748" data-line-number="748"></td>
        <td id="LC748">    BOOL <span>IsWinRTObjectType</span>();</td>
      </tr>
      <tr>
        <td id="L749" data-line-number="749"></td>
        <td id="LC749">
</td>
      </tr>
      <tr>
        <td id="L750" data-line-number="750"></td>
        <td id="LC750">    DWORD <span>IsComImport</span>();</td>
      </tr>
      <tr>
        <td id="L751" data-line-number="751"></td>
        <td id="LC751">
</td>
      </tr>
      <tr>
        <td id="L752" data-line-number="752"></td>
        <td id="LC752">    <span><span>//</span> class is a special COM event interface</span></td>
      </tr>
      <tr>
        <td id="L753" data-line-number="753"></td>
        <td id="LC753">    <span>int</span> <span>IsComEventItfType</span>();</td>
      </tr>
      <tr>
        <td id="L754" data-line-number="754"></td>
        <td id="LC754">
</td>
      </tr>
      <tr>
        <td id="L755" data-line-number="755"></td>
        <td id="LC755">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L756" data-line-number="756"></td>
        <td id="LC756">    <span><span>//</span> Sparse VTables.   These require a SparseVTableMap in the EEClass in</span></td>
      </tr>
      <tr>
        <td id="L757" data-line-number="757"></td>
        <td id="LC757">    <span><span>//</span> order to record how the CLR's vtable slots map across to COM</span></td>
      </tr>
      <tr>
        <td id="L758" data-line-number="758"></td>
        <td id="LC758">    <span><span>//</span> Interop slots.</span></td>
      </tr>
      <tr>
        <td id="L759" data-line-number="759"></td>
        <td id="LC759">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L760" data-line-number="760"></td>
        <td id="LC760">    <span>int</span> <span>IsSparseForCOMInterop</span>();</td>
      </tr>
      <tr>
        <td id="L761" data-line-number="761"></td>
        <td id="LC761">
</td>
      </tr>
      <tr>
        <td id="L762" data-line-number="762"></td>
        <td id="LC762">    <span><span>//</span> COM interop helpers</span></td>
      </tr>
      <tr>
        <td id="L763" data-line-number="763"></td>
        <td id="LC763">    <span><span>//</span> accessors for m_pComData</span></td>
      </tr>
      <tr>
        <td id="L764" data-line-number="764"></td>
        <td id="LC764">    ComCallWrapperTemplate *<span>GetComCallWrapperTemplate</span>();</td>
      </tr>
      <tr>
        <td id="L765" data-line-number="765"></td>
        <td id="LC765">    BOOL                    <span>SetComCallWrapperTemplate</span>(ComCallWrapperTemplate *pTemplate);</td>
      </tr>
      <tr>
        <td id="L766" data-line-number="766"></td>
        <td id="LC766">#<span>ifdef</span> FEATURE_COMINTEROP_UNMANAGED_ACTIVATION</td>
      </tr>
      <tr>
        <td id="L767" data-line-number="767"></td>
        <td id="LC767">    ClassFactoryBase       *<span>GetComClassFactory</span>();</td>
      </tr>
      <tr>
        <td id="L768" data-line-number="768"></td>
        <td id="LC768">    BOOL                    <span>SetComClassFactory</span>(ClassFactoryBase *pFactory);</td>
      </tr>
      <tr>
        <td id="L769" data-line-number="769"></td>
        <td id="LC769">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP_UNMANAGED_ACTIVATION</span></td>
      </tr>
      <tr>
        <td id="L770" data-line-number="770"></td>
        <td id="LC770">
</td>
      </tr>
      <tr>
        <td id="L771" data-line-number="771"></td>
        <td id="LC771">    OBJECTREF <span>GetObjCreateDelegate</span>();</td>
      </tr>
      <tr>
        <td id="L772" data-line-number="772"></td>
        <td id="LC772">    <span>void</span> <span>SetObjCreateDelegate</span>(OBJECTREF orDelegate);</td>
      </tr>
      <tr>
        <td id="L773" data-line-number="773"></td>
        <td id="LC773">
</td>
      </tr>
      <tr>
        <td id="L774" data-line-number="774"></td>
        <td id="LC774">private:</td>
      </tr>
      <tr>
        <td id="L775" data-line-number="775"></td>
        <td id="LC775">    <span><span>//</span> This is for COM Interop backwards compatibility</span></td>
      </tr>
      <tr>
        <td id="L776" data-line-number="776"></td>
        <td id="LC776">    BOOL <span>InsertComInteropData</span>(InteropMethodTableData *pData);</td>
      </tr>
      <tr>
        <td id="L777" data-line-number="777"></td>
        <td id="LC777">    InteropMethodTableData *<span>CreateComInteropData</span>(AllocMemTracker *pamTracker);</td>
      </tr>
      <tr>
        <td id="L778" data-line-number="778"></td>
        <td id="LC778">
</td>
      </tr>
      <tr>
        <td id="L779" data-line-number="779"></td>
        <td id="LC779">public:</td>
      </tr>
      <tr>
        <td id="L780" data-line-number="780"></td>
        <td id="LC780">    InteropMethodTableData *<span>LookupComInteropData</span>();</td>
      </tr>
      <tr>
        <td id="L781" data-line-number="781"></td>
        <td id="LC781">    <span><span>//</span> This is the preferable entrypoint, as it will make sure that all</span></td>
      </tr>
      <tr>
        <td id="L782" data-line-number="782"></td>
        <td id="LC782">    <span><span>//</span> parent MT's have their interop data created, and will create and</span></td>
      </tr>
      <tr>
        <td id="L783" data-line-number="783"></td>
        <td id="LC783">    <span><span>//</span> add this MT's data if not available. The caller should make sure that</span></td>
      </tr>
      <tr>
        <td id="L784" data-line-number="784"></td>
        <td id="LC784">    <span><span>//</span> an appropriate lock is taken to prevent duplicates.</span></td>
      </tr>
      <tr>
        <td id="L785" data-line-number="785"></td>
        <td id="LC785">    <span><span>//</span> NOTE: The current caller of this is ComInterop, and it makes calls</span></td>
      </tr>
      <tr>
        <td id="L786" data-line-number="786"></td>
        <td id="LC786">    <span><span>//</span> under its own lock to ensure not duplicates.</span></td>
      </tr>
      <tr>
        <td id="L787" data-line-number="787"></td>
        <td id="LC787">    InteropMethodTableData *<span>GetComInteropData</span>();</td>
      </tr>
      <tr>
        <td id="L788" data-line-number="788"></td>
        <td id="LC788">
</td>
      </tr>
      <tr>
        <td id="L789" data-line-number="789"></td>
        <td id="LC789">#<span>else</span> <span><span>//</span> !FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L790" data-line-number="790"></td>
        <td id="LC790">    BOOL <span>IsWinRTObjectType</span>()</td>
      </tr>
      <tr>
        <td id="L791" data-line-number="791"></td>
        <td id="LC791">    {</td>
      </tr>
      <tr>
        <td id="L792" data-line-number="792"></td>
        <td id="LC792">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L793" data-line-number="793"></td>
        <td id="LC793">        <span>return</span> <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L794" data-line-number="794"></td>
        <td id="LC794">    }</td>
      </tr>
      <tr>
        <td id="L795" data-line-number="795"></td>
        <td id="LC795">#<span>endif</span> <span><span>//</span> !FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L796" data-line-number="796"></td>
        <td id="LC796">
</td>
      </tr>
      <tr>
        <td id="L797" data-line-number="797"></td>
        <td id="LC797">    <span><span>//</span> class is a com object class</span></td>
      </tr>
      <tr>
        <td id="L798" data-line-number="798"></td>
        <td id="LC798">    BOOL <span>IsComObjectType</span>()</td>
      </tr>
      <tr>
        <td id="L799" data-line-number="799"></td>
        <td id="LC799">    {</td>
      </tr>
      <tr>
        <td id="L800" data-line-number="800"></td>
        <td id="LC800">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L801" data-line-number="801"></td>
        <td id="LC801">        <span>return</span> <span>GetFlag</span>(enum_flag_ComObject);</td>
      </tr>
      <tr>
        <td id="L802" data-line-number="802"></td>
        <td id="LC802">    }</td>
      </tr>
      <tr>
        <td id="L803" data-line-number="803"></td>
        <td id="LC803">
</td>
      </tr>
      <tr>
        <td id="L804" data-line-number="804"></td>
        <td id="LC804">    <span><span>//</span> mark the class type as COM object class</span></td>
      </tr>
      <tr>
        <td id="L805" data-line-number="805"></td>
        <td id="LC805">    <span>void</span> <span>SetComObjectType</span>();</td>
      </tr>
      <tr>
        <td id="L806" data-line-number="806"></td>
        <td id="LC806">
</td>
      </tr>
      <tr>
        <td id="L807" data-line-number="807"></td>
        <td id="LC807">#<span>ifdef</span> FEATURE_ICASTABLE</td>
      </tr>
      <tr>
        <td id="L808" data-line-number="808"></td>
        <td id="LC808">    <span>void</span> <span>SetICastable</span>();</td>
      </tr>
      <tr>
        <td id="L809" data-line-number="809"></td>
        <td id="LC809">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L810" data-line-number="810"></td>
        <td id="LC810">
</td>
      </tr>
      <tr>
        <td id="L811" data-line-number="811"></td>
        <td id="LC811">    BOOL <span>IsICastable</span>(); <span><span>//</span> This type implements ICastable interface</span></td>
      </tr>
      <tr>
        <td id="L812" data-line-number="812"></td>
        <td id="LC812">
</td>
      </tr>
      <tr>
        <td id="L813" data-line-number="813"></td>
        <td id="LC813">#<span>ifdef</span> FEATURE_TYPEEQUIVALENCE</td>
      </tr>
      <tr>
        <td id="L814" data-line-number="814"></td>
        <td id="LC814">    <span><span>//</span> mark the type as opted into type equivalence</span></td>
      </tr>
      <tr>
        <td id="L815" data-line-number="815"></td>
        <td id="LC815">    <span>void</span> <span>SetHasTypeEquivalence</span>()</td>
      </tr>
      <tr>
        <td id="L816" data-line-number="816"></td>
        <td id="LC816">    {</td>
      </tr>
      <tr>
        <td id="L817" data-line-number="817"></td>
        <td id="LC817">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L818" data-line-number="818"></td>
        <td id="LC818">        <span>SetFlag</span>(enum_flag_HasTypeEquivalence);</td>
      </tr>
      <tr>
        <td id="L819" data-line-number="819"></td>
        <td id="LC819">    }</td>
      </tr>
      <tr>
        <td id="L820" data-line-number="820"></td>
        <td id="LC820">#<span>endif</span> <span><span>//</span> FEATURE_TYPEEQUIVALENCE</span></td>
      </tr>
      <tr>
        <td id="L821" data-line-number="821"></td>
        <td id="LC821">
</td>
      </tr>
      <tr>
        <td id="L822" data-line-number="822"></td>
        <td id="LC822">    <span><span>//</span> type has opted into type equivalence or is instantiated by/derived from a type that is</span></td>
      </tr>
      <tr>
        <td id="L823" data-line-number="823"></td>
        <td id="LC823">    BOOL <span>HasTypeEquivalence</span>()</td>
      </tr>
      <tr>
        <td id="L824" data-line-number="824"></td>
        <td id="LC824">    {</td>
      </tr>
      <tr>
        <td id="L825" data-line-number="825"></td>
        <td id="LC825">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L826" data-line-number="826"></td>
        <td id="LC826">#<span>ifdef</span> FEATURE_TYPEEQUIVALENCE</td>
      </tr>
      <tr>
        <td id="L827" data-line-number="827"></td>
        <td id="LC827">        <span>return</span> <span>GetFlag</span>(enum_flag_HasTypeEquivalence);</td>
      </tr>
      <tr>
        <td id="L828" data-line-number="828"></td>
        <td id="LC828">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L829" data-line-number="829"></td>
        <td id="LC829">        <span>return</span> <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L830" data-line-number="830"></td>
        <td id="LC830">#<span>endif</span> <span><span>//</span> FEATURE_TYPEEQUIVALENCE</span></td>
      </tr>
      <tr>
        <td id="L831" data-line-number="831"></td>
        <td id="LC831">    }</td>
      </tr>
      <tr>
        <td id="L832" data-line-number="832"></td>
        <td id="LC832">
</td>
      </tr>
      <tr>
        <td id="L833" data-line-number="833"></td>
        <td id="LC833">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L834" data-line-number="834"></td>
        <td id="LC834">    <span><span>//</span> DYNAMIC ADDITION OF INTERFACES FOR COM INTEROP</span></td>
      </tr>
      <tr>
        <td id="L835" data-line-number="835"></td>
        <td id="LC835">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L836" data-line-number="836"></td>
        <td id="LC836">    <span><span>//</span> Support for dynamically added interfaces on extensible RCW's.</span></td>
      </tr>
      <tr>
        <td id="L837" data-line-number="837"></td>
        <td id="LC837">
</td>
      </tr>
      <tr>
        <td id="L838" data-line-number="838"></td>
        <td id="LC838">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L839" data-line-number="839"></td>
        <td id="LC839">    PTR_InterfaceInfo <span>GetDynamicallyAddedInterfaceMap</span>();</td>
      </tr>
      <tr>
        <td id="L840" data-line-number="840"></td>
        <td id="LC840">    <span>unsigned</span> <span>GetNumDynamicallyAddedInterfaces</span>();</td>
      </tr>
      <tr>
        <td id="L841" data-line-number="841"></td>
        <td id="LC841">    BOOL <span>FindDynamicallyAddedInterface</span>(MethodTable *pInterface);</td>
      </tr>
      <tr>
        <td id="L842" data-line-number="842"></td>
        <td id="LC842">    <span>void</span> <span>AddDynamicInterface</span>(MethodTable *pItfMT);</td>
      </tr>
      <tr>
        <td id="L843" data-line-number="843"></td>
        <td id="LC843">
</td>
      </tr>
      <tr>
        <td id="L844" data-line-number="844"></td>
        <td id="LC844">    BOOL <span>HasDynamicInterfaceMap</span>()</td>
      </tr>
      <tr>
        <td id="L845" data-line-number="845"></td>
        <td id="LC845">    {</td>
      </tr>
      <tr>
        <td id="L846" data-line-number="846"></td>
        <td id="LC846">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L847" data-line-number="847"></td>
        <td id="LC847">
</td>
      </tr>
      <tr>
        <td id="L848" data-line-number="848"></td>
        <td id="LC848">        <span><span>//</span> currently all ComObjects except</span></td>
      </tr>
      <tr>
        <td id="L849" data-line-number="849"></td>
        <td id="LC849">        <span><span>//</span> for __ComObject have dynamic Interface maps</span></td>
      </tr>
      <tr>
        <td id="L850" data-line-number="850"></td>
        <td id="LC850">        <span>return</span> <span>GetNumInterfaces</span>() &gt; <span>0</span> &amp;&amp; <span>IsComObjectType</span>() &amp;&amp; !<span>ParentEquals</span>(g_pObjectClass);</td>
      </tr>
      <tr>
        <td id="L851" data-line-number="851"></td>
        <td id="LC851">    }</td>
      </tr>
      <tr>
        <td id="L852" data-line-number="852"></td>
        <td id="LC852">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L853" data-line-number="853"></td>
        <td id="LC853">
</td>
      </tr>
      <tr>
        <td id="L854" data-line-number="854"></td>
        <td id="LC854">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L855" data-line-number="855"></td>
        <td id="LC855">    VOID <span>EnsureActive</span>();</td>
      </tr>
      <tr>
        <td id="L856" data-line-number="856"></td>
        <td id="LC856">    VOID <span>EnsureInstanceActive</span>();</td>
      </tr>
      <tr>
        <td id="L857" data-line-number="857"></td>
        <td id="LC857">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L858" data-line-number="858"></td>
        <td id="LC858">
</td>
      </tr>
      <tr>
        <td id="L859" data-line-number="859"></td>
        <td id="LC859">    CHECK <span>CheckActivated</span>();</td>
      </tr>
      <tr>
        <td id="L860" data-line-number="860"></td>
        <td id="LC860">    CHECK <span>CheckInstanceActivated</span>();</td>
      </tr>
      <tr>
        <td id="L861" data-line-number="861"></td>
        <td id="LC861">
</td>
      </tr>
      <tr>
        <td id="L862" data-line-number="862"></td>
        <td id="LC862">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L863" data-line-number="863"></td>
        <td id="LC863">    <span><span>//</span> THE DEFAULT CONSTRUCTOR</span></td>
      </tr>
      <tr>
        <td id="L864" data-line-number="864"></td>
        <td id="LC864">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L865" data-line-number="865"></td>
        <td id="LC865">
</td>
      </tr>
      <tr>
        <td id="L866" data-line-number="866"></td>
        <td id="LC866">public:</td>
      </tr>
      <tr>
        <td id="L867" data-line-number="867"></td>
        <td id="LC867">    BOOL <span>HasDefaultConstructor</span>();</td>
      </tr>
      <tr>
        <td id="L868" data-line-number="868"></td>
        <td id="LC868">    <span>void</span> <span>SetHasDefaultConstructor</span>();</td>
      </tr>
      <tr>
        <td id="L869" data-line-number="869"></td>
        <td id="LC869">    WORD <span>GetDefaultConstructorSlot</span>();</td>
      </tr>
      <tr>
        <td id="L870" data-line-number="870"></td>
        <td id="LC870">    MethodDesc *<span>GetDefaultConstructor</span>();</td>
      </tr>
      <tr>
        <td id="L871" data-line-number="871"></td>
        <td id="LC871">
</td>
      </tr>
      <tr>
        <td id="L872" data-line-number="872"></td>
        <td id="LC872">    BOOL <span>HasExplicitOrImplicitPublicDefaultConstructor</span>();</td>
      </tr>
      <tr>
        <td id="L873" data-line-number="873"></td>
        <td id="LC873">
</td>
      </tr>
      <tr>
        <td id="L874" data-line-number="874"></td>
        <td id="LC874">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L875" data-line-number="875"></td>
        <td id="LC875">    <span><span>//</span> THE CLASS INITIALIZATION CONDITION</span></td>
      </tr>
      <tr>
        <td id="L876" data-line-number="876"></td>
        <td id="LC876">    <span><span>//</span>  (and related DomainLocalModule storage)</span></td>
      </tr>
      <tr>
        <td id="L877" data-line-number="877"></td>
        <td id="LC877">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L878" data-line-number="878"></td>
        <td id="LC878">    <span><span>//</span> - populate the DomainLocalModule if needed</span></td>
      </tr>
      <tr>
        <td id="L879" data-line-number="879"></td>
        <td id="LC879">    <span><span>//</span> - run the cctor</span></td>
      </tr>
      <tr>
        <td id="L880" data-line-number="880"></td>
        <td id="LC880">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L881" data-line-number="881"></td>
        <td id="LC881">
</td>
      </tr>
      <tr>
        <td id="L882" data-line-number="882"></td>
        <td id="LC882">public:</td>
      </tr>
      <tr>
        <td id="L883" data-line-number="883"></td>
        <td id="LC883">
</td>
      </tr>
      <tr>
        <td id="L884" data-line-number="884"></td>
        <td id="LC884">    <span><span>//</span> checks whether the class initialiser should be run on this class, and runs it if necessary</span></td>
      </tr>
      <tr>
        <td id="L885" data-line-number="885"></td>
        <td id="LC885">    <span>void</span> <span>CheckRunClassInitThrowing</span>();</td>
      </tr>
      <tr>
        <td id="L886" data-line-number="886"></td>
        <td id="LC886">
</td>
      </tr>
      <tr>
        <td id="L887" data-line-number="887"></td>
        <td id="LC887">    <span><span>//</span> checks whether or not the non-beforefieldinit class initializers have been run for all types in this type's</span></td>
      </tr>
      <tr>
        <td id="L888" data-line-number="888"></td>
        <td id="LC888">    <span><span>//</span> inheritance hierarchy, and runs them if necessary. This simulates the behavior of running class constructors</span></td>
      </tr>
      <tr>
        <td id="L889" data-line-number="889"></td>
        <td id="LC889">    <span><span>//</span> during object construction.</span></td>
      </tr>
      <tr>
        <td id="L890" data-line-number="890"></td>
        <td id="LC890">    <span>void</span> <span>CheckRunClassInitAsIfConstructingThrowing</span>();</td>
      </tr>
      <tr>
        <td id="L891" data-line-number="891"></td>
        <td id="LC891">
</td>
      </tr>
      <tr>
        <td id="L892" data-line-number="892"></td>
        <td id="LC892">#<span>if</span> defined(UNIX_AMD64_ABI_ITF)</td>
      </tr>
      <tr>
        <td id="L893" data-line-number="893"></td>
        <td id="LC893">    <span><span>//</span> Builds the internal data structures and classifies struct eightbytes for Amd System V calling convention.</span></td>
      </tr>
      <tr>
        <td id="L894" data-line-number="894"></td>
        <td id="LC894">    <span>bool</span> <span>ClassifyEightBytes</span>(SystemVStructRegisterPassingHelperPtr helperPtr, <span>unsigned</span> <span>int</span> nestingLevel, <span>unsigned</span> <span>int</span> startOffsetOfStruct, <span>bool</span> isNativeStruct);</td>
      </tr>
      <tr>
        <td id="L895" data-line-number="895"></td>
        <td id="LC895">#<span>endif</span> <span><span>//</span> defined(UNIX_AMD64_ABI_ITF)</span></td>
      </tr>
      <tr>
        <td id="L896" data-line-number="896"></td>
        <td id="LC896">
</td>
      </tr>
      <tr>
        <td id="L897" data-line-number="897"></td>
        <td id="LC897">    <span><span>//</span> Copy m_dwFlags from another method table</span></td>
      </tr>
      <tr>
        <td id="L898" data-line-number="898"></td>
        <td id="LC898">    <span>void</span> <span>CopyFlags</span>(MethodTable * pOldMT)</td>
      </tr>
      <tr>
        <td id="L899" data-line-number="899"></td>
        <td id="LC899">    {</td>
      </tr>
      <tr>
        <td id="L900" data-line-number="900"></td>
        <td id="LC900">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L901" data-line-number="901"></td>
        <td id="LC901">        m_dwFlags = pOldMT-&gt;<span>m_dwFlags</span>;</td>
      </tr>
      <tr>
        <td id="L902" data-line-number="902"></td>
        <td id="LC902">        m_wFlags2 = pOldMT-&gt;<span>m_wFlags2</span>;</td>
      </tr>
      <tr>
        <td id="L903" data-line-number="903"></td>
        <td id="LC903">    }</td>
      </tr>
      <tr>
        <td id="L904" data-line-number="904"></td>
        <td id="LC904">
</td>
      </tr>
      <tr>
        <td id="L905" data-line-number="905"></td>
        <td id="LC905">    <span><span>//</span> Init the m_dwFlags field for an array</span></td>
      </tr>
      <tr>
        <td id="L906" data-line-number="906"></td>
        <td id="LC906">    <span>void</span> <span>SetIsArray</span>(CorElementType arrayType);</td>
      </tr>
      <tr>
        <td id="L907" data-line-number="907"></td>
        <td id="LC907">        </td>
      </tr>
      <tr>
        <td id="L908" data-line-number="908"></td>
        <td id="LC908">    BOOL <span>IsClassPreInited</span>();</td>
      </tr>
      <tr>
        <td id="L909" data-line-number="909"></td>
        <td id="LC909">
</td>
      </tr>
      <tr>
        <td id="L910" data-line-number="910"></td>
        <td id="LC910">    <span><span>//</span> mark the class as having its cctor run.</span></td>
      </tr>
      <tr>
        <td id="L911" data-line-number="911"></td>
        <td id="LC911">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L912" data-line-number="912"></td>
        <td id="LC912">    <span>void</span> <span>SetClassInited</span>();</td>
      </tr>
      <tr>
        <td id="L913" data-line-number="913"></td>
        <td id="LC913">    BOOL  <span>IsClassInited</span>();</td>
      </tr>
      <tr>
        <td id="L914" data-line-number="914"></td>
        <td id="LC914">
</td>
      </tr>
      <tr>
        <td id="L915" data-line-number="915"></td>
        <td id="LC915">    BOOL <span>IsInitError</span>();</td>
      </tr>
      <tr>
        <td id="L916" data-line-number="916"></td>
        <td id="LC916">    <span>void</span> <span>SetClassInitError</span>();</td>
      </tr>
      <tr>
        <td id="L917" data-line-number="917"></td>
        <td id="LC917">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L918" data-line-number="918"></td>
        <td id="LC918">
</td>
      </tr>
      <tr>
        <td id="L919" data-line-number="919"></td>
        <td id="LC919">    <span>inline</span> BOOL <span>IsGlobalClass</span>()</td>
      </tr>
      <tr>
        <td id="L920" data-line-number="920"></td>
        <td id="LC920">    {</td>
      </tr>
      <tr>
        <td id="L921" data-line-number="921"></td>
        <td id="LC921">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L922" data-line-number="922"></td>
        <td id="LC922">        <span>return</span> (<span>GetTypeDefRid</span>() == <span>RidFromToken</span>(COR_GLOBAL_PARENT_TOKEN));</td>
      </tr>
      <tr>
        <td id="L923" data-line-number="923"></td>
        <td id="LC923">    }</td>
      </tr>
      <tr>
        <td id="L924" data-line-number="924"></td>
        <td id="LC924">
</td>
      </tr>
      <tr>
        <td id="L925" data-line-number="925"></td>
        <td id="LC925">    <span><span>//</span> uniquely identifes this type in the Domain table</span></td>
      </tr>
      <tr>
        <td id="L926" data-line-number="926"></td>
        <td id="LC926">    DWORD <span>GetClassIndex</span>();</td>
      </tr>
      <tr>
        <td id="L927" data-line-number="927"></td>
        <td id="LC927">
</td>
      </tr>
      <tr>
        <td id="L928" data-line-number="928"></td>
        <td id="LC928">private:</td>
      </tr>
      <tr>
        <td id="L929" data-line-number="929"></td>
        <td id="LC929">
</td>
      </tr>
      <tr>
        <td id="L930" data-line-number="930"></td>
        <td id="LC930">#<span>if</span> defined(UNIX_AMD64_ABI_ITF)</td>
      </tr>
      <tr>
        <td id="L931" data-line-number="931"></td>
        <td id="LC931">    <span>void</span> <span>AssignClassifiedEightByteTypes</span>(SystemVStructRegisterPassingHelperPtr helperPtr, <span>unsigned</span> <span>int</span> nestingLevel) <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L932" data-line-number="932"></td>
        <td id="LC932">    <span><span>//</span> Builds the internal data structures and classifies struct eightbytes for Amd System V calling convention.</span></td>
      </tr>
      <tr>
        <td id="L933" data-line-number="933"></td>
        <td id="LC933">    <span>bool</span> <span>ClassifyEightBytesWithManagedLayout</span>(SystemVStructRegisterPassingHelperPtr helperPtr, <span>unsigned</span> <span>int</span> nestingLevel, <span>unsigned</span> <span>int</span> startOffsetOfStruct, <span>bool</span> isNativeStruct);</td>
      </tr>
      <tr>
        <td id="L934" data-line-number="934"></td>
        <td id="LC934">    <span>bool</span> <span>ClassifyEightBytesWithNativeLayout</span>(SystemVStructRegisterPassingHelperPtr helperPtr, <span>unsigned</span> <span>int</span> nestingLevel, <span>unsigned</span> <span>int</span> startOffsetOfStruct, <span>bool</span> isNativeStruct);</td>
      </tr>
      <tr>
        <td id="L935" data-line-number="935"></td>
        <td id="LC935">#<span>endif</span> <span><span>//</span> defined(UNIX_AMD64_ABI_ITF)</span></td>
      </tr>
      <tr>
        <td id="L936" data-line-number="936"></td>
        <td id="LC936">
</td>
      </tr>
      <tr>
        <td id="L937" data-line-number="937"></td>
        <td id="LC937">    DWORD   <span>GetClassIndexFromToken</span>(mdTypeDef typeToken)</td>
      </tr>
      <tr>
        <td id="L938" data-line-number="938"></td>
        <td id="LC938">    {</td>
      </tr>
      <tr>
        <td id="L939" data-line-number="939"></td>
        <td id="LC939">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L940" data-line-number="940"></td>
        <td id="LC940">        <span>return</span> <span>RidFromToken</span>(typeToken) - <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L941" data-line-number="941"></td>
        <td id="LC941">    }</td>
      </tr>
      <tr>
        <td id="L942" data-line-number="942"></td>
        <td id="LC942">
</td>
      </tr>
      <tr>
        <td id="L943" data-line-number="943"></td>
        <td id="LC943">    <span><span>//</span> called from CheckRunClassInitThrowing().  The type wasn't marked as</span></td>
      </tr>
      <tr>
        <td id="L944" data-line-number="944"></td>
        <td id="LC944">    <span><span>//</span> inited while we were there, so let's attempt to do the work.</span></td>
      </tr>
      <tr>
        <td id="L945" data-line-number="945"></td>
        <td id="LC945">    <span>void</span>  <span>DoRunClassInitThrowing</span>();</td>
      </tr>
      <tr>
        <td id="L946" data-line-number="946"></td>
        <td id="LC946">
</td>
      </tr>
      <tr>
        <td id="L947" data-line-number="947"></td>
        <td id="LC947">    BOOL <span>RunClassInitEx</span>(OBJECTREF *pThrowable);</td>
      </tr>
      <tr>
        <td id="L948" data-line-number="948"></td>
        <td id="LC948">
</td>
      </tr>
      <tr>
        <td id="L949" data-line-number="949"></td>
        <td id="LC949">public:</td>
      </tr>
      <tr>
        <td id="L950" data-line-number="950"></td>
        <td id="LC950">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L951" data-line-number="951"></td>
        <td id="LC951">    <span><span>//</span> THE CLASS CONSTRUCTOR</span></td>
      </tr>
      <tr>
        <td id="L952" data-line-number="952"></td>
        <td id="LC952">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L953" data-line-number="953"></td>
        <td id="LC953">
</td>
      </tr>
      <tr>
        <td id="L954" data-line-number="954"></td>
        <td id="LC954">    MethodDesc * <span>GetClassConstructor</span>();</td>
      </tr>
      <tr>
        <td id="L955" data-line-number="955"></td>
        <td id="LC955">
</td>
      </tr>
      <tr>
        <td id="L956" data-line-number="956"></td>
        <td id="LC956">    BOOL <span>HasClassConstructor</span>();</td>
      </tr>
      <tr>
        <td id="L957" data-line-number="957"></td>
        <td id="LC957">    <span>void</span> <span>SetHasClassConstructor</span>();</td>
      </tr>
      <tr>
        <td id="L958" data-line-number="958"></td>
        <td id="LC958">    WORD <span>GetClassConstructorSlot</span>();</td>
      </tr>
      <tr>
        <td id="L959" data-line-number="959"></td>
        <td id="LC959">    <span>void</span> <span>SetClassConstructorSlot</span> (WORD wCCtorSlot);</td>
      </tr>
      <tr>
        <td id="L960" data-line-number="960"></td>
        <td id="LC960">
</td>
      </tr>
      <tr>
        <td id="L961" data-line-number="961"></td>
        <td id="LC961">    ClassCtorInfoEntry* <span>GetClassCtorInfoIfExists</span>();</td>
      </tr>
      <tr>
        <td id="L962" data-line-number="962"></td>
        <td id="LC962">
</td>
      </tr>
      <tr>
        <td id="L963" data-line-number="963"></td>
        <td id="LC963">
</td>
      </tr>
      <tr>
        <td id="L964" data-line-number="964"></td>
        <td id="LC964">    <span>void</span> <span>GetSavedExtent</span>(TADDR *ppStart, TADDR *ppEnd);</td>
      </tr>
      <tr>
        <td id="L965" data-line-number="965"></td>
        <td id="LC965">
</td>
      </tr>
      <tr>
        <td id="L966" data-line-number="966"></td>
        <td id="LC966">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L967" data-line-number="967"></td>
        <td id="LC967">    <span><span>//</span> Save/Fixup/Restore/NeedsRestore</span></td>
      </tr>
      <tr>
        <td id="L968" data-line-number="968"></td>
        <td id="LC968">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L969" data-line-number="969"></td>
        <td id="LC969">    <span><span>//</span> Restore this method table if it's not already restored</span></td>
      </tr>
      <tr>
        <td id="L970" data-line-number="970"></td>
        <td id="LC970">    <span><span>//</span> This is done by forcing a class load which in turn calls the Restore method</span></td>
      </tr>
      <tr>
        <td id="L971" data-line-number="971"></td>
        <td id="LC971">    <span><span>//</span> The pending list is required for restoring types that reference themselves through</span></td>
      </tr>
      <tr>
        <td id="L972" data-line-number="972"></td>
        <td id="LC972">    <span><span>//</span> instantiations of the superclass or interfaces e.g. System.Int32 : IComparable&lt;System.Int32&gt;</span></td>
      </tr>
      <tr>
        <td id="L973" data-line-number="973"></td>
        <td id="LC973">
</td>
      </tr>
      <tr>
        <td id="L974" data-line-number="974"></td>
        <td id="LC974">
</td>
      </tr>
      <tr>
        <td id="L975" data-line-number="975"></td>
        <td id="LC975">#<span>ifdef</span> FEATURE_PREJIT</td>
      </tr>
      <tr>
        <td id="L976" data-line-number="976"></td>
        <td id="LC976">
</td>
      </tr>
      <tr>
        <td id="L977" data-line-number="977"></td>
        <td id="LC977">    <span>void</span> <span>Save</span>(DataImage *image, DWORD profilingFlags);</td>
      </tr>
      <tr>
        <td id="L978" data-line-number="978"></td>
        <td id="LC978">    <span>void</span> <span>Fixup</span>(DataImage *image);</td>
      </tr>
      <tr>
        <td id="L979" data-line-number="979"></td>
        <td id="LC979">
</td>
      </tr>
      <tr>
        <td id="L980" data-line-number="980"></td>
        <td id="LC980">    <span><span>//</span> This is different from !IsRestored() in that it checks if restoring</span></td>
      </tr>
      <tr>
        <td id="L981" data-line-number="981"></td>
        <td id="LC981">    <span><span>//</span> will ever be needed for this ngened data-structure.</span></td>
      </tr>
      <tr>
        <td id="L982" data-line-number="982"></td>
        <td id="LC982">    <span><span>//</span> This is to be used at ngen time of a dependent module to determine</span></td>
      </tr>
      <tr>
        <td id="L983" data-line-number="983"></td>
        <td id="LC983">    <span><span>//</span> if it can be accessed directly, or if the restoring mechanism needs</span></td>
      </tr>
      <tr>
        <td id="L984" data-line-number="984"></td>
        <td id="LC984">    <span><span>//</span> to be hooked in.</span></td>
      </tr>
      <tr>
        <td id="L985" data-line-number="985"></td>
        <td id="LC985">    BOOL <span>ComputeNeedsRestore</span>(DataImage *image, TypeHandleList *pVisited);</td>
      </tr>
      <tr>
        <td id="L986" data-line-number="986"></td>
        <td id="LC986">
</td>
      </tr>
      <tr>
        <td id="L987" data-line-number="987"></td>
        <td id="LC987">    BOOL <span>NeedsRestore</span>(DataImage *image)</td>
      </tr>
      <tr>
        <td id="L988" data-line-number="988"></td>
        <td id="LC988">    {</td>
      </tr>
      <tr>
        <td id="L989" data-line-number="989"></td>
        <td id="LC989">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L990" data-line-number="990"></td>
        <td id="LC990">        <span>return</span> <span>ComputeNeedsRestore</span>(image, <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L991" data-line-number="991"></td>
        <td id="LC991">    }</td>
      </tr>
      <tr>
        <td id="L992" data-line-number="992"></td>
        <td id="LC992">
</td>
      </tr>
      <tr>
        <td id="L993" data-line-number="993"></td>
        <td id="LC993">private:</td>
      </tr>
      <tr>
        <td id="L994" data-line-number="994"></td>
        <td id="LC994">    BOOL <span>ComputeNeedsRestoreWorker</span>(DataImage *image, TypeHandleList *pVisited);</td>
      </tr>
      <tr>
        <td id="L995" data-line-number="995"></td>
        <td id="LC995">
</td>
      </tr>
      <tr>
        <td id="L996" data-line-number="996"></td>
        <td id="LC996">public:</td>
      </tr>
      <tr>
        <td id="L997" data-line-number="997"></td>
        <td id="LC997">    <span><span>//</span> This returns true at NGen time if we can eager bind to all dictionaries along the inheritance chain</span></td>
      </tr>
      <tr>
        <td id="L998" data-line-number="998"></td>
        <td id="LC998">    BOOL <span>CanEagerBindToParentDictionaries</span>(DataImage *image, TypeHandleList *pVisited);</td>
      </tr>
      <tr>
        <td id="L999" data-line-number="999"></td>
        <td id="LC999">
</td>
      </tr>
      <tr>
        <td id="L1000" data-line-number="1000"></td>
        <td id="LC1000">    <span><span>//</span> This returns true at NGen time if we may need to attach statics to</span></td>
      </tr>
      <tr>
        <td id="L1001" data-line-number="1001"></td>
        <td id="LC1001">    <span><span>//</span> other module than current loader module at runtime</span></td>
      </tr>
      <tr>
        <td id="L1002" data-line-number="1002"></td>
        <td id="LC1002">    BOOL <span>NeedsCrossModuleGenericsStaticsInfo</span>();</td>
      </tr>
      <tr>
        <td id="L1003" data-line-number="1003"></td>
        <td id="LC1003">
</td>
      </tr>
      <tr>
        <td id="L1004" data-line-number="1004"></td>
        <td id="LC1004">    <span><span>//</span> Returns true at NGen time if we may need to write into the MethodTable at runtime</span></td>
      </tr>
      <tr>
        <td id="L1005" data-line-number="1005"></td>
        <td id="LC1005">    BOOL <span>IsWriteable</span>();</td>
      </tr>
      <tr>
        <td id="L1006" data-line-number="1006"></td>
        <td id="LC1006">
</td>
      </tr>
      <tr>
        <td id="L1007" data-line-number="1007"></td>
        <td id="LC1007">#<span>endif</span> <span><span>//</span> FEATURE_PREJIT</span></td>
      </tr>
      <tr>
        <td id="L1008" data-line-number="1008"></td>
        <td id="LC1008">
</td>
      </tr>
      <tr>
        <td id="L1009" data-line-number="1009"></td>
        <td id="LC1009">    <span>void</span> <span>AllocateRegularStaticBoxes</span>();</td>
      </tr>
      <tr>
        <td id="L1010" data-line-number="1010"></td>
        <td id="LC1010">    <span>static</span> OBJECTREF <span>AllocateStaticBox</span>(MethodTable* pFieldMT, BOOL fPinned, OBJECTHANDLE* pHandle = <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L1011" data-line-number="1011"></td>
        <td id="LC1011">
</td>
      </tr>
      <tr>
        <td id="L1012" data-line-number="1012"></td>
        <td id="LC1012">    <span>void</span> <span>CheckRestore</span>();</td>
      </tr>
      <tr>
        <td id="L1013" data-line-number="1013"></td>
        <td id="LC1013">
</td>
      </tr>
      <tr>
        <td id="L1014" data-line-number="1014"></td>
        <td id="LC1014">    <span><span>//</span> Perform restore actions on type key components of method table (EEClass pointer + Module, generic args)</span></td>
      </tr>
      <tr>
        <td id="L1015" data-line-number="1015"></td>
        <td id="LC1015">    <span>void</span> <span>DoRestoreTypeKey</span>();</td>
      </tr>
      <tr>
        <td id="L1016" data-line-number="1016"></td>
        <td id="LC1016">
</td>
      </tr>
      <tr>
        <td id="L1017" data-line-number="1017"></td>
        <td id="LC1017">    <span>inline</span> BOOL <span>HasUnrestoredTypeKey</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L1018" data-line-number="1018"></td>
        <td id="LC1018">    {</td>
      </tr>
      <tr>
        <td id="L1019" data-line-number="1019"></td>
        <td id="LC1019">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1020" data-line-number="1020"></td>
        <td id="LC1020">
</td>
      </tr>
      <tr>
        <td id="L1021" data-line-number="1021"></td>
        <td id="LC1021">        <span>return</span> !<span>IsPreRestored</span>() &amp;&amp;</td>
      </tr>
      <tr>
        <td id="L1022" data-line-number="1022"></td>
        <td id="LC1022">            (<span>GetWriteableData</span>()-&gt;<span>m_dwFlags</span> &amp; MethodTableWriteableData::enum_flag_UnrestoredTypeKey) != <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1023" data-line-number="1023"></td>
        <td id="LC1023">    }</td>
      </tr>
      <tr>
        <td id="L1024" data-line-number="1024"></td>
        <td id="LC1024">
</td>
      </tr>
      <tr>
        <td id="L1025" data-line-number="1025"></td>
        <td id="LC1025">    <span><span>//</span> Actually do the restore actions on the method table</span></td>
      </tr>
      <tr>
        <td id="L1026" data-line-number="1026"></td>
        <td id="LC1026">    <span>void</span> <span>Restore</span>();</td>
      </tr>
      <tr>
        <td id="L1027" data-line-number="1027"></td>
        <td id="LC1027">
</td>
      </tr>
      <tr>
        <td id="L1028" data-line-number="1028"></td>
        <td id="LC1028">    <span>void</span> <span>SetIsRestored</span>();</td>
      </tr>
      <tr>
        <td id="L1029" data-line-number="1029"></td>
        <td id="LC1029">
</td>
      </tr>
      <tr>
        <td id="L1030" data-line-number="1030"></td>
        <td id="LC1030">    <span>inline</span> BOOL <span>IsRestored_NoLogging</span>()</td>
      </tr>
      <tr>
        <td id="L1031" data-line-number="1031"></td>
        <td id="LC1031">    {</td>
      </tr>
      <tr>
        <td id="L1032" data-line-number="1032"></td>
        <td id="LC1032">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1033" data-line-number="1033"></td>
        <td id="LC1033">
</td>
      </tr>
      <tr>
        <td id="L1034" data-line-number="1034"></td>
        <td id="LC1034">        <span><span>//</span> If we are prerestored then we are considered a restored methodtable.</span></td>
      </tr>
      <tr>
        <td id="L1035" data-line-number="1035"></td>
        <td id="LC1035">        <span><span>//</span> Note that IsPreRestored is always false for jitted code.</span></td>
      </tr>
      <tr>
        <td id="L1036" data-line-number="1036"></td>
        <td id="LC1036">        <span>if</span> (<span>IsPreRestored</span>())</td>
      </tr>
      <tr>
        <td id="L1037" data-line-number="1037"></td>
        <td id="LC1037">            <span>return</span> <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L1038" data-line-number="1038"></td>
        <td id="LC1038">
</td>
      </tr>
      <tr>
        <td id="L1039" data-line-number="1039"></td>
        <td id="LC1039">        <span>return</span> !(<span>GetWriteableData_NoLogging</span>()-&gt;<span>m_dwFlags</span> &amp; MethodTableWriteableData::enum_flag_Unrestored);</td>
      </tr>
      <tr>
        <td id="L1040" data-line-number="1040"></td>
        <td id="LC1040">    }</td>
      </tr>
      <tr>
        <td id="L1041" data-line-number="1041"></td>
        <td id="LC1041">    <span>inline</span> BOOL <span>IsRestored</span>()</td>
      </tr>
      <tr>
        <td id="L1042" data-line-number="1042"></td>
        <td id="LC1042">    {</td>
      </tr>
      <tr>
        <td id="L1043" data-line-number="1043"></td>
        <td id="LC1043">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1044" data-line-number="1044"></td>
        <td id="LC1044">
</td>
      </tr>
      <tr>
        <td id="L1045" data-line-number="1045"></td>
        <td id="LC1045">        g_IBCLogger.<span>LogMethodTableAccess</span>(this);</td>
      </tr>
      <tr>
        <td id="L1046" data-line-number="1046"></td>
        <td id="LC1046">
</td>
      </tr>
      <tr>
        <td id="L1047" data-line-number="1047"></td>
        <td id="LC1047">        <span><span>//</span> If we are prerestored then we are considered a restored methodtable.</span></td>
      </tr>
      <tr>
        <td id="L1048" data-line-number="1048"></td>
        <td id="LC1048">        <span><span>//</span> Note that IsPreRestored is always false for jitted code.</span></td>
      </tr>
      <tr>
        <td id="L1049" data-line-number="1049"></td>
        <td id="LC1049">        <span>if</span> (<span>IsPreRestored</span>())</td>
      </tr>
      <tr>
        <td id="L1050" data-line-number="1050"></td>
        <td id="LC1050">            <span>return</span> <span>TRUE</span>;</td>
      </tr>
      <tr>
        <td id="L1051" data-line-number="1051"></td>
        <td id="LC1051">
</td>
      </tr>
      <tr>
        <td id="L1052" data-line-number="1052"></td>
        <td id="LC1052">        <span>return</span> !(<span>GetWriteableData</span>()-&gt;<span>m_dwFlags</span> &amp; MethodTableWriteableData::enum_flag_Unrestored);</td>
      </tr>
      <tr>
        <td id="L1053" data-line-number="1053"></td>
        <td id="LC1053">    }</td>
      </tr>
      <tr>
        <td id="L1054" data-line-number="1054"></td>
        <td id="LC1054">
</td>
      </tr>
      <tr>
        <td id="L1055" data-line-number="1055"></td>
        <td id="LC1055">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1056" data-line-number="1056"></td>
        <td id="LC1056">    <span><span>//</span> LOAD LEVEL</span></td>
      </tr>
      <tr>
        <td id="L1057" data-line-number="1057"></td>
        <td id="LC1057">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1058" data-line-number="1058"></td>
        <td id="LC1058">    <span><span>//</span> The load level of a method table is derived from various flag bits</span></td>
      </tr>
      <tr>
        <td id="L1059" data-line-number="1059"></td>
        <td id="LC1059">    <span><span>//</span> See classloadlevel.h for details of each level</span></td>
      </tr>
      <tr>
        <td id="L1060" data-line-number="1060"></td>
        <td id="LC1060">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1061" data-line-number="1061"></td>
        <td id="LC1061">    <span><span>//</span> Level CLASS_LOADED (fully loaded) is special: a type only</span></td>
      </tr>
      <tr>
        <td id="L1062" data-line-number="1062"></td>
        <td id="LC1062">    <span><span>//</span> reaches this level once all of its dependent types are also at</span></td>
      </tr>
      <tr>
        <td id="L1063" data-line-number="1063"></td>
        <td id="LC1063">    <span><span>//</span> this level (generic arguments, parent, interfaces, etc).</span></td>
      </tr>
      <tr>
        <td id="L1064" data-line-number="1064"></td>
        <td id="LC1064">    <span><span>//</span> Fully loading a type to this level is done outside locks, hence the need for</span></td>
      </tr>
      <tr>
        <td id="L1065" data-line-number="1065"></td>
        <td id="LC1065">    <span><span>//</span> a single atomic action that sets the level.</span></td>
      </tr>
      <tr>
        <td id="L1066" data-line-number="1066"></td>
        <td id="LC1066">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1067" data-line-number="1067"></td>
        <td id="LC1067">    <span>inline</span> <span>void</span> <span>SetIsFullyLoaded</span>()</td>
      </tr>
      <tr>
        <td id="L1068" data-line-number="1068"></td>
        <td id="LC1068">    {</td>
      </tr>
      <tr>
        <td id="L1069" data-line-number="1069"></td>
        <td id="LC1069">        CONTRACTL</td>
      </tr>
      <tr>
        <td id="L1070" data-line-number="1070"></td>
        <td id="LC1070">        {</td>
      </tr>
      <tr>
        <td id="L1071" data-line-number="1071"></td>
        <td id="LC1071">            THROWS;</td>
      </tr>
      <tr>
        <td id="L1072" data-line-number="1072"></td>
        <td id="LC1072">            GC_NOTRIGGER;</td>
      </tr>
      <tr>
        <td id="L1073" data-line-number="1073"></td>
        <td id="LC1073">            MODE_ANY;</td>
      </tr>
      <tr>
        <td id="L1074" data-line-number="1074"></td>
        <td id="LC1074">        }</td>
      </tr>
      <tr>
        <td id="L1075" data-line-number="1075"></td>
        <td id="LC1075">        CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L1076" data-line-number="1076"></td>
        <td id="LC1076">
</td>
      </tr>
      <tr>
        <td id="L1077" data-line-number="1077"></td>
        <td id="LC1077">        <span>PRECONDITION</span>(!<span>HasApproxParent</span>());</td>
      </tr>
      <tr>
        <td id="L1078" data-line-number="1078"></td>
        <td id="LC1078">        <span>PRECONDITION</span>(<span>IsRestored_NoLogging</span>());</td>
      </tr>
      <tr>
        <td id="L1079" data-line-number="1079"></td>
        <td id="LC1079">
</td>
      </tr>
      <tr>
        <td id="L1080" data-line-number="1080"></td>
        <td id="LC1080">        <span>FastInterlockAnd</span>(&amp;<span>GetWriteableDataForWrite</span>()-&gt;<span>m_dwFlags</span>, ~MethodTableWriteableData::enum_flag_IsNotFullyLoaded);</td>
      </tr>
      <tr>
        <td id="L1081" data-line-number="1081"></td>
        <td id="LC1081">    }</td>
      </tr>
      <tr>
        <td id="L1082" data-line-number="1082"></td>
        <td id="LC1082">
</td>
      </tr>
      <tr>
        <td id="L1083" data-line-number="1083"></td>
        <td id="LC1083">    <span><span>//</span> Equivalent to GetLoadLevel() == CLASS_LOADED</span></td>
      </tr>
      <tr>
        <td id="L1084" data-line-number="1084"></td>
        <td id="LC1084">    <span>inline</span> BOOL <span>IsFullyLoaded</span>()</td>
      </tr>
      <tr>
        <td id="L1085" data-line-number="1085"></td>
        <td id="LC1085">    {</td>
      </tr>
      <tr>
        <td id="L1086" data-line-number="1086"></td>
        <td id="LC1086">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1087" data-line-number="1087"></td>
        <td id="LC1087">
</td>
      </tr>
      <tr>
        <td id="L1088" data-line-number="1088"></td>
        <td id="LC1088">        <span>return</span> (<span>IsPreRestored</span>())</td>
      </tr>
      <tr>
        <td id="L1089" data-line-number="1089"></td>
        <td id="LC1089">            || (<span>GetWriteableData</span>()-&gt;<span>m_dwFlags</span> &amp; MethodTableWriteableData::enum_flag_IsNotFullyLoaded) == <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1090" data-line-number="1090"></td>
        <td id="LC1090">    }</td>
      </tr>
      <tr>
        <td id="L1091" data-line-number="1091"></td>
        <td id="LC1091">
</td>
      </tr>
      <tr>
        <td id="L1092" data-line-number="1092"></td>
        <td id="LC1092">    <span>inline</span> BOOL <span>IsSkipWinRTOverride</span>()</td>
      </tr>
      <tr>
        <td id="L1093" data-line-number="1093"></td>
        <td id="LC1093">    {</td>
      </tr>
      <tr>
        <td id="L1094" data-line-number="1094"></td>
        <td id="LC1094">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1095" data-line-number="1095"></td>
        <td id="LC1095">        <span>return</span> (<span>GetWriteableData_NoLogging</span>()-&gt;<span>m_dwFlags</span> &amp; MethodTableWriteableData::enum_flag_SkipWinRTOverride);</td>
      </tr>
      <tr>
        <td id="L1096" data-line-number="1096"></td>
        <td id="LC1096">    }</td>
      </tr>
      <tr>
        <td id="L1097" data-line-number="1097"></td>
        <td id="LC1097">
</td>
      </tr>
      <tr>
        <td id="L1098" data-line-number="1098"></td>
        <td id="LC1098">    <span>inline</span> <span>void</span> <span>SetSkipWinRTOverride</span>()</td>
      </tr>
      <tr>
        <td id="L1099" data-line-number="1099"></td>
        <td id="LC1099">    {</td>
      </tr>
      <tr>
        <td id="L1100" data-line-number="1100"></td>
        <td id="LC1100">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1101" data-line-number="1101"></td>
        <td id="LC1101">        <span>FastInterlockOr</span>(&amp;<span>GetWriteableDataForWrite_NoLogging</span>()-&gt;<span>m_dwFlags</span>, MethodTableWriteableData::enum_flag_SkipWinRTOverride);</td>
      </tr>
      <tr>
        <td id="L1102" data-line-number="1102"></td>
        <td id="LC1102">    }</td>
      </tr>
      <tr>
        <td id="L1103" data-line-number="1103"></td>
        <td id="LC1103">
</td>
      </tr>
      <tr>
        <td id="L1104" data-line-number="1104"></td>
        <td id="LC1104">    <span>inline</span> BOOL <span>CanCompareBitsOrUseFastGetHashCode</span>()</td>
      </tr>
      <tr>
        <td id="L1105" data-line-number="1105"></td>
        <td id="LC1105">    {</td>
      </tr>
      <tr>
        <td id="L1106" data-line-number="1106"></td>
        <td id="LC1106">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1107" data-line-number="1107"></td>
        <td id="LC1107">        <span>return</span> (<span>GetWriteableData_NoLogging</span>()-&gt;<span>m_dwFlags</span> &amp; MethodTableWriteableData::enum_flag_CanCompareBitsOrUseFastGetHashCode);</td>
      </tr>
      <tr>
        <td id="L1108" data-line-number="1108"></td>
        <td id="LC1108">    }</td>
      </tr>
      <tr>
        <td id="L1109" data-line-number="1109"></td>
        <td id="LC1109">
</td>
      </tr>
      <tr>
        <td id="L1110" data-line-number="1110"></td>
        <td id="LC1110">    <span><span>//</span> If canCompare is true, this method ensure an atomic operation for setting</span></td>
      </tr>
      <tr>
        <td id="L1111" data-line-number="1111"></td>
        <td id="LC1111">    <span><span>//</span> enum_flag_HasCheckedCanCompareBitsOrUseFastGetHashCode and enum_flag_CanCompareBitsOrUseFastGetHashCode flags.</span></td>
      </tr>
      <tr>
        <td id="L1112" data-line-number="1112"></td>
        <td id="LC1112">    <span>inline</span> <span>void</span> <span>SetCanCompareBitsOrUseFastGetHashCode</span>(BOOL canCompare)</td>
      </tr>
      <tr>
        <td id="L1113" data-line-number="1113"></td>
        <td id="LC1113">    {</td>
      </tr>
      <tr>
        <td id="L1114" data-line-number="1114"></td>
        <td id="LC1114">        WRAPPER_NO_CONTRACT</td>
      </tr>
      <tr>
        <td id="L1115" data-line-number="1115"></td>
        <td id="LC1115">        <span>if</span> (canCompare)</td>
      </tr>
      <tr>
        <td id="L1116" data-line-number="1116"></td>
        <td id="LC1116">        {</td>
      </tr>
      <tr>
        <td id="L1117" data-line-number="1117"></td>
        <td id="LC1117">            <span><span>//</span> Set checked and canCompare flags in one interlocked operation.</span></td>
      </tr>
      <tr>
        <td id="L1118" data-line-number="1118"></td>
        <td id="LC1118">            <span>FastInterlockOr</span>(&amp;<span>GetWriteableDataForWrite_NoLogging</span>()-&gt;<span>m_dwFlags</span>,</td>
      </tr>
      <tr>
        <td id="L1119" data-line-number="1119"></td>
        <td id="LC1119">                MethodTableWriteableData::enum_flag_HasCheckedCanCompareBitsOrUseFastGetHashCode | MethodTableWriteableData::enum_flag_CanCompareBitsOrUseFastGetHashCode);</td>
      </tr>
      <tr>
        <td id="L1120" data-line-number="1120"></td>
        <td id="LC1120">        }</td>
      </tr>
      <tr>
        <td id="L1121" data-line-number="1121"></td>
        <td id="LC1121">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L1122" data-line-number="1122"></td>
        <td id="LC1122">        {</td>
      </tr>
      <tr>
        <td id="L1123" data-line-number="1123"></td>
        <td id="LC1123">            <span>SetHasCheckedCanCompareBitsOrUseFastGetHashCode</span>();</td>
      </tr>
      <tr>
        <td id="L1124" data-line-number="1124"></td>
        <td id="LC1124">        }</td>
      </tr>
      <tr>
        <td id="L1125" data-line-number="1125"></td>
        <td id="LC1125">    }</td>
      </tr>
      <tr>
        <td id="L1126" data-line-number="1126"></td>
        <td id="LC1126">
</td>
      </tr>
      <tr>
        <td id="L1127" data-line-number="1127"></td>
        <td id="LC1127">    <span>inline</span> BOOL <span>HasCheckedCanCompareBitsOrUseFastGetHashCode</span>()</td>
      </tr>
      <tr>
        <td id="L1128" data-line-number="1128"></td>
        <td id="LC1128">    {</td>
      </tr>
      <tr>
        <td id="L1129" data-line-number="1129"></td>
        <td id="LC1129">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1130" data-line-number="1130"></td>
        <td id="LC1130">        <span>return</span> (<span>GetWriteableData_NoLogging</span>()-&gt;<span>m_dwFlags</span> &amp; MethodTableWriteableData::enum_flag_HasCheckedCanCompareBitsOrUseFastGetHashCode);</td>
      </tr>
      <tr>
        <td id="L1131" data-line-number="1131"></td>
        <td id="LC1131">    }</td>
      </tr>
      <tr>
        <td id="L1132" data-line-number="1132"></td>
        <td id="LC1132">
</td>
      </tr>
      <tr>
        <td id="L1133" data-line-number="1133"></td>
        <td id="LC1133">    <span>inline</span> <span>void</span> <span>SetHasCheckedCanCompareBitsOrUseFastGetHashCode</span>()</td>
      </tr>
      <tr>
        <td id="L1134" data-line-number="1134"></td>
        <td id="LC1134">    {</td>
      </tr>
      <tr>
        <td id="L1135" data-line-number="1135"></td>
        <td id="LC1135">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1136" data-line-number="1136"></td>
        <td id="LC1136">        <span>FastInterlockOr</span>(&amp;<span>GetWriteableDataForWrite_NoLogging</span>()-&gt;<span>m_dwFlags</span>, MethodTableWriteableData::enum_flag_HasCheckedCanCompareBitsOrUseFastGetHashCode);</td>
      </tr>
      <tr>
        <td id="L1137" data-line-number="1137"></td>
        <td id="LC1137">    }</td>
      </tr>
      <tr>
        <td id="L1138" data-line-number="1138"></td>
        <td id="LC1138">
</td>
      </tr>
      <tr>
        <td id="L1139" data-line-number="1139"></td>
        <td id="LC1139">    <span>inline</span> <span>void</span> <span>SetIsDependenciesLoaded</span>()</td>
      </tr>
      <tr>
        <td id="L1140" data-line-number="1140"></td>
        <td id="LC1140">    {</td>
      </tr>
      <tr>
        <td id="L1141" data-line-number="1141"></td>
        <td id="LC1141">        CONTRACTL</td>
      </tr>
      <tr>
        <td id="L1142" data-line-number="1142"></td>
        <td id="LC1142">        {</td>
      </tr>
      <tr>
        <td id="L1143" data-line-number="1143"></td>
        <td id="LC1143">            THROWS;</td>
      </tr>
      <tr>
        <td id="L1144" data-line-number="1144"></td>
        <td id="LC1144">            GC_NOTRIGGER;</td>
      </tr>
      <tr>
        <td id="L1145" data-line-number="1145"></td>
        <td id="LC1145">            MODE_ANY;</td>
      </tr>
      <tr>
        <td id="L1146" data-line-number="1146"></td>
        <td id="LC1146">        }</td>
      </tr>
      <tr>
        <td id="L1147" data-line-number="1147"></td>
        <td id="LC1147">        CONTRACTL_END;</td>
      </tr>
      <tr>
        <td id="L1148" data-line-number="1148"></td>
        <td id="LC1148">
</td>
      </tr>
      <tr>
        <td id="L1149" data-line-number="1149"></td>
        <td id="LC1149">        <span>PRECONDITION</span>(!<span>HasApproxParent</span>());</td>
      </tr>
      <tr>
        <td id="L1150" data-line-number="1150"></td>
        <td id="LC1150">        <span>PRECONDITION</span>(<span>IsRestored_NoLogging</span>());</td>
      </tr>
      <tr>
        <td id="L1151" data-line-number="1151"></td>
        <td id="LC1151">
</td>
      </tr>
      <tr>
        <td id="L1152" data-line-number="1152"></td>
        <td id="LC1152">        <span>FastInterlockOr</span>(&amp;<span>GetWriteableDataForWrite</span>()-&gt;<span>m_dwFlags</span>, MethodTableWriteableData::enum_flag_DependenciesLoaded);</td>
      </tr>
      <tr>
        <td id="L1153" data-line-number="1153"></td>
        <td id="LC1153">    }</td>
      </tr>
      <tr>
        <td id="L1154" data-line-number="1154"></td>
        <td id="LC1154">
</td>
      </tr>
      <tr>
        <td id="L1155" data-line-number="1155"></td>
        <td id="LC1155">    <span>inline</span> ClassLoadLevel <span>GetLoadLevel</span>()</td>
      </tr>
      <tr>
        <td id="L1156" data-line-number="1156"></td>
        <td id="LC1156">    {</td>
      </tr>
      <tr>
        <td id="L1157" data-line-number="1157"></td>
        <td id="LC1157">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1158" data-line-number="1158"></td>
        <td id="LC1158">
</td>
      </tr>
      <tr>
        <td id="L1159" data-line-number="1159"></td>
        <td id="LC1159">        g_IBCLogger.<span>LogMethodTableAccess</span>(this);</td>
      </tr>
      <tr>
        <td id="L1160" data-line-number="1160"></td>
        <td id="LC1160">
</td>
      </tr>
      <tr>
        <td id="L1161" data-line-number="1161"></td>
        <td id="LC1161">        <span><span>//</span> Fast path for zapped images</span></td>
      </tr>
      <tr>
        <td id="L1162" data-line-number="1162"></td>
        <td id="LC1162">        <span>if</span> (<span>IsPreRestored</span>())</td>
      </tr>
      <tr>
        <td id="L1163" data-line-number="1163"></td>
        <td id="LC1163">            <span>return</span> CLASS_LOADED;</td>
      </tr>
      <tr>
        <td id="L1164" data-line-number="1164"></td>
        <td id="LC1164">
</td>
      </tr>
      <tr>
        <td id="L1165" data-line-number="1165"></td>
        <td id="LC1165">        DWORD dwFlags = <span>GetWriteableData</span>()-&gt;<span>m_dwFlags</span>;</td>
      </tr>
      <tr>
        <td id="L1166" data-line-number="1166"></td>
        <td id="LC1166">
</td>
      </tr>
      <tr>
        <td id="L1167" data-line-number="1167"></td>
        <td id="LC1167">        <span>if</span> (dwFlags &amp; MethodTableWriteableData::enum_flag_IsNotFullyLoaded)</td>
      </tr>
      <tr>
        <td id="L1168" data-line-number="1168"></td>
        <td id="LC1168">        {</td>
      </tr>
      <tr>
        <td id="L1169" data-line-number="1169"></td>
        <td id="LC1169">            <span>if</span> (dwFlags &amp; MethodTableWriteableData::enum_flag_UnrestoredTypeKey)</td>
      </tr>
      <tr>
        <td id="L1170" data-line-number="1170"></td>
        <td id="LC1170">                <span>return</span> CLASS_LOAD_UNRESTOREDTYPEKEY;</td>
      </tr>
      <tr>
        <td id="L1171" data-line-number="1171"></td>
        <td id="LC1171">
</td>
      </tr>
      <tr>
        <td id="L1172" data-line-number="1172"></td>
        <td id="LC1172">            <span>if</span> (dwFlags &amp; MethodTableWriteableData::enum_flag_Unrestored)</td>
      </tr>
      <tr>
        <td id="L1173" data-line-number="1173"></td>
        <td id="LC1173">                <span>return</span> CLASS_LOAD_UNRESTORED;</td>
      </tr>
      <tr>
        <td id="L1174" data-line-number="1174"></td>
        <td id="LC1174">
</td>
      </tr>
      <tr>
        <td id="L1175" data-line-number="1175"></td>
        <td id="LC1175">            <span>if</span> (dwFlags &amp; MethodTableWriteableData::enum_flag_HasApproxParent)</td>
      </tr>
      <tr>
        <td id="L1176" data-line-number="1176"></td>
        <td id="LC1176">                <span>return</span> CLASS_LOAD_APPROXPARENTS;</td>
      </tr>
      <tr>
        <td id="L1177" data-line-number="1177"></td>
        <td id="LC1177">
</td>
      </tr>
      <tr>
        <td id="L1178" data-line-number="1178"></td>
        <td id="LC1178">            <span>if</span> (!(dwFlags &amp; MethodTableWriteableData::enum_flag_DependenciesLoaded))</td>
      </tr>
      <tr>
        <td id="L1179" data-line-number="1179"></td>
        <td id="LC1179">                <span>return</span> CLASS_LOAD_EXACTPARENTS;</td>
      </tr>
      <tr>
        <td id="L1180" data-line-number="1180"></td>
        <td id="LC1180">
</td>
      </tr>
      <tr>
        <td id="L1181" data-line-number="1181"></td>
        <td id="LC1181">            <span>return</span> CLASS_DEPENDENCIES_LOADED;</td>
      </tr>
      <tr>
        <td id="L1182" data-line-number="1182"></td>
        <td id="LC1182">        }</td>
      </tr>
      <tr>
        <td id="L1183" data-line-number="1183"></td>
        <td id="LC1183">
</td>
      </tr>
      <tr>
        <td id="L1184" data-line-number="1184"></td>
        <td id="LC1184">        <span>return</span> CLASS_LOADED;</td>
      </tr>
      <tr>
        <td id="L1185" data-line-number="1185"></td>
        <td id="LC1185">    }</td>
      </tr>
      <tr>
        <td id="L1186" data-line-number="1186"></td>
        <td id="LC1186">
</td>
      </tr>
      <tr>
        <td id="L1187" data-line-number="1187"></td>
        <td id="LC1187">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L1188" data-line-number="1188"></td>
        <td id="LC1188">    CHECK <span>CheckLoadLevel</span>(ClassLoadLevel level)</td>
      </tr>
      <tr>
        <td id="L1189" data-line-number="1189"></td>
        <td id="LC1189">    {</td>
      </tr>
      <tr>
        <td id="L1190" data-line-number="1190"></td>
        <td id="LC1190">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1191" data-line-number="1191"></td>
        <td id="LC1191">        <span>return</span> <span>TypeHandle</span>(this).<span>CheckLoadLevel</span>(level);</td>
      </tr>
      <tr>
        <td id="L1192" data-line-number="1192"></td>
        <td id="LC1192">    }</td>
      </tr>
      <tr>
        <td id="L1193" data-line-number="1193"></td>
        <td id="LC1193">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1194" data-line-number="1194"></td>
        <td id="LC1194">
</td>
      </tr>
      <tr>
        <td id="L1195" data-line-number="1195"></td>
        <td id="LC1195">
</td>
      </tr>
      <tr>
        <td id="L1196" data-line-number="1196"></td>
        <td id="LC1196">    <span>void</span> <span>DoFullyLoad</span>(Generics::RecursionGraph * <span>const</span> pVisited, <span>const</span> ClassLoadLevel level, DFLPendingList * <span>const</span> pPending, BOOL * <span>const</span> pfBailed,</td>
      </tr>
      <tr>
        <td id="L1197" data-line-number="1197"></td>
        <td id="LC1197">                     <span>const</span> InstantiationContext * <span>const</span> pInstContext);</td>
      </tr>
      <tr>
        <td id="L1198" data-line-number="1198"></td>
        <td id="LC1198">
</td>
      </tr>
      <tr>
        <td id="L1199" data-line-number="1199"></td>
        <td id="LC1199">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1200" data-line-number="1200"></td>
        <td id="LC1200">    <span><span>//</span> METHOD TABLES AS TYPE DESCRIPTORS</span></td>
      </tr>
      <tr>
        <td id="L1201" data-line-number="1201"></td>
        <td id="LC1201">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1202" data-line-number="1202"></td>
        <td id="LC1202">    <span><span>//</span> A MethodTable can represeent a type such as "String" or an</span></td>
      </tr>
      <tr>
        <td id="L1203" data-line-number="1203"></td>
        <td id="LC1203">    <span><span>//</span> instantiated type such as "List&lt;String&gt;".</span></td>
      </tr>
      <tr>
        <td id="L1204" data-line-number="1204"></td>
        <td id="LC1204">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1205" data-line-number="1205"></td>
        <td id="LC1205">
</td>
      </tr>
      <tr>
        <td id="L1206" data-line-number="1206"></td>
        <td id="LC1206">    <span>inline</span> BOOL <span>IsInterface</span>()</td>
      </tr>
      <tr>
        <td id="L1207" data-line-number="1207"></td>
        <td id="LC1207">    {</td>
      </tr>
      <tr>
        <td id="L1208" data-line-number="1208"></td>
        <td id="LC1208">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1209" data-line-number="1209"></td>
        <td id="LC1209">        <span>return</span> <span>GetFlag</span>(enum_flag_Category_Mask) == enum_flag_Category_Interface;</td>
      </tr>
      <tr>
        <td id="L1210" data-line-number="1210"></td>
        <td id="LC1210">    }</td>
      </tr>
      <tr>
        <td id="L1211" data-line-number="1211"></td>
        <td id="LC1211">
</td>
      </tr>
      <tr>
        <td id="L1212" data-line-number="1212"></td>
        <td id="LC1212">    <span>void</span> <span>SetIsInterface</span>()</td>
      </tr>
      <tr>
        <td id="L1213" data-line-number="1213"></td>
        <td id="LC1213">    {</td>
      </tr>
      <tr>
        <td id="L1214" data-line-number="1214"></td>
        <td id="LC1214">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1215" data-line-number="1215"></td>
        <td id="LC1215">
</td>
      </tr>
      <tr>
        <td id="L1216" data-line-number="1216"></td>
        <td id="LC1216">        <span>_ASSERTE</span>(<span>GetFlag</span>(enum_flag_Category_Mask) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L1217" data-line-number="1217"></td>
        <td id="LC1217">        <span>SetFlag</span>(enum_flag_Category_Interface);</td>
      </tr>
      <tr>
        <td id="L1218" data-line-number="1218"></td>
        <td id="LC1218">    }</td>
      </tr>
      <tr>
        <td id="L1219" data-line-number="1219"></td>
        <td id="LC1219">
</td>
      </tr>
      <tr>
        <td id="L1220" data-line-number="1220"></td>
        <td id="LC1220">    <span>inline</span> BOOL <span>IsSealed</span>();</td>
      </tr>
      <tr>
        <td id="L1221" data-line-number="1221"></td>
        <td id="LC1221">
</td>
      </tr>
      <tr>
        <td id="L1222" data-line-number="1222"></td>
        <td id="LC1222">    <span>inline</span> BOOL <span>IsAbstract</span>();</td>
      </tr>
      <tr>
        <td id="L1223" data-line-number="1223"></td>
        <td id="LC1223">
</td>
      </tr>
      <tr>
        <td id="L1224" data-line-number="1224"></td>
        <td id="LC1224">    BOOL <span>IsExternallyVisible</span>();</td>
      </tr>
      <tr>
        <td id="L1225" data-line-number="1225"></td>
        <td id="LC1225">
</td>
      </tr>
      <tr>
        <td id="L1226" data-line-number="1226"></td>
        <td id="LC1226">    <span><span>//</span> Get the instantiation for this instantiated type e.g. for Dict&lt;string,int&gt;</span></td>
      </tr>
      <tr>
        <td id="L1227" data-line-number="1227"></td>
        <td id="LC1227">    <span><span>//</span> this would be an array {string,int}</span></td>
      </tr>
      <tr>
        <td id="L1228" data-line-number="1228"></td>
        <td id="LC1228">    <span><span>//</span> If not instantiated, return NULL</span></td>
      </tr>
      <tr>
        <td id="L1229" data-line-number="1229"></td>
        <td id="LC1229">    Instantiation <span>GetInstantiation</span>();</td>
      </tr>
      <tr>
        <td id="L1230" data-line-number="1230"></td>
        <td id="LC1230">
</td>
      </tr>
      <tr>
        <td id="L1231" data-line-number="1231"></td>
        <td id="LC1231">    <span><span>//</span> Get the instantiation for an instantiated type or a pointer to the</span></td>
      </tr>
      <tr>
        <td id="L1232" data-line-number="1232"></td>
        <td id="LC1232">    <span><span>//</span> element type for an array</span></td>
      </tr>
      <tr>
        <td id="L1233" data-line-number="1233"></td>
        <td id="LC1233">    Instantiation <span>GetClassOrArrayInstantiation</span>();</td>
      </tr>
      <tr>
        <td id="L1234" data-line-number="1234"></td>
        <td id="LC1234">    Instantiation <span>GetArrayInstantiation</span>();</td>
      </tr>
      <tr>
        <td id="L1235" data-line-number="1235"></td>
        <td id="LC1235">
</td>
      </tr>
      <tr>
        <td id="L1236" data-line-number="1236"></td>
        <td id="LC1236">    <span><span>//</span> Does this method table require that additional modules be loaded?</span></td>
      </tr>
      <tr>
        <td id="L1237" data-line-number="1237"></td>
        <td id="LC1237">    <span>inline</span> BOOL <span>HasModuleDependencies</span>()</td>
      </tr>
      <tr>
        <td id="L1238" data-line-number="1238"></td>
        <td id="LC1238">    {</td>
      </tr>
      <tr>
        <td id="L1239" data-line-number="1239"></td>
        <td id="LC1239">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1240" data-line-number="1240"></td>
        <td id="LC1240">        <span>return</span> <span>GetFlag</span>(enum_flag_HasModuleDependencies);</td>
      </tr>
      <tr>
        <td id="L1241" data-line-number="1241"></td>
        <td id="LC1241">    }</td>
      </tr>
      <tr>
        <td id="L1242" data-line-number="1242"></td>
        <td id="LC1242">
</td>
      </tr>
      <tr>
        <td id="L1243" data-line-number="1243"></td>
        <td id="LC1243">    <span>inline</span> <span>void</span> <span>SetHasModuleDependencies</span>()</td>
      </tr>
      <tr>
        <td id="L1244" data-line-number="1244"></td>
        <td id="LC1244">    {</td>
      </tr>
      <tr>
        <td id="L1245" data-line-number="1245"></td>
        <td id="LC1245">        <span>SetFlag</span>(enum_flag_HasModuleDependencies);</td>
      </tr>
      <tr>
        <td id="L1246" data-line-number="1246"></td>
        <td id="LC1246">    }</td>
      </tr>
      <tr>
        <td id="L1247" data-line-number="1247"></td>
        <td id="LC1247">
</td>
      </tr>
      <tr>
        <td id="L1248" data-line-number="1248"></td>
        <td id="LC1248">    <span>inline</span> BOOL <span>IsIntrinsicType</span>()</td>
      </tr>
      <tr>
        <td id="L1249" data-line-number="1249"></td>
        <td id="LC1249">    {</td>
      </tr>
      <tr>
        <td id="L1250" data-line-number="1250"></td>
        <td id="LC1250">        LIMITED_METHOD_DAC_CONTRACT;;</td>
      </tr>
      <tr>
        <td id="L1251" data-line-number="1251"></td>
        <td id="LC1251">        <span>return</span> <span>GetFlag</span>(enum_flag_IsIntrinsicType);</td>
      </tr>
      <tr>
        <td id="L1252" data-line-number="1252"></td>
        <td id="LC1252">    }</td>
      </tr>
      <tr>
        <td id="L1253" data-line-number="1253"></td>
        <td id="LC1253">
</td>
      </tr>
      <tr>
        <td id="L1254" data-line-number="1254"></td>
        <td id="LC1254">    <span>inline</span> <span>void</span> <span>SetIsIntrinsicType</span>()</td>
      </tr>
      <tr>
        <td id="L1255" data-line-number="1255"></td>
        <td id="LC1255">    {</td>
      </tr>
      <tr>
        <td id="L1256" data-line-number="1256"></td>
        <td id="LC1256">        LIMITED_METHOD_DAC_CONTRACT;;</td>
      </tr>
      <tr>
        <td id="L1257" data-line-number="1257"></td>
        <td id="LC1257">        <span>SetFlag</span>(enum_flag_IsIntrinsicType);</td>
      </tr>
      <tr>
        <td id="L1258" data-line-number="1258"></td>
        <td id="LC1258">    }</td>
      </tr>
      <tr>
        <td id="L1259" data-line-number="1259"></td>
        <td id="LC1259">
</td>
      </tr>
      <tr>
        <td id="L1260" data-line-number="1260"></td>
        <td id="LC1260">    <span><span>//</span> See the comment in code:MethodTable.DoFullyLoad for detailed description.</span></td>
      </tr>
      <tr>
        <td id="L1261" data-line-number="1261"></td>
        <td id="LC1261">    <span>inline</span> BOOL <span>DependsOnEquivalentOrForwardedStructs</span>()</td>
      </tr>
      <tr>
        <td id="L1262" data-line-number="1262"></td>
        <td id="LC1262">    {</td>
      </tr>
      <tr>
        <td id="L1263" data-line-number="1263"></td>
        <td id="LC1263">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1264" data-line-number="1264"></td>
        <td id="LC1264">        <span>return</span> <span>GetFlag</span>(enum_flag_DependsOnEquivalentOrForwardedStructs);</td>
      </tr>
      <tr>
        <td id="L1265" data-line-number="1265"></td>
        <td id="LC1265">    }</td>
      </tr>
      <tr>
        <td id="L1266" data-line-number="1266"></td>
        <td id="LC1266">
</td>
      </tr>
      <tr>
        <td id="L1267" data-line-number="1267"></td>
        <td id="LC1267">    <span>inline</span> <span>void</span> <span>SetDependsOnEquivalentOrForwardedStructs</span>()</td>
      </tr>
      <tr>
        <td id="L1268" data-line-number="1268"></td>
        <td id="LC1268">    {</td>
      </tr>
      <tr>
        <td id="L1269" data-line-number="1269"></td>
        <td id="LC1269">        <span>SetFlag</span>(enum_flag_DependsOnEquivalentOrForwardedStructs);</td>
      </tr>
      <tr>
        <td id="L1270" data-line-number="1270"></td>
        <td id="LC1270">    }</td>
      </tr>
      <tr>
        <td id="L1271" data-line-number="1271"></td>
        <td id="LC1271">
</td>
      </tr>
      <tr>
        <td id="L1272" data-line-number="1272"></td>
        <td id="LC1272">    <span><span>//</span> Is this a method table for a generic type instantiation, e.g. List&lt;string&gt;?</span></td>
      </tr>
      <tr>
        <td id="L1273" data-line-number="1273"></td>
        <td id="LC1273">    <span>inline</span> BOOL <span>HasInstantiation</span>();</td>
      </tr>
      <tr>
        <td id="L1274" data-line-number="1274"></td>
        <td id="LC1274">
</td>
      </tr>
      <tr>
        <td id="L1275" data-line-number="1275"></td>
        <td id="LC1275">    <span><span>//</span> Returns true for any class which is either itself a generic</span></td>
      </tr>
      <tr>
        <td id="L1276" data-line-number="1276"></td>
        <td id="LC1276">    <span><span>//</span> instantiation or is derived from a generic</span></td>
      </tr>
      <tr>
        <td id="L1277" data-line-number="1277"></td>
        <td id="LC1277">    <span><span>//</span> instantiation anywhere in it's class hierarchy,</span></td>
      </tr>
      <tr>
        <td id="L1278" data-line-number="1278"></td>
        <td id="LC1278">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1279" data-line-number="1279"></td>
        <td id="LC1279">    <span><span>//</span> e.g. class D : C&lt;int&gt;</span></td>
      </tr>
      <tr>
        <td id="L1280" data-line-number="1280"></td>
        <td id="LC1280">    <span><span>//</span> or class E : D, class D : C&lt;int&gt;</span></td>
      </tr>
      <tr>
        <td id="L1281" data-line-number="1281"></td>
        <td id="LC1281">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1282" data-line-number="1282"></td>
        <td id="LC1282">    <span><span>//</span> Does not return true just because the class supports</span></td>
      </tr>
      <tr>
        <td id="L1283" data-line-number="1283"></td>
        <td id="LC1283">    <span><span>//</span> an instantiated interface type.</span></td>
      </tr>
      <tr>
        <td id="L1284" data-line-number="1284"></td>
        <td id="LC1284">    BOOL <span>HasGenericClassInstantiationInHierarchy</span>()</td>
      </tr>
      <tr>
        <td id="L1285" data-line-number="1285"></td>
        <td id="LC1285">    {</td>
      </tr>
      <tr>
        <td id="L1286" data-line-number="1286"></td>
        <td id="LC1286">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1287" data-line-number="1287"></td>
        <td id="LC1287">        <span>return</span> <span>GetNumDicts</span>() != <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1288" data-line-number="1288"></td>
        <td id="LC1288">    }</td>
      </tr>
      <tr>
        <td id="L1289" data-line-number="1289"></td>
        <td id="LC1289">
</td>
      </tr>
      <tr>
        <td id="L1290" data-line-number="1290"></td>
        <td id="LC1290">    <span><span>//</span> Is this an instantiation of a generic class at its formal</span></td>
      </tr>
      <tr>
        <td id="L1291" data-line-number="1291"></td>
        <td id="LC1291">    <span><span>//</span> type parameters ie. List&lt;T&gt; ?</span></td>
      </tr>
      <tr>
        <td id="L1292" data-line-number="1292"></td>
        <td id="LC1292">    <span>inline</span> BOOL <span>IsGenericTypeDefinition</span>();</td>
      </tr>
      <tr>
        <td id="L1293" data-line-number="1293"></td>
        <td id="LC1293">
</td>
      </tr>
      <tr>
        <td id="L1294" data-line-number="1294"></td>
        <td id="LC1294">    BOOL <span>ContainsGenericMethodVariables</span>();</td>
      </tr>
      <tr>
        <td id="L1295" data-line-number="1295"></td>
        <td id="LC1295">
</td>
      </tr>
      <tr>
        <td id="L1296" data-line-number="1296"></td>
        <td id="LC1296">    <span>static</span> BOOL <span>ComputeContainsGenericVariables</span>(Instantiation inst);</td>
      </tr>
      <tr>
        <td id="L1297" data-line-number="1297"></td>
        <td id="LC1297">
</td>
      </tr>
      <tr>
        <td id="L1298" data-line-number="1298"></td>
        <td id="LC1298">    <span>inline</span> <span>void</span> <span>SetContainsGenericVariables</span>()</td>
      </tr>
      <tr>
        <td id="L1299" data-line-number="1299"></td>
        <td id="LC1299">    {</td>
      </tr>
      <tr>
        <td id="L1300" data-line-number="1300"></td>
        <td id="LC1300">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1301" data-line-number="1301"></td>
        <td id="LC1301">        <span>SetFlag</span>(enum_flag_ContainsGenericVariables);</td>
      </tr>
      <tr>
        <td id="L1302" data-line-number="1302"></td>
        <td id="LC1302">    }</td>
      </tr>
      <tr>
        <td id="L1303" data-line-number="1303"></td>
        <td id="LC1303">
</td>
      </tr>
      <tr>
        <td id="L1304" data-line-number="1304"></td>
        <td id="LC1304">    <span>inline</span> <span>void</span> <span>SetHasVariance</span>()</td>
      </tr>
      <tr>
        <td id="L1305" data-line-number="1305"></td>
        <td id="LC1305">    {</td>
      </tr>
      <tr>
        <td id="L1306" data-line-number="1306"></td>
        <td id="LC1306">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1307" data-line-number="1307"></td>
        <td id="LC1307">        <span>SetFlag</span>(enum_flag_HasVariance);</td>
      </tr>
      <tr>
        <td id="L1308" data-line-number="1308"></td>
        <td id="LC1308">    }</td>
      </tr>
      <tr>
        <td id="L1309" data-line-number="1309"></td>
        <td id="LC1309">
</td>
      </tr>
      <tr>
        <td id="L1310" data-line-number="1310"></td>
        <td id="LC1310">    <span>inline</span> BOOL <span>HasVariance</span>()</td>
      </tr>
      <tr>
        <td id="L1311" data-line-number="1311"></td>
        <td id="LC1311">    {</td>
      </tr>
      <tr>
        <td id="L1312" data-line-number="1312"></td>
        <td id="LC1312">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1313" data-line-number="1313"></td>
        <td id="LC1313">        <span>return</span> <span>GetFlag</span>(enum_flag_HasVariance);</td>
      </tr>
      <tr>
        <td id="L1314" data-line-number="1314"></td>
        <td id="LC1314">    }</td>
      </tr>
      <tr>
        <td id="L1315" data-line-number="1315"></td>
        <td id="LC1315">
</td>
      </tr>
      <tr>
        <td id="L1316" data-line-number="1316"></td>
        <td id="LC1316">    <span><span>//</span> Is this something like List&lt;T&gt; or List&lt;Stack&lt;T&gt;&gt;?</span></td>
      </tr>
      <tr>
        <td id="L1317" data-line-number="1317"></td>
        <td id="LC1317">    <span><span>//</span> List&lt;Blah&lt;T&gt;&gt; only exists for reflection and verification.</span></td>
      </tr>
      <tr>
        <td id="L1318" data-line-number="1318"></td>
        <td id="LC1318">    <span>inline</span> DWORD <span>ContainsGenericVariables</span>(BOOL methodVarsOnly = <span>FALSE</span>)</td>
      </tr>
      <tr>
        <td id="L1319" data-line-number="1319"></td>
        <td id="LC1319">    {</td>
      </tr>
      <tr>
        <td id="L1320" data-line-number="1320"></td>
        <td id="LC1320">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1321" data-line-number="1321"></td>
        <td id="LC1321">        SUPPORTS_DAC;</td>
      </tr>
      <tr>
        <td id="L1322" data-line-number="1322"></td>
        <td id="LC1322">        <span>if</span> (methodVarsOnly)</td>
      </tr>
      <tr>
        <td id="L1323" data-line-number="1323"></td>
        <td id="LC1323">            <span>return</span> <span>ContainsGenericMethodVariables</span>();</td>
      </tr>
      <tr>
        <td id="L1324" data-line-number="1324"></td>
        <td id="LC1324">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L1325" data-line-number="1325"></td>
        <td id="LC1325">            <span>return</span> <span>GetFlag</span>(enum_flag_ContainsGenericVariables);</td>
      </tr>
      <tr>
        <td id="L1326" data-line-number="1326"></td>
        <td id="LC1326">    }</td>
      </tr>
      <tr>
        <td id="L1327" data-line-number="1327"></td>
        <td id="LC1327">
</td>
      </tr>
      <tr>
        <td id="L1328" data-line-number="1328"></td>
        <td id="LC1328">    BOOL <span>IsByRefLike</span>()</td>
      </tr>
      <tr>
        <td id="L1329" data-line-number="1329"></td>
        <td id="LC1329">    {</td>
      </tr>
      <tr>
        <td id="L1330" data-line-number="1330"></td>
        <td id="LC1330">        LIMITED_METHOD_DAC_CONTRACT;;</td>
      </tr>
      <tr>
        <td id="L1331" data-line-number="1331"></td>
        <td id="LC1331">        <span>return</span> <span>GetFlag</span>(enum_flag_IsByRefLike);</td>
      </tr>
      <tr>
        <td id="L1332" data-line-number="1332"></td>
        <td id="LC1332">    }</td>
      </tr>
      <tr>
        <td id="L1333" data-line-number="1333"></td>
        <td id="LC1333">
</td>
      </tr>
      <tr>
        <td id="L1334" data-line-number="1334"></td>
        <td id="LC1334">    <span>void</span> <span>SetIsByRefLike</span>()</td>
      </tr>
      <tr>
        <td id="L1335" data-line-number="1335"></td>
        <td id="LC1335">    {</td>
      </tr>
      <tr>
        <td id="L1336" data-line-number="1336"></td>
        <td id="LC1336">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1337" data-line-number="1337"></td>
        <td id="LC1337">        <span>SetFlag</span>(enum_flag_IsByRefLike);</td>
      </tr>
      <tr>
        <td id="L1338" data-line-number="1338"></td>
        <td id="LC1338">    }</td>
      </tr>
      <tr>
        <td id="L1339" data-line-number="1339"></td>
        <td id="LC1339">
</td>
      </tr>
      <tr>
        <td id="L1340" data-line-number="1340"></td>
        <td id="LC1340">    <span><span>//</span> class is a com object class</span></td>
      </tr>
      <tr>
        <td id="L1341" data-line-number="1341"></td>
        <td id="LC1341">    Module* <span>GetDefiningModuleForOpenType</span>();</td>
      </tr>
      <tr>
        <td id="L1342" data-line-number="1342"></td>
        <td id="LC1342">
</td>
      </tr>
      <tr>
        <td id="L1343" data-line-number="1343"></td>
        <td id="LC1343">    <span>inline</span> BOOL <span>IsTypicalTypeDefinition</span>()</td>
      </tr>
      <tr>
        <td id="L1344" data-line-number="1344"></td>
        <td id="LC1344">    {</td>
      </tr>
      <tr>
        <td id="L1345" data-line-number="1345"></td>
        <td id="LC1345">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1346" data-line-number="1346"></td>
        <td id="LC1346">        <span>return</span> !<span>HasInstantiation</span>() || <span>IsGenericTypeDefinition</span>();</td>
      </tr>
      <tr>
        <td id="L1347" data-line-number="1347"></td>
        <td id="LC1347">    }</td>
      </tr>
      <tr>
        <td id="L1348" data-line-number="1348"></td>
        <td id="LC1348">
</td>
      </tr>
      <tr>
        <td id="L1349" data-line-number="1349"></td>
        <td id="LC1349">    <span>typedef</span> <span>enum</span></td>
      </tr>
      <tr>
        <td id="L1350" data-line-number="1350"></td>
        <td id="LC1350">    {</td>
      </tr>
      <tr>
        <td id="L1351" data-line-number="1351"></td>
        <td id="LC1351">        modeProjected = <span>0x1</span>,</td>
      </tr>
      <tr>
        <td id="L1352" data-line-number="1352"></td>
        <td id="LC1352">        modeRedirected = <span>0x2</span>,</td>
      </tr>
      <tr>
        <td id="L1353" data-line-number="1353"></td>
        <td id="LC1353">        modeAll = modeProjected|modeRedirected</td>
      </tr>
      <tr>
        <td id="L1354" data-line-number="1354"></td>
        <td id="LC1354">    } Mode;</td>
      </tr>
      <tr>
        <td id="L1355" data-line-number="1355"></td>
        <td id="LC1355">
</td>
      </tr>
      <tr>
        <td id="L1356" data-line-number="1356"></td>
        <td id="LC1356">    <span><span>//</span> Is this a generic interface/delegate that can be used for COM interop?</span></td>
      </tr>
      <tr>
        <td id="L1357" data-line-number="1357"></td>
        <td id="LC1357">    <span>inline</span> BOOL <span>SupportsGenericInterop</span>(TypeHandle::InteropKind interopKind, Mode = modeAll);</td>
      </tr>
      <tr>
        <td id="L1358" data-line-number="1358"></td>
        <td id="LC1358">
</td>
      </tr>
      <tr>
        <td id="L1359" data-line-number="1359"></td>
        <td id="LC1359">    BOOL <span>HasSameTypeDefAs</span>(MethodTable *pMT);</td>
      </tr>
      <tr>
        <td id="L1360" data-line-number="1360"></td>
        <td id="LC1360">    BOOL <span>HasSameTypeDefAs_NoLogging</span>(MethodTable *pMT);</td>
      </tr>
      <tr>
        <td id="L1361" data-line-number="1361"></td>
        <td id="LC1361">
</td>
      </tr>
      <tr>
        <td id="L1362" data-line-number="1362"></td>
        <td id="LC1362">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1363" data-line-number="1363"></td>
        <td id="LC1363">    <span><span>//</span> GENERICS &amp; CODE SHARING</span></td>
      </tr>
      <tr>
        <td id="L1364" data-line-number="1364"></td>
        <td id="LC1364">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1365" data-line-number="1365"></td>
        <td id="LC1365">
</td>
      </tr>
      <tr>
        <td id="L1366" data-line-number="1366"></td>
        <td id="LC1366">    BOOL <span>IsSharedByGenericInstantiations</span>();</td>
      </tr>
      <tr>
        <td id="L1367" data-line-number="1367"></td>
        <td id="LC1367">
</td>
      </tr>
      <tr>
        <td id="L1368" data-line-number="1368"></td>
        <td id="LC1368">    <span><span>//</span> If this is a "representative" generic MT or a non-generic (regular) MT return true</span></td>
      </tr>
      <tr>
        <td id="L1369" data-line-number="1369"></td>
        <td id="LC1369">    <span>inline</span> BOOL <span>IsCanonicalMethodTable</span>();</td>
      </tr>
      <tr>
        <td id="L1370" data-line-number="1370"></td>
        <td id="LC1370">
</td>
      </tr>
      <tr>
        <td id="L1371" data-line-number="1371"></td>
        <td id="LC1371">    <span><span>//</span> Return the canonical representative MT amongst the set of MT's that share</span></td>
      </tr>
      <tr>
        <td id="L1372" data-line-number="1372"></td>
        <td id="LC1372">    <span><span>//</span> code with the given MT because of generics.</span></td>
      </tr>
      <tr>
        <td id="L1373" data-line-number="1373"></td>
        <td id="LC1373">    PTR_MethodTable <span>GetCanonicalMethodTable</span>();</td>
      </tr>
      <tr>
        <td id="L1374" data-line-number="1374"></td>
        <td id="LC1374">
</td>
      </tr>
      <tr>
        <td id="L1375" data-line-number="1375"></td>
        <td id="LC1375">    <span><span>//</span> Returns fixup if canonical method table needs fixing up, NULL otherwise</span></td>
      </tr>
      <tr>
        <td id="L1376" data-line-number="1376"></td>
        <td id="LC1376">    TADDR <span>GetCanonicalMethodTableFixup</span>();</td>
      </tr>
      <tr>
        <td id="L1377" data-line-number="1377"></td>
        <td id="LC1377">
</td>
      </tr>
      <tr>
        <td id="L1378" data-line-number="1378"></td>
        <td id="LC1378">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1379" data-line-number="1379"></td>
        <td id="LC1379">    <span><span>//</span> Accessing methods by slot number</span></td>
      </tr>
      <tr>
        <td id="L1380" data-line-number="1380"></td>
        <td id="LC1380">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1381" data-line-number="1381"></td>
        <td id="LC1381">    <span><span>//</span> Some of these functions are also currently used to get non-virtual</span></td>
      </tr>
      <tr>
        <td id="L1382" data-line-number="1382"></td>
        <td id="LC1382">    <span><span>//</span> methods, relying on the assumption that they are contiguous.  This</span></td>
      </tr>
      <tr>
        <td id="L1383" data-line-number="1383"></td>
        <td id="LC1383">    <span><span>//</span> is not true for non-virtual methods in generic instantiations, which</span></td>
      </tr>
      <tr>
        <td id="L1384" data-line-number="1384"></td>
        <td id="LC1384">    <span><span>//</span> only live on the canonical method table.</span></td>
      </tr>
      <tr>
        <td id="L1385" data-line-number="1385"></td>
        <td id="LC1385">
</td>
      </tr>
      <tr>
        <td id="L1386" data-line-number="1386"></td>
        <td id="LC1386">    <span>enum</span></td>
      </tr>
      <tr>
        <td id="L1387" data-line-number="1387"></td>
        <td id="LC1387">    {</td>
      </tr>
      <tr>
        <td id="L1388" data-line-number="1388"></td>
        <td id="LC1388">        NO_SLOT = <span>0xffff</span> <span><span>//</span> a unique slot number used to indicate "empty" for fields that record slot numbers</span></td>
      </tr>
      <tr>
        <td id="L1389" data-line-number="1389"></td>
        <td id="LC1389">    };</td>
      </tr>
      <tr>
        <td id="L1390" data-line-number="1390"></td>
        <td id="LC1390">
</td>
      </tr>
      <tr>
        <td id="L1391" data-line-number="1391"></td>
        <td id="LC1391">    PCODE <span>GetSlot</span>(UINT32 slotNumber)</td>
      </tr>
      <tr>
        <td id="L1392" data-line-number="1392"></td>
        <td id="LC1392">    {</td>
      </tr>
      <tr>
        <td id="L1393" data-line-number="1393"></td>
        <td id="LC1393">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1394" data-line-number="1394"></td>
        <td id="LC1394">        <span>CONSISTENCY_CHECK</span>(slotNumber &lt; <span>GetNumVtableSlots</span>());</td>
      </tr>
      <tr>
        <td id="L1395" data-line-number="1395"></td>
        <td id="LC1395">
</td>
      </tr>
      <tr>
        <td id="L1396" data-line-number="1396"></td>
        <td id="LC1396">        TADDR pSlot = <span>GetSlotPtrRaw</span>(slotNumber);</td>
      </tr>
      <tr>
        <td id="L1397" data-line-number="1397"></td>
        <td id="LC1397">        <span>if</span> (slotNumber &lt; <span>GetNumVirtuals</span>())</td>
      </tr>
      <tr>
        <td id="L1398" data-line-number="1398"></td>
        <td id="LC1398">        {</td>
      </tr>
      <tr>
        <td id="L1399" data-line-number="1399"></td>
        <td id="LC1399">            <span>return</span> <span>VTableIndir2_t::GetValueMaybeNullAtPtr</span>(pSlot);</td>
      </tr>
      <tr>
        <td id="L1400" data-line-number="1400"></td>
        <td id="LC1400">        }</td>
      </tr>
      <tr>
        <td id="L1401" data-line-number="1401"></td>
        <td id="LC1401">        <span>else</span> <span>if</span> (<span>IsZapped</span>() &amp;&amp; slotNumber &gt;= <span>GetNumVirtuals</span>())</td>
      </tr>
      <tr>
        <td id="L1402" data-line-number="1402"></td>
        <td id="LC1402">        {</td>
      </tr>
      <tr>
        <td id="L1403" data-line-number="1403"></td>
        <td id="LC1403">            <span><span>//</span> Non-virtual slots in NGened images are relative pointers</span></td>
      </tr>
      <tr>
        <td id="L1404" data-line-number="1404"></td>
        <td id="LC1404">            <span>return</span> RelativePointer&lt;PCODE&gt;::<span>GetValueAtPtr</span>(pSlot);</td>
      </tr>
      <tr>
        <td id="L1405" data-line-number="1405"></td>
        <td id="LC1405">        }</td>
      </tr>
      <tr>
        <td id="L1406" data-line-number="1406"></td>
        <td id="LC1406">        <span>return</span> *dac_cast&lt;PTR_PCODE&gt;(pSlot);</td>
      </tr>
      <tr>
        <td id="L1407" data-line-number="1407"></td>
        <td id="LC1407">    }</td>
      </tr>
      <tr>
        <td id="L1408" data-line-number="1408"></td>
        <td id="LC1408">
</td>
      </tr>
      <tr>
        <td id="L1409" data-line-number="1409"></td>
        <td id="LC1409">    <span><span>//</span> Special-case for when we know that the slot number corresponds</span></td>
      </tr>
      <tr>
        <td id="L1410" data-line-number="1410"></td>
        <td id="LC1410">    <span><span>//</span> to a virtual method.</span></td>
      </tr>
      <tr>
        <td id="L1411" data-line-number="1411"></td>
        <td id="LC1411">    <span>inline</span> PCODE <span>GetSlotForVirtual</span>(UINT32 slotNum)</td>
      </tr>
      <tr>
        <td id="L1412" data-line-number="1412"></td>
        <td id="LC1412">    {</td>
      </tr>
      <tr>
        <td id="L1413" data-line-number="1413"></td>
        <td id="LC1413">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1414" data-line-number="1414"></td>
        <td id="LC1414">
</td>
      </tr>
      <tr>
        <td id="L1415" data-line-number="1415"></td>
        <td id="LC1415">        <span>CONSISTENCY_CHECK</span>(slotNum &lt; <span>GetNumVirtuals</span>());</td>
      </tr>
      <tr>
        <td id="L1416" data-line-number="1416"></td>
        <td id="LC1416">        <span><span>//</span> Virtual slots live in chunks pointed to by vtable indirections</span></td>
      </tr>
      <tr>
        <td id="L1417" data-line-number="1417"></td>
        <td id="LC1417">
</td>
      </tr>
      <tr>
        <td id="L1418" data-line-number="1418"></td>
        <td id="LC1418">        DWORD <span>index</span> = <span>GetIndexOfVtableIndirection</span>(slotNum);</td>
      </tr>
      <tr>
        <td id="L1419" data-line-number="1419"></td>
        <td id="LC1419">        TADDR base = dac_cast&lt;TADDR&gt;(&amp;(<span>GetVtableIndirections</span>()[<span>index</span>]));</td>
      </tr>
      <tr>
        <td id="L1420" data-line-number="1420"></td>
        <td id="LC1420">        <span>DPTR</span>(VTableIndir2_t) baseAfterInd = <span>VTableIndir_t::GetValueMaybeNullAtPtr</span>(base) + <span>GetIndexAfterVtableIndirection</span>(slotNum);</td>
      </tr>
      <tr>
        <td id="L1421" data-line-number="1421"></td>
        <td id="LC1421">        <span>return</span> <span>VTableIndir2_t::GetValueMaybeNullAtPtr</span>(dac_cast&lt;TADDR&gt;(baseAfterInd));</td>
      </tr>
      <tr>
        <td id="L1422" data-line-number="1422"></td>
        <td id="LC1422">    }</td>
      </tr>
      <tr>
        <td id="L1423" data-line-number="1423"></td>
        <td id="LC1423">
</td>
      </tr>
      <tr>
        <td id="L1424" data-line-number="1424"></td>
        <td id="LC1424">    TADDR <span>GetSlotPtrRaw</span>(UINT32 slotNum)</td>
      </tr>
      <tr>
        <td id="L1425" data-line-number="1425"></td>
        <td id="LC1425">    {</td>
      </tr>
      <tr>
        <td id="L1426" data-line-number="1426"></td>
        <td id="LC1426">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1427" data-line-number="1427"></td>
        <td id="LC1427">        <span>CONSISTENCY_CHECK</span>(slotNum &lt; <span>GetNumVtableSlots</span>());</td>
      </tr>
      <tr>
        <td id="L1428" data-line-number="1428"></td>
        <td id="LC1428">
</td>
      </tr>
      <tr>
        <td id="L1429" data-line-number="1429"></td>
        <td id="LC1429">        <span>if</span> (slotNum &lt; <span>GetNumVirtuals</span>())</td>
      </tr>
      <tr>
        <td id="L1430" data-line-number="1430"></td>
        <td id="LC1430">        {</td>
      </tr>
      <tr>
        <td id="L1431" data-line-number="1431"></td>
        <td id="LC1431">            <span><span>//</span> Virtual slots live in chunks pointed to by vtable indirections</span></td>
      </tr>
      <tr>
        <td id="L1432" data-line-number="1432"></td>
        <td id="LC1432">            DWORD <span>index</span> = <span>GetIndexOfVtableIndirection</span>(slotNum);</td>
      </tr>
      <tr>
        <td id="L1433" data-line-number="1433"></td>
        <td id="LC1433">            TADDR base = dac_cast&lt;TADDR&gt;(&amp;(<span>GetVtableIndirections</span>()[<span>index</span>]));</td>
      </tr>
      <tr>
        <td id="L1434" data-line-number="1434"></td>
        <td id="LC1434">            <span>DPTR</span>(VTableIndir2_t) baseAfterInd = <span>VTableIndir_t::GetValueMaybeNullAtPtr</span>(base) + <span>GetIndexAfterVtableIndirection</span>(slotNum);</td>
      </tr>
      <tr>
        <td id="L1435" data-line-number="1435"></td>
        <td id="LC1435">            <span>return</span> dac_cast&lt;TADDR&gt;(baseAfterInd);</td>
      </tr>
      <tr>
        <td id="L1436" data-line-number="1436"></td>
        <td id="LC1436">        }</td>
      </tr>
      <tr>
        <td id="L1437" data-line-number="1437"></td>
        <td id="LC1437">        <span>else</span> <span>if</span> (<span>HasSingleNonVirtualSlot</span>())</td>
      </tr>
      <tr>
        <td id="L1438" data-line-number="1438"></td>
        <td id="LC1438">        {</td>
      </tr>
      <tr>
        <td id="L1439" data-line-number="1439"></td>
        <td id="LC1439">            <span><span>//</span> Non-virtual slots &lt; GetNumVtableSlots live in a single chunk pointed to by an optional member,</span></td>
      </tr>
      <tr>
        <td id="L1440" data-line-number="1440"></td>
        <td id="LC1440">            <span><span>//</span> except when there is only one in which case it lives in the optional member itself</span></td>
      </tr>
      <tr>
        <td id="L1441" data-line-number="1441"></td>
        <td id="LC1441">            <span>_ASSERTE</span>(slotNum == <span>GetNumVirtuals</span>());</td>
      </tr>
      <tr>
        <td id="L1442" data-line-number="1442"></td>
        <td id="LC1442">            <span>return</span> <span>GetNonVirtualSlotsPtr</span>();</td>
      </tr>
      <tr>
        <td id="L1443" data-line-number="1443"></td>
        <td id="LC1443">        }</td>
      </tr>
      <tr>
        <td id="L1444" data-line-number="1444"></td>
        <td id="LC1444">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L1445" data-line-number="1445"></td>
        <td id="LC1445">        {</td>
      </tr>
      <tr>
        <td id="L1446" data-line-number="1446"></td>
        <td id="LC1446">            <span><span>//</span> Non-virtual slots &lt; GetNumVtableSlots live in a single chunk pointed to by an optional member</span></td>
      </tr>
      <tr>
        <td id="L1447" data-line-number="1447"></td>
        <td id="LC1447">            <span>_ASSERTE</span>(<span>HasNonVirtualSlotsArray</span>());</td>
      </tr>
      <tr>
        <td id="L1448" data-line-number="1448"></td>
        <td id="LC1448">            g_IBCLogger.<span>LogMethodTableNonVirtualSlotsAccess</span>(this);</td>
      </tr>
      <tr>
        <td id="L1449" data-line-number="1449"></td>
        <td id="LC1449">            <span>return</span> dac_cast&lt;TADDR&gt;(<span>GetNonVirtualSlotsArray</span>() + (slotNum - <span>GetNumVirtuals</span>()));</td>
      </tr>
      <tr>
        <td id="L1450" data-line-number="1450"></td>
        <td id="LC1450">        }</td>
      </tr>
      <tr>
        <td id="L1451" data-line-number="1451"></td>
        <td id="LC1451">    }</td>
      </tr>
      <tr>
        <td id="L1452" data-line-number="1452"></td>
        <td id="LC1452">
</td>
      </tr>
      <tr>
        <td id="L1453" data-line-number="1453"></td>
        <td id="LC1453">    TADDR <span>GetSlotPtr</span>(UINT32 slotNum)</td>
      </tr>
      <tr>
        <td id="L1454" data-line-number="1454"></td>
        <td id="LC1454">    {</td>
      </tr>
      <tr>
        <td id="L1455" data-line-number="1455"></td>
        <td id="LC1455">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1456" data-line-number="1456"></td>
        <td id="LC1456">
</td>
      </tr>
      <tr>
        <td id="L1457" data-line-number="1457"></td>
        <td id="LC1457">        <span><span>//</span> Slots in NGened images are relative pointers</span></td>
      </tr>
      <tr>
        <td id="L1458" data-line-number="1458"></td>
        <td id="LC1458">        <span>CONSISTENCY_CHECK</span>(!<span>IsZapped</span>());</td>
      </tr>
      <tr>
        <td id="L1459" data-line-number="1459"></td>
        <td id="LC1459">
</td>
      </tr>
      <tr>
        <td id="L1460" data-line-number="1460"></td>
        <td id="LC1460">        <span>return</span> <span>GetSlotPtrRaw</span>(slotNum);</td>
      </tr>
      <tr>
        <td id="L1461" data-line-number="1461"></td>
        <td id="LC1461">    }</td>
      </tr>
      <tr>
        <td id="L1462" data-line-number="1462"></td>
        <td id="LC1462">
</td>
      </tr>
      <tr>
        <td id="L1463" data-line-number="1463"></td>
        <td id="LC1463">    <span>void</span> <span>SetSlot</span>(UINT32 slotNum, PCODE slotVal);</td>
      </tr>
      <tr>
        <td id="L1464" data-line-number="1464"></td>
        <td id="LC1464">
</td>
      </tr>
      <tr>
        <td id="L1465" data-line-number="1465"></td>
        <td id="LC1465">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1466" data-line-number="1466"></td>
        <td id="LC1466">    <span><span>//</span> The VTABLE</span></td>
      </tr>
      <tr>
        <td id="L1467" data-line-number="1467"></td>
        <td id="LC1467">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1468" data-line-number="1468"></td>
        <td id="LC1468">    <span><span>//</span> Rather than the traditional array of code pointers (or "slots") we use a two-level vtable in</span></td>
      </tr>
      <tr>
        <td id="L1469" data-line-number="1469"></td>
        <td id="LC1469">    <span><span>//</span> which slots for virtual methods live in chunks.  Doing so allows the chunks to be shared among</span></td>
      </tr>
      <tr>
        <td id="L1470" data-line-number="1470"></td>
        <td id="LC1470">    <span><span>//</span> method tables (the most common example being between parent and child classes where the child</span></td>
      </tr>
      <tr>
        <td id="L1471" data-line-number="1471"></td>
        <td id="LC1471">    <span><span>//</span> does not override any method in the chunk).  This yields substantial space savings at the fixed</span></td>
      </tr>
      <tr>
        <td id="L1472" data-line-number="1472"></td>
        <td id="LC1472">    <span><span>//</span> cost of one additional indirection for a virtual call.</span></td>
      </tr>
      <tr>
        <td id="L1473" data-line-number="1473"></td>
        <td id="LC1473">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1474" data-line-number="1474"></td>
        <td id="LC1474">    <span><span>//</span> Note that none of this should be visible outside the implementation of MethodTable; all other</span></td>
      </tr>
      <tr>
        <td id="L1475" data-line-number="1475"></td>
        <td id="LC1475">    <span><span>//</span> code continues to refer to a virtual method via the traditional slot number.  This is similar to</span></td>
      </tr>
      <tr>
        <td id="L1476" data-line-number="1476"></td>
        <td id="LC1476">    <span><span>//</span> how we refer to non-virtual methods as having a slot number despite having long ago moved their</span></td>
      </tr>
      <tr>
        <td id="L1477" data-line-number="1477"></td>
        <td id="LC1477">    <span><span>//</span> code pointers out of the vtable.</span></td>
      </tr>
      <tr>
        <td id="L1478" data-line-number="1478"></td>
        <td id="LC1478">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1479" data-line-number="1479"></td>
        <td id="LC1479">    <span><span>//</span> Consider a class where GetNumVirtuals is 5 and (for the sake of the example) assume we break</span></td>
      </tr>
      <tr>
        <td id="L1480" data-line-number="1480"></td>
        <td id="LC1480">    <span><span>//</span> the vtable into chunks of size 3.  The layout would be as follows:</span></td>
      </tr>
      <tr>
        <td id="L1481" data-line-number="1481"></td>
        <td id="LC1481">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1482" data-line-number="1482"></td>
        <td id="LC1482">    <span><span>//</span>   pMT                       chunk 1                   chunk 2</span></td>
      </tr>
      <tr>
        <td id="L1483" data-line-number="1483"></td>
        <td id="LC1483">    <span><span>//</span>   ------------------        ------------------        ------------------</span></td>
      </tr>
      <tr>
        <td id="L1484" data-line-number="1484"></td>
        <td id="LC1484">    <span><span>//</span>   |                |        |      M1()      |        |      M4()      |</span></td>
      </tr>
      <tr>
        <td id="L1485" data-line-number="1485"></td>
        <td id="LC1485">    <span><span>//</span>   |   fixed-size   |        ------------------        ------------------</span></td>
      </tr>
      <tr>
        <td id="L1486" data-line-number="1486"></td>
        <td id="LC1486">    <span><span>//</span>   |   portion of   |        |      M2()      |        |      M5()      |</span></td>
      </tr>
      <tr>
        <td id="L1487" data-line-number="1487"></td>
        <td id="LC1487">    <span><span>//</span>   |   MethodTable  |        ------------------        ------------------</span></td>
      </tr>
      <tr>
        <td id="L1488" data-line-number="1488"></td>
        <td id="LC1488">    <span><span>//</span>   |                |        |      M3()      |</span></td>
      </tr>
      <tr>
        <td id="L1489" data-line-number="1489"></td>
        <td id="LC1489">    <span><span>//</span>   ------------------        ------------------</span></td>
      </tr>
      <tr>
        <td id="L1490" data-line-number="1490"></td>
        <td id="LC1490">    <span><span>//</span>   | ptr to chunk 1 |</span></td>
      </tr>
      <tr>
        <td id="L1491" data-line-number="1491"></td>
        <td id="LC1491">    <span><span>//</span>   ------------------</span></td>
      </tr>
      <tr>
        <td id="L1492" data-line-number="1492"></td>
        <td id="LC1492">    <span><span>//</span>   | ptr to chunk 2 |</span></td>
      </tr>
      <tr>
        <td id="L1493" data-line-number="1493"></td>
        <td id="LC1493">    <span><span>//</span>   ------------------</span></td>
      </tr>
      <tr>
        <td id="L1494" data-line-number="1494"></td>
        <td id="LC1494">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1495" data-line-number="1495"></td>
        <td id="LC1495">    <span><span>//</span> We refer to "ptr to chunk 1" and "ptr to chunk 2" as "indirection slots."</span></td>
      </tr>
      <tr>
        <td id="L1496" data-line-number="1496"></td>
        <td id="LC1496">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1497" data-line-number="1497"></td>
        <td id="LC1497">    <span><span>//</span> The current chunking strategy is independent of class properties; all are of size 8.  Several</span></td>
      </tr>
      <tr>
        <td id="L1498" data-line-number="1498"></td>
        <td id="LC1498">    <span><span>//</span> other strategies were tried, and the only one that has performed better empirically is to begin</span></td>
      </tr>
      <tr>
        <td id="L1499" data-line-number="1499"></td>
        <td id="LC1499">    <span><span>//</span> with a single chunk of size 4 (matching the number of virtuals in System.Object) and then</span></td>
      </tr>
      <tr>
        <td id="L1500" data-line-number="1500"></td>
        <td id="LC1500">    <span><span>//</span> continue with chunks of size 8.  However it was a small improvement and required the run-time</span></td>
      </tr>
      <tr>
        <td id="L1501" data-line-number="1501"></td>
        <td id="LC1501">    <span><span>//</span> helpers listed below to be measurably slower.</span></td>
      </tr>
      <tr>
        <td id="L1502" data-line-number="1502"></td>
        <td id="LC1502">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1503" data-line-number="1503"></td>
        <td id="LC1503">    <span><span>//</span> If you want to change this, you should only need to modify the first four functions below</span></td>
      </tr>
      <tr>
        <td id="L1504" data-line-number="1504"></td>
        <td id="LC1504">    <span><span>//</span> along with any assembly helper that has taken a dependency on the layout.  Currently,</span></td>
      </tr>
      <tr>
        <td id="L1505" data-line-number="1505"></td>
        <td id="LC1505">    <span><span>//</span> those consist of:</span></td>
      </tr>
      <tr>
        <td id="L1506" data-line-number="1506"></td>
        <td id="LC1506">    <span><span>//</span>     JIT_IsInstanceOfInterface</span></td>
      </tr>
      <tr>
        <td id="L1507" data-line-number="1507"></td>
        <td id="LC1507">    <span><span>//</span>     JIT_ChkCastInterface</span></td>
      </tr>
      <tr>
        <td id="L1508" data-line-number="1508"></td>
        <td id="LC1508">    <span><span>//</span>     Transparent proxy stub</span></td>
      </tr>
      <tr>
        <td id="L1509" data-line-number="1509"></td>
        <td id="LC1509">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1510" data-line-number="1510"></td>
        <td id="LC1510">    <span><span>//</span> This layout only applies to the virtual methods in a class (those with slot number below GetNumVirtuals).</span></td>
      </tr>
      <tr>
        <td id="L1511" data-line-number="1511"></td>
        <td id="LC1511">    <span><span>//</span> Non-virtual methods that are in the vtable (those with slot numbers between GetNumVirtuals and</span></td>
      </tr>
      <tr>
        <td id="L1512" data-line-number="1512"></td>
        <td id="LC1512">    <span><span>//</span> GetNumVtableSlots) are laid out in a single chunk pointed to by an optional member.</span></td>
      </tr>
      <tr>
        <td id="L1513" data-line-number="1513"></td>
        <td id="LC1513">    <span><span>//</span> See GetSlotPtrRaw for more details.</span></td>
      </tr>
      <tr>
        <td id="L1514" data-line-number="1514"></td>
        <td id="LC1514">
</td>
      </tr>
      <tr>
        <td id="L1515" data-line-number="1515"></td>
        <td id="LC1515">    #<span>define</span> <span>VTABLE_SLOTS_PER_CHUNK</span> <span>8</span></td>
      </tr>
      <tr>
        <td id="L1516" data-line-number="1516"></td>
        <td id="LC1516">    #<span>define</span> <span>VTABLE_SLOTS_PER_CHUNK_LOG2</span> <span>3</span></td>
      </tr>
      <tr>
        <td id="L1517" data-line-number="1517"></td>
        <td id="LC1517">
</td>
      </tr>
      <tr>
        <td id="L1518" data-line-number="1518"></td>
        <td id="LC1518">#<span>if</span> defined(FEATURE_NGEN_RELOCS_OPTIMIZATIONS)</td>
      </tr>
      <tr>
        <td id="L1519" data-line-number="1519"></td>
        <td id="LC1519">    <span>typedef</span> RelativePointer&lt;PCODE&gt; VTableIndir2_t;</td>
      </tr>
      <tr>
        <td id="L1520" data-line-number="1520"></td>
        <td id="LC1520">    <span>typedef</span> RelativePointer&lt;<span>DPTR</span>(VTableIndir2_t)&gt; VTableIndir_t;</td>
      </tr>
      <tr>
        <td id="L1521" data-line-number="1521"></td>
        <td id="LC1521">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L1522" data-line-number="1522"></td>
        <td id="LC1522">    <span>typedef</span> PlainPointer&lt;PCODE&gt; VTableIndir2_t;</td>
      </tr>
      <tr>
        <td id="L1523" data-line-number="1523"></td>
        <td id="LC1523">    <span>typedef</span> PlainPointer&lt;<span>DPTR</span>(VTableIndir2_t)&gt; VTableIndir_t;</td>
      </tr>
      <tr>
        <td id="L1524" data-line-number="1524"></td>
        <td id="LC1524">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1525" data-line-number="1525"></td>
        <td id="LC1525">
</td>
      </tr>
      <tr>
        <td id="L1526" data-line-number="1526"></td>
        <td id="LC1526">    <span>static</span> DWORD <span>GetIndexOfVtableIndirection</span>(DWORD slotNum);</td>
      </tr>
      <tr>
        <td id="L1527" data-line-number="1527"></td>
        <td id="LC1527">    <span>static</span> DWORD <span>GetStartSlotForVtableIndirection</span>(UINT32 indirectionIndex, DWORD wNumVirtuals);</td>
      </tr>
      <tr>
        <td id="L1528" data-line-number="1528"></td>
        <td id="LC1528">    <span>static</span> DWORD <span>GetEndSlotForVtableIndirection</span>(UINT32 indirectionIndex, DWORD wNumVirtuals);</td>
      </tr>
      <tr>
        <td id="L1529" data-line-number="1529"></td>
        <td id="LC1529">    <span>static</span> UINT32 <span>GetIndexAfterVtableIndirection</span>(UINT32 slotNum);</td>
      </tr>
      <tr>
        <td id="L1530" data-line-number="1530"></td>
        <td id="LC1530">    <span>static</span> DWORD <span>GetNumVtableIndirections</span>(DWORD wNumVirtuals);</td>
      </tr>
      <tr>
        <td id="L1531" data-line-number="1531"></td>
        <td id="LC1531">    <span>DPTR</span>(VTableIndir_t) <span>GetVtableIndirections</span>();</td>
      </tr>
      <tr>
        <td id="L1532" data-line-number="1532"></td>
        <td id="LC1532">    DWORD <span>GetNumVtableIndirections</span>();</td>
      </tr>
      <tr>
        <td id="L1533" data-line-number="1533"></td>
        <td id="LC1533">
</td>
      </tr>
      <tr>
        <td id="L1534" data-line-number="1534"></td>
        <td id="LC1534">    class VtableIndirectionSlotIterator</td>
      </tr>
      <tr>
        <td id="L1535" data-line-number="1535"></td>
        <td id="LC1535">    {</td>
      </tr>
      <tr>
        <td id="L1536" data-line-number="1536"></td>
        <td id="LC1536">        friend class MethodTable;</td>
      </tr>
      <tr>
        <td id="L1537" data-line-number="1537"></td>
        <td id="LC1537">
</td>
      </tr>
      <tr>
        <td id="L1538" data-line-number="1538"></td>
        <td id="LC1538">    private:</td>
      </tr>
      <tr>
        <td id="L1539" data-line-number="1539"></td>
        <td id="LC1539">        <span>DPTR</span>(VTableIndir_t) m_pSlot;</td>
      </tr>
      <tr>
        <td id="L1540" data-line-number="1540"></td>
        <td id="LC1540">        DWORD m_i;</td>
      </tr>
      <tr>
        <td id="L1541" data-line-number="1541"></td>
        <td id="LC1541">        DWORD m_count;</td>
      </tr>
      <tr>
        <td id="L1542" data-line-number="1542"></td>
        <td id="LC1542">        PTR_MethodTable m_pMT;</td>
      </tr>
      <tr>
        <td id="L1543" data-line-number="1543"></td>
        <td id="LC1543">
</td>
      </tr>
      <tr>
        <td id="L1544" data-line-number="1544"></td>
        <td id="LC1544">        <span>VtableIndirectionSlotIterator</span>(MethodTable *pMT);</td>
      </tr>
      <tr>
        <td id="L1545" data-line-number="1545"></td>
        <td id="LC1545">        <span>VtableIndirectionSlotIterator</span>(MethodTable *pMT, DWORD <span>index</span>);</td>
      </tr>
      <tr>
        <td id="L1546" data-line-number="1546"></td>
        <td id="LC1546">
</td>
      </tr>
      <tr>
        <td id="L1547" data-line-number="1547"></td>
        <td id="LC1547">    public:</td>
      </tr>
      <tr>
        <td id="L1548" data-line-number="1548"></td>
        <td id="LC1548">        BOOL <span>Next</span>();</td>
      </tr>
      <tr>
        <td id="L1549" data-line-number="1549"></td>
        <td id="LC1549">        BOOL <span>Finished</span>();</td>
      </tr>
      <tr>
        <td id="L1550" data-line-number="1550"></td>
        <td id="LC1550">        DWORD <span>GetIndex</span>();</td>
      </tr>
      <tr>
        <td id="L1551" data-line-number="1551"></td>
        <td id="LC1551">        DWORD <span>GetOffsetFromMethodTable</span>();</td>
      </tr>
      <tr>
        <td id="L1552" data-line-number="1552"></td>
        <td id="LC1552">        <span>DPTR</span>(VTableIndir2_t) <span>GetIndirectionSlot</span>();</td>
      </tr>
      <tr>
        <td id="L1553" data-line-number="1553"></td>
        <td id="LC1553">
</td>
      </tr>
      <tr>
        <td id="L1554" data-line-number="1554"></td>
        <td id="LC1554">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L1555" data-line-number="1555"></td>
        <td id="LC1555">        <span>void</span> <span>SetIndirectionSlot</span>(<span>DPTR</span>(VTableIndir2_t) pChunk);</td>
      </tr>
      <tr>
        <td id="L1556" data-line-number="1556"></td>
        <td id="LC1556">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1557" data-line-number="1557"></td>
        <td id="LC1557">
</td>
      </tr>
      <tr>
        <td id="L1558" data-line-number="1558"></td>
        <td id="LC1558">        DWORD <span>GetStartSlot</span>();</td>
      </tr>
      <tr>
        <td id="L1559" data-line-number="1559"></td>
        <td id="LC1559">        DWORD <span>GetEndSlot</span>();</td>
      </tr>
      <tr>
        <td id="L1560" data-line-number="1560"></td>
        <td id="LC1560">        DWORD <span>GetNumSlots</span>();</td>
      </tr>
      <tr>
        <td id="L1561" data-line-number="1561"></td>
        <td id="LC1561">        DWORD <span>GetSize</span>();</td>
      </tr>
      <tr>
        <td id="L1562" data-line-number="1562"></td>
        <td id="LC1562">    };  <span><span>//</span> class VtableIndirectionSlotIterator</span></td>
      </tr>
      <tr>
        <td id="L1563" data-line-number="1563"></td>
        <td id="LC1563">
</td>
      </tr>
      <tr>
        <td id="L1564" data-line-number="1564"></td>
        <td id="LC1564">    VtableIndirectionSlotIterator <span>IterateVtableIndirectionSlots</span>();</td>
      </tr>
      <tr>
        <td id="L1565" data-line-number="1565"></td>
        <td id="LC1565">    VtableIndirectionSlotIterator <span>IterateVtableIndirectionSlotsFrom</span>(DWORD <span>index</span>);</td>
      </tr>
      <tr>
        <td id="L1566" data-line-number="1566"></td>
        <td id="LC1566">
</td>
      </tr>
      <tr>
        <td id="L1567" data-line-number="1567"></td>
        <td id="LC1567">#<span>ifdef</span> FEATURE_PREJIT</td>
      </tr>
      <tr>
        <td id="L1568" data-line-number="1568"></td>
        <td id="LC1568">    <span>static</span> BOOL <span>CanShareVtableChunksFrom</span>(MethodTable *pTargetMT, Module *pCurrentLoaderModule, Module *pCurrentPreferredZapModule);</td>
      </tr>
      <tr>
        <td id="L1569" data-line-number="1569"></td>
        <td id="LC1569">    BOOL <span>CanInternVtableChunk</span>(DataImage *image, VtableIndirectionSlotIterator it);</td>
      </tr>
      <tr>
        <td id="L1570" data-line-number="1570"></td>
        <td id="LC1570">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L1571" data-line-number="1571"></td>
        <td id="LC1571">    <span>static</span> BOOL <span>CanShareVtableChunksFrom</span>(MethodTable *pTargetMT, Module *pCurrentLoaderModule);</td>
      </tr>
      <tr>
        <td id="L1572" data-line-number="1572"></td>
        <td id="LC1572">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1573" data-line-number="1573"></td>
        <td id="LC1573">
</td>
      </tr>
      <tr>
        <td id="L1574" data-line-number="1574"></td>
        <td id="LC1574">    <span>inline</span> BOOL <span>HasNonVirtualSlots</span>()</td>
      </tr>
      <tr>
        <td id="L1575" data-line-number="1575"></td>
        <td id="LC1575">    {</td>
      </tr>
      <tr>
        <td id="L1576" data-line-number="1576"></td>
        <td id="LC1576">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1577" data-line-number="1577"></td>
        <td id="LC1577">        <span>return</span> <span>GetFlag</span>(enum_flag_HasNonVirtualSlots);</td>
      </tr>
      <tr>
        <td id="L1578" data-line-number="1578"></td>
        <td id="LC1578">    }</td>
      </tr>
      <tr>
        <td id="L1579" data-line-number="1579"></td>
        <td id="LC1579">
</td>
      </tr>
      <tr>
        <td id="L1580" data-line-number="1580"></td>
        <td id="LC1580">    <span>inline</span> BOOL <span>HasSingleNonVirtualSlot</span>()</td>
      </tr>
      <tr>
        <td id="L1581" data-line-number="1581"></td>
        <td id="LC1581">    {</td>
      </tr>
      <tr>
        <td id="L1582" data-line-number="1582"></td>
        <td id="LC1582">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1583" data-line-number="1583"></td>
        <td id="LC1583">        <span>return</span> <span>GetFlag</span>(enum_flag_HasSingleNonVirtualSlot);</td>
      </tr>
      <tr>
        <td id="L1584" data-line-number="1584"></td>
        <td id="LC1584">    }</td>
      </tr>
      <tr>
        <td id="L1585" data-line-number="1585"></td>
        <td id="LC1585">
</td>
      </tr>
      <tr>
        <td id="L1586" data-line-number="1586"></td>
        <td id="LC1586">    <span>inline</span> BOOL <span>HasNonVirtualSlotsArray</span>()</td>
      </tr>
      <tr>
        <td id="L1587" data-line-number="1587"></td>
        <td id="LC1587">    {</td>
      </tr>
      <tr>
        <td id="L1588" data-line-number="1588"></td>
        <td id="LC1588">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1589" data-line-number="1589"></td>
        <td id="LC1589">        <span>return</span> <span>HasNonVirtualSlots</span>() &amp;&amp; !<span>HasSingleNonVirtualSlot</span>();</td>
      </tr>
      <tr>
        <td id="L1590" data-line-number="1590"></td>
        <td id="LC1590">    }</td>
      </tr>
      <tr>
        <td id="L1591" data-line-number="1591"></td>
        <td id="LC1591">
</td>
      </tr>
      <tr>
        <td id="L1592" data-line-number="1592"></td>
        <td id="LC1592">    TADDR <span>GetNonVirtualSlotsPtr</span>();</td>
      </tr>
      <tr>
        <td id="L1593" data-line-number="1593"></td>
        <td id="LC1593">
</td>
      </tr>
      <tr>
        <td id="L1594" data-line-number="1594"></td>
        <td id="LC1594">    <span>inline</span> PTR_PCODE <span>GetNonVirtualSlotsArray</span>()</td>
      </tr>
      <tr>
        <td id="L1595" data-line-number="1595"></td>
        <td id="LC1595">    {</td>
      </tr>
      <tr>
        <td id="L1596" data-line-number="1596"></td>
        <td id="LC1596">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1597" data-line-number="1597"></td>
        <td id="LC1597">        <span>_ASSERTE</span>(<span>HasNonVirtualSlotsArray</span>());</td>
      </tr>
      <tr>
        <td id="L1598" data-line-number="1598"></td>
        <td id="LC1598">        <span>return</span> RelativePointer&lt;PTR_PCODE&gt;::<span>GetValueAtPtr</span>(<span>GetNonVirtualSlotsPtr</span>());</td>
      </tr>
      <tr>
        <td id="L1599" data-line-number="1599"></td>
        <td id="LC1599">    }</td>
      </tr>
      <tr>
        <td id="L1600" data-line-number="1600"></td>
        <td id="LC1600">
</td>
      </tr>
      <tr>
        <td id="L1601" data-line-number="1601"></td>
        <td id="LC1601">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L1602" data-line-number="1602"></td>
        <td id="LC1602">    <span>inline</span> <span>void</span> <span>SetNonVirtualSlotsArray</span>(PCODE *slots)</td>
      </tr>
      <tr>
        <td id="L1603" data-line-number="1603"></td>
        <td id="LC1603">    {</td>
      </tr>
      <tr>
        <td id="L1604" data-line-number="1604"></td>
        <td id="LC1604">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1605" data-line-number="1605"></td>
        <td id="LC1605">        <span>_ASSERTE</span>(<span>HasNonVirtualSlotsArray</span>());</td>
      </tr>
      <tr>
        <td id="L1606" data-line-number="1606"></td>
        <td id="LC1606">
</td>
      </tr>
      <tr>
        <td id="L1607" data-line-number="1607"></td>
        <td id="LC1607">        RelativePointer&lt;PCODE *&gt; *pRelPtr = (RelativePointer&lt;PCODE *&gt; *)<span>GetNonVirtualSlotsPtr</span>();</td>
      </tr>
      <tr>
        <td id="L1608" data-line-number="1608"></td>
        <td id="LC1608">        pRelPtr-&gt;<span>SetValue</span>(slots);</td>
      </tr>
      <tr>
        <td id="L1609" data-line-number="1609"></td>
        <td id="LC1609">    }</td>
      </tr>
      <tr>
        <td id="L1610" data-line-number="1610"></td>
        <td id="LC1610">
</td>
      </tr>
      <tr>
        <td id="L1611" data-line-number="1611"></td>
        <td id="LC1611">    <span>inline</span> <span>void</span> <span>SetHasSingleNonVirtualSlot</span>()</td>
      </tr>
      <tr>
        <td id="L1612" data-line-number="1612"></td>
        <td id="LC1612">    {</td>
      </tr>
      <tr>
        <td id="L1613" data-line-number="1613"></td>
        <td id="LC1613">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1614" data-line-number="1614"></td>
        <td id="LC1614">        <span>SetFlag</span>(enum_flag_HasSingleNonVirtualSlot);</td>
      </tr>
      <tr>
        <td id="L1615" data-line-number="1615"></td>
        <td id="LC1615">    }</td>
      </tr>
      <tr>
        <td id="L1616" data-line-number="1616"></td>
        <td id="LC1616">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1617" data-line-number="1617"></td>
        <td id="LC1617">
</td>
      </tr>
      <tr>
        <td id="L1618" data-line-number="1618"></td>
        <td id="LC1618">    <span>inline</span> <span>unsigned</span> <span>GetNonVirtualSlotsArraySize</span>()</td>
      </tr>
      <tr>
        <td id="L1619" data-line-number="1619"></td>
        <td id="LC1619">    {</td>
      </tr>
      <tr>
        <td id="L1620" data-line-number="1620"></td>
        <td id="LC1620">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1621" data-line-number="1621"></td>
        <td id="LC1621">        <span>return</span> <span>GetNumNonVirtualSlots</span>() * <span>sizeof</span>(PCODE);</td>
      </tr>
      <tr>
        <td id="L1622" data-line-number="1622"></td>
        <td id="LC1622">    }</td>
      </tr>
      <tr>
        <td id="L1623" data-line-number="1623"></td>
        <td id="LC1623">
</td>
      </tr>
      <tr>
        <td id="L1624" data-line-number="1624"></td>
        <td id="LC1624">    <span>inline</span> WORD <span>GetNumNonVirtualSlots</span>();</td>
      </tr>
      <tr>
        <td id="L1625" data-line-number="1625"></td>
        <td id="LC1625">
</td>
      </tr>
      <tr>
        <td id="L1626" data-line-number="1626"></td>
        <td id="LC1626">    <span>inline</span> WORD <span>GetNumVirtuals</span>()</td>
      </tr>
      <tr>
        <td id="L1627" data-line-number="1627"></td>
        <td id="LC1627">    {</td>
      </tr>
      <tr>
        <td id="L1628" data-line-number="1628"></td>
        <td id="LC1628">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1629" data-line-number="1629"></td>
        <td id="LC1629">
</td>
      </tr>
      <tr>
        <td id="L1630" data-line-number="1630"></td>
        <td id="LC1630">        g_IBCLogger.<span>LogMethodTableAccess</span>(this);</td>
      </tr>
      <tr>
        <td id="L1631" data-line-number="1631"></td>
        <td id="LC1631">        <span>return</span> <span>GetNumVirtuals_NoLogging</span>();</td>
      </tr>
      <tr>
        <td id="L1632" data-line-number="1632"></td>
        <td id="LC1632">    }</td>
      </tr>
      <tr>
        <td id="L1633" data-line-number="1633"></td>
        <td id="LC1633">
</td>
      </tr>
      <tr>
        <td id="L1634" data-line-number="1634"></td>
        <td id="LC1634">    <span>inline</span> WORD <span>GetNumVirtuals_NoLogging</span>()</td>
      </tr>
      <tr>
        <td id="L1635" data-line-number="1635"></td>
        <td id="LC1635">    {</td>
      </tr>
      <tr>
        <td id="L1636" data-line-number="1636"></td>
        <td id="LC1636">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1637" data-line-number="1637"></td>
        <td id="LC1637">
</td>
      </tr>
      <tr>
        <td id="L1638" data-line-number="1638"></td>
        <td id="LC1638">        <span>return</span> m_wNumVirtuals;</td>
      </tr>
      <tr>
        <td id="L1639" data-line-number="1639"></td>
        <td id="LC1639">    }</td>
      </tr>
      <tr>
        <td id="L1640" data-line-number="1640"></td>
        <td id="LC1640">
</td>
      </tr>
      <tr>
        <td id="L1641" data-line-number="1641"></td>
        <td id="LC1641">    <span>inline</span> <span>void</span> <span>SetNumVirtuals</span> (WORD wNumVtableSlots)</td>
      </tr>
      <tr>
        <td id="L1642" data-line-number="1642"></td>
        <td id="LC1642">    {</td>
      </tr>
      <tr>
        <td id="L1643" data-line-number="1643"></td>
        <td id="LC1643">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1644" data-line-number="1644"></td>
        <td id="LC1644">        m_wNumVirtuals = wNumVtableSlots;</td>
      </tr>
      <tr>
        <td id="L1645" data-line-number="1645"></td>
        <td id="LC1645">    }</td>
      </tr>
      <tr>
        <td id="L1646" data-line-number="1646"></td>
        <td id="LC1646">
</td>
      </tr>
      <tr>
        <td id="L1647" data-line-number="1647"></td>
        <td id="LC1647">    <span>unsigned</span> <span>GetNumParentVirtuals</span>()</td>
      </tr>
      <tr>
        <td id="L1648" data-line-number="1648"></td>
        <td id="LC1648">    {</td>
      </tr>
      <tr>
        <td id="L1649" data-line-number="1649"></td>
        <td id="LC1649">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1650" data-line-number="1650"></td>
        <td id="LC1650">        <span>if</span> (<span>IsInterface</span>()) {</td>
      </tr>
      <tr>
        <td id="L1651" data-line-number="1651"></td>
        <td id="LC1651">            <span>return</span> <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1652" data-line-number="1652"></td>
        <td id="LC1652">        }</td>
      </tr>
      <tr>
        <td id="L1653" data-line-number="1653"></td>
        <td id="LC1653">        MethodTable *pMTParent = <span>GetParentMethodTable</span>();</td>
      </tr>
      <tr>
        <td id="L1654" data-line-number="1654"></td>
        <td id="LC1654">        g_IBCLogger.<span>LogMethodTableAccess</span>(this);</td>
      </tr>
      <tr>
        <td id="L1655" data-line-number="1655"></td>
        <td id="LC1655">        <span>return</span> pMTParent == <span>NULL</span> ? <span>0</span> : pMTParent-&gt;<span>GetNumVirtuals</span>();</td>
      </tr>
      <tr>
        <td id="L1656" data-line-number="1656"></td>
        <td id="LC1656">    }</td>
      </tr>
      <tr>
        <td id="L1657" data-line-number="1657"></td>
        <td id="LC1657">
</td>
      </tr>
      <tr>
        <td id="L1658" data-line-number="1658"></td>
        <td id="LC1658">    #<span>define</span> <span>SIZEOF__MethodTable_</span> (<span>0x10</span> + (<span>6</span> <span>INDEBUG</span>(+<span>1</span>)) * TARGET_POINTER_SIZE)</td>
      </tr>
      <tr>
        <td id="L1659" data-line-number="1659"></td>
        <td id="LC1659">
</td>
      </tr>
      <tr>
        <td id="L1660" data-line-number="1660"></td>
        <td id="LC1660">    static inline DWORD GetVtableOffset()</td>
      </tr>
      <tr>
        <td id="L1661" data-line-number="1661"></td>
        <td id="LC1661">    {</td>
      </tr>
      <tr>
        <td id="L1662" data-line-number="1662"></td>
        <td id="LC1662">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1663" data-line-number="1663"></td>
        <td id="LC1663">
</td>
      </tr>
      <tr>
        <td id="L1664" data-line-number="1664"></td>
        <td id="LC1664">        <span>return</span> SIZEOF__MethodTable_;</td>
      </tr>
      <tr>
        <td id="L1665" data-line-number="1665"></td>
        <td id="LC1665">    }</td>
      </tr>
      <tr>
        <td id="L1666" data-line-number="1666"></td>
        <td id="LC1666">
</td>
      </tr>
      <tr>
        <td id="L1667" data-line-number="1667"></td>
        <td id="LC1667">    <span><span>//</span> Return total methods: virtual, static, and instance method slots.</span></td>
      </tr>
      <tr>
        <td id="L1668" data-line-number="1668"></td>
        <td id="LC1668">    WORD <span>GetNumMethods</span>();</td>
      </tr>
      <tr>
        <td id="L1669" data-line-number="1669"></td>
        <td id="LC1669">
</td>
      </tr>
      <tr>
        <td id="L1670" data-line-number="1670"></td>
        <td id="LC1670">    <span><span>//</span> Return number of slots in this methodtable. This is just an information about the layout of the methodtable, it should not be used</span></td>
      </tr>
      <tr>
        <td id="L1671" data-line-number="1671"></td>
        <td id="LC1671">    <span><span>//</span> for functionality checks. Do not confuse with GetNumVirtuals()!</span></td>
      </tr>
      <tr>
        <td id="L1672" data-line-number="1672"></td>
        <td id="LC1672">    WORD <span>GetNumVtableSlots</span>()</td>
      </tr>
      <tr>
        <td id="L1673" data-line-number="1673"></td>
        <td id="LC1673">    {</td>
      </tr>
      <tr>
        <td id="L1674" data-line-number="1674"></td>
        <td id="LC1674">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1675" data-line-number="1675"></td>
        <td id="LC1675">        <span>return</span> <span>GetNumVirtuals</span>() + <span>GetNumNonVirtualSlots</span>();</td>
      </tr>
      <tr>
        <td id="L1676" data-line-number="1676"></td>
        <td id="LC1676">    }</td>
      </tr>
      <tr>
        <td id="L1677" data-line-number="1677"></td>
        <td id="LC1677">
</td>
      </tr>
      <tr>
        <td id="L1678" data-line-number="1678"></td>
        <td id="LC1678">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1679" data-line-number="1679"></td>
        <td id="LC1679">    <span><span>//</span> Slots &lt;-&gt; the MethodDesc associated with the slot.</span></td>
      </tr>
      <tr>
        <td id="L1680" data-line-number="1680"></td>
        <td id="LC1680">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1681" data-line-number="1681"></td>
        <td id="LC1681">
</td>
      </tr>
      <tr>
        <td id="L1682" data-line-number="1682"></td>
        <td id="LC1682">    MethodDesc* <span>GetMethodDescForSlot</span>(DWORD slot);</td>
      </tr>
      <tr>
        <td id="L1683" data-line-number="1683"></td>
        <td id="LC1683">
</td>
      </tr>
      <tr>
        <td id="L1684" data-line-number="1684"></td>
        <td id="LC1684">    <span>static</span> MethodDesc*  <span>GetMethodDescForSlotAddress</span>(PCODE addr, BOOL fSpeculative = <span>FALSE</span>);</td>
      </tr>
      <tr>
        <td id="L1685" data-line-number="1685"></td>
        <td id="LC1685">
</td>
      </tr>
      <tr>
        <td id="L1686" data-line-number="1686"></td>
        <td id="LC1686">    PCODE <span>GetRestoredSlot</span>(DWORD slot);</td>
      </tr>
      <tr>
        <td id="L1687" data-line-number="1687"></td>
        <td id="LC1687">
</td>
      </tr>
      <tr>
        <td id="L1688" data-line-number="1688"></td>
        <td id="LC1688">    <span><span>//</span> Returns MethodTable that GetRestoredSlot get its values from</span></td>
      </tr>
      <tr>
        <td id="L1689" data-line-number="1689"></td>
        <td id="LC1689">    MethodTable * <span>GetRestoredSlotMT</span>(DWORD slot);</td>
      </tr>
      <tr>
        <td id="L1690" data-line-number="1690"></td>
        <td id="LC1690">
</td>
      </tr>
      <tr>
        <td id="L1691" data-line-number="1691"></td>
        <td id="LC1691">    <span><span>//</span> Used to map methods on the same slot between instantiations.</span></td>
      </tr>
      <tr>
        <td id="L1692" data-line-number="1692"></td>
        <td id="LC1692">    MethodDesc * <span>GetParallelMethodDesc</span>(MethodDesc * pDefMD);</td>
      </tr>
      <tr>
        <td id="L1693" data-line-number="1693"></td>
        <td id="LC1693">
</td>
      </tr>
      <tr>
        <td id="L1694" data-line-number="1694"></td>
        <td id="LC1694">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1695" data-line-number="1695"></td>
        <td id="LC1695">    <span><span>//</span> BoxedEntryPoint MethodDescs.</span></td>
      </tr>
      <tr>
        <td id="L1696" data-line-number="1696"></td>
        <td id="LC1696">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1697" data-line-number="1697"></td>
        <td id="LC1697">    <span><span>//</span> Virtual methods on structs have BoxedEntryPoint method descs in their vtable.</span></td>
      </tr>
      <tr>
        <td id="L1698" data-line-number="1698"></td>
        <td id="LC1698">    <span><span>//</span> See also notes for MethodDesc::FindOrCreateAssociatedMethodDesc.  You should</span></td>
      </tr>
      <tr>
        <td id="L1699" data-line-number="1699"></td>
        <td id="LC1699">    <span><span>//</span> probably be using that function if you need to map between unboxing</span></td>
      </tr>
      <tr>
        <td id="L1700" data-line-number="1700"></td>
        <td id="LC1700">    <span><span>//</span> stubs and non-unboxing stubs.</span></td>
      </tr>
      <tr>
        <td id="L1701" data-line-number="1701"></td>
        <td id="LC1701">
</td>
      </tr>
      <tr>
        <td id="L1702" data-line-number="1702"></td>
        <td id="LC1702">    MethodDesc* <span>GetBoxedEntryPointMD</span>(MethodDesc *pMD);</td>
      </tr>
      <tr>
        <td id="L1703" data-line-number="1703"></td>
        <td id="LC1703">
</td>
      </tr>
      <tr>
        <td id="L1704" data-line-number="1704"></td>
        <td id="LC1704">    MethodDesc* <span>GetUnboxedEntryPointMD</span>(MethodDesc *pMD);</td>
      </tr>
      <tr>
        <td id="L1705" data-line-number="1705"></td>
        <td id="LC1705">    MethodDesc* <span>GetExistingUnboxedEntryPointMD</span>(MethodDesc *pMD);</td>
      </tr>
      <tr>
        <td id="L1706" data-line-number="1706"></td>
        <td id="LC1706">
</td>
      </tr>
      <tr>
        <td id="L1707" data-line-number="1707"></td>
        <td id="LC1707">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1708" data-line-number="1708"></td>
        <td id="LC1708">    <span><span>//</span> FIELD LAYOUT, OBJECT SIZE ETC.</span></td>
      </tr>
      <tr>
        <td id="L1709" data-line-number="1709"></td>
        <td id="LC1709">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1710" data-line-number="1710"></td>
        <td id="LC1710">
</td>
      </tr>
      <tr>
        <td id="L1711" data-line-number="1711"></td>
        <td id="LC1711">    <span>inline</span> BOOL <span>HasLayout</span>();</td>
      </tr>
      <tr>
        <td id="L1712" data-line-number="1712"></td>
        <td id="LC1712">
</td>
      </tr>
      <tr>
        <td id="L1713" data-line-number="1713"></td>
        <td id="LC1713">    <span>inline</span> EEClassLayoutInfo *<span>GetLayoutInfo</span>();</td>
      </tr>
      <tr>
        <td id="L1714" data-line-number="1714"></td>
        <td id="LC1714">
</td>
      </tr>
      <tr>
        <td id="L1715" data-line-number="1715"></td>
        <td id="LC1715">    <span>inline</span> BOOL <span>IsBlittable</span>();</td>
      </tr>
      <tr>
        <td id="L1716" data-line-number="1716"></td>
        <td id="LC1716">
</td>
      </tr>
      <tr>
        <td id="L1717" data-line-number="1717"></td>
        <td id="LC1717">    <span>inline</span> BOOL <span>IsManagedSequential</span>();</td>
      </tr>
      <tr>
        <td id="L1718" data-line-number="1718"></td>
        <td id="LC1718">
</td>
      </tr>
      <tr>
        <td id="L1719" data-line-number="1719"></td>
        <td id="LC1719">    <span>inline</span> BOOL <span>HasExplicitSize</span>();</td>
      </tr>
      <tr>
        <td id="L1720" data-line-number="1720"></td>
        <td id="LC1720">
</td>
      </tr>
      <tr>
        <td id="L1721" data-line-number="1721"></td>
        <td id="LC1721">    UINT32 <span>GetNativeSize</span>();</td>
      </tr>
      <tr>
        <td id="L1722" data-line-number="1722"></td>
        <td id="LC1722">
</td>
      </tr>
      <tr>
        <td id="L1723" data-line-number="1723"></td>
        <td id="LC1723">    DWORD           <span>GetBaseSize</span>()</td>
      </tr>
      <tr>
        <td id="L1724" data-line-number="1724"></td>
        <td id="LC1724">    {</td>
      </tr>
      <tr>
        <td id="L1725" data-line-number="1725"></td>
        <td id="LC1725">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1726" data-line-number="1726"></td>
        <td id="LC1726">        <span>return</span>(m_BaseSize);</td>
      </tr>
      <tr>
        <td id="L1727" data-line-number="1727"></td>
        <td id="LC1727">    }</td>
      </tr>
      <tr>
        <td id="L1728" data-line-number="1728"></td>
        <td id="LC1728">
</td>
      </tr>
      <tr>
        <td id="L1729" data-line-number="1729"></td>
        <td id="LC1729">    <span>void</span>            <span>SetBaseSize</span>(DWORD baseSize)</td>
      </tr>
      <tr>
        <td id="L1730" data-line-number="1730"></td>
        <td id="LC1730">    {</td>
      </tr>
      <tr>
        <td id="L1731" data-line-number="1731"></td>
        <td id="LC1731">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1732" data-line-number="1732"></td>
        <td id="LC1732">        m_BaseSize = baseSize;</td>
      </tr>
      <tr>
        <td id="L1733" data-line-number="1733"></td>
        <td id="LC1733">    }</td>
      </tr>
      <tr>
        <td id="L1734" data-line-number="1734"></td>
        <td id="LC1734">
</td>
      </tr>
      <tr>
        <td id="L1735" data-line-number="1735"></td>
        <td id="LC1735">    BOOL            <span>IsStringOrArray</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L1736" data-line-number="1736"></td>
        <td id="LC1736">    {</td>
      </tr>
      <tr>
        <td id="L1737" data-line-number="1737"></td>
        <td id="LC1737">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1738" data-line-number="1738"></td>
        <td id="LC1738">        <span>return</span> <span>HasComponentSize</span>();</td>
      </tr>
      <tr>
        <td id="L1739" data-line-number="1739"></td>
        <td id="LC1739">    }</td>
      </tr>
      <tr>
        <td id="L1740" data-line-number="1740"></td>
        <td id="LC1740">
</td>
      </tr>
      <tr>
        <td id="L1741" data-line-number="1741"></td>
        <td id="LC1741">    BOOL <span>IsString</span>()</td>
      </tr>
      <tr>
        <td id="L1742" data-line-number="1742"></td>
        <td id="LC1742">    {</td>
      </tr>
      <tr>
        <td id="L1743" data-line-number="1743"></td>
        <td id="LC1743">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1744" data-line-number="1744"></td>
        <td id="LC1744">        <span>return</span> <span>HasComponentSize</span>() &amp;&amp; !<span>IsArray</span>() &amp;&amp; <span>RawGetComponentSize</span>() == <span>2</span>;</td>
      </tr>
      <tr>
        <td id="L1745" data-line-number="1745"></td>
        <td id="LC1745">    }</td>
      </tr>
      <tr>
        <td id="L1746" data-line-number="1746"></td>
        <td id="LC1746">
</td>
      </tr>
      <tr>
        <td id="L1747" data-line-number="1747"></td>
        <td id="LC1747">    BOOL            <span>HasComponentSize</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L1748" data-line-number="1748"></td>
        <td id="LC1748">    {</td>
      </tr>
      <tr>
        <td id="L1749" data-line-number="1749"></td>
        <td id="LC1749">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1750" data-line-number="1750"></td>
        <td id="LC1750">        <span>return</span> <span>GetFlag</span>(enum_flag_HasComponentSize);</td>
      </tr>
      <tr>
        <td id="L1751" data-line-number="1751"></td>
        <td id="LC1751">    }</td>
      </tr>
      <tr>
        <td id="L1752" data-line-number="1752"></td>
        <td id="LC1752">
</td>
      </tr>
      <tr>
        <td id="L1753" data-line-number="1753"></td>
        <td id="LC1753">    <span><span>//</span> returns random combination of flags if this doesn't have a component size</span></td>
      </tr>
      <tr>
        <td id="L1754" data-line-number="1754"></td>
        <td id="LC1754">    WORD            <span>RawGetComponentSize</span>()</td>
      </tr>
      <tr>
        <td id="L1755" data-line-number="1755"></td>
        <td id="LC1755">    {</td>
      </tr>
      <tr>
        <td id="L1756" data-line-number="1756"></td>
        <td id="LC1756">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1757" data-line-number="1757"></td>
        <td id="LC1757">#<span>if</span> BIGENDIAN</td>
      </tr>
      <tr>
        <td id="L1758" data-line-number="1758"></td>
        <td id="LC1758">        <span>return</span> *((WORD*)&amp;m_dwFlags + <span>1</span>);</td>
      </tr>
      <tr>
        <td id="L1759" data-line-number="1759"></td>
        <td id="LC1759">#<span>else</span> <span><span>//</span> !BIGENDIAN</span></td>
      </tr>
      <tr>
        <td id="L1760" data-line-number="1760"></td>
        <td id="LC1760">        <span>return</span> *(WORD*)&amp;m_dwFlags;</td>
      </tr>
      <tr>
        <td id="L1761" data-line-number="1761"></td>
        <td id="LC1761">#<span>endif</span> <span><span>//</span> !BIGENDIAN</span></td>
      </tr>
      <tr>
        <td id="L1762" data-line-number="1762"></td>
        <td id="LC1762">    }</td>
      </tr>
      <tr>
        <td id="L1763" data-line-number="1763"></td>
        <td id="LC1763">
</td>
      </tr>
      <tr>
        <td id="L1764" data-line-number="1764"></td>
        <td id="LC1764">    <span><span>//</span> returns 0 if this doesn't have a component size</span></td>
      </tr>
      <tr>
        <td id="L1765" data-line-number="1765"></td>
        <td id="LC1765">
</td>
      </tr>
      <tr>
        <td id="L1766" data-line-number="1766"></td>
        <td id="LC1766">    <span><span>//</span> The component size is actually 16-bit WORD, but this method is returning SIZE_T to ensure</span></td>
      </tr>
      <tr>
        <td id="L1767" data-line-number="1767"></td>
        <td id="LC1767">    <span><span>//</span> that SIZE_T is used everywhere for object size computation. It is necessary to support</span></td>
      </tr>
      <tr>
        <td id="L1768" data-line-number="1768"></td>
        <td id="LC1768">    <span><span>//</span> objects bigger than 2GB.</span></td>
      </tr>
      <tr>
        <td id="L1769" data-line-number="1769"></td>
        <td id="LC1769">    SIZE_T          <span>GetComponentSize</span>()</td>
      </tr>
      <tr>
        <td id="L1770" data-line-number="1770"></td>
        <td id="LC1770">    {</td>
      </tr>
      <tr>
        <td id="L1771" data-line-number="1771"></td>
        <td id="LC1771">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1772" data-line-number="1772"></td>
        <td id="LC1772">        <span>return</span> <span>HasComponentSize</span>() ? <span>RawGetComponentSize</span>() : <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L1773" data-line-number="1773"></td>
        <td id="LC1773">    }</td>
      </tr>
      <tr>
        <td id="L1774" data-line-number="1774"></td>
        <td id="LC1774">
</td>
      </tr>
      <tr>
        <td id="L1775" data-line-number="1775"></td>
        <td id="LC1775">    <span>void</span> <span>SetComponentSize</span>(WORD wComponentSize)</td>
      </tr>
      <tr>
        <td id="L1776" data-line-number="1776"></td>
        <td id="LC1776">    {</td>
      </tr>
      <tr>
        <td id="L1777" data-line-number="1777"></td>
        <td id="LC1777">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1778" data-line-number="1778"></td>
        <td id="LC1778">        <span><span>//</span> it would be nice to assert here that this is either a string</span></td>
      </tr>
      <tr>
        <td id="L1779" data-line-number="1779"></td>
        <td id="LC1779">        <span><span>//</span> or an array, but how do we know.</span></td>
      </tr>
      <tr>
        <td id="L1780" data-line-number="1780"></td>
        <td id="LC1780">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1781" data-line-number="1781"></td>
        <td id="LC1781">        <span><span>//</span> it would also be nice to assert that the component size is &gt; 0,</span></td>
      </tr>
      <tr>
        <td id="L1782" data-line-number="1782"></td>
        <td id="LC1782">        <span><span>//</span> but that would not hold for array's of System.Void and generic type parameters</span></td>
      </tr>
      <tr>
        <td id="L1783" data-line-number="1783"></td>
        <td id="LC1783">        <span>SetFlag</span>(enum_flag_HasComponentSize);</td>
      </tr>
      <tr>
        <td id="L1784" data-line-number="1784"></td>
        <td id="LC1784">        m_dwFlags = (m_dwFlags &amp; ~<span>0xFFFF</span>) | wComponentSize;</td>
      </tr>
      <tr>
        <td id="L1785" data-line-number="1785"></td>
        <td id="LC1785">    }</td>
      </tr>
      <tr>
        <td id="L1786" data-line-number="1786"></td>
        <td id="LC1786">
</td>
      </tr>
      <tr>
        <td id="L1787" data-line-number="1787"></td>
        <td id="LC1787">    <span>inline</span> WORD <span>GetNumInstanceFields</span>();</td>
      </tr>
      <tr>
        <td id="L1788" data-line-number="1788"></td>
        <td id="LC1788">
</td>
      </tr>
      <tr>
        <td id="L1789" data-line-number="1789"></td>
        <td id="LC1789">    <span>inline</span> WORD <span>GetNumStaticFields</span>();</td>
      </tr>
      <tr>
        <td id="L1790" data-line-number="1790"></td>
        <td id="LC1790">
</td>
      </tr>
      <tr>
        <td id="L1791" data-line-number="1791"></td>
        <td id="LC1791">    <span>inline</span> WORD <span>GetNumThreadStaticFields</span>();</td>
      </tr>
      <tr>
        <td id="L1792" data-line-number="1792"></td>
        <td id="LC1792">
</td>
      </tr>
      <tr>
        <td id="L1793" data-line-number="1793"></td>
        <td id="LC1793">    <span><span>//</span> Note that for value types GetBaseSize returns the size of instance fields for</span></td>
      </tr>
      <tr>
        <td id="L1794" data-line-number="1794"></td>
        <td id="LC1794">    <span><span>//</span> a boxed value, and GetNumInstanceFieldsBytes for an unboxed value.</span></td>
      </tr>
      <tr>
        <td id="L1795" data-line-number="1795"></td>
        <td id="LC1795">    <span><span>//</span> We place methods like these on MethodTable primarily so we can choose to cache</span></td>
      </tr>
      <tr>
        <td id="L1796" data-line-number="1796"></td>
        <td id="LC1796">    <span><span>//</span> the information within MethodTable, and so less code manipulates EEClass</span></td>
      </tr>
      <tr>
        <td id="L1797" data-line-number="1797"></td>
        <td id="LC1797">    <span><span>//</span> objects directly, because doing so can lead to bugs related to generics.</span></td>
      </tr>
      <tr>
        <td id="L1798" data-line-number="1798"></td>
        <td id="LC1798">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1799" data-line-number="1799"></td>
        <td id="LC1799">    <span><span>//</span> &lt;TODO&gt; Use m_wBaseSize whenever this is identical to GetNumInstanceFieldBytes.</span></td>
      </tr>
      <tr>
        <td id="L1800" data-line-number="1800"></td>
        <td id="LC1800">    <span><span>//</span> We would need to reserve a flag for this. &lt;/TODO&gt;</span></td>
      </tr>
      <tr>
        <td id="L1801" data-line-number="1801"></td>
        <td id="LC1801">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1802" data-line-number="1802"></td>
        <td id="LC1802">    <span>inline</span> DWORD <span>GetNumInstanceFieldBytes</span>();</td>
      </tr>
      <tr>
        <td id="L1803" data-line-number="1803"></td>
        <td id="LC1803">
</td>
      </tr>
      <tr>
        <td id="L1804" data-line-number="1804"></td>
        <td id="LC1804">    <span>inline</span> WORD <span>GetNumIntroducedInstanceFields</span>();</td>
      </tr>
      <tr>
        <td id="L1805" data-line-number="1805"></td>
        <td id="LC1805">
</td>
      </tr>
      <tr>
        <td id="L1806" data-line-number="1806"></td>
        <td id="LC1806">    <span><span>//</span> &lt;TODO&gt; Does this always return the same (or related) size as GetBaseSize()? &lt;/TODO&gt;</span></td>
      </tr>
      <tr>
        <td id="L1807" data-line-number="1807"></td>
        <td id="LC1807">    <span>inline</span> DWORD <span>GetAlignedNumInstanceFieldBytes</span>();</td>
      </tr>
      <tr>
        <td id="L1808" data-line-number="1808"></td>
        <td id="LC1808">
</td>
      </tr>
      <tr>
        <td id="L1809" data-line-number="1809"></td>
        <td id="LC1809">
</td>
      </tr>
      <tr>
        <td id="L1810" data-line-number="1810"></td>
        <td id="LC1810">    <span><span>//</span> Note: This flag MUST be available even from an unrestored MethodTable - see GcScanRoots in siginfo.cpp.</span></td>
      </tr>
      <tr>
        <td id="L1811" data-line-number="1811"></td>
        <td id="LC1811">    DWORD           <span>ContainsPointers</span>()</td>
      </tr>
      <tr>
        <td id="L1812" data-line-number="1812"></td>
        <td id="LC1812">    {</td>
      </tr>
      <tr>
        <td id="L1813" data-line-number="1813"></td>
        <td id="LC1813">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1814" data-line-number="1814"></td>
        <td id="LC1814">        <span>return</span> <span>GetFlag</span>(enum_flag_ContainsPointers);</td>
      </tr>
      <tr>
        <td id="L1815" data-line-number="1815"></td>
        <td id="LC1815">    }</td>
      </tr>
      <tr>
        <td id="L1816" data-line-number="1816"></td>
        <td id="LC1816">    BOOL            <span>Collectible</span>()</td>
      </tr>
      <tr>
        <td id="L1817" data-line-number="1817"></td>
        <td id="LC1817">    {</td>
      </tr>
      <tr>
        <td id="L1818" data-line-number="1818"></td>
        <td id="LC1818">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1819" data-line-number="1819"></td>
        <td id="LC1819">#<span>ifdef</span> FEATURE_COLLECTIBLE_TYPES</td>
      </tr>
      <tr>
        <td id="L1820" data-line-number="1820"></td>
        <td id="LC1820">        <span>return</span> <span>GetFlag</span>(enum_flag_Collectible);</td>
      </tr>
      <tr>
        <td id="L1821" data-line-number="1821"></td>
        <td id="LC1821">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L1822" data-line-number="1822"></td>
        <td id="LC1822">        <span>return</span> <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L1823" data-line-number="1823"></td>
        <td id="LC1823">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1824" data-line-number="1824"></td>
        <td id="LC1824">    }</td>
      </tr>
      <tr>
        <td id="L1825" data-line-number="1825"></td>
        <td id="LC1825">    BOOL            <span>ContainsPointersOrCollectible</span>()</td>
      </tr>
      <tr>
        <td id="L1826" data-line-number="1826"></td>
        <td id="LC1826">    {</td>
      </tr>
      <tr>
        <td id="L1827" data-line-number="1827"></td>
        <td id="LC1827">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1828" data-line-number="1828"></td>
        <td id="LC1828">        <span>return</span> <span>GetFlag</span>(enum_flag_ContainsPointers) || <span>GetFlag</span>(enum_flag_Collectible);</td>
      </tr>
      <tr>
        <td id="L1829" data-line-number="1829"></td>
        <td id="LC1829">    }</td>
      </tr>
      <tr>
        <td id="L1830" data-line-number="1830"></td>
        <td id="LC1830">
</td>
      </tr>
      <tr>
        <td id="L1831" data-line-number="1831"></td>
        <td id="LC1831">    OBJECTHANDLE    <span>GetLoaderAllocatorObjectHandle</span>();</td>
      </tr>
      <tr>
        <td id="L1832" data-line-number="1832"></td>
        <td id="LC1832">    NOINLINE BYTE *<span>GetLoaderAllocatorObjectForGC</span>();</td>
      </tr>
      <tr>
        <td id="L1833" data-line-number="1833"></td>
        <td id="LC1833">
</td>
      </tr>
      <tr>
        <td id="L1834" data-line-number="1834"></td>
        <td id="LC1834">    BOOL            <span>IsNotTightlyPacked</span>();</td>
      </tr>
      <tr>
        <td id="L1835" data-line-number="1835"></td>
        <td id="LC1835">
</td>
      </tr>
      <tr>
        <td id="L1836" data-line-number="1836"></td>
        <td id="LC1836">    <span>void</span> <span>SetContainsPointers</span>()</td>
      </tr>
      <tr>
        <td id="L1837" data-line-number="1837"></td>
        <td id="LC1837">    {</td>
      </tr>
      <tr>
        <td id="L1838" data-line-number="1838"></td>
        <td id="LC1838">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1839" data-line-number="1839"></td>
        <td id="LC1839">        <span>SetFlag</span>(enum_flag_ContainsPointers);</td>
      </tr>
      <tr>
        <td id="L1840" data-line-number="1840"></td>
        <td id="LC1840">    }</td>
      </tr>
      <tr>
        <td id="L1841" data-line-number="1841"></td>
        <td id="LC1841">
</td>
      </tr>
      <tr>
        <td id="L1842" data-line-number="1842"></td>
        <td id="LC1842">#<span>ifdef</span> FEATURE_64BIT_ALIGNMENT</td>
      </tr>
      <tr>
        <td id="L1843" data-line-number="1843"></td>
        <td id="LC1843">    <span>inline</span> <span>bool</span> <span>RequiresAlign8</span>()</td>
      </tr>
      <tr>
        <td id="L1844" data-line-number="1844"></td>
        <td id="LC1844">    {</td>
      </tr>
      <tr>
        <td id="L1845" data-line-number="1845"></td>
        <td id="LC1845">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1846" data-line-number="1846"></td>
        <td id="LC1846">        <span>return</span> !!<span>GetFlag</span>(enum_flag_RequiresAlign8);</td>
      </tr>
      <tr>
        <td id="L1847" data-line-number="1847"></td>
        <td id="LC1847">    }</td>
      </tr>
      <tr>
        <td id="L1848" data-line-number="1848"></td>
        <td id="LC1848">
</td>
      </tr>
      <tr>
        <td id="L1849" data-line-number="1849"></td>
        <td id="LC1849">    <span>inline</span> <span>void</span> <span>SetRequiresAlign8</span>()</td>
      </tr>
      <tr>
        <td id="L1850" data-line-number="1850"></td>
        <td id="LC1850">    {</td>
      </tr>
      <tr>
        <td id="L1851" data-line-number="1851"></td>
        <td id="LC1851">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1852" data-line-number="1852"></td>
        <td id="LC1852">        <span>SetFlag</span>(enum_flag_RequiresAlign8);</td>
      </tr>
      <tr>
        <td id="L1853" data-line-number="1853"></td>
        <td id="LC1853">    }</td>
      </tr>
      <tr>
        <td id="L1854" data-line-number="1854"></td>
        <td id="LC1854">#<span>endif</span> <span><span>//</span> FEATURE_64BIT_ALIGNMENT</span></td>
      </tr>
      <tr>
        <td id="L1855" data-line-number="1855"></td>
        <td id="LC1855">
</td>
      </tr>
      <tr>
        <td id="L1856" data-line-number="1856"></td>
        <td id="LC1856">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1857" data-line-number="1857"></td>
        <td id="LC1857">    <span><span>//</span> FIELD DESCRIPTORS</span></td>
      </tr>
      <tr>
        <td id="L1858" data-line-number="1858"></td>
        <td id="LC1858">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1859" data-line-number="1859"></td>
        <td id="LC1859">    <span><span>//</span> Most of this API still lives on EEClass.</span></td>
      </tr>
      <tr>
        <td id="L1860" data-line-number="1860"></td>
        <td id="LC1860">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1861" data-line-number="1861"></td>
        <td id="LC1861">    <span><span>//</span> ************************************ WARNING *************</span></td>
      </tr>
      <tr>
        <td id="L1862" data-line-number="1862"></td>
        <td id="LC1862">    <span><span>//</span> **   !!!!INSTANCE FIELDDESCS ARE REPRESENTATIVES!!!!!   **</span></td>
      </tr>
      <tr>
        <td id="L1863" data-line-number="1863"></td>
        <td id="LC1863">    <span><span>//</span> ** THEY ARE SHARED BY COMPATIBLE GENERIC INSTANTIATIONS **</span></td>
      </tr>
      <tr>
        <td id="L1864" data-line-number="1864"></td>
        <td id="LC1864">    <span><span>//</span> ************************************ WARNING *************</span></td>
      </tr>
      <tr>
        <td id="L1865" data-line-number="1865"></td>
        <td id="LC1865">
</td>
      </tr>
      <tr>
        <td id="L1866" data-line-number="1866"></td>
        <td id="LC1866">    <span><span>//</span> This goes straight to the EEClass</span></td>
      </tr>
      <tr>
        <td id="L1867" data-line-number="1867"></td>
        <td id="LC1867">    <span><span>//</span> Careful about using this method. If it's possible that fields may have been added via EnC, then</span></td>
      </tr>
      <tr>
        <td id="L1868" data-line-number="1868"></td>
        <td id="LC1868">    <span><span>//</span> must use the FieldDescIterator as any fields added via EnC won't be in the raw list</span></td>
      </tr>
      <tr>
        <td id="L1869" data-line-number="1869"></td>
        <td id="LC1869">    PTR_FieldDesc <span>GetApproxFieldDescListRaw</span>();</td>
      </tr>
      <tr>
        <td id="L1870" data-line-number="1870"></td>
        <td id="LC1870">
</td>
      </tr>
      <tr>
        <td id="L1871" data-line-number="1871"></td>
        <td id="LC1871">    <span><span>//</span> This returns a type-exact FieldDesc for a static field, but may still return a representative</span></td>
      </tr>
      <tr>
        <td id="L1872" data-line-number="1872"></td>
        <td id="LC1872">    <span><span>//</span> for a non-static field.</span></td>
      </tr>
      <tr>
        <td id="L1873" data-line-number="1873"></td>
        <td id="LC1873">    PTR_FieldDesc <span>GetFieldDescByIndex</span>(DWORD fieldIndex);</td>
      </tr>
      <tr>
        <td id="L1874" data-line-number="1874"></td>
        <td id="LC1874">
</td>
      </tr>
      <tr>
        <td id="L1875" data-line-number="1875"></td>
        <td id="LC1875">    DWORD <span>GetIndexForFieldDesc</span>(FieldDesc *pField);</td>
      </tr>
      <tr>
        <td id="L1876" data-line-number="1876"></td>
        <td id="LC1876">
</td>
      </tr>
      <tr>
        <td id="L1877" data-line-number="1877"></td>
        <td id="LC1877">    <span>inline</span> <span>bool</span> <span>RequiresFatDispatchTokens</span>()</td>
      </tr>
      <tr>
        <td id="L1878" data-line-number="1878"></td>
        <td id="LC1878">    {</td>
      </tr>
      <tr>
        <td id="L1879" data-line-number="1879"></td>
        <td id="LC1879">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1880" data-line-number="1880"></td>
        <td id="LC1880">        <span>return</span> !!<span>GetFlag</span>(enum_flag_RequiresDispatchTokenFat);</td>
      </tr>
      <tr>
        <td id="L1881" data-line-number="1881"></td>
        <td id="LC1881">    }</td>
      </tr>
      <tr>
        <td id="L1882" data-line-number="1882"></td>
        <td id="LC1882">
</td>
      </tr>
      <tr>
        <td id="L1883" data-line-number="1883"></td>
        <td id="LC1883">    <span>inline</span> <span>void</span> <span>SetRequiresFatDispatchTokens</span>()</td>
      </tr>
      <tr>
        <td id="L1884" data-line-number="1884"></td>
        <td id="LC1884">    {</td>
      </tr>
      <tr>
        <td id="L1885" data-line-number="1885"></td>
        <td id="LC1885">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1886" data-line-number="1886"></td>
        <td id="LC1886">        <span>SetFlag</span>(enum_flag_RequiresDispatchTokenFat);</td>
      </tr>
      <tr>
        <td id="L1887" data-line-number="1887"></td>
        <td id="LC1887">    }</td>
      </tr>
      <tr>
        <td id="L1888" data-line-number="1888"></td>
        <td id="LC1888">
</td>
      </tr>
      <tr>
        <td id="L1889" data-line-number="1889"></td>
        <td id="LC1889">    <span>inline</span> <span>bool</span> <span>HasPreciseInitCctors</span>()</td>
      </tr>
      <tr>
        <td id="L1890" data-line-number="1890"></td>
        <td id="LC1890">    {</td>
      </tr>
      <tr>
        <td id="L1891" data-line-number="1891"></td>
        <td id="LC1891">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1892" data-line-number="1892"></td>
        <td id="LC1892">        <span>return</span> !!<span>GetFlag</span>(enum_flag_HasPreciseInitCctors);</td>
      </tr>
      <tr>
        <td id="L1893" data-line-number="1893"></td>
        <td id="LC1893">    }</td>
      </tr>
      <tr>
        <td id="L1894" data-line-number="1894"></td>
        <td id="LC1894">
</td>
      </tr>
      <tr>
        <td id="L1895" data-line-number="1895"></td>
        <td id="LC1895">    <span>inline</span> <span>void</span> <span>SetHasPreciseInitCctors</span>()</td>
      </tr>
      <tr>
        <td id="L1896" data-line-number="1896"></td>
        <td id="LC1896">    {</td>
      </tr>
      <tr>
        <td id="L1897" data-line-number="1897"></td>
        <td id="LC1897">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1898" data-line-number="1898"></td>
        <td id="LC1898">        <span>SetFlag</span>(enum_flag_HasPreciseInitCctors);</td>
      </tr>
      <tr>
        <td id="L1899" data-line-number="1899"></td>
        <td id="LC1899">    }</td>
      </tr>
      <tr>
        <td id="L1900" data-line-number="1900"></td>
        <td id="LC1900">
</td>
      </tr>
      <tr>
        <td id="L1901" data-line-number="1901"></td>
        <td id="LC1901">#<span>if</span> defined(FEATURE_HFA)</td>
      </tr>
      <tr>
        <td id="L1902" data-line-number="1902"></td>
        <td id="LC1902">    <span>inline</span> <span>bool</span> <span>IsHFA</span>()</td>
      </tr>
      <tr>
        <td id="L1903" data-line-number="1903"></td>
        <td id="LC1903">    {</td>
      </tr>
      <tr>
        <td id="L1904" data-line-number="1904"></td>
        <td id="LC1904">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1905" data-line-number="1905"></td>
        <td id="LC1905">        <span>return</span> !!<span>GetFlag</span>(enum_flag_IsHFA);</td>
      </tr>
      <tr>
        <td id="L1906" data-line-number="1906"></td>
        <td id="LC1906">    }</td>
      </tr>
      <tr>
        <td id="L1907" data-line-number="1907"></td>
        <td id="LC1907">
</td>
      </tr>
      <tr>
        <td id="L1908" data-line-number="1908"></td>
        <td id="LC1908">    <span>inline</span> <span>void</span> <span>SetIsHFA</span>()</td>
      </tr>
      <tr>
        <td id="L1909" data-line-number="1909"></td>
        <td id="LC1909">    {</td>
      </tr>
      <tr>
        <td id="L1910" data-line-number="1910"></td>
        <td id="LC1910">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1911" data-line-number="1911"></td>
        <td id="LC1911">        <span>SetFlag</span>(enum_flag_IsHFA);</td>
      </tr>
      <tr>
        <td id="L1912" data-line-number="1912"></td>
        <td id="LC1912">    }</td>
      </tr>
      <tr>
        <td id="L1913" data-line-number="1913"></td>
        <td id="LC1913">#<span>else</span> <span><span>//</span> !FEATURE_HFA</span></td>
      </tr>
      <tr>
        <td id="L1914" data-line-number="1914"></td>
        <td id="LC1914">    <span>bool</span> <span>IsHFA</span>();</td>
      </tr>
      <tr>
        <td id="L1915" data-line-number="1915"></td>
        <td id="LC1915">#<span>endif</span> <span><span>//</span> FEATURE_HFA</span></td>
      </tr>
      <tr>
        <td id="L1916" data-line-number="1916"></td>
        <td id="LC1916">
</td>
      </tr>
      <tr>
        <td id="L1917" data-line-number="1917"></td>
        <td id="LC1917">    <span><span>//</span> Returns the size in bytes of this type if it is a HW vector type; 0 otherwise.</span></td>
      </tr>
      <tr>
        <td id="L1918" data-line-number="1918"></td>
        <td id="LC1918">    <span>int</span> <span>GetVectorSize</span>();</td>
      </tr>
      <tr>
        <td id="L1919" data-line-number="1919"></td>
        <td id="LC1919">
</td>
      </tr>
      <tr>
        <td id="L1920" data-line-number="1920"></td>
        <td id="LC1920">    <span><span>//</span> Get the HFA type. This is supported both with FEATURE_HFA, in which case it</span></td>
      </tr>
      <tr>
        <td id="L1921" data-line-number="1921"></td>
        <td id="LC1921">    <span><span>//</span> depends on the cached bit on the class, or without, in which case it is recomputed</span></td>
      </tr>
      <tr>
        <td id="L1922" data-line-number="1922"></td>
        <td id="LC1922">    <span><span>//</span> for each invocation.</span></td>
      </tr>
      <tr>
        <td id="L1923" data-line-number="1923"></td>
        <td id="LC1923">    CorElementType <span>GetHFAType</span>();</td>
      </tr>
      <tr>
        <td id="L1924" data-line-number="1924"></td>
        <td id="LC1924">    <span><span>//</span> The managed and unmanaged HFA type can differ for types with layout. The following two methods return the unmanaged HFA type.</span></td>
      </tr>
      <tr>
        <td id="L1925" data-line-number="1925"></td>
        <td id="LC1925">    <span>bool</span> <span>IsNativeHFA</span>();</td>
      </tr>
      <tr>
        <td id="L1926" data-line-number="1926"></td>
        <td id="LC1926">    CorElementType <span>GetNativeHFAType</span>();</td>
      </tr>
      <tr>
        <td id="L1927" data-line-number="1927"></td>
        <td id="LC1927">
</td>
      </tr>
      <tr>
        <td id="L1928" data-line-number="1928"></td>
        <td id="LC1928">#<span>ifdef</span> UNIX_AMD64_ABI</td>
      </tr>
      <tr>
        <td id="L1929" data-line-number="1929"></td>
        <td id="LC1929">    <span>inline</span> <span>bool</span> <span>IsRegPassedStruct</span>()</td>
      </tr>
      <tr>
        <td id="L1930" data-line-number="1930"></td>
        <td id="LC1930">    {</td>
      </tr>
      <tr>
        <td id="L1931" data-line-number="1931"></td>
        <td id="LC1931">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1932" data-line-number="1932"></td>
        <td id="LC1932">        <span>return</span> !!<span>GetFlag</span>(enum_flag_IsRegStructPassed);</td>
      </tr>
      <tr>
        <td id="L1933" data-line-number="1933"></td>
        <td id="LC1933">    }</td>
      </tr>
      <tr>
        <td id="L1934" data-line-number="1934"></td>
        <td id="LC1934">
</td>
      </tr>
      <tr>
        <td id="L1935" data-line-number="1935"></td>
        <td id="LC1935">    <span>inline</span> <span>void</span> <span>SetRegPassedStruct</span>()</td>
      </tr>
      <tr>
        <td id="L1936" data-line-number="1936"></td>
        <td id="LC1936">    {</td>
      </tr>
      <tr>
        <td id="L1937" data-line-number="1937"></td>
        <td id="LC1937">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1938" data-line-number="1938"></td>
        <td id="LC1938">        <span>SetFlag</span>(enum_flag_IsRegStructPassed);</td>
      </tr>
      <tr>
        <td id="L1939" data-line-number="1939"></td>
        <td id="LC1939">    }</td>
      </tr>
      <tr>
        <td id="L1940" data-line-number="1940"></td>
        <td id="LC1940">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L1941" data-line-number="1941"></td>
        <td id="LC1941">    <span>inline</span> <span>bool</span> <span>IsRegPassedStruct</span>()</td>
      </tr>
      <tr>
        <td id="L1942" data-line-number="1942"></td>
        <td id="LC1942">    {</td>
      </tr>
      <tr>
        <td id="L1943" data-line-number="1943"></td>
        <td id="LC1943">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L1944" data-line-number="1944"></td>
        <td id="LC1944">    }</td>
      </tr>
      <tr>
        <td id="L1945" data-line-number="1945"></td>
        <td id="LC1945">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1946" data-line-number="1946"></td>
        <td id="LC1946">
</td>
      </tr>
      <tr>
        <td id="L1947" data-line-number="1947"></td>
        <td id="LC1947">#<span>ifdef</span> FEATURE_64BIT_ALIGNMENT</td>
      </tr>
      <tr>
        <td id="L1948" data-line-number="1948"></td>
        <td id="LC1948">    <span><span>//</span> Returns true iff the native view of this type requires 64-bit aligment.</span></td>
      </tr>
      <tr>
        <td id="L1949" data-line-number="1949"></td>
        <td id="LC1949">    <span>bool</span> <span>NativeRequiresAlign8</span>();</td>
      </tr>
      <tr>
        <td id="L1950" data-line-number="1950"></td>
        <td id="LC1950">#<span>endif</span> <span><span>//</span> FEATURE_64BIT_ALIGNMENT</span></td>
      </tr>
      <tr>
        <td id="L1951" data-line-number="1951"></td>
        <td id="LC1951">
</td>
      </tr>
      <tr>
        <td id="L1952" data-line-number="1952"></td>
        <td id="LC1952">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1953" data-line-number="1953"></td>
        <td id="LC1953">    <span><span>//</span> PARENT INTERFACES</span></td>
      </tr>
      <tr>
        <td id="L1954" data-line-number="1954"></td>
        <td id="LC1954">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1955" data-line-number="1955"></td>
        <td id="LC1955">    <span>unsigned</span> <span>GetNumInterfaces</span>()</td>
      </tr>
      <tr>
        <td id="L1956" data-line-number="1956"></td>
        <td id="LC1956">    {</td>
      </tr>
      <tr>
        <td id="L1957" data-line-number="1957"></td>
        <td id="LC1957">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L1958" data-line-number="1958"></td>
        <td id="LC1958">        <span>return</span> m_wNumInterfaces;</td>
      </tr>
      <tr>
        <td id="L1959" data-line-number="1959"></td>
        <td id="LC1959">    }</td>
      </tr>
      <tr>
        <td id="L1960" data-line-number="1960"></td>
        <td id="LC1960">
</td>
      </tr>
      <tr>
        <td id="L1961" data-line-number="1961"></td>
        <td id="LC1961">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1962" data-line-number="1962"></td>
        <td id="LC1962">    <span><span>//</span> CASTING</span></td>
      </tr>
      <tr>
        <td id="L1963" data-line-number="1963"></td>
        <td id="LC1963">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1964" data-line-number="1964"></td>
        <td id="LC1964">    BOOL <span>CanCastToInterface</span>(MethodTable *pTargetMT, TypeHandlePairList *pVisited = <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1965" data-line-number="1965"></td>
        <td id="LC1965">    BOOL <span>CanCastToClass</span>(MethodTable *pTargetMT, TypeHandlePairList *pVisited = <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L1966" data-line-number="1966"></td>
        <td id="LC1966">    BOOL <span>CanCastTo</span>(MethodTable* pTargetMT, TypeHandlePairList *pVisited);</td>
      </tr>
      <tr>
        <td id="L1967" data-line-number="1967"></td>
        <td id="LC1967">    BOOL <span>ArraySupportsBizarreInterface</span>(MethodTable* pInterfaceMT, TypeHandlePairList* pVisited);</td>
      </tr>
      <tr>
        <td id="L1968" data-line-number="1968"></td>
        <td id="LC1968">    BOOL <span>ArrayIsInstanceOf</span>(MethodTable* pTargetMT, TypeHandlePairList* pVisited);</td>
      </tr>
      <tr>
        <td id="L1969" data-line-number="1969"></td>
        <td id="LC1969">
</td>
      </tr>
      <tr>
        <td id="L1970" data-line-number="1970"></td>
        <td id="LC1970">    BOOL <span>CanCastByVarianceToInterfaceOrDelegate</span>(MethodTable* pTargetMT, TypeHandlePairList* pVisited);</td>
      </tr>
      <tr>
        <td id="L1971" data-line-number="1971"></td>
        <td id="LC1971">
</td>
      </tr>
      <tr>
        <td id="L1972" data-line-number="1972"></td>
        <td id="LC1972">    <span><span>//</span> The inline part of equivalence check.</span></td>
      </tr>
      <tr>
        <td id="L1973" data-line-number="1973"></td>
        <td id="LC1973">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L1974" data-line-number="1974"></td>
        <td id="LC1974">    FORCEINLINE BOOL <span>IsEquivalentTo</span>(MethodTable *pOtherMT <span>COMMA_INDEBUG</span>(TypeHandlePairList *pVisited = <span>NULL</span>));</td>
      </tr>
      <tr>
        <td id="L1975" data-line-number="1975"></td>
        <td id="LC1975">
</td>
      </tr>
      <tr>
        <td id="L1976" data-line-number="1976"></td>
        <td id="LC1976">#<span>ifdef</span> FEATURE_TYPEEQUIVALENCE</td>
      </tr>
      <tr>
        <td id="L1977" data-line-number="1977"></td>
        <td id="LC1977">    <span><span>//</span> This method is public so that TypeHandle has direct access to it</span></td>
      </tr>
      <tr>
        <td id="L1978" data-line-number="1978"></td>
        <td id="LC1978">    BOOL <span>IsEquivalentTo_Worker</span>(MethodTable *pOtherMT <span>COMMA_INDEBUG</span>(TypeHandlePairList *pVisited));      <span><span>//</span> out-of-line part, SO tolerant</span></td>
      </tr>
      <tr>
        <td id="L1979" data-line-number="1979"></td>
        <td id="LC1979">private:</td>
      </tr>
      <tr>
        <td id="L1980" data-line-number="1980"></td>
        <td id="LC1980">    BOOL <span>IsEquivalentTo_WorkerInner</span>(MethodTable *pOtherMT <span>COMMA_INDEBUG</span>(TypeHandlePairList *pVisited)); <span><span>//</span> out-of-line part, SO intolerant</span></td>
      </tr>
      <tr>
        <td id="L1981" data-line-number="1981"></td>
        <td id="LC1981">#<span>endif</span> <span><span>//</span> FEATURE_TYPEEQUIVALENCE</span></td>
      </tr>
      <tr>
        <td id="L1982" data-line-number="1982"></td>
        <td id="LC1982">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1983" data-line-number="1983"></td>
        <td id="LC1983">
</td>
      </tr>
      <tr>
        <td id="L1984" data-line-number="1984"></td>
        <td id="LC1984">public:</td>
      </tr>
      <tr>
        <td id="L1985" data-line-number="1985"></td>
        <td id="LC1985">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L1986" data-line-number="1986"></td>
        <td id="LC1986">    <span><span>//</span> THE METHOD TABLE PARENT (SUPERCLASS/BASE CLASS)</span></td>
      </tr>
      <tr>
        <td id="L1987" data-line-number="1987"></td>
        <td id="LC1987">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L1988" data-line-number="1988"></td>
        <td id="LC1988">
</td>
      </tr>
      <tr>
        <td id="L1989" data-line-number="1989"></td>
        <td id="LC1989">#<span>if</span> defined(FEATURE_NGEN_RELOCS_OPTIMIZATIONS)</td>
      </tr>
      <tr>
        <td id="L1990" data-line-number="1990"></td>
        <td id="LC1990">#<span>define</span> <span>PARENT_MT_FIXUP_OFFSET</span> (-FIXUP_POINTER_INDIRECTION)</td>
      </tr>
      <tr>
        <td id="L1991" data-line-number="1991"></td>
        <td id="LC1991">    <span>typedef</span> RelativeFixupPointer&lt;PTR_MethodTable&gt; ParentMT_t;</td>
      </tr>
      <tr>
        <td id="L1992" data-line-number="1992"></td>
        <td id="LC1992">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L1993" data-line-number="1993"></td>
        <td id="LC1993">#<span>define</span> <span>PARENT_MT_FIXUP_OFFSET</span> ((SSIZE_T)offsetof(MethodTable, m_pParentMethodTable))</td>
      </tr>
      <tr>
        <td id="L1994" data-line-number="1994"></td>
        <td id="LC1994">    <span>typedef</span> IndirectPointer&lt;PTR_MethodTable&gt; ParentMT_t;</td>
      </tr>
      <tr>
        <td id="L1995" data-line-number="1995"></td>
        <td id="LC1995">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L1996" data-line-number="1996"></td>
        <td id="LC1996">
</td>
      </tr>
      <tr>
        <td id="L1997" data-line-number="1997"></td>
        <td id="LC1997">    BOOL <span>HasApproxParent</span>()</td>
      </tr>
      <tr>
        <td id="L1998" data-line-number="1998"></td>
        <td id="LC1998">    {</td>
      </tr>
      <tr>
        <td id="L1999" data-line-number="1999"></td>
        <td id="LC1999">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2000" data-line-number="2000"></td>
        <td id="LC2000">        <span>return</span> (<span>GetWriteableData</span>()-&gt;<span>m_dwFlags</span> &amp; MethodTableWriteableData::enum_flag_HasApproxParent) != <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2001" data-line-number="2001"></td>
        <td id="LC2001">    }</td>
      </tr>
      <tr>
        <td id="L2002" data-line-number="2002"></td>
        <td id="LC2002">    <span>inline</span> <span>void</span> <span>SetHasExactParent</span>()</td>
      </tr>
      <tr>
        <td id="L2003" data-line-number="2003"></td>
        <td id="LC2003">    {</td>
      </tr>
      <tr>
        <td id="L2004" data-line-number="2004"></td>
        <td id="LC2004">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2005" data-line-number="2005"></td>
        <td id="LC2005">        <span>FastInterlockAnd</span>(&amp;(<span>GetWriteableDataForWrite</span>()-&gt;<span>m_dwFlags</span>), ~MethodTableWriteableData::enum_flag_HasApproxParent);</td>
      </tr>
      <tr>
        <td id="L2006" data-line-number="2006"></td>
        <td id="LC2006">    }</td>
      </tr>
      <tr>
        <td id="L2007" data-line-number="2007"></td>
        <td id="LC2007">
</td>
      </tr>
      <tr>
        <td id="L2008" data-line-number="2008"></td>
        <td id="LC2008">
</td>
      </tr>
      <tr>
        <td id="L2009" data-line-number="2009"></td>
        <td id="LC2009">    <span><span>//</span> Caller must know that the parent method table is not an encoded fixup</span></td>
      </tr>
      <tr>
        <td id="L2010" data-line-number="2010"></td>
        <td id="LC2010">    <span>inline</span> PTR_MethodTable <span>GetParentMethodTable</span>()</td>
      </tr>
      <tr>
        <td id="L2011" data-line-number="2011"></td>
        <td id="LC2011">    {</td>
      </tr>
      <tr>
        <td id="L2012" data-line-number="2012"></td>
        <td id="LC2012">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2013" data-line-number="2013"></td>
        <td id="LC2013">
</td>
      </tr>
      <tr>
        <td id="L2014" data-line-number="2014"></td>
        <td id="LC2014">        <span>PRECONDITION</span>(<span>IsParentMethodTablePointerValid</span>());</td>
      </tr>
      <tr>
        <td id="L2015" data-line-number="2015"></td>
        <td id="LC2015">        <span>return</span> <span>ReadPointerMaybeNull</span>(this, &amp;MethodTable::m_pParentMethodTable, <span>GetFlagHasIndirectParent</span>());</td>
      </tr>
      <tr>
        <td id="L2016" data-line-number="2016"></td>
        <td id="LC2016">    }</td>
      </tr>
      <tr>
        <td id="L2017" data-line-number="2017"></td>
        <td id="LC2017">
</td>
      </tr>
      <tr>
        <td id="L2018" data-line-number="2018"></td>
        <td id="LC2018">    <span>inline</span> <span>static</span> PTR_VOID <span>GetParentMethodTableOrIndirection</span>(PTR_VOID pMT)</td>
      </tr>
      <tr>
        <td id="L2019" data-line-number="2019"></td>
        <td id="LC2019">    {</td>
      </tr>
      <tr>
        <td id="L2020" data-line-number="2020"></td>
        <td id="LC2020">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2021" data-line-number="2021"></td>
        <td id="LC2021">#<span>if</span> defined(FEATURE_NGEN_RELOCS_OPTIMIZATIONS)</td>
      </tr>
      <tr>
        <td id="L2022" data-line-number="2022"></td>
        <td id="LC2022">        PTR_MethodTable pMethodTable = dac_cast&lt;PTR_MethodTable&gt;(pMT);</td>
      </tr>
      <tr>
        <td id="L2023" data-line-number="2023"></td>
        <td id="LC2023">        PTR_MethodTable pParentMT = <span>ReadPointerMaybeNull</span>((MethodTable*) pMethodTable, &amp;MethodTable::m_pParentMethodTable);</td>
      </tr>
      <tr>
        <td id="L2024" data-line-number="2024"></td>
        <td id="LC2024">        <span>return</span> dac_cast&lt;PTR_VOID&gt;(pParentMT);</td>
      </tr>
      <tr>
        <td id="L2025" data-line-number="2025"></td>
        <td id="LC2025">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L2026" data-line-number="2026"></td>
        <td id="LC2026">        <span>return</span> <span>PTR_VOID</span>(*<span>PTR_TADDR</span>(dac_cast&lt;TADDR&gt;(pMT) + <span>offsetof</span>(MethodTable, m_pParentMethodTable)));</td>
      </tr>
      <tr>
        <td id="L2027" data-line-number="2027"></td>
        <td id="LC2027">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2028" data-line-number="2028"></td>
        <td id="LC2028">    }</td>
      </tr>
      <tr>
        <td id="L2029" data-line-number="2029"></td>
        <td id="LC2029">
</td>
      </tr>
      <tr>
        <td id="L2030" data-line-number="2030"></td>
        <td id="LC2030">    <span>inline</span> <span>static</span> BOOL <span>IsParentMethodTableTagged</span>(PTR_MethodTable pMT)</td>
      </tr>
      <tr>
        <td id="L2031" data-line-number="2031"></td>
        <td id="LC2031">    {</td>
      </tr>
      <tr>
        <td id="L2032" data-line-number="2032"></td>
        <td id="LC2032">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2033" data-line-number="2033"></td>
        <td id="LC2033">        TADDR base = dac_cast&lt;TADDR&gt;(pMT) + <span>offsetof</span>(MethodTable, m_pParentMethodTable);</td>
      </tr>
      <tr>
        <td id="L2034" data-line-number="2034"></td>
        <td id="LC2034">        <span>return</span> pMT-&gt;<span>m_pParentMethodTable</span>.<span>IsTaggedIndirect</span>(base, pMT-&gt;<span>GetFlagHasIndirectParent</span>(), PARENT_MT_FIXUP_OFFSET);</td>
      </tr>
      <tr>
        <td id="L2035" data-line-number="2035"></td>
        <td id="LC2035">    }</td>
      </tr>
      <tr>
        <td id="L2036" data-line-number="2036"></td>
        <td id="LC2036">
</td>
      </tr>
      <tr>
        <td id="L2037" data-line-number="2037"></td>
        <td id="LC2037">    <span>bool</span> <span>GetFlagHasIndirectParent</span>()</td>
      </tr>
      <tr>
        <td id="L2038" data-line-number="2038"></td>
        <td id="LC2038">    {</td>
      </tr>
      <tr>
        <td id="L2039" data-line-number="2039"></td>
        <td id="LC2039">#<span>ifdef</span> FEATURE_PREJIT</td>
      </tr>
      <tr>
        <td id="L2040" data-line-number="2040"></td>
        <td id="LC2040">        <span>return</span> !!<span>GetFlag</span>(enum_flag_HasIndirectParent);</td>
      </tr>
      <tr>
        <td id="L2041" data-line-number="2041"></td>
        <td id="LC2041">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L2042" data-line-number="2042"></td>
        <td id="LC2042">        <span>return</span> <span>false</span>;</td>
      </tr>
      <tr>
        <td id="L2043" data-line-number="2043"></td>
        <td id="LC2043">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2044" data-line-number="2044"></td>
        <td id="LC2044">    }</td>
      </tr>
      <tr>
        <td id="L2045" data-line-number="2045"></td>
        <td id="LC2045">
</td>
      </tr>
      <tr>
        <td id="L2046" data-line-number="2046"></td>
        <td id="LC2046">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2047" data-line-number="2047"></td>
        <td id="LC2047">    <span>inline</span> ParentMT_t * <span>GetParentMethodTablePointerPtr</span>()</td>
      </tr>
      <tr>
        <td id="L2048" data-line-number="2048"></td>
        <td id="LC2048">    {</td>
      </tr>
      <tr>
        <td id="L2049" data-line-number="2049"></td>
        <td id="LC2049">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2050" data-line-number="2050"></td>
        <td id="LC2050">        <span>return</span> &amp;m_pParentMethodTable;</td>
      </tr>
      <tr>
        <td id="L2051" data-line-number="2051"></td>
        <td id="LC2051">    }</td>
      </tr>
      <tr>
        <td id="L2052" data-line-number="2052"></td>
        <td id="LC2052">
</td>
      </tr>
      <tr>
        <td id="L2053" data-line-number="2053"></td>
        <td id="LC2053">    <span>inline</span> <span>bool</span> <span>IsParentMethodTableIndirectPointerMaybeNull</span>()</td>
      </tr>
      <tr>
        <td id="L2054" data-line-number="2054"></td>
        <td id="LC2054">    {</td>
      </tr>
      <tr>
        <td id="L2055" data-line-number="2055"></td>
        <td id="LC2055">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2056" data-line-number="2056"></td>
        <td id="LC2056">        <span>return</span> m_pParentMethodTable.<span>IsIndirectPtrMaybeNullIndirect</span>(<span>GetFlagHasIndirectParent</span>(), PARENT_MT_FIXUP_OFFSET);</td>
      </tr>
      <tr>
        <td id="L2057" data-line-number="2057"></td>
        <td id="LC2057">    }</td>
      </tr>
      <tr>
        <td id="L2058" data-line-number="2058"></td>
        <td id="LC2058">
</td>
      </tr>
      <tr>
        <td id="L2059" data-line-number="2059"></td>
        <td id="LC2059">    <span>inline</span> <span>bool</span> <span>IsParentMethodTableIndirectPointer</span>()</td>
      </tr>
      <tr>
        <td id="L2060" data-line-number="2060"></td>
        <td id="LC2060">    {</td>
      </tr>
      <tr>
        <td id="L2061" data-line-number="2061"></td>
        <td id="LC2061">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2062" data-line-number="2062"></td>
        <td id="LC2062">        <span>return</span> m_pParentMethodTable.<span>IsIndirectPtrIndirect</span>(<span>GetFlagHasIndirectParent</span>(), PARENT_MT_FIXUP_OFFSET);</td>
      </tr>
      <tr>
        <td id="L2063" data-line-number="2063"></td>
        <td id="LC2063">    }</td>
      </tr>
      <tr>
        <td id="L2064" data-line-number="2064"></td>
        <td id="LC2064">
</td>
      </tr>
      <tr>
        <td id="L2065" data-line-number="2065"></td>
        <td id="LC2065">    <span>inline</span> MethodTable ** <span>GetParentMethodTableValuePtr</span>()</td>
      </tr>
      <tr>
        <td id="L2066" data-line-number="2066"></td>
        <td id="LC2066">    {</td>
      </tr>
      <tr>
        <td id="L2067" data-line-number="2067"></td>
        <td id="LC2067">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2068" data-line-number="2068"></td>
        <td id="LC2068">        <span>return</span> m_pParentMethodTable.<span>GetValuePtrIndirect</span>(<span>GetFlagHasIndirectParent</span>(), PARENT_MT_FIXUP_OFFSET);</td>
      </tr>
      <tr>
        <td id="L2069" data-line-number="2069"></td>
        <td id="LC2069">    }</td>
      </tr>
      <tr>
        <td id="L2070" data-line-number="2070"></td>
        <td id="LC2070">#<span>endif</span> <span><span>//</span> !DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L2071" data-line-number="2071"></td>
        <td id="LC2071">
</td>
      </tr>
      <tr>
        <td id="L2072" data-line-number="2072"></td>
        <td id="LC2072">    <span><span>//</span> Is the parent method table pointer equal to the given argument?</span></td>
      </tr>
      <tr>
        <td id="L2073" data-line-number="2073"></td>
        <td id="LC2073">    BOOL <span>ParentEquals</span>(PTR_MethodTable pMT)</td>
      </tr>
      <tr>
        <td id="L2074" data-line-number="2074"></td>
        <td id="LC2074">    {</td>
      </tr>
      <tr>
        <td id="L2075" data-line-number="2075"></td>
        <td id="LC2075">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2076" data-line-number="2076"></td>
        <td id="LC2076">        <span>PRECONDITION</span>(<span>IsParentMethodTablePointerValid</span>());</td>
      </tr>
      <tr>
        <td id="L2077" data-line-number="2077"></td>
        <td id="LC2077">        g_IBCLogger.<span>LogMethodTableAccess</span>(this);</td>
      </tr>
      <tr>
        <td id="L2078" data-line-number="2078"></td>
        <td id="LC2078">        <span>return</span> <span>GetParentMethodTable</span>() == pMT;</td>
      </tr>
      <tr>
        <td id="L2079" data-line-number="2079"></td>
        <td id="LC2079">    }</td>
      </tr>
      <tr>
        <td id="L2080" data-line-number="2080"></td>
        <td id="LC2080">
</td>
      </tr>
      <tr>
        <td id="L2081" data-line-number="2081"></td>
        <td id="LC2081">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L2082" data-line-number="2082"></td>
        <td id="LC2082">    BOOL <span>IsParentMethodTablePointerValid</span>();</td>
      </tr>
      <tr>
        <td id="L2083" data-line-number="2083"></td>
        <td id="LC2083">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2084" data-line-number="2084"></td>
        <td id="LC2084">
</td>
      </tr>
      <tr>
        <td id="L2085" data-line-number="2085"></td>
        <td id="LC2085">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2086" data-line-number="2086"></td>
        <td id="LC2086">    <span>void</span> <span>SetParentMethodTable</span> (MethodTable *pParentMethodTable)</td>
      </tr>
      <tr>
        <td id="L2087" data-line-number="2087"></td>
        <td id="LC2087">    {</td>
      </tr>
      <tr>
        <td id="L2088" data-line-number="2088"></td>
        <td id="LC2088">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2089" data-line-number="2089"></td>
        <td id="LC2089">        <span>PRECONDITION</span>(!<span>IsParentMethodTableIndirectPointerMaybeNull</span>());</td>
      </tr>
      <tr>
        <td id="L2090" data-line-number="2090"></td>
        <td id="LC2090">        m_pParentMethodTable.<span>SetValueMaybeNull</span>(pParentMethodTable);</td>
      </tr>
      <tr>
        <td id="L2091" data-line-number="2091"></td>
        <td id="LC2091">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L2092" data-line-number="2092"></td>
        <td id="LC2092">        <span>GetWriteableDataForWrite_NoLogging</span>()-&gt;<span>SetParentMethodTablePointerValid</span>();</td>
      </tr>
      <tr>
        <td id="L2093" data-line-number="2093"></td>
        <td id="LC2093">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2094" data-line-number="2094"></td>
        <td id="LC2094">    }</td>
      </tr>
      <tr>
        <td id="L2095" data-line-number="2095"></td>
        <td id="LC2095">#<span>endif</span> <span><span>//</span> !DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L2096" data-line-number="2096"></td>
        <td id="LC2096">    MethodTable * <span>GetMethodTableMatchingParentClass</span>(MethodTable * pWhichParent);</td>
      </tr>
      <tr>
        <td id="L2097" data-line-number="2097"></td>
        <td id="LC2097">    Instantiation <span>GetInstantiationOfParentClass</span>(MethodTable *pWhichParent);</td>
      </tr>
      <tr>
        <td id="L2098" data-line-number="2098"></td>
        <td id="LC2098">
</td>
      </tr>
      <tr>
        <td id="L2099" data-line-number="2099"></td>
        <td id="LC2099">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2100" data-line-number="2100"></td>
        <td id="LC2100">    <span><span>//</span> THE  EEClass (Possibly shared between instantiations!).</span></td>
      </tr>
      <tr>
        <td id="L2101" data-line-number="2101"></td>
        <td id="LC2101">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2102" data-line-number="2102"></td>
        <td id="LC2102">    <span><span>//</span> Note that it is not generally the case that GetClass.GetMethodTable() == t.</span></td>
      </tr>
      <tr>
        <td id="L2103" data-line-number="2103"></td>
        <td id="LC2103">
</td>
      </tr>
      <tr>
        <td id="L2104" data-line-number="2104"></td>
        <td id="LC2104">    PTR_EEClass <span>GetClass</span>();</td>
      </tr>
      <tr>
        <td id="L2105" data-line-number="2105"></td>
        <td id="LC2105">
</td>
      </tr>
      <tr>
        <td id="L2106" data-line-number="2106"></td>
        <td id="LC2106">    <span>inline</span> PTR_EEClass <span>GetClass_NoLogging</span>();</td>
      </tr>
      <tr>
        <td id="L2107" data-line-number="2107"></td>
        <td id="LC2107">
</td>
      </tr>
      <tr>
        <td id="L2108" data-line-number="2108"></td>
        <td id="LC2108">    PTR_EEClass <span>GetClassWithPossibleAV</span>();</td>
      </tr>
      <tr>
        <td id="L2109" data-line-number="2109"></td>
        <td id="LC2109">
</td>
      </tr>
      <tr>
        <td id="L2110" data-line-number="2110"></td>
        <td id="LC2110">    BOOL <span>ValidateWithPossibleAV</span>();</td>
      </tr>
      <tr>
        <td id="L2111" data-line-number="2111"></td>
        <td id="LC2111">
</td>
      </tr>
      <tr>
        <td id="L2112" data-line-number="2112"></td>
        <td id="LC2112">    BOOL <span>IsClassPointerValid</span>();</td>
      </tr>
      <tr>
        <td id="L2113" data-line-number="2113"></td>
        <td id="LC2113">
</td>
      </tr>
      <tr>
        <td id="L2114" data-line-number="2114"></td>
        <td id="LC2114">    <span>static</span> UINT32 <span>GetOffsetOfFlags</span>()</td>
      </tr>
      <tr>
        <td id="L2115" data-line-number="2115"></td>
        <td id="LC2115">    {</td>
      </tr>
      <tr>
        <td id="L2116" data-line-number="2116"></td>
        <td id="LC2116">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2117" data-line-number="2117"></td>
        <td id="LC2117">        <span>return</span> <span>offsetof</span>(MethodTable, m_dwFlags);</td>
      </tr>
      <tr>
        <td id="L2118" data-line-number="2118"></td>
        <td id="LC2118">    }</td>
      </tr>
      <tr>
        <td id="L2119" data-line-number="2119"></td>
        <td id="LC2119">
</td>
      </tr>
      <tr>
        <td id="L2120" data-line-number="2120"></td>
        <td id="LC2120">    <span>static</span> UINT32 <span>GetIfArrayThenSzArrayFlag</span>()</td>
      </tr>
      <tr>
        <td id="L2121" data-line-number="2121"></td>
        <td id="LC2121">    {</td>
      </tr>
      <tr>
        <td id="L2122" data-line-number="2122"></td>
        <td id="LC2122">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2123" data-line-number="2123"></td>
        <td id="LC2123">        <span>return</span> enum_flag_Category_IfArrayThenSzArray;</td>
      </tr>
      <tr>
        <td id="L2124" data-line-number="2124"></td>
        <td id="LC2124">    }</td>
      </tr>
      <tr>
        <td id="L2125" data-line-number="2125"></td>
        <td id="LC2125">
</td>
      </tr>
      <tr>
        <td id="L2126" data-line-number="2126"></td>
        <td id="LC2126">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2127" data-line-number="2127"></td>
        <td id="LC2127">    <span><span>//</span> CONSTRUCTION</span></td>
      </tr>
      <tr>
        <td id="L2128" data-line-number="2128"></td>
        <td id="LC2128">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2129" data-line-number="2129"></td>
        <td id="LC2129">    <span><span>//</span> Do not call the following at any time except when creating a method table.</span></td>
      </tr>
      <tr>
        <td id="L2130" data-line-number="2130"></td>
        <td id="LC2130">    <span><span>//</span> One day we will have proper constructors for method tables and all these</span></td>
      </tr>
      <tr>
        <td id="L2131" data-line-number="2131"></td>
        <td id="LC2131">    <span><span>//</span> will disappear.</span></td>
      </tr>
      <tr>
        <td id="L2132" data-line-number="2132"></td>
        <td id="LC2132">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2133" data-line-number="2133"></td>
        <td id="LC2133">    <span>inline</span> <span>void</span> <span>SetClass</span>(EEClass *pClass)</td>
      </tr>
      <tr>
        <td id="L2134" data-line-number="2134"></td>
        <td id="LC2134">    {</td>
      </tr>
      <tr>
        <td id="L2135" data-line-number="2135"></td>
        <td id="LC2135">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2136" data-line-number="2136"></td>
        <td id="LC2136">        m_pEEClass.<span>SetValue</span>(pClass);</td>
      </tr>
      <tr>
        <td id="L2137" data-line-number="2137"></td>
        <td id="LC2137">    }</td>
      </tr>
      <tr>
        <td id="L2138" data-line-number="2138"></td>
        <td id="LC2138">
</td>
      </tr>
      <tr>
        <td id="L2139" data-line-number="2139"></td>
        <td id="LC2139">    <span>inline</span> <span>void</span> <span>SetCanonicalMethodTable</span>(MethodTable * pMT)</td>
      </tr>
      <tr>
        <td id="L2140" data-line-number="2140"></td>
        <td id="LC2140">    {</td>
      </tr>
      <tr>
        <td id="L2141" data-line-number="2141"></td>
        <td id="LC2141">        m_pCanonMT.<span>SetValue</span>((TADDR)pMT | MethodTable::UNION_METHODTABLE);</td>
      </tr>
      <tr>
        <td id="L2142" data-line-number="2142"></td>
        <td id="LC2142">    }</td>
      </tr>
      <tr>
        <td id="L2143" data-line-number="2143"></td>
        <td id="LC2143">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2144" data-line-number="2144"></td>
        <td id="LC2144">
</td>
      </tr>
      <tr>
        <td id="L2145" data-line-number="2145"></td>
        <td id="LC2145">    <span>inline</span> <span>void</span> <span>SetHasInstantiation</span>(BOOL fTypicalInstantiation, BOOL fSharedByGenericInstantiations);</td>
      </tr>
      <tr>
        <td id="L2146" data-line-number="2146"></td>
        <td id="LC2146">
</td>
      </tr>
      <tr>
        <td id="L2147" data-line-number="2147"></td>
        <td id="LC2147">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2148" data-line-number="2148"></td>
        <td id="LC2148">    <span><span>//</span> INTERFACE IMPLEMENTATION</span></td>
      </tr>
      <tr>
        <td id="L2149" data-line-number="2149"></td>
        <td id="LC2149">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2150" data-line-number="2150"></td>
        <td id="LC2150"> public:</td>
      </tr>
      <tr>
        <td id="L2151" data-line-number="2151"></td>
        <td id="LC2151">    <span><span>//</span> Faster force-inlined version of ImplementsInterface</span></td>
      </tr>
      <tr>
        <td id="L2152" data-line-number="2152"></td>
        <td id="LC2152">    BOOL <span>ImplementsInterfaceInline</span>(MethodTable *pInterface);</td>
      </tr>
      <tr>
        <td id="L2153" data-line-number="2153"></td>
        <td id="LC2153">
</td>
      </tr>
      <tr>
        <td id="L2154" data-line-number="2154"></td>
        <td id="LC2154">    BOOL <span>ImplementsInterface</span>(MethodTable *pInterface);</td>
      </tr>
      <tr>
        <td id="L2155" data-line-number="2155"></td>
        <td id="LC2155">    BOOL <span>ImplementsEquivalentInterface</span>(MethodTable *pInterface);</td>
      </tr>
      <tr>
        <td id="L2156" data-line-number="2156"></td>
        <td id="LC2156">
</td>
      </tr>
      <tr>
        <td id="L2157" data-line-number="2157"></td>
        <td id="LC2157">    MethodDesc *<span>GetMethodDescForInterfaceMethod</span>(TypeHandle ownerType, MethodDesc *pInterfaceMD, BOOL throwOnConflict);</td>
      </tr>
      <tr>
        <td id="L2158" data-line-number="2158"></td>
        <td id="LC2158">    MethodDesc *<span>GetMethodDescForInterfaceMethod</span>(MethodDesc *pInterfaceMD, BOOL throwOnConflict); <span><span>//</span> You can only use this one for non-generic interfaces</span></td>
      </tr>
      <tr>
        <td id="L2159" data-line-number="2159"></td>
        <td id="LC2159">
</td>
      </tr>
      <tr>
        <td id="L2160" data-line-number="2160"></td>
        <td id="LC2160">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2161" data-line-number="2161"></td>
        <td id="LC2161">    <span><span>//</span> INTERFACE MAP.</span></td>
      </tr>
      <tr>
        <td id="L2162" data-line-number="2162"></td>
        <td id="LC2162">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2163" data-line-number="2163"></td>
        <td id="LC2163">
</td>
      </tr>
      <tr>
        <td id="L2164" data-line-number="2164"></td>
        <td id="LC2164">    <span>inline</span> PTR_InterfaceInfo <span>GetInterfaceMap</span>();</td>
      </tr>
      <tr>
        <td id="L2165" data-line-number="2165"></td>
        <td id="LC2165">
</td>
      </tr>
      <tr>
        <td id="L2166" data-line-number="2166"></td>
        <td id="LC2166">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2167" data-line-number="2167"></td>
        <td id="LC2167">    <span>void</span> <span>SetInterfaceMap</span>(WORD wNumInterfaces, InterfaceInfo_t* iMap);</td>
      </tr>
      <tr>
        <td id="L2168" data-line-number="2168"></td>
        <td id="LC2168">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2169" data-line-number="2169"></td>
        <td id="LC2169">
</td>
      </tr>
      <tr>
        <td id="L2170" data-line-number="2170"></td>
        <td id="LC2170">    <span>inline</span> <span>int</span> <span>HasInterfaceMap</span>()</td>
      </tr>
      <tr>
        <td id="L2171" data-line-number="2171"></td>
        <td id="LC2171">    {</td>
      </tr>
      <tr>
        <td id="L2172" data-line-number="2172"></td>
        <td id="LC2172">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2173" data-line-number="2173"></td>
        <td id="LC2173">        <span>return</span> (m_wNumInterfaces != <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L2174" data-line-number="2174"></td>
        <td id="LC2174">    }</td>
      </tr>
      <tr>
        <td id="L2175" data-line-number="2175"></td>
        <td id="LC2175">
</td>
      </tr>
      <tr>
        <td id="L2176" data-line-number="2176"></td>
        <td id="LC2176">    <span><span>//</span> Where possible, use this iterator over the interface map instead of accessing the map directly</span></td>
      </tr>
      <tr>
        <td id="L2177" data-line-number="2177"></td>
        <td id="LC2177">    <span><span>//</span> That way we can easily change the implementation of the map</span></td>
      </tr>
      <tr>
        <td id="L2178" data-line-number="2178"></td>
        <td id="LC2178">    class InterfaceMapIterator</td>
      </tr>
      <tr>
        <td id="L2179" data-line-number="2179"></td>
        <td id="LC2179">    {</td>
      </tr>
      <tr>
        <td id="L2180" data-line-number="2180"></td>
        <td id="LC2180">        friend class MethodTable;</td>
      </tr>
      <tr>
        <td id="L2181" data-line-number="2181"></td>
        <td id="LC2181">
</td>
      </tr>
      <tr>
        <td id="L2182" data-line-number="2182"></td>
        <td id="LC2182">    private:</td>
      </tr>
      <tr>
        <td id="L2183" data-line-number="2183"></td>
        <td id="LC2183">        PTR_InterfaceInfo m_pMap;</td>
      </tr>
      <tr>
        <td id="L2184" data-line-number="2184"></td>
        <td id="LC2184">        DWORD m_i;</td>
      </tr>
      <tr>
        <td id="L2185" data-line-number="2185"></td>
        <td id="LC2185">        DWORD m_count;</td>
      </tr>
      <tr>
        <td id="L2186" data-line-number="2186"></td>
        <td id="LC2186">
</td>
      </tr>
      <tr>
        <td id="L2187" data-line-number="2187"></td>
        <td id="LC2187">        <span>InterfaceMapIterator</span>(MethodTable *pMT)</td>
      </tr>
      <tr>
        <td id="L2188" data-line-number="2188"></td>
        <td id="LC2188">          : <span>m_pMap</span>(pMT-&gt;<span>GetInterfaceMap</span>()),</td>
      </tr>
      <tr>
        <td id="L2189" data-line-number="2189"></td>
        <td id="LC2189">            <span>m_i</span>((DWORD) -<span>1</span>),</td>
      </tr>
      <tr>
        <td id="L2190" data-line-number="2190"></td>
        <td id="LC2190">            <span>m_count</span>(pMT-&gt;<span>GetNumInterfaces</span>())</td>
      </tr>
      <tr>
        <td id="L2191" data-line-number="2191"></td>
        <td id="LC2191">        {</td>
      </tr>
      <tr>
        <td id="L2192" data-line-number="2192"></td>
        <td id="LC2192">            WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2193" data-line-number="2193"></td>
        <td id="LC2193">        }</td>
      </tr>
      <tr>
        <td id="L2194" data-line-number="2194"></td>
        <td id="LC2194">
</td>
      </tr>
      <tr>
        <td id="L2195" data-line-number="2195"></td>
        <td id="LC2195">        <span>InterfaceMapIterator</span>(MethodTable *pMT, DWORD <span>index</span>)</td>
      </tr>
      <tr>
        <td id="L2196" data-line-number="2196"></td>
        <td id="LC2196">          : <span>m_pMap</span>(pMT-&gt;<span>GetInterfaceMap</span>() + <span>index</span>),</td>
      </tr>
      <tr>
        <td id="L2197" data-line-number="2197"></td>
        <td id="LC2197">            <span>m_i</span>(<span>index</span>),</td>
      </tr>
      <tr>
        <td id="L2198" data-line-number="2198"></td>
        <td id="LC2198">            <span>m_count</span>(pMT-&gt;<span>GetNumInterfaces</span>())</td>
      </tr>
      <tr>
        <td id="L2199" data-line-number="2199"></td>
        <td id="LC2199">        {</td>
      </tr>
      <tr>
        <td id="L2200" data-line-number="2200"></td>
        <td id="LC2200">            WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2201" data-line-number="2201"></td>
        <td id="LC2201">            <span>CONSISTENCY_CHECK</span>(<span>index</span> &gt;= <span>0</span> &amp;&amp; <span>index</span> &lt; m_count);</td>
      </tr>
      <tr>
        <td id="L2202" data-line-number="2202"></td>
        <td id="LC2202">        }</td>
      </tr>
      <tr>
        <td id="L2203" data-line-number="2203"></td>
        <td id="LC2203">
</td>
      </tr>
      <tr>
        <td id="L2204" data-line-number="2204"></td>
        <td id="LC2204">    public:</td>
      </tr>
      <tr>
        <td id="L2205" data-line-number="2205"></td>
        <td id="LC2205">        InterfaceInfo_t* <span>GetInterfaceInfo</span>()</td>
      </tr>
      <tr>
        <td id="L2206" data-line-number="2206"></td>
        <td id="LC2206">        {</td>
      </tr>
      <tr>
        <td id="L2207" data-line-number="2207"></td>
        <td id="LC2207">            LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2208" data-line-number="2208"></td>
        <td id="LC2208">            <span>return</span> m_pMap;</td>
      </tr>
      <tr>
        <td id="L2209" data-line-number="2209"></td>
        <td id="LC2209">        }</td>
      </tr>
      <tr>
        <td id="L2210" data-line-number="2210"></td>
        <td id="LC2210">
</td>
      </tr>
      <tr>
        <td id="L2211" data-line-number="2211"></td>
        <td id="LC2211">        <span><span>//</span> Move to the next item in the map, returning TRUE if an item</span></td>
      </tr>
      <tr>
        <td id="L2212" data-line-number="2212"></td>
        <td id="LC2212">        <span><span>//</span> exists or FALSE if we've run off the end</span></td>
      </tr>
      <tr>
        <td id="L2213" data-line-number="2213"></td>
        <td id="LC2213">        <span>inline</span> BOOL <span>Next</span>()</td>
      </tr>
      <tr>
        <td id="L2214" data-line-number="2214"></td>
        <td id="LC2214">        {</td>
      </tr>
      <tr>
        <td id="L2215" data-line-number="2215"></td>
        <td id="LC2215">            LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2216" data-line-number="2216"></td>
        <td id="LC2216">            <span>PRECONDITION</span>(!<span>Finished</span>());</td>
      </tr>
      <tr>
        <td id="L2217" data-line-number="2217"></td>
        <td id="LC2217">            <span>if</span> (m_i != (DWORD) -<span>1</span>)</td>
      </tr>
      <tr>
        <td id="L2218" data-line-number="2218"></td>
        <td id="LC2218">                m_pMap++;</td>
      </tr>
      <tr>
        <td id="L2219" data-line-number="2219"></td>
        <td id="LC2219">            <span>return</span> (++m_i &lt; m_count);</td>
      </tr>
      <tr>
        <td id="L2220" data-line-number="2220"></td>
        <td id="LC2220">        }</td>
      </tr>
      <tr>
        <td id="L2221" data-line-number="2221"></td>
        <td id="LC2221">
</td>
      </tr>
      <tr>
        <td id="L2222" data-line-number="2222"></td>
        <td id="LC2222">        <span><span>//</span> Have we iterated over all of the items?</span></td>
      </tr>
      <tr>
        <td id="L2223" data-line-number="2223"></td>
        <td id="LC2223">        BOOL <span>Finished</span>()</td>
      </tr>
      <tr>
        <td id="L2224" data-line-number="2224"></td>
        <td id="LC2224">        {</td>
      </tr>
      <tr>
        <td id="L2225" data-line-number="2225"></td>
        <td id="LC2225">            <span>return</span> (m_i == m_count);</td>
      </tr>
      <tr>
        <td id="L2226" data-line-number="2226"></td>
        <td id="LC2226">        }</td>
      </tr>
      <tr>
        <td id="L2227" data-line-number="2227"></td>
        <td id="LC2227">
</td>
      </tr>
      <tr>
        <td id="L2228" data-line-number="2228"></td>
        <td id="LC2228">        <span><span>//</span> Get the interface at the current position</span></td>
      </tr>
      <tr>
        <td id="L2229" data-line-number="2229"></td>
        <td id="LC2229">        <span>inline</span> PTR_MethodTable <span>GetInterface</span>()</td>
      </tr>
      <tr>
        <td id="L2230" data-line-number="2230"></td>
        <td id="LC2230">        {</td>
      </tr>
      <tr>
        <td id="L2231" data-line-number="2231"></td>
        <td id="LC2231">            <span>CONTRACT</span>(PTR_MethodTable)</td>
      </tr>
      <tr>
        <td id="L2232" data-line-number="2232"></td>
        <td id="LC2232">            {</td>
      </tr>
      <tr>
        <td id="L2233" data-line-number="2233"></td>
        <td id="LC2233">                GC_NOTRIGGER;</td>
      </tr>
      <tr>
        <td id="L2234" data-line-number="2234"></td>
        <td id="LC2234">                NOTHROW;</td>
      </tr>
      <tr>
        <td id="L2235" data-line-number="2235"></td>
        <td id="LC2235">                SUPPORTS_DAC;</td>
      </tr>
      <tr>
        <td id="L2236" data-line-number="2236"></td>
        <td id="LC2236">                <span>PRECONDITION</span>(m_i != (DWORD) -<span>1</span> &amp;&amp; m_i &lt; m_count);</td>
      </tr>
      <tr>
        <td id="L2237" data-line-number="2237"></td>
        <td id="LC2237">                <span>POSTCONDITION</span>(<span>CheckPointer</span>(RETVAL));</td>
      </tr>
      <tr>
        <td id="L2238" data-line-number="2238"></td>
        <td id="LC2238">            }</td>
      </tr>
      <tr>
        <td id="L2239" data-line-number="2239"></td>
        <td id="LC2239">            CONTRACT_END;</td>
      </tr>
      <tr>
        <td id="L2240" data-line-number="2240"></td>
        <td id="LC2240">
</td>
      </tr>
      <tr>
        <td id="L2241" data-line-number="2241"></td>
        <td id="LC2241">            <span>RETURN</span> (m_pMap-&gt;<span>GetMethodTable</span>());</td>
      </tr>
      <tr>
        <td id="L2242" data-line-number="2242"></td>
        <td id="LC2242">        }</td>
      </tr>
      <tr>
        <td id="L2243" data-line-number="2243"></td>
        <td id="LC2243">
</td>
      </tr>
      <tr>
        <td id="L2244" data-line-number="2244"></td>
        <td id="LC2244">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2245" data-line-number="2245"></td>
        <td id="LC2245">        <span>void</span> <span>SetInterface</span>(MethodTable *pMT)</td>
      </tr>
      <tr>
        <td id="L2246" data-line-number="2246"></td>
        <td id="LC2246">        {</td>
      </tr>
      <tr>
        <td id="L2247" data-line-number="2247"></td>
        <td id="LC2247">            WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2248" data-line-number="2248"></td>
        <td id="LC2248">            m_pMap-&gt;<span>SetMethodTable</span>(pMT);</td>
      </tr>
      <tr>
        <td id="L2249" data-line-number="2249"></td>
        <td id="LC2249">        }</td>
      </tr>
      <tr>
        <td id="L2250" data-line-number="2250"></td>
        <td id="LC2250">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2251" data-line-number="2251"></td>
        <td id="LC2251">
</td>
      </tr>
      <tr>
        <td id="L2252" data-line-number="2252"></td>
        <td id="LC2252">        DWORD <span>GetIndex</span>()</td>
      </tr>
      <tr>
        <td id="L2253" data-line-number="2253"></td>
        <td id="LC2253">        {</td>
      </tr>
      <tr>
        <td id="L2254" data-line-number="2254"></td>
        <td id="LC2254">            LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2255" data-line-number="2255"></td>
        <td id="LC2255">            <span>return</span> m_i;</td>
      </tr>
      <tr>
        <td id="L2256" data-line-number="2256"></td>
        <td id="LC2256">        }</td>
      </tr>
      <tr>
        <td id="L2257" data-line-number="2257"></td>
        <td id="LC2257">    };  <span><span>//</span> class InterfaceMapIterator</span></td>
      </tr>
      <tr>
        <td id="L2258" data-line-number="2258"></td>
        <td id="LC2258">
</td>
      </tr>
      <tr>
        <td id="L2259" data-line-number="2259"></td>
        <td id="LC2259">    <span><span>//</span> Create a new iterator over the interface map</span></td>
      </tr>
      <tr>
        <td id="L2260" data-line-number="2260"></td>
        <td id="LC2260">    <span><span>//</span> The iterator starts just before the first item in the map</span></td>
      </tr>
      <tr>
        <td id="L2261" data-line-number="2261"></td>
        <td id="LC2261">    InterfaceMapIterator <span>IterateInterfaceMap</span>()</td>
      </tr>
      <tr>
        <td id="L2262" data-line-number="2262"></td>
        <td id="LC2262">    {</td>
      </tr>
      <tr>
        <td id="L2263" data-line-number="2263"></td>
        <td id="LC2263">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2264" data-line-number="2264"></td>
        <td id="LC2264">        <span>return</span> <span>InterfaceMapIterator</span>(this);</td>
      </tr>
      <tr>
        <td id="L2265" data-line-number="2265"></td>
        <td id="LC2265">    }</td>
      </tr>
      <tr>
        <td id="L2266" data-line-number="2266"></td>
        <td id="LC2266">
</td>
      </tr>
      <tr>
        <td id="L2267" data-line-number="2267"></td>
        <td id="LC2267">    <span><span>//</span> Create a new iterator over the interface map, starting at the index specified</span></td>
      </tr>
      <tr>
        <td id="L2268" data-line-number="2268"></td>
        <td id="LC2268">    InterfaceMapIterator <span>IterateInterfaceMapFrom</span>(DWORD <span>index</span>)</td>
      </tr>
      <tr>
        <td id="L2269" data-line-number="2269"></td>
        <td id="LC2269">    {</td>
      </tr>
      <tr>
        <td id="L2270" data-line-number="2270"></td>
        <td id="LC2270">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2271" data-line-number="2271"></td>
        <td id="LC2271">        <span>return</span> <span>InterfaceMapIterator</span>(this, <span>index</span>);</td>
      </tr>
      <tr>
        <td id="L2272" data-line-number="2272"></td>
        <td id="LC2272">    }</td>
      </tr>
      <tr>
        <td id="L2273" data-line-number="2273"></td>
        <td id="LC2273">
</td>
      </tr>
      <tr>
        <td id="L2274" data-line-number="2274"></td>
        <td id="LC2274">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2275" data-line-number="2275"></td>
        <td id="LC2275">    <span><span>//</span> ADDITIONAL INTERFACE MAP DATA</span></td>
      </tr>
      <tr>
        <td id="L2276" data-line-number="2276"></td>
        <td id="LC2276">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2277" data-line-number="2277"></td>
        <td id="LC2277">
</td>
      </tr>
      <tr>
        <td id="L2278" data-line-number="2278"></td>
        <td id="LC2278">    <span><span>//</span> We store extra info (flag bits) for interfaces implemented on this MethodTable in a separate optional</span></td>
      </tr>
      <tr>
        <td id="L2279" data-line-number="2279"></td>
        <td id="LC2279">    <span><span>//</span> location for better data density (if we put them in the interface map directly data alignment could</span></td>
      </tr>
      <tr>
        <td id="L2280" data-line-number="2280"></td>
        <td id="LC2280">    <span><span>//</span> have us using 32 or even 64 bits to represent a single boolean value). Currently the only flag we</span></td>
      </tr>
      <tr>
        <td id="L2281" data-line-number="2281"></td>
        <td id="LC2281">    <span><span>//</span> persist is IsDeclaredOnClass (was the interface explicitly declared by this class).</span></td>
      </tr>
      <tr>
        <td id="L2282" data-line-number="2282"></td>
        <td id="LC2282">
</td>
      </tr>
      <tr>
        <td id="L2283" data-line-number="2283"></td>
        <td id="LC2283">    <span><span>//</span> Currently we always store extra info whenever we have an interface map (in the future you could imagine</span></td>
      </tr>
      <tr>
        <td id="L2284" data-line-number="2284"></td>
        <td id="LC2284">    <span><span>//</span> this being limited to those scenarios in which at least one of the interfaces has a non-default value</span></td>
      </tr>
      <tr>
        <td id="L2285" data-line-number="2285"></td>
        <td id="LC2285">    <span><span>//</span> for a flag).</span></td>
      </tr>
      <tr>
        <td id="L2286" data-line-number="2286"></td>
        <td id="LC2286">    <span>inline</span> BOOL <span>HasExtraInterfaceInfo</span>()</td>
      </tr>
      <tr>
        <td id="L2287" data-line-number="2287"></td>
        <td id="LC2287">    {</td>
      </tr>
      <tr>
        <td id="L2288" data-line-number="2288"></td>
        <td id="LC2288">        SUPPORTS_DAC;</td>
      </tr>
      <tr>
        <td id="L2289" data-line-number="2289"></td>
        <td id="LC2289">        <span>return</span> <span>HasInterfaceMap</span>();</td>
      </tr>
      <tr>
        <td id="L2290" data-line-number="2290"></td>
        <td id="LC2290">    }</td>
      </tr>
      <tr>
        <td id="L2291" data-line-number="2291"></td>
        <td id="LC2291">
</td>
      </tr>
      <tr>
        <td id="L2292" data-line-number="2292"></td>
        <td id="LC2292">    <span><span>//</span> Count of interfaces that can have their extra info stored inline in the optional data structure itself</span></td>
      </tr>
      <tr>
        <td id="L2293" data-line-number="2293"></td>
        <td id="LC2293">    <span><span>//</span> (once the interface count exceeds this limit the optional data slot will instead point to a buffer with</span></td>
      </tr>
      <tr>
        <td id="L2294" data-line-number="2294"></td>
        <td id="LC2294">    <span><span>//</span> the information).</span></td>
      </tr>
      <tr>
        <td id="L2295" data-line-number="2295"></td>
        <td id="LC2295">    <span>enum</span> { <span>kInlinedInterfaceInfoThreshhold</span> = <span>sizeof</span>(TADDR) * <span>8</span> };</td>
      </tr>
      <tr>
        <td id="L2296" data-line-number="2296"></td>
        <td id="LC2296">
</td>
      </tr>
      <tr>
        <td id="L2297" data-line-number="2297"></td>
        <td id="LC2297">    <span><span>//</span> Calculate how many bytes of storage will be required to track additional information for interfaces.</span></td>
      </tr>
      <tr>
        <td id="L2298" data-line-number="2298"></td>
        <td id="LC2298">    <span><span>//</span> This will be zero if there are no interfaces, but can also be zero for small numbers of interfaces as</span></td>
      </tr>
      <tr>
        <td id="L2299" data-line-number="2299"></td>
        <td id="LC2299">    <span><span>//</span> well, and callers should be ready to handle this.</span></td>
      </tr>
      <tr>
        <td id="L2300" data-line-number="2300"></td>
        <td id="LC2300">    <span>static</span> SIZE_T <span>GetExtraInterfaceInfoSize</span>(DWORD cInterfaces);</td>
      </tr>
      <tr>
        <td id="L2301" data-line-number="2301"></td>
        <td id="LC2301">
</td>
      </tr>
      <tr>
        <td id="L2302" data-line-number="2302"></td>
        <td id="LC2302">    <span><span>//</span> Called after GetExtraInterfaceInfoSize above to setup a new MethodTable with the additional memory to</span></td>
      </tr>
      <tr>
        <td id="L2303" data-line-number="2303"></td>
        <td id="LC2303">    <span><span>//</span> track extra interface info. If there are a non-zero number of interfaces implemented on this class but</span></td>
      </tr>
      <tr>
        <td id="L2304" data-line-number="2304"></td>
        <td id="LC2304">    <span><span>//</span> GetExtraInterfaceInfoSize() returned zero, this call must still be made (with a NULL argument).</span></td>
      </tr>
      <tr>
        <td id="L2305" data-line-number="2305"></td>
        <td id="LC2305">    <span>void</span> <span>InitializeExtraInterfaceInfo</span>(PVOID pInfo);</td>
      </tr>
      <tr>
        <td id="L2306" data-line-number="2306"></td>
        <td id="LC2306">
</td>
      </tr>
      <tr>
        <td id="L2307" data-line-number="2307"></td>
        <td id="LC2307">#<span>ifdef</span> FEATURE_PREJIT</td>
      </tr>
      <tr>
        <td id="L2308" data-line-number="2308"></td>
        <td id="LC2308">    <span><span>//</span> Ngen support.</span></td>
      </tr>
      <tr>
        <td id="L2309" data-line-number="2309"></td>
        <td id="LC2309">    <span>void</span> <span>SaveExtraInterfaceInfo</span>(DataImage *pImage);</td>
      </tr>
      <tr>
        <td id="L2310" data-line-number="2310"></td>
        <td id="LC2310">    <span>void</span> <span>FixupExtraInterfaceInfo</span>(DataImage *pImage);</td>
      </tr>
      <tr>
        <td id="L2311" data-line-number="2311"></td>
        <td id="LC2311">#<span>endif</span> <span><span>//</span> FEATURE_PREJIT</span></td>
      </tr>
      <tr>
        <td id="L2312" data-line-number="2312"></td>
        <td id="LC2312">
</td>
      </tr>
      <tr>
        <td id="L2313" data-line-number="2313"></td>
        <td id="LC2313">#<span>ifdef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2314" data-line-number="2314"></td>
        <td id="LC2314">    <span>void</span> <span>EnumMemoryRegionsForExtraInterfaceInfo</span>();</td>
      </tr>
      <tr>
        <td id="L2315" data-line-number="2315"></td>
        <td id="LC2315">#<span>endif</span> <span><span>//</span> DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L2316" data-line-number="2316"></td>
        <td id="LC2316">
</td>
      </tr>
      <tr>
        <td id="L2317" data-line-number="2317"></td>
        <td id="LC2317">    <span><span>//</span> For the given interface in the map (specified via map index) mark the interface as declared explicitly</span></td>
      </tr>
      <tr>
        <td id="L2318" data-line-number="2318"></td>
        <td id="LC2318">    <span><span>//</span> on this class. This is not legal for dynamically added interfaces (as used by RCWs).</span></td>
      </tr>
      <tr>
        <td id="L2319" data-line-number="2319"></td>
        <td id="LC2319">    <span>void</span> <span>SetInterfaceDeclaredOnClass</span>(DWORD <span>index</span>);</td>
      </tr>
      <tr>
        <td id="L2320" data-line-number="2320"></td>
        <td id="LC2320">
</td>
      </tr>
      <tr>
        <td id="L2321" data-line-number="2321"></td>
        <td id="LC2321">    <span><span>//</span> For the given interface in the map (specified via map index) return true if the interface was declared</span></td>
      </tr>
      <tr>
        <td id="L2322" data-line-number="2322"></td>
        <td id="LC2322">    <span><span>//</span> explicitly on this class.</span></td>
      </tr>
      <tr>
        <td id="L2323" data-line-number="2323"></td>
        <td id="LC2323">    <span>bool</span> <span>IsInterfaceDeclaredOnClass</span>(DWORD <span>index</span>);</td>
      </tr>
      <tr>
        <td id="L2324" data-line-number="2324"></td>
        <td id="LC2324">
</td>
      </tr>
      <tr>
        <td id="L2325" data-line-number="2325"></td>
        <td id="LC2325">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2326" data-line-number="2326"></td>
        <td id="LC2326">    <span><span>//</span> VIRTUAL/INTERFACE CALL RESOLUTION</span></td>
      </tr>
      <tr>
        <td id="L2327" data-line-number="2327"></td>
        <td id="LC2327">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2328" data-line-number="2328"></td>
        <td id="LC2328">    <span><span>//</span> These should probably go in method.hpp since they don't have</span></td>
      </tr>
      <tr>
        <td id="L2329" data-line-number="2329"></td>
        <td id="LC2329">    <span><span>//</span> much to do with method tables per se.</span></td>
      </tr>
      <tr>
        <td id="L2330" data-line-number="2330"></td>
        <td id="LC2330">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2331" data-line-number="2331"></td>
        <td id="LC2331">
</td>
      </tr>
      <tr>
        <td id="L2332" data-line-number="2332"></td>
        <td id="LC2332">    <span><span>//</span> get the method desc given the interface method desc</span></td>
      </tr>
      <tr>
        <td id="L2333" data-line-number="2333"></td>
        <td id="LC2333">    <span>static</span> MethodDesc *<span>GetMethodDescForInterfaceMethodAndServer</span>(TypeHandle ownerType, MethodDesc *pItfMD, OBJECTREF *pServer);</td>
      </tr>
      <tr>
        <td id="L2334" data-line-number="2334"></td>
        <td id="LC2334">
</td>
      </tr>
      <tr>
        <td id="L2335" data-line-number="2335"></td>
        <td id="LC2335">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L2336" data-line-number="2336"></td>
        <td id="LC2336">    <span><span>//</span> get the method desc given the interface method desc on a COM implemented server (if fNullOk is set then NULL is an allowable return value)</span></td>
      </tr>
      <tr>
        <td id="L2337" data-line-number="2337"></td>
        <td id="LC2337">    MethodDesc *<span>GetMethodDescForComInterfaceMethod</span>(MethodDesc *pItfMD, <span>bool</span> fNullOk);</td>
      </tr>
      <tr>
        <td id="L2338" data-line-number="2338"></td>
        <td id="LC2338">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L2339" data-line-number="2339"></td>
        <td id="LC2339">
</td>
      </tr>
      <tr>
        <td id="L2340" data-line-number="2340"></td>
        <td id="LC2340">
</td>
      </tr>
      <tr>
        <td id="L2341" data-line-number="2341"></td>
        <td id="LC2341">    <span><span>//</span> Try a partial resolve of the constraint call, up to generic code sharing.</span></td>
      </tr>
      <tr>
        <td id="L2342" data-line-number="2342"></td>
        <td id="LC2342">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2343" data-line-number="2343"></td>
        <td id="LC2343">    <span><span>//</span> Note that this will not necessarily resolve the call exactly, since we might be compiling</span></td>
      </tr>
      <tr>
        <td id="L2344" data-line-number="2344"></td>
        <td id="LC2344">    <span><span>//</span> shared generic code - it may just resolve it to a candidate suitable for</span></td>
      </tr>
      <tr>
        <td id="L2345" data-line-number="2345"></td>
        <td id="LC2345">    <span><span>//</span> JIT compilation, and require a runtime lookup for the actual code pointer</span></td>
      </tr>
      <tr>
        <td id="L2346" data-line-number="2346"></td>
        <td id="LC2346">    <span><span>//</span> to call.</span></td>
      </tr>
      <tr>
        <td id="L2347" data-line-number="2347"></td>
        <td id="LC2347">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2348" data-line-number="2348"></td>
        <td id="LC2348">    <span><span>//</span> Return NULL if the call could not be resolved, e.g. because it is invoked</span></td>
      </tr>
      <tr>
        <td id="L2349" data-line-number="2349"></td>
        <td id="LC2349">    <span><span>//</span> on a type that inherits the implementation of the method from System.Object</span></td>
      </tr>
      <tr>
        <td id="L2350" data-line-number="2350"></td>
        <td id="LC2350">    <span><span>//</span> or System.ValueType.</span></td>
      </tr>
      <tr>
        <td id="L2351" data-line-number="2351"></td>
        <td id="LC2351">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2352" data-line-number="2352"></td>
        <td id="LC2352">    <span><span>//</span> Always returns an unboxed entry point with a uniform calling convention.</span></td>
      </tr>
      <tr>
        <td id="L2353" data-line-number="2353"></td>
        <td id="LC2353">    MethodDesc * <span>TryResolveConstraintMethodApprox</span>(</td>
      </tr>
      <tr>
        <td id="L2354" data-line-number="2354"></td>
        <td id="LC2354">        TypeHandle   ownerType,</td>
      </tr>
      <tr>
        <td id="L2355" data-line-number="2355"></td>
        <td id="LC2355">        MethodDesc * pMD,</td>
      </tr>
      <tr>
        <td id="L2356" data-line-number="2356"></td>
        <td id="LC2356">        BOOL *       pfForceUseRuntimeLookup = <span>NULL</span>);</td>
      </tr>
      <tr>
        <td id="L2357" data-line-number="2357"></td>
        <td id="LC2357">
</td>
      </tr>
      <tr>
        <td id="L2358" data-line-number="2358"></td>
        <td id="LC2358">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2359" data-line-number="2359"></td>
        <td id="LC2359">    <span><span>//</span> CONTRACT IMPLEMENTATIONS</span></td>
      </tr>
      <tr>
        <td id="L2360" data-line-number="2360"></td>
        <td id="LC2360">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2361" data-line-number="2361"></td>
        <td id="LC2361">
</td>
      </tr>
      <tr>
        <td id="L2362" data-line-number="2362"></td>
        <td id="LC2362">    <span>inline</span> BOOL <span>HasDispatchMap</span>()</td>
      </tr>
      <tr>
        <td id="L2363" data-line-number="2363"></td>
        <td id="LC2363">    {</td>
      </tr>
      <tr>
        <td id="L2364" data-line-number="2364"></td>
        <td id="LC2364">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2365" data-line-number="2365"></td>
        <td id="LC2365">        <span>return</span> <span>GetDispatchMap</span>() != <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L2366" data-line-number="2366"></td>
        <td id="LC2366">    }</td>
      </tr>
      <tr>
        <td id="L2367" data-line-number="2367"></td>
        <td id="LC2367">
</td>
      </tr>
      <tr>
        <td id="L2368" data-line-number="2368"></td>
        <td id="LC2368">    PTR_DispatchMap <span>GetDispatchMap</span>();</td>
      </tr>
      <tr>
        <td id="L2369" data-line-number="2369"></td>
        <td id="LC2369">
</td>
      </tr>
      <tr>
        <td id="L2370" data-line-number="2370"></td>
        <td id="LC2370">    <span>inline</span> BOOL <span>HasDispatchMapSlot</span>()</td>
      </tr>
      <tr>
        <td id="L2371" data-line-number="2371"></td>
        <td id="LC2371">    {</td>
      </tr>
      <tr>
        <td id="L2372" data-line-number="2372"></td>
        <td id="LC2372">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2373" data-line-number="2373"></td>
        <td id="LC2373">        <span>return</span> <span>GetFlag</span>(enum_flag_HasDispatchMapSlot);</td>
      </tr>
      <tr>
        <td id="L2374" data-line-number="2374"></td>
        <td id="LC2374">    }</td>
      </tr>
      <tr>
        <td id="L2375" data-line-number="2375"></td>
        <td id="LC2375">
</td>
      </tr>
      <tr>
        <td id="L2376" data-line-number="2376"></td>
        <td id="LC2376">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2377" data-line-number="2377"></td>
        <td id="LC2377">    <span>void</span> <span>SetDispatchMap</span>(DispatchMap *pDispatchMap)</td>
      </tr>
      <tr>
        <td id="L2378" data-line-number="2378"></td>
        <td id="LC2378">    {</td>
      </tr>
      <tr>
        <td id="L2379" data-line-number="2379"></td>
        <td id="LC2379">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2380" data-line-number="2380"></td>
        <td id="LC2380">        <span>_ASSERTE</span>(<span>HasDispatchMapSlot</span>());</td>
      </tr>
      <tr>
        <td id="L2381" data-line-number="2381"></td>
        <td id="LC2381">
</td>
      </tr>
      <tr>
        <td id="L2382" data-line-number="2382"></td>
        <td id="LC2382">        TADDR pSlot = <span>GetMultipurposeSlotPtr</span>(enum_flag_HasDispatchMapSlot, c_DispatchMapSlotOffsets);</td>
      </tr>
      <tr>
        <td id="L2383" data-line-number="2383"></td>
        <td id="LC2383">
</td>
      </tr>
      <tr>
        <td id="L2384" data-line-number="2384"></td>
        <td id="LC2384">        RelativePointer&lt;DispatchMap *&gt; *pRelPtr = (RelativePointer&lt;DispatchMap *&gt; *)pSlot;</td>
      </tr>
      <tr>
        <td id="L2385" data-line-number="2385"></td>
        <td id="LC2385">        pRelPtr-&gt;<span>SetValue</span>(pDispatchMap);</td>
      </tr>
      <tr>
        <td id="L2386" data-line-number="2386"></td>
        <td id="LC2386">    }</td>
      </tr>
      <tr>
        <td id="L2387" data-line-number="2387"></td>
        <td id="LC2387">#<span>endif</span> <span><span>//</span> !DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L2388" data-line-number="2388"></td>
        <td id="LC2388">
</td>
      </tr>
      <tr>
        <td id="L2389" data-line-number="2389"></td>
        <td id="LC2389">protected:</td>
      </tr>
      <tr>
        <td id="L2390" data-line-number="2390"></td>
        <td id="LC2390">    BOOL <span>FindEncodedMapDispatchEntry</span>(UINT32 typeID,</td>
      </tr>
      <tr>
        <td id="L2391" data-line-number="2391"></td>
        <td id="LC2391">                                     UINT32 slotNumber,</td>
      </tr>
      <tr>
        <td id="L2392" data-line-number="2392"></td>
        <td id="LC2392">                                     DispatchMapEntry *pEntry);</td>
      </tr>
      <tr>
        <td id="L2393" data-line-number="2393"></td>
        <td id="LC2393">
</td>
      </tr>
      <tr>
        <td id="L2394" data-line-number="2394"></td>
        <td id="LC2394">    BOOL <span>FindIntroducedImplementationTableDispatchEntry</span>(UINT32 slotNumber,</td>
      </tr>
      <tr>
        <td id="L2395" data-line-number="2395"></td>
        <td id="LC2395">                                                        DispatchMapEntry *pEntry,</td>
      </tr>
      <tr>
        <td id="L2396" data-line-number="2396"></td>
        <td id="LC2396">                                                        BOOL fVirtualMethodsOnly);</td>
      </tr>
      <tr>
        <td id="L2397" data-line-number="2397"></td>
        <td id="LC2397">
</td>
      </tr>
      <tr>
        <td id="L2398" data-line-number="2398"></td>
        <td id="LC2398">    BOOL <span>FindDispatchEntryForCurrentType</span>(UINT32 typeID,</td>
      </tr>
      <tr>
        <td id="L2399" data-line-number="2399"></td>
        <td id="LC2399">                                         UINT32 slotNumber,</td>
      </tr>
      <tr>
        <td id="L2400" data-line-number="2400"></td>
        <td id="LC2400">                                         DispatchMapEntry *pEntry);</td>
      </tr>
      <tr>
        <td id="L2401" data-line-number="2401"></td>
        <td id="LC2401">
</td>
      </tr>
      <tr>
        <td id="L2402" data-line-number="2402"></td>
        <td id="LC2402">    BOOL <span>FindDispatchEntry</span>(UINT32 typeID,</td>
      </tr>
      <tr>
        <td id="L2403" data-line-number="2403"></td>
        <td id="LC2403">                           UINT32 slotNumber,</td>
      </tr>
      <tr>
        <td id="L2404" data-line-number="2404"></td>
        <td id="LC2404">                           DispatchMapEntry *pEntry);</td>
      </tr>
      <tr>
        <td id="L2405" data-line-number="2405"></td>
        <td id="LC2405">
</td>
      </tr>
      <tr>
        <td id="L2406" data-line-number="2406"></td>
        <td id="LC2406">private:</td>
      </tr>
      <tr>
        <td id="L2407" data-line-number="2407"></td>
        <td id="LC2407">    BOOL <span>FindDispatchImpl</span>(</td>
      </tr>
      <tr>
        <td id="L2408" data-line-number="2408"></td>
        <td id="LC2408">        UINT32         typeID,</td>
      </tr>
      <tr>
        <td id="L2409" data-line-number="2409"></td>
        <td id="LC2409">        UINT32         slotNumber,</td>
      </tr>
      <tr>
        <td id="L2410" data-line-number="2410"></td>
        <td id="LC2410">        DispatchSlot * pImplSlot,</td>
      </tr>
      <tr>
        <td id="L2411" data-line-number="2411"></td>
        <td id="LC2411">        BOOL           throwOnConflict);</td>
      </tr>
      <tr>
        <td id="L2412" data-line-number="2412"></td>
        <td id="LC2412">
</td>
      </tr>
      <tr>
        <td id="L2413" data-line-number="2413"></td>
        <td id="LC2413">public:</td>
      </tr>
      <tr>
        <td id="L2414" data-line-number="2414"></td>
        <td id="LC2414">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2415" data-line-number="2415"></td>
        <td id="LC2415">    BOOL <span>FindDefaultInterfaceImplementation</span>(</td>
      </tr>
      <tr>
        <td id="L2416" data-line-number="2416"></td>
        <td id="LC2416">        MethodDesc *pInterfaceMD,</td>
      </tr>
      <tr>
        <td id="L2417" data-line-number="2417"></td>
        <td id="LC2417">        MethodTable *pObjectMT,</td>
      </tr>
      <tr>
        <td id="L2418" data-line-number="2418"></td>
        <td id="LC2418">        MethodDesc **ppDefaultMethod,</td>
      </tr>
      <tr>
        <td id="L2419" data-line-number="2419"></td>
        <td id="LC2419">        BOOL allowVariance,</td>
      </tr>
      <tr>
        <td id="L2420" data-line-number="2420"></td>
        <td id="LC2420">        BOOL throwOnConflict);</td>
      </tr>
      <tr>
        <td id="L2421" data-line-number="2421"></td>
        <td id="LC2421">#<span>endif</span> <span><span>//</span> DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L2422" data-line-number="2422"></td>
        <td id="LC2422">
</td>
      </tr>
      <tr>
        <td id="L2423" data-line-number="2423"></td>
        <td id="LC2423">    DispatchSlot <span>FindDispatchSlot</span>(UINT32 typeID, UINT32 slotNumber, BOOL throwOnConflict);</td>
      </tr>
      <tr>
        <td id="L2424" data-line-number="2424"></td>
        <td id="LC2424">
</td>
      </tr>
      <tr>
        <td id="L2425" data-line-number="2425"></td>
        <td id="LC2425">    <span><span>//</span> You must use the second of these two if there is any chance the pMD is a method</span></td>
      </tr>
      <tr>
        <td id="L2426" data-line-number="2426"></td>
        <td id="LC2426">    <span><span>//</span> on a generic interface such as IComparable&lt;T&gt; (which it normally can be).  The</span></td>
      </tr>
      <tr>
        <td id="L2427" data-line-number="2427"></td>
        <td id="LC2427">    <span><span>//</span> ownerType is used to provide an exact qualification in the case the pMD is</span></td>
      </tr>
      <tr>
        <td id="L2428" data-line-number="2428"></td>
        <td id="LC2428">    <span><span>//</span> a shared method descriptor.</span></td>
      </tr>
      <tr>
        <td id="L2429" data-line-number="2429"></td>
        <td id="LC2429">    DispatchSlot <span>FindDispatchSlotForInterfaceMD</span>(MethodDesc *pMD, BOOL throwOnConflict);</td>
      </tr>
      <tr>
        <td id="L2430" data-line-number="2430"></td>
        <td id="LC2430">    DispatchSlot <span>FindDispatchSlotForInterfaceMD</span>(TypeHandle ownerType, MethodDesc *pMD, BOOL throwOnConflict);</td>
      </tr>
      <tr>
        <td id="L2431" data-line-number="2431"></td>
        <td id="LC2431">
</td>
      </tr>
      <tr>
        <td id="L2432" data-line-number="2432"></td>
        <td id="LC2432">    MethodDesc *<span>ReverseInterfaceMDLookup</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L2433" data-line-number="2433"></td>
        <td id="LC2433">
</td>
      </tr>
      <tr>
        <td id="L2434" data-line-number="2434"></td>
        <td id="LC2434">    <span><span>//</span> Lookup, does not assign if not already done.</span></td>
      </tr>
      <tr>
        <td id="L2435" data-line-number="2435"></td>
        <td id="LC2435">    UINT32 <span>LookupTypeID</span>();</td>
      </tr>
      <tr>
        <td id="L2436" data-line-number="2436"></td>
        <td id="LC2436">    <span><span>//</span> Lookup, will assign ID if not already done.</span></td>
      </tr>
      <tr>
        <td id="L2437" data-line-number="2437"></td>
        <td id="LC2437">    UINT32 <span>GetTypeID</span>();</td>
      </tr>
      <tr>
        <td id="L2438" data-line-number="2438"></td>
        <td id="LC2438">
</td>
      </tr>
      <tr>
        <td id="L2439" data-line-number="2439"></td>
        <td id="LC2439">
</td>
      </tr>
      <tr>
        <td id="L2440" data-line-number="2440"></td>
        <td id="LC2440">    MethodTable *<span>LookupDispatchMapType</span>(DispatchMapTypeID typeID);</td>
      </tr>
      <tr>
        <td id="L2441" data-line-number="2441"></td>
        <td id="LC2441">
</td>
      </tr>
      <tr>
        <td id="L2442" data-line-number="2442"></td>
        <td id="LC2442">    MethodDesc *<span>GetIntroducingMethodDesc</span>(DWORD slotNumber);</td>
      </tr>
      <tr>
        <td id="L2443" data-line-number="2443"></td>
        <td id="LC2443">
</td>
      </tr>
      <tr>
        <td id="L2444" data-line-number="2444"></td>
        <td id="LC2444">    <span><span>//</span> Determines whether all methods in the given interface have their final implementing</span></td>
      </tr>
      <tr>
        <td id="L2445" data-line-number="2445"></td>
        <td id="LC2445">    <span><span>//</span> slot in a parent class. I.e. if this returns TRUE, it is trivial (no VSD lookup) to</span></td>
      </tr>
      <tr>
        <td id="L2446" data-line-number="2446"></td>
        <td id="LC2446">    <span><span>//</span> dispatch pItfMT methods on this class if one knows how to dispatch them on pParentMT.</span></td>
      </tr>
      <tr>
        <td id="L2447" data-line-number="2447"></td>
        <td id="LC2447">    BOOL <span>ImplementsInterfaceWithSameSlotsAsParent</span>(MethodTable *pItfMT, MethodTable *pParentMT);</td>
      </tr>
      <tr>
        <td id="L2448" data-line-number="2448"></td>
        <td id="LC2448">
</td>
      </tr>
      <tr>
        <td id="L2449" data-line-number="2449"></td>
        <td id="LC2449">    <span><span>//</span> Determines whether all methods in the given interface have their final implementation</span></td>
      </tr>
      <tr>
        <td id="L2450" data-line-number="2450"></td>
        <td id="LC2450">    <span><span>//</span> in a parent class. I.e. if this returns TRUE, this class behaves the same as pParentMT</span></td>
      </tr>
      <tr>
        <td id="L2451" data-line-number="2451"></td>
        <td id="LC2451">    <span><span>//</span> when it comes to dispatching pItfMT methods.</span></td>
      </tr>
      <tr>
        <td id="L2452" data-line-number="2452"></td>
        <td id="LC2452">    BOOL <span>HasSameInterfaceImplementationAsParent</span>(MethodTable *pItfMT, MethodTable *pParentMT);</td>
      </tr>
      <tr>
        <td id="L2453" data-line-number="2453"></td>
        <td id="LC2453">
</td>
      </tr>
      <tr>
        <td id="L2454" data-line-number="2454"></td>
        <td id="LC2454">public:</td>
      </tr>
      <tr>
        <td id="L2455" data-line-number="2455"></td>
        <td id="LC2455">    <span>static</span> MethodDesc *<span>MapMethodDeclToMethodImpl</span>(MethodDesc *pMDDecl);</td>
      </tr>
      <tr>
        <td id="L2456" data-line-number="2456"></td>
        <td id="LC2456">
</td>
      </tr>
      <tr>
        <td id="L2457" data-line-number="2457"></td>
        <td id="LC2457">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2458" data-line-number="2458"></td>
        <td id="LC2458">    <span><span>//</span> FINALIZATION SEMANTICS</span></td>
      </tr>
      <tr>
        <td id="L2459" data-line-number="2459"></td>
        <td id="LC2459">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2460" data-line-number="2460"></td>
        <td id="LC2460">
</td>
      </tr>
      <tr>
        <td id="L2461" data-line-number="2461"></td>
        <td id="LC2461">    DWORD  <span>CannotUseSuperFastHelper</span>()</td>
      </tr>
      <tr>
        <td id="L2462" data-line-number="2462"></td>
        <td id="LC2462">    {</td>
      </tr>
      <tr>
        <td id="L2463" data-line-number="2463"></td>
        <td id="LC2463">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2464" data-line-number="2464"></td>
        <td id="LC2464">        <span>return</span> <span>HasFinalizer</span>();</td>
      </tr>
      <tr>
        <td id="L2465" data-line-number="2465"></td>
        <td id="LC2465">    }</td>
      </tr>
      <tr>
        <td id="L2466" data-line-number="2466"></td>
        <td id="LC2466">
</td>
      </tr>
      <tr>
        <td id="L2467" data-line-number="2467"></td>
        <td id="LC2467">    <span>void</span> <span>SetHasFinalizer</span>()</td>
      </tr>
      <tr>
        <td id="L2468" data-line-number="2468"></td>
        <td id="LC2468">    {</td>
      </tr>
      <tr>
        <td id="L2469" data-line-number="2469"></td>
        <td id="LC2469">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2470" data-line-number="2470"></td>
        <td id="LC2470">        <span>SetFlag</span>(enum_flag_HasFinalizer);</td>
      </tr>
      <tr>
        <td id="L2471" data-line-number="2471"></td>
        <td id="LC2471">    }</td>
      </tr>
      <tr>
        <td id="L2472" data-line-number="2472"></td>
        <td id="LC2472">
</td>
      </tr>
      <tr>
        <td id="L2473" data-line-number="2473"></td>
        <td id="LC2473">    <span>void</span> <span>SetHasCriticalFinalizer</span>()</td>
      </tr>
      <tr>
        <td id="L2474" data-line-number="2474"></td>
        <td id="LC2474">    {</td>
      </tr>
      <tr>
        <td id="L2475" data-line-number="2475"></td>
        <td id="LC2475">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2476" data-line-number="2476"></td>
        <td id="LC2476">        <span>SetFlag</span>(enum_flag_HasCriticalFinalizer);</td>
      </tr>
      <tr>
        <td id="L2477" data-line-number="2477"></td>
        <td id="LC2477">    }</td>
      </tr>
      <tr>
        <td id="L2478" data-line-number="2478"></td>
        <td id="LC2478">    <span><span>//</span> Does this class have non-trivial finalization requirements?</span></td>
      </tr>
      <tr>
        <td id="L2479" data-line-number="2479"></td>
        <td id="LC2479">    DWORD <span>HasFinalizer</span>()</td>
      </tr>
      <tr>
        <td id="L2480" data-line-number="2480"></td>
        <td id="LC2480">    {</td>
      </tr>
      <tr>
        <td id="L2481" data-line-number="2481"></td>
        <td id="LC2481">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2482" data-line-number="2482"></td>
        <td id="LC2482">        <span>return</span> <span>GetFlag</span>(enum_flag_HasFinalizer);</td>
      </tr>
      <tr>
        <td id="L2483" data-line-number="2483"></td>
        <td id="LC2483">    }</td>
      </tr>
      <tr>
        <td id="L2484" data-line-number="2484"></td>
        <td id="LC2484">    <span><span>//</span> Must this class be finalized during a rude appdomain unload, and</span></td>
      </tr>
      <tr>
        <td id="L2485" data-line-number="2485"></td>
        <td id="LC2485">    <span><span>//</span> must it's finalizer run in a different order from normal finalizers?</span></td>
      </tr>
      <tr>
        <td id="L2486" data-line-number="2486"></td>
        <td id="LC2486">    DWORD <span>HasCriticalFinalizer</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L2487" data-line-number="2487"></td>
        <td id="LC2487">    {</td>
      </tr>
      <tr>
        <td id="L2488" data-line-number="2488"></td>
        <td id="LC2488">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2489" data-line-number="2489"></td>
        <td id="LC2489">        <span>return</span> <span>GetFlag</span>(enum_flag_HasCriticalFinalizer);</td>
      </tr>
      <tr>
        <td id="L2490" data-line-number="2490"></td>
        <td id="LC2490">    }</td>
      </tr>
      <tr>
        <td id="L2491" data-line-number="2491"></td>
        <td id="LC2491">
</td>
      </tr>
      <tr>
        <td id="L2492" data-line-number="2492"></td>
        <td id="LC2492">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2493" data-line-number="2493"></td>
        <td id="LC2493">    <span><span>//</span> STATIC FIELDS</span></td>
      </tr>
      <tr>
        <td id="L2494" data-line-number="2494"></td>
        <td id="LC2494">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2495" data-line-number="2495"></td>
        <td id="LC2495">
</td>
      </tr>
      <tr>
        <td id="L2496" data-line-number="2496"></td>
        <td id="LC2496">    DWORD  <span>GetOffsetOfFirstStaticHandle</span>();</td>
      </tr>
      <tr>
        <td id="L2497" data-line-number="2497"></td>
        <td id="LC2497">    DWORD  <span>GetOffsetOfFirstStaticMT</span>();</td>
      </tr>
      <tr>
        <td id="L2498" data-line-number="2498"></td>
        <td id="LC2498">
</td>
      </tr>
      <tr>
        <td id="L2499" data-line-number="2499"></td>
        <td id="LC2499">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2500" data-line-number="2500"></td>
        <td id="LC2500">    <span>inline</span> PTR_BYTE <span>GetNonGCStaticsBasePointer</span>();</td>
      </tr>
      <tr>
        <td id="L2501" data-line-number="2501"></td>
        <td id="LC2501">    <span>inline</span> PTR_BYTE <span>GetGCStaticsBasePointer</span>();</td>
      </tr>
      <tr>
        <td id="L2502" data-line-number="2502"></td>
        <td id="LC2502">    <span>inline</span> PTR_BYTE <span>GetNonGCThreadStaticsBasePointer</span>();</td>
      </tr>
      <tr>
        <td id="L2503" data-line-number="2503"></td>
        <td id="LC2503">    <span>inline</span> PTR_BYTE <span>GetGCThreadStaticsBasePointer</span>();</td>
      </tr>
      <tr>
        <td id="L2504" data-line-number="2504"></td>
        <td id="LC2504">#<span>endif</span> <span><span>//</span>!DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L2505" data-line-number="2505"></td>
        <td id="LC2505">
</td>
      </tr>
      <tr>
        <td id="L2506" data-line-number="2506"></td>
        <td id="LC2506">    <span>inline</span> PTR_BYTE <span>GetNonGCThreadStaticsBasePointer</span>(PTR_Thread pThread);</td>
      </tr>
      <tr>
        <td id="L2507" data-line-number="2507"></td>
        <td id="LC2507">    <span>inline</span> PTR_BYTE <span>GetGCThreadStaticsBasePointer</span>(PTR_Thread pThread);</td>
      </tr>
      <tr>
        <td id="L2508" data-line-number="2508"></td>
        <td id="LC2508">
</td>
      </tr>
      <tr>
        <td id="L2509" data-line-number="2509"></td>
        <td id="LC2509">    <span>inline</span> DWORD <span>IsDynamicStatics</span>()</td>
      </tr>
      <tr>
        <td id="L2510" data-line-number="2510"></td>
        <td id="LC2510">    {</td>
      </tr>
      <tr>
        <td id="L2511" data-line-number="2511"></td>
        <td id="LC2511">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2512" data-line-number="2512"></td>
        <td id="LC2512">        <span>return</span> !<span>TestFlagWithMask</span>(enum_flag_StaticsMask, enum_flag_StaticsMask_NonDynamic);</td>
      </tr>
      <tr>
        <td id="L2513" data-line-number="2513"></td>
        <td id="LC2513">    }</td>
      </tr>
      <tr>
        <td id="L2514" data-line-number="2514"></td>
        <td id="LC2514">
</td>
      </tr>
      <tr>
        <td id="L2515" data-line-number="2515"></td>
        <td id="LC2515">    <span>inline</span> <span>void</span> <span>SetDynamicStatics</span>(BOOL fGeneric)</td>
      </tr>
      <tr>
        <td id="L2516" data-line-number="2516"></td>
        <td id="LC2516">    {</td>
      </tr>
      <tr>
        <td id="L2517" data-line-number="2517"></td>
        <td id="LC2517">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2518" data-line-number="2518"></td>
        <td id="LC2518">        <span>SetFlag</span>(fGeneric ? enum_flag_StaticsMask_Generics : enum_flag_StaticsMask_Dynamic);</td>
      </tr>
      <tr>
        <td id="L2519" data-line-number="2519"></td>
        <td id="LC2519">    }</td>
      </tr>
      <tr>
        <td id="L2520" data-line-number="2520"></td>
        <td id="LC2520">
</td>
      </tr>
      <tr>
        <td id="L2521" data-line-number="2521"></td>
        <td id="LC2521">    <span>inline</span> <span>void</span> <span>SetHasBoxedRegularStatics</span>()</td>
      </tr>
      <tr>
        <td id="L2522" data-line-number="2522"></td>
        <td id="LC2522">    {</td>
      </tr>
      <tr>
        <td id="L2523" data-line-number="2523"></td>
        <td id="LC2523">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2524" data-line-number="2524"></td>
        <td id="LC2524">        <span>SetFlag</span>(enum_flag_HasBoxedRegularStatics);</td>
      </tr>
      <tr>
        <td id="L2525" data-line-number="2525"></td>
        <td id="LC2525">    }</td>
      </tr>
      <tr>
        <td id="L2526" data-line-number="2526"></td>
        <td id="LC2526">
</td>
      </tr>
      <tr>
        <td id="L2527" data-line-number="2527"></td>
        <td id="LC2527">    <span>inline</span> DWORD <span>HasBoxedRegularStatics</span>()</td>
      </tr>
      <tr>
        <td id="L2528" data-line-number="2528"></td>
        <td id="LC2528">    {</td>
      </tr>
      <tr>
        <td id="L2529" data-line-number="2529"></td>
        <td id="LC2529">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2530" data-line-number="2530"></td>
        <td id="LC2530">        <span>return</span> <span>GetFlag</span>(enum_flag_HasBoxedRegularStatics);</td>
      </tr>
      <tr>
        <td id="L2531" data-line-number="2531"></td>
        <td id="LC2531">    }</td>
      </tr>
      <tr>
        <td id="L2532" data-line-number="2532"></td>
        <td id="LC2532">
</td>
      </tr>
      <tr>
        <td id="L2533" data-line-number="2533"></td>
        <td id="LC2533">    DWORD <span>HasFixedAddressVTStatics</span>();</td>
      </tr>
      <tr>
        <td id="L2534" data-line-number="2534"></td>
        <td id="LC2534">
</td>
      </tr>
      <tr>
        <td id="L2535" data-line-number="2535"></td>
        <td id="LC2535">    <span><span>//</span> Indicates if the MethodTable only contains abstract methods</span></td>
      </tr>
      <tr>
        <td id="L2536" data-line-number="2536"></td>
        <td id="LC2536">    BOOL <span>HasOnlyAbstractMethods</span>();</td>
      </tr>
      <tr>
        <td id="L2537" data-line-number="2537"></td>
        <td id="LC2537">
</td>
      </tr>
      <tr>
        <td id="L2538" data-line-number="2538"></td>
        <td id="LC2538">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2539" data-line-number="2539"></td>
        <td id="LC2539">    <span><span>//</span> PER-INSTANTIATION STATICS INFO</span></td>
      </tr>
      <tr>
        <td id="L2540" data-line-number="2540"></td>
        <td id="LC2540">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2541" data-line-number="2541"></td>
        <td id="LC2541">
</td>
      </tr>
      <tr>
        <td id="L2542" data-line-number="2542"></td>
        <td id="LC2542">
</td>
      </tr>
      <tr>
        <td id="L2543" data-line-number="2543"></td>
        <td id="LC2543">    <span>void</span> <span>SetupGenericsStaticsInfo</span>(FieldDesc* pStaticFieldDescs);</td>
      </tr>
      <tr>
        <td id="L2544" data-line-number="2544"></td>
        <td id="LC2544">
</td>
      </tr>
      <tr>
        <td id="L2545" data-line-number="2545"></td>
        <td id="LC2545">    BOOL <span>HasGenericsStaticsInfo</span>()</td>
      </tr>
      <tr>
        <td id="L2546" data-line-number="2546"></td>
        <td id="LC2546">    {</td>
      </tr>
      <tr>
        <td id="L2547" data-line-number="2547"></td>
        <td id="LC2547">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2548" data-line-number="2548"></td>
        <td id="LC2548">        <span>return</span> <span>GetFlag</span>(enum_flag_StaticsMask_Generics);</td>
      </tr>
      <tr>
        <td id="L2549" data-line-number="2549"></td>
        <td id="LC2549">    }</td>
      </tr>
      <tr>
        <td id="L2550" data-line-number="2550"></td>
        <td id="LC2550">
</td>
      </tr>
      <tr>
        <td id="L2551" data-line-number="2551"></td>
        <td id="LC2551">    PTR_FieldDesc <span>GetGenericsStaticFieldDescs</span>()</td>
      </tr>
      <tr>
        <td id="L2552" data-line-number="2552"></td>
        <td id="LC2552">    {</td>
      </tr>
      <tr>
        <td id="L2553" data-line-number="2553"></td>
        <td id="LC2553">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2554" data-line-number="2554"></td>
        <td id="LC2554">        <span>_ASSERTE</span>(<span>HasGenericsStaticsInfo</span>());</td>
      </tr>
      <tr>
        <td id="L2555" data-line-number="2555"></td>
        <td id="LC2555">        <span>return</span> <span>ReadPointerMaybeNull</span>((GenericsStaticsInfo *)<span>GetGenericsStaticsInfo</span>(), &amp;GenericsStaticsInfo::m_pFieldDescs);</td>
      </tr>
      <tr>
        <td id="L2556" data-line-number="2556"></td>
        <td id="LC2556">    }</td>
      </tr>
      <tr>
        <td id="L2557" data-line-number="2557"></td>
        <td id="LC2557">
</td>
      </tr>
      <tr>
        <td id="L2558" data-line-number="2558"></td>
        <td id="LC2558">    BOOL <span>HasCrossModuleGenericStaticsInfo</span>()</td>
      </tr>
      <tr>
        <td id="L2559" data-line-number="2559"></td>
        <td id="LC2559">    {</td>
      </tr>
      <tr>
        <td id="L2560" data-line-number="2560"></td>
        <td id="LC2560">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2561" data-line-number="2561"></td>
        <td id="LC2561">        <span>return</span> <span>TestFlagWithMask</span>(enum_flag_StaticsMask, enum_flag_StaticsMask_CrossModuleGenerics);</td>
      </tr>
      <tr>
        <td id="L2562" data-line-number="2562"></td>
        <td id="LC2562">    }</td>
      </tr>
      <tr>
        <td id="L2563" data-line-number="2563"></td>
        <td id="LC2563">
</td>
      </tr>
      <tr>
        <td id="L2564" data-line-number="2564"></td>
        <td id="LC2564">    PTR_Module <span>GetGenericsStaticsModuleAndID</span>(DWORD * pID);</td>
      </tr>
      <tr>
        <td id="L2565" data-line-number="2565"></td>
        <td id="LC2565">
</td>
      </tr>
      <tr>
        <td id="L2566" data-line-number="2566"></td>
        <td id="LC2566">    WORD <span>GetNumHandleRegularStatics</span>();</td>
      </tr>
      <tr>
        <td id="L2567" data-line-number="2567"></td>
        <td id="LC2567">
</td>
      </tr>
      <tr>
        <td id="L2568" data-line-number="2568"></td>
        <td id="LC2568">    WORD <span>GetNumBoxedRegularStatics</span> ();</td>
      </tr>
      <tr>
        <td id="L2569" data-line-number="2569"></td>
        <td id="LC2569">    WORD <span>GetNumBoxedThreadStatics</span> ();</td>
      </tr>
      <tr>
        <td id="L2570" data-line-number="2570"></td>
        <td id="LC2570">
</td>
      </tr>
      <tr>
        <td id="L2571" data-line-number="2571"></td>
        <td id="LC2571">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2572" data-line-number="2572"></td>
        <td id="LC2572">    <span><span>//</span> DYNAMIC ID</span></td>
      </tr>
      <tr>
        <td id="L2573" data-line-number="2573"></td>
        <td id="LC2573">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2574" data-line-number="2574"></td>
        <td id="LC2574">
</td>
      </tr>
      <tr>
        <td id="L2575" data-line-number="2575"></td>
        <td id="LC2575">    <span><span>//</span> Used for generics and reflection emit in memory</span></td>
      </tr>
      <tr>
        <td id="L2576" data-line-number="2576"></td>
        <td id="LC2576">    DWORD <span>GetModuleDynamicEntryID</span>();</td>
      </tr>
      <tr>
        <td id="L2577" data-line-number="2577"></td>
        <td id="LC2577">    Module* <span>GetModuleForStatics</span>();</td>
      </tr>
      <tr>
        <td id="L2578" data-line-number="2578"></td>
        <td id="LC2578">
</td>
      </tr>
      <tr>
        <td id="L2579" data-line-number="2579"></td>
        <td id="LC2579">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2580" data-line-number="2580"></td>
        <td id="LC2580">    <span><span>//</span> GENERICS DICT INFO</span></td>
      </tr>
      <tr>
        <td id="L2581" data-line-number="2581"></td>
        <td id="LC2581">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2582" data-line-number="2582"></td>
        <td id="LC2582">
</td>
      </tr>
      <tr>
        <td id="L2583" data-line-number="2583"></td>
        <td id="LC2583">    <span><span>//</span> Number of generic arguments, whether this is a method table for</span></td>
      </tr>
      <tr>
        <td id="L2584" data-line-number="2584"></td>
        <td id="LC2584">    <span><span>//</span> a generic type instantiation, e.g. List&lt;string&gt; or the "generic" MethodTable</span></td>
      </tr>
      <tr>
        <td id="L2585" data-line-number="2585"></td>
        <td id="LC2585">    <span><span>//</span> e.g. for List.</span></td>
      </tr>
      <tr>
        <td id="L2586" data-line-number="2586"></td>
        <td id="LC2586">    <span>inline</span> DWORD <span>GetNumGenericArgs</span>()</td>
      </tr>
      <tr>
        <td id="L2587" data-line-number="2587"></td>
        <td id="LC2587">    {</td>
      </tr>
      <tr>
        <td id="L2588" data-line-number="2588"></td>
        <td id="LC2588">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2589" data-line-number="2589"></td>
        <td id="LC2589">        <span>if</span> (<span>HasInstantiation</span>())</td>
      </tr>
      <tr>
        <td id="L2590" data-line-number="2590"></td>
        <td id="LC2590">            <span>return</span> (DWORD) (<span>GetGenericsDictInfo</span>()-&gt;<span>m_wNumTyPars</span>);</td>
      </tr>
      <tr>
        <td id="L2591" data-line-number="2591"></td>
        <td id="LC2591">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L2592" data-line-number="2592"></td>
        <td id="LC2592">            <span>return</span> <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2593" data-line-number="2593"></td>
        <td id="LC2593">    }</td>
      </tr>
      <tr>
        <td id="L2594" data-line-number="2594"></td>
        <td id="LC2594">
</td>
      </tr>
      <tr>
        <td id="L2595" data-line-number="2595"></td>
        <td id="LC2595">    <span>inline</span> DWORD <span>GetNumDicts</span>()</td>
      </tr>
      <tr>
        <td id="L2596" data-line-number="2596"></td>
        <td id="LC2596">    {</td>
      </tr>
      <tr>
        <td id="L2597" data-line-number="2597"></td>
        <td id="LC2597">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2598" data-line-number="2598"></td>
        <td id="LC2598">        <span>if</span> (<span>HasPerInstInfo</span>())</td>
      </tr>
      <tr>
        <td id="L2599" data-line-number="2599"></td>
        <td id="LC2599">        {</td>
      </tr>
      <tr>
        <td id="L2600" data-line-number="2600"></td>
        <td id="LC2600">            PTR_GenericsDictInfo  pDictInfo = <span>GetGenericsDictInfo</span>();</td>
      </tr>
      <tr>
        <td id="L2601" data-line-number="2601"></td>
        <td id="LC2601">            <span>return</span> (DWORD) (pDictInfo-&gt;<span>m_wNumDicts</span>);</td>
      </tr>
      <tr>
        <td id="L2602" data-line-number="2602"></td>
        <td id="LC2602">        }</td>
      </tr>
      <tr>
        <td id="L2603" data-line-number="2603"></td>
        <td id="LC2603">        <span>else</span></td>
      </tr>
      <tr>
        <td id="L2604" data-line-number="2604"></td>
        <td id="LC2604">            <span>return</span> <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L2605" data-line-number="2605"></td>
        <td id="LC2605">    }</td>
      </tr>
      <tr>
        <td id="L2606" data-line-number="2606"></td>
        <td id="LC2606">
</td>
      </tr>
      <tr>
        <td id="L2607" data-line-number="2607"></td>
        <td id="LC2607">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2608" data-line-number="2608"></td>
        <td id="LC2608">    <span><span>//</span> OBJECTS</span></td>
      </tr>
      <tr>
        <td id="L2609" data-line-number="2609"></td>
        <td id="LC2609">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2610" data-line-number="2610"></td>
        <td id="LC2610">
</td>
      </tr>
      <tr>
        <td id="L2611" data-line-number="2611"></td>
        <td id="LC2611">    OBJECTREF <span>Allocate</span>();</td>
      </tr>
      <tr>
        <td id="L2612" data-line-number="2612"></td>
        <td id="LC2612">
</td>
      </tr>
      <tr>
        <td id="L2613" data-line-number="2613"></td>
        <td id="LC2613">    <span><span>//</span> This flavor of Allocate is more efficient, but can only be used</span></td>
      </tr>
      <tr>
        <td id="L2614" data-line-number="2614"></td>
        <td id="LC2614">    <span><span>//</span> if IsRestored(), CheckInstanceActivated(), IsClassInited() are known to be true.</span></td>
      </tr>
      <tr>
        <td id="L2615" data-line-number="2615"></td>
        <td id="LC2615">    <span><span>//</span> A sufficient condition is that another instance of the exact same type already</span></td>
      </tr>
      <tr>
        <td id="L2616" data-line-number="2616"></td>
        <td id="LC2616">    <span><span>//</span> exists in the same appdomain. It's currently called only from Delegate.Combine</span></td>
      </tr>
      <tr>
        <td id="L2617" data-line-number="2617"></td>
        <td id="LC2617">    <span><span>//</span> via COMDelegate::InternalAllocLike.</span></td>
      </tr>
      <tr>
        <td id="L2618" data-line-number="2618"></td>
        <td id="LC2618">    OBJECTREF <span>AllocateNoChecks</span>();</td>
      </tr>
      <tr>
        <td id="L2619" data-line-number="2619"></td>
        <td id="LC2619">
</td>
      </tr>
      <tr>
        <td id="L2620" data-line-number="2620"></td>
        <td id="LC2620">    OBJECTREF <span>Box</span>(<span>void</span>* data);</td>
      </tr>
      <tr>
        <td id="L2621" data-line-number="2621"></td>
        <td id="LC2621">    OBJECTREF <span>FastBox</span>(<span>void</span>** data);</td>
      </tr>
      <tr>
        <td id="L2622" data-line-number="2622"></td>
        <td id="LC2622">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2623" data-line-number="2623"></td>
        <td id="LC2623">    BOOL <span>UnBoxInto</span>(<span>void</span> *dest, OBJECTREF src);</td>
      </tr>
      <tr>
        <td id="L2624" data-line-number="2624"></td>
        <td id="LC2624">    BOOL <span>UnBoxIntoArg</span>(ArgDestination *argDest, OBJECTREF src);</td>
      </tr>
      <tr>
        <td id="L2625" data-line-number="2625"></td>
        <td id="LC2625">    <span>void</span> <span>UnBoxIntoUnchecked</span>(<span>void</span> *dest, OBJECTREF src);</td>
      </tr>
      <tr>
        <td id="L2626" data-line-number="2626"></td>
        <td id="LC2626">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2627" data-line-number="2627"></td>
        <td id="LC2627">
</td>
      </tr>
      <tr>
        <td id="L2628" data-line-number="2628"></td>
        <td id="LC2628">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L2629" data-line-number="2629"></td>
        <td id="LC2629">    <span><span>//</span> Used for debugging class layout. Dumps to the debug console</span></td>
      </tr>
      <tr>
        <td id="L2630" data-line-number="2630"></td>
        <td id="LC2630">    <span><span>//</span> when debug is true.</span></td>
      </tr>
      <tr>
        <td id="L2631" data-line-number="2631"></td>
        <td id="LC2631">    <span>void</span> <span>DebugDumpVtable</span>(LPCUTF8 szClassName, BOOL fDebug);</td>
      </tr>
      <tr>
        <td id="L2632" data-line-number="2632"></td>
        <td id="LC2632">    <span>void</span> <span>Debug_DumpInterfaceMap</span>(LPCSTR szInterfaceMapPrefix);</td>
      </tr>
      <tr>
        <td id="L2633" data-line-number="2633"></td>
        <td id="LC2633">    <span>void</span> <span>Debug_DumpDispatchMap</span>();</td>
      </tr>
      <tr>
        <td id="L2634" data-line-number="2634"></td>
        <td id="LC2634">    <span>void</span> <span>DebugDumpFieldLayout</span>(LPCUTF8 pszClassName, BOOL debug);</td>
      </tr>
      <tr>
        <td id="L2635" data-line-number="2635"></td>
        <td id="LC2635">    <span>void</span> <span>DebugRecursivelyDumpInstanceFields</span>(LPCUTF8 pszClassName, BOOL debug);</td>
      </tr>
      <tr>
        <td id="L2636" data-line-number="2636"></td>
        <td id="LC2636">    <span>void</span> <span>DebugDumpGCDesc</span>(LPCUTF8 pszClassName, BOOL debug);</td>
      </tr>
      <tr>
        <td id="L2637" data-line-number="2637"></td>
        <td id="LC2637">#<span>endif</span> <span><span>//</span>_DEBUG</span></td>
      </tr>
      <tr>
        <td id="L2638" data-line-number="2638"></td>
        <td id="LC2638">
</td>
      </tr>
      <tr>
        <td id="L2639" data-line-number="2639"></td>
        <td id="LC2639">    <span>inline</span> BOOL <span>IsAgileAndFinalizable</span>()</td>
      </tr>
      <tr>
        <td id="L2640" data-line-number="2640"></td>
        <td id="LC2640">    {</td>
      </tr>
      <tr>
        <td id="L2641" data-line-number="2641"></td>
        <td id="LC2641">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2642" data-line-number="2642"></td>
        <td id="LC2642">        <span><span>//</span> Right now, System.Thread is the only cases of this.</span></td>
      </tr>
      <tr>
        <td id="L2643" data-line-number="2643"></td>
        <td id="LC2643">        <span><span>//</span> Things should stay this way - please don't change without talking to EE team.</span></td>
      </tr>
      <tr>
        <td id="L2644" data-line-number="2644"></td>
        <td id="LC2644">        <span>return</span> this == g_pThreadClass;</td>
      </tr>
      <tr>
        <td id="L2645" data-line-number="2645"></td>
        <td id="LC2645">    }</td>
      </tr>
      <tr>
        <td id="L2646" data-line-number="2646"></td>
        <td id="LC2646">
</td>
      </tr>
      <tr>
        <td id="L2647" data-line-number="2647"></td>
        <td id="LC2647">
</td>
      </tr>
      <tr>
        <td id="L2648" data-line-number="2648"></td>
        <td id="LC2648">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2649" data-line-number="2649"></td>
        <td id="LC2649">    <span><span>//</span> ENUMS, DELEGATES, VALUE TYPES, ARRAYS</span></td>
      </tr>
      <tr>
        <td id="L2650" data-line-number="2650"></td>
        <td id="LC2650">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2651" data-line-number="2651"></td>
        <td id="LC2651">    <span><span>//</span> #KindsOfElementTypes</span></td>
      </tr>
      <tr>
        <td id="L2652" data-line-number="2652"></td>
        <td id="LC2652">    <span><span>//</span> GetInternalCorElementType() retrieves the internal representation of the type. It's not always</span></td>
      </tr>
      <tr>
        <td id="L2653" data-line-number="2653"></td>
        <td id="LC2653">    <span><span>//</span> appropiate to use this. For example, we treat enums as their underlying type or some structs are</span></td>
      </tr>
      <tr>
        <td id="L2654" data-line-number="2654"></td>
        <td id="LC2654">    <span><span>//</span> optimized to be ints. To get the signature type or the verifier type (same as signature except for</span></td>
      </tr>
      <tr>
        <td id="L2655" data-line-number="2655"></td>
        <td id="LC2655">    <span><span>//</span> enums are normalized to the primtive type that underlies them), use the APIs in Typehandle.h</span></td>
      </tr>
      <tr>
        <td id="L2656" data-line-number="2656"></td>
        <td id="LC2656">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2657" data-line-number="2657"></td>
        <td id="LC2657">    <span><span>//</span>   * code:TypeHandle.GetSignatureCorElementType()</span></td>
      </tr>
      <tr>
        <td id="L2658" data-line-number="2658"></td>
        <td id="LC2658">    <span><span>//</span>   * code:TypeHandle.GetVerifierCorElementType()</span></td>
      </tr>
      <tr>
        <td id="L2659" data-line-number="2659"></td>
        <td id="LC2659">    <span><span>//</span>   * code:TypeHandle.GetInternalCorElementType()</span></td>
      </tr>
      <tr>
        <td id="L2660" data-line-number="2660"></td>
        <td id="LC2660">    CorElementType <span>GetInternalCorElementType</span>();</td>
      </tr>
      <tr>
        <td id="L2661" data-line-number="2661"></td>
        <td id="LC2661">    <span>void</span> <span>SetInternalCorElementType</span>(CorElementType _NormType);</td>
      </tr>
      <tr>
        <td id="L2662" data-line-number="2662"></td>
        <td id="LC2662">
</td>
      </tr>
      <tr>
        <td id="L2663" data-line-number="2663"></td>
        <td id="LC2663">    <span><span>//</span> See code:TypeHandle::GetVerifierCorElementType for description</span></td>
      </tr>
      <tr>
        <td id="L2664" data-line-number="2664"></td>
        <td id="LC2664">    CorElementType <span>GetVerifierCorElementType</span>();</td>
      </tr>
      <tr>
        <td id="L2665" data-line-number="2665"></td>
        <td id="LC2665">
</td>
      </tr>
      <tr>
        <td id="L2666" data-line-number="2666"></td>
        <td id="LC2666">    <span><span>//</span> See code:TypeHandle::GetSignatureCorElementType for description</span></td>
      </tr>
      <tr>
        <td id="L2667" data-line-number="2667"></td>
        <td id="LC2667">    CorElementType <span>GetSignatureCorElementType</span>();</td>
      </tr>
      <tr>
        <td id="L2668" data-line-number="2668"></td>
        <td id="LC2668">
</td>
      </tr>
      <tr>
        <td id="L2669" data-line-number="2669"></td>
        <td id="LC2669">    <span><span>//</span> A true primitive is one who's GetVerifierCorElementType() ==</span></td>
      </tr>
      <tr>
        <td id="L2670" data-line-number="2670"></td>
        <td id="LC2670">    <span><span>//</span>      ELEMENT_TYPE_I,</span></td>
      </tr>
      <tr>
        <td id="L2671" data-line-number="2671"></td>
        <td id="LC2671">    <span><span>//</span>      ELEMENT_TYPE_I4,</span></td>
      </tr>
      <tr>
        <td id="L2672" data-line-number="2672"></td>
        <td id="LC2672">    <span><span>//</span>      ELEMENT_TYPE_TYPEDBYREF etc.</span></td>
      </tr>
      <tr>
        <td id="L2673" data-line-number="2673"></td>
        <td id="LC2673">    <span><span>//</span> Note that GetIntenalCorElementType might return these same values for some additional</span></td>
      </tr>
      <tr>
        <td id="L2674" data-line-number="2674"></td>
        <td id="LC2674">    <span><span>//</span> types such as Enums and some structs.</span></td>
      </tr>
      <tr>
        <td id="L2675" data-line-number="2675"></td>
        <td id="LC2675">    BOOL <span>IsTruePrimitive</span>();</td>
      </tr>
      <tr>
        <td id="L2676" data-line-number="2676"></td>
        <td id="LC2676">    <span>void</span> <span>SetIsTruePrimitive</span>();</td>
      </tr>
      <tr>
        <td id="L2677" data-line-number="2677"></td>
        <td id="LC2677">
</td>
      </tr>
      <tr>
        <td id="L2678" data-line-number="2678"></td>
        <td id="LC2678">    <span><span>//</span> Is this delegate? Returns false for System.Delegate and System.MulticastDelegate.</span></td>
      </tr>
      <tr>
        <td id="L2679" data-line-number="2679"></td>
        <td id="LC2679">    <span>inline</span> BOOL <span>IsDelegate</span>()</td>
      </tr>
      <tr>
        <td id="L2680" data-line-number="2680"></td>
        <td id="LC2680">    {</td>
      </tr>
      <tr>
        <td id="L2681" data-line-number="2681"></td>
        <td id="LC2681">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2682" data-line-number="2682"></td>
        <td id="LC2682">        <span><span>//</span> We do not allow single cast delegates anymore, just check for multicast delegate</span></td>
      </tr>
      <tr>
        <td id="L2683" data-line-number="2683"></td>
        <td id="LC2683">        <span>_ASSERTE</span>(g_pMulticastDelegateClass);</td>
      </tr>
      <tr>
        <td id="L2684" data-line-number="2684"></td>
        <td id="LC2684">        <span>return</span> <span>ParentEquals</span>(g_pMulticastDelegateClass);</td>
      </tr>
      <tr>
        <td id="L2685" data-line-number="2685"></td>
        <td id="LC2685">    }</td>
      </tr>
      <tr>
        <td id="L2686" data-line-number="2686"></td>
        <td id="LC2686">
</td>
      </tr>
      <tr>
        <td id="L2687" data-line-number="2687"></td>
        <td id="LC2687">    <span><span>//</span> Is this System.Object?</span></td>
      </tr>
      <tr>
        <td id="L2688" data-line-number="2688"></td>
        <td id="LC2688">    <span>inline</span> BOOL <span>IsObjectClass</span>()</td>
      </tr>
      <tr>
        <td id="L2689" data-line-number="2689"></td>
        <td id="LC2689">    {</td>
      </tr>
      <tr>
        <td id="L2690" data-line-number="2690"></td>
        <td id="LC2690">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2691" data-line-number="2691"></td>
        <td id="LC2691">        <span>_ASSERTE</span>(g_pObjectClass);</td>
      </tr>
      <tr>
        <td id="L2692" data-line-number="2692"></td>
        <td id="LC2692">        <span>return</span> (this == g_pObjectClass);</td>
      </tr>
      <tr>
        <td id="L2693" data-line-number="2693"></td>
        <td id="LC2693">    }</td>
      </tr>
      <tr>
        <td id="L2694" data-line-number="2694"></td>
        <td id="LC2694">
</td>
      </tr>
      <tr>
        <td id="L2695" data-line-number="2695"></td>
        <td id="LC2695">    <span><span>//</span> Is this System.ValueType?</span></td>
      </tr>
      <tr>
        <td id="L2696" data-line-number="2696"></td>
        <td id="LC2696">    <span>inline</span> DWORD <span>IsValueTypeClass</span>()</td>
      </tr>
      <tr>
        <td id="L2697" data-line-number="2697"></td>
        <td id="LC2697">    {</td>
      </tr>
      <tr>
        <td id="L2698" data-line-number="2698"></td>
        <td id="LC2698">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2699" data-line-number="2699"></td>
        <td id="LC2699">        <span>_ASSERTE</span>(g_pValueTypeClass);</td>
      </tr>
      <tr>
        <td id="L2700" data-line-number="2700"></td>
        <td id="LC2700">        <span>return</span> (this == g_pValueTypeClass);</td>
      </tr>
      <tr>
        <td id="L2701" data-line-number="2701"></td>
        <td id="LC2701">    }</td>
      </tr>
      <tr>
        <td id="L2702" data-line-number="2702"></td>
        <td id="LC2702">
</td>
      </tr>
      <tr>
        <td id="L2703" data-line-number="2703"></td>
        <td id="LC2703">    <span><span>//</span> Is this value type? Returns false for System.ValueType and System.Enum.</span></td>
      </tr>
      <tr>
        <td id="L2704" data-line-number="2704"></td>
        <td id="LC2704">    <span>inline</span> BOOL <span>IsValueType</span>();</td>
      </tr>
      <tr>
        <td id="L2705" data-line-number="2705"></td>
        <td id="LC2705">
</td>
      </tr>
      <tr>
        <td id="L2706" data-line-number="2706"></td>
        <td id="LC2706">    <span><span>//</span> Returns "TRUE" iff "this" is a struct type such that return buffers used for returning a value</span></td>
      </tr>
      <tr>
        <td id="L2707" data-line-number="2707"></td>
        <td id="LC2707">    <span><span>//</span> of this type must be stack-allocated.  This will generally be true only if the struct</span></td>
      </tr>
      <tr>
        <td id="L2708" data-line-number="2708"></td>
        <td id="LC2708">    <span><span>//</span> contains GC pointers, and does not exceed some size limit.  Maintaining this as an invariant allows</span></td>
      </tr>
      <tr>
        <td id="L2709" data-line-number="2709"></td>
        <td id="LC2709">    <span><span>//</span> an optimization: the JIT may assume that return buffer pointers for return types for which this predicate</span></td>
      </tr>
      <tr>
        <td id="L2710" data-line-number="2710"></td>
        <td id="LC2710">    <span><span>//</span> returns TRUE are always stack allocated, and thus, that stores to the GC-pointer fields of such return</span></td>
      </tr>
      <tr>
        <td id="L2711" data-line-number="2711"></td>
        <td id="LC2711">    <span><span>//</span> buffers do not require GC write barriers.</span></td>
      </tr>
      <tr>
        <td id="L2712" data-line-number="2712"></td>
        <td id="LC2712">    BOOL <span>IsStructRequiringStackAllocRetBuf</span>();</td>
      </tr>
      <tr>
        <td id="L2713" data-line-number="2713"></td>
        <td id="LC2713">
</td>
      </tr>
      <tr>
        <td id="L2714" data-line-number="2714"></td>
        <td id="LC2714">    <span><span>//</span> Is this enum? Returns false for System.Enum.</span></td>
      </tr>
      <tr>
        <td id="L2715" data-line-number="2715"></td>
        <td id="LC2715">    <span>inline</span> BOOL <span>IsEnum</span>();</td>
      </tr>
      <tr>
        <td id="L2716" data-line-number="2716"></td>
        <td id="LC2716">
</td>
      </tr>
      <tr>
        <td id="L2717" data-line-number="2717"></td>
        <td id="LC2717">    <span><span>//</span> Is this array? Returns false for System.Array.</span></td>
      </tr>
      <tr>
        <td id="L2718" data-line-number="2718"></td>
        <td id="LC2718">    <span>inline</span> BOOL <span>IsArray</span>()</td>
      </tr>
      <tr>
        <td id="L2719" data-line-number="2719"></td>
        <td id="LC2719">    {</td>
      </tr>
      <tr>
        <td id="L2720" data-line-number="2720"></td>
        <td id="LC2720">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2721" data-line-number="2721"></td>
        <td id="LC2721">        <span>return</span> <span>GetFlag</span>(enum_flag_Category_Array_Mask) == enum_flag_Category_Array;</td>
      </tr>
      <tr>
        <td id="L2722" data-line-number="2722"></td>
        <td id="LC2722">    }</td>
      </tr>
      <tr>
        <td id="L2723" data-line-number="2723"></td>
        <td id="LC2723">    <span>inline</span> BOOL <span>IsMultiDimArray</span>()</td>
      </tr>
      <tr>
        <td id="L2724" data-line-number="2724"></td>
        <td id="LC2724">    {</td>
      </tr>
      <tr>
        <td id="L2725" data-line-number="2725"></td>
        <td id="LC2725">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2726" data-line-number="2726"></td>
        <td id="LC2726">        <span>PRECONDITION</span>(<span>IsArray</span>());</td>
      </tr>
      <tr>
        <td id="L2727" data-line-number="2727"></td>
        <td id="LC2727">        <span>return</span> !<span>GetFlag</span>(enum_flag_Category_IfArrayThenSzArray);</td>
      </tr>
      <tr>
        <td id="L2728" data-line-number="2728"></td>
        <td id="LC2728">    }</td>
      </tr>
      <tr>
        <td id="L2729" data-line-number="2729"></td>
        <td id="LC2729">
</td>
      </tr>
      <tr>
        <td id="L2730" data-line-number="2730"></td>
        <td id="LC2730">    <span><span>//</span> Returns true if this type is Nullable&lt;T&gt; for some T.</span></td>
      </tr>
      <tr>
        <td id="L2731" data-line-number="2731"></td>
        <td id="LC2731">    <span>inline</span> BOOL <span>IsNullable</span>()</td>
      </tr>
      <tr>
        <td id="L2732" data-line-number="2732"></td>
        <td id="LC2732">    {</td>
      </tr>
      <tr>
        <td id="L2733" data-line-number="2733"></td>
        <td id="LC2733">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2734" data-line-number="2734"></td>
        <td id="LC2734">        <span>return</span> <span>GetFlag</span>(enum_flag_Category_Mask) == enum_flag_Category_Nullable;</td>
      </tr>
      <tr>
        <td id="L2735" data-line-number="2735"></td>
        <td id="LC2735">    }</td>
      </tr>
      <tr>
        <td id="L2736" data-line-number="2736"></td>
        <td id="LC2736">
</td>
      </tr>
      <tr>
        <td id="L2737" data-line-number="2737"></td>
        <td id="LC2737">    <span>inline</span> <span>void</span> <span>SetIsNullable</span>()</td>
      </tr>
      <tr>
        <td id="L2738" data-line-number="2738"></td>
        <td id="LC2738">    {</td>
      </tr>
      <tr>
        <td id="L2739" data-line-number="2739"></td>
        <td id="LC2739">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2740" data-line-number="2740"></td>
        <td id="LC2740">        <span>_ASSERTE</span>(<span>GetFlag</span>(enum_flag_Category_Mask) == enum_flag_Category_ValueType);</td>
      </tr>
      <tr>
        <td id="L2741" data-line-number="2741"></td>
        <td id="LC2741">        <span>SetFlag</span>(enum_flag_Category_Nullable);</td>
      </tr>
      <tr>
        <td id="L2742" data-line-number="2742"></td>
        <td id="LC2742">    }</td>
      </tr>
      <tr>
        <td id="L2743" data-line-number="2743"></td>
        <td id="LC2743">
</td>
      </tr>
      <tr>
        <td id="L2744" data-line-number="2744"></td>
        <td id="LC2744">    <span>inline</span> BOOL <span>IsStructMarshalable</span>()</td>
      </tr>
      <tr>
        <td id="L2745" data-line-number="2745"></td>
        <td id="LC2745">    {</td>
      </tr>
      <tr>
        <td id="L2746" data-line-number="2746"></td>
        <td id="LC2746">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2747" data-line-number="2747"></td>
        <td id="LC2747">        <span>PRECONDITION</span>(!<span>IsInterface</span>());</td>
      </tr>
      <tr>
        <td id="L2748" data-line-number="2748"></td>
        <td id="LC2748">        <span>return</span> <span>GetFlag</span>(enum_flag_IfNotInterfaceThenMarshalable);</td>
      </tr>
      <tr>
        <td id="L2749" data-line-number="2749"></td>
        <td id="LC2749">    }</td>
      </tr>
      <tr>
        <td id="L2750" data-line-number="2750"></td>
        <td id="LC2750">
</td>
      </tr>
      <tr>
        <td id="L2751" data-line-number="2751"></td>
        <td id="LC2751">    <span>inline</span> <span>void</span> <span>SetStructMarshalable</span>()</td>
      </tr>
      <tr>
        <td id="L2752" data-line-number="2752"></td>
        <td id="LC2752">    {</td>
      </tr>
      <tr>
        <td id="L2753" data-line-number="2753"></td>
        <td id="LC2753">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2754" data-line-number="2754"></td>
        <td id="LC2754">        <span>PRECONDITION</span>(!<span>IsInterface</span>());</td>
      </tr>
      <tr>
        <td id="L2755" data-line-number="2755"></td>
        <td id="LC2755">        <span>SetFlag</span>(enum_flag_IfNotInterfaceThenMarshalable);</td>
      </tr>
      <tr>
        <td id="L2756" data-line-number="2756"></td>
        <td id="LC2756">    }</td>
      </tr>
      <tr>
        <td id="L2757" data-line-number="2757"></td>
        <td id="LC2757">    </td>
      </tr>
      <tr>
        <td id="L2758" data-line-number="2758"></td>
        <td id="LC2758">    <span><span>//</span> The following methods are only valid for the method tables for array types.  </span></td>
      </tr>
      <tr>
        <td id="L2759" data-line-number="2759"></td>
        <td id="LC2759">    CorElementType <span>GetArrayElementType</span>();</td>
      </tr>
      <tr>
        <td id="L2760" data-line-number="2760"></td>
        <td id="LC2760">    DWORD <span>GetRank</span>();</td>
      </tr>
      <tr>
        <td id="L2761" data-line-number="2761"></td>
        <td id="LC2761">
</td>
      </tr>
      <tr>
        <td id="L2762" data-line-number="2762"></td>
        <td id="LC2762">    TypeHandle <span>GetArrayElementTypeHandle</span>()</td>
      </tr>
      <tr>
        <td id="L2763" data-line-number="2763"></td>
        <td id="LC2763">    {</td>
      </tr>
      <tr>
        <td id="L2764" data-line-number="2764"></td>
        <td id="LC2764">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2765" data-line-number="2765"></td>
        <td id="LC2765">        <span>_ASSERTE</span> (<span>IsArray</span>());</td>
      </tr>
      <tr>
        <td id="L2766" data-line-number="2766"></td>
        <td id="LC2766">        <span>return</span> <span>TypeHandle::FromTAddr</span>(m_ElementTypeHnd);</td>
      </tr>
      <tr>
        <td id="L2767" data-line-number="2767"></td>
        <td id="LC2767">    }</td>
      </tr>
      <tr>
        <td id="L2768" data-line-number="2768"></td>
        <td id="LC2768">
</td>
      </tr>
      <tr>
        <td id="L2769" data-line-number="2769"></td>
        <td id="LC2769">    <span>void</span> <span>SetArrayElementTypeHandle</span>(TypeHandle th)</td>
      </tr>
      <tr>
        <td id="L2770" data-line-number="2770"></td>
        <td id="LC2770">    {</td>
      </tr>
      <tr>
        <td id="L2771" data-line-number="2771"></td>
        <td id="LC2771">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2772" data-line-number="2772"></td>
        <td id="LC2772">        m_ElementTypeHnd = th.<span>AsTAddr</span>();</td>
      </tr>
      <tr>
        <td id="L2773" data-line-number="2773"></td>
        <td id="LC2773">    }</td>
      </tr>
      <tr>
        <td id="L2774" data-line-number="2774"></td>
        <td id="LC2774">
</td>
      </tr>
      <tr>
        <td id="L2775" data-line-number="2775"></td>
        <td id="LC2775">    TypeHandle * <span>GetArrayElementTypeHandlePtr</span>()</td>
      </tr>
      <tr>
        <td id="L2776" data-line-number="2776"></td>
        <td id="LC2776">    {</td>
      </tr>
      <tr>
        <td id="L2777" data-line-number="2777"></td>
        <td id="LC2777">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2778" data-line-number="2778"></td>
        <td id="LC2778">        <span>return</span> (TypeHandle *)&amp;m_ElementTypeHnd;</td>
      </tr>
      <tr>
        <td id="L2779" data-line-number="2779"></td>
        <td id="LC2779">    }</td>
      </tr>
      <tr>
        <td id="L2780" data-line-number="2780"></td>
        <td id="LC2780">
</td>
      </tr>
      <tr>
        <td id="L2781" data-line-number="2781"></td>
        <td id="LC2781">    <span>static</span> <span>inline</span> DWORD <span>GetOffsetOfArrayElementTypeHandle</span>()</td>
      </tr>
      <tr>
        <td id="L2782" data-line-number="2782"></td>
        <td id="LC2782">    {</td>
      </tr>
      <tr>
        <td id="L2783" data-line-number="2783"></td>
        <td id="LC2783">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2784" data-line-number="2784"></td>
        <td id="LC2784">        <span>return</span> <span>offsetof</span>(MethodTable, m_ElementTypeHnd);</td>
      </tr>
      <tr>
        <td id="L2785" data-line-number="2785"></td>
        <td id="LC2785">    }</td>
      </tr>
      <tr>
        <td id="L2786" data-line-number="2786"></td>
        <td id="LC2786">
</td>
      </tr>
      <tr>
        <td id="L2787" data-line-number="2787"></td>
        <td id="LC2787">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2788" data-line-number="2788"></td>
        <td id="LC2788">    <span><span>//</span> UNDERLYING METADATA</span></td>
      </tr>
      <tr>
        <td id="L2789" data-line-number="2789"></td>
        <td id="LC2789">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2790" data-line-number="2790"></td>
        <td id="LC2790">
</td>
      </tr>
      <tr>
        <td id="L2791" data-line-number="2791"></td>
        <td id="LC2791">
</td>
      </tr>
      <tr>
        <td id="L2792" data-line-number="2792"></td>
        <td id="LC2792">    <span><span>//</span> Get the RID/token for the metadata for the corresponding type declaration</span></td>
      </tr>
      <tr>
        <td id="L2793" data-line-number="2793"></td>
        <td id="LC2793">    <span>unsigned</span> <span>GetTypeDefRid</span>();</td>
      </tr>
      <tr>
        <td id="L2794" data-line-number="2794"></td>
        <td id="LC2794">    <span>unsigned</span> <span>GetTypeDefRid_NoLogging</span>();</td>
      </tr>
      <tr>
        <td id="L2795" data-line-number="2795"></td>
        <td id="LC2795">
</td>
      </tr>
      <tr>
        <td id="L2796" data-line-number="2796"></td>
        <td id="LC2796">    <span>inline</span> mdTypeDef <span>GetCl</span>()</td>
      </tr>
      <tr>
        <td id="L2797" data-line-number="2797"></td>
        <td id="LC2797">    {</td>
      </tr>
      <tr>
        <td id="L2798" data-line-number="2798"></td>
        <td id="LC2798">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2799" data-line-number="2799"></td>
        <td id="LC2799">        <span>return</span> <span>TokenFromRid</span>(<span>GetTypeDefRid</span>(), mdtTypeDef);</td>
      </tr>
      <tr>
        <td id="L2800" data-line-number="2800"></td>
        <td id="LC2800">    }</td>
      </tr>
      <tr>
        <td id="L2801" data-line-number="2801"></td>
        <td id="LC2801">
</td>
      </tr>
      <tr>
        <td id="L2802" data-line-number="2802"></td>
        <td id="LC2802">    <span>inline</span> mdTypeDef <span>GetCl_NoLogging</span>()</td>
      </tr>
      <tr>
        <td id="L2803" data-line-number="2803"></td>
        <td id="LC2803">    {</td>
      </tr>
      <tr>
        <td id="L2804" data-line-number="2804"></td>
        <td id="LC2804">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2805" data-line-number="2805"></td>
        <td id="LC2805">        <span>return</span> <span>TokenFromRid</span>(<span>GetTypeDefRid_NoLogging</span>(), mdtTypeDef);</td>
      </tr>
      <tr>
        <td id="L2806" data-line-number="2806"></td>
        <td id="LC2806">    }</td>
      </tr>
      <tr>
        <td id="L2807" data-line-number="2807"></td>
        <td id="LC2807">
</td>
      </tr>
      <tr>
        <td id="L2808" data-line-number="2808"></td>
        <td id="LC2808">    <span>void</span> <span>SetCl</span>(mdTypeDef token);</td>
      </tr>
      <tr>
        <td id="L2809" data-line-number="2809"></td>
        <td id="LC2809">
</td>
      </tr>
      <tr>
        <td id="L2810" data-line-number="2810"></td>
        <td id="LC2810">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L2811" data-line-number="2811"></td>
        <td id="LC2811"><span><span>//</span> Make this smaller in debug builds to exercise the overflow codepath</span></td>
      </tr>
      <tr>
        <td id="L2812" data-line-number="2812"></td>
        <td id="LC2812">#<span>define</span> <span>METHODTABLE_TOKEN_OVERFLOW</span> <span>0xFFF</span></td>
      </tr>
      <tr>
        <td id="L2813" data-line-number="2813"></td>
        <td id="LC2813">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L2814" data-line-number="2814"></td>
        <td id="LC2814">#<span>define</span> <span>METHODTABLE_TOKEN_OVERFLOW</span> <span>0xFFFF</span></td>
      </tr>
      <tr>
        <td id="L2815" data-line-number="2815"></td>
        <td id="LC2815">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2816" data-line-number="2816"></td>
        <td id="LC2816">
</td>
      </tr>
      <tr>
        <td id="L2817" data-line-number="2817"></td>
        <td id="LC2817">    BOOL <span>HasTokenOverflow</span>()</td>
      </tr>
      <tr>
        <td id="L2818" data-line-number="2818"></td>
        <td id="LC2818">    {</td>
      </tr>
      <tr>
        <td id="L2819" data-line-number="2819"></td>
        <td id="LC2819">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2820" data-line-number="2820"></td>
        <td id="LC2820">        <span>return</span> m_wToken == METHODTABLE_TOKEN_OVERFLOW;</td>
      </tr>
      <tr>
        <td id="L2821" data-line-number="2821"></td>
        <td id="LC2821">    }</td>
      </tr>
      <tr>
        <td id="L2822" data-line-number="2822"></td>
        <td id="LC2822">
</td>
      </tr>
      <tr>
        <td id="L2823" data-line-number="2823"></td>
        <td id="LC2823">    <span><span>//</span> Get the MD Import for the metadata for the corresponding type declaration</span></td>
      </tr>
      <tr>
        <td id="L2824" data-line-number="2824"></td>
        <td id="LC2824">    IMDInternalImport* <span>GetMDImport</span>();</td>
      </tr>
      <tr>
        <td id="L2825" data-line-number="2825"></td>
        <td id="LC2825">
</td>
      </tr>
      <tr>
        <td id="L2826" data-line-number="2826"></td>
        <td id="LC2826">    HRESULT <span>GetCustomAttribute</span>(WellKnownAttribute attribute,</td>
      </tr>
      <tr>
        <td id="L2827" data-line-number="2827"></td>
        <td id="LC2827">                               <span>const</span> <span>void</span>  **ppData,</td>
      </tr>
      <tr>
        <td id="L2828" data-line-number="2828"></td>
        <td id="LC2828">                               ULONG *pcbData);</td>
      </tr>
      <tr>
        <td id="L2829" data-line-number="2829"></td>
        <td id="LC2829">
</td>
      </tr>
      <tr>
        <td id="L2830" data-line-number="2830"></td>
        <td id="LC2830">    mdTypeDef <span>GetEnclosingCl</span>();</td>
      </tr>
      <tr>
        <td id="L2831" data-line-number="2831"></td>
        <td id="LC2831">
</td>
      </tr>
      <tr>
        <td id="L2832" data-line-number="2832"></td>
        <td id="LC2832">#<span>ifdef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2833" data-line-number="2833"></td>
        <td id="LC2833">    <span>void</span> <span>EnumMemoryRegions</span>(CLRDataEnumMemoryFlags flags);</td>
      </tr>
      <tr>
        <td id="L2834" data-line-number="2834"></td>
        <td id="LC2834">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2835" data-line-number="2835"></td>
        <td id="LC2835">
</td>
      </tr>
      <tr>
        <td id="L2836" data-line-number="2836"></td>
        <td id="LC2836">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2837" data-line-number="2837"></td>
        <td id="LC2837">    <span><span>//</span> REMOTEABLE METHOD INFO</span></td>
      </tr>
      <tr>
        <td id="L2838" data-line-number="2838"></td>
        <td id="LC2838">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2839" data-line-number="2839"></td>
        <td id="LC2839">
</td>
      </tr>
      <tr>
        <td id="L2840" data-line-number="2840"></td>
        <td id="LC2840">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L2841" data-line-number="2841"></td>
        <td id="LC2841">    <span>void</span> <span>SetHasGuidInfo</span>();</td>
      </tr>
      <tr>
        <td id="L2842" data-line-number="2842"></td>
        <td id="LC2842">    BOOL <span>HasGuidInfo</span>();</td>
      </tr>
      <tr>
        <td id="L2843" data-line-number="2843"></td>
        <td id="LC2843">    <span>void</span> <span>SetHasCCWTemplate</span>();</td>
      </tr>
      <tr>
        <td id="L2844" data-line-number="2844"></td>
        <td id="LC2844">    BOOL <span>HasCCWTemplate</span>();</td>
      </tr>
      <tr>
        <td id="L2845" data-line-number="2845"></td>
        <td id="LC2845">    <span>void</span> <span>SetHasRCWPerTypeData</span>();</td>
      </tr>
      <tr>
        <td id="L2846" data-line-number="2846"></td>
        <td id="LC2846">    BOOL <span>HasRCWPerTypeData</span>();</td>
      </tr>
      <tr>
        <td id="L2847" data-line-number="2847"></td>
        <td id="LC2847">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L2848" data-line-number="2848"></td>
        <td id="LC2848">
</td>
      </tr>
      <tr>
        <td id="L2849" data-line-number="2849"></td>
        <td id="LC2849">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L2850" data-line-number="2850"></td>
        <td id="LC2850">    <span><span>//</span> DICTIONARIES FOR GENERIC INSTANTIATIONS</span></td>
      </tr>
      <tr>
        <td id="L2851" data-line-number="2851"></td>
        <td id="LC2851">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2852" data-line-number="2852"></td>
        <td id="LC2852">    <span><span>//</span> The PerInstInfo pointer is a pointer to per-instantiation pointer table,</span></td>
      </tr>
      <tr>
        <td id="L2853" data-line-number="2853"></td>
        <td id="LC2853">    <span><span>//</span> each entry of which points to an instantiation "dictionary"</span></td>
      </tr>
      <tr>
        <td id="L2854" data-line-number="2854"></td>
        <td id="LC2854">    <span><span>//</span> for an instantiated type; the last pointer points to a</span></td>
      </tr>
      <tr>
        <td id="L2855" data-line-number="2855"></td>
        <td id="LC2855">    <span><span>//</span> dictionary which is specific to this method table, previous</span></td>
      </tr>
      <tr>
        <td id="L2856" data-line-number="2856"></td>
        <td id="LC2856">    <span><span>//</span> entries point to dictionaries in superclasses. Instantiated interfaces and structs</span></td>
      </tr>
      <tr>
        <td id="L2857" data-line-number="2857"></td>
        <td id="LC2857">    <span><span>//</span> have just single dictionary (no inheritance).</span></td>
      </tr>
      <tr>
        <td id="L2858" data-line-number="2858"></td>
        <td id="LC2858">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2859" data-line-number="2859"></td>
        <td id="LC2859">    <span><span>//</span> GetNumDicts() gives the number of dictionaries.</span></td>
      </tr>
      <tr>
        <td id="L2860" data-line-number="2860"></td>
        <td id="LC2860">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2861" data-line-number="2861"></td>
        <td id="LC2861">    <span><span>//</span>@nice GENERICS: instead of a separate table of pointers, put the pointers</span></td>
      </tr>
      <tr>
        <td id="L2862" data-line-number="2862"></td>
        <td id="LC2862">    <span><span>//</span> in the vtable itself. Advantages:</span></td>
      </tr>
      <tr>
        <td id="L2863" data-line-number="2863"></td>
        <td id="LC2863">    <span><span>//</span> * Time: we save an indirection as we don't need to go through PerInstInfo first.</span></td>
      </tr>
      <tr>
        <td id="L2864" data-line-number="2864"></td>
        <td id="LC2864">    <span><span>//</span> * Space: no need for PerInstInfo (1 word)</span></td>
      </tr>
      <tr>
        <td id="L2865" data-line-number="2865"></td>
        <td id="LC2865">    <span><span>//</span> Problem is that lots of code assumes that the vtable is filled</span></td>
      </tr>
      <tr>
        <td id="L2866" data-line-number="2866"></td>
        <td id="LC2866">    <span><span>//</span> uniformly with pointers to MethodDesc stubs.</span></td>
      </tr>
      <tr>
        <td id="L2867" data-line-number="2867"></td>
        <td id="LC2867">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2868" data-line-number="2868"></td>
        <td id="LC2868">    <span><span>//</span> The dictionary for the method table is just an array of handles for</span></td>
      </tr>
      <tr>
        <td id="L2869" data-line-number="2869"></td>
        <td id="LC2869">    <span><span>//</span> type parameters in the following cases:</span></td>
      </tr>
      <tr>
        <td id="L2870" data-line-number="2870"></td>
        <td id="LC2870">    <span><span>//</span> * instantiated interfaces (no code)</span></td>
      </tr>
      <tr>
        <td id="L2871" data-line-number="2871"></td>
        <td id="LC2871">    <span><span>//</span> * instantiated types whose code is not shared</span></td>
      </tr>
      <tr>
        <td id="L2872" data-line-number="2872"></td>
        <td id="LC2872">    <span><span>//</span> Otherwise, it starts with the type parameters and then has a fixed</span></td>
      </tr>
      <tr>
        <td id="L2873" data-line-number="2873"></td>
        <td id="LC2873">    <span><span>//</span> number of slots for handles (types &amp; methods)</span></td>
      </tr>
      <tr>
        <td id="L2874" data-line-number="2874"></td>
        <td id="LC2874">    <span><span>//</span> that are filled in lazily at run-time. Finally there is a "spill-bucket"</span></td>
      </tr>
      <tr>
        <td id="L2875" data-line-number="2875"></td>
        <td id="LC2875">    <span><span>//</span> pointer used when the dictionary gets filled.</span></td>
      </tr>
      <tr>
        <td id="L2876" data-line-number="2876"></td>
        <td id="LC2876">    <span><span>//</span> In summary:</span></td>
      </tr>
      <tr>
        <td id="L2877" data-line-number="2877"></td>
        <td id="LC2877">    <span><span>//</span>    typar_1              type handle for first type parameter</span></td>
      </tr>
      <tr>
        <td id="L2878" data-line-number="2878"></td>
        <td id="LC2878">    <span><span>//</span>    ...</span></td>
      </tr>
      <tr>
        <td id="L2879" data-line-number="2879"></td>
        <td id="LC2879">    <span><span>//</span>    typar_n              type handle for last type parameter</span></td>
      </tr>
      <tr>
        <td id="L2880" data-line-number="2880"></td>
        <td id="LC2880">    <span><span>//</span>    slot_1               slot for first run-time handle (initially null)</span></td>
      </tr>
      <tr>
        <td id="L2881" data-line-number="2881"></td>
        <td id="LC2881">    <span><span>//</span>    ...</span></td>
      </tr>
      <tr>
        <td id="L2882" data-line-number="2882"></td>
        <td id="LC2882">    <span><span>//</span>    slot_m               slot for last run-time handle (initially null)</span></td>
      </tr>
      <tr>
        <td id="L2883" data-line-number="2883"></td>
        <td id="LC2883">    <span><span>//</span>    next_bucket          pointer to spill bucket (possibly null)</span></td>
      </tr>
      <tr>
        <td id="L2884" data-line-number="2884"></td>
        <td id="LC2884">    <span><span>//</span> The spill bucket contains just run-time handle slots.</span></td>
      </tr>
      <tr>
        <td id="L2885" data-line-number="2885"></td>
        <td id="LC2885">    <span><span>//</span>   (Alternative: continue chaining buckets.</span></td>
      </tr>
      <tr>
        <td id="L2886" data-line-number="2886"></td>
        <td id="LC2886">    <span><span>//</span>    Advantage: no need to deallocate when growing dictionaries.</span></td>
      </tr>
      <tr>
        <td id="L2887" data-line-number="2887"></td>
        <td id="LC2887">    <span><span>//</span>    Disadvantage: more indirections required at run-time.)</span></td>
      </tr>
      <tr>
        <td id="L2888" data-line-number="2888"></td>
        <td id="LC2888">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2889" data-line-number="2889"></td>
        <td id="LC2889">    <span><span>//</span> The layout of dictionaries is determined by GetClass()-&gt;GetDictionaryLayout()</span></td>
      </tr>
      <tr>
        <td id="L2890" data-line-number="2890"></td>
        <td id="LC2890">    <span><span>//</span> Thus the layout can vary between incompatible instantiations. This is sometimes useful because individual type</span></td>
      </tr>
      <tr>
        <td id="L2891" data-line-number="2891"></td>
        <td id="LC2891">    <span><span>//</span> parameters may or may not be shared. For example, consider a two parameter class Dict&lt;K,D&gt;. In instantiations shared with</span></td>
      </tr>
      <tr>
        <td id="L2892" data-line-number="2892"></td>
        <td id="LC2892">    <span><span>//</span> Dict&lt;double,string&gt; any reference to K is known at JIT-compile-time (it's double) but any token containing D</span></td>
      </tr>
      <tr>
        <td id="L2893" data-line-number="2893"></td>
        <td id="LC2893">    <span><span>//</span> must have a dictionary entry. On the other hand, for instantiations shared with Dict&lt;string,double&gt; the opposite holds.</span></td>
      </tr>
      <tr>
        <td id="L2894" data-line-number="2894"></td>
        <td id="LC2894">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2895" data-line-number="2895"></td>
        <td id="LC2895">
</td>
      </tr>
      <tr>
        <td id="L2896" data-line-number="2896"></td>
        <td id="LC2896">#<span>if</span> defined(FEATURE_NGEN_RELOCS_OPTIMIZATIONS)</td>
      </tr>
      <tr>
        <td id="L2897" data-line-number="2897"></td>
        <td id="LC2897">    <span>typedef</span> RelativePointer&lt;PTR_Dictionary&gt; PerInstInfoElem_t;</td>
      </tr>
      <tr>
        <td id="L2898" data-line-number="2898"></td>
        <td id="LC2898">    <span>typedef</span> RelativePointer&lt;<span>DPTR</span>(PerInstInfoElem_t)&gt; PerInstInfo_t;</td>
      </tr>
      <tr>
        <td id="L2899" data-line-number="2899"></td>
        <td id="LC2899">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L2900" data-line-number="2900"></td>
        <td id="LC2900">    <span>typedef</span> PlainPointer&lt;PTR_Dictionary&gt; PerInstInfoElem_t;</td>
      </tr>
      <tr>
        <td id="L2901" data-line-number="2901"></td>
        <td id="LC2901">    <span>typedef</span> PlainPointer&lt;<span>DPTR</span>(PerInstInfoElem_t)&gt; PerInstInfo_t;</td>
      </tr>
      <tr>
        <td id="L2902" data-line-number="2902"></td>
        <td id="LC2902">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2903" data-line-number="2903"></td>
        <td id="LC2903">
</td>
      </tr>
      <tr>
        <td id="L2904" data-line-number="2904"></td>
        <td id="LC2904">    <span><span>//</span> Return a pointer to the per-instantiation information. See field itself for comments.</span></td>
      </tr>
      <tr>
        <td id="L2905" data-line-number="2905"></td>
        <td id="LC2905">    <span>DPTR</span>(PerInstInfoElem_t) <span>GetPerInstInfo</span>()</td>
      </tr>
      <tr>
        <td id="L2906" data-line-number="2906"></td>
        <td id="LC2906">    {</td>
      </tr>
      <tr>
        <td id="L2907" data-line-number="2907"></td>
        <td id="LC2907">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2908" data-line-number="2908"></td>
        <td id="LC2908">        <span>_ASSERTE</span>(<span>HasPerInstInfo</span>());</td>
      </tr>
      <tr>
        <td id="L2909" data-line-number="2909"></td>
        <td id="LC2909">        <span>return</span> <span>ReadPointer</span>(this, &amp;MethodTable::m_pPerInstInfo);</td>
      </tr>
      <tr>
        <td id="L2910" data-line-number="2910"></td>
        <td id="LC2910">    }</td>
      </tr>
      <tr>
        <td id="L2911" data-line-number="2911"></td>
        <td id="LC2911">    BOOL <span>HasPerInstInfo</span>()</td>
      </tr>
      <tr>
        <td id="L2912" data-line-number="2912"></td>
        <td id="LC2912">    {</td>
      </tr>
      <tr>
        <td id="L2913" data-line-number="2913"></td>
        <td id="LC2913">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2914" data-line-number="2914"></td>
        <td id="LC2914">        <span>return</span> <span>GetFlag</span>(enum_flag_HasPerInstInfo) &amp;&amp; !<span>IsArray</span>();</td>
      </tr>
      <tr>
        <td id="L2915" data-line-number="2915"></td>
        <td id="LC2915">    }</td>
      </tr>
      <tr>
        <td id="L2916" data-line-number="2916"></td>
        <td id="LC2916">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L2917" data-line-number="2917"></td>
        <td id="LC2917">    <span>static</span> <span>inline</span> <span>bool</span> <span>IsPerInstInfoRelative</span>()</td>
      </tr>
      <tr>
        <td id="L2918" data-line-number="2918"></td>
        <td id="LC2918">    {</td>
      </tr>
      <tr>
        <td id="L2919" data-line-number="2919"></td>
        <td id="LC2919">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2920" data-line-number="2920"></td>
        <td id="LC2920">        <span>return</span> <span>decltype</span>(m_pPerInstInfo)::isRelative;</td>
      </tr>
      <tr>
        <td id="L2921" data-line-number="2921"></td>
        <td id="LC2921">    }</td>
      </tr>
      <tr>
        <td id="L2922" data-line-number="2922"></td>
        <td id="LC2922">    <span>static</span> <span>inline</span> DWORD <span>GetOffsetOfPerInstInfo</span>()</td>
      </tr>
      <tr>
        <td id="L2923" data-line-number="2923"></td>
        <td id="LC2923">    {</td>
      </tr>
      <tr>
        <td id="L2924" data-line-number="2924"></td>
        <td id="LC2924">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2925" data-line-number="2925"></td>
        <td id="LC2925">        <span>return</span> <span>offsetof</span>(MethodTable, m_pPerInstInfo);</td>
      </tr>
      <tr>
        <td id="L2926" data-line-number="2926"></td>
        <td id="LC2926">    }</td>
      </tr>
      <tr>
        <td id="L2927" data-line-number="2927"></td>
        <td id="LC2927">    <span>void</span> <span>SetPerInstInfo</span>(PerInstInfoElem_t *pPerInstInfo)</td>
      </tr>
      <tr>
        <td id="L2928" data-line-number="2928"></td>
        <td id="LC2928">    {</td>
      </tr>
      <tr>
        <td id="L2929" data-line-number="2929"></td>
        <td id="LC2929">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2930" data-line-number="2930"></td>
        <td id="LC2930">        m_pPerInstInfo.<span>SetValue</span>(pPerInstInfo);</td>
      </tr>
      <tr>
        <td id="L2931" data-line-number="2931"></td>
        <td id="LC2931">    }</td>
      </tr>
      <tr>
        <td id="L2932" data-line-number="2932"></td>
        <td id="LC2932">    <span>void</span> <span>SetDictInfo</span>(WORD numDicts, WORD numTyPars)</td>
      </tr>
      <tr>
        <td id="L2933" data-line-number="2933"></td>
        <td id="LC2933">    {</td>
      </tr>
      <tr>
        <td id="L2934" data-line-number="2934"></td>
        <td id="LC2934">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2935" data-line-number="2935"></td>
        <td id="LC2935">        GenericsDictInfo* pInfo = <span>GetGenericsDictInfo</span>();</td>
      </tr>
      <tr>
        <td id="L2936" data-line-number="2936"></td>
        <td id="LC2936">        pInfo-&gt;<span>m_wNumDicts</span>  = numDicts;</td>
      </tr>
      <tr>
        <td id="L2937" data-line-number="2937"></td>
        <td id="LC2937">        pInfo-&gt;<span>m_wNumTyPars</span> = numTyPars;</td>
      </tr>
      <tr>
        <td id="L2938" data-line-number="2938"></td>
        <td id="LC2938">    }</td>
      </tr>
      <tr>
        <td id="L2939" data-line-number="2939"></td>
        <td id="LC2939">#<span>endif</span> <span><span>//</span> !DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L2940" data-line-number="2940"></td>
        <td id="LC2940">    PTR_GenericsDictInfo <span>GetGenericsDictInfo</span>()</td>
      </tr>
      <tr>
        <td id="L2941" data-line-number="2941"></td>
        <td id="LC2941">    {</td>
      </tr>
      <tr>
        <td id="L2942" data-line-number="2942"></td>
        <td id="LC2942">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2943" data-line-number="2943"></td>
        <td id="LC2943">        <span><span>//</span> GenericsDictInfo is stored at negative offset of the dictionary</span></td>
      </tr>
      <tr>
        <td id="L2944" data-line-number="2944"></td>
        <td id="LC2944">        <span>return</span> dac_cast&lt;PTR_GenericsDictInfo&gt;(<span>GetPerInstInfo</span>()) - <span>1</span>;</td>
      </tr>
      <tr>
        <td id="L2945" data-line-number="2945"></td>
        <td id="LC2945">    }</td>
      </tr>
      <tr>
        <td id="L2946" data-line-number="2946"></td>
        <td id="LC2946">
</td>
      </tr>
      <tr>
        <td id="L2947" data-line-number="2947"></td>
        <td id="LC2947">    <span><span>//</span> Get a pointer to the dictionary for this instantiated type</span></td>
      </tr>
      <tr>
        <td id="L2948" data-line-number="2948"></td>
        <td id="LC2948">    <span><span>//</span> (The instantiation is stored in the initial slots of the dictionary)</span></td>
      </tr>
      <tr>
        <td id="L2949" data-line-number="2949"></td>
        <td id="LC2949">    <span><span>//</span> If not instantiated, return NULL</span></td>
      </tr>
      <tr>
        <td id="L2950" data-line-number="2950"></td>
        <td id="LC2950">    PTR_Dictionary <span>GetDictionary</span>();</td>
      </tr>
      <tr>
        <td id="L2951" data-line-number="2951"></td>
        <td id="LC2951">
</td>
      </tr>
      <tr>
        <td id="L2952" data-line-number="2952"></td>
        <td id="LC2952">#<span>ifdef</span> FEATURE_PREJIT</td>
      </tr>
      <tr>
        <td id="L2953" data-line-number="2953"></td>
        <td id="LC2953">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2954" data-line-number="2954"></td>
        <td id="LC2954">    <span><span>//</span> After the zapper compiles all code in a module it may attempt</span></td>
      </tr>
      <tr>
        <td id="L2955" data-line-number="2955"></td>
        <td id="LC2955">    <span><span>//</span> to populate entries in all dictionaries</span></td>
      </tr>
      <tr>
        <td id="L2956" data-line-number="2956"></td>
        <td id="LC2956">    <span><span>//</span> associated with generic types.  This is an optional step - nothing will</span></td>
      </tr>
      <tr>
        <td id="L2957" data-line-number="2957"></td>
        <td id="LC2957">    <span><span>//</span> go wrong at runtime except we may get more one-off calls to JIT_GenericHandle.</span></td>
      </tr>
      <tr>
        <td id="L2958" data-line-number="2958"></td>
        <td id="LC2958">    <span><span>//</span> Although these are one-off we prefer to avoid them since they touch metadata</span></td>
      </tr>
      <tr>
        <td id="L2959" data-line-number="2959"></td>
        <td id="LC2959">    <span><span>//</span> pages.</span></td>
      </tr>
      <tr>
        <td id="L2960" data-line-number="2960"></td>
        <td id="LC2960">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2961" data-line-number="2961"></td>
        <td id="LC2961">    <span><span>//</span> Fully populating a dictionary may in theory load more types. However</span></td>
      </tr>
      <tr>
        <td id="L2962" data-line-number="2962"></td>
        <td id="LC2962">    <span><span>//</span> for the moment only those entries that refer to types that</span></td>
      </tr>
      <tr>
        <td id="L2963" data-line-number="2963"></td>
        <td id="LC2963">    <span><span>//</span> are already loaded will be filled in.</span></td>
      </tr>
      <tr>
        <td id="L2964" data-line-number="2964"></td>
        <td id="LC2964">    <span>void</span> <span>PrepopulateDictionary</span>(DataImage * image, BOOL nonExpansive);</td>
      </tr>
      <tr>
        <td id="L2965" data-line-number="2965"></td>
        <td id="LC2965">#<span>endif</span> <span><span>//</span> FEATURE_PREJIT</span></td>
      </tr>
      <tr>
        <td id="L2966" data-line-number="2966"></td>
        <td id="LC2966">
</td>
      </tr>
      <tr>
        <td id="L2967" data-line-number="2967"></td>
        <td id="LC2967">    <span><span>//</span> Return a substitution suitbale for interpreting</span></td>
      </tr>
      <tr>
        <td id="L2968" data-line-number="2968"></td>
        <td id="LC2968">    <span><span>//</span> the metadata in parent class, assuming we already have a subst.</span></td>
      </tr>
      <tr>
        <td id="L2969" data-line-number="2969"></td>
        <td id="LC2969">    <span><span>//</span> suitable for interpreting the current class.</span></td>
      </tr>
      <tr>
        <td id="L2970" data-line-number="2970"></td>
        <td id="LC2970">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2971" data-line-number="2971"></td>
        <td id="LC2971">    <span><span>//</span> If, for example, the definition for the current class is</span></td>
      </tr>
      <tr>
        <td id="L2972" data-line-number="2972"></td>
        <td id="LC2972">    <span><span>//</span>   D&lt;T&gt; : C&lt;List&lt;T&gt;, T[] &gt;</span></td>
      </tr>
      <tr>
        <td id="L2973" data-line-number="2973"></td>
        <td id="LC2973">    <span><span>//</span> then this (for C&lt;!0,!1&gt;) will be</span></td>
      </tr>
      <tr>
        <td id="L2974" data-line-number="2974"></td>
        <td id="LC2974">    <span><span>//</span>   0 --&gt; List&lt;T&gt;</span></td>
      </tr>
      <tr>
        <td id="L2975" data-line-number="2975"></td>
        <td id="LC2975">    <span><span>//</span>   1 --&gt; T[]</span></td>
      </tr>
      <tr>
        <td id="L2976" data-line-number="2976"></td>
        <td id="LC2976">    <span><span>//</span> added to the chain of substitutions.</span></td>
      </tr>
      <tr>
        <td id="L2977" data-line-number="2977"></td>
        <td id="LC2977">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L2978" data-line-number="2978"></td>
        <td id="LC2978">    <span><span>//</span> Subsequently, if the definition for C is</span></td>
      </tr>
      <tr>
        <td id="L2979" data-line-number="2979"></td>
        <td id="LC2979">    <span><span>//</span>   C&lt;T, U&gt; : B&lt; Dictionary&lt;T, U&gt; &gt;</span></td>
      </tr>
      <tr>
        <td id="L2980" data-line-number="2980"></td>
        <td id="LC2980">    <span><span>//</span> then the next subst (for B&lt;!0&gt;) will be</span></td>
      </tr>
      <tr>
        <td id="L2981" data-line-number="2981"></td>
        <td id="LC2981">    <span><span>//</span>   0 --&gt; Dictionary&lt; List&lt;T&gt;, T[] &gt;</span></td>
      </tr>
      <tr>
        <td id="L2982" data-line-number="2982"></td>
        <td id="LC2982">
</td>
      </tr>
      <tr>
        <td id="L2983" data-line-number="2983"></td>
        <td id="LC2983">    Substitution <span>GetSubstitutionForParent</span>(<span>const</span> Substitution *pSubst);</td>
      </tr>
      <tr>
        <td id="L2984" data-line-number="2984"></td>
        <td id="LC2984">
</td>
      </tr>
      <tr>
        <td id="L2985" data-line-number="2985"></td>
        <td id="LC2985">    <span>inline</span> DWORD <span>GetAttrClass</span>();</td>
      </tr>
      <tr>
        <td id="L2986" data-line-number="2986"></td>
        <td id="LC2986">
</td>
      </tr>
      <tr>
        <td id="L2987" data-line-number="2987"></td>
        <td id="LC2987">    <span>inline</span> BOOL <span>HasFieldsWhichMustBeInited</span>();</td>
      </tr>
      <tr>
        <td id="L2988" data-line-number="2988"></td>
        <td id="LC2988">
</td>
      </tr>
      <tr>
        <td id="L2989" data-line-number="2989"></td>
        <td id="LC2989">    <span>inline</span> BOOL <span>IsPreRestored</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L2990" data-line-number="2990"></td>
        <td id="LC2990">    {</td>
      </tr>
      <tr>
        <td id="L2991" data-line-number="2991"></td>
        <td id="LC2991">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L2992" data-line-number="2992"></td>
        <td id="LC2992">
</td>
      </tr>
      <tr>
        <td id="L2993" data-line-number="2993"></td>
        <td id="LC2993">#<span>ifdef</span> FEATURE_PREJIT</td>
      </tr>
      <tr>
        <td id="L2994" data-line-number="2994"></td>
        <td id="LC2994">        <span>return</span> <span>GetFlag</span>(enum_flag_IsPreRestored);</td>
      </tr>
      <tr>
        <td id="L2995" data-line-number="2995"></td>
        <td id="LC2995">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L2996" data-line-number="2996"></td>
        <td id="LC2996">        <span>return</span> <span>FALSE</span>;</td>
      </tr>
      <tr>
        <td id="L2997" data-line-number="2997"></td>
        <td id="LC2997">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L2998" data-line-number="2998"></td>
        <td id="LC2998">    }</td>
      </tr>
      <tr>
        <td id="L2999" data-line-number="2999"></td>
        <td id="LC2999">
</td>
      </tr>
      <tr>
        <td id="L3000" data-line-number="3000"></td>
        <td id="LC3000">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3001" data-line-number="3001"></td>
        <td id="LC3001">    <span><span>//</span> THE EXPOSED CLASS OBJECT</span></td>
      </tr>
      <tr>
        <td id="L3002" data-line-number="3002"></td>
        <td id="LC3002">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3003" data-line-number="3003"></td>
        <td id="LC3003">    <span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L3004" data-line-number="3004"></td>
        <td id="LC3004"><span>     * m_ExposedClassObject is a RuntimeType instance for this class.  But</span></td>
      </tr>
      <tr>
        <td id="L3005" data-line-number="3005"></td>
        <td id="LC3005"><span>     * do NOT use it for Arrays or remoted objects!  All arrays of objects</span></td>
      </tr>
      <tr>
        <td id="L3006" data-line-number="3006"></td>
        <td id="LC3006"><span>     * share the same MethodTable/EEClass.</span></td>
      </tr>
      <tr>
        <td id="L3007" data-line-number="3007"></td>
        <td id="LC3007"><span>     * @GENERICS: this is per-instantiation data</span></td>
      </tr>
      <tr>
        <td id="L3008" data-line-number="3008"></td>
        <td id="LC3008"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3009" data-line-number="3009"></td>
        <td id="LC3009">    <span><span>//</span> There are two version of GetManagedClassObject.  The GetManagedClassObject()</span></td>
      </tr>
      <tr>
        <td id="L3010" data-line-number="3010"></td>
        <td id="LC3010">    <span><span>//</span>  method will get the class object.  If it doesn't exist it will be created.</span></td>
      </tr>
      <tr>
        <td id="L3011" data-line-number="3011"></td>
        <td id="LC3011">    <span><span>//</span>  GetManagedClassObjectIfExists() will return null if the Type object doesn't exist.</span></td>
      </tr>
      <tr>
        <td id="L3012" data-line-number="3012"></td>
        <td id="LC3012">    OBJECTREF <span>GetManagedClassObject</span>();</td>
      </tr>
      <tr>
        <td id="L3013" data-line-number="3013"></td>
        <td id="LC3013">    OBJECTREF <span>GetManagedClassObjectIfExists</span>();</td>
      </tr>
      <tr>
        <td id="L3014" data-line-number="3014"></td>
        <td id="LC3014">
</td>
      </tr>
      <tr>
        <td id="L3015" data-line-number="3015"></td>
        <td id="LC3015">
</td>
      </tr>
      <tr>
        <td id="L3016" data-line-number="3016"></td>
        <td id="LC3016">    <span><span>//</span> ------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3017" data-line-number="3017"></td>
        <td id="LC3017">    <span><span>//</span> Private part of MethodTable</span></td>
      </tr>
      <tr>
        <td id="L3018" data-line-number="3018"></td>
        <td id="LC3018">    <span><span>//</span> ------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3019" data-line-number="3019"></td>
        <td id="LC3019">
</td>
      </tr>
      <tr>
        <td id="L3020" data-line-number="3020"></td>
        <td id="LC3020">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L3021" data-line-number="3021"></td>
        <td id="LC3021">    <span>inline</span> <span>void</span> <span>SetWriteableData</span>(PTR_MethodTableWriteableData pMTWriteableData)</td>
      </tr>
      <tr>
        <td id="L3022" data-line-number="3022"></td>
        <td id="LC3022">    {</td>
      </tr>
      <tr>
        <td id="L3023" data-line-number="3023"></td>
        <td id="LC3023">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3024" data-line-number="3024"></td>
        <td id="LC3024">        <span>_ASSERTE</span>(pMTWriteableData);</td>
      </tr>
      <tr>
        <td id="L3025" data-line-number="3025"></td>
        <td id="LC3025">        m_pWriteableData.<span>SetValue</span>(pMTWriteableData);</td>
      </tr>
      <tr>
        <td id="L3026" data-line-number="3026"></td>
        <td id="LC3026">    }</td>
      </tr>
      <tr>
        <td id="L3027" data-line-number="3027"></td>
        <td id="LC3027">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3028" data-line-number="3028"></td>
        <td id="LC3028">
</td>
      </tr>
      <tr>
        <td id="L3029" data-line-number="3029"></td>
        <td id="LC3029">    <span>inline</span> PTR_Const_MethodTableWriteableData <span>GetWriteableData</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L3030" data-line-number="3030"></td>
        <td id="LC3030">    {</td>
      </tr>
      <tr>
        <td id="L3031" data-line-number="3031"></td>
        <td id="LC3031">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3032" data-line-number="3032"></td>
        <td id="LC3032">        g_IBCLogger.<span>LogMethodTableWriteableDataAccess</span>(this);</td>
      </tr>
      <tr>
        <td id="L3033" data-line-number="3033"></td>
        <td id="LC3033">        <span>return</span> <span>GetWriteableData_NoLogging</span>();</td>
      </tr>
      <tr>
        <td id="L3034" data-line-number="3034"></td>
        <td id="LC3034">    }</td>
      </tr>
      <tr>
        <td id="L3035" data-line-number="3035"></td>
        <td id="LC3035">
</td>
      </tr>
      <tr>
        <td id="L3036" data-line-number="3036"></td>
        <td id="LC3036">    <span>inline</span> PTR_Const_MethodTableWriteableData <span>GetWriteableData_NoLogging</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L3037" data-line-number="3037"></td>
        <td id="LC3037">    {</td>
      </tr>
      <tr>
        <td id="L3038" data-line-number="3038"></td>
        <td id="LC3038">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3039" data-line-number="3039"></td>
        <td id="LC3039">        <span>return</span> <span>ReadPointer</span>(this, &amp;MethodTable::m_pWriteableData);</td>
      </tr>
      <tr>
        <td id="L3040" data-line-number="3040"></td>
        <td id="LC3040">    }</td>
      </tr>
      <tr>
        <td id="L3041" data-line-number="3041"></td>
        <td id="LC3041">
</td>
      </tr>
      <tr>
        <td id="L3042" data-line-number="3042"></td>
        <td id="LC3042">    <span>inline</span> PTR_MethodTableWriteableData <span>GetWriteableDataForWrite</span>()</td>
      </tr>
      <tr>
        <td id="L3043" data-line-number="3043"></td>
        <td id="LC3043">    {</td>
      </tr>
      <tr>
        <td id="L3044" data-line-number="3044"></td>
        <td id="LC3044">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3045" data-line-number="3045"></td>
        <td id="LC3045">        g_IBCLogger.<span>LogMethodTableWriteableDataWriteAccess</span>(this);</td>
      </tr>
      <tr>
        <td id="L3046" data-line-number="3046"></td>
        <td id="LC3046">        <span>return</span> <span>GetWriteableDataForWrite_NoLogging</span>();</td>
      </tr>
      <tr>
        <td id="L3047" data-line-number="3047"></td>
        <td id="LC3047">    }</td>
      </tr>
      <tr>
        <td id="L3048" data-line-number="3048"></td>
        <td id="LC3048">
</td>
      </tr>
      <tr>
        <td id="L3049" data-line-number="3049"></td>
        <td id="LC3049">    <span>inline</span> PTR_MethodTableWriteableData <span>GetWriteableDataForWrite_NoLogging</span>()</td>
      </tr>
      <tr>
        <td id="L3050" data-line-number="3050"></td>
        <td id="LC3050">    {</td>
      </tr>
      <tr>
        <td id="L3051" data-line-number="3051"></td>
        <td id="LC3051">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3052" data-line-number="3052"></td>
        <td id="LC3052">        <span>return</span> <span>ReadPointer</span>(this, &amp;MethodTable::m_pWriteableData);</td>
      </tr>
      <tr>
        <td id="L3053" data-line-number="3053"></td>
        <td id="LC3053">    }</td>
      </tr>
      <tr>
        <td id="L3054" data-line-number="3054"></td>
        <td id="LC3054">
</td>
      </tr>
      <tr>
        <td id="L3055" data-line-number="3055"></td>
        <td id="LC3055">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3056" data-line-number="3056"></td>
        <td id="LC3056">    <span><span>//</span> The GUID Info</span></td>
      </tr>
      <tr>
        <td id="L3057" data-line-number="3057"></td>
        <td id="LC3057">    <span><span>//</span> Used by COM interop to get GUIDs (IIDs and CLSIDs)</span></td>
      </tr>
      <tr>
        <td id="L3058" data-line-number="3058"></td>
        <td id="LC3058">
</td>
      </tr>
      <tr>
        <td id="L3059" data-line-number="3059"></td>
        <td id="LC3059">    <span><span>//</span> Get/store cached GUID information</span></td>
      </tr>
      <tr>
        <td id="L3060" data-line-number="3060"></td>
        <td id="LC3060">    PTR_GuidInfo <span>GetGuidInfo</span>();</td>
      </tr>
      <tr>
        <td id="L3061" data-line-number="3061"></td>
        <td id="LC3061">    <span>void</span> <span>SetGuidInfo</span>(GuidInfo* pGuidInfo);</td>
      </tr>
      <tr>
        <td id="L3062" data-line-number="3062"></td>
        <td id="LC3062">
</td>
      </tr>
      <tr>
        <td id="L3063" data-line-number="3063"></td>
        <td id="LC3063">    <span><span>//</span> Get and cache the GUID for this interface/class</span></td>
      </tr>
      <tr>
        <td id="L3064" data-line-number="3064"></td>
        <td id="LC3064">    HRESULT <span>GetGuidNoThrow</span>(GUID *pGuid, BOOL bGenerateIfNotFound, BOOL bClassic = <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L3065" data-line-number="3065"></td>
        <td id="LC3065">
</td>
      </tr>
      <tr>
        <td id="L3066" data-line-number="3066"></td>
        <td id="LC3066">    <span><span>//</span> Get and cache the GUID for this interface/class</span></td>
      </tr>
      <tr>
        <td id="L3067" data-line-number="3067"></td>
        <td id="LC3067">    <span>void</span>    <span>GetGuid</span>(GUID *pGuid, BOOL bGenerateIfNotFound, BOOL bClassic = <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L3068" data-line-number="3068"></td>
        <td id="LC3068">
</td>
      </tr>
      <tr>
        <td id="L3069" data-line-number="3069"></td>
        <td id="LC3069">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L3070" data-line-number="3070"></td>
        <td id="LC3070">    <span><span>//</span> Get the GUID used for WinRT interop</span></td>
      </tr>
      <tr>
        <td id="L3071" data-line-number="3071"></td>
        <td id="LC3071">    <span><span>//</span>   * for projection generic interfaces returns the equivalent WinRT type's GUID</span></td>
      </tr>
      <tr>
        <td id="L3072" data-line-number="3072"></td>
        <td id="LC3072">    <span><span>//</span>   * for everything else returns the GetGuid(, TRUE)</span></td>
      </tr>
      <tr>
        <td id="L3073" data-line-number="3073"></td>
        <td id="LC3073">    BOOL    <span>GetGuidForWinRT</span>(GUID *pGuid);</td>
      </tr>
      <tr>
        <td id="L3074" data-line-number="3074"></td>
        <td id="LC3074">
</td>
      </tr>
      <tr>
        <td id="L3075" data-line-number="3075"></td>
        <td id="LC3075">private:</td>
      </tr>
      <tr>
        <td id="L3076" data-line-number="3076"></td>
        <td id="LC3076">    <span><span>//</span> Create RCW data associated with this type.</span></td>
      </tr>
      <tr>
        <td id="L3077" data-line-number="3077"></td>
        <td id="LC3077">    RCWPerTypeData *<span>CreateRCWPerTypeData</span>(<span>bool</span> bThrowOnOOM);</td>
      </tr>
      <tr>
        <td id="L3078" data-line-number="3078"></td>
        <td id="LC3078">
</td>
      </tr>
      <tr>
        <td id="L3079" data-line-number="3079"></td>
        <td id="LC3079">public:</td>
      </tr>
      <tr>
        <td id="L3080" data-line-number="3080"></td>
        <td id="LC3080">    <span><span>//</span> Get the RCW data associated with this type or NULL if the type does not need such data or allocation</span></td>
      </tr>
      <tr>
        <td id="L3081" data-line-number="3081"></td>
        <td id="LC3081">    <span><span>//</span> failed (only if bThrowOnOOM is false).</span></td>
      </tr>
      <tr>
        <td id="L3082" data-line-number="3082"></td>
        <td id="LC3082">    RCWPerTypeData *<span>GetRCWPerTypeData</span>(<span>bool</span> bThrowOnOOM = <span>true</span>);</td>
      </tr>
      <tr>
        <td id="L3083" data-line-number="3083"></td>
        <td id="LC3083">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L3084" data-line-number="3084"></td>
        <td id="LC3084">
</td>
      </tr>
      <tr>
        <td id="L3085" data-line-number="3085"></td>
        <td id="LC3085">    <span><span>//</span> Convenience method - determine if the interface/class has a guid specified (even if not yet cached)</span></td>
      </tr>
      <tr>
        <td id="L3086" data-line-number="3086"></td>
        <td id="LC3086">    BOOL <span>HasExplicitGuid</span>();</td>
      </tr>
      <tr>
        <td id="L3087" data-line-number="3087"></td>
        <td id="LC3087">
</td>
      </tr>
      <tr>
        <td id="L3088" data-line-number="3088"></td>
        <td id="LC3088">public :</td>
      </tr>
      <tr>
        <td id="L3089" data-line-number="3089"></td>
        <td id="LC3089">    <span><span>//</span> Helper routines for the GetFullyQualifiedNameForClass macros defined at the top of class.h.</span></td>
      </tr>
      <tr>
        <td id="L3090" data-line-number="3090"></td>
        <td id="LC3090">    <span><span>//</span> You probably should not use these functions directly.</span></td>
      </tr>
      <tr>
        <td id="L3091" data-line-number="3091"></td>
        <td id="LC3091">    SString &amp;<span>_GetFullyQualifiedNameForClassNestedAware</span>(SString &amp;ssBuf);</td>
      </tr>
      <tr>
        <td id="L3092" data-line-number="3092"></td>
        <td id="LC3092">    SString &amp;<span>_GetFullyQualifiedNameForClass</span>(SString &amp;ssBuf);</td>
      </tr>
      <tr>
        <td id="L3093" data-line-number="3093"></td>
        <td id="LC3093">    LPCUTF8 <span>GetFullyQualifiedNameInfo</span>(LPCUTF8 *ppszNamespace);</td>
      </tr>
      <tr>
        <td id="L3094" data-line-number="3094"></td>
        <td id="LC3094">
</td>
      </tr>
      <tr>
        <td id="L3095" data-line-number="3095"></td>
        <td id="LC3095">private:</td>
      </tr>
      <tr>
        <td id="L3096" data-line-number="3096"></td>
        <td id="LC3096">    template&lt;typename RedirectFunctor&gt; SString &amp;<span>_GetFullyQualifiedNameForClassNestedAwareInternal</span>(SString &amp;ssBuf);</td>
      </tr>
      <tr>
        <td id="L3097" data-line-number="3097"></td>
        <td id="LC3097">
</td>
      </tr>
      <tr>
        <td id="L3098" data-line-number="3098"></td>
        <td id="LC3098">public :</td>
      </tr>
      <tr>
        <td id="L3099" data-line-number="3099"></td>
        <td id="LC3099">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3100" data-line-number="3100"></td>
        <td id="LC3100">    <span><span>//</span> Debug Info</span></td>
      </tr>
      <tr>
        <td id="L3101" data-line-number="3101"></td>
        <td id="LC3101">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3102" data-line-number="3102"></td>
        <td id="LC3102">
</td>
      </tr>
      <tr>
        <td id="L3103" data-line-number="3103"></td>
        <td id="LC3103">
</td>
      </tr>
      <tr>
        <td id="L3104" data-line-number="3104"></td>
        <td id="LC3104">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L3105" data-line-number="3105"></td>
        <td id="LC3105">    <span>inline</span> LPCUTF8 <span>GetDebugClassName</span>()</td>
      </tr>
      <tr>
        <td id="L3106" data-line-number="3106"></td>
        <td id="LC3106">    {</td>
      </tr>
      <tr>
        <td id="L3107" data-line-number="3107"></td>
        <td id="LC3107">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3108" data-line-number="3108"></td>
        <td id="LC3108">        <span>return</span> debug_m_szClassName;</td>
      </tr>
      <tr>
        <td id="L3109" data-line-number="3109"></td>
        <td id="LC3109">    }</td>
      </tr>
      <tr>
        <td id="L3110" data-line-number="3110"></td>
        <td id="LC3110">    <span>inline</span> <span>void</span> <span>SetDebugClassName</span>(LPCUTF8 name)</td>
      </tr>
      <tr>
        <td id="L3111" data-line-number="3111"></td>
        <td id="LC3111">    {</td>
      </tr>
      <tr>
        <td id="L3112" data-line-number="3112"></td>
        <td id="LC3112">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3113" data-line-number="3113"></td>
        <td id="LC3113">        debug_m_szClassName = name;</td>
      </tr>
      <tr>
        <td id="L3114" data-line-number="3114"></td>
        <td id="LC3114">    }</td>
      </tr>
      <tr>
        <td id="L3115" data-line-number="3115"></td>
        <td id="LC3115">
</td>
      </tr>
      <tr>
        <td id="L3116" data-line-number="3116"></td>
        <td id="LC3116">    <span><span>//</span> Was the type created with injected duplicates?</span></td>
      </tr>
      <tr>
        <td id="L3117" data-line-number="3117"></td>
        <td id="LC3117">    <span><span>//</span> TRUE means that we tried to inject duplicates (not that we found one to inject).</span></td>
      </tr>
      <tr>
        <td id="L3118" data-line-number="3118"></td>
        <td id="LC3118">    <span>inline</span> BOOL <span>Debug_HasInjectedInterfaceDuplicates</span>() <span>const</span></td>
      </tr>
      <tr>
        <td id="L3119" data-line-number="3119"></td>
        <td id="LC3119">    {</td>
      </tr>
      <tr>
        <td id="L3120" data-line-number="3120"></td>
        <td id="LC3120">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3121" data-line-number="3121"></td>
        <td id="LC3121">        <span>return</span> (<span>GetWriteableData</span>()-&gt;<span>m_dwFlags</span> &amp; MethodTableWriteableData::enum_flag_HasInjectedInterfaceDuplicates) != <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3122" data-line-number="3122"></td>
        <td id="LC3122">    }</td>
      </tr>
      <tr>
        <td id="L3123" data-line-number="3123"></td>
        <td id="LC3123">    <span>inline</span> <span>void</span> <span>Debug_SetHasInjectedInterfaceDuplicates</span>()</td>
      </tr>
      <tr>
        <td id="L3124" data-line-number="3124"></td>
        <td id="LC3124">    {</td>
      </tr>
      <tr>
        <td id="L3125" data-line-number="3125"></td>
        <td id="LC3125">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3126" data-line-number="3126"></td>
        <td id="LC3126">        <span>GetWriteableDataForWrite</span>()-&gt;<span>m_dwFlags</span> |= MethodTableWriteableData::enum_flag_HasInjectedInterfaceDuplicates;</td>
      </tr>
      <tr>
        <td id="L3127" data-line-number="3127"></td>
        <td id="LC3127">    }</td>
      </tr>
      <tr>
        <td id="L3128" data-line-number="3128"></td>
        <td id="LC3128">#<span>endif</span> <span><span>//</span> _DEBUG</span></td>
      </tr>
      <tr>
        <td id="L3129" data-line-number="3129"></td>
        <td id="LC3129">
</td>
      </tr>
      <tr>
        <td id="L3130" data-line-number="3130"></td>
        <td id="LC3130">
</td>
      </tr>
      <tr>
        <td id="L3131" data-line-number="3131"></td>
        <td id="LC3131">#<span>ifndef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L3132" data-line-number="3132"></td>
        <td id="LC3132">public:</td>
      </tr>
      <tr>
        <td id="L3133" data-line-number="3133"></td>
        <td id="LC3133">    <span><span>//</span>--------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3134" data-line-number="3134"></td>
        <td id="LC3134">    class MethodData</td>
      </tr>
      <tr>
        <td id="L3135" data-line-number="3135"></td>
        <td id="LC3135">    {</td>
      </tr>
      <tr>
        <td id="L3136" data-line-number="3136"></td>
        <td id="LC3136">      public:</td>
      </tr>
      <tr>
        <td id="L3137" data-line-number="3137"></td>
        <td id="LC3137">        <span>inline</span> ULONG <span>AddRef</span>()</td>
      </tr>
      <tr>
        <td id="L3138" data-line-number="3138"></td>
        <td id="LC3138">            { LIMITED_METHOD_CONTRACT; <span>return</span> (ULONG) <span>InterlockedIncrement</span>((LONG*)&amp;m_cRef); }</td>
      </tr>
      <tr>
        <td id="L3139" data-line-number="3139"></td>
        <td id="LC3139">
</td>
      </tr>
      <tr>
        <td id="L3140" data-line-number="3140"></td>
        <td id="LC3140">        ULONG <span>Release</span>();</td>
      </tr>
      <tr>
        <td id="L3141" data-line-number="3141"></td>
        <td id="LC3141">
</td>
      </tr>
      <tr>
        <td id="L3142" data-line-number="3142"></td>
        <td id="LC3142">        <span><span>//</span> Since all methods that return a MethodData already AddRef'd, we do NOT</span></td>
      </tr>
      <tr>
        <td id="L3143" data-line-number="3143"></td>
        <td id="LC3143">        <span><span>//</span> want to AddRef when putting a holder around it. We only want to release it.</span></td>
      </tr>
      <tr>
        <td id="L3144" data-line-number="3144"></td>
        <td id="LC3144">        <span>static</span> <span>void</span> <span>HolderAcquire</span>(MethodData *pEntry)</td>
      </tr>
      <tr>
        <td id="L3145" data-line-number="3145"></td>
        <td id="LC3145">            { LIMITED_METHOD_CONTRACT; <span>return</span>; }</td>
      </tr>
      <tr>
        <td id="L3146" data-line-number="3146"></td>
        <td id="LC3146">        <span>static</span> <span>void</span> <span>HolderRelease</span>(MethodData *pEntry)</td>
      </tr>
      <tr>
        <td id="L3147" data-line-number="3147"></td>
        <td id="LC3147">            { WRAPPER_NO_CONTRACT; <span>if</span> (pEntry != <span>NULL</span>) pEntry-&gt;<span>Release</span>(); }</td>
      </tr>
      <tr>
        <td id="L3148" data-line-number="3148"></td>
        <td id="LC3148">
</td>
      </tr>
      <tr>
        <td id="L3149" data-line-number="3149"></td>
        <td id="LC3149">      protected:</td>
      </tr>
      <tr>
        <td id="L3150" data-line-number="3150"></td>
        <td id="LC3150">        ULONG m_cRef;</td>
      </tr>
      <tr>
        <td id="L3151" data-line-number="3151"></td>
        <td id="LC3151">        MethodTable *<span>const</span> m_pImplMT;</td>
      </tr>
      <tr>
        <td id="L3152" data-line-number="3152"></td>
        <td id="LC3152">        MethodTable *<span>const</span> m_pDeclMT;</td>
      </tr>
      <tr>
        <td id="L3153" data-line-number="3153"></td>
        <td id="LC3153">
</td>
      </tr>
      <tr>
        <td id="L3154" data-line-number="3154"></td>
        <td id="LC3154">      public:</td>
      </tr>
      <tr>
        <td id="L3155" data-line-number="3155"></td>
        <td id="LC3155">        <span>MethodData</span>(MethodTable *implMT, MethodTable *declMT) : <span>m_cRef</span>(<span>1</span>), <span>m_pImplMT</span>(implMT), <span>m_pDeclMT</span>(declMT) { LIMITED_METHOD_CONTRACT; }</td>
      </tr>
      <tr>
        <td id="L3156" data-line-number="3156"></td>
        <td id="LC3156">        virtual ~<span>MethodData</span>() { LIMITED_METHOD_CONTRACT; }</td>
      </tr>
      <tr>
        <td id="L3157" data-line-number="3157"></td>
        <td id="LC3157">
</td>
      </tr>
      <tr>
        <td id="L3158" data-line-number="3158"></td>
        <td id="LC3158">        virtual MethodData  *<span>GetDeclMethodData</span>() = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3159" data-line-number="3159"></td>
        <td id="LC3159">        MethodTable *<span>GetDeclMethodTable</span>() { <span>return</span> m_pDeclMT; }</td>
      </tr>
      <tr>
        <td id="L3160" data-line-number="3160"></td>
        <td id="LC3160">        virtual MethodDesc  *<span>GetDeclMethodDesc</span>(UINT32 slotNumber) = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3161" data-line-number="3161"></td>
        <td id="LC3161">
</td>
      </tr>
      <tr>
        <td id="L3162" data-line-number="3162"></td>
        <td id="LC3162">        virtual MethodData  *<span>GetImplMethodData</span>() = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3163" data-line-number="3163"></td>
        <td id="LC3163">        MethodTable *<span>GetImplMethodTable</span>() { <span>return</span> m_pImplMT; }</td>
      </tr>
      <tr>
        <td id="L3164" data-line-number="3164"></td>
        <td id="LC3164">        virtual DispatchSlot <span>GetImplSlot</span>(UINT32 slotNumber) = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3165" data-line-number="3165"></td>
        <td id="LC3165">        <span><span>//</span> Returns INVALID_SLOT_NUMBER if no implementation exists.</span></td>
      </tr>
      <tr>
        <td id="L3166" data-line-number="3166"></td>
        <td id="LC3166">        virtual UINT32       <span>GetImplSlotNumber</span>(UINT32 slotNumber) = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3167" data-line-number="3167"></td>
        <td id="LC3167">        virtual MethodDesc  *<span>GetImplMethodDesc</span>(UINT32 slotNumber) = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3168" data-line-number="3168"></td>
        <td id="LC3168">        virtual <span>void</span> <span>InvalidateCachedVirtualSlot</span>(UINT32 slotNumber) = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3169" data-line-number="3169"></td>
        <td id="LC3169">
</td>
      </tr>
      <tr>
        <td id="L3170" data-line-number="3170"></td>
        <td id="LC3170">        virtual UINT32 <span>GetNumVirtuals</span>() = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3171" data-line-number="3171"></td>
        <td id="LC3171">        virtual UINT32 <span>GetNumMethods</span>() = <span>0</span>;</td>
      </tr>
      <tr>
        <td id="L3172" data-line-number="3172"></td>
        <td id="LC3172">
</td>
      </tr>
      <tr>
        <td id="L3173" data-line-number="3173"></td>
        <td id="LC3173">      protected:</td>
      </tr>
      <tr>
        <td id="L3174" data-line-number="3174"></td>
        <td id="LC3174">        <span>static</span> <span>const</span> UINT32 INVALID_SLOT_NUMBER = UINT32_MAX;</td>
      </tr>
      <tr>
        <td id="L3175" data-line-number="3175"></td>
        <td id="LC3175">
</td>
      </tr>
      <tr>
        <td id="L3176" data-line-number="3176"></td>
        <td id="LC3176">        <span><span>//</span> This is used when building the data</span></td>
      </tr>
      <tr>
        <td id="L3177" data-line-number="3177"></td>
        <td id="LC3177">        <span>struct</span> MethodDataEntry</td>
      </tr>
      <tr>
        <td id="L3178" data-line-number="3178"></td>
        <td id="LC3178">        {</td>
      </tr>
      <tr>
        <td id="L3179" data-line-number="3179"></td>
        <td id="LC3179">          private:</td>
      </tr>
      <tr>
        <td id="L3180" data-line-number="3180"></td>
        <td id="LC3180">            <span>static</span> <span>const</span> UINT32 INVALID_CHAIN_AND_INDEX = (UINT32)(-<span>1</span>);</td>
      </tr>
      <tr>
        <td id="L3181" data-line-number="3181"></td>
        <td id="LC3181">            <span>static</span> <span>const</span> UINT16 INVALID_IMPL_SLOT_NUM = (UINT16)(-<span>1</span>);</td>
      </tr>
      <tr>
        <td id="L3182" data-line-number="3182"></td>
        <td id="LC3182">
</td>
      </tr>
      <tr>
        <td id="L3183" data-line-number="3183"></td>
        <td id="LC3183">            <span><span>//</span> This contains both the chain delta and the table index. The</span></td>
      </tr>
      <tr>
        <td id="L3184" data-line-number="3184"></td>
        <td id="LC3184">            <span><span>//</span> reason that they are combined is that we need atomic update</span></td>
      </tr>
      <tr>
        <td id="L3185" data-line-number="3185"></td>
        <td id="LC3185">            <span><span>//</span> of both, and it is convenient that both are on UINT16 in size.</span></td>
      </tr>
      <tr>
        <td id="L3186" data-line-number="3186"></td>
        <td id="LC3186">            UINT32           m_chainDeltaAndTableIndex;</td>
      </tr>
      <tr>
        <td id="L3187" data-line-number="3187"></td>
        <td id="LC3187">            UINT16           m_implSlotNum;     <span><span>//</span> For virtually remapped slots</span></td>
      </tr>
      <tr>
        <td id="L3188" data-line-number="3188"></td>
        <td id="LC3188">            DispatchSlot     m_slot;            <span><span>//</span> The entry in the DispatchImplTable</span></td>
      </tr>
      <tr>
        <td id="L3189" data-line-number="3189"></td>
        <td id="LC3189">            MethodDesc      *m_pMD;             <span><span>//</span> The MethodDesc for this slot</span></td>
      </tr>
      <tr>
        <td id="L3190" data-line-number="3190"></td>
        <td id="LC3190">
</td>
      </tr>
      <tr>
        <td id="L3191" data-line-number="3191"></td>
        <td id="LC3191">          public:</td>
      </tr>
      <tr>
        <td id="L3192" data-line-number="3192"></td>
        <td id="LC3192">            <span>inline</span> <span>MethodDataEntry</span>() : <span>m_slot</span>(<span>NULL</span>)</td>
      </tr>
      <tr>
        <td id="L3193" data-line-number="3193"></td>
        <td id="LC3193">                { WRAPPER_NO_CONTRACT; <span>Init</span>(); }</td>
      </tr>
      <tr>
        <td id="L3194" data-line-number="3194"></td>
        <td id="LC3194">
</td>
      </tr>
      <tr>
        <td id="L3195" data-line-number="3195"></td>
        <td id="LC3195">            <span>inline</span> <span>void</span> <span>Init</span>()</td>
      </tr>
      <tr>
        <td id="L3196" data-line-number="3196"></td>
        <td id="LC3196">            {</td>
      </tr>
      <tr>
        <td id="L3197" data-line-number="3197"></td>
        <td id="LC3197">                LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3198" data-line-number="3198"></td>
        <td id="LC3198">                m_chainDeltaAndTableIndex = INVALID_CHAIN_AND_INDEX;</td>
      </tr>
      <tr>
        <td id="L3199" data-line-number="3199"></td>
        <td id="LC3199">                m_implSlotNum = INVALID_IMPL_SLOT_NUM;</td>
      </tr>
      <tr>
        <td id="L3200" data-line-number="3200"></td>
        <td id="LC3200">                m_slot = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L3201" data-line-number="3201"></td>
        <td id="LC3201">                m_pMD = <span>NULL</span>;</td>
      </tr>
      <tr>
        <td id="L3202" data-line-number="3202"></td>
        <td id="LC3202">            }</td>
      </tr>
      <tr>
        <td id="L3203" data-line-number="3203"></td>
        <td id="LC3203">
</td>
      </tr>
      <tr>
        <td id="L3204" data-line-number="3204"></td>
        <td id="LC3204">            <span>inline</span> BOOL <span>IsDeclInit</span>()</td>
      </tr>
      <tr>
        <td id="L3205" data-line-number="3205"></td>
        <td id="LC3205">                { LIMITED_METHOD_CONTRACT; <span>return</span> m_chainDeltaAndTableIndex != INVALID_CHAIN_AND_INDEX; }</td>
      </tr>
      <tr>
        <td id="L3206" data-line-number="3206"></td>
        <td id="LC3206">            <span>inline</span> BOOL <span>IsImplInit</span>()</td>
      </tr>
      <tr>
        <td id="L3207" data-line-number="3207"></td>
        <td id="LC3207">                { LIMITED_METHOD_CONTRACT; <span>return</span> m_implSlotNum != INVALID_IMPL_SLOT_NUM; }</td>
      </tr>
      <tr>
        <td id="L3208" data-line-number="3208"></td>
        <td id="LC3208">
</td>
      </tr>
      <tr>
        <td id="L3209" data-line-number="3209"></td>
        <td id="LC3209">            <span>inline</span> <span>void</span> <span>SetDeclData</span>(UINT32 chainDelta, UINT32 tableIndex)</td>
      </tr>
      <tr>
        <td id="L3210" data-line-number="3210"></td>
        <td id="LC3210">                { LIMITED_METHOD_CONTRACT; m_chainDeltaAndTableIndex = ((((UINT16) chainDelta) &lt;&lt; <span>16</span>) | ((UINT16) tableIndex)); }</td>
      </tr>
      <tr>
        <td id="L3211" data-line-number="3211"></td>
        <td id="LC3211">            <span>inline</span> UINT32 <span>GetChainDelta</span>()</td>
      </tr>
      <tr>
        <td id="L3212" data-line-number="3212"></td>
        <td id="LC3212">                { LIMITED_METHOD_CONTRACT; <span>CONSISTENCY_CHECK</span>(<span>IsDeclInit</span>()); <span>return</span> m_chainDeltaAndTableIndex &gt;&gt; <span>16</span>; }</td>
      </tr>
      <tr>
        <td id="L3213" data-line-number="3213"></td>
        <td id="LC3213">            <span>inline</span> UINT32 <span>GetTableIndex</span>()</td>
      </tr>
      <tr>
        <td id="L3214" data-line-number="3214"></td>
        <td id="LC3214">                { LIMITED_METHOD_CONTRACT; <span>CONSISTENCY_CHECK</span>(<span>IsDeclInit</span>()); <span>return</span> (m_chainDeltaAndTableIndex &amp; (UINT32)UINT16_MAX); }</td>
      </tr>
      <tr>
        <td id="L3215" data-line-number="3215"></td>
        <td id="LC3215">
</td>
      </tr>
      <tr>
        <td id="L3216" data-line-number="3216"></td>
        <td id="LC3216">            <span>inline</span> <span>void</span> <span>SetImplData</span>(UINT32 implSlotNum)</td>
      </tr>
      <tr>
        <td id="L3217" data-line-number="3217"></td>
        <td id="LC3217">                { LIMITED_METHOD_CONTRACT; m_implSlotNum = (UINT16) implSlotNum; }</td>
      </tr>
      <tr>
        <td id="L3218" data-line-number="3218"></td>
        <td id="LC3218">            <span>inline</span> UINT32 <span>GetImplSlotNum</span>()</td>
      </tr>
      <tr>
        <td id="L3219" data-line-number="3219"></td>
        <td id="LC3219">                { LIMITED_METHOD_CONTRACT; <span>CONSISTENCY_CHECK</span>(<span>IsImplInit</span>()); <span>return</span> m_implSlotNum; }</td>
      </tr>
      <tr>
        <td id="L3220" data-line-number="3220"></td>
        <td id="LC3220">
</td>
      </tr>
      <tr>
        <td id="L3221" data-line-number="3221"></td>
        <td id="LC3221">            <span>inline</span> <span>void</span> <span>SetSlot</span>(DispatchSlot slot)</td>
      </tr>
      <tr>
        <td id="L3222" data-line-number="3222"></td>
        <td id="LC3222">                { LIMITED_METHOD_CONTRACT; m_slot = slot; }</td>
      </tr>
      <tr>
        <td id="L3223" data-line-number="3223"></td>
        <td id="LC3223">            <span>inline</span> DispatchSlot <span>GetSlot</span>()</td>
      </tr>
      <tr>
        <td id="L3224" data-line-number="3224"></td>
        <td id="LC3224">                { LIMITED_METHOD_CONTRACT; <span>return</span> m_slot; }</td>
      </tr>
      <tr>
        <td id="L3225" data-line-number="3225"></td>
        <td id="LC3225">
</td>
      </tr>
      <tr>
        <td id="L3226" data-line-number="3226"></td>
        <td id="LC3226">            <span>inline</span> <span>void</span> <span>SetMethodDesc</span>(MethodDesc *pMD)</td>
      </tr>
      <tr>
        <td id="L3227" data-line-number="3227"></td>
        <td id="LC3227">                { LIMITED_METHOD_CONTRACT; m_pMD = pMD; }</td>
      </tr>
      <tr>
        <td id="L3228" data-line-number="3228"></td>
        <td id="LC3228">            <span>inline</span> MethodDesc *<span>GetMethodDesc</span>()</td>
      </tr>
      <tr>
        <td id="L3229" data-line-number="3229"></td>
        <td id="LC3229">                { LIMITED_METHOD_CONTRACT; <span>return</span> m_pMD; }</td>
      </tr>
      <tr>
        <td id="L3230" data-line-number="3230"></td>
        <td id="LC3230">
</td>
      </tr>
      <tr>
        <td id="L3231" data-line-number="3231"></td>
        <td id="LC3231">        };</td>
      </tr>
      <tr>
        <td id="L3232" data-line-number="3232"></td>
        <td id="LC3232">
</td>
      </tr>
      <tr>
        <td id="L3233" data-line-number="3233"></td>
        <td id="LC3233">        <span>static</span> <span>void</span> <span>ProcessMap</span>(</td>
      </tr>
      <tr>
        <td id="L3234" data-line-number="3234"></td>
        <td id="LC3234">            <span>const</span> DispatchMapTypeID * rgTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3235" data-line-number="3235"></td>
        <td id="LC3235">            UINT32                    cTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3236" data-line-number="3236"></td>
        <td id="LC3236">            MethodTable *             pMT,</td>
      </tr>
      <tr>
        <td id="L3237" data-line-number="3237"></td>
        <td id="LC3237">            UINT32                    cCurrentChainDepth,</td>
      </tr>
      <tr>
        <td id="L3238" data-line-number="3238"></td>
        <td id="LC3238">            MethodDataEntry *         rgWorkingData);</td>
      </tr>
      <tr>
        <td id="L3239" data-line-number="3239"></td>
        <td id="LC3239">    };  <span><span>//</span> class MethodData</span></td>
      </tr>
      <tr>
        <td id="L3240" data-line-number="3240"></td>
        <td id="LC3240">
</td>
      </tr>
      <tr>
        <td id="L3241" data-line-number="3241"></td>
        <td id="LC3241">    <span>typedef</span> ::Holder &lt; MethodData *, MethodData::HolderAcquire, MethodData::HolderRelease &gt; MethodDataHolder;</td>
      </tr>
      <tr>
        <td id="L3242" data-line-number="3242"></td>
        <td id="LC3242">    <span>typedef</span> ::Wrapper &lt; MethodData *, MethodData::HolderAcquire, MethodData::HolderRelease &gt; MethodDataWrapper;</td>
      </tr>
      <tr>
        <td id="L3243" data-line-number="3243"></td>
        <td id="LC3243">
</td>
      </tr>
      <tr>
        <td id="L3244" data-line-number="3244"></td>
        <td id="LC3244">protected:</td>
      </tr>
      <tr>
        <td id="L3245" data-line-number="3245"></td>
        <td id="LC3245">    <span><span>//</span>--------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3246" data-line-number="3246"></td>
        <td id="LC3246">    class MethodDataObject : public MethodData</td>
      </tr>
      <tr>
        <td id="L3247" data-line-number="3247"></td>
        <td id="LC3247">    {</td>
      </tr>
      <tr>
        <td id="L3248" data-line-number="3248"></td>
        <td id="LC3248">      public:</td>
      </tr>
      <tr>
        <td id="L3249" data-line-number="3249"></td>
        <td id="LC3249">        <span><span>//</span> Static method that returns the amount of memory to allocate for a particular type.</span></td>
      </tr>
      <tr>
        <td id="L3250" data-line-number="3250"></td>
        <td id="LC3250">        <span>static</span> UINT32 <span>GetObjectSize</span>(MethodTable *pMT);</td>
      </tr>
      <tr>
        <td id="L3251" data-line-number="3251"></td>
        <td id="LC3251">
</td>
      </tr>
      <tr>
        <td id="L3252" data-line-number="3252"></td>
        <td id="LC3252">        <span><span>//</span> Constructor. Make sure you have allocated enough memory using GetObjectSize.</span></td>
      </tr>
      <tr>
        <td id="L3253" data-line-number="3253"></td>
        <td id="LC3253">        <span>inline</span> <span>MethodDataObject</span>(MethodTable *pMT) : <span>MethodData</span>(pMT, pMT)</td>
      </tr>
      <tr>
        <td id="L3254" data-line-number="3254"></td>
        <td id="LC3254">            { WRAPPER_NO_CONTRACT; <span>Init</span>(<span>NULL</span>); }</td>
      </tr>
      <tr>
        <td id="L3255" data-line-number="3255"></td>
        <td id="LC3255">
</td>
      </tr>
      <tr>
        <td id="L3256" data-line-number="3256"></td>
        <td id="LC3256">        <span>inline</span> <span>MethodDataObject</span>(MethodTable *pMT, MethodData *pParentData) : <span>MethodData</span>(pMT, pMT)</td>
      </tr>
      <tr>
        <td id="L3257" data-line-number="3257"></td>
        <td id="LC3257">            { WRAPPER_NO_CONTRACT; <span>Init</span>(pParentData); }</td>
      </tr>
      <tr>
        <td id="L3258" data-line-number="3258"></td>
        <td id="LC3258">
</td>
      </tr>
      <tr>
        <td id="L3259" data-line-number="3259"></td>
        <td id="LC3259">        virtual ~<span>MethodDataObject</span>() { LIMITED_METHOD_CONTRACT; }</td>
      </tr>
      <tr>
        <td id="L3260" data-line-number="3260"></td>
        <td id="LC3260">
</td>
      </tr>
      <tr>
        <td id="L3261" data-line-number="3261"></td>
        <td id="LC3261">        virtual MethodData  *<span>GetDeclMethodData</span>()</td>
      </tr>
      <tr>
        <td id="L3262" data-line-number="3262"></td>
        <td id="LC3262">            { LIMITED_METHOD_CONTRACT; <span>return</span> this; }</td>
      </tr>
      <tr>
        <td id="L3263" data-line-number="3263"></td>
        <td id="LC3263">        virtual MethodDesc *<span>GetDeclMethodDesc</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3264" data-line-number="3264"></td>
        <td id="LC3264">
</td>
      </tr>
      <tr>
        <td id="L3265" data-line-number="3265"></td>
        <td id="LC3265">        virtual MethodData  *<span>GetImplMethodData</span>()</td>
      </tr>
      <tr>
        <td id="L3266" data-line-number="3266"></td>
        <td id="LC3266">            { LIMITED_METHOD_CONTRACT; <span>return</span> this; }</td>
      </tr>
      <tr>
        <td id="L3267" data-line-number="3267"></td>
        <td id="LC3267">        virtual DispatchSlot <span>GetImplSlot</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3268" data-line-number="3268"></td>
        <td id="LC3268">        virtual UINT32       <span>GetImplSlotNumber</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3269" data-line-number="3269"></td>
        <td id="LC3269">        virtual MethodDesc  *<span>GetImplMethodDesc</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3270" data-line-number="3270"></td>
        <td id="LC3270">        virtual <span>void</span> <span>InvalidateCachedVirtualSlot</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3271" data-line-number="3271"></td>
        <td id="LC3271">
</td>
      </tr>
      <tr>
        <td id="L3272" data-line-number="3272"></td>
        <td id="LC3272">        virtual UINT32 <span>GetNumVirtuals</span>()</td>
      </tr>
      <tr>
        <td id="L3273" data-line-number="3273"></td>
        <td id="LC3273">            { LIMITED_METHOD_CONTRACT; <span>return</span> m_pDeclMT-&gt;<span>GetNumVirtuals</span>(); }</td>
      </tr>
      <tr>
        <td id="L3274" data-line-number="3274"></td>
        <td id="LC3274">        virtual UINT32 <span>GetNumMethods</span>()</td>
      </tr>
      <tr>
        <td id="L3275" data-line-number="3275"></td>
        <td id="LC3275">            { LIMITED_METHOD_CONTRACT; <span>return</span> m_pDeclMT-&gt;<span>GetCanonicalMethodTable</span>()-&gt;<span>GetNumMethods</span>(); }</td>
      </tr>
      <tr>
        <td id="L3276" data-line-number="3276"></td>
        <td id="LC3276">
</td>
      </tr>
      <tr>
        <td id="L3277" data-line-number="3277"></td>
        <td id="LC3277">      protected:</td>
      </tr>
      <tr>
        <td id="L3278" data-line-number="3278"></td>
        <td id="LC3278">        <span>void</span> <span>Init</span>(MethodData *pParentData);</td>
      </tr>
      <tr>
        <td id="L3279" data-line-number="3279"></td>
        <td id="LC3279">
</td>
      </tr>
      <tr>
        <td id="L3280" data-line-number="3280"></td>
        <td id="LC3280">        BOOL <span>PopulateNextLevel</span>();</td>
      </tr>
      <tr>
        <td id="L3281" data-line-number="3281"></td>
        <td id="LC3281">
</td>
      </tr>
      <tr>
        <td id="L3282" data-line-number="3282"></td>
        <td id="LC3282">        <span><span>//</span> This is used in staged map decoding - it indicates which type we will next decode.</span></td>
      </tr>
      <tr>
        <td id="L3283" data-line-number="3283"></td>
        <td id="LC3283">        UINT32       m_iNextChainDepth;</td>
      </tr>
      <tr>
        <td id="L3284" data-line-number="3284"></td>
        <td id="LC3284">        <span>static</span> <span>const</span> UINT32 MAX_CHAIN_DEPTH = UINT32_MAX;</td>
      </tr>
      <tr>
        <td id="L3285" data-line-number="3285"></td>
        <td id="LC3285">
</td>
      </tr>
      <tr>
        <td id="L3286" data-line-number="3286"></td>
        <td id="LC3286">        BOOL m_containsMethodImpl;</td>
      </tr>
      <tr>
        <td id="L3287" data-line-number="3287"></td>
        <td id="LC3287">
</td>
      </tr>
      <tr>
        <td id="L3288" data-line-number="3288"></td>
        <td id="LC3288">        <span><span>//</span> NOTE: Use of these APIs are unlocked and may appear to be erroneous. However, since calls</span></td>
      </tr>
      <tr>
        <td id="L3289" data-line-number="3289"></td>
        <td id="LC3289">        <span><span>//</span>       to ProcessMap will result in identical values being placed in the MethodDataObjectEntry</span></td>
      </tr>
      <tr>
        <td id="L3290" data-line-number="3290"></td>
        <td id="LC3290">        <span><span>//</span>       array, it it is not a problem if there is a race, since one thread may just end up</span></td>
      </tr>
      <tr>
        <td id="L3291" data-line-number="3291"></td>
        <td id="LC3291">        <span><span>//</span>       doing some duplicate work.</span></td>
      </tr>
      <tr>
        <td id="L3292" data-line-number="3292"></td>
        <td id="LC3292">
</td>
      </tr>
      <tr>
        <td id="L3293" data-line-number="3293"></td>
        <td id="LC3293">        <span>inline</span> UINT32 <span>GetNextChainDepth</span>()</td>
      </tr>
      <tr>
        <td id="L3294" data-line-number="3294"></td>
        <td id="LC3294">        { LIMITED_METHOD_CONTRACT; <span>return</span> <span>VolatileLoad</span>(&amp;m_iNextChainDepth); }</td>
      </tr>
      <tr>
        <td id="L3295" data-line-number="3295"></td>
        <td id="LC3295">
</td>
      </tr>
      <tr>
        <td id="L3296" data-line-number="3296"></td>
        <td id="LC3296">        <span>inline</span> <span>void</span> <span>SetNextChainDepth</span>(UINT32 iDepth)</td>
      </tr>
      <tr>
        <td id="L3297" data-line-number="3297"></td>
        <td id="LC3297">        {</td>
      </tr>
      <tr>
        <td id="L3298" data-line-number="3298"></td>
        <td id="LC3298">            LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3299" data-line-number="3299"></td>
        <td id="LC3299">            <span>if</span> (<span>GetNextChainDepth</span>() &lt; iDepth) {</td>
      </tr>
      <tr>
        <td id="L3300" data-line-number="3300"></td>
        <td id="LC3300">                <span>VolatileStore</span>(&amp;m_iNextChainDepth, iDepth);</td>
      </tr>
      <tr>
        <td id="L3301" data-line-number="3301"></td>
        <td id="LC3301">            }</td>
      </tr>
      <tr>
        <td id="L3302" data-line-number="3302"></td>
        <td id="LC3302">        }</td>
      </tr>
      <tr>
        <td id="L3303" data-line-number="3303"></td>
        <td id="LC3303">
</td>
      </tr>
      <tr>
        <td id="L3304" data-line-number="3304"></td>
        <td id="LC3304">        <span><span>//</span> This is used when building the data</span></td>
      </tr>
      <tr>
        <td id="L3305" data-line-number="3305"></td>
        <td id="LC3305">        <span>struct</span> MethodDataObjectEntry</td>
      </tr>
      <tr>
        <td id="L3306" data-line-number="3306"></td>
        <td id="LC3306">        {</td>
      </tr>
      <tr>
        <td id="L3307" data-line-number="3307"></td>
        <td id="LC3307">          private:</td>
      </tr>
      <tr>
        <td id="L3308" data-line-number="3308"></td>
        <td id="LC3308">            MethodDesc *m_pMDDecl;</td>
      </tr>
      <tr>
        <td id="L3309" data-line-number="3309"></td>
        <td id="LC3309">            MethodDesc *m_pMDImpl;</td>
      </tr>
      <tr>
        <td id="L3310" data-line-number="3310"></td>
        <td id="LC3310">
</td>
      </tr>
      <tr>
        <td id="L3311" data-line-number="3311"></td>
        <td id="LC3311">          public:</td>
      </tr>
      <tr>
        <td id="L3312" data-line-number="3312"></td>
        <td id="LC3312">            <span>inline</span> <span>MethodDataObjectEntry</span>() : <span>m_pMDDecl</span>(<span>NULL</span>), <span>m_pMDImpl</span>(<span>NULL</span>) {}</td>
      </tr>
      <tr>
        <td id="L3313" data-line-number="3313"></td>
        <td id="LC3313">
</td>
      </tr>
      <tr>
        <td id="L3314" data-line-number="3314"></td>
        <td id="LC3314">            <span>inline</span> <span>void</span> <span>SetDeclMethodDesc</span>(MethodDesc *pMD)</td>
      </tr>
      <tr>
        <td id="L3315" data-line-number="3315"></td>
        <td id="LC3315">                { LIMITED_METHOD_CONTRACT; m_pMDDecl = pMD; }</td>
      </tr>
      <tr>
        <td id="L3316" data-line-number="3316"></td>
        <td id="LC3316">            <span>inline</span> MethodDesc *<span>GetDeclMethodDesc</span>()</td>
      </tr>
      <tr>
        <td id="L3317" data-line-number="3317"></td>
        <td id="LC3317">                { LIMITED_METHOD_CONTRACT; <span>return</span> m_pMDDecl; }</td>
      </tr>
      <tr>
        <td id="L3318" data-line-number="3318"></td>
        <td id="LC3318">            <span>inline</span> <span>void</span> <span>SetImplMethodDesc</span>(MethodDesc *pMD)</td>
      </tr>
      <tr>
        <td id="L3319" data-line-number="3319"></td>
        <td id="LC3319">                { LIMITED_METHOD_CONTRACT; m_pMDImpl = pMD; }</td>
      </tr>
      <tr>
        <td id="L3320" data-line-number="3320"></td>
        <td id="LC3320">            <span>inline</span> MethodDesc *<span>GetImplMethodDesc</span>()</td>
      </tr>
      <tr>
        <td id="L3321" data-line-number="3321"></td>
        <td id="LC3321">                { LIMITED_METHOD_CONTRACT; <span>return</span> m_pMDImpl; }</td>
      </tr>
      <tr>
        <td id="L3322" data-line-number="3322"></td>
        <td id="LC3322">        };</td>
      </tr>
      <tr>
        <td id="L3323" data-line-number="3323"></td>
        <td id="LC3323">
</td>
      </tr>
      <tr>
        <td id="L3324" data-line-number="3324"></td>
        <td id="LC3324">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3325" data-line-number="3325"></td>
        <td id="LC3325">        <span><span>//</span> At the end of this object is an array, so you cannot derive from this class.</span></td>
      </tr>
      <tr>
        <td id="L3326" data-line-number="3326"></td>
        <td id="LC3326">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3327" data-line-number="3327"></td>
        <td id="LC3327">
</td>
      </tr>
      <tr>
        <td id="L3328" data-line-number="3328"></td>
        <td id="LC3328">        <span>inline</span> MethodDataObjectEntry *<span>GetEntryData</span>()</td>
      </tr>
      <tr>
        <td id="L3329" data-line-number="3329"></td>
        <td id="LC3329">            { LIMITED_METHOD_CONTRACT; <span>return</span> (MethodDataObjectEntry *)(this + <span>1</span>); }</td>
      </tr>
      <tr>
        <td id="L3330" data-line-number="3330"></td>
        <td id="LC3330">
</td>
      </tr>
      <tr>
        <td id="L3331" data-line-number="3331"></td>
        <td id="LC3331">        <span>inline</span> MethodDataObjectEntry *<span>GetEntry</span>(UINT32 i)</td>
      </tr>
      <tr>
        <td id="L3332" data-line-number="3332"></td>
        <td id="LC3332">            { LIMITED_METHOD_CONTRACT; <span>CONSISTENCY_CHECK</span>(i &lt; <span>GetNumMethods</span>()); <span>return</span> <span>GetEntryData</span>() + i; }</td>
      </tr>
      <tr>
        <td id="L3333" data-line-number="3333"></td>
        <td id="LC3333">
</td>
      </tr>
      <tr>
        <td id="L3334" data-line-number="3334"></td>
        <td id="LC3334">        <span>void</span> <span>FillEntryDataForAncestor</span>(MethodTable *pMT);</td>
      </tr>
      <tr>
        <td id="L3335" data-line-number="3335"></td>
        <td id="LC3335">
</td>
      </tr>
      <tr>
        <td id="L3336" data-line-number="3336"></td>
        <td id="LC3336">        <span><span>//</span> MethodDataObjectEntry m_rgEntries[...];</span></td>
      </tr>
      <tr>
        <td id="L3337" data-line-number="3337"></td>
        <td id="LC3337">    };  <span><span>//</span> class MethodDataObject</span></td>
      </tr>
      <tr>
        <td id="L3338" data-line-number="3338"></td>
        <td id="LC3338">
</td>
      </tr>
      <tr>
        <td id="L3339" data-line-number="3339"></td>
        <td id="LC3339">    <span><span>//</span>--------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3340" data-line-number="3340"></td>
        <td id="LC3340">    class MethodDataInterface : public MethodData</td>
      </tr>
      <tr>
        <td id="L3341" data-line-number="3341"></td>
        <td id="LC3341">    {</td>
      </tr>
      <tr>
        <td id="L3342" data-line-number="3342"></td>
        <td id="LC3342">      public:</td>
      </tr>
      <tr>
        <td id="L3343" data-line-number="3343"></td>
        <td id="LC3343">        <span><span>//</span> Static method that returns the amount of memory to allocate for a particular type.</span></td>
      </tr>
      <tr>
        <td id="L3344" data-line-number="3344"></td>
        <td id="LC3344">        <span>static</span> UINT32 <span>GetObjectSize</span>(MethodTable *pMT)</td>
      </tr>
      <tr>
        <td id="L3345" data-line-number="3345"></td>
        <td id="LC3345">            { LIMITED_METHOD_CONTRACT; <span>return</span> <span>sizeof</span>(MethodDataInterface); }</td>
      </tr>
      <tr>
        <td id="L3346" data-line-number="3346"></td>
        <td id="LC3346">
</td>
      </tr>
      <tr>
        <td id="L3347" data-line-number="3347"></td>
        <td id="LC3347">        <span><span>//</span> Constructor. Make sure you have allocated enough memory using GetObjectSize.</span></td>
      </tr>
      <tr>
        <td id="L3348" data-line-number="3348"></td>
        <td id="LC3348">        <span>MethodDataInterface</span>(MethodTable *pMT) : <span>MethodData</span>(pMT, pMT)</td>
      </tr>
      <tr>
        <td id="L3349" data-line-number="3349"></td>
        <td id="LC3349">        {</td>
      </tr>
      <tr>
        <td id="L3350" data-line-number="3350"></td>
        <td id="LC3350">            LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3351" data-line-number="3351"></td>
        <td id="LC3351">            <span>CONSISTENCY_CHECK</span>(<span>CheckPointer</span>(pMT));</td>
      </tr>
      <tr>
        <td id="L3352" data-line-number="3352"></td>
        <td id="LC3352">            <span>CONSISTENCY_CHECK</span>(pMT-&gt;<span>IsInterface</span>());</td>
      </tr>
      <tr>
        <td id="L3353" data-line-number="3353"></td>
        <td id="LC3353">        }</td>
      </tr>
      <tr>
        <td id="L3354" data-line-number="3354"></td>
        <td id="LC3354">        virtual ~<span>MethodDataInterface</span>()</td>
      </tr>
      <tr>
        <td id="L3355" data-line-number="3355"></td>
        <td id="LC3355">            { LIMITED_METHOD_CONTRACT; }</td>
      </tr>
      <tr>
        <td id="L3356" data-line-number="3356"></td>
        <td id="LC3356">
</td>
      </tr>
      <tr>
        <td id="L3357" data-line-number="3357"></td>
        <td id="LC3357">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3358" data-line-number="3358"></td>
        <td id="LC3358">        <span><span>//</span> Decl data</span></td>
      </tr>
      <tr>
        <td id="L3359" data-line-number="3359"></td>
        <td id="LC3359">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3360" data-line-number="3360"></td>
        <td id="LC3360">        virtual MethodData  *<span>GetDeclMethodData</span>()</td>
      </tr>
      <tr>
        <td id="L3361" data-line-number="3361"></td>
        <td id="LC3361">            { LIMITED_METHOD_CONTRACT; <span>return</span> this; }</td>
      </tr>
      <tr>
        <td id="L3362" data-line-number="3362"></td>
        <td id="LC3362">        virtual MethodDesc *<span>GetDeclMethodDesc</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3363" data-line-number="3363"></td>
        <td id="LC3363">
</td>
      </tr>
      <tr>
        <td id="L3364" data-line-number="3364"></td>
        <td id="LC3364">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3365" data-line-number="3365"></td>
        <td id="LC3365">        <span><span>//</span> Impl data</span></td>
      </tr>
      <tr>
        <td id="L3366" data-line-number="3366"></td>
        <td id="LC3366">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3367" data-line-number="3367"></td>
        <td id="LC3367">        virtual MethodData  *<span>GetImplMethodData</span>()</td>
      </tr>
      <tr>
        <td id="L3368" data-line-number="3368"></td>
        <td id="LC3368">            { LIMITED_METHOD_CONTRACT; <span>return</span> this; }</td>
      </tr>
      <tr>
        <td id="L3369" data-line-number="3369"></td>
        <td id="LC3369">        virtual DispatchSlot <span>GetImplSlot</span>(UINT32 slotNumber)</td>
      </tr>
      <tr>
        <td id="L3370" data-line-number="3370"></td>
        <td id="LC3370">            { WRAPPER_NO_CONTRACT; <span>return</span> <span>DispatchSlot</span>(m_pDeclMT-&gt;<span>GetRestoredSlot</span>(slotNumber)); }</td>
      </tr>
      <tr>
        <td id="L3371" data-line-number="3371"></td>
        <td id="LC3371">        virtual UINT32       <span>GetImplSlotNumber</span>(UINT32 slotNumber)</td>
      </tr>
      <tr>
        <td id="L3372" data-line-number="3372"></td>
        <td id="LC3372">            { LIMITED_METHOD_CONTRACT; <span>return</span> slotNumber; }</td>
      </tr>
      <tr>
        <td id="L3373" data-line-number="3373"></td>
        <td id="LC3373">        virtual MethodDesc  *<span>GetImplMethodDesc</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3374" data-line-number="3374"></td>
        <td id="LC3374">        virtual <span>void</span> <span>InvalidateCachedVirtualSlot</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3375" data-line-number="3375"></td>
        <td id="LC3375">
</td>
      </tr>
      <tr>
        <td id="L3376" data-line-number="3376"></td>
        <td id="LC3376">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3377" data-line-number="3377"></td>
        <td id="LC3377">        <span><span>//</span> Slot count data</span></td>
      </tr>
      <tr>
        <td id="L3378" data-line-number="3378"></td>
        <td id="LC3378">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3379" data-line-number="3379"></td>
        <td id="LC3379">        virtual UINT32 <span>GetNumVirtuals</span>()</td>
      </tr>
      <tr>
        <td id="L3380" data-line-number="3380"></td>
        <td id="LC3380">            { LIMITED_METHOD_CONTRACT; <span>return</span> m_pDeclMT-&gt;<span>GetNumVirtuals</span>(); }</td>
      </tr>
      <tr>
        <td id="L3381" data-line-number="3381"></td>
        <td id="LC3381">        virtual UINT32 <span>GetNumMethods</span>()</td>
      </tr>
      <tr>
        <td id="L3382" data-line-number="3382"></td>
        <td id="LC3382">            { LIMITED_METHOD_CONTRACT; <span>return</span> m_pDeclMT-&gt;<span>GetNumMethods</span>(); }</td>
      </tr>
      <tr>
        <td id="L3383" data-line-number="3383"></td>
        <td id="LC3383">    };  <span><span>//</span> class MethodDataInterface</span></td>
      </tr>
      <tr>
        <td id="L3384" data-line-number="3384"></td>
        <td id="LC3384">
</td>
      </tr>
      <tr>
        <td id="L3385" data-line-number="3385"></td>
        <td id="LC3385">    <span><span>//</span>--------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3386" data-line-number="3386"></td>
        <td id="LC3386">    class MethodDataInterfaceImpl : public MethodData</td>
      </tr>
      <tr>
        <td id="L3387" data-line-number="3387"></td>
        <td id="LC3387">    {</td>
      </tr>
      <tr>
        <td id="L3388" data-line-number="3388"></td>
        <td id="LC3388">      public:</td>
      </tr>
      <tr>
        <td id="L3389" data-line-number="3389"></td>
        <td id="LC3389">        <span><span>//</span> Object construction-related methods</span></td>
      </tr>
      <tr>
        <td id="L3390" data-line-number="3390"></td>
        <td id="LC3390">        <span>static</span> UINT32 <span>GetObjectSize</span>(MethodTable *pMTDecl);</td>
      </tr>
      <tr>
        <td id="L3391" data-line-number="3391"></td>
        <td id="LC3391">
</td>
      </tr>
      <tr>
        <td id="L3392" data-line-number="3392"></td>
        <td id="LC3392">        <span>MethodDataInterfaceImpl</span>(</td>
      </tr>
      <tr>
        <td id="L3393" data-line-number="3393"></td>
        <td id="LC3393">            <span>const</span> DispatchMapTypeID * rgDeclTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3394" data-line-number="3394"></td>
        <td id="LC3394">            UINT32                    cDeclTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3395" data-line-number="3395"></td>
        <td id="LC3395">            MethodData *              pDecl,</td>
      </tr>
      <tr>
        <td id="L3396" data-line-number="3396"></td>
        <td id="LC3396">            MethodData *              pImpl);</td>
      </tr>
      <tr>
        <td id="L3397" data-line-number="3397"></td>
        <td id="LC3397">        virtual ~<span>MethodDataInterfaceImpl</span>();</td>
      </tr>
      <tr>
        <td id="L3398" data-line-number="3398"></td>
        <td id="LC3398">
</td>
      </tr>
      <tr>
        <td id="L3399" data-line-number="3399"></td>
        <td id="LC3399">        <span><span>//</span> Decl-related methods</span></td>
      </tr>
      <tr>
        <td id="L3400" data-line-number="3400"></td>
        <td id="LC3400">        virtual MethodData  *<span>GetDeclMethodData</span>()</td>
      </tr>
      <tr>
        <td id="L3401" data-line-number="3401"></td>
        <td id="LC3401">            { LIMITED_METHOD_CONTRACT; <span>return</span> m_pDecl; }</td>
      </tr>
      <tr>
        <td id="L3402" data-line-number="3402"></td>
        <td id="LC3402">        virtual MethodTable *<span>GetDeclMethodTable</span>()</td>
      </tr>
      <tr>
        <td id="L3403" data-line-number="3403"></td>
        <td id="LC3403">            { WRAPPER_NO_CONTRACT; <span>return</span> m_pDecl-&gt;<span>GetDeclMethodTable</span>(); }</td>
      </tr>
      <tr>
        <td id="L3404" data-line-number="3404"></td>
        <td id="LC3404">        virtual MethodDesc  *<span>GetDeclMethodDesc</span>(UINT32 slotNumber)</td>
      </tr>
      <tr>
        <td id="L3405" data-line-number="3405"></td>
        <td id="LC3405">            { WRAPPER_NO_CONTRACT; <span>return</span> m_pDecl-&gt;<span>GetDeclMethodDesc</span>(slotNumber); }</td>
      </tr>
      <tr>
        <td id="L3406" data-line-number="3406"></td>
        <td id="LC3406">
</td>
      </tr>
      <tr>
        <td id="L3407" data-line-number="3407"></td>
        <td id="LC3407">        <span><span>//</span> Impl-related methods</span></td>
      </tr>
      <tr>
        <td id="L3408" data-line-number="3408"></td>
        <td id="LC3408">        virtual MethodData  *<span>GetImplMethodData</span>()</td>
      </tr>
      <tr>
        <td id="L3409" data-line-number="3409"></td>
        <td id="LC3409">            { LIMITED_METHOD_CONTRACT; <span>return</span> m_pImpl; }</td>
      </tr>
      <tr>
        <td id="L3410" data-line-number="3410"></td>
        <td id="LC3410">        virtual MethodTable *<span>GetImplMethodTable</span>()</td>
      </tr>
      <tr>
        <td id="L3411" data-line-number="3411"></td>
        <td id="LC3411">            { WRAPPER_NO_CONTRACT; <span>return</span> m_pImpl-&gt;<span>GetImplMethodTable</span>(); }</td>
      </tr>
      <tr>
        <td id="L3412" data-line-number="3412"></td>
        <td id="LC3412">        virtual DispatchSlot <span>GetImplSlot</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3413" data-line-number="3413"></td>
        <td id="LC3413">        virtual UINT32       <span>GetImplSlotNumber</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3414" data-line-number="3414"></td>
        <td id="LC3414">        virtual MethodDesc  *<span>GetImplMethodDesc</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3415" data-line-number="3415"></td>
        <td id="LC3415">        virtual <span>void</span> <span>InvalidateCachedVirtualSlot</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3416" data-line-number="3416"></td>
        <td id="LC3416">
</td>
      </tr>
      <tr>
        <td id="L3417" data-line-number="3417"></td>
        <td id="LC3417">        virtual UINT32 <span>GetNumVirtuals</span>()</td>
      </tr>
      <tr>
        <td id="L3418" data-line-number="3418"></td>
        <td id="LC3418">            { WRAPPER_NO_CONTRACT; <span>return</span> m_pDecl-&gt;<span>GetNumVirtuals</span>(); }</td>
      </tr>
      <tr>
        <td id="L3419" data-line-number="3419"></td>
        <td id="LC3419">        virtual UINT32 <span>GetNumMethods</span>()</td>
      </tr>
      <tr>
        <td id="L3420" data-line-number="3420"></td>
        <td id="LC3420">            { WRAPPER_NO_CONTRACT; <span>return</span> m_pDecl-&gt;<span>GetNumVirtuals</span>(); }</td>
      </tr>
      <tr>
        <td id="L3421" data-line-number="3421"></td>
        <td id="LC3421">
</td>
      </tr>
      <tr>
        <td id="L3422" data-line-number="3422"></td>
        <td id="LC3422">      protected:</td>
      </tr>
      <tr>
        <td id="L3423" data-line-number="3423"></td>
        <td id="LC3423">        UINT32 <span>MapToImplSlotNumber</span>(UINT32 slotNumber);</td>
      </tr>
      <tr>
        <td id="L3424" data-line-number="3424"></td>
        <td id="LC3424">
</td>
      </tr>
      <tr>
        <td id="L3425" data-line-number="3425"></td>
        <td id="LC3425">        BOOL <span>PopulateNextLevel</span>();</td>
      </tr>
      <tr>
        <td id="L3426" data-line-number="3426"></td>
        <td id="LC3426">        <span>void</span> <span>Init</span>(</td>
      </tr>
      <tr>
        <td id="L3427" data-line-number="3427"></td>
        <td id="LC3427">            <span>const</span> DispatchMapTypeID * rgDeclTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3428" data-line-number="3428"></td>
        <td id="LC3428">            UINT32                    cDeclTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3429" data-line-number="3429"></td>
        <td id="LC3429">            MethodData *              pDecl,</td>
      </tr>
      <tr>
        <td id="L3430" data-line-number="3430"></td>
        <td id="LC3430">            MethodData *              pImpl);</td>
      </tr>
      <tr>
        <td id="L3431" data-line-number="3431"></td>
        <td id="LC3431">
</td>
      </tr>
      <tr>
        <td id="L3432" data-line-number="3432"></td>
        <td id="LC3432">        MethodData *m_pDecl;</td>
      </tr>
      <tr>
        <td id="L3433" data-line-number="3433"></td>
        <td id="LC3433">        MethodData *m_pImpl;</td>
      </tr>
      <tr>
        <td id="L3434" data-line-number="3434"></td>
        <td id="LC3434">
</td>
      </tr>
      <tr>
        <td id="L3435" data-line-number="3435"></td>
        <td id="LC3435">        <span><span>//</span> This is used in staged map decoding - it indicates which type(s) we will find.</span></td>
      </tr>
      <tr>
        <td id="L3436" data-line-number="3436"></td>
        <td id="LC3436">        <span>const</span> DispatchMapTypeID * m_rgDeclTypeIDs;</td>
      </tr>
      <tr>
        <td id="L3437" data-line-number="3437"></td>
        <td id="LC3437">        UINT32                    m_cDeclTypeIDs;</td>
      </tr>
      <tr>
        <td id="L3438" data-line-number="3438"></td>
        <td id="LC3438">        UINT32                    m_iNextChainDepth;</td>
      </tr>
      <tr>
        <td id="L3439" data-line-number="3439"></td>
        <td id="LC3439">        <span>static</span> <span>const</span> UINT32       MAX_CHAIN_DEPTH = UINT32_MAX;</td>
      </tr>
      <tr>
        <td id="L3440" data-line-number="3440"></td>
        <td id="LC3440">
</td>
      </tr>
      <tr>
        <td id="L3441" data-line-number="3441"></td>
        <td id="LC3441">        <span>inline</span> UINT32 <span>GetNextChainDepth</span>()</td>
      </tr>
      <tr>
        <td id="L3442" data-line-number="3442"></td>
        <td id="LC3442">        { LIMITED_METHOD_CONTRACT; <span>return</span> <span>VolatileLoad</span>(&amp;m_iNextChainDepth); }</td>
      </tr>
      <tr>
        <td id="L3443" data-line-number="3443"></td>
        <td id="LC3443">
</td>
      </tr>
      <tr>
        <td id="L3444" data-line-number="3444"></td>
        <td id="LC3444">        <span>inline</span> <span>void</span> <span>SetNextChainDepth</span>(UINT32 iDepth)</td>
      </tr>
      <tr>
        <td id="L3445" data-line-number="3445"></td>
        <td id="LC3445">        {</td>
      </tr>
      <tr>
        <td id="L3446" data-line-number="3446"></td>
        <td id="LC3446">            LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3447" data-line-number="3447"></td>
        <td id="LC3447">            <span>if</span> (<span>GetNextChainDepth</span>() &lt; iDepth) {</td>
      </tr>
      <tr>
        <td id="L3448" data-line-number="3448"></td>
        <td id="LC3448">                <span>VolatileStore</span>(&amp;m_iNextChainDepth, iDepth);</td>
      </tr>
      <tr>
        <td id="L3449" data-line-number="3449"></td>
        <td id="LC3449">            }</td>
      </tr>
      <tr>
        <td id="L3450" data-line-number="3450"></td>
        <td id="LC3450">        }</td>
      </tr>
      <tr>
        <td id="L3451" data-line-number="3451"></td>
        <td id="LC3451">
</td>
      </tr>
      <tr>
        <td id="L3452" data-line-number="3452"></td>
        <td id="LC3452">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3453" data-line-number="3453"></td>
        <td id="LC3453">        <span><span>//</span> At the end of this object is an array, so you cannot derive from this class.</span></td>
      </tr>
      <tr>
        <td id="L3454" data-line-number="3454"></td>
        <td id="LC3454">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3455" data-line-number="3455"></td>
        <td id="LC3455">
</td>
      </tr>
      <tr>
        <td id="L3456" data-line-number="3456"></td>
        <td id="LC3456">        <span>inline</span> MethodDataEntry *<span>GetEntryData</span>()</td>
      </tr>
      <tr>
        <td id="L3457" data-line-number="3457"></td>
        <td id="LC3457">            { LIMITED_METHOD_CONTRACT; <span>return</span> (MethodDataEntry *)(this + <span>1</span>); }</td>
      </tr>
      <tr>
        <td id="L3458" data-line-number="3458"></td>
        <td id="LC3458">
</td>
      </tr>
      <tr>
        <td id="L3459" data-line-number="3459"></td>
        <td id="LC3459">        <span>inline</span> MethodDataEntry *<span>GetEntry</span>(UINT32 i)</td>
      </tr>
      <tr>
        <td id="L3460" data-line-number="3460"></td>
        <td id="LC3460">            { LIMITED_METHOD_CONTRACT; <span>CONSISTENCY_CHECK</span>(i &lt; <span>GetNumMethods</span>()); <span>return</span> <span>GetEntryData</span>() + i; }</td>
      </tr>
      <tr>
        <td id="L3461" data-line-number="3461"></td>
        <td id="LC3461">
</td>
      </tr>
      <tr>
        <td id="L3462" data-line-number="3462"></td>
        <td id="LC3462">        <span><span>//</span> MethodDataEntry m_rgEntries[...];</span></td>
      </tr>
      <tr>
        <td id="L3463" data-line-number="3463"></td>
        <td id="LC3463">    };  <span><span>//</span> class MethodDataInterfaceImpl</span></td>
      </tr>
      <tr>
        <td id="L3464" data-line-number="3464"></td>
        <td id="LC3464">
</td>
      </tr>
      <tr>
        <td id="L3465" data-line-number="3465"></td>
        <td id="LC3465">    <span><span>//</span>--------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3466" data-line-number="3466"></td>
        <td id="LC3466">    <span>static</span> MethodDataCache *s_pMethodDataCache;</td>
      </tr>
      <tr>
        <td id="L3467" data-line-number="3467"></td>
        <td id="LC3467">    <span>static</span> BOOL             s_fUseParentMethodData;</td>
      </tr>
      <tr>
        <td id="L3468" data-line-number="3468"></td>
        <td id="LC3468">    <span>static</span> BOOL             s_fUseMethodDataCache;</td>
      </tr>
      <tr>
        <td id="L3469" data-line-number="3469"></td>
        <td id="LC3469">
</td>
      </tr>
      <tr>
        <td id="L3470" data-line-number="3470"></td>
        <td id="LC3470">public:</td>
      </tr>
      <tr>
        <td id="L3471" data-line-number="3471"></td>
        <td id="LC3471">    <span>static</span> <span>void</span> <span>AllowMethodDataCaching</span>()</td>
      </tr>
      <tr>
        <td id="L3472" data-line-number="3472"></td>
        <td id="LC3472">        { WRAPPER_NO_CONTRACT; <span>CheckInitMethodDataCache</span>(); s_fUseMethodDataCache = <span>TRUE</span>; }</td>
      </tr>
      <tr>
        <td id="L3473" data-line-number="3473"></td>
        <td id="LC3473">    <span>static</span> <span>void</span> <span>ClearMethodDataCache</span>();</td>
      </tr>
      <tr>
        <td id="L3474" data-line-number="3474"></td>
        <td id="LC3474">    <span>static</span> <span>void</span> <span>AllowParentMethodDataCopy</span>()</td>
      </tr>
      <tr>
        <td id="L3475" data-line-number="3475"></td>
        <td id="LC3475">        { LIMITED_METHOD_CONTRACT; s_fUseParentMethodData = <span>TRUE</span>; }</td>
      </tr>
      <tr>
        <td id="L3476" data-line-number="3476"></td>
        <td id="LC3476">    <span><span>//</span> NOTE: The fCanCache argument determines if the resulting MethodData object can</span></td>
      </tr>
      <tr>
        <td id="L3477" data-line-number="3477"></td>
        <td id="LC3477">    <span><span>//</span>       be added to the global MethodDataCache. This is used when requesting a</span></td>
      </tr>
      <tr>
        <td id="L3478" data-line-number="3478"></td>
        <td id="LC3478">    <span><span>//</span>       MethodData object for a type currently being built.</span></td>
      </tr>
      <tr>
        <td id="L3479" data-line-number="3479"></td>
        <td id="LC3479">    <span>static</span> MethodData *<span>GetMethodData</span>(MethodTable *pMT, BOOL fCanCache = <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L3480" data-line-number="3480"></td>
        <td id="LC3480">    <span>static</span> MethodData *<span>GetMethodData</span>(MethodTable *pMTDecl, MethodTable *pMTImpl, BOOL fCanCache = <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L3481" data-line-number="3481"></td>
        <td id="LC3481">    <span><span>//</span> This method is used by BuildMethodTable because the exact interface has not yet been loaded.</span></td>
      </tr>
      <tr>
        <td id="L3482" data-line-number="3482"></td>
        <td id="LC3482">    <span><span>//</span> NOTE: This method does not cache the resulting MethodData object in the global MethodDataCache.</span></td>
      </tr>
      <tr>
        <td id="L3483" data-line-number="3483"></td>
        <td id="LC3483">    <span>static</span> MethodData * <span>GetMethodData</span>(</td>
      </tr>
      <tr>
        <td id="L3484" data-line-number="3484"></td>
        <td id="LC3484">        <span>const</span> DispatchMapTypeID * rgDeclTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3485" data-line-number="3485"></td>
        <td id="LC3485">        UINT32                    cDeclTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3486" data-line-number="3486"></td>
        <td id="LC3486">        MethodTable *             pMTDecl,</td>
      </tr>
      <tr>
        <td id="L3487" data-line-number="3487"></td>
        <td id="LC3487">        MethodTable *             pMTImpl);</td>
      </tr>
      <tr>
        <td id="L3488" data-line-number="3488"></td>
        <td id="LC3488">
</td>
      </tr>
      <tr>
        <td id="L3489" data-line-number="3489"></td>
        <td id="LC3489">    <span>void</span> <span>CopySlotFrom</span>(UINT32 slotNumber, MethodDataWrapper &amp;hSourceMTData, MethodTable *pSourceMT);</td>
      </tr>
      <tr>
        <td id="L3490" data-line-number="3490"></td>
        <td id="LC3490">
</td>
      </tr>
      <tr>
        <td id="L3491" data-line-number="3491"></td>
        <td id="LC3491">protected:</td>
      </tr>
      <tr>
        <td id="L3492" data-line-number="3492"></td>
        <td id="LC3492">    <span>static</span> <span>void</span> <span>CheckInitMethodDataCache</span>();</td>
      </tr>
      <tr>
        <td id="L3493" data-line-number="3493"></td>
        <td id="LC3493">    <span>static</span> MethodData *<span>FindParentMethodDataHelper</span>(MethodTable *pMT);</td>
      </tr>
      <tr>
        <td id="L3494" data-line-number="3494"></td>
        <td id="LC3494">    <span>static</span> MethodData *<span>FindMethodDataHelper</span>(MethodTable *pMTDecl, MethodTable *pMTImpl);</td>
      </tr>
      <tr>
        <td id="L3495" data-line-number="3495"></td>
        <td id="LC3495">    <span>static</span> MethodData *<span>GetMethodDataHelper</span>(MethodTable *pMTDecl, MethodTable *pMTImpl, BOOL fCanCache);</td>
      </tr>
      <tr>
        <td id="L3496" data-line-number="3496"></td>
        <td id="LC3496">    <span><span>//</span> NOTE: This method does not cache the resulting MethodData object in the global MethodDataCache.</span></td>
      </tr>
      <tr>
        <td id="L3497" data-line-number="3497"></td>
        <td id="LC3497">    <span>static</span> MethodData * <span>GetMethodDataHelper</span>(</td>
      </tr>
      <tr>
        <td id="L3498" data-line-number="3498"></td>
        <td id="LC3498">        <span>const</span> DispatchMapTypeID * rgDeclTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3499" data-line-number="3499"></td>
        <td id="LC3499">        UINT32                    cDeclTypeIDs,</td>
      </tr>
      <tr>
        <td id="L3500" data-line-number="3500"></td>
        <td id="LC3500">        MethodTable *             pMTDecl,</td>
      </tr>
      <tr>
        <td id="L3501" data-line-number="3501"></td>
        <td id="LC3501">        MethodTable *             pMTImpl);</td>
      </tr>
      <tr>
        <td id="L3502" data-line-number="3502"></td>
        <td id="LC3502">
</td>
      </tr>
      <tr>
        <td id="L3503" data-line-number="3503"></td>
        <td id="LC3503">public:</td>
      </tr>
      <tr>
        <td id="L3504" data-line-number="3504"></td>
        <td id="LC3504">    <span><span>//</span>--------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3505" data-line-number="3505"></td>
        <td id="LC3505">    class MethodIterator</td>
      </tr>
      <tr>
        <td id="L3506" data-line-number="3506"></td>
        <td id="LC3506">    {</td>
      </tr>
      <tr>
        <td id="L3507" data-line-number="3507"></td>
        <td id="LC3507">    public:</td>
      </tr>
      <tr>
        <td id="L3508" data-line-number="3508"></td>
        <td id="LC3508">        <span>MethodIterator</span>(MethodTable *pMT);</td>
      </tr>
      <tr>
        <td id="L3509" data-line-number="3509"></td>
        <td id="LC3509">        <span>MethodIterator</span>(MethodTable *pMTDecl, MethodTable *pMTImpl);</td>
      </tr>
      <tr>
        <td id="L3510" data-line-number="3510"></td>
        <td id="LC3510">        <span>MethodIterator</span>(MethodData *pMethodData);</td>
      </tr>
      <tr>
        <td id="L3511" data-line-number="3511"></td>
        <td id="LC3511">        <span>MethodIterator</span>(<span>const</span> MethodIterator &amp;it);</td>
      </tr>
      <tr>
        <td id="L3512" data-line-number="3512"></td>
        <td id="LC3512">        <span>inline</span> ~<span>MethodIterator</span>() { WRAPPER_NO_CONTRACT; m_pMethodData-&gt;<span>Release</span>(); }</td>
      </tr>
      <tr>
        <td id="L3513" data-line-number="3513"></td>
        <td id="LC3513">        INT32 <span>GetNumMethods</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3514" data-line-number="3514"></td>
        <td id="LC3514">        <span>inline</span> BOOL <span>IsValid</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3515" data-line-number="3515"></td>
        <td id="LC3515">        <span>inline</span> BOOL <span>MoveTo</span>(UINT32 idx);</td>
      </tr>
      <tr>
        <td id="L3516" data-line-number="3516"></td>
        <td id="LC3516">        <span>inline</span> BOOL <span>Prev</span>();</td>
      </tr>
      <tr>
        <td id="L3517" data-line-number="3517"></td>
        <td id="LC3517">        <span>inline</span> BOOL <span>Next</span>();</td>
      </tr>
      <tr>
        <td id="L3518" data-line-number="3518"></td>
        <td id="LC3518">        <span>inline</span> <span>void</span> <span>MoveToBegin</span>();</td>
      </tr>
      <tr>
        <td id="L3519" data-line-number="3519"></td>
        <td id="LC3519">        <span>inline</span> <span>void</span> <span>MoveToEnd</span>();</td>
      </tr>
      <tr>
        <td id="L3520" data-line-number="3520"></td>
        <td id="LC3520">        <span>inline</span> UINT32 <span>GetSlotNumber</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3521" data-line-number="3521"></td>
        <td id="LC3521">        <span>inline</span> UINT32 <span>GetImplSlotNumber</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3522" data-line-number="3522"></td>
        <td id="LC3522">        <span>inline</span> BOOL <span>IsVirtual</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3523" data-line-number="3523"></td>
        <td id="LC3523">        <span>inline</span> UINT32 <span>GetNumVirtuals</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3524" data-line-number="3524"></td>
        <td id="LC3524">        <span>inline</span> DispatchSlot <span>GetTarget</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3525" data-line-number="3525"></td>
        <td id="LC3525">
</td>
      </tr>
      <tr>
        <td id="L3526" data-line-number="3526"></td>
        <td id="LC3526">        <span><span>//</span> Can be called only if IsValid()=TRUE</span></td>
      </tr>
      <tr>
        <td id="L3527" data-line-number="3527"></td>
        <td id="LC3527">        <span>inline</span> MethodDesc *<span>GetMethodDesc</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3528" data-line-number="3528"></td>
        <td id="LC3528">        <span>inline</span> MethodDesc *<span>GetDeclMethodDesc</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3529" data-line-number="3529"></td>
        <td id="LC3529">
</td>
      </tr>
      <tr>
        <td id="L3530" data-line-number="3530"></td>
        <td id="LC3530">    protected:</td>
      </tr>
      <tr>
        <td id="L3531" data-line-number="3531"></td>
        <td id="LC3531">        <span>void</span> <span>Init</span>(MethodTable *pMTDecl, MethodTable *pMTImpl);</td>
      </tr>
      <tr>
        <td id="L3532" data-line-number="3532"></td>
        <td id="LC3532">
</td>
      </tr>
      <tr>
        <td id="L3533" data-line-number="3533"></td>
        <td id="LC3533">        MethodData         *m_pMethodData;</td>
      </tr>
      <tr>
        <td id="L3534" data-line-number="3534"></td>
        <td id="LC3534">        INT32               m_iCur;           <span><span>//</span> Current logical slot index</span></td>
      </tr>
      <tr>
        <td id="L3535" data-line-number="3535"></td>
        <td id="LC3535">        INT32               m_iMethods;</td>
      </tr>
      <tr>
        <td id="L3536" data-line-number="3536"></td>
        <td id="LC3536">    };  <span><span>//</span> class MethodIterator</span></td>
      </tr>
      <tr>
        <td id="L3537" data-line-number="3537"></td>
        <td id="LC3537">#<span>endif</span> <span><span>//</span> !DACCESS_COMPILE</span></td>
      </tr>
      <tr>
        <td id="L3538" data-line-number="3538"></td>
        <td id="LC3538">
</td>
      </tr>
      <tr>
        <td id="L3539" data-line-number="3539"></td>
        <td id="LC3539">    <span><span>//</span>--------------------------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3540" data-line-number="3540"></td>
        <td id="LC3540">    <span><span>//</span> This iterator lets you walk over all the method bodies introduced by this type.</span></td>
      </tr>
      <tr>
        <td id="L3541" data-line-number="3541"></td>
        <td id="LC3541">    <span><span>//</span> This includes new static methods, new non-virtual methods, and any overrides</span></td>
      </tr>
      <tr>
        <td id="L3542" data-line-number="3542"></td>
        <td id="LC3542">    <span><span>//</span> of the parent's virtual methods. It does not include virtual method implementations</span></td>
      </tr>
      <tr>
        <td id="L3543" data-line-number="3543"></td>
        <td id="LC3543">    <span><span>//</span> provided by the parent</span></td>
      </tr>
      <tr>
        <td id="L3544" data-line-number="3544"></td>
        <td id="LC3544">
</td>
      </tr>
      <tr>
        <td id="L3545" data-line-number="3545"></td>
        <td id="LC3545">    class IntroducedMethodIterator</td>
      </tr>
      <tr>
        <td id="L3546" data-line-number="3546"></td>
        <td id="LC3546">    {</td>
      </tr>
      <tr>
        <td id="L3547" data-line-number="3547"></td>
        <td id="LC3547">    public:</td>
      </tr>
      <tr>
        <td id="L3548" data-line-number="3548"></td>
        <td id="LC3548">        <span>IntroducedMethodIterator</span>(MethodTable *pMT, BOOL restrictToCanonicalTypes = <span>TRUE</span>);</td>
      </tr>
      <tr>
        <td id="L3549" data-line-number="3549"></td>
        <td id="LC3549">        <span>inline</span> BOOL <span>IsValid</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3550" data-line-number="3550"></td>
        <td id="LC3550">        BOOL <span>Next</span>();</td>
      </tr>
      <tr>
        <td id="L3551" data-line-number="3551"></td>
        <td id="LC3551">
</td>
      </tr>
      <tr>
        <td id="L3552" data-line-number="3552"></td>
        <td id="LC3552">        <span><span>//</span> Can be called only if IsValid()=TRUE</span></td>
      </tr>
      <tr>
        <td id="L3553" data-line-number="3553"></td>
        <td id="LC3553">        <span>inline</span> MethodDesc *<span>GetMethodDesc</span>() <span>const</span>;</td>
      </tr>
      <tr>
        <td id="L3554" data-line-number="3554"></td>
        <td id="LC3554">
</td>
      </tr>
      <tr>
        <td id="L3555" data-line-number="3555"></td>
        <td id="LC3555">        <span><span>//</span> Static worker methods of the iterator. These are meant to be used</span></td>
      </tr>
      <tr>
        <td id="L3556" data-line-number="3556"></td>
        <td id="LC3556">        <span><span>//</span> by RuntimeTypeHandle::GetFirstIntroducedMethod and RuntimeTypeHandle::GetNextIntroducedMethod</span></td>
      </tr>
      <tr>
        <td id="L3557" data-line-number="3557"></td>
        <td id="LC3557">        <span><span>//</span> only to expose this iterator to managed code.</span></td>
      </tr>
      <tr>
        <td id="L3558" data-line-number="3558"></td>
        <td id="LC3558">        <span>static</span> MethodDesc * <span>GetFirst</span>(MethodTable * pMT);</td>
      </tr>
      <tr>
        <td id="L3559" data-line-number="3559"></td>
        <td id="LC3559">        <span>static</span> MethodDesc * <span>GetNext</span>(MethodDesc * pMD);</td>
      </tr>
      <tr>
        <td id="L3560" data-line-number="3560"></td>
        <td id="LC3560">
</td>
      </tr>
      <tr>
        <td id="L3561" data-line-number="3561"></td>
        <td id="LC3561">    protected:</td>
      </tr>
      <tr>
        <td id="L3562" data-line-number="3562"></td>
        <td id="LC3562">        MethodDesc      *m_pMethodDesc;     <span><span>//</span> Current method desc</span></td>
      </tr>
      <tr>
        <td id="L3563" data-line-number="3563"></td>
        <td id="LC3563">
</td>
      </tr>
      <tr>
        <td id="L3564" data-line-number="3564"></td>
        <td id="LC3564">        <span><span>//</span> Cached info about current method desc</span></td>
      </tr>
      <tr>
        <td id="L3565" data-line-number="3565"></td>
        <td id="LC3565">        MethodDescChunk *m_pChunk;</td>
      </tr>
      <tr>
        <td id="L3566" data-line-number="3566"></td>
        <td id="LC3566">        TADDR            m_pChunkEnd;</td>
      </tr>
      <tr>
        <td id="L3567" data-line-number="3567"></td>
        <td id="LC3567">
</td>
      </tr>
      <tr>
        <td id="L3568" data-line-number="3568"></td>
        <td id="LC3568">        <span>void</span> <span>SetChunk</span>(MethodDescChunk * pChunk);</td>
      </tr>
      <tr>
        <td id="L3569" data-line-number="3569"></td>
        <td id="LC3569">    };  <span><span>//</span> class IntroducedMethodIterator</span></td>
      </tr>
      <tr>
        <td id="L3570" data-line-number="3570"></td>
        <td id="LC3570">
</td>
      </tr>
      <tr>
        <td id="L3571" data-line-number="3571"></td>
        <td id="LC3571">    <span><span>//</span>-------------------------------------------------------------------</span></td>
      </tr>
      <tr>
        <td id="L3572" data-line-number="3572"></td>
        <td id="LC3572">    <span><span>//</span> INSTANCE MEMBER VARIABLES</span></td>
      </tr>
      <tr>
        <td id="L3573" data-line-number="3573"></td>
        <td id="LC3573">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3574" data-line-number="3574"></td>
        <td id="LC3574">
</td>
      </tr>
      <tr>
        <td id="L3575" data-line-number="3575"></td>
        <td id="LC3575">#<span>ifdef</span> DACCESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L3576" data-line-number="3576"></td>
        <td id="LC3576">public:</td>
      </tr>
      <tr>
        <td id="L3577" data-line-number="3577"></td>
        <td id="LC3577">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L3578" data-line-number="3578"></td>
        <td id="LC3578">private:</td>
      </tr>
      <tr>
        <td id="L3579" data-line-number="3579"></td>
        <td id="LC3579">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3580" data-line-number="3580"></td>
        <td id="LC3580">    <span>enum</span> WFLAGS_LOW_ENUM</td>
      </tr>
      <tr>
        <td id="L3581" data-line-number="3581"></td>
        <td id="LC3581">    {</td>
      </tr>
      <tr>
        <td id="L3582" data-line-number="3582"></td>
        <td id="LC3582">        <span><span>//</span> AS YOU ADD NEW FLAGS PLEASE CONSIDER WHETHER Generics::NewInstantiation NEEDS</span></td>
      </tr>
      <tr>
        <td id="L3583" data-line-number="3583"></td>
        <td id="LC3583">        <span><span>//</span> TO BE UPDATED IN ORDER TO ENSURE THAT METHODTABLES DUPLICATED FOR GENERIC INSTANTIATIONS</span></td>
      </tr>
      <tr>
        <td id="L3584" data-line-number="3584"></td>
        <td id="LC3584">        <span><span>//</span> CARRY THE CORECT FLAGS.</span></td>
      </tr>
      <tr>
        <td id="L3585" data-line-number="3585"></td>
        <td id="LC3585">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3586" data-line-number="3586"></td>
        <td id="LC3586">
</td>
      </tr>
      <tr>
        <td id="L3587" data-line-number="3587"></td>
        <td id="LC3587">        <span><span>//</span> We are overloading the low 2 bytes of m_dwFlags to be a component size for Strings</span></td>
      </tr>
      <tr>
        <td id="L3588" data-line-number="3588"></td>
        <td id="LC3588">        <span><span>//</span> and Arrays and some set of flags which we can be assured are of a specified state</span></td>
      </tr>
      <tr>
        <td id="L3589" data-line-number="3589"></td>
        <td id="LC3589">        <span><span>//</span> for Strings / Arrays, currently these will be a bunch of generics flags which don't</span></td>
      </tr>
      <tr>
        <td id="L3590" data-line-number="3590"></td>
        <td id="LC3590">        <span><span>//</span> apply to Strings / Arrays.</span></td>
      </tr>
      <tr>
        <td id="L3591" data-line-number="3591"></td>
        <td id="LC3591">
</td>
      </tr>
      <tr>
        <td id="L3592" data-line-number="3592"></td>
        <td id="LC3592">        enum_flag_UNUSED_ComponentSize_1    = <span>0x00000001</span>,</td>
      </tr>
      <tr>
        <td id="L3593" data-line-number="3593"></td>
        <td id="LC3593">
</td>
      </tr>
      <tr>
        <td id="L3594" data-line-number="3594"></td>
        <td id="LC3594">        enum_flag_StaticsMask               = <span>0x00000006</span>,</td>
      </tr>
      <tr>
        <td id="L3595" data-line-number="3595"></td>
        <td id="LC3595">        enum_flag_StaticsMask_NonDynamic    = <span>0x00000000</span>,</td>
      </tr>
      <tr>
        <td id="L3596" data-line-number="3596"></td>
        <td id="LC3596">        enum_flag_StaticsMask_Dynamic       = <span>0x00000002</span>,   <span><span>//</span> dynamic statics (EnC, reflection.emit)</span></td>
      </tr>
      <tr>
        <td id="L3597" data-line-number="3597"></td>
        <td id="LC3597">        enum_flag_StaticsMask_Generics      = <span>0x00000004</span>,   <span><span>//</span> generics statics</span></td>
      </tr>
      <tr>
        <td id="L3598" data-line-number="3598"></td>
        <td id="LC3598">        enum_flag_StaticsMask_CrossModuleGenerics       = <span>0x00000006</span>, <span><span>//</span> cross module generics statics (NGen)</span></td>
      </tr>
      <tr>
        <td id="L3599" data-line-number="3599"></td>
        <td id="LC3599">        enum_flag_StaticsMask_IfGenericsThenCrossModule = <span>0x00000002</span>, <span><span>//</span> helper constant to get rid of unnecessary check</span></td>
      </tr>
      <tr>
        <td id="L3600" data-line-number="3600"></td>
        <td id="LC3600">
</td>
      </tr>
      <tr>
        <td id="L3601" data-line-number="3601"></td>
        <td id="LC3601">        enum_flag_NotInPZM                  = <span>0x00000008</span>,   <span><span>//</span> True if this type is not in its PreferredZapModule</span></td>
      </tr>
      <tr>
        <td id="L3602" data-line-number="3602"></td>
        <td id="LC3602">
</td>
      </tr>
      <tr>
        <td id="L3603" data-line-number="3603"></td>
        <td id="LC3603">        enum_flag_GenericsMask              = <span>0x00000030</span>,</td>
      </tr>
      <tr>
        <td id="L3604" data-line-number="3604"></td>
        <td id="LC3604">        enum_flag_GenericsMask_NonGeneric   = <span>0x00000000</span>,   <span><span>//</span> no instantiation</span></td>
      </tr>
      <tr>
        <td id="L3605" data-line-number="3605"></td>
        <td id="LC3605">        enum_flag_GenericsMask_GenericInst  = <span>0x00000010</span>,   <span><span>//</span> regular instantiation, e.g. List&lt;String&gt;</span></td>
      </tr>
      <tr>
        <td id="L3606" data-line-number="3606"></td>
        <td id="LC3606">        enum_flag_GenericsMask_SharedInst   = <span>0x00000020</span>,   <span><span>//</span> shared instantiation, e.g. List&lt;__Canon&gt; or List&lt;MyValueType&lt;__Canon&gt;&gt;</span></td>
      </tr>
      <tr>
        <td id="L3607" data-line-number="3607"></td>
        <td id="LC3607">        enum_flag_GenericsMask_TypicalInst  = <span>0x00000030</span>,   <span><span>//</span> the type instantiated at its formal parameters, e.g. List&lt;T&gt;</span></td>
      </tr>
      <tr>
        <td id="L3608" data-line-number="3608"></td>
        <td id="LC3608">
</td>
      </tr>
      <tr>
        <td id="L3609" data-line-number="3609"></td>
        <td id="LC3609">        enum_flag_HasVariance               = <span>0x00000100</span>,   <span><span>//</span> This is an instantiated type some of whose type parameters are co- or contra-variant</span></td>
      </tr>
      <tr>
        <td id="L3610" data-line-number="3610"></td>
        <td id="LC3610">
</td>
      </tr>
      <tr>
        <td id="L3611" data-line-number="3611"></td>
        <td id="LC3611">        enum_flag_HasDefaultCtor            = <span>0x00000200</span>,</td>
      </tr>
      <tr>
        <td id="L3612" data-line-number="3612"></td>
        <td id="LC3612">        enum_flag_HasPreciseInitCctors      = <span>0x00000400</span>,   <span><span>//</span> Do we need to run class constructors at allocation time? (Not perf important, could be moved to EEClass</span></td>
      </tr>
      <tr>
        <td id="L3613" data-line-number="3613"></td>
        <td id="LC3613">
</td>
      </tr>
      <tr>
        <td id="L3614" data-line-number="3614"></td>
        <td id="LC3614">#<span>if</span> defined(FEATURE_HFA)</td>
      </tr>
      <tr>
        <td id="L3615" data-line-number="3615"></td>
        <td id="LC3615">#<span>if</span> defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L3616" data-line-number="3616"></td>
        <td id="LC3616">#<span>error</span> "Can't define both FEATURE_HFA and UNIX_AMD64_ABI"</td>
      </tr>
      <tr>
        <td id="L3617" data-line-number="3617"></td>
        <td id="LC3617">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3618" data-line-number="3618"></td>
        <td id="LC3618">        enum_flag_IsHFA                     = <span>0x00000800</span>,   <span><span>//</span> This type is an HFA (Homogenous Floating-point Aggregate)</span></td>
      </tr>
      <tr>
        <td id="L3619" data-line-number="3619"></td>
        <td id="LC3619">#<span>endif</span> <span><span>//</span> FEATURE_HFA</span></td>
      </tr>
      <tr>
        <td id="L3620" data-line-number="3620"></td>
        <td id="LC3620">
</td>
      </tr>
      <tr>
        <td id="L3621" data-line-number="3621"></td>
        <td id="LC3621">#<span>if</span> defined(UNIX_AMD64_ABI)</td>
      </tr>
      <tr>
        <td id="L3622" data-line-number="3622"></td>
        <td id="LC3622">#<span>if</span> defined(FEATURE_HFA)</td>
      </tr>
      <tr>
        <td id="L3623" data-line-number="3623"></td>
        <td id="LC3623">#<span>error</span> "Can't define both FEATURE_HFA and UNIX_AMD64_ABI"</td>
      </tr>
      <tr>
        <td id="L3624" data-line-number="3624"></td>
        <td id="LC3624">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3625" data-line-number="3625"></td>
        <td id="LC3625">        enum_flag_IsRegStructPassed         = <span>0x00000800</span>,   <span><span>//</span> This type is a System V register passed struct.</span></td>
      </tr>
      <tr>
        <td id="L3626" data-line-number="3626"></td>
        <td id="LC3626">#<span>endif</span> <span><span>//</span> UNIX_AMD64_ABI</span></td>
      </tr>
      <tr>
        <td id="L3627" data-line-number="3627"></td>
        <td id="LC3627">
</td>
      </tr>
      <tr>
        <td id="L3628" data-line-number="3628"></td>
        <td id="LC3628">        enum_flag_IsByRefLike               = <span>0x00001000</span>,</td>
      </tr>
      <tr>
        <td id="L3629" data-line-number="3629"></td>
        <td id="LC3629">
</td>
      </tr>
      <tr>
        <td id="L3630" data-line-number="3630"></td>
        <td id="LC3630">        <span><span>//</span> In a perfect world we would fill these flags using other flags that we already have</span></td>
      </tr>
      <tr>
        <td id="L3631" data-line-number="3631"></td>
        <td id="LC3631">        <span><span>//</span> which have a constant value for something which has a component size.</span></td>
      </tr>
      <tr>
        <td id="L3632" data-line-number="3632"></td>
        <td id="LC3632">        enum_flag_UNUSED_ComponentSize_5    = <span>0x00002000</span>,</td>
      </tr>
      <tr>
        <td id="L3633" data-line-number="3633"></td>
        <td id="LC3633">        enum_flag_UNUSED_ComponentSize_6    = <span>0x00004000</span>,</td>
      </tr>
      <tr>
        <td id="L3634" data-line-number="3634"></td>
        <td id="LC3634">        enum_flag_UNUSED_ComponentSize_7    = <span>0x00008000</span>,</td>
      </tr>
      <tr>
        <td id="L3635" data-line-number="3635"></td>
        <td id="LC3635">
</td>
      </tr>
      <tr>
        <td id="L3636" data-line-number="3636"></td>
        <td id="LC3636">#<span>define</span> <span>SET_FALSE</span>(<span>flag</span>)     ((flag) &amp; <span>0</span>)</td>
      </tr>
      <tr>
        <td id="L3637" data-line-number="3637"></td>
        <td id="LC3637">#<span>define</span> <span>SET_TRUE</span>(<span>flag</span>)      ((flag) &amp; <span>0xffff</span>)</td>
      </tr>
      <tr>
        <td id="L3638" data-line-number="3638"></td>
        <td id="LC3638">
</td>
      </tr>
      <tr>
        <td id="L3639" data-line-number="3639"></td>
        <td id="LC3639">        <span><span>//</span> IMPORTANT! IMPORTANT! IMPORTANT!</span></td>
      </tr>
      <tr>
        <td id="L3640" data-line-number="3640"></td>
        <td id="LC3640">        <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3641" data-line-number="3641"></td>
        <td id="LC3641">        <span><span>//</span> As you change the flags in WFLAGS_LOW_ENUM you also need to change this</span></td>
      </tr>
      <tr>
        <td id="L3642" data-line-number="3642"></td>
        <td id="LC3642">        <span><span>//</span> to be up to date to reflect the default values of those flags for the</span></td>
      </tr>
      <tr>
        <td id="L3643" data-line-number="3643"></td>
        <td id="LC3643">        <span><span>//</span> case where this MethodTable is for a String or Array</span></td>
      </tr>
      <tr>
        <td id="L3644" data-line-number="3644"></td>
        <td id="LC3644">        enum_flag_StringArrayValues = <span>SET_TRUE</span>(enum_flag_StaticsMask_NonDynamic) |</td>
      </tr>
      <tr>
        <td id="L3645" data-line-number="3645"></td>
        <td id="LC3645">                                      <span>SET_FALSE</span>(enum_flag_NotInPZM) |</td>
      </tr>
      <tr>
        <td id="L3646" data-line-number="3646"></td>
        <td id="LC3646">                                      <span>SET_TRUE</span>(enum_flag_GenericsMask_NonGeneric) |</td>
      </tr>
      <tr>
        <td id="L3647" data-line-number="3647"></td>
        <td id="LC3647">                                      <span>SET_FALSE</span>(enum_flag_HasVariance) |</td>
      </tr>
      <tr>
        <td id="L3648" data-line-number="3648"></td>
        <td id="LC3648">                                      <span>SET_FALSE</span>(enum_flag_HasDefaultCtor) |</td>
      </tr>
      <tr>
        <td id="L3649" data-line-number="3649"></td>
        <td id="LC3649">                                      <span>SET_FALSE</span>(enum_flag_HasPreciseInitCctors),</td>
      </tr>
      <tr>
        <td id="L3650" data-line-number="3650"></td>
        <td id="LC3650">
</td>
      </tr>
      <tr>
        <td id="L3651" data-line-number="3651"></td>
        <td id="LC3651">    };  <span><span>//</span> enum WFLAGS_LOW_ENUM</span></td>
      </tr>
      <tr>
        <td id="L3652" data-line-number="3652"></td>
        <td id="LC3652">
</td>
      </tr>
      <tr>
        <td id="L3653" data-line-number="3653"></td>
        <td id="LC3653">    <span>enum</span> WFLAGS_HIGH_ENUM</td>
      </tr>
      <tr>
        <td id="L3654" data-line-number="3654"></td>
        <td id="LC3654">    {</td>
      </tr>
      <tr>
        <td id="L3655" data-line-number="3655"></td>
        <td id="LC3655">        <span><span>//</span> DO NOT use flags that have bits set in the low 2 bytes.</span></td>
      </tr>
      <tr>
        <td id="L3656" data-line-number="3656"></td>
        <td id="LC3656">        <span><span>//</span> These flags are DWORD sized so that our atomic masking</span></td>
      </tr>
      <tr>
        <td id="L3657" data-line-number="3657"></td>
        <td id="LC3657">        <span><span>//</span> operations can operate on the entire 4-byte aligned DWORD</span></td>
      </tr>
      <tr>
        <td id="L3658" data-line-number="3658"></td>
        <td id="LC3658">        <span><span>//</span> instead of the logical non-aligned WORD of flags.  The</span></td>
      </tr>
      <tr>
        <td id="L3659" data-line-number="3659"></td>
        <td id="LC3659">        <span><span>//</span> low WORD of flags is reserved for the component size.</span></td>
      </tr>
      <tr>
        <td id="L3660" data-line-number="3660"></td>
        <td id="LC3660">
</td>
      </tr>
      <tr>
        <td id="L3661" data-line-number="3661"></td>
        <td id="LC3661">        <span><span>//</span> The following bits describe mutually exclusive locations of the type</span></td>
      </tr>
      <tr>
        <td id="L3662" data-line-number="3662"></td>
        <td id="LC3662">        <span><span>//</span> in the type hiearchy.</span></td>
      </tr>
      <tr>
        <td id="L3663" data-line-number="3663"></td>
        <td id="LC3663">        enum_flag_Category_Mask             = <span>0x000F0000</span>,</td>
      </tr>
      <tr>
        <td id="L3664" data-line-number="3664"></td>
        <td id="LC3664">
</td>
      </tr>
      <tr>
        <td id="L3665" data-line-number="3665"></td>
        <td id="LC3665">        enum_flag_Category_Class            = <span>0x00000000</span>,</td>
      </tr>
      <tr>
        <td id="L3666" data-line-number="3666"></td>
        <td id="LC3666">        enum_flag_Category_Unused_1         = <span>0x00010000</span>,</td>
      </tr>
      <tr>
        <td id="L3667" data-line-number="3667"></td>
        <td id="LC3667">        enum_flag_Category_Unused_2         = <span>0x00020000</span>,</td>
      </tr>
      <tr>
        <td id="L3668" data-line-number="3668"></td>
        <td id="LC3668">        enum_flag_Category_Unused_3         = <span>0x00030000</span>,</td>
      </tr>
      <tr>
        <td id="L3669" data-line-number="3669"></td>
        <td id="LC3669">
</td>
      </tr>
      <tr>
        <td id="L3670" data-line-number="3670"></td>
        <td id="LC3670">        enum_flag_Category_ValueType        = <span>0x00040000</span>,</td>
      </tr>
      <tr>
        <td id="L3671" data-line-number="3671"></td>
        <td id="LC3671">        enum_flag_Category_ValueType_Mask   = <span>0x000C0000</span>,</td>
      </tr>
      <tr>
        <td id="L3672" data-line-number="3672"></td>
        <td id="LC3672">        enum_flag_Category_Nullable         = <span>0x00050000</span>, <span><span>//</span> sub-category of ValueType</span></td>
      </tr>
      <tr>
        <td id="L3673" data-line-number="3673"></td>
        <td id="LC3673">        enum_flag_Category_PrimitiveValueType=<span>0x00060000</span>, <span><span>//</span> sub-category of ValueType, Enum or primitive value type</span></td>
      </tr>
      <tr>
        <td id="L3674" data-line-number="3674"></td>
        <td id="LC3674">        enum_flag_Category_TruePrimitive    = <span>0x00070000</span>, <span><span>//</span> sub-category of ValueType, Primitive (ELEMENT_TYPE_I, etc.)</span></td>
      </tr>
      <tr>
        <td id="L3675" data-line-number="3675"></td>
        <td id="LC3675">
</td>
      </tr>
      <tr>
        <td id="L3676" data-line-number="3676"></td>
        <td id="LC3676">        enum_flag_Category_Array            = <span>0x00080000</span>,</td>
      </tr>
      <tr>
        <td id="L3677" data-line-number="3677"></td>
        <td id="LC3677">        enum_flag_Category_Array_Mask       = <span>0x000C0000</span>,</td>
      </tr>
      <tr>
        <td id="L3678" data-line-number="3678"></td>
        <td id="LC3678">        <span><span>//</span> enum_flag_Category_IfArrayThenUnused                 = 0x00010000, // sub-category of Array</span></td>
      </tr>
      <tr>
        <td id="L3679" data-line-number="3679"></td>
        <td id="LC3679">        enum_flag_Category_IfArrayThenSzArray                   = <span>0x00020000</span>, <span><span>//</span> sub-category of Array</span></td>
      </tr>
      <tr>
        <td id="L3680" data-line-number="3680"></td>
        <td id="LC3680">
</td>
      </tr>
      <tr>
        <td id="L3681" data-line-number="3681"></td>
        <td id="LC3681">        enum_flag_Category_Interface        = <span>0x000C0000</span>,</td>
      </tr>
      <tr>
        <td id="L3682" data-line-number="3682"></td>
        <td id="LC3682">        enum_flag_Category_Unused_4         = <span>0x000D0000</span>,</td>
      </tr>
      <tr>
        <td id="L3683" data-line-number="3683"></td>
        <td id="LC3683">        enum_flag_Category_Unused_5         = <span>0x000E0000</span>,</td>
      </tr>
      <tr>
        <td id="L3684" data-line-number="3684"></td>
        <td id="LC3684">        enum_flag_Category_Unused_6         = <span>0x000F0000</span>,</td>
      </tr>
      <tr>
        <td id="L3685" data-line-number="3685"></td>
        <td id="LC3685">
</td>
      </tr>
      <tr>
        <td id="L3686" data-line-number="3686"></td>
        <td id="LC3686">        enum_flag_Category_ElementTypeMask  = <span>0x000E0000</span>, <span><span>//</span> bits that matter for element type mask</span></td>
      </tr>
      <tr>
        <td id="L3687" data-line-number="3687"></td>
        <td id="LC3687">
</td>
      </tr>
      <tr>
        <td id="L3688" data-line-number="3688"></td>
        <td id="LC3688">
</td>
      </tr>
      <tr>
        <td id="L3689" data-line-number="3689"></td>
        <td id="LC3689">        enum_flag_HasFinalizer                = <span>0x00100000</span>, <span><span>//</span> instances require finalization</span></td>
      </tr>
      <tr>
        <td id="L3690" data-line-number="3690"></td>
        <td id="LC3690">
</td>
      </tr>
      <tr>
        <td id="L3691" data-line-number="3691"></td>
        <td id="LC3691">        enum_flag_IfNotInterfaceThenMarshalable = <span>0x00200000</span>, <span><span>//</span> Is this type marshalable by the pinvoke marshalling layer</span></td>
      </tr>
      <tr>
        <td id="L3692" data-line-number="3692"></td>
        <td id="LC3692">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L3693" data-line-number="3693"></td>
        <td id="LC3693">        enum_flag_IfInterfaceThenHasGuidInfo    = <span>0x00200000</span>, <span><span>//</span> Does the type has optional GuidInfo</span></td>
      </tr>
      <tr>
        <td id="L3694" data-line-number="3694"></td>
        <td id="LC3694">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L3695" data-line-number="3695"></td>
        <td id="LC3695">
</td>
      </tr>
      <tr>
        <td id="L3696" data-line-number="3696"></td>
        <td id="LC3696">        enum_flag_ICastable                   = <span>0x00400000</span>, <span><span>//</span> class implements ICastable interface</span></td>
      </tr>
      <tr>
        <td id="L3697" data-line-number="3697"></td>
        <td id="LC3697">
</td>
      </tr>
      <tr>
        <td id="L3698" data-line-number="3698"></td>
        <td id="LC3698">        enum_flag_HasIndirectParent           = <span>0x00800000</span>, <span><span>//</span> m_pParentMethodTable has double indirection</span></td>
      </tr>
      <tr>
        <td id="L3699" data-line-number="3699"></td>
        <td id="LC3699">
</td>
      </tr>
      <tr>
        <td id="L3700" data-line-number="3700"></td>
        <td id="LC3700">        enum_flag_ContainsPointers            = <span>0x01000000</span>,</td>
      </tr>
      <tr>
        <td id="L3701" data-line-number="3701"></td>
        <td id="LC3701">
</td>
      </tr>
      <tr>
        <td id="L3702" data-line-number="3702"></td>
        <td id="LC3702">        enum_flag_HasTypeEquivalence          = <span>0x02000000</span>, <span><span>//</span> can be equivalent to another type</span></td>
      </tr>
      <tr>
        <td id="L3703" data-line-number="3703"></td>
        <td id="LC3703">
</td>
      </tr>
      <tr>
        <td id="L3704" data-line-number="3704"></td>
        <td id="LC3704">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L3705" data-line-number="3705"></td>
        <td id="LC3705">        enum_flag_HasRCWPerTypeData           = <span>0x04000000</span>, <span><span>//</span> has optional pointer to RCWPerTypeData</span></td>
      </tr>
      <tr>
        <td id="L3706" data-line-number="3706"></td>
        <td id="LC3706">#<span>endif</span> <span><span>//</span> FEATURE_COMINTEROP</span></td>
      </tr>
      <tr>
        <td id="L3707" data-line-number="3707"></td>
        <td id="LC3707">
</td>
      </tr>
      <tr>
        <td id="L3708" data-line-number="3708"></td>
        <td id="LC3708">        enum_flag_HasCriticalFinalizer        = <span>0x08000000</span>, <span><span>//</span> finalizer must be run on Appdomain Unload</span></td>
      </tr>
      <tr>
        <td id="L3709" data-line-number="3709"></td>
        <td id="LC3709">        enum_flag_Collectible                 = <span>0x10000000</span>,</td>
      </tr>
      <tr>
        <td id="L3710" data-line-number="3710"></td>
        <td id="LC3710">        enum_flag_ContainsGenericVariables    = <span>0x20000000</span>,   <span><span>//</span> we cache this flag to help detect these efficiently and</span></td>
      </tr>
      <tr>
        <td id="L3711" data-line-number="3711"></td>
        <td id="LC3711">                                                              <span><span>//</span> to detect this condition when restoring</span></td>
      </tr>
      <tr>
        <td id="L3712" data-line-number="3712"></td>
        <td id="LC3712">
</td>
      </tr>
      <tr>
        <td id="L3713" data-line-number="3713"></td>
        <td id="LC3713">        enum_flag_ComObject                   = <span>0x40000000</span>, <span><span>//</span> class is a com object</span></td>
      </tr>
      <tr>
        <td id="L3714" data-line-number="3714"></td>
        <td id="LC3714">
</td>
      </tr>
      <tr>
        <td id="L3715" data-line-number="3715"></td>
        <td id="LC3715">        enum_flag_HasComponentSize            = <span>0x80000000</span>,   <span><span>//</span> This is set if component size is used for flags.</span></td>
      </tr>
      <tr>
        <td id="L3716" data-line-number="3716"></td>
        <td id="LC3716">
</td>
      </tr>
      <tr>
        <td id="L3717" data-line-number="3717"></td>
        <td id="LC3717">        <span><span>//</span> Types that require non-trivial interface cast have this bit set in the category</span></td>
      </tr>
      <tr>
        <td id="L3718" data-line-number="3718"></td>
        <td id="LC3718">        enum_flag_NonTrivialInterfaceCast   =  enum_flag_Category_Array</td>
      </tr>
      <tr>
        <td id="L3719" data-line-number="3719"></td>
        <td id="LC3719">                                             | enum_flag_ComObject</td>
      </tr>
      <tr>
        <td id="L3720" data-line-number="3720"></td>
        <td id="LC3720">                                             | enum_flag_ICastable</td>
      </tr>
      <tr>
        <td id="L3721" data-line-number="3721"></td>
        <td id="LC3721">
</td>
      </tr>
      <tr>
        <td id="L3722" data-line-number="3722"></td>
        <td id="LC3722">    };  <span><span>//</span> enum WFLAGS_HIGH_ENUM</span></td>
      </tr>
      <tr>
        <td id="L3723" data-line-number="3723"></td>
        <td id="LC3723">
</td>
      </tr>
      <tr>
        <td id="L3724" data-line-number="3724"></td>
        <td id="LC3724"><span><span>//</span> NIDump needs to be able to see these flags</span></td>
      </tr>
      <tr>
        <td id="L3725" data-line-number="3725"></td>
        <td id="LC3725"><span><span>//</span> TODO: figure out how to make these private</span></td>
      </tr>
      <tr>
        <td id="L3726" data-line-number="3726"></td>
        <td id="LC3726">#<span>if</span> defined(DACCESS_COMPILE)</td>
      </tr>
      <tr>
        <td id="L3727" data-line-number="3727"></td>
        <td id="LC3727">public:</td>
      </tr>
      <tr>
        <td id="L3728" data-line-number="3728"></td>
        <td id="LC3728">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L3729" data-line-number="3729"></td>
        <td id="LC3729">private:</td>
      </tr>
      <tr>
        <td id="L3730" data-line-number="3730"></td>
        <td id="LC3730">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3731" data-line-number="3731"></td>
        <td id="LC3731">    <span>enum</span> WFLAGS2_ENUM</td>
      </tr>
      <tr>
        <td id="L3732" data-line-number="3732"></td>
        <td id="LC3732">    {</td>
      </tr>
      <tr>
        <td id="L3733" data-line-number="3733"></td>
        <td id="LC3733">        <span><span>//</span> AS YOU ADD NEW FLAGS PLEASE CONSIDER WHETHER Generics::NewInstantiation NEEDS</span></td>
      </tr>
      <tr>
        <td id="L3734" data-line-number="3734"></td>
        <td id="LC3734">        <span><span>//</span> TO BE UPDATED IN ORDER TO ENSURE THAT METHODTABLES DUPLICATED FOR GENERIC INSTANTIATIONS</span></td>
      </tr>
      <tr>
        <td id="L3735" data-line-number="3735"></td>
        <td id="LC3735">        <span><span>//</span> CARRY THE CORECT FLAGS.</span></td>
      </tr>
      <tr>
        <td id="L3736" data-line-number="3736"></td>
        <td id="LC3736">
</td>
      </tr>
      <tr>
        <td id="L3737" data-line-number="3737"></td>
        <td id="LC3737">        <span><span>//</span> The following bits describe usage of optional slots. They have to stay</span></td>
      </tr>
      <tr>
        <td id="L3738" data-line-number="3738"></td>
        <td id="LC3738">        <span><span>//</span> together because of we index using them into offset arrays.</span></td>
      </tr>
      <tr>
        <td id="L3739" data-line-number="3739"></td>
        <td id="LC3739">        enum_flag_MultipurposeSlotsMask     = <span>0x001F</span>,</td>
      </tr>
      <tr>
        <td id="L3740" data-line-number="3740"></td>
        <td id="LC3740">        enum_flag_HasPerInstInfo            = <span>0x0001</span>,</td>
      </tr>
      <tr>
        <td id="L3741" data-line-number="3741"></td>
        <td id="LC3741">        enum_flag_HasInterfaceMap           = <span>0x0002</span>,</td>
      </tr>
      <tr>
        <td id="L3742" data-line-number="3742"></td>
        <td id="LC3742">        enum_flag_HasDispatchMapSlot        = <span>0x0004</span>,</td>
      </tr>
      <tr>
        <td id="L3743" data-line-number="3743"></td>
        <td id="LC3743">        enum_flag_HasNonVirtualSlots        = <span>0x0008</span>,</td>
      </tr>
      <tr>
        <td id="L3744" data-line-number="3744"></td>
        <td id="LC3744">        enum_flag_HasModuleOverride         = <span>0x0010</span>,</td>
      </tr>
      <tr>
        <td id="L3745" data-line-number="3745"></td>
        <td id="LC3745">
</td>
      </tr>
      <tr>
        <td id="L3746" data-line-number="3746"></td>
        <td id="LC3746">        enum_flag_IsZapped                  = <span>0x0020</span>, <span><span>//</span> This could be fetched from m_pLoaderModule if we run out of flags</span></td>
      </tr>
      <tr>
        <td id="L3747" data-line-number="3747"></td>
        <td id="LC3747">
</td>
      </tr>
      <tr>
        <td id="L3748" data-line-number="3748"></td>
        <td id="LC3748">        enum_flag_IsPreRestored             = <span>0x0040</span>, <span><span>//</span> Class does not need restore</span></td>
      </tr>
      <tr>
        <td id="L3749" data-line-number="3749"></td>
        <td id="LC3749">                                                      <span><span>//</span> This flag is set only for NGENed classes (IsZapped is true)</span></td>
      </tr>
      <tr>
        <td id="L3750" data-line-number="3750"></td>
        <td id="LC3750">
</td>
      </tr>
      <tr>
        <td id="L3751" data-line-number="3751"></td>
        <td id="LC3751">        enum_flag_HasModuleDependencies     = <span>0x0080</span>,</td>
      </tr>
      <tr>
        <td id="L3752" data-line-number="3752"></td>
        <td id="LC3752">
</td>
      </tr>
      <tr>
        <td id="L3753" data-line-number="3753"></td>
        <td id="LC3753">        enum_flag_IsIntrinsicType           = <span>0x0100</span>,</td>
      </tr>
      <tr>
        <td id="L3754" data-line-number="3754"></td>
        <td id="LC3754">
</td>
      </tr>
      <tr>
        <td id="L3755" data-line-number="3755"></td>
        <td id="LC3755">        enum_flag_RequiresDispatchTokenFat  = <span>0x0200</span>,</td>
      </tr>
      <tr>
        <td id="L3756" data-line-number="3756"></td>
        <td id="LC3756">
</td>
      </tr>
      <tr>
        <td id="L3757" data-line-number="3757"></td>
        <td id="LC3757">        enum_flag_HasCctor                  = <span>0x0400</span>,</td>
      </tr>
      <tr>
        <td id="L3758" data-line-number="3758"></td>
        <td id="LC3758">        enum_flag_HasCCWTemplate            = <span>0x0800</span>, <span><span>//</span> Has an extra field pointing to a CCW template</span></td>
      </tr>
      <tr>
        <td id="L3759" data-line-number="3759"></td>
        <td id="LC3759">
</td>
      </tr>
      <tr>
        <td id="L3760" data-line-number="3760"></td>
        <td id="LC3760">#<span>ifdef</span> FEATURE_64BIT_ALIGNMENT</td>
      </tr>
      <tr>
        <td id="L3761" data-line-number="3761"></td>
        <td id="LC3761">        enum_flag_RequiresAlign8            = <span>0x1000</span>, <span><span>//</span> Type requires 8-byte alignment (only set on platforms that require this and don't get it implicitly)</span></td>
      </tr>
      <tr>
        <td id="L3762" data-line-number="3762"></td>
        <td id="LC3762">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3763" data-line-number="3763"></td>
        <td id="LC3763">
</td>
      </tr>
      <tr>
        <td id="L3764" data-line-number="3764"></td>
        <td id="LC3764">        enum_flag_HasBoxedRegularStatics    = <span>0x2000</span>, <span><span>//</span> GetNumBoxedRegularStatics() != 0</span></td>
      </tr>
      <tr>
        <td id="L3765" data-line-number="3765"></td>
        <td id="LC3765">
</td>
      </tr>
      <tr>
        <td id="L3766" data-line-number="3766"></td>
        <td id="LC3766">        enum_flag_HasSingleNonVirtualSlot   = <span>0x4000</span>,</td>
      </tr>
      <tr>
        <td id="L3767" data-line-number="3767"></td>
        <td id="LC3767">
</td>
      </tr>
      <tr>
        <td id="L3768" data-line-number="3768"></td>
        <td id="LC3768">        enum_flag_DependsOnEquivalentOrForwardedStructs= <span>0x8000</span>, <span><span>//</span> Declares methods that have type equivalent or type forwarded structures in their signature</span></td>
      </tr>
      <tr>
        <td id="L3769" data-line-number="3769"></td>
        <td id="LC3769">
</td>
      </tr>
      <tr>
        <td id="L3770" data-line-number="3770"></td>
        <td id="LC3770">    };  <span><span>//</span> enum WFLAGS2_ENUM</span></td>
      </tr>
      <tr>
        <td id="L3771" data-line-number="3771"></td>
        <td id="LC3771">
</td>
      </tr>
      <tr>
        <td id="L3772" data-line-number="3772"></td>
        <td id="LC3772">    __forceinline <span>void</span> <span>ClearFlag</span>(WFLAGS_LOW_ENUM flag)</td>
      </tr>
      <tr>
        <td id="L3773" data-line-number="3773"></td>
        <td id="LC3773">    {</td>
      </tr>
      <tr>
        <td id="L3774" data-line-number="3774"></td>
        <td id="LC3774">        <span>_ASSERTE</span>(!<span>IsStringOrArray</span>());</td>
      </tr>
      <tr>
        <td id="L3775" data-line-number="3775"></td>
        <td id="LC3775">        m_dwFlags &amp;= ~flag;</td>
      </tr>
      <tr>
        <td id="L3776" data-line-number="3776"></td>
        <td id="LC3776">    }</td>
      </tr>
      <tr>
        <td id="L3777" data-line-number="3777"></td>
        <td id="LC3777">    __forceinline <span>void</span> <span>SetFlag</span>(WFLAGS_LOW_ENUM flag)</td>
      </tr>
      <tr>
        <td id="L3778" data-line-number="3778"></td>
        <td id="LC3778">    {</td>
      </tr>
      <tr>
        <td id="L3779" data-line-number="3779"></td>
        <td id="LC3779">        <span>_ASSERTE</span>(!<span>IsStringOrArray</span>());</td>
      </tr>
      <tr>
        <td id="L3780" data-line-number="3780"></td>
        <td id="LC3780">        m_dwFlags |= flag;</td>
      </tr>
      <tr>
        <td id="L3781" data-line-number="3781"></td>
        <td id="LC3781">    }</td>
      </tr>
      <tr>
        <td id="L3782" data-line-number="3782"></td>
        <td id="LC3782">    __forceinline DWORD <span>GetFlag</span>(WFLAGS_LOW_ENUM flag) <span>const</span></td>
      </tr>
      <tr>
        <td id="L3783" data-line-number="3783"></td>
        <td id="LC3783">    {</td>
      </tr>
      <tr>
        <td id="L3784" data-line-number="3784"></td>
        <td id="LC3784">        SUPPORTS_DAC;</td>
      </tr>
      <tr>
        <td id="L3785" data-line-number="3785"></td>
        <td id="LC3785">        <span>return</span> (<span>IsStringOrArray</span>() ? (enum_flag_StringArrayValues &amp; flag) : (m_dwFlags &amp; flag));</td>
      </tr>
      <tr>
        <td id="L3786" data-line-number="3786"></td>
        <td id="LC3786">    }</td>
      </tr>
      <tr>
        <td id="L3787" data-line-number="3787"></td>
        <td id="LC3787">    __forceinline BOOL <span>TestFlagWithMask</span>(WFLAGS_LOW_ENUM mask, WFLAGS_LOW_ENUM flag) <span>const</span></td>
      </tr>
      <tr>
        <td id="L3788" data-line-number="3788"></td>
        <td id="LC3788">    {</td>
      </tr>
      <tr>
        <td id="L3789" data-line-number="3789"></td>
        <td id="LC3789">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3790" data-line-number="3790"></td>
        <td id="LC3790">        <span>return</span> (<span>IsStringOrArray</span>() ? (((DWORD)enum_flag_StringArrayValues &amp; (DWORD)mask) == (DWORD)flag) :</td>
      </tr>
      <tr>
        <td id="L3791" data-line-number="3791"></td>
        <td id="LC3791">            ((m_dwFlags &amp; (DWORD)mask) == (DWORD)flag));</td>
      </tr>
      <tr>
        <td id="L3792" data-line-number="3792"></td>
        <td id="LC3792">    }</td>
      </tr>
      <tr>
        <td id="L3793" data-line-number="3793"></td>
        <td id="LC3793">
</td>
      </tr>
      <tr>
        <td id="L3794" data-line-number="3794"></td>
        <td id="LC3794">    __forceinline <span>void</span> <span>ClearFlag</span>(WFLAGS_HIGH_ENUM flag)</td>
      </tr>
      <tr>
        <td id="L3795" data-line-number="3795"></td>
        <td id="LC3795">    {</td>
      </tr>
      <tr>
        <td id="L3796" data-line-number="3796"></td>
        <td id="LC3796">        m_dwFlags &amp;= ~flag;</td>
      </tr>
      <tr>
        <td id="L3797" data-line-number="3797"></td>
        <td id="LC3797">    }</td>
      </tr>
      <tr>
        <td id="L3798" data-line-number="3798"></td>
        <td id="LC3798">    __forceinline <span>void</span> <span>SetFlag</span>(WFLAGS_HIGH_ENUM flag)</td>
      </tr>
      <tr>
        <td id="L3799" data-line-number="3799"></td>
        <td id="LC3799">    {</td>
      </tr>
      <tr>
        <td id="L3800" data-line-number="3800"></td>
        <td id="LC3800">        m_dwFlags |= flag;</td>
      </tr>
      <tr>
        <td id="L3801" data-line-number="3801"></td>
        <td id="LC3801">    }</td>
      </tr>
      <tr>
        <td id="L3802" data-line-number="3802"></td>
        <td id="LC3802">    __forceinline DWORD <span>GetFlag</span>(WFLAGS_HIGH_ENUM flag) <span>const</span></td>
      </tr>
      <tr>
        <td id="L3803" data-line-number="3803"></td>
        <td id="LC3803">    {</td>
      </tr>
      <tr>
        <td id="L3804" data-line-number="3804"></td>
        <td id="LC3804">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3805" data-line-number="3805"></td>
        <td id="LC3805">        <span>return</span> m_dwFlags &amp; flag;</td>
      </tr>
      <tr>
        <td id="L3806" data-line-number="3806"></td>
        <td id="LC3806">    }</td>
      </tr>
      <tr>
        <td id="L3807" data-line-number="3807"></td>
        <td id="LC3807">    __forceinline BOOL <span>TestFlagWithMask</span>(WFLAGS_HIGH_ENUM mask, WFLAGS_HIGH_ENUM flag) <span>const</span></td>
      </tr>
      <tr>
        <td id="L3808" data-line-number="3808"></td>
        <td id="LC3808">    {</td>
      </tr>
      <tr>
        <td id="L3809" data-line-number="3809"></td>
        <td id="LC3809">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3810" data-line-number="3810"></td>
        <td id="LC3810">        <span>return</span> ((m_dwFlags &amp; (DWORD)mask) == (DWORD)flag);</td>
      </tr>
      <tr>
        <td id="L3811" data-line-number="3811"></td>
        <td id="LC3811">    }</td>
      </tr>
      <tr>
        <td id="L3812" data-line-number="3812"></td>
        <td id="LC3812">
</td>
      </tr>
      <tr>
        <td id="L3813" data-line-number="3813"></td>
        <td id="LC3813">    __forceinline <span>void</span> <span>ClearFlag</span>(WFLAGS2_ENUM flag)</td>
      </tr>
      <tr>
        <td id="L3814" data-line-number="3814"></td>
        <td id="LC3814">    {</td>
      </tr>
      <tr>
        <td id="L3815" data-line-number="3815"></td>
        <td id="LC3815">        m_wFlags2 &amp;= ~flag;</td>
      </tr>
      <tr>
        <td id="L3816" data-line-number="3816"></td>
        <td id="LC3816">    }</td>
      </tr>
      <tr>
        <td id="L3817" data-line-number="3817"></td>
        <td id="LC3817">    __forceinline <span>void</span> <span>SetFlag</span>(WFLAGS2_ENUM flag)</td>
      </tr>
      <tr>
        <td id="L3818" data-line-number="3818"></td>
        <td id="LC3818">    {</td>
      </tr>
      <tr>
        <td id="L3819" data-line-number="3819"></td>
        <td id="LC3819">        m_wFlags2 |= flag;</td>
      </tr>
      <tr>
        <td id="L3820" data-line-number="3820"></td>
        <td id="LC3820">    }</td>
      </tr>
      <tr>
        <td id="L3821" data-line-number="3821"></td>
        <td id="LC3821">    __forceinline DWORD <span>GetFlag</span>(WFLAGS2_ENUM flag) <span>const</span></td>
      </tr>
      <tr>
        <td id="L3822" data-line-number="3822"></td>
        <td id="LC3822">    {</td>
      </tr>
      <tr>
        <td id="L3823" data-line-number="3823"></td>
        <td id="LC3823">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3824" data-line-number="3824"></td>
        <td id="LC3824">        <span>return</span> m_wFlags2 &amp; flag;</td>
      </tr>
      <tr>
        <td id="L3825" data-line-number="3825"></td>
        <td id="LC3825">    }</td>
      </tr>
      <tr>
        <td id="L3826" data-line-number="3826"></td>
        <td id="LC3826">    __forceinline BOOL <span>TestFlagWithMask</span>(WFLAGS2_ENUM mask, WFLAGS2_ENUM flag) <span>const</span></td>
      </tr>
      <tr>
        <td id="L3827" data-line-number="3827"></td>
        <td id="LC3827">    {</td>
      </tr>
      <tr>
        <td id="L3828" data-line-number="3828"></td>
        <td id="LC3828">        <span>return</span> (m_wFlags2 &amp; (DWORD)mask) == (DWORD)flag;</td>
      </tr>
      <tr>
        <td id="L3829" data-line-number="3829"></td>
        <td id="LC3829">    }</td>
      </tr>
      <tr>
        <td id="L3830" data-line-number="3830"></td>
        <td id="LC3830">
</td>
      </tr>
      <tr>
        <td id="L3831" data-line-number="3831"></td>
        <td id="LC3831">private:</td>
      </tr>
      <tr>
        <td id="L3832" data-line-number="3832"></td>
        <td id="LC3832">    <span><span>/*</span></span></td>
      </tr>
      <tr>
        <td id="L3833" data-line-number="3833"></td>
        <td id="LC3833"><span>     * This stuff must be first in the struct and should fit on a cache line - don't move it. Used by the GC.</span></td>
      </tr>
      <tr>
        <td id="L3834" data-line-number="3834"></td>
        <td id="LC3834"><span>     <span>*/</span></span></td>
      </tr>
      <tr>
        <td id="L3835" data-line-number="3835"></td>
        <td id="LC3835">    <span><span>//</span> struct</span></td>
      </tr>
      <tr>
        <td id="L3836" data-line-number="3836"></td>
        <td id="LC3836">    <span><span>//</span> {</span></td>
      </tr>
      <tr>
        <td id="L3837" data-line-number="3837"></td>
        <td id="LC3837">
</td>
      </tr>
      <tr>
        <td id="L3838" data-line-number="3838"></td>
        <td id="LC3838">    <span><span>//</span> Low WORD is component size for array and string types (HasComponentSize() returns true).</span></td>
      </tr>
      <tr>
        <td id="L3839" data-line-number="3839"></td>
        <td id="LC3839">    <span><span>//</span> Used for flags otherwise.</span></td>
      </tr>
      <tr>
        <td id="L3840" data-line-number="3840"></td>
        <td id="LC3840">    DWORD           m_dwFlags;</td>
      </tr>
      <tr>
        <td id="L3841" data-line-number="3841"></td>
        <td id="LC3841">
</td>
      </tr>
      <tr>
        <td id="L3842" data-line-number="3842"></td>
        <td id="LC3842">    <span><span>//</span> Base size of instance of this class when allocated on the heap</span></td>
      </tr>
      <tr>
        <td id="L3843" data-line-number="3843"></td>
        <td id="LC3843">    DWORD           m_BaseSize;</td>
      </tr>
      <tr>
        <td id="L3844" data-line-number="3844"></td>
        <td id="LC3844">    <span><span>//</span> }</span></td>
      </tr>
      <tr>
        <td id="L3845" data-line-number="3845"></td>
        <td id="LC3845">
</td>
      </tr>
      <tr>
        <td id="L3846" data-line-number="3846"></td>
        <td id="LC3846">    WORD            m_wFlags2;</td>
      </tr>
      <tr>
        <td id="L3847" data-line-number="3847"></td>
        <td id="LC3847">
</td>
      </tr>
      <tr>
        <td id="L3848" data-line-number="3848"></td>
        <td id="LC3848">    <span><span>//</span> Class token if it fits into 16-bits. If this is (WORD)-1, the class token is stored in the TokenOverflow optional member.</span></td>
      </tr>
      <tr>
        <td id="L3849" data-line-number="3849"></td>
        <td id="LC3849">    WORD            m_wToken;</td>
      </tr>
      <tr>
        <td id="L3850" data-line-number="3850"></td>
        <td id="LC3850">
</td>
      </tr>
      <tr>
        <td id="L3851" data-line-number="3851"></td>
        <td id="LC3851">    <span><span>//</span> &lt;NICE&gt; In the normal cases we shouldn't need a full word for each of these &lt;/NICE&gt;</span></td>
      </tr>
      <tr>
        <td id="L3852" data-line-number="3852"></td>
        <td id="LC3852">    WORD            m_wNumVirtuals;</td>
      </tr>
      <tr>
        <td id="L3853" data-line-number="3853"></td>
        <td id="LC3853">    WORD            m_wNumInterfaces;</td>
      </tr>
      <tr>
        <td id="L3854" data-line-number="3854"></td>
        <td id="LC3854">
</td>
      </tr>
      <tr>
        <td id="L3855" data-line-number="3855"></td>
        <td id="LC3855">#<span>ifdef</span> _DEBUG</td>
      </tr>
      <tr>
        <td id="L3856" data-line-number="3856"></td>
        <td id="LC3856">    LPCUTF8         debug_m_szClassName;</td>
      </tr>
      <tr>
        <td id="L3857" data-line-number="3857"></td>
        <td id="LC3857">#<span>endif</span> <span><span>//</span>_DEBUG</span></td>
      </tr>
      <tr>
        <td id="L3858" data-line-number="3858"></td>
        <td id="LC3858">
</td>
      </tr>
      <tr>
        <td id="L3859" data-line-number="3859"></td>
        <td id="LC3859">    <span><span>//</span> On Linux ARM is a RelativeFixupPointer. Otherwise,</span></td>
      </tr>
      <tr>
        <td id="L3860" data-line-number="3860"></td>
        <td id="LC3860">    <span><span>//</span> Parent PTR_MethodTable if enum_flag_HasIndirectParent is not set. Pointer to indirection cell</span></td>
      </tr>
      <tr>
        <td id="L3861" data-line-number="3861"></td>
        <td id="LC3861">    <span><span>//</span> if enum_flag_enum_flag_HasIndirectParent is set. The indirection is offset by offsetof(MethodTable, m_pParentMethodTable).</span></td>
      </tr>
      <tr>
        <td id="L3862" data-line-number="3862"></td>
        <td id="LC3862">    <span><span>//</span> It allows casting helpers to go through parent chain natually. Casting helper do not need need the explicit check</span></td>
      </tr>
      <tr>
        <td id="L3863" data-line-number="3863"></td>
        <td id="LC3863">    <span><span>//</span> for enum_flag_HasIndirectParentMethodTable.</span></td>
      </tr>
      <tr>
        <td id="L3864" data-line-number="3864"></td>
        <td id="LC3864">    ParentMT_t m_pParentMethodTable;</td>
      </tr>
      <tr>
        <td id="L3865" data-line-number="3865"></td>
        <td id="LC3865">
</td>
      </tr>
      <tr>
        <td id="L3866" data-line-number="3866"></td>
        <td id="LC3866">    RelativePointer&lt;PTR_Module&gt; m_pLoaderModule;    <span><span>//</span> LoaderModule. It is equal to the ZapModule in ngened images</span></td>
      </tr>
      <tr>
        <td id="L3867" data-line-number="3867"></td>
        <td id="LC3867">
</td>
      </tr>
      <tr>
        <td id="L3868" data-line-number="3868"></td>
        <td id="LC3868">#<span>if</span> defined(FEATURE_NGEN_RELOCS_OPTIMIZATIONS)</td>
      </tr>
      <tr>
        <td id="L3869" data-line-number="3869"></td>
        <td id="LC3869">    RelativePointer&lt;PTR_MethodTableWriteableData&gt; m_pWriteableData;</td>
      </tr>
      <tr>
        <td id="L3870" data-line-number="3870"></td>
        <td id="LC3870">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L3871" data-line-number="3871"></td>
        <td id="LC3871">    PlainPointer&lt;PTR_MethodTableWriteableData&gt; m_pWriteableData;</td>
      </tr>
      <tr>
        <td id="L3872" data-line-number="3872"></td>
        <td id="LC3872">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3873" data-line-number="3873"></td>
        <td id="LC3873">
</td>
      </tr>
      <tr>
        <td id="L3874" data-line-number="3874"></td>
        <td id="LC3874">    <span><span>//</span> The value of lowest two bits describe what the union contains</span></td>
      </tr>
      <tr>
        <td id="L3875" data-line-number="3875"></td>
        <td id="LC3875">    <span>enum</span> LowBits {</td>
      </tr>
      <tr>
        <td id="L3876" data-line-number="3876"></td>
        <td id="LC3876">        UNION_EECLASS      = <span>0</span>,    <span><span>//</span>  0 - pointer to EEClass. This MethodTable is the canonical method table.</span></td>
      </tr>
      <tr>
        <td id="L3877" data-line-number="3877"></td>
        <td id="LC3877">        UNION_INVALID      = <span>1</span>,    <span><span>//</span>  1 - not used</span></td>
      </tr>
      <tr>
        <td id="L3878" data-line-number="3878"></td>
        <td id="LC3878">        UNION_METHODTABLE  = <span>2</span>,    <span><span>//</span>  2 - pointer to canonical MethodTable.</span></td>
      </tr>
      <tr>
        <td id="L3879" data-line-number="3879"></td>
        <td id="LC3879">        UNION_INDIRECTION  = <span>3</span>     <span><span>//</span>  3 - pointer to indirection cell that points to canonical MethodTable.</span></td>
      </tr>
      <tr>
        <td id="L3880" data-line-number="3880"></td>
        <td id="LC3880">    };                             <span><span>//</span>      (used only if FEATURE_PREJIT is defined)</span></td>
      </tr>
      <tr>
        <td id="L3881" data-line-number="3881"></td>
        <td id="LC3881">    <span>static</span> <span>const</span> TADDR UNION_MASK = <span>3</span>;</td>
      </tr>
      <tr>
        <td id="L3882" data-line-number="3882"></td>
        <td id="LC3882">
</td>
      </tr>
      <tr>
        <td id="L3883" data-line-number="3883"></td>
        <td id="LC3883">    <span>union</span> {</td>
      </tr>
      <tr>
        <td id="L3884" data-line-number="3884"></td>
        <td id="LC3884">#<span>if</span> defined(FEATURE_NGEN_RELOCS_OPTIMIZATIONS)</td>
      </tr>
      <tr>
        <td id="L3885" data-line-number="3885"></td>
        <td id="LC3885">        RelativePointer&lt;<span>DPTR</span>(EEClass)&gt; m_pEEClass;</td>
      </tr>
      <tr>
        <td id="L3886" data-line-number="3886"></td>
        <td id="LC3886">        RelativePointer&lt;TADDR&gt; m_pCanonMT;</td>
      </tr>
      <tr>
        <td id="L3887" data-line-number="3887"></td>
        <td id="LC3887">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L3888" data-line-number="3888"></td>
        <td id="LC3888">        PlainPointer&lt;<span>DPTR</span>(EEClass)&gt; m_pEEClass;</td>
      </tr>
      <tr>
        <td id="L3889" data-line-number="3889"></td>
        <td id="LC3889">        PlainPointer&lt;TADDR&gt; m_pCanonMT;</td>
      </tr>
      <tr>
        <td id="L3890" data-line-number="3890"></td>
        <td id="LC3890">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3891" data-line-number="3891"></td>
        <td id="LC3891">    };</td>
      </tr>
      <tr>
        <td id="L3892" data-line-number="3892"></td>
        <td id="LC3892">
</td>
      </tr>
      <tr>
        <td id="L3893" data-line-number="3893"></td>
        <td id="LC3893">    __forceinline <span>static</span> LowBits <span>union_getLowBits</span>(TADDR pCanonMT)</td>
      </tr>
      <tr>
        <td id="L3894" data-line-number="3894"></td>
        <td id="LC3894">    {</td>
      </tr>
      <tr>
        <td id="L3895" data-line-number="3895"></td>
        <td id="LC3895">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3896" data-line-number="3896"></td>
        <td id="LC3896">        <span>return</span> <span>LowBits</span>(pCanonMT &amp; UNION_MASK);</td>
      </tr>
      <tr>
        <td id="L3897" data-line-number="3897"></td>
        <td id="LC3897">    }</td>
      </tr>
      <tr>
        <td id="L3898" data-line-number="3898"></td>
        <td id="LC3898">    __forceinline <span>static</span> TADDR   <span>union_getPointer</span>(TADDR pCanonMT)</td>
      </tr>
      <tr>
        <td id="L3899" data-line-number="3899"></td>
        <td id="LC3899">    {</td>
      </tr>
      <tr>
        <td id="L3900" data-line-number="3900"></td>
        <td id="LC3900">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L3901" data-line-number="3901"></td>
        <td id="LC3901">        <span>return</span> (pCanonMT &amp; ~UNION_MASK);</td>
      </tr>
      <tr>
        <td id="L3902" data-line-number="3902"></td>
        <td id="LC3902">    }</td>
      </tr>
      <tr>
        <td id="L3903" data-line-number="3903"></td>
        <td id="LC3903">
</td>
      </tr>
      <tr>
        <td id="L3904" data-line-number="3904"></td>
        <td id="LC3904">    <span><span>//</span> m_pPerInstInfo and m_pInterfaceMap have to be at fixed offsets because of performance sensitive</span></td>
      </tr>
      <tr>
        <td id="L3905" data-line-number="3905"></td>
        <td id="LC3905">    <span><span>//</span> JITed code and JIT helpers. However, they are frequently not present. The space is used by other</span></td>
      </tr>
      <tr>
        <td id="L3906" data-line-number="3906"></td>
        <td id="LC3906">    <span><span>//</span> multipurpose slots on first come first served basis if the fixed ones are not present. The other</span></td>
      </tr>
      <tr>
        <td id="L3907" data-line-number="3907"></td>
        <td id="LC3907">    <span><span>//</span> multipurpose are DispatchMapSlot, NonVirtualSlots, ModuleOverride (see enum_flag_MultipurposeSlotsMask).</span></td>
      </tr>
      <tr>
        <td id="L3908" data-line-number="3908"></td>
        <td id="LC3908">    <span><span>//</span> The multipurpose slots that do not fit are stored after vtable slots.</span></td>
      </tr>
      <tr>
        <td id="L3909" data-line-number="3909"></td>
        <td id="LC3909">
</td>
      </tr>
      <tr>
        <td id="L3910" data-line-number="3910"></td>
        <td id="LC3910">    <span>union</span></td>
      </tr>
      <tr>
        <td id="L3911" data-line-number="3911"></td>
        <td id="LC3911">    {</td>
      </tr>
      <tr>
        <td id="L3912" data-line-number="3912"></td>
        <td id="LC3912">        PerInstInfo_t m_pPerInstInfo;</td>
      </tr>
      <tr>
        <td id="L3913" data-line-number="3913"></td>
        <td id="LC3913">        TADDR         m_ElementTypeHnd;</td>
      </tr>
      <tr>
        <td id="L3914" data-line-number="3914"></td>
        <td id="LC3914">        TADDR         m_pMultipurposeSlot1;</td>
      </tr>
      <tr>
        <td id="L3915" data-line-number="3915"></td>
        <td id="LC3915">    };</td>
      </tr>
      <tr>
        <td id="L3916" data-line-number="3916"></td>
        <td id="LC3916">    public:</td>
      </tr>
      <tr>
        <td id="L3917" data-line-number="3917"></td>
        <td id="LC3917">    <span>union</span></td>
      </tr>
      <tr>
        <td id="L3918" data-line-number="3918"></td>
        <td id="LC3918">    {</td>
      </tr>
      <tr>
        <td id="L3919" data-line-number="3919"></td>
        <td id="LC3919">#<span>if</span> defined(FEATURE_NGEN_RELOCS_OPTIMIZATIONS)</td>
      </tr>
      <tr>
        <td id="L3920" data-line-number="3920"></td>
        <td id="LC3920">        RelativePointer&lt;PTR_InterfaceInfo&gt;   m_pInterfaceMap;</td>
      </tr>
      <tr>
        <td id="L3921" data-line-number="3921"></td>
        <td id="LC3921">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L3922" data-line-number="3922"></td>
        <td id="LC3922">        PlainPointer&lt;PTR_InterfaceInfo&gt;   m_pInterfaceMap;</td>
      </tr>
      <tr>
        <td id="L3923" data-line-number="3923"></td>
        <td id="LC3923">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3924" data-line-number="3924"></td>
        <td id="LC3924">        TADDR               m_pMultipurposeSlot2;</td>
      </tr>
      <tr>
        <td id="L3925" data-line-number="3925"></td>
        <td id="LC3925">    };</td>
      </tr>
      <tr>
        <td id="L3926" data-line-number="3926"></td>
        <td id="LC3926">
</td>
      </tr>
      <tr>
        <td id="L3927" data-line-number="3927"></td>
        <td id="LC3927">    <span><span>//</span> VTable and Non-Virtual slots go here</span></td>
      </tr>
      <tr>
        <td id="L3928" data-line-number="3928"></td>
        <td id="LC3928">
</td>
      </tr>
      <tr>
        <td id="L3929" data-line-number="3929"></td>
        <td id="LC3929">    <span><span>//</span> Overflow multipurpose slots go here</span></td>
      </tr>
      <tr>
        <td id="L3930" data-line-number="3930"></td>
        <td id="LC3930">
</td>
      </tr>
      <tr>
        <td id="L3931" data-line-number="3931"></td>
        <td id="LC3931">    <span><span>//</span> Optional Members go here</span></td>
      </tr>
      <tr>
        <td id="L3932" data-line-number="3932"></td>
        <td id="LC3932">    <span><span>//</span>    See above for the list of optional members</span></td>
      </tr>
      <tr>
        <td id="L3933" data-line-number="3933"></td>
        <td id="LC3933">
</td>
      </tr>
      <tr>
        <td id="L3934" data-line-number="3934"></td>
        <td id="LC3934">    <span><span>//</span> Generic dictionary pointers go here</span></td>
      </tr>
      <tr>
        <td id="L3935" data-line-number="3935"></td>
        <td id="LC3935">
</td>
      </tr>
      <tr>
        <td id="L3936" data-line-number="3936"></td>
        <td id="LC3936">    <span><span>//</span> Interface map goes here</span></td>
      </tr>
      <tr>
        <td id="L3937" data-line-number="3937"></td>
        <td id="LC3937">
</td>
      </tr>
      <tr>
        <td id="L3938" data-line-number="3938"></td>
        <td id="LC3938">    <span><span>//</span> Generic instantiation+dictionary goes here</span></td>
      </tr>
      <tr>
        <td id="L3939" data-line-number="3939"></td>
        <td id="LC3939">
</td>
      </tr>
      <tr>
        <td id="L3940" data-line-number="3940"></td>
        <td id="LC3940">private:</td>
      </tr>
      <tr>
        <td id="L3941" data-line-number="3941"></td>
        <td id="LC3941">
</td>
      </tr>
      <tr>
        <td id="L3942" data-line-number="3942"></td>
        <td id="LC3942">    <span><span>//</span> disallow direct creation</span></td>
      </tr>
      <tr>
        <td id="L3943" data-line-number="3943"></td>
        <td id="LC3943">    <span>void</span> *operator <span>new</span>(<span>size_t</span> dummy);</td>
      </tr>
      <tr>
        <td id="L3944" data-line-number="3944"></td>
        <td id="LC3944">    <span>void</span> operator <span>delete</span>(<span>void</span> *pData);</td>
      </tr>
      <tr>
        <td id="L3945" data-line-number="3945"></td>
        <td id="LC3945">    <span>MethodTable</span>();</td>
      </tr>
      <tr>
        <td id="L3946" data-line-number="3946"></td>
        <td id="LC3946">
</td>
      </tr>
      <tr>
        <td id="L3947" data-line-number="3947"></td>
        <td id="LC3947">    <span><span>//</span> Optional members.  These are used for fields in the data structure where</span></td>
      </tr>
      <tr>
        <td id="L3948" data-line-number="3948"></td>
        <td id="LC3948">    <span><span>//</span> the fields are (a) known when MT is created and (b) there is a default</span></td>
      </tr>
      <tr>
        <td id="L3949" data-line-number="3949"></td>
        <td id="LC3949">    <span><span>//</span> value for the field in the common case.  That is, they are normally used</span></td>
      </tr>
      <tr>
        <td id="L3950" data-line-number="3950"></td>
        <td id="LC3950">    <span><span>//</span> for data that is only relevant to a small number of method tables.</span></td>
      </tr>
      <tr>
        <td id="L3951" data-line-number="3951"></td>
        <td id="LC3951">
</td>
      </tr>
      <tr>
        <td id="L3952" data-line-number="3952"></td>
        <td id="LC3952">    <span><span>//</span> Optional members and multipurpose slots have similar purpose, but they differ in details:</span></td>
      </tr>
      <tr>
        <td id="L3953" data-line-number="3953"></td>
        <td id="LC3953">    <span><span>//</span> - Multipurpose slots can only accomodate pointer sized structures right now. It is non-trivial</span></td>
      </tr>
      <tr>
        <td id="L3954" data-line-number="3954"></td>
        <td id="LC3954">    <span><span>//</span>   to add new ones, the access is faster.</span></td>
      </tr>
      <tr>
        <td id="L3955" data-line-number="3955"></td>
        <td id="LC3955">    <span><span>//</span> - Optional members can accomodate structures of any size. It is trivial to add new ones,</span></td>
      </tr>
      <tr>
        <td id="L3956" data-line-number="3956"></td>
        <td id="LC3956">    <span><span>//</span>   the access is slower.</span></td>
      </tr>
      <tr>
        <td id="L3957" data-line-number="3957"></td>
        <td id="LC3957">
</td>
      </tr>
      <tr>
        <td id="L3958" data-line-number="3958"></td>
        <td id="LC3958">    <span><span>//</span> The following macro will automatically create GetXXX accessors for the optional members.</span></td>
      </tr>
      <tr>
        <td id="L3959" data-line-number="3959"></td>
        <td id="LC3959">#<span>define</span> <span>METHODTABLE_OPTIONAL_MEMBERS</span>() </td>
      </tr>
      <tr>
        <td id="L3960" data-line-number="3960"></td>
        <td id="LC3960">    <span><span>/*</span>                          NAME                    TYPE                            GETTER                     <span>*/</span></span> </td>
      </tr>
      <tr>
        <td id="L3961" data-line-number="3961"></td>
        <td id="LC3961">    <span><span>/*</span> Accessing this member efficiently is currently performance critical for static field accesses               <span>*/</span></span> </td>
      </tr>
      <tr>
        <td id="L3962" data-line-number="3962"></td>
        <td id="LC3962">    <span><span>/*</span> in generic classes, so place it early in the list. <span>*/</span></span>                                                          </td>
      </tr>
      <tr>
        <td id="L3963" data-line-number="3963"></td>
        <td id="LC3963">    <span>METHODTABLE_OPTIONAL_MEMBER</span>(GenericsStaticsInfo,    GenericsStaticsInfo,            GetGenericsStaticsInfo      ) </td>
      </tr>
      <tr>
        <td id="L3964" data-line-number="3964"></td>
        <td id="LC3964">    <span><span>/*</span> Accessed by interop, fairly frequently. <span>*/</span></span>                                                                     </td>
      </tr>
      <tr>
        <td id="L3965" data-line-number="3965"></td>
        <td id="LC3965">    <span>METHODTABLE_COMINTEROP_OPTIONAL_MEMBERS</span>()                                                                         </td>
      </tr>
      <tr>
        <td id="L3966" data-line-number="3966"></td>
        <td id="LC3966">    <span><span>/*</span> Accessed during x-domain transition only, so place it late in the list. <span>*/</span></span>                                     </td>
      </tr>
      <tr>
        <td id="L3967" data-line-number="3967"></td>
        <td id="LC3967">    <span>METHODTABLE_REMOTING_OPTIONAL_MEMBERS</span>()                                                                           </td>
      </tr>
      <tr>
        <td id="L3968" data-line-number="3968"></td>
        <td id="LC3968">    <span><span>/*</span> Accessed during certain generic type load operations only, so low priority <span>*/</span></span>                                  </td>
      </tr>
      <tr>
        <td id="L3969" data-line-number="3969"></td>
        <td id="LC3969">    <span>METHODTABLE_OPTIONAL_MEMBER</span>(ExtraInterfaceInfo,     TADDR,                          GetExtraInterfaceInfoPtr    ) </td>
      </tr>
      <tr>
        <td id="L3970" data-line-number="3970"></td>
        <td id="LC3970">    <span><span>/*</span> TypeDef token for assemblies with more than 64k types. Never happens in real world. <span>*/</span></span>                         </td>
      </tr>
      <tr>
        <td id="L3971" data-line-number="3971"></td>
        <td id="LC3971">    <span>METHODTABLE_OPTIONAL_MEMBER</span>(TokenOverflow,          TADDR,                          GetTokenOverflowPtr         ) </td>
      </tr>
      <tr>
        <td id="L3972" data-line-number="3972"></td>
        <td id="LC3972">
</td>
      </tr>
      <tr>
        <td id="L3973" data-line-number="3973"></td>
        <td id="LC3973">#<span>ifdef</span> FEATURE_COMINTEROP</td>
      </tr>
      <tr>
        <td id="L3974" data-line-number="3974"></td>
        <td id="LC3974">#<span>define</span> <span>METHODTABLE_COMINTEROP_OPTIONAL_MEMBERS</span>() </td>
      </tr>
      <tr>
        <td id="L3975" data-line-number="3975"></td>
        <td id="LC3975">    <span>METHODTABLE_OPTIONAL_MEMBER</span>(GuidInfo,               PTR_GuidInfo,                   GetGuidInfoPtr              ) </td>
      </tr>
      <tr>
        <td id="L3976" data-line-number="3976"></td>
        <td id="LC3976">    <span>METHODTABLE_OPTIONAL_MEMBER</span>(RCWPerTypeData,         RCWPerTypeData *,               GetRCWPerTypeDataPtr        ) </td>
      </tr>
      <tr>
        <td id="L3977" data-line-number="3977"></td>
        <td id="LC3977">    <span>METHODTABLE_OPTIONAL_MEMBER</span>(CCWTemplate,            ComCallWrapperTemplate *,       GetCCWTemplatePtr           )</td>
      </tr>
      <tr>
        <td id="L3978" data-line-number="3978"></td>
        <td id="LC3978">#<span>else</span></td>
      </tr>
      <tr>
        <td id="L3979" data-line-number="3979"></td>
        <td id="LC3979">#<span>define</span> <span>METHODTABLE_COMINTEROP_OPTIONAL_MEMBERS</span>()</td>
      </tr>
      <tr>
        <td id="L3980" data-line-number="3980"></td>
        <td id="LC3980">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L3981" data-line-number="3981"></td>
        <td id="LC3981">
</td>
      </tr>
      <tr>
        <td id="L3982" data-line-number="3982"></td>
        <td id="LC3982">#<span>define</span> <span>METHODTABLE_REMOTING_OPTIONAL_MEMBERS</span>()</td>
      </tr>
      <tr>
        <td id="L3983" data-line-number="3983"></td>
        <td id="LC3983">
</td>
      </tr>
      <tr>
        <td id="L3984" data-line-number="3984"></td>
        <td id="LC3984">    <span>enum</span> OptionalMemberId</td>
      </tr>
      <tr>
        <td id="L3985" data-line-number="3985"></td>
        <td id="LC3985">    {</td>
      </tr>
      <tr>
        <td id="L3986" data-line-number="3986"></td>
        <td id="LC3986">#<span>undef</span> METHODTABLE_OPTIONAL_MEMBER</td>
      </tr>
      <tr>
        <td id="L3987" data-line-number="3987"></td>
        <td id="LC3987">#<span>define</span> <span>METHODTABLE_OPTIONAL_MEMBER</span>(<span>NAME, TYPE, GETTER</span>) OptionalMember_##NAME,</td>
      </tr>
      <tr>
        <td id="L3988" data-line-number="3988"></td>
        <td id="LC3988">        <span>METHODTABLE_OPTIONAL_MEMBERS</span>()</td>
      </tr>
      <tr>
        <td id="L3989" data-line-number="3989"></td>
        <td id="LC3989">        OptionalMember_Count,</td>
      </tr>
      <tr>
        <td id="L3990" data-line-number="3990"></td>
        <td id="LC3990">
</td>
      </tr>
      <tr>
        <td id="L3991" data-line-number="3991"></td>
        <td id="LC3991">        OptionalMember_First = OptionalMember_GenericsStaticsInfo,</td>
      </tr>
      <tr>
        <td id="L3992" data-line-number="3992"></td>
        <td id="LC3992">    };</td>
      </tr>
      <tr>
        <td id="L3993" data-line-number="3993"></td>
        <td id="LC3993">
</td>
      </tr>
      <tr>
        <td id="L3994" data-line-number="3994"></td>
        <td id="LC3994">    FORCEINLINE DWORD <span>GetOffsetOfOptionalMember</span>(OptionalMemberId id);</td>
      </tr>
      <tr>
        <td id="L3995" data-line-number="3995"></td>
        <td id="LC3995">
</td>
      </tr>
      <tr>
        <td id="L3996" data-line-number="3996"></td>
        <td id="LC3996">public:</td>
      </tr>
      <tr>
        <td id="L3997" data-line-number="3997"></td>
        <td id="LC3997">
</td>
      </tr>
      <tr>
        <td id="L3998" data-line-number="3998"></td>
        <td id="LC3998">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L3999" data-line-number="3999"></td>
        <td id="LC3999">    <span><span>//</span> Public accessor helpers for the optional members of MethodTable</span></td>
      </tr>
      <tr>
        <td id="L4000" data-line-number="4000"></td>
        <td id="LC4000">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4001" data-line-number="4001"></td>
        <td id="LC4001">
</td>
      </tr>
      <tr>
        <td id="L4002" data-line-number="4002"></td>
        <td id="LC4002">#<span>undef</span> METHODTABLE_OPTIONAL_MEMBER</td>
      </tr>
      <tr>
        <td id="L4003" data-line-number="4003"></td>
        <td id="LC4003">#<span>define</span> <span>METHODTABLE_OPTIONAL_MEMBER</span>(<span>NAME, TYPE, GETTER</span>) </td>
      </tr>
      <tr>
        <td id="L4004" data-line-number="4004"></td>
        <td id="LC4004">    <span>inline</span> <span>DPTR</span>(TYPE) <span>GETTER</span>() </td>
      </tr>
      <tr>
        <td id="L4005" data-line-number="4005"></td>
        <td id="LC4005">    { </td>
      </tr>
      <tr>
        <td id="L4006" data-line-number="4006"></td>
        <td id="LC4006">        LIMITED_METHOD_CONTRACT; </td>
      </tr>
      <tr>
        <td id="L4007" data-line-number="4007"></td>
        <td id="LC4007">        <span>_ASSERTE</span>(Has##<span>NAME</span>()); </td>
      </tr>
      <tr>
        <td id="L4008" data-line-number="4008"></td>
        <td id="LC4008">        <span>return</span> dac_cast&lt;<span>DPTR</span>(TYPE)&gt;(dac_cast&lt;TADDR&gt;(this) + <span>GetOffsetOfOptionalMember</span>(OptionalMember_##NAME)); </td>
      </tr>
      <tr>
        <td id="L4009" data-line-number="4009"></td>
        <td id="LC4009">    }</td>
      </tr>
      <tr>
        <td id="L4010" data-line-number="4010"></td>
        <td id="LC4010">
</td>
      </tr>
      <tr>
        <td id="L4011" data-line-number="4011"></td>
        <td id="LC4011">    <span>METHODTABLE_OPTIONAL_MEMBERS</span>()</td>
      </tr>
      <tr>
        <td id="L4012" data-line-number="4012"></td>
        <td id="LC4012">
</td>
      </tr>
      <tr>
        <td id="L4013" data-line-number="4013"></td>
        <td id="LC4013">private:</td>
      </tr>
      <tr>
        <td id="L4014" data-line-number="4014"></td>
        <td id="LC4014">    <span>inline</span> DWORD <span>GetStartOffsetOfOptionalMembers</span>()</td>
      </tr>
      <tr>
        <td id="L4015" data-line-number="4015"></td>
        <td id="LC4015">    {</td>
      </tr>
      <tr>
        <td id="L4016" data-line-number="4016"></td>
        <td id="LC4016">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L4017" data-line-number="4017"></td>
        <td id="LC4017">        <span>return</span> <span>GetOffsetOfOptionalMember</span>(OptionalMember_First);</td>
      </tr>
      <tr>
        <td id="L4018" data-line-number="4018"></td>
        <td id="LC4018">    }</td>
      </tr>
      <tr>
        <td id="L4019" data-line-number="4019"></td>
        <td id="LC4019">
</td>
      </tr>
      <tr>
        <td id="L4020" data-line-number="4020"></td>
        <td id="LC4020">    <span>inline</span> DWORD <span>GetEndOffsetOfOptionalMembers</span>()</td>
      </tr>
      <tr>
        <td id="L4021" data-line-number="4021"></td>
        <td id="LC4021">    {</td>
      </tr>
      <tr>
        <td id="L4022" data-line-number="4022"></td>
        <td id="LC4022">        WRAPPER_NO_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L4023" data-line-number="4023"></td>
        <td id="LC4023">        <span>return</span> <span>GetOffsetOfOptionalMember</span>(OptionalMember_Count);</td>
      </tr>
      <tr>
        <td id="L4024" data-line-number="4024"></td>
        <td id="LC4024">    }</td>
      </tr>
      <tr>
        <td id="L4025" data-line-number="4025"></td>
        <td id="LC4025">
</td>
      </tr>
      <tr>
        <td id="L4026" data-line-number="4026"></td>
        <td id="LC4026">    <span>inline</span> <span>static</span> DWORD <span>GetOptionalMembersAllocationSize</span>(</td>
      </tr>
      <tr>
        <td id="L4027" data-line-number="4027"></td>
        <td id="LC4027">                                                  DWORD dwMultipurposeSlotsMask,</td>
      </tr>
      <tr>
        <td id="L4028" data-line-number="4028"></td>
        <td id="LC4028">                                                  BOOL needsGenericsStaticsInfo,</td>
      </tr>
      <tr>
        <td id="L4029" data-line-number="4029"></td>
        <td id="LC4029">                                                  BOOL needsGuidInfo,</td>
      </tr>
      <tr>
        <td id="L4030" data-line-number="4030"></td>
        <td id="LC4030">                                                  BOOL needsCCWTemplate,</td>
      </tr>
      <tr>
        <td id="L4031" data-line-number="4031"></td>
        <td id="LC4031">                                                  BOOL needsRCWPerTypeData,</td>
      </tr>
      <tr>
        <td id="L4032" data-line-number="4032"></td>
        <td id="LC4032">                                                  BOOL needsTokenOverflow);</td>
      </tr>
      <tr>
        <td id="L4033" data-line-number="4033"></td>
        <td id="LC4033">    <span>inline</span> DWORD <span>GetOptionalMembersSize</span>();</td>
      </tr>
      <tr>
        <td id="L4034" data-line-number="4034"></td>
        <td id="LC4034">
</td>
      </tr>
      <tr>
        <td id="L4035" data-line-number="4035"></td>
        <td id="LC4035">    <span><span>//</span> The PerInstInfo is a (possibly empty) array of pointers to</span></td>
      </tr>
      <tr>
        <td id="L4036" data-line-number="4036"></td>
        <td id="LC4036">    <span><span>//</span> Instantiations/Dictionaries. This array comes after the optional members.</span></td>
      </tr>
      <tr>
        <td id="L4037" data-line-number="4037"></td>
        <td id="LC4037">    <span>inline</span> DWORD <span>GetPerInstInfoSize</span>();</td>
      </tr>
      <tr>
        <td id="L4038" data-line-number="4038"></td>
        <td id="LC4038">
</td>
      </tr>
      <tr>
        <td id="L4039" data-line-number="4039"></td>
        <td id="LC4039">    <span><span>//</span> This is the size of the interface map chunk in the method table.</span></td>
      </tr>
      <tr>
        <td id="L4040" data-line-number="4040"></td>
        <td id="LC4040">    <span><span>//</span> If the MethodTable has a dynamic interface map then the size includes the pointer</span></td>
      </tr>
      <tr>
        <td id="L4041" data-line-number="4041"></td>
        <td id="LC4041">    <span><span>//</span> that stores the extra info for that map.</span></td>
      </tr>
      <tr>
        <td id="L4042" data-line-number="4042"></td>
        <td id="LC4042">    <span><span>//</span> The interface map itself comes after the PerInstInfo (if any)</span></td>
      </tr>
      <tr>
        <td id="L4043" data-line-number="4043"></td>
        <td id="LC4043">    <span>inline</span> DWORD <span>GetInterfaceMapSize</span>();</td>
      </tr>
      <tr>
        <td id="L4044" data-line-number="4044"></td>
        <td id="LC4044">
</td>
      </tr>
      <tr>
        <td id="L4045" data-line-number="4045"></td>
        <td id="LC4045">    <span><span>//</span> The instantiation/dictionary comes at the end of the MethodTable after</span></td>
      </tr>
      <tr>
        <td id="L4046" data-line-number="4046"></td>
        <td id="LC4046">    <span><span>//</span>  the interface map.</span></td>
      </tr>
      <tr>
        <td id="L4047" data-line-number="4047"></td>
        <td id="LC4047">    <span>inline</span> DWORD <span>GetInstAndDictSize</span>();</td>
      </tr>
      <tr>
        <td id="L4048" data-line-number="4048"></td>
        <td id="LC4048">
</td>
      </tr>
      <tr>
        <td id="L4049" data-line-number="4049"></td>
        <td id="LC4049">private:</td>
      </tr>
      <tr>
        <td id="L4050" data-line-number="4050"></td>
        <td id="LC4050">    <span><span>//</span> Helper template to compute the offsets at compile time</span></td>
      </tr>
      <tr>
        <td id="L4051" data-line-number="4051"></td>
        <td id="LC4051">    template&lt;<span>int</span> mask&gt;</td>
      </tr>
      <tr>
        <td id="L4052" data-line-number="4052"></td>
        <td id="LC4052">    <span>struct</span> MultipurposeSlotOffset;</td>
      </tr>
      <tr>
        <td id="L4053" data-line-number="4053"></td>
        <td id="LC4053">
</td>
      </tr>
      <tr>
        <td id="L4054" data-line-number="4054"></td>
        <td id="LC4054">    <span>static</span> <span>const</span> BYTE c_DispatchMapSlotOffsets[];</td>
      </tr>
      <tr>
        <td id="L4055" data-line-number="4055"></td>
        <td id="LC4055">    <span>static</span> <span>const</span> BYTE c_NonVirtualSlotsOffsets[];</td>
      </tr>
      <tr>
        <td id="L4056" data-line-number="4056"></td>
        <td id="LC4056">    <span>static</span> <span>const</span> BYTE c_ModuleOverrideOffsets[];</td>
      </tr>
      <tr>
        <td id="L4057" data-line-number="4057"></td>
        <td id="LC4057">
</td>
      </tr>
      <tr>
        <td id="L4058" data-line-number="4058"></td>
        <td id="LC4058">    <span>static</span> <span>const</span> BYTE c_OptionalMembersStartOffsets[]; <span><span>//</span> total sizes of optional slots</span></td>
      </tr>
      <tr>
        <td id="L4059" data-line-number="4059"></td>
        <td id="LC4059">
</td>
      </tr>
      <tr>
        <td id="L4060" data-line-number="4060"></td>
        <td id="LC4060">    TADDR <span>GetMultipurposeSlotPtr</span>(WFLAGS2_ENUM flag, <span>const</span> BYTE * offsets);</td>
      </tr>
      <tr>
        <td id="L4061" data-line-number="4061"></td>
        <td id="LC4061">
</td>
      </tr>
      <tr>
        <td id="L4062" data-line-number="4062"></td>
        <td id="LC4062">    <span>void</span> <span>SetMultipurposeSlotsMask</span>(DWORD dwMask)</td>
      </tr>
      <tr>
        <td id="L4063" data-line-number="4063"></td>
        <td id="LC4063">    {</td>
      </tr>
      <tr>
        <td id="L4064" data-line-number="4064"></td>
        <td id="LC4064">        LIMITED_METHOD_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L4065" data-line-number="4065"></td>
        <td id="LC4065">        <span>_ASSERTE</span>((m_wFlags2 &amp; enum_flag_MultipurposeSlotsMask) == <span>0</span>);</td>
      </tr>
      <tr>
        <td id="L4066" data-line-number="4066"></td>
        <td id="LC4066">        m_wFlags2 |= (WORD)dwMask;</td>
      </tr>
      <tr>
        <td id="L4067" data-line-number="4067"></td>
        <td id="LC4067">    }</td>
      </tr>
      <tr>
        <td id="L4068" data-line-number="4068"></td>
        <td id="LC4068">
</td>
      </tr>
      <tr>
        <td id="L4069" data-line-number="4069"></td>
        <td id="LC4069">    BOOL <span>HasModuleOverride</span>()</td>
      </tr>
      <tr>
        <td id="L4070" data-line-number="4070"></td>
        <td id="LC4070">    {</td>
      </tr>
      <tr>
        <td id="L4071" data-line-number="4071"></td>
        <td id="LC4071">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L4072" data-line-number="4072"></td>
        <td id="LC4072">        <span>return</span> <span>GetFlag</span>(enum_flag_HasModuleOverride);</td>
      </tr>
      <tr>
        <td id="L4073" data-line-number="4073"></td>
        <td id="LC4073">    }</td>
      </tr>
      <tr>
        <td id="L4074" data-line-number="4074"></td>
        <td id="LC4074">
</td>
      </tr>
      <tr>
        <td id="L4075" data-line-number="4075"></td>
        <td id="LC4075">    <span>DPTR</span>(RelativeFixupPointer&lt;PTR_Module&gt;) <span>GetModuleOverridePtr</span>()</td>
      </tr>
      <tr>
        <td id="L4076" data-line-number="4076"></td>
        <td id="LC4076">    {</td>
      </tr>
      <tr>
        <td id="L4077" data-line-number="4077"></td>
        <td id="LC4077">        LIMITED_METHOD_DAC_CONTRACT;</td>
      </tr>
      <tr>
        <td id="L4078" data-line-number="4078"></td>
        <td id="LC4078">        <span>return</span> dac_cast&lt;<span>DPTR</span>(RelativeFixupPointer&lt;PTR_Module&gt;)&gt;(<span>GetMultipurposeSlotPtr</span>(enum_flag_HasModuleOverride, c_ModuleOverrideOffsets));</td>
      </tr>
      <tr>
        <td id="L4079" data-line-number="4079"></td>
        <td id="LC4079">    }</td>
      </tr>
      <tr>
        <td id="L4080" data-line-number="4080"></td>
        <td id="LC4080">
</td>
      </tr>
      <tr>
        <td id="L4081" data-line-number="4081"></td>
        <td id="LC4081">    <span>void</span> <span>SetModule</span>(Module * pModule);</td>
      </tr>
      <tr>
        <td id="L4082" data-line-number="4082"></td>
        <td id="LC4082">
</td>
      </tr>
      <tr>
        <td id="L4083" data-line-number="4083"></td>
        <td id="LC4083">public:</td>
      </tr>
      <tr>
        <td id="L4084" data-line-number="4084"></td>
        <td id="LC4084">
</td>
      </tr>
      <tr>
        <td id="L4085" data-line-number="4085"></td>
        <td id="LC4085">    BOOL <span>Validate</span> ();</td>
      </tr>
      <tr>
        <td id="L4086" data-line-number="4086"></td>
        <td id="LC4086">
</td>
      </tr>
      <tr>
        <td id="L4087" data-line-number="4087"></td>
        <td id="LC4087">#<span>ifdef</span> FEATURE_READYTORUN_COMPILER</td>
      </tr>
      <tr>
        <td id="L4088" data-line-number="4088"></td>
        <td id="LC4088">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4089" data-line-number="4089"></td>
        <td id="LC4089">    <span><span>//</span> Is field layout in this type within the current version bubble?</span></td>
      </tr>
      <tr>
        <td id="L4090" data-line-number="4090"></td>
        <td id="LC4090">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4091" data-line-number="4091"></td>
        <td id="LC4091">    BOOL <span>IsLayoutInCurrentVersionBubble</span>();</td>
      </tr>
      <tr>
        <td id="L4092" data-line-number="4092"></td>
        <td id="LC4092">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4093" data-line-number="4093"></td>
        <td id="LC4093">    <span><span>//</span> Is field layout in this type fixed within the current version bubble?</span></td>
      </tr>
      <tr>
        <td id="L4094" data-line-number="4094"></td>
        <td id="LC4094">    <span><span>//</span> This check does not take the inheritance chain into account.</span></td>
      </tr>
      <tr>
        <td id="L4095" data-line-number="4095"></td>
        <td id="LC4095">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4096" data-line-number="4096"></td>
        <td id="LC4096">    BOOL <span>IsLayoutFixedInCurrentVersionBubble</span>();</td>
      </tr>
      <tr>
        <td id="L4097" data-line-number="4097"></td>
        <td id="LC4097">
</td>
      </tr>
      <tr>
        <td id="L4098" data-line-number="4098"></td>
        <td id="LC4098">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4099" data-line-number="4099"></td>
        <td id="LC4099">    <span><span>//</span> Is field layout of the inheritance chain fixed within the current version bubble?</span></td>
      </tr>
      <tr>
        <td id="L4100" data-line-number="4100"></td>
        <td id="LC4100">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4101" data-line-number="4101"></td>
        <td id="LC4101">    BOOL <span>IsInheritanceChainLayoutFixedInCurrentVersionBubble</span>();</td>
      </tr>
      <tr>
        <td id="L4102" data-line-number="4102"></td>
        <td id="LC4102">
</td>
      </tr>
      <tr>
        <td id="L4103" data-line-number="4103"></td>
        <td id="LC4103">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4104" data-line-number="4104"></td>
        <td id="LC4104">    <span><span>//</span> Is the inheritance chain fixed within the current version bubble?</span></td>
      </tr>
      <tr>
        <td id="L4105" data-line-number="4105"></td>
        <td id="LC4105">    <span><span>//</span></span></td>
      </tr>
      <tr>
        <td id="L4106" data-line-number="4106"></td>
        <td id="LC4106">    BOOL <span>IsInheritanceChainFixedInCurrentVersionBubble</span>();</td>
      </tr>
      <tr>
        <td id="L4107" data-line-number="4107"></td>
        <td id="LC4107">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4108" data-line-number="4108"></td>
        <td id="LC4108">
</td>
      </tr>
      <tr>
        <td id="L4109" data-line-number="4109"></td>
        <td id="LC4109">};  <span><span>//</span> class MethodTable</span></td>
      </tr>
      <tr>
        <td id="L4110" data-line-number="4110"></td>
        <td id="LC4110">
</td>
      </tr>
      <tr>
        <td id="L4111" data-line-number="4111"></td>
        <td id="LC4111">#<span>ifndef</span> CROSSBITNESS_COMPILE</td>
      </tr>
      <tr>
        <td id="L4112" data-line-number="4112"></td>
        <td id="LC4112"><span>static_assert_no_msg</span>(<span>sizeof</span>(MethodTable) == SIZEOF__MethodTable_);</td>
      </tr>
      <tr>
        <td id="L4113" data-line-number="4113"></td>
        <td id="LC4113">#<span>endif</span></td>
      </tr>
      <tr>
        <td id="L4114" data-line-number="4114"></td>
        <td id="LC4114">#<span>if</span> defined(FEATURE_TYPEEQUIVALENCE) &amp;&amp; !defined(DACCESS_COMPILE)</td>
      </tr>
      <tr>
        <td id="L4115" data-line-number="4115"></td>
        <td id="LC4115">WORD <span>GetEquivalentMethodSlot</span>(MethodTable * pOldMT, MethodTable * pNewMT, WORD wMTslot, BOOL *pfFound);</td>
      </tr>
      <tr>
        <td id="L4116" data-line-number="4116"></td>
        <td id="LC4116">#<span>endif</span> <span><span>//</span> defined(FEATURE_TYPEEQUIVALENCE) &amp;&amp; !defined(DACCESS_COMPILE)</span></td>
      </tr>
      <tr>
        <td id="L4117" data-line-number="4117"></td>
        <td id="LC4117">
</td>
      </tr>
      <tr>
        <td id="L4118" data-line-number="4118"></td>
        <td id="LC4118">MethodTable* <span>CreateMinimalMethodTable</span>(Module* pContainingModule,</td>
      </tr>
      <tr>
        <td id="L4119" data-line-number="4119"></td>
        <td id="LC4119">                                      LoaderHeap* pCreationHeap,</td>
      </tr>
      <tr>
        <td id="L4120" data-line-number="4120"></td>
        <td id="LC4120">                                      AllocMemTracker* pamTracker);</td>
      </tr>
      <tr>
        <td id="L4121" data-line-number="4121"></td>
        <td id="LC4121">
</td>
      </tr>
      <tr>
        <td id="L4122" data-line-number="4122"></td>
        <td id="LC4122">#<span>endif</span> <span><span>//</span> !_METHODTABLE_H_</span></td>
      </tr>
</tbody></table>

  

  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>