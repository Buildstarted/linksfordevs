<!DOCTYPE html>
<html lang="en">
<head>
    <title>
File uploads with Blazor -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>File uploads with Blazor</h1>
    <div class="body"> <p>For a long time we&#x2019;ve expected that we&#x2019;d add a built-in &#x201C;file input&#x201D; feature to Blazor. This would let users pick local files and supply them to your application. Possible uses cases include:</p> <ul> <li>You want to upload and store those files on a server</li> <li>Or, you want to read and import some data from them</li> <li>Or, you want to present an editor UI for the file</li>
</ul> <p>It applies equally to client-side or server-side Blazor. In client-side Blazor, you&#x2019;re loading the file into the .NET application&#x2019;s memory, which can then edit it locally or could make an HTTP request to transfer it to some backend server. In server-side Blazor, your code is already running on the server, but you still want to be able to read files picked by the user.</p> <h2 id="existing-options">Existing options</h2> <p>There are already several open-source or third-party libraries in this area (<a href="https://remibou.github.io/Upload-file-with-Blazor/">example from R&#xE9;mi Bourgarel</a>, <a href="https://www.syncfusion.com/blazor-components/blazor-file-upload">example from SyncFusion</a>). It&#x2019;s especially worth mentioning <a href="https://github.com/Tewr/BlazorFileReader">Tewr&#x2019;s BlazorFileReader library</a>, which does an excellent job and is quite similar to what I&#x2019;m proposing in this post.</p> <p>What I want out of a great file input component is:</p> <ul> <li><strong>Does not require setting up a separate server-side API endpoint</strong>. The file data needs to get into Blazor via the existing JS interop mechanism.</li> <li><strong>Provides access to the file data as a regular .NET <code class="highlighter-rouge">Stream</code></strong>, so other code can handle it just the same as if it were a normal file on disk. <ul> <li>This must literally stream the content into the .NET process, since we don&#x2019;t want to depend on loading it all into memory at once.</li> </ul> </li> <li><strong>Works independently of SignalR message size limits</strong> and <strong>file API buffer sizes</strong> <ul> <li>This is what several of the existing options don&#x2019;t manage. By default, SignalR imposes a limit of 32KB for incoming messages, and .NET APIs like <code class="highlighter-rouge">Stream.CopyToAsync</code> use much larger internal buffers, so the streaming logic needs to work with this and not require reconfiguration.</li> </ul> </li> <li>&#x2026; while achieving <strong>near-native-HTTP transfer speeds</strong> <ul> <li>This is the hardest bit, not addressed by existing solutions as far as I know. There are simple ways to satisfy all the requirements above if you&#x2019;re willing to accept greatly reduced upload rates. I&#x2019;ll talk about the challenges and solutions later in this post.</li> </ul> </li>
</ul> <h2 id="introducing-inputfile">Introducing &lt;InputFile&gt;</h2> <p>As a possible starting point for a future built-in feature, I&#x2019;ve published a <a href="https://www.nuget.org/packages/BlazorInputFile">NuGet package called <code class="highlighter-rouge">BlazorInputFile</code></a> (<a href="https://github.com/SteveSandersonMS/BlazorInputFile">source on GitHub</a>), which provides a component called <code class="highlighter-rouge">&lt;InputFile&gt;</code>.</p> <p>Its features include <strong>uploading a single file</strong> (<a href="https://github.com/SteveSandersonMS/BlazorInputFile/blob/master/samples/Sample.Core/Pages/SingleFile.razor">sample source</a>):</p> <p><img src="/wp-content/uploads/2019/09/13/single-file.gif" alt="Single file upload"></p> <p>Or, <strong>multi-file upload</strong> and <strong>progress notifications</strong> (<a href="https://github.com/SteveSandersonMS/BlazorInputFile/blob/master/samples/Sample.Core/Pages/MultiFile.razor">sample source</a>):</p> <p><img src="/wp-content/uploads/2019/09/13/multi-file.gif" alt="Multiple file upload"></p> <p>Or, <strong>custom UI</strong> including <strong>drag-drop support</strong> (<a href="https://github.com/SteveSandersonMS/BlazorInputFile/blob/master/samples/Sample.Core/Pages/DragDropViewer.razor">sample source</a>):</p> <p><img src="/wp-content/uploads/2019/09/13/dragdrop.gif" alt="Drag-drop viewer"></p> <h2 id="installation">Installation</h2> <p>First, be sure you&#x2019;re on the latest <a href="https://devblogs.microsoft.com/aspnet/asp-net-core-and-blazor-updates-in-net-core-3-0-preview-9/">3.0.0-preview9 version</a> of Blazor, or newer if you&#x2019;re reading this from the future. You can use either server-side or client-side (WebAssembly).</p> <p>Add a dependency on the <code class="highlighter-rouge">BlazorInputFile</code> package in your <code class="highlighter-rouge">.csproj</code>:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ItemGroup&gt;</span> <span class="nt">&lt;PackageReference</span> <span class="na">Include=</span><span class="s">&quot;BlazorInputFile&quot;</span> <span class="na">Version=</span><span class="s">&quot;0.1.0-preview&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/ItemGroup&gt;</span>
</code></pre></div></div> <p>Reference the package&#x2019;s JavaScript file by editing your <code class="highlighter-rouge">_Host.cshtml</code> to add the following. It can go in the <code class="highlighter-rouge">&lt;body&gt;</code> or in <code class="highlighter-rouge">&lt;head&gt;</code>, wherever you want:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;_content/BlazorInputFile/inputfile.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div> <p>Now in your <code class="highlighter-rouge">_Imports.razor</code>, add:</p> <p><em>Temporary caveat:</em> Until .NET Core 3.0 ships, there&#x2019;s <a href="https://github.com/SteveSandersonMS/BlazorInputFile/commit/309b2076869f8f97c3f8b6c6bc8e34318df16bf5">a bug you need to work around</a> if you&#x2019;re hosting on IIS Express. Thanks to Tewr for <a href="https://github.com/aspnet/AspNetCore/issues/13470">originally reporting this</a>.</p> <p>That&#x2019;s it - you&#x2019;re ready to go! Move on to <a href="#usage">usage instructions</a>.</p> <p>Due to <a href="https://github.com/aspnet/AspNetCore/issues/13103">a bug</a> that we&#x2019;ll fix before client-side Blazor is shipped, you can&#x2019;t just reference <code class="highlighter-rouge">inputfile.js</code> from <code class="highlighter-rouge">_content</code>. Instead you&#x2019;ll have to manually copy <a href="https://raw.githubusercontent.com/SteveSandersonMS/BlazorInputFile/master/BlazorInputFile/wwwroot/inputfile.js">the contents of <code class="highlighter-rouge">inputfile.js</code> from GitHub</a> into a file in your project. For example, put it directly into <code class="highlighter-rouge">wwwroot</code>, and then add the following reference into your <code class="highlighter-rouge">index.html</code>:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">&quot;inputfile.js&quot;</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div> <p>This manual file-copying step for client-side Blazor will be fixed and eliminated soon. Finally, in your <code class="highlighter-rouge">_Imports.razor</code>, add:</p> <h2 id="usage">Usage</h2> <p>In one of your components, you can now add an <code class="highlighter-rouge">&lt;InputFile&gt;</code> component. You&#x2019;ll also want to add an event handler for <code class="highlighter-rouge">OnChange</code> so you can respond when files are picked:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;InputFile</span> <span class="na">OnChange=</span><span class="s">&quot;HandleFileSelected&quot;</span> <span class="nt">/&gt;</span>

@code {
    void HandleFileSelected(IFileListEntry[] files)
    {
        // Do something with the files, e.g., read them
    }
}
</code></pre></div></div> <p>In this case, we&#x2019;re only allowing single-file selection, so the <code class="highlighter-rouge">files</code> array will have either zero or one entry. You can read metadata about the file even before you actually transfer the contents of the file anywhere:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;InputFile</span> <span class="na">OnChange=</span><span class="s">&quot;HandleFileSelected&quot;</span> <span class="nt">/&gt;</span> @if (file != null)
{ <span class="nt">&lt;p&gt;</span>Name: @file.Name<span class="nt">&lt;/p&gt;</span> <span class="nt">&lt;p&gt;</span>Size in bytes: @file.Size<span class="nt">&lt;/p&gt;</span> <span class="nt">&lt;p&gt;</span>Last modified date: @file.LastModified.ToShortDateString()<span class="nt">&lt;/p&gt;</span> <span class="nt">&lt;p&gt;</span>Content type (not always supplied by the browser): @file.Type<span class="nt">&lt;/p&gt;</span>
}

@code {
    IFileListEntry file;

    void HandleFileSelected(IFileListEntry[] files)
    {
        file = files.FirstOrDefault();
    }
}
</code></pre></div></div> <p>You can read data from the file either immediately on selection, or later (e.g., when the user clicks an &#x2018;upload&#x2019; button). To read the data, just access <code class="highlighter-rouge">file.Data</code> which is a <code class="highlighter-rouge">Stream</code>. For example, to count the number of lines in a text file:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;InputFile</span> <span class="na">OnChange=</span><span class="s">&quot;HandleFileSelected&quot;</span> <span class="nt">/&gt;</span> @if (file != null)
{ <span class="nt">&lt;p&gt;</span>Number of lines read: @numLines<span class="nt">&lt;/p&gt;</span> <span class="nt">&lt;button</span> <span class="err">@</span><span class="na">onclick=</span><span class="s">&quot;CountLines&quot;</span><span class="nt">&gt;</span>Count<span class="nt">&lt;/button&gt;</span>
}

@code {
    int numLines;
    IFileListEntry file;

    void HandleFileSelected(IFileListEntry[] files)
    {
        file = files.FirstOrDefault();
    }

    async Task CountLines()
    {
        numLines = 0;
        using (var reader = new System.IO.StreamReader(file.Data))
        {
            while (await reader.ReadLineAsync() != null)
            {
                numLines++;
            }
        }
    }
}
</code></pre></div></div> <p><strong>Important:</strong> You can <strong>only</strong> use asynchronous APIs on this stream (e.g., <code class="highlighter-rouge">ReadLineAsync</code>, not <code class="highlighter-rouge">ReadLine</code>), because the data has to be transferred over the network.</p> <p>If you want to support multiple file selection, just add a <code class="highlighter-rouge">multiple</code> attribute:</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;InputFile</span> <span class="na">multiple</span> <span class="na">OnChange=</span><span class="s">&quot;HandleFileSelected&quot;</span> <span class="nt">/&gt;</span>
</code></pre></div></div> <p>&#x2026; and now your event handler will receive a <code class="highlighter-rouge">IFileListEntry[]</code> that can contain multiple entries.</p> <h2 id="implementation-notes">Implementation notes</h2> <p>For client-side Blazor (i.e., on WebAssembly), the data transfer between the browser&#x2019;s JavaScript APIs and .NET is very simple and near-instant, since it&#x2019;s all running locally. <code class="highlighter-rouge">&lt;InputFile&gt;</code> uses Blazor&#x2019;s low-level unmarshalled interop APIs to copy the requested chunks of the binary data directly into .NET memory without needing any serialization.</p> <p>For server-side Blazor (i.e., via SignalR), there&#x2019;s a lot more going on. We have to fetch chunks via <code class="highlighter-rouge">IJSRuntime</code> which only allows JSON-serializable data, and imposes a limit on the size of each returned chunk. By default, SignalR&#x2019;s maximum message size is 32KB.</p> <h3 id="bandwidth-latency-and-security">Bandwidth, latency, and security</h3> <p>Other libraries approaching this problem have required users to configure a SignalR message size greater than whatever maximum buffer size is used by the I/O APIs you&#x2019;re using (e.g., the default for <code class="highlighter-rouge">CopyToAsync</code> is about 128KB). As well as being inconvenient for developers, this still leaves a serious performance issue. Since each chunk is being fetched sequentially, the maximum transfer rate becomes limited not only by network bandwidth, but also by network latency. If your round-trip ping time from client to server is <code class="highlighter-rouge">L</code> (e.g., <code class="highlighter-rouge">L = 0.2 sec</code>), and your SignalR message size is <code class="highlighter-rouge">S</code> (e.g., <code class="highlighter-rouge">S = 32KB</code> by default), then the tranfer rate cannot exceed <code class="highlighter-rouge">S/L</code> (in this example, <code class="highlighter-rouge">32/0.2 = 160 KB/sec</code>), even if you have a terrabit network connection.</p> <p>Additionally, even if your SignalR message size is arbitrarily large, the I/O APIs you&#x2019;re using might themselves use smaller buffers. I often see code that reads data from streams in 1 KB chunks. For <code class="highlighter-rouge">L=0.2</code>, that would result in a maximum transfer rate of just 5KB/sec! It&#x2019;s not enough just to <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.bufferedstream">wrap a <code class="highlighter-rouge">BufferedStream</code></a> around the source, since then you wouldn&#x2019;t get progress notifications as often.</p> <p>My goal here is to get much closer to using your full network bandwidth. The approach this library uses is parallelism: the .NET side sets up a data structure that can hold many chunks (default total size is around 1MB), and asks the JS side to populate segments within it via a lot of concurrent interop calls. The parallelism amortises the latency, so the bottleneck ends up being your actual network bandwidth, which is what we want. But to maximise UI responsiveness, the I/O operations don&#x2019;t wait for that whole ~1MB structure to be filled - they receive completion notifications as each smaller segment comes in from the JS side.</p> <p>Also, for security reasons, we don&#x2019;t want to trust the JS-side code to send us as much data as it wants. That would let misbehaving clients occupy as much .NET memory as they want. So, all the transfer operations are initiated from the .NET side, and we can be sure to make full use of the allowed memory but no more.</p> <p>The net result of all this is that developers don&#x2019;t have to reconfigure SignalR or specify custom buffer sizes when making file API calls. It all just works efficiently and safely by default.</p> <h3 id="perf-numbers">Perf numbers</h3> <p>For client-side Blazor (WebAssembly), the data transfer speed is limited only by your CPU. You can load a 10 MB file into .NET memory almost instantly. On my machine, loading a 100 MB file into a .NET <code class="highlighter-rouge">byte</code> array takes about a second.</p> <p>To test with server-side Blazor, I deployed an application to a server about 4000 miles from me (so there&#x2019;s plenty of latency), and tried uploading a 20MB file.</p> <ul> <li>With a plain native HTTP upload on a fast office connection, the upload time was around 9 to 10 seconds. On the same network, transferring via <code class="highlighter-rouge">&lt;InputFile&gt;</code> took around 12 to 14 seconds.</li> <li>For the same 20MB file but over a slower cafe wifi connection, the native HTTP upload times were between 21 and 26 seconds. On the same network, transferring via <code class="highlighter-rouge">&lt;InputFile&gt;</code> took between 23 and 27 seconds.</li>
</ul> <p>It&#x2019;s entirely expected that <code class="highlighter-rouge">&lt;InputFile&gt;</code> takes ~30% longer than native HTTP uploads, because it has to base64 encode the data since <code class="highlighter-rouge">IJSRuntime</code> only allows JSON responses. For smaller files, e.g., under 5MB, it&#x2019;s unlikely that users will perceive any difference, and the vast level of extra convenience offered by <code class="highlighter-rouge">&lt;InputFile&gt;</code> (e.g., no need to set up a separate API endpoint) makes this well worthwhile. We&#x2019;ll also be able to eliminate the base64 penalty in the future by adding support for binary responses to JS interop calls, or expose SignalR&#x2019;s built-in streaming mechanisms, at which point there should be no meaningful speed difference versus native HTTP uploads.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>