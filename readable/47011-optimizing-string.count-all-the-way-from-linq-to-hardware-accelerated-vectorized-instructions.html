<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Optimizing string.Count all the way from LINQ to hardware accelerated vectorized instructions -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Optimizing string.Count all the way from LINQ to hardware accelerated vectorized instructions</h1><div><div class="ac ae af ag ah cz aj ak"><p id="7106" class="gy gz dc bk ha b hb je hd jf hf jg hh jh hj ji hl hm cu"><span class="r hn ho hp hq hr hs ht hu hv gf">V</span>ectorized instructions, often called <a href="https://en.wikipedia.org/wiki/SIMD" class="at cg jj jk jl jm" target="_blank" rel="noopener nofollow"><strong class="ha hw">SIMD instructions</strong></a> (single instruction multiple data) are instructions that leverage special registers in modern CPUs to speedup certain types of operations. These registers can hold a series of values next to each other, so that a single operation can be executed on all of them at the same time.</p><p id="5040" class="gy gz dc bk ha b hb hc hd he hf hg hh hi hj hk hl cu">One important thing to note is that the size of a SIMD register depends on the specific processor, and that it also influences the number of values it can hold at any time. To be precise, there are different SIMD instructions that work on different SIMD registers, each of a specific size, but the C# APIs we will use provide a nice abstraction over this and expose these registers to us as a vector type that can vary in size depending on the specific device we are executing our code on. For instance, it we have 128 bits registers at our disposal, we will be able to store either 2 <strong class="ha hw">double</strong> values (64 bits each), or 4 <strong class="ha hw">int</strong> or <strong class="ha hw">float</strong> values (32 bits each), 8 <strong class="ha hw">ushort</strong> or <strong class="ha hw">short</strong> values (16 bits each) or 16 <strong class="ha hw">byte</strong> or <strong class="ha hw">sbyte</strong> values (8 bits each). SIMD registers might also not be available at all, so we should always manually check whether thatâ€™s the case before executing our vectorized code.</p><p id="0f16" class="gy gz dc bk ha b hb hc hd he hf hg hh hi hj hk hl cu">Suppose we had two <strong class="ha hw">int[]</strong> arrays and we wanted to write to another <strong class="ha hw">int[]</strong> array of the same size the sum of each pair of values. Instead of going through each element one by one, we could load a chunk of consecutive values from each array into two separate SIMD registers, sum those registers together in a single instruction, and then copy that resulting register to the right location into the <strong class="ha hw">int[]</strong> array to return from the method. The type we need is <a href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.vector-1?view=netcore-3.1" class="at cg jj jk jl jm" target="_blank" rel="noopener nofollow"><strong class="ha hw">Vector&lt;T&gt;</strong></a>, which represents a SIMD register with elements of a given type. Here is a sample with both the traditional implementation of this algorithm using a <strong class="ha hw">for</strong> loop, and one using the <strong class="ha hw">Vector</strong> and <strong class="ha hw">Vector&lt;T&gt;</strong> APIs:</p><figure class="fw fx fy fz ga fm"><p id="feef" class="gy gz dc bk ha b hb hc hd he hf hg hh hi hj hk hl cu">With this proof of concept, we can now move on to an implementation of our original <strong class="ha hw">Count</strong> method that leverages the power of SIMD instructions.</p></figure></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>