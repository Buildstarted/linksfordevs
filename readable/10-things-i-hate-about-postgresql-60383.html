<!DOCTYPE html>
<html lang="en">
<head>
    <title>
10 Things I Hate About PostgreSQL - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="10 Things I Hate About PostgreSQL - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@rbranson"/>
    <meta property="og:description" content="Over the last few years, the software development community&#x2019;s love affair with the popular open-source relational database  has reached a&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@rbranson/10-things-i-hate-about-postgresql-20dbab8c2791"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title">devring.club</span>
				<a href="https://devring.club/site/1/previous" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - 10 Things I Hate About PostgreSQL</title>
<div class="readable">
        <h1>10 Things I Hate About PostgreSQL</h1>
            <div>by https://medium.com/@rbranson</div>
            <div>Reading time: 12-15 minutes</div>
        <div>Posted here: 04 Apr 2020</div>
        <p><a href="https://medium.com/@rbranson/10-things-i-hate-about-postgresql-20dbab8c2791">https://medium.com/@rbranson/10-things-i-hate-about-postgresql-20dbab8c2791</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@rbranson?source=post_page-----20dbab8c2791----------------------"><img alt="Rick Branson" src="https://miro.medium.com/fit/c/96/96/0*yO7RvOMwLS9hpOmK.jpg" width="48" height="48"></a></p></div></div></div></div><p id="b459" data-selectable-paragraph="">Over the last few years, the software development community’s love affair with the popular open-source relational database has reached a bit of a fever pitch. This <a href="https://news.ycombinator.com/item?id=22766681" target="_blank" rel="noopener nofollow">Hacker News thread</a> covering a piece titled <a href="https://www.2ndquadrant.com/en/blog/postgresql-is-the-worlds-best-database/" target="_blank" rel="noopener nofollow">“PostgreSQL is the worlds’ best database”</a>, busting at the seams with fawning sycophants lavishing unconditional praise, is a perfect example of this phenomenon.</p><p id="f90f" data-selectable-paragraph="">While much of this praise is certainly well-deserved, the lack of <em>meaningful </em>dissent left me a bit bothered. <strong>No software is perfect, so <em>exactly</em> what are PostgreSQL’s imperfections?</strong></p><p id="5965" data-selectable-paragraph="">I’ve been hands-on with PostgreSQL in production since 2003 with deployments ranging from small (gigabytes) to modest to very large (~petabyte). My perspective is largely from building and running systems that are at least <em>intended</em> to be continuously available. Needless to say, I have gained first-hand experience with PostgreSQL’s particular idiosyncrasies through some painful production issues over the years.</p><p id="5e10" data-selectable-paragraph=""><a href="https://blog.sentry.io/2015/07/23/transaction-id-wraparound-in-postgres" target="_blank" rel="noopener nofollow">Read more here.</a> Suffice to say, this one can bite <em>hard</em>. <strong>There are many stories of multi-day outages caused by this issue.</strong> Go ahead, Google it and you’ll find numerous poor souls writing about the time they stepped on this landmine. Pretty much any non-trivial PostgreSQL install that isn’t staffed with a top expert will run into it eventually.</p><p id="b3d7" data-selectable-paragraph="">It’s likely that, at some point in the future, XIDs will transition to use 64-bit integers, but until then, we’re stuck with it. I guess at least we can be thankful that there is a process which prevents it from happening as a matter of course, <em>unlike some </em><a href="https://arstechnica.com/information-technology/2015/05/boeing-787-dreamliners-contain-a-potentially-catastrophic-software-bug/" target="_blank" rel="noopener nofollow"><em>airplane software</em></a><em>.</em></p><p id="70fa" data-selectable-paragraph="">The run-of-the-mill streaming replication setup will almost certainly lose committed data if the active master suddenly fails. <em>“Such is the price of </em><a href="https://cloudbasic.net/white-papers/synchronous-vs-asynchronous-replication/" target="_blank" rel="noopener nofollow"><em>asynchronous replication</em></a><em>,”</em> some might say, but it doesn’t have to be this way. PostgreSQL supports synchronous replication with quorum commit for fault-tolerant durability, but it has a <a href="https://www.postgresql.org/docs/current/warm-standby.html#SYNCHRONOUS-REPLICATION-PERFORMANCE" target="_blank" rel="noopener nofollow"><em>much</em> tighter performance envelope</a> that complicates its application.</p><blockquote><p id="05df" data-selectable-paragraph="">Waiting doesn’t utilize system resources, but transaction locks continue to be held until the transfer is confirmed.<strong> As a result, incautious use of synchronous replication will reduce performance</strong> for database applications because of increased response times and higher contention.</p></blockquote><p id="17e6" data-selectable-paragraph="">This <em>bolt-on</em> quorum replication is useful in a pinch, but I hesitate to recommend it for general-purpose use cases. It is similar to <a href="https://www.cloudkarafka.com/blog/2019-09-28-what-does-in-sync-in-apache-kafka-really-mean.html" target="_blank" rel="noopener nofollow">Kafka’s ISR replication with acks=all and a quorum min_isr</a>, but with all the nuanced complexity of a transactional relational database running arbitrary queries. I’m not currently aware of a successful application of quorum commit for highly-available, high-durability replication at non-trivial scale. If you have, reach out!</p><p id="e036" data-selectable-paragraph="">In terms of relational databases, <a href="https://galeracluster.com/" target="_blank" rel="noopener nofollow">Galera Cluster</a>’s group replication is also imperfect, but <em>closer</em> to the ideal. They even <a href="https://galeracluster.com/2015/07/geo-distributed-database-clusters-with-galera/" target="_blank" rel="noopener nofollow">encourage geo-distributed replication</a>, which would very likely be disastrous for a PostgreSQL replication setup using quorum commit.</p><p id="b1fc" data-selectable-paragraph=""><a href="https://wiki.postgresql.org/wiki/Streaming_Replication" target="_blank" rel="noopener nofollow">Streaming Replication</a> is by far the most utilized replication mechanism in production deployments. It is a form of physical replication, meaning that it replicates changes in the on-disk binary data itself.</p><p id="b3d2" data-selectable-paragraph="">Every time an on-disk database page (4KB) needs to be modified by a write operation, even just a single byte, a copy of the entire page, edited with the requested changes, is written to the <a href="https://www.postgresql.org/docs/current/wal-intro.html" target="_blank" rel="noopener nofollow">write-ahead log (WAL)</a>. Physical streaming replication leverages this existing WAL infrastructure as a log of changes it streams to replicas.</p><p id="c12e" data-selectable-paragraph="">With physical replication, a large index build, for instance, creates a huge flood of WAL entries which can easily bottleneck the replication stream. The read-modify-replicate process at page-granularity can lead to <strong>hardware-induced data corruption on the master <em>much</em> more easily propagating</strong> to replicas, which I’ve personally witnessed several times in production.</p><p id="7874" data-selectable-paragraph="">This is in contrast to logical replication, which only replicates <em>logical</em> data changes. At least theoretically, a large index build would only result in a single command replicated across the network. While PostgreSQL has supported <a href="https://www.postgresql.org/docs/12/logical-replication.html" target="_blank" rel="noopener nofollow">logical replication</a> for quite some time, most deployments use physical streaming replication because it is more robust, more broadly supported, and much easier to use.</p><p id="2292" data-selectable-paragraph="">Like most mainstream databases, PostgreSQL uses multi-version concurrency control (MVCC) to implement concurrent transactions. However, its particular implementation often introduces operational pain around garbage row versions and their cleanup (<a href="https://www.postgresql.org/docs/12/sql-vacuum.html" target="_blank" rel="noopener nofollow">VACUUM</a>). Generally speaking, <code>UPDATE</code> operations create new copies (or “row versions”) of any modified rows, <strong>leaving the old versions on disk until they can be cleaned up.</strong></p><p id="8cba" data-selectable-paragraph="">While this situation has steadily improved over the years, it’s a complex system that is a bit of a black box for anyone approaching the problem for the first time. For instance, knowing about <a href="https://github.com/postgres/postgres/blob/master/src/backend/access/heap/README.HOT" target="_blank" rel="noopener nofollow">Heap-Only Tuples (HOT)</a> and when it kicks in can be make-or-break for heavy update-in-place workloads like maintaining a consistent counter column in a row. The default autovacuum setup <em>does</em> work <em>most </em>of the time, but when it doesn’t, <em>good lord</em>.</p><p id="e0ac" data-selectable-paragraph="">In contrast, MySQL and Oracle use redo and undo logs. They don’t need a similar background garbage collection process. The trade-off they make is mostly additional latency for transactional commit and rollback operations.</p><p id="fd5b" data-selectable-paragraph="">It could be that at some point in the distant future, <a href="http://rhaas.blogspot.com/2018/01/do-or-undo-there-is-no-vacuum.html" target="_blank" rel="noopener nofollow">zheap saves us all</a>.</p><p id="b614" data-selectable-paragraph=""><strong>PostgreSQL forks a process for every connection</strong>, where as most other databases use a more efficient connection concurrency model. This makes for a difficult tuning problem as there is a relatively low threshold at which adding more connections degrades performance (around ~2x cores) and eventually another higher threshold (hard to estimate, highly workload dependent) where performance will<em> plummet.</em></p><p id="6a94" data-selectable-paragraph="">The standard recipe of using a connection pooler certainly kicks the can down the road, but introduces significant additional architectural complexity. On a particularly large deployment, I eventually had to layer in a <em>second</em> <a href="https://www.pgbouncer.org/" target="_blank" rel="noopener nofollow">pgbouncer</a> tier. One tier ran on the application servers and another tier on the database servers. Altogether it aggregated connections for around 1 million client processes. Tuning it was 40% dark art, 40% brute force, and 10% <em>pure luck.</em></p><p id="2719" data-selectable-paragraph="">Process scalability has been getting incrementally better every major release, but ultimately there is a somewhat hard limit to the performance of this architecture compared to something like thread-per-connection, which is used in MySQL.</p><p id="fe1f" data-selectable-paragraph=""><em>For more technical depth, see </em><a href="https://brandur.org/postgres-connections" target="_blank" rel="noopener nofollow"><em>https://brandur.org/postgres-connections</em></a><em>.</em></p><p id="4a27" data-selectable-paragraph="">Tables in PostgreSQL have an index for the primary key and <a href="http://rachbelaid.com/introduction-to-postgres-physical-storage/" target="_blank" rel="noopener nofollow">separate row storage called the heap</a>. Other databases <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html" target="_blank" rel="noopener nofollow">integrate these together</a> or support <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/cncpt/indexes-and-index-organized-tables.html#GUID-DAEC075B-C16D-4A57-898C-70EBCB364F0C" target="_blank" rel="noopener nofollow">“index-organized tables”</a>. In this arrangement, the primary key lookup process leads directly to the row data without a secondary fetch to get the full row and the requisite additional CPU and I/O utilization.</p><p id="3922" data-selectable-paragraph="">The <a href="https://www.postgresql.org/docs/12/sql-cluster.html" target="_blank" rel="noopener nofollow">CLUSTER</a> command in PostgreSQL reorganizes a table according to an index to improve performance, but doesn’t really work for most real-world OLTP cases. It rewrites the entire table under an exclusive lock, blocking any reads or writes. PostgreSQL doesn’t maintain the clustered layout for new data, so this operation must be ran periodically. So it is <em>really</em> <strong>only useful if you can take your database offline for long periods of time on a regular basis.</strong></p><p id="859a" data-selectable-paragraph="">But more critically, <strong>index-organized tables save space</strong> as the index doesn’t require a separate copy of the row data. For tables with small rows that are mostly covered by the primary key, such as join tables, this can easily cut the table’s storage footprint<em> in half.</em></p><p id="cda3" data-selectable-paragraph="">Consider the following table which stores social “likes” for arbitrary objects:</p><pre><span id="fae0" data-selectable-paragraph="">CREATE TABLE likes (<br> object_type INTEGER NOT NULL,<br> object_id BIGINT NOT NULL GENERATED ALWAYS AS IDENTITY,<br> user_id BIGINT NOT NULL,<br> created_at TIMESTAMP WITH TIME ZONE NOT NULL,<br> PRIMARY KEY(object_type, object_id, user_id)<br>);</span></pre><p id="47f9" data-selectable-paragraph="">PostgreSQL will maintain an index for the primary key which is separate from the base table storage. This index will contain a full copy of the <code>object_type</code>, <code>object_id</code>, and <code>user_id</code> columns for every row. <strong>20 out of 28 bytes in each row (~70%) will be duplicated</strong>. If PostgreSQL supported index-organized tables, it wouldn’t consume all that additional space.</p><p id="7f6a" data-selectable-paragraph="">Some <a href="https://www.postgresql.org/docs/12/pgupgrade.html" target="_blank" rel="noopener nofollow">major version upgrades</a> require <strong>hours of downtime to convert the data for a large database.</strong> Using the typical streaming replication mechanism, it is not possible to do this gracefully by upgrading a replica and doing a failover. The on-disk binary format is <em>incompatible</em> across major versions, thus the wire protocol between master and replica is effectively also incompatible.</p><p id="d8dc" data-selectable-paragraph="">Hopefully logical replication will eventually completely replace streaming replication, which would enable an <a href="https://www.cybertec-postgresql.com/en/upgrading-postgres-major-versions-using-logical-replication/" target="_blank" rel="noopener nofollow">online, rolling upgrade strategy</a>. When I worked on a large-scale horizontally-scaled deployment, we made a significant engineering investment in custom infrastructure to do these upgrades without downtime using an additional <a href="https://bucardo.org/Bucardo/" target="_blank" rel="noopener nofollow">trigger-based replication</a> system that was also used for shard migration.</p><p id="0580" data-selectable-paragraph="">To be fair, MySQL’s out-of-the-box replication is <em>much</em> more cumbersome, but compared to some NoSQL stores like MongoDB and Redis or some cluster-oriented replication systems like <a href="https://dev.mysql.com/doc/refman/8.0/en/group-replication.html" target="_blank" rel="noopener nofollow">MySQL Group Replication</a> and <a href="https://galeracluster.com/" target="_blank" rel="noopener nofollow">Galera Cluster</a>, from an ease-of-use and sharp-edge-avoidance perspective, <a href="https://wiki.postgresql.org/wiki/Streaming_Replication#How_to_Use" target="_blank" rel="noopener nofollow">setting up replication in PostgreSQL</a> leaves<em> a lot </em>to be desired. While logical replication <em>theoretically</em> provides far more flexibility for third-party solutions to paper over these gaps, so far it’s there are <a href="https://www.postgresql.org/docs/12/logical-replication-restrictions.html" target="_blank" rel="noopener nofollow">some pretty big caveats</a> for using it in place of streaming replication.</p><p id="a08c" data-selectable-paragraph=""><a href="https://mariadb.com/kb/en/index-hints-how-to-force-query-plans/" target="_blank" rel="noopener nofollow">Planner hints</a> allow queries to direct the query planner to use strategies it wouldn’t otherwise use on its own. In what seems to be a form of the <a href="https://wiki.c2.com/?SufficientlySmartCompiler" target="_blank" rel="noopener nofollow">sufficiently smart compiler</a> argument, the PostgreSQL development team has held the line for years in refusing to support query planner hints.</p><p id="b6dd" data-selectable-paragraph="">I <em>do</em> understand their reasoning, which largely is about preventing users from attacking problems using query hints that should be fixed by writing proper queries. However, <strong>this philosophy seems brutally paternalistic when you’re watching a production database spiral into a full meltdown</strong> under a sudden and unexpected query plan shift.</p><p id="6312" data-selectable-paragraph="">In many of these situations, a hint to the planner can mitigate the issue in minutes, buying the engineering team the hours or days they need to make a proper fix to the query. While there <em>are</em> some indirect workarounds that involve disabling certain query planner strategies, they are risky and definitely shouldn’t be employed under any kind of time pressure.</p><p id="2169" data-selectable-paragraph=""><em>That ivory tower sure </em><a href="https://www.instagram.com/sarp/" target="_blank" rel="noopener nofollow"><em>must be nice.</em></a></p><p id="9954" data-selectable-paragraph="">InnoDB’s Page Compression in <strong>MySQL commonly </strong><a href="https://www.percona.com/blog/2019/02/11/compression-options-in-mysql-part-2/" target="_blank" rel="noopener nofollow"><strong>cuts storage footprint in half</strong></a><strong> and is pretty much <em>“free”</em> from a performance perspective.</strong> PostgreSQL will automatically <a href="https://wiki.postgresql.org/wiki/TOAST" target="_blank" rel="noopener nofollow">compress large values</a> but this isn’t useful for the most common ways data is stored in relational databases. For most RDBMS use cases, a row is typically a few hundred bytes or less, which means compression could only really be effective when applied across multiple rows, or in <em>blocks</em>.</p><p id="3594" data-selectable-paragraph="">Block compression is indeed quite difficult to implement for the kind of data structures at the heart of PostgreSQL, but the <a href="https://lwn.net/Articles/415889/" target="_blank" rel="noopener nofollow">“hole punch” strategy</a> employed by MySQL’s InnoDB storage engine seems to work quite well in practice, <a href="https://www.percona.com/blog/2017/11/20/innodb-page-compression/" target="_blank" rel="noopener nofollow">despite some drawbacks</a>.</p><p id="f3e6" data-selectable-paragraph="">The only general-purpose block compression setup widely used in the PostgreSQL world <a href="https://www.2ndquadrant.com/en/blog/pg-phriday-postgres-zfs/" target="_blank" rel="noopener nofollow">leverages ZFS</a>, which does seem to work quite well for people. ZFS <em>is</em> a production-grade reality in Linux these days, but definitely brings with it some administrative overhead that doesn’t exist for the more “out-of-the-box” filesystems like XFS or ext4.</p><p id="5e5a" data-selectable-paragraph="">You should probably still use PostgreSQL and not something else for storing data that you’d <em>ideally</em> like to, you know, keep around for some time. <strong>In general I’d recommend starting with PostgreSQL and then trying to figure out why it <em>won’t</em> work for your use case.</strong></p><p id="cd99" data-selectable-paragraph="">PostgreSQL is very mature, well-engineered, richly-featured, is generally free of sharp edges, and is quite performant for the vast majority of use cases. It also is unencumbered by a <a href="https://www.oracle.com/index.html" target="_blank" rel="noopener nofollow">dominant corporate sponsor</a>, includes fantastic documentation, and has a professional, inclusive community.</p><p id="4070" data-selectable-paragraph="">The good news is that the pain caused by many of the issues brought up in this post can be reduced or eliminated by using a managed database service like <a href="https://www.heroku.com/postgres" target="_blank" rel="noopener nofollow">Heroku PostgreSQL</a>, <a href="https://www.compose.com/databases/postgresql" target="_blank" rel="noopener nofollow">Compose PostgreSQL</a>, <a href="https://aws.amazon.com/rds/postgresql/" target="_blank" rel="noopener nofollow">Amazon RDS for PostgreSQL</a>, or <a href="https://cloud.google.com/sql" target="_blank" rel="noopener nofollow">Google Cloud SQL for PostgreSQL</a>. If you can use one of these services, for the love of all that is holy, <em>please do!</em></p><p id="19d8" data-selectable-paragraph="">I’m proud to say I’ve built software on top of PostgreSQL for almost two decades and remain a strong advocate, <em>despite its flaws.</em> Given the progress I’ve witnessed over the years by its incredible development team, <strong>I can say that most, if not all of these issues will be resolved in due time.</strong></p></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>