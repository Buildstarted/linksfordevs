<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Do YOU know how much your computer can do in a second? - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Do YOU know how much your computer can do in a second? - linksfor.dev(s)"/>
    <meta property="og:description" content="Welcome to the first program! This one is just to get you on&#xA;         your feet: how many loops can you go through in a second? (it might&#xA;         be more than you think!)"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://computers-are-fast.github.io/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Do YOU know how much your computer can do in a second?</title>
<div class="readable">
        <h1>Do YOU know how much your computer can do in a second?</h1>
            <div>Reading time: 10-13 minutes</div>
        <div>Posted here: 12 Jul 2020</div>
        <p><a href="http://computers-are-fast.github.io/">http://computers-are-fast.github.io/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="quiz"><div data-reactid=".0"><section data-reactid=".0.1:$0"><div data-reactid=".0.1:$0.0"><p>Welcome to the first program! This one is just to get you on
         your feet: how many loops can you go through in a second? (it might
         be more than you think!)</p></div><div data-reactid=".0.1:$0.1"><div data-reactid=".0.1:$0.1.$sum=1c"><p data-reactid=".0.1:$0.1.$sum=1c.0"><h3 data-reactid=".0.1:$0.1.$sum=1c.0.0"><span data-reactid=".0.1:$0.1.$sum=1c.0.0.0">sum.c</span><span data-reactid=".0.1:$0.1.$sum=1c.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$0.1.$sum=1c.1"></ul><p><span data-reactid=".0.1:$0.1.$sum=1c.3">Guess: </span><span data-reactid=".0.1:$0.1.$sum=1c.4">iterations</span><span data-reactid=".0.1:$0.1.$sum=1c.5"> in one second</span></p><pre data-reactid=".0.1:$0.1.$sum=1c.6">#include &lt;stdlib.h&gt;

// Number to guess: How many iterations of
// this loop can we go through in a second?

int main(int argc, char **argv) {
    int NUMBER, i, s;
    NUMBER = atoi(argv[1]);

    for (s = i = 0; i &lt; NUMBER; ++i) {
        s += 1;
    }

    return 0;
}
</pre></div><div data-reactid=".0.1:$0.1.$loop=1py"><p data-reactid=".0.1:$0.1.$loop=1py.0"><h3 data-reactid=".0.1:$0.1.$loop=1py.0.0"><span data-reactid=".0.1:$0.1.$loop=1py.0.0.0">loop.py</span><span data-reactid=".0.1:$0.1.$loop=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$0.1.$loop=1py.1"></ul><p><span data-reactid=".0.1:$0.1.$loop=1py.3">Guess: </span><span data-reactid=".0.1:$0.1.$loop=1py.4">iterations</span><span data-reactid=".0.1:$0.1.$loop=1py.5"> in one second</span></p><pre data-reactid=".0.1:$0.1.$loop=1py.6">#!/usr/bin/env python

# Number to guess: How many iterations of an
# empty loop can we go through in a second?

def f(NUMBER):
    for _ in xrange(NUMBER):
        pass

import sys
f(int(sys.argv[1]))
</pre></div></div><span data-reactid=".0.1:$0.2"></span></section><section data-reactid=".0.1:$1"><div data-reactid=".0.1:$1.0"><div data-reactid=".0.1:$1.0.0"><p>Now that we know about the most we can expect from Python
         (100 million things/s), let's explore a slightly more realistic use
         case. Dictionaries are used just about everywhere in Python, so how
         many elements can we add to a dictionary in Python in a second?</p>

        <p>
        Once you've gotten that one, let's look at a more complicated operation
        -- using Python's built-in HTTP request parser to parse a request.
        </p>
         </div></div><div data-reactid=".0.1:$1.1"><div data-reactid=".0.1:$1.1.$dict=1py"><p data-reactid=".0.1:$1.1.$dict=1py.0"><h3 data-reactid=".0.1:$1.1.$dict=1py.0.0"><span data-reactid=".0.1:$1.1.$dict=1py.0.0.0">dict.py</span><span data-reactid=".0.1:$1.1.$dict=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$1.1.$dict=1py.1"></ul><p><span data-reactid=".0.1:$1.1.$dict=1py.3">Guess: </span><span data-reactid=".0.1:$1.1.$dict=1py.4">iterations</span><span data-reactid=".0.1:$1.1.$dict=1py.5"> in one second</span></p><pre data-reactid=".0.1:$1.1.$dict=1py.6">#!/usr/bin/env python

# Number to guess: How many entries can
# we add to a dictionary in a second?

# Note: we take `i % 1000` to control
# the size of the dictionary

def f(NUMBER):
    d = {}
    for i in xrange(NUMBER):
        d[i % 1000] = i

import sys
f(int(sys.argv[1]))
</pre></div><div data-reactid=".0.1:$1.1.$parse_http_request=1py"><p data-reactid=".0.1:$1.1.$parse_http_request=1py.0"><h3 data-reactid=".0.1:$1.1.$parse_http_request=1py.0.0"><span data-reactid=".0.1:$1.1.$parse_http_request=1py.0.0.0">parse_http_request.py</span><span data-reactid=".0.1:$1.1.$parse_http_request=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$1.1.$parse_http_request=1py.1"></ul><p><span data-reactid=".0.1:$1.1.$parse_http_request=1py.3">Guess: </span><span data-reactid=".0.1:$1.1.$parse_http_request=1py.4">HTTP requests parsed</span><span data-reactid=".0.1:$1.1.$parse_http_request=1py.5"> in one second</span></p><pre data-reactid=".0.1:$1.1.$parse_http_request=1py.6">#!/usr/bin/env python

# Number to guess: How many HTTP requests
# can we parse in a second?

from BaseHTTPServer import BaseHTTPRequestHandler
from StringIO import StringIO

class HTTPRequest(BaseHTTPRequestHandler):
    def __init__(self, request_text):
        self.rfile = StringIO(request_text)
        self.raw_requestline = self.rfile.readline()
        self.error_code = self.error_message = None
        self.parse_request()

    def send_error(self, code, message):
        self.error_code = code
        self.error_message = message

request_text = """GET / HTTP/1.1
Host: localhost:8001
Connection: keep-alive
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.85 Safari/537.36
Accept-Encoding: gzip, deflate, sdch
Accept-Language: en-GB,en-US;q=0.8,en;q=0.6
"""

def f(NUMBER):
    for _ in range(NUMBER):
        HTTPRequest(request_text)

import sys
f(int(sys.argv[1]))
</pre></div></div><span data-reactid=".0.1:$1.2"></span></section><section data-reactid=".0.1:$2"><div data-reactid=".0.1:$2.0"><p>Next up, we have downloading a webpage vs running a Python script! 
            Hint: these are both less than 100 million :)</p></div><div data-reactid=".0.1:$2.1"><div data-reactid=".0.1:$2.1.$download_webpage=1py"><p data-reactid=".0.1:$2.1.$download_webpage=1py.0"><h3 data-reactid=".0.1:$2.1.$download_webpage=1py.0.0"><span data-reactid=".0.1:$2.1.$download_webpage=1py.0.0.0">download_webpage.py</span><span data-reactid=".0.1:$2.1.$download_webpage=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$2.1.$download_webpage=1py.1"></ul><p><span data-reactid=".0.1:$2.1.$download_webpage=1py.3">Guess: </span><span data-reactid=".0.1:$2.1.$download_webpage=1py.4">HTTP requests completed</span><span data-reactid=".0.1:$2.1.$download_webpage=1py.5"> in one second</span></p><pre data-reactid=".0.1:$2.1.$download_webpage=1py.6">#!/usr/bin/env python

# Number to guess: How many times can we
# download google.com in a second?

from urllib2 import urlopen


def f(NUMBER):
    for _ in xrange(NUMBER):
        r = urlopen("http://google.com")
        r.read()

import sys
f(int(sys.argv[1]))
</pre></div><div data-reactid=".0.1:$2.1.$run_python=1sh"><p data-reactid=".0.1:$2.1.$run_python=1sh.0"><h3 data-reactid=".0.1:$2.1.$run_python=1sh.0.0"><span data-reactid=".0.1:$2.1.$run_python=1sh.0.0.0">run_python.sh</span><span data-reactid=".0.1:$2.1.$run_python=1sh.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$2.1.$run_python=1sh.1"></ul><p><span data-reactid=".0.1:$2.1.$run_python=1sh.3">Guess: </span><span data-reactid=".0.1:$2.1.$run_python=1sh.4">iterations</span><span data-reactid=".0.1:$2.1.$run_python=1sh.5"> in one second</span></p><pre data-reactid=".0.1:$2.1.$run_python=1sh.6">#!/bin/bash

# Number to guess: How many times can we start
# the Python interpreter in a second?

NUMBER=$1

for i in $(seq $NUMBER); do
    python -c '';
done
</pre></div></div><span data-reactid=".0.1:$2.2"></span></section><section data-reactid=".0.1:$3"><div data-reactid=".0.1:$3.0"><p>
            How many bytes can you write to disk in a second? We all know writing
            to memory is faster, but how *much* faster? This code was run on a
            computer with an SSD
            </p></div><div data-reactid=".0.1:$3.1"><div data-reactid=".0.1:$3.1.$write_to_disk=1py"><p data-reactid=".0.1:$3.1.$write_to_disk=1py.0"><h3 data-reactid=".0.1:$3.1.$write_to_disk=1py.0.0"><span data-reactid=".0.1:$3.1.$write_to_disk=1py.0.0.0">write_to_disk.py</span><span data-reactid=".0.1:$3.1.$write_to_disk=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$3.1.$write_to_disk=1py.1"></ul><p><span data-reactid=".0.1:$3.1.$write_to_disk=1py.3">Guess: </span><span data-reactid=".0.1:$3.1.$write_to_disk=1py.4">bytes written</span><span data-reactid=".0.1:$3.1.$write_to_disk=1py.5"> in one second</span></p><pre data-reactid=".0.1:$3.1.$write_to_disk=1py.6">#!/usr/bin/env python

# Number to guess: How many bytes can we write
# to an output file in a second?
# Note: we make sure everything is sync'd to disk
# before exiting :)
import tempfile
import os

CHUNK_SIZE = 1000000
s = "a" * CHUNK_SIZE

def cleanup(f, name):
    f.flush()
    os.fsync(f.fileno())
    f.close()
    try:
        os.remove(name)
    except:
        pass

def f(NUMBER):
    name = './out'
    f = open(name, 'w')
    bytes_written = 0
    while bytes_written &lt; NUMBER:
        f.write(s)
        bytes_written += CHUNK_SIZE
    cleanup(f, name)

import sys
f(int(sys.argv[1]))
</pre></div><div data-reactid=".0.1:$3.1.$write_to_memory=1py"><p data-reactid=".0.1:$3.1.$write_to_memory=1py.0"><h3 data-reactid=".0.1:$3.1.$write_to_memory=1py.0.0"><span data-reactid=".0.1:$3.1.$write_to_memory=1py.0.0.0">write_to_memory.py</span><span data-reactid=".0.1:$3.1.$write_to_memory=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$3.1.$write_to_memory=1py.1"></ul><p><span data-reactid=".0.1:$3.1.$write_to_memory=1py.3">Guess: </span><span data-reactid=".0.1:$3.1.$write_to_memory=1py.4">bytes written</span><span data-reactid=".0.1:$3.1.$write_to_memory=1py.5"> in one second</span></p><pre data-reactid=".0.1:$3.1.$write_to_memory=1py.6">#!/usr/bin/env python

# Number to guess: How many bytes can we write
# to a string in memory in a second?

import cStringIO

CHUNK_SIZE = 1000000
s = "a" * CHUNK_SIZE

def f(NUMBER):
    output = cStringIO.StringIO()
    bytes_written = 0
    while bytes_written &lt; NUMBER:
        output.write(s)
        bytes_written += CHUNK_SIZE

import sys
f(int(sys.argv[1]))
</pre></div></div><span data-reactid=".0.1:$3.2"></span></section><section data-reactid=".0.1:$4"><div data-reactid=".0.1:$4.0"><div data-reactid=".0.1:$4.0.0">
            <p>
            File time! Sometimes I run a huge grep and it takes FOREVER. How many
            bytes can grep search in a second?
            </p>

            <p>
            Note when doing this one that the bytes grep is reading are already in memory.
            This will give us an idea of
            how much of grep's slowness is because of the search
            time required, and how much is because it needs to read from disk.
            </p>

            <p>
            Listing files also takes time! How many files can find list in a second?
            </p>
        </div></div><div data-reactid=".0.1:$4.1"><div data-reactid=".0.1:$4.1.$grep_bytes=1sh"><p data-reactid=".0.1:$4.1.$grep_bytes=1sh.0"><h3 data-reactid=".0.1:$4.1.$grep_bytes=1sh.0.0"><span data-reactid=".0.1:$4.1.$grep_bytes=1sh.0.0.0">grep_bytes.sh</span><span data-reactid=".0.1:$4.1.$grep_bytes=1sh.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$4.1.$grep_bytes=1sh.1"></ul><p><span data-reactid=".0.1:$4.1.$grep_bytes=1sh.3">Guess: </span><span data-reactid=".0.1:$4.1.$grep_bytes=1sh.4">bytes searched</span><span data-reactid=".0.1:$4.1.$grep_bytes=1sh.5"> in one second</span></p><pre data-reactid=".0.1:$4.1.$grep_bytes=1sh.6">#!/bin/bash 

# Number to guess: How many bytes can `grep`
# search, unsuccessfully, in a second?
# Note: the bytes are in memory


NUMBER=$1

cat /dev/zero | head -c $NUMBER | grep blah
exit 0
</pre></div><div data-reactid=".0.1:$4.1.$find-filenames=1sh"><p data-reactid=".0.1:$4.1.$find-filenames=1sh.0"><h3 data-reactid=".0.1:$4.1.$find-filenames=1sh.0.0"><span data-reactid=".0.1:$4.1.$find-filenames=1sh.0.0.0">find-filenames.sh</span><span data-reactid=".0.1:$4.1.$find-filenames=1sh.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$4.1.$find-filenames=1sh.1"></ul><p><span data-reactid=".0.1:$4.1.$find-filenames=1sh.3">Guess: </span><span data-reactid=".0.1:$4.1.$find-filenames=1sh.4">files listed</span><span data-reactid=".0.1:$4.1.$find-filenames=1sh.5"> in one second</span></p><pre data-reactid=".0.1:$4.1.$find-filenames=1sh.6">#!/bin/bash

# Number to guess: How many files can `find` list in a second?
# Note: the files will be in the filesystem cache.

find / -name '*' 2&gt; /dev/null | head -n $1 &gt; /dev/null
</pre></div></div><span data-reactid=".0.1:$4.2"></span></section><section data-reactid=".0.1:$5"><div data-reactid=".0.1:$5.0"><p>
            Serialization is a pretty common place to spend a lot of time, and
            it can really hurt, especially if you end up serializing/deserializing
            the same data repeatedly.
            Here are a couple of benchmarks: of parsing 64K of JSON, and the
            same data encoded in <a href="http://msgpack.org/index.html">msgpack</a> format.
            </p></div><div data-reactid=".0.1:$5.1"><div data-reactid=".0.1:$5.1.$json_parse=1py"><p data-reactid=".0.1:$5.1.$json_parse=1py.0"><h3 data-reactid=".0.1:$5.1.$json_parse=1py.0.0"><span data-reactid=".0.1:$5.1.$json_parse=1py.0.0.0">json_parse.py</span><span data-reactid=".0.1:$5.1.$json_parse=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$5.1.$json_parse=1py.1"></ul><p><span data-reactid=".0.1:$5.1.$json_parse=1py.3">Guess: </span><span data-reactid=".0.1:$5.1.$json_parse=1py.4">iterations</span><span data-reactid=".0.1:$5.1.$json_parse=1py.5"> in one second</span></p><pre data-reactid=".0.1:$5.1.$json_parse=1py.6">#!/usr/bin/env python

# Number to guess: How many times can we parse
# 64K of JSON in a second?

import json

with open('./setup/protobuf/message.json') as f:
    message = f.read()

def f(NUMBER):
    for _ in xrange(NUMBER):
        json.loads(message)

import sys
f(int(sys.argv[1]))
</pre></div><div data-reactid=".0.1:$5.1.$msgpack_parse=1py"><p data-reactid=".0.1:$5.1.$msgpack_parse=1py.0"><h3 data-reactid=".0.1:$5.1.$msgpack_parse=1py.0.0"><span data-reactid=".0.1:$5.1.$msgpack_parse=1py.0.0.0">msgpack_parse.py</span><span data-reactid=".0.1:$5.1.$msgpack_parse=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$5.1.$msgpack_parse=1py.1"></ul><p><span data-reactid=".0.1:$5.1.$msgpack_parse=1py.3">Guess: </span><span data-reactid=".0.1:$5.1.$msgpack_parse=1py.4">iterations</span><span data-reactid=".0.1:$5.1.$msgpack_parse=1py.5"> in one second</span></p><pre data-reactid=".0.1:$5.1.$msgpack_parse=1py.6">#!/usr/bin/env python

# Number to guess: How many times can we parse
# 46K of msgpack data in a second?

import msgpack

with open('./setup/protobuf/message.msgpack') as f:
    message = f.read()

def f(NUMBER):
    for _ in xrange(NUMBER):
        msgpack.unpackb(message)

import sys
f(int(sys.argv[1]))
</pre></div></div><span data-reactid=".0.1:$5.2"></span></section><section data-reactid=".0.1:$6"><div data-reactid=".0.1:$6.0"><p>
            DATABASES. We don't have anything fancy like PostgreSQL for you,
            but we made 2 copies of a SQLite table with 10 million rows, one
            indexed and one unindexed.
            </p></div><div data-reactid=".0.1:$6.1"><div data-reactid=".0.1:$6.1.$database_indexed=1py"><p data-reactid=".0.1:$6.1.$database_indexed=1py.0"><h3 data-reactid=".0.1:$6.1.$database_indexed=1py.0.0"><span data-reactid=".0.1:$6.1.$database_indexed=1py.0.0.0">database_indexed.py</span><span data-reactid=".0.1:$6.1.$database_indexed=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$6.1.$database_indexed=1py.1"></ul><p><span data-reactid=".0.1:$6.1.$database_indexed=1py.3">Guess: </span><span data-reactid=".0.1:$6.1.$database_indexed=1py.4">queries</span><span data-reactid=".0.1:$6.1.$database_indexed=1py.5"> in one second</span></p><pre data-reactid=".0.1:$6.1.$database_indexed=1py.6">#!/usr/bin/env python

# Number to guess: How many times can we
# select a row from an **indexed** table with 
# 10,000,000 rows?

import sqlite3

conn = sqlite3.connect('./indexed_db.sqlite')
c = conn.cursor()
def f(NUMBER):
    query = "select * from my_table where key = %d" % 5
    for i in xrange(NUMBER):
        c.execute(query)
        c.fetchall()

import sys
f(int(sys.argv[1]))
</pre></div><div data-reactid=".0.1:$6.1.$database_unindexed=1py"><p data-reactid=".0.1:$6.1.$database_unindexed=1py.0"><h3 data-reactid=".0.1:$6.1.$database_unindexed=1py.0.0"><span data-reactid=".0.1:$6.1.$database_unindexed=1py.0.0.0">database_unindexed.py</span><span data-reactid=".0.1:$6.1.$database_unindexed=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$6.1.$database_unindexed=1py.1"></ul><p><span data-reactid=".0.1:$6.1.$database_unindexed=1py.3">Guess: </span><span data-reactid=".0.1:$6.1.$database_unindexed=1py.4">queries</span><span data-reactid=".0.1:$6.1.$database_unindexed=1py.5"> in one second</span></p><pre data-reactid=".0.1:$6.1.$database_unindexed=1py.6">#!/usr/bin/env python

# Number to guess: How many times can we
# select a row from an **unindexed** table with 
# 10,000,000 rows?

import sqlite3

conn = sqlite3.connect('./unindexed_db.sqlite')
c = conn.cursor()
def f(NUMBER):
    query = "select * from my_table where key = %d" % 5
    for i in xrange(NUMBER):
        c.execute(query)
        c.fetchall()

import sys
f(int(sys.argv[1]))
</pre></div></div><span data-reactid=".0.1:$6.2"></span></section><section data-reactid=".0.1:$7"><div data-reactid=".0.1:$7.0"><p>
            Hashing time! Here we'll compare MD5 (which is designed to be
            fast) to bcrypt (which is designed to be slow). You can hash quite
            a bit of stuff in a second with MD5; not so with bcrypt.
            </p></div><div data-reactid=".0.1:$7.1"><div data-reactid=".0.1:$7.1.$hash=1py"><p data-reactid=".0.1:$7.1.$hash=1py.0"><h3 data-reactid=".0.1:$7.1.$hash=1py.0.0"><span data-reactid=".0.1:$7.1.$hash=1py.0.0.0">hash.py</span><span data-reactid=".0.1:$7.1.$hash=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$7.1.$hash=1py.1"></ul><p><span data-reactid=".0.1:$7.1.$hash=1py.3">Guess: </span><span data-reactid=".0.1:$7.1.$hash=1py.4">bytes hashed</span><span data-reactid=".0.1:$7.1.$hash=1py.5"> in one second</span></p><pre data-reactid=".0.1:$7.1.$hash=1py.6">#!/usr/bin/env python

# Number to guess: How many bytes can we md5sum in a second?

import hashlib

CHUNK_SIZE = 10000
s = 'a' * CHUNK_SIZE

def f(NUMBER):
    bytes_hashed = 0
    h = hashlib.md5()
    while bytes_hashed &lt; NUMBER:
        h.update(s)
        bytes_hashed += CHUNK_SIZE
    h.digest()
import sys
f(int(sys.argv[1]))
</pre></div><div data-reactid=".0.1:$7.1.$bcrypt_hash=1py"><p data-reactid=".0.1:$7.1.$bcrypt_hash=1py.0"><h3 data-reactid=".0.1:$7.1.$bcrypt_hash=1py.0.0"><span data-reactid=".0.1:$7.1.$bcrypt_hash=1py.0.0.0">bcrypt_hash.py</span><span data-reactid=".0.1:$7.1.$bcrypt_hash=1py.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$7.1.$bcrypt_hash=1py.1"></ul><p><span data-reactid=".0.1:$7.1.$bcrypt_hash=1py.3">Guess: </span><span data-reactid=".0.1:$7.1.$bcrypt_hash=1py.4"># passwords hashed</span><span data-reactid=".0.1:$7.1.$bcrypt_hash=1py.5"> in one second</span></p><pre data-reactid=".0.1:$7.1.$bcrypt_hash=1py.6">#!/usr/bin/env python

# Number to guess: How many passwords
# can we bcrypt in a second?

import bcrypt

password = 'a' * 100

def f(NUMBER):
    for _ in xrange(NUMBER):
        bcrypt.hashpw(password, bcrypt.gensalt())
        
import sys
f(int(sys.argv[1]))
</pre></div></div><span data-reactid=".0.1:$7.2"></span></section><section data-reactid=".0.1:$8"><div data-reactid=".0.1:$8.0"><div data-reactid=".0.1:$8.0.0">
            <p>
            Next up, let's talk about memory access. CPUs these days have L1 and L2 caches,
            which are much faster to access than main memory. This means that accessing memory
            sequentially (where the CPU can load a bunch of data into a cache) will normally give you faster code than
            accessing memory out of order.
            </p>
            <p>
            Let's see how that shakes out in practice! You might want to refer to 
            <a href="https://gist.github.com/jboner/2841832">Latency Numbers Every Programmer Should Know</a>
            to guess at this one.
            </p>
        </div></div><div data-reactid=".0.1:$8.1"><div data-reactid=".0.1:$8.1.$fill_array=1c"><p data-reactid=".0.1:$8.1.$fill_array=1c.0"><h3 data-reactid=".0.1:$8.1.$fill_array=1c.0.0"><span data-reactid=".0.1:$8.1.$fill_array=1c.0.0.0">fill_array.c</span><span data-reactid=".0.1:$8.1.$fill_array=1c.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$8.1.$fill_array=1c.1"></ul><p><span data-reactid=".0.1:$8.1.$fill_array=1c.3">Guess: </span><span data-reactid=".0.1:$8.1.$fill_array=1c.4">bytes written</span><span data-reactid=".0.1:$8.1.$fill_array=1c.5"> in one second</span></p><pre data-reactid=".0.1:$8.1.$fill_array=1c.6">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

// Number to guess: How big of an array (in bytes)
// can we allocate and fill in a second?

// this is intentionally more complicated than it needs to be
// so that it matches the out-of-order version :)

int main(int argc, char **argv) {
    int NUMBER, i;
    NUMBER = atoi(argv[1]);

    char* array = malloc(NUMBER);
    int j = 1;
    for (i = 0; i &lt; NUMBER; ++i) {
        j = j * 2;
        if (j &gt; NUMBER) {
            j = j - NUMBER;
        }
        array[i] = j;
    }

    printf("%d", array[NUMBER / 7]);
    // so that -O2 doesn't optimize out the loop

    return 0;
}
</pre></div><div data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c"><p data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c.0"><h3 data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c.0.0"><span data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c.0.0.0">fill_array_out_of_order.c</span><span data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c.0.0.1"> </span></h3></p><ul data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c.1"></ul><p><span data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c.3">Guess: </span><span data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c.4">bytes written</span><span data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c.5"> in one second</span></p><pre data-reactid=".0.1:$8.1.$fill_array_out_of_order=1c.6">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

// Number to guess: How big of an array (in bytes)
// can we allocate and fill with 5s in a second?
// The catch: We do it out of order instead of in order.
int main(int argc, char **argv) {
    int NUMBER, i;
    NUMBER = atoi(argv[1]);

    char* array = malloc(NUMBER);
    int j = 1;
    for (i = 0; i &lt; NUMBER; ++i) {
        j = j * 2;
        if (j &gt; NUMBER) {
            j = j - NUMBER;
        }
        array[j] = j;
    }

    printf("%d", array[NUMBER / 7]);
    // so that -O2 doesn't optimize out the loop

    return 0;
}
</pre></div></div><span data-reactid=".0.1:$8.2"></span></section></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>