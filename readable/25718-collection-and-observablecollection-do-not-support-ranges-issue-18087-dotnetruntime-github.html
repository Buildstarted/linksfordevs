<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Collection and ObservableCollection do not support ranges &#xB7; Issue #18087 &#xB7; dotnet/runtime &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Collection<t> and ObservableCollection<t> do not support ranges · Issue #18087 · dotnet/runtime · GitHub</t></t></h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><h1>Update 10/04/2018</h1><p><a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/ianhays/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/ianhays">@ianhays</a> and I discussed this and we agree to add this 6 APIs for now:</p><div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> Adds a range to the end of the collection.</span><span class="pl-c"><span class="pl-c">//</span> Raises CollectionChanged (NotifyCollectionChangedAction.Add)</span><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">AddRange</span>(<span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">collection</span>) <span class="pl-k">=&gt;</span><span class="pl-en">InsertItemsRange</span>(<span class="pl-c1">0</span>, <span class="pl-smi">collection</span>);

    <span class="pl-c"><span class="pl-c">//</span> Inserts a range</span><span class="pl-c"><span class="pl-c">//</span> Raises CollectionChanged (NotifyCollectionChangedAction.Add)</span><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">InsertRange</span>(<span class="pl-k">int</span><span class="pl-smi">index</span>, <span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">collection</span>) <span class="pl-k">=&gt;</span><span class="pl-en">InsertItemsRange</span>(<span class="pl-smi">index</span>, <span class="pl-smi">collection</span>);

    <span class="pl-c"><span class="pl-c">//</span> Removes a range.</span><span class="pl-c"><span class="pl-c">//</span> Raises CollectionChanged (NotifyCollectionChangedAction.Remove)</span><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">RemoveRange</span>(<span class="pl-k">int</span><span class="pl-smi">index</span>, <span class="pl-k">int</span><span class="pl-smi">count</span>) <span class="pl-k">=&gt;</span><span class="pl-en">RemoveItemsRange</span>(<span class="pl-smi">index</span>, <span class="pl-smi">count</span>);

    <span class="pl-c"><span class="pl-c">//</span> Will allow to replace a range with fewer, equal, or more items.</span><span class="pl-c"><span class="pl-c">//</span> Raises CollectionChanged (NotifyCollectionChangedAction.Replace)</span><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">ReplaceRange</span>(<span class="pl-k">int</span><span class="pl-smi">index</span>, <span class="pl-k">int</span><span class="pl-smi">count</span>, <span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">collection</span>)
    {
         <span class="pl-en">RemoveItemsRange</span>(<span class="pl-smi">index</span>, <span class="pl-smi">count</span>);
         <span class="pl-en">InsertItemsRange</span>(<span class="pl-smi">index</span>, <span class="pl-smi">collection</span>);
    }

    #<span class="pl-k">region</span><span class="pl-s">virtual methods</span><span class="pl-k">protected</span><span class="pl-k">virtual</span><span class="pl-k">void</span><span class="pl-en">InsertItemsRange</span>(<span class="pl-k">int</span><span class="pl-smi">index</span>, <span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">collection</span>);
    <span class="pl-k">protected</span><span class="pl-k">virtual</span><span class="pl-k">void</span><span class="pl-en">RemoveItemsRange</span>(<span class="pl-k">int</span><span class="pl-smi">index</span>, <span class="pl-k">int</span><span class="pl-smi">count</span>);
    #<span class="pl-k">endregion</span></pre></div><p>As those are the most commonly used across collection types and the <code>Predicate</code> ones can be achieved through Linq and seem like edge cases.</p><p>To answer <a class="user-mention" data-hovercard-type="user" data-hovercard-url="/users/terrajobst/hovercard" data-octo-click="hovercard-link-click" data-octo-dimensions="link_type:self" href="https://github.com/terrajobst">@terrajobst</a> questions:</p><blockquote><p>Should the methods be virtual? If no, why not? If yes, how does eventing work and how do derived types work?</p></blockquote><p>Yes, we would like to introduce 2 protected virtual methods to stick with the current pattern that we follow with other Insert/Remove apis to give people hability to add their custom removals (like filtering items on a certain condition).</p><blockquote><p>Should some of these methods be pushed down to Collection?</p></blockquote><p>Yes, and then <code>ObservableCollection</code> could just call the base implementation and then trigger the necessary events.</p><p>Let's keep the final speclet at the top for easier search</p><h1>Speclet (Updated 9/23/2016)</h1><h2>Scope</h2><p>Modernize <code>Collection&lt;T&gt;</code> and <code>ObservableCollection&lt;T&gt;</code> by allowing them to handle operations against multiple items simultaneously.</p><h2>Rationale</h2><p>The <code>ObservableCollection</code> is a critical collection when it comes to XAML-based development, though it can also be useful when building API client libraries as well. Because it implements <code>INotifyPropertyChanged</code> and <code>INotifyCollectionChanged</code>, nearly every XAML app in existence uses some form of this collection to bind a set of objects against UI.</p><p>However, this class has some shortcomings. Namely, it cannot currently handle adding or removing multiple objects in a single call. Because of that, it also cannot manipulate the collection in such a way that the <code>PropertyChanged</code> events are raised at the very end of the operation.</p><p>Consider the following situation:</p><ul><li>You have a XAML app that accesses an API.</li><li>That API call returns 25 objects that need to be bound to the UI.</li><li>In order to get the data displayed into the UI, you likely have to cycle through the results, and add them one at a time to the ObservableCollection.</li><li>This has the side-effect of firing the <code>CollectionChanged</code> event 25 times. If you are also using that event to do other processing on incoming items, then those events are firing 25 times too. This can get very expensive, very quickly.</li><li>Additionally, that event will have <code>ChangedItems</code> Lists that will only ever have 0 or 1 objects in them. That is... not ideal.</li></ul><p>This behavior is unnecessary, especially considering that <code>NotifyCollectionChangedEventArgs</code> already has the components necessary to handle firing the event once for multiple items, but that capability is presently not being used at all.</p><p>Implementing this properly would allow for better performance in these types of apps, and would negate the need for the plethora of replacements out there (<a href="http://blog.ddeysel.com/technicals/introducing-the-awesome-observable-collection/" rel="nofollow">here</a>, <a href="http://tliangnet.blogspot.com/2013/04/observablecollection-performance-issue.html" rel="nofollow">here</a>, and <a href="https://github.com/Windows-XAML/Template10/blob/master/Template10%20%28Library%29/Utils/IEnumerableUtils.cs#L34-L45">here</a>, for example).</p><h2>Usage</h2><p>Given the above scenario as an example, usage would look like this pseudocode:</p><div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span><span class="pl-smi">observable</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">ObservableCollection</span>&lt;<span class="pl-en">SomeObject</span>&gt;();
    <span class="pl-k">var</span><span class="pl-smi">client</span><span class="pl-k">=</span><span class="pl-k">new</span><span class="pl-en">HttpClient</span>();
    <span class="pl-k">var</span><span class="pl-smi">result</span><span class="pl-k">=</span><span class="pl-smi">client</span>.<span class="pl-en">GetStringAsync</span>(<span class="pl-s"><span class="pl-pds">"</span>http://someapi.com/someobject<span class="pl-pds">"</span></span>);
    <span class="pl-k">var</span><span class="pl-smi">results</span><span class="pl-k">=</span><span class="pl-smi">JsonConvert</span>.<span class="pl-en">DeserializeObject</span>&lt;<span class="pl-en">SomeObject</span>&gt;(<span class="pl-smi">result</span>);
    <span class="pl-smi">observable</span>.<span class="pl-en">AddRange</span>(<span class="pl-smi">results</span>);</pre></div><h2>Implementation</h2><p>This is not the complete implementation, because other <code>*Range</code> functionality would need to be implemented as well. You can see the start of this work in PR <a class="issue-link js-issue-link" data-error-text="Failed to load issue title" data-id="170993828" data-permission-text="Issue title is private" data-url="https://github.com/dotnet/corefx/issues/10751" data-hovercard-type="pull_request" data-hovercard-url="/dotnet/corefx/pull/10751/hovercard" href="https://github.com/dotnet/corefx/pull/10751">dotnet/corefx#10751</a></p><div class="highlight highlight-source-cs"><pre><span class="pl-c"><span class="pl-c">//</span> Adds a range to the end of the collection.</span><span class="pl-c"><span class="pl-c">//</span> Raises CollectionChanged (NotifyCollectionChangedAction.Add)</span><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">AddRange</span>(<span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">collection</span>)

    <span class="pl-c"><span class="pl-c">//</span> Inserts a range</span><span class="pl-c"><span class="pl-c">//</span> Raises CollectionChanged (NotifyCollectionChangedAction.Add)</span>
    public void InsertRange(<span class="pl-k">int</span><span class="pl-smi">index</span>, <span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">collection</span>);

    <span class="pl-c"><span class="pl-c">//</span> Removes a range.</span><span class="pl-c"><span class="pl-c">//</span> Raises CollectionChanged (NotifyCollectionChangedAction.Remove)</span><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">RemoveRange</span>(<span class="pl-k">int</span><span class="pl-smi">index</span>, <span class="pl-k">int</span><span class="pl-smi">count</span>);

    <span class="pl-c"><span class="pl-c">//</span> Will allow to replace a range with fewer, equal, or more items.</span><span class="pl-c"><span class="pl-c">//</span> Raises CollectionChanged (NotifyCollectionChangedAction.Replace)</span><span class="pl-k">public</span><span class="pl-k">void</span><span class="pl-en">ReplaceRange</span>(<span class="pl-k">int</span><span class="pl-smi">index</span>, <span class="pl-k">int</span><span class="pl-smi">count</span>, <span class="pl-en">IEnumerable</span>&lt;<span class="pl-en">T</span>&gt; <span class="pl-smi">collection</span>);

    <span class="pl-c"><span class="pl-c">//</span> Removes any item that matches the search criteria.</span><span class="pl-c"><span class="pl-c">//</span> Raises CollectionChanged (NotifyCollectionChangedAction.Remove)</span><span class="pl-c"><span class="pl-c">//</span> RWM: Excluded for now, will see if possible to add back in after implementation and testing.</span><span class="pl-c"><span class="pl-c">//</span> public int RemoveAll(Predicate&lt;T&gt; match);</span></pre></div><h2>Obstacles</h2><p>Doing this properly, and having the methods intuitively named, could potentially have the side effect of breaking existing classes that inherit from <code>ObservableCollection</code> to solve this problem. A good way to test this would be to make the change, compile something like Template10 against this new assembly, and see if it breaks.</p><hr><p>So the <code>ObservableCollection</code> is one of the cornerstones of software development, not just in Windows, but on the web. One issue that comes up constantly is that, while the <code>OnCollectionChanged</code> event has a structure and constructors that support signaling the change for multiple items being added, the <code>ObservableCollection</code> does not have a method to support this.</p><p>If you look at the web as an example, Knockout has a way to be able to add multiple items to the collection, but not signal the change until the very end. The <code>ObservableCollection</code> needs the same functionality, but does not have it.</p><p>If you look at other extension methods to solve this problem, like the one in <a href="https://github.com/Windows-XAML/Template10/blob/master/Template10%20%28Library%29/Utils/IEnumerableUtils.cs#L34-L45">Template10</a>, they let you add multiple items, but do not solve the signaling problem. That's because the <code>ObservableCollection.InsertItem()</code> method overrides <code>Collection.InsertItem()</code>, and all of the other methods are private. So the only way to fix this properly is in the <code>ObservableCollection</code> itself.</p><p>I'm proposing an "AddRange" function that accepts an existing collection as input, optionally clears the collection before adding, and then throws the <code>OnCollectionChanging</code> event AFTER all the objects have been added. I have already implemented this in a PR <a class="issue-link js-issue-link" data-error-text="Failed to load issue title" data-id="170993828" data-permission-text="Issue title is private" data-url="https://github.com/dotnet/corefx/issues/10751" data-hovercard-type="pull_request" data-hovercard-url="/dotnet/corefx/pull/10751/hovercard" href="https://github.com/dotnet/corefx/pull/10751">dotnet/corefx#10751</a> so you can see what the implementation would look like.</p><p>I look forward to your feedback. Thanks!</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>