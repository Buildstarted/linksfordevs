<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Introducing Scalar: Git at scale for everyone | Azure DevOps Blog - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Introducing Scalar: Git at scale for everyone | Azure DevOps Blog - linksfor.dev(s)"/>
    <meta property="article:author" content="Derrick StoleePrincipal Software Engineer,&#xA0;Azure DevOpsFollow Derrick"/>
    <meta property="og:description" content="Git is a distributed version control system, so by default each Git repository has a copy of all files in the entire history. Even moderately-sized teams can create thousands of commits adding hundreds of megabytes to the repository every month. As your repository grows,"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://devblogs.microsoft.com/devops/introducing-scalar/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Introducing Scalar: Git at scale for everyone | Azure DevOps Blog</title>
<div class="readable">
        <h1>Introducing Scalar: Git at scale for everyone | Azure DevOps Blog</h1>
            <div>by Derrick StoleePrincipal Software Engineer,&#xA0;Azure DevOpsFollow Derrick</div>
            <div>Reading time: 22-28 minutes</div>
        <div>Posted here: 13 Feb 2020</div>
        <p><a href="https://devblogs.microsoft.com/devops/introducing-scalar/">https://devblogs.microsoft.com/devops/introducing-scalar/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="featured"><div><div><div><div><p><img src="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2019/05/profile-150x150.jpg" width="58" height="58" alt="Derrick Stolee"></p><p>Derrick</p></div></div></div><p>February 12th, 2020</p><p>Git is a <em>distributed</em> version control system, so by default each Git repository has a copy of all files in the entire history. Even moderately-sized teams can create thousands of commits adding hundreds of megabytes to the repository every month. As your repository grows, Git may struggle to manage all that data. Time spent waiting for <code>git status</code> to report modified files or <code>git fetch</code> to get the latest data is time wasted. As these commands get slower, developers stop waiting and start switching context. <a href="https://www.joelonsoftware.com/2001/02/12/human-task-switches-considered-harmful/" target="_blank">Context switches harm developer productivity</a>.</p><p>At Microsoft, we support <a href="https://devblogs.microsoft.com/bharry/the-largest-git-repo-on-the-planet/">the Windows OS repository</a> using <a href="https://github.com/microsoft/VFSForGit" target="_blank">VFS for Git</a> (formerly GVFS). VFS for Git uses a <em>virtualized filesystem</em> to bypass many assumptions about repository size, enabling the Windows developers to use Git at a scale previously thought impossible.</p><p>While supporting VFS for Git, we identified performance bottlenecks <a href="https://devblogs.microsoft.com/devops/a-deep-dive-into-git-performance-using-trace2/">using a custom trace system</a> and collecting user feedback. We made several contributions to the Git client, including <a href="https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph/">the commit-graph file</a> and improvements to <a href="https://devblogs.microsoft.com/devops/exploring-new-frontiers-for-git-push-performance/"><code>git push</code></a> and <a href="https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/" target="_blank">sparse-checkout</a>. Building on these contributions and many other recent improvements to Git, we began a project to support very large repositories without needing a virtualized filesystem.</p><p>Today we are excited to announce the result of those efforts – <a href="https://github.com/microsoft/scalar/" target="_blank"><strong>Scalar</strong></a>. Scalar accelerates your Git workflow, no matter the size or shape of your repository. And it does it in ways we believe can all make their way into Git, with Scalar doing less and Git doing much more over time.</p><p><a href="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-card-opaque-1024x512.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-card-opaque-1024x512.png" alt="Scalar logo" width="640" height="320" srcset="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-card-opaque-1024x512.png 1024w, https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-card-opaque-300x150.png 300w, https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-card-opaque-768x384.png 768w, https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-card-opaque.png 1280w" sizes="(max-width: 640px) 100vw, 640px"> </a></p><p>Scalar is a .NET Core application with installers available for Windows and macOS. Scalar maximizes your Git command performance by setting recommended config values and running background maintenance. You can clone a repository using the <a href="https://github.com/microsoft/VFSForGit/blob/master/Protocol.md#the-gvfs-protocol-v1" target="_blank">GVFS protocol</a> if your repository is hosted by Azure Repos. This is how we will support the next largest Git repository: Microsoft Office.</p><blockquote><p> <b>What about Linux?</b><br> There is potential for porting Scalar to Linux, so please <a href="https://github.com/microsoft/scalar/issues/323" target="_blank">comment on this issue</a> if you would use Scalar on Linux.</p></blockquote><p>In the rest of this post, I’ll share three important lessons that informed Scalar’s design:</p><ol><li><a href="#lesson-1">Focus on the files that matter.</a></li><li><a href="#lesson-2">Reduce object transfer.</a></li><li><a href="#lesson-3">Don’t wait for expensive operations.</a></li></ol><p>Finally, I <a href="#git-future">share our plan for contributing these features to the Git client</a>. You can <a href="#quick-start">get started with Scalar</a> using the instructions below.</p><h3 id="quick-start">Quick start for existing repositories</h3><p>Scalar accelerates Git commands in your existing repositories, no matter what service you use to host those repositories. All you need to do is register your biggest repositories with Scalar and then see how much faster your Git experience becomes.</p><p>To get started, <a href="https://github.com/microsoft/scalar/releases" target="_blank">download and install the latest Scalar release</a>. Scalar currently requires <a href="https://github.com/microsoft/git" target="_blank">a custom version of Git</a>. We plan to remove that requirement after we contribute enough features to the core Git client.</p><p>Before beginning, ensure you have the correct versions:</p><pre><code><span>$ git version
git version </span><span>2.25</span><span>.</span><span>0.vfs</span><span>.</span><span>1.1</span><span>

$ scalar version
scalar </span><span>20.01</span><span>.</span><span>165.7</span></code></pre><p>From the working directory of your Git repository, run <code>scalar register</code> to make Scalar aware of your repository.</p><pre><code><span>$ scalar </span><span>register</span><span>
</span><span>Successfully</span><span> registered repo at </span><span>'/Users/stolee/_git/git'</span></code></pre><p>By registering your repository with Scalar, it will set up some local Git config options and start running background maintenance. If you decide that you do not want Scalar running maintenance, then <code>scalar pause</code> will delay all maintenance for 12 hours, or <code>scalar unregister</code> will stop all future maintenance on the current repository.</p><p>You can watch what Scalar does by checking the log files in your <code>.git/logs</code> directory. For example, here is a section of logs from my repository containing the Git source code:</p><pre><code><span>[</span><span>2020</span><span>-</span><span>02</span><span>-</span><span>05</span><span> </span><span>11</span><span>:</span><span>24</span><span>:</span><span>00.9711</span><span> </span><span>-</span><span>05</span><span>:</span><span>00</span><span>]</span><span> run </span><span>(</span><span>Start</span><span>)</span><span> </span><span>{</span><span>"Version"</span><span>:</span><span>"20.01.165.7"</span><span>,</span><span>"EnlistmentRoot"</span><span>:</span><span>"/Users/stolee/_git/git"</span><span>,</span><span>"Remote"</span><span>:</span><span>"https://github.com/git/git"</span><span>,</span><span>"ObjectsEndpoint"</span><span>:</span><span>"https://github.com/git/git"</span><span>,</span><span>"MaintenanceTask"</span><span>:</span><span>"commit-graph"</span><span>,</span><span>"PackfileMaintenanceBatchSize"</span><span>:</span><span>""</span><span>,</span><span>"EnlistmentRootPathParameter"</span><span>:</span><span>"/Users/stolee/_git/git"</span><span>,</span><span>"StartedByService"</span><span>:</span><span>true</span><span>,</span><span>"Area"</span><span>:</span><span>"run_Verb"</span><span>,</span><span>"Verb"</span><span>:</span><span>"run"</span><span>}</span><span>
</span><span>[</span><span>2020</span><span>-</span><span>02</span><span>-</span><span>05</span><span> </span><span>11</span><span>:</span><span>24</span><span>:</span><span>00.9797</span><span> </span><span>-</span><span>05</span><span>:</span><span>00</span><span>]</span><span> </span><span>TryWriteGitCommitGraph</span><span> </span><span>(</span><span>Start</span><span>)</span><span>
</span><span>[</span><span>2020</span><span>-</span><span>02</span><span>-</span><span>05</span><span> </span><span>11</span><span>:</span><span>24</span><span>:</span><span>00.9806</span><span> </span><span>-</span><span>05</span><span>:</span><span>00</span><span>]</span><span> </span><span>RunGitCommand</span><span> </span><span>(</span><span>Start</span><span>)</span><span> </span><span>{</span><span>"Area"</span><span>:</span><span>"CommitGraphStep"</span><span>,</span><span>"gitCommand"</span><span>:</span><span>"WriteCommitGraph"</span><span>}</span><span>
</span><span>[</span><span>2020</span><span>-</span><span>02</span><span>-</span><span>05</span><span> </span><span>11</span><span>:</span><span>24</span><span>:</span><span>01.2120</span><span> </span><span>-</span><span>05</span><span>:</span><span>00</span><span>]</span><span> </span><span>RunGitCommand</span><span> </span><span>(</span><span>Stop</span><span>)</span><span> </span><span>{</span><span>"DurationMs"</span><span>:</span><span>229</span><span>}</span><span>
</span><span>[</span><span>2020</span><span>-</span><span>02</span><span>-</span><span>05</span><span> </span><span>11</span><span>:</span><span>24</span><span>:</span><span>01.2297</span><span> </span><span>-</span><span>05</span><span>:</span><span>00</span><span>]</span><span> </span><span>Information</span><span> </span><span>{</span><span>"Message"</span><span>:</span><span>"commit-graph list after write: graph-6928d994cab880ad7e30fa9f406d01bd0c7bbe6c.graph;graph-cf5d2151c2cfac0451686fafdd6de8bb9111d0d9.graph;commit-graph-chain;graph-0c676dd4d1ff904528c8563a39de8c0e3928ba01.graph;"</span><span>}</span><span>
</span><span>[</span><span>2020</span><span>-</span><span>02</span><span>-</span><span>05</span><span> </span><span>11</span><span>:</span><span>24</span><span>:</span><span>01.2298</span><span> </span><span>-</span><span>05</span><span>:</span><span>00</span><span>]</span><span> </span><span>RunGitCommand</span><span> </span><span>(</span><span>Start</span><span>)</span><span> </span><span>{</span><span>"Area"</span><span>:</span><span>"CommitGraphStep"</span><span>,</span><span>"gitCommand"</span><span>:</span><span>"VerifyCommitGraph"</span><span>}</span><span>
</span><span>[</span><span>2020</span><span>-</span><span>02</span><span>-</span><span>05</span><span> </span><span>11</span><span>:</span><span>24</span><span>:</span><span>01.2518</span><span> </span><span>-</span><span>05</span><span>:</span><span>00</span><span>]</span><span> </span><span>RunGitCommand</span><span> </span><span>(</span><span>Stop</span><span>)</span><span> </span><span>{</span><span>"DurationMs"</span><span>:</span><span>21</span><span>}</span><span>
</span><span>[</span><span>2020</span><span>-</span><span>02</span><span>-</span><span>05</span><span> </span><span>11</span><span>:</span><span>24</span><span>:</span><span>01.2518</span><span> </span><span>-</span><span>05</span><span>:</span><span>00</span><span>]</span><span> </span><span>TryWriteGitCommitGraph</span><span> </span><span>(</span><span>Stop</span><span>)</span><span> </span><span>{</span><span>"DurationMs"</span><span>:</span><span>272</span><span>}</span><span>
</span><span>[</span><span>2020</span><span>-</span><span>02</span><span>-</span><span>05</span><span> </span><span>11</span><span>:</span><span>24</span><span>:</span><span>01.2522</span><span> </span><span>-</span><span>05</span><span>:</span><span>00</span><span>]</span><span> run </span><span>(</span><span>Stop</span><span>)</span><span> </span><span>{</span><span>"DurationMs"</span><span>:</span><span>333</span><span>}</span></code></pre><p>These logs show the details from updating the Git commit-graph in the background, the equivalent of the <code>scalar run commit-graph</code> command.</p><p>You can <a href="https://github.com/microsoft/scalar/blob/master/docs/advanced.md#run-maintenance-in-the-foreground" target="_blank">run maintenance in the foreground</a> using the <code>scalar run</code> command. When given the <code>all</code> option, Scalar runs all maintenance steps in a single command:</p><pre><code><span>$ scalar run all
</span><span>Setting</span><span> recommended config settings</span><span>...</span><span>Succeeded</span><span>
</span><span>Fetching</span><span> </span><span>from</span><span> remotes</span><span>...</span><span>Succeeded</span><span>
</span><span>Updating</span><span> commit</span><span>-</span><span>graph</span><span>...</span><span>Succeeded</span><span>
</span><span>Cleaning</span><span> up loose objects</span><span>...</span><span>Succeeded</span><span>
</span><span>Cleaning</span><span> up pack</span><span>-</span><span>files</span><span>...</span><span>Succeeded</span></code></pre><p>The <code>scalar run</code> command exists so you can run maintenance tasks on your own schedule or in conjunction with the background maintenance schedule provided by <code>scalar register</code>.</p><h3>Quick start for using the GVFS protocol</h3><p>If you are considering using Scalar with the GVFS protocol and <a href="https://azure.microsoft.com/en-us/services/devops/repos/?nav=min" target="_blank">Azure Repos</a>, then you can try cloning a new enlistment using <code>scalar clone &lt;url&gt;</code>. Scalar automatically registers this new enlistment, so it will benefit from all the config options and maintenance described above.</p><p>By following the snippet below, you can clone a mirror of the Scalar source code using the GVFS protocol:</p><pre><code><span>$ scalar clone https</span><span>:</span><span>//dev.azure.com/ms-scalar/_git/scalar</span><span>
</span><span>Clone</span><span> parameters</span><span>:</span><span>
  </span><span>Repo</span><span> URL</span><span>:</span><span>     https</span><span>:</span><span>//dev.azure.com/ms-scalar/_git/scalar</span><span>
  </span><span>Branch</span><span>:</span><span>       </span><span>Default</span><span>
  </span><span>Cache</span><span> </span><span>Server</span><span>:</span><span> </span><span>Default</span><span>
  </span><span>Local</span><span> </span><span>Cache</span><span>:</span><span>  </span><span>/Users/</span><span>stolee</span><span>/.</span><span>scalarCache
  </span><span>Destination</span><span>:</span><span>  </span><span>/Users/</span><span>stolee</span><span>/</span><span>_git</span><span>/</span><span>t</span><span>/</span><span>scalar
  </span><span>FullClone</span><span>:</span><span>     </span><span>False</span><span>
</span><span>Authenticating</span><span>...</span><span>Succeeded</span><span>
</span><span>Querying</span><span> remote </span><span>for</span><span> config</span><span>...</span><span>Succeeded</span><span>
</span><span>Using</span><span> cache server</span><span>:</span><span> </span><span>None</span><span> </span><span>(</span><span>https</span><span>:</span><span>//dev.azure.com/ms-scalar/_git/scalar)</span><span>
</span><span>Querying</span><span> remote </span><span>for</span><span> repo info</span><span>...</span><span>Succeeded</span><span>
</span><span>Cloning</span><span>...</span><span>Succeeded</span><span>
</span><span>Fetching</span><span> </span><span>from</span><span> origin </span><span>(</span><span>no</span><span> cache server</span><span>)...</span><span>Succeeded</span><span>
</span><span>Registering</span><span> repo</span><span>...</span><span>Succeeded</span></code></pre><p>Note that this repository is not large enough to really need the GVFS protocol. We have not set up a GVFS cache server for this repository, but any sufficiently large repository being used by a large group of users should set up a co-located cache server for handling GVFS protocol requests. If you do not have the resources to set up this infrastructure, then perhaps the GVFS protocol is not a good fit, and instead you could use <code>scalar register</code> on an existing Git repository using the Git protocol.</p><p>When using <code>scalar clone</code>, the working directory contains only the files at root using the <a href="https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/" target="_blank">Git sparse-checkout feature in <em>cone mode</em></a>. You can expand the files in your working directory using the <code>git sparse-checkout set</code> command, or fully populate your working directory by running <code>git sparse-checkout disable</code>.</p><pre><code><span>$ cd scalar</span><span>/</span><span>src
$ ls
</span><span>AuthoringTests</span><span>.</span><span>md      </span><span>Directory</span><span>.</span><span>Build</span><span>.</span><span>targets  SECURITY</span><span>.</span><span>md      </span><span>global</span><span>.</span><span>json
CONTRIBUTING</span><span>.</span><span>md          </span><span>License</span><span>.</span><span>md               </span><span>Scalar</span><span>.</span><span>ruleset   nuget</span><span>.</span><span>config
</span><span>Dependencies</span><span>.</span><span>props     </span><span>Protocol</span><span>.</span><span>md              </span><span>Scalar</span><span>.</span><span>sln
</span><span>Directory</span><span>.</span><span>Build</span><span>.</span><span>props    </span><span>Readme</span><span>.</span><span>md                </span><span>Signing</span><span>.</span><span>targets

$ git sparse</span><span>-</span><span>checkout </span><span>set</span><span> </span><span>Scalar</span><span> </span><span>Scripts</span><span>/</span><span>Mac</span><span>
</span><span>Receiving</span><span> packfile </span><span>1</span><span>/</span><span>1</span><span> </span><span>with</span><span> </span><span>45</span><span> objects </span><span>(</span><span>bytes received</span><span>):</span><span> </span><span>127638</span><span>,</span><span> </span><span>done</span><span>.</span><span>

$ ls
</span><span>AuthoringTests</span><span>.</span><span>md      </span><span>Directory</span><span>.</span><span>Build</span><span>.</span><span>targets  SECURITY</span><span>.</span><span>md     </span><span>Scripts</span><span>
CONTRIBUTING</span><span>.</span><span>md        </span><span>License</span><span>.</span><span>md               </span><span>Scalar</span><span>          </span><span>Signing</span><span>.</span><span>targets
</span><span>Dependencies</span><span>.</span><span>props     </span><span>Protocol</span><span>.</span><span>md              </span><span>Scalar</span><span>.</span><span>ruleset  </span><span>global</span><span>.</span><span>json
</span><span>Directory</span><span>.</span><span>Build</span><span>.</span><span>props  </span><span>Readme</span><span>.</span><span>md                </span><span>Scalar</span><span>.</span><span>sln      nuget</span><span>.</span><span>config

$ ls </span><span>Scalar</span><span>
</span><span>CommandLine</span><span>  </span><span>Images</span><span>  </span><span>Program</span><span>.</span><span>cs  </span><span>Scalar</span><span>.</span><span>csproj</span></code></pre><p>Note that the clone created the <code>scalar</code> directory and created the working directory is inside <a href="https://github.com/microsoft/scalar/blob/master/docs/faq.md#why-does-scalar-clone-create-a-reposrc-folder" target="_blank">a <code>src</code> directory one level down</a>. This allows creating sibling directories for build output files, preventing over-taxing the work Git needs to do when managing your repository. This leads to the first big lesson we learned about making Git as fast as possible.</p><h2 id="lesson-1">Lesson 1: Focus on the files that matter<a href="#lesson-1"></a></h2><p>The <a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository" target="_blank">most common Git commands</a> are <code>git status</code> to see what change are available, <code>git add</code> to stage those changes before committing, and <code>git checkout</code> to change your working directory to match a different version. We call these the <em>core commands</em>.</p><p>Each core command inspects the working directory to see how Git’s view of the working directory agrees with what is actually on-disk. There are a few different measurements for how “big” this set can be: the index size, the populated size, and the modified size.</p> <p><a href="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scale-venn-diagram.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scale-venn-diagram.png" alt="Image scale venn diagram" width="800" height="449" srcset="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scale-venn-diagram.png 800w, https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scale-venn-diagram-300x168.png 300w, https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scale-venn-diagram-768x431.png 768w" sizes="(max-width: 800px) 100vw, 800px"> </a></p><h3>Index size</h3><p>The Git index is a list of every tracked path at your current HEAD. This file is read and written by each core command, presenting a minimum amount of work.</p><blockquote><p> <b>Pro Tip!</b><br> If you are struggling with the size of your index, then you can try running <code>git config features.manyFiles true</code> to take advantage of the updated index version <i>and</i> Git’s untracked cache feature.</p></blockquote><p>In the Windows OS repository, the index contains over three million entries. We minimize the index file size by using an updated version of the index file format, which compresses the index file from 400 MB to 250 MB. Since this size primarily impacts reading and writing a stream from a single file, the average time per index entry is very low.</p><h3>Populated size</h3><p>How many paths in the index are actually in your working directory? This is normally equal to the number of tracked files in the index, but <a href="https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/" target="_blank">Git’s sparse-checkout feature</a> can make it smaller. It takes a little bit of work to design your repository to work with sparse-checkout, but it can allow most developers to populate a fraction of the total paths and still build the components necessary for their daily work.</p><p>Scalar leans into the sparse-checkout feature, so much so that the <code>scalar clone</code> command creates a sparse working directory by default. At the start, only the files in the root directory are present. It is up to the user to request more directories, increasing the populated size. This mode can be overridden using the <code>--full-clone</code> option.</p><p>The populated size is always at most the number of tracked files. The average cost of populating a file is much higher than adjusting an index entry due to the amount of data involved, so it is more critical to minimize the number of populated files than to minimize the total number of paths in the repository. It is even more expensive to determine which populated files were modified by the user.</p><h3>Modified Size</h3><p>The <em>modified size</em> is the number of paths in the working directory that differ from the version in the index. This includes all files that are untracked or ignored by Git. This size determines the minimum amount of work that Git must do to update the index and its caches during the core commands.</p><p>Without assistance, Git needs to scan the entire working directory to find which paths were modified. As the populated size increases, this can become extremely slow.</p><blockquote><p> <b><code>fsmonitor</code> in action</b><br>For some developers in the Microsoft Office team, their sparse-checkout definition requires around 700,000 populated files among the three million tracked files. When there are no modified files, <code>git status</code> takes 12.2 seconds with <code>fsmonitor</code> disabled and only 1.5 seconds with it enabled.</p></blockquote><p>Scalar painlessly configures your Git repository to work better with modified files using <a href="https://git-scm.com/docs/githooks#_fsmonitor_watchman" target="_blank">the <code>fsmonitor</code> Git feature</a> and the <a href="https://github.com/facebook/watchman" target="_blank">Watchman</a> tool. Git uses the <code>fsmonitor</code> hook to discover the list of paths that were modified since the last index update, then focuses its work in inspecting only those paths instead of every populated path. Our team <a href="https://github.com/git/git/commit/883e248b8a0fd88773cb902ab8e91273eb147d07" target="_blank">originally contributed the <code>fsmonitor</code> feature to Git</a>, and we <a href="https://lore.kernel.org/git/pull.510.git.1578423871.gitgitgadget@gmail.com/" target="_blank">continue to contribute improvements</a>.</p><h2 id="lesson-2">Lesson 2: Reduce object transfer<a href="#lesson-2"></a></h2><p>Now that the working directory is under control, let’s investigate another expensive dimension of Git at scale. Git expects a complete copy of all objects, both currently referenced and all versions in history. This can be a massive amount of data to transfer — especially when you only need objects near your current branch do a checkout and get on with your work.</p><p>For example, in the Windows OS repository, the complete set contains over 100 GB of compressed data. This is incredibly expensive for both the server and the client. Not only is that a lot of data to transfer over the network, but the client needs to verify that all 90 million Git objects hash to the correct values.</p><p>We created the <a href="https://github.com/microsoft/VFSForGit/blob/master/Protocol.md#the-gvfs-protocol-v1" target="_blank">GVFS protocol</a> to significantly reduce object transfer. This protocol is currently only available on Azure Repos. It solved one of the major issues with adapting Git to very large repositories by relaxing the distributed nature of Git to become slightly more coupled to a central server for missing objects. It has since inspired the <a href="https://git-scm.com/docs/partial-clone" target="_blank">Git partial clone feature</a> which has very similar goals.</p><p>When using the GVFS protocol, an initial clone downloads a set of pack-files containing only commits and trees. A clone of the Windows OS repository downloads about 15 GB of data containing 40 million commits and trees. With these objects on-disk, we can generate a view of the working directory and examine commit history using <code>git log</code>.</p><p>The GVFS protocol also allows dynamically downloading Git objects as-needed. This pairs well with our work to reduce the populated size using sparse checkout, since reducing the populated size reduces the number of required objects.</p><p>To reduce latency and increase throughput, we allow the GVFS protocol to be proxied through a set of <strong>cache servers</strong> that are co-located with the end users and build machines. This has an added bonus of reducing stress on the central server. We intend to contribute this idea to the Git protocol.</p><h2 id="lesson-3">Lesson 3: Don’t wait for expensive operations<a href="#lesson-3"></a></h2><p><em>There is no free lunch</em>. Large repositories require upkeep. We can’t make users wait, so we defer these operations to background processes.</p><p>Git typically handles maintenance by running garbage collection (GC) with <a href="https://git-scm.com/docs/git-gc#Documentation/git-gc.txt" target="_blank">the <code>git gc --auto</code> command</a> at the end of several common commands, like <code>git commit</code> and <code>git fetch</code>. Auto-GC checks your <code>.git</code> directory to see if certain thresholds are met to run garbage collection. If the thresholds are met, it completely rewrites all object data, a process that includes a CPU-intensive compression step. This can cause simple commands like <code>git commit</code> to be blocked for <em>minutes</em>. A rewrite of tens of gigabytes of data can also bring your entire system to a standstill because it consumes all the CPU and memory resources it can.</p><p>You can already disable automatic garbage collection by <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-gcauto" target="_blank">setting <code>gc.auto</code> to zero</a>. However, this has the downside that your Git performance will decay slowly as you accumulate new objects through your daily work.</p><p>VFS for Git and Scalar both solve this problem by maintaining the repository in the background. This is also done <em>incrementally</em> to reduce the extra load on your machine. Let’s explore each of these background operations and how they improve the repository.</p><h3>Set recommended Git config settings</h3><p>The <a href="https://github.com/microsoft/scalar/blob/master/Scalar.Common/Maintenance/ConfigStep.cs" target="_blank">config step</a> updates your Git config settings to some recommended values. The config step runs in the background so that new versions of Scalar can update the registered repositories after install. As new config options are supported, we will update the list of settings accordingly.</p><p>Some of the noteworthy config settings are:</p><ol><li><p>We disable auto-GC by setting <code>gc.auto=0</code>. This prevents your Git commands from being blocked by expensive maintenance. The background maintenance keeps your Git object database clean.</p></li><li><p>We disable writing the commit-graph during <code>git fetch</code> by setting <code>fetch.writeCommitGraph=false</code>, because we write it in the background (see below).</p></li><li><p>We set <code>status.aheadBehind=false</code> to remove the calculation of how far ahead or behind your branch is compared to the remote-tracking branch. This message is frequently ignored, but can cost precious seconds when you just want to see your unstaged changes.</p></li><li><p>We set <code>core.fsmonitor</code> to <a href="https://github.com/microsoft/scalar/blob/f46d0126b6c34af73d73a154b1ab040b3f7bf803/Scalar.Common/Maintenance/ConfigStep.cs#L226-L261" target="_blank">a hook that communicates with Watchman</a>, if Watchman is installed.</p></li></ol><h3>Fetch in the background</h3><p>The <a href="https://github.com/microsoft/scalar/blob/master/Scalar.Common/Maintenance/FetchStep.cs" target="_blank">fetch step</a> runs <code>git fetch</code> about once an hour. This allows your local repository to keep its object database close to that of your remotes. This means that the time-consuming part of <code>git fetch</code> that downloads the new objects happens when you are not waiting for your command to complete.</p><p>We intentionally do not change your local branches, including the ones in <code>refs/remotes</code>. You still need to run <code>git fetch</code> in the foreground when you want ref updates from your remotes. We run <a href="https://github.com/microsoft/scalar/blob/f46d0126b6c34af73d73a154b1ab040b3f7bf803/Scalar.Common/Git/GitProcess.cs#L427-L443" target="_blank"><code>git fetch</code> with a custom refspec</a> to put all remote refs into a new ref namespace: <code>refs/scalar/hidden/&lt;remote&gt;/&lt;branch&gt;</code>. This allows us to have starting points when writing the commit-graph.</p><h3>Write the commit-graph</h3><p>The <a href="https://devblogs.microsoft.com/devops/supercharging-the-git-commit-graph/">Git commit-graph</a> is critical to performance in repositories with hundreds of thousands of commits. While <a href="https://devblogs.microsoft.com/devops/updates-to-the-git-commit-graph-feature/">it is enabled</a> and written during <code>git fetch</code> by default since Git 2.24.0, that does require a little bit of extra overhead in foreground fetches. To recover that time during <code>git fetch</code> while maintaining performance, we update the commit-graph in the background.</p><p>By running <code>git commit-graph write --split --reachable</code>, we update the commit-graph to include all reachable commits (including those reachable from refs in <code>refs/scalar/hidden</code>) and use the <a href="https://github.com/git/git/blob/5b0ca878e008e82f91300091e793427205ce3544/Documentation/technical/commit-graph.txt#L139-L319" target="_blank">incremental file format</a> to minimize the cost of these background operations.</p><h3>Clean up loose objects</h3><p>As you work, Git creates “loose” objects by writing the data of a single object to a file named according to its SHA-1 hash. This is very quick to create, but accumulating too many objects like this can have significant performance drawbacks. It also uses more disk space than necessary, since Git’s pack-files can compress data more efficiently using <a href="https://en.wikipedia.org/wiki/Delta_encoding" target="_blank">delta encoding</a>.</p><p>To reduce this overhead, the <a href="https://github.com/microsoft/scalar/blob/master/Scalar.Common/Maintenance/LooseObjectsStep.cs" target="_blank">loose objects step</a> will clean up your loose objects.</p><h3>Index multiple pack-files</h3><p>Pack-files are very efficient ways to store a set of Git objects. Each <code>.pack</code> file is paired with a <code>.idx</code> file called the <em>pack-index</em>, which allows Git to find the data for a packed object quickly. As pack-files accumulate, Git needs to inspect a long list of pack-indexes to find objects, so a previously fast operation becomes slow. Normally, garbage collection would occasionally group these pack-files into a single pack-file, improving performance.</p><p>But what happens if we have too much data to efficiently rewrite <em>all</em> Git data into a single pack-file? How can we keep the performance of a single pack-file while also performing smaller maintenance steps?</p><p>Our solution is <a href="https://git-scm.com/docs/git-multi-pack-index" target="_blank">the Git multi-pack-index file</a>. Inspired by a similar feature in Azure Repos, the multi-pack-index tracks the location of objects across multiple pack-files. This file keeps Git’s object lookup time the same as if we had repacked into a single pack-file. Scalar runs <code>git multi-pack-index write</code> in the background to create the multi-pack-index.</p><h3>Clean up pack-files</h3><figure id="attachment_58467" aria-describedby="caption-attachment-58467"><a href="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-multi-pack-index-724x1024.png" data-featherlight="image"> <img src="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-multi-pack-index-724x1024.png" alt="Image scalar multi pack index" width="400" srcset="https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-multi-pack-index-724x1024.png 724w, https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-multi-pack-index-212x300.png 212w, https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-multi-pack-index-768x1086.png 768w, https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2020/02/scalar-multi-pack-index.png 800w" sizes="(max-width: 724px) 100vw, 724px"> </a><figcaption id="caption-attachment-58467">The multi-pack-index maintenance loop.</figcaption></figure><p>However, there is still a problem. If we let the number of pack-files grow without bound, Git cannot hold file handles to all pack-files at once. Rewriting pack-files could also reduce space costs due to better delta encoding.</p><p>To solve this problem, Scalar has a <a href="https://github.com/microsoft/scalar/blob/master/Scalar.Common/Maintenance/PackfileMaintenanceStep.cs" target="_blank">pack-file maintenance step</a> which performs an <em>incremental</em> repack by selecting a batch of small pack-files to rewrite. The multi-pack-index is a critical component for this rewrite. When the new pack-file is added to the multi-pack-index, the old pack-files are still referenced by the multi-pack-index, but all of their objects are pointing to the new pack-file. Any Git processes looking at the new multi-pack-index will never read from the old pack-files.</p><blockquote><p> <b>Concrete results for Windows</b><br>When we deployed these maintenance steps to the Windows OS developers, we saw that some repositories had <i>thousands</i> of packs that summed to 150-200 gigabytes. These repositories now have fewer than one hundred packs totaling 30-50 gigabytes.</p></blockquote><p>The <code>git multi-pack-index repack</code> command collects a set of small pack-files and creates a new pack-file containing all of the objects the multi-pack-index references from those pack-files. Then, Git adds the new pack-file to the multi-pack-index and updates those object references to point to the new pack-file. We then run <code>git multi-pack-index expire</code> which deletes the pack-files that have no referenced objects. By performing these in two steps, we avoid disrupting other Git commands a user may run in the foreground.</p><h2 id="git-future">Scalar and the future of Git<a href="#git-future"></a></h2><p>We intentionally are making Scalar do <em>less</em> and investing in making Git do <em>more</em>. Scalar is simply a way to get the performance we need today. As Git improves, Scalar can provide a way to transition away from needing Scalar and using only the core Git client.</p><p>Scalar also serves as an example for the kinds of features we need in Git to remove these management layers on top. Here are a few of our planned Git contributions for the coming years.</p><ul><li><p>Scalar relies on a stable and correct filesystem watcher to scale growth in modified size, and Watchman does that decently well. However, Watchman is a much more general tool than we need, and it isn’t “Git aware.” It doesn’t know when a directory matches a <code>.gitignore</code> pattern and that we don’t need to scan it for changes. By creating a custom filesystem watcher in Git itself, we can optimize this interface to our needs.</p></li><li><p>The sparse-checkout feature is how we scale growth in populated size. While <a href="https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/" target="_blank">the recent updates to the sparse-checkout feature</a> made it faster and easier to use, we have a long way to go before that feature is complete.</p></li><li><p>Now that we are using sparse-checkout instead of a virtualized filesystem, we have new bottlenecks for Git commands. In particular, <code>git checkout</code> is not as fast as when using VFS for Git. With virtualization tricks, VFS for Git can act as if the filesystem is updated, delaying the cost of the populated size to later operations. We are investigating a parallel version of <code>git checkout</code> to improve performance.</p></li><li><p>The GVFS protocol allowed Azure Repos to quickly support the Windows OS repository. After that success, a cross-community group created <a href="https://git-scm.com/docs/partial-clone" target="_blank">the partial clone feature in Git</a>. Partial clones do not have a local copy of every reachable object and request missing objects when needed. Partial clone needs a few client-side improvements and support from service providers. When implementing Scalar, we reworked how Git interacts with the GVFS protocol to be inside the partial clone interface, so improvements to one experience will benefit the other. As the Microsoft Office team onboards to Scalar, we expect to find new ways that Git can better interact with partial clone.</p></li><li><p>To truly scale Git services to the demands of thousands of engineers and build machines interacting with a central server, Git needs a notion similar to the GVFS cache servers. It could be as simple as a <code>fetch-objects</code> URL in addition to the <code>fetch</code> and <code>push</code> URLs in the remote config. While the branch updates would still come from the central authority, clients could download the pack-file from the <code>fetch-objects</code> URL. We plan to propose this concept on the mailing list soon.</p></li><li><p>We mentioned earlier how the Git client depends on periodic foreground garbage collection to keep repositories running smoothly. This is simply not feasible for very large repositories, and we plan to contribute a form of background maintenance to the core Git client. This will be an opt-in feature, and we hope to create a command such as <code>git maintenance start</code> that is as easy to use as <code>scalar register</code>.</p></li></ul><p>I will be presenting these ideas and more at <a href="https://git-merge.com/#derrick-stolee" target="_blank">Git Merge 2020</a>, so please check out the livestream at 12:00pm PT on March 4, 2020.</p><p>Please, <a href="https://github.com/microsoft/scalar/releases" target="_blank">give Scalar a try</a> and let us know if it helps you. Is there something it needs to do better? Please <a href="https://github.com/microsoft/scalar/issues" target="_blank">create an issue</a> to provide feedback.</p></div></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>