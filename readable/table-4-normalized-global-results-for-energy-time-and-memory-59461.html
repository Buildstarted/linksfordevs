<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Table 4 . Normalized global results for Energy, Time, and Memory&#xA0; - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Table 4 . Normalized global results for Energy, Time, and Memory&#xA0; - linksfor.dev(s)"/>
    <meta property="article:author" content="Rui Pereira"/>
    <meta property="og:description" content="Download Table | Normalized global results for Energy, Time, and Memory&#xA0; from publication: Energy efficiency across programming languages: how do energy, time, and memory relate? | This paper presents a study of the runtime, memory usage and energy consumption of twenty seven well-known software languages. We monitor the performance of such languages using ten different programming problems, expressed in each of the languages. Our results show... | Programming Languages and Software Engineering | ResearchGate, the professional network for scientists."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://www.researchgate.net/figure/Normalized-global-results-for-Energy-Time-and-Memory_tbl2_320436353"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Table 4 . Normalized global results for Energy, Time, and Memory&#xA0;</title>
<div class="readable">
        <h1>Table 4 . Normalized global results for Energy, Time, and Memory&#xA0;</h1>
            <div>by Rui Pereira</div>
            <div>Reading time: 14-18 minutes</div>
        <div>Posted here: 09 Mar 2020</div>
        <p><a href="https://www.researchgate.net/figure/Normalized-global-results-for-Energy-Time-and-Memory_tbl2_320436353">https://www.researchgate.net/figure/Normalized-global-results-for-Energy-Time-and-Memory_tbl2_320436353</a></p>
        <hr/>
<div id="readability-page-1" class="page"><p><span><div><div><div role="dialog" aria-modal="true" tabindex="-1"><div><div><div><p>We use cookies to offer you a better experience, personalize content, tailor advertising, provide social media features, and better understand the use of our services.</p><p>To learn more or modify/prevent the use of cookies, see our <a target="_blank" rel="noopener" href="https://www.researchgate.net/cookie-consent-policy" data-lite="{&quot;click&quot;:[{&quot;t&quot;:&quot;.gtm-open-cookie-policy-link&quot;,&quot;a&quot;:&quot;tgtm(gtm-ev-cookie-policy)&quot;}]}">Cookie Policy</a> and <a target="_blank" rel="noopener" href="https://www.researchgate.net/privacy-policy" data-lite="{&quot;click&quot;:[{&quot;t&quot;:&quot;.gtm-open-privacy-policy-link&quot;,&quot;a&quot;:&quot;tgtm(gtm-ev-privacy-policy)&quot;}]}">Privacy Policy</a>.</p></div></div></div></div></div></div></span></p><div role="main"><section><div itemscope="" itemtype="http://schema.org/ImageObject"><div><div><div><div><div><meta itemprop="thumbnailUrl" content="https://www.researchgate.net/profile/Jacome_Cunha/publication/320436353/figure/tbl2/AS:631653101744152@1527609243443/Normalized-global-results-for-Energy-Time-and-Memory_Q320.jpg"><p><img src="https://www.researchgate.net/profile/Jacome_Cunha/publication/320436353/figure/tbl2/AS:631653101744152@1527609243443/Normalized-global-results-for-Energy-Time-and-Memory.png" alt="Normalized global results for Energy, Time, and Memory&nbsp;" itemprop="contentUrl"></p></div></div></div></div><div><p>Source publication</p><div itemprop="isPartOf" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p>This paper presents a study of the runtime, memory usage and energy consumption of twenty seven well-known software languages. We monitor the performance of such languages using ten different programming problems, expressed in each of the languages. Our results show interesting findings, such as, slower/faster languages consuming less/more energy,...</p></div></div></div></div></div></div></div><div><div><div><div><p><strong>Context 1</strong></p><p>... at the same example benchmark, Rust, while the most energy efficient, would drop 9 positions if ordered by peak memory usage. <span>Table 4</span> shows the global results (on average) for Energy, Time, and Mb normalized to the most efficient language in that category. Since the pidigits benchmark solutions only contained less than half of the languages covered, we did not consider this one for the global results. ...</p></div><div><p><strong>Context 2</strong></p><p>... observing the data in <span>Table 4</span>, we can see that the C language is, overall, the fastest and most energy efficient. Nevertheless, in some specific benchmarks there are more efficient solutions (for example, in the fasta benchmark it is the third most energy efficient and second fastest). ...</p></div><div><p><strong>Context 3</strong></p><p>... these results, we can try to answer the question raised in RQ2: Is the faster language always the most energy efficient? By looking solely at the overall results, shown in <span>Table 4</span>, we can see that the top 5 most energy efficient languages keep their rank when they are sorted by execution time and with very small differences in both energy and time values. This does not come as a surprise, since in 9 out of 10 benchmark problems, the fastest and most energy efficient programming language was one of the top 3. Additionally, it is common knowledge that these top 3 language (C,C++, and Rust) are known to be heavily optimized and efficient for execution performance, as our data also shows. ...</p></div><div><p><strong>Context 4</strong></p><p>... as time influences energy, we had hypothesized that these languages would also produce efficient energy consumptions as they have a large advantage in one of the variables influencing energy, even if they consumed more power on average. Nevertheless, if we look at the remaining languages in <span>Table 4</span>, we can see that only 4 languages maintain the same energy and time rank (OCaml, Haskel, Racket, and Python), while the remainder are completely shuffled. Additionally, looking at individual benchmarks we see many cases where there is a different order for energy and time. ...</p></div><div><p><strong>Context 5</strong></p><p>... top 5 languages, also presented in <span>Table 4</span>, which needed the least amount of memory space (on average) to exe- cute the solutions were: Pascal (66Mb), Go (69Mb), C (77Mb), Fortran (82Mb), and C++ (88Mb); these are all compiled lan- guages. The bottom 5 languages were: JRuby (1309Mb), Dart (570Mb), Erlang (475Mb), Lua (444Mb), and Perl (437Mb); of these, only Erlang is not an interpreted language. ...</p></div><div><p><strong>Context 6</strong></p><p>... the best of our knowledge, this is the first time such work is presented. Note that we provide the information of each individual charac- teristic in <span>Table 4</span> so the developer can actually understand each particular set (we do not show such information in Ta- ble 5 to avoid cluttering the paper with to many tables with numbers). ...</p></div></div></div></div><div><div><div><div><div itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p>In this work, a malachite green residue detection system for aquaculture monitoring was established. The system includes a new method based on DNA adapter body of malachite green sensor, a handheld electrochemical detector, and the combination of the two, which constitute a set of high performance, convenient and portable malachite green residue de...</p></div></div></div></div></div></div></div></div><div><div><div><div><div><div><div><div><div><div itemprop="citation" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p><span>How a program is written has implications in the energy consumption of the running system, with economical and environmental consequences.
In this context, understanding the energy consumption of operations on data-structures is crucial when optimizing software to execute under power constricted environments. Existing studies have not focused on the different components of energy consumption that processors expose, rather considering the global consumption.
To understand the relationship between CPU and memory energy consumptions with execution time, we instrument a microbenchmark suite to collect such values, and we analyze the results.
Our benchmark suite is comprised of 16 implementations of functional sequences, collections and associative collections while measuring detailed energy and time metrics. We further investigate the energy consumption impact of using different compilation optimizations.
We have concluded that energy consumption is directly proportional to execution time. Additionally, DRAM and Package energy consumptions are directly proportional, with the DRAM representing between 15 and 31% of the total energy consumption. Finally, we also conclude that optimizations can have both a positive or a negative impact on energy consumption.</span></p></div></div></div></div></div></div></div></div></div></div><div><div><div><div><div><div><div itemprop="citation" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p><span>Motivation: Even though many studies examine the energy efficiency of hardware and embedded systems, those that investigate the energy consumption of software applications are still limited, and mostly focused on mobile applications. As modern applications become even more complex and heterogeneous a need arises for methods that can accurately assess their energy consumption.
Goal: Measure the energy consumption and run-time performance of commonly used programming tasks implemented in different programming languages and executed on a variety of platforms to help developers to choose appropriate implementation platforms.
Method: Obtain measurements to calculate the Energy Delay Product, a weighted function that takes into account a task's energy consumption and run-time performance. We perform our tests by calculating the Energy Delay Product of 25 programming tasks, found in the Rosetta Code Repository, which are implemented in 14 programming languages and run on three different computer platforms, a server, a laptop, and an embedded system.
Results: Compiled programming languages are outperforming the interpreted ones for most, but not for all tasks. C, C#, and JavaScript are on average the best performing compiled, semi-compiled, and interpreted programming languages for the Energy Delay Product, and Rust appears to be well-placed for i/o-intensive operations, such as file handling. We also find that a good behaviour, energy-wise, can be the result of clever optimizations and design choices in seemingly unexpected programming languages.</span></p></div></div></div></div></div></div></div></div></div></div><div><div><div><div><div><div><div itemprop="citation" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p><span>MapReduce and its open source implementation, Hadoop, have gained widespread adoption for parallel processing of big data jobs. Since the number of such big data jobs is also rapidly rising, reducing their energy consumption is increasingly more important to reduce environmental impact as well as operational costs. Prior work by Mashayekhy et al. (IEEE Trans. Parallel Distributed Syst. 26, 2720–2733, 2016), has tackled the problem of energy-aware scheduling of a single MapReduce job but we provide a far more efficient heuristic in this paper. We first model the problem as an Integer Linear Program to find the optimal solution using ILP solvers. Then we present a task-based greedy scheduling algorithm, TGSAVE, to select a slot for each task to minimize the total energy consumption of the MapReduce job for big data applications in heterogeneous environments without significant performance loss while satisfying the service level agreement (SLA). We perform several experiments on a Hadoop cluster to measure characteristics of tasks for nine different applications to evaluate our proposed algorithm. The results show that the total energy consumption of MapReduce jobs obtained by TGSAVE is up to 35% less than that achieved by EMRSA proposed in Mashayekhy et al. (IEEE Trans. Parallel Distributed Syst. 26, 2720–2733, 2016), its closest rival, for same workloads. Besides, TGSAVE is capable of finding a solution in same order of time for up to 74% tighter deadlines than the tightest deadline that EMRSA can find a feasible one. On average, TGSAVE solution is approximately 1.4% far from the optimal solution, and it can meet deadlines as tight as 12%, on average, above the energy-oblivious minimum makespan in the benchmarks we examined.</span></p></div></div></div></div></div></div></div></div></div></div><div><div><div><div><div><div><div itemprop="citation" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p><span>Software developers are more and more eager to understand their code’s energy performance. However, even with such knowledge it is di cult to know how to improve the code. Indeed, little tool support exists to understand the energy consumption pro le of a software system and to eventually (automatically) improve its code.
In this paper we present a tool termed jStanley which automatically nds collections in Java programs that can be replaced by others with a positive impact on the energy consumption as well as on the execution time. In seconds, developers obtain information about energy-eager collection usage. jStanley will further suggest alternative collections to improve the code, making it use less time, energy, or a combination of both. The preliminary evaluation we ran using jStanley shows energy gains between 2% and 17%, and a reduction in execution time between 2% and 13%.
A video can be seen at https://greensoftwarelab.github.io/jStanley.</span></p></div></div></div></div></div></div></div></div></div></div><div><div><div><div><div><div><div itemprop="citation" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p><span>The efficiency of a software piece is a key factor for many systems. Real-time programs, critical software, device drivers, kernel OS functions and many other software pieces which are executed thousands or even millions of times per day require a very efficient execution. How this software is built can significantly affect the run time for these programs, since the context is that of compile-once/run-many. In this sense, the optimization flags used during the compilation time are a crucial element for this goal and they could make a big difference in the final execution time. In this paper, we use parallel metaheuristic techniques to automatically decide which optimization flags should be activated during the compilation on a set of benchmarking programs. The using the appropriate flag configuration is a complex combinatorial problem, but our approach is able to adapt the flag tuning to the characteristics of the software, improving the final run times with respect to other spread practices.</span></p></div></div></div></div></div></div></div></div></div></div><div><div><div><div><div><div><div itemprop="citation" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p><span>Data processing is one of the most energy-consuming tasks of computing systems. For both environmental and economical reasons, it is necessary to optimize software programs to be more energy efficient. There has been a lazy versus strict evaluation debate in the community, with a special focus on functional programming, with regards to program speed. Until now there has not been any insight about the impact of the evaluation strategy in energy consumption. We have used micro-benchmarks on lazy and strict implementations of the Map data structure abstraction to understand how execution time and package and RAM energy consumptions are affected by using lazy or strict implementations. This study proposes recommendations for developers to use strict evaluation for most tasks as the default approach, specially when iterating over elements in Maps.</span></p></div></div></div></div></div></div></div></div></div></div><div><div><div><div><div><div><div itemprop="citation" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p><span>The number of mobile devices sold worldwide has exponentially increased in recent years, surpassing that of personal computers in 2011. Such devices daily download and run millions of apps that take advantage of modern hardware features (e.g., multi-core processors, large Organic Light-Emitting Diode—OLED—screens, etc.) to offer exciting user experiences. Clearly, there is a cost to pay in terms of energy consumption and, in particular, of reduced battery life. This has pushed researchers to investigate how to reduce the energy consumption of apps, for example, by optimizing the color palette used in the app’s GUI. Whilst past research in this area aimed at optimizing energy while keeping an acceptable level of contrast, this article proposes an approach, named Gui Energy Multi-objective optiMization for Android apps (GEMMA), for generating color palettes using a multi-objective optimization technique, which produces color solutions optimizing energy consumption and contrast while using consistent colors with respect to the original color palette. The empirical evaluation demonstrates (i) substantial improvements in terms of the three different objectives, (ii) a concrete reduction of the energy consumption as assessed by a hardware power monitor, (iii) the attractiveness of the generated color compositions for apps’ users, and (iv) the suitability of GEMMA to be adopted in industrial contexts.</span></p></div></div></div></div></div></div></div></div></div></div><div><div><div><div><div><div><div itemprop="citation" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p><span>The Internet of Things (IoT) is faced with challenges that require green solutions and energy-efficient paradigms. Architectures (such as ARM) have evolved significantly in recent years, with improvements to processor efficiency, essential for always-on devices, as a focal point. However, as far as software is concerned, few approaches analyse the advantages of writing efficient code when programming IoT devices. Therefore, this proposal aims to improve source code optimization to achieve better execution times. In addition, the importance of various techniques for writing efficient code for Raspberry Pi devices is analysed, with the objective of increasing execution speed. A complete set of tests have been developed exclusively for analysing and measuring the improvements achieved when applying each of these techniques. This will raise awareness of the significant impact the recommended techniques can have.</span></p></div></div></div></div></div></div></div></div></div></div><div><div><div><div><div><div><div itemprop="citation" itemscope="" itemtype="http://schema.org/ScholarlyArticle"><div><div><div><p><span>Recently, energy efficiency has gained attention from researchers interested in optimizing computing resources. Solving real-world problems using optimization techniques (such as metaheuristics) requires a large number of computing resources and time, consuming an enormous amount of energy. However, only a few and limited research efforts in studying the energy consumption of metaheuristics can be found in the existing literature. In particular, genetic algorithms (GAs) are being used so widely to solve a large range of problems in scientific and real-world problems, but hardly found explained in their internal consumption behavior. In the present article, we analyze the energy consumption behavior of such techniques to offer a useful set of findings to researchers in the mentioned domains. We expand our study to include several algorithms and different problems and target the components of the algorithms so that the results are still more appealing for researchers in arbitrary domains of application. Our experiments on the sequential GAs show the controlling role of the fitness operator on energy consumption and also reveal possible energy hot spots in GAs operations, such as mutation operator. Further, our distributed evaluations besides a statistical analysis of the results demonstrate that the communication scheme could highly affect the energy consumption of the parallel evaluations of the GAs.</span></p></div></div></div></div></div></div></div></div></div></div></div></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>