<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Stable Filtering &#xA0;&#x2014;&#xA0; Part 1 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Stable Filtering &#xA0;&#x2014;&#xA0; Part 1 - linksfor.dev(s)"/>
    <meta property="og:description" content="How to make a filter that can be applied millions of times without producing artifacts."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://caseymuratori.com/blog_0035"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="grid">
        <h1>
                <span style="cursor: default" title="linksfor.dev(s) has been running for 1 year! :partypopper:">üéâ</span>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Stable Filtering &#xA0;&#x2014;&#xA0; Part 1</title>
<div class="readable">
        <h1>Stable Filtering &#xA0;&#x2014;&#xA0; Part 1</h1>
        <p>
Reading time: 16-20 minutes        </p>
        <p><a href="https://caseymuratori.com/blog_0035">https://caseymuratori.com/blog_0035</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><div><div><div><p>Since I just finished shipping the web infrastructure for our new web comic <a href="https://meowtheinfinite.com/">Meow the Infinite</a>, I thought it might be a good time to take a break and write up some long-overdue tech articles.  This one is about a filter I designed several years ago, but which does something I‚Äôve never seen discussed in the video compression field, even though it seems like it really should have been.
</p><p>Way back in 2011, I designed a ‚Äúhalf-pel filter‚Äù.  This is a special kind of filter that‚Äôs supposed to take an input image and create, as convincingly as possible, what that image would look like if it were shifted <i>exactly half a pixel over</i>.
</p><p>You are probably wondering why anyone would need such a filter.  Well, it turns out they are actually quite common in modern video codecs.  Video codecs use filters like this to grab pieces of previous frames and use them in later frames.  Older codecs used to move frame data only by whole pixels at a time, but newer codecs get fancier and allow half-pixel and quarter-pixel shifting to better handle subtle motions.
</p><p>While analyzing the behavior of motion compensation algorithms using traditional half-pel filter designs, <a href="https://mollyrocket.com/news_0007">Jeff Roberts</a> found they degraded quickly when applied repeatedly to successive frames, forcing the other parts of the video compressor to use more data than necessary to correct the artifacts.  If he turned off these corrections, and just looked at the raw half-pel filter results, it would take an image like this:
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_original_91981ccbe692234f.png 1000w, r/halfpel_original_df19f1d28513f8f4.png 500w, r/halfpel_original_15a326821b7c7041.png 250w" src="https://caseymuratori.com/r/halfpel_original_91981ccbe692234f.png" width="1000" height="284"></p></div></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_h264_060_890ea3fd6125d28c.png 1000w, r/halfpel_h264_060_24843671f80c86cf.png 500w, r/halfpel_h264_060_3224075c793f5a86.png 250w" src="https://caseymuratori.com/r/halfpel_h264_060_890ea3fd6125d28c.png" width="1000" height="284"></p></div></div><div><p>after only a single second of video.  It slid to the side like it should, since each frame moved the image a half pixel over.  But instead of looking like a displaced version of the original image, the result appeared severely mangled.
</p><p>Now, a ‚Äúsingle second of video‚Äù is actually a lot of filter applications &nbsp;‚Äî&nbsp; 60 of them, actually, if it‚Äôs at 60 frames per second.  But ideally we‚Äôd have filters that stand up to this kind of abuse.  If we did, smoothly-scrolling videos wouldn‚Äôt have to be encoded with as many artifact corrections, so they‚Äôd be smaller, or higher quality, or both.
</p><p>If you‚Äôre familiar with video compression, you might rightfully be wondering why you need to apply a half-pel filter more than once anyway.  After all, if you do two half-pel filter applications, you‚Äôve moved by one whole pixel, so why not just use the data from <i>two</i> frames ago and grab <i>that</i>?
</p><p>Well, the answer is two-fold.  First, the more data you need to encode for the fetch, the less compression you get.  So if you start having to encode lots of ‚Äúwhich frame to grab from‚Äù data unnecessarily, you won‚Äôt compress as well.
</p><p>But that‚Äôs not that big a deal.  The real issue is that if you need to grab from prior frames, <i>you have to store them</i>.  Storing 2 prior frames instead of 1 uses, as you might guess, twice as much memory.  This isn‚Äôt a big deal on a modern CPU that has tons of memory and just wouldn‚Äôt care.  But it <i>is</i> a big deal if you‚Äôre trying to be a fast, portable, widely applicable video format that wants to run on devices where memory is tight (cell phones, embedded hardware, etc.)
</p><p>For our purposes, we really didn‚Äôt want to have to store multiple frames for motion compensation just to work around the half-pel filter.  So I was tasked to find out exactly what was going on here, and see if I could design a filter that wouldn‚Äôt have these problems.
</p><p>I had never looked at filters before at all &nbsp;‚Äî&nbsp; literally.  I had no idea how people typically designed them.  Strangely enough, this turned out to be a good thing, because it meant I looked at the problem without a lot of preconceived notions.
</p></div><div><p>What you‚Äôll learn very quickly if you look into half-pel filter design is that the common ones all take the same form: somewhere between 2 and 8 pixels of the input image are sampled and blended together at specific ratios to produce each pixel in the output image.  They differ only by how many input pixels they use (often called ‚Äútaps‚Äù in filter slang) and the ratios at which those pixels are blended.  These ratios are often called the ‚Äúfilter kernel‚Äù, and it‚Äôs all you need to completely define the filter.
</p><p>If you‚Äôre familiar with any kind of image sampling or resampling (like image scaling), then this should sound familiar to you.  The filters are basically the same.  Since video compression is a broad field with lots of research in it, there are obviously many <i>other</i> ways people do motion compensation that has nothing to do with simple filtering.  But the codecs in common use tend to have motion compensation routines that include half-pel filters that are basically the same as image scaling filters: you just take your input pixels, multiply them by some weights, add them together, and you‚Äôve got your output pixels.
</p></div><div><p>The Need for ‚ÄúSharpening‚Äù
</p></div><div><p>OK, so you need to shift an image by a half a pixel.  If you‚Äôre a graphics programmer, but you‚Äôre not particularly familiar with filtering, you might be thinking, ‚Äúbig deal, just bilinearly filter it‚Äù.  That‚Äôs a standard thing we do in graphics when we need to produce in-between values from two inputs, like we‚Äôre doing here.
</p><p>A bilinear filter for an exact half-pixel movement is easy to describe as a filter kernel &nbsp;‚Äî&nbsp; it‚Äôs just this:
</p></div></div><div><div><div><p><wbr><span>// <span>NOTE</span>(casey): Simple bilinear filter</span><wbr></p><p><wbr>BilinearKernel[] <wbr>= {<wbr><span>1.0</span><wbr><wbr>/<wbr><span>2.0</span><wbr>, <wbr><span>1.0</span><wbr><wbr>/<wbr><span>2.0</span><wbr>};</p></div></div></div><div><div><p>It works, but it has some issues.  If your primary goal is high-quality imaging &nbsp;‚Äî&nbsp; which is precisely the goal in video compression &nbsp;‚Äî&nbsp; the bilinear filter isn‚Äôt the best you can do, because it tends to introduce more blurriness into the result than is necessary.  It‚Äôs not <i>much</i>, but it‚Äôs <i>more</i> than other filters you could have used.
</p><p>To give you a visual idea of what I mean, here is a close-up of the walrus eye from the original image after a single application of some common filters:
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_zoom_001_a9b20360fc5985e2.png 335w, r/halfpel_zoom_001_90413bdf8aa21648.png 168w" src="https://caseymuratori.com/r/halfpel_zoom_001_a9b20360fc5985e2.png" width="335" height="70"></p></div></div><div><p>On the far left is the original, and on the far right is bilinear.  In the middle are some widely-used video codec half-pel filters.  Hopefully, if you look closely, you can see that pretty much all the images look similar <i>except for</i> the bilinear, which looks a little bit blurrier.  While it‚Äôs not a huge amount of blurring, it‚Äôs enough that if image quality is your primary goal (like it is in video encoding), you‚Äôd prefer one of the other filters.
</p><p>So how are these other filters ‚Äúkeeping‚Äù the sharpness of the image and avoiding the blur?  Well, recall that the bilinear blur kernel looks like this:
</p></div></div><div><div><div><p><wbr>BilinearKernel[] <wbr>= {<wbr><span>1.0</span><wbr><wbr>/<wbr><span>2.0</span><wbr>, <wbr><span>1.0</span><wbr><wbr>/<wbr><span>2.0</span><wbr>};</p></div></div></div><div><div><p>It‚Äôs very simple.  To shift an image over by half a pixel, you take a pixel and blend it 50% with its neighbor.  That‚Äôs it.  Intuitively, you can imagine how it ‚Äúblurs‚Äù the image, because in places where you might have had a bright white pixel next to a dark black pixel, those two pixels will get averaged together during the bilinear filter, and produce a gray pixel, ‚Äúsoftening‚Äù the edge.  This is happening at every pixel, so literally every place there was a pronounced difference in color or brightness, it is getting smoothed.
</p><p>This is why higher-end video codecs don‚Äôt rely entirely on bilinear filtering for motion compensation (although it may still be used for some parts).  Instead, they prefer filters that try to preserve the sharpness, like this:
</p></div></div><div><div><div><p><wbr><span>// <span>NOTE</span>(casey): Half-pel filters for the industry-standard h.264 and HEVC video codecs</span><wbr></p><p><wbr>h264Kernel[] <wbr>= {<wbr><span>1.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr>-<wbr><span>5.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr><span>20.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr><span>20.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr>-<wbr><span>5.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr><span>1.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>};</p><p><wbr>HEVCKernel[] <wbr>= {<wbr>-<wbr><span>1.0</span><wbr><wbr>/<wbr><span>64.0</span><wbr>, <wbr><span>4.0</span><wbr><wbr>/<wbr><span>64.0</span><wbr>, <wbr>-<wbr><span>11.0</span><wbr><wbr>/<wbr><span>64.0</span><wbr>, <wbr><span>40.0</span><wbr><wbr>/<wbr><span>64.0</span><wbr>, <wbr><span>40</span><wbr><wbr>/<wbr><span>64.0</span><wbr>, <wbr>-<wbr><span>11.0</span><wbr><wbr>/<wbr><span>64.0</span><wbr>, <wbr><span>4.0</span><wbr><wbr>/<wbr><span>64.0</span><wbr>, <wbr>-<wbr><span>1.0</span><wbr><wbr>/<wbr><span>64.0</span><wbr>};</p></div></div></div><div><div><p>As you can see, whereas bilinear filtering only looked at two pixels, these filters look at six (for h.264) or even eight (for HEVC) pixels.  Furthermore, they don‚Äôt just compute basic weighted averages of those pixels &nbsp;‚Äî&nbsp; they use <i>negative</i> weights on some pixels to <i>subtract</i> those pixels away from the other values.
</p><p>Why are they doing this?
</p><p>It‚Äôs actually not that complicated to get a basic understanding: by using both positive and negative weights, and looking at a wider window, the filter is able to take the <i>difference</i> between neighboring pixels into account, and model the sharpness of the two cloest pixels relative to their further-away neighbors.  This allows the result to preserve sharpness where pixels were changing dramatically from their neighbors, while still using averaging to produce plausible values for the ‚Äúhalf pixel‚Äù shift that must necessarily reflect a combination of the pixels from the input.
</p></div><div><p>OK, so, problem solved, right?  Well, perhaps if you‚Äôre only going to perform a single half-pixel shift and call it a day.  But these ‚Äúsharpening‚Äù filters (and I‚Äôm using that term very intentionally here) are actually doing something very dangerous that is <i>essentially equivalent</i> to what bilinear filtering is doing.  They‚Äôre just do a better job of hiding it.
</p><p>Where bilinear filtering <i>reduces</i> the sharpness in an image, these common filters <i>enhance</i> it.  They are actually <i>sharpening</i> the image, just like the ‚Äúsharpen‚Äù operation in your favorite photo editing package might do.  The amount of sharpening is very slight, so if you only run the filter once, you won‚Äôt notice it.  But if you run the filter more than once, it can become quite noticeable.
</p><p>And unfortunately, because this sharpening is procedural and based on the differences between pixels, it <i>creates a feedback loop</i> that will continue to sharpen the same edge over and over and over until it destroys the image.  To make this more concrete, take a look at some examples.
</p><p>Here is the original image on top, with a bilinear filter run for 60 frames on the bottom:
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_original_91981ccbe692234f.png 1000w, r/halfpel_original_df19f1d28513f8f4.png 500w, r/halfpel_original_15a326821b7c7041.png 250w" src="https://caseymuratori.com/r/halfpel_original_91981ccbe692234f.png" width="1000" height="284"></p></div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_bilinear_060_53c1659f788bcf4a.png 1000w, r/halfpel_bilinear_060_ca925ea6205c1af3.png 500w, r/halfpel_bilinear_060_33ceb7855b5c46c3.png 250w" src="https://caseymuratori.com/r/halfpel_bilinear_060_53c1659f788bcf4a.png" width="1000" height="284"></p></div></div><div><p>As we would expect, the blurring just continues to reduce the sharpness of the image until it is quite smooth.  Now here‚Äôs the original on top, and the h.264 half-pel filter run for 60 frames on bottom:
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_original_91981ccbe692234f.png 1000w, r/halfpel_original_df19f1d28513f8f4.png 500w, r/halfpel_original_15a326821b7c7041.png 250w" src="https://caseymuratori.com/r/halfpel_original_91981ccbe692234f.png" width="1000" height="284"></p></div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_h264_060_890ea3fd6125d28c.png 1000w, r/halfpel_h264_060_24843671f80c86cf.png 500w, r/halfpel_h264_060_3224075c793f5a86.png 250w" src="https://caseymuratori.com/r/halfpel_h264_060_890ea3fd6125d28c.png" width="1000" height="284"></p></div></div><div><p>See all the garbage?  It‚Äôs done the same thing as the bilinear ‚Äúblurring out the image‚Äù effect, but <i>in the opposite way</i> &nbsp;‚Äî&nbsp; it has ‚Äúsharpened out the image‚Äù so that every place there were details, there are now severely ringing light/dark patterns.
</p><p>Does the HEVC codec do any better by using 8 pixels?  Well, it does better than h.264, certainly:
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_hevc_060_a65c5d00bfeea8c5.png 1000w, r/halfpel_hevc_060_71df4fe2cc1acd35.png 500w, r/halfpel_hevc_060_ea8ee8021451786a.png 250w" src="https://caseymuratori.com/r/halfpel_hevc_060_a65c5d00bfeea8c5.png" width="1000" height="284"></p></div></div><div><p>but if we crank up the time from 60 frames (1 second) to 120 frames (2 seconds), we can still see that it is clearly feeding back and destroying the image:
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_hevc_120_bf8b9b9a8b970007.png 1000w, r/halfpel_hevc_120_aa86ea1605f27f79.png 500w, r/halfpel_hevc_120_ee4caa4697f050c6.png 250w" src="https://caseymuratori.com/r/halfpel_hevc_120_bf8b9b9a8b970007.png" width="1000" height="284"></p></div></div><div><p>For those of you who like signal processing sorts of things, before we move on to the next section, I‚Äôll also throw in a windowed sinc function (called a Lanczos filter) for reference:
</p></div></div><div><div><div><p><wbr><span>// <span>NOTE</span>(casey): Traditional 6-tap Lanczos filter</span><wbr></p><p><wbr>LanczosKernel[] <wbr>= {<wbr><span>0.02446</span><wbr>, <wbr>-<wbr><span>0.13587</span><wbr>, <wbr><span>0.61141</span><wbr>, <wbr><span>0.61141</span><wbr>, <wbr>-<wbr><span>0.13587</span><wbr>, <wbr><span>0.02446</span><wbr>};</p></div></div></div><div><div><p>Why anyone would care what a ‚Äúwindowed sinc‚Äù looks like here is beyond the scope of the article, but suffice to say, it‚Äôs a popular filter for theoretical reasons so here‚Äôs what it looks like at 60 frames (1 second):
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_lanczos_060_c231b9d2fd935e05.png 1000w, r/halfpel_lanczos_060_b4de21d2ad239a17.png 500w, r/halfpel_lanczos_060_dc0eb91833042878.png 250w" src="https://caseymuratori.com/r/halfpel_lanczos_060_c231b9d2fd935e05.png" width="1000" height="284"></p></div></div><div><p>and at 120 frames (2 seconds):
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_lanczos_120_c2a8b17317ee780.png 1000w, r/halfpel_lanczos_120_b41498e6e241cd8e.png 500w, r/halfpel_lanczos_120_427a8a5800aa4f38.png 250w" src="https://caseymuratori.com/r/halfpel_lanczos_120_c2a8b17317ee780.png" width="1000" height="284"></p></div></div><div><p>Better than h.264, but about the same as HEVC.
</p></div><div><p>How could we do better than h.264, HEVC, and windowed sinc?  And how much better could we do?
</p><p>These are questions I would have <i>expected</i> to see in the video compression literature, and be widely known by video compression experts, but actually &nbsp;‚Äî&nbsp; at least in 2011 &nbsp;‚Äî&nbsp; I don‚Äôt know of anyone who has even stated that this was a problem.  So I was left to my own devices to devise a solution.
</p><p>Fortunately, the problem statement is very straightforward: make a filter that you can apply as many times as possible while keeping the image looking roughly the same as it did when you started.
</p><p>I thought of this definition as ‚Äústable filtering‚Äù, because to me, it could be considered a property of a filter.  A filter is ‚Äústable‚Äù if it does not feed back on itself, so it can be applied over and over and not produce artifacts.  A filter is ‚Äúunstable‚Äù if it produces artifacts that magnify with successive applications, eventually destroying the image.
</p><p>Again, why this isn‚Äôt already a thing in video codec or image processing literature, I don‚Äôt know.  Maybe they have another term for it, but I haven‚Äôt seen it.  The concept of ‚Äúfeedback‚Äù is well established in audio, but it just doesn‚Äôt seem to be a central concern in image processing, perhaps because filters are normally only meant to be applied once?
</p><p>Were I an expert in the field, I would probably have an opinion about all of this, or perhaps even know of the nooks and crannies in the literature where solutions to this problem already exist but aren‚Äôt widely cited.  But as I said at the outset of the article, I‚Äôd never done filter design before, so I was only looking at the common, widely-cited papers (although it‚Äôs worth noting, there was at least one person well-versed in the literature at RAD at the time and he hadn‚Äôt heard of anything like this either).
</p><p>So there I was, having been told in the morning that we needed this filter, and I sat down that afternoon to try to design one.  My approach was simple: I made a program that ran the filter hundreds of times, outputting the image each time, so I could look at the result of long runs.  I then tried various filter coefficients and observed the results.  It was literally just guided trial-and-error.
</p><p>After about an hour, I had zeroed in on the best filter coefficients I could find for this task (with one caveat that I‚Äôll discuss in <a href="https://caseymuratori.com/blog_0036">part 2</a>):
</p></div></div><div><div><div><p><wbr>MyKernel[] <wbr>= {<wbr><span>1.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr>-<wbr><span>4.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr><span>19.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr><span>19.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr>-<wbr><span>4.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>, <wbr><span>1.0</span><wbr><wbr>/<wbr><span>32.0</span><wbr>};</p></div></div></div><div><div><p>This kernel is on the edge between sharpening and blurring.  Because sharpening will always feed back to bright, obvious artifacts, this filter kernel prefers slight blurring so that the image will just appear ‚Äúduller‚Äù.
</p><p>Here‚Äôs what it looks like after 60 frames.  For reference, I‚Äôve shown all the filters in this order: original (no filtering), mine, bilinear, Lanczos, h.264, HEVC:
</p></div><div><p>As you can see, my filter does get a little blurrier than the sharpening filters, but it has no objectionable sharpening artifacts like they do after 60 frames.  However, maybe you would prefer sharpening artifacts to blurring artifacts, so maybe it‚Äôs a toss up for the best sharpening filter (Lanczos) vs. mine.  However, if we go to 120 frames, it becomes no contest:
</p></div><div><p>After 300 frames, every filter other than mine is a joke:
</p></div><div><p>After 600 frames, the joke is even more cruel:
</p></div><div><p>After 900 frames, well, why even bother:
</p></div><div><p>At this point, the natural question would be, is my filter <i>actually</i> stable, or is it just a very slow blur, much slower than bilinear?  If applied perhaps thousands of times, would my filter <i>eventually</i> blur out the image?
</p><p>Surprisingly, the answer appears to be ‚Äúno‚Äù.  Although some blurring is introduced in the first hundred or so applications, it appears to <i>converge</i> to a stable image representation that <i>never</i> degrades thereafter.  Here, for example, is another closeup of the walrus eye:
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_muratori_eye_70ee249352f4d043.png 384w, r/halfpel_muratori_eye_707d34c121caaca.png 192w" src="https://caseymuratori.com/r/halfpel_muratori_eye_70ee249352f4d043.png" width="384" height="64"></p></div></div><div><p>From left to right, that‚Äôs the original, then my filter applied 60 times, 120 times, 300 times, 600 times, and 900 times.  As you can see, the blurring appears to converge to a stable state that no longer degrades, even with hundreds of additional applications of the filter.  Contrast this with windowed sync at the same tap count, and you can see how badly (and quickly!) the artifacts feedback on themselves and create an unusable result:
</p></div><div><div>
<p><img sizes="(min-width: 35.000000em) 35.00rem, 100.00vw" alt="" srcset="r/halfpel_lanczos_eye_65acbcde4185489d.png 384w, r/halfpel_lanczos_eye_7f1bdb981ee394c9.png 192w" src="https://caseymuratori.com/r/halfpel_lanczos_eye_65acbcde4185489d.png" width="384" height="64"></p></div></div><div><p>My filter seems very stable, and also seems to produce the best looking results after successive applications, as compared to any existing filter I have seen.  It seems to have some sort of ‚Äúasymptotic‚Äù property, where it converges to a (boundedly) smoother image quickly and then preserves that smoother image, rather than having an apparently unbounded worst case that degrades to garbage.
</p><p>I have even tried running the filter for a <i>million</i> applications, and it doesn‚Äôt seem to degrade any further than it does after the first few hundred.  Without better mathematical analysis (and I‚Äôve yet to find the math that would work to prove this definitively, although I‚Äôm sure it‚Äôs out there somewhere), I can‚Äôt say for certain that somewhere in the billions or trillions of applications it doesn‚Äôt somehow break.  But within the limits of reasonable testing, I can‚Äôt find any further degradation.
</p></div><div><p>Is This the Best Stable Half-pel Filter for Six Taps?
</p></div><div><p>So the obvious thing to do at this point is to ask, ‚ÄúIs this the best we can do?‚Äù  Intuition would suggest that the answer is ‚Äúno‚Äù, because with literally no background in filter design and a near-complete ignorance of the literature, I came up with this filter after an hour.  One would at least <i>assume</i> that such a short exploration shouldn‚Äôt have found the final-ultimate-best-answer-of-all-champions-majesty filter.
</p><p>Is that assumption correct?  And if it is, what <i>is</i> the final ultimate best answer of all champions?  I‚Äôll cover this in detail in <a href="https://caseymuratori.com/blog_0036">Stable Filtering - Part 2</a>, so stay tuned.
</p><p>&nbsp;‚Äî&nbsp; Casey
</p><p>PS. If you like my blog and want to see what I‚Äôm working on these days, here are some links to my current projects:
</p><table><tbody><tr><td><a href="https://meowtheinfinite.com/"></a></td></tr><tr><td><a href="https://meowtheinfinite.com/">Meow the Infinite</a></td></tr><tr><td>The feline space opera you‚Äôve been waiting for, presented in serial comic form.</td></tr></tbody></table><table><tbody><tr><td><a href="https://handmadehero.org/"></a></td></tr><tr><td><a href="https://handmadehero.org/">Handmade Hero</a></td></tr><tr><td>A complete, professional-quality game and engine, coded from scratch on a live stream.</td></tr></tbody></table><table><tbody><tr><td><a href="https://molly1935.com/"></a></td></tr><tr><td><a href="https://molly1935.com/">1935</a></td></tr><tr><td>A fully interactive story about the criminal underworld of 1930s New York City and the prosecutors charged with bringing them down.</td></tr></tbody></table></div></div></div></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>