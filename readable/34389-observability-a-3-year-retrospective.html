<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Observability &#x2014; A 3-Year Retrospective -
linksfor.dev(s)
    </title>
	<link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <style type="text/css">
        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: transparent;
            height: 100%;
        }

        *, ::after, ::before {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";
            font-size: 1rem;
            font-weight: 400;
            line-height: 1.5;
            color: #60656a;
            text-align: left;
            background-color: #323b44;
        }

        h1 {
            font-size: 6rem;
            font-weight: 300;
            line-height: 1.2;
            margin-top: 0;
            margin-bottom: 0.5rem;
            margin-bottom: 0.5rem
        }

        a {
            color: #007bff;
            color: #ccc;
            text-decoration: none;
            background-color: transparent;
            word-break: break-all;
        }

        .unseen a {
            font-weight: bold;
        }

        h3 {
            margin-top: 0;
            padding-top: 0;
            font-weight: normal;
        }

        .grid {
            -ms-flex-direction: column;
            flex-direction: column;
            width: 1024px;
            margin: 0 auto;
            flex: 1 0 auto;
        }

        .row {
            -ms-flex-direction: row;
            flex-direction: row;
            width: 100%;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            display: -ms-flexbox;
            display: flex;
        }

        .col {
            margin: 0 10px 0 10px;
            box-sizing: border-box;
            vertical-align: top;
        }

        .col-3-of-4, .col-6-of-8, .col-9-of-12 {
            width: calc(75% - 20px);
        }

        .col-1-of-4, .col-2-of-8, .col-3-of-12 {
            width: calc(25% - 20px);
        }

        @media (max-width:1023px) {
            /* big landscape tablets, laptops, and desktops */
            body {
                overflow-x: hidden;
            }

            main {
                width: 99%;
            }

            h1 {
                font-size: 50px;
            }
        }

        .text-right {
            text-align: right;
        }

        footer {
            left: 0;
            width: 100%;
            margin-top: 2em;
            padding: 50px 0;
            text-align: center;
            -moz-box-sizing: border-box;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
        }

        .readable {
            color: #949ba2;
        }

        svg:not(:root).svg-inline--fa {
            color: #60656a;
            overflow: visible;
        }

        .svg-inline--fa.fa-w-12 {
            width: 0.75em;
        }

        svg:not(:root) {
            overflow: hidden;
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -0.125em;
        }

        img {
            max-width: 100%;
        }

        .text-center {
            text-align: center;
        }

        .readable h1 {
            font-size: 2em;
        }
    </style>
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <h1>Observability &#x2014; A 3-Year Retrospective</h1>
    <div class="post-content"> <a href="https://twitter.com/mipsytipsy" class="clearfix infoBlock"> <div class="infoBlockTextBlock"> <div class="infoBlockText">Charity Majors is the co-founder and CTO of Honeycomb.io, provider of tools for engineering and DevOps teams to debug production systems faster and smarter. Previously Charity ran infrastructure at Parse and was an engineering manager at Facebook, where she ran next-generation distributed systems at scale. After leaving Facebook, Charity and her co-founder started Honeycomb to help engineering teams ship code faster and more safely with observability tooling natively designed for this new era of chaotic, ephemeral, loosely coupled distributed systems. Charity is the co-author of Database Reliability Engineering (O&apos;Reilly) and is devoted to a world where every engineer is on call and nobody thinks on call sucks. </div> </div> </a>
<p>Like so many other terms in software engineering, &#x201C;observability&#x201D; is a term borrowed from an older physical discipline: in this case, control systems engineering. Observability is the mathematical dual of controllability.</p>
<p><em>&#x201C;Less formally, this means that one can determine the behavior of the entire system from the system&#x2019;s outputs. If a system is not observable, this means that the current values of some of its state variables cannot be determined through output</em> <a href="https://en.wikipedia.org/wiki/Sensors" class="ext-link"><em>sensors</em></a><em>.&#x201D;</em></p>
<p>Before we can understand why observability is a meaningful technical term and not just a product marketing term, we need to understand some things about monitoring, metrics, events, and a brief history of how we have tried to make sense of our systems. We need to understand how the world has changed to understand why this, why now.</p>
<p>Ever since there have been terminals and high-level computer languages, there have been logs: strings outputted to a human-readable device, to help humans understand what was happening. Next came early text-based systems packages sysstat, sar, iostat, netstat, mpstat etc. which are still the best way to understand single node performance. Then in 1988 SNMPv1 was born &#x2014; the first metrics-based telemetry system (that I know of).</p>
<blockquote><p>Metrics do not equal observability.</p></blockquote>
<p>Metrics have ruled the day since the 80s: snmp, rrdtool, cacti, Ganglia, <a href="https://codeascraft.com/2011/02/15/measure-anything-measure-everything/" class="ext-link">Etsy&#x2019;s monumentally influential</a> statsd. Their modern successors include SignalFX, DataDog, Wavefront, among others. The user experience has come a long way, but all of these tools are built atop the metric <em>as unit of work</em>: a single number, with tags appended so you can slice and dice, group and locate various metrics and their sources.</p>
<p>A request making its way through your code might emit dozens or even hundreds of metrics before it&#x2019;s finished &#x2014; gauges, counters, and other numbers that represent details like CPU load, resident memory size, I/O stats, etc. and tagged with information like build ID, AWS region, and so forth. Metrics typically get aggregated at write time and lose granularity as they age out, which makes them very efficient to collect and store. Metrics are still the dominant way to understand how your infrastructure system as a whole is behaving, and probably always will be. But don&#x2019;t miss that note above about &#x201C;lose granularity&#x201D; &#x2014; it&#x2019;s important to keep in mind because we&#x2019;ll get back to it; metrics do not equal observability.</p>
<h3>The &#x2018;00s Spawned a New Vendor Breed: APM</h3>
<p>About 10 years ago, a crop of new providers emerged under the APM (Application Performance Management) umbrella. NewRelic, AppDynamics, and others billed as a better way to understand your application code. Instead of using an agent, you might install their libraries in your code, which would then track requests and report on language internals as well as request specifics. They usefully generate lots of top-10 lists so you could understand where your performance problems were coming from &#x2014; by endpoint, by query, and so forth.</p>
<p>These tools were a major step forward. They were still mostly metrics-based under the hood, but the perspective shift from third-party observer to the first-person observer allowed for far greater introspection of your software and its behavior.</p>
<p>Tools have come a long way. Yet still just five short years ago when I was at Parse (subsequently acquired by Facebook) grappling with a platform that was going down constantly and suffering from unpredictable co-tenancy problems, I tried all of these tools and more, and none of them helped resolve system performance and reliability. Let me repeat: none of them did what they claimed to do. This isn&#x2019;t because they lied or misrepresented themselves, it&#x2019;s because <em>the kinds of systems we were building were fundamentally different than the systems those tools were developed to understand</em>. Parse was an early adopter of a lot of trends which are still relatively cutting edge, and more and more people are now experiencing the consternation and frustration that I did during that time. These older tools, once revolutionary, simply no longer work for our current systems.</p>
<h3>Cardinality and Its Relation to Complex Distributed Systems</h3>
<p>To fully grasp the &#x201C;why&#x201D; &#x2014; first you need to understand how today&#x2019;s systems we are building are different (and why), and core to that is understanding something called cardinality.</p>
<p>Cardinality refers to the number of unique items in a set. Any unique ID will always be the highest possible cardinality, and a single value will always be the lowest possible cardinality. If you had a collection of a hundred million user records, you can guess confidently that Social Security numbers will have the highest possible cardinality; first name and last name will be high cardinality, though lower (because some names repeat); gender will be fairly low-cardinality, and &#x201C;Species: human&#x201D; will, presumably, be the lowest possible cardinality, should you actually bother to record it.</p>
<h3>Without Access to High Cardinality Data, Good Luck Debugging</h3>
<p>Why does this matter? Because <em>high-cardinality information is the most useful data for debugging</em> or understanding a system (think user IDs, shopping cart IDs, request IDs &#x2026; basically any IDs and also instances, container, build number, span ID, etc). Unique IDs will always do the best job of identifying individual needles in a given haystack.</p>
<p>Yet metrics-based tooling systems can only deal with <em>low-cardinality dimensions at scale</em>. If you have even merely hundreds of hosts, you can&#x2019;t put the hostname in as an identifying tag, or you&#x2019;ll blow out your cardinality key-space. Likewise, for every question you want to ask with a metrics-based tool, you have to decide to ask it in advance so the answer can be written out at write time. This means a) if you want to ask any new question after the fact, you can&#x2019;t, and b) cost goes up linearly with the number of questions you want to be able to ask(!).</p>
<blockquote><p>When we blew up the monolith into many services, we lost the ability to step through our code with a debugger: it now hops the network.&#xA0; Our tools are still coming to grips with this seismic shift.</p></blockquote>
<p>For a long time, this didn&#x2019;t matter so much, because high-cardinality dimensions were pretty rare. With a typical monolithic system, you had a single app tier and one database. All the interesting logic was hidden inside the application code, where you could step through it with a debugger like gdb. You could look at your dashboards and intuit instantly which of the three, four, five monolithic components was at fault, when faced with an issue to troubleshoot.</p>
<p>This is increasingly untrue. Look at all the infra/architecture trends of the past five-plus years. Containers, schedulers, microservices, polyglot persistence, mesh routing, ephemeral auto-scaling instances, serverless, lambda functions. A request may do 20-30 hops after your edge &#x2014; or a multiple or two of that if you count database queries. Suddenly, the hardest thing about debugging systems is no longer understanding how the code runs but finding <em>where in your system is the code with the problem</em>. You usually can&#x2019;t just look at a dashboard or service map and see which node or service or component is slow because it loops back into itself &#x2014; when anything gets slow, EVERYTHING gets slow. Today&#x2019;s modern cloud native environment is essentially a platform, meaning the code &#x201C;inside&#x201D; and queries may not even be under a single team&#x2019;s control.</p>
<p>When we blew up the monolith into many services, we lost the ability to step through our code with a debugger: it now hops the network.&#xA0; Our tools are still coming to grips with this seismic shift.</p>
<p>Back at Parse, a user might complain: &#x201C;Parse is down!&#x201D; Our monitoring tools would clearly show that Parse was not down. So what was the user&#x2019;s complaining about? Well, we would dispatch someone to investigate, but it was not entirely clear; developers were able to upload their own code and queries and we had to make them work, on hardware shared with hundreds of thousands of other neighboring apps. So the problem could be a) a code change or query of theirs, b) a code change or query of ours, c) some intersection of the two, d) some code change or query of a user sharing resources with the complaining user, e) some code change or query we did which affected a user sharing resources with them, f) any intersection of the above. Oh, and we had over a million apps, we shipped code constantly which affected all of them, and each of them had their own entire ecosystem of users and shipped their own code which affected their own users constantly.</p>
<p>Good times.</p>
<p>Monitoring tools are effective for systems with a stable set of known-unknowns, and relatively few unknown-unknowns. For a system with predominantly unknown-unknowns, monitoring tools were all but useless. We literally had to debug them by hand, painfully and slowly. It would often take a day or more to track down a user&#x2019;s complaint, or to decide if it was actually on &#x201C;their&#x201D; side. The solution that finally saved our asses was Facebook&#x2019;s Scuba which we started to use once Parse was acquired. We started feeding datasets into Scuba, and were able to slice and dice data by ad hoc dimensions &#x2014; by userID, then endpoint, then query, etc. This dropped the time it took for us to identify a problem down from a day or more to &#x2026; seconds, usually, or a small number of minutes.</p>
<p>This experience made a deep impression on me, though I had no words to describe it at the time. It wasn&#x2019;t until I stumbled across the term &#x201C;observability&#x201D;, and looked up its origin, that I realized how much it had to teach us about building understandable software systems.</p>
<h2>What Observability Looks Like in Practice</h2>
<p>With that trip down memory lane, let&#x2019;s revisit the definition:</p>
<p><strong><em>Observability</em></strong><em> is a measure of how well internal states of a</em> <a href="https://en.wikipedia.org/wiki/System" class="ext-link"><em>system</em></a><em> can be inferred from knowledge of its external outputs.</em></p>
<p><em>Less formally, this means that one can determine the behavior of the entire system from the system&#x2019;s outputs. If a system is not observable, this means that the current values of some of its state variables cannot be determined through output</em> <a href="https://en.wikipedia.org/wiki/Sensors" class="ext-link"><em>sensors</em></a><em>.</em></p>
<p>When you&#x2019;re flipping through a bunch of dashboards trying to figure out what&#x2019;s happening, you aren&#x2019;t inspecting what&#x2019;s happening and reasoning about it, or following a trail of meaningful breadcrumbs. You&#x2019;re jumping straight to the end &#x2014; a guess. It&#x2019;s as though the entire system were still a big black box, and you had no information to reason about what happened in what sequence. Your mental process probably looks something like this:</p>
<p><em>I see a huge spike in errors at the edge at 2 p.m. today. That&#x2019;s unexpected and is probably bad. It looks like it correlates with a spike in errors to this particular DB cluster. Last time this happened, it was because someone was running a bad long-running write query, which held a contentious lock and then replicated the same write to the followers. I am going to check for a long-running query and growing queue length around that time to validate my hypothesis. Cool, I found one &#x2014; that confirms my theory.</em></p>
<p>Notice how much it relies on intuitive leaps and your mental library of past outages. Ideally, rather than jump immediately to possible solutions, you would start out at the top with an open mind &#x2014; &#x201C;what happened?&#x201D; and systematically follow the data-driven breadcrumbs to the verifiable solution, whatever it might be. Like this:</p>
<p><em>I see a huge spike in errors at the edge at 2 p.m. today. Let&#x2019;s explore. I will break down by replica set (or endpoint, or user, or literally anything, but let&#x2019;s say replica set for now). Okay, there&#x2019;s a huge spike in errors to replica set 1, and a much smaller spike in errors to two other replica sets, 4 and 5. Interesting. The queue lengths appear to steadily climb through the length of the spike on replica set 1, and bounce up and down through the duration on 4, and just a short spike on 5. There is a long-running query on rs1, and not the other two. I wonder if it&#x2019;s a transient problem with EBS/IOPS &#x2014; so I will break down by replica set node and availability zone, which shows me that they are on different AZs. Cool, ruled that one out. Is it a migration? No, the build_id didn&#x2019;t change. Let me sum up the lock time being held and break down by user_id and sort to see who is holding the lock and for which query &#x2014; AH! this is coming from a background expiration job from cron! It lasted longer on RS1 than RS4/5 because there was more older data there. Let&#x2019;s rework it so it doesn&#x2019;t have to contend for the lock in this way.</em></p>
<p>I&#x2019;m explaining this the long, painful, manual way of narrowing down your hypotheses step by step. Debugging this way involves lots of small, verifiable hypotheses, one after another, like breadcrumbs. It works <em>only</em> because I can break down by every dimension, including ones with very high cardinality. It works <em>only</em> because I have done no pre-aggregation before writing records to disk, in fact, every query I issue aggregates at read time to answer my question. It works <em>only</em> because I have gathered the data at the right level of abstraction, oriented around the request and its units of work &#x2014; because the request is what maps to the user&#x2019;s real lived experience.</p>
<p>Cardinality limitations aren&#x2019;t the only problem with metrics-based systems, either. A metric is a single number with tags appended to it. A request might fire off a dozen or a hundred metrics as it executes &#x2026; but those metrics are all disconnected from each other and can never be reconnected again, unlike an arbitrarily wide event which knits together all the details and context for that request. A lot of debugging consists of looking at an anomalous spike or some other shape, then figuring out what characteristic(s) or outliers the errors all have in common. You cannot do this if you&#x2019;ve already stripped away the connective tissue of the event; then all you can do is guess. That&#x2019;s not debugging, that&#x2019;s magic.</p>
<p>By using events and passing along the full context, conversely I can ask any question of my systems and inspect its internal state, therefore I can understand any state my system has gotten itself into &#x2014; even if I have never seen it before, never conceived of it before! I can understand anything that is happening inside my system, any state it may be in &#x2014; without having to ship new code to handle the state. This is key. This is observability.</p>
<p>You can always understand the things you predicted and checked for. But if you checked for something, that implies you knew to expect it, which creates a Catch-22. The reason monitoring worked so well for so long was, we could predict most of the states our systems would get into. Connections would fill up, CPU would overload, you would need to add more app capacity or tune your database, etc. You could predict most of them, and you&#x2019;d find the rest out the hard way. Systems were relatively stable, and the only unpredictable problems would be the ones triggered by your own team deploying code, which is why so many teams are so terrified of deployments.</p>
<p>A system is observable to the extent that you can understand new internal system states without having to guess, pattern-match, or ship new code to understand that state. This, to me, is the most useful way to extend the control theory concept to software engineering. The ratio of known-unknown system states to unknown-unknown system states is dropping like a rock for most. The unknown-unknowns now rapidly outpace monitoring dashboards capability to explain them to the humans responsible for continuous uptime, reliability and acceptable performance.</p>
<p>This is a technical distinction worth preserving and distinguishing from mere telemetry, because the ability to understand unknown-unknown states is what so many teams currently lack, and that lack is actively hurting them every single day. With modern distributed systems and the platform-ification of services, unknown-unknowns are most of what you will have to deal with for the rest of your life. It&#x2019;s worth getting good at explaining them. It&#x2019;s worth preserving a technical vocabulary for these solutions</p>
<h3>Observability and Its Progenitors</h3>
<p>Over the past three years, there is no doubt that &#x201C;observability&#x201D; has taken off quickly, and in part, this is due to others jumping on the &#x201C;movement&#x201D; in spite of considerable attempts at diluting the term and confusing practitioners. Let&#x2019;s take a step outside and see what happened across the market, following a chronological timeline.</p>
<p>I am not the first person to mention observability in the context of software. The first time I heard the term was when I came across Twitter&#x2019;s monitoring team, then named &#x201C;observability engineering.&#x201D; They used observability as a straight-up synonym for telemetry, as far as I could tell.</p>
<p>The second time I heard the term used was in the article by Cory Watson, &#x201C;<a href="https://www.infoq.com/presentations/stripe-culture-2016/" class="ext-link">Creating a culture of observability at Stripe</a>.&#x201D; Cory was the manager of the Twitter team. That heritage is the only one I am aware of prior to when Honeycomb began adopting, promoting it and building a software solution towards that end.</p>
<p>In parallel, tech titans including Google were developing their own observability platforms, but not calling them &#x201C;observability&#x201D; per <em>se</em>. Those tools, such as Dapper, Monarch, and Dremel, weren&#x2019;t externalized at all, built initially for Google&#x2019;s internal use, until the Google Cloud Platform, came along at which time they needed an external market-driven name for it, and, oh hey look, <a href="https://cloud.google.com/service-monitoring/" class="ext-link">Observability</a> is a thing now? Sometimes it takes a few bigger players to make it a movement.</p>
<p>Honeycomb&#x2019;s principal dev advocate <a href="https://twitter.com/lizthegrey" class="ext-link">Liz Fong-Jones</a>, formerly with Google shared, &#x201C;We were calling what we were doing &#x201C;<a href="https://landing.google.com/sre/sre-book/chapters/evolving-sre-engagement-model/#the-sre-engagement-model-kpsOTpo" class="ext-link">monitoring</a>,&#x201D; <a href="https://landing.google.com/sre/sre-book/chapters/monitoring-distributed-systems/" class="ext-link">sometimes</a>, except it had moved far beyond what people in the outside world though was &#x201C;monitoring&#x201D; (Nagios, Splunk, etc.). but we also had started using the words &#x201C;observability,&#x201D; &#x201C;observe,&#x201D; &#x201C;observation&#x201D; <a href="https://landing.google.com/sre/sre-book/chapters/effective-troubleshooting/#making-troubleshooting-easier-BVsbsE" class="ext-link">in parallel</a> in the SRE book published March 2016&#x201C;. By November 2017 Google engineer Jaana B. Dogan was <a href="https://medium.com/observability/googles-approach-to-observability-frameworks-c89fc1f0e058" class="ext-link">using</a> &#x201C;observability&#x201D; full-throated, but to refer to systems data that were aggregated, because that was what worked for us at that scale.</p>
<p>Honeycomb was founded on Jan. 1, 2016. We spent the first year building the storage engine and query planner, laying a strong foundation for Honeycomb&#x2019;s product that would scale without compromising on cardinality limits. Halfway through 2016, I was tied up in knots trying to figure out how to describe what we were doing and the impact it would make to software engineering teams living through the pain I witnessed firsthand at Parse/Facebook. Early efforts &#x201C;Business Intelligence for systems,&#x201D; &#x201C;strace for distributed systems&#x201D; didn&#x2019;t quite get the impact I was looking for and just seemed a little too narrow at the time. According to my chat logs, I looked up the definition of observability in July 2016, and began talking about it nonstop after that.</p>
<p>As a harbinger of the coming storm, <span class="css-901oao css-16my406 css-bfa6kz r-hkyrab r-1qd0xha r-1vr29t4 r-ad9z0x r-bcqeeo r-3s2u2q r-qvutc0"><span class="css-901oao css-16my406 r-1qd0xha r-ad9z0x r-bcqeeo r-qvutc0">Gregory Poirier</span></span> sounded off at Monitorama in June 2016 about the struggles of folks trying to run production systems using the then-state of the art in a talk titled &#x201C;<a href="https://vimeo.com/173610062" class="ext-link">Monitoring Is Dead</a>.&#x201D;</p>
<p>In May of 2017, I gave a talk at Monitorama called &#x201C;<a href="https://vimeo.com/221055194" class="ext-link">Monitoring: A Post Mortem</a>&#x201D; where I talked about the cardinality limitations and other inherent problems with the monitoring model, and on the last slide welcomed everyone back next year to &#x201C;observability-orama&#x201D;. As you&#x2019;d expect, it made some people grumpy on Twitter.</p>
<p>And in September &#x2018;17, engineer Cindy Sridharan wrote an influential piece on observability, where she mostly adopted our frame and shone more light on the difference between known-unknowns and unknown-unknowns). This validated what we had begun to realize, which was that there was a deep well of growing dissatisfaction with monitoring, APM, and Logs tools &#x2014; they simply no longer met people&#x2019;s needs. Engineers were extremely receptive to the way we described the problems with monitoring software, and were ready, willing and eager to hear about what was next and how it was going to solve the issues faced every day that were on the rise.</p>
<p>In 2017, Peter Bourgon also published an article saying that observability has three pillars. While vendors eagerly latched on to this alternate definition, I&#x2019;ll let Ben Sigelman of Lightstep refute this most thoroughly<a href="https://lightstep.com/blog/three-pillars-zero-answers-towards-new-scorecard-observability/" class="ext-link"> here</a>.</p>
<p>In 2018, the QCon conference added an &#x201C;observability&#x201D; track to its conference. The <a href="https://serverlessconf.io/" class="ext-link">Serverlessconf</a> series was also an early and enthusiastic adopter of observability &#x2014; which makes perfect sense because there are characteristics of serverless that align perfectly with the newer model: viewing the world purely through the lens of your instrumentation, not logging to disk, aggregating lots of information densely by request, etc.</p>
<p>Microservices communities and Kubernetes adopters were also early and quick to embrace observability. Because once you&#x2019;ve blown up (or decomposed) the monolith, most of your &#x201C;traditional&#x201D; debugging tools no longer work. You have to return to first principles and make all these decisions again and aggregation on the request ID becomes of paramount importance; the hardest part is figuring out where the problem is in your distributed system, not debugging the code itself.</p>
<p>And between 2017 and 2018, literally every vendor in the monitoring, APM and log management market segments added the term observability to their content, sites and marketing language. Which brings us to the next section on how many misuse observability and misguide others.</p>
<h3>How Observability&#x2019;s Purpose and Value Have Been Misrepresented</h3>
<p>In early 2018 I noticed that vendors had latched on to &#x201C;distributed tracing, metrics, and logs&#x201D; as &#x201C;three pillars of observability.&#x201D; Ben Sigelman neatly <a href="https://lightstep.com/blog/three-pillars-zero-answers-towards-new-scorecard-observability/" class="ext-link">debunked</a> this, saying: <em>it makes no sense because those are just three data types. You may achieve [observability] with all three, or none &#x2014; what matters is what you do with the data, not the data itself.</em></p>
<p>If you attend an industry conference today, you&#x2019;re likely to hear the speakers adhere to the accurate definition &#x2014; that observability is how you explain unknown-unknowns, that it&#x2019;s about exploration and debugging instead of dashboards and pattern matching or accessing certain data types. I am impressed and delighted that practitioners have remained mostly impervious to the blanket marketing being done by so many tool vendors pushing the &#x201C;three pillars&#x201D; definition on users, yet I wonder how much longer they can hold true against the millions of dollars of ad spend deployed with the goal of shipping more software and increasing spend. I&#x2019;m hopeful and I&#x2019;m not sure if this is just the &#x201C;elites&#x201D; or if the more technical definition is finally trickling down to the general population &#x2014; but I do see early signs of that now over the past 6 months.</p>
<p>I am sometimes criticized for using observability as my own product marketing term and policing its definition. People accuse me of defining observability to mean &#x201C;the set of features that make up honeycomb.&#x201D; It&#x2019;s a fair criticism! but they get the causation backward. Instead of defining observability as &#x201C;what honeycomb does,&#x201D; observability came first. I spent years grappling with these problems, and months stewing over the observability definition and the side effects, the implications for an observability solution. For example, observability is impossible without:</p>
<ul>
<li>raw events</li>
<li>high cardinality dimensions</li>
<li>no pre-aggregation, no pre-indexing (which lock you into asking predefined questions)</li>
<li>read time aggregation</li>
<li>arbitrarily wide events</li>
<li>schema-less-ness</li>
<li>structured data</li>
<li>oriented around the lifecycle of the request</li>
<li>batched up context</li>
<li>not metrics-based</li>
<li>static dashboards don&#x2019;t work, it must be exploratory</li>
<li>etc.</li>
</ul>
<p>And then we built honeycomb precisely to that spec.</p>
<p>Hell yes, I will police how people use it to some extent &#x2014; I desperately want it to be a real technical term with real meaning. We <em>need</em> that specific technical language to grapple the problems we face as software engineering teams. We do not need another synonym for telemetry; of those we already have plenty.</p>
<p>If we do not appropriate &#x201C;observability&#x201D; to denote the differences between known unknowns and unknown-unknowns, between passive monitoring and exploratory debugging, it is not clear what other terms are available to us (and unclear that the same fate will not befall them). I believe it will set the industry back by years if we cannot clearly articulate the (substantial) technical differences between monitoring and observability. But this will be up to the engineers in the field, the only people with the ability to hold vendors accountable for their language &#x2014; or not.</p>
<h3>The Future of Observability</h3>
<p>Three short years into this ride, I ponder the question; <em>What&#x2019;s next and where will this movement take us</em>? I believe that in the next ~3 years, all three of those categories &#x2014; APM, monitoring/metrics, logs, and possibly others &#x2014; are likely to cease to exist. There will only be one category: observability. And it will contain all the insights you need to understand any state your system can get itself into.</p>
<p>After all, metrics, logs, and traces can trivially be derived from arbitrarily wide structured events; the reverse is not true.</p>
<p>Users are going to start to figure out that they are paying multiple times to store single data sets they should only have to store once. There is no reason to invest budget with separate monitoring vendors, logs vendors, tracing vendors, or APM vendors. If you collect data in arbitrarily wide structured events, you can infer metrics from those, and if you automatically append some simple span identifiers, you can use those same events for tracing views. Not only can you cut spending by 3-4X, but it&#x2019;s phenomenally more powerful if you can use a single tool and fluidly flip back and forth between the big picture (&#x201C;there&#x2019;s a spike&#x201D;) and drilling down to the exact raw events with the errors. Next, compute what outlier values they have in common, trace one of them, locate wherein the trace a problem lives, and figure out who else is impacted by that specific outlier behavior. All conducted in one single solution with all teams getting the same level of visibility.</p>
<p>Right now this is either a) impossible, or b) a human being has to copy-paste an ID from one system to another to the next. This is wasteful, slow, and cumbersome, and extremely frustrating for the teams that have to do this when trying to solve a problem. Tools create silos and siloed teams spend too much time arguing about the nature of reality instead of the problem at hand.</p>
<h3>Engage in Constant Conversation with Your Code</h3>
<p>We are putting software engineers on call, and empowering them to truly understand their own code in production. We enable and empower engineers to test in prod, experiment with chaos engineering, feature flags, and other modern practices.</p>
<p>Three years ago, this was an active argument in the industry.&#xA0; These battles are over; now we know the only way to build quality services is to empower software engineers to own their code all the way into production. All that&#x2019;s left is the implementation, which is in progress and will continue to take place over the next decade or so as our industry continues to drive providers to deliver services at scale.</p>
<h3>For Engineers &#x2026; but also Engineering-adjacent Teams</h3>
<p>I also think that after mastering this for engineering that builds it, improves it, and maintains it &#x2014; after getting that tight, virtuous feedback loop of &#x201C;verifying that what I shipped is behaving the way I expected it to, nothing else looks weird,&#x201D; and after successfully putting developers on call &#x2014; the next frontier is exposing real production insights to engineering-adjacent teams. Support, customer service, product managers, and even business owners of those systems stand to gain from a deeper understanding of what&#x2019;s happening with business-critical applications. Tools create silos &#x2014; if your team uses one tool, and another team uses a different tool, you don&#x2019;t share the same view of reality. You will spend a lot of time disagreeing over what you deem reality before even getting to resolving the real issue.</p>
<p>We can empower other teams to do vast amounts of debugging and problem-solving without even involving the engineers. Imagine a templated set of questions for a support team to plug a user-ID into and check to see if the complaint matches a known bug or has already been fixed, or if the complaint is even real, before opening a ticket and escalating to engineers. Imagine all the time you spend on-call digging around in prod to answer questions for other people. Now imagine you don&#x2019;t have to do any of that.</p>
<p>Everyone wins the closer they get to understanding production.</p>
<h2>TLDR &#x2026; It&#x2019;s Still about the People.</h2>
<p>This battle will be won by whoever can deliver the best end-user experience. As Mike Julian said in his <a href="https://monitoring.love/articles/2019-predictions/" class="ext-link">Monitoring and Observability 2019 Predictions</a>, history, social sharing, and learning from each other across disparate teams are necessary to make distributed systems understandable and tractable.</p>
<p>AI and ML are powerful (and possibly even dangerous) tools, but too many organizations are running the risk of putting the horse before the carriage. Any machine can detect a spike, but only a human can tell you if that spike was bad, good, desired, expected, scary. Only a human can derive meaning from numbers.</p>
<p>We believe in Allspaw&#x2019;s declaration that <em>debugging must forever be a human-centered process</em>. Our aim should be to make it as pleasant and collaborative a process as possible.</p>
<p class="attribution">Feature image <a href="https://pixabay.com/illustrations/cube-geometry-construction-model-2366515/" class="ext-link">via</a> Pixabay.</p> </div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2019 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
    </footer>
    
</body>
</html>