<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Thinking about Algorithmic problems - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Thinking about Algorithmic problems - linksfor.dev(s)"/>
    <meta property="og:description" content="The three most important qualities of a programmer can be summarized as follows: Algorithmic thinking. Code design. Mastery of the language of choice. In this posting we will discuss algorithmic th&#x2026;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="http://codingismycraft.com/index.php/2020/07/02/thinking-about-algorithmic-problems/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Thinking about Algorithmic problems</title>
<div class="readable">
        <h1>Thinking about Algorithmic problems</h1>
            <div>Reading time: 12-15 minutes</div>
        <div>Posted here: 03 Jul 2020</div>
        <p><a href="http://codingismycraft.com/index.php/2020/07/02/thinking-about-algorithmic-problems/">http://codingismycraft.com/index.php/2020/07/02/thinking-about-algorithmic-problems/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>The three most important qualities of a programmer can be summarized as follows:</p>
<ul>
<li>Algorithmic thinking.</li>
<li>Code design.</li>
<li>Mastery of the language of choice.</li>
</ul>
<p>In this posting we will discuss <strong>algorithmic thinking</strong> and try to propose a way of thinking that might become helpful when trying to solve a problem that does not have an obvious solution and some level or <strong>improvisation</strong> is required.</p>
<p>The ability to solve problems that require the <strong>invention</strong> of a new algorithm combined with the skill of recognizing cases that can be solved directly by a “standard” one is one of the strongest signs of programming expertise and talent.</p>
<p>Although it is true that the need to create a brand new algorithm does not appear often in our days, it is also equally true that a programmer who has the ability to successfully <strong>combine analytic and synthetic thinking</strong> and efficiently solve a multi-dimensional problem will probably be proven to be more effective than somebody who does not.</p>
<p>Out of the three types of skills that I am mentioning above the one that requires the most <strong>programming talent</strong> is without a doubt the <strong>Algorithmic thinking</strong>; the most successful software companies are convinced about the the truth of this statement and this is why algorithms lie in the core of their interviewing processes.</p>
<p>Although talent is definitely required in most cases it is not enough when facing a new problem; we can certainly be assisted by some “methodical” steps that can serve as the blueprint for the creation of a solution and discussing them is the topic of this posting.</p>
<p>A summary of these “methodical” steps that I am usually following whenever I have to deal with an original problem is the following:</p>
<ul>
<li>Articulate the problem with clarity and try to understand niche cases.</li>
<li>Creating several sets of testing input – output</li>
<li>Code at least one brutal force solution</li>
<li>Study the problem trying to understand it in depth.</li>
<li>Decide if an existing algorithm can solve it directly or a special “trick” is needed;</li>
<li>Can one of the standard methodologies like graph, recursion, dynamic programming or data structures can be used?</li>
</ul>
<p>I will now pick a simple algorithmic problem and try to explain the thought process to solve it.</p>
<h2>The problem</h2>
<p>This is a well known problem that can be found in several websites that specialize on preparing candidates for programming positions.<br>
Assume a water tank which has multiple parallel movable divisors placed in different locations as can be seen in the following picture:</p>

<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/tank.gif?resize=490%2C330" alt="tank" width="490" height="330"></p>

<p>To better understand the picture you have to think that its third dimension is omitted; the blue bars represent the divisors that can be removed. Each divisor is set in a specific distance that cannot change.</p>
<p>The objective is to discover the two divisors that can hold the most water when others will be removed.</p>
<h2>First thoughts</h2>
<p>Now that we have the problem clearly defined, lets pause for a second and try to put together a trivial solution which will solve it without considering its performance.</p>
<p>The fact that we are looking for a <b>pair </b>of divisors makes it obvious that if find all the divisor pairs and calculate the covering areas for each of them and simply select the largest one (we do not need to consider the third dimension since it will be the same for all the pairs.</p>
<p>Before we do any coding and using the picture above we can create the testing data to check our brutal solution and verify it.</p>
<p>Eyeballing the picture we immediately see that there are two candidate solution:</p>
<p>The 3 – 10 pair results to 4 X 7 = 28 while the 3 – 6 pair to 7 X 3 = 21 <strong>so the expected solution will be 28.</strong></p>
<h2>Describe the problem programmatically</h2>
<p>At this point it makes sense to try to describe the problem in a programming language (for this example we will use python).</p>
<p>The first thing that comes to mind is to represent the water tank programmatically.  We can start by introducing a class to hold the coordinates of the upper point of each location:</p>
<div><div id="highlighter_167061"><table><tbody><tr><td><p>1</p><p>2</p></td><td><div><p><code>import</code> <code>collections</code></p><p><code>Point </code><code>=</code> <code>collections.namedtuple(</code><code>"Point"</code><code>, [</code><code>'x'</code><code>, </code><code>'y'</code><code>])</code></p></div></td></tr></tbody></table></div></div>
<p>Now using Point we can represent the tank as follows:</p>
<div><div id="highlighter_615626"><table><tbody><tr><td><p>1</p></td><td><div><p><code>tank </code><code>=</code> <code>[Point(</code><code>1</code><code>, </code><code>3</code><code>), Point(</code><code>3</code><code>, </code><code>9</code><code>), Point(</code><code>6</code><code>, </code><code>7</code><code>), Point(</code><code>10</code><code>, </code><code>4</code><code>)]</code></p></div></td></tr></tbody></table></div></div>
<p>Also we can declare the function to calculate the max_area:</p>
<div><div id="highlighter_248096"><table><tbody><tr><td><p>1</p><p>2</p></td><td><div><p><code>def</code> <code>get_max_area(points):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pass</code></p></div></td></tr></tbody></table></div></div>
<p>Since we already have calculated the expected answer we can add an assertion to validate our solution:</p>
<div><div id="highlighter_495209"><table><tbody><tr><td><p>1</p></td><td><div><p><code>assert</code> <code>get_max_area(tank) </code><code>=</code><code>=</code> <code>28</code></p></div></td></tr></tbody></table></div></div>
<p>At this point our code should look as follows:</p>
<div><div id="highlighter_471238"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p></td><td><div><p><code>import</code> <code>collections</code></p><p><code>Point </code><code>=</code> <code>collections.namedtuple(</code><code>"Point"</code><code>, [</code><code>'x'</code><code>, </code><code>'y'</code><code>])</code></p><p><code>tank </code><code>=</code> <code>[Point(</code><code>1</code><code>, </code><code>3</code><code>), Point(</code><code>3</code><code>, </code><code>9</code><code>), Point(</code><code>6</code><code>, </code><code>7</code><code>), Point(</code><code>10</code><code>, </code><code>4</code><code>)]</code></p><p><code>def</code> <code>get_max_area(tank):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>pass</code></p><p><code>assert</code> <code>get_max_area(tank) </code><code>=</code><code>=</code> <code>28</code></p></div></td></tr></tbody></table></div></div>
<p>If we run the program we should see the following output:</p>
<p><img src="http://i2.wp.com/codingismycraft.com/wp-content/uploads/2020/07/tank-1.gif?resize=678%2C109" alt="tank-1" width="678" height="109"></p>
<h2>A Brutal solution</h2>
<p>Assuming that we are having a pair of Points (representing two divisors) its covered area can be found if we multiply its width by the lower divisor:</p>
<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/tank-2.gif?resize=486%2C328" alt="tank-2" width="486" height="328"></p>
<p>In this example the area will be covered by a 7 X 3 rectangle; 7 is the height of the lower divisor while 3 is the distance between them.</p>
<p>To simplify our solution, we can define a function which will receive two divisors as Points and return the enclosed area:</p>
<div><div id="highlighter_467060"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p></td><td><div><p><code>def</code> <code>get_area(p1, p2):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>width </code><code>=</code> <code>p2.x </code><code>-</code> <code>p1.x </code><code>if</code> <code>p2.x &gt; p1.x </code><code>else</code> <code>p1.x </code><code>-</code> <code>p2.x</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>height </code><code>=</code> <code>min</code><code>(p2.y,&nbsp; p1.y)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>width </code><code>*</code> <code>height</code></p></div></td></tr></tbody></table></div></div>
<p>Now we are ready to implement the brutal solution.  We should simply create all possible pairs of divisors, calculate the area for each of them and return the maximum value:</p>
<div><div id="highlighter_31015"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p></td><td><div><p><code>import</code> <code>collections</code></p><p><code>import</code> <code>itertools</code></p><p><code>Point </code><code>=</code> <code>collections.namedtuple(</code><code>"Point"</code><code>, [</code><code>'x'</code><code>, </code><code>'y'</code><code>])</code></p><p><code>tank </code><code>=</code> <code>[Point(</code><code>1</code><code>, </code><code>3</code><code>), Point(</code><code>3</code><code>, </code><code>9</code><code>), Point(</code><code>6</code><code>, </code><code>7</code><code>), Point(</code><code>10</code><code>, </code><code>4</code><code>)]</code></p><p><code>def</code> <code>get_area(p1, p2):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>width </code><code>=</code> <code>p2.x </code><code>-</code> <code>p1.x </code><code>if</code> <code>p2.x &gt; p1.x </code><code>else</code> <code>p1.x </code><code>-</code> <code>p2.x</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>height </code><code>=</code> <code>min</code><code>(p2.y,&nbsp; p1.y)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>width </code><code>*</code> <code>height</code></p><p><code>def</code> <code>get_max_area(tank):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_area </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>p1, p2 </code><code>in</code> <code>itertools.combinations(tank, </code><code>2</code><code>):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_area </code><code>=</code> <code>max</code><code>(max_area, get_area(p2, p1))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>max_area</code></p><p><code>assert</code> <code>get_max_area(tank) </code><code>=</code><code>=</code> <code>28</code></p></div></td></tr></tbody></table></div></div>
<p>If we run the program above we will see that it completes without an error so our thought process was correct.</p>
<h2>The problem with the brutal solution</h2>
<p>Our brutal solution appears to be correct, so now let’s see how it scales. Let’s go ahead and stress test it by creating a tank that consists of a large number of points and see how it behaves.  To do so we need to write a function to generate random points and call our get_max_area with increasing number of divisors:</p>
<div><div id="highlighter_997777"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p></td><td><div><p><code>import</code> <code>collections</code></p><p><code>import</code> <code>itertools</code></p><p><code>import</code> <code>random</code></p><p><code>import</code> <code>timeit</code></p><p><code>import</code> <code>functools</code></p><p><code>Point </code><code>=</code> <code>collections.namedtuple(</code><code>"Point"</code><code>, [</code><code>'x'</code><code>, </code><code>'y'</code><code>])</code></p><p><code>def</code> <code>get_area(p1, p2):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>width </code><code>=</code> <code>p2.x </code><code>-</code> <code>p1.x </code><code>if</code> <code>p2.x &gt; p1.x </code><code>else</code> <code>p1.x </code><code>-</code> <code>p2.x</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>height </code><code>=</code> <code>min</code><code>(p2.y, p1.y)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>width </code><code>*</code> <code>height</code></p><p><code>def</code> <code>random_points(count, max_height):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>x </code><code>in</code> <code>random.sample(</code><code>range</code><code>(</code><code>1</code><code>, count </code><code>*</code> <code>10</code><code>), count):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>y </code><code>=</code> <code>random.randint(</code><code>1</code><code>, max_height)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>yield</code> <code>Point(x, y)</code></p><p><code>def</code> <code>get_max_area(tank):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_area </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>p1, p2 </code><code>in</code> <code>itertools.combinations(tank, </code><code>2</code><code>):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_area </code><code>=</code> <code>max</code><code>(max_area, get_area(p2, p1))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>max_area</code></p><p><code>for</code> <code>count </code><code>in</code> <code>[</code><code>100</code><code>, </code><code>1000</code><code>, </code><code>5000</code><code>, </code><code>10000</code><code>]:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>tank </code><code>=</code> <code>list</code><code>(random_points(count</code><code>=</code><code>count, max_height</code><code>=</code><code>12</code><code>))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>'count:'</code><code>, count, </code><code>'duration:'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>timeit.timeit(stmt</code><code>=</code><code>functools.partial(get_max_area, tank), number</code><code>=</code><code>1</code><code>)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>)</code></p></div></td></tr></tbody></table></div></div>
<p>So, running the above program resulted on the following output on my computer:</p>
<p><img src="http://i0.wp.com/codingismycraft.com/wp-content/uploads/2020/07/tank-3.gif?resize=599%2C132" alt="tank-3" width="599" height="132"></p>
<p>As you can see although our solution works fast enough when the number of divisors is low it grows very fast and when we are trying 10,000 of them it takes more than 41 seconds!</p>
<p>The poor performance is caused from the fact that we are calculating the area for all the possible pairs.  </p>
<p>We now that the possible combination of n things by k are given by the following formula:</p>
<p><img src="http://i2.wp.com/codingismycraft.com/wp-content/uploads/2020/07/CodeCogsEqn.gif?resize=169%2C44" alt="CodeCogsEqn" width="169" height="44"></p>
<p>So assuming we have 10,000 divisors, the possible pairs will be:</p>
<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/combos.gif?resize=161%2C44" alt="combos" width="161" height="44"></p>
<p>which equals 49,995,000 or in other words it has a time complexity of O(C(n,k)) which results into an extremely slow solution.</p>
<p>At this point we must revisit our problem and think if we can come up with a “smart trick” that will allow us to improve our solution.. Please pause for a while and think our problem again trying to detect if there is something that will allow us to bypass most of the calculations of the brutal solution and then move on to the  explanation of the efficient solution..</p>
<h2>The trick</h2>
<p>Lets revisit our original example and try to go step by step to an efficient solution. This time we will start by calculating the area of the first and last point as can be seen in the following picture:</p>
<p><img src="http://i1.wp.com/codingismycraft.com/wp-content/uploads/2020/07/tank-4.gif?resize=461%2C308" alt="tank-4" width="461" height="308"></p>
<p>The area between the first and the last point is: <strong>3 X (10 – 1) = 27</strong>.</p>
<p>Note that we use the point with the lower height and multiply it by the distance.</p>
<p>The trick arises is exactly here. </p>
<p>Note that for obvious the point with the lower height is impossible to result to a larger area when combined with any other point.  This means that once we have calculated the first – last area in our example we can simply get rid of the first point without having to deal with it anymore. </p>
<p>This is a great improvement over the brutal solution since for it each point (including the first) has to be paired with all the others.  In our example this means that for the brutal solution the first point is matched against all the three others but as we can see we do not need to do so since it is impossible to find a larger area anywhere else except the last point. </p>
<p>Following our observation, we keep the calculated area (27) remove the first point and continue to the next point as can be seen here:</p>
<p><img src="http://i0.wp.com/codingismycraft.com/wp-content/uploads/2020/07/tank-5.gif?resize=455%2C305" alt="tank-5" width="455" height="305"></p>
<p>Note that now the last point is lower that the first; the enclosed area is <strong>4 X (10 – 3) = 28</strong> which replaces the previous maximum area value (was 27).  Thinking in the same way we remove the last point and now our problem looks as follows:</p>
<p><img src="http://i2.wp.com/codingismycraft.com/wp-content/uploads/2020/07/tank-6.gif?resize=453%2C310" alt="tank-6" width="453" height="310"></p>
<p>Now the enclosed area in <strong>7 X (6 -3) = 21</strong> which is less that the previous maximum area which remains 28 while we remove the lower Point and remain with a single point meaning that our problem is over and we have found the solution which is 28.</p>
<h2>The efficient solution</h2>
<p>Now that we have found the <strong>trick</strong> our next step is to re-write our get_max_area function replacing the brutal with the efficient logic:</p>
<div><div id="highlighter_977053"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p></td><td><div><p><code>def</code> <code>get_max_area(tank):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>i1 </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>i2 </code><code>=</code> <code>len</code><code>(tank) </code><code>-</code> <code>1</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_area </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>tank[i1].x &lt; tank[i2].x:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>height </code><code>=</code> <code>min</code><code>(tank[i1].y, tank[i2].y)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>width </code><code>=</code> <code>tank[i2].x </code><code>-</code> <code>tank[i1].x</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_area </code><code>=</code> <code>max</code><code>(max_area, height </code><code>*</code> <code>width)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>tank[i1].y &gt; tank[i2].y:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>i2 </code><code>-</code><code>=</code> <code>1</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code><code>:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>i1 </code><code>+</code><code>=</code> <code>1</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>max_area</code></p></div></td></tr></tbody></table></div></div>
<p>What happens here is simply expressing the steps we have followed before in python code.</p>
<p>* We start with two indexes pointing in the first and last point of the tank and we initialize the max_area to 0. </p>
<p>* Calculate the maximum area between the two indexes and store it if it is larger than the previous  .</p>
<p>* Remove the lower point.</p>
<p>* Continue until the first point passes the second on the horizontal axis. </p>
<p>Now are full code including the testing data and the stress test becomes as follows:</p>
<div><div id="highlighter_554385"><table><tbody><tr><td><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p></td><td><div><p><code>import</code> <code>collections</code></p><p><code>import</code> <code>random</code></p><p><code>import</code> <code>timeit</code></p><p><code>import</code> <code>functools</code></p><p><code>Point </code><code>=</code> <code>collections.namedtuple(</code><code>"Point"</code><code>, [</code><code>'x'</code><code>, </code><code>'y'</code><code>])</code></p><p><code>def</code> <code>random_points(count, max_height):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>for</code> <code>x </code><code>in</code> <code>random.sample(</code><code>range</code><code>(</code><code>1</code><code>, count </code><code>*</code> <code>10</code><code>), count):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>y </code><code>=</code> <code>random.randint(</code><code>1</code><code>, max_height)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>yield</code> <code>Point(x, y)</code></p><p><code>def</code> <code>get_max_area(tank):</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>i1 </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>i2 </code><code>=</code> <code>len</code><code>(tank) </code><code>-</code> <code>1</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_area </code><code>=</code> <code>0</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>while</code> <code>tank[i1].x &lt; tank[i2].x:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>height </code><code>=</code> <code>min</code><code>(tank[i1].y, tank[i2].y)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>width </code><code>=</code> <code>tank[i2].x </code><code>-</code> <code>tank[i1].x</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>max_area </code><code>=</code> <code>max</code><code>(max_area, height </code><code>*</code> <code>width)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>if</code> <code>tank[i1].y &gt; tank[i2].y:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>i2 </code><code>-</code><code>=</code> <code>1</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>else</code><code>:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>i1 </code><code>+</code><code>=</code> <code>1</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>return</code> <code>max_area</code></p><p><code>tank </code><code>=</code> <code>[Point(</code><code>1</code><code>, </code><code>3</code><code>), Point(</code><code>3</code><code>, </code><code>9</code><code>), Point(</code><code>6</code><code>, </code><code>7</code><code>), Point(</code><code>10</code><code>, </code><code>4</code><code>)]</code></p><p><code>assert</code> <code>get_max_area(tank) </code><code>=</code><code>=</code> <code>28</code></p><p><code>for</code> <code>count </code><code>in</code> <code>[</code><code>100</code><code>, </code><code>1000</code><code>, </code><code>5000</code><code>, </code><code>10000</code><code>]:</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>tank </code><code>=</code> <code>list</code><code>(random_points(count</code><code>=</code><code>count, max_height</code><code>=</code><code>12</code><code>))</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>print</code><code>(</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>'count:'</code><code>, count, </code><code>'duration:'</code><code>,</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code>timeit.timeit(stmt</code><code>=</code><code>functools.partial(get_max_area, tank), number</code><code>=</code><code>1</code><code>)</code></p><p><code>&nbsp;&nbsp;&nbsp;&nbsp;</code><code>)</code></p></div></td></tr></tbody></table></div></div>
<p>Running the program has the following output:</p>
<p><img src="http://i2.wp.com/codingismycraft.com/wp-content/uploads/2020/07/track-7.gif?resize=427%2C118" alt="track-7" width="427" height="118"></p>
<p>Note that now the 10,000 points are taking fractions of a second and compare it with the brutal solution to see how much faster this solution is.</p>
<p>The complexity of the efficient solution is O(n) meaning that for 10,000 points it will run approximately 10,000 times faster!</p>
<h2>Concusion</h2>
<p>We were able to create a very fast solution for our problem simply be observing a “trick” that is related to it and allows us to eliminate the overhead of the obvious and brutal solution; the same though pattern must be followed to all the related problems until we discover an efficient solution or conclude that this is impossible.</p>

	</div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs" /></noscript>
</body>
</html>