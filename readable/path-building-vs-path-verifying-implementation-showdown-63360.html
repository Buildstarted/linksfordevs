<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Path Building vs Path Verifying: Implementation Showdown - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Path Building vs Path Verifying: Implementation Showdown - linksfor.dev(s)"/>
    <meta property="article:author" content="https://medium.com/@sleevi_"/>
    <meta property="og:description" content="Disclaimer: This post represents personal opinions and thoughts, and does not represent the views or positions of my employer, Google."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://medium.com/@sleevi_/path-building-vs-path-verifying-implementation-showdown-39a9272b2820"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Path Building vs Path Verifying: Implementation Showdown</title>
<div class="readable">
        <h1>Path Building vs Path Verifying: Implementation Showdown</h1>
            <div>by https://medium.com/@sleevi_</div>
            <div>Reading time: 18-22 minutes</div>
        <div>Posted here: 24 Jun 2020</div>
        <p><a href="https://medium.com/@sleevi_/path-building-vs-path-verifying-implementation-showdown-39a9272b2820">https://medium.com/@sleevi_/path-building-vs-path-verifying-implementation-showdown-39a9272b2820</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><section><div><div><div><div><div><div><p><a rel="noopener" href="https://medium.com/@sleevi_?source=post_page-----39a9272b2820----------------------"><img alt="Ryan Sleevi" src="https://miro.medium.com/fit/c/96/96/0*f7tlX2YUMTyKGtS3.jpeg" width="48" height="48"></a></p></div></div></div></div><p id="aaaa" data-selectable-paragraph=""><em>Disclaimer: This post represents personal opinions and thoughts, and does not represent the views or positions of my employer, Google.</em></p><p id="59c9" data-selectable-paragraph="">In <a target="_blank" rel="noopener" href="https://medium.com/@sleevi_/path-building-vs-path-verifying-the-chain-of-pain-9fbab861d7d6">my previous post</a>, I talked about what the issue with Sectigo’s expired root was, from the perspective of the PKI graph, and talked a bit about what makes a good certificate verifier implementation. Unfortunately, despite browsers and commercial OSes mostly handling this issue, the sheer variety of open-source implementations means that there’s a number of not-so-good verifiers out there.</p><p id="86f6" data-selectable-paragraph="">In this post, I’ll dig in a little deeper, looking at specific implementations, and talking about how their strategies either lead to this issue, or avoided this issue but will lead to other issues.</p><figure><div></div></figure><p id="4de7" data-selectable-paragraph="">While this is not a comprehensive look at every third-party library, nor of every piece of functionality needed to cope with the broader Internet, it is meant to provide a “brief” overview of how different libraries handle this graph problem, and how different design decisions can lead to bad results.</p><p id="38e8" data-selectable-paragraph="">For folks who are interested in fixing these libraries, I cannot stress enough, read RFC 4158. An implementation that considers even those basic strategies is vastly easier to maintain, predict, and secure, both in the short-term and the long-term.</p><p id="4b47" data-selectable-paragraph="">I’ve mostly focused on source analysis, so I very well could have botched something, missing a global config variable, or didn’t look into that One Weird Function, so apologies if that’s the case.</p><h2 id="338e" data-selectable-paragraph="">OpenSSL</h2><p id="7555" data-selectable-paragraph="">OpenSSL’s design does not support path building in any meaningful sense. The bulk of OpenSSL’s path validation logic lives in the <a href="https://github.com/openssl/openssl/blob/670ff08e77c5b331443a3ed6d41564d863a47f06/crypto/x509/x509_vfy.c#L2954" target="_blank" rel="noopener nofollow">build_chain</a> of x509_vfy.c. Despite improvements made during the 1.0.0 series to support <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.10" target="_blank" rel="noopener nofollow">nameConstraints</a>, among others, and 1.1.0’s improvements causing it to actually recognize trust anchors, OpenSSL remains a bit of a case study for how not to verify certificates.</p><ul><li id="8a77" data-selectable-paragraph="">The OpenSSL <a href="https://github.com/openssl/openssl/blob/670ff08e77c5b331443a3ed6d41564d863a47f06/crypto/x509/x509_lu.c#L90" target="_blank" rel="noopener nofollow">public</a> and <a href="https://github.com/openssl/openssl/blob/670ff08e77c5b331443a3ed6d41564d863a47f06/crypto/x509/x509_vfy.c#L320" target="_blank" rel="noopener nofollow">internal APIs</a> assume there is only a singular issuer certificate.</li><li id="d75b" data-selectable-paragraph="">It applies the X.509v3 extensions and application policies (like algorithm checks) <a href="https://github.com/openssl/openssl/blob/670ff08e77c5b331443a3ed6d41564d863a47f06/crypto/x509/x509_vfy.c#L219-L221" target="_blank" rel="noopener nofollow"><em>after</em></a> chain building.</li><li id="f00e" data-selectable-paragraph="">It checks revocation <a href="https://github.com/openssl/openssl/blob/670ff08e77c5b331443a3ed6d41564d863a47f06/crypto/x509/x509_vfy.c#L224" target="_blank" rel="noopener nofollow"><em>after</em></a> chain building.</li></ul><p id="6b53" data-selectable-paragraph="">The overall state machine/algorithm that OpenSSL uses is a bit of a hodge-podge of oddities that can cause issues. For example, CRLs are checked before verifying signatures, which can cause issues with CAs that use multiple public keys with the same name, such as for CA rollover, since they won’t verify the CRL correctly.</p><p id="98b0" data-selectable-paragraph="">The core algorithm has effectively three modes: <strong>trusted-first</strong> (X509_V_FLAG_TRUSTED_FIRST, introduced 1.0.2, default 1.1.x+), <strong>random/server-preference</strong> (X509_V_FLAG_NO_ALT_CHAINS; introduced &gt; 1.0.2b), and <strong>trusted-last</strong> (neither/legacy).</p><p id="fe9e" data-selectable-paragraph="">In all three modes, the verifier starts with the server certificate, and then continues to try to add certificates until it finds a chain that works. In <strong>trusted-first</strong> mode, it’ll search the trusted store first. In <strong>random/server-preference</strong>, it will search the untrusted store. I call this “random” because, as mentioned, the API only supports returning a single certificate for an issuer, so if the peer sends two certificates that match the issuer name in the TLS handshake, it’s “undefined” which you’ll get, at least by API contract. This process continues until a trusted certificate is found.</p><p id="0de3" data-selectable-paragraph="">With <strong>trusted-last</strong>, which is the 1.0.2–1.1.x behavior, if it doesn’t find a path to a trusted root using the random/server-provided method, it works backwards to start cutting off untrusted certificates, trying to replace them with trusted certificates.</p><p id="8fef" data-selectable-paragraph="">The above algorithm reflects the general anti-pattern for certificate verification, which is “append to win”, which is why OpenSSL continues to have issues.</p><p id="4714" data-selectable-paragraph="">For example, the trusted-first mode doesn’t consider the validity period or other attributes of the certificate, as those are verified after the chain has been returned. Using the examples from the previous post, imagine the following two chains: EE←B¹←A¹←Trust Anchor and EE←B¹←A²←C¹←Trust Anchor. For OpenSSL, “←Trust Anchor” just means the previous cert, either A¹ or C¹, is on the filesystem. If A¹ is expired, the <strong>trusted-first</strong> logic will cause validation to fail, because it will ignore the server-supplied A², which it could use to build the chain to C, while <strong>trusted-last</strong> works. Of course, <strong>trusted-last</strong> can have its own issues, as the Sectigo incident shows.</p><p id="add2" data-selectable-paragraph="">OpenSSL does check EKUs, <a href="https://github.com/openssl/openssl/blob/bbc3c22c0e2b3b4b6f069712dc8322a48506b775/crypto/x509/x509_vfy.c#L456" target="_blank" rel="noopener nofollow">by way of</a> calling the X509_check_purpose, and it does seem to check this for the <a href="https://github.com/openssl/openssl/blob/bbc3c22c0e2b3b4b6f069712dc8322a48506b775/crypto/x509/x509_vfy.c#L556-L557" target="_blank" rel="noopener nofollow">entire chain</a>. It will <a href="https://github.com/openssl/openssl/blob/bbc3c22c0e2b3b4b6f069712dc8322a48506b775/crypto/x509/x509_vfy.c#L719" target="_blank" rel="noopener nofollow">check the commonName against nameConstraints</a>, if no DNS name SANs are present, as well as the <a href="https://github.com/openssl/openssl/blob/49a36a528a48bb6b8421b8a0363adb85e63d71fe/crypto/x509/v3_ncons.c#L269-L284" target="_blank" rel="noopener nofollow">emailAddress attribute</a>.</p><h2 id="1d51" data-selectable-paragraph="">LibreSSL</h2><p id="0967" data-selectable-paragraph="">While LibreSSL is very similar to OpenSSL, given their shared ancestry, not all of the changes and refactoring that has happened in OpenSSL has migrated to LibreSSL. LibreSSL still keeps the bulk of the algorithm in <a href="https://github.com/libressl-portable/openbsd/blob/acb6629b569371e05b84fe83ef150cd62f35415c/src/lib/libcrypto/x509/x509_vfy.c#L226" target="_blank" rel="noopener nofollow">X509_verify_cert</a>, and behaves similar to an OpenSSL 1.0.2–1.1.x client (that is, <strong>trusted-last</strong>).</p><p id="ec86" data-selectable-paragraph="">In light of the Sectigo expiration, <a href="https://github.com/libressl-portable/openbsd/commit/3e1824f80e220e5ab685abcff80715fbb392cb1d#diff-027facc0b7c35aa46b0e8fa7b467f1c4" target="_blank" rel="noopener nofollow">a small tweak was made</a>, such that if the only untrusted certificate provided is expired, it will instead search the trust store for an unexpired certificate, before adding the untrusted certificate.</p><p id="9a89" data-selectable-paragraph="">While this tries to split the difference between <strong>trusted-first</strong> and <strong>trusted-last,</strong> the unfortunate shared ancestry with OpenSSL means that it suffers from the same <a href="https://github.com/libressl-portable/openbsd/blob/acb6629b569371e05b84fe83ef150cd62f35415c/src/lib/libcrypto/x509/x509_vfy.c#L537" target="_blank" rel="noopener nofollow">post-chain verification hodge-podge</a>, and so bad things still happen.</p><h2 id="7f01" data-selectable-paragraph="">BoringSSL</h2><p id="ee98" data-selectable-paragraph="">BoringSSL, like LibreSSL, shares a history with OpenSSL that diverged following Heartbleed. Like LibreSSL, there’s still a flow of patches and work in both directions, although the certificate verification <a href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/boringssl/src/crypto/x509/x509_vfy.c;l=184;drc=5cd0724ecbf49d9c530f0c01f17f6b557d6913f9?originalUrl=https:%2F%2Fcs.chromium.org%2F" target="_blank" rel="noopener nofollow">largely remains untouched</a>, as the plan is to move away from the X509* API entirely, as much as possible.</p><p id="9535" data-selectable-paragraph="">BoringSSL currently hasn’t adopted any changes like LibreSSL, although that could change in the future. For now, it’s <strong>trusted-last</strong>.</p><h2 id="c40d" data-selectable-paragraph="">GnuTLS</h2><p id="076a" data-selectable-paragraph="">For all of my criticism for OpenSSL, GnuTLS remains some of the most obnoxiously obtuse certificate verification code I’ve read, and I’ve spent plenty of time tracing Windows assembly in WinDBG debugging Crypt32.dll. It reminds me a bit of <a href="https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition" target="_blank" rel="noopener nofollow">FizzBuzz Enterprise Edition</a>, on first reading.</p><p id="d8a1" data-selectable-paragraph="">My experience with GnuTLS is mostly through seeing research papers discovering cryptographic implementation issues. I was surprised, as in writing up this post, it looks like GnuTLS’s <a href="https://www.gnutls.org/security-new.html" target="_blank" rel="noopener nofollow">advisory page</a> glosses right over <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10844" target="_blank" rel="noopener nofollow">these</a> <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-10846" target="_blank" rel="noopener nofollow">sorts</a> of <a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-16868" target="_blank" rel="noopener nofollow">issues</a>. Having spent time reading through the code, I’m not surprised Tavis was able to find <a href="https://gitlab.com/gnutls/gnutls/-/issues/694" target="_blank" rel="noopener nofollow">low-hanging double-frees</a>.</p><p id="fb77" data-selectable-paragraph="">GnuTLS bashing side, despite its maddening complexity, GnuTLS boils down to a very simple function, even more basic than OpenSSL. According to <a href="https://www.gnutls.org/manual/gnutls.html#Verifying-X_002e509-certificate-paths" target="_blank" rel="noopener nofollow">both the documentation</a> and past <a href="https://lists.gnutls.org/pipermail/gnutls-help/2018-July/004427.html" target="_blank" rel="noopener nofollow">mailing list posts</a>, the entry-point is gnutls_x509_trust_list_verify_crt / <a href="https://gitlab.com/gnutls/gnutls/-/blob/e476e4b7e0de11820123da06ca9fcd0cbb94b8ff/lib/x509/verify-high.c#L1203" target="_blank" rel="noopener nofollow">gnutls_x509_trust_list_verify_crt2</a>. By default, the bulk of path building is handled via <a href="https://gitlab.com/gnutls/gnutls/-/blob/e476e4b7e0de11820123da06ca9fcd0cbb94b8ff/lib/x509/common.c#L1693" target="_blank" rel="noopener nofollow">_gnutls_sort_clist</a>, which orders the untrusted certificates into a sequential chain, to then have trusted certificates added.</p><p id="37f7" data-selectable-paragraph="">While structurally, this would appear similar OpenSSL’s <strong>trusted-last</strong> implementation, the actual implementation goes <strong>trusted-first</strong>, in that after the list is sorted, certificates are swapped with known-trusted variants. When this issue first came to their attention, <a href="https://gitlab.com/gnutls/gnutls/-/commit/299bd4f113d0bd39fa1577a671a04ed7899eff3c" target="_blank" rel="noopener nofollow">a fix similar to LibreSSL’s was adopted</a>, by peeking in the trust store for an unexpired certificate and swapping things out. For GnuTLS, it appears that the bug was a logic bug in the mostly-identical duplicate function _gnutls_pkcs11_verify_crt_status function, which is used to search PKCS#11 tokens for trusted certificates, and evaluated the expiration of the wrong certificate.</p><p id="7b7c" data-selectable-paragraph="">Similar to OpenSSL, the policy checks come at the end of all of this, which can lead to all sorts of sad times when different paths have different policies attached, are revoked, and so on.</p><p id="8824" data-selectable-paragraph="">It does check <a href="https://gitlab.com/gnutls/gnutls/-/blob/e64327a7f78ee183c0766631be171c2d8cd4f042/lib/x509/name_constraints.c#L1218-1245" target="_blank" rel="noopener nofollow">the commonName</a> and emailAddress against nameConstraints, as appropriate, and does make sure <a href="http://_gnutls_check_key_purpose/" target="_blank" rel="noopener nofollow">all of the EKUs chain</a>.</p><p id="e453" data-selectable-paragraph="">I know I was rather critical of OpenSSL above, but in no uncertain terms, I would advise against using GnuTLS. Having spent time reading and tracing the code, it has all the hallmarks of boundless complexity masquerading as flexibility. The abstractions harm readability and debugability, while the actual implementation leaves much to be desired. Heartbleed was a result, in part, of not saying no to needless complexity, and GnuTLS has the similar “code smell” of supporting both everything and nothing at the same time. While OpenSSL got some discipline there, and forks like BoringSSL made their mark by actively rejecting and removing complexity, GnuTLS has the hallmarks of wanting/needing to provide a “stable” ABI for a long time, without the ability or willingness to say no or revisit past decisions.</p><h2 id="e7c5" data-selectable-paragraph="">Botan</h2><p id="177c" data-selectable-paragraph="">Like GnuTLS, most of my experience with Botan is reading about how it once again is vulnerable to some new cryptographic attack that other libraries were immune from. However, since I was asked whether it was affected, I spent some time looking at the code.</p><p id="d39e" data-selectable-paragraph="">Given all of the above remarks about libraries failing, consider my surprise when Botan actually did try to explore <a href="https://github.com/randombit/botan/blob/0349b99244b9cea4098f625e4dcf1d0f10163141/src/lib/x509/x509path.cpp#L846" target="_blank" rel="noopener nofollow">the entire certificate path graph</a> for a valid chain, and incorporated the policy checks for each path as part of the path selection.</p><p id="8c63" data-selectable-paragraph="">It <a href="https://github.com/randombit/botan/blob/cb55fadda1d481448d8edf423fc2879d02f9816f/src/lib/x509/x509_ext.h#L472" target="_blank" rel="noopener nofollow">doesn’t check EKUs</a> as part of chain processing, <a href="https://github.com/randombit/botan/blob/cb55fadda1d481448d8edf423fc2879d02f9816f/src/lib/x509/x509_ext.h#L59-L77" target="_blank" rel="noopener nofollow">as best</a> as I <a href="https://github.com/randombit/botan/blob/e98eb9deb02d4aacca14d947d5a8aab90cf7cf52/src/lib/x509/x509cert.cpp#L564-L565" target="_blank" rel="noopener nofollow">can tell</a>, nor does it seem to apply nameConstraints to the commonName, although it supports commonName fallback.</p><p id="a49f" data-selectable-paragraph="">I wouldn’t recommend Botan, both due to issues like this and the fundamental architecture that lends itself to security vulnerabilities. But beyond the potential security issues, the actual implementation just seems very inefficient, throughout. Reading the code, it begins allocating memory to track every possible path, even before verifying these paths, bringing worst-case performance to the forefront. There’s likely low-hanging memory DoS fruit there. Similarly, during the certificate path processing for nameConstraints, <a href="https://github.com/randombit/botan/blob/0349b99244b9cea4098f625e4dcf1d0f10163141/src/lib/x509/x509path.cpp#L32" target="_blank" rel="noopener nofollow">PKIX::check_chain</a> builds a forward path from the leaf to the root, checking extensions along the way. When it <a href="https://github.com/randombit/botan/blob/0349b99244b9cea4098f625e4dcf1d0f10163141/src/lib/x509/x509path.cpp#L169" target="_blank" rel="noopener nofollow">begins processing</a> a nameConstraint extension, it <a href="https://github.com/randombit/botan/blob/0349b99244b9cea4098f625e4dcf1d0f10163141/src/lib/x509/x509_ext.cpp#L653" target="_blank" rel="noopener nofollow">recomputes and validates the nameConstraints</a> for all of the remainder of the path, burning CPU to constantly recompute the same thing. RFC 4158 talks about how implementations can optimize this, but it feels fairly wasteful to leave this performance on the table. While I didn’t spend any time compiling it and getting it set up, it would be interesting to see how well it fares against test suites like <a href="https://nameconstraints.bettertls.com/" target="_blank" rel="noopener nofollow">BetterTLS</a>, as there were things that just didn’t look right.</p><h2 id="c702" data-selectable-paragraph="">Other Libraries</h2><p id="2be7" data-selectable-paragraph="">While I did look at other libraries, such as BearSSL and yaSSL, it’s not surprising that the IoT-heavy focus of these libraries means they’re intentionally limited in what they support. For IoT, where memory is at a premium, graph traversal means buffering things in memory, which is often anathema to these constrained environments.</p><p id="b18c" data-selectable-paragraph="">To BearSSL’s credit, the limitations and expectations are <a href="https://bearssl.org/x509.html" target="_blank" rel="noopener nofollow">clearly documented</a>. Reading through the code, the X.509v3 verification is streamed as a linear series of certificates, using a trusted-first approach before processing the next certificate. While it’s possible to save these certificates, so that a consumer of the library could implement path building via the chain engine API, that’s not really fitting with the spirit of the library. It also doesn’t process nameConstraints, but that’s not surprising given the complexity.</p><p id="be33" data-selectable-paragraph="">If you are going to use an IoT library, or build an IoT device, then you need to make sure you fully control the client, the server, and all PKIs involved in issuing certificates. Which is to say, avoid using publicly trusted certificates entirely.</p><p id="dd7c" data-selectable-paragraph="">While browsers were, by and large, completely unaffected by the Sectigo expiration, this doesn’t mean they’ve been immune from issues that share a similar root cause.</p><h2 id="ccb6" data-selectable-paragraph="">MacOS Expired Intermediates</h2><p id="04ec" data-selectable-paragraph="">Beginning with macOS 10.12, certificate verification started going through a modern verifier, trustd, which had previously been available on iOS. However, prior to that, the macOS verifier shared many of the same issues as described above. While it supported returning multiple issuer certificates, it didn’t do a full graph analysis, and instead tried to pick the “best”.</p><p id="a384" data-selectable-paragraph="">Unfortunately, sometimes the “best” isn’t good enough, particularly when an <a href="https://blog.digicert.com/expired-intermediate-certificate/" target="_blank" rel="noopener nofollow">expired intermediate is installed in the Keychain</a>, leading to a scenario similar to the OpenSSL <strong>trusted-first</strong> issue.</p><p id="24a3" data-selectable-paragraph="">Considering that Chromium still runs on, supports, and is actively developed for macOS 10.10 and 10.11, it has a <a href="https://source.chromium.org/chromium/chromium/src/+/master:net/cert/cert_verify_proc_mac.cc;l=793;drc=78742234dc8ebff97591d331fabdb7c07875656d?originalUrl=https:%2F%2Fcs.chromium.org%2F" target="_blank" rel="noopener nofollow">giant rat’s nest of complexity</a> to try and work through the various bugs and quirks in the OS verification stack, <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=236112" target="_blank" rel="noopener nofollow">accumulated over the years</a>. While Chromium is in the process of replacing all of this with its own integrated verifier, it highlights that even the OS doesn’t always get things right.</p><h2 id="fb98" data-selectable-paragraph="">NSS: A Tale of Three Verifiers</h2><p id="fb9c" data-selectable-paragraph=""><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS" target="_blank" rel="noopener nofollow">NSS</a>, which is used by Mozilla, actually has three independent certificate verification stacks. “Legacy”, the verifier originally used by Firefox, “libpkix”, a ‘port’ of the Java APIs to C, via 7 layers of preprocessor macros, and “mozilla::pkix”, or “mozpkix”. Each of these verifiers has their own quirks and bugs, although some more intentional than the others.</p><p id="a37b" data-selectable-paragraph="">“legacy” was implemented similar to OpenSSL or GnuTLS, by finding “the” issuer for each certificate along the way. However, the reason Firefox wasn’t all doom and gloom when using this verifier, despite the many bugs it did cause, was that under the hood, NSS actually gathered all issuers, and used a function <a href="https://dxr.mozilla.org/nss/rev/38f1c92a5e1175bb8388768a209ac0efdabd1bd7/nss/lib/pki/pkibase.c#413" target="_blank" rel="noopener nofollow">nssCertificateArray_FindBestCertificate</a> to try to find the certificate path most likely to succeed. A CA could use this logic to gently nudge NSS into finding a path that would work, by manipulating the fields in certificates to cause them to sort better or worse for legacy clients.</p><p id="66dd" data-selectable-paragraph="">“libpkix” was a hand-translation of the concepts found in Java’s PathBuilder/PathVerifier classes, adopted to C, and with heavy use of macros. While Mozilla never switched to it, over concerns around performance and memory usage, except for verifying EV certificates, Chromium launched using this verifier from the get-go. Despite the incredible complexity in reading and maintaining the code, it was a more faithful implementation of RFC 4158 than any other library out there.</p><p id="3df2" data-selectable-paragraph="">While Mozilla considered adopting “libpkix” for Firefox, they looked at the effort spent by the Chromium team maintaining and debugging that code, among many reasons, opted for a ground-up rewrite into a modern verifier, similar to Apple with trustd. This was initially known as “insanity::pkix”, and was later renamed to “mozilla::pkix”, and was lead by Brian Smith while he was still at Mozilla. Brian’s write-up of <a href="https://briansmith.org/insanity-pkix" target="_blank" rel="noopener nofollow">the “why”</a> gives context about the issues with the first two verifiers, and the design work he started there has continued with his Rust implementation of a modern verifier, <a href="https://github.com/briansmith/webpki" target="_blank" rel="noopener nofollow">webpki</a>.</p><p id="f811" data-selectable-paragraph="">Unless you take explicit action to use mozilla::pkix/mozpkix, you’ll likely end up with the legacy verifier. libpkix has been largely demoted to opt-in, but it may still be included by some distros, given that Firefox has moved on from it. The legacy verifier shares many of the faults and foibles of implementations discussed above, and so “use NSS” is not quite the answer as “use mozpkix.”</p><h2 id="9871" data-selectable-paragraph="">Android</h2><p id="57bd" data-selectable-paragraph="">Android has been a complex, and sometimes unfortunate, story. The <a href="https://android.googlesource.com/platform/external/conscrypt/+/a2901b933c152680ca3b1eb628084ea3eef2dff0/common/src/main/java/org/conscrypt/TrustManagerImpl.java#498" target="_blank" rel="noopener nofollow">current implementation</a> uses a recursive algorithm to traverse the graph, using all available certificates to try to find certificate paths that comply with local security policy. While this is still not robust enough to handle the Web at large without errors¹, been a massive improvement over where things were. In Android <a href="https://android.googlesource.com/platform/external/conscrypt/+/381c900af12815e6f0c01519d8ebdd57297303e9" target="_blank" rel="noopener nofollow">releases before Android N</a>, Android used an algorithm similar to many of the libraries above: a <strong>trusted-last</strong> approach that tried to work backwards from the server-supplied chain to a trust anchor, although with its own set of embarrassing <a href="https://android.googlesource.com/platform/external/conscrypt/+/c4ab1b959280413fb11bf4fd7f6b4c2ba38bd779" target="_blank" rel="noopener nofollow">security issues</a>.</p><h2 id="f407" data-selectable-paragraph="">Windows CryptoAPI</h2><p id="5942" data-selectable-paragraph="">Despite CryptoAPI being one of the most robust certificate validators, in part due to it supporting just about every scenario mentioned in RFC 5280 and RFC 4158, it’s not been without its own bugs. CryptoAPI is used throughout Windows, including IE/Edge, although it’s in the process of being phased out in Chromium.</p><p id="8dd0" data-selectable-paragraph="">While <a href="https://marc.info/?l=bugtraq&amp;m=102866120821995&amp;w=2" target="_blank" rel="noopener nofollow">certain bugs</a> are still so astounding that nearly twenty years later it’s still surprising that they even happened, and <a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-0601" target="_blank" rel="noopener nofollow">bugs since then</a> have similarly shocked and amazed, the actual path building and handling has turned out to be <a href="https://docs.microsoft.com/en-us/previous-versions/tn-archive/cc700843(v=technet.10)" target="_blank" rel="noopener nofollow">incredibly robust</a> for a variety of certificate graphs.</p><p id="b62d" data-selectable-paragraph="">The one exception to this is when systems have <a href="https://serverfault.com/questions/752146/why-are-many-admins-using-turn-off-automatic-root-certificates-update-policy" target="_blank" rel="noopener nofollow">Automatic Root Update</a> disabled. When Windows is released, there’s a copy of the root store provided, traditionally as a resource within crypt32.dll. When Windows verifies a certificate chain, and it encounters an untrusted self-signed root, it will check to see if AuthRoot needs to be updated, pulling down a list of hashes of certificates and other attributes, and potentially fetching the trusted root, if needed. When <a href="https://serverfault.com/questions/752146/why-are-many-admins-using-turn-off-automatic-root-certificates-update-policy" target="_blank" rel="noopener nofollow">AuthRoot is disabled</a>, or if the user isn’t able to connect to Microsoft to update, however, this can all fall apart, with clients only able to build paths to expired or no longer valid roots. While this isn’t strictly a path building / path validation issue, it does reflect the necessity that having a robust verifier isn’t sufficient, and regular updates are still necessary.</p><p id="dac2" data-selectable-paragraph="">Despite the length of this post, it has primarily focused on how different libraries build and validate certificate chains, in terms of simply discovering issuers. If the API doesn’t support multiple issuers, questions such as application provided untrusted certificates become irrelevant, because the extra certs aren’t going to help find a valid path. It also limits the value of trust store management, if any change to the trust store could cause otherwise valid certificates to break.</p><p id="d71e" data-selectable-paragraph="">This is all to say that RFC 4158 is a starting point, and not the end goal. However, in order to address many of the security issues that can arise in certificate validation, it’s absolutely critical to support some basic path building via graph traversal. If an implementation supports a graph traversal algorithm, adding additional policies becomes significantly easier, which improves both the security and the robustness of client software. However, the current approaches used by many open-source libraries means that they are themselves some of <a href="https://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html" target="_blank" rel="noopener nofollow">the most dangerous code in the world</a>.</p><p id="2136" data-selectable-paragraph="">There’s a number of libraries that, in the course of <a href="https://twitter.com/sleevi_/status/1272763292168196096" target="_blank" rel="noopener nofollow">tweeting about the research process</a> for this, people were interested in. Is library X bad? Is library Y good? While I answered some of these tweets, my hope is that the analysis and links provided here help people look at how they can evaluate themselves. The biggest signal of doom begins with looking at how issuer certificates are discovered. If only a single certificate can be returned, the implementation is going to have a bad time, so start there.</p><p id="84b3" data-selectable-paragraph="">¹ <a href="https://research.google/pubs/pub46359/" target="_blank" rel="noopener nofollow">Where the Wild Warnings Are: Root Causes of Chrome Certificate Errors</a>, Section 10.3</p></div></div></section></div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>