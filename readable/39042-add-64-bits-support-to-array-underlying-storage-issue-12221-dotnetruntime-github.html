<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Add 64 bits support to Array underlying storage &#xB7; Issue #12221 &#xB7; dotnet/runtime &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Add 64 bits support to Array underlying storage · Issue #12221 · dotnet/runtime · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>It has been proposed that we could make <code>Array.Length</code> and array indices native-sized (<code>nint</code> or <code>IntPtr</code>).</p><p>This would be a portability issue. Code would need to be tested on both bitnesses which currently is rarely required for most codebases. Code on the internet would be subtly broken all the time because developers would only test their own bitness.</p><p>Likely, there will be language level awkwardness when <code>nint</code> and <code>int</code> come into contact. This awkwardness is a main reason unsigned types are not generally used.</p><p>In C languages the zoo of integer types with their loose size guarantees is a pain point.</p><p>I don't think we want to routinely use variable-length types in normal code. If <code>nint</code> is introduced as a type it should be for special situations. Likely, it is most useful as a performance optimization or when interoperating with native code.</p><hr><p>All arrays should transparently support large sizes and large indexing. There should be no <code>LargeArray&lt;T&gt;</code> and no <code>LargeSpan&lt;T&gt;</code> so that we don't bifurcate the type system. This would entail an enormous duplication of APIs that operate on arrays and spans.</p><p>If the object size increase on 32 bit is considered a problem (it might well be) this could be behind a config switch.</p><hr><p>Code, that cares about large arrays needs to switch to <code>long</code>.</p><p>Likely, it will be fine even in the very long term to keep most code on <code>int</code>. In my experience, over all the code I ever worked on, it is quite rare to have large collections. Most collections are somehow related to a concept that is inherently fairly limited. For example, a list of customers will not have billions of items in it except if you work for one of 10 companies in the entire world. They can use <code>long</code>. Luckily for us, our reality is structured so that most types of objects do not exist in amounts of billions.</p><p>I see no realistic way to upgrade the existing collection system to 64 bit indexes. It would create unacceptable compatibility issues. For example, if <code>ICollection&lt;T&gt;.Count</code> becomes 64 bit, all calling code is broken (all arithmetic but also storing indexes somewhere). This must be opt-in.</p><p>It would be nicer to have a more fundamental and more elegant solution. But I think this is the best tradeoff that we can achieve.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>