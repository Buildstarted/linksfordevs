<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Concurrent Reference Counting and Resource Management in Wait-free Constant Time - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Concurrent Reference Counting and Resource Management in Wait-free Constant Time - linksfor.dev(s)"/>
    <meta property="article:author" content="[Submitted on 17 Feb 2020 (v1), last revised 29 Feb 2020 (this version, v2)]"/>
    <meta property="og:description" content="A common problem when implementing concurrent programs is efficiently&#xA;protecting against unsafe races between processes reading and then using a&#xA;resource (e.g., memory blocks, file descriptors, or network connections) and&#xA;other processes that are concurrently overwriting and then destructing the same&#xA;resource. Such read-destruct races can be protected with locks, or with&#xA;lock-free solutions such as hazard-pointers or read-copy-update (RCU).&#xA;  In this paper we describe a method for protecting read-destruct races with&#xA;expected constant time overhead, $O(P^2)$ space and $O(P^2)$ delayed destructs,&#xA;and with just single word atomic memory operations (reads, writes, and CAS). It&#xA;is based on an interface with four primitives, an acquire-release pair to&#xA;protect accesses, and a retire-eject pair to delay the destruct until it is&#xA;safe. We refer to this as the acquire-retire interface. Using the&#xA;acquire-retire interface, we develop simple implementations for three common&#xA;use cases: (1) memory reclamation with applications to stacks and queues, (2)&#xA;reference counted objects, and (3) objects manage by ownership with moves,&#xA;copies, and destructs. The first two results significantly improve on previous&#xA;results, and the third application is original. Importantly, all operations&#xA;have expected constant time overhead."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://arxiv.org/abs/2002.07053"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Concurrent Reference Counting and Resource Management in Wait-free Constant Time</title>
<div class="readable">
        <h1>Concurrent Reference Counting and Resource Management in Wait-free Constant Time</h1>
            <div>by [Submitted on 17 Feb 2020 (v1), last revised 29 Feb 2020 (this version, v2)]</div>
            <div>Reading time: 2 minutes</div>
        <div>Posted here: 07 Jul 2020</div>
        <p><a href="https://arxiv.org/abs/2002.07053">https://arxiv.org/abs/2002.07053</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div id="content-inner">
  <div id="abs">
    
    
    
      
    
  
    <p><a href="https://arxiv.org/pdf/2002.07053">Download PDF</a></p><blockquote>
      <span>Abstract:</span>  A common problem when implementing concurrent programs is efficiently
protecting against unsafe races between processes reading and then using a
resource (e.g., memory blocks, file descriptors, or network connections) and
other processes that are concurrently overwriting and then destructing the same
resource. Such read-destruct races can be protected with locks, or with
lock-free solutions such as hazard-pointers or read-copy-update (RCU).
<br>In this paper we describe a method for protecting read-destruct races with
expected constant time overhead, <span id="MathJax-Element-1-Frame" tabindex="0"><nobr><span id="MathJax-Span-1"><span><span><span id="MathJax-Span-2"><span id="MathJax-Span-3">O</span><span id="MathJax-Span-4">(</span><span id="MathJax-Span-5"><span><span><span id="MathJax-Span-6">P<span></span></span><span></span></span><span><span id="MathJax-Span-7">2</span><span></span></span></span></span><span id="MathJax-Span-8">)</span></span><span></span></span></span><span></span></span></nobr></span> space and <span id="MathJax-Element-2-Frame" tabindex="0"><nobr><span id="MathJax-Span-9"><span><span><span id="MathJax-Span-10"><span id="MathJax-Span-11">O</span><span id="MathJax-Span-12">(</span><span id="MathJax-Span-13"><span><span><span id="MathJax-Span-14">P<span></span></span><span></span></span><span><span id="MathJax-Span-15">2</span><span></span></span></span></span><span id="MathJax-Span-16">)</span></span><span></span></span></span><span></span></span></nobr></span> delayed destructs,
and with just single word atomic memory operations (reads, writes, and CAS). It
is based on an interface with four primitives, an acquire-release pair to
protect accesses, and a retire-eject pair to delay the destruct until it is
safe. We refer to this as the acquire-retire interface. Using the
acquire-retire interface, we develop simple implementations for three common
use cases: (1) memory reclamation with applications to stacks and queues, (2)
reference counted objects, and (3) objects manage by ownership with moves,
copies, and destructs. The first two results significantly improve on previous
results, and the third application is original. Importantly, all operations
have expected constant time overhead.

    </blockquote>

    <!--CONTEXT-->
    
  </div>
</div><div>
      <h2>Submission history</h2><p> From: Yuanhao Wei [<a href="https://arxiv.org/show-email/e67a1dbb/2002.07053">view email</a>]
      <br>
  <strong><a href="https://arxiv.org/abs/2002.07053v1">[v1]</a></strong>
  Mon, 17 Feb 2020 16:47:50 UTC (192 KB)<br><strong>[v2]</strong>
Sat, 29 Feb 2020 14:45:45 UTC (184 KB)<br></p></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>