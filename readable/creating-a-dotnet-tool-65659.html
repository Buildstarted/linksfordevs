<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Creating a dotnet tool - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.min.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Creating a dotnet tool - linksfor.dev(s)"/>
    <meta property="og:description" content="Building, packaging and publishing a `dotnet` tool via NuGet"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://rendle.dev/posts/creating-a-dotnet-tool/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1 style="margin: unset">
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Creating a dotnet tool</title>
<div class="readable">
        <h1>Creating a dotnet tool</h1>
            <div>Reading time: 12-15 minutes</div>
        <div>Posted here: 14 Aug 2020</div>
        <p><a href="https://rendle.dev/posts/creating-a-dotnet-tool/">https://rendle.dev/posts/creating-a-dotnet-tool/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div><p>One of the great features of .NET Core is that it gives you a simple
way to create and distribute CLI tools via NuGet. You just create a Console
application, add a few entries to the <code>.csproj</code> file, and publish it to
NuGet. Then other people can install it with the <code>dotnet tool install</code>
command. I’ve published a couple of tools this way before, but I’ve just
published another one so I thought I’d take time to describe the steps
involved, as well as a handful of neat NuGet packages that I used along
the way.</p><h2 id="nuke-from-orbit">nuke-from-orbit</h2><p>You know how doing <code>dotnet clean</code> (or right-click &gt; Clean solution in Visual Studio)
doesn’t actually delete all the <code>bin</code> and <code>obj</code> directories and the stuff in them?
And you know how sometimes you really, really have to do that, because something
hiding in one of those directories has got itself into such a muddle that the only
way to fix it is to nuke the site from orbit? Yeah. That’s why I wrote this.</p><p>The tool is published as <a href="https://www.nuget.org/packages/RendleLabs.NukeFromOrbit/">RendleLabs.NukeFromOrbit</a>,
so you can install it by running:</p><div><pre><code data-lang="shell">dotnet tool install -g RendleLabs.NukeFromOrbit
</code></pre></div><p>The <code>-g</code> tells dotnet to install the tool globally so you can use it from anywhere.</p><p>This should output:</p><div><pre><code data-lang="text">You can invoke the tool using the following command: nuke-from-orbit
Tool 'rendlelabs.nukefromorbit' (version '1.0.3') was successfully installed.
</code></pre></div><p>Which helpfully tells you that you can now call it as <code>nuke-from-orbit</code>. If you run it
with the <code>--help</code> argument, it will helpfully tell you how to use it:</p><div><pre><code data-lang="text">NukeFromOrbit:
  Dust off and nuke bin and obj directories from orbit. It's the only way to be sure.

Usage:
  NukeFromOrbit [options] [&lt;workingDirectory&gt;]

Arguments:
  &lt;workingDirectory&gt;    [default: D:\blog]

Options:
  -y, --yes         Don't ask for confirmation, just nuke it. [default: False]
  -n, --dry-run     List items that will be nuked but don't nuke them. [default: False]
  --version         Show version information
  -?, -h, --help    Show help and usage information
</code></pre></div><p>That little feature comes from a NuGet package called
<a href="https://www.nuget.org/packages/System.CommandLine">System.CommandLine</a>,
which is pre-release at the moment but dead useful for this kind of thing.</p><h2 id="systemcommandline">System.CommandLine</h2><p>This package provides a command line argument parser which makes it easy to handle
flags, options and arguments, and even sub-commands if you’re building something big.
You just create a <code>Command</code>, assign a <code>Handler</code> to it, and then <code>Invoke</code> it with
the <code>args</code> parameter from your <code>Main</code> method.</p><p>For <code>nuke-from-orbit</code> the command looks like this:</p><div><pre><code data-lang="csharp"><span><span>var</span></span> command = <span><span>new</span></span> RootCommand
{
    <span><span>new</span></span> Option&lt;<span><span>bool</span></span>&gt;(<span><span>new</span></span>[]{<span><span>"--yes"</span></span>, <span><span>"-y"</span></span>}, () =&gt; <span><span>false</span></span>,
        <span><span>"Don't ask for confirmation, just nuke it."</span></span>),
    <span><span>new</span></span> Option&lt;<span><span>bool</span></span>&gt;(<span><span>new</span></span>[]{<span><span>"--dry-run"</span></span>, <span><span>"-n"</span></span>}, () =&gt; <span><span>false</span></span>,
        <span><span>"List items that will be nuked but don't nuke them."</span></span>),
    <span><span>new</span></span> Argument&lt;<span><span>string</span></span>&gt;(<span><span>"workingDirectory"</span></span>, () =&gt; Environment.CurrentDirectory)
};

command.Description = <span><span>"Dust off and nuke bin and obj directories from orbit. It's the only way to be sure."</span></span>;
</code></pre></div><p>It’s using C#’s list initializer syntax so you can add as many <code>Option</code>s and <code>Argument</code>s
as you need. The <code>Argument</code>s will be <em>positional</em> if there’s more than one, in the order
that they’re added in the list. The <code>Option</code>s can be anywhere, before or after the
<code>Argument</code>s.</p><p>For each option, you can specify an array of <em>aliases</em>, like <code>--yes</code> or <code>-y</code>. You can
also specify a default value for both <code>Option</code>s and <code>Argument</code>s by using a <code>Func&lt;T&gt;</code>
that returns the default; if you specify this, the <code>Option</code> or <code>Argument</code> will be
optional.</p><p>The <code>Description</code> property is output in the Help, just under the name of the command.</p><p>To add a handler, we just create a <code>CommandHandler</code> using an <code>Action</code> or <code>Func</code>, like this:</p><div><pre><code data-lang="csharp">command.Handler = CommandHandler.Create&lt;<span><span>bool</span></span>, <span><span>bool</span></span>, <span><span>string</span></span>&gt;(
    <span><span>async</span></span> (yes, dryRun, workingDirectory) =&gt;
    {
        <span><span>await</span></span> Nuke(yes, dryRun, workingDirectory);
    }
);
</code></pre></div><p><code>System.CommandLine</code> uses the names of the parameters on the delegate to match to the
<code>Option</code> and <code>Argument</code> names; <code>Option</code>s with hyphens are converted to <code>camelCase</code> so
<code>--dry-run</code> matches <code>dryRun</code>.</p><blockquote><p><strong>Note:</strong> at the time of writing System.CommandLine is still in preview, so you’ll
need to enable pre-release packages to use it in your project.</p></blockquote><h2 id="finding-bin-and-obj-folders">Finding bin and obj folders</h2><p>Have you ever written an application that worked with files or directories and muttered
dark curses at whichever API designer decided that the <code>File</code> and <code>Directory</code> classes
should be <code>static</code>, so they’re impossible to test against? You are not alone.
Rejoice! for there is a NuGet package that fixes this, too:
<a href="https://www.nuget.org/packages/System.IO.Abstractions">System.IO.Abstractions</a> provides
interfaces for all the static <code>System.IO</code> types, along with default implementations,
so you can write proper tests without contaminating the file system of whatever
machine the tests run on.</p><div><pre><code data-lang="csharp"><span><span>foreach</span></span> (<span><span>var</span></span> directory <span><span>in</span></span> _fileSystem.Directory.EnumerateDirectories(currentDirectory))
{
    <span><span>var</span></span> name = _fileSystem.Path.GetFileName(directory);
    <span><span>if</span></span> (name <span><span>is</span></span> <span><span>null</span></span>) <span><span>continue</span></span>;
</code></pre></div><p>It even allows you to mock <code>Path</code> so you can change things like <code>DirectorySeparatorChar</code>
and simulate Linux or Windows in your tests.</p><p>Here’s an example using <a href="https://www.nuget.org/packages/NSubstitute/">NSubstitute</a>
to mock the <code>IDirectory</code> interface:</p><div><pre><code data-lang="csharp">        <span><span><span>private</span></span></span><span> </span><span><span><span>static</span></span></span><span> IDirectory <span>FakeDirectory</span>(</span><span><span><span><span>string</span></span></span></span><span><span>[] directories, IPath path, </span></span><span><span><span><span>string</span></span></span></span><span><span>[] files</span>)</span>
        {
            <span><span>var</span></span> directory = Substitute.For&lt;IDirectory&gt;();
            
            directory.EnumerateDirectories(Arg.Any&lt;<span><span>string</span></span>&gt;())
                .Returns(c =&gt; directories.Where(d =&gt; path.GetDirectoryName(d) == c.Arg&lt;<span><span>string</span></span>&gt;()).Distinct());
            
            directory.EnumerateFiles(Arg.Any&lt;<span><span>string</span></span>&gt;())
                .Returns(c =&gt; files.Where(f =&gt; path.GetDirectoryName(f) == c.Arg&lt;<span><span>string</span></span>&gt;()).Distinct());
            
            directory.Exists(Arg.Any&lt;<span><span>string</span></span>&gt;()).Returns(<span><span>true</span></span>);
            
            <span><span>return</span></span> directory;
        }
</code></pre></div><p>The other really nice thing about <code>System.IO.Abstractions</code> is that you can add extension
methods to the interfaces, like this one to detect whether the file system is case
sensitive:</p><div><pre><code data-lang="csharp"><span><span>public</span></span> <span><span>static</span></span> <span><span>class</span></span> <span><span>FileSystemExtensions</span></span>
{
    <span><span><span>public</span></span></span><span> </span><span><span><span>static</span></span></span><span> </span><span><span><span>bool</span></span></span><span> <span>IsCaseSensitive</span>(</span><span><span><span><span>this</span></span></span></span><span><span> IFileSystem fileSystem, </span></span><span><span><span><span>string</span></span></span></span><span><span> directory</span>)</span>
    {
        <span><span>if</span></span> (!fileSystem.Directory.Exists(directory))
            <span><span>throw</span></span> <span><span>new</span></span> InvalidOperationException(<span><span>"Directory does not exist."</span></span>);
        
        <span><span>if</span></span> (directory.Where(<span><span>char</span></span>.IsLetter).Any(<span><span>char</span></span>.IsLower))
        {
            <span><span>if</span></span> (fileSystem.Directory.Exists(directory.ToUpper())) <span><span>return</span></span> <span><span>false</span></span>;
        }
        <span><span>else</span></span>
        {
            <span><span>if</span></span> (fileSystem.Directory.Exists(directory.ToLower())) <span><span>return</span></span> <span><span>false</span></span>;
        }

        <span><span>return</span></span> <span><span>true</span></span>;
    }
}
</code></pre></div><h2 id="not-deleting-git-controlled-files">Not deleting Git-controlled files</h2><p>There are bad people in the world. People who hate puppies, eat your last Jaffa Cake, and
add files in their <code>bin</code> and <code>obj</code> directories to source control. I’m sure they have very
good reasons for doing that, but they don’t. Let’s humour them anyway, and check whether
and <code>bin</code> or <code>obj</code> files are in Git before deleting them.</p><p>From the command line, you can get a complete list of files that are version controlled
using the <code>git ls-files</code> command. So we can run that, find any entries with <code>/bin/</code> or
<code>/obj/</code> in them, and add them to some kind of protected list.</p><p>I don’t know if you’ve ever written the code to run a process and capture its output, but
it’s more complicated than it should be. You have to remember to redirect standard
output, and not use ShellExecute (or is it <em>use</em> ShellExecute? I can never remember),
and then handle the events and everything. It’s just annoying.</p><p>Enter another great NuGet package: <a href="https://www.nuget.org/packages/CliWrap/">CliWrap</a>.
This package wraps all that <code>ProcessInfo</code> and <code>Process.Start</code> business up in a really
well-designed fluent API and takes care of remembering the hard stuff for you.</p><p>Here’s a call to <code>git ls-files</code> using <code>CliWrap</code>:</p><div><pre><code data-lang="csharp"><span><span>private</span></span> <span><span>async</span></span> Task&lt;HashSet&lt;<span><span>string</span></span>&gt;&gt; ListFileAsync()
{
    <span><span>var</span></span> <span><span>set</span></span> = <span><span>new</span></span> HashSet&lt;<span><span>string</span></span>&gt;(_stringComparer);

    <span><span>var</span></span> result = <span><span>await</span></span> Cli.Wrap(<span><span>"git"</span></span>)
        .WithArguments(<span><span>"ls-files"</span></span>)
        .WithWorkingDirectory(_workingDirectory)
        .WithStandardOutputPipe(PipeTarget.ToDelegate(line =&gt;
        {
            line = _fileSystem.Path.Normalize(line);
            
            <span><span>if</span></span> (line.Contains(Bin) || line.Contains(Obj))
            {
                <span><span>set</span></span>.Add(Path.Combine(_workingDirectory, line));
            }
        }))
        .ExecuteAsync();

    <span><span>if</span></span> (result.ExitCode != <span><span>0</span></span>)
    {
        <span><span>set</span></span>.Clear();
    }
    <span><span>return</span></span> <span><span>set</span></span>;
}
</code></pre></div><p>That <code>WithStandardOutputPipe</code> call works with <code>PipeTarget</code> objects: there are
implementations built-in for delegates, streams and <code>StringBuilder</code> and you
can implement your own, too.</p><p>If <code>git</code> isn’t installed, or the working directory is not a <code>git</code> repo, then the
exit code will be non-zero and we can just forget it.</p><p>A <code>dotnet</code> tool is just a NuGet package with a bit of extra metadata specified in the
project file:</p><div><pre><code data-lang="xml">  <span><span>&lt;<span>PropertyGroup</span>&gt;</span></span>
    <span><span>&lt;<span>PackAsTool</span>&gt;</span></span>true<span><span>&lt;/<span>PackAsTool</span>&gt;</span></span>
    <span><span>&lt;<span>ToolCommandName</span>&gt;</span></span>nuke-from-orbit<span><span>&lt;/<span>ToolCommandName</span>&gt;</span></span>
    <span><span>&lt;<span>PackageId</span>&gt;</span></span>RendleLabs.NukeFromOrbit<span><span>&lt;/<span>PackageId</span>&gt;</span></span>
  <span><span>&lt;/<span>PropertyGroup</span>&gt;</span></span>
</code></pre></div><p>The <code>PackAsTool</code> property sets the <code>tool</code> flag in the NuGet package, and the
<code>ToolCommandName</code> is the name used to invoke the command. I’d normally go for something
a bit shorter, but I’m generally so annoyed by the time I need this one that I want
the satisfaction of typing <code>nuke-from-orbit</code> and smashing the <em>Enter</em> key.</p><h2 id="publishing-to-nuget">Publishing to NuGet</h2><p>There are a bunch of ways to publish NuGet packages these days, but I wanted to try
GitHub Actions. This involves adding a <em>workflow</em> file to your git repo which is, of
course, YAML. This is the workflow for NukeFromOrbit, in a file at
<code>.github/workflows/dotnet-core.yml</code>:</p><div><pre><code data-lang="yml"><span><span>name</span></span><span>:</span> <span>.NET</span> <span>Core</span>

<span><span>on</span></span><span>:</span>
  <span><span>push</span></span><span>:</span>
    <span><span>branches</span></span><span>:</span> <span>[</span> <span>master</span> <span>]</span>
  <span><span>pull_request</span></span><span>:</span>
    <span><span>branches</span></span><span>:</span> <span>[</span> <span>master</span> <span>]</span>

<span><span>jobs</span></span><span>:</span>
  <span><span>build</span></span><span>:</span>

    <span><span>runs-on</span></span><span>:</span> <span>windows-latest</span>

    <span><span>steps</span></span><span>:</span>
    <span>-</span> <span><span>uses</span></span><span>:</span> <span>actions/checkout@v2</span>
      <span><span>with</span></span><span>:</span>
        <span><span>fetch-depth</span></span><span>:</span> <span><span>0</span></span>
    <span>-</span> <span><span>name</span></span><span>:</span> <span>Setup</span> <span>.NET</span> <span>Core</span>
      <span><span>uses</span></span><span>:</span> <span>actions/setup-dotnet@v1</span>
      <span><span>with</span></span><span>:</span>
        <span><span>dotnet-version</span></span><span>:</span> <span><span>3.1</span><span>.301</span></span>
    <span>-</span> <span><span>name</span></span><span>:</span> <span>Install</span> <span>dependencies</span>
      <span><span>run</span></span><span>:</span> <span>dotnet</span> <span>restore</span>
    <span>-</span> <span><span>name</span></span><span>:</span> <span>Nerdbank.GitVersioning</span>
      <span><span>id</span></span><span>:</span> <span>nbgv</span>
      <span><span>uses</span></span><span>:</span> <span>dotnet/nbgv@v0</span><span><span>.3.1</span></span>
    <span>-</span> <span><span>name</span></span><span>:</span> <span>Build</span>
      <span><span>run</span></span><span>:</span> <span>dotnet</span> <span>build</span> <span>--configuration</span> <span>Release</span> <span>--no-restore</span>
    <span>-</span> <span><span>name</span></span><span>:</span> <span>Test</span>
      <span><span>run</span></span><span>:</span> <span>dotnet</span> <span>test</span> <span>--configuration</span> <span>Release</span> <span>--no-build</span> <span>--verbosity</span> <span>normal</span> <span>test\NukeFromOrbit.Tests</span>
    <span>-</span> <span><span>name</span></span><span>:</span> <span>Pack</span>
      <span><span>run</span></span><span>:</span> <span>dotnet</span> <span>pack</span> <span>--configuration</span> <span>Release</span> <span>--no-build</span> <span>-p:PackageVersion=${{</span> <span>steps.nbgv.outputs.SimpleVersion</span> <span>}}</span> <span>--output</span> <span>.</span> <span>src\NukeFromOrbit\NukeFromOrbit.csproj</span>
    <span>-</span> <span><span>name</span></span><span>:</span> <span>Push</span>
      <span><span>run</span></span><span>:</span> <span>dotnet</span> <span>nuget</span> <span>push</span> <span><span>*.nupkg</span></span> <span>-s</span> <span>https://api.nuget.org/v3/index.json</span> <span>-k</span> <span>${{</span> <span>secrets.NUGET_API_KEY</span> <span>}}</span> <span>--skip-duplicate</span>
</code></pre></div><p>This is mostly the default .NET Core workflow template, with a couple of additions.</p><h3 id="nerdbankgitversioning">NerdBank.GitVersioning</h3><p>This step takes care of assigning version numbers to assemblies, using the “height” of
the git history (i.e. the number of commits) as the revision number, and taking the major
and minor version numbers from a <code>version.json</code> file in the root of the repo.</p><div><pre><code data-lang="json">{
  <span><span>"$schema"</span></span>: <span><span>"https://raw.githubusercontent.com/dotnet/Nerdbank.GitVersioning/master/src/NerdBank.GitVersioning/version.schema.json"</span></span>,
  <span><span>"version"</span></span>: <span><span>"1.0"</span></span>,
  <span><span>"assemblyVersion"</span></span>: {
    <span><span>"precision"</span></span>: <span><span>"revision"</span></span>
  }
}
</code></pre></div><p>The <code>assemblyVersion</code> property tells NBGV to include the <code>revision</code> in the
<code>AssemblyVersion</code> value; without this the default is just <code>{version}.0.0</code>. I want it
to include the revision because <code>System.CommandLine</code> automatically adds a <code>--version</code>
flag that prints the <code>AssemblyVersion</code> value.</p><p>The workflow uses an <em>output variable</em> from the NBGV step to set the package version
in the <code>dotnet pack</code> step.</p><p>NerdBank.GitVersioning is in the GitHub Actions Marketplace, pulled in with the
<code>uses: dotnet/nbgv@v0.3.1</code> line.</p><h3 id="nuget_api_key">NUGET_API_KEY</h3><p>GitHub Actions provides a <em>Secrets</em> store where you can put API keys, passwords and the
like. You can store Secrets at the repo level, or at the organisation level, where you
can specify which repos the secrets are available to.</p><h2 id="thats-it">That’s it!</h2><p>Hopefully this post has shown you how easy it is to publish your own <code>dotnet</code> tool,
from <code>dotnet new console</code> to CI/CD. If you have any simple tools lying around then
why not share them? And if you do, be sure to drop by
<a href="https://github.com/natemcmaster/dotnet-tools">github.com/natemcmaster/dotnet-tools</a>
and submit a PR to let people know about it.</p><p>The source code for the tool, including the workflow stuff, is at
<a href="https://github.com/RendleLabs/NukeFromOrbit">github.com/RendleLabs/NukeFromOrbit</a>.
Let me know if you like it, or open an issue or submit a PR if it needs fixing.</p></div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>