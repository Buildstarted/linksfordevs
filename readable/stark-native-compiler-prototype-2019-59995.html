<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Stark - Native Compiler - Prototype 2019 - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="Stark - Native Compiler - Prototype 2019 - linksfor.dev(s)"/>
    <meta property="og:description" content="This is the second part of the blog post series about The Odyssey of Stark and Melody and more specifically, about the development of a prototype of the native compiler for the Stark language developed..."/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://xoofx.com/blog/2020/03/21/stark-native-compiler/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
    <div class="devring" style="background: #222">
        <div style="text-align:center">Explore other dev related sites in this ring. If you would like to join this ring <a href="https://devring.club">click here</a>.</div>
        <div class="grid">
            <div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
                <span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
                <a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
                <a href="https://devring.club/random" class="devring-random">Random</a>
                <a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
            </div>
        </div>
    </div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - Stark - Native Compiler - Prototype 2019</title>
<div class="readable">
        <h1>Stark - Native Compiler - Prototype 2019</h1>
            <div>Reading time: 31-40 minutes</div>
        <div>Posted here: 24 Mar 2020</div>
        <p><a href="https://xoofx.com/blog/2020/03/21/stark-native-compiler/">https://xoofx.com/blog/2020/03/21/stark-native-compiler/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div itemprop="articleBody">
	
	<p>This is the second part of the blog post series about <a href="https://xoofx.com/blog/2020/03/05/stark-melody-dotnet-sel4/">The Odyssey of Stark and Melody</a> and more specifically, about the development of a prototype of the native compiler for the <a href="https://github.com/stark-lang/stark">Stark</a> language developed during last year.</p>

<h2 id="overview">Overview<a aria-label="Anchor" data-anchorjs-icon="" href="#overview"></a></h2>

<p>As we saw previously about the <a href="https://xoofx.com/blog/2020/03/06/stark-language-frontend-compiler/">front-end compiler</a>, Stark is a language meant to generate native executable code at build time (AOT compiler). From a set of Stark <code>sklib</code> pre-compiled libraries, we want to generate this native code.</p>

<p>After the Raspberry Pi4 experiment, I originally thought that I would reuse large parts of the <a href="https://github.com/dotnet/corert">CoreRT</a> compiler and its runtime (the experimental AOT .NET compiler) in order to speedup the development of this prototype. But while digging more into the syntax of the language by developing the core library with the language itself, I realized that CoreRT would not be a good fit for the following reasons:</p>

<ul>
  <li>The compiler doesn’t fit into the data oriented approach I was looking for. Lots of managed objects are allocated and used around which are a source of inefficiency.</li>
  <li>The compiler is plugged into RyuJIT by implementing the entire callback interface (170+ methods) in C#
    <ul>
      <li>Whenever RyuJIT is updated, you need to manually update a <a href="https://github.com/dotnet/corert/blob/c142d456570b105d18bfb92229bddb78e7f4cfd8/src/JitInterface/src/ThunkGenerator/ThunkInput.txt">ThunkInput.txt</a> text file as well as manually update new enum items…etc (See for example <a href="https://github.com/dotnet/corert/pull/8016/files">this PR to update RyuJIT</a>)</li>
      <li>The fine-grained interface can be very chatty, requiring lots of native (RyuJIT) to managed transition to compile a single method.</li>
    </ul>
  </li>
  <li>The compiler requires also to compile a LLVM library - <a href="https://github.com/dotnet/corert/blob/master/Documentation/how-to-build-ObjectWriter.md">the Object Writer</a> - (16Mb+) in order to generate COFF/DWARF/MACHO object files.</li>
  <li>The compilation requires various low-level CPU dependent <a href="https://github.com/dotnet/corert/tree/master/src/Native/Runtime/amd64">ASM files</a> to be linked with.
    <ul>
      <li>Many <a href="https://github.com/dotnet/corert/blob/master/src/Native/Runtime/AsmOffsets.h">offsets</a> need to be shared and maintained with the compiler/runtime in order to work correctly.</li>
    </ul>
  </li>
  <li>The .NET Runtime in CoreRT is relying on some existing C/C++ runtime (e.g GC) while Stark will be entirely implemented in Stark.</li>
  <li>Many challenging parts in CoreRT will be implemented very differently in Stark:
    <ul>
      <li>Interface calls in Stark are using fat-pointer.</li>
      <li>Delegates are not managed object in Stark but value types, either a direct function pointers (for static functions) or fat pointers for closure functions (e.g instance method of an object).</li>
      <li>Virtual methods with generics are not allowed in Stark.</li>
      <li>Static/Const data in Stark are entirely computed at compile time and baked into a readonly data section. This include loading string literals for example, which is a nop in Stark as there is no heap allocation involved for string literals in Stark.</li>
      <li>Generics would be handled up-front by the native compiler, allowing more opportunities/optimizations or different strategies for native code sharing, RyuJIT would not see any generics at all.
        <ul>
          <li>Literal generics would be part of these optimizations.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>For these reasons, I decided that the architecture of the native compiler would be significantly different to justify to not rely on CoreRT. Though, in order to keep the development practical, it would still rely on RyuJIT for generating native code but it would keep it as an implementation “detail”, as it is done similarly in CoreRT. Other reasons for using RyuJIT:</p>

<ul>
  <li>RyuJIT is a compiler aware of managed objects references (for precise stack root walking).
    <ul>
      <li>It provides correct reporting of stack frame walking and managed objects on the stack.</li>
    </ul>
  </li>
  <li>RyuJIT is being improved constantly.</li>
  <li>RyuJIT provides good codegen balance between throughput and optimizations.</li>
</ul>

<p>Let’s see how the native compiler of Stark was designed and developed.</p>

<h2 id="architecture">Architecture<a aria-label="Anchor" data-anchorjs-icon="" href="#architecture"></a></h2>

<p><img src="https://xoofx.com/images/stark-ncl.png"></p>

<p>The key requirements of the native compiler are:</p>

<ul>
  <li>Design the compiler up-front using data-oriented structures to improve its efficiency.</li>
  <li>Take into account early in its design a server/incremental mode to allow to cache assemblies, detect modifications…etc.</li>
  <li>Rely on RyuJIT as a base - for simple - IL compiler to native code:
    <ul>
      <li>Move some of its prerogatives to the higher level (e.g generics, some code elision/inline decisions…).</li>
      <li>Keep modifications required for RyuJIT to its bare minimum.</li>
    </ul>
  </li>
  <li>Use an intermediate IR to perform higher level transformations before going back to RyuJIT
    <ul>
      <li>So the transform process for RyuJIT would be: IL (from sklib) =&gt; IR + transforms =&gt; Simple Il (for RyuJIT)</li>
      <li>Allow this IR to be used later by a different IR to native code path (e.g custom IR to native compiler, LLVM…)</li>
    </ul>
  </li>
  <li>Make every parts of the compiler streamlined, integrated and fine-grained control. The compiler should be able to perform on its own without relying on external tools:
    <ul>
      <li>Generate low-level assembler parts.</li>
      <li>Perform linking and layout of the generated executable.</li>
      <li>Write debug information.</li>
    </ul>
  </li>
</ul>

<p>Unlike a regular C/C++ compiler, the process of compilation can be more focused: we know for example the entry-point of an executable in an <code>sklib</code> and in that case we can transitively collect exactly what we will need to transform to native code. <code>sklib</code> libraries should be seen as pre-compiled headers stored in a compressed data-layout format.</p>

<p>When processing these methods, we are going to collect lots of data that we need to un-compress and organize in memory to allow to process them more efficiently later.</p>

<h3 id="data-oriented-ir">Data Oriented IR<a aria-label="Anchor" data-anchorjs-icon="" href="#data-oriented-ir"></a></h3>

<p>What does it mean for a compiler to be data oriented? It is actually quite challenging because a compiler manipulates trees of instructions and these trees can be transformed, new nodes can be created and this often doesn’t translate back to sequential memory access (after a few transforms), unless we compact/reorder our data after a few transforms based on some fragmentation levels and on the remaining amount of transforms or analysis that still need to proceed. This sequential memory access problem is mostly for instructions. Other type system related metadata are less affected and can be layout in memory relatively efficiently.</p>

<p>But there are other related aspects of being data oriented:</p>
<ul>
  <li>Adapt the data to a particular process, usually the most common/time consuming process.
    <ul>
      <li>Take the word “oriented” in data oriented as oriented to a particular process need. Different process can require different optimal data layout. The goal is not to find a general purpose data layout valid in all kind of situations.</li>
      <li>If we have a chain of processes where some processes are going through the data in a completely orthogonal manner, decide whether we need to build a more suitable data layout view (e.g re-layout-copy vs index indirection).</li>
    </ul>
  </li>
  <li>Craft the data to present a maximum entropy/locality of information at one place.</li>
  <li>Make allocation and de-allocation fast.</li>
  <li>Avoid unnecessary copy of data.</li>
</ul>

<p>When processing IL, we have many different connected data:</p>

<ul>
  <li>Methods
    <ul>
      <li>Signatures
        <ul>
          <li>Parameters</li>
        </ul>
      </li>
      <li>Local variables</li>
      <li>Basic blocks
        <ul>
          <li>Instructions
            <ul>
              <li>Arguments
                <ul>
                  <li>Users (instruction dependencies)</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Types
    <ul>
      <li>Fields</li>
    </ul>
  </li>
  <li>Generic types</li>
</ul>

<h4 id="arena-allocator">Arena Allocator<a aria-label="Anchor" data-anchorjs-icon="" href="#arena-allocator"></a></h4>
<p>Because we are collecting methods on our way, we don’t know exactly how much data we will need to finally transform to native code.</p>

<p>If we were using a naive approach, we would use something like this:</p>



<p>To our principles defined earlier, even if <code>IRMethod</code> is a struct, this approach is not enough data oriented friendly: We are still making lots of copy of data.
We could decide to pre-allocate <code>List&lt;IRMethod&gt;</code> with an original capacity, but this is not great to allocate and consume potentially lots of memory that in the end would not be used at all.</p>

<p>Instead for the Stark native compiler, a dedicated virtual memory arena allocator is used for each kind of data to allocate:</p>

<p><img src="https://xoofx.com/images/stark-ncl-data-oriented-arena-allocator.png"></p>

<p>Each kind of data has its own continuous block committed (actually used) and reserved (maybe used later) virtual memory. Whenever we have to add some data to a block, we just need to transform a reserved memory page into a committed memory page while keeping the same initial base pointer for the block.</p>

<p>Each block of memory is storing a single kind of data so that we can index them (instead of offset-ing).</p>

<p>Finally, this arena allocator is very easy to collect or reuse, no need for a GC to visit every single reference to realize that it can free large block of memory. Once we are done compiling a graph of methods, the same areana allocator can be reused for subsequent requests. Resetting the allocator just requires to reset the start pointer to zero. That can be massively effective when using this approach in a shared compiler server.</p>

<h4 id="index-based-references">Index-based references<a aria-label="Anchor" data-anchorjs-icon="" href="#index-based-references"></a></h4>

<p>Because the memory used to store these data is unmanaged, we can’t store any managed references in them (we could use GCHandle but that’s not the point). Moreover, each kind of data might references other kinds (e.g a method has basic blocks, each basic blocks has instructions…).</p>

<p>As the memory blocks are contiguous and are guaranteed to not be re-allocated, we could use pointers to connect them. But again, pointers in that case are actually not data oriented friendly. On a 64 bit arch, their footprint adds-up quickly, specially when you have lots of references. For a simple, case like an <code>IRFieldDesc</code> structure:</p>



<p>Using a pointer for <code>IRTypeHandle</code> would increase the size of this struct by 25%, from 32 bytes to 40 bytes. It could be seen as acceptable, but it is one of the best-case struct in the IR model, while there are other cases that are much worse (1.5x to 2x bigger).</p>

<p>Instead, we are using 32-bit indices to address and connect data. This should give plenty enough room to index our data (4 billions of entries per kind).</p>

<p>Reducing size for data oriented data is particularly important to improve cache utilization - which is usually the bottleneck of most modern workload these days.</p>

<p>When using indices, we are usually always reserving the index 0 as a null reference (not used). Another interesting side effect of using indices is that you can clone data without having to patch the indices referencing these data.</p>

<h4 id="il-to-ir">IL to IR<a aria-label="Anchor" data-anchorjs-icon="" href="#il-to-ir"></a></h4>

<p>The IL in a <code>sklib</code> is stored in a compressed format, well suited for a compact and efficient storage for IO, but absolutely not efficient for manipulating it. For example, some integers/indices in IL metadata can be encoded using a <a href="https://en.wikipedia.org/wiki/LEB128">variable-length encoding scheme</a>. The stream of IL instructions of a method has to be decoded from the start of the method in order to access a certain instruction.</p>

<p>In Stark, we transform IL instructions along all the associated data (methods, types, fields…) to an IR representation that is more suited for traversing and transforming. The stream of IR instruction is encoded as a continuous linked list of fixed-size instructions as it is important that the underlying container supports addition/insertion/removal of instructions without having to copy or shift a large amount of data.</p>

<p><img src="https://xoofx.com/images/stark-ncl-data-oriented-instructions.png"></p>

<p>For instance, a single IR instruction in Stark is occupying around 40 bytes, while most instructions in the IL can occupy as little as 1 byte. Why there is such a huge difference with the IR?</p>

<p>The reason is that we need to manipulate efficiently these IR instructions at compile time, detect what is the final type of the operation, find users of a particular instruction (so that it can be replaced easily)… Also the IL is encoded as a stack of instructions (push and pop) which requires to process the instructions to know where we are, while the IR is register based, so an index of an instruction is its register/reference:</p>

<p>For example, the following IL:</p>



<p>Would be translated to the following (simplified) IR:</p>



<p>In order to decode the IL, we are using our own <code>StarkPlatform.Reflection.Metadata</code>/<code>SRM</code> which is a fork of <code>System.Reflection.Metadata</code>. As explained in the previous blog post, a fork of this library was required to make breaking changes on the IL and add new features.</p>

<p><code>SRM</code> is a very well designed data-oriented library, suited to decode efficiently a <code>sklib</code> without having to expand or IL-uncompress the library into memory. It just requires to load (or even better - memory map a file) into memory and the library is working directly on the buffer without having to transform it.</p>

<h4 id="zero-copy-utf8-strings">Zero-copy UTF8 strings<a aria-label="Anchor" data-anchorjs-icon="" href="#zero-copy-utf8-strings"></a></h4>

<p>Stark is using from the start UTF8 strings, for all metadata inside the <code>sklib</code>, for both strings used for metadata namespace/method/type names as well as for user literal strings. This is one of the breaking change made to the IL.</p>

<p>But <code>SRM</code> library was also slightly modified to more efficiently support these strings without requiring a managed allocation (unlike the original SRM). It means that whenever you need to access a string defined in an assembly (and you can have lots of strings in an assembly!), you can get a reference to it through a small wrapper struct which contains just a pointer to the array of bytes and a length. It provides a zero-cost abstraction when using strings which is very valuable in our data-oriented compiler.</p>

<p>Whenever we need to concatenate strings (e.g to build a full type name for example with generic arguments), we allocate new strings as part of one bucket in our arena allocator and we are able to create/copy/contact strings if needed and get a reference from there.</p>

<h3 id="ryujit-integration">RyuJIT integration<a aria-label="Anchor" data-anchorjs-icon="" href="#ryujit-integration"></a></h3>

<p>RyuJIT is the JIT compiler used by .NET Runtime to compile methods on the fly. Its <a href="https://github.com/dotnet/runtime/blob/d2f7b6b0d46a45be29ebafca0584142219ffe495/src/coreclr/src/inc/corjit.h#L88-L139"><code>ICorJitCompiler</code> interface</a> is lightweight as it is completely decoupled from the <a href="https://github.com/dotnet/runtime/blob/d2f7b6b0d46a45be29ebafca0584142219ffe495/src/coreclr/src/inc/corjit.h#L141-L306"><code>IICorJitInfo</code> interface</a> providing actual metadata required for JIT to compile a method:</p>



<p>Inspired by the design of CoreRT, I originally thought that I would implement the whole <code>ICorJitInfo</code> interface in C# by passing a custom virtual table to RyuJIT. Unlike CoreRT, I wanted to automate entirely the maintenance of this virtual table by generating it from source code instead.</p>

<p>So I started to develop the library <a href="https://github.com/xoofx/CppAst"><code>CppAst</code></a> (released almost one year ago!), a simple wrapper around <code>libclang</code> that provides an easy way to navigate C/C++ headers.
From that, I developed another library <a href="https://github.com/xoofx/CppAst.CodeGen"><code>CppAst.CodeGen</code></a> to generate a C# PInvoke layer from C/C++ header files. <code>CppAst.CodeGen</code> was heavily inspired by the work I did on SharpDX but was simplified and made more decoupled. It is not as rich as what was done in SharpDX, but it is good enough to handle most C/C++ header files. I even started to develop the wrapper <a href="https://github.com/xoofx/GitLib.NET">GitLib.NET</a> around <a href="https://libgit2.org/">libgit2</a> as a playground for <code>CppAst.CodeGen</code>. You can have a look at the <a href="https://github.com/xoofx/GitLib.NET/tree/master/src/GitLib/generated">generated files</a> for this project. But I didn’t continue much further <code>GitLib.NET</code> (I was already off-track for the Stark native compiler!) even If I believe that it could have been a much faster/slim/efficient interface around libgit2 compare to the existing <a href="https://github.com/libgit2/libgit2sharp">LibGit2Sharp</a>.</p>

<p>Anyway, after this code interlude (and we will see that there are others coming!) when I started much later in September to actually develop the Stark native compiler, I realized that instead of implementing entirely the <code>ICorJitInfo</code> interface in C#, I would implement it in C++ with only a pointer to the generated IR datas:</p>

<p><img src="https://xoofx.com/images/stark-ncl-data-oriented-ryujit.png"></p>

<p>So, Was <code>CppAst</code> in the end developed for nothing? Actually not! As I had to make an integration with RyuJIT by implementing the entire interface in C++, I decided to model the IR in C as well. That was much easier to integrate it directly with RyuJIT, but with <code>CppAst.CodeGen</code> I could easily generate all the C# structs from this simple and straightforward API. It means that the interface between the Stark C# native compiler and RyuJIT integration was mostly data-oriented, with a single method to call RyuJIT:</p>



<p>In Stark, the <code>IRContextDesc</code> serves similar purpose than the <code>ICorJitInfo</code>, but it is exposing only data. The implementation of <code>ICorJitInfo</code> lives just behind this <code>StarkNclCompile</code> method but is very easy to develop as it is mainly extracting data from our IR and return them in the different implementation methods of <code>ICorJitInfo</code>.</p>

<p>For example, implementing the method <code>ICorJitInfo::getClassNumInstanceFields</code> is simply a matter of indexing in the <code>IRClassDesc</code> table:</p>


<p>So we can better understand now how different is the integration of RyuJIT in Stark compare to CoreRT:</p>

<ul>
  <li>In CoreRT, the compilation process transform IL to a representation using managed objects (the type system…etc.). Then RyuJIT is called with a callback interface <code>ICorJitInfo</code> implemented in C# that will access these managed objects to return the requested data to RyuJIT. Compiling a method requires lots of round-trip/native-to-managed transition in order to extract these data. The access to the data can be jumping around in memory - because there is no guarantee that these managed objects are all well co-located in memory, moreover, there are many managed allocations going around with more GC happening.</li>
  <li>In Stark, the compilation process transform the IL to a data-oriented IR representation - on which we can operate more transforms before going to RyuJIT. Then RyuJIT is called only once with a pointer to these data and is able to to extract all the required information to compile a method. No other managed transitions are happening during this process, resulting in a much leaner and efficient integration with RyuJIT. The GC is barely involved, as the Stark compiler is data-oriented.</li>
</ul>

<p>As this Stark RyuJIT C++ integration is actually another flavor of RyuJIT (e.g it creates a native DLL called <code>stark-ncl-clrjit-x64.dll</code>), I made a <a href="https://github.com/dotnet/runtime/pull/1292">PR to dotnet/runtime</a> to simplify the creation of my own C++ RyuJIT DLL outside of the CoreCLR repository.</p>

<p>This way of working with RyuJIT payed off as well later when I transitioned from the old <code>CoreCLR</code> repository to the new <code>dotnet/runtime</code>. In the meantime, the interface of <code>ICorJitInfo</code> changed a bit, some enums were removed, some methods were changed… but it took me just a few minutes to upgrade the Stark RyuJIT integration layer to this new version. I didn’t have to touch at all the IR data during this process.</p>

<h3 id="generics-and-inlining">Generics and Inlining<a aria-label="Anchor" data-anchorjs-icon="" href="#generics-and-inlining"></a></h3>

<p>Handling generics efficiently is an important challenge for reducing compilation time and avoid code-size explosion. But It is also often critical to generate efficient code for a particular generic case.</p>

<p>RyuJIT has been (re)using an effective rule since the beginning of generics in .NET Framework 2.0:</p>

<ul>
  <li>Generated code for generics with reference types is <strong>shared</strong> (e.g <code>List&lt;object&gt;</code>)</li>
  <li>Generated code for generics with value types is <strong>specialized</strong> (e.g <code>List&lt;int&gt;</code>)</li>
  <li>A mix of both (e.g <code>SpecialList&lt;object, int&gt;</code>)</li>
</ul>

<p>Matt Warren wrote a great article about <a href="https://mattwarren.org/2018/03/02/How-generics-were-added-to-.NET/">“How generics were added to .NET”</a> and the original paper <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2001/01/designandimplementationofgenerics.pdf">Design and Implementation of Generics for the .NET Common Language Runtime</a> gives plenty of details about the implementation (part 4), so I won’t give more insights here about the rationale but highlight some of the differences.</p>

<p>It has proven over the years to be a sensible rule overall:</p>

<ul>
  <li>For value types, you often don’t have much choice. If you don’t specialize, you would have to go through quite some indirections to make the code shared (e.g query the size of an element type in an array everytime you want to access an element and index dynamically based on this sizeof).</li>
  <li>For reference types, it also makes sense, as a reference type is occupying the same space (a pointer size) and access to them can be gated through interface calls which can be shared.</li>
</ul>

<p>I didn’t change drastically these rules for Stark, but the implementation details are still different. Because we can have generic const literals (e.g <code>FixedArray&lt;int, 5&gt;</code>) it would require to change RyuJIT in order to support this new scenario. I would like to avoid as much as possible modifications to RyuJIT as it would complicate merging and future maintenance. So instead, <strong>generics are expanded at IR build time</strong>. This should also give more opportunities in the future to decide which generics should be shared or specialized. Typically, I would like to share structs which have the same layout of fields, it was mentioned in the original paper (Section <code>4.1 Specializing and Sharing</code>: “<em>That leaves user-defined struct types, which are compatible if their layout is the same with respect to garbage collection i.e. they share the same pattern of traced pointers</em>”) but I don’t think that this is something currently implemented in RyuJIT (thought It might have changed recently!).</p>

<p>So in the end, RyuJIT is receiving only plain generic-less methods and structs to compile. This will also simplify later potential integrations with other native compilers (e.g LLVM).</p>

<p>Inlining can also erase the distinction between shared vs specialized because if the method being called is a candidate for inlining, it will be inlined whether it is specialized or shared, and thus, make the inlining actually specialized. You can see this in action with <code>List&lt;string&gt;.Add(...)</code> and <code>List&lt;object&gt;.Add(...)</code> on <a href="https://sharplab.io/#v2:C4LghgzgtgPgAgBgARwIwBYDcBYAUHuAZhQCYkAFAGzAE8BxAUwDsGAnASwGMIkBvPJIJTE0ANhTokAQQAmMgKKUGUZsAAUAGXYRgAHjQIAfEkrbgAGhSpkDJSqbAAlHwFC3pnQDpZMtbeWqjji4bgC+roIRwlbicJI+igEOmma6APYARgBWDJzAxh4WSJk5eUj+9k4uIW5Chd5yfnaBwWF4oUA=">this example on sharplab.io</a>.</p>

<p>It will be possible also to control the inlining at the IR level in order to cover some LTO scenarios that RyuJIT alone cannot make a decision about (e.g single method use).</p>

<h3 id="layout-of-code">Layout of Code<a aria-label="Anchor" data-anchorjs-icon="" href="#layout-of-code"></a></h3>

<p>In a traditional C/C++ workflow, a compiler will roughly compile code and generate an object file per cpp file. Then a linker will glue these object files together to form a final executable. But if you think about it, it is actually far from being optimal in terms of locality and cache-coherency: Functions that are being used in a method call graph could potentially jump between several different locations/object files. This is what LTO (Link Time Optimizations) of some of these compilers are also taking this into account otherwise you can use solutions like <a href="https://github.com/facebookincubator/BOLT">BOLT</a> to optimize the layout of your code.</p>

<p>In Stark - but I believe also in CoreRT, the layout of the code is following the method call graph, which result in a more optimal layout of the code straight from the beginning of the codegen. Though, the layout of code based solely on the method call graph is not necessarily the most optimal. You can come up with an even more optimal layout by using a PGO approach (Profile Guided Optimizations) where you run your code with instrumentation for which we can reuse the results to feedback the compiler with additional layout hints. Note that profile guided optimizations are also used for better inline decisions.</p>

<h3 id="layout-of-data">Layout of Data<a aria-label="Anchor" data-anchorjs-icon="" href="#layout-of-data"></a></h3>

<p>Similarly, the layout of the data is actually impacted by the method call graph. In Stark, this is something even more important, because all static data are constant data that will stay in a readonly section of the executable.</p>

<p>Unlike in .NET/CoreCLR (and CoreRT, even if it can optimize certain scenarios), all (static) const objects are not allocated on the heap but will stay in the readonly section without generating any allocations.</p>

<p>For instance, if you take the instruction ldstr in IL <code>ldstr "This is another string"</code>, in a .NET Runtime, this requires usually to allocate a string on the heap, copy the string content from its metadata assembly to the heap, store a dictionary to associate this original metadata string with its heap representation (this is called internalize). It is such a costly process that RyuJIT is even deciding to not inline a method whenever there is a <code>ldstr</code> somewhere in your method and another reason why you will see plenty of places in the .NET runtime where a <code>throw new ArgumentXXXException("This is an awful string to load")</code> will be moved to a separate method (see for example <a href="https://github.com/dotnet/runtime/blob/8593a477fb8f41029f9d7963658922b8d504c76e/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs#L145-L166"><code>List&lt;T&gt;</code></a>). (Edit: As suggested by a careful reader on Twitter - Hey Lucas! ;) - That was based on an <a href="https://twitter.com/xoofx/status/1241481370821591041">old discussion</a> but it seems to inline fine now with RyuJIT!).</p>

<p>Let see how this is handled for loading a string in Stark:</p>

<p>First, we convert <code>ldstr "This is another string"</code> at IR level into loading a static field value <code>ldsfld _my_string_field</code>. A string in Stark is a value type which contains a managed array of <code>u8</code>:</p>



<p>An array is a special type which contains first a length followed immediately by the elements:</p>



<p>but <code>Array</code> also inherits from <code>Object</code>:</p>



<p>where Type is simply a wrapper around a pointer to simple runtime representation:</p>



<p>Then the string is actually layout in the data section like this:</p>

<p><img src="https://xoofx.com/images/stark-ncl-data-oriented-string-layout.png"></p>

<ul>
  <li><strong>Offset 0</strong>: is the address where <code>_my_string_field</code> is located which is a struct <code>string</code>.
    <ul>
      <li>This entry contains an address to the internal <code>_buffer []u8</code>.</li>
    </ul>
  </li>
  <li>Then the following entry is the actual layout of the object <code>[]u8</code>
    <ul>
      <li><strong>Offset 8</strong>: With a pointer to the type of <code>[]u8</code> because <code>Array&lt;T&gt;</code> inherits from <code>Array</code> which inherits from <code>object</code>.</li>
      <li><strong>Offset 16</strong>: The field <code>let _size : int</code> is coming from <code>Array</code>.</li>
      <li><strong>Offset 24 and followings</strong>: The string <code>u8</code> elements data coming from <code>Array&lt;T&gt;</code>.</li>
    </ul>
  </li>
</ul>

<p>The metadata for <code>Type</code> are stored in a different location, and are all grouped together in a continuous block of memory.</p>

<p>Having data streamed along the way of discovering code allow to colocate data where they are used. It doesn’t give a strict optimal solution (again requiring PGO to make it effective) but it should be on average much better, specially when a method access a few constant objects that it is only using, the compiler will make a guarantee that these data are layout in memory in consecutive cache lines, which can be very effective!</p>

<p>A careful reader could see that our object doesn’t contain a GC Header. This is yet to be confirmed with the design of the memory manager, but I don’t plan to have a GC header for managed objects. In .NET this is called ObjHeader (see <a href="https://github.com/dotnet/runtime/blob/master/src/coreclr/src/vm/syncblk.h">syncblk.h</a>) which contains bits required by the GC as well as a potential pointer to a shadow object runtime called the <code>SyncBlock</code>. When you do a <code>lock(object)</code> it will create and access this shadow object at runtime or same if you start to call the default <code>Object.GetHashCode()</code>. This GC header is unfortunately an - awful - story/legacy coming from Java which is bringing lots of unnecessary runtime burden to our object (a pointer size + a potential shadow runtime object). As a breaking change and to improve runtime efficiency, we can completely remove that implementation details in Stark!</p>

<h3 id="special-functions">Special functions<a aria-label="Anchor" data-anchorjs-icon="" href="#special-functions"></a></h3>

<p>The native compiler in Stark allows to replace any external methods with a custom implementation. For example the following <code>debug_output_char</code> method:</p>



<p>Can be redirected at compile time to an implementation that requires access to a special CPU instruction <code>syscall</code> which is unavailable via RyuJIT. Here is an example by redirecting this method to a Linux kernel method:</p>



<p>Most of the work was actually spent at <a href="https://github.com/0xd4d/iced/pull/60">developing an assembler for the project Iced</a> that I happily pushed through a massive PR after several evenings of coding!</p>

<p>As we are going to need to access a seL4 micro-kernel while building our Stark-based micro-operating-system we will require several of these methods to interact efficiently with seL4.</p>

<p>Having a tight integration of the Stark native compiler with an integrated assembler allows to easily generate dedicated assembler code that can be dependent on other input data available at compile time (e.g constants, offsets, generation of variants of assembler code…etc.). It is also saving the time of a linker, which would be actually more costly, as the total time to read of the object file from disk, decode the DWARF section, copy the data to a new place in the final executable…etc. are requiring a lot more CPU cycles than to encode these instructions directly (Iced is also the most marvelous and fastest assembler I know about!).</p>

<h3 id="change-to-ryujit">Change to RyuJIT<a aria-label="Anchor" data-anchorjs-icon="" href="#change-to-ryujit"></a></h3>

<p>The prototype was around generating code for a simple HelloWorld program using the following function:</p>



<p>One important change that was made to Stark is that all arrays are using a native integer (<code>int</code> in Stark, which is 8 bytes for a 64 bit CPU arch) for their size.</p>

<p>I wanted to propagate this change also to RyuJIT to allow the compiler to perform proper <code>IndexOutOfRangeException</code> removal, so I took the side-time to also make these <a href="https://github.com/stackrift/stark-dotnet-runtime/commit/44f040f8f01497ff3e394eafa4048cba52df63ec">changes to RyuJIT</a>. The changes are relatively small and I hope to be able to maintain them easily while merging back <code>dotnet/runtime</code>. But as for Roslyn, it is never easy to make a change to a repository you are not an expert in without having a review from someone more knowledgeable!</p>

<h3 id="generate-an-executable">Generate an executable<a aria-label="Anchor" data-anchorjs-icon="" href="#generate-an-executable"></a></h3>

<p>In order to run an executable on an Operating System, you need to have a proper file format of this executable, how to layout code and data in memory…etc. For Stark, I decided to adopt the ELF file format for which you can find plenty of tools to manipulate them (at least on Linux and MacOSX).</p>

<p>As per our requirements, I wanted also this integration to be streamlined so I decided to develop a whole library for manipulating object files from C#/.NET called <a href="https://github.com/xoofx/LibObjectFile">LibObjectFile</a>.</p>

<p>This library helps to create easily ELF executable with whatever section/segments requirements we need for our case.</p>

<p>Because I wanted also the executable to be debuggable via qemu, I have also added support for DWARF debugging information. The <a href="http://dwarfstd.org/">DWARF specifications</a> are huge and splitted between multiple versions of the specs, so the development of DWARF into <code>LibObjectFile</code> took me several weeks of work.</p>

<p>A Stark executable for the Melody OS is currently composed of 3 segments/sections:</p>

<ul>
  <li>Code section</li>
  <li>Read-only data section</li>
  <li>BSS section (only relevant for the boot core server - to have an initial heap/stack available)</li>
</ul>

<h5 id="symbols-relocations">Symbols Relocations<a aria-label="Anchor" data-anchorjs-icon="" href="#symbols-relocations"></a></h5>

<p>Another challenge when linking code is that you need to relocate all the code and data (symbols) to a different final target memory location.</p>

<p>For code, whenever RyuJIT is emitting a relocatable code - accessing for example a data - it will emit a relocation entry which will perform a callback to our compiler (tip: one case where RyuJIT is calling back our compiler here). For most assembler code, relocation entries are relative 32 bit offsets to the end of the instruction using this data:</p>



<p>Translates to the following instruction, where we can see the relocation entry of <code>_my_string_field</code>:</p>



<p>We are using our same virtual memory allocator also for storing generated code and data, but a block region of code has more reserved memory (e.g 16Mb) than it is actually using (committed). It means that the offsets between code and data at compilation time (in-memory) will be different once translated back to a file layout. This is the process of relocation:</p>

<p><img src="https://xoofx.com/images/stark-ncl-data-oriented-elf-file-layout.png"></p>

<p>Recall from the previous section about data layout that we need also to perform these relocations for data when a data is referencing another data (e.g the pointer to <code>[]u8</code> or the <code>*Impl</code> for type) or a pointer to a code (e.g the address of a native function stored in a const data - used by function pointers, vtable…).</p>

<p>Finally, the sections/segments in the final ELF file need to be also aligned so that the in-memory representation will be at the same offset than the file representation and has to be accounted when performing the final relocations of all symbols.</p>

<h3 id="challenges">Challenges<a aria-label="Anchor" data-anchorjs-icon="" href="#challenges"></a></h3>

<p>There are many challenges ahead that I didn’t have time to evaluate during this first year prototype:</p>

<ul>
  <li>Handle of const generic literal types.</li>
  <li>Handle virtual calls with virtual tables.</li>
  <li>Handle interface calls: remember that unlike .NET, an interface in Stark is a fat pointer composed of an object target and a side vtable. It allows typically to declare an implementation of an interface for a type outside of a type, which is very powerful. It makes also function pointers calls a lot more faster (they are very costly in .NET).</li>
  <li>Handle function pointers (similar to interface calls).</li>
  <li>Generate debug info (even though my DWARF library is up and ready to be used!).</li>
  <li>Generate stack-walk frames and GC stack frames: these are both generated by RyuJIT via a callback when generating code. Stark will have to re-package these data, as we will likely use a different format.</li>
  <li>Support for SIMD intrinsics: Stark will provide similar access to SIMD types and <a href="https://devblogs.microsoft.com/dotnet/hardware-intrinsics-in-net-core/">hardware intrinsics</a>. The difference will be mostly around functions and namespaces naming. It will likely require a change to RyuJIT, unless I can find a way to the RyuJIT integration by mocking Stark SIMD functions/types as .NET SIMD function/types. We will see!</li>
</ul>

<h2 id="open-sourcing">Open-Sourcing<a aria-label="Anchor" data-anchorjs-icon="" href="#open-sourcing"></a></h2>

<p>Unlike the Stark front-end compiler - along its runtime which is open-source at <a href="https://github.com/stark-lang/stark">https://github.com/stark-lang/stark</a>, the native compiler will remain closed source for now. It is mainly an opportunity for me to keep this project in a potential business-able state. But this blog post is giving you lots of insights about how it was developed - even though there are many tricks and the real challenge is to plug all of these together in the details, but at least, you can enjoy some overview of these details! ;)</p>

<p>But it is not completely closed-source either, as most of the code I have developed for this prototype has been made OSS:</p>

<ul>
  <li><a href="https://github.com/xoofx/CppAst">CppAst</a> and <a href="https://github.com/xoofx/CppAst.CodeGen">CppAst.CodeGen</a></li>
  <li><a href="https://github.com/xoofx/LibObjectFile">LibObjectFile</a></li>
  <li><a href="https://github.com/0xd4d/iced">Iced.Assembler</a></li>
</ul>

<p>And these are not small OSS libraries to develop!</p>

<h2 id="next-steps">Next Steps<a aria-label="Anchor" data-anchorjs-icon="" href="#next-steps"></a></h2>

<p>Developing a native compiler bottom-up to the front-end compiler that can generate an actual executable was a fantastic and exciting achievement to see in motion when running the prototype with QEMU.</p>

<p>But the success of this enterprise is also largely due to the availability of RyuJIT and the feedback of the .NET ecosystem that helped to make this endeavor more practical for an individual.</p>

<p>The development of the prototype was always strongly focused on the target of developing a small Hello-World program around a seL4 micro-kernel, which helped me being concentrated - and motivated along the way. By the number of side-OSS projects that I had to develop to make this possible, you can imagine how much work it is to bring this to life!</p>

<p>Anyway, we still need to talk about the end of this first prototype through the integration with seL4 micro-kernel, and how Melody will be built around that.</p>

<p>Stay tuned for a next blog post.</p>

<p>Happy coding!</p>

	</div></div></div>
    </div>
    <footer>
        <div>created by <a href="https://buildstarted.com">buildstarted</a> &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
        <div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function() {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>