<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Breaking all existing Hex Encoding Records with .NET Core 3.0 - Nicolas Portmann -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Breaking all existing Hex Encoding Records with .NET Core 3.0 - Nicolas Portmann</h1><div><div class="jsx-1967274227 bodytext"><p>It all started over 10 years ago when someone dared to ask ‚Äù<a href="https://stackoverflow.com/questions/311165/how-do-you-convert-a-byte-array-to-a-hexadecimal-string-and-vice-versa?answertab=oldest#tab-top">how to convert a byte array to a hexadecimal string?</a>‚Äù over at Stack Overflow. The community quickly provided several very different answers. Some involved loops, some LINQ, others bent the available Framework-methods to their needs. Both bit fiddlers and lookup table magicians entered the field and presented their more and more unsafe solutions. <a href="https://github.com/patridge">Adam Patridge</a> stepped in quite a bit later and benchmarked all submitted solutions.</p><p>Today - more than 10 years later - we are going to beat all previous records once again, utilizing the new secret sauce introduced in .NET Core 3.0: hardware intrinsics. But let‚Äôs have a look at the current champion of hex encoding fist.</p><h2>The Current Champion</h2><div class="gatsby-highlight" data-language="csharp"><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">static</span><span class="token keyword">uint</span><span class="token punctuation">[</span><span class="token punctuation">]</span> _Lookup32 <span class="token operator">=</span> Enumerable<span class="token punctuation">.</span><span class="token function">Range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>i <span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token keyword">string</span> s <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token string">"X2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>BitConverter<span class="token punctuation">.</span>IsLittleEndian<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint</span><span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint</span><span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint</span><span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">uint</span><span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span><span class="token keyword">readonly</span><span class="token keyword">uint</span><span class="token operator">*</span> _lookup32UnsafeP <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">uint</span><span class="token operator">*</span><span class="token punctuation">)</span>GCHandle<span class="token punctuation">.</span><span class="token function">Alloc</span><span class="token punctuation">(</span>_Lookup32<span class="token punctuation">,</span> GCHandleType<span class="token punctuation">.</span>Pinned<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AddrOfPinnedObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span><span class="token keyword">string</span><span class="token function">ByteArrayToHexViaLookup32UnsafeDirect</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> lookupP <span class="token operator">=</span> _lookup32UnsafeP<span class="token punctuation">;</span><span class="token keyword">var</span> result <span class="token operator">=</span><span class="token keyword">new</span><span class="token keyword">string</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span> bytes<span class="token punctuation">.</span>Length <span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">fixed</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token operator">*</span> bytesP <span class="token operator">=</span> bytes<span class="token punctuation">)</span><span class="token keyword">fixed</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> resultP <span class="token operator">=</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">uint</span><span class="token operator">*</span> resultP2 <span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">uint</span><span class="token operator">*</span><span class="token punctuation">)</span>resultP<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bytes<span class="token punctuation">.</span>Length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            resultP2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> lookupP<span class="token punctuation">[</span>bytesP<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></div><p>The process of encoding a <code class="language-text">byte</code> into its hex representation converts one byte into two characters. Each character is a 16-bit value (<code class="language-text">char</code>). The two characters representing a given byte, therefore, take up exactly 32-bits, the size of a <code class="language-text">uint</code>. The first lines above create a lookup table for every one of the 256 possible <code class="language-text">byte</code> values. The resulting table is exactly 1 KB in size and pinned in memory by the second group of lines to get a <code class="language-text">uint*</code> (I‚Äôm sure you‚Äôve noticed by now, that the entire snippet is <code class="language-text">unsafe</code> C#). We‚Äôll talk more about this trick later, as there are downsides to consider at least until the <a href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/PinnedHeap.md">Pinned Heap</a> GC-feature is ready.</p><p>The main method creates a right-sized string, takes its address using the <code class="language-text">fixed</code> keyword and turns every input byte in its respective two-character hex representation using the pinned lookup table described above.</p><p>If you crave performance, this method does a couple of things very well:</p><ul><li>The one-time calculation of a lookup table is a typical memory vs. speed trade-off (investing 1 KB of memory for a significant speed-up can be a good thing).</li><li>Permanently pinning the lookup table <em>potentially</em> reduces the method overhead, as it does not have to fix the lookup table on each invocation.</li><li>Turing <code class="language-text">_lookup32UnsafeP</code> into a local variable <code class="language-text">lookupP</code> means the lookup of the static variable happens only once (instead of in the loop).</li><li>Creating a right sized-string and working with it‚Äôs pinned address avoids unnecessary copies. There even is a <a href="https://github.com/dotnet/coreclr/blob/5937becd8823312d6b2d490a4d977ec663def72d/src/System.Private.CoreLib/shared/System/String.cs#L280">fast-path</a> for the chosen constructor if the first parameter is the zero/null <code class="language-text">char</code>.</li></ul><p>There are, however, downsides or potential improvements to almost all of the above optimizations:</p><ul><li>The lookup table is too large to reside in the cache closest to the processing units completely. This results in data-dependent execution times due to cache-misses.</li><li>Keeping the lookup table pinned permanently causes trouble for the GC, as it will never be able to relocate the array and must work its way around it. An alternative would be to unpin the array in a <code class="language-text">Dispose</code> method, or just pinning the array inside of the actual method.</li><li>The <code class="language-text">string.Create</code> method introduced in .NET Core 2.1 is even cleaner (more obvious) than the cleverly used string constructor.</li></ul><h2>Benchmarking is Hard - Use BenchmarkDotNet</h2><p>The original benchmarks are still on <a href="https://github.com/patridge/PerformanceStubs">GitHub</a>. It is worth noting, however that they were written in a time before <a href="https://benchmarkdotnet.org/">BenchmarkDotNet</a>. The .NET community today generally agrees to leave the setup and execution of benchmarks to BenchmarkDotnet instead of rolling your own. Luckily, the existing benchmark is easily portable to a BenchmarkDotNet project (as showcased over <a href="https://github.com/tkp1n/HexMate/blob/blog/HexMate.Benchmarks/BlogBench.cs">here</a>).</p><p>The old benchmark used two text files as input for the various tested encoding algorithms. This is desirable to ensure consistent results. Unfortunately, the text files translate only to a subset of possible bytes as input to the algorithms (printable ASCII) which may favor branchy or lookup-based approaches. This is also easily improved by using <code class="language-text">new Random(42).NextBytes(data)</code> as input. The constant seed ensures consistency, while <code class="language-text">Random</code> pseudo-randomly produces all possible byte values.</p><p>Another potential issue with using files as input is their fixed size (in this case ,3.38 KB and 1.16 MB). BenchmarkDotnet allows for straightforward configuration of various input sizes <a href="https://github.com/tkp1n/HexMate/blob/b7f7e89252d2cc8a03f65e32566fcb4ce4963ee5/HexMate.Benchmarks/BlogBench.cs#L16">like so</a>. For a general-purpose algorithm such as hex encoding, I typically prefer to test on three sizes of input data:</p><ul><li>The first one small enough to almost exclusively test the overhead of the methods under test</li><li>The second one small enough to ensure, input and output data can reside in a cache close to the processing units. This way, we make sure not to test memory bandwidth but the actual algorithm.</li><li>The third one large enough to make sure any unexpected algorithmic complexity would show up in the results.</li></ul><p>Below diagram shows the results of testing the current champion vs. my implementation <a href="https://github.com/tkp1n/HexMate">HexMate</a> for a lot of different input sizes. Please note that the scales are not linear (logarithmic), which lets the differences appear smaller than they are. The chart does, however, showcase the three categories of input data sizes quite well. Below 64 bytes we are only comparing the overhead of the methods. Unsurprisingly comparing a raw conversion method vs. a library-like implementation (HexMate) with a bunch of input validation favors the raw method. In the second category, we see HexMate taking off üöÄ and completing the job <strong>twice as fast</strong> (-65.31% @ 32 KiB) as its competitor. All measurements above the size of the L2 cache of my MacBook seem to be bottlenecked by memory speed. This means that the algorithm for converting (in my case) more than 512 KiB of data does not matter, as long as it is faster than the reads/stores from/to memory.</p><p><span class="gatsby-resp-image-wrapper"><a class="gatsby-resp-image-link" href="/static/147f38db5f9708f21eedceff4dd1c383/97a96/HexMate.png" target="_blank" rel="noopener"><span class="gatsby-resp-image-background-image"></span><img class="gatsby-resp-image-image" alt="HexMate vs ByteArrayToHexViaLookup32UnsafeDirect" title="HexMate vs ByteArrayToHexViaLookup32UnsafeDirect" src="/static/147f38db5f9708f21eedceff4dd1c383/5a190/HexMate.png" srcset="/static/147f38db5f9708f21eedceff4dd1c383/772e8/HexMate.png 200w,
/static/147f38db5f9708f21eedceff4dd1c383/e17e5/HexMate.png 400w,
/static/147f38db5f9708f21eedceff4dd1c383/5a190/HexMate.png 800w,
/static/147f38db5f9708f21eedceff4dd1c383/c1b63/HexMate.png 1200w,
/static/147f38db5f9708f21eedceff4dd1c383/29007/HexMate.png 1600w,
/static/147f38db5f9708f21eedceff4dd1c383/97a96/HexMate.png 2400w" sizes="(max-width: 800px) 100vw, 800px" loading="lazy"></a></span></p><h2>The Hardware Intrinsics Magic</h2><p>Now that we studied the current Champion and discussed the benchmarking methodology it‚Äôs time to look at HexMate. I started writing HexMate as a playground to explore the new hardware intrinsics API and as an implementation of my <a href="https://github.com/dotnet/corefx/issues/10013#issuecomment-511112311">API proposal</a> for .NET Core. It is apparent that hex encoding/decoding algorithms will likely always be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"></span><span class="mord mathdefault">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>, so how do we improve upon the current Champion encoding a byte to two characters using two lookups? We work on multiple bytes at once using SIMD (single instruction, multiple data) instructions! The SSE instructions allow us to work on 16 bytes at a time, while AVX even works on 32-byte vectors. The following snippet is the main part of the inner loop of HexMates UTF-8 hex encoding algorithm using SSSE3 (full source <a href="https://github.com/tkp1n/HexMate/blob/master/HexMate/Formatter/Utf8/Utf8HexFormatter.Ssse3.cs">here</a>).</p><p>The first three lines isolate the high (<code class="language-text">hiHalf</code>) and the low (<code class="language-text">loHalf</code>) nibbles of each byte in the given <code class="language-text">input</code> vector. Using <code class="language-text">UnpackHigh</code> and <code class="language-text">UnpackLow</code> (<code class="language-text">punpckhbw</code> and <code class="language-text">punpcklbw</code>), the isolated nibbles are arranged (interleaved) in the proper order. The <code class="language-text">Shuffle</code> instruction (<code class="language-text">pshufb</code>) performs a 16-byte lookup to translate the input nibbles into the desired UTF-8 codepoints (0x0A -&gt; 0x41, 0x06 -&gt; 0x36).</p><div class="gatsby-highlight" data-language="csharp"><pre class="language-csharp"><code class="language-csharp"><span class="token keyword">var</span> hiShift <span class="token operator">=</span><span class="token function">ShiftRightLogical</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span><span class="token function">AsInt16</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AsByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> hiHalf <span class="token operator">=</span><span class="token function">And</span><span class="token punctuation">(</span>hiShift<span class="token punctuation">,</span> x0F<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> loHalf <span class="token operator">=</span><span class="token function">And</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> x0F<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> hi <span class="token operator">=</span><span class="token function">UnpackHigh</span><span class="token punctuation">(</span>hiHalf<span class="token punctuation">,</span> loHalf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> lo <span class="token operator">=</span><span class="token function">UnpackLow</span><span class="token punctuation">(</span>hiHalf<span class="token punctuation">,</span> loHalf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> resLeft <span class="token operator">=</span><span class="token function">Shuffle</span><span class="token punctuation">(</span>hexLookupTable<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> resRight <span class="token operator">=</span><span class="token function">Shuffle</span><span class="token punctuation">(</span>hexLookupTable<span class="token punctuation">,</span> lo<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><p>HexMate supports UTF-8 and UTF-16 encoding and validating decoding (both upper- and lowercase) using the following instruction sets to enable maximum performance on all modern (non-ARM, non-exotic) CPUs:</p><table><thead><tr><th></th><th align="center"><strong>SSE2</strong></th><th align="center"><strong>SSE41</strong></th><th align="center"><strong>SSSE3</strong></th><th align="center"><strong>AVX2</strong></th></tr></thead><tbody><tr><td><strong>Encoding</strong></td><td align="center">‚úÖ</td><td align="center">‚ùå</td><td align="center">‚úÖ</td><td align="center">‚úÖ</td></tr><tr><td><strong>Decoding</strong></td><td align="center">‚úÖ</td><td align="center">‚úÖ</td><td align="center">‚úÖ</td><td align="center">‚úÖ</td></tr></tbody></table><p>Make sure to check out its source code on <a href="https://github.com/tkp1n/HexMate">GitHub</a> as well as the available <a href="https://www.nuget.org/packages/HexMate/">NuGet Package</a>. But most importantly; leave a vote or comment on <a href="https://github.com/dotnet/corefx/issues/10013">corefx Issue 10013</a> to finally make hex encoding/decoding a part of the .NET framework.</p></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>