<!DOCTYPE html>
<html lang="en">
<head>
    <title>
Local variable getting modified by function call &#xB7; Issue #13362 &#xB7; dotnet/runtime &#xB7; GitHub -
linksfor.dev(s)
    </title>
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta charset="utf-8">
    <meta name="Description" content="A curated source of links that devs might find interesting. Updated around the clock." />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="grid">
        
<div class="readable">
    <div id="readOverlay" class="style-ebook"><div id="readInner" class="margin-medium size-medium"><h1>Local variable getting modified by function call · Issue #13362 · dotnet/runtime · GitHub</h1><div><div id="" class="d-block comment-body markdown-body  js-comment-body"><p>Local variable gets modified by an unrelated function call, with .NET Core 3.0. Admittedly the type in question is a bit weird, lifted from a CoreCLR test case.</p><p>In the code snippet below, "instance" mutates from being an object of type <code>GenInt</code> to a <code>List&lt;FieldInfo&gt;</code> magically. Calling GetAllInstanceFields shouldn't modified the local of the caller.</p><p>Observed output:<br>ClrIssueRepro.GenInt<br>System.Object</p><p>Expected output:<br>ClrIssueRepro.GenInt<br>ClrIssueRepro.GenInt</p><p>Here is the code snippet:</p><pre><code>using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
#pragma warning disable 649, 169
namespace ClrIssueRepro
{
    [StructLayout(LayoutKind.Sequential)]
    public class GenBase&lt;T&gt;
    {
        public T Fld10;

        public int _int0 = 0;
        public double _double0 = 0;
        public string _string0 = "string0";
        public Guid _Guid0 = new Guid();

        public T Fld11;

        public int _int1 = int.MaxValue;
        public double _double1 = double.MaxValue;
        public string _string1 = "string1";
        public Guid _Guid1 = new Guid(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);

        public T Fld12;
    }

    [StructLayout(LayoutKind.Explicit)]
    public class GenInt : GenBase&lt;int&gt;
    {
        [FieldOffset(0)] public int sFld10;

        [FieldOffset(16)] public int _sint0 = 0;
        [FieldOffset(24)] public double _sdouble0 = 0;
        [FieldOffset(32)] public string _sstring0 = "string0";
        [FieldOffset(40)] public Guid _sGuid0 = new Guid();

        [FieldOffset(56)] public int sFld11;

        [FieldOffset(72)] public int _sint1 = int.MaxValue;
        [FieldOffset(80)] public double _sdouble1 = double.MaxValue;
        [FieldOffset(88)] public string _sstring1 = "string1";
        [FieldOffset(96)] public Guid _sGuid1 = new Guid(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);

        [FieldOffset(112)] public int sFld12;
    }

    class Program
    {
        private static FieldInfo[] GetAllInstanceFields(Type type)
        {
            List&lt;FieldInfo&gt; result = new List&lt;FieldInfo&gt;();
            for (Type t = type; t != null; t = t.BaseType)
            {
                // Stop iterating once we get to System.ValueType. There should be no fields in it
                // or System.Object, it's base class. This is ok to do for desktop &amp; ProjectN.
                if (t == typeof(ValueType))
                {
                    break;
                }

                FieldInfo[] fieldsOnType = t.GetFields(
                    BindingFlags.Public |
                    BindingFlags.NonPublic |
                    BindingFlags.Instance |
                    BindingFlags.DeclaredOnly);
                result.AddRange(fieldsOnType);
            }

            return result.ToArray();
        }

        private static object CreateInstance(Type t)
        {
            return t.IsValueType ? Activator.CreateInstance(t) : FormatterServices.GetUninitializedObject(t);
        }

        static void Main(string[] args)
        {
            Type type = typeof(GenInt);

            object instance = CreateInstance(type);
            // instance is of type GenInt.

            Console.WriteLine(instance.GetType());

            System.Reflection.FieldInfo[] fields = GetAllInstanceFields(type);
            // is it still?

            Console.WriteLine(instance.GetType());
            Debugger.Break();
        }
    }
}
</code></pre></div></div></div></div>
</div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
    </footer>
    
    <script>
        (function () {
            var COLLECT_URL = "https://dna.buildstarted.com/t";
            var SITE_ID = "linksfor.devs";
            var GLOBAL_VAR_NAME = "__DNA__";

            window[GLOBAL_VAR_NAME] = {};

            window[GLOBAL_VAR_NAME].sendPageView = function () {
                var path = location.pathname;
                var referrer = document.referrer;

                var url = COLLECT_URL + "?siteid=" + SITE_ID + "&p=" + encodeURIComponent(path) + "&r=" + encodeURIComponent(referrer);

                try { fetch(url, { method: "GET" }); } catch (e) { }
            };

            window[GLOBAL_VAR_NAME].sendPageView();
        })();
    </script>
</body>
</html>