<!DOCTYPE html>
<html lang="en">
<head>
    <title>
DRY vs DAMP in Unit Tests - linksfor.dev(s)    </title>
    <meta charset="utf-8">
    <link rel="alternate" type="application/rss+xml" title="Linksfor.dev(s) feed" href="https://linksfor.dev/feed.rss" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="google" value="notranslate">
    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <meta property="og:title" content="DRY vs DAMP in Unit Tests - linksfor.dev(s)"/>
    <meta property="article:author" content="Vladimir Khorikov"/>
    <meta property="og:description" content="&#xA;In this post, we&#x2019;ll make a deep dive into the DRY and DAMP principles and will talk about the false dichotomy around them.&#xA;"/>
    <meta property="og:type" content="website"/>
    <meta property="og:url" content="https://enterprisecraftsmanship.com/posts/dry-damp-unit-tests/"/>

<meta property="og:site_name" content="linksfor.dev(s)" />
</head>
<body>
	<div class="devring" style="background: #222">
		<div class="grid">
			<div style="display: grid; grid-template-columns: .5fr 1fr 1fr 1fr; text-align: center;">
				<span class="devring-title"><a href="https://devring.club/">devring.club</a></span>
				<a href="https://devring.club/sites/1/prev" class="devring-previous">Previous</a>
				<a href="https://devring.club/random" class="devring-random">Random</a>
				<a href="https://devring.club/sites/1/next" class="devring-next">Next</a>
			</div>
		</div>
	</div>
    <div class="grid">
        <h1>
<a href="/" style="color:inherit">linksfor.dev(s)</a>
        </h1>
        <title>linksfor.dev(s) - DRY vs DAMP in Unit Tests</title>
<div class="readable">
        <h1>DRY vs DAMP in Unit Tests</h1>
            <div>by Vladimir Khorikov</div>
            <div>Reading time: 19-24 minutes</div>
        <div>Posted here: 10 Jun 2020</div>
        <p><a href="https://enterprisecraftsmanship.com/posts/dry-damp-unit-tests/">https://enterprisecraftsmanship.com/posts/dry-damp-unit-tests/</a></p>
        <hr/>
<div id="readability-page-1" class="page"><div>
	    <div>
          

<main>
	<div>
		


		<p><time datetime="2020-06-08 00:00:00 +0000 UTC">June 8, 2020</time>
</p>


		<p>In this post, we’ll make a deep dive into the DRY and DAMP principles and will talk about the false dichotomy around them.</p>
<div>
<h2 id="_the_dry_and_damp_principles">The DRY and DAMP principles</h2>
<div>
<p>The <a href="https://enterprisecraftsmanship.com/posts/dry-revisited/">DRY principle</a> stands for "Don’t Repeat Yourself" and requires that any piece of domain knowledge has a single representation in your code base. In other words, in requires that you don’t duplicate the domain knowledge.</p>
<p>The DAMP principle stands for "Descriptive and Meaningful Phrases" and promotes the readability of the code.</p>
</div>
</div>
<div>
<h2 id="_dry_vs_damp_the_dichotomy">DRY vs. DAMP: the dichotomy</h2>
<div>
<p>You can often hear that people put these two principles in opposition to each other. DRY and DAMP are usually represented as two ends of the spectrum that covers all of your code:</p>
<div>
<p><img src="https://enterprisecraftsmanship.com/images/2020/2020-05-29-dry-vs-damp.png" alt="2020 05 29 dry vs damp">
</p>
<p>DRY and DAMP as two ends of the spectrum</p>
</div>
<p>You can choose to make your code more descriptive at the expense of the DRY principle (and thus lean towards the DAMP end of the spectrum) or you can choose to remove duplication, but at the cost of the code becoming less expressive. In other words, you can’t adhere to both principles with the same piece of code.</p>
<p>You may also hear the guideline saying that:</p>
<div>
<ul>
<li>
<p>For your <strong>production code</strong>, you should err on the side of the DRY principle</p>
</li>
<li>
<p>For the <strong>test code</strong>, you should favor DAMP over DRY</p>
</li>
</ul>
</div>
<p>I strongly disagree with this opposition.</p>
<p>But let’s first take an example, to understand where this guideline comes from. I’ll then describe why this guideline misses the point.</p>
<p>Let’s say we have a <code>UserController</code> with two methods:</p>
<div>






<div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>UserController</span>
<span>{</span>
    <span>public</span> <span>string</span> <span>Register</span><span>(</span><span>string</span> <span>userName</span><span>,</span> <span>string</span> <span>email</span><span>)</span>
    <span>{</span>
        <span>User</span> <span>userByName</span> <span>=</span> <span>_dbContext</span><span>.</span><span>Users</span>
            <span>.</span><span>SingleOrDefault</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>UserName</span> <span>==</span> <span>userName</span><span>);</span>
        <span>if</span> <span>(</span><span>userByName</span> <span>!=</span> <span>null</span><span>)</span>
            <span>return</span> <span>"User with such username already exists"</span><span>;</span>

        <span>User</span> <span>userByEmail</span> <span>=</span> <span>_dbContext</span><span>.</span><span>Users</span>
            <span>.</span><span>SingleOrDefault</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>Email</span> <span>==</span> <span>email</span><span>);</span>
        <span>if</span> <span>(</span><span>userByEmail</span> <span>!=</span> <span>null</span><span>)</span>
            <span>return</span> <span>"User with such email already exists"</span><span>;</span>

        <span>// Register the user
</span><span></span>
        <span>return</span> <span>"OK"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>string</span> <span>EditPersonalInfo</span><span>(</span><span>string</span> <span>userName</span><span>,</span> <span>string</span> <span>email</span><span>)</span>
    <span>{</span>
        <span>User</span> <span>currentUser</span> <span>=</span> <span>GetCurrentUser</span><span>();</span>

        <span>User</span> <span>userByName</span> <span>=</span> <span>_dbContext</span><span>.</span><span>Users</span>
            <span>.</span><span>SingleOrDefault</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>UserName</span> <span>==</span> <span>userName</span> <span>&amp;&amp;</span> <span>x</span><span>.</span><span>UserName</span> <span>!=</span> <span>currentUser</span><span>.</span><span>UserName</span><span>);</span>
        <span>if</span> <span>(</span><span>userByName</span> <span>!=</span> <span>null</span><span>)</span>
            <span>return</span> <span>"User with such username already exists"</span><span>;</span>

        <span>User</span> <span>userByEmail</span> <span>=</span> <span>_dbContext</span><span>.</span><span>Users</span>
            <span>.</span><span>SingleOrDefault</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>Email</span> <span>==</span> <span>email</span> <span>&amp;&amp;</span> <span>x</span><span>.</span><span>UserName</span> <span>!=</span> <span>currentUser</span><span>.</span><span>Email</span><span>);</span>
        <span>if</span> <span>(</span><span>userByEmail</span> <span>!=</span> <span>null</span><span>)</span>
            <span>return</span> <span>"User with such email already exists"</span><span>;</span>

        <span>// Update personal info
</span><span></span>
        <span>return</span> <span>"OK"</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div>

</div>
<p>Both of the methods check for user name and email uniqueness before making the changes. These checks aren’t exactly the same (<code>EditPersonalInfo</code> takes into account the current user’s name and email), but close enough to be worth extracting into one place.</p>
<p>Here’s how we can do that:</p>
<div>






<div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>UserController</span>
<span>{</span>
    <span>public</span> <span>string</span> <span>Register</span><span>(</span><span>string</span> <span>userName</span><span>,</span> <span>string</span> <span>email</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>UserNameAlreadyExists</span><span>(</span><span>userName</span><span>,</span> <span>null</span><span>))</span>
            <span>return</span> <span>"User with such username already exists"</span><span>;</span>

        <span>if</span> <span>(</span><span>UserEmailAlreadyExists</span><span>(</span><span>email</span><span>,</span> <span>null</span><span>))</span>
            <span>return</span> <span>"User with such email already exists"</span><span>;</span>

        <span>// Register the user
</span><span></span>
        <span>return</span> <span>"OK"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>string</span> <span>EditPersonalInfo</span><span>(</span><span>string</span> <span>userName</span><span>,</span> <span>string</span> <span>email</span><span>)</span>
    <span>{</span>
        <span>User</span> <span>currentUser</span> <span>=</span> <span>GetCurrentUser</span><span>();</span>

        <span>if</span> <span>(</span><span>UserNameAlreadyExists</span><span>(</span><span>userName</span><span>,</span> <span>currentUser</span><span>.</span><span>UserName</span><span>))</span>
            <span>return</span> <span>"User with such username already exists"</span><span>;</span>

        <span>if</span> <span>(</span><span>UserEmailAlreadyExists</span><span>(</span><span>email</span><span>,</span> <span>currentUser</span><span>.</span><span>Email</span><span>))</span>
            <span>return</span> <span>"User with such email already exists"</span><span>;</span>

        <span>// Update personal info
</span><span></span>
        <span>return</span> <span>"OK"</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>bool</span> <span>UserNameAlreadyExists</span><span>(</span><span>string</span> <span>name</span><span>,</span> <span>string</span> <span>currentUserName</span><span>)</span>
    <span>{</span>
        <span>IQueryable</span><span>&lt;</span><span>User</span><span>&gt;</span> <span>query</span> <span>=</span> <span>_dbContext</span><span>.</span><span>Users</span>
            <span>.</span><span>Where</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>UserName</span> <span>==</span> <span>name</span><span>);</span>

        <span>if</span> <span>(</span><span>currentUserName</span> <span>!=</span> <span>null</span><span>)</span>
        <span>{</span>
            <span>query</span> <span>=</span> <span>query</span><span>.</span><span>Where</span><span>(</span><span>x</span> <span>=&gt;</span> <span>x</span><span>.</span><span>UserName</span> <span>!=</span> <span>currentUserName</span><span>);</span>
        <span>}</span>

        <span>User</span> <span>user</span> <span>=</span> <span>query</span><span>.</span><span>SingleOrDefault</span><span>();</span>

        <span>return</span> <span>user</span> <span>!=</span> <span>null</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>bool</span> <span>UserEmailAlreadyExists</span><span>(</span><span>string</span> <span>email</span><span>,</span> <span>string</span> <span>currentUserEmail</span><span>)</span>
    <span>{</span>
        <span>/* Same for email */</span>
    <span>}</span>
<span>}</span>
</code></pre></div>

</div>
<p>This version is much cleaner. It also adheres to the DRY principle — the common bits get reused across the two methods. (Notice that I moved the checks for uniqueness to private methods, but they could also be repository methods, depending on your project’s specifics.)</p>
<p>So, that’s the example of the first part of the guideline — favoring DRY in the production code. The benefits are pretty self-evident: the code in the two controller methods gets simpler and, more importantly, the knowledge of <strong>how</strong> to do the uniqueness checks now resides in one place.</p>
<p>Let’s now look at the second part of the guideline — preferring DAMP in the test code. Let’s say we’ve got a <code>CalculatorController</code> and two tests that check its functionality:</p>
<div>






<div><pre><code data-lang="csharp"><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_by_zero</span><span>()</span>
<span>{</span>
    <span>// Arrange
</span><span></span>    <span>int</span> <span>dividend</span> <span>=</span> <span>10</span><span>;</span>
    <span>int</span> <span>divisor</span> <span>=</span> <span>0</span><span>;</span>
    <span>var</span> <span>calculator</span> <span>=</span> <span>new</span> <span>CalculatorController</span><span>();</span>

    <span>// Act
</span><span></span>    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>calculator</span><span>.</span><span>Divide</span><span>(</span><span>dividend</span><span>,</span> <span>divisor</span><span>);</span>

    <span>// Assert
</span><span></span>    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeTrue</span><span>();</span>
    <span>response</span><span>.</span><span>ErrorCode</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>"division.by.zero"</span><span>);</span>
<span>}</span>
<span>
</span><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_of_two_numbers</span><span>()</span>
<span>{</span>
    <span>// Arrange
</span><span></span>    <span>int</span> <span>dividend</span> <span>=</span> <span>10</span><span>;</span>
    <span>int</span> <span>divisor</span> <span>=</span> <span>2</span><span>;</span>
    <span>var</span> <span>calculator</span> <span>=</span> <span>new</span> <span>CalculatorController</span><span>();</span>

    <span>// Act
</span><span></span>    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>calculator</span><span>.</span><span>Divide</span><span>(</span><span>dividend</span><span>,</span> <span>divisor</span><span>);</span>

    <span>// Assert
</span><span></span>    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeFalse</span><span>();</span>
    <span>response</span><span>.</span><span>Result</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>5</span><span>);</span>
<span>}</span>
</code></pre></div>

</div>
<p>These tests also have common bits, that could be extracted like this:</p>
<div>






<div><pre><code data-lang="csharp"><span>/* The initialization code that is common for both tests */</span>
<span>int</span> <span>_dividend</span> <span>=</span> <span>10</span><span>;</span>
<span>CalculatorController</span> <span>_calculator</span> <span>=</span> <span>new</span> <span>CalculatorController</span><span>();</span>
<span>
</span><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_by_zero</span><span>()</span>
<span>{</span>
    <span>// Arrange
</span><span></span>    <span>int</span> <span>divisor</span> <span>=</span> <span>0</span><span>;</span>

    <span>// Act
</span><span></span>    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>_calculator</span><span>.</span><span>Divide</span><span>(</span><span>_dividend</span><span>,</span> <span>divisor</span><span>);</span>

    <span>// Assert
</span><span></span>    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeTrue</span><span>();</span>
    <span>response</span><span>.</span><span>ErrorCode</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>"division.by.zero"</span><span>);</span>
<span>}</span>
<span>
</span><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_of_two_values</span><span>()</span>
<span>{</span>
    <span>// Arrange
</span><span></span>    <span>int</span> <span>divisor</span> <span>=</span> <span>2</span><span>;</span>

    <span>// Act
</span><span></span>    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>_calculator</span><span>.</span><span>Divide</span><span>(</span><span>_dividend</span><span>,</span> <span>divisor</span><span>);</span>

    <span>// Assert
</span><span></span>    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeFalse</span><span>();</span>
    <span>response</span><span>.</span><span>Result</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>5</span><span>);</span>
<span>}</span>
</code></pre></div>

</div>
<p>This time the refactoring doesn’t feel as good as in the previous example, does it?</p>
<p>Indeed, such a refactoring is an anti-pattern:</p>
<div>
<ul>
<li>
<p><strong>It introduces high coupling between tests</strong> — If you need to modify the calculator setup in one test, it will affect the other test too.</p>
<p>Such coupling becomes hard to trace really quickly. Changes in one test may ripple through the remaining tests and may introduce unexpected bugs in them.</p>
<p>Try to always follow this rule of thumb: <mark>a modification of one test should not affect other tests</mark>. For that, you need to avoid sharing state between tests. The two private fields (<code>_dividend</code> and <code>_calculator</code>) are an example of such a shared state.</p>
</li>
<li>
<p><strong>It diminishes test readability</strong> — After extracting the two lines, you no longer see the full picture just by looking at individual tests. You have to examine the whole class in order to understand what the test does.</p>
<p>Even if there’s not much of arrangement logic, for example, only instantiation of the calculator, like in the example above, you are still better off moving that logic directly to the test method. Otherwise, you’ll wonder if it’s really just instantiation or maybe there’s something else is being configured here as well. A self-contained test doesn’t leave you with such uncertainties.</p>
</li>
</ul>
</div>
<p>That’s where the guideline of preferring DAMP over DRY in tests comes from. The initial version of the two tests is better — it’s more expressive, even if at the expense of code repetition.</p>
</div>
</div>
<div>
<h2 id="_the_dry_vs_damp_dichotomy_is_false">The DRY vs. DAMP dichotomy is false</h2>
<div>
<p>So, again, the common belief is that you can’t adhere to both DRY and DAMP with the same piece of code, and the choice should be the following:</p>
<div>
<ul>
<li>
<p>For the production code, prefer DRY over DAMP</p>
</li>
<li>
<p>For the test code, do the opposite choice.</p>
</li>
</ul>
</div>
<p><mark>This dichotomy between DRY and DAMP is false</mark>. Both principles are equally important in both the production and test code. In fact, you don’t have to make a trade-off between these two principles at all.</p>
<p>To see why, we need to step back and make a closer look at the DRY principle. As I mentioned earlier, it stands for "Don’t Repeat Yourself" and requires that any piece of domain knowledge has a single representation in your code base. The words <span>domain knowledge</span> are key here. <mark>DRY is not about duplicating code. It is specifically about duplicating domain knowledge.</mark></p>
<p>The following method is a nice way to visualize this distinction:</p>
<div>






<div><pre><code data-lang="csharp"><span>public</span> <span>static</span> <span>string</span> <span>GetStatus</span><span>(</span><span>bool</span> <span>isLocked</span><span>)</span>
<span>{</span>
    <span>return</span> <span>(</span><span>isLocked</span> <span>?</span> <span>"L"</span> <span>:</span> <span>"Unl"</span><span>)</span> <span>+</span> <span>"ocked"</span><span>;</span>
<span>}</span>
</code></pre></div>

</div>
<p>This code is what you get when you try to apply the DRY principle not to the domain knowledge but to the code itself.</p>
<p>Of course, this method is ridiculous — it tries to squeeze together as many characters as possible. It should have listed these two words separately, like this:</p>
<div>






<div><pre><code data-lang="csharp"><span>public</span> <span>static</span> <span>string</span> <span>GetStatus</span><span>(</span><span>bool</span> <span>isLocked</span><span>)</span>
<span>{</span>
    <span>return</span> <span>isLocked</span> <span>?</span> <span>"Locked"</span> <span>:</span> <span>"Unlocked"</span><span>;</span>
<span>}</span>
</code></pre></div>

</div>
<p>The fact that these two words have some common piece in them doesn’t mean they share domain knowledge. The common piece is just a coincidence, there’s nothing that inherently unites them.</p>
<p>The words represent two separate pieces of domain knowledge. Particularly, the knowledge of how the <code>Locked</code> and <code>Unlocked</code> statuses are displayed to the user. You should be able to change one of these words without affecting the other. For that, you need to decouple them by splitting into two separate strings.</p>
<p>This is essentially the same misapplication of the DRY principle as in previous example (I’m copying it here for convenience):</p>
<div>






<div><pre><code data-lang="csharp"><span>/* The initialization code that is common for both tests */</span>
<span>int</span> <span>_dividend</span> <span>=</span> <span>10</span><span>;</span>
<span>CalculatorController</span> <span>_calculator</span> <span>=</span> <span>new</span> <span>CalculatorController</span><span>();</span>
<span>
</span><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_by_zero</span><span>()</span>
<span>{</span>
    <span>// Arrange
</span><span></span>    <span>int</span> <span>divisor</span> <span>=</span> <span>0</span><span>;</span>

    <span>// Act
</span><span></span>    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>_calculator</span><span>.</span><span>Divide</span><span>(</span><span>_dividend</span><span>,</span> <span>divisor</span><span>);</span>

    <span>// Assert
</span><span></span>    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeTrue</span><span>();</span>
    <span>response</span><span>.</span><span>ErrorCode</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>"division.by.zero"</span><span>);</span>
<span>}</span>
<span>
</span><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_of_two_values</span><span>()</span>
<span>{</span>
    <span>// Arrange
</span><span></span>    <span>int</span> <span>divisor</span> <span>=</span> <span>2</span><span>;</span>

    <span>// Act
</span><span></span>    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>_calculator</span><span>.</span><span>Divide</span><span>(</span><span>_dividend</span><span>,</span> <span>divisor</span><span>);</span>

    <span>// Assert
</span><span></span>    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeFalse</span><span>();</span>
    <span>response</span><span>.</span><span>Result</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>5</span><span>);</span>
<span>}</span>
</code></pre></div>

</div>
<p>Here, we are also applying the DRY principle not to the domain knowledge, but to the code itself, which is incorrect. The two shared lines at the top don’t represent any domain knowledge, they are just happen to be the same for both tests. Therefore, they should <span>not</span> be reused.</p>
</div>
</div>
<div>
<h2 id="_dry_and_damp_as_how_to_s_and_what_to_s">DRY and DAMP as How-to’s and What-to’s</h2>
<div>
<p>I hope you can see now why the dichotomy between DRY and DAMP is false. You should avoid the code reuse shown in the previous example, but not because DRY somehow doesn’t apply to tests. It’s because such a reuse is an misapplication of DRY, and it is a misapplication regardless of whether you do that in tests or in the production code.</p>
<p>Alright, so the DRY principle should only be applied to domain knowledge. But doesn’t the concept of domain knowledge itself only apply to the production code?</p>
<p>That’s a great question. Tests contain domain knowledge too, but this is the knowledge of a different kind. It’s not about the application itself; it’s the knowledge about how to <strong>test</strong> that application. There is an overlap between the application domain knowledge and the domain knowledge of the tests, but still, these two sets are not the same:</p>
<div>
<p><img src="https://enterprisecraftsmanship.com/images/2020/2020-06-05-domain-knowledge.png" alt="2020 06 05 domain knowledge">
</p>
<p>Both production and test code contain domain knowledge</p>
</div>
<p>The tests' knowledge lies in the following two things:</p>
<div>
<ul>
<li>
<p>The scenarios that need to be performed to verify the application’s correctness</p>
</li>
<li>
<p>The steps that should be in those scenarios</p>
</li>
</ul>
</div>
<p>The scenarios are represented by tests themselves. For example, the division by zero scenario, or the division of two numbers:</p>
<div>






<div><pre><code data-lang="csharp"><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_by_zero</span><span>()</span>
<span>
</span><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_of_two_numbers</span><span>()</span>
</code></pre></div>

</div>
<p>The steps are the content of the arrange, act, and assert sections in those tests. For example, set the divisor and the dividend, check the result, and so on:</p>
<div>






<div><pre><code data-lang="csharp"><span>int</span> <span>dividend</span> <span>=</span> <span>10</span><span>;</span>
<span>int</span> <span>divisor</span> <span>=</span> <span>2</span><span>;</span>

<span>response</span><span>.</span><span>Result</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>5</span><span>);</span>
</code></pre></div>

</div>
<p>And so, when you extract common steps from tests, you don’t reuse this knowledge, but <strong>remove</strong> it from the tests.</p>
<p>You should think of this in terms of <strong><em>what-to</em></strong>'s versus <strong><em>how-to</em></strong>'s:</p>
<div>
<ul>
<li>
<p>The <strong><em>what-to</em></strong>'s answer the question of what we are testing. They describe a test scenario using specific steps relevant for that scenario.</p>
</li>
<li>
<p>The <strong><em>how-to</em></strong>'s contain the knowledge of how to implement those specific steps — how these are steps executed.</p>
</li>
</ul>
</div>
<p><mark>The DRY principle should be applied to the <strong><em>how-to</em></strong>'s, whereas the DAMP principle should be applied to the <strong><em>what-to</em></strong>'s.</mark></p>
<p>In other words, you should describe the scenario steps as expressively as possible, but you can (and should) extract any implementation details regarding those steps and reuse them between tests.</p>
<p>Let’s take an example. Let’s say that our calculator API has a memorization functionality and we need to test it. Here’s how this functionality looks:</p>
<div>






<div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>CalculatorController</span>
<span>{</span>
    <span>private</span> <span>int</span> <span>_memorizedDividend</span><span>;</span>

    <span>public</span> <span>void</span> <span>Memorize</span><span>(</span><span>int</span> <span>dividend</span><span>)</span>
    <span>{</span>
        <span>_memorizedDividend</span> <span>=</span> <span>dividend</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>Divide</span><span>(</span><span>int</span> <span>divisor</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>divisor</span> <span>==</span> <span>0</span><span>)</span>
           <span>return</span> <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;.</span><span>Error</span><span>(</span><span>Errors</span><span>.</span><span>DivisionByZero</span><span>);</span>

        <span>int</span> <span>result</span> <span>=</span> <span>_memorizedDividend</span> <span>/</span> <span>divisor</span><span>;</span>

        <span>return</span> <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;.</span><span>Ok</span><span>(</span><span>result</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div>

</div>
<p>The difference with the initial version is that we can call <code>Memorize()</code> to save the dividend, and then use a <code>Divide()</code> overload that accepts only the divisor.</p>
<p>Here are the tests that verify this functionality:</p>
<div>






<div><pre><code data-lang="csharp"><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_by_zero_with_memorization</span><span>()</span>
<span>{</span>
    <span>int</span> <span>dividend</span> <span>=</span> <span>10</span><span>;</span>
    <span>int</span> <span>divisor</span> <span>=</span> <span>0</span><span>;</span>
    <span>var</span> <span>calculator</span> <span>=</span> <span>new</span> <span>CalculatorController</span><span>();</span>
    <span>calculator</span><span>.</span><span>Memorize</span><span>(</span><span>dividend</span><span>);</span> <span>// the additional method call
</span><span></span>
    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>calculator</span><span>.</span><span>Divide</span><span>(</span><span>divisor</span><span>);</span>

    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeTrue</span><span>();</span>
    <span>response</span><span>.</span><span>ErrorCode</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>"division.by.zero"</span><span>);</span>
<span>}</span>
<span>
</span><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_of_two_values_with_memorization</span><span>()</span>
<span>{</span>
    <span>int</span> <span>dividend</span> <span>=</span> <span>10</span><span>;</span>
    <span>int</span> <span>divisor</span> <span>=</span> <span>2</span><span>;</span>
    <span>var</span> <span>calculator</span> <span>=</span> <span>new</span> <span>CalculatorController</span><span>();</span>
    <span>calculator</span><span>.</span><span>Memorize</span><span>(</span><span>dividend</span><span>);</span> <span>// the additional method call
</span><span></span>
    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>calculator</span><span>.</span><span>Divide</span><span>(</span><span>divisor</span><span>);</span>

    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeFalse</span><span>();</span>
    <span>response</span><span>.</span><span>Result</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>5</span><span>);</span>
<span>}</span>
</code></pre></div>

</div>
<p>Notice the additional method call in both of these tests that brings the calculator into the required state. This method call is part of the overarching step where we setup the calculator.</p>
<p>We can extract the details of how this step is implemented into a helper method:</p>
<div>






<div><pre><code data-lang="csharp"><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_by_zero_with_memorization</span><span>()</span>
<span>{</span>
    <span>int</span> <span>divisor</span> <span>=</span> <span>0</span><span>;</span>
    <span>CalculatorController</span> <span>calculator</span> <span>=</span> <span>CreateCalculatorWithMemorizedDividend</span><span>(</span><span>10</span><span>);</span>

    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>calculator</span><span>.</span><span>Divide</span><span>(</span><span>divisor</span><span>);</span>

    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeTrue</span><span>();</span>
    <span>response</span><span>.</span><span>ErrorCode</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>"division.by.zero"</span><span>);</span>
<span>}</span>
<span>
</span><span>[Fact]</span>
<span>public</span> <span>void</span> <span>Division_of_two_values_with_memorization</span><span>()</span>
<span>{</span>
    <span>int</span> <span>divisor</span> <span>=</span> <span>2</span><span>;</span>
    <span>CalculatorController</span> <span>calculator</span> <span>=</span> <span>CreateCalculatorWithMemorizedDividend</span><span>(</span><span>10</span><span>);</span>

    <span>Envelope</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>response</span> <span>=</span> <span>calculator</span><span>.</span><span>Divide</span><span>(</span><span>divisor</span><span>);</span>

    <span>response</span><span>.</span><span>IsError</span><span>.</span><span>Should</span><span>().</span><span>BeFalse</span><span>();</span>
    <span>response</span><span>.</span><span>Result</span><span>.</span><span>Should</span><span>().</span><span>Be</span><span>(</span><span>5</span><span>);</span>
<span>}</span>

<span>private</span> <span>CalculatorController</span> <span>CreateCalculatorWithMemorizedDividend</span><span>(</span><span>int</span> <span>dividend</span><span>)</span>
<span>{</span>
    <span>var</span> <span>calculator</span> <span>=</span> <span>new</span> <span>CalculatorController</span><span>();</span>
    <span>calculator</span><span>.</span><span>Memorize</span><span>(</span><span>dividend</span><span>);</span>
    <span>return</span> <span>calculator</span><span>;</span>
<span>}</span>
</code></pre></div>

</div>
<p>Note that these tests still contain the setup step itself, we haven’t removed it from the tests. What we did is we abstracted away the details of how this step is performed.</p>
<p>This is the distinction between <strong><em>what-to</em></strong>'s and <strong><em>how-to</em></strong>'s. The <strong><em>what-to</em></strong>'s are still in place: we can clearly see the steps the tests take in order to check the calculation functionality. And we are using descriptive and meaningful phrases when describing these steps — the name of this method communicates its behavior very well. In other words, we are following the DAMP principle here.</p>
<p>At the same time, the details of how this step is performed — the <strong><em>how-to</em></strong>'s — are extracted into a single place and reused by tests, thereby following the DRY principle.</p>
<p>This approach combines the best of both worlds:</p>
<div>
<ul>
<li>
<p>We don’t need to duplicate the knowledge of how to create the calculator with the memorized dividend.</p>
</li>
<li>
<p>At the same time, we don’t compromise on the test readability. Thanks to the descriptive name of this method, we don’t need to examine the internals of this step in order to understand the attributes of the created calculator. Because we are keeping all the steps intact, we have the full context of what is going on in the tests.</p>
</li>
</ul>
</div>
<p>Moreover, the private method doesn’t couple tests to each other, at least not to the same degree as we had when we extracted the initialization logic into private fields. That’s because tests can still control how they want the calculator be created. They keep that control by passing the required dividend as an argument.</p>
<p>Notice that this rationale is universal and applies to the production code just as much as the test code. In fact, the example with <code>Register</code> and <code>EditPersonalInfo</code> methods also adheres to both DRY and DAMP (I’m copying that example here):</p>
<div>






<div><pre><code data-lang="csharp"><span>public</span> <span>class</span> <span>UserController</span>
<span>{</span>
    <span>public</span> <span>string</span> <span>Register</span><span>(</span><span>string</span> <span>userName</span><span>,</span> <span>string</span> <span>email</span><span>)</span>
    <span>{</span>
        <span>if</span> <span>(</span><span>UserNameAlreadyExists</span><span>(</span><span>userName</span><span>,</span> <span>null</span><span>))</span>
            <span>return</span> <span>"User with such username already exists"</span><span>;</span>

        <span>if</span> <span>(</span><span>UserEmailAlreadyExists</span><span>(</span><span>email</span><span>,</span> <span>null</span><span>))</span>
            <span>return</span> <span>"User with such email already exists"</span><span>;</span>

        <span>// Register the user
</span><span></span>
        <span>return</span> <span>"OK"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>string</span> <span>EditPersonalInfo</span><span>(</span><span>string</span> <span>userName</span><span>,</span> <span>string</span> <span>email</span><span>)</span>
    <span>{</span>
        <span>User</span> <span>currentUser</span> <span>=</span> <span>GetCurrentUser</span><span>();</span>

        <span>if</span> <span>(</span><span>UserNameAlreadyExists</span><span>(</span><span>userName</span><span>,</span> <span>currentUser</span><span>.</span><span>UserName</span><span>))</span>
            <span>return</span> <span>"User with such username already exists"</span><span>;</span>

        <span>if</span> <span>(</span><span>UserEmailAlreadyExists</span><span>(</span><span>email</span><span>,</span> <span>currentUser</span><span>.</span><span>Email</span><span>))</span>
            <span>return</span> <span>"User with such email already exists"</span><span>;</span>

        <span>// Update personal info
</span><span></span>
        <span>return</span> <span>"OK"</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>bool</span> <span>UserNameAlreadyExists</span><span>(</span><span>string</span> <span>name</span><span>,</span> <span>string</span> <span>currentUserName</span><span>)</span>
    <span>{</span>
        <span>/* Look in the database if the user name exists */</span>
    <span>}</span>

    <span>private</span> <span>bool</span> <span>UserEmailAlreadyExists</span><span>(</span><span>string</span> <span>email</span><span>,</span> <span>string</span> <span>currentUserEmail</span><span>)</span>
    <span>{</span>
        <span>/* Look in the database if the user email exists */</span>
    <span>}</span>
<span>}</span>
</code></pre></div>

</div>
<p>All steps (<strong><em>what-to</em></strong>'s) are intact: we can clearly see that, to register a user, we first need to check if the user name and email already exist in the database. At the same time, the details of how these steps are performed (<strong><em>how-to</em></strong>'s), are abstracted away.</p>
</div>
</div>
<div>
<h2 id="_summary">Summary</h2>
<div>
<div>
<ul>
<li>
<p>DRY stands for "Don’t Repeat Yourself" and requires that any piece of domain knowledge has a single representation in your code base.</p>
<div>
<ul>
<li>
<p>DRY applies specifically to the domain knowledge, not code lines</p>
</li>
</ul>
</div>
</li>
<li>
<p>DAMP stands for "Descriptive and Meaningful Phrases" and promotes the readability of the code.</p>
</li>
<li>
<p>People often put these two principles in opposition to each other saying that:</p>
<div>
<ul>
<li>
<p>You can’t apply both DRY and DAMP to the same piece of code</p>
</li>
<li>
<p>You should favor DRY over DAMP in the production code, and DAMP over DRY in the test code</p>
</li>
</ul>
</div>
</li>
<li>
<p>The dichotomy between DRY and DAMP is false. Both principles are equally important in both the production and test code.</p>
</li>
<li>
<p>Think of DAMP and DRY in terms of <strong><em>what-to</em></strong>'s versus <strong><em>how-to</em></strong>'s:</p>
<div>
<ul>
<li>
<p><strong><em>What-to</em></strong>'s answer the question of what we are doing; they describe the use case (in the case of the production code) or a test scenario (in the case of the test code) using specific steps</p>
</li>
<li>
<p><strong><em>How-to</em></strong>'s contain the knowledge of how to implement those specific steps</p>
</li>
<li>
<p>The DRY principle should be applied to the <strong><em>how-to</em></strong>'s, whereas the DAMP principle should be applied to the <strong><em>what-to</em></strong>'s.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>


		

<h2>Subscribe</h2>

<hr>






<h2>Comments</h2>

<hr>


	





	</div>

	
</main>


		</div>
		
	  </div></div></div>
    </div>
    <footer>
        <div>created by buildstarted &copy; 2020 <a href="/about">about</a></div>
        <div>Share this page on social media: copy and paste this url https://linksfor.dev/</div>
        <div>If you prefer RSS: <a href="https://linksfor.dev/feed.xml">https://linksfor.dev/feed.xml</a></div>
		<div>Customer satisfaction guaranteed to be optional.</div>
    </footer>
    
    <script async defer>
        _dna = window._dna || {};
        _dna.siteId = "linksfor.devs";
        _dna.outlink = true;

        (function () {
            let dna = document.createElement('script');
            dna.type = 'text/javascript';
            dna.async = true;
            dna.src = '//dna.buildstarted.com/t.js';
            let s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(dna, s);
        })();
    </script>
    <noscript><img src="//dna.buildstarted.com/g?siteId=linksfor.devs"/></noscript>
</body>
</html>